[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <complex>\n#include <list>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <sstream>\n#include <numeric>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n// INF\n#define IINF (INT_MAX/2)\n#define INF (1<<29)\n\n// math\n#define SQ(x) ((x)*(x))\n\n// container utility\n#define ALL(x) (x).begin(), (x).end()\n#define MP make_pair\n#define PB push_back\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\n// rep\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define rep(i,n) REP(i,0,n)\n\n// typedef\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\n\ntypedef long long ll;\n\n// conversion\ntemplate<class T> inline string toStr(T a) { ostringstream oss; oss << a; return oss.str(); }\ninline int toInt(string s) { return atoi(s.c_str()); }\n\n// prime\nbool isPrime(int a) { for(int i=2; i*i <=a; i++) if(a%i == 0) return false; return true; }\n\n// dx, dy\nint const dx[] = {-1,0,1,0,-1,1,1,-1};\nint const dy[] = {0,-1,0,1,-1,-1,1,1};\n\n// inRange\ninline bool inRange(int x, int y, int W, int H) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\n// isPalindrome\ninline bool isPalindrome(string s) {\n  return equal(s.begin(), s.end(), s.rbegin());\n}\n\nint check(char grid[2][2]) {\n  if(grid[0][0] == '#'\n     && grid[0][1] == '.'\n     && grid[1][0] == '.'\n     && grid[1][1] == '.') {\n    return +1;\n  }\n  \n  if(grid[0][0] == '.'\n     && grid[0][1] == '#'\n     && grid[1][0] == '#'\n     && grid[1][1] == '#'\n  ) {\n    return +1;\n  }\n  \n  if(grid[0][0] == '#'\n     && grid[0][1] == '#'\n     && grid[1][0] == '#'\n     && grid[1][1] == '.'\n  ) {\n    return -1;\n  }\n\n  if(grid[0][0] == '.'\n     && grid[0][1] == '.'\n     && grid[1][0] == '.'\n     && grid[1][1] == '#'\n  ) {\n    return -1;\n  }\n  \n  return 0;\n}\n\nint main() {\n  \n  int H, W;\n  while(cin >> H >> W) {\n    H+=2, W+=2;\n    vector<vector<char>> G(H, vector<char>(W, '.'));\n    REP(i, 1, H-1) {\n      REP(j, 1, W-1) {\n        cin >> G[i][j];\n      }\n    }\n    \n    vector<pair<double, int>> event;\n    \n    // rep(i, H) {rep(j, W) {cout << G[i][j];}cout << endl;}\n    \n    rep(i, H-1) {\n      rep(j, W-1) {\n        \n        char grid[2][2];\n        grid[0][0] = G[i][j];\n        grid[0][1] = G[i][j+1];\n        grid[1][0] = G[i+1][j];\n        grid[1][1] = G[i+1][j+1];\n        \n        int num = check(grid);\n        if(num!=0) {\n          double ang = atan2((H-2)-i, j);\n          event.PB(MP(atan2((H-2)-i, j), num));\n        }\n        \n      }\n    }\n    \n    sort(ALL(event));\n    \n    int mx = 2;\n    int cnt = 1;\n    for(auto e : event) {\n      cnt += e.second;\n      mx = max(mx, cnt);\n    }\n    cout << mx << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<double,int> P;\n\n\nint H,W;\nstring str;\n\nvector <P> u;\nchar t[600][600];\n\ndouble change(double x,double y){\n  if(x>0.0)return y/x;\n  else return 99999999.99999999;\n}\nchar T(int y,int x){\n  if(y<0||x<0)return '.';\n  if(y>=H||x>=W)return '.';\n  return t[y][x];\n}\nint main(){\n\n  double a,x,y;\n  \n  cin>>H>>W;\n\n  u.clear();\n  for(int i=H-1;i>=0;i--){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      t[i][j]=str[j];\n    }\n  }\n  \n  \n  for(int i=-1;i<H;i++){\n    for(int j=-1;j<W;j++){\n      if(T(i,j)=='#'&&T(i+1,j)=='#'&&T(i,j+1)=='.'&&T(i+1,j+1)=='#'){\n\tx=j+1;y=i+1;\n\ta=acos( (x)/(sqrt(x*x+y*y)) );\n\tu.push_back(P(change(x,y),-1));\n      }\n      if(T(i,j)=='.'&&T(i+1,j)=='#'&&T(i,j+1)=='.'&&T(i+1,j+1)=='.'){\n\tx=j+1;y=i+1;\n\ta=acos( (x)/(sqrt(x*x+y*y)) );\n\tu.push_back(P(change(x,y),1));\n      }\n      if(T(i,j)=='#'&&T(i+1,j)=='.'&&T(i,j+1)=='#'&&T(i+1,j+1)=='#'){\n\tx=j+1;y=i+1;\n\ta=acos( (x)/(sqrt(x*x+y*y)) );\n\tu.push_back(P(change(x,y),1));\n      }\n      if(T(i,j)=='.'&&T(i+1,j)=='.'&&T(i,j+1)=='#'&&T(i+1,j+1)=='.'){\n\tx=j+1;y=i+1;\n\ta=acos( (x)/(sqrt(x*x+y*y)) );\n\tu.push_back(P(change(x,y),-1));\n      }\n    }\n  }\n  \n  \n\n  int cnt=1,ans=1;\n  sort(u.begin(),u.end());\n  for(int i=0;i<(int)u.size();i++){\n    \n    cnt+=u[i].second;\n    ans=max(ans,cnt);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\nint H,W;\nstring s[601];\nD EPS=1e-8;\nvector<D> ts;\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[H-1-i];\n\trep1(x,W) rep1(y,H){\n\t\tts.pb((D)y/x+EPS);\n\t\tts.pb((D)y/x-EPS);\n\t}\n\ts[H].assign(W,'.');\n\trep(i,H+1) s[i]+='.';\n\tint mx=0;\n\tfor(D t:ts){\n\t\tint cnt=0;\n\t\trep1(x,W){\n\t\t\tint y=floor(t*x);\n\t\t\tif(y<H&&s[y][x-1]!=s[y][x]) cnt++;\n\t\t}\n\t\trep1(y,H){\n\t\t\tint x=floor(y/t);\n\t\t\tif(x<W&&s[y-1][x]!=s[y][x]) cnt++;\n\t\t}\n\t\tmx=max(mx,(cnt+1)/2+1);\n\t}\n\tcout<<mx<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<tuple>\nusing namespace std;\nint H, W, x[1000][1000], maxn = 1, cnt = 1;\nvector<tuple<long double, int, int>>tup;\nint analysis(int p, int q) {\n\tint D = x[p - 1][q - 1] * 1 + x[p - 1][q] * 2;\n\tD += x[p][q - 1] * 4 + x[p][q] * 8;\n\tif (D == 8 || D == 7)return 1;\n\tif (D == 1 || D == 14)return -1;\n\treturn 0;\n}\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tchar c; cin >> c; if (c == '#')x[i][j] = 1;\n\t\t\tint XX = H - i + 1, YY = j;\n\t\t\ttup.push_back(make_tuple(1.0l*YY / XX, i, j));\n\t\t}\n\t}\n\tsort(tup.begin(), tup.end());\n\tfor (int i = 0; i < tup.size(); i++) {\n\t\tcnt += analysis(get<1>(tup[i]), get<2>(tup[i]));\n\t\tif (i >= 1 && get<0>(tup[i - 1]) == get<0>(tup[i])) {\n\t\t\tmaxn = max(maxn, cnt);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int W = 666;\nconst int INF = 1000000007;\nint h,w;\nvector<string> board;\n\nbool input(){\n\tcin>>h>>w;\n\tboard.clear();\n\trep(i,h){\n\t\tstring s;\n\t\tcin>>s;\n\t\tboard.pb(s);\n\t}\n\treturn true;\n}\n\nint gcd(int n, int m) {\n\treturn (n % m) ? gcd(m, n %m) : m;\n}\n\nint isBlock(char c){\n\tif(c=='#')return 1;\n\treturn 0;\n}\n\nint getState(int y,int x){\n\tint ret = 0;\n\tret += (1<<0)*isBlock(board[y][x-1]);\n\tret += (1<<1)*isBlock(board[y][x]);\n\tret += (1<<2)*isBlock(board[y-1][x-1]);\n\tret += (1<<3)*isBlock(board[y-1][x]);\n\treturn ret;\n}\n\nint cup[16];\nint cdown[16];\n\nint _cup(int state){\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 2;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 0;\n\t\tcase 8:return 0;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 2;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n\t\n}\n\nint _cdown(int state){\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 0;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 2;\n\t\tcase 8:return 2;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 0;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n}\n\nvoid setCount(){\n\trep(i,16)cup[i] = _cup(i);\n\trep(i,16)cdown[i] = _cdown(i);\n}\n\nint getCountUp(int y,int x){\n\tint state = getState(y,x);\n\t\n\treturn cup[state];\n\t\n}\n\nint getCountDown(int y,int x){\n\t\n\tint state = getState(y,x);\n\t\n\treturn cdown[state];\n}\n\nint splitCount(int y,int x){\n\t\n\t\n\t\n\tint countUp = 0;\n\tint countDown = 0;\n\t\n\treps(i,1,w+1){\n        double dy = (double)y/x;\n        if(i%x==0){\n            int ny = y*(i/x);\n            int nx = i;\n            if(ny>h)break;\n             \n            int dup = getCountUp(ny,nx);\n            int ddown = getCountDown(ny,nx);\n             \n            if(x==2 && y==1 || true){\n                //printf(\"nx=%d  ny=%d,  dup=%d  ddown=%d\\n\",nx,ny,dup,ddown);\n            }\n             \n            countUp += dup;\n            countDown += ddown;\n        }\n    }\n     \n\t\n\tdouble dy = (double)y/x;\n\tdouble dx = (double)x/y;\n\t\n\treps(i,1,w+1){\n\t\tif(i%x!=0){\n\t\t\tdouble ny = dy*i;\n\t\t\t\n\t\t\tint nh = (int)ny;\n\t\t\tif(nh>h)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[nh][i-1];\n\t\t\tchar right = board[nh][i];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\treps(i,1,h+1){\n\t\t\n\t\tif(i%y!=0){\n\t\t\t\n\t\t\tint nh = (int)(dx*i);\n\t\t\tif(nh>w)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[i-1][nh];\n\t\t\tchar right = board[i][nh];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans1 = (countUp+1)/2 + 1;\n\tint ans2 = (countDown+1)/2 + 1;\n\t\n\t//printf(\"x=%d y=%d  up=%d  down=%d\\n\",x,y,countUp, countDown);\n\t\n\treturn max(ans1, ans2);\n}\n\nvoid addBanpei(){\n\treverse(board.begin(), board.end());\n\trep(i,board.size()){\n\t\tboard[i] += \".\";\n\t}\n\tstring tmp = \"\";\n\trep(i,w+1)tmp += \".\";\n\tboard.pb(tmp);\n}\n\nvoid solve(){\n\t\n\taddBanpei();\n\tsetCount();\n\t\n\tint ans = 0;\n\treps(i,1,h+1){\n\t\treps(j,1,w+1){\n\t\t\tif(gcd(i,j)==1){\n\t\t\t\tint sp = splitCount(i,j);\n\t\t\t\tans = max(ans, sp);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint h,w;\nvector<string> mp;\n\n//   1   -1    1   -1\n//  #.   ..   .#   ##\n//  ..   .#   ##   #.\n\n\nbool O___(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '.' && mp[y-1][x] == '.' && mp[y-1][x+1] == '.';\n}\n\nbool ___O(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '.' && mp[y-1][x] == '.' && mp[y-1][x+1] == '#';\n}\n\nbool _OOO(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '#' && mp[y-1][x] == '#' && mp[y-1][x+1] == '#';\n}\n\nbool OOO_(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '#' && mp[y-1][x] == '#' && mp[y-1][x+1] == '.';\n}\n\n\nsigned main(){\n  cin>>h>>w;\n  mp.resize(h+2,string(w+2,'.'));\n\n  for(int i=0;i<h;i++) \n    for(int j=0;j<w;j++) cin>>mp[h-i][j+1];\n\n  int K = 100;\n  /*\n    vector<string> mp2((h+2)*K,string((w+2)*K,'.'));\n  for(int i=0;i<h+2;i++)\n    for(int j=0;j<w+2;j++){\n      for(int y = 0; y < K; y++)\n        for(int x = 0; x < K; x++)\n          mp2[i*K+y][j*K+x] = mp[i][j];\n    }\n  \n    mp = mp2;\n  h = mp.size() - 2;\n  w = mp[0].size() - 2;\n  */\n\n  typedef tuple<int,int,int> T;\n  vector<T> A;\n  for(int i=1;i<h+1;i++)\n    for(int j=1;j<w+1;j++){\n      if(O___(j,i)) A.push_back(T(j*K+K-1,i*K,1));\n      if(___O(j,i)) A.push_back(T(j*K+K-1,i*K,-1));\n      if(_OOO(j,i)) A.push_back(T(j*K+K-1,i*K,1));\n      if(OOO_(j,i)) A.push_back(T(j*K+K-1,i*K,-1));\n    }\n  \n  typedef complex<double> Point;\n  sort(A.begin(),A.end(),[&](T &a,T &b){\n      double x1,y1; tie(x1,y1,ignore) = a;\n      double x2,y2; tie(x2,y2,ignore) = b;\n      x1-=K;y1-=K;\n      x2-=K,y2-=K;\n      return arg(Point(x1,y1)) < arg(Point(x2,y2));\n    });\n  \n  //for(int i=0;i<h;i++) cout<<mp[h-i]<<endl;\n  //cout<<endl;\n  //for(int i=0;i<h;i++) cout<<mp[i]<<endl;\n  //cout<<A.size()<<endl; \n  \n int ans = 1;\n  int cnt = 1;\n  for(int i=0;i<(int)A.size();){\n    double x,y; tie(x,y,ignore) = A[i];\n    double th = arg(Point(x,y));\n    while(i < (int)A.size()){\n      int cost;\n      double x,y; tie(x,y,cost) = A[i];\n      if(abs(th - arg(Point(x,y))) > EPS) break;\n      //cout<<abs(th - arg(Point(x,y)))<<endl;      \n      i++;\n      cnt += cost;\n      //cout<<pr(x,y)<<endl;\n      //cout<<pr(O___(x,y), _OOO(x,y), ___O(x,y), OOO_(x,y)) <<endl;\n    }\n    Max(ans,cnt);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass UF{\n    private:\n    int sz; vector<int> par,nrank,size;\n    public:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz),size.resize(sz);\n        rep(i,sz){par[i] = i;nrank[i]=0;size[i]=1;}}\n    int find(int x){if(par[x]==x){return x;}else{return par[x] = find(par[x]);}}\n    void unite(int x,int y)\n    { x =find(x),y = find(y);if(x==y)return;if(nrank[x]<nrank[y])swap(x,y);\n        par[y] = x;size[x] += size[y];if(nrank[x]==nrank[y])nrank[x]++;}\n    int query(int x){x = find(x);return size[x];}\n    bool same(int x,int y){return find(x)==find(y);}\n};\n\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<string>s(n);\n    rep(i,n)cin >> s[n-1-i];\n    vector<vector<bool> > p(n+1,vector<bool>(m+1));\n    vector<vector<bool> > pp(n+1,vector<bool>(m+1));\n    vector<vector<bool> > qq(n+1,vector<bool>(m+1));\n    vector<vector<bool> > used(2*(n+1),vector<bool>(2*(m+1)));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(s[i][j]=='#'){\n                p[i][j] = 1;\n                p[i+1][j] = 1;\n                p[i][j+1] = 1;\n                p[i+1][j+1] = 1;\n                pp[i][j]=1;\n                pp[i+1][j]=1;\n                qq[i][j]=1;\n                qq[i][j+1]=1;\n            }\n        }\n    }\n    int ma = 1;\n    int ng = (n+1)*(m+1);\n    used[0][0] = 1;\n    for(int a=0;a<2*(n+1);a++){\n        for(int b=0;b<2*(m+1);b++){\n            if(used[a][b])continue;\n            for(int i=1;i<1000;i++){\n                if(a*i>n||b*i>m)break;\n                used[a*i][b*i] = 1;\n            }\n            UF v((n+1)*(m+1)+1);\n            vector<vector<int> > d(n+1,vector<int>(m+1));\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    if(!p[i][j]){\n                        d[i][j] = -1;\n                    }else if(a*j==i*b){\n                        d[i][j] = 0;\n                    }else if(a*j>i*b){\n                        d[i][j] = 1;\n                    }else{\n                        d[i][j] = 2;\n                    }\n                }\n            }\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(d[i][j]==-1){\n                        v.unite(now,ng);\n                    }else if(d[i][j]==0){\n                        v.unite(now,ng);\n                        if(i>0&&j<m){\n                            if(qq[i-1][j]&&pp[i][j]){\n                                v.unite(now-m-1,now+1);\n                            }\n                        }\n                        if(i<n&&j>0){\n                            if(qq[i][j]&&pp[i][j-1]){\n                                v.unite(now+m+1,now-1);\n                            }\n                        }\n                    }else{\n                        if(i+1<n+1){\n                            if(d[i][j]==d[i+1][j]&&(qq[i][j])){\n                                v.unite(now,now+m+1);\n                            }\n                        }\n                        if(j+1<m+1){\n                            if(d[i][j]==d[i][j+1]&&(pp[i][j])){\n                                v.unite(now,now+1);\n                            }\n                        }\n                    }\n                }\n            }\n            set<int> st;\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(!v.same(now,ng)){\n                        st.insert(v.find(now));\n                    }\n                }\n            }\n            // cout << \"a=\" << a << \"b=\" << b << endl;\n            // for(auto x:st){\n            //     cout << x/(m+1) << \" \" << x%(m+1) << endl;\n            // } \n            ma = max(ma,(int)st.size());\n        }\n    }\n    cout << ma << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<double,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint h,w;\nvector<string> mp;\n\n//   1   -1    1   -1\n//  #.   ..   .#   ##\n//  ..   .#   ##   #.\n\n\nbool O___(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '.' && mp[y+1][x] == '#' && mp[y+1][x+1] == '.';\n}\n\nbool ___O(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '#' && mp[y+1][x] == '.' && mp[y+1][x+1] == '.';\n}\n\nbool _OOO(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '#' && mp[y+1][x] == '.' && mp[y+1][x+1] == '#';\n}\n\nbool OOO_(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '.' && mp[y+1][x] == '#' && mp[y+1][x+1] == '#';\n}\n\n\nsigned main(){\n  cin>>h>>w;\n\n  int ofset = 1;\n  mp.resize(h+ofset * 2,string(w+ofset * 2,'.'));\n\n  for(int i=0;i<h;i++) \n    for(int j=0;j<w;j++) cin>>mp[h-i][j+1];\n  \n  auto getArg=[](double x,double y){\n    return 180 * (arg(complex<double>(x,y))/ PI);\n  };\n  \n  vector<P> A;\n  for(int i=0;i<=h;i++)\n    for(int j=0;j<=w;j++){\n      if(O___(j,i)) A.push_back(P(getArg(j,i),1));\n      if(___O(j,i)) A.push_back(P(getArg(j,i),-1));\n      if(_OOO(j,i)) A.push_back(P(getArg(j,i),1));\n      if(OOO_(j,i)) A.push_back(P(getArg(j,i),-1));\n    }\n  sort(A.begin(),A.end());  \n  \n  int ans = 1;\n  int cnt = 1;\n  for(int i=0;i<(int)A.size();){\n    double th = A[i].first;\n    while(i < (int)A.size()){\n      double th2 = A[i].first;\n      int type = A[i].second;\n      if(abs(th - th2) > EPS) break;\n      i++;\n      cnt += type;\n    }\n    Max(ans,cnt);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fs first\n#define sc second\n#define mp make_pair\nusing namespace std;\ntypedef pair<pair<int,int>,int> pii;\n\nbool l(const pii &a,const pii &b){\n  int s1 = a.fs.sc*b.fs.fs, s2 = a.fs.fs*b.fs.sc;\n  if(s1==s2)return a.sc<b.sc;\n  if(a.fs.fs==0)return false;\n  if(b.fs.fs==0)return true;\n  return s1<s2;\n}\n\nint main(){\n  int h,w;\n  string f[999];\n  cin >> h >> w;\n\n  vector<pii> v;\n  rep(i,h){\n    cin >> f[i];\n    rep(j,w){\n      if( (i==0&&f[i][j]=='#') || (i!=0&&f[i][j]!=f[i-1][j]) ){\n\tv.push_back(mp(mp(j,h-i),-1));\n\tv.push_back(mp(mp(j+1,h-i),1));\n      }\n      if( (j==w-1&&f[i][j]=='#') || (j!=w-1&&f[i][j]!=f[i][j+1])){\n\tv.push_back(mp(mp(j+1,h-i),-1));\n\tv.push_back(mp(mp(j+1,h-i-1),1));\n      }\n    }\n  }\n\n  int res = 0, tmp = 0;\n  sort(v.begin(),v.end(),l);\n  rep(i,v.size()){\n    tmp += v[i].sc;\n    res = max(res,tmp);\n  }\n  cout << (res+3)/2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nll gcd(ll x, ll y) {\n\tx = abs(x), y = abs(y);\n\tif (x < y)swap(x, y);\n\twhile (y) {\n\t\tll r = x % y; x = y; y = r;\n\t}\n\treturn x;\n}\n\n//0/0だけ気を付けて！\nstruct ratio {\n\tll a, b;\n\tratio(ll x) { a = x; b = 1; };\n\tratio(ll x, ll y) { \n\t\ta = x; b = y; \n\t\tll g = gcd(x, y); \n\t\tif (g > 0) {\n\t\t\ta /= g, b /= g;\n\t\t\tif (b < 0)a = -a, b = -b;\n\t\t}\n\t};\n\t\n};\n\nvoid normalize(ratio &r) {\n\tll g = gcd(r.a, r.b);\n\tr.a /= g; r.b /= g;\n\tif (r.b < 0)r.b = -r.b, r.a = -r.a;\n}\nbool operator<(const ratio &x,const ratio &y) {\n\treturn x.a*y.b < x.b*y.a;\n}\nbool operator==(const ratio &x,const ratio &y) {\n\treturn x.a*y.b == x.b*y.a;\n}\n\ntypedef pair<ratio, int> speP;\n\nchar mp[600][600];\nvoid solve(){\n\tint h, w; cin >> h >> w;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\tvector<speP> v;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tif (mp[i][j] != '#')continue;\n\t\t\t//左下\n\t\t\tint x = h - 1 - i, y = j;\n\n\t\t\tif (j==w-1||(j < w - 1&&mp[i][j+1]=='.')) {\n\t\t\t\tv.push_back({ ratio(x+1,y+1),1 });\n\t\t\t\tv.push_back({ ratio(x,y + 1),0 });\n\t\t\t}\n\t\t\tif (j==0||(j > 0 && mp[i][j - 1] == '.')) {\n\t\t\t\tv.push_back({ ratio(x+1,y),1 });\n\t\t\t\tv.push_back({ ratio(x,y),0 });\n\t\t\t}\n\t\t\tif (i==0||(i > 0 && mp[i - 1][j] == '.')) {\n\t\t\t\tv.push_back({ ratio(x+1,y),1 });\n\t\t\t\tv.push_back({ ratio(x+1,y + 1),0 });\n\t\t\t}\n\t\t\tif (i==h-1||(i < h - 1 && mp[i + 1][j] == '.')) {\n\t\t\t\tv.push_back({ ratio(x,y),1 });\n\t\t\t\tv.push_back({ ratio(x,y + 1),0 });\n\t\t\t}\n\t\t}\n\t}\n\tint len = v.size();\n\tfor (int i = len-1; i >= 0;i--) {\n\t\t//cout << v[i].first.a << \" \" << v[i].first.b << endl;\n\t\tif (v[i].first.a==0&&v[i].first.b==0) {\n\t\t\t//cout << \"Hello\" << \" \" << i << endl;\n\t\t\tv.erase(v.begin() + i);\n\t\t}\n\t}\n\tlen = v.size();\n\t//cout << len << endl;\n\tint ans = 0;\n\tsort(v.begin(), v.end());\n\t/*rep(i, len) {\n\t\tcout << v[i].first.a << \" \" << v[i].first.b << endl;\n\t}*/\n\tint cur = 0;\n\trep(i, len) {\n\t\tint le = i;\n\t\twhile (i + 1 < len&&v[i].first == v[i + 1].first)i++;\n\t\tRep1(j, le, i) {\n\t\t\tif (v[j].second)cur--;\n\t\t\telse cur++;\n\t\t}\n\t\tans = max(ans, cur);\n\t\t//cout << cur << \" \"<<v[i].first.a << \" \" << v[i].first.b << endl;\n\t}\n\tcout << ans / 2+1 << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct UnionFind {\n  int parent[610 * 610];\n  UnionFind() { MEMSET(parent, -1); }\n  int UnionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) { return 0; }\n    if (parent[x] > parent[y]) { swap(x, y); }\n    parent[x] += parent[y];\n    parent[y] = x;\n    return 1;\n  }\n  int FindSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n};\n\ntypedef vector<int> Array;\ntypedef vector<Array> Matrix;\n\ntemplate <class T>\nvoid PrintMatrix(const vector<vector<T> > &matrix) {\n  REP(y, matrix.size()) {\n    REP(x, matrix[y].size()) {\n      cout << matrix[y][x] << \" \";\n    }\n    puts(\"\");\n  }\n}\n\ntemplate <class T>\nvector<vector<T> > Transpose(const vector<vector<T> > &matrix) {\n  int h = matrix.size();\n  int w = matrix[0].size();\n  vector<vector<T> > ret(w, vector<T>(h));\n  REP(y, h) {\n    REP(x, w) {\n      ret[w - x - 1][h - y - 1] = matrix[y][x];\n    }\n  }\n  return ret;\n}\n\n//=====================\n\nUnionFind ufind;\npair<Matrix, Matrix> calc(const vector<vector<char> > &field) {\n  int h = field.size();\n  int w = field[0].size();\n  ufind = UnionFind();\n  pair<Matrix, Matrix> ret(Matrix(h, Array(w, 0)), Matrix(h, Array(w, 0)));\n  map<double, vector<pair<int, int> > > que;\n  REP(y, h - 1) {\n    REP(x, w - 1) {\n      int dy = h - 2 - y;\n      int dx = x;\n      if (dy == 0 && dx == 0) { continue; }\n      int g = __gcd(dy, dx);\n      dy /= g; dx /= g;\n      double angle = dy / (double)dx;\n      if (dx == 0) { angle = 1e+100; }\n      que[angle].push_back(make_pair(x, y));\n    }\n  }\n  int lans = 0;\n  FORIT (it1, que) {\n    //PrintMatrix(ret);\n    //cout << endl;\n    //cout << lans << endl;\n    assert(lans >= 0);\n    const vector<pair<int, int> > &poss = it1->second;\n    FORIT(it2, poss) {\n      ret.first[it2->second][it2->first] = lans;\n    }\n    FORIT(it2, poss) {\n      int x = it2->first;\n      int y = it2->second;\n      if (field[y][x] == '.') { continue; }\n      lans++;\n      if (field[y + 1][x] == '#' && ufind.UnionSet(y * w + x, (y + 1) * w + x)) { lans--; }\n      if (field[y][x + 1] == '#' && ufind.UnionSet(y * w + x, y * w + (x + 1))) { lans--; }\n      if (field[y][x + 1] == '#' && field[y + 1][x] == '#' && ufind.UnionSet(y * w + x + 1, (y + 1) * w + x)) { lans--; }\n      if (field[y][x] == '#' && field[y + 1][x + 1] == '#' && ufind.UnionSet(y * w + x, (y + 1) * w + x + 1)) { lans--; }\n    }\n    FORIT(it2, poss) {\n      ret.second[it2->second][it2->first] = lans;\n    }\n  }\n  return ret;\n}\n\nchar str[1010];\nint main() {\n  int h, w;\n  while (scanf(\"%d %d\", &h, &w) > 0) {\n    vector<vector<char> > field(h + 2, vector<char>(w + 2, '.'));\n    REP(y, h) {\n      int v = scanf(\"%s\", str);\n      assert(v == 1);\n      REP(x, w) { field[y + 1][x + 1] = str[x]; }\n    }\n    pair<Matrix, Matrix> lans = calc(field);\n    //PrintMatrix(lans.first);\n    //PrintMatrix(lans.second);\n    field = Transpose(field);\n    pair<Matrix, Matrix> rans = calc(field);\n    //PrintMatrix(rans.first);\n    //PrintMatrix(rans.second);\n    rans.first = Transpose(rans.first);\n    rans.second = Transpose(rans.second);\n    //PrintMatrix(rans);\n    int ans = 0;\n    REP(y, h + 1) {\n      REP(x, w + 1) {\n        ans = max(ans, lans.first[y][x] + rans.second[y + 1][x + 1]);\n        ans = max(ans, lans.second[y][x] + rans.first[y + 1][x + 1]);\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Vector;\n\nconst double EPS = 1e-9;\n\nbool inRange(int a, int x, int b) {\n    return a <= x && x < b;\n}\n\nchar get(const vector<string> &f, int r, int c) {\n    if(!inRange(0, r, f.size()) || !inRange(0, c, f[0].size())) return 0;\n    return f[r][c] == '#';;\n}\n\nbool eqv(double a, double b) {\n    return fabs(a-b) < EPS;\n}\n\nstruct Point {\n    double angle;\n    bool inc;\n\n    Point() {}\n    Point(double a, bool i) : angle(a), inc(i) {}\n\n    bool operator < (const Point &other) const {\n        return angle < other.angle;\n    }\n};\n\nint main() {\n    int R, C;\n    cin >> R >> C;\n\n    vector<string> f(R);\n    for(int i = 0; i < R; ++i) {\n        cin >> f[i];\n    }\n\n    vector<Point> v;\n    for(int r = -1; r < R; ++r) {\n        for(int c = -1; c < C; ++c) {\n            int pat = 0;\n            pat |= get(f, r, c) << 3;\n            pat |= get(f, r, c+1) << 2;\n            pat |= get(f, r+1, c) << 1;\n            pat |= get(f, r+1, c+1) << 0;\n\n            if(pat == 0x1 || pat == 0xe) {\n                double angle = atan2(R-r-1, c+1);\n                v.push_back(Point(angle, false));\n                //cout << r << ' ' << c << '(' << angle << ')' << \" false\" << endl;\n            }\n            else if(pat == 0x8 || pat == 0x7) {\n                double angle = atan2(R-r-1, c+1);\n                v.push_back(Point(angle, true));\n                //cout << r << ' ' << c << '(' << angle << ')' << \" true\" << endl;\n            }\n        }\n    }\n\n    sort(v.begin(), v.end());\n\n    int cnt = 1;\n    int ans = 1;\n    for(int i = 0; i < v.size(); ++i) {\n        if(v[i].inc) ++cnt;\n        else --cnt;\n        if(i+1 < v.size() && eqv(v[i].angle, v[i+1].angle)) continue;\n\n        //cout << \"i=\" << i << ' ' << cnt << endl;\n        ans = max(ans, cnt);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconstexpr double EPS = 1e-4;\n\nint gcd(int x, int y) { return y == 0 ? x : gcd(y, x%y); }\n\nstruct point {\n    double x, y;\n    point() {}\n    point(double x, double y): x(x), y(y) {}\n\n    point operator + (const point& o) const { return point(x+o.x, y+o.y); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y); }\n    point operator * (const double a) const { return point(x*a, y*a); }\n\n    bool operator < (const point& o) const { return x == o.x ? y < o.y : x < o.x; }\n    bool operator == (const point& o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble fabs(point a) { return sqrt(a.x*a.x + a.y*a.y); }\ndouble dist(point a, point b) { return fabs(a - b); }\ndouble dist(line l) { return dist(l.a, l.b); }\ndouble dot(point a, point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(point a, point b) { return a.x*b.y - a.y*b.x; }\n\ndouble dist_point_line(point p, line l) {\n    if (dot(p - l.a, l.b - l.a) >= 0 && dot(p - l.b, l.a - l.b) >= 0)\n        return fabs(cross(p - l.a, l.b - l.a)) / dist(l);\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nbool has_intersection(line s, line t) {\n    double s1 = cross(s.b - s.a, t.a - s.b) * cross(s.b - s.a, t.b - s.b);\n    double s2 = cross(t.b - t.a, s.a - t.a) * cross(t.b - t.a, s.b - t.a);\n    if (s1 < 0 && s2 < 0) return true;\n    else if (s1 * s2 == 0) {\n        double d1 = dist_point_line(s.a, t);\n        double d2 = dist_point_line(s.b, t);\n        double d3 = dist_point_line(t.a, s);\n        double d4 = dist_point_line(t.b, s);\n        return min(min(d1, d2), min(d3, d4)) == 0;\n    }\n    return false;\n}\n\npoint intersection(line s, line t) {\n    double c1 = fabs(cross(t.b - t.a, s.a - t.a));\n    double c2 = fabs(cross(t.b - t.a, s.b - t.a));\n    return s.a + (s.b - s.a) * (c1 / (c1 + c2));\n}\n\nint H, W;\nint block[605][605];\n\nvector<line> ls;\nvector<point> ps;\n\nint main(void) {\n    cin >> H >> W;\n    for (int i = 0; i <= H; ++i) fill(block[i], block[i]+W+1, 0);\n    for (int i = 0 ; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            char ch; cin >> ch;\n            block[i][j] = (ch == '#') ? 1 : 0;\n        }\n    }\n\n    for (int i = 0; i <= H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if ((i == 0 && block[i][j] == 1) || (i > 0 && (block[i][j] ^ block[i-1][j]))) {\n                int lj = j++;\n                while (j < W) {\n                    if ((i == 0 || block[i-1][j] == block[i-1][lj]) &&\n                        block[i][j] == block[i][lj])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(i, lj), point(i, j));\n                --j;\n            }\n        }\n    }\n\n    for (int i = 0; i <= W; ++i) {\n        for (int j = 0; j < H; ++j) {\n            if ((i == 0 && block[j][i] == 1) || (i > 0 && (block[j][i] ^ block[j][i-1]))) {\n                int lj = j++;\n                while (j < H) {\n                    if ((i == 0 || block[j][i-1] == block[lj][i-1]) &&\n                        block[j][i] == block[lj][i])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(lj, i), point(j, i));\n                --j;\n            }\n        }\n    }\n\n    int itv = 5;\n    vector<point> es;\n    for (int i = 0; i <= itv*W; ++i) es.emplace_back(0, (double)i/itv);\n    for (int i = 0; i <= itv*H; ++i) es.emplace_back((double)i/itv, W);\n\n    int ans = 0;\n    point left_bottom(H, 0);\n    for (point e : es) {\n        line tiro(left_bottom, left_bottom + (e-left_bottom)*2);\n\n        set<point> cs;\n        for (line l : ls) {\n            if (has_intersection(tiro, l)) cs.insert(intersection(tiro, l));\n        }\n\n        ans = max(ans, (int)cs.size() / 2 + 1);\n\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nstruct verticle {\n    double theta;\n    ll x, y;\n    bitset<4> pattern;\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll hn, wn; cin >> hn >> wn;\n    vector<string> b(hn); rep(i, hn) cin >> b[i]; reverse(all(b));\n\n    vector<verticle> vs;\n    rep(h, hn+1) rep(w, wn+1) if (h || w) {\n        verticle v;\n        v.x = h;\n        v.y = w;\n        v.theta = atan2(h, w);\n\n        // 10 \n        // 23\n        auto f = [&](ll h, ll w){ return h >= 0 && w >= 0 && h < hn && w < wn; };\n        v.pattern[2] = f(h, w-1) && b[h][w-1] == '#';\n        v.pattern[0] = f(h-1, w) && b[h-1][w] == '#';\n        v.pattern[1] = f(h-1, w-1) && b[h-1][w-1] == '#';\n        v.pattern[3] = f(h, w) && b[h][w] == '#'; \n        vs.pb(v);\n    }\n    sort(all(vs), [](const verticle& a, const verticle& b){ return a.theta < b.theta; });\n    /*\n    rep(i, vs.size()) {\n        cout << vs[i].x << \" \" << vs[i].y << \" \" << vs[i].theta << endl;\n        cout << vs[i].pattern[1] << vs[i].pattern[0] << endl;\n        cout << vs[i].pattern[2] << vs[i].pattern[3] << endl;\n    }\n    rep(i, b.size()) \n        cout << b[i] << endl;\n        */\n    ll ret = 0;\n    ll cut = 0;\n    ll i = 0;\n    while (i < vs.size()) {\n        /*\n        cout << i << endl;\n        cout << vs[i].x << \" \" << vs[i].y << endl;\n        */\n        double th = vs[i].theta;\n        vector<verticle> p;\n        while (i < vs.size() && vs[i].theta < th + EPS) {\n            p.pb(vs[i]);\n            i++;\n        }\n\n        rep(j, p.size()) {\n            // +1\n            if (!p[j].pattern[0] && !p[j].pattern[1] && p[j].pattern[2] && !p[j].pattern[3]) cut++;\n            if (p[j].pattern[0] && p[j].pattern[1] && !p[j].pattern[2] && p[j].pattern[3]) cut++;\n            // -1\n            if (p[j].pattern[0] && !p[j].pattern[1] && !p[j].pattern[2] && !p[j].pattern[3]) cut--;\n            if (!p[j].pattern[0] && p[j].pattern[1] && p[j].pattern[2] && p[j].pattern[3]) cut--;\n        }\n//        cout << cut << endl;\n        chmax(ret, cut); \n    }\n    cout << ret + 1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\nnamespace Geometry{\n#define F first\n#define S second\n  typedef long double D;\n  typedef complex<long double> P;\n  typedef pair<P,D> C;\n    \n  const D EPS=1e-9;\n  const D PI=asin(1)*2;\n  const D INF=1e18;\n    \n  static bool comp(const P &p1,const P &p2){\n    if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n    return p1.real()<p2.real();\n  }\n    \n  static bool comp_y(const P &p1,const P &p2){\n    if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n    return p1.imag()<p2.imag();\n  }\n    \n  static bool eqls(const P &p1,const P &p2){return abs(p1-p2)<EPS;}\n    \n  D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n  D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n  P project(P vec,P x){return vec*(x/vec).real();}\n    \n  P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n  P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n  P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n  bool intersectSL(P p1,P p2,P vec){\n    vec/=abs(vec); p1/=vec; p2/=vec;\n    return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);\n  }\n    \n  bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n  bool intersectSS(P p1,P p2,P p3,P p4){\n    if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n    if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n    return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n  }\n    \n  D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n  D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n  D distSP(P p1,P p2,P x){\n    if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n    if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n    return distLP(p1,p2,x);\n  }\n    \n  D distSS(P p1,P p2,P p3,P p4){\n    if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n    return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n                distSP(p3,p4,p1),distSP(p3,p4,p2)});\n  }\n    \n  P crosspointLL(P p1,P p2,P vec){\n    if(abs(cross(p2-p1,vec))<EPS){return vec;}\n    return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n  }\n    \n  P crosspointLL(P p1,P p2,P p3,P p4){\n    return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n  }\n    \n  P crosspointSS(P p1,P p2,P p3,P p4){\n    if(distSP(p1,p2,p3)<EPS){return p3;}\n    if(distSP(p1,p2,p4)<EPS){return p4;}\n    return crosspointLL(p1,p2,p3,p4);\n  }\n    \n  bool intersectShL(P p1,P p2,P vec){\n    vec/=abs(vec);\n    return intersectSL(p1,p2,vec) &&\n      crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n  }\n    \n  bool intersectShL(P p1,P p2,P p3,P p4){\n    return intersectShL(p1-p3,p2-p3,p4-p3);\n  }\n    \n  //1::in,0::on edge,-1::out\n  int contain(const vector<P> &poly,const P &p){\n    vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n    int s=A.size();\n    vector<bool> cnt(s,false);\n    for(int i=0;i<(int)poly.size();i++){\n      int k=(i+1)%poly.size();\n      if(distSP(poly[i],poly[k],p)<EPS){return 0;}\n      for(int j=0;j<s;j++){\n        if(intersectShL(poly[i],poly[k],p,p+A[j])){cnt[j]=!cnt[j];}\n      }\n    }\n    int in=0;\n    for(int j=0;j<s;j++){if(cnt[j]){in++;}}\n    return in>s/2?1:-1;\n  }\n    \n  vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n    vector<P> ret;\n    for(int i=0;i<(int)poly.size();i++){\n      int j=(i+1)%poly.size();\n      if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n      if(intersectSL(poly[i],poly[j],p1,p2) &&\n         distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n        ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly){\n    D ans=0;\n    for(int i=2;i<(int)poly.size();i++){\n      ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n    }\n    return abs(ans)/2;\n  }\n    \n  vector<P> convexhull(vector<P> pts){\n    vector<P> ret;\n    sort(pts.begin(),pts.end(),comp);\n    auto fnc=[&](){\n               for(auto &I:pts){\n                 if(!ret.empty() && abs(I-ret.back())<EPS){continue;}\n                 while(ret.size()>1){\n                   P A=ret.back()-ret[ret.size()-2];\n                   P B=I-ret.back();\n                   if(cross(A,B)<-EPS){ret.pop_back();}\n                   else if(abs(cross(A,B))<EPS && dot(A,B)>EPS){ret.pop_back();}\n                   else{break;}\n                 }\n                 ret.push_back(I);\n               }\n             };\n    fnc();\n    reverse(pts.begin(),pts.end());\n    fnc();\n    if(ret.size()>1 && ret[0]==ret.back()){ret.pop_back();}\n    return ret;\n  }\n    \n  //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n  int intersectCC(C c1,C c2){\n    D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n    if(d<EPS && dif<EPS){return -1;}\n    if(d-r>EPS){return 4;}\n    if(d-r>-EPS){return 3;}\n    if(d-dif>EPS){return 2;}\n    if(d-dif>-EPS){return 1;}\n    return 0;\n  }\n    \n  vector<P> crosspointLC(P p1,P p2,C c){\n    vector<P> ret;\n    P pr=project(p1,p2,c.F);\n    D d=distLP(p1,p2,c.F);\n    if(d-c.S>EPS){return ret;}\n    if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n    P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n    ret.push_back(pr-vec);\n    ret.push_back(pr+vec);\n    return ret;\n  }\n    \n  vector<P> crosspointSC(P p1,P p2,C c){\n    vector<P> ret;\n    for(auto &I:crosspointLC(p1,p2,c)){\n      if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n    }\n    return ret;\n  }\n    \n  vector<P> crosspointCC(C c1,C c2){\n    vector<P> ret;\n    P vec=c2.F-c1.F;\n    D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n    D h=sqrt(c1.S*c1.S-base*base);\n    vec/=abs(vec);\n    ret.push_back(c1.F+vec*P(base,-h));\n    ret.push_back(c1.F+vec*P(base,h));\n    return ret;\n  }\n    \n  vector<P> tangentCP(C c,P p){\n    return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n  }\n    \n  vector<pair<P,P>> tangentCC(C c1,C c2){\n    vector<pair<P,P>> ret;\n    P d=c2.F-c1.F;\n    for(D i:{-1,1}){\n      D r=c1.S+c2.S*i;\n      if(intersectCC(c1,c2)>i+1){\n        for(P s:{-1i,1i}){\n          P p=r+s*sqrt(norm(d)-norm(r));\n          ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n        }\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly,C c){\n    D ret=0;\n    for(int i=0;i<(int)poly.size();i++){\n      P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n      if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n      else{\n        vector<P> A=crosspointSC(a,b,{0,c.S});\n        if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n        else{\n          ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n          ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n          ret+=cross(A[0],A.back());\n        }\n      }\n    }\n    return abs(ret)/2;\n  }\n    \n  //反時計回り\n  D diameter(const vector<P> &poly){\n    D ret=0;\n    ll l=0,r=0,n=poly.size();\n    if(n==2){return abs(poly[0]-poly[1]);}\n    for(int i=0;i<n;i++){\n      if(comp(poly[l],poly[i])){l=i;}\n      if(comp(poly[i],poly[r])){r=i;}\n    }\n    ll sl=r,sr=l;\n    while(sl!=l || sr!=r){\n      ret=max(ret,abs(poly[r]-poly[l]));\n      if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n      else{(++r)%=n;}\n    }\n    return ret;\n  }\n    \n  D closestpair(vector<P> pt){\n    sort(pt.begin(),pt.end(),comp);\n    D ret=INF;\n    int N=pt.size();\n    for(int i=1;i<N;i<<=1){\n      for(int j=0;i+j<N;j+=i*2){\n        int m=i+j;\n        vector<P> R;\n        D l=-INF,r=INF;\n        for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n        for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n        for(int k=0;m+k<N && k<i;k++){\n          if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n        }\n        int idx=0;\n        for(int k=j;k<m;k++){\n          if(r-pt[k].real()>ret){continue;}\n          int M=R.size();\n          while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n          for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n            ret=min(ret,abs(R[s]-pt[k]));\n          }\n        }\n        auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n        inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n      }\n    }\n    return ret;\n  }\n    \n  P centerofgravity(const vector<P> &pt){\n    P ret(0,0);\n    D wt=0;\n    for(int i=2;i<(int)pt.size();i++){\n      D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n      P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n      wt+=w2;\n      ret+=p*w2;\n    }\n    return ret/wt;\n  }\n    \n  void segment_arrangement(const vector<pair<P,P>> &L,vector<pair<int,int>> &seg,vector<P> &pt){\n    int N=L.size();\n    for(int i=0;i<N;i++){\n      pt.push_back(L[i].F);\n      pt.push_back(L[i].S);\n      for(int j=i+1;j<N;j++){\n        if(intersectSS(L[i].F,L[i].S,L[j].F,L[j].S)){\n          pt.push_back(crosspointSS(L[i].F,L[i].S,L[j].F,L[j].S));\n        }\n      }\n    }\n    auto le=[](P a,P b){return eqls(a,b)?false:comp(a,b);};\n    sort(pt.begin(),pt.end(),le);\n    pt.erase(unique(pt.begin(),pt.end(),eqls),pt.end());\n    for(auto &I:L){\n      vector<pair<D,int>> on;\n      for(int j=0;j<(int)pt.size();j++){\n        if(distSP(I.F,I.S,pt[j])<EPS){\n          on.emplace_back(abs(pt[j]-I.F),j);\n        }\n      }\n      sort(on.begin(),on.end());\n      for(int j=1;j<(int)on.size();j++){\n        seg.emplace_back(on[j-1].S,on[j].S);\n      }\n    }\n    sort(seg.begin(),seg.end());\n    seg.erase(unique(seg.begin(),seg.end()),seg.end());\n  }\n    \n  vector<P> convex_of_segments(const vector<pair<P,P>> &L){\n    vector<pair<int,int>> seg;\n    vector<P> pt;\n    segment_arrangement(L,seg,pt);\n    vector<vector<int>> edge(pt.size());\n    for(auto &I:seg){\n      edge[I.F].push_back(I.S);\n      edge[I.S].push_back(I.F);\n    }\n    vector<P> ret;\n    function<void(int,int)> dfs=[&](int v,int pre){\n                                  if(pre!=-1 && v==0){return;}\n                                  ret.push_back(pt[v]);\n                                  vector<pair<D,int>> nx;\n                                  for(auto &u:edge[v]){\n                                    D a=arg((pt[u]-pt[v])/(pre==-1 || eqls(pt[v],pt[pre])?P(1):pt[v]-pt[pre]));\n                                    if(abs(a+PI)<EPS){a=PI;}\n                                    nx.emplace_back(a,u);\n                                  }\n                                  sort(nx.begin(),nx.end());\n                                  dfs(nx[0].S,v);\n                                };\n    dfs(0,-1);\n    return ret;\n  }\n    \n  istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n  istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n  void Input(P &p){D x,y;cin>>x>>y;p={x,y};}\n};\n\nusing namespace Geometry;\n\nvector<ll> uft(610*610);\n\nll parent(ll a){return uft[a]==a?a:uft[a]=parent(uft[a]);}\n\nvoid merge(ll a,ll b){uft[parent(a)]=parent(b);}\n\nbool same(ll a,ll b){return parent(a)==parent(b);}\n\nvector<ll> dx={0,0,-1,-1,0};\nvector<ll> dy={0,-1,-1,0,0};\nll H,W;\n\nll gcd(ll a,ll b){\n  while(b!=0){a%=b; swap(a,b);}\n  return a;\n}\n\nint main(){\n  cout<<fixed<<setprecision(12);\n  cin>>H>>W;\n  vector<string> A(H);\n  for(int i=H-1;i>=0;i--){cin>>A[i];}\n  for(int i=0;i<H*W;i++){uft[i]=i;}\n  auto valid=\n    [&](ll x,ll y){return 0<=x && 0<=y && x<H && y<W && A[x][y]=='#';};\n  vector<pll> event;\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      event.push_back({i,j});\n    }\n  }\n  ll sz=H*W;\n  //cout<<event<<endl;\n  sort(event.begin(),event.end(),[](pll a,pll b){return a.F*b.S>b.F*a.S;});\n  //cout<<event<<endl;\n  ll sum=0;\n  vector<vector<bool>> used(H,vector<bool>(W,false));\n  auto add_edge=\n    [&](ll x1,ll y1,ll x2,ll y2){\n      if(valid(x1,y1) && valid(x2,y2) && !same(x1*W+y1,x2*W+y2)){\n        sum--;\n        merge(x1*W+y1,x2*W+y2);\n        //cout<<\"connect \"<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<endl;\n      }\n    };\n\n  auto add_upper=\n    [&](ll x,ll y){\n      for(int i=0;i<3;i++){\n        ll u=x+dx[i];\n        ll v=y+dy[i];\n        if(valid(u,v) && !used[u][v]){used[u][v]=true; sum++;}\n      }\n      for(int i=0;i<2;i++){\n        ll u1=x+dx[i];\n        ll v1=y+dy[i];\n        ll u2=x+dx[i+1];\n        ll v2=y+dy[i+1];\n        add_edge(u1,v1,u2,v2);\n      }\n    };\n\n  auto add_lower=\n    [&](ll x,ll y){\n      for(int i=2;i<5;i++){\n        ll u=x+dx[i];\n        ll v=y+dy[i];\n        if(valid(u,v) && !used[u][v]){used[u][v]=true; sum++;}\n      }\n      for(int i=2;i<4;i++){\n        ll u1=x+dx[i];\n        ll v1=y+dy[i];\n        ll u2=x+dx[i+1];\n        ll v2=y+dy[i+1];\n        add_edge(u1,v1,u2,v2);\n      }\n    };\n  \n  for(int i=1;i<=H;i++){add_lower(i,0);}\n  vector<vector<int>> cnt1(H+1,vector<int>(W+1,0));//点まで\n  vector<vector<int>> cnt2(H+1,vector<int>(W+1,0));//全部\n  cnt2[1][0]=sum;\n  for(int i=0;i<sz;){\n    int x=event[i].F,y=event[i].S;\n    int tmp=gcd(x,y);\n    x/=tmp;\n    y/=tmp;\n    \n    int j=i;\n    for(;j<sz && event[i].F*event[j].S==event[i].S*event[j].F;j++){\n      add_upper(event[j].F,event[j].S);\n    }\n    //cout<<x<<\" \"<<y<<\" \"<<\" \"<<1<<\" \"<<sum<<endl;\n    cnt1[x][y]=sum;\n    j=i;\n    for(;j<sz && event[i].F*event[j].S==event[i].S*event[j].F;j++){\n      add_lower(event[j].F,event[j].S);\n    }\n    //cout<<x<<\" \"<<y<<\" \"<<\" \"<<2<<\" \"<<sum<<endl;\n    cnt2[x][y]=sum;\n    i=j;\n  }\n  //cout<<\"reverse\"<<endl;\n  reverse(event.begin(),event.end());\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){used[i][j]=false;}\n  }\n  sum=0;\n  ll ans=0;\n  for(int i=0;i<H*W;i++){uft[i]=i;}\n  for(int i=1;i<=W;i++){add_upper(0,i);}\n  for(int i=0;i<sz;){\n    int x=event[i].F,y=event[i].S;\n    int tmp=gcd(x,y);\n    x/=tmp;\n    y/=tmp;\n    //cout<<x<<\" \"<<y<<\" \"<<\" \"<<1<<\" \"<<sum<<\" \"<<cnt2[x][y]+sum<<endl;\n    ans=max(ans,cnt2[x][y]+sum);\n    int j=i;\n    for(;j<sz && event[i].F*event[j].S==event[i].S*event[j].F;j++){\n      add_lower(event[j].F,event[j].S);\n    }\n    //cout<<x<<\" \"<<y<<\" \"<<\" \"<<2<<\" \"<<sum<<\" \"<<cnt1[x][y]+sum<<endl;\n    //ans=max(ans,cnt1[x][y]+sum);\n    j=i;\n    for(;j<sz && event[i].F*event[j].S==event[i].S*event[j].F;j++){\n      add_upper(event[j].F,event[j].S);\n    }\n    i=j;\n  }\n  ans=max(ans,cnt2[1][0]+sum);\n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> field(1, string(w + 1, '.'));\n\tfield.reserve(h + 2);\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tstring line;\n\t\tcin >> line;\n\t\tfield.emplace_back(line + '.');\n\t}\n\n\tfield.emplace_back(string(w + 1, '.'));\n\n\ttypedef pair<double, bool> event; // arg, inc\n\tvector<event> events;\n\n\tconst int oy = h;\n\n\tfor(int i = 1; i < h + 2; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == field[i - 1][j + 1]) {\n\t\t\t\tif(field[i][j] == field[i][j + 1] && field[i][j] != field[i - 1][j]) { // inc\n\t\t\t\t\tevents.emplace_back(atan2(oy - (i - 1), j + 1), true);\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] != field[i][j + 1] && field[i][j] == field[i - 1][j]) { // dec\n\t\t\t\t\tevents.emplace_back(atan2(oy - (i - 1), j + 1), false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(events.begin(), events.end());\n\n\tint ans = 1;\n\tint cnt = 1;\n\n\tfor(const auto &e : events) {\n\t\tif(e.second) {\n\t\t\tchmax(ans, ++cnt);\n\t\t}\n\t\telse {\n\t\t\t--cnt;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<tuple>\nusing namespace std;\nint H, W, x[1000][1000], maxn = 1, cnt = 1;\nvector<tuple<long double, int, int>>tup;\nint analysis(int p, int q) {\n\tint D = x[p - 1][q - 1] * 1 + x[p - 1][q] * 2;\n\tD += x[p][q - 1] * 4 + x[p][q] * 8;\n\tif (D == 8 || D == 7)return 1;\n\tif (D == 1 || D == 14)return -1;\n\treturn 0;\n}\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tchar c; cin >> c; if (c == '#')x[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= H + 1; i++) {\n\t\tfor (int j = 1; j <= W + 1; j++) {\n\t\t\tint XX = (H + 1) - i, YY = j - 1;\n\t\t\tif (XX + YY == 0)continue;\n\t\t\ttup.push_back(make_tuple(1.0l*YY / XX, i, j));\n\t\t}\n\t}\n\tsort(tup.begin(), tup.end());\n\tfor (int i = 0; i < tup.size(); i++) {\n\t\tint p = analysis(get<1>(tup[i]), get<2>(tup[i]));\n\t\tcnt += p;\n\t\tlong double B = 0.0l;\n\t\tif (i < tup.size() - 1)B = fabs(get<0>(tup[i]) - get<0>(tup[i + 1]));\n\t\tif (i == (tup.size() - 1) || B > 1e-12) {\n\t\t\tmaxn = max(maxn, cnt);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool compare(P A, P B){\n  \n  int y1 = A.first, x1 = A.second;\n  int y2 = B.first, x2 = B.second;\n  \n  return y1 * x2 < x1 * y2;\n}\n\nint h, w;\nstring s[605];\n\nint check(int y, int x){\n  \n  char a = s[y][x], b = s[y+1][x], c = s[y+1][x+1], d = s[y][x+1];\n  \n  if( a == '.' && b == '#' && c == '.' && d == '.' ) return 1;\n  \n  if( a == '.' && b == '.' && c == '.' && d == '#' ) return -1;\n  \n  if( a == '#' && b == '.' && c == '#' && d == '#' ) return 1;\n  \n  if( a == '#' && b == '#' && c == '#' && d == '.' ) return -1;\n  \n  return 0;\n}\n\nvector<P> point;\n\nint main(){\n  \n  cin>>h>>w;\n  \n  for(int i=0;i<=h+1;i++) s[i] = string( w + 2, '.' );\n  \n  for(int i=h;i>=1;i--){\n    for(int j=1;j<=w;j++) cin>>s[i][j];\n  }\n    \n  for(int i=0;i<=h;i++){\n    \n    for(int j=0;j<=w;j++){\n      \n      int r = check( i, j );\n      \n      if( !r ) continue;\n      \n      point.push_back(P( i, j ));\n      \n    }\n    \n  }\n  \n  sort( point.begin(), point.end(), compare );\n  \n  int ans = 1, x = 1, idx = 0, len = (int)point.size();\n  \n  while( idx < len ){\n    \n    while( idx < len && compare( point[idx], point[idx+1] ) == false ){\n    \n      x += check( point[idx].first, point[idx].second );\n      \n      idx++;\n      \n    }\n\n    x += check( point[idx].first, point[idx].second );\n      \n    idx++;\n    \n    ans = max( ans, x );\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<double,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint h,w;\nvector<string> mp;\n\n//   1   -1    1   -1\n//  #.   ..   .#   ##\n//  ..   .#   ##   #.\n\n\nbool O___(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '.' && mp[y+1][x] == '#' && mp[y+1][x+1] == '.';\n}\n\nbool ___O(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '#' && mp[y+1][x] == '.' && mp[y+1][x+1] == '.';\n}\n\nbool _OOO(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '#' && mp[y+1][x] == '.' && mp[y+1][x+1] == '#';\n}\n\nbool OOO_(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '.' && mp[y+1][x] == '#' && mp[y+1][x+1] == '#';\n}\n\n\nsigned main(){\n  cin>>h>>w;\n\n  int ofset = 1;\n  mp.resize(h+ofset * 2,string(w+ofset * 2,'.'));\n\n  for(int i=0;i<h;i++) \n    for(int j=0;j<w;j++) cin>>mp[h-i][j+1];\n  \n  auto getArg=[](double x,double y){\n    return 180 * (arg(complex<double>(x,y))/ PI);\n  };\n  \n  vector<P> A;\n  for(int i=0;i<=h;i++)\n    for(int j=0;j<=w;j++){\n      if(O___(j,i)) A.push_back(P(getArg(j,i),1));\n      if(___O(j,i)) A.push_back(P(getArg(j,i),-1));\n      if(_OOO(j,i)) A.push_back(P(getArg(j,i),1));\n      if(OOO_(j,i)) A.push_back(P(getArg(j,i),-1));\n    }\n  sort(A.begin(),A.end());  \n  \n  int ans = 1;\n  int cnt = 1;\n  for(int i=0;i<(int)A.size();){\n    double th = A[i].first;\n    while(i < (int)A.size()){\n      double th2 = A[i].first;\n      int type = A[i].second;\n      if(abs(th - th2) > EPS) break;\n      i++;\n      cnt += type;\n    }\n    Max(ans,cnt);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef pair<ld, int> pdi;\n\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tvs fld(h+2);\n\tfld[0] = fld[h + 1] = string(w+2, '.');\n\tREP(i, h)\n\t{\n\t\tstring s; cin >> s;\n\t\tfld[i + 1] = \".\" + s + \".\";\n\t}\n\tvector<pdi> v;\n\tFOR(i, 1, h + 2)FOR(j, 1, w + 2)\n\t{\n\t\tld t;\n\t\tif (j != 1) t = (ld)(h + 1 - i) / (ld)(j-1);\n\t\telse t = INF;\n\t\tif (fld[i - 1][j - 1] == '.'&&fld[i - 1][j] == '.'&&fld[i][j - 1] == '.'&&fld[i][j] == '#')\n\t\t{\n\t\t\tv.emplace_back(t, -1);\n\t\t}\n\t\tif (fld[i - 1][j - 1] == '#'&&fld[i - 1][j] == '#'&&fld[i][j - 1] == '#'&&fld[i][j] == '.')\n\t\t{\n\t\t\tv.emplace_back(t, -1);\n\t\t}\n\t\tif (fld[i - 1][j - 1] == '#'&&fld[i - 1][j] == '.'&&fld[i][j - 1] == '.'&&fld[i][j] == '.')\n\t\t{\n\t\t\tv.emplace_back(t, 1);\n\t\t}\n\t\tif (fld[i - 1][j - 1] == '.'&&fld[i - 1][j] == '#'&&fld[i][j - 1] == '#'&&fld[i][j] == '#')\n\t\t{\n\t\t\tv.emplace_back(t, 1);\n\t\t}\n\t}\n\tsort(v.rbegin(),v.rend());\n\tint ans = -1, tmp = 1;\n\tREP(i, v.size())\n\t{\n\t\ttmp -= v[i].second;\n\t\tchmax(ans, tmp);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double, bool> P;\nchar f[600][601];\nconst LL MOD = 1000000007LL;\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> f[i];\n\t}\n\tvector<P> v;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (f[i][j] == '#' && (i + 1 >= H || f[i + 1][j] == '.') && (j + 1 >= W || f[i][j + 1] == '.')) {\n\t\t\t\tv.emplace_back(atan2(H - i - 1, j + 1), 1);\n\t\t\t\t//+1\n\t\t\t}\n\t\t\tif (f[i][j] == '#' && (i == 0 || f[i - 1][j] == '.') && (j == 0 || f[i][j - 1] == '.')) {\n\t\t\t\tv.emplace_back(atan2(H - i, j), 0);\n\t\t\t\t//-1\n\t\t\t}\n\t\t\tif (f[i][j] == '.' && (i >0 && f[i - 1][j] == '#') && (j > 0 && f[i][j - 1] == '#')) {\n\t\t\t\t//-1\n\t\t\t\tv.emplace_back(atan2(H - i, j), 0);\n\t\t\t}\n\t\t\tif (f[i][j] == '.' && (i + 1 < H && f[i + 1][j] == '#') && (j + 1 < W && f[i][j + 1] == '#')) {\n\t\t\t\t//+1\n\t\t\t\tv.emplace_back(atan2(H - i - 1, j + 1), 1);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint cnt = 1;\n\tint ans = 1;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i].second) cnt++;\n\t\telse cnt--;\n\t\tans = max(ans, cnt);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\n\nint dh[4]={0,1,0,-1};\nint dw[4]={1,0,-1,0};\n\nusing Event=pair<ld,int>;\nconst ld eps=1e-8;\n\nint main(){\n    int h,w;\n    cin>>h>>w;\n    vector<string> f(h);\n    for(int i=0;i<h;i++) cin>>f[i];\n\n    reverse(f.begin(),f.end());\n    string top=\"\";\n    for(int i=0;i<w;i++) top+=\".\";    \n    w++;\n    h++;    \n    f.push_back(top);\n    for(int i=0;i<h;i++){\n        f[i]+=\".\";\n    }\n\n    auto isRange=[&](int i,int j){\n        return 0<=i && i<h && 0<=j && j<w;\n    };\n    \n    vector<Event> event;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]!='#') continue;\n            for(int k=0;k<4;k++){\n                if(isRange(i+dh[k],j+dw[k]) && f[i+dh[k]][j+dw[k]]=='.'){\n                    if(k==0){\n                        event.push_back({ld(i)/ld(j+1),1});\n                        event.push_back({ld(i+1)/ld(j+1),-1});\n                    }\n                    if(k==1){\n                        event.push_back({ld(i+1)/ld(j+1),1});\n                        if(j!=0) event.push_back({ld(i+1)/ld(j),-1});\n                    }\n                    if(k==2 && j!=0){\n                        event.push_back({ld(i)/ld(j),1});\n                        event.push_back({ld(i+1)/ld(j),-1});\n                    }\n                    if(k==3 && i!=0){\n                        event.push_back({ld(i)/ld(j+1),1});\n                        if(j!=0) event.push_back({ld(i)/ld(j),-1});\n                    }\n                }\n            }\n        }\n    }\n    sort(event.begin(),event.end());\n    int idx=0;\n    int cnt=0;\n    int res=0;\n    while(idx<event.size()){\n        ld t;\n        do{\n            auto e=event[idx++];\n            t=e.first;\n            cnt+=e.second;\n        }while(idx<event.size() && abs(t-event[idx].first)<eps);\n        res=max(cnt,res);\n    }\n    if(f[0][0]=='#') res++;\n    res=res/2+1;\n    cout<<res<<endl;    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n  int H, W;\n  cin >> H >> W;\n  string F[H];\n  for(int i = 0; i < H; ++i){\n    cin >> F[i];\n  }\n  int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n  pair<pii,pii> e[4];\n  e[0] = make_pair(pii(1,0),pii(1,1));\n  e[1] = make_pair(pii(0,1),pii(1,1));\n  e[2] = make_pair(pii(0,0),pii(0,1));\n  e[3] = make_pair(pii(0,0),pii(1,0));\n  vector< pair<double,int> > A;//\"#\"テ」ツ?ョテヲツ閉ーテ」ツつ誰テ」ツ?ィテ」ツ?凖」ツつ凝」ツ?ィ2*N+2テ」ツ?静」ツつ嘉」ツ??」ツ?ョティツヲツ?ァツエツ?ヲツ閉ー\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(F[i][j] == '#'){\n\tfor(int k = 0; k < 4; ++k){\n\t  if(i+dx[k] < 0 || j+dy[k] < 0 || i+dx[k] > H-1 || j+dy[k] > W-1 || F[i+dx[k]][j+dy[k]] != '#'){\n\t    pii s = pii(H-i-e[k].first.first, j+e[k].first.second);\n\t    pii t = pii(H-i-e[k].second.first, j+e[k].second.second);\n\t    //printf(\"(%d, %d), (%d, %d)\\n\",s.first,s.second,t.first,t.second);\n\t    if(s.second && s.first)\n\t      A.push_back(make_pair((double)s.first/s.second, -1));\n\t    if(t.second && s.first)\n\t      A.push_back(make_pair((double)t.first/t.second, +1));\n\t  }\n\t}\n      }\n    }\n  }\n  sort(A.begin(),A.end());\n  int ans = 0, t = 0;\n\n  for(int i = 0; i < (int)A.size(); ++i){\n\n    t += A[i].second;\n    t = max(t,0);\n    ans = max(t,ans);\n  }\n\n  cout << (ans+1)/2 + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct point\n{\n  int n, d;\n  bool inc;\n  point(int x, int y, bool z) : n(x), d(y), inc(z) {}\n  bool operator<(const point& that) const\n  {\n    const int x = n*that.d;\n    const int y = that.n*d;\n    if (x == y) {\n      return !inc && that.inc;\n    } else {\n      return x < y;\n    }\n  }\n};\n\nint main()\n{\n  int H, W;\n  cin >> H >> W;\n  vector<string> grid(H);\n  for (int i = 0; i < H; i++) {\n    cin >> grid[i];\n  }\n\n  vector<point> ps;\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (grid[i][j] == '#'\n          && (i == 0 || grid[i-1][j] == '.')\n          && (j == 0 || grid[i][j-1] == '.')) {\n        ps.push_back(point(j, H-i, true));\n      } else if (grid[i][j] == '#'\n          && (i == H-1 || grid[i+1][j] == '.')\n          && (j == W-1 || grid[i][j+1] == '.')) {\n        ps.push_back(point(j+1, H-i-1, false));\n      } else if (grid[i][j] == '.'\n          && (i != 0 && grid[i-1][j] == '#')\n          && (j != 0 && grid[i][j-1] == '#')) {\n        ps.push_back(point(j, H-i, true));\n      } else if (grid[i][j] == '.'\n          && (i != H-1 && grid[i+1][j] == '#')\n          && (j != W-1 && grid[i][j+1] == '#')) {\n        ps.push_back(point(j+1, H-i-1, false));\n      }\n    }\n  }\n  sort(ps.begin(), ps.end());\n  int ans = 0;\n  int acc = 1;\n  for (vector<point>::const_iterator it = ps.begin(); it != ps.end(); ++it) {\n    if (it->inc) {\n      ++acc;\n      ans = max(ans, acc);\n    } else {\n      --acc;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n//constant\n//--------------------------------------------\nconst double mEPS = 1e-10;\nconst double PI  = acos(-1.0);\n \nclass Point{\npublic:\n    double x, y;\n \n    Point(double x = 0.0, double y = 0.0) : x(x), y(y){}\n \n    Point operator + (Point p){ return Point(x + p.x, y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x, y - p.y); }\n    Point operator * (double a){ return Point(a*x, a*y); }\n    Point operator / (double a){ return Point(x / a, y / a); }\n \n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x*x + y*y; }\n \n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n \n    //EPS???????????°??????????\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n    }\n \n  friend ostream& operator<<(ostream& os, const Point& p);\n \n};\nostream& operator<<(ostream& os, const Point& p){\n  os << \"(\" << p.x << \",\" << p.y << \")\";\n  return os;\n}\n   \nclass Segment{\npublic:\n    Point p1, p2;\n};\n \n \ntypedef vector<Point> Polygon;\n \n//????????????¨?????????±???\ntypedef Point Vector;\n//????????????´??????¨?????????±???\ntypedef Segment Line;\n \n//??????\ndouble dot(Vector a, Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n \n//????????????§??????\ndouble cross(Vector a, Vector b){\n    return a.x*b.y - a.y*b.x;\n}\n \nint ccw(Point p0, Point p1, Point p2){\n \n    //p0->p1???p0??§???????p1??????????????????????????????¨?????????¨???\n \n    //p0->p2???????????¨???????????????????¨???\n    static const int COUNTER_CLOCKWISE = 1;\n    //p0->p2????????¨???????????????????¨???\n    static const int CLOCKWISE = -1;\n    //p2,p0,p1?????????§?????????´??????????????????¨???\n    static const int ONLINE_BACK = 2;\n    //p0,p1,p2 ?????????§?????????´??????????????????´???\n    static const int ONLINE_FRONT = -2;\n    //p2 ????????? p0p1 ???????????????´???\n    static const int ON_SEGMENT = 0;\n \n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n \n    if (cross(a, b) > mEPS) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -mEPS) return CLOCKWISE;\n    if (dot(a, b) < -mEPS) return ONLINE_BACK;\n    if (a.norm() < b.norm()) return ONLINE_FRONT;\n \n    return ON_SEGMENT;\n \n}\n \nbool intersect(Segment s1, Segment s2){\n    return(ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n        ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n \n \nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  int H, W; cin >> H >> W;\n  VS str(H); REP(i,H) cin >> str[i];\n  reverse(ALL(str));\n  vector<Segment> ls;\n  REP(y,H) REP(x,W){\n    if(str[y][x] == '#' && (y == 0 || str[y-1][x] == '.')){\n      int t = x;\n      for(;t<W;++t)\n        if(str[y][t] == '.' || (y > 0 && str[y-1][t] == '#')) break;\n      Point p1, p2;\n      p1.x = x; p1.y = y;\n      p2.x = t, p2.y = y;\n      Segment s; s.p1 = p1, s.p2 = p2;\n      ls.PB(s);\n      x = t;\n    }\n  }\n  REP(y,H) REP(x,W){\n    if(str[y][x] == '#' && (y == H-1 || str[y+1][x] == '.')){\n      int t = x;\n      for(;t<W;++t)\n        if(str[y][t] == '.' || (y < H-1 && str[y+1][t] == '#')) break;\n      Point p1, p2;\n      p1.x = x; p1.y = y+1;\n      p2.x = t, p2.y = y+1;\n      Segment s; s.p1 = p1, s.p2 = p2;\n      ls.PB(s);\n      x = t;\n    }\n  }\n  REP(x,W) REP(y,H){\n    if(str[y][x] == '#' && (x == 0 || str[y][x-1] == '.')){\n      int t = y;\n      for(;t<H;++t)\n        if(str[t][x] == '.' || (x > 0 && str[t][x-1] == '#')) break;\n      Point p1, p2;\n      p1.x = x; p1.y = y;\n      p2.x = x, p2.y = t;\n      Segment s; s.p1 = p1, s.p2 = p2;\n      ls.PB(s);\n      y = t;\n    }\n  }\n  REP(x,W) REP(y,H){\n    if(str[y][x] == '#' && (x == W-1 || str[y][x+1] == '.')){\n      int t = y;\n      for(;t<H;++t)\n        if(str[t][x] == '.' || (x < W-1 && str[t][x+1] == '#')) break;\n      Point p1, p2;\n      p1.x = x+1; p1.y = y;\n      p2.x = x+1, p2.y = t;\n      Segment s; s.p1 = p1, s.p2 = p2;\n      ls.PB(s);\n      y = t;\n    }\n  }\n \n  vector<tuple<int,int,Point>> memo;\n  REP(i,SZ(ls)) FOR(j,i+1,SZ(ls))\n    if(intersect(ls[i], ls[j])){\n      if(ls[i].p1 == ls[j].p1 || ls[i].p1 == ls[j].p2)\n        memo.PB(MT(i,j,ls[i].p1));\n      else\n        memo.PB(MT(i,j,ls[i].p2));\n    }\n \n  int ans = 1;\n  for(int y=0;y<=H;++y) for(int x=0;x<=W;++x) for(double dy=-1;dy<=1.1;dy+=0.5)for(double dx=-1;dx<=1.1;dx+=0.5){\n\t\t  double th = atan2(y+dy, x+dx);\n    Segment s;\n    s.p1.x = 0, s.p1.y = 0;\n    s.p2.x = 1000. * cos(th), s.p2.y = 1000. * sin(th);\n    vector<bool> cr(SZ(ls));\n    REP(i,SZ(ls)) cr[i] = intersect(s, ls[i]);\n    int c = count(ALL(cr), true);\n    for(auto& pp: memo){\n      if(cr[get<0>(pp)] && cr[get<1>(pp)] && !ccw(s.p1, s.p2, get<2>(pp)))\n        --c;\n    }\n    ans = max(ans, c/2+1);\n  }\n  cout << ans << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int W = 666;\nconst int INF = 1000000007;\nint h,w;\nvector<string> board;\n\nbool input(){\n\tcin>>h>>w;\n\tboard.clear();\n\trep(i,h){\n\t\tstring s;\n\t\tcin>>s;\n\t\tboard.pb(s);\n\t}\n\treturn true;\n}\n\nint gcd(int n, int m) {\n\treturn (n % m) ? gcd(m, n %m) : m;\n}\n\nint isBlock(char c){\n\tif(c=='#')return 1;\n\treturn 0;\n}\n\nint getState(int y,int x){\n\tint ret = 0;\n\tret += (1<<0)*isBlock(board[y][x-1]);\n\tret += (1<<1)*isBlock(board[y][x]);\n\tret += (1<<2)*isBlock(board[y-1][x-1]);\n\tret += (1<<3)*isBlock(board[y-1][x]);\n\treturn ret;\n}\n\nint cup[16];\nint cdown[16];\n\nint _cup(int state){\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 2;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 0;\n\t\tcase 8:return 0;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 2;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n\t\n}\n\nint _cdown(int state){\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 0;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 2;\n\t\tcase 8:return 2;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 0;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n}\n\nvoid setCount(){\n\trep(i,16)cup[i] = _cup(i);\n\trep(i,16)cdown[i] = _cdown(i);\n}\n\nint getCountUp(int y,int x){\n\tint state = getState(y,x);\n\t\n\treturn cup[state];\n\t\n}\n\nint getCountDown(int y,int x){\n\t\n\tint state = getState(y,x);\n\t\n\treturn cdown[state];\n}\n\nint splitCount(int y,int x){\n\t\n\t\n\t\n\tint countUp = 0;\n\tint countDown = 0;\n\t\n\tdouble dy = (double)y/x;\n\tdouble dx = (double)x/y;\n\t/*\n\treps(i,1,w+1){\n        double dy = (double)y/x;\n        if(i%x==0){\n            int ny = y*(i/x);\n            int nx = i;\n            if(ny>h)break;\n             \n            int dup = getCountUp(ny,nx);\n            int ddown = getCountDown(ny,nx);\n             \n            if(x==2 && y==1 || true){\n                //printf(\"nx=%d  ny=%d,  dup=%d  ddown=%d\\n\",nx,ny,dup,ddown);\n            }\n             \n            countUp += dup;\n            countDown += ddown;\n        }\n    }\n     */\n     \n     for(int i=1;i<=w;i++){\n            int ny = y*i;\n            int nx = i*x;\n            if(ny>h)break;\n             \n            int dup = getCountUp(ny,nx);\n            int ddown = getCountDown(ny,nx);\n             \n             \n            countUp += dup;\n            countDown += ddown;\n    }\n\t\n\t\n\treps(i,1,w+1){\n\t\tif(i%x!=0){\n\t\t\tdouble ny = dy*i;\n\t\t\t\n\t\t\tint nh = (int)ny;\n\t\t\tif(nh>h)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[nh][i-1];\n\t\t\tchar right = board[nh][i];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\treps(i,1,h+1){\n\t\t\n\t\tif(i%y!=0){\n\t\t\t\n\t\t\tint nh = (int)(dx*i);\n\t\t\tif(nh>w)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[i-1][nh];\n\t\t\tchar right = board[i][nh];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans1 = (countUp+1)/2 + 1;\n\tint ans2 = (countDown+1)/2 + 1;\n\t\n\t//printf(\"x=%d y=%d  up=%d  down=%d\\n\",x,y,countUp, countDown);\n\t\n\treturn max(ans1, ans2);\n}\n\nvoid addBanpei(){\n\treverse(board.begin(), board.end());\n\trep(i,board.size()){\n\t\tboard[i] += \".\";\n\t}\n\tstring tmp = \"\";\n\trep(i,w+1)tmp += \".\";\n\tboard.pb(tmp);\n}\n\nvoid solve(){\n\t\n\taddBanpei();\n\tsetCount();\n\t\n\tint ans = 0;\n\treps(i,1,h+1){\n\t\treps(j,1,w+1){\n\t\t\tif(gcd(i,j)==1){\n\t\t\t\tint sp = splitCount(i,j);\n\t\t\t\tans = max(ans, sp);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct PQ {\n\tint den, num;\n\tPQ(int den, int num) : den(den), num(num) {}\n};\nbool operator>(const PQ& pq1, const PQ& pq2) {\n\treturn pq1.num * pq2.den > pq1.den * pq2.num;\n}\nbool operator<(const PQ& pq1, const PQ& pq2) {\n\treturn pq2 > pq1;\n}\nbool operator==(const PQ& pq1, const PQ& pq2) {\n\treturn !(pq1 > pq2) && !(pq1 < pq2);\n}\nbool operator>=(const PQ& pq1, const PQ& pq2) {\n\treturn pq1 == pq2 || pq1 > pq2;\n}\nbool operator<=(const PQ& pq1, const PQ& pq2) {\n\treturn pq2 >= pq1;\n}\n\ntypedef pair<PQ, PQ> PQP;\n\nint H, W;\nvector<string> M;\nbool dot[601][601] = {0};\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nbool inRange2(int x, int y) {\n\treturn 0 <= x && x <= W && 0 <= y && y <= H;\n}\nbool isWall(int x, int y) {\n\tif ( !inRange(x, y) ) return false;\n\treturn M[y][x] == '#';\n}\nbool getDot(int x, int y) {\n\tif ( !inRange2(x, y) ) return false;\n\treturn dot[y][x];\n}\nbool moveCheck(int x1, int y1, int x2, int y2) {\n\tif ( !getDot(x2, y2) ) return false;\n\tmap<P, int> cnt;\n\tfor (int dy = -1; dy <= 0; ++dy) {\n\t\tfor (int dx = -1; dx <= 0; ++dx) {\n\t\t\tcnt[P(x1+dx, y1+dy)]++;\n\t\t\tcnt[P(x2+dx, y2+dy)]++;\n\t\t}\n\t}\n\tset<bool> s;\n\tfor ( pair<const P, int>& p : cnt ) {\n\t\tif (p.second == 2 ) {\n\t\t\ts.insert(isWall(p.first.first, p.first.second));\n\t\t}\n\t}\n\treturn s.size() == 2;\n}\nint moveX(int x0, int y0) {\n\tbool bfl = true, bfr = true;\n\tbool fl = true, fr = true;\n\tfor (int dx = 1; dx <= W+3; ++dx) {\n\t\tfr = fr && moveCheck(x0+dx-1, y0, x0+dx, y0);\n\t\tfl = fl && moveCheck(x0-(dx-1), y0, x0-dx, y0);\n\t\tif ( !fr && !fl ) {\n\t\t\tif (bfl) return x0-(dx-1);\n\t\t\treturn x0+dx-1;\n\t\t}\n\t\tbfl = fl, bfr = fr;\n\t}\n}\nint moveY(int x0, int y0) {\n\tbool bfl = true, bfr = true;\n\tbool fl = true, fr = true;\n\tfor (int dy = 1; dy <= H+3; ++dy) {\n\t\tfr = fr && moveCheck(x0, y0+(dy-1), x0, y0+dy);\n\t\tfl = fl && moveCheck(x0, y0-(dy-1), x0, y0-dy);\n\t\tif ( !fr && !fl ) {\n\t\t\tif (bfl) return y0-(dy-1);\n\t\t\treturn y0+dy-1;\n\t\t}\n\t\tbfl = fl, bfr = fr;\n\t}\n}\n\nPQ f(int x, int y) {\n\treturn PQ(x, y);\n}\n\nvector<PQP> r;\nvoid addLine(int x1, int y1, int x2, int y2) {\n\ty1 = H-y1, y2 = H-y2;\n\tif (x1 == 0 && y1 == 0) return;\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << (double)y1/x1 << \" \" << (double)y2/x2 << endl;\n\tPQ pq1 = f(x1, y1);\n\tPQ pq2 = f(x2, y2);\n\tif (pq2 < pq1) swap(pq1, pq2);\n\tr.push_back( PQP(pq1, pq2) );\n}\nint main() {\n\tcin >> H >> W;\n\tM.resize(H);\n\tfor (int i = 0; i < H; ++i) cin >> M[i];\n\tfor (int y = 0; y <= H; ++y) {\n\t\tfor (int x = 0; x <= W; ++x) {\n\t\t\tset<bool> s;\n\t\t\tfor (int dx = -1; dx <= 0; ++dx) {\n\t\t\t\tfor (int dy = -1; dy <= 0; ++dy) {\n\t\t\t\t\ts.insert( isWall(x+dx, y+dy) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tdot[y][x] = s.size() == 2;\n\t\t}\n\t}\n\tint sx = -1, sy = -1;\n\tfor (int y = 0; y < H; ++y) {\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tif ( isWall(x, y) ) {\n\t\t\t\tsx = x, sy = y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sx >= 0) break;\n\t}\n\t{\n\t\tint x = sx, y = sy;\n\t\twhile (1) {\n\t\t\tint nx = moveX(x, y);\n\t\t\tint ny = moveY(nx, y);\n//\t\t\tassert(nx != x);\n//\t\t\tassert(ny != y);\n\t\t\taddLine(x, y, nx, y);\n\t\t\tif (nx == sx && ny == sy) break;\n\t\t\taddLine(nx, y, nx, ny);\n\t\t\tx = nx, y = ny;\n\t\t}\n\t\tsort(r.begin(), r.end());\n\t\tint mx = 0;\n\t\tmap<PQ, int> m;\n\t\t{\n\t\t\tvector<PQ> v;\n\t\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\t\tv.push_back(r[i].first);\n\t\t\t\tv.push_back(r[i].second);\n\t\t\t}\n\t\t\tsort(v.begin(), v.end());\n\t\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t\t\tfor (int i = 0; i < v.size(); ++i) {\n\t//\t\t\tcout << v[i].first.num << \" \" << v[i].\n\t\t\t\tm[v[i]] = i;\n\t\t\t}\n\t\t\tmx = v.size();\n\t\t}\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\tv.push_back( P(m[r[i].first], m[r[i].second]) );\n\t\t}\n\t\tfor (int i = 0; i < v.size(); ++i) {\n//\t\t\tcout << v[i].first << \" \" << v[i].second << endl;\n\t\t}\n\t\tvector<int> cnt(mx*2+3, 0);\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\t++cnt[v[i].first*2+1];\n\t\t\t--cnt[v[i].second*2];\n\t\t}\n\t\tfor (int i = 0; i+1 < cnt.size(); ++i) {\n\t\t\tcnt[i+1] += cnt[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < cnt.size(); ++i) {\n\t\t\tans = max(ans, cnt[i]);\n\t\t}\n\t\t++ans;\n\t\tcout << ans/2+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\nconst double EPS = 1e-10;\n\nint H, W;\n\nbool inside(int a, int b) {\n\treturn 0 <= a && a < H && 0 <= b && b < W;\n}\n\n\n\nint main() {\n\tcin >> H >> W;\n\tvector<string> v(H);\n\trep(i, H) cin >> v[i];\n\t// map<pair<int,int>,int> ma;\n\tvector<pair<double, int>> w;\n\trep(i, H - 1) {\n\t\trep(j, W - 1) {\n\t\t\tif(v[i].substr(j, 2) == \"#.\" && v[i + 1].substr(j, 2) == \"..\") {\n\t\t\t\tdouble ang = 1.0 * (H - 1 - i) / (j + 1);\n\t\t\t\tw.push_back(make_pair(ang, 1));\n\t\t\t}\n\t\t\tif(v[i].substr(j, 2) == \"..\" && v[i + 1].substr(j, 2) == \".#\") {\n\t\t\t\tdouble ang = 1.0 * (H - 1 - i) / (j + 1) - EPS;\n\t\t\t\tw.push_back(make_pair(ang, -1));\n\t\t\t}\n\t\t\tif(v[i].substr(j, 2) == \"##\" && v[i + 1].substr(j, 2) == \"#.\") {\n\t\t\t\tdouble ang = 1.0 * (H - 1 - i) / (j + 1) - EPS;\n\t\t\t\tw.push_back(make_pair(ang, -1));\n\t\t\t}\n\t\t\tif(v[i].substr(j, 2) == \".#\" && v[i + 1].substr(j, 2) == \"##\") {\n\t\t\t\tdouble ang = 1.0 * (H - 1 - i) / (j + 1);\n\t\t\t\tw.push_back(make_pair(ang, +1));\n\t\t\t}\n\t\t}\n\t}\n\trep(i, H - 1) {\n\t\tif(v[i][W - 1] == '#' && (i == H - 1 || v[i + 1][W - 1] == '.')) {\n\t\t\tdouble ang = 1.0 * (H - 1 - i) / (W);\n\t\t\tw.push_back(make_pair(ang, 1));\n\t\t}\n\t}\n\trep(i, W) {\n\t\tif(i && v[0][i] == '#' && v[0][i - 1] == '.') {\n\t\t\tdouble ang = 1.0 * (H) / (i) - EPS;\n\t\t\tw.push_back(make_pair(ang, -1));\n\t\t}\n\t\tif(v[H - 1][i] == '#' && (i == W - 1 || v[H - 1][i + 1] == '.')) {\n\t\t\tdouble ang = 1.0 * (0) / (i + 1);\n\t\t\tw.push_back(make_pair(ang, 1));\n\t\t}\n\t}\n\tint ans = 1;\n\tint tmp = 1;\n\tsort(w.begin(), w.end());\n\trep(i, w.size()) {\n\t\ttmp += w[i].second;\n\t\tans = max(ans, tmp);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int h,w;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++) cin>>s[i];\n  bool e[h+10][w+10];\n  memset(e,0,sizeof(e));\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      e[h-i-1][j]=s[i][j]=='#';\n  /*//\n    for(int i=h-1;i>=0;i--)\n    for(int j=0;j<w;j++)\n    cout<<e[i][j]<<\" \\n\"[j==w-1];\n  //*/\n  int ans=2;\n  \n  time_t start=clock();\n  srand((unsigned)time(NULL));\n  int k=0;\n  while((double)(clock()-start)/CLOCKS_PER_SEC<1.8&&k<=min(w,h)){\n    k++;\n    for(int i=1;i<=h+k;i++){\n      int x=0,y=0,tmp=e[0][0],p;\n      while(x<=w&&y<=h){\n\t//if(i==4&&k==2) cout<<y<<\" \"<<x<<endl;\n\tp=e[y][x];\n\tif((i*(x+1))%(w+k)==0) x++,y++;\n\tif((i*(x+1))/(w+k)==y) x++;\n\telse y++;\n\tif(!p&&e[y][x]) tmp++;\n      }\n      //cout<<i<<\":\"<<tmp<<endl;\n      //if(i==4&&k==2) cout<<tmp<<endl;\n      ans=max(ans,tmp+1);\n    }\n    for(int j=1;j<=w+k;j++){\n      int x=0,y=0,tmp=e[0][0],p;\n      while(x<=w&&y<=h){\n\tp=e[y][x];\n\tif((j*(y+1))%(h+k)==0) x++,y++;\n\telse if((j*(y+1))/(h+k)==x) y++;\n\telse x++;\n\tif(!p&&e[y][x]) tmp++;\n      }\n      //cout<<j<<\" \"<<tmp<<endl;\n      ans=max(ans,tmp+1);\n    }\n  }\n  //cout<<k<<endl;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-11, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<bool>>fi(H+2, vector<bool>(W+2));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '#') {\n\t\t\t\tfi[i+1][j+1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<Line>ls;\n\tvector<double>katas;\n\tvector<vector<bool>>tates(H + 2, vector<bool>(W + 1));\n\tvector<vector<bool>>yokos(H + 1, vector<bool> (W + 2));\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 1; x < W + 1; ++x) {\n\t\t\tif (fi[y][x]) {\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tPoint ld(x, y + 1);\n\t\t\t\t\tPoint lu(x, y);\n\t\t\t\t\tPoint rd(x + 1, y + 1);\n\t\t\t\t\tPoint ru(x + 1, y);\n\t\t\t\t\tif (!fi[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\ttates[y][x - 1] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(ld, lu);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == 1) {\n\t\t\t\t\t\t\tyokos[y][x] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(rd, ld);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == 2) {\n\t\t\t\t\t\t\ttates[y][x] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(ru, rd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tyokos[y - 1][x] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(lu, ru);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < W + 1; ++x) {\n\t\tbool now = false;\n\t\tPoint from;\n\t\tfor (int y = 0; y < H + 2; ++y) {\n\t\t\t\n\t\t\tif (tates[y][x]) {\n\t\t\t\tif (!now) {\n\t\t\t\t\tfrom=Point(x+1,y);\n\t\t\t\t}\n\t\t\t\tnow = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (now) {\n\t\t\t\t\tls.emplace_back(from, Point(x + 1, y));\n\t\t\t\t}\n\t\t\t\tnow = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = 0; y < H + 1; ++y) {\n\t\tbool now = false;\n\t\tPoint from;\n\t\tfor (int x = 0; x < W + 2; ++x) {\n\t\t\tif (yokos[y][x]) {\n\t\t\t\tif (!now) {\n\t\t\t\t\tfrom = Point(x, y + 1);\n\t\t\t\t}\n\t\t\t\tnow = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (now) {\n\t\t\t\t\tls.emplace_back(from, Point(x, y + 1));\n\t\t\t\t}\n\t\t\t\tnow = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 2; x < W + 2; ++x) {\n\t\t\tkatas.push_back(double(y-(H+1))/ (x - 1));\n\t\t}\n\t}\n\tkatas.push_back(0);\n\tkatas.push_back(-1000);\n\tsort(katas.begin(), katas.end());\n\tvector<double>newkatas;\n\tdouble now = 1;\n\tfor (int i = 0; i < katas.size(); ++i) {\n\t\tif (abs(katas[i]-now)>1e-10) {\n\t\t\tnewkatas.push_back(katas[i]);\n\t\t\tnow = (katas[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\n\tmap<double, int>mp;\n\tmp[0] = 0;\n\tmp[-1000] = 0;\n\tfor (int j = 0; j < ls.size(); ++j) {\n\t\tif (ls[j][0] == Point(1, H+1) || ls[j][1] == Point(1, H+1))continue;\n\t\tdouble kataf = (ls[j][0].imag() - H-1) / (ls[j][0].real()+eps - 1);\n\t\tdouble katat = (ls[j][1].imag() - H - 1) / (ls[j][1].real() + eps - 1);\n\t\tif (kataf < katat)swap(kataf, katat);\n\t\tassert(kataf >= katat);\n\t\tmp[kataf]--;\n\t\tmp[katat]++;\n\t}\n\tint anow = 0;\n\tfor (auto &it : mp) {\n\t\tit.second += anow;\n\t\tanow = it.second;\n\t}\n\t\n\tfor (int i = 0; i < newkatas.size()-1; ++i) {\n\t\tdouble kata = (newkatas[i + 1] + newkatas[i])/2;\n\t\tLine l(Point(1, H + 1), Point(1 + 1, H + 1 + kata));\n\t\tint nans = 0;\n\t\tnans = prev(mp.lower_bound(kata))->second;\n\t\tif (fi[H][1])nans += 1;\n\t\tans = max(ans, 1+nans/2);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int W = 666;\nconst int INF = 1000000007;\nint h,w;\nvector<string> board;\n\nbool input(){\n\tcin>>h>>w;\n\tboard.clear();\n\trep(i,h){\n\t\tstring s;\n\t\tcin>>s;\n\t\tboard.pb(s);\n\t}\n\treturn true;\n}\n\nint gcd(int n, int m) {\n\treturn (n % m) ? gcd(m, n %m) : m;\n}\n\nint isBlock(char c){\n\tif(c=='#')return 1;\n\treturn 0;\n}\n\nint getState(int y,int x){\n\tint ret = 0;\n\tret += (1<<0)*isBlock(board[y][x-1]);\n\tret += (1<<1)*isBlock(board[y][x]);\n\tret += (1<<2)*isBlock(board[y-1][x-1]);\n\tret += (1<<3)*isBlock(board[y-1][x]);\n\treturn ret;\n}\n\nint cup[16];\nint cdown[16];\n\nint _cup(int state){\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 2;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 0;\n\t\tcase 8:return 0;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 2;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n\t\n}\n\nint _cdown(int state){\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 0;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 2;\n\t\tcase 8:return 2;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 0;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n}\n\nvoid setCount(){\n\trep(i,16)cup[i] = _cup(i);\n\trep(i,16)cdown[i] = _cdown(i);\n}\n\nint getCountUp(int y,int x){\n\tint state = getState(y,x);\n\t\n\treturn cup[state];\n\t\n}\n\nint getCountDown(int y,int x){\n\t\n\tint state = getState(y,x);\n\t\n\treturn cdown[state];\n}\n\nint splitCount(int y,int x){\n\t\n\t\n\t\n\tint countUp = 0;\n\tint countDown = 0;\n\t\n\tfor(int i=1;;i++){\n\t\tint ny = y*i;\n\t\tint nx = i*w;\n\t\tif(nx>w)break;\n\t\tif(ny>h)break;\n\t\t\n\t\tcountUp += getCountUp(ny,nx);\n\t\tcountDown += getCountDown(ny,nx);\n\t}\n\t\n\treps(i,1,w+1){\n\t\tdouble dy = (double)y/x;\n\t\tif(i%x!=0){\n\t\t\tdouble ny = dy*i;\n\t\t\t\n\t\t\tint nh = (int)ny;\n\t\t\tif(nh>h)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[nh][i-1];\n\t\t\tchar right = board[nh][i];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\treps(i,1,h+1){\n\t\t\n\t\tdouble dx = (double)x/y;\n\t\tif(i%y!=0){\n\t\t\tdouble nx = dx*i;\n\t\t\t\n\t\t\tint nh = (int)nx;\n\t\t\tif(nh>w)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[i-1][nh];\n\t\t\tchar right = board[i][nh];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans1 = (countUp+1)/2 + 1;\n\tint ans2 = (countDown+1)/2 + 1;\n\t\n\t//printf(\"x=%d y=%d  up=%d  down=%d\\n\",x,y,countUp, countDown);\n\t\n\treturn max(ans1, ans2);\n}\n\nvoid addBanpei(){\n\treverse(board.begin(), board.end());\n\trep(i,board.size()){\n\t\tboard[i] += \".\";\n\t}\n\tstring tmp = \"\";\n\trep(i,w+1)tmp += \".\";\n\tboard.pb(tmp);\n}\n\nvoid solve(){\n\t\n\taddBanpei();\n\tsetCount();\n\t\n\tint ans = 0;\n\treps(i,1,h+1){\n\t\treps(j,1,w+1){\n\t\t\tif(gcd(i,j)==1){\n\t\t\t\tint sp = splitCount(i,j);\n\t\t\t\tans = max(ans, sp);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\t/*\n\treps(i,1,5){\n\t\treps(j,1,5){\n\t\t\tprintf(\"%d %d %d\\n\",i,j,gcd(i,j));\n\t\t}\n\t}*/\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define in_range(x,l,r) (l<=x && x<r)\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int dy[] = {-1,-1,0,0}, dx[] = {-1,0,0,-1};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int h,w;\n  cin >> h >> w;\n\n  vector<string> g(h);\n  rep(i,h)cin >> g[i];\n\n  map<pii,int> dif;\n  int init = -1, last = 1;\n  rep(i,h+1)rep(j,w+1){\n    \n    int cnt = 0;\n    rep(d,4){\n      int flag = 0;\n      int ny = i + dy[d], nx = j + dx[d];\n      if(in_range(ny,0,h) && in_range(nx,0,w) && g[ny][nx]=='#')flag++;\n      ny = i + dy[(d+1)%4]; nx = j + dx[(d+1)%4];\n      if(in_range(ny,0,h) && in_range(nx,0,w) && g[ny][nx]=='#')flag++;\n\n      //cout << i << \" \" << j << \" \" << d << \" \" << flag << endl;\n      if(flag==1){\n\tif((d+1)%4>=2)cnt--;\n\telse cnt++;\n      }\n    }\n\n    int y = h-i, x = j;\n    if(y==0 && x==0)continue;\n    else if(y==0)init += cnt;\n    else if(x==0)last += cnt;\n    else{\n      int gcd = __gcd(y,x);\n      pii key = pii(y/gcd, x/gcd);\n      dif[key] += cnt;\n    }\n  }\n\n  vector< pair<double,int> > event;\n  for(auto p : dif){\n    event.push_back( make_pair( (double)p.first.first/p.first.second, p.second ) );\n  }\n  sort(event.begin(), event.end());\n  \n  int res = init, cur = init;\n  //cout << init << endl;\n  for(auto p : event){\n    //cout << p.first << \" \" << p.second << endl;\n    cur += p.second;\n    res = max(res, cur);\n  }\n  //cout << last << endl;\n\n  res = max(res, res+last);\n  cout << (res+1)/2 + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <iostream>\n\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n//typedef tuple<int, int, int> T;\ntypedef pair<ll, ll> Pl;\n//typedef tuple<ll, ll, ll> Tl;\n\nnamespace Ps{\n\tconst double EPS=1e-8,INF=1e12;\n#define X real()\n#define Y imag()\n\ttypedef complex<double> P;\n}\nusing namespace Ps;\nnamespace Ls{\n\tstruct L:public vector<P>{\n\t\tL(const P&a,const P&b){\n\t\t\tpush_back(a);push_back(b);\n\t\t}\n\t};\n}\nusing namespace Ls;\n\n\nclass Seg{\npublic:\n\tdouble l,r;\n\tSeg(double l,double r):l(l),r(r){\n\t}\n\n\tbool operator < (const Seg& rt) const{\n\t\treturn l<rt.l;\n\t}\n};\n\nint main() {\n\tint H,W;cin >> H >> W;\n\tvector<string> board(H+2);\n\tfor(int y=0;y<H;y++){\n\t\tstringstream ss;string s;\n\t\tss<<\".\";\n\t\tcin >> s;\n\t\tss<< s;\n\t\tss<<\".\";\n\t\tboard[y]=ss.str();\n\t}\n\n\tvector<L> ls;\n\n\t// -\n\tfor(int y=1;y<=H+1;y++){\n\t\tint x=1;\n\t\tfor(;x<=W+1;x++){\n\t\t\tif(board[y][x]=='.' && board[y-1][x]=='#'){\n\t\t\t\tP p1(y,x);\n\t\t\t\tx++;\n\t\t\t\twhile(board[y][x]=='.' && board[y-1][x]=='#'){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tP p2(y,x);\n\t\t\t\tls.push_back(L(p1,p2));\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tif(board[y][x]=='#' && board[y-1][x]=='.'){\n\t\t\t\tP p1(y,x);\n\t\t\t\tx++;\n\t\t\t\twhile(board[y][x]=='#' && board[y-1][x]=='.'){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tP p2(y,x);\n\t\t\t\tls.push_back(L(p1,p2));\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t}\n\n\t// |\n\tfor(int x=1;x<=W+1;x++){\n\t\tint y=1;\n\t\tfor(;y<=H+1;y++){\n\t\t\tif(board[y][x]=='.' && board[y][x-1]=='#'){\n\t\t\t\tP p1(y,x);\n\t\t\t\ty++;\n\t\t\t\twhile(board[y][x]=='.' && board[y][x-1]=='#'){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tP p2(y,x);\n\t\t\t\tls.push_back(L(p1,p2));\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tif(board[y][x]=='#' && board[y][x-1]=='.'){\n\t\t\t\tP p1(y,x);\n\t\t\t\ty++;\n\t\t\t\twhile(board[y][x]=='#' && board[y][x-1]=='.'){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tP p2(y,x);\n\t\t\t\tls.push_back(L(p1,p2));\n\t\t\t\ty--;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<Seg> ss;\n\tfor(int i=0;i<ls.size();i++){\n\n\t\tss.push_back(Seg(min(arg(ls[i][0]),arg(ls[i][1])+EPS),1));\n\t\tss.push_back(Seg(max(arg(ls[i][0]),arg(ls[i][1])-EPS),-1));\t\t\n\t}\n\tsort(ss.begin(),ss.end());\n\n\n\tint Mv=0,v=0;\n\tfor(int i=0;i<ss.size();i++){\n\t\tv+=ss[i].r;\n\t\tMv=max(Mv,v);\n\t}\n\n\tcout << (Mv/2 + 1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct I{I(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\nconst double eps=1e-10;\nint main(){\n    int R,C,res=0;\n    cin>>R>>C;\n    vector<string> f(R);\n    for(int i=0;i<R;i++){\n        cin>>f[i];f[i]+=\"..\";\n    }\n    reverse(f.begin(),f.end());\n    f.push_back(string(C+2,'.'));\n    f.push_back(string(C+2,'.'));\n    using T=tuple<int,int>;\n    map<double,T> d;\n    for(int i=1;i<=R;i++)\n        for(int j=1;j<=C;j++){\n            auto dd=atan2(i,j);\n            if(d.count(dd))d[dd]=min(d[dd],T(i,j));\n            else d[dd]=T(i,j);\n        }\n    vector<int> X(R,C+1);\n    vector<int> Y(C,1);\n    for(auto &it:d){\n        int cross=0;\n        if(f[0][0]=='#')cross++;\n        int l=0,m=0,r=0;\n        int x,y;\n        tie(x,y)=it.second;\n        double k=y/(double)x;\n        for(int i=0;i<R;i++){\n            double yy=k*(i+1);\n            while(yy+eps<X[i])X[i]--;\n            if(yy-eps<X[i]&&X[i]<yy+eps){\n                int mask=0;\n                if(f[i][X[i]-1]=='#')mask|=1;\n                if(f[i][X[i]]=='#')mask|=2;\n                if(f[i+1][X[i]-1]=='#')mask|=4;\n                if(f[i+1][X[i]]=='#')mask|=8;\n                switch(mask){\n                case 0:\n                case 15:break;\n                case 13:\n                case 2:r+=2;break;\n                case 11:\n                case 4:l+=2;break;\n                default:cross++;break;\n                }\n\n            }\n            else{\n                if(f[i][X[i]]!=f[i+1][X[i]])cross++;\n            }\n        }\n        k=x/(double)y;\n        for(int i=0;i<C;i++){\n            double xx=k*(i+1);\n            while(xx-eps>Y[i]&&Y[i]<=R)Y[i]++;\n            if(xx-eps<Y[i]&&Y[i]<xx+eps)continue;\n            if(f[Y[i]-1][i]!=f[Y[i]-1][i+1])cross++;\n        }\n        //cout<<x<<\" \"<<y<<endl;\n        //if(x==3&&y==8)cout<<cross<<\" \"<<l<<\" \" <<r<<endl;\n        res=max(res,1+(cross+max({l,r}))/2);\n        //cout<<res<<endl;\n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// OBïÄh2011 Day4 A : åKåNÌ\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint main(){\n\tint H, W;\n\tstring f[600];\n\twhile(cin >> H >> W){\n\t\tfor(int i=H-1;i>=0;i--) cin >> f[i];\n\n\t\tvector< pair<double, int> > vd;\n\t\t// ÌæªÏíé¸_ð²×é.\n\t\t// X«(j/i)ðå«­µ½Æ«ÌÌæÌ¸àÁÄ¨­\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=0;j<=W;j++){\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i-k%2, nj = j-k/2;\n\t\t\t\t\tif(0<=ni&&ni<H&&0<=nj&&nj<W&&f[ni][nj]=='#') cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt%2 == 1){\n\t\t\t\t\tif(0<=i-1&&i-1<H&&0<=j&&j<W&&f[i-1][j]==(cnt==1?'#':'.'))\n\t\t\t\t\t\tvd.push_back(make_pair((double)j/i,  1));\n\t\t\t\t\tif(0<=i&&i<H&&0<=j-1&&j-1<W&&f[i][j-1]==(cnt==1?'#':'.'))\n\t\t\t\t\t\tvd.push_back(make_pair((double)j/i, -1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vd.begin(), vd.end());\n\n\t\tint res = 1, cur = 1;\n\t\t// X«ðå«­µÄ¢«AÌæÌ¸ð²×é\n\t\tfor(int i=0;i<vd.size(); ){\n\t\t\tint idx = i;\n\t\t\twhile(idx < vd.size() && abs(vd[i].first-vd[idx].first) < EPS)\n\t\t\t\tcur += vd[idx++].second;\n\t\t\ti = idx;\n\t\t\tres = max(cur, res);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nstring F[600];\n\nbool isgrid(int x, int y)\n{\n  return (0 <= x && x < W && 0 <= y && y < H && F[y][x] == '#');\n}\n\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> F[i];\n  }\n\n  vector< pair< pair< int, int >, int > > Event;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(isgrid(j, i) && !isgrid(j, i - 1) && !isgrid(j - 1, i))\n        Event.push_back({{j, H - i}, 1});\n      else if(!isgrid(j, i) && isgrid(j, i - 1) && isgrid(j - 1, i))\n        Event.push_back({{j, H - i}, 1});\n      else if(isgrid(j, i) && !isgrid(j, i + 1) && !isgrid(j + 1, i))\n        Event.push_back({{j + 1, H - i - 1}, -1});\n      else if(!isgrid(j, i) && isgrid(j, i + 1) && isgrid(j + 1, i))\n        Event.push_back({{j + 1, H - i - 1}, -1});\n    }\n  }\n\n  sort(begin(Event), end(Event), [](auto &a, auto &b)\n  {\n    int c = a.first.first * b.first.second;\n    int d = a.first.second * b.first.first;\n    if(c == d) return (a.second < b.second);\n    return (c < d);\n  });\n\n\n  int proc = 1, ret = 1;\n  for(auto &k : Event) {\n    proc += k.second;\n    ret = max(ret, proc);\n  }\n\n  cout << ret << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\nint f[605][605];\nvector<int> vec;\n\nint main(void)\n{\n\tcin >> H >> W;\n\t\n\tchar c;\n\tfor(int y = H-1; y >= 0; y--){\n\t\tfor(int x = 0; x < W; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == '#') f[x][y] = 1;\n\t\t\telse f[x][y] = 0;\n\t\t}\n\t}\n\t\n\tint ans = 0, cnt, x, y, px, py, prev;\n\tfor(int bx = 1; bx <= W; bx++){\n\t\tfor(int by = 1; by <= H; by++){\n\t\t\tvec.clear();\n\t\t\t\n\t\t\tpx = 2*bx, py = 2*by-1;\n\t\t\tif(px > py){\n\t\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\t\ty = x*py/px;\n\t\t\t\t\tif(x % px){\n\t\t\t\t\t\tvec.push_back(f[x-1][y]);\n\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvec.push_back(f[x-1][y-1]);\n\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int y = 1; y <= H; y++){\n\t\t\t\t\tx = y*px/py;\n\t\t\t\t\tif(y % py){\n\t\t\t\t\t\tvec.push_back(f[x][y-1]);\n\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvec.push_back(f[x-1][y-1]);\n\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcnt = prev = 0;\n\t\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\t\tif(prev != vec[i]) cnt++;\n\t\t\t\tprev = vec[i];\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t}\n\t\n\tfor(int bx = 1; bx <= W; bx++){\n\t\tfor(int by = 1; by <= H; by++){\n\t\t\tvec.clear();\n\t\t\t\n\t\t\tpx = 2*bx-1, py = 2*by;\n\t\t\tif(px > py){\n\t\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\t\ty = x*py/px;\n\t\t\t\t\tif(x % px){\n\t\t\t\t\t\tvec.push_back(f[x-1][y]);\n\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvec.push_back(f[x-1][y-1]);\n\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int y = 1; y <= H; y++){\n\t\t\t\t\tx = y*px/py;\n\t\t\t\t\tif(y % py){\n\t\t\t\t\t\tvec.push_back(f[x][y-1]);\n\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvec.push_back(f[x-1][y-1]);\n\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcnt = prev = 0;\n\t\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\t\tif(prev != vec[i]) cnt++;\n\t\t\t\tprev = vec[i];\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t}\n\t\n\tcout << ans / 2 + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\nint H,W;\nstring s[601];\nD EPS=1e-8;\nvector<D> ts;\nbool dx[601][601],dy[601][601];\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[H-1-i];\n\trep1(x,W) rep1(y,H){\n\t\tts.pb((D)y/x+EPS);\n\t\tts.pb((D)y/x-EPS);\n\t}\n\ts[H].assign(W,'.');\n\trep(i,H+1) s[i]+='.';\n\trep(i,H) rep(j,W+1) dx[i][j]=(s[i][j]==s[i+1][j]);\n\trep(i,H+1) rep(j,W) dy[i][j]=(s[i][j]==s[i][j+1]);\n\tsort(all(ts));\n\tts.erase(unique(all(ts)),ts.end());\n\tint mx=0;\n\tfor(D t:ts){\n\t\tint cnt=0;\n\t\trep1(x,W){\n\t\t\tint y=floor(t*x);\n\t\t\tif(y<H&&!dy[y][x-1]) cnt++;\n\t\t}\n\t\trep1(y,H){\n\t\t\tint x=floor(y/t);\n\t\t\tif(x<W&&!dx[y-1][x]) cnt++;\n\t\t}\n\t\tmx=max(mx,cnt);\n\t}\n\tcout<<(mx+3)/2<<endl;\n}\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\nint H,W;\nstring s[601];\nD EPS=1e-8;\nvector<D> ts;\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[H-1-i];\n\trep1(x,W) rep1(y,H){\n\t\tts.pb((D)y/x+EPS);\n\t\tts.pb((D)y/x-EPS);\n\t}\n\ts[H].assign(W,'.');\n\trep(i,H+1) s[i]+='.';\n\tsort(all(ts));\n\tts.erase(unique(all(ts)),ts.end());\n\tint mx=0;\n\tfor(D t:ts){\n\t\tint cnt=0;\n\t\trep1(x,W){\n\t\t\tint y=floor(t*x);\n\t\t\tif(y<H&&s[y][x-1]!=s[y][x]) cnt++;\n\t\t}\n\t\trep1(y,H){\n\t\t\tint x=floor(y/t);\n\t\t\tif(x<W&&s[y-1][x]!=s[y][x]) cnt++;\n\t\t}\n\t\tmx=max(mx,(cnt+1)/2+1);\n\t}\n\tcout<<mx<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble EPS = 1e6;\nclass P{\npublic:\n    int x, y;\n    P(){};\n    P(int x, int y): x(x), y(y){};\n    \n    bool operator < (const P &r)const{\n        return 0 < x*r.y - y*r.x;\n    }\n    bool operator == (const P &r)const{\n        return 0 == x*r.y - y*r.x;\n    }\n};\n\ntypedef pair<P, P> Span;\n\nint H, W;\nvector<string> field;\n\n//up, down, right, left\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n\nSpan make_span(double h, double w, int dir){\n    P l, r;\n    if(dir == 0){ //up\n        l = P(w+1, h+1);\n        r = P(w, h+1);\n    }\n    if(dir == 1){ //down\n        l = P(w+1, h);\n        r = P(w, h);\n    }\n    if(dir == 2){ //right\n        l = P(w+1, h);\n        r = P(w+1, h+1);\n    }\n    if(dir == 3){ //left\n        l = P(w, h);\n        r = P(w, h+1);\n    }\n    return Span(l, r);\n}\n\nint main(){\n    cin >> H >> W;\n    field.resize(H+1);\n    for(int i=0; i<W+1; i++)\n        field[H] += '.';\n    \n    for(int i=0; i<H; i++){\n        cin >> field[H-1-i];\n        field[H-1-i] += '.';\n    }\n    \n    vector<Span> spans; //??????\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++) if(field[h][w] == '#'){\n            for(int i=0; i<4; i++){\n                int nh = h + dh[i];\n                int nw = w + dw[i];\n                if(nh<0 || nw<0 || H<nh || W<nw || field[nh][nw]!='.') continue;\n                \n                spans.push_back(make_span(h, w, i));\n            }\n        }\n    }\n    vector<P> tmp;\n    for(auto span: spans)\n        tmp.push_back(span.first), tmp.push_back(span.second);\n    sort(tmp.begin(), tmp.end());\n    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n\n    vector<int> cum(tmp.size());\n    for(auto &span: spans){\n        int l = lower_bound(tmp.begin(), tmp.end(), span.first) - tmp.begin();\n        int r = lower_bound(tmp.begin(), tmp.end(), span.second) - tmp.begin();\n        for(int i=l; i<r; i++)\n            cum[i]++;\n    }\n    \n    int ans = 0;\n    for(int i=0; i<cum.size(); i++)\n        ans = max(ans, cum[i]);\n    if(field[0][0] == '#')\n        ans++;\n    cout << ans/2 + 1 << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nstring F[600];\n\nbool isgrid(int x, int y)\n{\n  return (0 <= x && x < W && 0 <= y && y < H && F[y][x] == '#');\n}\n\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> F[i];\n  }\n\n  vector< pair< pair< int, int >, int > > Event;\n  for(int i = -1; i <= H; i++) {\n    for(int j = -1; j <= W; j++) {\n      if(!isgrid(j, i) && !isgrid(j + 1, i) && !isgrid(j, i + 1) && isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, 1});\n      else if(isgrid(j, i) && isgrid(j + 1, i) && isgrid(j, i + 1) && !isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, 1});\n      else if(isgrid(j, i) && !isgrid(j + 1, i) && !isgrid(j, i + 1) && !isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, -1});\n      else if(!isgrid(j, i) && isgrid(j + 1, i) && isgrid(j, i + 1) && isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, -1});\n    }\n  }\n\n  sort(begin(Event), end(Event), [](auto &a, auto &b)\n  {\n    int c = a.first.first * b.first.second;\n    int d = a.first.second * b.first.first;\n    if(c == d) return (a.second < b.second);\n    return (c < d);\n  });\n\n\n  int proc = 1, ret = 1;\n  for(auto &k : Event) {\n    proc += k.second;\n    ret = max(ret, proc);\n  }\n\n  cout << ret << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<double,int> P;\n\n\nint H,W;\nstring str;\n\nvector <P> u;\nchar t[600][600];\n\nchar T(int y,int x){\n  if(y<0||x<0)return '.';\n  if(y>=H||x>=W)return '.';\n  return t[y][x];\n}\nint main(){\n\n  double a,x,y;\n\n  while(cin>>H>>W){\n    u.clear();\n    for(int i=H-1;i>=0;i--){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n      }\n    }\n    \n    \n    for(int i=-1;i<H;i++){\n      for(int j=-1;j<W;j++){\n\tif(T(i,j)=='#'&&T(i+1,j)=='#'&&T(i,j+1)=='.'&&T(i+1,j+1)=='#'){\n\t  x=j+1;y=i+1;\n\t  a=acos( (x)/(sqrt(x*x+y*y)) );\n\t  u.push_back(P(a,-1));\n\t}\n\tif(T(i,j)=='.'&&T(i+1,j)=='#'&&T(i,j+1)=='.'&&T(i+1,j+1)=='.'){\n\t  x=j+1;y=i+1;\n\t  a=acos( (x)/(sqrt(x*x+y*y)) );\n\t  u.push_back(P(a,1));\n\t}\n\tif(T(i,j)=='#'&&T(i+1,j)=='.'&&T(i,j+1)=='#'&&T(i+1,j+1)=='#'){\n\t  x=j+1;y=i+1;\n\t  a=acos( (x)/(sqrt(x*x+y*y)) );\n\t  u.push_back(P(a,1));\n\t}\n\tif(T(i,j)=='.'&&T(i+1,j)=='.'&&T(i,j+1)=='#'&&T(i+1,j+1)=='.'){\n\t  x=j+1;y=i+1;\n\t  a=acos( (x)/(sqrt(x*x+y*y)) );\n\t  u.push_back(P(a,-1));\n\t}\n      }\n    }\n    \n    int cnt=1,ans=1;\n    sort(u.begin(),u.end());\n    for(int i=0;i<(int)u.size();i++){\n      \n      cnt+=u[i].second;\n      ans=max(ans,cnt);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9 + 7;\n\n\nsigned main(){\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    for(int i = 0; i < h; ++i){\n        cin >> s[i];\n        for(int j = 0; j < 3; ++j)\n            s[i] += '.';\n    }\n    reverse(s.begin(), s.end());\n    for(int i = 0; i < 3; ++i){\n        string t = \"\";\n        for(int j = 0; j < w + 3; ++j)\n            t += '.';\n        s.emplace_back(t);\n    }\n\n    /*\n    for(auto& x : s)\n        cout << x << endl;\n    */\n\n    auto f = [&](double rot){\n        double x = 0;\n        double y = 0;\n        bool fl = s[0][0] == '#';\n        int cnt = fl;\n\n        while(x <= h && y <= w){\n            // y = x * rot\n            double xx = ceil(x + 1e-9);\n            double xy = xx * rot;\n\n            double yy = ceil(y + 1e-9);\n            double yx = yy / rot;\n\n            if(xx < yx){\n                x = xx;\n                y = xy;\n            }else{\n                x = yx;\n                y = yy;\n            }\n            bool nex = s[int(x + 1e-9)][int(y + 1e-9)] == '#';\n            cnt += fl ^ nex;\n            fl = nex;\n        }\n        return cnt;\n    };\n    int ma = 0;\n    set<double> se;\n    for(int i = 1; i <= h + 1; ++i)\n        for(int j = 1; j <= w + 1; ++j)\n            if(i && j){\n                if(s[i][j] != s[i - 1][j - 1] || s[i][j - 1] != s[i - 1][j]){\n                    int cnt = (s[i][j] == '#') + (s[i - 1][j - 1] == '#')\n                            + (s[i - 1][j] == '#') + (s[i][j - 1] == '#');\n                    if(cnt == 2 || cnt == 0 || cnt == 4)\n                        continue;\n                    if(cnt == 1 && (s[i][j] == '#' || s[i - 1][j - 1] == '#'))\n                        continue;\n                    if(cnt == 3 && !(s[i][j] == '#' && s[i - 1][j - 1] == '#'))\n                        continue;\n                    se.emplace(1.0 * j / i);\n                    se.emplace(1.0 * j / i - 1e-8);\n                    se.emplace(1.0 * j / i + 1e-8);\n                }\n            }\n    se.emplace(1);\n    for(auto& rot : se){\n        int ret = f(rot);\n        ma = max(ma, ret);\n    }\n    cout << ma / 2 + 1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H + 2, vector<int>(W + 2));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '#') {\n\t\t\t\tfield[H- i][j + 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<Line>walls;\n\tfor (int x = 0; x < W + 1; ++x) {\n\t\tfor (int y = 0; y < H + 2; ++y) {\n\t\t\tif (field[y][x]^field[y][x + 1]) {\n\t\t\t\twalls.push_back(Line(Point(x + 1, y + 1), Point(x+1, y)));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < W + 2; ++x) {\n\t\tfor (int y = 0; y < H + 1; ++y) {\n\t\t\tif (field[y][x] ^ field[y+1][x]) {\n\t\t\t\twalls.push_back(Line(Point(x, y + 1), Point(x + 1, y + 1)));\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (int x = 1; x < W + 1; ++x) {\n\t\tfor (int y = 1; y < H + 1; ++y) {\n\t\t\tif(gcd(x,y)==1)tans.emplace_back(ld(y) / x);\n\t\t\t\n\t\t}\n\t}\n\ttans.emplace_back(0);\n\ttans.emplace_back(-1e18);\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int t = 0; t < tans.size()-1; ++t) {\n\t\t\tntans.emplace_back((tans[t + 1] + tans[t]) / 2);\n\t\t}\n\t\ttans = ntans;\n\t}\n\tint ans = 0;\n\tfor (auto t : tans) {\n\t\tint num = 0;\n\t\tLine l(Point(1, 1), Point(2, t+1));\n\t\tfor (auto w : walls) {\n\t\t\tif (isis_ls(l, w))num++;\n\t\t}\n\t\tans = max(ans, (num + 1) / 2);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int W = 666;\nconst int INF = 1000000007;\nint h,w;\nvector<string> board;\n\nbool input(){\n\tcin>>h>>w;\n\tboard.clear();\n\trep(i,h){\n\t\tstring s;\n\t\tcin>>s;\n\t\tboard.pb(s);\n\t}\n\treturn true;\n}\n\nint gcd(int n, int m) {\n\treturn (n % m) ? gcd(m, n %m) : m;\n}\n\nint isBlock(char c){\n\tif(c=='#')return 1;\n\treturn 0;\n}\n\nint getState(int y,int x){\n\tint ret = 0;\n\tret += (1<<0)*isBlock(board[y][x-1]);\n\tret += (1<<1)*isBlock(board[y][x]);\n\tret += (1<<2)*isBlock(board[y-1][x-1]);\n\tret += (1<<3)*isBlock(board[y-1][x]);\n\treturn ret;\n}\n\nint getCountUp(int y,int x){\n\tint state = getState(y,x);\n\t\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 2;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 0;\n\t\tcase 8:return 0;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 2;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n}\n\nint getCountDown(int y,int x){\n\t\n\tint state = getState(y,x);\n\t\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 0;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 2;\n\t\tcase 8:return 2;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 0;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n}\n\nint splitCount(int y,int x){\n\t\n\t\n\t\n\tint countUp = 0;\n\tint countDown = 0;\n\t\n\treps(i,1,w+1){\n\t\tdouble dy = (double)y/x;\n\t\tif(i%x==0){\n\t\t\tint ny = y*(i/x);\n\t\t\tint nx = i;\n\t\t\tif(ny>h)break;\n\t\t\t\n\t\t\tint dup = getCountUp(ny,nx);\n\t\t\tint ddown = getCountDown(ny,nx);\n\t\t\t\n\t\t\tif(x==2 && y==1 || true){\n\t\t\t\t//printf(\"nx=%d  ny=%d,  dup=%d  ddown=%d\\n\",nx,ny,dup,ddown);\n\t\t\t}\n\t\t\t\n\t\t\tcountUp += dup;\n\t\t\tcountDown += ddown;\n\t\t}\n\t}\n\t\n\treps(i,1,w+1){\n\t\tdouble dy = (double)y/x;\n\t\tif(i%x!=0){\n\t\t\tdouble ny = dy*i;\n\t\t\t\n\t\t\tint nh = (int)ny;\n\t\t\tif(nh>h)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[nh][i-1];\n\t\t\tchar right = board[nh][i];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\treps(i,1,h+1){\n\t\t\n\t\tdouble dx = (double)x/y;\n\t\tif(i%y!=0){\n\t\t\tdouble nx = dx*i;\n\t\t\t\n\t\t\tint nh = (int)nx;\n\t\t\tif(nh>w)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[i-1][nh];\n\t\t\tchar right = board[i][nh];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans1 = (countUp+1)/2 + 1;\n\tint ans2 = (countDown+1)/2 + 1;\n\t\n\t//printf(\"x=%d y=%d  up=%d  down=%d\\n\",x,y,countUp, countDown);\n\t\n\treturn max(ans1, ans2);\n}\n\nvoid addBanpei(){\n\treverse(board.begin(), board.end());\n\trep(i,board.size()){\n\t\tboard[i] += \".\";\n\t}\n\tstring tmp = \"\";\n\trep(i,w+1)tmp += \".\";\n\tboard.pb(tmp);\n}\n\nvoid solve(){\n\t\n\taddBanpei();\n\t\n\tint ans = 0;\n\treps(i,1,h+1){\n\t\treps(j,1,w+1){\n\t\t\tif(gcd(i,j)==1){\n\t\t\t\tint sp = splitCount(i,j);\n\t\t\t\tans = max(ans, sp);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\t/*\n\treps(i,1,5){\n\t\treps(j,1,5){\n\t\t\tprintf(\"%d %d %d\\n\",i,j,gcd(i,j));\n\t\t}\n\t}*/\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1);\nint sig(double r){return (r<-EPS)?-1:(r>+EPS)?+1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y): x(x),y(y){}\n\tPt operator+(const Pt&a)const {return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt&a)const {return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt&a)const {return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt&a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt&a)const{return x*a.y-y*a.x;}\n};\ninline Pt pLL(Pt a,Pt b,Pt c,Pt d){\n\tb=b-a;d=d-c;return a+b*(c-a).det(d)/b.det(d);\n}\nchar str[700][700];\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;\n\t\tint c=b;\n\t\tb=a;\n\t\ta=c;\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[a-1-i]);\n\tint ret=0;\n\t\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(gcd(i+1,j+1)>1)continue;\n\t\t\tint val=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,(1e-8)+j+1),Pt(k+1,0),Pt(k+1,1));\n\t\t\t\tint d=(int)(t.y);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tif(str[k][d]=='#'&&str[k+1][d]!='#')val++;\n\t\t\t\tif(str[k][d]!='#'&&str[k+1][d]=='#')val++;\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,(1e-8)+j+1),Pt(0,k+1),Pt(1,k+1));\n\t\t\t\tint d=(int)(t.x);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tif(str[d][k]=='#'&&str[d][k+1]!='#')val++;\n\t\t\t\tif(str[d][k]!='#'&&str[d][k+1]=='#')val++;\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t\tval=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,-(1e-8)+j+1),Pt(k+1,0),Pt(k+1,1));\n\t\t\t\tint d=(int)(t.y);\n\t\t\t\tif(d>=b)continue;\n\t\t\t\tif(str[k][d]=='#'&&str[k+1][d]!='#')val++;\n\t\t\t\tif(str[k][d]!='#'&&str[k+1][d]=='#')val++;\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,-(1e-8)+j+1),Pt(0,k+1),Pt(1,k+1));\n\t\t\t\tint d=(int)(t.x);\n\t\t\t\tif(d>=a)continue;\n\t\t\t\tif(str[d][k]=='#'&&str[d][k+1]!='#')val++;\n\t\t\t\tif(str[d][k]!='#'&&str[d][k+1]=='#')val++;\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t}\n\t}\n\tif(str[0][0]=='#')ret++;\n\tprintf(\"%d\\n\",1+ret/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define ALL(x) x.begin(), x.end()\nusing namespace std;\ntypedef complex<double> Point;\n#define ALL(x) x.begin(), x.end()\nconst double EPS = 1e-9;\nchar A[606][606];\nchar pat[4][2][2] = {\n    {{'#', '.'}, {'.', '.'}}, {{'.', '#'}, {'#', '#'}}, {{'.', '.'}, {'.', '#'}}, {{'#', '#'}, {'#', '.'}}};\n\nint check(int x, int y) {\n    vector<bool> same(4, true);\n    REP(k, 4) {\n        REP(i, 2) REP(j, 2) {\n            if (A[x + i][y + j] != pat[k][i][j]) same[k] = false;\n        }\n    }\n    if (same[0] || same[1])\n        return 1;\n    else if (same[2] || same[3])\n        return -1;\n    else\n        return 0;\n}\nconst double PI = acos(-1);\nvoid solve() {\n    int H, W;\n    cin >> H >> W;\n    REP(i, H + 2) REP(j, W + 2) { A[i][j] = '.'; }\n    REP(i, H) {\n        REP(j, W) { cin >> A[i + 1][j + 1]; }\n    }\n    H += 2, W += 2;\n    vector<pair<double, int>> v;\n    vector<pair<double, pair<int, int>>> v2;\n    REP(i, H - 1) {\n        REP(j, W - 1) {\n            int c = check(i, j);\n            if (c == 0) continue;\n            // cout << i << \" \" << j << \" \" << c << endl;\n            double x = j, y = H - i - 2;\n            Point p = {x, y};\n            double theta = atan2(y, x);\n            // cout << theta * 180 / PI << endl;\n            v.push_back({theta, c});\n            v2.push_back({theta, {i, j}});\n        }\n    }\n    sort(ALL(v));\n    // v.push_back({100, 0});\n    int M = v.size();\n    int ans = 2;\n    int cur = 1;\n    sort(ALL(v2));\n    REP(i, M) {\n        cur += v[i].second;\n        // if (abs(v[i + 1].first - v[i].first) < EPS) continue;\n        // if (cur == 9) {\n        //     cout << v[i].first * 180 / PI << endl;\n        //     int x = v2[i].second.first, y = v2[i].second.second;\n        //     cout << v2[i].second.first << \" \" << v2[i].second.second << endl;\n        //     A[x][y] = 'o';\n        // }\n        ans = max(ans, cur);\n    }\n\n    // REP(i, H) {\n    //     REP(j, W) { cout << A[i][j]; }\n    //     cout << endl;\n    // }\n    // cout << cur << endl;\n    cout << ans << endl;\n}\nsigned main() { solve(); }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconstexpr double EPS = 1e-4;\n\nstruct point {\n    double x, y;\n    point() {}\n    point(double x, double y): x(x), y(y) {}\n\n    point operator + (const point& o) const { return point(x+o.x, y+o.y); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y); }\n    point operator * (const double a) const { return point(x*a, y*a); }\n\n    bool operator < (const point& o) const { return x == o.x ? y < o.y : x < o.x; }\n    bool operator == (const point& o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble fabs(point a) { return sqrt(a.x*a.x + a.y*a.y); }\ndouble dist(point a, point b) { return fabs(a - b); }\ndouble dist(line l) { return dist(l.a, l.b); }\ndouble dot(point a, point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(point a, point b) { return a.x*b.y - a.y*b.x; }\n\ndouble dist_point_line(point p, line l) {\n    if (dot(p - l.a, l.b - l.a) >= 0 && dot(p - l.b, l.a - l.b) >= 0)\n        return fabs(cross(p - l.a, l.b - l.a)) / dist(l);\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nbool has_intersection(line s, line t) {\n    double s1 = cross(s.b - s.a, t.a - s.b) * cross(s.b - s.a, t.b - s.b);\n    double s2 = cross(t.b - t.a, s.a - t.a) * cross(t.b - t.a, s.b - t.a);\n    if (s1 < 0 && s2 < 0) return true;\n    else if (s1 * s2 == 0) {\n        double d1 = dist_point_line(s.a, t);\n        double d2 = dist_point_line(s.b, t);\n        double d3 = dist_point_line(t.a, s);\n        double d4 = dist_point_line(t.b, s);\n        return min(min(d1, d2), min(d3, d4)) == 0;\n    }\n    return false;\n}\n\npoint intersection(line s, line t) {\n    double c1 = fabs(cross(t.b - t.a, s.a - t.a));\n    double c2 = fabs(cross(t.b - t.a, s.b - t.a));\n    return s.a + (s.b - s.a) * (c1 / (c1 + c2));\n}\n\nint H, W;\nint block[605][605];\n\nvector<line> ls;\nvector<point> ps;\n\nint main(void) {\n    cin >> H >> W;\n    for (int i = 0; i <= H; ++i) fill(block[i], block[i]+W+1, 0);\n    for (int i = 0 ; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            char ch; cin >> ch;\n            block[i][j] = (ch == '#') ? 1 : 0;\n        }\n    }\n\n    for (int i = 0; i <= H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if ((i == 0 && block[i][j] == 1) || (i > 0 && (block[i][j] ^ block[i-1][j]))) {\n                int lj = j++;\n                while (j < W) {\n                    if ((i == 0 || block[i-1][j] == block[i-1][lj]) &&\n                        block[i][j] == block[i][lj])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(i, lj), point(i, j));\n                ps.emplace_back(i, lj);\n                ps.emplace_back(i, j);\n                --j;\n            }\n        }\n    }\n\n    for (int i = 0; i <= W; ++i) {\n        for (int j = 0; j < H; ++j) {\n            if ((i == 0 && block[j][i] == 1) || (i > 0 && (block[j][i] ^ block[j][i-1]))) {\n                int lj = j++;\n                while (j < H) {\n                    if ((i == 0 || block[j][i-1] == block[lj][i-1]) &&\n                        block[j][i] == block[lj][i])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(lj, i), point(j, i));\n                ps.emplace_back(lj, i);\n                ps.emplace_back(j, i);\n                --j;\n            }\n        }\n    }\n\n    ps.emplace_back(H, W);\n    ps.emplace_back(0, 0);\n    sort(begin(ps), end(ps), [](point p, point q) {\n        if (p.y == 0 && q.y == 0) return p.x < q.x;\n        if (p.y == 0) return false;\n        if (q.y == 0) return true;\n        double a1 = (H - p.x) / p.y;\n        double a2 = (H - q.x) / q.y;\n        return a1 == a2 ? p.y < q.y : a1 < a2;\n    });\n\n    int ans = 0;\n\n    point left_bottom(H, 0);\n    for (int i = 0; i < ps.size()-1; ++i) {\n        point p1 = ps[i], p2 = ps[i+1];\n        point end1 = left_bottom + (p1 - left_bottom) * 1000;\n        point end2 = left_bottom + ((p1+p2)*0.5 - left_bottom) * 1000;\n\n        line tiros[2] = {line(left_bottom, end1), line(left_bottom, end2)};\n        for (line tiro : tiros) {\n            set<point> cs;\n            for (line l : ls) {\n                if (has_intersection(tiro, l))\n                    cs.insert(intersection(tiro, l));\n            }\n\n            ans = max(ans, (int)cs.size()/2 + 1);\n\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 1000\n#define INF 1e9\ntypedef pair<double,int> P;\n \nint H,W;\n \ndouble make(int x,int y){\n    if(x == 0) return INF;\n    return (double)y / x;\n}\n \nint pat(char a,char b,char c,char d){\n    if(a == '.' && b == '#' && \n       c == '#' && d == '#'){\n\treturn 1;\n    }\n    if(a == '#' && b == '.' && \n       c == '.' && d == '.'){\n\treturn 1;\n    }\n    if(a == '.' && b == '.' && \n       c == '.' && d == '#'){\n\treturn -1;\n    }\n    if(a == '#' && b == '#' && \n       c == '#' && d == '.'){\n\treturn -1;\n    }\n  \n    return 0;\n}\n \nint main(){\n    string in;\n    char a[MAX][MAX];\n \n    for(int i = 0 ; i < MAX ; i++){\n\tfor(int j = 0 ; j < MAX ; j++){\n\t    a[i][j] = '.';\n\t}\n    }\n \n    cin >> H >> W;\n    for(int i = H ; i > 0 ; i--){\n\tcin >> in;\n\tfor(int j = 1 ; j <= W ; j++){\n\t    a[i][j] = in[j-1];\n\t}\n    }\n \n    vector<P> v;\n    for(int i = 0 ; i <= H ; i++){\n\tfor(int j = 0 ; j <= W ; j++){\n\t    char u1 = a[i+1][j],u2 = a[i+1][j+1];\n\t    char u3 = a[i][j],u4 = a[i][j+1];\n\t    int n = pat(u1,u2,u3,u4);\n \n\t    if(n != 0){\n\t\tdouble r = make(j,i);\n\t\tv.push_back(P(r,n));\n\t    }\n\t}\n    }\n \n    sort(v.begin(),v.end());\n    int len = (int)v.size(),ans = 1,sum = 1;\n    for(int i = 0 ; i < len ; i++){\n\tsum += v[i].second;\n\tans = max(ans,sum);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fs first\n#define sc second\n#define mp make_pair\nusing namespace std;\ntypedef pair<pair<int,int>,int> pii;\n\nbool l(const pii &a,const pii &b){\n  int s1 = a.fs.sc*b.fs.fs, s2 = a.fs.fs*b.fs.sc;\n  if(s1==s2)return a.sc<b.sc;\n  if(a.fs.fs==0)return false;\n  if(b.fs.fs==0)return true;\n  return s1<s2;\n}\n\nint main(){\n  int h,w;\n  string f[999];\n  cin.tie(0);\n  std::ios::sync_with_stdio(0);\n  cin >> h >> w;\n\n  vector<pii> v;\n  rep(i,h){\n    cin >> f[i];\n    rep(j,w){\n      if( (i==0&&f[i][j]=='#') || (i!=0&&f[i][j]!=f[i-1][j]) ){\n\tv.push_back(mp(mp(j,h-i),-1));\n\tv.push_back(mp(mp(j+1,h-i),1));\n      }\n      if( (j==w-1&&f[i][j]=='#') || (j!=w-1&&f[i][j]!=f[i][j+1])){\n\tv.push_back(mp(mp(j+1,h-i),-1));\n\tv.push_back(mp(mp(j+1,h-i-1),1));\n      }\n    }\n  }\n\n  int res = 0, tmp = 0;\n  sort(v.begin(),v.end(),l);\n  rep(i,v.size()){\n    tmp += v[i].sc;\n    res = max(res,tmp);\n  }\n  cout << (res+3)/2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool rose(const vector<string>& g,int i,int j)\n{\n\treturn 0<=i && i<g.size() && 0<=j && j<g[0].size() && g[i][j]=='#';\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvector<string> g(h);\n\t\tfor(int i=0;i<h;i++) cin>>g[i];\n\t\treverse(begin(g),end(g));\n\t\t\n\t\tvector<tuple<int,int,int>> ts;\n\t\tfor(int i=0;i<=h;i++) for(int j=0;j<=w;j++){\n\t\t\tint a=rose(g,i-1,j-1),b=rose(g,i-1,j),c=rose(g,i,j-1),d=rose(g,i,j);\n\t\t\tif(a==b && a==d && a!=c) ts.emplace_back(i,j,1);\n\t\t\tif(a==c && a==d && a!=b) ts.emplace_back(i,j,-1);\n\t\t}\n\t\tsort(begin(ts),end(ts),[&](tuple<int,int,int> a,tuple<int,int,int> b){\n\t\t\tint i1,j1,x1,i2,j2,x2; tie(i1,j1,x1,i2,j2,x2)=tuple_cat(a,b);\n\t\t\treturn i1*(i2+j2)!=i2*(i1+j1)?i1*(i2+j2)<i2*(i1+j1):x1<x2;\n\t\t});\n\t\t\n\t\tint res=0,cnt=1;\n\t\tfor(auto t:ts) res=max(res,cnt+=get<2>(t));\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Arg {\n  int x, y, t;\n  bool operator < (const Arg &a) const {\n    if(y * a.x == a.y * x) return t < a.t;\n    else y * a.x < a.y * x;\n  }\n};\n\nint H, W;\nmap<int,map<int,char> > G;\n\nint main() {\n  cin >> H >> W;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> G[i][j];\n    }\n  }\n  vector<Arg> v;\n  for(int i = 0; i <= H; ++i) {\n    for(int j = 0; j <= W; ++j) {\n      bool a = G[i-1][j-1] == '#';\n      bool b = G[i-1][j]   == '#';\n      bool c = G[i][j-1]   == '#';\n      bool d = G[i][j]     == '#';\n      if( a && !b && !c && !d) v.push_back((Arg){j, H-i,  1});\n      if(!a &&  b &&  c &&  d) v.push_back((Arg){j, H-i,  1});\n      if(!a && !b && !c &&  d) v.push_back((Arg){j, H-i, -1});\n      if( a &&  b &&  c && !d) v.push_back((Arg){j, H-i, -1});\n    }\n  }\n  sort(v.begin(), v.end());\n  int now = 1, maxi = now;\n  for(int i = 0; i < v.size(); ++i) {\n    now += v[i].t;\n    maxi = max(maxi, now);\n  }\n  cout << maxi << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// container utility\n#define ALL(x) (x).begin(), (x).end()\n#define MP make_pair\n#define PB push_back\n\n// rep\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define rep(i,n) REP(i,0,n)\n\nint check(char grid[2][2]) {\n  if(grid[0][0] == '#'\n     && grid[0][1] == '.'\n     && grid[1][0] == '.'\n     && grid[1][1] == '.') {\n    return +1;\n  }\n   \n  if(grid[0][0] == '.'\n     && grid[0][1] == '#'\n     && grid[1][0] == '#'\n     && grid[1][1] == '#'\n  ) {\n    return +1;\n  }\n   \n  if(grid[0][0] == '#'\n     && grid[0][1] == '#'\n     && grid[1][0] == '#'\n     && grid[1][1] == '.'\n  ) {\n    return -1;\n  }\n \n  if(grid[0][0] == '.'\n     && grid[0][1] == '.'\n     && grid[1][0] == '.'\n     && grid[1][1] == '#'\n  ) {\n    return -1;\n  }\n   \n  return 0;\n}\n \nint main() {\n   \n  int H, W;\n  while(cin >> H >> W) {\n    H+=2, W+=2;\n    vector<vector<char>> G(H, vector<char>(W, '.'));\n    REP(i, 1, H-1) {\n      REP(j, 1, W-1) {\n        cin >> G[i][j];\n      }\n    }\n     \n    vector<pair<double, int>> event;\n     \n    rep(i, H-1) {\n      rep(j, W-1) {\n         \n        char grid[2][2];\n        grid[0][0] = G[i][j];\n        grid[0][1] = G[i][j+1];\n        grid[1][0] = G[i+1][j];\n        grid[1][1] = G[i+1][j+1];\n         \n        int num = check(grid);\n        if(num!=0) {\n          double ang = atan2((H-2)-i, j);\n          event.PB(MP(atan2((H-2)-i, j), num));\n        }\n         \n      }\n    }\n     \n    sort(ALL(event));\n     \n    int mx = 2;\n    int cnt = 1;\n    for(auto e : event) {\n      cnt += e.second;\n      mx = max(mx, cnt);\n    }\n    cout << mx << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\n int inf=1<<30;\n long long int infll=1LL<<62;\n double eps=1e-9;\n int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os,  vector<T> &vec){\n    os << \"[\";\n    for ( auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int h,w;\n    cin >> h >> w;\n    vector<vector<bool>> f(w,vector<bool>(h));\n    for(int y=h-1; y>=0; --y) rep(x,0,w){\n        char ch;\n        cin >> ch;\n        if(ch=='#') f[x][y]=true;\n    }\n\n    auto is_in_range=[&](int x,int y){\n        return 0<=x and x<w and 0<=y and y<h;\n    };\n\n    auto is_flower=[&](int x,int y){\n        return is_in_range(x,y) and f[x][y];\n    };\n\n    vector<pair<long double,bool>> events;\n    rep(x,0,w+1) rep(y,0,h+1){\n        if(!is_flower(x,y) and is_flower(x-1,y) and !is_flower(x-1,y-1)){\n            events.push_back(make_pair(atan2l(y,x),true));\n            continue;\n        }\n        if(is_flower(x,y) and is_flower(x,y-1) and is_flower(x-1,y-1) and !is_flower(x-1,y)){\n            events.push_back(make_pair(atan2l(y,x),true));\n            continue;\n        }\n        if(!is_flower(x,y) and is_flower(x,y-1) and !is_flower(x-1,y-1)){\n            events.push_back(make_pair(atan2l(y,x),false));\n            continue;\n        }\n        if(is_flower(x,y) and is_flower(x-1,y) and is_flower(x-1,y-1) and !is_flower(x,y-1)){\n            events.push_back(make_pair(atan2l(y,x),false));\n            continue;\n        }\n    }\n    sort(events.begin(),events.end());\n\n    int ans=0,cnt=1;\n    for(auto &p:events){\n        if(p.second) ++cnt;\n        else --cnt;\n        ans=max(ans,cnt);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass UF{\n    private:\n    int sz; vector<int> par,nrank,size;\n    public:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz),size.resize(sz);\n        rep(i,sz){par[i] = i;nrank[i]=0;size[i]=1;}}\n    int find(int x){if(par[x]==x){return x;}else{return par[x] = find(par[x]);}}\n    void unite(int x,int y)\n    { x =find(x),y = find(y);if(x==y)return;if(nrank[x]<nrank[y])swap(x,y);\n        par[y] = x;size[x] += size[y];if(nrank[x]==nrank[y])nrank[x]++;}\n    int query(int x){x = find(x);return size[x];}\n    bool same(int x,int y){return find(x)==find(y);}\n};\n\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<string>s(n);\n    rep(i,n)cin >> s[n-1-i];\n    vector<vector<bool> > p(n+1,vector<bool>(m+1));\n    vector<vector<bool> > pp(n+1,vector<bool>(m+1));\n    vector<vector<bool> > qq(n+1,vector<bool>(m+1));\n    vector<vector<bool> > used(2*(n+1),vector<bool>(2*(m+1)));\n    set<pair<int,int> > v;\n    for(int i=1;i<n;i++){\n        for(int j=1;j<m;j++){\n            if(s[i-1][j-1]=='#'&&s[i][j-1]=='#'&&s[i-1][j]=='#'&&s[i][j]=='#'){\n                continue;\n            }\n            if(s[i-1][j-1]=='.'&&s[i][j-1]=='.'&&s[i-1][j]=='.'&&s[i][j]=='.'){\n                continue;\n            }\n            v.insert(make_pair(2*i,2*j));\n            v.insert(make_pair(2*i-1,2*j));\n            v.insert(make_pair(2*i+1,2*j));\n            v.insert(make_pair(2*i-1,2*j-1));\n            v.insert(make_pair(2*i+1,2*j+1));\n            v.insert(make_pair(2*i-1,2*j+1));\n            v.insert(make_pair(2*i+1,2*j-1));\n            v.insert(make_pair(2*i,2*j-1));\n            v.insert(make_pair(2*i,2*j+1));\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(s[i][j]=='#'){\n                p[i][j] = 1;\n                p[i+1][j] = 1;\n                p[i][j+1] = 1;\n                p[i+1][j+1] = 1;\n                pp[i][j]=1;\n                pp[i+1][j]=1;\n                qq[i][j]=1;\n                qq[i][j+1]=1;\n            }\n        }\n    }\n    int ma = 2;\n    int ng = (n+1)*(m+1);\n    used[0][0] = 1;\n    for(auto x:v){\n        int a = x.first;\n        int b = x.second;\n            if(used[a][b])continue;\n            for(int i=1;i<1000;i++){\n                if(a*i>n||b*i>m)break;\n                used[a*i][b*i] = 1;\n            }\n            UF v((n+1)*(m+1)+1);\n            vector<vector<int> > d(n+1,vector<int>(m+1));\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    if(!p[i][j]){\n                        d[i][j] = -1;\n                    }else if(a*j==i*b){\n                        d[i][j] = 0;\n                    }else if(a*j>i*b){\n                        d[i][j] = 1;\n                    }else{\n                        d[i][j] = 2;\n                    }\n                }\n            }\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(d[i][j]==-1){\n                        v.unite(now,ng);\n                    }else if(d[i][j]==0){\n                        v.unite(now,ng);\n                        if(i>0&&j<m){\n                            if(qq[i-1][j]&&pp[i][j]){\n                                v.unite(now-m-1,now+1);\n                            }\n                        }\n                        if(i<n&&j>0){\n                            if(qq[i][j]&&pp[i][j-1]){\n                                v.unite(now+m+1,now-1);\n                            }\n                        }\n                    }else{\n                        if(i+1<n+1){\n                            if(d[i][j]==d[i+1][j]&&(qq[i][j])){\n                                v.unite(now,now+m+1);\n                            }\n                        }\n                        if(j+1<m+1){\n                            if(d[i][j]==d[i][j+1]&&(pp[i][j])){\n                                v.unite(now,now+1);\n                            }\n                        }\n                    }\n                }\n            }\n            set<int> st;\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(!v.same(now,ng)){\n                        st.insert(v.find(now));\n                    }\n                }\n            }\n            // cout << \"a=\" << a << \"b=\" << b << endl;\n            // for(auto x:st){\n            //     cout << x/(m+1) << \" \" << x%(m+1) << endl;\n            // } \n            ma = max(ma,(int)st.size());\n        \n    }\n    cout << ma << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nbool field[660][660];\n\nstruct event{\n\tint x,y;\n\tbool which;//true:++,false:--\n\tevent(){}\n\tevent(int a,int b,bool c):x(a),y(b),which(c){}\n};\n\nvector<event> events;\n\nbool cmp(const event &e1,const event &e2)\n{\n\tif(e1.x==0) return true;\n\tif(e2.x==0) return false;\n\tif(e1.y==0) return false;\n\tif(e2.y==0) return true;\n\tif(e1.y*e2.x!=e2.y*e1.x) return (e1.y*e2.x>e2.y*e1.x);\n\tif(e1.which==false) return true;\n\tif(e2.which==false) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint H,W;\n\tscanf(\"%d%d\",&H,&W);\n\tmemset(field,false,sizeof(field));\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tchar ch[660];\n\t\tscanf(\"%s\",ch);\n\t\tfor(int j=0;j<W;j++)\n\t\t{\n\t\t\tfield[i+1][j+1]=(ch[j]=='#');\n\t\t}\n\t}\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tfor(int j=1;j<=W;j++)\n\t\t{\n\t\t\tif(field[i][j]==true&&field[i-1][j-1]==false&&field[i-1][j]==false&&field[i][j-1]==false)\n\t\t\t{\n\t\t\t\tevents.push_back(event(j-1,H-i+1,true));\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i+1][j]==false&&field[i][j+1]==false&&field[i+1][j+1]==false)\n\t\t\t{\n\t\t\t\tevents.push_back(event(j,H-i,false));\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i+1][j]==true&&field[i][j+1]==true&&field[i+1][j+1]==false)\n\t\t\t{\n\t\t\t\tevents.push_back(event(j,H-i,true));\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i-1][j]==true&&field[i][j-1]==true&&field[i-1][j-1]==false)\n\t\t\t{\n\t\t\t\tevents.push_back(event(j-1,H-i+1,false));\n\t\t\t}\n\t\t}\n\t}\n\tsort(events.begin(),events.end(),cmp);\n\tint cur=1,ans=1;\n\tfor(int i=0;i<events.size();i++)\n\t{\n\t\tcur+=(events[i].which==false?-1:1);\n\t\tans=max(ans,cur);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconstexpr double EPS = 1e-4;\n\nint gcd(int x, int y) { return y == 0 ? x : gcd(y, x%y); }\n\nstruct point {\n    double x, y;\n    point() {}\n    point(double x, double y): x(x), y(y) {}\n\n    point operator + (const point& o) const { return point(x+o.x, y+o.y); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y); }\n    point operator * (const double a) const { return point(x*a, y*a); }\n\n    bool operator < (const point& o) const { return x == o.x ? y < o.y : x < o.x; }\n    bool operator == (const point& o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble fabs(point a) { return sqrt(a.x*a.x + a.y*a.y); }\ndouble dist(point a, point b) { return fabs(a - b); }\ndouble dist(line l) { return dist(l.a, l.b); }\ndouble dot(point a, point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(point a, point b) { return a.x*b.y - a.y*b.x; }\n\ndouble dist_point_line(point p, line l) {\n    if (dot(p - l.a, l.b - l.a) >= 0 && dot(p - l.b, l.a - l.b) >= 0)\n        return fabs(cross(p - l.a, l.b - l.a)) / dist(l);\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nbool has_intersection(line s, line t) {\n    double s1 = cross(s.b - s.a, t.a - s.b) * cross(s.b - s.a, t.b - s.b);\n    double s2 = cross(t.b - t.a, s.a - t.a) * cross(t.b - t.a, s.b - t.a);\n    if (s1 < 0 && s2 < 0) return true;\n    else if (s1 * s2 == 0) {\n        double d1 = dist_point_line(s.a, t);\n        double d2 = dist_point_line(s.b, t);\n        double d3 = dist_point_line(t.a, s);\n        double d4 = dist_point_line(t.b, s);\n        return min(min(d1, d2), min(d3, d4)) == 0;\n    }\n    return false;\n}\n\npoint intersection(line s, line t) {\n    double c1 = fabs(cross(t.b - t.a, s.a - t.a));\n    double c2 = fabs(cross(t.b - t.a, s.b - t.a));\n    return s.a + (s.b - s.a) * (c1 / (c1 + c2));\n}\n\nint H, W;\nint block[605][605];\n\nvector<line> ls;\nvector<point> ps;\n\nint main(void) {\n    cin >> H >> W;\n    for (int i = 0; i <= H; ++i) fill(block[i], block[i]+W+1, 0);\n    for (int i = 0 ; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            char ch; cin >> ch;\n            block[i][j] = (ch == '#') ? 1 : 0;\n        }\n    }\n\n    for (int i = 0; i <= H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if ((i == 0 && block[i][j] == 1) || (i > 0 && (block[i][j] ^ block[i-1][j]))) {\n                int lj = j++;\n                while (j < W) {\n                    if ((i == 0 || block[i-1][j] == block[i-1][lj]) &&\n                        block[i][j] == block[i][lj])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(i, lj), point(i, j));\n                --j;\n            }\n        }\n    }\n\n    for (int i = 0; i <= W; ++i) {\n        for (int j = 0; j < H; ++j) {\n            if ((i == 0 && block[j][i] == 1) || (i > 0 && (block[j][i] ^ block[j][i-1]))) {\n                int lj = j++;\n                while (j < H) {\n                    if ((i == 0 || block[j][i-1] == block[lj][i-1]) &&\n                        block[j][i] == block[lj][i])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(lj, i), point(j, i));\n                --j;\n            }\n        }\n    }\n\n    int itv = 2;\n    vector<point> es;\n    for (int i = 0; i <= itv*W; ++i) es.emplace_back(0, (double)i/itv);\n    for (int i = 0; i <= itv*H; ++i) es.emplace_back((double)i/itv, W);\n\n    int ans = 0;\n    point left_bottom(H, 0);\n    for (point e : es) {\n        line tiro(left_bottom, left_bottom + (e-left_bottom)*2);\n\n        set<point> cs;\n        for (line l : ls) {\n            if (has_intersection(tiro, l)) cs.insert(intersection(tiro, l));\n        }\n\n        ans = max(ans, (int)cs.size() / 2 + 1);\n\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fs first\n#define sc second\n#define mp make_pair\nusing namespace std;\ntypedef double D;\ntypedef pair<D,int> pii;\n\nint main(){\n  int h,w;\n  char f[999][999];\n  scanf(\"%d%d\",&h,&w); getchar();\n\n  rep(i,h){rep(j,w)f[i][j] = getchar();getchar();}\n\n  vector<pii> v;\n  rep(i,h)rep(j,w){\n    if( i==0?f[i][j]=='#':f[i][j]!=f[i-1][j] ){\n      v.push_back(mp((D)(h-i)/j,-1));\n      v.push_back(mp((D)(h-i)/(j+1),1));\n    }\n    if( j==w-1?f[i][j]=='#':f[i][j]!=f[i][j+1] ){\n      v.push_back(mp((D)(h-i)/(j+1),-1));\n      v.push_back(mp((D)(h-i-1)/(j+1),1));\n    }\n  }\n\n  int res = 0, tmp = 0;\n  sort(v.begin(),v.end());\n  rep(i,v.size())res = max(res,tmp += v[i].sc);\n  cout << (res+3)/2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\n \nstruct angle{\n    int x,y,delta;\n    bool operator<(const angle &a)const{\n        return y*a.x==x*a.y ? delta<a.delta : y*a.x<x*a.y;\n    }\n};\n \n#define O(i,j) (0<=i && i<h && 0<=j && j<w && B[i][j]=='#')\n#define X(i,j) (!O(i,j))\n \nint main(){\n    int h,w; scanf(\"%d%d\",&h,&w);\n    char B[600][601];\n    rep(i,h) scanf(\"%s\",B[i]);\n \n    vector<angle> A;\n    rep(i,h+1) rep(j,w+1) {\n        if(O(i-1,j-1) && X(i-1,j)\n        && X( i ,j-1) && X( i ,j)) A.push_back((angle){j,h-i,1});\n        if(X(i-1,j-1) && O(i-1,j)\n        && O( i ,j-1) && O( i ,j)) A.push_back((angle){j,h-i,1});\n        if(O(i-1,j-1) && O(i-1,j)\n        && O( i ,j-1) && X( i ,j)) A.push_back((angle){j,h-i,-1});\n        if(X(i-1,j-1) && X(i-1,j)\n        && X( i ,j-1) && O( i ,j)) A.push_back((angle){j,h-i,-1});\n    }\n    sort(A.begin(),A.end());\n \n    int ans=1,num=1;\n    rep(i,A.size()) num+=A[i].delta, ans=max(ans,num);\n    printf(\"%d\\n\",ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nbool field[660][660];\n\nstruct frac{\n\tint x,y;\n\tbool just;\n\tfrac(){}\n\tfrac(int x,int y,bool c):x(x),y(y),just(c){}\n};\n\nbool operator<(const frac &f1,const frac &f2)\n{\n\tif(f1.x==0) return true;\n\tif(f2.x==0) return false;\n\tif(f1.y==0) return false;\n\tif(f2.y==0) return true;\n\tif(f1.y*f2.x!=f2.y*f1.x) return f1.y*f2.x>f2.y*f1.x;\n\tif(f1.just==true) return true;\n\tif(f2.just==true) return false;\n\treturn true;\n}\n\nmap<frac,int> events;\n\nint gcd(int x,int y)\n{\n\tif(x<y) swap(x,y);\n\tif(y==0) return x;\n\treturn gcd(y,x%y);\n}\n\nint main()\n{\n\tint H,W;\n\tscanf(\"%d%d\",&H,&W);\n\tmemset(field,false,sizeof(field));\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tchar ch[660];\n\t\tscanf(\"%s\",ch);\n\t\tfor(int j=0;j<W;j++)\n\t\t{\n\t\t\tfield[i+1][j+1]=(ch[j]=='#');\n\t\t}\n\t}\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tfor(int j=1;j<=W;j++)\n\t\t{\n\t\t\tif(field[i][j]==true&&field[i-1][j-1]==false&&field[i-1][j]==false&&field[i][j-1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j-1,H-i+1,true));\n\t\t\t\t//events[m]=event(j-1,H-i+1,true);\n\t\t\t\t//m++;\n\t\t\t\tint d=gcd(j-1,H-i+1);\n\t\t\t\tevents[frac((j-1)/d,(H-i+1)/d,false)]++;\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i+1][j]==false&&field[i][j+1]==false&&field[i+1][j+1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j,H-i,false));\n\t\t\t\t//events[m]=event(j,H-i,false);\n\t\t\t\t//m++;\n\t\t\t\tint d=gcd(j,H-i);\n\t\t\t\tevents[frac(j/d,(H-i)/d,true)]--;\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i+1][j]==true&&field[i][j+1]==true&&field[i+1][j+1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j,H-i,true));\n\t\t\t\t//events[m]=event(j,H-i,true);\n\t\t\t\t//m++;\n\t\t\t\tint d=gcd(j,H-i);\n\t\t\t\tevents[frac(j/d,(H-i)/d,false)]++;\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i-1][j]==true&&field[i][j-1]==true&&field[i-1][j-1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j-1,H-i+1,false));\n\t\t\t\t//events[m]=event(j-1,H-i+1,false);\n\t\t\t\t//m++;\n\t\t\t\tint d=gcd(j-1,H-i+1);\n\t\t\t\tevents[frac((j-1)/d,(H-i+1)/d,true)]--;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=1,cur=1;\n\tmap<frac,int>::iterator it=events.begin();\n\tfor(;it!=events.end();it++)\n\t{\n\t\tcur+=(*it).second;\n\t\tans=max(ans,cur);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> PII;\n\nbool cmp(PII a,PII b){\n  return a.first*b.second>a.second*b.first;\n}\n\nint main(){\n  int H,W;\n  cin>>H>>W;\n  map<PII,int,bool(*)(PII,PII)> m(cmp);\n  bool g[602][602]={};\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      int ii=i+1;\n      int jj=j+1;\n      char c;\n      cin>>c;\n      g[ii][jj]=c=='#';\n    }\n  }\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      int ii=i+1;\n      int jj=j+1;\n      bool f=g[ii][jj];\n      if((f^g[ii-1][jj-1])&&(f^g[ii-1][jj])&&(f^g[ii][jj-1])){\n\tm[PII(H-i,j)]++;\n      }\n      if((f^g[ii][jj+1])&&(f^g[ii+1][jj])&&(f^g[ii+1][jj+1])){\n\tm[PII(H-i-1,j+1)]--;\n      }\n    }\n  }\n  int c=1,ans=1;\n  for(auto e:m){\n    c+=e.second;\n    ans=max(ans,c);\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\ntypedef pair<double,int> P;\n\n\nint H,W;\nstring str;\n\nvector <P> u;\nchar t[600][600];\n\nchar T(int y,int x){\n  if(y<0||x<0)return '.';\n  if(y>=H||x>=W)return '.';\n  return t[y][x];\n}\nint main(){\n\n  double a,x,y;\n\n  while(cin>>H>>W){\n    u.clear();\n    for(int i=H-1;i>=0;i--){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n      }\n    }\n    \n    \n    for(int i=-1;i<H;i++){\n      for(int j=-1;j<W;j++){\n\tif(T(i,j)=='#'&&T(i+1,j)=='#'&&T(i,j+1)=='.'&&T(i+1,j+1)=='#'){\n\t  x=j+1;y=i+1;\n\t  a=acos( (x)/(sqrt(x*x+y*y)) );\n\t  u.push_back(P(a,-1));\n\t}\n\tif(T(i,j)=='.'&&T(i+1,j)=='#'&&T(i,j+1)=='.'&&T(i+1,j+1)=='.'){\n\t  x=j+1;y=i+1;\n\t  a=acos( (x)/(sqrt(x*x+y*y)) );\n\t  u.push_back(P(a,1));\n\t}\n\tif(T(i,j)=='#'&&T(i+1,j)=='.'&&T(i,j+1)=='#'&&T(i+1,j+1)=='#'){\n\t  x=j+1;y=i+1;\n\t  a=acos( (x)/(sqrt(x*x+y*y)) );\n\t  u.push_back(P(a,1));\n\t}\n\tif(T(i,j)=='.'&&T(i+1,j)=='.'&&T(i,j+1)=='#'&&T(i+1,j+1)=='.'){\n\t  x=j+1;y=i+1;\n\t  a=acos( (x)/(sqrt(x*x+y*y)) );\n\t  u.push_back(P(a,-1));\n\t}\n      }\n    }\n    \n    int cnt=1,ans=1;\n    sort(u.begin(),u.end());\n    for(int i=0;i<(int)u.size();i++){\n      \n      cnt+=u[i].second;\n      ans=max(ans,cnt);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fs first\n#define sc second\n#define mp make_pair\nusing namespace std;\ntypedef double D;\ntypedef pair<D,int> pii;\n\nint main(){\n  int h,w;\n  string f[999];\n  cin.tie(0);\n  std::ios::sync_with_stdio(0);\n  cin >> h >> w;\n\n  vector<pii> v;\n  rep(i,h){\n    cin >> f[i];\n    rep(j,w){\n      if( f[i][j]=='#'&&(i==0||f[i-1][j]=='.') ){\n\tv.push_back(mp((D)(h-i)/j,-1));\n\tv.push_back(mp((D)(h-i)/(j+1),1));\n      }\n      if( f[i][j]=='#'&&(j==w-1||f[i][j+1]=='.') ){\n\tv.push_back(mp((D)(h-i)/(j+1),-1));\n\tv.push_back(mp((D)(h-i-1)/(j+1),1));\n      }\n    }\n  }\n\n  int res = 0, tmp = 1;\n  sort(v.begin(),v.end());\n  rep(i,v.size())res = max(res,tmp += v[i].sc);\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nstring F[600];\n\nbool isgrid(int x, int y)\n{\n  return (0 <= x && x < W && 0 <= y && y < H && F[y][x] == '#');\n}\n\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> F[i];\n  }\n\n  vector< pair< pair< int, int >, int > > Event;\n  for(int i = -1; i <= H; i++) {\n    for(int j = -1; j <= W; j++) {\n      if(!isgrid(j, i) && !isgrid(j + 1, i) && !isgrid(j, i + 1) && isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, 1});\n      else if(isgrid(j, i) && isgrid(j + 1, i) && isgrid(j, i + 1) && !isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, 1});\n      else if(isgrid(j, i) && !isgrid(j + 1, i) && !isgrid(j, i + 1) && !isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, -1});\n      else if(!isgrid(j, i) && isgrid(j + 1, i) && isgrid(j, i + 1) && isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, -1});\n    }\n  }\n\n  sort(begin(Event), end(Event), [](auto &a, auto &b)\n  {\n    int c = a.first.first * b.first.second;\n    int d = a.first.second * b.first.first;\n    if(c == d) return (a.second < b.second);\n    return (c < d);\n  });\n\n\n  int proc = 1, ret = 1;\n  for(auto &k : Event) {\n    proc += k.second;\n    ret = max(ret, proc);\n  }\n\n  cout << ret << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nconst int M = 1000000007;\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    for (int i = h - 1; i >= 0; --i)\n        cin >> s[i];\n\n    int ans = 2;\n    for (int i = 1; i <= h; ++i) {\n        for (int j = 1; j <= w; ++j) {\n            if (gcd(i, j) > 1) continue;\n            int c = 0;\n            for (int k = i - 1; k <= i && k < h; ++k) {\n                for (int l = j - 1; l <= j && l < w; ++l) {\n                    c += s[k][l] == '#';\n                }\n            }\n            if (c == 0 || c == 4) continue;\n\n            // up-right\n            c = 0;\n            for (int k = 0; k <= h; ++k) {\n                int l = j * k / i;\n                if (l < 0) continue;\n                if (l >= w) break;\n                if (k == 0)\n                    c += s[k][l] == '#';\n                else if (k == h)\n                    c += s[k - 1][l] == '#';\n                else\n                    c += s[k - 1][l] != s[k][l];\n            }\n            for (int k = 0; k <= w; ++k) {\n                int l = (i * k - 1) / j;\n                if (l < 0) continue;\n                if (l >= h) break;\n                if (k == 0)\n                    c += s[l][k] == '#';\n                else if (k == w)\n                    c += s[l][k - 1] == '#';\n                else\n                    c += s[l][k - 1] != s[l][k];\n            }\n            ans = max(ans, c / 2 + 1);\n\n            // down-left\n            c = 0;\n            for (int k = 0; k <= h; ++k) {\n                int l = (j * k - 1) / i;\n                if (l < 0) continue;\n                if (l >= w) break;\n                if (k == 0)\n                    c += s[k][l] == '#';\n                else if (k == h)\n                    c += s[k - 1][l] == '#';\n                else\n                    c += s[k - 1][l] != s[k][l];\n            }\n            for (int k = 0; k <= w; ++k) {\n                int l = i * k / j;\n                if (l < 0) continue;\n                if (l >= h) break;\n                if (k == 0)\n                    c += s[l][k] == '#';\n                else if (k == w)\n                    c += s[l][k - 1] == '#';\n                else\n                    c += s[l][k - 1] != s[l][k];\n            }\n            ans = max(ans, c / 2 + 1);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\nconst ld eps = 1e-8, INF = 1e+8;\n\nint main() {\n  int h,w;\n  cin>>h>>w;\n  vector<string> t(h+2,string(w+2,'.'));\n  REP(i,h) {\n    string str;\n    cin>>str;\n    t[i+1] = '.'+str+'.';\n  }\n  reverse(begin(t),end(t));\n  map<ld,int> s;\n  REP(i,h+1)REP(j,w+1) {\n    if (t[i][j] == t[i+1][j+1] && t[i+1][j] != t[i][j+1]) {\n      if (t[i][j] == t[i][j+1]) ++s[((ld)i)/j];\n      else --s[((ld)i)/j];\n    }\n  }\n  int sum = 0;\n  int mxsum = 0;\n  for (auto p : s) {\n    sum += p.second;\n    mxsum = max(mxsum, sum);\n  }\n  cout << mxsum+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef pair<double,int> P;\n\nint H,W;\nstring str;\n\nvector <P> u;\nchar t[600][600];\n\ndouble change(double x,double y){\n  if(x>0.0)return y/x;\n  else return 99999999.99999999;\n}\n\nchar T(int y,int x){\n  if(y<0||x<0)return '.';\n  if(y>=H||x>=W)return '.';\n  return t[y][x];\n}\n\nint main(){\n  cin>>H>>W;\n  for(int i=H-1;i>=0;i--){\n    cin>>str;\n    for(int j=0;j<W;j++)t[i][j]=str[j];\n  }\n  \n  for(int i=-1;i<H;i++){\n    for(int j=-1;j<W;j++){\n      if(T(i,j)=='#'&&T(i+1,j)=='#'&&T(i,j+1)=='.'&&T(i+1,j+1)=='#'){\n\tu.push_back(P(change(j+1,i+1),-1));\n      }else if(T(i,j)=='.'&&T(i+1,j)=='#'&&T(i,j+1)=='.'&&T(i+1,j+1)=='.'){\n\tu.push_back(P(change(j+1,i+1),1));\n      }else if(T(i,j)=='#'&&T(i+1,j)=='.'&&T(i,j+1)=='#'&&T(i+1,j+1)=='#'){\n\tu.push_back(P(change(j+1,i+1),1));\n      }else if(T(i,j)=='.'&&T(i+1,j)=='.'&&T(i,j+1)=='#'&&T(i+1,j+1)=='.'){\n\tu.push_back(P(change(j+1,i+1),-1));\n      }\n    }\n  }\n\n  int cnt=1,ans=1;\n  sort(u.begin(),u.end());\n  for(int i=0;i<(int)u.size();i++){    \n    cnt+=u[i].second;\n    ans=max(ans,cnt);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-10;\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\nint main(){\n    int h,w;\n    cin >> h >> w;\n    vector<vector<char> > mat(h+2, vector<char>(w+2, '.'));\n    for(int i=1; i<=h; i++){\n        for(int j=1; j<=w; j++){\n            cin >> mat[i][j];\n        }\n    }\n    reverse(mat.begin(), mat.end());\n\n    VP cut;\n    for(int i=1; i<=h; i++){\n        for(int j=1; j<=w; j++){\n            cut.push_back(P(j,i)/abs(P(j,i)));\n        }\n    }\n    sort(cut.begin(), cut.end());\n    cut.erase(unique(cut.begin(), cut.end()), cut.end());\n\n    int ans=0;\n    for(int i=0; i<(int)cut.size(); i++){\n        for(int j=0; j<2; j++){\n            double eps=(j==0)?EPS: -EPS;\n            int subans=0;\n            double m = cut[i].Y/cut[i].X;\n            for(int x=0; x<=w; x++){\n                int y = m*x +1 +eps;\n                if(y>h+1) break;\n                if(mat[y][x] != mat[y][x+1]) subans++;\n            }\n            m = cut[i].X/cut[i].Y;\n            for(int y=0; y<=h; y++){\n                int x = m*y +1 -eps;\n                if(x>w+1) break;\n                if(mat[y][x] != mat[y+1][x]) subans++;\n            }\n            ans = max(ans, subans);\n        }\n    }\n    cout << ans/2+1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconstexpr double EPS = 1e-4;\n\nstruct point {\n    double x, y;\n    point() {}\n    point(double x, double y): x(x), y(y) {}\n\n    point operator + (const point& o) const { return point(x+o.x, y+o.y); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y); }\n    point operator * (const double a) const { return point(x*a, y*a); }\n\n    bool operator < (const point& o) const { return x == o.x ? y < o.y : x < o.x; }\n    bool operator == (const point& o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble fabs(point a) { return sqrt(a.x*a.x + a.y*a.y); }\ndouble dist(point a, point b) { return fabs(a - b); }\ndouble dist(line l) { return dist(l.a, l.b); }\ndouble dot(point a, point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(point a, point b) { return a.x*b.y - a.y*b.x; }\n\ndouble dist_point_line(point p, line l) {\n    if (dot(p - l.a, l.b - l.a) >= 0 && dot(p - l.b, l.a - l.b) >= 0)\n        return fabs(cross(p - l.a, l.b - l.a)) / dist(l);\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nbool has_intersection(line s, line t) {\n    double s1 = cross(s.b - s.a, t.a - s.b) * cross(s.b - s.a, t.b - s.b);\n    double s2 = cross(t.b - t.a, s.a - t.a) * cross(t.b - t.a, s.b - t.a);\n    if (s1 < 0 && s2 < 0) return true;\n    else if (s1 * s2 == 0) {\n        double d1 = dist_point_line(s.a, t);\n        double d2 = dist_point_line(s.b, t);\n        double d3 = dist_point_line(t.a, s);\n        double d4 = dist_point_line(t.b, s);\n        return min(min(d1, d2), min(d3, d4)) == 0;\n    }\n    return false;\n}\n\npoint intersection(line s, line t) {\n    double c1 = fabs(cross(t.b - t.a, s.a - t.a));\n    double c2 = fabs(cross(t.b - t.a, s.b - t.a));\n    return s.a + (s.b - s.a) * (c1 / (c1 + c2));\n}\n\nint H, W;\nint block[605][605];\n\nvector<line> ls;\nvector<point> ps;\n\nint main(void) {\n    cin >> H >> W;\n    for (int i = 0; i <= H; ++i) fill(block[i], block[i]+W+1, 0);\n    for (int i = 0 ; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            char ch; cin >> ch;\n            block[i][j] = (ch == '#') ? 1 : 0;\n        }\n    }\n\n    for (int i = 0; i <= H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if ((i == 0 && block[i][j] == 1) || (i > 0 && (block[i][j] ^ block[i-1][j]))) {\n                int lj = j++;\n                while (j < W) {\n                    if ((i == 0 || block[i-1][j] == block[i-1][lj]) &&\n                        block[i][j] == block[i][lj])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(i, lj), point(i, j));\n                ps.emplace_back(i, lj);\n                ps.emplace_back(i, j);\n                --j;\n            }\n        }\n    }\n\n    for (int i = 0; i <= W; ++i) {\n        for (int j = 0; j < H; ++j) {\n            if ((i == 0 && block[j][i] == 1) || (i > 0 && (block[j][i] ^ block[j][i-1]))) {\n                int lj = j++;\n                while (j < H) {\n                    if ((i == 0 || block[j][i-1] == block[lj][i-1]) &&\n                        block[j][i] == block[lj][i])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(lj, i), point(j, i));\n                ps.emplace_back(lj, i);\n                ps.emplace_back(j, i);\n                --j;\n            }\n        }\n    }\n\n    ps.emplace_back(H, W);\n    ps.emplace_back(0, 0);\n    sort(begin(ps), end(ps), [](point p, point q) {\n        if (p.y == 0 && q.y == 0) return p.x < q.x;\n        if (p.y == 0) return false;\n        if (q.y == 0) return true;\n        double a1 = (H - p.x) / p.y;\n        double a2 = (H - q.x) / q.y;\n        return a1 == a2 ? p.y < q.y : a1 < a2;\n    });\n\n    int ans = 0;\n\n    point left_bottom(H, 0);\n    for (int i = 0; i < ps.size()-1; ++i) {\n        point p1 = ps[i], p2 = ps[i+1];\n        point end1 = left_bottom + (p1 - left_bottom) * 1000;\n        point end2 = left_bottom + ((p1+p2)*0.5 - left_bottom) * 1000;\n\n        line tiros[2] = {line(left_bottom, end1), line(left_bottom, end2)};\n        for (line tiro : tiros) {\n            set<point> cs;\n            for (line l : ls) {\n                if (has_intersection(tiro, l))\n                    cs.insert(intersection(tiro, l));\n            }\n\n            ans = max(ans, (int)cs.size()/2 + 1);\n\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n\ndouble angle(int x, int y){\n    int d = gcd(x,y);\n    x/=d; y/=d;\n    return double(y)/double(x);\n}\nusing Event = pair<double,int>;\nusing P = pair<int,int>;\nvector<Event> V;\n\nchar M[600][600];\n\nint main(){\n    int H,W;\n    cin>>H>>W;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>M[H-1-i][j];\n        }\n    }\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(M[i][j]=='#'){\n                if(i+1==H||M[i+1][j]=='.'){\n                    // cout<<j<<' '<<i<<'U'<<'('<<j<<\", \"<<i+1<<\")-(\"<<j+1<<\", \"<<i+1<<')'<<endl;\n                    double k1 = angle(j,i+1), k2 = angle(j+1,i+1);\n                    if(k2<k1) swap(k1,k2);\n                    V.emplace_back(k1,1);\n                    V.emplace_back(k2,-1);\n                }\n                if(j+1==W||M[i][j+1]=='.'){\n                    // cout<<j<<' '<<i<<'R'<<'('<<j+1<<\", \"<<i<<\")-(\"<<j+1<<\", \"<<i+1<<')'<<endl;\n                    double k1 = angle(j+1,i), k2 = angle(j+1,i+1);\n                    if(k2<k1) swap(k1,k2);\n                    V.emplace_back(k1,1);\n                    V.emplace_back(k2,-1);\n                }\n            }else{\n                if(i+1<H&&M[i+1][j]=='#'){\n                    // cout<<j<<' '<<i<<'U'<<'('<<j<<\", \"<<i+1<<\")-(\"<<j+1<<\", \"<<i+1<<')'<<endl;\n                    double k1 = angle(j,i+1), k2 = angle(j+1,i+1);\n                    if(k2<k1) swap(k1,k2);\n                    V.emplace_back(k1,1);\n                    V.emplace_back(k2,-1);\n                }\n                if(j+1<W&&M[i][j+1]=='#'){\n                    // cout<<j<<' '<<i<<'R'<<'('<<j+1<<\", \"<<i<<\")-(\"<<j+1<<\", \"<<i+1<<')'<<endl;\n                    double k1 = angle(j+1,i), k2 = angle(j+1,i+1);\n                    if(k2<k1) swap(k1,k2);\n                    V.emplace_back(k1,1);\n                    V.emplace_back(k2,-1);\n                }\n            }\n        }\n    }\n    sort(V.begin(), V.end());\n    int cnt = 0, ans = 0;;\n    for(auto v:V){\n        cnt+=v.second;\n        // cout<<v.first<<' '<<v.second<<' '<<cnt<<endl;\n        ans = max(cnt,ans);\n    }\n    ans = (ans+1)/2+1;\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\nLL mod = 1000000007;\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  LL W, H;\n  cin >> H >> W;\n  vector<string> ss(H);\n\n  vector<string> s(601,\"\");\n\n  REP(i,H){\n    cin >> ss[H-i-1];\n  }\n  \n  REP(i,601){\n    REP(j,601){\n      if(i<ss.size()&&j<ss[i].size()){\n        if(ss[i][j]=='#'){\n          s[i] += \"#\";\n        }else{\n          s[i] += \".\";\n        }\n      }else{\n          s[i] += \".\";\n      }\n    }\n  }\n\n  LL max = 0;\n\n  for (ld dy = 0; dy <= 1; dy += 1.0/600.0/50.0){    \n    ld y = 0;\n    LL xx = 0;\n    LL yy = 0;\n\n    LL cnt = s[0][0]=='#'?1:0;\n    LL now = s[0][0];\n    REP(i, H)\n    {\n      y += dy;\n      if(y>=1){\n        y -= 1;\n        cnt += s[xx][yy] != s[xx][yy + 1] ? 1 : 0;\n        cnt += s[xx][yy + 1] != s[xx + 1][yy + 1] ? 1 : 0;\n        yy++;\n      }\n      else\n      {\n        cnt += s[xx][yy]!=s[xx+1][yy] ? 1 : 0;\n      }\n      xx++;\n    }\n    if(max<cnt){\n      max = cnt;\n    }\n  }\n\n  for (ld dy = 0; dy <= 1; dy += 1.0/600.0/50.0){    \n    ld y = 0;\n    LL xx = 0;\n    LL yy = 0;\n\n    LL cnt = s[0][0]=='#'?1:0;\n    LL now = s[0][0];\n    REP(i, W)\n    {\n      y += dy;\n      if(y>=1){\n        y -= 1;\n        cnt += s[yy][xx] != s[yy + 1][xx] ? 1 : 0;\n        cnt += s[yy + 1][xx] != s[yy + 1][xx + 1] ? 1 : 0;\n        yy++;\n      }\n      else\n      {\n        cnt += s[yy][xx]!=s[yy][xx+1] ? 1 : 0;\n      }\n      xx++;\n    }\n    if(max<cnt){\n      max = cnt;\n    }\n  }\n\n  cout << max / 2 + 1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n#define int long long\nint gcd(int a, int b) {\n\tif (a > b)swap(a, b);\n\twhile (a != 0) {\n\t\tb = b % a;\n\t\tswap(a, b);\n\t}\n\treturn b;\n}\nsigned main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> A;\n\tA.resize(H + 1);\n\tfor (int i = 0; i < H; i++) {\n\n\t\tcin >> A[i + 1];\n\n\t\tA[i + 1].push_back('.');\n\t}\n\tA[0] = string(W + 1, '.');\n\treverse(A.begin(), A.end());\n\tint res = 0;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (gcd(i, j) == 1) {\n\t\t\t\tfor (int l = 0; l < 2; l++) {\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tif (A[0][0] == '#')tmp = 1;\n\t\t\t\t\tdouble d = ((double)i / j) + 1e-9 * (1 - 2 * l);\n\t\t\t\t\tfor (int jj = 0; jj < W; jj++) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tint ii = d * (jj + 1);\n\t\t\t\t\t\t/*if (i == 1 && j == 2) {\n\t\t\t\t\t\t\tcerr << ii << \" yoko \" << jj << endl;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tif (ii >= H)break;\n\t\t\t\t\t\tif (A[ii][jj] != A[ii][jj + 1]) {\n\t\t\t\t\t\t\ttmp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\td = 1 / d;\n\t\t\t\t\tfor (int ii = 0; ii < H; ii++) {\n\t\t\t\t\t\tint jj = d * (ii + 1);\n\t\t\t\t\t\t/*if (i == 1 && j == 2) {\n\t\t\t\t\t\t\tcerr << ii << \" tate \" << jj << endl;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tif (jj >= W)break;\n\t\t\t\t\t\tif (A[ii + 1][jj] != A[ii][jj]) {\n\t\t\t\t\t\t\ttmp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cerr << i << \" \" << j << \" \" << l << \" \" << tmp << endl;\n\t\t\t\t\tres = max((tmp / 2) + 1, res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\nconst ld eps = 1e-8, INF = 1e+8;\n\nint main() {\n  int h,w;\n  cin>>h>>w;\n  vector<string> t(h);\n  REP(i,h)cin>>t[i];\n  reverse(begin(t),end(t));\n  map<ld,int> s;\n  REP(i,h-1)REP(j,w-1) {\n    if (t[i][j] == t[i+1][j+1] && t[i+1][j] != t[i][j+1]) {\n      if (t[i][j] == t[i][j+1]) ++s[((ld)i+1)/(j+1)];\n      else --s[((ld)i+1)/(j+1)];\n    }\n  }\n  REP(i,h-1) {\n    if (t[i][0] != t[i+1][0]) {\n      if (t[i][0] == '#') --s[INF];\n    }\n  }\n  REP(i,h-1) {\n    if (t[i][w-1] != t[i+1][w-1]) {\n      if (t[i][w-1] == '.') ++s[((ld)i+1)/w];\n    }\n  }\n  REP(i,w-1) {\n    if (t[0][i] != t[0][i+1]) {\n      if (t[0][i] == '#') ++s[0];\n    }\n  }\n  REP(i,w-1) {\n    if (t[h-1][i] != t[h-1][i+1]) {\n      if (t[h-1][i] == '.') --s[((ld)h)/(i+1)];\n    }\n  }\n  if (t[h-1][0] == '#') --s[INF];\n  if (t[0][w-1] == '#') ++s[0];\n  int sum = 0;\n  int mxsum = 0;\n  for (auto p : s) {\n    int addv;\n    tie(ignore, addv) = p;\n    sum += addv;\n    mxsum = max(mxsum, sum);\n  }\n  cout << (mxsum + 1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<pi,int>;\n\nbool cmp(const pi &lh, const pi &rh){\n    return lh.fi*rh.se < rh.fi*lh.se;\n}\n\nint main(){\n    int h,w;\n    cin >>h >>w;\n    vector<string> f(h);\n    rep(i,h) cin >>f[i];\n\n    // find corners\n    /*\n    .. #. ## .#\n    .# .. #. ##\n    */\n    map<string,int> mp;\n    mp[\"...#\"] = -1;\n    mp[\"#...\"] = 1;\n    mp[\"###.\"] = -1;\n    mp[\".###\"] = 1;\n\n    auto field = [&](int y, int x){\n        if(0<=y && y<h && 0<=x && x<w) return f[y][x];\n        return '.';\n    };\n\n    auto corner = [&](int y, int x){\n        string pat = \"\";\n        rep(i,2)rep(j,2){\n            pat += field(h-1-y+i, x-1+j);\n        }\n\n        if(mp.count(pat)) return mp[pat];\n        return 0;\n    };\n\n    vector<P> c;\n    vector<pi> v;\n    for(int i=0; i<=h; ++i){\n        for(int j=0; j<=w; ++j){\n            int cc = corner(i,j);\n            if(cc != 0){\n                int g = __gcd(i,j);\n                c.pb({{i/g, j/g}, cc});\n                v.pb({i/g, j/g});\n            }\n        }\n    }\n\n    sort(all(v), cmp);\n    v.erase(unique(all(v)), v.end());\n    int V = v.size();\n    map<pi,int> idx;\n    rep(i,V) idx[v[i]] = i;\n\n    vector<vector<int>> Q(V);\n    for(const auto &p:c){\n        Q[idx[p.fi]].pb(p.se);\n    }\n\n    int ans = 1;\n    int cur = 1;\n    rep(i,V){\n        for(int j:Q[i]) cur += j;\n        ans = max(ans, cur);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<double,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint h,w;\nvector<string> mp;\n\n//   1   -1    1   -1\n//  #.   ..   .#   ##\n//  ..   .#   ##   #.\n\n\nbool O___(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '.' && mp[y+1][x] == '#' && mp[y+1][x+1] == '.';\n}\n\nbool ___O(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '#' && mp[y+1][x] == '.' && mp[y+1][x+1] == '.';\n}\n\nbool _OOO(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '#' && mp[y+1][x] == '.' && mp[y+1][x+1] == '#';\n}\n\nbool OOO_(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '.' && mp[y+1][x] == '#' && mp[y+1][x+1] == '#';\n}\n\n\nsigned main(){\n  cin>>h>>w;\n\n  int ofset = 1;\n  mp.resize(h+ofset * 2,string(w+ofset * 2,'.'));\n\n  for(int i=0;i<h;i++) \n    for(int j=0;j<w;j++) cin>>mp[h-i][j+1];\n  \n  auto getArg=[](double x,double y){\n    return 180 * (arg(complex<double>(x,y))/ PI);\n  };\n  \n  vector<P> A;\n  for(int i=0;i<=h;i++)\n    for(int j=0;j<=w;j++){\n      if(O___(j,i)) A.push_back(P(getArg(j,i),1));\n      if(___O(j,i)) A.push_back(P(getArg(j,i),-1));\n      if(_OOO(j,i)) A.push_back(P(getArg(j,i),1));\n      if(OOO_(j,i)) A.push_back(P(getArg(j,i),-1));\n    }\n  sort(A.begin(),A.end());  \n  \n  int ans = 1;\n  int cnt = 1;\n  for(int i=0;i<(int)A.size();){\n    double th = A[i].first;\n    while(i < (int)A.size()){\n      double th2 = A[i].first;\n      int type = A[i].second;\n      if(abs(th - th2) > EPS) break;\n      i++;\n      cnt += type;\n    }\n    Max(ans,cnt);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass UF{\n    private:\n    int sz; vector<int> par,nrank,size;\n    public:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz),size.resize(sz);\n        rep(i,sz){par[i] = i;nrank[i]=0;size[i]=1;}}\n    int find(int x){if(par[x]==x){return x;}else{return par[x] = find(par[x]);}}\n    void unite(int x,int y)\n    { x =find(x),y = find(y);if(x==y)return;if(nrank[x]<nrank[y])swap(x,y);\n        par[y] = x;size[x] += size[y];if(nrank[x]==nrank[y])nrank[x]++;}\n    int query(int x){x = find(x);return size[x];}\n    bool same(int x,int y){return find(x)==find(y);}\n};\n\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<string>s(n);\n    rep(i,n)cin >> s[n-1-i];\n    vector<vector<bool> > p(n+1,vector<bool>(m+1));\n    vector<vector<bool> > pp(n+1,vector<bool>(m+1));\n    vector<vector<bool> > qq(n+1,vector<bool>(m+1));\n    vector<vector<bool> > used(2*(n+1),vector<bool>(2*(m+1)));\n    vector<pair<int,int> > v;\n    for(int i=1;i<n;i++){\n        for(int j=1;j<m;j++){\n            if(s[i-1][j-1]=='#'&&s[i][j-1]=='#'&&s[i-1][j]=='#'&&s[i][j]=='#'){\n                continue;\n            }\n            if(s[i-1][j-1]=='.'&&s[i][j-1]=='.'&&s[i-1][j]=='.'&&s[i][j]=='.'){\n                continue;\n            }\n            v.push_back(make_pair(2*i,2*j));\n            v.push_back(make_pair(2*i-1,2*j));\n            v.push_back(make_pair(2*i+1,2*j));\n            v.push_back(make_pair(2*i-1,2*j-1));\n            v.push_back(make_pair(2*i+1,2*j+1));\n            v.push_back(make_pair(2*i-1,2*j+1));\n            v.push_back(make_pair(2*i+1,2*j-1));\n            v.push_back(make_pair(2*i,2*j-1));\n            v.push_back(make_pair(2*i,2*j+1));\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(s[i][j]=='#'){\n                p[i][j] = 1;\n                p[i+1][j] = 1;\n                p[i][j+1] = 1;\n                p[i+1][j+1] = 1;\n                pp[i][j]=1;\n                pp[i+1][j]=1;\n                qq[i][j]=1;\n                qq[i][j+1]=1;\n            }\n        }\n    }\n    int ma = 2;\n    int ng = (n+1)*(m+1);\n    used[0][0] = 1;\n    for(auto x:v){\n        int a = x.first;\n        int b = x.second;\n            if(used[a][b])continue;\n            for(int i=1;i<1000;i++){\n                if(a*i>n||b*i>m)break;\n                used[a*i][b*i] = 1;\n            }\n            UF v((n+1)*(m+1)+1);\n            vector<vector<int> > d(n+1,vector<int>(m+1));\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    if(!p[i][j]){\n                        d[i][j] = -1;\n                    }else if(a*j==i*b){\n                        d[i][j] = 0;\n                    }else if(a*j>i*b){\n                        d[i][j] = 1;\n                    }else{\n                        d[i][j] = 2;\n                    }\n                }\n            }\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(d[i][j]==-1){\n                        v.unite(now,ng);\n                    }else if(d[i][j]==0){\n                        v.unite(now,ng);\n                        if(i>0&&j<m){\n                            if(qq[i-1][j]&&pp[i][j]){\n                                v.unite(now-m-1,now+1);\n                            }\n                        }\n                        if(i<n&&j>0){\n                            if(qq[i][j]&&pp[i][j-1]){\n                                v.unite(now+m+1,now-1);\n                            }\n                        }\n                    }else{\n                        if(i+1<n+1){\n                            if(d[i][j]==d[i+1][j]&&(qq[i][j])){\n                                v.unite(now,now+m+1);\n                            }\n                        }\n                        if(j+1<m+1){\n                            if(d[i][j]==d[i][j+1]&&(pp[i][j])){\n                                v.unite(now,now+1);\n                            }\n                        }\n                    }\n                }\n            }\n            set<int> st;\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(!v.same(now,ng)){\n                        st.insert(v.find(now));\n                    }\n                }\n            }\n            // cout << \"a=\" << a << \"b=\" << b << endl;\n            // for(auto x:st){\n            //     cout << x/(m+1) << \" \" << x%(m+1) << endl;\n            // } \n            ma = max(ma,(int)st.size());\n        \n    }\n    cout << ma << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-11, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<bool>>fi(H+2, vector<bool>(W+2));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '#') {\n\t\t\t\tfi[i+1][j+1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<Line>ls;\n\tvector<double>katas;\n\tvector<vector<bool>>tates(H + 2, vector<bool>(W + 1));\n\tvector<vector<bool>>yokos(H + 1, vector<bool> (W + 2));\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 1; x < W + 1; ++x) {\n\t\t\tif (fi[y][x]) {\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tPoint ld(x, y + 1);\n\t\t\t\t\tPoint lu(x, y);\n\t\t\t\t\tPoint rd(x + 1, y + 1);\n\t\t\t\t\tPoint ru(x + 1, y);\n\t\t\t\t\tif (!fi[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\ttates[y][x - 1] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(ld, lu);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == 1) {\n\t\t\t\t\t\t\tyokos[y][x] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(rd, ld);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == 2) {\n\t\t\t\t\t\t\ttates[y][x] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(ru, rd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tyokos[y - 1][x] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(lu, ru);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < W + 1; ++x) {\n\t\tbool now = false;\n\t\tPoint from;\n\t\tfor (int y = 0; y < H + 2; ++y) {\n\t\t\t\n\t\t\tif (tates[y][x]) {\n\t\t\t\tif (!now) {\n\t\t\t\t\tfrom=Point(x+1,y);\n\t\t\t\t}\n\t\t\t\tnow = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (now) {\n\t\t\t\t\tls.emplace_back(from, Point(x + 1, y));\n\t\t\t\t}\n\t\t\t\tnow = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = 0; y < H + 1; ++y) {\n\t\tbool now = false;\n\t\tPoint from;\n\t\tfor (int x = 0; x < W + 2; ++x) {\n\t\t\tif (yokos[y][x]) {\n\t\t\t\tif (!now) {\n\t\t\t\t\tfrom = Point(x, y + 1);\n\t\t\t\t}\n\t\t\t\tnow = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (now) {\n\t\t\t\t\tls.emplace_back(from, Point(x, y + 1));\n\t\t\t\t}\n\t\t\t\tnow = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 2; x < W + 2; ++x) {\n\t\t\tkatas.push_back(double(y-(H+1))/ (x - 1));\n\t\t}\n\t}\n\tkatas.push_back(0);\n\tkatas.push_back(-1000);\n\tsort(katas.begin(), katas.end());\n\tvector<double>newkatas;\n\tdouble now = 1;\n\tfor (int i = 0; i < katas.size(); ++i) {\n\t\tif (abs(katas[i]-now)>1e-10) {\n\t\t\tnewkatas.push_back(katas[i]);\n\t\t\tnow = (katas[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\n\tmap<double, int>mp;\n\tmp[0] = 0;\n\tmp[-1000] = 0;\n\tfor (int j = 0; j < ls.size(); ++j) {\n\t\tif (ls[j][0] == Point(1, H+1) || ls[j][1] == Point(1, H+1))continue;\n\t\tdouble kataf = (ls[j][0].imag() - H-1) / (ls[j][0].real()+eps - 1);\n\t\tdouble katat = (ls[j][1].imag() - H - 1) / (ls[j][1].real() + eps - 1);\n\t\tif (kataf < katat)swap(kataf, katat);\n\t\tassert(kataf >= katat);\n\t\tmp[kataf]--;\n\t\tmp[katat]++;\n\t}\n\tint anow = 0;\n\tfor (auto &it : mp) {\n\t\tit.second += anow;\n\t\tanow = it.second;\n\t}\n\t\n\tfor (int i = 0; i < newkatas.size()-1; ++i) {\n\t\tdouble kata = (newkatas[i + 1] + newkatas[i])/2;\n\t\tLine l(Point(1, H + 1), Point(1 + 1, H + 1 + kata));\n\t\tint nans = 0;\n\t\tnans = mp.lower_bound(kata)->second;\n\t\tif (fi[H][1])nans += 1;\n\t\tans = max(ans, 1+nans/2);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<double,double>D;\ntypedef pair<P,int>PP;\ntypedef pair<double,P>dP;\ntypedef pair<D,int>Di;\n\nconst int MAX_N = 602;\nconst int dx[] = {1,1,0,0};\nconst int dy[] = {0,0,1,-1};\nconst int ex[] = {1,0,1};\nconst int ey[] = {0,1,1};\n\nint a[MAX_N][MAX_N];\nint flag[MAX_N][MAX_N];\nint h,w;\nint gcd_table[MAX_N][MAX_N];\nvector<PP> vec;\nmap<P,int> mp;\n\nvoid dfs(int u,int v)\n{\n    flag[u][v] = 1;\n    if(u < w-1 && 0 < v && !a[u+1][v] && !a[u][v-1] && !a[u+1][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u == w-1 && 0 < v && !a[u][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u < w-1 && 0 < v && a[u+1][v] && a[u][v-1] && !a[u+1][v-1]){  //??????2\n        vec.push_back(PP(P(u+1,v),2));\n    }\n    if(0 < u && v < h-1 && !a[u-1][v] && !a[u][v+1] && !a[u-1][v+1]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v == h-1 && !a[u-1][v]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v < h-1 && a[u-1][v] && a[u][v+1] && !a[u-1][v+1]){  //??????2\n        vec.push_back(PP(P(u,v+1),3));\n    }\n    rep(i,4){\n        int nx = u + dx[i],ny = v + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && a[nx][ny] && !flag[nx][ny]){\n            dfs(nx,ny);\n        }\n    }\n    return;\n}\n\nint gcd(int a,int b)\n{\n    if(a % b == 0){\n        return b;\n    }\n    return gcd(b,a % b);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&h,&w);\n    rep(j,h){\n        string s;\n        cin >> s;\n        rep(i,s.length()){\n            flag[i][j] = 0;\n            if(s[i] == '#'){\n                a[i][h-j-1] = 1;\n            }else{\n                a[i][h-j-1] = 0;\n            }\n        }\n    }\n    for(int i = 1;i <= 600;i++){\n        for(int j = i;j <= 600;j++){\n            gcd_table[j][i] = gcd(j,i);\n        }\n    }\n    bool fl = false;\n    rep(i,w){\n        rep(j,h){\n            if(a[i][j]){\n                dfs(i,j);\n                fl = true;\n                break;\n            }\n        }\n        if(!fl){\n            break;\n        }\n    }\n    // rep(i,vec.size()){\n    //     cout << vec[i].first.first << \" \" << vec[i].first.second << \" \" << vec[i].second << \"\\n\";\n    // }\n    vector<dP> tilt;\n    rep(i,vec.size()){\n        int p1 = (vec[i].first).first;\n        int p2 = (vec[i].first).second;\n        tilt.push_back(dP((double)p2 / p1,P(i,vec[i].second)));\n    }\n    sort(all(tilt));\n    vector<PP> cand;\n    rep(i,tilt.size()){\n        int cnt[] = {0,0,0,0};\n        int id = i;\n        double n1 = tilt[i].first;\n        int n2 = (tilt[i].second).first;\n        int n3 = (tilt[i].second).second;\n        cnt[n3]++;\n        while(id + 1 < tilt.size() && abs(tilt[id].first-tilt[id+1].first) < EPS){\n            n1 = tilt[i+1].first;\n            n3 = (tilt[i+1].second).first;\n            cnt[n3]++;\n            id++;\n        }\n        int mx = max(cnt[0]+cnt[3],cnt[1]+cnt[2]);\n        i = id;\n        P p = vec[n2].first;\n        int md = gcd_table[max(p.first,p.second)][min(p.first,p.second)];\n        mp[P(p.first / md,p.second / md)]++;\n        cand.push_back(PP(P(p.first / md,p.second / md),mx));\n    }\n    for(int i = 1;i <= w;i++){\n        for(int j = 1;j <= h;j++){\n            int md = gcd_table[max(i,j)][min(i,j)];\n            P p = P(i / md,j / md);\n            if(!mp[p]){\n                cand.push_back(PP(p,0));\n                mp[p]++;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,cand.size()){\n        vector<Di> cros;\n        P p = cand[i].first;\n        rep(j,p.first-1){\n            cros.push_back(Di(D(j+1,(double)(j+1) * p.second / p.first),0));\n        }\n        rep(j,p.second-1){\n            cros.push_back(Di(D((double)(j+1) * p.first / p.second,j+1),1));\n        }\n        sort(all(cros));\n        vector<int> act;\n        rep(j,cros.size()){\n            act.push_back(cros[j].second);\n        }\n        act.push_back(2);\n        int cnt = 0;\n        int px = 0,py = 0;\n        int bf = a[0][0];\n        int res = 0;\n        while(1){\n            px += ex[act[cnt%act.size()]];\n            py += ey[act[cnt%act.size()]];\n            if(px < w && py < h){\n                if(bf == 1 && !a[px][py]){\n                    res++;\n                }\n                bf = a[px][py];\n            }else{\n                if(bf == 1){\n                    res++;\n                }\n                break;\n            }\n            cnt++;\n        }\n        ans = max(res+cand[i].second,ans);\n    }\n    cout << ans + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass UF{\n    private:\n    int sz; vector<int> par,nrank,size;\n    public:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz),size.resize(sz);\n        rep(i,sz){par[i] = i;nrank[i]=0;size[i]=1;}}\n    int find(int x){if(par[x]==x){return x;}else{return par[x] = find(par[x]);}}\n    void unite(int x,int y)\n    { x =find(x),y = find(y);if(x==y)return;if(nrank[x]<nrank[y])swap(x,y);\n        par[y] = x;size[x] += size[y];if(nrank[x]==nrank[y])nrank[x]++;}\n    int query(int x){x = find(x);return size[x];}\n    bool same(int x,int y){return find(x)==find(y);}\n};\n\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<string>s(n);\n    rep(i,n)cin >> s[n-1-i];\n    vector<vector<bool> > p(n+1,vector<bool>(m+1));\n    vector<vector<bool> > pp(n+1,vector<bool>(m+1));\n    vector<vector<bool> > qq(n+1,vector<bool>(m+1));\n    vector<vector<bool> > used(2*(n+1),vector<bool>(2*(m+1)));\n    vector<pair<int,int> > v;\n    for(int i=1;i<n;i++){\n        for(int j=1;j<m;j++){\n            if(s[i-1][j-1]=='#'&&s[i][j-1]=='#'&&s[i-1][j]=='#'&&s[i][j]=='#'){\n                continue;\n            }\n            if(s[i-1][j-1]=='.'&&s[i][j-1]=='.'&&s[i-1][j]=='.'&&s[i][j]=='.'){\n                continue;\n            }\n            v.push_back(make_pair(2*i,2*j));\n            v.push_back(make_pair(2*i-1,2*j));\n            v.push_back(make_pair(2*i+1,2*j));\n            v.push_back(make_pair(2*i-1,2*j-1));\n            v.push_back(make_pair(2*i+1,2*j+1));\n            v.push_back(make_pair(2*i-1,2*j+1));\n            v.push_back(make_pair(2*i+1,2*j-1));\n            v.push_back(make_pair(2*i,2*j-1));\n            v.push_back(make_pair(2*i,2*j+1));\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(s[i][j]=='#'){\n                p[i][j] = 1;\n                p[i+1][j] = 1;\n                p[i][j+1] = 1;\n                p[i+1][j+1] = 1;\n                pp[i][j]=1;\n                pp[i+1][j]=1;\n                qq[i][j]=1;\n                qq[i][j+1]=1;\n            }\n        }\n    }\n    int ma = 1;\n    int ng = (n+1)*(m+1);\n    used[0][0] = 1;\n    for(auto x:v){\n        int a = x.first;\n        int b = x.second;\n            if(used[a][b])continue;\n            for(int i=1;i<1000;i++){\n                if(a*i>n||b*i>m)break;\n                used[a*i][b*i] = 1;\n            }\n            UF v((n+1)*(m+1)+1);\n            vector<vector<int> > d(n+1,vector<int>(m+1));\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    if(!p[i][j]){\n                        d[i][j] = -1;\n                    }else if(a*j==i*b){\n                        d[i][j] = 0;\n                    }else if(a*j>i*b){\n                        d[i][j] = 1;\n                    }else{\n                        d[i][j] = 2;\n                    }\n                }\n            }\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(d[i][j]==-1){\n                        v.unite(now,ng);\n                    }else if(d[i][j]==0){\n                        v.unite(now,ng);\n                        if(i>0&&j<m){\n                            if(qq[i-1][j]&&pp[i][j]){\n                                v.unite(now-m-1,now+1);\n                            }\n                        }\n                        if(i<n&&j>0){\n                            if(qq[i][j]&&pp[i][j-1]){\n                                v.unite(now+m+1,now-1);\n                            }\n                        }\n                    }else{\n                        if(i+1<n+1){\n                            if(d[i][j]==d[i+1][j]&&(qq[i][j])){\n                                v.unite(now,now+m+1);\n                            }\n                        }\n                        if(j+1<m+1){\n                            if(d[i][j]==d[i][j+1]&&(pp[i][j])){\n                                v.unite(now,now+1);\n                            }\n                        }\n                    }\n                }\n            }\n            set<int> st;\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(!v.same(now,ng)){\n                        st.insert(v.find(now));\n                    }\n                }\n            }\n            // cout << \"a=\" << a << \"b=\" << b << endl;\n            // for(auto x:st){\n            //     cout << x/(m+1) << \" \" << x%(m+1) << endl;\n            // } \n            ma = max(ma,(int)st.size());\n        \n    }\n    cout << ma << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nusing Real = double;\nReal EPS = 1e-8, PI = acos(-1);\n\nusing Point = complex<Real>;\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        if (a.real() == b.real()) return a.imag() < b.imag();\n        return a.real() < b.real();\n    }\n}\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\n\nReal radian_to_degree(Real r) {\n    return r * 180.0 / PI;\n}\n\nReal degree_to_radian(Real d) {\n    return d * PI / 180.0;\n}\n\nPoint rotate(const Point &p, Real theta) {\n    return p * polar(1., theta);\n}\n\nReal cross(const Point& a, const Point& b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n         B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\n\nbool parallel(const Line& l1, const Line& l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nbool orthogonal(const Line& l1, const Line& l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nconst int COUNTER_CLOCKWISE = 1,\n      CLOCKWISE = -1,\n      ONLINE_BACK = 2,\n      ONLINE_FRONT = -2,\n      ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersected(const Line& l, const Point& p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersected(const Segment& s, const Point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersected(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersected(const Segment& s1, const Segment& s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n        ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\n\nReal distance(const Segment& s, const Point& p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\nReal distance(const Segment& s1, const Segment& s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({ distance(s1, s2.a), distance(s1, s2.b),\n            distance(s2, s1.a), distance(s2, s1.b) });\n}\n\nPoint crosspoint(const Line& l1, const Line& l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n         B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int H, W; cin >> H >> W;\n    vector<string> M(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> M[H-1-i];\n    }\n    int si = -1, sj = -1;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (M[i][j] == '#') {\n                si = i, sj = j;\n            }\n        }\n    }\n\n    auto used = make_v<bool>(H, W);\n    int dy[] = {0, -1, 0, 1},\n        dx[] = {-1, 0, 1, 0},\n        dy1[] = {0, 0, 0, 1},\n        dy2[] = {1, 0, 1, 1},\n        dx1[] = {0, 0, 1, 0},\n        dx2[] = {0, 1, 1, 1};\n\n    vector<Segment> edges;\n\n    function<void(int,int)> bfs = [&](int i, int j){\n        used[i][j] = true;\n        for (int k = 0; k < 4; ++k) {\n            int y = i + dy[k], x = j + dx[k];\n            if (y < 0 or H <= y or x < 0 or W <= x or M[y][x] == '.') {\n                edges.emplace_back(\n                        Point{ (Real)dy1[k] + i, (Real)dx1[k] + j },\n                        Point{ (Real)dy2[k] + i, (Real)dx2[k] + j }\n                        );\n            } else if (!used[y][x]) {\n                bfs(y, x);\n            }\n        }\n    };\n\n    bfs(si, sj);\n\n    vector<double> left, right;\n    for (int i = 0; i < edges.size(); ++i) {\n        if (arg(edges[i].a) < arg(edges[i].b)) {\n            left.push_back(arg(edges[i].a));\n            right.push_back(arg(edges[i].b));\n        } else {\n            left.push_back(arg(edges[i].b));\n            right.push_back(arg(edges[i].a));\n        }\n    }\n    sort(left.begin(), left.end());\n    sort(right.begin(), right.end());\n\n    const int SPLIT = 99991;\n    int cnt = 0;\n\n    int l = 0, r = 0;\n    int ans = 0;\n    for (int i = 1; i < SPLIT; ++i) {\n\n        Real theta = PI / 2 / SPLIT * i;\n\n        while (l < left.size() and left[l] < theta) {\n            ++cnt; ++l;\n        }\n        while (r < right.size() and right[r] < theta) {\n            --cnt; ++r;\n        }\n        chmax(ans, cnt);\n    }\n\n    cout << ans / 2 + 1 << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint main(){\n\tint H, W;\n\tstring f[600];\n\twhile(cin >> H >> W){\n\t\tfor(int i=H-1;i>=0;i--) cin >> f[i];\n\n\t\tvector< pair<double, int> > vd;\n\t\t// ????????°??????????????????????????????.\n\t\t// ??????(j/i)?????§??????????????¨??????????????°????¢????????????£?????????\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=0;j<=W;j++){\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i-k%2, nj = j-k/2;\n\t\t\t\t\tif(0<=ni&&ni<H&&0<=nj&&nj<W&&f[ni][nj]=='#') cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt%2 == 1){\n\t\t\t\t\tif(0<=i-1&&i-1<H&&0<=j&&j<W&&f[i-1][j]==(cnt==1?'#':'.'))\n\t\t\t\t\t\tvd.push_back(make_pair((double)j/i,  1));\n\t\t\t\t\tif(0<=i&&i<H&&0<=j-1&&j-1<W&&f[i][j-1]==(cnt==1?'#':'.'))\n\t\t\t\t\t\tvd.push_back(make_pair((double)j/i, -1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vd.begin(), vd.end());\n\n\t\tint res = 1, cur = 1;\n\t\t// ???????????§?????????????????????????????°????¢????????????????\n\t\tfor(int i=0;i<vd.size(); ){\n\t\t\tint idx = i;\n\t\t\twhile(idx < vd.size() && abs(vd[i].first-vd[idx].first) < EPS)\n\t\t\t\tcur += vd[idx++].second;\n\t\t\ti = idx;\n\t\t\tres = max(cur, res);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\nconst double EPS=1e-10;\nchar str[700][700];\nint array[700][700];\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;\n\t\tint c=b;\n\t\tb=a;\n\t\ta=c;\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[a-1-i]);\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<b;j++)array[i][j]=(str[i][j]=='#'?1:0);\n\tint ret=0;\n\t\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(gcd(i+1,j+1)>1)continue;\n\t\t\tint val=0;\n\t\t\tdouble X=i+1;\n\t\t\tdouble Y=(1e-8)+j+1;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tval+=(array[k][d]^array[k+1][d]);\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tint d=(int)(X*(k+1)/Y);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tval+=(array[d][k]^array[d][k+1]);\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t\tval=0;\n\t\t\tY=-(1e-8)+j+1;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tval+=(array[k][d]^array[k+1][d]);\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tint d=(int)(X*(k+1)/Y);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tval+=(array[d][k]^array[d][k+1]);\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t}\n\t}\n\tif(str[0][0]=='#')ret++;\n\tprintf(\"%d\\n\",1+ret/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double mEPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nclass Point{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a*x, a*y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\t//EPS??????????°??????????\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n\t}\n\n  friend ostream& operator<<(ostream& os, const Point& p);\n\n};\nostream& operator<<(ostream& os, const Point& p){\n  os << \"(\" << p.x << \",\" << p.y << \")\";\n  return os;\n}\n  \nclass Segment{\npublic:\n\tPoint p1, p2;\n};\n\n\ntypedef vector<Point> Polygon;\n\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\n\n//??????\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//???????????§??????\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > mEPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -mEPS) return CLOCKWISE;\n\tif (dot(a, b) < -mEPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn(ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; cin >> H >> W;\n  VS str(H); REP(i,H) cin >> str[i];\n  reverse(ALL(str));\n  vector<Segment> ls;\n  REP(y,H) REP(x,W){\n\tif(str[y][x] == '#' && (y == 0 || str[y-1][x] == '.')){\n\t  int t = x;\n\t  for(;t<W;++t)\n\t\tif(str[y][t] == '.' || (y > 0 && str[y-1][t] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y;\n\t  p2.x = t, p2.y = y;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  x = t;\n\t}\n  }\n  REP(y,H) REP(x,W){\n\tif(str[y][x] == '#' && (y == H-1 || str[y+1][x] == '.')){\n\t  int t = x;\n\t  for(;t<W;++t)\n\t\tif(str[y][t] == '.' || (y < H-1 && str[y+1][t] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y+1;\n\t  p2.x = t, p2.y = y+1;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  x = t;\n\t}\n  }\n  REP(x,W) REP(y,H){\n\tif(str[y][x] == '#' && (x == 0 || str[y][x-1] == '.')){\n\t  int t = y;\n\t  for(;t<H;++t)\n\t\tif(str[t][x] == '.' || (x > 0 && str[t][x-1] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y;\n\t  p2.x = x, p2.y = t;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  y = t;\n\t}\n  }\n  REP(x,W) REP(y,H){\n\tif(str[y][x] == '#' && (x == W-1 || str[y][x+1] == '.')){\n\t  int t = y;\n\t  for(;t<H;++t)\n\t\tif(str[t][x] == '.' || (x < W-1 && str[t][x+1] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x+1; p1.y = y;\n\t  p2.x = x+1, p2.y = t;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  y = t;\n\t}\n  }\n\n  vector<tuple<int,int,Point>> memo;\n  REP(i,SZ(ls)) FOR(j,i+1,SZ(ls))\n\tif(intersect(ls[i], ls[j])){\n\t  if(ls[i].p1 == ls[j].p1 || ls[i].p1 == ls[j].p2)\n\t\tmemo.PB(MT(i,j,ls[i].p1));\n\t  else\n\t\tmemo.PB(MT(i,j,ls[i].p2));\n\t}\n\n  int ans = 1;\n  for(double th=0.;th<PI/2;th+=0.0001){\n\tSegment s;\n\ts.p1.x = 0, s.p1.y = 0;\n\ts.p2.x = 1000. * cos(th), s.p2.y = 1000. * sin(th);\n\tvector<bool> cr(SZ(ls));\n\tREP(i,SZ(ls)) cr[i] = intersect(s, ls[i]);\n\tint c = count(ALL(cr), true);\n\tfor(auto& pp: memo){\n\t  if(cr[get<0>(pp)] && cr[get<1>(pp)] && !ccw(s.p1, s.p2, get<2>(pp)))\n\t\t--c;\n\t}\n\tans = max(ans, c/2+1);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Point{\n\tint x,y;\n\tPoint(){}\n\tPoint(int x,int y):x(x),y(y){}\n};\n\nbool isrose(const vs& grid,int i,int j)\n{\n\tint h=grid.size(),w=grid[0].size();\n\treturn 0<=i && i<h && 0<=j && j<w && grid[i][j]=='#';\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\treverse(all(grid));\n\t\t\n\t\tvector<tuple<int,int,int>> ts;\n\t\trep(i,h+1) rep(j,w+1){\n\t\t\tint a=isrose(grid,i-1,j-1),b=isrose(grid,i-1,j),\n\t\t\t\t\tc=isrose(grid,i,j-1),d=isrose(grid,i,j);\n\t\t\tif(a==b && a==d && a!=c)\n\t\t\t\tts.emplace_back(i,j,1);\n\t\t\tif(a==c && a==d && a!=b)\n\t\t\t\tts.emplace_back(i,j,-1);\n\t\t}\n\t\t\n\t\tsort(all(ts),[&](tuple<int,int,int> a,tuple<int,int,int> b){\n\t\t\tint i1,j1,x1; tie(i1,j1,x1)=a;\n\t\t\tint i2,j2,x2; tie(i2,j2,x2)=b;\n\t\t\t//return i1/(i1+j1)!=i2/(i2+j2)?i1/(i1+j1)<i2/(i2+j2):x1<x2;\n\t\t\treturn i1*(i2+j2)!=i2*(i1+j1)?i1*(i2+j2)<i2*(i1+j1):x1<x2;\n\t\t});\n\t\t\n\t\tint res=-1,cnt=1;\n\t\tfor(auto t:ts) res=max(res,cnt+=get<2>(t));\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconstexpr double EPS = 1e-4;\n\nint gcd(int x, int y) { return y == 0 ? x : gcd(y, x%y); }\n\nstruct point {\n    double x, y;\n    point() {}\n    point(double x, double y): x(x), y(y) {}\n\n    point operator + (const point& o) const { return point(x+o.x, y+o.y); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y); }\n    point operator * (const double a) const { return point(x*a, y*a); }\n\n    bool operator < (const point& o) const { return x == o.x ? y < o.y : x < o.x; }\n    bool operator == (const point& o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble fabs(point a) { return sqrt(a.x*a.x + a.y*a.y); }\ndouble dist(point a, point b) { return fabs(a - b); }\ndouble dist(line l) { return dist(l.a, l.b); }\ndouble dot(point a, point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(point a, point b) { return a.x*b.y - a.y*b.x; }\n\ndouble dist_point_line(point p, line l) {\n    if (dot(p - l.a, l.b - l.a) >= 0 && dot(p - l.b, l.a - l.b) >= 0)\n        return fabs(cross(p - l.a, l.b - l.a)) / dist(l);\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nbool has_intersection(line s, line t) {\n    double s1 = cross(s.b - s.a, t.a - s.b) * cross(s.b - s.a, t.b - s.b);\n    double s2 = cross(t.b - t.a, s.a - t.a) * cross(t.b - t.a, s.b - t.a);\n    if (s1 < 0 && s2 < 0) return true;\n    else if (s1 * s2 == 0) {\n        double d1 = dist_point_line(s.a, t);\n        double d2 = dist_point_line(s.b, t);\n        double d3 = dist_point_line(t.a, s);\n        double d4 = dist_point_line(t.b, s);\n        return min(min(d1, d2), min(d3, d4)) == 0;\n    }\n    return false;\n}\n\npoint intersection(line s, line t) {\n    double c1 = fabs(cross(t.b - t.a, s.a - t.a));\n    double c2 = fabs(cross(t.b - t.a, s.b - t.a));\n    return s.a + (s.b - s.a) * (c1 / (c1 + c2));\n}\n\nint H, W;\nint block[605][605];\n\nvector<line> ls;\nvector<point> ps;\n\nint main(void) {\n    cin >> H >> W;\n    for (int i = 0; i <= H; ++i) fill(block[i], block[i]+W+1, 0);\n    for (int i = 0 ; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            char ch; cin >> ch;\n            block[i][j] = (ch == '#') ? 1 : 0;\n        }\n    }\n\n    for (int i = 0; i <= H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if ((i == 0 && block[i][j] == 1) || (i > 0 && (block[i][j] ^ block[i-1][j]))) {\n                int lj = j++;\n                while (j < W) {\n                    if ((i == 0 || block[i-1][j] == block[i-1][lj]) &&\n                        block[i][j] == block[i][lj])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(i, lj), point(i, j));\n                --j;\n            }\n        }\n    }\n\n    for (int i = 0; i <= W; ++i) {\n        for (int j = 0; j < H; ++j) {\n            if ((i == 0 && block[j][i] == 1) || (i > 0 && (block[j][i] ^ block[j][i-1]))) {\n                int lj = j++;\n                while (j < H) {\n                    if ((i == 0 || block[j][i-1] == block[lj][i-1]) &&\n                        block[j][i] == block[lj][i])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(lj, i), point(j, i));\n                --j;\n            }\n        }\n    }\n\n    int itv = 10;\n    vector<point> es;\n    for (int i = 0; i <= itv*W; ++i) es.emplace_back(0, (double)i/itv);\n    for (int i = 0; i <= itv*H; ++i) es.emplace_back((double)i/itv, W);\n\n    int ans = 0;\n    point left_bottom(H, 0);\n    for (point e : es) {\n        line tiro(left_bottom, left_bottom + (e-left_bottom)*2);\n\n        set<point> cs;\n        for (line l : ls) {\n            if (has_intersection(tiro, l)) cs.insert(intersection(tiro, l));\n        }\n\n        ans = max(ans, (int)cs.size() / 2 + 1);\n\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define uniq(xs) ((xs).erase(unique((xs).begin(), (xs).end()), (xs).end()))\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    const double EPS = 1e-8;\n\n    bool EQ(double x, double y) { return abs(x - y) < EPS; }\n\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(double k) const { return Point(k * x, k * y); }\n        Point operator/(double k) const { return Point(x / k, y / k); }\n        bool operator==(const Point& p) const { return EQ(x, p.x) && EQ(y, p.y); }\n        bool operator<(const Point& p) const { return EQ(x, p.x) ? y < p.y : x < p.x; }\n    };\n    double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    double norm(const Point& a) { return sqrt(dot(a, a)); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n    int ccw(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n        if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n        if (dot(b, c) < 0) return +2;          // c--a--b 直線\n        if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n        return 0;                              // a--c--b 直線\n    }\n\n    struct Segment {\n        Point a, b;\n        Segment() {}\n        Segment(const Point& a, const Point& b) : a(a), b(b) {}\n    };\n    bool intersects(const Segment& s, const Segment& t) {\n        return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    }\n    ostream& operator<<(ostream& os, const Segment& s) {\n        return os << \"Segment(\" << s.a << \",\" << s.b << \")\";\n    }\n\n    Point crosspoint(const Segment& s, const Segment& t) {\n        assert(intersects(s, t));\n        double d = cross(t.b - t.a, s.b - s.a);\n        assert(abs(d) >= EPS);\n        return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n    }\n\n    int H, W;\n    vector<string> F;\n    void input() {\n        cin >> H >> W;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) {\n            cin >> F[i];\n        }\n        reverse(F.begin(), F.end());\n    }\n\n    int count(const vector<Segment>& L, const Segment& s) {\n        vector<Point> cs;\n        for (int i = 0; i < L.size(); i++) {\n            const Segment& t = L[i];\n            if (intersects(s, t)) {\n                cs.push_back(crosspoint(s, t));\n            }\n        }\n        sort(cs.begin(), cs.end());\n        uniq(cs);\n        //cout << s << \" \" << cs << endl;\n        return int(cs.size());\n    }\n\n    const int dy[] = {1, 0}, dx[] = {0, 1};\n    void solve() {\n        vector<Segment> L;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                int y = i, x = j;\n                for (int k = 0; k < 2; k++) {\n                    int ny = y + dy[k],\n                        nx = x + dx[k];\n                    if (ny >= H || nx >= W) {\n                        if (F[y][x] == '#') {\n                            if (x == nx) {\n                                L.push_back(Segment(Point(nx, ny), Point(nx + 1, ny)));\n                            } else if (y == ny) {\n                                L.push_back(Segment(Point(nx, ny), Point(nx, ny + 1)));\n                            }\n                        }\n                        continue;\n                    }\n                    if ( (F[y][x] == '#' && (ny >= H || nx >= W)) || (F[ny][nx] != F[y][x]) ) {\n                        if (x == nx) {\n                            L.push_back(Segment(Point(nx, ny), Point(nx + 1, ny)));\n                        } else if (y == ny) {\n                            L.push_back(Segment(Point(nx, ny), Point(nx, ny + 1)));\n                        }\n                        continue;\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < H; i++) {\n            double x = double(W);\n            for (int k = 0; k < 10; k++) {\n                double y = double(i) + k * 0.1 + 1.0 / 991;\n                ans = max(ans, count(L, Segment(Point(0, 0), Point(x, y))));\n            }\n        }\n        for (int j = 0; j < W; j++) {\n            double y = double(H);\n            for (int k = 0; k < 10; k++) {\n                double x = double(j) + k * 0.1 + 1.0 / 991;\n                ans = max(ans, count(L, Segment(Point(0, 0), Point(x, y))));\n            }\n        }\n        cout << 1 + (ans + 1) / 2 << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nstruct verticle {\n    double theta;\n    ll x, y;\n    bitset<4> pattern;\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll hn, wn; cin >> hn >> wn;\n    vector<string> b(hn); rep(i, hn) cin >> b[i]; reverse(all(b));\n\n    vector<verticle> vs;\n    rep(h, hn+1) rep(w, wn+1) if (h || w) {\n        verticle v;\n        v.x = h;\n        v.y = w;\n        v.theta = atan2(h, w);\n\n        // 10 \n        // 23\n        auto f = [&](ll h, ll w){ return h >= 0 && w >= 0 && h < hn && w < wn; };\n        v.pattern[2] = f(h, w-1) && b[h][w-1] == '#';\n        v.pattern[0] = f(h-1, w) && b[h-1][w] == '#';\n        v.pattern[1] = f(h-1, w-1) && b[h-1][w-1] == '#';\n        v.pattern[3] = f(h, w) && b[h][w] == '#'; \n        vs.pb(v);\n    }\n    sort(all(vs), [](const verticle& a, const verticle& b){ return a.theta < b.theta; });\n\n    ll ret = 0;\n    ll cut = 0;\n    ll i = 0;\n    while (i < vs.size()) {\n        double th = vs[i].theta;\n        vector<verticle> p;\n        while (i < vs.size() && vs[i].theta < th + EPS) {\n            p.pb(vs[i]);\n            i++;\n        }\n\n        rep(j, p.size()) {\n            // +1\n            if (!p[j].pattern[0] && !p[j].pattern[1] && p[j].pattern[2] && !p[j].pattern[3]) cut++;\n            if (p[j].pattern[0] && p[j].pattern[1] && !p[j].pattern[2] && p[j].pattern[3]) cut++;\n            // -1\n            if (p[j].pattern[0] && !p[j].pattern[1] && !p[j].pattern[2] && !p[j].pattern[3]) cut--;\n            if (!p[j].pattern[0] && p[j].pattern[1] && p[j].pattern[2] && p[j].pattern[3]) cut--;\n        }\n        chmax(ret, cut); \n    }\n    cout << ret + 1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double mEPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nclass Point{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a*x, a*y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\t//EPS??????????°??????????\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n\t}\n\n  friend ostream& operator<<(ostream& os, const Point& p);\n\n};\nostream& operator<<(ostream& os, const Point& p){\n  os << \"(\" << p.x << \",\" << p.y << \")\";\n  return os;\n}\n  \nclass Segment{\npublic:\n\tPoint p1, p2;\n};\n\n\ntypedef vector<Point> Polygon;\n\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\n\n//??????\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//???????????§??????\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > mEPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -mEPS) return CLOCKWISE;\n\tif (dot(a, b) < -mEPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn(ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; cin >> H >> W;\n  VS str(H); REP(i,H) cin >> str[i];\n  reverse(ALL(str));\n  vector<Segment> ls;\n  REP(y,H) REP(x,W){\n\tif(str[y][x] == '#' && (y == 0 || str[y-1][x] == '.')){\n\t  int t = x;\n\t  for(;t<W;++t)\n\t\tif(str[y][t] == '.' || (y > 0 && str[y-1][t] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y;\n\t  p2.x = t, p2.y = y;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  x = t;\n\t}\n  }\n  REP(y,H) REP(x,W){\n\tif(str[y][x] == '#' && (y == H-1 || str[y+1][x] == '.')){\n\t  int t = x;\n\t  for(;t<W;++t)\n\t\tif(str[y][t] == '.' || (y < H-1 && str[y+1][t] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y+1;\n\t  p2.x = t, p2.y = y+1;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  x = t;\n\t}\n  }\n  REP(x,W) REP(y,H){\n\tif(str[y][x] == '#' && (x == 0 || str[y][x-1] == '.')){\n\t  int t = y;\n\t  for(;t<H;++t)\n\t\tif(str[t][x] == '.' || (x > 0 && str[t][x-1] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y;\n\t  p2.x = x, p2.y = t;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  y = t;\n\t}\n  }\n  REP(x,W) REP(y,H){\n\tif(str[y][x] == '#' && (x == W-1 || str[y][x+1] == '.')){\n\t  int t = y;\n\t  for(;t<H;++t)\n\t\tif(str[t][x] == '.' || (x < W-1 && str[t][x+1] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x+1; p1.y = y;\n\t  p2.x = x+1, p2.y = t;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  y = t;\n\t}\n  }\n\n  vector<tuple<int,int,Point>> memo;\n  REP(i,SZ(ls)) FOR(j,i+1,SZ(ls))\n\tif(intersect(ls[i], ls[j])){\n\t  if(ls[i].p1 == ls[j].p1 || ls[i].p1 == ls[j].p2)\n\t\tmemo.PB(MT(i,j,ls[i].p1));\n\t  else\n\t\tmemo.PB(MT(i,j,ls[i].p2));\n\t}\n\n  int ans = 1;\n  for(double th=0.;th<PI/2;th+=0.001){\n\tSegment s;\n\ts.p1.x = 0, s.p1.y = 0;\n\ts.p2.x = 1000. * cos(th), s.p2.y = 1000. * sin(th);\n\tvector<bool> cr(SZ(ls));\n\tREP(i,SZ(ls)) cr[i] = intersect(s, ls[i]);\n\tint c = count(ALL(cr), true);\n\tfor(auto& pp: memo){\n\t  if(cr[get<0>(pp)] && cr[get<1>(pp)] && !ccw(s.p1, s.p2, get<2>(pp)))\n\t\t--c;\n\t}\n\tans = max(ans, c/2+1);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nstruct frac{\n\tint num,den;\n\tfrac(){}\n\tfrac(int a,int b):num(a),den(b){}\n};\n\nbool cmp(const frac &f1,const frac &f2)\n{\n\treturn f1.num*f2.den<f1.den*f2.num;\n}\n\nint gcd(int a,int b)\n{\n\tif(a<b) return gcd(b,a);\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nint W,H;\nchar field[660][660];\n\nfrac fracs[400400];\n\nint getState(int x,int y)\n{\n\t//char lu=field[x][H-y],ld=field[x][H-y+1];\n\t//char ru=field[x+1][H-y],rd=field[x+1][H-y+1];\n\tchar lu=field[H-y][x],ld=field[H-y+1][x];\n\tchar ru=field[H-y][x+1],rd=field[H-y+1][x+1];\n\tif(lu==ld&&ld==ru&&ld!=rd) return 1;\n\tif(ld==ru&&ru==rd&&lu!=rd) return 2;\n\treturn 0;\n}\n\nint getD(int x,int y)\n{\n\tint res=0;\n\tfor(int c=1;;c++)\n\t{\n\t\tint xx=x*c,yy=y*c;\n\t\tif(xx>W-1) break;\n\t\tif(yy>H) break;\n\t\tint s=getState(xx,yy);\n\t\tif(s==1) res++;\n\t\tif(s==2) res--;\n\t}\n\treturn res;\n}\n\nchar ch[660];\n\nint main()\n{\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<660;i++) for(int j=0;j<660;j++) field[i][j]='.';\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tscanf(\"%s\",ch);\n\t\tfor(int j=1;j<=W;j++) field[i][j]=ch[j-1];\n\t}\n\tint c=0;\n\tfor(int x=0;x<=W-1;x++) for(int y=1;y<=H;y++)\n\t{\n\t\tif(gcd(x,y)!=1) continue;\n\t\tfracs[c]=frac(x,y);\n\t\tc++;\n\t}\n\tsort(fracs,fracs+c,cmp);\n\tint ans=1;\n\tint cur=1;\n\tfor(int i=0;i<c;i++)\n\t{\n\t\tcur+=getD(fracs[i].num,fracs[i].den);\n\t\tans=max(ans,cur);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-11, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<bool>>fi(H+2, vector<bool>(W+2));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '#') {\n\t\t\t\tfi[i+1][j+1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<Line>ls;\n\tvector<double>katas;\n\tvector<vector<bool>>tates(H + 2, vector<bool>(W + 1));\n\tvector<vector<bool>>yokos(H + 1, vector<bool> (W + 2));\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 1; x < W + 1; ++x) {\n\t\t\tif (fi[y][x]) {\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tPoint ld(x, y + 1);\n\t\t\t\t\tPoint lu(x, y);\n\t\t\t\t\tPoint rd(x + 1, y + 1);\n\t\t\t\t\tPoint ru(x + 1, y);\n\t\t\t\t\tif (!fi[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\ttates[y][x - 1] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(ld, lu);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == 1) {\n\t\t\t\t\t\t\tyokos[y][x] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(rd, ld);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == 2) {\n\t\t\t\t\t\t\ttates[y][x] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(ru, rd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tyokos[y - 1][x] = true;\n\t\t\t\t\t\t\t//ls.emplace_back(lu, ru);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < W + 1; ++x) {\n\t\tbool now = false;\n\t\tPoint from;\n\t\tfor (int y = 0; y < H + 2; ++y) {\n\t\t\t\n\t\t\tif (tates[y][x]) {\n\t\t\t\tif (!now) {\n\t\t\t\t\tfrom=Point(x+1,y);\n\t\t\t\t}\n\t\t\t\tnow = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (now) {\n\t\t\t\t\tls.emplace_back(from, Point(x + 1, y));\n\t\t\t\t}\n\t\t\t\tnow = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = 0; y < H + 1; ++y) {\n\t\tbool now = false;\n\t\tPoint from;\n\t\tfor (int x = 0; x < W + 2; ++x) {\n\t\t\tif (yokos[y][x]) {\n\t\t\t\tif (!now) {\n\t\t\t\t\tfrom = Point(x, y + 1);\n\t\t\t\t}\n\t\t\t\tnow = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (now) {\n\t\t\t\t\tls.emplace_back(from, Point(x, y + 1));\n\t\t\t\t}\n\t\t\t\tnow = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 2; x < W + 2; ++x) {\n\t\t\tkatas.push_back(double(y-(H+1))/ (x - 1));\n\t\t}\n\t}\n\tkatas.push_back(0);\n\tkatas.push_back(-1000);\n\tsort(katas.begin(), katas.end());\n\tvector<double>newkatas;\n\tdouble now = 1;\n\tfor (int i = 0; i < katas.size(); ++i) {\n\t\tif (abs(katas[i]-now)>1e-10) {\n\t\t\tnewkatas.push_back(katas[i]);\n\t\t\tnow = (katas[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < newkatas.size()-1; ++i) {\n\t\tdouble kata = (newkatas[i + 1] + newkatas[i])/2;\n\t\tLine l(Point(1, H + 1), Point(1 + 1, H + 1 + kata));\n\t\tint nans = 0;\n\t\tfor (int j = 0; j < ls.size(); ++j) {\n\t\t\tif (isis_ls(l, ls[j])) {\n\t\t\t\tnans++;\n\t\t\t}\n\t\t}\n\t\tif (fi[H][1])nans--;\n\t\tans = max(ans, 1+nans/2);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\nint H,W;\nstring s[601];\nbool dx[601][601],dy[601][601];\nint gcd(int x,int y){\n\tif(y==0) return x;\n\treturn gcd(y,x%y);\n}\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[H-1-i];\n\ts[H].assign(W,'.');\n\trep(i,H+1) s[i]+='.';\n\trep(i,H) rep(j,W+1) dx[i][j]=(s[i][j]==s[i+1][j]);\n\trep(i,H+1) rep(j,W) dy[i][j]=(s[i][j]==s[i][j+1]);\n\tint mx=0;\n\trep1(a,W) rep1(b,H){\n\t\tif(gcd(a,b)!=1) continue;\n\t\tint cnt=0;\n\t\trep1(x,W){\n\t\t\tint y=(b*x-1)/a;\n\t\t\tif(y<H&&!dy[y][x-1]) cnt++;\n\t\t}\n\t\trep1(y,H){\n\t\t\tint x=(a*y)/b;\n\t\t\tif(x<W&&!dx[y-1][x]) cnt++;\n\t\t}\n\t\tmx=max(mx,cnt);\n\t\tcnt=0;\n\t\trep1(x,W){\n\t\t\tint y=(b*x)/a;\n\t\t\tif(y<H&&!dy[y][x-1]) cnt++;\n\t\t}\n\t\trep1(y,H){\n\t\t\tint x=(a*y-1)/b;\n\t\t\tif(x<W&&!dx[y-1][x]) cnt++;\n\t\t}\n\t\tmx=max(mx,cnt);\n\t}\n\tcout<<(mx+3)/2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<double,double>D;\ntypedef pair<P,int>PP;\ntypedef pair<double,P>dP;\ntypedef pair<D,int>Di;\n\nconst int MAX_N = 602;\nconst int dx[] = {1,1,0,0};\nconst int dy[] = {0,0,1,-1};\nconst int ex[] = {1,0,1};\nconst int ey[] = {0,1,1};\n\nint a[MAX_N][MAX_N];\nint flag[MAX_N][MAX_N];\nint h,w;\nint gcd_table[MAX_N][MAX_N];\nvector<PP> vec;\n\nvoid dfs(int u,int v)\n{\n    flag[u][v] = 1;\n    if(u < w-1 && 0 < v && !a[u+1][v] && !a[u][v-1] && !a[u+1][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u < w-1 && 0 < v && a[u+1][v] && a[u][v-1] && !a[u+1][v-1]){  //??????2\n        vec.push_back(PP(P(u+1,v),2));\n    }\n    if(0 < u && v < h-1 && !a[u-1][v] && !a[u][v+1] && !a[u-1][v+1]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v < h-1 && a[u-1][v] && a[u][v+1] && !a[u-1][v+1]){  //??????2\n        vec.push_back(PP(P(u,v+1),3));\n    }\n    rep(i,4){\n        int nx = u + dx[i],ny = v + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && a[nx][ny] && !flag[nx][ny]){\n            dfs(nx,ny);\n        }\n    }\n    return;\n}\n\nint gcd(int a,int b)\n{\n    if(a % b == 0){\n        return b;\n    }\n    return gcd(b,a % b);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&h,&w);\n\trep(j,h){\n        string s;\n        cin >> s;\n        rep(i,s.length()){\n            flag[i][j] = 0;\n            if(s[i] == '#'){\n                a[i][h-j-1] = 1;\n            }else{\n                a[i][h-j-1] = 0;\n            }\n        }\n\t}\n    for(int i = 1;i < 600;i++){\n        for(int j = i;j < 600;j++){\n            gcd_table[j][i] = gcd(j,i);\n        }\n    }\n    bool fl = false;\n    rep(i,w){\n        rep(j,h){\n            if(a[i][j]){\n                dfs(i,j);\n                fl = true;\n                break;\n            }\n        }\n        if(!fl){\n            break;\n        }\n    }\n    // rep(i,vec.size()){\n    //     cout << vec[i].first.first << \" \" << vec[i].first.second << \" \" << vec[i].second << \"\\n\";\n    // }\n    vector<dP> tilt;\n    rep(i,vec.size()){\n        int p1 = (vec[i].first).first;\n        int p2 = (vec[i].first).second;\n        tilt.push_back(dP((double)p2 / p1,P(i,vec[i].second)));\n    }\n    sort(all(tilt));\n    map<P,int> mp;\n    vector<PP> cand;\n    rep(i,tilt.size()){\n        int cnt[] = {0,0,0,0};\n        int id = i;\n        double n1 = tilt[i].first;\n        int n2 = (tilt[i].second).first;\n        int n3 = (tilt[i].second).second;\n        cnt[n3]++;\n        while(id + 1 < tilt.size() && abs(tilt[id].first-tilt[id+1].first) < EPS){\n            n1 = tilt[i+1].first;\n            n3 = (tilt[i+1].second).first;\n            cnt[n3]++;\n            id++;\n        }\n        int mx = max(cnt[0]+cnt[3],cnt[1]+cnt[2]);\n        i = id;\n        P p = vec[n2].first;\n        int md = gcd_table[max(p.first,p.second)][min(p.first,p.second)];\n        mp[P(p.first / md,p.second / md)]++;\n        cand.push_back(PP(P(p.first / md,p.second / md),mx));\n    }\n    for(int i = 1;i < w;i++){\n        for(int j = 1;j < h;j++){\n            int md = gcd_table[max(i,j)][min(i,j)];\n            P p = P(i / md,j / md);\n            if(!mp[p]){\n                cand.push_back(PP(p,0));\n                mp[p]++;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,cand.size()){\n        vector<Di> cros;\n        P p = cand[i].first;\n        rep(j,p.first-1){\n            cros.push_back(Di(D(j+1,(double)(j+1) * p.second / p.first),0));\n        }\n        rep(j,p.second-1){\n            cros.push_back(Di(D((double)(j+1) * p.first / p.second,j+1),1));\n        }\n        sort(all(cros));\n        vector<int> act;\n        rep(j,cros.size()){\n            act.push_back(cros[j].second);\n        }\n        act.push_back(2);\n        int cnt = 0;\n        int px = 0,py = 0;\n        int bf = a[0][0];\n        int res = 0;\n        while(1){\n            px += ex[act[cnt%act.size()]];\n            py += ey[act[cnt%act.size()]];\n            if(px < w && py < h){\n                if(bf == 1 && !a[px][py]){\n                    res++;\n                }\n                bf = a[px][py];\n            }else{\n                if(bf == 1){\n                    res++;\n                }\n                break;\n            }\n            cnt++;\n        }\n        ans = max(res+cand[i].second,ans);\n    }\n    cout << ans + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nstring F[600];\n\nbool isgrid(int x, int y)\n{\n  return (0 <= x && x < W && 0 <= y && y < H && F[y][x] == '#');\n}\n\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> F[i];\n  }\n\n  vector< pair< pair< int, int >, int > > Event;\n  for(int i = -1; i <= H; i++) {\n    for(int j = -1; j <= W; j++) {\n      if(!isgrid(j, i) && !isgrid(j + 1, i) && !isgrid(j, i + 1) && isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, 1});\n      else if(isgrid(j, i) && isgrid(j + 1, i) && isgrid(j, i + 1) && !isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, 1});\n      else if(isgrid(j, i) && !isgrid(j + 1, i) && !isgrid(j, i + 1) && !isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, -1});\n      else if(!isgrid(j, i) && isgrid(j + 1, i) && isgrid(j, i + 1) && isgrid(j + 1, i + 1))\n        Event.push_back({{j, H - i}, -1});\n    }\n  }\n\n  sort(begin(Event), end(Event), [](auto &a, auto &b)\n  {\n    int c = a.first.first * b.first.second;\n    int d = a.first.second * b.first.first;\n    if(c == d) return (a.second < b.second);\n    return (c < d);\n  });\n\n\n  int proc = 1, ret = 1;\n  for(auto &k : Event) {\n    proc += k.second;\n    ret = max(ret, proc);\n  }\n\n  cout << ret << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define MOD_TYPE 1\n\n#pragma region Macros\n#include <bits/stdc++.h>\nusing namespace std;\n/*\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nusing multiInt = boost::multiprecision::cpp_int;\nusing lld = boost::multiprecision::cpp_dec_float_100;\n*/\n/*\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n*/\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pld = pair<ld, ld>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconstexpr ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\n//constexpr ll MOD = 1;\nconstexpr int INF = (int)1e9;\nconstexpr ll LINF = (ll)4e18;\nconstexpr double PI = acos(-1.0);\nconstexpr double EPS = 1e-10;\nconstexpr int Dx[] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nconstexpr int Dy[] = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define REPI(i, m, n) for (int i = m; i < (int)(n); ++i)\n#define repi(i, n) REPI(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << \"\\n\"\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << \"\\n\"\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << \"\\n\"\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << \"\\n\"\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << \"\\n\"\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << \"\\n\";\n\ninline void init_main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(30) << setiosflags(ios::fixed);\n}\ntemplate <typename T>\ninline bool chmin(T &a, T b)\n{\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T>\ninline bool chmax(T &a, T b)\n{\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ninline ll CEIL(ll a, ll b)\n{\n  return (a + b - 1) / b;\n}\ntemplate <typename A, size_t N, typename T>\ninline void Fill(A (&array)[N], const T &val)\n{\n  fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T, typename U>\nconstexpr ostream &operator<<(ostream &os, pair<T, U> &p) noexcept\n{\n  os << p.first << \" \" << p.second;\n  return os;\n}\n#pragma endregion\n\nusing Real = double;\nusing Point = complex<Real>;\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d)\n{\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p)\n{\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p)\n{\n  return os << fixed << setprecision(20) << p.real() << \" \" << p.imag();\n}\n\n// 点 p を反時計回りに theta 回転\ninline Point rotate(Real theta, const Point &p)\n{\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r)\n{\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d)\n{\n  return (d * PI / 180.0);\n}\n\n// a-b-c の角度のうち小さい方を返す\nReal get_angle(const Point &a, const Point &b, const Point &c)\n{\n  const Point v(a - b), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta)\n    swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std\n{\n  bool operator<(const Point &a, const Point &b)\n  {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n} // namespace std\n\nvoid solve()\n{\n  int h, w;\n  cin >> h >> w;\n  string s[610];\n  s[0] = s[h + 1] = string(w + 1, '.');\n  rep(i, h)\n  {\n    cin >> s[i + 1];\n    s[i + 1].push_back('.');\n  }\n\n  vector<pair<double, int>> v;\n  rep(i, h + 1) rep(j, w)\n  {\n    Point p(j + 1, h - i);\n    if (s[i][j] == '#' and s[i + 1][j] == '.' and s[i][j + 1] == '.' and s[i + 1][j + 1] == '.')\n      v.push_back(MP(arg(p) + EPS, 1));\n    else if (s[i][j] == '.' and s[i + 1][j] == '#' and s[i][j + 1] == '#' and s[i + 1][j + 1] == '#')\n      v.push_back(MP(arg(p) + EPS, 1));\n    else if (s[i][j] == '#' and s[i + 1][j] == '#' and s[i][j + 1] == '#' and s[i + 1][j + 1] == '.')\n      v.push_back(MP(arg(p) - EPS, -1));\n    else if (s[i][j] == '.' and s[i + 1][j] == '.' and s[i][j + 1] == '.' and s[i + 1][j + 1] == '#')\n      v.push_back(MP(arg(p) - EPS, -1));\n  }\n  sort(all(v));\n\n  int Max = 1, now = 1;\n  double theta;\n  int t;\n  for (auto p : v)\n  {\n    tie(theta, t) = p;\n    now += t;\n    chmax(Max, now);\n  }\n  cout << Max << \"\\n\";\n}\n\nint main()\n{\n  init_main();\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define uniq(xs) ((xs).erase(unique((xs).begin(), (xs).end()), (xs).end()))\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    const double EPS = 1e-5;\n\n    bool EQ(double x, double y) { return abs(x - y) < EPS; }\n\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(double k) const { return Point(k * x, k * y); }\n        Point operator/(double k) const { return Point(x / k, y / k); }\n        bool operator==(const Point& p) const { return EQ(x, p.x) && EQ(y, p.y); }\n        bool operator<(const Point& p) const { return EQ(x, p.x) ? y < p.y : x < p.x; }\n    };\n    double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    double norm(const Point& a) { return sqrt(dot(a, a)); }\n    double angle(const Point& a) { return atan2(a.y, a.x); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n    int H, W;\n    vector<string> F;\n    void input() {\n        cin >> H >> W;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) {\n            cin >> F[i];\n        }\n    }\n\n    struct E {\n        Point p;\n        bool type;\n        E() {}\n        E(Point p, bool type) : p(p), type(type) { }\n        bool operator<(const E& e) const {\n            double a = angle(p), b = angle(e.p);\n            return (EQ(a, b) ? type > e.type : a > b);\n        }\n    };\n    ostream& operator<<(ostream& os, const E& e) {\n        return os << \"E(\" << e.p << \"->\" << e.type << \")\";\n    }\n\n    void C(int y, int x, priority_queue<E>& Q) {\n        string s, t;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                int ny = y - i, nx = x - j;\n                if (ny < 0 || nx < 0) {\n                    s.push_back('.');\n                } else {\n                    s.push_back(F[ny][nx]);\n                }\n                ny = y + i, nx = x + j;\n                if (ny >= H || nx >= W) {\n                    t.push_back('.');\n                } else {\n                    t.push_back(F[ny][nx]);\n                }\n            }\n        }\n\n        if (false) {\n            cout << y << \" \" << x << endl;\n            cout << s << \" \" << t << endl;\n        }\n        if (s == \"#...\" || s == \"###.\") {\n            Point p(x, H - y);\n            Q.push(E(p, s == \"###.\"));\n        }\n        if (t == \"#...\" || t == \"###.\") {\n            Point p(x + 1, H - (y + 1));\n            Q.push(E(p, t == \"#...\"));\n        }\n    }\n\n    void solve() {\n        priority_queue<E> Q;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                C(i, j, Q);\n            }\n        }\n        int ans = 1;\n        int c = 1;\n        while (!Q.empty()) {\n            E e = Q.top(); Q.pop();\n            c += (e.type ? +1 : -1);\n            ans = max(ans, c);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct obj{ int a,b,c; };\n\nsigned main(){\n\tint h,w;\n\tstring f[610];\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++) cin >> f[i];\n\tvector<obj> vec;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif((i && f[i][j] != f[i - 1][j]) || (!i && f[i][j] == '#')){\n\t\t\t\tvec.push_back({h - i,j + 1,1});\n\t\t\t\tvec.push_back({h - i,j,-1});\n\t\t\t}\n\t\t\tif((j != w - 1 && f[i][j] != f[i][j + 1]) || (j == w - 1 && f[i][j] == '#')){\n\t\t\t\tvec.push_back({h - i - 1,j + 1,1});\n\t\t\t\tvec.push_back({h - i,j + 1,-1});\n\t\t\t}\n\t\t}\n\t}\n\tsort(all(vec),[](const obj &x,const obj &y){\n\t\treturn (x.a * y.b != x.b * y.a) ? (x.a * y.b < x.b * y.a) : (x.c < y.c);\n\t});\n\tint sum = 0,ma = 0;\n\tfor(const auto &v : vec){\n\t\tsum += v.c;\n\t\tchmax(ma,(sum + 3) / 2);\n\t}\n\tcout << ma << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\nint H,W;\nstring s[601];\nbool dx[601][601],dy[601][601];\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[H-1-i];\n\ts[H].assign(W,'.');\n\trep(i,H+1) s[i]+='.';\n\trep(i,H) rep(j,W+1) dx[i][j]=(s[i][j]==s[i+1][j]);\n\trep(i,H+1) rep(j,W) dy[i][j]=(s[i][j]==s[i][j+1]);\n\tint mx=0;\n\trep1(a,W) rep1(b,H){\n\t\tint cnt=0;\n\t\trep1(x,W){\n\t\t\tint y=(b*x-1)/a;\n\t\t\tif(y<H&&!dy[y][x-1]) cnt++;\n\t\t}\n\t\trep1(y,H){\n\t\t\tint x=(a*y)/b;\n\t\t\tif(x<W&&!dx[y-1][x]) cnt++;\n\t\t}\n\t\tmx=max(mx,cnt);\n\t\tcnt=0;\n\t\trep1(x,W){\n\t\t\tint y=(b*x)/a;\n\t\t\tif(y<H&&!dy[y][x-1]) cnt++;\n\t\t}\n\t\trep1(y,H){\n\t\t\tint x=(a*y-1)/b;\n\t\t\tif(x<W&&!dx[y-1][x]) cnt++;\n\t\t}\n\t\tmx=max(mx,cnt);\n\t}\n\tcout<<(mx+3)/2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000\n#define INF 1e9\ntypedef pair<double,int> P;\n\nint H,W;\n\ndouble make(int x,int y){\n  if(x == 0) return INF;\n  return (double)y / x;\n}\n\nint pat(char a,char b,char c,char d){\n  if(a == '.' && b == '#' && \n     c == '#' && d == '#'){\n    return 1;\n  }\n  if(a == '#' && b == '.' && \n     c == '.' && d == '.'){\n    return 1;\n  }\n  if(a == '.' && b == '.' && \n     c == '.' && d == '#'){\n    return -1;\n  }\n  if(a == '#' && b == '#' && \n     c == '#' && d == '.'){\n    return -1;\n  }\n \n  return 0;\n}\n\nint main(){\n  string in;\n  char a[MAX][MAX];\n\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      a[i][j] = '.';\n    }\n  }\n\n  cin >> H >> W;\n  for(int i = H ; i > 0 ; i--){\n    cin >> in;\n    for(int j = 1 ; j <= W ; j++){\n      a[i][j] = in[j-1];\n    }\n  }\n\n  vector<P> v;\n  for(int i = 0 ; i <= H ; i++){\n    for(int j = 0 ; j <= W ; j++){\n      char u1 = a[i+1][j],u2 = a[i+1][j+1];\n      char u3 = a[i][j],u4 = a[i][j+1];\n      int n = pat(u1,u2,u3,u4);\n\n      if(n != 0){\n\tdouble r = make(j,i);\n\tv.push_back(P(r,n));\n      }\n    }\n  }\n\n  sort(v.begin(),v.end());\n  int len = (int)v.size(),ans = 1,sum = 1;\n  for(int i = 0 ; i < len ; i++){\n    sum += v[i].second;\n    ans = max(ans,sum);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<double,int> P;\n\nint h,w,sum=1,ans;\nstring s[1111];\n\nint main(){\n    cin>>h>>w;\n    r(i,h)cin>>s[h-i];\n    r(i,h)s[i+1]=\".\"+s[i+1]+\".\";\n    r(i,w+2)s[h+1]+='.',s[0]+='.';\n    vector<P>v;\n    for(int i=1;i<=h+1;i++){\n        for(int j=1;j<=w+1;j++){\n            double x=atan2(j-1,i-1);\n            string t=s[i].substr(j-1,2)+s[i-1].substr(j-1,2);\n            if(t==\"###.\"||t==\"...#\")v.push_back(P(x,1));\n            if(t==\".###\"||t==\"#...\")v.push_back(P(x,-1));\n        }\n    }\n    sort(v.begin(),v.end());\n    r(i,v.size()){\n        sum+=v[i].second;\n        ans=max(sum,ans);\n    }\n    cout<<ans<<endl;\n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct PQ {\n\tint den, num;\n\tPQ(int den, int num) : den(den), num(num) {}\n};\nbool operator>(const PQ& pq1, const PQ& pq2) {\n\treturn pq1.num * pq2.den > pq1.den * pq2.num;\n}\nbool operator<(const PQ& pq1, const PQ& pq2) {\n\treturn pq2 > pq1;\n}\nbool operator==(const PQ& pq1, const PQ& pq2) {\n\treturn !(pq1 > pq2) && !(pq2 > pq1);\n}\nbool operator>=(const PQ& pq1, const PQ& pq2) {\n\treturn pq1 == pq2 || pq1 > pq2;\n}\nbool operator<=(const PQ& pq1, const PQ& pq2) {\n\treturn pq2 >= pq1;\n}\n\ntypedef pair<PQ, PQ> PQP;\n\nint H, W;\nvector<string> M;\nbool dot[601][601] = {0};\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nbool inRange2(int x, int y) {\n\treturn 0 <= x && x <= W && 0 <= y && y <= H;\n}\nbool isWall(int x, int y) {\n\tif ( !inRange(x, y) ) return false;\n\treturn M[y][x] == '#';\n}\nbool getDot(int x, int y) {\n\tif ( !inRange2(x, y) ) return false;\n\treturn dot[y][x];\n}\nbool moveCheck(int x1, int y1, int x2, int y2) {\n\tif ( !getDot(x2, y2) ) return false;\n\tmap<P, int> cnt;\n\tfor (int dy = -1; dy <= 0; ++dy) {\n\t\tfor (int dx = -1; dx <= 0; ++dx) {\n\t\t\tcnt[P(x1+dx, y1+dy)]++;\n\t\t\tcnt[P(x2+dx, y2+dy)]++;\n\t\t}\n\t}\n\tset<bool> s;\n\tfor ( pair<const P, int>& p : cnt ) {\n\t\tif (p.second == 2 ) {\n\t\t\ts.insert(isWall(p.first.first, p.first.second));\n\t\t}\n\t}\n\treturn s.size() == 2;\n}\nint moveX(int x0, int y0) {\n\tbool bfl = true, bfr = true;\n\tbool fl = true, fr = true;\n\tfor (int dx = 1; dx <= W+3; ++dx) {\n\t\tfr = fr && moveCheck(x0+dx-1, y0, x0+dx, y0);\n\t\tfl = fl && moveCheck(x0-(dx-1), y0, x0-dx, y0);\n\t\tif ( !fr && !fl ) {\n\t\t\tif (bfl) return x0-(dx-1);\n\t\t\treturn x0+dx-1;\n\t\t}\n\t\tbfl = fl, bfr = fr;\n\t}\n}\nint moveY(int x0, int y0) {\n\tbool bfl = true, bfr = true;\n\tbool fl = true, fr = true;\n\tfor (int dy = 1; dy <= H+3; ++dy) {\n\t\tfr = fr && moveCheck(x0, y0+(dy-1), x0, y0+dy);\n\t\tfl = fl && moveCheck(x0, y0-(dy-1), x0, y0-dy);\n\t\tif ( !fr && !fl ) {\n\t\t\tif (bfl) return y0-(dy-1);\n\t\t\treturn y0+dy-1;\n\t\t}\n\t\tbfl = fl, bfr = fr;\n\t}\n}\n\nPQ f(int x, int y) {\n\treturn PQ(y, x);\n}\n\nvector<PQP> r;\nvoid addLine(int x1, int y1, int x2, int y2) {\n\tPQ pq1 = f(x1, y1);\n\tPQ pq2 = f(x2, y2);\n\tif (pq2 < pq1) swap(pq1, pq2);\n\tr.push_back( PQP(pq1, pq2) );\n}\nint main() {\n\tcin >> H >> W;\n\tM.resize(H);\n\tfor (int i = 0; i < H; ++i) cin >> M[i];\n\tfor (int y = 0; y <= H; ++y) {\n\t\tfor (int x = 0; x <= W; ++x) {\n\t\t\tset<bool> s;\n\t\t\tfor (int dx = -1; dx <= 0; ++dx) {\n\t\t\t\tfor (int dy = -1; dy <= 0; ++dy) {\n\t\t\t\t\ts.insert( isWall(x+dx, y+dy) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tdot[y][x] = s.size() == 2;\n\t\t}\n\t}\n\tint sx = -1, sy = -1;\n\tfor (int y = 0; y < H; ++y) {\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tif ( isWall(x, y) ) {\n\t\t\t\tsx = x, sy = y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sx >= 0) break;\n\t}\n\t{\n\t\tint x = sx, y = sy;\n\t\twhile (1) {\n\t\t\tint nx = moveX(x, y);\n\t\t\tint ny = moveY(nx, y);\n//\t\t\tassert(nx != x);\n//\t\t\tassert(ny != y);\n\t\t\taddLine(x, y, nx, y);\n\t\t\taddLine(nx, y, nx, ny);\n\t\t\tif (nx == sx && ny == sy) break;\n\t\t\tx = nx, y = ny;\n\t\t}\n\t\tsort(r.begin(), r.end());\n\t\tint mx = 0;\n\t\tmap<PQ, int> m;\n\t\t{\n\t\t\tvector<PQ> v;\n\t\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\t\tv.push_back(r[i].first);\n\t\t\t\tv.push_back(r[i].second);\n\t\t\t}\n\t\t\tsort(v.begin(), v.end());\n\t\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\t\tm[v[i]] = i;\n\t\t\t}\n\t\t\tmx = v.size();\n\t\t}\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\tv.push_back( P(m[r[i].first], m[r[i].second]) );\n\t\t}\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t//\t\tcout << v[i].first << \" \" << v[i].second << endl;\n\t\t}\n\t\tvector<int> cnt(mx*2+3, 0);\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\t++cnt[v[i].first*2+1];\n\t\t\t--cnt[v[i].second*2];\n\t\t}\n\t\tfor (int i = 0; i+1 < cnt.size(); ++i) {\n\t\t\tcnt[i+1] += cnt[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < cnt.size(); ++i) {\n\t\t\tans = max(ans, cnt[i]);\n\t\t}\n\t\tcout << ans/2+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<double,int> P;\n\n\nint H,W;\nstring str;\n\nvector <P> u;\nchar t[600][600];\n\nchar T(int y,int x){\n  if(y<0||x<0)return '.';\n  if(y>=H||x>=W)return '.';\n  return t[y][x];\n}\nint main(){\n\n  double a,x,y;\n  \n  cin>>H>>W;\n\n  u.clear();\n  for(int i=H-1;i>=0;i--){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      t[i][j]=str[j];\n    }\n  }\n  \n  \n  for(int i=-1;i<H;i++){\n    for(int j=-1;j<W;j++){\n      if(T(i,j)=='#'&&T(i+1,j)=='#'&&T(i,j+1)=='.'&&T(i+1,j+1)=='#'){\n\tx=j+1;y=i+1;\n\ta=acos( (x)/(sqrt(x*x+y*y)) );\n\tu.push_back(P(a,-1));\n      }\n      if(T(i,j)=='.'&&T(i+1,j)=='#'&&T(i,j+1)=='.'&&T(i+1,j+1)=='.'){\n\tx=j+1;y=i+1;\n\ta=acos( (x)/(sqrt(x*x+y*y)) );\n\tu.push_back(P(a,1));\n      }\n      if(T(i,j)=='#'&&T(i+1,j)=='.'&&T(i,j+1)=='#'&&T(i+1,j+1)=='#'){\n\tx=j+1;y=i+1;\n\ta=acos( (x)/(sqrt(x*x+y*y)) );\n\tu.push_back(P(a,1));\n      }\n      if(T(i,j)=='.'&&T(i+1,j)=='.'&&T(i,j+1)=='#'&&T(i+1,j+1)=='.'){\n\tx=j+1;y=i+1;\n\ta=acos( (x)/(sqrt(x*x+y*y)) );\n\tu.push_back(P(a,-1));\n      }\n    }\n  }\n    \n  int cnt=1,ans=1;\n  sort(u.begin(),u.end());\n  for(int i=0;i<(int)u.size();i++){\n    \n    cnt+=u[i].second;\n    ans=max(ans,cnt);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int h, w; cin >> h >> w;\n  V<string> s(h); for (auto&& e : s) cin >> e;\n  reverse(begin(s), end(s));\n  struct Event {\n    int id, x, y; bool in;\n    bool operator<(const Event& r) const {\n      return y * r.x != r.y * x ? y * r.x < r.y * x : in < r.in;\n    }\n  };\n  V<Event> es;\n  for (int x = 0; x < w; ++x) for (int y = 0; y < h; ++y) {\n    es.emplace_back(Event{y * w + x, x + 1, y, true});\n    es.emplace_back(Event{y * w + x, x, y + 1, false});\n  }\n  sort(begin(es), end(es));\n  int res = 0, curr = 0;\n  set< pair<int, char> > se;\n  for (const auto& e : es) {\n    if (e.in) {\n      auto itr = se.emplace(e.id, s[e.id / w][e.id % w]).first;\n      if (s[e.id / w][e.id % w] == '#') {\n        if ((itr == begin(se) or prev(itr)->second == '.') and (next(itr) == end(se) or next(itr)->second == '.')) ++curr;\n      } else {\n        if (itr != begin(se) and prev(itr)->second == '#' and next(itr) != end(se) and next(itr)->second == '#') ++curr;\n      }\n    } else {\n      auto itr = se.find({e.id, s[e.id / w][e.id % w]});\n      if (s[e.id / w][e.id % w] == '#') {\n        if ((itr == begin(se) or prev(itr)->second == '.') and (next(itr) == end(se) or next(itr)->second == '.')) --curr;\n      } else {\n        if (itr != begin(se) and prev(itr)->second == '#' and next(itr) != end(se) and next(itr)->second == '#') --curr;\n      }\n      se.erase({e.id, s[e.id / w][e.id % w]});\n    }\n    // for (auto itr = begin(se); itr != end(se); ++itr) {\n    //   curr += itr->second == '#' and (next(itr) == end(se) or next(itr)->second == '.');\n    // }\n    res = max(res, curr + 1);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<tuple>\nusing namespace std;\nint H, W, x[1000][1000], maxn = 1, cnt = 1;\nvector<tuple<long double, int, int>>tup;\nint analysis(int p, int q) {\n\tint D = x[p - 1][q - 1] * 1 + x[p - 1][q] * 2;\n\tD += x[p][q - 1] * 4 + x[p][q] * 8;\n\tif (D == 8 || D == 7)return 1;\n\tif (D == 1 || D == 14)return -1;\n\treturn 0;\n}\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tchar c; cin >> c; if (c == '#')x[i][j] = 1;\n\t\t\tint XX = H - i + 1, YY = j;\n\t\t\ttup.push_back(make_tuple(1.0l*YY / XX, i, j));\n\t\t}\n\t}\n\tsort(tup.begin(), tup.end());\n\tfor (int i = 0; i < tup.size(); i++) {\n\t\tcnt += analysis(get<1>(tup[i]), get<2>(tup[i]));\n\t\tif (i >= 1 && get<0>(tup[i - 1]) == get<0>(tup[i])) {\n\t\t\tmaxn = max(maxn, cnt);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1);\nint sig(double r){return (r<-EPS)?-1:(r>+EPS)?+1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y): x(x),y(y){}\n\tPt operator+(const Pt&a)const {return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt&a)const {return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt&a)const {return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt&a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt&a)const{return x*a.y-y*a.x;}\n};\ndouble tri(const Pt&a,const Pt&b,const Pt&c){return(b-a).det(c-a);}\nPt pLL(Pt a,Pt b,Pt c,Pt d){\n\tb=b-a;d=d-c;return a+b*(c-a).det(d)/b.det(d);\n}\nchar str[700][700];\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;\n\t\tint c=b;\n\t\tb=a;\n\t\ta=c;\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[a-1-i]);\n\tint ret=0;\n\t\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(gcd(i+1,j+1)>1)continue;\n\t\t\tint val=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,(1e-8)+j+1),Pt(k+1,0),Pt(k+1,1));\n\t\t\t\tint d=(int)(t.y);\n\t\t\t\tif(d>=b)continue;\n\t\t\t\tif(str[k][d]=='#'&&str[k+1][d]!='#')val++;\n\t\t\t\tif(str[k][d]!='#'&&str[k+1][d]=='#')val++;\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,(1e-8)+j+1),Pt(0,k+1),Pt(1,k+1));\n\t\t\t\tint d=(int)(t.x);\n\t\t\t\tif(d>=a)continue;\n\t\t\t\tif(str[d][k]=='#'&&str[d][k+1]!='#')val++;\n\t\t\t\tif(str[d][k]!='#'&&str[d][k+1]=='#')val++;\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t\tval=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,-(1e-8)+j+1),Pt(k+1,0),Pt(k+1,1));\n\t\t\t\tint d=(int)(t.y);\n\t\t\t\tif(d>=b)continue;\n\t\t\t\tif(str[k][d]=='#'&&str[k+1][d]!='#')val++;\n\t\t\t\tif(str[k][d]!='#'&&str[k+1][d]=='#')val++;\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,-(1e-8)+j+1),Pt(0,k+1),Pt(1,k+1));\n\t\t\t\tint d=(int)(t.x);\n\t\t\t\tif(d>=a)continue;\n\t\t\t\tif(str[d][k]=='#'&&str[d][k+1]!='#')val++;\n\t\t\t\tif(str[d][k]!='#'&&str[d][k+1]=='#')val++;\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t}\n\t}\n\tif(str[0][0]=='#')ret++;\n\tprintf(\"%d\\n\",1+ret/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nchar ptn[4][2][2] = {\n  {\n    {'.','#'},\n    {'.','.'}\n  },\n  {\n    {'#','.'},\n    {'#','#'}\n  },\n  {\n    {'.','.'},\n    {'#','.'}\n  },\n  {\n    {'#','#'},\n    {'.','#'}\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int H, W;\n  cin >> H >> W;\n  H += 2, W += 2;\n  char f[666][666];\n  rep(i, H) rep(j, W) f[i][j] = '.';\n  reps(i, 1, H-1) reps(j, 1, W-1) cin >> f[H-1-i][j];\n\n  vector< pair<double, int> > vec;\n  rep(i, H-1) rep(j, W-1) {\n    rep(k, 4) {\n      bool flag = true;\n      rep(y, 2) rep(x, 2) flag &= (f[i+y][j+x] == ptn[k][y][x]);\n      if(flag) {\n\tvec.emplace_back(atan2(i, j), (k < 2 ? -1 : 1));\n\tbreak;\n      }\n    }\n  }\n\n  sort(all(vec));\n  \n  int ans = 2, div = 1;\n  for(auto p : vec) {\n    div += p.second;\n    ans = max(ans, div);\n  }\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nbool comp2(pair<pair<int,int>,int>a,pair<pair<int,int>,int>b){\n    int x = a.first.first;\n    int y = a.first.second;\n    int w = b.first.first;\n    int z = b.first.second;\n    if(x*z==y*w){\n        return 1;\n    }\n    if(x*z>y*w){\n        return 0;\n    }\n    if(x*z<y*w){\n        return 0;\n    }\n}\n\nbool comp(pair<pair<int,int>,int>a,pair<pair<int,int>,int>b){\n    int x = a.first.first;\n    int y = a.first.second;\n    int w = b.first.first;\n    int z = b.first.second;\n    if(x*z==y*w){\n        return 0;\n    }\n    if(x*z>y*w){\n        return 1;\n    }\n    if(x*z<y*w){\n        return 0;\n    }\n}\n\nint main(){\n    int h,w;\n    cin >> h >> w;\n    vector<string>v(h);\n    rep(i,h)cin >> v[h-i-1];\n    rep(i,h)v[i].push_back('.');\n    rep(i,h)v[i] = \".\"+v[i];\n    string ssss;\n    rep(i,w+2)ssss.push_back('.');\n    v.push_back(ssss);\n    vector<pair<pair<int,int>,int> > p;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w+1;j++){\n            if(v[i][j]=='#'&&v[i][j+1]=='#'&&v[i+1][j]=='.'&&v[i+1][j+1]=='#'){\n                p.push_back(make_pair(make_pair(i+1,j),-1));\n            }\n            if(v[i][j]=='.'&&v[i][j+1]=='.'&&v[i+1][j]=='#'&&v[i+1][j+1]=='.'){\n                p.push_back(make_pair(make_pair(i+1,j),-1));\n            }\n            if(v[i][j]=='#'&&v[i][j+1]=='.'&&v[i+1][j]=='#'&&v[i+1][j+1]=='#'){\n                p.push_back(make_pair(make_pair(i+1,j),1));\n            }\n            if(v[i][j]=='.'&&v[i][j+1]=='#'&&v[i+1][j]=='.'&&v[i+1][j+1]=='.'){\n                p.push_back(make_pair(make_pair(i+1,j),1));\n            }\n        }\n    }\n    sort(p.begin(),p.end(),comp);\n    int mx = 2;\n    int cnt = 1;\n    // rep(i,h+1){\n    //     rep(j,w+2){\n    //         cout << v[i][j];\n    //     }\n    //     cout <<endl;\n    // }\n    for(int i=0;i<p.size();i++){\n        //cout << p[i].first.first << \" \" << p[i].first.second << \" \" << p[i].second << \" \" << cnt<< endl;\n        if(i==p.size()-1){\n            cnt += p[i].second;\n            mx = max(mx,cnt);\n        }else{\n            if(!comp2(p[i],p[i+1])){\n                cnt += p[i].second;\n                mx = max(mx,cnt);\n            }else{\n                cnt += p[i].second;\n            }\n        }\n    }\n    cout << mx << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\nint H,W;\nstring s[601];\nD EPS=1e-8;\nvector<D> ts;\nbool dx[601][601],dy[601][601];\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[H-1-i];\n\trep1(x,W) rep1(y,H){\n\t\tts.pb((D)y/x+EPS);\n\t\tts.pb((D)y/x-EPS);\n\t}\n\ts[H].assign(W,'.');\n\trep(i,H+1) s[i]+='.';\n\trep(i,H) rep(j,W+1) dx[i][j]=(s[i][j]==s[i+1][j]);\n\trep(i,H+1) rep(j,W) dy[i][j]=(s[i][j]==s[i][j+1]);\n\tsort(all(ts));\n\tts.erase(unique(all(ts)),ts.end());\n\tint mx=0;\n\tfor(D t:ts){\n\t\tint cnt=0;\n\t\trep1(x,W){\n\t\t\tint y=floor(t*x);\n\t\t\tif(y<H&&!dy[y][x-1]) cnt++;\n\t\t}\n\t\trep1(y,H){\n\t\t\tint x=floor(y/t);\n\t\t\tif(x<W&&!dx[y-1][x]) cnt++;\n\t\t}\n\t\tmx=max(mx,cnt);\n\t}\n\tcout<<(mx+3)/2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int h,w;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++) cin>>s[i];\n  bool e[h+10][w+10];\n  memset(e,0,sizeof(e));\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      e[h-i-1][j]=s[i][j]=='#';\n  /*//\n    for(int i=h-1;i>=0;i--)\n    for(int j=0;j<w;j++)\n    cout<<e[i][j]<<\" \\n\"[j==w-1];\n  //*/\n  int ans=2;\n  \n  time_t start=clock();\n  srand((unsigned)time(NULL));\n  int k=0;\n  while((double)(clock()-start)/CLOCKS_PER_SEC<1.8&&k<=max(w,h)){\n    k++;\n    for(int i=1;i<=h+k;i++){\n      int x=0,y=0,tmp=e[0][0],p;\n      while(x<=w&&y<=h){\n\t//if(i==4&&k==2) cout<<y<<\" \"<<x<<endl;\n\tp=e[y][x];\n\tif((i*(x+1))%(w+k)==0) x++,y++;\n\tif((i*(x+1))/(w+k)==y) x++;\n\telse y++;\n\tif(!p&&e[y][x]) tmp++;\n      }\n      //cout<<i<<\":\"<<tmp<<endl;\n      //if(i==4&&k==2) cout<<tmp<<endl;\n      ans=max(ans,tmp+1);\n    }\n    for(int j=1;j<=w+k;j++){\n      int x=0,y=0,tmp=e[0][0],p;\n      while(x<=w&&y<=h){\n\tp=e[y][x];\n\tif((j*(y+1))%(h+k)==0) x++,y++;\n\telse if((j*(y+1))/(h+k)==x) y++;\n\telse x++;\n\tif(!p&&e[y][x]) tmp++;\n      }\n      //cout<<j<<\" \"<<tmp<<endl;\n      ans=max(ans,tmp+1);\n    }\n  }\n  //cout<<k<<endl;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass rational {\nprivate:\n  static ll gcd(ll a, ll b) { return b != 0 ? gcd(b, a % b) : a; }\npublic:\n  ll p, q;\n  rational(ll _p, ll _q) {\n    ll g = gcd(_p, _q);\n    p = _p / g;\n    q = _q / g;\n  }\n  bool operator==(const rational r) const { return p * r.q == q * r.p; }\n  bool operator<(const rational r) const { return p * r.q < q * r.p; }\n};\n\nint main(void) {\n  ll H, W;\n  cin >> H >> W;\n  vector<string> S(H + 1);\n  REP(i, 0, H) {\n    cin >> S[H - i - 1];\n    S[H - i - 1] += '.';\n  }\n  S[H] = \"\";\n  REP(i, 0, W + 1) S[H] += '.';\n\n  vector<rational> vec;\n  vec.push_back(rational(0, 1));\n  vec.push_back(rational(1LL << 50, 1));\n  REP(i, 0, H) REP(j, 0, W) {\n    if(j != 0) vec.push_back(rational(i + 1, j));\n    if(i != 0) vec.push_back(rational(i, j + 1));\n    vec.push_back(rational(i + 1, j + 1));\n  }\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n\n  vector<ll> imos(vec.size() + 1, 0);\n  REP(i, 0, H) REP(j, 0, W) {\n    if(S[i][j] != S[i + 1][j]) {\n      ll s = lower_bound(vec.begin(), vec.end(), rational(i + 1, j + 1)) - vec.begin();\n      ll e = lower_bound(vec.begin(), vec.end(), j != 0 ? rational(i + 1, j) : rational(1LL << 50, 1)) - vec.begin();\n      imos[s + 1]++;\n      imos[e + 1]--;\n    }\n    if(S[i][j] != S[i][j + 1]) {\n      ll s = lower_bound(vec.begin(), vec.end(), i != 0 ? rational(i, j + 1) : rational(0, 1)) - vec.begin();\n      ll e = lower_bound(vec.begin(), vec.end(), rational(i + 1, j + 1)) - vec.begin();\n      imos[s + 1]++;\n      imos[e + 1]--;\n    }\n  }\n  REP(i, 0, imos.size() - 1) imos[i + 1] += imos[i];\n\n  ll ans = 0;\n  REP(i, 0, imos.size() - 1) ans = max(ans, imos[i]);\n  cout << (ans + 1) / 2 + 1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<D,int> pdi;\n\nbool dcmp(const pdi &a, const pdi &b){\n  if( abs(a.first-b.first)<1e-8 )return a.second<b.second;\n  return a.first<b.first;\n}\n\nint main(){\n  int h,w;\n  string f[999];\n  cin >> h >> w;\n\n  vector<pdi> v;\n  rep(i,h){\n    cin >> f[i];\n    rep(j,w){\n      if( (i==0&&f[i][j]=='#') || (i!=0&&f[i][j]!=f[i-1][j]) ){\n\t//cout << \"h:\" << j << \" \" << i << endl;\n\t//cout << j << \" \" << h-i << \" \" << j+1 << \" \" << h-i << endl;\n\tv.push_back(pdi(arg(P(j,h-i)),-1));\n\tv.push_back(pdi(arg(P(j+1,h-i)),1));\n      }\n      if( (j==w-1&&f[i][j]=='#') || (j!=w-1&&f[i][j]!=f[i][j+1])){\n\t//cout << \"v:\" << j << \" \" << i << endl;\n\t//cout << j+1 << \" \" << h-i-1 << \" \" << j+1 << \" \" << h-i << endl;\n\tv.push_back(pdi(arg(P(j+1,h-i)),-1));\n\tv.push_back(pdi(arg(P(j+1,h-i-1)),1));\n      }\n    }\n  }\n\n  int maxv = 0, tmp = 0;\n  sort(v.begin(),v.end(),dcmp);\n  rep(i,v.size()){\n    tmp += v[i].second;\n    maxv = max(maxv,tmp);\n  }\n  cout << (maxv+3)/2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-11, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<bool>>fi(H+2, vector<bool>(W+2));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '#') {\n\t\t\t\tfi[i+1][j+1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<Line>ls;\n\tvector<double>katas;\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 1; x < W + 1; ++x) {\n\t\t\tif (fi[y][x]) {\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tPoint ld(x, y + 1);\n\t\t\t\t\tPoint lu(x, y);\n\t\t\t\t\tPoint rd(x + 1, y + 1);\n\t\t\t\t\tPoint ru(x + 1, y);\n\t\t\t\t\tif (!fi[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\tls.emplace_back(ld, lu);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == 1) {\n\t\t\t\t\t\t\tls.emplace_back(rd, ld);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == 2) {\n\t\t\t\t\t\t\tls.emplace_back(ru, rd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tls.emplace_back(lu, ru);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 2; x < W + 2; ++x) {\n\t\t\tkatas.push_back(double(y-(H+1))/ (x - 1));\n\t\t}\n\t}\n\tkatas.push_back(0);\n\tkatas.push_back(-1000);\n\tsort(katas.begin(), katas.end());\n\tvector<double>newkatas;\n\tdouble now = 1;\n\tfor (int i = 0; i < katas.size(); ++i) {\n\t\tif (abs(katas[i]-now)>1e-10) {\n\t\t\tnewkatas.push_back(katas[i]);\n\t\t\tnow = (katas[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < newkatas.size()-1; ++i) {\n\t\tdouble kata = (newkatas[i + 1] + newkatas[i])/2;\n\t\tLine l(Point(1, H + 1), Point(1 + 1, H + 1 + kata));\n\t\tint nans = 0;\n\t\tfor (int j = 0; j < ls.size(); ++j) {\n\t\t\tif (isis_ls(l, ls[j])) {\n\t\t\t\tnans++;\n\t\t\t}\n\t\t}\n\t\tif (fi[H][1])nans--;\n\t\tans = max(ans, 1+nans/2);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n#include <complex>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double, int> E;\ntypedef complex<double> P;\ntypedef pair<P, P> L;\nconst double EPS = 1e-9;\nint main() {\n    char c[700][700];\n    fill_n(c[0], 700*700, '.');\n    int w, h;\n    cin >> w >> h;\n    for (int i = 0; i < w; i++) {\n        for (int j = 0; j < h; j++) {\n            cin >> c[w-i-1+10][j+10];\n        }\n    }\n    bool f[700];\n    vector<L> l;\n    for (int i = 1; i < 650; i++) {\n        fill_n(f, 700, false);\n        for (int j = 0; j < 650; j++) {\n            if (c[i-1][j] != c[i][j]) f[j] = true;\n        }\n        vector<int> v;\n        for (int j = 1; j < 650; j++) {\n            if (f[j-1] != f[j]) v.push_back(j);\n        }\n        for (int j = 0; j < v.size(); j+=2) {\n            l.push_back(L(P(i, v[j]), P(i, v[j+1])));\n        }\n    }\n    for (int j = 1; j < 650; j++) {\n        fill_n(f, 700, false);\n        for (int i = 0; i < 650; i++) {\n            if (c[i][j-1] != c[i][j]) f[i] = true;\n        }\n        vector<int> v;\n        for (int i = 1; i < 650; i++) {\n            if (f[i-1] != f[i]) v.push_back(i);\n        }\n        for (int i = 0; i < v.size(); i+=2) {\n            l.push_back(L(P(v[i], j), P(v[i+1], j)));\n        }\n    }\n    vector<E> e;\n    for (L ll : l) {\n        P p = P(10, 10);\n        ll.first -= p; ll.second -= p;\n        e.push_back(E(max(arg(ll.first), arg(ll.second))-EPS, -1));\n        e.push_back(E(min(arg(ll.first), arg(ll.second))+EPS, 1));\n    }\n    sort(e.begin(), e.end());\n    int res = 0, r = 0;\n    for (E ee: e) {\n        r += ee.second;\n        res = max(res, r);\n    }\n    cout << res/2+1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// OBïÄh2011 Day4 A : åKåNÌ\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint main(){\n\tint H, W;\n\tstring f[600];\n\twhile(cin >> H >> W){\n\t\tfor(int i=H-1;i>=0;i--) cin >> f[i];\n\n\t\tvector< pair<double, int> > vd;\n\t\t// ÌæªÏíé¸_ð²×é.\n\t\t// X«(j/i)ðå«­µ½Æ«ÌÌæÌ¸àÁÄ¨­\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=0;j<=W;j++){\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i-k%2, nj = j-k/2;\n\t\t\t\t\tif(0<=ni&&ni<H&&0<=nj&&nj<W&&f[ni][nj]=='#') cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt%2 == 1){\n\t\t\t\t\tif(0<=i-1&&i-1<H&&0<=j&&j<W&&f[i-1][j]==(cnt==1?'#':'.'))\n\t\t\t\t\t\tvd.push_back(make_pair((double)j/i,  1));\n\t\t\t\t\tif(0<=i&&i<H&&0<=j-1&&j-1<W&&f[i][j-1]==(cnt==1?'#':'.'))\n\t\t\t\t\t\tvd.push_back(make_pair((double)j/i, -1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vd.begin(), vd.end());\n\n\t\tint res = 1, cur = 1;\n\t\t// X«ðå«­µÄ¢«AÌæÌ¸ð²×é\n\t\tfor(int i=0;i<vd.size(); ){\n\t\t\tint idx = i;\n\t\t\twhile(idx < vd.size() && abs(vd[i].first-vd[idx].first) < EPS)\n\t\t\t\tcur += vd[idx++].second;\n\t\t\ti = idx;\n\t\t\tres = max(cur, res);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> field(1, string(w + 1, '.'));\n\tfield.reserve(h + 2);\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tstring line;\n\t\tcin >> line;\n\t\tfield.emplace_back(line + '.');\n\t}\n\n\tfield.emplace_back(string(w + 1, '.'));\n\n\ttypedef pair<double, bool> event; // arg, inc\n\tvector<event> events;\n\n\tconst int oy = h;\n\n\tfor(int i = 1; i < h + 2; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == field[i - 1][j + 1]) {\n\t\t\t\tif(field[i][j] == field[i][j + 1] && field[i][j] != field[i - 1][j]) { // inc\n\t\t\t\t\tevents.emplace_back(atan2(oy - (i - 1), j + 1), true);\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] != field[i][j + 1] && field[i][j] == field[i - 1][j]) { // dec\n\t\t\t\t\tevents.emplace_back(atan2(oy - (i - 1), j + 1), false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(events.begin(), events.end());\n\n\tint ans = 1;\n\tint cnt = 1;\n\n\tfor(const auto &e : events) {\n\t\tif(e.second) {\n\t\t\tchmax(ans, ++cnt);\n\t\t}\n\t\telse {\n\t\t\t--cnt;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\nint H,W;\nstring s[601];\nD EPS=1e-8;\nvector<D> ts;\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[H-1-i];\n\trep1(x,W) rep1(y,H){\n\t\tts.pb((D)y/x+EPS);\n\t\tts.pb((D)y/x-EPS);\n\t}\n\ts[H].assign(W,'.');\n\trep(i,H+1) s[i]+='.';\n\tsort(all(ts));\n\tts.erase(unique(all(ts)),ts.end());\n\tint mx=0;\n\tfor(D t:ts){\n\t\tint cnt=0;\n\t\trep1(x,W){\n\t\t\tint y=floor(t*x);\n\t\t\tif(y<H&&s[y][x-1]!=s[y][x]) cnt++;\n\t\t}\n\t\trep1(y,H){\n\t\t\tint x=floor(y/t);\n\t\t\tif(x<W&&s[y-1][x]!=s[y][x]) cnt++;\n\t\t}\n\t\tmx=max(mx,(cnt+1)/2+1);\n\t}\n\tcout<<mx<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int h, w;\n  cin >> h >> w;\n  vector<string> v(h+2, string(w+2, '.'));\n  FOR(i, 1, h+1) {\n    cin >> v[i];\n    v[i] = '.' + v[i] + '.';\n  }\n\n  vector<pair<double,int>> eve;\n  REP(i, h+1) REP(j, w+1) {\n    // (h-i, j+1) の偏角\n    double ang = atan2(h-i, j);\n    if(v[i][j] == '#' && v[i+1][j] == '.' && v[i][j+1] == '.' && v[i+1][j+1] == '.') {\n      eve.PB({ang, 1});\n    }\n    if(v[i][j] == '.' && v[i+1][j] == '#' && v[i][j+1] == '#' && v[i+1][j+1] == '#') {\n      eve.PB({ang, 1});\n    }\n    if(v[i][j] == '.' && v[i+1][j] == '.' && v[i][j+1] == '.' && v[i+1][j+1] == '#') {\n      eve.PB({ang, -1});\n    }\n    if(v[i][j] == '#' && v[i+1][j] == '#' && v[i][j+1] == '#' && v[i+1][j+1] == '.') {\n      eve.PB({ang, -1});\n    }\n  }\n\n  sort(ALL(eve));\n  int num = 1, ans = 2;\n  for(auto i: eve) {\n    num += i.second;\n    chmax(ans, num);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<double,double>D;\ntypedef pair<P,int>PP;\ntypedef pair<double,P>dP;\ntypedef pair<D,int>Di;\n\nconst int MAX_N = 602;\nconst int dx[] = {1,1,0,0};\nconst int dy[] = {0,0,1,-1};\nconst int ex[] = {1,0,1};\nconst int ey[] = {0,1,1};\n\nint a[MAX_N][MAX_N];\nint flag[MAX_N][MAX_N];\nint h,w;\nint gcd_table[MAX_N][MAX_N];\nint mp[MAX_N][MAX_N];\nvector<PP> vec;\n\nvoid dfs(int u,int v)\n{\n    flag[u][v] = 1;\n    if(u < w-1 && 0 < v && !a[u+1][v] && !a[u][v-1] && !a[u+1][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u == w-1 && 0 < v && !a[u][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u < w-1 && 0 < v && a[u+1][v] && a[u][v-1] && !a[u+1][v-1]){  //??????2\n        vec.push_back(PP(P(u+1,v),2));\n    }\n    if(0 < u && v < h-1 && !a[u-1][v] && !a[u][v+1] && !a[u-1][v+1]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v == h-1 && !a[u-1][v]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v < h-1 && a[u-1][v] && a[u][v+1] && !a[u-1][v+1]){  //??????2\n        vec.push_back(PP(P(u,v+1),3));\n    }\n    rep(i,4){\n        int nx = u + dx[i],ny = v + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && a[nx][ny] && !flag[nx][ny]){\n            dfs(nx,ny);\n        }\n    }\n    return;\n}\n\nint gcd(int a,int b)\n{\n    if(a % b == 0){\n        return b;\n    }\n    return gcd(b,a % b);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&h,&w);\n    rep(j,h){\n        string s;\n        cin >> s;\n        rep(i,s.length()){\n            flag[i][j] = 0;\n            if(s[i] == '#'){\n                a[i][h-j-1] = 1;\n            }else{\n                a[i][h-j-1] = 0;\n            }\n        }\n    }\n    for(int i = 1;i <= 600;i++){\n        for(int j = i;j <= 600;j++){\n            gcd_table[j][i] = gcd(j,i);\n        }\n    }\n    bool fl = false;\n    rep(i,w){\n        rep(j,h){\n            if(a[i][j]){\n                dfs(i,j);\n                fl = true;\n                break;\n            }\n        }\n        if(!fl){\n            break;\n        }\n    }\n    // rep(i,vec.size()){\n    //     cout << vec[i].first.first << \" \" << vec[i].first.second << \" \" << vec[i].second << \"\\n\";\n    // }\n    vector<dP> tilt;\n    rep(i,vec.size()){\n        int p1 = (vec[i].first).first;\n        int p2 = (vec[i].first).second;\n        tilt.push_back(dP((double)p2 / p1,P(i,vec[i].second)));\n    }\n    sort(all(tilt));\n    vector<PP> cand;\n    rep(i,tilt.size()){\n        int cnt[] = {0,0,0,0};\n        int id = i;\n        double n1 = tilt[i].first;\n        int n2 = (tilt[i].second).first;\n        int n3 = (tilt[i].second).second;\n        cnt[n3]++;\n        while(id + 1 < tilt.size() && abs(tilt[id].first-tilt[id+1].first) < EPS){\n            n1 = tilt[i+1].first;\n            n3 = (tilt[i+1].second).first;\n            cnt[n3]++;\n            id++;\n        }\n        int mx = max(cnt[0]+cnt[3],cnt[1]+cnt[2]);\n        i = id;\n        P p = vec[n2].first;\n        int md = gcd_table[max(p.first,p.second)][min(p.first,p.second)];\n        mp[p.first / md][p.second / md]++;\n        cand.push_back(PP(P(p.first / md,p.second / md),mx));\n    }\n    for(int i = 1;i <= w;i++){\n        for(int j = 1;j <= h;j++){\n            int md = gcd_table[max(i,j)][min(i,j)];\n            P p = P(i / md,j / md);\n            if(!mp[p.first][p.second]){\n                cand.push_back(PP(p,0));\n                mp[p.first][p.second]++;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,cand.size()){\n        vector<Di> cros;\n        P p = cand[i].first;\n        rep(j,p.first-1){\n            cros.push_back(Di(D(j+1,(double)(j+1) * p.second / p.first),0));\n        }\n        rep(j,p.second-1){\n            cros.push_back(Di(D((double)(j+1) * p.first / p.second,j+1),1));\n        }\n        sort(all(cros));\n        vector<int> act;\n        rep(j,cros.size()){\n            act.push_back(cros[j].second);\n        }\n        act.push_back(2);\n        int cnt = 0;\n        int px = 0,py = 0;\n        int bf = a[0][0];\n        int res = 0;\n        while(1){\n            px += ex[act[cnt%act.size()]];\n            py += ey[act[cnt%act.size()]];\n            if(px < w && py < h){\n                if(bf == 1 && !a[px][py]){\n                    res++;\n                }\n                bf = a[px][py];\n            }else{\n                if(bf == 1){\n                    res++;\n                }\n                break;\n            }\n            cnt++;\n        }\n        ans = max(res+cand[i].second,ans);\n    }\n    cout << ans + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n  int H, W;\n  cin >> H >> W;\n  string F[H];\n  for(int i = 0; i < H; ++i){\n    cin >> F[i];\n  }\n  int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n  pair<pii,pii> e[4];\n  e[0] = make_pair(pii(1,0),pii(1,1));\n  e[1] = make_pair(pii(0,1),pii(1,1));\n  e[2] = make_pair(pii(0,0),pii(0,1));\n  e[3] = make_pair(pii(0,0),pii(1,0));\n  vector< pair<double,int> > A;//\"#\"?????°???N??¨????????¨2*N+2????????????????´???°\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(F[i][j] == '#'){\n\tfor(int k = 0; k < 4; ++k){\n\t  if(i+dx[k] < 0 || j+dy[k] < 0 || i+dx[k] > H-1 || j+dy[k] > W-1 || F[i+dx[k]][j+dy[k]] != '#'){\n\t    pii s = pii(H-i-e[k].first.first, j+e[k].first.second);\n\t    pii t = pii(H-i-e[k].second.first, j+e[k].second.second);\n\t    //printf(\"(%d, %d), (%d, %d)\\n\",s.first,s.second,t.first,t.second);\n\t    if(s.second && s.first)\n\t      A.push_back(make_pair((double)s.first/s.second, -1));\n\t    if(t.second && s.first)\n\t      A.push_back(make_pair((double)t.first/t.second, +1));\n\t  }\n\t}\n      }\n    }\n  }\n  sort(A.begin(),A.end());\n  int ans = 0, t = 0;\n\n  for(int i = 0; i < (int)A.size(); ++i){\n\n    t += A[i].second;\n    t = max(t,0);\n    ans = max(t,ans);\n  }\n\n  cout << (ans+1)/2 + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<double,double>D;\ntypedef pair<P,int>PP;\ntypedef pair<double,P>dP;\ntypedef pair<D,int>Di;\n\nconst int MAX_N = 602;\nconst int dx[] = {1,1,0,0};\nconst int dy[] = {0,0,1,-1};\nconst int ex[] = {1,0,1};\nconst int ey[] = {0,1,1};\n\nint a[MAX_N][MAX_N];\nint flag[MAX_N][MAX_N];\nint h,w;\nint gcd_table[MAX_N][MAX_N];\nvector<PP> vec;\n\nvoid dfs(int u,int v)\n{\n    flag[u][v] = 1;\n    if(u < w-1 && 0 < v && !a[u+1][v] && !a[u][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u < w-1 && 0 < v && a[u+1][v] && a[u][v-1]){  //??????2\n        vec.push_back(PP(P(u+1,v),2));\n    }\n    if(0 < u && v < h-1 && !a[u-1][v] && !a[u][v+1]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v < h-1 && a[u-1][v] && a[u][v+1]){  //??????2\n        vec.push_back(PP(P(u,v+1),3));\n    }\n    rep(i,4){\n        int nx = u + dx[i],ny = v + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && a[nx][ny] && !flag[nx][ny]){\n            dfs(nx,ny);\n        }\n    }\n    return;\n}\n\nint gcd(int a,int b)\n{\n    if(a % b == 0){\n        return b;\n    }\n    return gcd(b,a % b);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&h,&w);\n\trep(j,h){\n        string s;\n        cin >> s;\n        rep(i,s.length()){\n            flag[i][j] = 0;\n            if(s[i] == '#'){\n                a[i][h-j-1] = 1;\n            }else{\n                a[i][h-j-1] = 0;\n            }\n        }\n\t}\n    for(int i = 1;i < 600;i++){\n        for(int j = i;j < 600;j++){\n            gcd_table[j][i] = gcd(j,i);\n        }\n    }\n    bool fl = false;\n    rep(i,w){\n        rep(j,h){\n            if(a[i][j]){\n                dfs(i,j);\n                fl = true;\n                break;\n            }\n        }\n        if(!fl){\n            break;\n        }\n    }\n    vector<dP> tilt;\n    rep(i,vec.size()){\n        int p1 = (vec[i].first).first;\n        int p2 = (vec[i].first).second;\n        tilt.push_back(dP((double)p2 / p1,P(i,vec[i].second)));\n    }\n    sort(all(tilt));\n    map<P,int> mp;\n    vector<PP> cand;\n    rep(i,tilt.size()){\n        int cnt[] = {0,0,0,0};\n        int id = i;\n        double n1 = tilt[i].first;\n        int n2 = (tilt[i].second).first;\n        int n3 = (tilt[i].second).second;\n        cnt[n3]++;\n        if(i + 1 < tilt.size()){\n            while(abs(tilt[id].first-tilt[id+1].first) < EPS){\n                n1 = tilt[i+1].first;\n                n3 = (tilt[i+1].second).first;\n                cnt[n3]++;\n                id++;\n            }\n        }\n        int mx = max(cnt[0]+cnt[3],cnt[1]+cnt[2]);\n        i = id;\n        P p = vec[n2].first;\n        int md = gcd_table[max(p.first,p.second)][min(p.first,p.second)];\n        mp[P(p.first / md,p.second / md)]++;\n        cand.push_back(PP(P(p.first / md,p.second / md),mx));\n    }\n    for(int i = 1;i < w;i++){\n        for(int j = 1;j < h;j++){\n            int md = gcd_table[max(i,j)][min(i,j)];\n            P p = P(i / md,j / md);\n            if(!mp[p]){\n                cand.push_back(PP(p,0));\n                mp[p]++;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,cand.size()){\n        vector<Di> cros;\n        P p = cand[i].first;\n        rep(j,p.first-1){\n            cros.push_back(Di(D(j+1,(double)(j+1) * p.second / p.first),0));\n        }\n        rep(j,p.second-1){\n            cros.push_back(Di(D((double)(j+1) * p.first / p.second,j+1),1));\n        }\n        sort(all(cros));\n        vector<int> act;\n        rep(j,cros.size()){\n            act.push_back(cros[j].second);\n        }\n        act.push_back(2);\n        int cnt = 0;\n        int px = 0,py = 0;\n        int bf = a[0][0];\n        int res = 0;\n        while(1){\n            px += ex[act[cnt%act.size()]];\n            py += ey[act[cnt%act.size()]];\n            if(px < w && py < h){\n                if(bf == 1 && !a[px][py]){\n                    res++;\n                }\n                bf = a[px][py];\n            }else{\n                if(bf == 1){\n                    res++;\n                }\n                break;\n            }\n            cnt++;\n        }\n        ans = max(res+cand[i].second,ans);\n    }\n    cout << ans + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\nstatic const double pi = 3.141592653589793;\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-8;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n\nchar hyou[610][610];\nint H, W;\nvector<pair<double, P>> points;\n\nint cntrose(int x, int y) {\n\tint r = (int)(hyou[y][x] == '#') + (int)(hyou[y][x + 1] == '#') + (int)(hyou[y + 1][x] == '#') + (int)(hyou[y + 1][x + 1] == '#');\n\treturn r;\n}\n\nint isL(P a) {\n\tint x = (int)(a.real());\n\tint y = (int)(a.imag());\n\tif (hyou[y][x] == '.' and hyou[y + 1][x + 1] == '.'){\n\t\tif(hyou[y][x + 1] == '#') return -1;\n\t\telse return 1; \n\t} else if (hyou[y][x] == '#' and hyou[y + 1][x + 1] == '#'){\n\t\tif(hyou[y][x + 1] == '#') return 1;\n\t\telse return -1;\n\t} \n\telse return 0;\n}\n\nint main() {\n\tcin >> H >> W;\n\tfor(int h = H + 1; h >= 0; h--) {\n\t\tfor(int w = 0; w <= W + 1; w++) {\n\t\t\tif(w == 0 and h == 0) continue;\n\t\t\tif (h == 0 or h == H + 1 or w == 0 or w == W + 1) {\n\t\t\t\thyou[h][w] = '.';\n\t\t\t} else {\n\t\t\t\tcin >> hyou[h][w];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int w = 0; w <= W; w++) {\n\t\tfor(int h = 0; h <= H; h++) {\n\t\t\tif(cntrose(w,h) % 2){\n\t\t\t\tP a = P(w, h);\n\t\t\t\tpoints.push_back(make_pair(arg(a), a));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0, cnt = 1;\n\tsort(points.begin(), points.end());\n\trep(i, points.size()){\n\t\tcnt += isL(points[i].second);\n\t\tif (i + 1== points.size() or abs(points[i].first - points[i + 1].first) > EPS) ans = max(ans, cnt);\n\t}\n\tcout << ans << endl;\n}\n\t\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(double arg_slope,int arg_value){\n\t\tslope = arg_slope;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\tif(fabs(slope-arg.slope) > EPS){\n\t\t\treturn slope < arg.slope;\n\t\t}else{\n\t\t\treturn value < arg.value;\n\t\t}\n\t}\n\n\tdouble slope;\n\tint value;\n};\n\ndouble getSlope(int y,int x){\n\treturn double(y)/(double)x;\n}\n\nint H,W;\nchar input_map[600][601],calc_map[602][603];\n\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",input_map[row]);\n\t}\n\n\tfor(int row = 0; row <= H+1; row++){\n\t\tfor(int col = 0; col <= W+1; col++)calc_map[row][col] = '.';\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tcalc_map[row+1][col+1] = input_map[row][col];\n\t\t}\n\t}\n\n\tvector<Info> V;\n\n\tfor(int row = 0; row <= H; row++){\n\t\tfor(int col = 1; col <= W; col++){\n\n\t\t\tif(calc_map[row][col] == '#' && calc_map[row][col+1] == '.' && calc_map[row+1][col] == '.' && calc_map[row+1][col+1] == '.'){\n\t\t\t\tV.push_back(Info(getSlope(H-row,col),1));\n\t\t\t}else if(calc_map[row][col] == '.' && calc_map[row][col+1] == '#' && calc_map[row+1][col] == '#' && calc_map[row+1][col+1] == '#'){\n\t\t\t\tV.push_back(Info(getSlope(H-row,col),1));\n\t\t\t}else if(calc_map[row][col] == '.' && calc_map[row][col+1] == '.' && calc_map[row+1][col] == '.' && calc_map[row+1][col+1] == '#'){\n\t\t\t\tV.push_back(Info(getSlope(H-row,col),-1));\n\t\t\t}else if(calc_map[row][col] == '#' && calc_map[row][col+1] == '#' && calc_map[row+1][col] == '#' && calc_map[row+1][col+1] == '.'){\n\t\t\t\tV.push_back(Info(getSlope(H-row,col),-1));\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(V.begin(),V.end());\n\n\tint tmp = 1,ans = 1;\n\n\tfor(int i = 0; i < V.size(); i++){\n\t\ttmp += V[i].value;\n\t\tans = max(ans,tmp);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<double,double>D;\ntypedef pair<P,int>PP;\ntypedef pair<double,P>dP;\ntypedef pair<D,int>Di;\n\nconst int MAX_N = 602;\nconst int dx[] = {1,1,0,0};\nconst int dy[] = {0,0,1,-1};\nconst int ex[] = {1,0,1};\nconst int ey[] = {0,1,1};\n\nint a[MAX_N][MAX_N];\nint flag[MAX_N][MAX_N];\nint h,w;\nint gcd_table[MAX_N][MAX_N];\nvector<PP> vec;\nmap<P,int> mp;\n\nvoid dfs(int u,int v)\n{\n    flag[u][v] = 1;\n    if(u < w-1 && 0 < v && !a[u+1][v] && !a[u][v-1] && !a[u+1][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u < w-1 && 0 < v && a[u+1][v] && a[u][v-1] && !a[u+1][v-1]){  //??????2\n        vec.push_back(PP(P(u+1,v),2));\n    }\n    if(0 < u && v < h-1 && !a[u-1][v] && !a[u][v+1] && !a[u-1][v+1]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v < h-1 && a[u-1][v] && a[u][v+1] && !a[u-1][v+1]){  //??????2\n        vec.push_back(PP(P(u,v+1),3));\n    }\n    rep(i,4){\n        int nx = u + dx[i],ny = v + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && a[nx][ny] && !flag[nx][ny]){\n            dfs(nx,ny);\n        }\n    }\n    return;\n}\n\nint gcd(int a,int b)\n{\n    if(a % b == 0){\n        return b;\n    }\n    return gcd(b,a % b);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&h,&w);\n    rep(j,h){\n        string s;\n        cin >> s;\n        rep(i,s.length()){\n            flag[i][j] = 0;\n            if(s[i] == '#'){\n                a[i][h-j-1] = 1;\n            }else{\n                a[i][h-j-1] = 0;\n            }\n        }\n    }\n    for(int i = 1;i < 600;i++){\n        for(int j = i;j < 600;j++){\n            gcd_table[j][i] = gcd(j,i);\n        }\n    }\n    bool fl = false;\n    rep(i,w){\n        rep(j,h){\n            if(a[i][j]){\n                dfs(i,j);\n                fl = true;\n                break;\n            }\n        }\n        if(!fl){\n            break;\n        }\n    }\n    // rep(i,vec.size()){\n    //     cout << vec[i].first.first << \" \" << vec[i].first.second << \" \" << vec[i].second << \"\\n\";\n    // }\n    vector<dP> tilt;\n    rep(i,vec.size()){\n        int p1 = (vec[i].first).first;\n        int p2 = (vec[i].first).second;\n        tilt.push_back(dP((double)p2 / p1,P(i,vec[i].second)));\n    }\n    sort(all(tilt));\n    vector<PP> cand;\n    rep(i,tilt.size()){\n        int cnt[] = {0,0,0,0};\n        int id = i;\n        double n1 = tilt[i].first;\n        int n2 = (tilt[i].second).first;\n        int n3 = (tilt[i].second).second;\n        cnt[n3]++;\n        while(id + 1 < tilt.size() && abs(tilt[id].first-tilt[id+1].first) < EPS){\n            n1 = tilt[i+1].first;\n            n3 = (tilt[i+1].second).first;\n            cnt[n3]++;\n            id++;\n        }\n        int mx = max(cnt[0]+cnt[3],cnt[1]+cnt[2]);\n        i = id;\n        P p = vec[n2].first;\n        int md = gcd_table[max(p.first,p.second)][min(p.first,p.second)];\n        mp[P(p.first / md,p.second / md)]++;\n        cand.push_back(PP(P(p.first / md,p.second / md),mx));\n    }\n    for(int i = 1;i < w;i++){\n        for(int j = 1;j < h;j++){\n            int md = gcd_table[max(i,j)][min(i,j)];\n            P p = P(i / md,j / md);\n            if(!mp[p]){\n                cand.push_back(PP(p,0));\n                mp[p]++;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,cand.size()){\n        vector<Di> cros;\n        P p = cand[i].first;\n        rep(j,p.first-1){\n            cros.push_back(Di(D(j+1,(double)(j+1) * p.second / p.first),0));\n        }\n        rep(j,p.second-1){\n            cros.push_back(Di(D((double)(j+1) * p.first / p.second,j+1),1));\n        }\n        sort(all(cros));\n        vector<int> act;\n        rep(j,cros.size()){\n            act.push_back(cros[j].second);\n        }\n        act.push_back(2);\n        int cnt = 0;\n        int px = 0,py = 0;\n        int bf = a[0][0];\n        int res = 0;\n        while(1){\n            px += ex[act[cnt%act.size()]];\n            py += ey[act[cnt%act.size()]];\n            if(px < w && py < h){\n                if(bf == 1 && !a[px][py]){\n                    res++;\n                }\n                bf = a[px][py];\n            }else{\n                if(bf == 1){\n                    res++;\n                }\n                break;\n            }\n            cnt++;\n        }\n        ans = max(res+cand[i].second,ans);\n    }\n    cout << ans + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment,[-PI,PI]\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1.0L);\nconst long double EPS = 1e-10;\n// cos a\nlong double costh(long double a, long double b,\n                  long double c) {\n  return (b * b + c * c - a * a) / (2.0L * b * c);\n}\n\n// dot(a,b) = |a||b|cos x\nlong double dot(CP a, CP b) { return (conj(a) * b).X; }\n// cross(a,b) : area of parallelogram\n// sign : a-> b ,counter clockwise? + : -\nlong double cross(CP a, CP b) { return (conj(a) * b).Y; }\nlong double corner(CP a, CP b) {\n  //[0,PI]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP projection(CP s, CP t, CP p) {\n  CP base = t - s;\n  long double r = dot(p - s, base) / norm(base);\n  return s + base * r;\n}\n\nCP reflection(CP s, CP t, CP p) {\n  CP tmp = (projection(s, t, p) - p);\n  tmp *= 2;\n  return p + tmp;\n}\n\nCP intersectionLL(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\nbool on_seg(CP s, CP t, CP p) {\n  // if not use end point, dot(s - p, t - p) < 0\n  return abs(cross(s - p, t - p)) <= 1e-10 &&\n         dot(s - p, t - p) <= 0;\n}\n\n// crossing lines? (a,b) and (c,d)\nbool iscross(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= 1e-10) {\n    return on_seg(a, b, c) || on_seg(a, b, d) ||\n           on_seg(c, d, a) || on_seg(c, d, b);\n  }\n  CP isp = intersectionLL(a, b, c, d);\n  return on_seg(a, b, isp) && on_seg(c, d, isp);\n}\n\nlong long calc_clockwise(CP s, CP t, CP p) {\n  t -= s;\n  p -= s;\n  if(cross(t, p) > EPS) return 1;   // \"COUNTER_CLOCKWISE\"\n  if(cross(t, p) < -EPS) return -1; //\"CLOCK_WISE\"\n  if(dot(t, p) < 0) return 2;       // ONLINE_BACK\n  if(norm(t) < norm(p)) return -2;  // ONLINE_FRONT\n  return 0;                         // ON_SEGMENT\n}\n\nstruct line {\n  CP s, t;\n};\n\nstruct corn {\n  CP a, b, c;\n  bool operator<(const corn &x) const {\n    return arg(a) < arg(x.a);\n  }\n};\n\nint h, w;\nint d[4] = {-1, 0, 1, 0};\nvector<string> s;\nvector<line> edges;\n\nlong long solve();\nbool isvalid(long long x, long long y, long long nd) {\n  if(nd == 0) --x, --y;\n  if(nd == 1) --y;\n  if(nd == 3) --x;\n  return x >= 0 && x < h && y >= 0 && y < w &&\n         s[x][y] == '#';\n}\n\nint main() {\n  cin >> h >> w;\n  s.resize(h);\n  for(int i = 0; i < h; ++i) cin >> s[i];\n\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long res = 0, sx = -1, sy = -1, nx = -1, ny = -1,\n            nd = 2;\n  for(int i = 0; i < h; ++i)\n    if(sx == -1)\n      for(int j = 0; j < w; ++j)\n        if(s[i][j] == '#') {\n          nx = sx = i;\n          ny = sy = j;\n          break;\n        }\n  do {\n    long long tx = nx, ty = ny;\n    while(1) {\n      tx += d[nd];\n      ty += d[1 ^ nd];\n      if(!isvalid(tx, ty, nd)) break;\n      if(isvalid(tx, ty, (nd + 3) % 4)) {\n        nd += 2;\n        break;\n      }\n    }\n    if(nx != tx || ny != ty)\n      edges.push_back({CP(nx, ny), CP(tx, ty)});\n    nx = tx;\n    ny = ty;\n    (++nd) %= 4;\n  } while(sx != nx || sy != ny || nd != 2);\n  long long n = edges.size(), cnt = 0;\n  vector<corn> corners;\n  for(int i = 0; i < n; ++i)\n    corners.push_back({edges[i].t - CP(h, 0), edges[i].s,\n                       edges[(i + 1) % n].t});\n  sort(corners.begin(), corners.end());\n  for(long long i = 0; i < n;) {\n    CP nows(h, 0), nowt;\n    long double nowarg = arg(corners[i].a);\n    while(i < n && abs(nowarg - arg(corners[i].a)) <= EPS) {\n      if(norm(corners[i].a) <= EPS * EPS) {\n        ++cnt;\n        ++i;\n        continue;\n      }\n      nowt = corners[i].a + nows;\n      int ch = calc_clockwise(nows, nowt, corners[i].b);\n      if(ch == 1)\n        ++cnt;\n      else if(ch == -1)\n        --cnt;\n      ch = calc_clockwise(nows, nowt, corners[i].c);\n      if(ch == 1)\n        ++cnt;\n      else if(ch == -1)\n        --cnt;\n      ++i;\n    }\n    res = max(res, cnt / 2);\n  }\n  return res + 1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\nconst double EPS=1e-10;\nchar str[700][700];\nint array[700][700];\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;\n\t\tint c=b;\n\t\tb=a;\n\t\ta=c;\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[a-1-i]);\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<b;j++)array[i][j]=(str[i][j]=='#'?1:0);\n\tint ret=0;\n\t\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(gcd(i+1,j+1)>1)continue;\n\t\t\tint val=0;\n\t\t\tdouble X=i+1;\n\t\t\tdouble Y=(1e-8)+j+1;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tval+=(array[k][d]^array[k+1][d]);\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tint d=(int)(X*(k+1)/Y);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tval+=(array[d][k]^array[d][k+1]);\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t\tval=0;\n\t\t\tY=-(1e-8)+j+1;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tval+=(array[k][d]^array[k+1][d]);\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tint d=(int)(X*(k+1)/Y);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tval+=(array[d][k]^array[d][k+1]);\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t}\n\t}\n\tif(str[0][0]=='#')ret++;\n\tprintf(\"%d\\n\",1+ret/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\nstruct Data{\n  double theta;\n  int cost;\n  Data(double theta=IINF,int cost=IINF):theta(theta),cost(cost){}\n  bool operator < (const Data& a)const{\n    if(equals(theta,a.theta)) return cost < a.cost;\n    return theta > a.theta;\n  }\n};\n\nint H,W;\nchar f[619][619];\n\nint main(){\n  cin.tie(0);\n  std::ios::sync_with_stdio(0);\n  cin >> H >> W;\n  rep(i,H)rep(j,W)cin >> f[i][j];\n\n  vector<Data> vec;\n  rep(i,H)rep(j,W){\n    if( f[i][j] == '#' && ( j-1 <  0 || f[i][j-1] == '.' ) && ( i-1 <  0 || f[i-1][j] == '.' ) ) vec.push_back(Data(atan2(H-i,j),1));\n    if( f[i][j] == '#' && ( j+1 >= W || f[i][j+1] == '.' ) && ( i+1 >= H || f[i+1][j] == '.' ) ) vec.push_back(Data(atan2(H-i-1,j+1),-1));\n    if( f[i][j] == '#' && ( j+1 <  W && f[i][j+1] == '#' ) && ( i+1 <  H && f[i+1][j] == '#' ) ) vec.push_back(Data(atan2(H-i-1,j+1),1));\n    if( f[i][j] == '#' && ( j-1 >= 0 && f[i][j-1] == '#' ) && ( i-1 >= 0 && f[i-1][j] == '#' ) ) vec.push_back(Data(atan2(H-i,j),-1));\n  }\n\n  sort(vec.begin(),vec.end());\n\n  int area = 1, ans = 1;\n  rep(i,vec.size())ans = max(ans,(area+=vec[i].cost));\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconstexpr double EPS = 1e-4;\n\nint gcd(int x, int y) { return y == 0 ? x : gcd(y, x%y); }\n\nstruct point {\n    double x, y;\n    point() {}\n    point(double x, double y): x(x), y(y) {}\n\n    point operator + (const point& o) const { return point(x+o.x, y+o.y); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y); }\n    point operator * (const double a) const { return point(x*a, y*a); }\n\n    bool operator < (const point& o) const { return x == o.x ? y < o.y : x < o.x; }\n    bool operator == (const point& o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble fabs(point a) { return sqrt(a.x*a.x + a.y*a.y); }\ndouble dist(point a, point b) { return fabs(a - b); }\ndouble dist(line l) { return dist(l.a, l.b); }\ndouble dot(point a, point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(point a, point b) { return a.x*b.y - a.y*b.x; }\n\ndouble dist_point_line(point p, line l) {\n    if (dot(p - l.a, l.b - l.a) >= 0 && dot(p - l.b, l.a - l.b) >= 0)\n        return fabs(cross(p - l.a, l.b - l.a)) / dist(l);\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nbool has_intersection(line s, line t) {\n    double s1 = cross(s.b - s.a, t.a - s.b) * cross(s.b - s.a, t.b - s.b);\n    double s2 = cross(t.b - t.a, s.a - t.a) * cross(t.b - t.a, s.b - t.a);\n    if (s1 < 0 && s2 < 0) return true;\n    else if (s1 * s2 == 0) {\n        double d1 = dist_point_line(s.a, t);\n        double d2 = dist_point_line(s.b, t);\n        double d3 = dist_point_line(t.a, s);\n        double d4 = dist_point_line(t.b, s);\n        return min(min(d1, d2), min(d3, d4)) == 0;\n    }\n    return false;\n}\n\npoint intersection(line s, line t) {\n    double c1 = fabs(cross(t.b - t.a, s.a - t.a));\n    double c2 = fabs(cross(t.b - t.a, s.b - t.a));\n    return s.a + (s.b - s.a) * (c1 / (c1 + c2));\n}\n\nint H, W;\nint block[605][605];\n\nvector<line> ls;\nvector<point> ps;\n\nint main(void) {\n    cin >> H >> W;\n    for (int i = 0; i <= H; ++i) fill(block[i], block[i]+W+1, 0);\n    for (int i = 0 ; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            char ch; cin >> ch;\n            block[i][j] = (ch == '#') ? 1 : 0;\n        }\n    }\n\n    for (int i = 0; i <= H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if ((i == 0 && block[i][j] == 1) || (i > 0 && (block[i][j] ^ block[i-1][j]))) {\n                int lj = j++;\n                while (j < W) {\n                    if ((i == 0 || block[i-1][j] == block[i-1][lj]) &&\n                        block[i][j] == block[i][lj])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(i, lj), point(i, j));\n                ps.emplace_back(H-i, lj);\n                ps.emplace_back(H-i, j);\n                --j;\n            }\n        }\n    }\n\n    for (int i = 0; i <= W; ++i) {\n        for (int j = 0; j < H; ++j) {\n            if ((i == 0 && block[j][i] == 1) || (i > 0 && (block[j][i] ^ block[j][i-1]))) {\n                int lj = j++;\n                while (j < H) {\n                    if ((i == 0 || block[j][i-1] == block[lj][i-1]) &&\n                        block[j][i] == block[lj][i])\n                        ;\n                    else break;\n                    ++j;\n                }\n                ls.emplace_back(point(lj, i), point(j, i));\n                ps.emplace_back(H-lj, i);\n                ps.emplace_back(H-j, i);\n                --j;\n            }\n        }\n    }\n\n    ps.emplace_back(0, 1);\n    ps.emplace_back(1, 0);\n\n    sort(begin(ps), end(ps), [](point p, point q) { return p.x * q.y < q.x * p.y; });\n\n    int ans = 0;\n\n    point left_bottom(H, 0);\n    for (int i = 0; i < ps.size()-1; ++i) {\n        point p1 = ps[i], p2 = ps[i+1];\n        if (p1.x * p2.y == p1.y * p2.x) continue;\n\n        p1.x *= -1; p2.x *= -1;\n\n        point end1 = left_bottom + p1 * 1000;\n        point end2 = left_bottom + (p1+p2)* 500;\n\n        line tiros[2] = {line(left_bottom, end1), line(left_bottom, end2)};\n        for (line tiro : tiros) {\n            set<point> cs;\n            for (line l : ls) {\n                if (has_intersection(tiro, l))\n                    cs.insert(intersection(tiro, l));\n            }\n\n            ans = max(ans, (int)cs.size()/2 + 1);\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = ((int)b) - 1; i >= (int)(a); --i)\n#define all(c) c.begin(), c.end()\n#define sz(c) ((int)c.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nstruct UnionFind {\n    vi data;\n    int comp;\n    UnionFind() {}\n    UnionFind(int size) {\n        init(size);\n    }\n    void init(int size) {\n        data.assign(size, -1);\n        comp = size;\n    }\n    void unite(int x, int y) {\n        x = root(x), y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n            comp--;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        if (data[x] < 0) {\n            return x;\n        } else {\n            return data[x] = root(data[x]);\n        }\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    int components() {\n        return comp;\n    }\n};\n\nvector<int> calc(const vector<string> &F) {\n    int H = sz(F);\n    int W = sz(F[0]);\n\n    set<pii> st;\n    rep(y, 0, H) {\n        rep(x, 0, W) {\n            if (F[y][x] == '#') {\n                st.insert({x,     y    });\n                st.insert({x + 1, y    });\n                st.insert({x    , y + 1});\n                st.insert({x + 1, y + 1});\n            }\n        }\n    }\n    int n = sz(st);\n    map<pii, vector<pii>> mp;\n    for (auto p : st) {\n        int x, y;\n        tie(x, y) = p;\n        int g = __gcd(x, y);\n        if (x == 0 && y == 0) {\n            mp[{0, 0}].push_back({x, y});\n        } else {\n            mp[{x / g, y / g}].push_back({x, y});\n        }\n    }\n    using T = tuple<int, int, vector<pii>>;\n    vector<T> vec;\n    for (auto p : mp) {\n        int x, y;\n        vector<pii> tmp;\n        tie(x, y) = p.first;\n        tmp = p.second;\n        vec.push_back(make_tuple(x, y, tmp));\n    }\n    sort(all(vec), [](const T& l, const T &r) {\n        int x1, y1, x2, y2;\n        tie(x1, y1, ignore) = l;\n        tie(x2, y2, ignore) = r;\n        if (x1 == 0 && y1 == 0) return true;\n        if (x2 == 0 && y2 == 0) return false;\n        return x2 * y1 < x1 * y2;\n    });\n    \n    int M = (H + 1) * (W + 1);\n    vector<int> size;\n    UnionFind uf(M);\n    auto idx = [&](int x, int y) {\n        return y * (W + 1) + x;\n    };\n    auto ok = [&](int x, int y) {\n        return 0 <= x && x < W && 0 <= y && y < H && F[y][x] == '#';\n    };\n    // cerr << \"n: \" << n << endl;\n    int cnt = 0;\n    for (auto &u : vec) {\n        int X, Y;\n        vector<pii> w;\n        tie(X, Y, w) = u;\n        \n        if (X == 0 && Y == 0) {\n            uf.unite(idx(0, 0), idx(1, 0));\n            cnt++;\n            continue;\n        }\n        cnt += sz(w);\n\n        // cerr << \"X: \" << X << \", Y: \"  << Y << \", sz(w): \" << sz(w) << \", cnt:\" << cnt << endl;\n\n        for (pii p : w) {\n            int x, y;\n            tie(x, y) = p;\n\n            // cerr << \"x: \" << x << \", y: \" << y << endl;\n\n            if (ok(x - 1, y - 1) || ok(x, y - 1)) {\n                // 下\n                // cerr << \"1: (\" << x << \", \" << y << \") <--> (\" << x << \", \" << y - 1 << \")\" << endl;\n                uf.unite(idx(x, y), idx(x, y - 1));\n            }\n            if (ok(x, y) || ok(x, y - 1)) {\n                // 右\n                // cerr << \"2: (\" << x << \", \" << y << \") <--> (\" << x + 1 << \", \" << y << \")\" << endl;\n                uf.unite(idx(x, y), idx(x + 1, y));\n            }\n        }\n        // cerr << sz(size)<< \":  uf.comp: \" << uf.components() << \" M-n:\" << M - n << \" n-cnt: \" << n - cnt << \" ==> push_back \" << uf.components() - (M - n) - (n - cnt) << endl;\n        size.push_back(uf.components() - (M - n) - (n - cnt));\n    }\n    return size;\n}\n\nsigned main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> F(H);\n    rep(i, 0, H) {\n        cin >> F[i];\n    }\n    reverse(all(F));\n\n    auto size1 = calc(F);\n    size1.insert(begin(size1), 0);\n    \n    // cerr << \"size1: \";\n    // for (int x : size1) {\n        // cerr << x << \" \";\n    // }\n    // cerr << endl;\n\n    vector<string> G(W, string(H, '.'));\n    rep(i, 0, H) {\n        rep(j, 0, W) {\n            G[j][i] = F[i][j];\n        }\n    }\n    auto size2 = calc(G);\n    reverse(all(size2));\n    size2.push_back(0);\n\n    // cerr << \"size2: \";\n    // for (int x : size2) {\n        // cerr << x << \" \";\n    // }\n    // cerr << endl;\n\n    assert(sz(size1) == sz(size2));\n    int ans = 0;\n    rep(i, 0, sz(size1)) {\n        // cerr << \"sum \" << i << \": \" << size1[i] + size2[i] << endl;\n        ans = max(ans, size1[i] + size2[i]);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\nconst double EPS = 1e-10;\n\nint H,W;\n\nbool inside(int a,int b){\n\treturn 0<=a&&a<H&&0<=b&&b<W;\n}\n\n\n\nint main(){\n\tcin>>H>>W;\n\tvector<string> v(H);\n\trep(i,H) cin>>v[i];\n\t// map<pair<int,int>,int> ma;\n\tvector<pair<double,int>> w;\n\trep(i,H-1){\n\t\trep(j,W-1){\n\t\t\tif(v[i].substr(j,2) == \"#.\" && v[i+1].substr(j,2) == \"..\"){\n\t\t\t\tdouble ang = 1.0*(H-1-i)/(j+1);\n\t\t\t\tw.push_back(make_pair(ang,1));\t\n\t\t\t}\n\t\t\tif(v[i].substr(j,2) == \"..\" && v[i+1].substr(j,2) == \".#\"){\n\t\t\t\tdouble ang = 1.0*(H-1-i)/(j+1)-EPS;\n\t\t\t\tw.push_back(make_pair(ang,-1));\t\t\t\t\t\n\t\t\t}\n\t\t\tif(v[i].substr(j,2) == \"##\" && v[i+1].substr(j,2) == \"#.\"){\n\t\t\t\tdouble ang = 1.0*(H-1-i)/(j+1)-EPS;\n\t\t\t\tw.push_back(make_pair(ang,-1));\t\n\t\t\t}\n\t\t\tif(v[i].substr(j,2) == \".#\" && v[i+1].substr(j,2) == \"##\"){\n\t\t\t\tdouble ang = 1.0*(H-1-i)/(j+1);\n\t\t\t\tw.push_back(make_pair(ang,+1));\t\n\t\t\t}\n\t\t}\n\t}\n\trep(i,H-1){\n\t\tif(v[i][W-1]=='#'&&(i==H-1||v[i+1][W-1]=='.')){\n\t\t\tdouble ang = 1.0*(H-1-i)/(W);\n\t\t\tw.push_back(make_pair(ang,1));\t\n\t\t}\n\t}\n\trep(i,W){\n\t\tif(i&&v[0][i]=='#'&&v[0][i-1]=='.'){\n\t\t\tdouble ang = 1.0*(H)/(i+1)-EPS;\n\t\t\tw.push_back(make_pair(ang,-1));\t\n\t\t}\n\t\tif(v[H-1][i]=='#'&&(i==W-1||v[H-1][i+1]=='.')){\n\t\t\tdouble ang = 1.0*(0)/(i+1);\n\t\t\tw.push_back(make_pair(ang,1));\t\n\t\t}\n\t}\n\tint ans = 1;\n\tint tmp = 1;\n\tsort(w.begin(),w.end());\n\trep(i,w.size()){\n\t\ttmp += w[i].second;\n\t\tans = max(ans, tmp);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tint h,w;\n\tchar f[602][602];\n\trep(i,602)rep(j,602)f[i][j] = '.';\n\tscanf(\"%d%d\",&h,&w);\n\trrep1(y,h){\n\t\tscanf(\"\\n\");\n\t\trep1(x,w)scanf(\"%c\",&f[x][y]);\n\t}\n\th ++; w ++;\n\t\n\tmultiset<pair<ld,int>> S;\n\trep1(x,w)rep1(y,h-1){\n\t\tif(f[x][y] != f[x][y+1]){\n\t\t\tS.insert(pair<ld,int>(y/(ld)x+1e-9,1));\n\t\t\tif(x != 1)S.insert(pair<ld,int>(y/(ld)(x-1)-1e-9,-1));\n\t\t}\n\t}\n\trep1(y,h)rep1(x,w-1){\n\t\tif(f[x][y] != f[x+1][y]){\n\t\t\tS.insert(pair<ld,int>((y-1)/(ld)x+1e-9,1));\n\t\t\tS.insert(pair<ld,int>(y/(ld)x-1e-9,-1));\n\t\t}\n\t}\n\t\n\tint ret = 0;\n\tint cnt = 0;\n\tfor(pair<ld,int> p: S){\n\t\tcnt += p.sc;\n\t\tret = max( ret , cnt );\n\t\t//cout << p.fr << \" \" << p.sc << \" \" << cnt << endl;\n\t}\n\tcout << 1+(ret+1)/2 << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nchar str[700][700];\npair<double,int> ev[500000];\ndouble eps=1e-9;\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\t\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<=a;i++)str[i][b]='.';\n\tfor(int i=0;i<=b;i++)str[a][i]='.';\n\ta++;b++;\n\tint sz=0;\n\tfor(int i=0;i<a-1;i++){\n\t\tfor(int j=0;j<b-1;j++){\n\t\t\tif(str[i][j]==str[i][j+1]&&str[i][j]==str[i+1][j]&&str[i][j]!=str[i+1][j+1]){\n\t\t\t\tev[sz++]=make_pair(atan2(a-i-2,j+1),-1);\n\t\t\t}\n\t\t\tif(str[i][j]!=str[i][j+1]&&str[i][j]!=str[i+1][j]&&str[i][j]!=str[i+1][j+1]){\n\t\t\t\tev[sz++]=make_pair(atan2(a-i-2,j+1),1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<b;i++){\n\t\tif(str[0][i]=='#'&&str[0][i-1]=='.'){\n\t\t\tev[sz++]=make_pair(atan2(a-1,i),-1);\n\t\t}\n\t}\n\tfor(int i=1;i<a;i++){\n\t\tif(str[i][0]=='#'&&str[i-1][0]=='.'){\n\t\t\tev[sz++]=make_pair(atan2(1,0),-1);\n\t\t}\n\t}\n\tstd::sort(ev,ev+sz);\n\t//for(int i=0;i<sz;i++)printf(\"%f %d\\n\",ev[i].first,ev[i].second);\n\tint ret=1;\n\tint now=1;\n\tfor(int i=0;i<sz;i++){\n\t\tnow+=ev[i].second;\n\t\tif(i<sz-1&&ev[i+1].first-ev[i].first<eps)continue;\n\t\tret=max(ret,now);\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n#define count __mycount\n\nint H, W;\nint count(int rx, int ry, const vector<string>& grid){\n    int res = 1;\n    int curr = 0;\n    bool state = false;\n    for(int x = 0; x < W; x++){\n        int next = ry * (x + 1) / rx;\n        for(int y = curr; y <= min(next, H - 1); y++){\n            char c = grid[y][x];\n            // printf(\"x = %d y = %d c = %c state = %d\\n\", x, y, c, state);\n            if(c == '#' && !state){\n                state = true;\n                res ++;\n            }else if(c == '.' && state){\n                state = false;\n            }\n        }\n        if(next >= H) break;\n        curr = next;\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> H >> W){\n        vector<string> grid(H);\n        REP(y, H) cin >> grid[H - 1 - y];\n\n        int ans = 0;\n        for(int y = 1; y <= H + 1; y++){\n            for(int x = 1; x <= W + 1; x++){\n                ans = max(ans, count(x, y, grid));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define X(p)  ( (p).real() )\n#define Y(p)  ( (p).imag() )\n\nconst double eps = 1e-10;\nconst double pi  = 3.14159265358979323846;\n\ntypedef double Num;\ntypedef complex<Num> Pt2;\ntypedef vector<Pt2> Polygon2;\n\nstruct Line2 : vector<Pt2> {\n  Line2(Pt2 a, Pt2 b) { push_back(a); push_back(b); }\n  Pt2 vec() { return (*this)[1]-(*this)[0]; }\n};\n\nPt2  unit (Pt2 v)        { return v/abs(v);     }\nNum  dist (Pt2 a, Pt2 b) { return abs(a-b);     }\nNum  dot  (Pt2 a, Pt2 b) { return X(a*conj(b)); }\nNum  cross(Pt2 a, Pt2 b) { return Y(conj(a)*b); }\nbool equal(Num a, Num b) { return abs(a-b)<eps; }\nbool equal(Pt2 a, Pt2 b) { return equal(X(a),X(b))&&equal(Y(a),Y(b)); }\n\nbool intersectLS(Line2 s, Line2 t) {\n  return cross(s.vec(), t[0]-s[0])\n       * cross(s.vec(), t[1]-s[0]) < eps;\n}\n\nint main()\n{\n\tint H,W,px=-1,py=-1,pd=-1;\n\tchar e[602][602]={0};\n\tbool b[602][602]={0};\n\n\tcin>>H>>W;\n\tfor(int y=1; y<=H; y++)\n\tfor(int x=1; x<=W; x++)\n\t{\n\t\tchar c; cin>>c;\n\t\tif(c=='#')\n\t\t{\n\t\t\tb[y][x] = 1;\n\t\t\tif(px==-1) { px=x; py=y; }\n\t\t}\n\t}\n\n\tfor(int y=1; y<=H+1; y++)\n\tfor(int x=1; x<=W+1; x++)\n\t{\n\t\tif(b[y][x]!=b[y-1][x  ]) e[y][x] |= 1;\n\t\tif(b[y][x]!=b[y  ][x-1]) e[y][x] |= 2;\n\t}\n\n\tPolygon2 g;\n\twhile(true)\n\t{\n\t\tint d=-1;\n\t\tif     (e[py  ][px  ] & 1) { d=0; e[py  ][px  ]-=1; }\n\t\telse if(e[py  ][px  ] & 2) { d=1; e[py  ][px  ]-=2; }\n\t\telse if(e[py  ][px-1] & 1) { d=2; e[py  ][px-1]-=1; }\n\t\telse if(e[py-1][px  ] & 2) { d=3; e[py-1][px  ]-=2; }\n\n\t\tif(d==-1) break;\n\t\tif(d!=pd) g.push_back(Pt2(px-1,H+1-py));\n\n\t\tconst int dx[] = {+1, 0,-1, 0};\n\t\tconst int dy[] = { 0,+1, 0,-1};\n\t\tpx+=dx[d]; py+=dy[d]; pd=d;\n\t}\n\n\tvector<Num> ang;\n\tmap<Num,int> vtx;\n\tfor(int i=0; i<g.size(); i++)\n\t{\n\t\tNum a=arg(g[i]), b=arg(g[(i+1)%g.size()]);\n\t\tang.push_back(a);\n\n\t\tif(equal(a,b)) continue;\n\t\tif(a>b) swap(a,b);\n\n\t\tif(!vtx.insert(make_pair(a, 1)).second) vtx[a]++;\n\t\tif(!vtx.insert(make_pair(b,-1)).second) vtx[b]--;\n\t}\n\n\tsort(ang.begin(), ang.end());\n\tang.erase(unique(ang.begin(), ang.end()), ang.end());\n\n\tint ans=0,cnt=0,idx=1;\n\tmap<Num,int>::iterator it;\n\tfor(it=vtx.begin(); it!=vtx.end(); it++)\n\t{\n\t\twhile((ang[idx-1]+ang[idx])/2.0 < it->first && idx<ang.size())\n\t\t{\n\t\t\tans=max(ans,cnt); idx++;\n\t\t}\n\t\tif(idx>=ang.size()) break;\n\n\t\tcnt += it->second;\n\t}\n\n\tcout << 1+ans/2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fs first\n#define sc second\n#define mp make_pair\nusing namespace std;\ntypedef double D;\ntypedef pair<D,int> pii;\n\nint main(){\n  int h,w;\n  string f[999];\n  cin.tie(0);\n  std::ios::sync_with_stdio(0);\n  cin >> h >> w;\n\n  vector<pii> v;\n  rep(i,h){\n    cin >> f[i];\n    rep(j,w){\n      if( i==0?f[i][j]=='#':f[i][j]!=f[i-1][j] ){\n\tv.push_back(mp((D)(h-i)/j,-1));\n\tv.push_back(mp((D)(h-i)/(j+1),1));\n      }\n      if( j==w-1?f[i][j]=='#':f[i][j]!=f[i][j+1] ){\n\tv.push_back(mp((D)(h-i)/(j+1),-1));\n\tv.push_back(mp((D)(h-i-1)/(j+1),1));\n      }\n    }\n  }\n\n  int res = 0, tmp = 0;\n  sort(v.begin(),v.end());\n  rep(i,v.size())res = max(res,tmp += v[i].sc);\n  cout << (res+3)/2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <complex>\n#include <list>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <sstream>\n#include <numeric>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n// INF\n#define IINF (INT_MAX/2)\n#define INF (1<<29)\n\n// math\n#define SQ(x) ((x)*(x))\n\n// container utility\n#define ALL(x) (x).begin(), (x).end()\n#define MP make_pair\n#define PB push_back\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\n// rep\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define rep(i,n) REP(i,0,n)\n\n// typedef\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\n\ntypedef long long ll;\n\n// conversion\ntemplate<class T> inline string toStr(T a) { ostringstream oss; oss << a; return oss.str(); }\ninline int toInt(string s) { return atoi(s.c_str()); }\n\n// prime\nbool isPrime(int a) { for(int i=2; i*i <=a; i++) if(a%i == 0) return false; return true; }\n\n// dx, dy\nint const dx[] = {-1,0,1,0,-1,1,1,-1};\nint const dy[] = {0,-1,0,1,-1,-1,1,1};\n\n// inRange\ninline bool inRange(int x, int y, int W, int H) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\n// isPalindrome\ninline bool isPalindrome(string s) {\n  return equal(s.begin(), s.end(), s.rbegin());\n}\n\nint check(char grid[2][2]) {\n  if(grid[0][0] == '#'\n     && grid[0][1] == '.'\n     && grid[1][0] == '.'\n     && grid[1][1] == '.') {\n    return +1;\n  }\n  \n  if(grid[0][0] == '.'\n     && grid[0][1] == '#'\n     && grid[1][0] == '#'\n     && grid[1][1] == '#'\n  ) {\n    return +1;\n  }\n  \n  if(grid[0][0] == '#'\n     && grid[0][1] == '#'\n     && grid[1][0] == '#'\n     && grid[1][1] == '.'\n  ) {\n    return -1;\n  }\n\n  if(grid[0][0] == '.'\n     && grid[0][1] == '.'\n     && grid[1][0] == '.'\n     && grid[1][1] == '#'\n  ) {\n    return -1;\n  }\n  \n  return 0;\n}\n\nint main() {\n  \n  int H, W;\n  while(cin >> H >> W) {\n    H+=2, W+=2;\n    vector<vector<char>> G(H, vector<char>(W, '.'));\n    REP(i, 1, H-1) {\n      REP(j, 1, W-1) {\n        cin >> G[i][j];\n      }\n    }\n    \n    vector<pair<double, int>> event;\n    \n    // rep(i, H) {rep(j, W) {cout << G[i][j];}cout << endl;}\n    \n    rep(i, H-1) {\n      rep(j, W-1) {\n        \n        char grid[2][2];\n        grid[0][0] = G[i][j];\n        grid[0][1] = G[i][j+1];\n        grid[1][0] = G[i+1][j];\n        grid[1][1] = G[i+1][j+1];\n        \n        int num = check(grid);\n        if(num!=0) {\n          double ang = atan2((H-2)-i, j);\n          event.PB(MP(atan2((H-2)-i, j), num));\n        }\n        \n      }\n    }\n    \n    sort(ALL(event));\n    \n    int mx = 1;\n    int cnt = 1;\n    for(auto e : event) {\n      cnt += e.second;\n      mx = max(mx, cnt);\n    }\n    cout << mx << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint h,w;\nvector<string> mp;\n\n//   1   -1    1   -1\n//  #.   ..   .#   ##\n//  ..   .#   ##   #.\n\n\nbool O___(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '.' && mp[y+1][x] == '#' && mp[y+1][x+1] == '.';\n}\n\nbool ___O(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '#' && mp[y+1][x] == '.' && mp[y+1][x+1] == '.';\n}\n\nbool _OOO(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '#' && mp[y+1][x] == '.' && mp[y+1][x+1] == '#';\n}\n\nbool OOO_(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '.' && mp[y+1][x] == '#' && mp[y+1][x+1] == '#';\n}\n\n\nsigned main(){\n  cin>>h>>w;\n  mp.resize(h+2,string(w+2,'.'));\n\n  for(int i=0;i<h;i++) \n    for(int j=0;j<w;j++) cin>>mp[h-i][j+1];\n\n  vector<string> mp2((h+2)*10,string((w+2)*10,'.'));\n  \n  for(int i=0;i<h+2;i++)\n    for(int j=0;j<w+2;j++){\n      for(int y = 0; y < 10; y++)\n        for(int x = 0; x < 10; x++)\n          mp2[i*10+y][j*10+x] = mp[i][j];\n    }\n  \n  mp = mp2;\n  h = mp.size() - 2;\n  w = mp[0].size() - 2;\n    \n  vector<P> A;\n  for(int i=1;i<h+1;i++)\n    for(int j=1;j<w+1;j++){\n      if(O___(j,i) || ___O(j,i) || _OOO(j,i) || OOO_(j,i)) A.push_back(P(j,i));\n    }\n\n  typedef complex<double> Point;\n  sort(A.begin(),A.end(),[&](P &a,P &b){\n      double x1,y1; tie(x1,y1) = a;\n      double x2,y2; tie(x2,y2) = b;\n      x1-=10;y1-=10;\n      x2-=10,y2-=10;\n      return arg(Point(x1,y1)) < arg(Point(x2,y2));\n    });\n  \n  int ans = 1;\n  int cnt = 1;\n  for(int i=0;i<(int)A.size();){\n    double x,y; tie(x,y) = A[i];\n    double th = arg(Point(x,y));\n    while(i < (int)A.size()){\n      double x,y; tie(x,y) = A[i];\n      if(th != arg(Point(x,y))) break;\n      i++;\n      if(O___(x,y) || _OOO(x,y)) cnt++;\n      else if(___O(x,y) || OOO_(x,y)) cnt--;\n      else assert(0);\n      //cout<<pr(x,y)<<endl;\n      //cout<<pr(O___(x,y), _OOO(x,y), ___O(x,y), OOO_(x,y)) <<endl;\n    }\n    Max(ans,cnt);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint h,w;\nvector<string> mp;\n\n//   1   -1    1   -1\n//  #.   ..   .#   ##\n//  ..   .#   ##   #.\n\n\nbool O___(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '.' && mp[y-1][x] == '.' && mp[y-1][x+1] == '.';\n}\n\nbool ___O(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '.' && mp[y-1][x] == '.' && mp[y-1][x+1] == '#';\n}\n\nbool _OOO(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '#' && mp[y-1][x] == '#' && mp[y-1][x+1] == '#';\n}\n\nbool OOO_(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '#' && mp[y-1][x] == '#' && mp[y-1][x+1] == '.';\n}\n\n\nsigned main(){\n  cin>>h>>w;\n  mp.resize(h+4,string(w+4,'.'));\n\n  for(int i=0;i<h;i++) \n    for(int j=0;j<w;j++) cin>>mp[(h+4-1)-i-2][j+2];\n\n  int K = 100;\n  \n  typedef tuple<int,int,int> T;\n  vector<T> A;\n  for(int i=1;i<h+3;i++)\n    for(int j=1;j<w+3;j++){\n      if(O___(j,i)) A.push_back(T(j*K+K-1,i*K,1));\n      if(___O(j,i)) A.push_back(T(j*K+K-1,i*K,-1));\n      if(_OOO(j,i)) A.push_back(T(j*K+K-1,i*K,1));\n      if(OOO_(j,i)) A.push_back(T(j*K+K-1,i*K,-1));\n    }\n\n  typedef complex<double> Point;\n  sort(A.begin(),A.end(),[&](T &a,T &b){\n      double x1,y1; tie(x1,y1,ignore) = a;\n      double x2,y2; tie(x2,y2,ignore) = b;\n      x1 -= 2*K; y1 -= 2*K;\n      x2 -= 2*K; y2 -= 2*K;\n      return arg(Point(x1,y1)) < arg(Point(x2,y2));\n    });\n  \n\n  //for(int i=0;i<h+4;i++) cout<<mp[h+3-i]<<endl; cout<<endl;\n  //for(int i=0;i<h+4;i++) cout<<mp[i]<<endl;\n  //cout<<A.size()<<endl; \n  \n  int ans = 2;\n  int cnt = 1;\n  for(int i=0;i<(int)A.size();){\n    double x,y; tie(x,y,ignore) = A[i];\n    double th = arg(Point(x-2*K,y-2*K));\n    while(i < (int)A.size()){\n      int cost;\n      double x,y; tie(x,y,cost) = A[i];\n      if(abs(th - arg(Point(x-2*K,y-2*K))) > EPS) break;\n      i++;\n      cnt += cost;\n      //cout<<pr(x,y,th,cost,cnt)<<endl;\n    }\n    Max(ans,cnt);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-11, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<bool>>fi(H+2, vector<bool>(W+2));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '#') {\n\t\t\t\tfi[i+1][j+1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<Line>ls;\n\tvector<double>katas;\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 1; x < W + 1; ++x) {\n\t\t\tif (fi[y][x]) {\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tPoint ld(x, y + 1);\n\t\t\t\t\tPoint lu(x, y);\n\t\t\t\t\tPoint rd(x + 1, y + 1);\n\t\t\t\t\tPoint ru(x + 1, y);\n\t\t\t\t\tif (!fi[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\tls.emplace_back(ld, lu);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == 1) {\n\t\t\t\t\t\t\tls.emplace_back(rd, ld);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == 2) {\n\t\t\t\t\t\t\tls.emplace_back(ru, rd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tls.emplace_back(lu, ru);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = 1; y < H + 1; ++y) {\n\t\tfor (int x = 2; x < W + 2; ++x) {\n\t\t\tint num = 0;\n\t\t\tif (fi[y][x]) num++;\n\t\t\tif (fi[y + 1][x]) num++;\n\t\t\tif (fi[y][x + 1]) num++;\n\t\t\tif (fi[y + 1][x + 1]) num++;\n\t\t\tif(num==1||num==3)katas.push_back(double(y-(H+1))/ (x - 1));\n\t\t}\n\t}\n\tkatas.push_back(0);\n\tkatas.push_back(-1000);\n\tsort(katas.begin(), katas.end());\n\tvector<double>newkatas;\n\tdouble now = 1;\n\tfor (int i = 0; i < katas.size(); ++i) {\n\t\tif (abs(katas[i]-now)>1e-10) {\n\t\t\tnewkatas.push_back(katas[i]);\n\t\t\tnow = (katas[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < newkatas.size()-1; ++i) {\n\t\tdouble kata = (newkatas[i + 1] + newkatas[i])/2;\n\t\tLine l(Point(1, H + 1), Point(1 + 1, H + 1 + kata));\n\t\tint nans = 0;\n\t\tfor (int j = 0; j < ls.size(); ++j) {\n\t\t\tif (isis_ls(l, ls[j])) {\n\t\t\t\tnans++;\n\t\t\t}\n\t\t}\n\t\tif (fi[H][1])nans--;\n\t\tans = max(ans, 1+nans/2);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nchar cps[4][2][3]={\n\t{\"#.\",\n\t \"##\"},\n\t{\".#\",\n\t \"..\"},\n\t{\"..\",\n\t \"#.\"},\n\t{\"##\",\n\t \".#\"}\n};\n\nint h,w;\nchar s[605][605];\ntypedef pair<double,int> dip;\nvector<dip> ps;\n\nint main(void){\n\tscanf(\"%d%d\",&h,&w);\n\tireg(y,1,h)scanf(\"%s\",s[y]+1);\n\treg(y,0,h+1)s[y][0]=s[y][w+1]='.';\n\treg(x,0,w+1)s[0][x]=s[h+1][x]='.';\n\t\n\treg(y,0,h){\n\t\treg(x,0,w){\n\t\t\trep(k,4){\n\t\t\t\tbool mc=true;\n\t\t\t\trep(p,2)rep(q,2){\n\t\t\t\t\tif(s[y+p][x+q]!=cps[k][p][q])mc=false;\n\t\t\t\t}\n\t\t\t\tif(mc){\n\t\t\t\t\tdouble r=atan2(y,x);\n\t\t\t\t\tint a;\n\t\t\t\t\tif(k<2)a=-1;\n\t\t\t\t\telse a=1;\n\t\t\t\t\tif(k%2==0)r-=1e-6;\n\t\t\t\t\telse r+=1e-6;\n\t\t\t\t\tps.push_back(dip(r,a));\n\t\t\t\t\t//printf(\"%d %d %lf %d\\n\",x,y,r,a);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsort(ps.begin(),ps.end());\n\tint ans=0,ns=1;\n\trep(i,ps.size()){\n\t\t//printf(\"%lf %d\\n\",ps[i].fir,ps[i].sec);\n\t\tns+=ps[i].sec;\n\t\tans=max(ans,ns);\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PL;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll h,w;\nstring s[606];\n\nint main(){\n  cin>>h>>w;\n  rep(j,w+2){\n    s[0]+=\".\";\n    s[h+1]+=\".\";\n  }\n  repl(i,1,h+1){\n    string in;\n    cin>>in;\n    s[i]=\".\"+in+\".\";\n  }\n  w+=2; h+=2;\n  vector<PL> ps;\n  rep(i,h-1)rep(j,w-1){\n    if(s[i][j]=='#'&&s[i][j+1]=='#'&&s[i+1][j]=='#'&&s[i+1][j+1]=='.'){ // inc\n      ps.push_back(PL(P(j,h-2-i),1));\n    }\n    if(s[i][j]=='.'&&s[i][j+1]=='.'&&s[i+1][j]=='.'&&s[i+1][j+1]=='#'){ // inc\n      ps.push_back(PL(P(j,h-2-i),1));\n    }\n\n    if(s[i][j]=='.'&&s[i][j+1]=='#'&&s[i+1][j]=='#'&&s[i+1][j+1]=='#'){ // dec\n      ps.push_back(PL(P(j,h-2-i),0));\n    }\n    if(s[i][j]=='#'&&s[i][j+1]=='.'&&s[i+1][j]=='.'&&s[i+1][j+1]=='.'){ // dec\n      ps.push_back(PL(P(j,h-2-i),0));\n    }\n  }\n\n  sort(all(ps),[=](const PL& a,const PL& b){\n    ll l=a.fi.se*b.fi.fi,r=a.fi.fi*b.fi.se;\n    if(l==r)return a.se < b.se;\n    else return l > r;\n  });\n\n  ll res=1,crt=1;\n  rep(i,ps.size()){\n    if(ps[i].se)crt++;\n    else crt--;\n    maxch(res,crt);\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\nint cross(int x0, int y0, int x1, int y1) { return x0*y1-x1*y0; }\n\nstruct P {\n    int i, j, p;\n    P(int i, int j, int p) : i(i), j(j), p(p) {}\n};\nbool operator<(const P& l, const P& r) {\n    const int c = cross(l.i, l.j, r.i, r.j);\n    return c!=0 ? c<0 : l.p<r.p;\n}\n\nint H, W;\nchar f[1024][1024];\n\nint kount(int i, int j) {\n    int c = 0;\n    rep(a, 2) rep(b, 2) if(f[i+a][j+b]=='#') c++;\n    return c;\n}\n\nint main() {\n    memset(f, '.', sizeof(f));\n    scanf(\"%d%d\", &H, &W);\n    rep(i, H) rep(j, W) scanf(\" %c\", f[H-i]+j+1);\n    vector<P> v;\n    rep(i, H+1) rep(j, W+1) if(i || j) {\n        const int c = kount(i, j);\n        if(c==1) {\n            if(f[i+1][j]=='#') v.push_back(P(i, j, 1));\n            if(f[i][j+1]=='#') v.push_back(P(i, j, -1));\n        }\n        else if(c==2) {\n            if(f[i+1][j]=='#' && f[i][j+1]=='#') {\n                v.push_back(P(i, j, 1));\n                v.push_back(P(i, j, -1));\n            }\n        }\n        else if(c==3) {\n            if(f[i+1][j]=='.') v.push_back(P(i, j, 1));\n            if(f[i][j+1]=='.') v.push_back(P(i, j, -1));\n        }\n    }\n    sort(v.begin(), v.end());\n    int cur = 1;\n    int ans = cur;\n    rep(i, v.size()) {\n        cur += v[i].p;\n        ans = max(ans, cur);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1);\nint sig(double r){return (r<-EPS)?-1:(r>+EPS)?+1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y): x(x),y(y){}\n\tPt operator+(const Pt&a)const {return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt&a)const {return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt&a)const {return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt&a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt&a)const{return x*a.y-y*a.x;}\n};\ninline Pt pLL(Pt a,Pt b,Pt c,Pt d){\n\tb=b-a;d=d-c;return a+b*(c-a).det(d)/b.det(d);\n}\nchar str[700][700];\nint array[700][700];\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;\n\t\tint c=b;\n\t\tb=a;\n\t\ta=c;\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[a-1-i]);\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<b;j++)array[i][j]=(str[i][j]=='#'?1:0);\n\tint ret=0;\n\t\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(gcd(i+1,j+1)>1)continue;\n\t\t\tint val=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tdouble X=i+1;\n\t\t\t\tdouble Y=(1e-8)+j+1;\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tval+=(array[k][d]^array[k+1][d]);\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tdouble Y=i+1;\n\t\t\t\tdouble X=(1e-8)+j+1;\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tval+=(array[d][k]^array[d][k+1]);\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t\tval=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tdouble X=i+1;\n\t\t\t\tdouble Y=-(1e-8)+j+1;\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tval+=(array[k][d]^array[k+1][d]);\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tdouble Y=i+1;\n\t\t\t\tdouble X=-(1e-8)+j+1;\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tval+=(array[d][k]^array[d][k+1]);\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t}\n\t}\n\tif(str[0][0]=='#')ret++;\n\tprintf(\"%d\\n\",1+ret/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nstruct frac{\n\tint num,den;\n\tfrac(){}\n\tfrac(int a,int b):num(a),den(b){}\n};\n\nbool cmp(const frac &f1,const frac &f2)\n{\n\treturn f1.num*f2.den<f1.den*f2.num;\n}\n\nint gcd(int a,int b)\n{\n\tif(a<b) return gcd(b,a);\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nint W,H;\nchar field[660][660];\n\nfrac fracs[400400];\n\nint getState(int x,int y)\n{\n\t//char lu=field[x][H-y],ld=field[x][H-y+1];\n\t//char ru=field[x+1][H-y],rd=field[x+1][H-y+1];\n\tchar lu=field[H-y][x],ld=field[H-y+1][x];\n\tchar ru=field[H-y][x+1],rd=field[H-y+1][x+1];\n\tif(lu==ld&&ld==ru&&ld!=rd)\n\t{\n\t\tif(lu=='#') return 1;\n\t\telse return 3;\n\t\t//return 1;\n\t}\n\tif(ld==ru&&ru==rd&&lu!=rd)\n\t{\n\t\tif(lu=='#') return 2;\n\t\telse return 4;\n\t\t//return 2;\n\t}\n\treturn 0;\n}\n\nint getD1(int x,int y)\n{\n\tint res=0;\n\tfor(int c=1;;c++)\n\t{\n\t\tint xx=x*c,yy=y*c;\n\t\tif(xx>W-1) break;\n\t\tif(yy>H) break;\n\t\tint s=getState(xx,yy);\n\t\tif(s==1) res++;\n\t\tif(s==4) res--;\n\t}\n\treturn res;\n}\n\nint getD2(int x,int y)\n{\n\tint res=0;\n\tfor(int c=1;;c++)\n\t{\n\t\tint xx=x*c,yy=y*c;\n\t\tif(xx>W-1) break;\n\t\tif(yy>H) break;\n\t\tint s=getState(xx,yy);\n\t\tif(s==3) res++;\n\t\tif(s==2) res--;\n\t}\n\treturn res;\n}\n\nchar ch[660];\n\nint main()\n{\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<660;i++) for(int j=0;j<660;j++) field[i][j]='.';\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tscanf(\"%s\",ch);\n\t\tfor(int j=1;j<=W;j++) field[i][j]=ch[j-1];\n\t}\n\tint c=0;\n\tfor(int x=0;x<=W-1;x++) for(int y=1;y<=H;y++)\n\t{\n\t\tif(gcd(x,y)!=1) continue;\n\t\tfracs[c]=frac(x,y);\n\t\tc++;\n\t}\n\tsort(fracs,fracs+c,cmp);\n\tint ans=1;\n\tint cur=1;\n\tfor(int i=0;i<c;i++)\n\t{\n\t\tcur+=getD1(fracs[i].num,fracs[i].den);\n\t\tans=max(ans,cur);\n\t\tcur+=getD2(fracs[i].num,fracs[i].den);\n\t\tans=max(ans,cur);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nstruct point {\n    int y, x, pls;\n    bool operator<(point const& other) const {\n        int sl1 = y * other.x;\n        int sl2 = other.y * x;\n        if(sl1 == sl2) {\n            return pls < other.pls;\n        }\n        return sl1 < sl2;\n    }\n};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> v(H);\n    vector<point> ps;\n    for(int i=0; i<H; ++i) {\n        cin >> v[i];\n    }\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            if(v[i][j] == '#') {\n                if((i == H-1 || v[i+1][j] == '.') && (j == W-1 || v[i][j+1] == '.')) {\n                    ps.push_back(point{H-i-1, j+1, 1});\n                }\n                if((i == 0 || v[i-1][j] == '.') && (j == 0 || v[i][j-1] == '.')) {\n                    ps.push_back(point{H-i, j, -1});\n                }\n            } else if(v[i][j] == '.') {\n                if((i != H-1 && v[i+1][j] == '#') && (j != W-1 && v[i][j+1] == '#')) {\n                    ps.push_back(point{H-i-1, j+1, 1});\n                }\n                if((i != 0 && v[i-1][j] == '#') && (j != 0 && v[i][j-1] == '#')) {\n                    ps.push_back(point{H-i, j, -1});\n                }\n            }\n        }\n    }\n    sort(ps.begin(), ps.end());\n    int now = 1;\n    int res = now;\n    for(auto& p : ps) {\n        now += p.pls;\n        res = max(res, now);\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\nconst ld eps = 1e-8, INF = 1e+8;\n\nint main() {\n  int h,w;\n  cin>>h>>w;\n  vector<string> t(h+2,string(w+2,'.'));\n  REP(i,h) {\n    string str;\n    cin>>str;\n    t[i+1] = '.'+str+'.';\n  }\n  reverse(begin(t),end(t));\n  map<ld,int> s;\n  REP(i,h+1)REP(j,w+1) {\n    if (t[i][j] == t[i+1][j+1] && t[i+1][j] != t[i][j+1]) {\n      if (t[i][j] == t[i][j+1]) ++s[((ld)i)/j];\n      else --s[((ld)i)/j];\n    }\n  }\n  int sum = 0;\n  int mxsum = 0;\n  for (auto p : s) {\n    int addv;\n    tie(ignore, addv) = p;\n    sum += addv;\n    mxsum = max(mxsum, sum);\n  }\n  cout << mxsum+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass UF{\n    private:\n    int sz; vector<int> par,nrank,size;\n    public:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz),size.resize(sz);\n        rep(i,sz){par[i] = i;nrank[i]=0;size[i]=1;}}\n    int find(int x){if(par[x]==x){return x;}else{return par[x] = find(par[x]);}}\n    void unite(int x,int y)\n    { x =find(x),y = find(y);if(x==y)return;if(nrank[x]<nrank[y])swap(x,y);\n        par[y] = x;size[x] += size[y];if(nrank[x]==nrank[y])nrank[x]++;}\n    int query(int x){x = find(x);return size[x];}\n    bool same(int x,int y){return find(x)==find(y);}\n};\n\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<string>s(n);\n    rep(i,n)cin >> s[n-1-i];\n    vector<vector<bool> > p(n+1,vector<bool>(m+1));\n    vector<vector<bool> > pp(n+1,vector<bool>(m+1));\n    vector<vector<bool> > qq(n+1,vector<bool>(m+1));\n    vector<vector<bool> > used(2*(n+1),vector<bool>(2*(m+1)));\n    vector<pair<int,int> > v;\n    for(int i=1;i<n;i++){\n        for(int j=1;j<m;j++){\n            if(s[i-1][j-1]=='#'&&s[i][j-1]=='#'&&s[i-1][j]=='#'&&s[i][j]=='#'){\n                continue;\n            }\n            if(s[i-1][j-1]=='.'&&s[i][j-1]=='.'&&s[i-1][j]=='.'&&s[i][j]=='.'){\n                continue;\n            }\n            v.push_back(make_pair(2*i,2*j));\n            v.push_back(make_pair(2*i-1,2*j));\n            v.push_back(make_pair(2*i+1,2*j));\n            v.push_back(make_pair(2*i-1,2*j-1));\n            v.push_back(make_pair(2*i+1,2*j+1));\n            v.push_back(make_pair(2*i-1,2*j+1));\n            v.push_back(make_pair(2*i+1,2*j-1));\n            v.push_back(make_pair(2*i,2*j-1));\n            v.push_back(make_pair(2*i,2*j+1));\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(s[i][j]=='#'){\n                p[i][j] = 1;\n                p[i+1][j] = 1;\n                p[i][j+1] = 1;\n                p[i+1][j+1] = 1;\n                pp[i][j]=1;\n                pp[i+1][j]=1;\n                qq[i][j]=1;\n                qq[i][j+1]=1;\n            }\n        }\n    }\n    int ma = 1;\n    int ng = (n+1)*(m+1);\n    used[0][0] = 1;\n    if(n==1||m==1){\n        for(int a=0;a<2*n+2;a++){for(int b=0;b<2*m+2;b++){\n            if(used[a][b])continue;\n            for(int i=1;i<1000;i++){\n                if(a*i>n||b*i>m)break;\n                used[a*i][b*i] = 1;\n            }\n            UF v((n+1)*(m+1)+1);\n            vector<vector<int> > d(n+1,vector<int>(m+1));\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    if(!p[i][j]){\n                        d[i][j] = -1;\n                    }else if(a*j==i*b){\n                        d[i][j] = 0;\n                    }else if(a*j>i*b){\n                        d[i][j] = 1;\n                    }else{\n                        d[i][j] = 2;\n                    }\n                }\n            }\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(d[i][j]==-1){\n                        v.unite(now,ng);\n                    }else if(d[i][j]==0){\n                        v.unite(now,ng);\n                        if(i>0&&j<m){\n                            if(qq[i-1][j]&&pp[i][j]){\n                                v.unite(now-m-1,now+1);\n                            }\n                        }\n                        if(i<n&&j>0){\n                            if(qq[i][j]&&pp[i][j-1]){\n                                v.unite(now+m+1,now-1);\n                            }\n                        }\n                    }else{\n                        if(i+1<n+1){\n                            if(d[i][j]==d[i+1][j]&&(qq[i][j])){\n                                v.unite(now,now+m+1);\n                            }\n                        }\n                        if(j+1<m+1){\n                            if(d[i][j]==d[i][j+1]&&(pp[i][j])){\n                                v.unite(now,now+1);\n                            }\n                        }\n                    }\n                }\n            }\n            set<int> st;\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(!v.same(now,ng)){\n                        st.insert(v.find(now));\n                    }\n                }\n            }\n            // cout << \"a=\" << a << \"b=\" << b << endl;\n            // for(auto x:st){\n            //     cout << x/(m+1) << \" \" << x%(m+1) << endl;\n            // } \n            ma = max(ma,(int)st.size());\n        }   \n    }\n    }\n    for(auto x:v){\n        int a = x.first;\n        int b = x.second;\n            if(used[a][b])continue;\n            for(int i=1;i<1000;i++){\n                if(a*i>n||b*i>m)break;\n                used[a*i][b*i] = 1;\n            }\n            UF v((n+1)*(m+1)+1);\n            vector<vector<int> > d(n+1,vector<int>(m+1));\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    if(!p[i][j]){\n                        d[i][j] = -1;\n                    }else if(a*j==i*b){\n                        d[i][j] = 0;\n                    }else if(a*j>i*b){\n                        d[i][j] = 1;\n                    }else{\n                        d[i][j] = 2;\n                    }\n                }\n            }\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(d[i][j]==-1){\n                        v.unite(now,ng);\n                    }else if(d[i][j]==0){\n                        v.unite(now,ng);\n                        if(i>0&&j<m){\n                            if(qq[i-1][j]&&pp[i][j]){\n                                v.unite(now-m-1,now+1);\n                            }\n                        }\n                        if(i<n&&j>0){\n                            if(qq[i][j]&&pp[i][j-1]){\n                                v.unite(now+m+1,now-1);\n                            }\n                        }\n                    }else{\n                        if(i+1<n+1){\n                            if(d[i][j]==d[i+1][j]&&(qq[i][j])){\n                                v.unite(now,now+m+1);\n                            }\n                        }\n                        if(j+1<m+1){\n                            if(d[i][j]==d[i][j+1]&&(pp[i][j])){\n                                v.unite(now,now+1);\n                            }\n                        }\n                    }\n                }\n            }\n            set<int> st;\n            for(int i=0;i<n+1;i++){\n                for(int j=0;j<m+1;j++){\n                    int now = i*(m+1)+j;\n                    if(!v.same(now,ng)){\n                        st.insert(v.find(now));\n                    }\n                }\n            }\n            // cout << \"a=\" << a << \"b=\" << b << endl;\n            // for(auto x:st){\n            //     cout << x/(m+1) << \" \" << x%(m+1) << endl;\n            // } \n            ma = max(ma,(int)st.size());\n        \n    }\n    cout << ma << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass rational {\nprivate:\n  static ll gcd(ll a, ll b) { return b != 0 ? gcd(b, a % b) : a; }\npublic:\n  ll p, q;\n  rational(ll _p, ll _q) {\n    ll g = gcd(_p, _q);\n    p = _p / g;\n    q = _q / g;\n  }\n  bool operator==(const rational r) const { return p * r.q == q * r.p; }\n  bool operator<(const rational r) const { return p * r.q < q * r.p; }\n};\n\nint main(void) {\n  ll H, W;\n  cin >> H >> W;\n  vector<string> S(H + 1);\n  REP(i, 0, H) {\n    cin >> S[H - i - 1];\n    S[H - i - 1] += '.';\n  }\n  S[H] = \"\";\n  REP(i, 0, W + 1) S[H] += '.';\n\n  vector<rational> vec;\n  vec.push_back(rational(0, 1));\n  vec.push_back(rational(1LL << 50, 1));\n  REP(i, 0, H) REP(j, 0, W) {\n    if(j != 0) vec.push_back(rational(i + 1, j));\n    if(i != 0) vec.push_back(rational(i, j + 1));\n    vec.push_back(rational(i + 1, j + 1));\n  }\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n\n  vector<ll> imos(vec.size() + 1, 0);\n  REP(i, 0, H) REP(j, 0, W) {\n    if(S[i][j] != S[i + 1][j]) {\n      ll s = lower_bound(vec.begin(), vec.end(), rational(i + 1, j + 1)) - vec.begin();\n      ll e = lower_bound(vec.begin(), vec.end(), j != 0 ? rational(i + 1, j) : rational(1LL << 50, 1)) - vec.begin();\n      imos[s + 1]++;\n      imos[e + 1]--;\n    }\n    if(S[i][j] != S[i][j + 1]) {\n      ll s = lower_bound(vec.begin(), vec.end(), i != 0 ? rational(i, j + 1) : rational(0, 1)) - vec.begin();\n      ll e = lower_bound(vec.begin(), vec.end(), rational(i + 1, j + 1)) - vec.begin();\n      imos[s + 1]++;\n      imos[e + 1]--;\n    }\n  }\n  REP(i, 0, imos.size() - 1) imos[i + 1] += imos[i];\n\n  ll ans = 0;\n  REP(i, 0, imos.size() - 1) ans = max(ans, imos[i]);\n  cout << (ans + 1) / 2 + 1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<tuple>\nusing namespace std;\nint H, W, x[1000][1000], maxn = 1, cnt = 1;\nvector<tuple<long double, int, int>>tup;\nint analysis(int p, int q) {\n\tint D = x[p - 1][q - 1] * 1 + x[p - 1][q] * 2;\n\tD += x[p][q - 1] * 4 + x[p][q] * 8;\n\tif (D == 8 || D == 7)return 1;\n\tif (D == 1 || D == 14)return -1;\n\treturn 0;\n}\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tchar c; cin >> c; if (c == '#')x[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= H + 1; i++) {\n\t\tfor (int j = 1; j <= W + 1; j++) {\n\t\t\tint XX = (H + 1) - i, YY = j - 1;\n\t\t\tif (XX + YY == 0)continue;\n\t\t\ttup.push_back(make_tuple(1.0l*YY / XX, i, j));\n\t\t}\n\t}\n\tsort(tup.begin(), tup.end());\n\tfor (int i = 0; i < tup.size(); i++) {\n\t\tint p = analysis(get<1>(tup[i]), get<2>(tup[i]));\n\t\tcnt += p;\n\t\tlong double B = 0.0l;\n\t\tif (i < tup.size() - 1)B = fabs(get<0>(tup[i]) - get<0>(tup[i + 1]));\n\t\tif (i == (tup.size() - 1) || B > 1e-12) {\n\t\t\tmaxn = max(maxn, cnt);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint check(char *grid){\n  char g1[] = \"#...\";\n  char g2[] = \".###\";\n  char g3[] = \"...#\";\n  char g4[] = \"###.\";\n  \n  if(!strncmp(grid, \"#...\", 4) || !strncmp(grid, \".###\", 4)) return 1;\n  if(!strncmp(grid, \"...#\", 4) || !strncmp(grid, \"###.\", 4)) return -1;\n  return 0;\n}\n\nint main(){\n  int H, W;\n  while(cin >> H >> W){\n    H += 2; W += 2;\n    vector<vector<char> >G(H, vector<char>(W, '.'));\n    for(int i=1;i<H-1;i++){\n      for(int j=1;j<W-1;j++){\n\tcin >> G[i][j];\n      }\n    }\n    // for(int i=0;i<H;i++){\n    //   for(int j=0;j<W;j++){\n    // \tcout << G[i][j];\n    //   }\n    //   cout << endl;\n    // }\n    vector<pair<double, int> >E;\n    for(int i=0;i<H-1;i++){\n      for(int j=0;j<W-1;j++){\n\tchar g[4];\n\tg[0] = G[i][j];\n\tg[1] = G[i][j+1];\n\tg[2] = G[i+1][j];\n\tg[3] = G[i+1][j+1];\n\tint c = check(g);\n\t// cout << g << \" \" << c << endl;\n\tif(c){\n\t  E.push_back(make_pair(atan2(H-2-i, j), c));\n\t}\n      }\n    }\n\n    sort(E.begin(), E.end());\n\n    int result = 2;\n    int cnt = 1;\n    // cout << E.size() << endl;\n    for(const auto &e: E){\n      cnt += e.second;\n      result = max(result, cnt);\n    }\n\n    cout << result << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n  int H, W;\n  cin >> H >> W;\n  string F[H];\n  for(int i = 0; i < H; ++i){\n    cin >> F[i];\n  }\n  map<pair<pii,pii>, int> E;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(F[i][j] == '#'){\n\t++E[make_pair(pii(H-i,j), pii(H-i-1,j))];\n\t++E[make_pair(pii(H-i,j), pii(H-i,j+1))];\n\t++E[make_pair(pii(H-i-1,j), pii(H-i-1,j+1))];\n\t++E[make_pair(pii(H-i,j+1), pii(H-i-1,j+1))];\n      }\n    }\n  }\n  vector< pair<double,int> > A;\n  for(map<pair<pii,pii>,int>::iterator itr = E.begin(); itr != E.end(); ++itr){\n    if(itr->second == 1){\n      pii s = itr->first.first, t = itr->first.second;\n      //cout << \"(\" << s.first << \", \" << s.second << \"), (\" << t.first << \", \" << t.second << \")\" << endl;\n      if(s.second && s.first)\n\tA.push_back(make_pair((double)s.first/s.second, -1));\n      if(t.second && s.first)\n\tA.push_back(make_pair((double)t.first/t.second, +1));\n    }\n  }\n  sort(A.begin(),A.end());\n  int ans = 0, t = 0;\n\n  for(int i = 0; i < (int)A.size(); ++i){\n\n    t += A[i].second;\n    t = max(t,0);\n    ans = max(t,ans);\n  }\n  //cout << ans << endl;\n  cout << (ans+1)/2 + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Arg {\n  int x, y, t;\n  bool operator < (const Arg &a) const {\n    if(y * a.x == a.y * x) return t < a.t;\n    else y * a.x < a.y * x;\n  }\n};\n\nconst int MAXH = 666;\nconst int MAXW = 666;\n\nint H, W;\nchar G[MAXH][MAXW];\n\nint main() {\n  cin >> H >> W;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> G[i][j];\n    }\n  }\n  vector<Arg> v;\n  for(int i = 0; i <= H; ++i) {\n    for(int j = 0; j <= W; ++j) {\n      bool a = i   && j   && G[i-1][j-1] == '#';\n      bool b = i   && j-W && G[i-1][j]   == '#';\n      bool c = i-H && j   && G[i][j-1]   == '#';\n      bool d = i-H && j-W && G[i][j]     == '#';\n      if( a && !b && !c && !d) v.push_back((Arg){j, H-i,  1});\n      if(!a &&  b &&  c &&  d) v.push_back((Arg){j, H-i,  1});\n      if(!a && !b && !c &&  d) v.push_back((Arg){j, H-i, -1});\n      if( a &&  b &&  c && !d) v.push_back((Arg){j, H-i, -1});\n    }\n  }\n  sort(v.begin(), v.end());\n  int now = 1;\n  int maxi = now;\n  for(int i = 0; i < v.size(); ++i) {\n    now += v[i].t;\n    maxi = max(maxi, now);\n  }\n  cout << maxi << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<double,double>D;\ntypedef pair<P,int>PP;\ntypedef pair<double,P>dP;\ntypedef pair<D,int>Di;\n\nconst int MAX_N = 602;\nconst int dx[] = {1,1,0,0};\nconst int dy[] = {0,0,1,-1};\nconst int ex[] = {1,0,1};\nconst int ey[] = {0,1,1};\n\nint a[MAX_N][MAX_N];\nint flag[MAX_N][MAX_N];\nint h,w;\nint gcd_table[MAX_N][MAX_N];\nvector<PP> vec;\nmap<P,int> mp;\n\nvoid dfs(int u,int v)\n{\n    flag[u][v] = 1;\n    if(u < w-1 && 0 < v && !a[u+1][v] && !a[u][v-1] && !a[u+1][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u == w-1 && 0 < v && !a[u][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u < w-1 && 0 < v && a[u+1][v] && a[u][v-1] && !a[u+1][v-1]){  //??????2\n        vec.push_back(PP(P(u+1,v),2));\n    }\n    if(0 < u && v < h-1 && !a[u-1][v] && !a[u][v+1] && !a[u-1][v+1]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(v == h-1 && !a[u-1][v]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v < h-1 && a[u-1][v] && a[u][v+1] && !a[u-1][v+1]){  //??????2\n        vec.push_back(PP(P(u,v+1),3));\n    }\n    rep(i,4){\n        int nx = u + dx[i],ny = v + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && a[nx][ny] && !flag[nx][ny]){\n            dfs(nx,ny);\n        }\n    }\n    return;\n}\n\nint gcd(int a,int b)\n{\n    if(a % b == 0){\n        return b;\n    }\n    return gcd(b,a % b);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&h,&w);\n    rep(j,h){\n        string s;\n        cin >> s;\n        rep(i,s.length()){\n            flag[i][j] = 0;\n            if(s[i] == '#'){\n                a[i][h-j-1] = 1;\n            }else{\n                a[i][h-j-1] = 0;\n            }\n        }\n    }\n    for(int i = 1;i <= 600;i++){\n        for(int j = i;j <= 600;j++){\n            gcd_table[j][i] = gcd(j,i);\n        }\n    }\n    bool fl = false;\n    rep(i,w){\n        rep(j,h){\n            if(a[i][j]){\n                dfs(i,j);\n                fl = true;\n                break;\n            }\n        }\n        if(!fl){\n            break;\n        }\n    }\n    // rep(i,vec.size()){\n    //     cout << vec[i].first.first << \" \" << vec[i].first.second << \" \" << vec[i].second << \"\\n\";\n    // }\n    vector<dP> tilt;\n    rep(i,vec.size()){\n        int p1 = (vec[i].first).first;\n        int p2 = (vec[i].first).second;\n        tilt.push_back(dP((double)p2 / p1,P(i,vec[i].second)));\n    }\n    sort(all(tilt));\n    vector<PP> cand;\n    rep(i,tilt.size()){\n        int cnt[] = {0,0,0,0};\n        int id = i;\n        double n1 = tilt[i].first;\n        int n2 = (tilt[i].second).first;\n        int n3 = (tilt[i].second).second;\n        cnt[n3]++;\n        while(id + 1 < tilt.size() && abs(tilt[id].first-tilt[id+1].first) < EPS){\n            n1 = tilt[i+1].first;\n            n3 = (tilt[i+1].second).first;\n            cnt[n3]++;\n            id++;\n        }\n        int mx = max(cnt[0]+cnt[3],cnt[1]+cnt[2]);\n        i = id;\n        P p = vec[n2].first;\n        int md = gcd_table[max(p.first,p.second)][min(p.first,p.second)];\n        mp[P(p.first / md,p.second / md)]++;\n        cand.push_back(PP(P(p.first / md,p.second / md),mx));\n    }\n    for(int i = 1;i <= w;i++){\n        for(int j = 1;j <= h;j++){\n            int md = gcd_table[max(i,j)][min(i,j)];\n            P p = P(i / md,j / md);\n            if(!mp[p]){\n                cand.push_back(PP(p,0));\n                mp[p]++;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,cand.size()){\n        vector<Di> cros;\n        P p = cand[i].first;\n        rep(j,p.first-1){\n            cros.push_back(Di(D(j+1,(double)(j+1) * p.second / p.first),0));\n        }\n        rep(j,p.second-1){\n            cros.push_back(Di(D((double)(j+1) * p.first / p.second,j+1),1));\n        }\n        sort(all(cros));\n        vector<int> act;\n        rep(j,cros.size()){\n            act.push_back(cros[j].second);\n        }\n        act.push_back(2);\n        int cnt = 0;\n        int px = 0,py = 0;\n        int bf = a[0][0];\n        int res = 0;\n        while(1){\n            px += ex[act[cnt%act.size()]];\n            py += ey[act[cnt%act.size()]];\n            if(px < w && py < h){\n                if(bf == 1 && !a[px][py]){\n                    res++;\n                }\n                bf = a[px][py];\n            }else{\n                if(bf == 1){\n                    res++;\n                }\n                break;\n            }\n            cnt++;\n        }\n        ans = max(res+cand[i].second,ans);\n    }\n    cout << ans + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <iostream>\n \n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <complex>\n#include <cassert>\n \nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n//typedef tuple<int, int, int> T;\ntypedef pair<ll, ll> Pl;\n//typedef tuple<ll, ll, ll> Tl;\n \n \n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n \n//config\n//#define NDEBUG\n \n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n \ntemplate<class T> inline string toString(const vector<T>& x) {\n    stringstream ss;\n    REP(i,x.size()){\n        if(i!=0)ss<<\" \";\n        ss<< x[i];\n    }\n    return ss.str();\n}\n \ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n    stringstream ss;\n    REP(i,map.size()){\n        if(i!=0)ss<<BR;\n        ss<< toString(map[i]);\n    }\n    return ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n    string res;stringstream ss;\n    for(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n    return ss.str();\n}\n \n \n \nnamespace Ps{\n    const double EPS=1e-8,INF=1e12;\n#define X real()\n#define Y imag()\n    typedef complex<double> P;\n}\nusing namespace Ps;\nnamespace Ls{\n    struct L:public vector<P>{\n        L(const P&a,const P&b){\n            push_back(a);push_back(b);\n        }\n    };\n}\nusing namespace Ls;\n \n \nclass Seg{\npublic:\n    double l,r;\n    Seg(double l,double r):l(l),r(r){\n    }\n \n    bool operator < (const Seg& rt) const{\n        return l<rt.l;\n    }\n};\n \nint main() {\n    int H,W;cin >> H >> W;\n    vector<string> board(H+2);\n\n    board[0]=string(W+2,'.');\n     \n    for(int y=1;y<=H;y++){\n    \tboard[y]=string(W+2,'.');\n    \tstring s;cin >> s;\n    \tfor(int i=1;i<=W;i++)board[y][i]=s[i-1];\n    }\n    board[H+1]=string(W+2,'.');\n   \n    vector<L> ls;\n \n    // -\n    for(int y=1;y<=H+1;y++){\n        int x=1;\n        for(;x<=W;x++){\n            if(board[y-1][x]=='.' && board[y][x]=='#'){\n                P p1(H-(y-1),x-1);\n                x++;\n                while(board[y-1][x]=='.' && board[y][x]=='#'){\n                    x++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                x--;\n            }\n            if(board[y-1][x]=='#' && board[y][x]=='.'){\n                P p1(H-(y-1),x-1);\n                x++;\n                while(board[y-1][x]=='#' && board[y][x]=='.'){\n                    x++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                x--;\n            }\n        }\n    }\n \n    // |\n    for(int x=1;x<=W+1;x++){\n        int y=0;\n        for(;y<=H;y++){\n            if(board[y][x]=='.' && board[y][x+1]=='#'){\n                P p1(H-(y-1),x-1);\n                y++;\n                while(board[y][x]=='.' && board[y][x+1]=='#'){\n                    y++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                y--;\n            }\n            if(board[y][x]=='#' && board[y][x+1]=='.'){\n                P p1(H-(y-1),x-1);\n                y++;\n                while(board[y][x]=='#' && board[y][x+1]=='.'){\n                    y++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                y--;\n            } \n        }\n    }\n \n    // for(int i=0;i<ls.size();i++){\n    //  cout << ls[i][0]<<\" \" <<ls[i][1]<<endl;\n    // }\n \n    // DUMP(ls.size());\n    // //DUMP(toString())\n \n    vector<Seg> ss;\n    for(int i=0;i<ls.size();i++){\n        ss.push_back(Seg(min(arg(ls[i][0]),arg(ls[i][1])+EPS),1));\n        ss.push_back(Seg(max(arg(ls[i][0]),arg(ls[i][1])-EPS),-1));     \n    } \n    sort(ss.begin(),ss.end());\n \n \n    int Mv=0,v=0;\n    for(int i=0;i<ss.size();i++){\n        v+=ss[i].r;\n        Mv=max(Mv,v);\n    }\n \n    cout << (Mv/2 + 1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct point {\n\tint x, y;\n};\nbool operator<(const point& p1, const point& p2) {\n\treturn p1.x * p2.y < p1.y * p2.x;\n}\nbool operator>(const point& p1, const point& p2) {\n\treturn p1.x * p2.y > p1.y * p2.x;\n}\nbool operator==(const point& p1, const point& p2) {\n\treturn p1.x == p2.x && p1.y == p2.y;\n}\nint gcd(int x, int y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> S(H + 2, string(W + 2, '.'));\n\tfor (int i = 0; i < H; ++i) {\n\t\tcin >> S[i + 1]; S[i + 1] = '.' + S[i + 1] + '.';\n\t}\n\treverse(S.begin(), S.end());\n\tvector<point> l, r;\n\tfor (int i = 1; i <= H; ++i) {\n\t\tint pre = 0;\n\t\tfor (int j = 1; j <= W + 1; ++j) {\n\t\t\tif (S[i][j] != S[i][j - 1] || S[i + 1][j] != S[i + 1][j - 1]) {\n\t\t\t\tif (S[i][j - 1] != S[i + 1][j - 1]) {\n\t\t\t\t\tl.push_back(point{ i, j - 1 });\n\t\t\t\t\tr.push_back(point{ i, pre - 1 });\n\t\t\t\t}\n\t\t\t\tpre = j;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= W; ++i) {\n\t\tint pre = 0;\n\t\tfor (int j = 1; j <= H + 1; ++j) {\n\t\t\tif (S[j][i] != S[j - 1][i] || S[j][i + 1] != S[j - 1][i + 1]) {\n\t\t\t\tif (S[j - 1][i] != S[j - 1][i + 1]) {\n\t\t\t\t\tl.push_back(point{ j - 1, i });\n\t\t\t\t\tr.push_back(point{ pre - 1, i });\n\t\t\t\t}\n\t\t\t\tpre = j;\n\t\t\t}\n\t\t}\n\t}\n\tint N = l.size();\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (l[i] > r[i]) {\n\t\t\tswap(l[i], r[i]);\n\t\t}\n\t\tint gl = gcd(l[i].x, l[i].y); if (gl != 0) l[i].x /= gl, l[i].y /= gl;\n\t\tint gr = gcd(r[i].x, r[i].y); if (gr != 0) r[i].x /= gr, r[i].y /= gr;\n\t}\n\tmap<point, int> gin, gout;\n\tvector<point> sp;\n\tfor (int i = 0; i < N; ++i) {\n\t\t++gin[l[i]];\n\t\t++gout[r[i]];\n\t\tsp.push_back(l[i]);\n\t\tsp.push_back(r[i]);\n\t}\n\tsort(sp.begin(), sp.end());\n\tsp.erase(unique(sp.begin(), sp.end()), sp.end());\n\tint cnt = 0, mx = 0;\n\tfor (point p : sp) {\n\t\tcnt += gin[p];\n\t\tcnt -= gout[p];\n\t\tmx = max(mx, cnt);\n\t}\n\tcout << (mx + 1) / 2 + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1);\nint sig(double r){return (r<-EPS)?-1:(r>+EPS)?+1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y): x(x),y(y){}\n\tPt operator+(const Pt&a)const {return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt&a)const {return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt&a)const {return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt&a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt&a)const{return x*a.y-y*a.x;}\n};\ninline Pt pLL(Pt a,Pt b,Pt c,Pt d){\n\tb=b-a;d=d-c;return a+b*(c-a).det(d)/b.det(d);\n}\nchar str[700][700];\nint array[700][700];\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;\n\t\tint c=b;\n\t\tb=a;\n\t\ta=c;\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[a-1-i]);\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<b;j++)array[i][j]=(str[i][j]=='#'?1:0);\n\tint ret=0;\n\t\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(gcd(i+1,j+1)>1)continue;\n\t\t\tint val=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,(1e-8)+j+1),Pt(k+1,0),Pt(k+1,1));\n\t\t\t\tint d=(int)(t.y);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tval+=(array[k][d]^array[k+1][d]);\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,(1e-8)+j+1),Pt(0,k+1),Pt(1,k+1));\n\t\t\t\tint d=(int)(t.x);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tval+=(array[d][k]^array[d][k+1]);\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t\tval=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,-(1e-8)+j+1),Pt(k+1,0),Pt(k+1,1));\n\t\t\t\tint d=(int)(t.y);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tval+=(array[k][d]^array[k+1][d]);\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,-(1e-8)+j+1),Pt(0,k+1),Pt(1,k+1));\n\t\t\t\tint d=(int)(t.x);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tval+=(array[d][k]^array[d][k+1]);\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t}\n\t}\n\tif(str[0][0]=='#')ret++;\n\tprintf(\"%d\\n\",1+ret/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nint N;\nstring G[701];\ntypedef pair<int,int>P;\ntypedef pair<P,int>PP;\nint H,W;\n//double eps=0.000005;\ndouble eps=0.0000000000;\ndouble eeps=0.00001;\nbool cmp(const PP&a,const PP&b){\n\tif(a.first==b.first){\n\t\treturn a.second<b.second;\n\t}\n\tif((H-a.first.first)*(b.first.second)==(a.first.second)*(H-b.first.first)){\n\t\treturn a.second<b.second;\n\t}\n\treturn (H-a.first.first)*(b.first.second)>(a.first.second)*(H-b.first.first);\n}\nint main(){\n\tcin>>H>>W;\n\tREP(i,H){\n\t\tcin>>G[i];\n\t}\n\tvector<PP>v;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tif(G[i][j]=='#'){\n\t\t\t\t/*//横\n\t\t\t\tif(i==0||G[i-1][j]=='.'){\n\t\t\t\t\tv.push_back(PP(P(i,j),1));\n\t\t\t\t\tv.push_back(PP(P(i,j+1),-1));\n\t\t\t\t}\n\t\t\t\tif(i!=H-1&&G[i+1][j]=='.'){\n\t\t\t\t\tv.push_back(PP(P(i+1,j),1));\n\t\t\t\t\tv.push_back(PP(P(i+1,j+1),-1));\n\t\t\t\t}\n\t\t\t\t//縦\n\t\t\t\tif((j+1)==W-1||G[i][j+1]=='.'){\n\t\t\t\t\tv.push_back(PP(P(i,j+1),1));\n\t\t\t\t\tv.push_back(PP(P(i+1,j+1),-1));\n\t\t\t\t}\n\t\t\t\tif(j!=0&&G[i][j-1]=='.'){\n\t\t\t\t\tv.push_back(PP(P(i,j),1));\n\t\t\t\t\tv.push_back(PP(P(i+1,j),-1));\n\t\t\t\t}*/\n\t\t\t\t\n\t\t\t\t//横\n\t\t\t\tif(i==0||G[i-1][j]=='.'){\n\t\t\t\t\tv.push_back(PP(P(i,j),1));\n\t\t\t\t\tv.push_back(PP(P(i,j+1),-1));\n\t\t\t\t}\n\t\t\t\tif(i+1!=H&&G[i+1][j]=='.'){\n\t\t\t\t\tv.push_back(PP(P(i+1,j),1));\n\t\t\t\t\tv.push_back(PP(P(i+1,j+1),-1));\n\t\t\t\t}\n\t\t\t\t//縦\n\t\t\t\tif((j+1)==W||G[i][j+1]=='.'){\n\t\t\t\t\tv.push_back(PP(P(i,j+1),1));\n\t\t\t\t\tv.push_back(PP(P(i+1,j+1),-1));\n\t\t\t\t}\n\t\t\t\tif(j!=0&&G[i][j-1]=='.'){\n\t\t\t\t\tv.push_back(PP(P(i,j),1));\n\t\t\t\t\tv.push_back(PP(P(i+1,j),-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(),v.end(),cmp);\n\tLL ans=2;\n\tLL ans2=0;\n\tLL now=0;\n\tREP(i,v.size()){\n\t\t//cout<<v[i].first.first<<\" \"<<v[i].first.second<<\" \"<<v[i].second<<endl;\n\t\tnow+=v[i].second;\n\t\tans=max(ans,(now+1)/2+1);\n\t\tans2=max(ans2,now);\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int W = 666;\nconst int INF = 1000000007;\nint h,w;\nvector<string> board;\n\nbool input(){\n\tcin>>h>>w;\n\tboard.clear();\n\trep(i,h){\n\t\tstring s;\n\t\tcin>>s;\n\t\tboard.pb(s);\n\t}\n\treturn true;\n}\n\nint gcd(int n, int m) {\n\treturn (n % m) ? gcd(m, n %m) : m;\n}\n\nint isBlock(char c){\n\tif(c=='#')return 1;\n\treturn 0;\n}\n\nint getState(int y,int x){\n\tint ret = 0;\n\tret += (1<<0)*isBlock(board[y][x-1]);\n\tret += (1<<1)*isBlock(board[y][x]);\n\tret += (1<<2)*isBlock(board[y-1][x-1]);\n\tret += (1<<3)*isBlock(board[y-1][x]);\n\treturn ret;\n}\n\nint cup[16];\nint cdown[16];\n\nint _cup(int state){\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 2;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 0;\n\t\tcase 8:return 0;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 2;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n\t\n}\n\nint _cdown(int state){\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 0;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 2;\n\t\tcase 8:return 2;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 0;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n}\n\nvoid setCount(){\n\trep(i,16)cup[i] = _cup(i);\n\trep(i,16)cdown[i] = _cdown(i);\n}\n\nint getCountUp(int y,int x){\n\tint state = getState(y,x);\n\t\n\treturn cup[state];\n\t\n}\n\nint getCountDown(int y,int x){\n\t\n\tint state = getState(y,x);\n\t\n\treturn cdown[state];\n}\n\nint splitCount(int y,int x){\n\t\n\t\n\t\n\tint countUp = 0;\n\tint countDown = 0;\n\t\n\tdouble dy = (double)y/x;\n\tdouble dx = (double)x/y;\n\t/*\n\treps(i,1,w+1){\n        double dy = (double)y/x;\n        if(i%x==0){\n            int ny = y*(i/x);\n            int nx = i;\n            if(ny>h)break;\n             \n            int dup = getCountUp(ny,nx);\n            int ddown = getCountDown(ny,nx);\n             \n            if(x==2 && y==1 || true){\n                //printf(\"nx=%d  ny=%d,  dup=%d  ddown=%d\\n\",nx,ny,dup,ddown);\n            }\n             \n            countUp += dup;\n            countDown += ddown;\n        }\n    }\n     */\n     \n     for(int i=1;i*x<=w;i++){\n            int ny = y*i;\n            int nx = x*i;\n            if(ny>h)break;\n             \n            int dup = getCountUp(ny,nx);\n            int ddown = getCountDown(ny,nx);\n             \n             \n            countUp += dup;\n            countDown += ddown;\n    }\n\t\n\t\n\treps(i,1,w+1){\n\t\tif(i%x!=0){\n\t\t\tdouble ny = dy*i;\n\t\t\t\n\t\t\tint nh = (int)ny;\n\t\t\tif(nh>h)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[nh][i-1];\n\t\t\tchar right = board[nh][i];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\treps(i,1,h+1){\n\t\t\n\t\tif(i%y!=0){\n\t\t\t\n\t\t\tint nh = (int)(dx*i);\n\t\t\tif(nh>w)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[i-1][nh];\n\t\t\tchar right = board[i][nh];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans1 = (countUp+1)/2 + 1;\n\tint ans2 = (countDown+1)/2 + 1;\n\t\n\t//printf(\"x=%d y=%d  up=%d  down=%d\\n\",x,y,countUp, countDown);\n\t\n\treturn max(ans1, ans2);\n}\n\nvoid addBanpei(){\n\treverse(board.begin(), board.end());\n\trep(i,board.size()){\n\t\tboard[i] += \".\";\n\t}\n\tstring tmp = \"\";\n\trep(i,w+1)tmp += \".\";\n\tboard.pb(tmp);\n}\n\nvoid solve(){\n\t\n\taddBanpei();\n\tsetCount();\n\t\n\tint ans = 0;\n\treps(i,1,h+1){\n\t\treps(j,1,w+1){\n\t\t\tif(gcd(i,j)==1){\n\t\t\t\tint sp = splitCount(i,j);\n\t\t\t\tans = max(ans, sp);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <complex>\n#include <list>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <sstream>\n#include <numeric>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n// INF\n#define IINF (INT_MAX/2)\n#define INF (1<<29)\n\n// math\n#define SQ(x) ((x)*(x))\n\n// container utility\n#define ALL(x) (x).begin(), (x).end()\n#define MP make_pair\n#define PB push_back\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\n// rep\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define rep(i,n) REP(i,0,n)\n\n// typedef\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\n\ntypedef long long ll;\n\n// conversion\ntemplate<class T> inline string toStr(T a) { ostringstream oss; oss << a; return oss.str(); }\ninline int toInt(string s) { return atoi(s.c_str()); }\n\n// prime\nbool isPrime(int a) { for(int i=2; i*i <=a; i++) if(a%i == 0) return false; return true; }\n\n// dx, dy\nint const dx[] = {-1,0,1,0,-1,1,1,-1};\nint const dy[] = {0,-1,0,1,-1,-1,1,1};\n\n// inRange\ninline bool inRange(int x, int y, int W, int H) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\n// isPalindrome\ninline bool isPalindrome(string s) {\n  return equal(s.begin(), s.end(), s.rbegin());\n}\n\nint check(char grid[2][2]) {\n  if(grid[0][0] == '#'\n     && grid[0][1] == '.'\n     && grid[1][0] == '.'\n     && grid[1][1] == '.') {\n    return +1;\n  }\n  \n  if(grid[0][0] == '.'\n     && grid[0][1] == '#'\n     && grid[1][0] == '#'\n     && grid[1][1] == '#'\n  ) {\n    return +1;\n  }\n  \n  if(grid[0][0] == '#'\n     && grid[0][1] == '#'\n     && grid[1][0] == '#'\n     && grid[1][1] == '.'\n  ) {\n    return -1;\n  }\n\n  if(grid[0][0] == '.'\n     && grid[0][1] == '.'\n     && grid[1][0] == '.'\n     && grid[1][1] == '#'\n  ) {\n    return -1;\n  }\n  \n  return 0;\n}\n\nint main() {\n  \n  int H, W;\n  while(cin >> H >> W) {\n    H+=2, W+=2;\n    vector<vector<char>> G(H, vector<char>(W, '.'));\n    REP(i, 1, H-1) {\n      REP(j, 1, W-1) {\n        cin >> G[i][j];\n      }\n    }\n    \n    vector<pair<double, int>> event;\n    \n    // rep(i, H) {rep(j, W) {cout << G[i][j];}cout << endl;}\n    \n    rep(i, H-1) {\n      rep(j, W-1) {\n        \n        char grid[2][2];\n        grid[0][0] = G[i][j];\n        grid[0][1] = G[i][j+1];\n        grid[1][0] = G[i+1][j];\n        grid[1][1] = G[i+1][j+1];\n        \n        int num = check(grid);\n        if(num!=0) {\n          double ang = atan2((H-2)-i, j);\n          event.PB(MP(atan2((H-2)-i, j), num));\n        }\n        \n      }\n    }\n    \n    sort(ALL(event));\n    \n    int mx = 1;\n    int cnt = 0;\n    for(auto e : event) {\n      cnt += e.second;\n      mx = max(mx, cnt);\n    }\n    cout << mx+1 << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) begin(V), end(V)\n#define ALLR(V) rbegin(V), rend(V)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n\nusing Frac = PLL;\n\nFrac about_f(const Frac &p) {\n    ll a, b;\n    tie(a, b) = p;\n    ll g = gcd(a, b);\n    a /= g;\n    b /= g;\n    return Frac(a, b);\n}\n\nFrac make_f(ll a, ll b) { return about_f(Frac(a, b)); }\n\nstruct FracID {\n    V<Frac> id_v;\n\n    FracID(ll X, ll Y) {\n        for (ll x = 1; x <= X; x++) for (ll y = 1; y <= Y; y++) {\n            Frac f = make_f(y, x);\n            id_v.push_back(f);\n        }\n        sort(ALL(id_v), [&](const Frac &p, const Frac &q) { return comp(p, q); });\n        auto ite = unique(ALL(id_v));\n        id_v.erase(ite, id_v.end());\n    }\n\n    bool comp(const Frac &p, const Frac &q) {\n        ll a, b, c, d;\n        tie(a, b) = p;\n        tie(c, d) = q;\n        // a/b < c/d\n        return a * d < b * c;\n    }\n\n    ll get_id(const Frac &f) {\n        ll a, b;\n        tie(a, b) = f;\n        if (!a) return 0;\n        if (!b) return id_v.size() + 2;\n        auto ite = lower_bound(ALL(id_v), f, [&](const Frac &p, const Frac &q) { return comp(p, q); });\n        DEBUG(make_tuple(f, *ite));\n        return distance(id_v.begin(), ite) + 1;\n    }\n\n    ll get_id(ll a, ll b) {\n        Frac f = make_f(a, b);\n        DEBUG(f);\n        return get_id(f);\n    }\n};\n\nint main() {\n    ll Y, X;\n    cin >> Y >> X;\n    auto grid = make_v<bool>(0, X, Y);\n    {\n        V<string> vs(Y);\n        for (auto &&s : vs) cin >> s;\n        for (ll x = 0; x < X; x++) for (ll y = 0; y < Y; y++) grid[x][y] = (vs[Y - y - 1][x] == '#');\n    }\n    FracID fid(X, Y);\n    V<ll> imos(2 * (fid.id_v.size() + 1) + 10);\n    imos[0]++;\n\n    auto fix_id = [&](ll fid) { return fid * 2; };\n\n    auto add_imos = [&](ll x1, ll y1, ll x2, ll y2) {\n        if (x1 == y1 && x2 == y2) return;\n        auto fid1 = fid.get_id(y1, x1);\n        auto fid2 = fid.get_id(y2, x2);\n        DEBUG(make_tuple(x1, y1, x2, y2));\n        if (fid2 < fid1) swap(fid1, fid2);\n        DEBUG(make_tuple(fix_id(fid1), fix_id(fid2)));\n        imos[fix_id(fid1) + 1]++;\n        imos[fix_id(fid2)]--;\n    };\n    \n    for (ll x = 0; x < X; x++) for (ll y = 1; y <= Y; y++) {\n        bool down = grid[x][y - 1];\n        bool up = (y < Y && grid[x][y]);\n        if (!(up ^ down)) continue;\n        add_imos(x, y, x + 1, y);\n    }\n    for (ll x = 1; x <= X; x++) for (ll y = 0; y < Y; y++) {\n        bool left = grid[x - 1][y];\n        bool right = (x < X && grid[x][y]);\n        if (!(left ^ right)) continue;\n        add_imos(x, y, x, y + 1);\n    }\n\n    DEBUG(imos);\n    for (ll i = 0; i + 1 < imos.size(); i++) imos[i + 1] += imos[i];\n    DEBUG(imos);\n    ll maxv = 0;\n    for (ll i = 0; i < imos.size(); i++) chmax(maxv, imos[i]);\n    DEBUG(maxv);\n    cout << 1 + maxv / 2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<D,int> pdi;\n\n/*\nbool dcmp(const pdi &a, const pdi &b){\n  if( abs(a.first-b.first)<1e-8 )return a.second<b.second;\n  return a.first<b.first;\n}\n*/\n\nint main(){\n  int h,w;\n  string f[999];\n  cin >> h >> w;\n\n  vector<pdi> v;\n  rep(i,h){\n    cin >> f[i];\n    rep(j,w){\n      if( (i==0&&f[i][j]=='#') || (i!=0&&f[i][j]!=f[i-1][j]) ){\n\tv.push_back(pdi(arg(P(j,h-i)),-1));\n\tv.push_back(pdi(arg(P(j+1,h-i)),1));\n      }\n      if( (j==w-1&&f[i][j]=='#') || (j!=w-1&&f[i][j]!=f[i][j+1])){\n\tv.push_back(pdi(arg(P(j+1,h-i)),-1));\n\tv.push_back(pdi(arg(P(j+1,h-i-1)),1));\n      }\n    }\n  }\n\n  int maxv = 0, tmp = 0;\n  sort(v.begin(),v.end());\n  //sort(v.begin(),v.end(),dcmp);\n  rep(i,v.size()){\n    tmp += v[i].second;\n    maxv = max(maxv,tmp);\n  }\n  cout << (maxv+3)/2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <complex>\n#include <list>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <sstream>\n#include <numeric>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n// INF\n#define IINF (INT_MAX/2)\n#define INF (1<<29)\n\n// math\n#define SQ(x) ((x)*(x))\n\n// container utility\n#define ALL(x) (x).begin(), (x).end()\n#define MP make_pair\n#define PB push_back\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\n// rep\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define rep(i,n) REP(i,0,n)\n\n// typedef\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\n\ntypedef long long ll;\n\n// conversion\ntemplate<class T> inline string toStr(T a) { ostringstream oss; oss << a; return oss.str(); }\ninline int toInt(string s) { return atoi(s.c_str()); }\n\n// prime\nbool isPrime(int a) { for(int i=2; i*i <=a; i++) if(a%i == 0) return false; return true; }\n\n// dx, dy\nint const dx[] = {-1,0,1,0,-1,1,1,-1};\nint const dy[] = {0,-1,0,1,-1,-1,1,1};\n\n// inRange\ninline bool inRange(int x, int y, int W, int H) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\n// isPalindrome\ninline bool isPalindrome(string s) {\n  return equal(s.begin(), s.end(), s.rbegin());\n}\n\nint check(char grid[2][2]) {\n  if(grid[0][0] == '#'\n     && grid[0][1] == '.'\n     && grid[1][0] == '.'\n     && grid[1][1] == '.') {\n    return +1;\n  }\n  \n  if(grid[0][0] == '.'\n     && grid[0][1] == '#'\n     && grid[1][0] == '#'\n     && grid[1][1] == '#'\n  ) {\n    return +1;\n  }\n  \n  if(grid[0][0] == '#'\n     && grid[0][1] == '#'\n     && grid[1][0] == '#'\n     && grid[1][1] == '.'\n  ) {\n    return -1;\n  }\n\n  if(grid[0][0] == '.'\n     && grid[0][1] == '.'\n     && grid[1][0] == '.'\n     && grid[1][1] == '#'\n  ) {\n    return -1;\n  }\n  \n  return 0;\n}\n\nint main() {\n  \n  int H, W;\n  while(cin >> H >> W) {\n    H+=2, W+=2;\n    vector<vector<char>> G(H, vector<char>(W, '.'));\n    REP(i, 1, H-1) {\n      REP(j, 1, W-1) {\n        cin >> G[i][j];\n      }\n    }\n    \n    vector<pair<double, int>> event;\n    \n    // rep(i, H) {rep(j, W) {cout << G[i][j];}cout << endl;}\n    \n    rep(i, H-1) {\n      rep(j, W-1) {\n        \n        char grid[2][2];\n        grid[0][0] = G[i][j];\n        grid[0][1] = G[i][j+1];\n        grid[1][0] = G[i+1][j];\n        grid[1][1] = G[i+1][j+1];\n        \n        int num = check(grid);\n        if(num!=0) {\n          double ang = atan2((H-2)-i, j);\n          event.PB(MP(atan2((H-2)-i, j), num));\n        }\n        \n      }\n    }\n    \n    sort(ALL(event));\n    \n    int mx = 1;\n    int cnt = 0;\n    for(auto e : event) {\n      cnt += e.second;\n      mx = max(mx, cnt);\n    }\n    cout << mx+1 << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define uniq(xs) ((xs).erase(unique((xs).begin(), (xs).end()), (xs).end()))\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    const double EPS = 1e-8;\n\n    bool EQ(double x, double y) { return abs(x - y) < EPS; }\n\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(double k) const { return Point(k * x, k * y); }\n        Point operator/(double k) const { return Point(x / k, y / k); }\n        bool operator==(const Point& p) { return EQ(x, p.x) && EQ(y, p.y); }\n        bool operator<(const Point& p) { return EQ(x, p.x) ? y < p.y : x < p.x; }\n    };\n    double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    double norm(const Point& a) { return sqrt(dot(a, a)); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n    int ccw(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n        if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n        if (dot(b, c) < 0) return +2;          // c--a--b 直線\n        if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n        return 0;                              // a--c--b 直線\n    }\n\n    struct Segment {\n        Point a, b;\n        Segment() {}\n        Segment(const Point& a, const Point& b) : a(a), b(b) {}\n    };\n    bool intersects(const Segment& s, const Segment& t) {\n        return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    }\n    ostream& operator<<(ostream& os, const Segment& s) {\n        return os << \"Segment(\" << s.a << \",\" << s.b << \")\";\n    }\n\n    Point crosspoint(const Segment& s, const Segment& t) {\n        assert(intersects(s, t));\n        double d = cross(t.b - t.a, s.b - s.a);\n        assert(abs(d) >= EPS);\n        return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n    }\n\n    int H, W;\n    vector<string> F;\n    void input() {\n        cin >> H >> W;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) {\n            cin >> F[i];\n        }\n        reverse(F.begin(), F.end());\n    }\n\n    int count(const vector<Segment>& L, const Segment& s) {\n        vector<Point> cs;\n        for (int i = 0; i < L.size(); i++) {\n            const Segment& t = L[i];\n            if (intersects(s, t)) {\n                cs.push_back(crosspoint(s, t));\n            }\n        }\n        sort(cs.begin(), cs.end());\n        uniq(cs);\n        //cout << s << \" \" << cs << endl;\n        return int(cs.size());\n    }\n\n    const int dy[] = {1, 0}, dx[] = {0, 1};\n    void solve() {\n        vector<Segment> L;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                int y = i, x = j;\n                for (int k = 0; k < 2; k++) {\n                    int ny = y + dy[k],\n                        nx = x + dx[k];\n                    if (ny >= H || nx >= W) {\n                        if (F[y][x] == '#') {\n                            if (x == nx) {\n                                L.push_back(Segment(Point(nx, ny), Point(nx + 1, ny)));\n                            } else if (y == ny) {\n                                L.push_back(Segment(Point(nx, ny), Point(nx, ny + 1)));\n                            }\n                        }\n                        continue;\n                    }\n                    if ( (F[y][x] == '#' && (ny >= H || nx >= W)) || (F[ny][nx] != F[y][x]) ) {\n                        if (x == nx) {\n                            L.push_back(Segment(Point(nx, ny), Point(nx + 1, ny)));\n                        } else if (y == ny) {\n                            L.push_back(Segment(Point(nx, ny), Point(nx, ny + 1)));\n                        }\n                        continue;\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < H; i++) {\n            double x = double(W);\n            for (int k = 0; k < 10; k++) {\n                double y = double(i) + k * 0.1 + 1.0 / 991;\n                ans = max(ans, count(L, Segment(Point(0, 0), Point(x, y))));\n            }\n        }\n        for (int j = 0; j < W; j++) {\n            double y = double(H);\n            for (int k = 0; k < 10; k++) {\n                double x = double(j) + k * 0.1 + 1.0 / 991;\n                ans = max(ans, count(L, Segment(Point(0, 0), Point(x, y))));\n            }\n        }\n        cout << 1 + (ans + 1) / 2 << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nchar ptn[4][2][2] = {\n  {\n    {'.','#'},\n    {'.','.'}\n  },\n  {\n    {'#','.'},\n    {'#','#'}\n  },\n  {\n    {'.','.'},\n    {'#','.'}\n  },\n  {\n    {'#','#'},\n    {'.','#'}\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int H, W;\n  cin >> H >> W;\n  H += 2, W += 2;\n  char f[666][666];\n  rep(i, H) rep(j, W) f[i][j] = '.';\n  reps(i, 1, H-1) reps(j, 1, W-1) cin >> f[H-1-i][j];\n\n  vector< pair<double, int> > vec;\n  rep(i, H-1) rep(j, W-1) {\n    rep(k, 4) {\n      bool flag = true;\n      rep(y, 2) rep(x, 2) flag &= (f[i+y][j+x] == ptn[k][y][x]);\n      if(flag) {\n\trep(y, 2) {\n\t  rep(x, 2) cout << ptn[k][1-y][x];\n\t  cout << endl;\n\t}\n\tvec.emplace_back(atan2(i, j), (k < 2 ? -1 : 1));\n\tbreak;\n      }\n    }\n  }\n\n  sort(all(vec));\n  \n  int ans = 2, div = 1;\n  for(auto p : vec) {\n    div += p.second;\n    ans = max(ans, div);\n  }\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <iostream>\n\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n//typedef tuple<int, int, int> T;\ntypedef pair<ll, ll> Pl;\n//typedef tuple<ll, ll, ll> Tl;\n\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\n\n\nnamespace Ps{\n\tconst double EPS=1e-8,INF=1e12;\n#define X real()\n#define Y imag()\n\ttypedef complex<double> P;\n}\nusing namespace Ps;\nnamespace Ls{\n\tstruct L:public vector<P>{\n\t\tL(const P&a,const P&b){\n\t\t\tpush_back(a);push_back(b);\n\t\t}\n\t};\n}\nusing namespace Ls;\n\n\nclass Seg{\npublic:\n\tdouble l,r;\n\tSeg(double l,double r):l(l),r(r){\n\t}\n\n\tbool operator < (const Seg& rt) const{\n\t\treturn l<rt.l;\n\t}\n};\n\nint main() {\n\tint H,W;cin >> H >> W;\n\tvector<string> board(H+2);\n\t\n\t{\n\t\tstringstream ss;string s;\n\t\tfor(int x=0;x<W+1;x++)ss<<\".\";\n\t\tss>> s;\n\tboard[0]=s;\n\tboard[H+1]=s;\n\n\t}\n\tfor(int y=1;y<=H;y++){\n\t\tstringstream ss;string s;\n\t\tss<<\".\";\n\t\tcin >> s;\n\t\tss<< s;\n\t\tss<<\".\";\n\t\tboard[y]=ss.str();\n\t}\n\n\n\tvector<L> ls;\n\n\t// -\n\tfor(int y=0;y<=H;y++){\n\t\tint x=1;\n\t\tfor(;x<=W;x++){\n\t\t\tif(board[y][x]=='.' && board[y+1][x]=='#'){\n\t\t\t\tP p1(H-y,x-1);\n\t\t\t\tx++;\n\t\t\t\twhile(board[y][x]=='.' && board[y+1][x]=='#'){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tP p2(H-y,x-1);\n\t\t\t\tls.push_back(L(p1,p2));\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tif(board[y][x]=='#' && board[y+1][x]=='.'){\n\t\t\t\tP p1(H-y,x-1);\n\t\t\t\tx++;\n\t\t\t\twhile(board[y][x]=='#' && board[y+1][x]=='.'){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tP p2(H-y,x-1);\n\t\t\t\tls.push_back(L(p1,p2));\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t}\n\n\t// |\n\tfor(int x=0;x<=W;x++){\n\t\tint y=0;\n\t\tfor(;y<=H;y++){\n\t\t\tif(board[y][x]=='.' && board[y][x+1]=='#'){\n\t\t\t\tP p1(H+1-y,x);\n\t\t\t\ty++;\n\t\t\t\twhile(board[y][x]=='.' && board[y][x+1]=='#'){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tP p2(H+1-y,x);\n\t\t\t\tls.push_back(L(p1,p2));\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tif(board[y][x]=='#' && board[y][x+1]=='.'){\n\t\t\t\tP p1(H+1-y,x);\n\t\t\t\ty++;\n\t\t\t\twhile(board[y][x]=='#' && board[y][x+1]=='.'){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tP p2(H+1-y,x);\n\t\t\t\tls.push_back(L(p1,p2));\n\t\t\t\ty--;\n\t\t\t} \n\t\t}\n\t}\n\n\t// for(int i=0;i<ls.size();i++){\n\t// \tcout << ls[i][0]<<\" \" <<ls[i][1]<<endl;\n\t// }\n\n\t// DUMP(ls.size());\n\t// //DUMP(toString())\n\n\tvector<Seg> ss;\n\tfor(int i=0;i<ls.size();i++){\n\t\tss.push_back(Seg(min(arg(ls[i][0]),arg(ls[i][1])+EPS),1));\n\t\tss.push_back(Seg(max(arg(ls[i][0]),arg(ls[i][1])-EPS),-1));\t\t\n\t} \n\tsort(ss.begin(),ss.end());\n\n\n\tint Mv=0,v=0;\n\tfor(int i=0;i<ss.size();i++){\n\t\tv+=ss[i].r;\n\t\tMv=max(Mv,v);\n\t}\n\n\tcout << (Mv/2 + 1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<double,double>D;\ntypedef pair<P,int>PP;\ntypedef pair<double,P>dP;\ntypedef pair<D,int>Di;\n\nconst int MAX_N = 602;\nconst int dx[] = {1,1,0,0};\nconst int dy[] = {0,0,1,-1};\nconst int ex[] = {1,0,1};\nconst int ey[] = {0,1,1};\n\nint a[MAX_N][MAX_N];\nint flag[MAX_N][MAX_N];\nint h,w;\nint gcd_table[MAX_N][MAX_N];\nint mp[MAX_N][MAX_N];\nvector<PP> vec;\n\nvoid dfs(int u,int v)\n{\n    flag[u][v] = 1;\n    if(u < w-1 && 0 < v && !a[u+1][v] && !a[u][v-1] && !a[u+1][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u == w-1 && 0 < v && !a[u][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u < w-1 && 0 < v && a[u+1][v] && a[u][v-1] && !a[u+1][v-1]){  //??????2\n        vec.push_back(PP(P(u+1,v),2));\n    }\n    if(0 < u && v < h-1 && !a[u-1][v] && !a[u][v+1] && !a[u-1][v+1]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v == h-1 && !a[u-1][v]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v < h-1 && a[u-1][v] && a[u][v+1] && !a[u-1][v+1]){  //??????2\n        vec.push_back(PP(P(u,v+1),3));\n    }\n    rep(i,4){\n        int nx = u + dx[i],ny = v + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && a[nx][ny] && !flag[nx][ny]){\n            dfs(nx,ny);\n        }\n    }\n    return;\n}\n\nint gcd(int a,int b)\n{\n    if(a % b == 0){\n        return b;\n    }\n    return gcd(b,a % b);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&h,&w);\n    rep(j,h){\n        string s;\n        cin >> s;\n        rep(i,s.length()){\n            flag[i][j] = 0;\n            if(s[i] == '#'){\n                a[i][h-j-1] = 1;\n            }else{\n                a[i][h-j-1] = 0;\n            }\n        }\n    }\n    for(int i = 1;i <= 600;i++){\n        for(int j = i;j <= 600;j++){\n            gcd_table[j][i] = gcd(j,i);\n        }\n    }\n    bool fl = false;\n    rep(i,w){\n        rep(j,h){\n            if(a[i][j]){\n                dfs(i,j);\n                fl = true;\n                break;\n            }\n        }\n        if(!fl){\n            break;\n        }\n    }\n    // rep(i,vec.size()){\n    //     cout << vec[i].first.first << \" \" << vec[i].first.second << \" \" << vec[i].second << \"\\n\";\n    // }\n    vector<dP> tilt;\n    rep(i,vec.size()){\n        int p1 = (vec[i].first).first;\n        int p2 = (vec[i].first).second;\n        tilt.push_back(dP((double)p2 / p1,P(i,vec[i].second)));\n    }\n    sort(all(tilt));\n    vector<PP> cand;\n    rep(i,tilt.size()){\n        int cnt[] = {0,0,0,0};\n        int id = i;\n        double n1 = tilt[i].first;\n        int n2 = (tilt[i].second).first;\n        int n3 = (tilt[i].second).second;\n        cnt[n3]++;\n        while(id + 1 < tilt.size() && abs(tilt[id].first-tilt[id+1].first) < EPS){\n            n1 = tilt[i+1].first;\n            n3 = (tilt[i+1].second).first;\n            cnt[n3]++;\n            id++;\n        }\n        int mx = max(cnt[0]+cnt[3],cnt[1]+cnt[2]);\n        i = id;\n        P p = vec[n2].first;\n        int md = gcd_table[max(p.first,p.second)][min(p.first,p.second)];\n        mp[p.first / md][p.second / md]++;\n        cand.push_back(PP(P(p.first / md,p.second / md),mx));\n    }\n    for(int i = 1;i <= w;i++){\n        for(int j = 1;j <= h;j++){\n            int md = gcd_table[max(i,j)][min(i,j)];\n            P p = P(i / md,j / md);\n            if(!mp[p.first][p.second]){\n                cand.push_back(PP(p,0));\n                mp[p.first][p.second]++;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,cand.size()){\n        vector<Di> cros;\n        P p = cand[i].first;\n        rep(j,p.first-1){\n            cros.push_back(Di(D(j+1,(double)(j+1) * p.second / p.first),0));\n        }\n        rep(j,p.second-1){\n            cros.push_back(Di(D((double)(j+1) * p.first / p.second,j+1),1));\n        }\n        sort(all(cros));\n        vector<int> act;\n        rep(j,cros.size()){\n            act.push_back(cros[j].second);\n        }\n        act.push_back(2);\n        int cnt = 0;\n        int px = 0,py = 0;\n        int bf = a[0][0];\n        int res = 0;\n        while(1){\n            px += ex[act[cnt%act.size()]];\n            py += ey[act[cnt%act.size()]];\n            if(px < w && py < h){\n                if(bf == 1 && !a[px][py]){\n                    res++;\n                }\n                bf = a[px][py];\n            }else{\n                if(bf == 1){\n                    res++;\n                }\n                break;\n            }\n            cnt++;\n        }\n        ans = max(res+cand[i].second,ans);\n    }\n    cout << ans + 1 << \"\\n\";\n    exit(0);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nstruct fraction{\n    ll num,dom;\n    fraction(){}\n    fraction(ll num,ll dom):num(num),dom(dom){\n        //assert(dom!=0);    \n        if(dom<0) num*=-1,dom*=-1;  \n        //いりそうならここでGCDとる  \n    }\n    fraction operator+(const fraction a) const{\n        return fraction(num*a.dom+a.num*dom,dom*a.dom);\n    }\n    fraction operator-(const fraction a) const{\n        return fraction(num*a.dom-a.num*dom,dom*a.dom);\n    }\n    fraction operator*(const fraction a) const{\n        return fraction(num*a.num,dom*a.dom);\n    }\n    fraction operator/(const fraction a){\n        return fraction(num*a.dom,dom*a.num);\n    }\n    fraction operator*(ll k) const{return fraction(num*k,dom);}\n    fraction operator/(ll k) const{return fraction(num,dom*k);}\n    bool operator<(const fraction a)const{\n        return num*a.dom<a.num*dom;\n    }\n    bool operator>(const fraction a)const{\n        return num*a.dom>a.num*dom;\n    }\n    bool operator==(const fraction a)const{\n        return num*a.dom==a.num*dom;\n    }\n    bool operator!=(const fraction a)const{\n        return num*a.dom!=a.num*dom;\n    }\n    bool operator<=(const fraction a)const{\n        return num*a.dom<=a.num*dom;\n    }\n    bool operator>=(const fraction a)const{\n        return num*a.dom>=a.num*dom;\n    }\n};   \nint main(){\n    int h,w;\n    cin>>h>>w;\n    string s[h+1];\n    rep(i,h){\n        cin>>s[i+1];\n        s[i+1]+='.';\n    }\n    rep(i,w+1)s[0]+='.';\n    vector<pair<fraction,fraction> > v;\n    rep(i,h)rep(j,w){\n        if(s[i+1][j]=='#'&&s[i][j]=='.'){\n            v.push_back({{h-i,j+1},{h-i,j}});\n        }\n        if(s[i+1][j]=='#'&&s[i+1][j+1]=='.'){\n            v.push_back({{h-i-1,j+1},{h-i,j+1}});\n        }\n    }\n    sort(v.begin(),v.end());\n    priority_queue<fraction,vector<fraction>,greater<fraction> > que;\n    int ans=0;\n    for(auto p : v){\n        while(que.size()&&que.top()<=p.first)que.pop();\n        que.push(p.second);\n        ans=max(ans,(int)que.size());\n    }\n    cout<<ans+1<<endl;\n    return 0;\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll solve(){\n    ll H,W; cin >> H >> W;\n    ll res = 1;\n    vector<vector<char>> masu(H+2,vector<char>(W+2,'.'));\n    vector<pair<double,int>> event;\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            cin >> masu[i][j];\n        }\n    }\n    \n    vector<vector<pii>> masu2(H+2,vector<pii>(W+2));\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            masu2[i][j] = {j-1,H-i};\n        }\n    }\n\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            if(masu[i][j] == '#'){\n                \n                double angle = 0;\n                // increment pattern\n                //  ..\n                //  .#\n                if(masu[i-1][j-1] == '.' && masu[i-1][j] == '.' && masu[i][j-1] == '.'){\n                    angle = atan2(masu2[i][j].second+1,masu2[i][j].first);\n                    event.push_back({angle,-1});\n                }\n                \n                // increment pattern\n                //  ##\n                //  #.\n                if(masu[i+1][j+1] == '.' && masu[i+1][j] == '#' && masu[i][j+1] == '#'){\n                    angle = atan2(masu2[i][j].second,masu2[i][j].first+1);\n                    event.push_back({angle,-1});\n                }\n                \n                // decrement pattern\n                //  .#\n                //  ##\n                if(masu[i-1][j-1] == '.' && masu[i-1][j] == '#' && masu[i][j-1] == '#'){\n                    angle = atan2(masu2[i][j].second+1,masu2[i][j].first);\n                    event.push_back({angle,1});\n                }\n                \n                // decrement pattern\n                //  #.\n                //  ..\n                if(masu[i+1][j+1] == '.' && masu[i+1][j] == '.' && masu[i][j+1] == '.'){\n                    angle = atan2(masu2[i][j].second,masu2[i][j].first+1);\n                    event.push_back({angle,1});\n                }\n            }\n        }\n    }\n    \n    sort(event.begin(),event.end());\n    \n    ll cnt = 1;\n    for(auto it = event.rbegin(); it != event.rend(); it++){\n        auto e = *it;\n        cnt -= e.second;\n        res = max(res,cnt);\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nbool comp2(pair<pair<int,int>,int>a,pair<pair<int,int>,int>b){\n    int x = a.first.first;\n    int y = a.first.second;\n    int w = b.first.first;\n    int z = b.first.second;\n    y--;z--;\n    if(x*z==y*w){\n        return 1;\n    }\n    if(x*z>y*w){\n        return 0;\n    }\n    if(x*z<y*w){\n        return 0;\n    }\n}\n\nbool comp(pair<pair<int,int>,int>a,pair<pair<int,int>,int>b){\n    int x = a.first.first;\n    int y = a.first.second;\n    int w = b.first.first;\n    int z = b.first.second;\n    y--;z--;\n    if(x*z==y*w){\n        return 0;\n    }\n    if(x*z>y*w){\n        return 1;\n    }\n    if(x*z<y*w){\n        return 0;\n    }\n}\n\nint main(){\n    int h,w;\n    cin >> h >> w;\n    vector<string>v(h);\n    rep(i,h)cin >> v[h-i-1];\n    rep(i,h)v[i].push_back('.');\n    rep(i,h)v[i] = \".\"+v[i];\n    string ssss;\n    rep(i,w+2)ssss.push_back('.');\n    v.push_back(ssss);\n    vector<pair<pair<int,int>,int> > p;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(v[i][j]=='#'&&v[i][j+1]=='#'&&v[i+1][j]=='.'&&v[i+1][j+1]=='#'){\n                p.push_back(make_pair(make_pair(i+1,j+1),-1));\n            }\n            if(v[i][j]=='.'&&v[i][j+1]=='.'&&v[i+1][j]=='#'&&v[i+1][j+1]=='.'){\n                p.push_back(make_pair(make_pair(i+1,j+1),-1));\n            }\n            if(v[i][j]=='#'&&v[i][j+1]=='.'&&v[i+1][j]=='#'&&v[i+1][j+1]=='#'){\n                p.push_back(make_pair(make_pair(i+1,j+1),1));\n            }\n            if(v[i][j]=='.'&&v[i][j+1]=='#'&&v[i+1][j]=='.'&&v[i+1][j+1]=='.'){\n                p.push_back(make_pair(make_pair(i+1,j+1),1));\n            }\n        }\n    }\n    sort(p.begin(),p.end(),comp);\n    int mx = 2;\n    int cnt = 1;\n    // rep(i,h+1){\n    //     rep(j,w+2){\n    //         cout << v[i][j];\n    //     }\n    //     cout <<endl;\n    // }\n    for(int i=0;i<p.size();i++){\n        //cout << p[i].first.first << \" \" << p[i].first.second << \" \" << p[i].second << \" \" << cnt<< endl;\n        if(i==p.size()-1){\n            cnt += p[i].second;\n            mx = max(mx,cnt);\n        }else{\n            if(!comp2(p[i],p[i+1])){\n                cnt += p[i].second;\n                mx = max(mx,cnt);\n            }else{\n                cnt += p[i].second;\n            }\n        }\n    }\n    cout << mx << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1);\nint sig(double r){return (r<-EPS)?-1:(r>+EPS)?+1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y): x(x),y(y){}\n\tPt operator+(const Pt&a)const {return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt&a)const {return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt&a)const {return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt&a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt&a)const{return x*a.y-y*a.x;}\n};\ninline Pt pLL(Pt a,Pt b,Pt c,Pt d){\n\tb=b-a;d=d-c;return a+b*(c-a).det(d)/b.det(d);\n}\nchar str[700][700];\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;\n\t\tint c=b;\n\t\tb=a;\n\t\ta=c;\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[a-1-i]);\n\tint ret=0;\n\t\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(gcd(i+1,j+1)>1)continue;\n\t\t\tint val=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,(1e-8)+j+1),Pt(k+1,0),Pt(k+1,1));\n\t\t\t\tint d=(int)(t.y);\n\t\t\t\tif(d>=b)continue;\n\t\t\t\tif(str[k][d]=='#'&&str[k+1][d]!='#')val++;\n\t\t\t\tif(str[k][d]!='#'&&str[k+1][d]=='#')val++;\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,(1e-8)+j+1),Pt(0,k+1),Pt(1,k+1));\n\t\t\t\tint d=(int)(t.x);\n\t\t\t\tif(d>=a)continue;\n\t\t\t\tif(str[d][k]=='#'&&str[d][k+1]!='#')val++;\n\t\t\t\tif(str[d][k]!='#'&&str[d][k+1]=='#')val++;\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t\tval=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,-(1e-8)+j+1),Pt(k+1,0),Pt(k+1,1));\n\t\t\t\tint d=(int)(t.y);\n\t\t\t\tif(d>=b)continue;\n\t\t\t\tif(str[k][d]=='#'&&str[k+1][d]!='#')val++;\n\t\t\t\tif(str[k][d]!='#'&&str[k+1][d]=='#')val++;\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tPt t=pLL(Pt(0,0),Pt(i+1,-(1e-8)+j+1),Pt(0,k+1),Pt(1,k+1));\n\t\t\t\tint d=(int)(t.x);\n\t\t\t\tif(d>=a)continue;\n\t\t\t\tif(str[d][k]=='#'&&str[d][k+1]!='#')val++;\n\t\t\t\tif(str[d][k]!='#'&&str[d][k+1]=='#')val++;\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t}\n\t}\n\tif(str[0][0]=='#')ret++;\n\tprintf(\"%d\\n\",1+ret/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double mEPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nclass Point{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a*x, a*y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\t//EPS??????????°??????????\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n\t}\n\n  friend ostream& operator<<(ostream& os, const Point& p);\n\n};\nostream& operator<<(ostream& os, const Point& p){\n  os << \"(\" << p.x << \",\" << p.y << \")\";\n  return os;\n}\n  \nclass Segment{\npublic:\n\tPoint p1, p2;\n};\n\n\ntypedef vector<Point> Polygon;\n\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\n\n//??????\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//???????????§??????\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > mEPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -mEPS) return CLOCKWISE;\n\tif (dot(a, b) < -mEPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn(ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; cin >> H >> W;\n  VS str(H); REP(i,H) cin >> str[i];\n  reverse(ALL(str));\n  vector<Segment> ls;\n  REP(y,H) REP(x,W){\n\tif(str[y][x] == '#' && (y == 0 || str[y-1][x] == '.')){\n\t  int t = x;\n\t  for(;t<W;++t)\n\t\tif(str[y][t] == '.' || (y > 0 && str[y-1][t] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y;\n\t  p2.x = t, p2.y = y;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  x = t;\n\t}\n  }\n  REP(y,H) REP(x,W){\n\tif(str[y][x] == '#' && (y == H-1 || str[y+1][x] == '.')){\n\t  int t = x;\n\t  for(;t<W;++t)\n\t\tif(str[y][t] == '.' || (y < H-1 && str[y+1][t] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y+1;\n\t  p2.x = t, p2.y = y+1;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  x = t;\n\t}\n  }\n  REP(x,W) REP(y,H){\n\tif(str[y][x] == '#' && (x == 0 || str[y][x-1] == '.')){\n\t  int t = y;\n\t  for(;t<H;++t)\n\t\tif(str[t][x] == '.' || (x > 0 && str[t][x-1] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y;\n\t  p2.x = x, p2.y = t;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  y = t;\n\t}\n  }\n  REP(x,W) REP(y,H){\n\tif(str[y][x] == '#' && (x == W-1 || str[y][x+1] == '.')){\n\t  int t = y;\n\t  for(;t<H;++t)\n\t\tif(str[t][x] == '.' || (x < W-1 && str[t][x+1] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x+1; p1.y = y;\n\t  p2.x = x+1, p2.y = t;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  y = t;\n\t}\n  }\n\n  vector<tuple<int,int,Point>> memo;\n  REP(i,SZ(ls)) FOR(j,i+1,SZ(ls))\n\tif(intersect(ls[i], ls[j])){\n\t  if(ls[i].p1 == ls[j].p1 || ls[i].p1 == ls[j].p2)\n\t\tmemo.PB(MT(i,j,ls[i].p1));\n\t  else\n\t\tmemo.PB(MT(i,j,ls[i].p2));\n\t}\n\n  int ans = 1;\n  for(double th=0.;th<PI/2;th+=0.01){\n\tSegment s;\n\ts.p1.x = 0, s.p1.y = 0;\n\ts.p2.x = 1000. * cos(th), s.p2.y = 1000. * sin(th);\n\tvector<bool> cr(SZ(ls));\n\tREP(i,SZ(ls)) cr[i] = intersect(s, ls[i]);\n\tint c = count(ALL(cr), true);\n\tfor(auto& pp: memo){\n\t  if(cr[get<0>(pp)] && cr[get<1>(pp)] && !ccw(s.p1, s.p2, get<2>(pp)))\n\t\t--c;\n\t}\n\tans = max(ans, c/2+1);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n//constant\n//--------------------------------------------\nconst double mEPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint f(VS& vs, int x, int y){\n  string str = vs[y].substr(x,1) + vs[y].substr(x+1,1)\n\t+ vs[y+1].substr(x,1) + vs[y+1].substr(x+1,1);\n  if(str == \"..#.\" || str == \"##.#\") return 1;\n  if(str == \".#..\" || str == \"#.##\") return -1;\n  return 0;\n}\n\nint main(){\n  int H, W; cin >> H >> W;\n  VS vs(H+2, string(W+2, '.'));\n  REP(i,H){\n\tstring s;\n\tcin >> s;\n\tvs[i+1] = \".\" + s + \".\";\n  }\n  reverse(ALL(vs));\n\n  vector<pair<double,int>> ev;\n  FOR(y,0,H+1) FOR(x,0,W+1){\n\tint n = f(vs, x, y);\n\tif(n) ev.PB(MP(atan2(y,x),n));\n  }\n  SORT(ev);\n  int ans = 2, tmp = 1;\n  for(auto& e: ev)\n\tans = max(ans, tmp += e.second);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct PQ {\n\tint den, num;\n\tPQ(int den, int num) : den(den), num(num) {}\n};\nbool operator>(const PQ& pq1, const PQ& pq2) {\n\treturn pq1.num * pq2.den > pq1.den * pq2.num;\n}\nbool operator<(const PQ& pq1, const PQ& pq2) {\n\treturn pq2 > pq1;\n}\nbool operator==(const PQ& pq1, const PQ& pq2) {\n\treturn !(pq1 > pq2) && !(pq2 > pq1);\n}\nbool operator>=(const PQ& pq1, const PQ& pq2) {\n\treturn pq1 == pq2 || pq1 > pq2;\n}\nbool operator<=(const PQ& pq1, const PQ& pq2) {\n\treturn pq2 >= pq1;\n}\n\ntypedef pair<PQ, PQ> PQP;\n\nint H, W;\nvector<string> M;\nbool dot[601][601] = {0};\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nbool inRange2(int x, int y) {\n\treturn 0 <= x && x <= W && 0 <= y && y <= H;\n}\nbool isWall(int x, int y) {\n\tif ( !inRange(x, y) ) return false;\n\treturn M[y][x] == '#';\n}\nbool getDot(int x, int y) {\n\tif ( !inRange2(x, y) ) return false;\n\treturn dot[y][x];\n}\nbool moveCheck(int x1, int y1, int x2, int y2) {\n\tif ( !getDot(x2, y2) ) return false;\n\tmap<P, int> cnt;\n\tfor (int dy = -1; dy <= 0; ++dy) {\n\t\tfor (int dx = -1; dx <= 0; ++dx) {\n\t\t\tcnt[P(x1+dx, y1+dy)]++;\n\t\t\tcnt[P(x2+dx, y2+dy)]++;\n\t\t}\n\t}\n\tset<bool> s;\n\tfor ( pair<const P, int>& p : cnt ) {\n\t\tif (p.second == 2 ) {\n\t\t\ts.insert(isWall(p.first.first, p.first.second));\n\t\t}\n\t}\n\treturn s.size() == 2;\n}\nint moveX(int x0, int y0) {\n\tbool bfl = true, bfr = true;\n\tbool fl = true, fr = true;\n\tfor (int dx = 1; dx <= W+3; ++dx) {\n\t\tfr = fr && moveCheck(x0+dx-1, y0, x0+dx, y0);\n\t\tfl = fl && moveCheck(x0-(dx-1), y0, x0-dx, y0);\n\t\tif ( !fr && !fl ) {\n\t\t\tif (bfl) return x0-(dx-1);\n\t\t\treturn x0+dx-1;\n\t\t}\n\t\tbfl = fl, bfr = fr;\n\t}\n}\nint moveY(int x0, int y0) {\n\tbool bfl = true, bfr = true;\n\tbool fl = true, fr = true;\n\tfor (int dy = 1; dy <= H+3; ++dy) {\n\t\tfr = fr && moveCheck(x0, y0+(dy-1), x0, y0+dy);\n\t\tfl = fl && moveCheck(x0, y0-(dy-1), x0, y0-dy);\n\t\tif ( !fr && !fl ) {\n\t\t\tif (bfl) return y0-(dy-1);\n\t\t\treturn y0+dy-1;\n\t\t}\n\t\tbfl = fl, bfr = fr;\n\t}\n}\n\nPQ f(int x, int y) {\n\treturn PQ(y, x);\n}\n\nvector<PQP> r;\nvoid addLine(int x1, int y1, int x2, int y2) {\n\tPQ pq1 = f(x1, y1);\n\tPQ pq2 = f(x2, y2);\n\tif (pq2 < pq1) swap(pq1, pq2);\n\tr.push_back( PQP(pq1, pq2) );\n}\nint main() {\n\tcin >> H >> W;\n\tM.resize(H);\n\tfor (int i = 0; i < H; ++i) cin >> M[i];\n\tfor (int y = 0; y <= H; ++y) {\n\t\tfor (int x = 0; x <= W; ++x) {\n\t\t\tset<bool> s;\n\t\t\tfor (int dx = -1; dx <= 0; ++dx) {\n\t\t\t\tfor (int dy = -1; dy <= 0; ++dy) {\n\t\t\t\t\ts.insert( isWall(x+dx, y+dy) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tdot[y][x] = s.size() == 2;\n\t\t}\n\t}\n\tint sx = -1, sy = -1;\n\tfor (int y = 0; y < H; ++y) {\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tif ( isWall(x, y) ) {\n\t\t\t\tsx = x, sy = y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sx >= 0) break;\n\t}\n\t{\n\t\tint x = sx, y = sy;\n\t\twhile (1) {\n\t\t\tint nx = moveX(x, y);\n\t\t\tint ny = moveY(nx, y);\n//\t\t\tassert(nx != x);\n//\t\t\tassert(ny != y);\n\t\t\taddLine(x, y, nx, y);\n\t\t\taddLine(nx, y, nx, ny);\n\t\t\tif (nx == sx && ny == sy) break;\n\t\t\tx = nx, y = ny;\n\t\t}\n\t\tsort(r.begin(), r.end());\n\t\tint mx = 0;\n\t\tmap<PQ, int> m;\n\t\t{\n\t\t\tvector<PQ> v;\n\t\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\t\tv.push_back(r[i].first);\n\t\t\t\tv.push_back(r[i].second);\n\t\t\t}\n\t\t\tsort(v.begin(), v.end());\n\t\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\t\tm[v[i]] = i;\n\t\t\t}\n\t\t\tmx = v.size();\n\t\t}\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\tv.push_back( P(m[r[i].first], m[r[i].second]) );\n\t\t}\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t//\t\tcout << v[i].first << \" \" << v[i].second << endl;\n\t\t}\n\t\tvector<int> cnt(mx*2+3, 0);\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\t++cnt[v[i].first*2+1];\n\t\t\t--cnt[v[i].second*2];\n\t\t}\n\t\tfor (int i = 0; i+1 < cnt.size(); ++i) {\n\t\t\tcnt[i+1] += cnt[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < cnt.size(); ++i) {\n\t\t\tans = max(ans, cnt[i]);\n\t\t}\n\t\tcout << ans/2+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint H,W;\nchar F[610][610];\nint main(){\n    cin >> H >> W;\n    for(int i=0;i<=H+1;i++) for(int j=0;j<=W+1;j++) F[i][j] = '.';\n    for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) cin >> F[i][j];\n    vector<pair<double,int>> v;\n    for(int i=0;i<=H;i++){\n        for(int j=0;j<=W;j++){\n            double arg = atan2(H-i,j);\n            if(F[i][j]=='#' && F[i+1][j]=='.' && F[i][j+1]=='.' && F[i+1][j+1]=='.') v.push_back({arg,1});\n            if(F[i][j]=='.' && F[i+1][j]=='#' && F[i][j+1]=='#' && F[i+1][j+1]=='#') v.push_back({arg,1});\n            if(F[i][j]=='.' && F[i+1][j]=='.' && F[i][j+1]=='.' && F[i+1][j+1]=='#') v.push_back({arg,-1});\n            if(F[i][j]=='#' && F[i+1][j]=='#' && F[i][j+1]=='#' && F[i+1][j+1]=='.') v.push_back({arg,-1});\n        }\n    }\n    sort(v.begin(),v.end());\n    int now = 1,ans = 0;\n    for(auto x:v){\n        now += x.second;\n        ans = max(ans,now);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n  int H, W;\n  cin >> H >> W;\n  string F[H];\n  for(int i = 0; i < H; ++i){\n    cin >> F[i];\n  }\n  int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n  pair<pii,pii> e[4];\n  e[0] = make_pair(pii(1,0),pii(1,1));\n  e[1] = make_pair(pii(0,1),pii(1,1));\n  e[2] = make_pair(pii(0,0),pii(0,1));\n  e[3] = make_pair(pii(0,0),pii(1,0));\n  vector< pair<double,int> > A;//\"#\"テ」ツ?ョテヲツ閉ーテ」ツつ誰テ」ツ?ィテ」ツ?凖」ツつ凝」ツ?ィ2*N+2テ」ツ?静」ツつ嘉」ツ??」ツ?ョティツヲツ?ァツエツ?ヲツ閉ー\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(F[i][j] == '#'){\n\tfor(int k = 0; k < 4; ++k){\n\t  if(i+dx[k] < 0 || j+dy[k] < 0 || i+dx[k] > H-1 || j+dy[k] > W-1 || F[i+dx[k]][j+dy[k]] != '#'){\n\t    pii s = pii(H-i-e[k].first.first, j+e[k].first.second);\n\t    pii t = pii(H-i-e[k].second.first, j+e[k].second.second);\n\t    //printf(\"(%d, %d), (%d, %d)\\n\",s.first,s.second,t.first,t.second);\n\t    if(s.second && s.first)\n\t      A.push_back(make_pair((double)s.first/s.second, -1));\n\t    if(t.second && s.first)\n\t      A.push_back(make_pair((double)t.first/t.second, +1));\n\t  }\n\t}\n      }\n    }\n  }\n  sort(A.begin(),A.end());\n  int ans = 0, t = 0;\n\n  for(int i = 0; i < (int)A.size(); ++i){\n\n    t += A[i].second;\n    t = max(t,0);\n    ans = max(t,ans);\n  }\n\n  cout << (ans+1)/2 + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nbool field[660][660];\n\nstruct event{\n\tint x,y;\n\tbool which;//true:++,false:--\n\tevent(){}\n\tevent(int a,int b,bool c):x(a),y(b),which(c){}\n};\n\n//vector<event> events;\nevent events[720050];\n\nbool cmp(const event &e1,const event &e2)\n{\n\tif(e1.x==0) return true;\n\tif(e2.x==0) return false;\n\tif(e1.y==0) return false;\n\tif(e2.y==0) return true;\n\tif(e1.y*e2.x!=e2.y*e1.x) return (e1.y*e2.x>e2.y*e1.x);\n\tif(e1.which==false) return true;\n\tif(e2.which==false) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint H,W;\n\tscanf(\"%d%d\",&H,&W);\n\tmemset(field,false,sizeof(field));\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tchar ch[660];\n\t\tscanf(\"%s\",ch);\n\t\tfor(int j=0;j<W;j++)\n\t\t{\n\t\t\tfield[i+1][j+1]=(ch[j]=='#');\n\t\t}\n\t}\n\tint m=0;\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tfor(int j=1;j<=W;j++)\n\t\t{\n\t\t\tif(field[i][j]==true&&field[i-1][j-1]==false&&field[i-1][j]==false&&field[i][j-1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j-1,H-i+1,true));\n\t\t\t\tevents[m]=event(j-1,H-i+1,true);\n\t\t\t\tm++;\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i+1][j]==false&&field[i][j+1]==false&&field[i+1][j+1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j,H-i,false));\n\t\t\t\tevents[m]=event(j,H-i,false);\n\t\t\t\tm++;\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i+1][j]==true&&field[i][j+1]==true&&field[i+1][j+1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j,H-i,true));\n\t\t\t\tevents[m]=event(j,H-i,true);\n\t\t\t\tm++;\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i-1][j]==true&&field[i][j-1]==true&&field[i-1][j-1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j-1,H-i+1,false));\n\t\t\t\tevents[m]=event(j-1,H-i+1,false);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t}\n\t//sort(events.begin(),events.end(),cmp);\n\tsort(events,events+m,cmp);\n\tint cur=1,ans=1;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcur+=(events[i].which==false?-1:1);\n\t\tans=max(ans,cur);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nconst int M = 1000000007;\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    for (int i = h - 1; i >= 0; --i)\n        cin >> s[i];\n\n    int ans = 2;\n    for (int i = 1; i <= h; ++i) {\n        for (int j = 1; j <= w; ++j) {\n            if (gcd(i, j) > 1) continue;\n            // up-right\n            int c = 0;\n            for (int k = 0; k <= h; ++k) {\n                int l = j * k / i;\n                if (l < 0) continue;\n                if (l >= w) break;\n                if (k == 0)\n                    c += s[k][l] == '#';\n                else if (k == h)\n                    c += s[k - 1][l] == '#';\n                else\n                    c += s[k - 1][l] != s[k][l];\n            }\n            for (int k = 0; k <= w; ++k) {\n                int l = (i * k - 1) / j;\n                if (l < 0) continue;\n                if (l >= h) break;\n                if (k == 0)\n                    c += s[l][k] == '#';\n                else if (k == w)\n                    c += s[l][k - 1] == '#';\n                else\n                    c += s[l][k - 1] != s[l][k];\n            }\n            ans = max(ans, c / 2 + 1);\n\n            // down-left\n            c = 0;\n            for (int k = 0; k <= h; ++k) {\n                int l = (j * k - 1) / i;\n                if (l < 0) continue;\n                if (l >= w) break;\n                if (k == 0)\n                    c += s[k][l] == '#';\n                else if (k == h)\n                    c += s[k - 1][l] == '#';\n                else\n                    c += s[k - 1][l] != s[k][l];\n            }\n            for (int k = 0; k <= w; ++k) {\n                int l = i * k / j;\n                if (l < 0) continue;\n                if (l >= h) break;\n                if (k == 0)\n                    c += s[l][k] == '#';\n                else if (k == w)\n                    c += s[l][k - 1] == '#';\n                else\n                    c += s[l][k - 1] != s[l][k];\n            }\n            ans = max(ans, c / 2 + 1);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define uniq(xs) ((xs).erase(unique((xs).begin(), (xs).end()), (xs).end()))\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    const double EPS = 1e-8;\n\n    bool EQ(double x, double y) { return abs(x - y) < EPS; }\n\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(double k) const { return Point(k * x, k * y); }\n        Point operator/(double k) const { return Point(x / k, y / k); }\n        bool operator==(const Point& p) const { return EQ(x, p.x) && EQ(y, p.y); }\n        bool operator<(const Point& p) const { return EQ(x, p.x) ? y < p.y : x < p.x; }\n    };\n    double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    double norm(const Point& a) { return sqrt(dot(a, a)); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n    int ccw(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n        if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n        if (dot(b, c) < 0) return +2;          // c--a--b 直線\n        if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n        return 0;                              // a--c--b 直線\n    }\n\n    struct Segment {\n        Point a, b;\n        Segment() {}\n        Segment(const Point& a, const Point& b) : a(a), b(b) {}\n    };\n    bool intersects(const Segment& s, const Segment& t) {\n        return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    }\n    ostream& operator<<(ostream& os, const Segment& s) {\n        return os << \"Segment(\" << s.a << \",\" << s.b << \")\";\n    }\n\n    Point crosspoint(const Segment& s, const Segment& t) {\n        assert(intersects(s, t));\n        double d = cross(t.b - t.a, s.b - s.a);\n        assert(abs(d) >= EPS);\n        return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n    }\n\n    int H, W;\n    vector<string> F;\n    void input() {\n        cin >> H >> W;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) {\n            cin >> F[i];\n        }\n        reverse(F.begin(), F.end());\n    }\n\n    int count(const vector<Segment>& L, const Segment& s) {\n        int ret = 0;\n        for (int i = 0; i < L.size(); i++) {\n            const Segment& t = L[i];\n            if (intersects(s, t)) ret++;\n        }\n        return ret;\n    }\n\n    const int dy[] = {1, 0}, dx[] = {0, 1};\n    void solve() {\n        vector<Segment> L;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                int y = i, x = j;\n                for (int k = 0; k < 2; k++) {\n                    int ny = y + dy[k],\n                        nx = x + dx[k];\n                    if (ny >= H || nx >= W) {\n                        if (F[y][x] == '#') {\n                            if (x == nx) {\n                                L.push_back(Segment(Point(nx, ny), Point(nx + 1, ny)));\n                            } else if (y == ny) {\n                                L.push_back(Segment(Point(nx, ny), Point(nx, ny + 1)));\n                            }\n                        }\n                        continue;\n                    }\n                    if ( (F[y][x] == '#' && (ny >= H || nx >= W)) || (F[ny][nx] != F[y][x]) ) {\n                        if (x == nx) {\n                            L.push_back(Segment(Point(nx, ny), Point(nx + 1, ny)));\n                        } else if (y == ny) {\n                            L.push_back(Segment(Point(nx, ny), Point(nx, ny + 1)));\n                        }\n                        continue;\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < H; i++) {\n            double x = double(W);\n            for (int k = 0; k < 10; k++) {\n                double y = double(i) + k * 0.1 + 1.0 / 991;\n                ans = max(ans, count(L, Segment(Point(0, 0), Point(x, y))));\n            }\n        }\n        for (int j = 0; j < W; j++) {\n            double y = double(H);\n            for (int k = 0; k < 10; k++) {\n                double x = double(j) + k * 0.1 + 1.0 / 991;\n                ans = max(ans, count(L, Segment(Point(0, 0), Point(x, y))));\n            }\n        }\n        cout << 1 + (ans + 1) / 2 << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble EPS = 1e6;\nclass P{\npublic:\n    int x, y;\n    P(){};\n    P(int x, int y): x(x), y(y){};\n    \n    bool operator < (const P &r)const{\n        return 0 < x*r.y - y*r.x;\n    }\n    bool operator == (const P &r)const{\n        return 0 == x*r.y - y*r.x;\n    }\n};\n\ntypedef pair<P, P> Span;\n\nint H, W;\nvector<string> field;\n\n//up, down, right, left\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n\nSpan make_span(double h, double w, int dir){\n    P l, r;\n    if(dir == 0){ //up\n        l = P(w+1, h+1);\n        r = P(w, h+1);\n    }\n    if(dir == 1){ //down\n        l = P(w+1, h);\n        r = P(w, h);\n    }\n    if(dir == 2){ //right\n        l = P(w+1, h);\n        r = P(w+1, h+1);\n    }\n    if(dir == 3){ //left\n        l = P(w, h);\n        r = P(w, h+1);\n    }\n    return Span(l, r);\n}\n\nint main(){\n    cin >> H >> W;\n    field.resize(H+1);\n    for(int i=0; i<W+1; i++)\n        field[H] += '.';\n    \n    for(int i=0; i<H; i++){\n        cin >> field[H-1-i];\n        field[H-1-i] += '.';\n    }\n    \n    vector<Span> spans; //??????\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++) if(field[h][w] == '#'){\n            for(int i=0; i<4; i++){\n                int nh = h + dh[i];\n                int nw = w + dw[i];\n                if(nh<0 || nw<0 || H<nh || W<nw || field[nh][nw]!='.') continue;\n                \n                spans.push_back(make_span(h, w, i));\n            }\n        }\n    }\n    vector<P> tmp;\n    for(auto span: spans)\n        tmp.push_back(span.first), tmp.push_back(span.second);\n    sort(tmp.begin(), tmp.end());\n    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n\n    vector<int> cum(tmp.size());\n    for(auto &span: spans){\n        int l = lower_bound(tmp.begin(), tmp.end(), span.first) - tmp.begin();\n        int r = lower_bound(tmp.begin(), tmp.end(), span.second) - tmp.begin();\n        cum[l]++; cum[r]--;\n    }\n    int ans = 0;\n    for(int i=0; i<cum.size(); i++){\n        if(i != 0) cum[i] += cum[i-1];\n        ans = max(ans, cum[i]);\n    }\n    if(field[0][0] == '#')\n        ans++;\n    cout << ans/2 + 1 << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<double,double>D;\ntypedef pair<P,int>PP;\ntypedef pair<double,P>dP;\ntypedef pair<D,int>Di;\n\nconst int MAX_N = 602;\nconst int dx[] = {1,1,0,0};\nconst int dy[] = {0,0,1,-1};\nconst int ex[] = {1,0,1};\nconst int ey[] = {0,1,1};\n\nint a[MAX_N][MAX_N];\nint flag[MAX_N][MAX_N];\nint h,w;\nint gcd_table[MAX_N][MAX_N];\nint mp[MAX_N][MAX_N];\nvector<PP> vec;\n\nvoid dfs(int u,int v)\n{\n    flag[u][v] = 1;\n    if(u < w-1 && 0 < v && !a[u+1][v] && !a[u][v-1] && !a[u+1][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u == w-1 && 0 < v && !a[u][v-1]){  //??????\n        vec.push_back(PP(P(u+1,v),0));\n    }\n    if(u < w-1 && 0 < v && a[u+1][v] && a[u][v-1] && !a[u+1][v-1]){  //??????2\n        vec.push_back(PP(P(u+1,v),2));\n    }\n    if(0 < u && v < h-1 && !a[u-1][v] && !a[u][v+1] && !a[u-1][v+1]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v == h-1 && !a[u-1][v]){  //??????\n        vec.push_back(PP(P(u,v+1),1));\n    }\n    if(0 < u && v < h-1 && a[u-1][v] && a[u][v+1] && !a[u-1][v+1]){  //??????2\n        vec.push_back(PP(P(u,v+1),3));\n    }\n    rep(i,4){\n        int nx = u + dx[i],ny = v + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && a[nx][ny] && !flag[nx][ny]){\n            dfs(nx,ny);\n        }\n    }\n    return;\n}\n\nint gcd(int a,int b)\n{\n    if(a % b == 0){\n        return b;\n    }\n    return gcd(b,a % b);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&h,&w);\n    rep(j,h){\n        string s;\n        cin >> s;\n        rep(i,s.length()){\n            flag[i][j] = 0;\n            if(s[i] == '#'){\n                a[i][h-j-1] = 1;\n            }else{\n                a[i][h-j-1] = 0;\n            }\n        }\n    }\n    for(int i = 1;i <= 600;i++){\n        for(int j = i;j <= 600;j++){\n            gcd_table[j][i] = gcd(j,i);\n        }\n    }\n    bool fl = false;\n    rep(i,w){\n        rep(j,h){\n            if(a[i][j]){\n                dfs(i,j);\n                fl = true;\n                break;\n            }\n        }\n        if(!fl){\n            break;\n        }\n    }\n    // rep(i,vec.size()){\n    //     cout << vec[i].first.first << \" \" << vec[i].first.second << \" \" << vec[i].second << \"\\n\";\n    // }\n    vector<dP> tilt;\n    rep(i,vec.size()){\n        int p1 = (vec[i].first).first;\n        int p2 = (vec[i].first).second;\n        tilt.push_back(dP((double)p2 / p1,P(i,vec[i].second)));\n    }\n    sort(all(tilt));\n    vector<PP> cand;\n    rep(i,tilt.size()){\n        int cnt[] = {0,0,0,0};\n        int id = i;\n        double n1 = tilt[i].first;\n        int n2 = (tilt[i].second).first;\n        int n3 = (tilt[i].second).second;\n        cnt[n3]++;\n        while(id + 1 < tilt.size() && abs(tilt[id].first-tilt[id+1].first) < EPS){\n            n1 = tilt[i+1].first;\n            n3 = (tilt[i+1].second).first;\n            cnt[n3]++;\n            id++;\n        }\n        int mx = max(cnt[0]+cnt[3],cnt[1]+cnt[2]);\n        i = id;\n        P p = vec[n2].first;\n        int md = gcd_table[max(p.first,p.second)][min(p.first,p.second)];\n        mp[p.first / md][p.second / md]++;\n        cand.push_back(PP(P(p.first / md,p.second / md),mx));\n    }\n    for(int i = 1;i <= w;i++){\n        for(int j = 1;j <= h;j++){\n            int md = gcd_table[max(i,j)][min(i,j)];\n            P p = P(i / md,j / md);\n            if(!mp[p.first][p.second]){\n                cand.push_back(PP(p,0));\n                mp[p.first][p.second]++;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,cand.size()){\n        vector<Di> cros;\n        P p = cand[i].first;\n        rep(j,p.first-1){\n            cros.push_back(Di(D(j+1,(double)(j+1) * p.second / p.first),0));\n        }\n        rep(j,p.second-1){\n            cros.push_back(Di(D((double)(j+1) * p.first / p.second,j+1),1));\n        }\n        sort(all(cros));\n        vector<int> act;\n        rep(j,cros.size()){\n            act.push_back(cros[j].second);\n        }\n        act.push_back(2);\n        int cnt = 0;\n        int px = 0,py = 0;\n        int bf = a[0][0];\n        int res = 0;\n        while(1){\n            px += ex[act[cnt%act.size()]];\n            py += ey[act[cnt%act.size()]];\n            if(px < w && py < h){\n                if(bf == 1 && !a[px][py]){\n                    res++;\n                }\n                bf = a[px][py];\n            }else{\n                if(bf == 1){\n                    res++;\n                }\n                break;\n            }\n            cnt++;\n        }\n        ans = max(res+cand[i].second,ans);\n    }\n    cout << ans + 1 << \"\\n\";\n    exit(1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nbool compare(P A, P B){\n  \n  int y1 = A.first, x1 = A.second;\n  int y2 = B.first, x2 = B.second;\n  \n  return y1 * x2 < x1 * y2;\n}\n\nint h, w;\nstring s[605];\n\nint check(int y, int x){\n  \n  char a = s[y][x], b = s[y+1][x], c = s[y+1][x+1], d = s[y][x+1];\n  \n  if( a == '.' && b == '#' && c == '.' && d == '.' ) return 1;\n  \n  if( a == '.' && b == '.' && c == '.' && d == '#' ) return -1;\n  \n  if( a == '#' && b == '.' && c == '#' && d == '#' ) return 1;\n  \n  if( a == '#' && b == '#' && c == '#' && d == '.' ) return -1;\n  \n  return 0;\n}\n\nvector<P> point;\n\nint main(){\n  \n  cin>>h>>w;\n  \n  for(int i=0;i<=h+1;i++) s[i] = string( w + 2, '.' );\n  \n  for(int i=h;i>=1;i--){\n    for(int j=1;j<=w;j++) cin>>s[i][j];\n  }\n    \n  for(int i=0;i<=h;i++){\n    \n    for(int j=0;j<=w;j++){\n      \n      int r = check( i, j );\n      \n      if( !r ) continue;\n      \n      point.push_back(P( i, j ));\n      \n    }\n    \n  }\n  \n  sort( point.begin(), point.end(), compare );\n  \n  int ans = 1, x = 1;\n  \n  for(P p : point ){\n    x += check( p.first, p.second );\n    ans = max( ans, x );\n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint h,w;\nstring g[600];\nbool rose(int i,int j){\n\treturn 0<=i&&i<h&&0<=j&&j<w&&g[i][j]=='#';\n}\nint main(){\n\tcin>>h>>w;\n\tfor(int i=h;i--;) cin>>g[i];\n\tvector<tuple<int,int,int>> ts;\n\tfor(int i=0;i<=h;i++) for(int j=0;j<=w;j++){\n\t\tint a=rose(i-1,j-1),b=rose(i-1,j),c=rose(i,j-1),d=rose(i,j);\n\t\tif(a==b && a==d && a!=c) ts.emplace_back(i,j,1);\n\t\tif(a==c && a==d && a!=b) ts.emplace_back(i,j,-1);\n\t}\n\tsort(begin(ts),end(ts),[&](tuple<int,int,int> t1,tuple<int,int,int> t2){\n\t\tint a,b,x,c,d,y; tie(a,b,x,c,d,y)=tuple_cat(t1,t2);\n\t\treturn a*(c+d)!=c*(a+b)?a*(c+d)<c*(a+b):x<y;\n\t});\n\tint res=0,cnt=1;\n\tfor(auto t:ts) res=max(res,cnt+=get<2>(t));\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double mEPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nclass Point{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a*x, a*y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\t//EPS??????????°??????????\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n\t}\n\n  friend ostream& operator<<(ostream& os, const Point& p);\n\n};\nostream& operator<<(ostream& os, const Point& p){\n  os << \"(\" << p.x << \",\" << p.y << \")\";\n  return os;\n}\n  \nclass Segment{\npublic:\n\tPoint p1, p2;\n};\n\n\ntypedef vector<Point> Polygon;\n\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\n\n//??????\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//???????????§??????\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > mEPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -mEPS) return CLOCKWISE;\n\tif (dot(a, b) < -mEPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn(ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; cin >> H >> W;\n  VS str(H); REP(i,H) cin >> str[i];\n  reverse(ALL(str));\n  vector<Segment> ls;\n  REP(y,H) REP(x,W){\n\tif(str[y][x] == '#' && (y == 0 || str[y-1][x] == '.')){\n\t  int t = x;\n\t  for(;t<W;++t)\n\t\tif(str[y][t] == '.' || (y > 0 && str[y-1][t] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y;\n\t  p2.x = t, p2.y = y;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  x = t;\n\t}\n  }\n  REP(y,H) REP(x,W){\n\tif(str[y][x] == '#' && (y == H-1 || str[y+1][x] == '.')){\n\t  int t = x;\n\t  for(;t<W;++t)\n\t\tif(str[y][t] == '.' || (y < H-1 && str[y+1][t] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y+1;\n\t  p2.x = t, p2.y = y+1;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  x = t;\n\t}\n  }\n  REP(x,W) REP(y,H){\n\tif(str[y][x] == '#' && (x == 0 || str[y][x-1] == '.')){\n\t  int t = y;\n\t  for(;t<H;++t)\n\t\tif(str[t][x] == '.' || (x > 0 && str[t][x-1] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x; p1.y = y;\n\t  p2.x = x, p2.y = t;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  y = t;\n\t}\n  }\n  REP(x,W) REP(y,H){\n\tif(str[y][x] == '#' && (x == W-1 || str[y][x+1] == '.')){\n\t  int t = y;\n\t  for(;t<H;++t)\n\t\tif(str[t][x] == '.' || (x < W-1 && str[t][x+1] == '#')) break;\n\t  Point p1, p2;\n\t  p1.x = x+1; p1.y = y;\n\t  p2.x = x+1, p2.y = t;\n\t  Segment s; s.p1 = p1, s.p2 = p2;\n\t  ls.PB(s);\n\t  y = t;\n\t}\n  }\n\n  vector<tuple<int,int,Point>> memo;\n  REP(i,SZ(ls)) FOR(j,i+1,SZ(ls))\n\tif(intersect(ls[i], ls[j])){\n\t  if(ls[i].p1 == ls[j].p1 || ls[i].p1 == ls[j].p2)\n\t\tmemo.PB(MT(i,j,ls[i].p1));\n\t  else\n\t\tmemo.PB(MT(i,j,ls[i].p2));\n\t}\n\n  int ans = 1;\n  for(double th=0.;th<PI/2;th+=0.005){\n\tSegment s;\n\ts.p1.x = 0, s.p1.y = 0;\n\ts.p2.x = 1000. * cos(th), s.p2.y = 1000. * sin(th);\n\tvector<bool> cr(SZ(ls));\n\tREP(i,SZ(ls)) cr[i] = intersect(s, ls[i]);\n\tint c = count(ALL(cr), true);\n\tfor(auto& pp: memo){\n\t  if(cr[get<0>(pp)] && cr[get<1>(pp)] && !ccw(s.p1, s.p2, get<2>(pp)))\n\t\t--c;\n\t}\n\tans = max(ans, c/2+1);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct PQ {\n\tint den, num;\n\tPQ(int den, int num) : den(den), num(num) {}\n};\nbool operator>(const PQ& pq1, const PQ& pq2) {\n\treturn pq1.num * pq2.den > pq1.den * pq2.num;\n}\nbool operator<(const PQ& pq1, const PQ& pq2) {\n\treturn pq2 > pq1;\n}\nbool operator==(const PQ& pq1, const PQ& pq2) {\n\treturn !(pq1 > pq2) && !(pq1 < pq2);\n}\nbool operator>=(const PQ& pq1, const PQ& pq2) {\n\treturn pq1 == pq2 || pq1 > pq2;\n}\nbool operator<=(const PQ& pq1, const PQ& pq2) {\n\treturn pq2 >= pq1;\n}\n\ntypedef pair<PQ, PQ> PQP;\n\nint H, W;\nvector<string> M;\nbool dot[601][601] = {0};\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nbool inRange2(int x, int y) {\n\treturn 0 <= x && x <= W && 0 <= y && y <= H;\n}\nbool isWall(int x, int y) {\n\tif ( !inRange(x, y) ) return false;\n\treturn M[y][x] == '#';\n}\nbool getDot(int x, int y) {\n\tif ( !inRange2(x, y) ) return false;\n\treturn dot[y][x];\n}\nbool moveCheck(int x1, int y1, int x2, int y2) {\n\tif ( !getDot(x2, y2) ) return false;\n\tmap<P, int> cnt;\n\tfor (int dy = -1; dy <= 0; ++dy) {\n\t\tfor (int dx = -1; dx <= 0; ++dx) {\n\t\t\tcnt[P(x1+dx, y1+dy)]++;\n\t\t\tcnt[P(x2+dx, y2+dy)]++;\n\t\t}\n\t}\n\tset<bool> s;\n\tfor ( pair<const P, int>& p : cnt ) {\n\t\tif (p.second == 2 ) {\n\t\t\ts.insert(isWall(p.first.first, p.first.second));\n\t\t}\n\t}\n\treturn s.size() == 2;\n}\nint moveX(int x0, int y0) {\n\tbool bfl = true, bfr = true;\n\tbool fl = true, fr = true;\n\tfor (int dx = 1; dx <= W+3; ++dx) {\n\t\tfr = fr && moveCheck(x0+dx-1, y0, x0+dx, y0);\n\t\tfl = fl && moveCheck(x0-(dx-1), y0, x0-dx, y0);\n\t\tif ( !fr && !fl ) {\n\t\t\tif (bfl) return x0-(dx-1);\n\t\t\treturn x0+dx-1;\n\t\t}\n\t\tbfl = fl, bfr = fr;\n\t}\n}\nint moveY(int x0, int y0) {\n\tbool bfl = true, bfr = true;\n\tbool fl = true, fr = true;\n\tfor (int dy = 1; dy <= H+3; ++dy) {\n\t\tfr = fr && moveCheck(x0, y0+(dy-1), x0, y0+dy);\n\t\tfl = fl && moveCheck(x0, y0-(dy-1), x0, y0-dy);\n\t\tif ( !fr && !fl ) {\n\t\t\tif (bfl) return y0-(dy-1);\n\t\t\treturn y0+dy-1;\n\t\t}\n\t\tbfl = fl, bfr = fr;\n\t}\n}\n\nPQ f(int x, int y) {\n\treturn PQ(x, y);\n}\n\nvector<PQP> r;\nvoid addLine(int x1, int y1, int x2, int y2) {\n\ty1 = H-y1, y2 = H-y2;\n\tif (x1 == 0 && y1 == 0) return;\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << (double)y1/x1 << \" \" << (double)y2/x2 << endl;\n\tPQ pq1 = f(x1, y1);\n\tPQ pq2 = f(x2, y2);\n\tif (pq2 < pq1) swap(pq1, pq2);\n\tr.push_back( PQP(pq1, pq2) );\n}\nsigned main() {\n\tcin >> H >> W;\n\tM.resize(H);\n\tfor (int i = 0; i < H; ++i) cin >> M[i];\n\tfor (int y = 0; y <= H; ++y) {\n\t\tfor (int x = 0; x <= W; ++x) {\n\t\t\tset<bool> s;\n\t\t\tfor (int dx = -1; dx <= 0; ++dx) {\n\t\t\t\tfor (int dy = -1; dy <= 0; ++dy) {\n\t\t\t\t\ts.insert( isWall(x+dx, y+dy) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tdot[y][x] = s.size() == 2;\n\t\t}\n\t}\n\tint sx = -1, sy = -1;\n\tfor (int y = 0; y < H; ++y) {\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tif ( isWall(x, y) ) {\n\t\t\t\tsx = x, sy = y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sx >= 0) break;\n\t}\n\t{\n\t\tint x = sx, y = sy;\n\t\twhile (1) {\n\t\t\tint nx = moveX(x, y);\n\t\t\tint ny = moveY(nx, y);\n//\t\t\tassert(nx != x);\n//\t\t\tassert(ny != y);\n\t\t\taddLine(x, y, nx, y);\n\t\t\tif (nx == sx && ny == sy) break;\n\t\t\taddLine(nx, y, nx, ny);\n\t\t\tx = nx, y = ny;\n\t\t}\n\t\tsort(r.begin(), r.end());\n\t\tint mx = 0;\n\t\tmap<PQ, int> m;\n\t\t{\n\t\t\tvector<PQ> v;\n\t\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\t\tv.push_back(r[i].first);\n\t\t\t\tv.push_back(r[i].second);\n\t\t\t}\n\t\t\tsort(v.begin(), v.end());\n\t\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t\t\tfor (int i = 0; i < v.size(); ++i) {\n\t//\t\t\tcout << v[i].first.num << \" \" << v[i].\n\t\t\t\tm[v[i]] = i;\n\t\t\t}\n\t\t\tmx = v.size();\n\t\t}\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\tv.push_back( P(m[r[i].first], m[r[i].second]) );\n\t\t}\n\t\tfor (int i = 0; i < v.size(); ++i) {\n//\t\t\tcout << v[i].first << \" \" << v[i].second << endl;\n\t\t}\n\t\tvector<int> cnt(mx*2+3, 0);\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\t++cnt[v[i].first*2+1];\n\t\t\t--cnt[v[i].second*2];\n\t\t}\n\t\tfor (int i = 0; i+1 < cnt.size(); ++i) {\n\t\t\tcnt[i+1] += cnt[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < cnt.size(); ++i) {\n\t\t\tans = max(ans, cnt[i]);\n\t\t}\n\t\t++ans;\n\t\tcout << ans/2+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,a,n) for(int i=a;i<n;i++)\n#define pb push_back\nusing namespace std;\ntypedef pair<double,int> P;\ntypedef double D;\nint H,W,ans,sum=1;\nstring s[666];\nvector<P>a;\nint main(){\n  cin>>H>>W;\n  r(i,0,H)cin>>s[i+1];\n  r(i,0,W+2)s[0]+='.',s[H+1]+='.';\n  r(i,0,H)s[i+1]='.'+s[i+1]+'.';\n  H+=2,W+=2;\n  r(i,1,H-1)r(j,1,W-1){\n    if(s[i][j]=='#'&&s[i-1][j]=='.'&&s[i][j-1]=='.')a.pb(P(D(i)/j,-1));\n    if(s[i][j]=='#'&&s[i+1][j]=='.'&&s[i][j+1]=='.')a.pb(P(D(i)/j,1));\n    if(s[i][j]=='.'&&s[i+1][j]=='#'&&s[i][j+1]=='#')a.pb(P(D(i)/j,1));\n    if(s[i][j]=='.'&&s[i-1][j]=='#'&&s[i][j-1]=='#')a.pb(P(D(i)/j,-1));\n  }\n  sort(a.begin(),a.end());\n  r(i,0,a.size()){\n    sum+=a[i].second*-1;\n    ans=max(ans,sum);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// OBïÄh2011 Day4 A : åKåNÌ\n\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint main(){\n\tint H, W;\n\tstring f[600];\n\twhile(cin >> H >> W){\n\t\tfor(int i=H-1;i>=0;i--) cin >> f[i];\n\n\t\tvector< pair<double, int> > vd;\n\t\t// ÌæªÏíé¸_ð²×é.\n\t\t// X«(j/i)ðå«­µ½Æ«ÌÌæÌ¸àÁÄ¨­\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=0;j<=W;j++){\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i-k%2;\n\t\t\t\t\tint nj = j-k/2;\n\t\t\t\t\tif(0<=ni&&ni<H&&0<=nj&&nj<W&&f[ni][nj]=='#') cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt == 1){\n\t\t\t\t\tif(0<=i-1&&i-1<H&&0<=j&&j<W&&f[i-1][j]=='#') vd.push_back(make_pair((double)j/i,  1));\n\t\t\t\t\tif(0<=i&&i<H&&0<=j-1&&j-1<W&&f[i][j-1]=='#') vd.push_back(make_pair((double)j/i, -1));\n\t\t\t\t}\n\t\t\t\tif(cnt == 3){\n\t\t\t\t\tif(0<=i-1&&i-1<H&&0<=j&&j<W&&f[i-1][j]=='.') vd.push_back(make_pair((double)j/i,  1));\n\t\t\t\t\tif(0<=i&&i<H&&0<=j-1&&j-1<W&&f[i][j-1]=='.') vd.push_back(make_pair((double)j/i, -1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vd.begin(), vd.end());\n\n\t\tint res = 1, cur = 1;\n\t\t// X«ðå«­µÄ¢«AÌæÌ¸ð²×é\n\t\tfor(int i=0;i<vd.size(); ){\n\t\t\tint idx = i;\n\t\t\twhile(idx < vd.size() && abs(vd[i].first-vd[idx].first) < EPS)\n\t\t\t\tcur += vd[idx++].second;\n\t\t\ti = idx;\n\t\t\tres = max(cur, res);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-3;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint h,w;\nvector<string> mp;\n\n//   1   -1    1   -1\n//  #.   ..   .#   ##\n//  ..   .#   ##   #.\n\n\nbool O___(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '.' && mp[y+1][x] == '#' && mp[y+1][x+1] == '.';\n}\n\nbool ___O(int x,int y){\n  return mp[y][x] == '.' && mp[y][x+1] == '#' && mp[y+1][x] == '.' && mp[y+1][x+1] == '.';\n}\n\nbool _OOO(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '#' && mp[y+1][x] == '.' && mp[y+1][x+1] == '#';\n}\n\nbool OOO_(int x,int y){\n  return mp[y][x] == '#' && mp[y][x+1] == '.' && mp[y+1][x] == '#' && mp[y+1][x+1] == '#';\n}\n\n\nsigned main(){\n  cin>>h>>w;\n  mp.resize(h+2,string(w+2,'.'));\n\n  for(int i=0;i<h;i++) \n    for(int j=0;j<w;j++) cin>>mp[h-i][j+1];\n\n  const int K = 10;\n  vector<string> mp2((h+2)*K,string((w+2)*K,'.'));\n  for(int i=0;i<h+2;i++)\n    for(int j=0;j<w+2;j++){\n      for(int y = 0; y < K; y++)\n        for(int x = 0; x < K; x++)\n          mp2[i*K+y][j*K+x] = mp[i][j];\n    }\n  \n  mp = mp2;\n  h = mp.size() - 2;\n  w = mp[0].size() - 2;\n\n  //for(int i=0;i<h;i++) cout<<mp[h-i]<<endl;\n    \n  vector<P> A;\n  for(int i=1;i<h+1;i++)\n    for(int j=1;j<w+1;j++){\n      if(O___(j,i) || ___O(j,i) || _OOO(j,i) || OOO_(j,i)) A.push_back(P(j,i));\n    }\n\n  typedef complex<double> Point;\n  sort(A.begin(),A.end(),[&](P &a,P &b){\n      double x1,y1; tie(x1,y1) = a;\n      double x2,y2; tie(x2,y2) = b;\n      x1-=K;y1-=K;\n      x2-=K,y2-=K;\n      return arg(Point(x1,y1)) < arg(Point(x2,y2));\n    });\n  \n  //cout<<pr(A)<<endl;\n  int ans = 1;\n  int cnt = 1;\n  for(int i=0;i<(int)A.size();){\n    double x,y; tie(x,y) = A[i];\n    double th = arg(Point(x,y));\n    while(i < (int)A.size()){\n      double x,y; tie(x,y) = A[i];\n      if(abs(th - arg(Point(x,y))) > EPS) break;\n      //cout<<abs(th - arg(Point(x,y)))<<endl;\n      \n      i++;\n      if(O___(x,y) || _OOO(x,y)) cnt++;\n      else if(___O(x,y) || OOO_(x,y)) cnt--;\n      else assert(0);\n      //cout<<pr(x,y)<<endl;\n      //cout<<pr(O___(x,y), _OOO(x,y), ___O(x,y), OOO_(x,y)) <<endl;\n    }\n    Max(ans,cnt);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <iostream>\n \n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <complex>\n#include <cassert>\n \nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n//typedef tuple<int, int, int> T;\ntypedef pair<ll, ll> Pl;\n//typedef tuple<ll, ll, ll> Tl;\n \n \n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n \n//config\n//#define NDEBUG\n \n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n \ntemplate<class T> inline string toString(const vector<T>& x) {\n    stringstream ss;\n    REP(i,x.size()){\n        if(i!=0)ss<<\" \";\n        ss<< x[i];\n    }\n    return ss.str();\n}\n \ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n    stringstream ss;\n    REP(i,map.size()){\n        if(i!=0)ss<<BR;\n        ss<< toString(map[i]);\n    }\n    return ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n    string res;stringstream ss;\n    for(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n    return ss.str();\n}\n \n \n \nnamespace Ps{\n    const double EPS=1e-8,INF=1e12;\n#define X real()\n#define Y imag()\n    typedef complex<double> P;\n}\nusing namespace Ps;\nnamespace Ls{\n    struct L:public vector<P>{\n        L(const P&a,const P&b){\n            push_back(a);push_back(b);\n        }\n    };\n}\nusing namespace Ls;\n \n \nclass Seg{\npublic:\n    double l,r;\n    Seg(double l,double r):l(l),r(r){\n    }\n \n    bool operator < (const Seg& rt) const{\n        return l<rt.l;\n    }\n};\n \nint main() {\n    int H,W;cin >> H >> W;\n    vector<string> board(H+2);\n\n    board[0]=string(W+2,'.');\n     \n    for(int y=1;y<=H;y++){\n    \tboard[y]=string(W+2,'.');\n    \tstring s;cin >> s;\n    \tfor(int i=1;i<=W;i++)board[y][i]=s[i-1];\n    }\n    board[H+1]=string(W+2,'.');\n   \n    vector<L> ls;\n \n    // -\n    for(int y=1;y<=H+1;y++){\n        int x=1;\n        for(;x<=W;x++){\n            if(board[y-1][x]=='.' && board[y][x]=='#'){\n                P p1(H-(y-1),x-1);\n                x++;\n                while(board[y-1][x]=='.' && board[y][x]=='#'){\n                    x++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                x--;\n            }\n            if(board[y-1][x]=='#' && board[y][x]=='.'){\n                P p1(H-(y-1),x-1);\n                x++;\n                while(board[y-1][x]=='#' && board[y][x]=='.'){\n                    x++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                x--;\n            }\n        }\n    }\n \n    // |\n    for(int x=1;x<=W+1;x++){\n        int y=0;\n        for(;y<=H;y++){\n            if(board[y][x-1]=='.' && board[y][x]=='#'){\n                P p1(H-(y-1),x-1);\n                y++;\n                while(board[y][x-1]=='.' && board[y][x]=='#'){\n                    y++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                y--;\n            }\n            if(board[y][x-1]=='#' && board[y][x]=='.'){\n                P p1(H-(y-1),x-1);\n                y++;\n                while(board[y][x-1]=='#' && board[y][x]=='.'){\n                    y++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                y--;\n            } \n        }\n    }\n \n    // for(int i=0;i<ls.size();i++){\n    //  cout << ls[i][0]<<\" \" <<ls[i][1]<<endl;\n    // }\n \n    // DUMP(ls.size());\n    // //DUMP(toString())\n \n    vector<Seg> ss;\n    for(int i=0;i<ls.size();i++){\n        ss.push_back(Seg(min(arg(ls[i][0]),arg(ls[i][1])+EPS),1));\n        ss.push_back(Seg(max(arg(ls[i][0]),arg(ls[i][1])-EPS),-1));     \n    } \n    sort(ss.begin(),ss.end());\n \n \n    int Mv=0,v=0;\n    for(int i=0;i<ss.size();i++){\n        v+=ss[i].r;\n        Mv=max(Mv,v);\n    }\n \n    cout << (Mv/2 + 1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int h,w;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++) cin>>s[i];\n  bool e[h+10][w+10];\n  memset(e,0,sizeof(e));\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      e[h-i-1][j]=s[i][j]=='#';\n  /*//\n    for(int i=h-1;i>=0;i--)\n    for(int j=0;j<w;j++)\n    cout<<e[i][j]<<\" \\n\"[j==w-1];\n  //*/\n  int ans=2;\n  \n  time_t start=clock();\n  srand((unsigned)time(NULL));\n  int k=0;\n  while((double)(clock()-start)/CLOCKS_PER_SEC<1.8){\n    k++;\n    for(int i=1;i<=h+k;i++){\n      int x=0,y=0,tmp=e[0][0],p;\n      while(x<=w&&y<=h){\n\t//if(i==4&&k==2) cout<<y<<\" \"<<x<<endl;\n\tp=e[y][x];\n\tif((i*(x+1))%(w+k)==0) x++,y++;\n\tif((i*(x+1))/(w+k)==y) x++;\n\telse y++;\n\tif(!p&&e[y][x]) tmp++;\n      }\n      //cout<<i<<\":\"<<tmp<<endl;\n      //if(i==4&&k==2) cout<<tmp<<endl;\n      ans=max(ans,tmp+1);\n    }\n    for(int j=1;j<=w+k;j++){\n      int x=0,y=0,tmp=e[0][0],p;\n      while(x<=w&&y<=h){\n\tp=e[y][x];\n\tif((j*(y+1))%(h+k)==0) x++,y++;\n\telse if((j*(y+1))/(h+k)==x) y++;\n\telse x++;\n\tif(!p&&e[y][x]) tmp++;\n      }\n      //cout<<j<<\" \"<<tmp<<endl;\n      ans=max(ans,tmp+1);\n    }\n  }\n  //cout<<k<<endl;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n#define X(p)  ( (p).real() )\n#define Y(p)  ( (p).imag() )\n\nconst double eps = 1e-10;\nconst double pi  = 3.14159265358979323846;\n\ntypedef double Num;\ntypedef complex<Num> Pt2;\ntypedef vector<Pt2> Polygon2;\n\nstruct Line2 : vector<Pt2> {\n  Line2(Pt2 a, Pt2 b) { push_back(a); push_back(b); }\n  Pt2 vec() { return (*this)[1]-(*this)[0]; }\n};\n\nPt2  unit (Pt2 v)        { return v/abs(v);     }\nNum  dist (Pt2 a, Pt2 b) { return abs(a-b);     }\nNum  dot  (Pt2 a, Pt2 b) { return X(a*conj(b)); }\nNum  cross(Pt2 a, Pt2 b) { return Y(conj(a)*b); }\nbool equal(Num a, Num b) { return abs(a-b)<eps; }\nbool equal(Pt2 a, Pt2 b) { return equal(X(a),X(b))&&equal(Y(a),Y(b)); }\n\nbool intersectLS(Line2 s, Line2 t) {\n  return cross(s.vec(), t[0]-s[0])\n       * cross(s.vec(), t[1]-s[0]) < eps;\n}\n\nint main()\n{\n\tint H,W;\n\tchar e[602][602]={0};\n\tbool b[602][602]={0};\n\n\tcin>>H>>W;\n\tfor(int y=1; y<=H; y++)\n\tfor(int x=1; x<=W; x++)\n\t{\n\t\tchar c; cin>>c;\n\t\tb[y][x] = (c=='#');\n\t}\n\n\tfor(int y=1; y<=H+1; y++)\n\tfor(int x=1; x<=W+1; x++)\n\t{\n\t\tif(b[y][x]!=b[y-1][x  ]) e[y][x] |= 1;\n\t\tif(b[y][x]!=b[y  ][x-1]) e[y][x] |= 2;\n\t}\n\n\tint px=-1,py=-1,pd=-1;\n\tfor(int y=1; y<=H; y++)\n\t{\n\t\tfor(int x=1; x<=W; x++)\n\t\t{\n\t\t\tif(b[y][x]) { px=x; py=y; break; }\n\t\t}\n\t\tif(px!=-1) break;\n\t}\n\n\tPolygon2 g;\n\twhile(true)\n\t{\n\t\tint d=-1;\n\t\tif     (e[py  ][px  ] & 1) { d=0; e[py  ][px  ]-=1; }\n\t\telse if(e[py  ][px  ] & 2) { d=1; e[py  ][px  ]-=2; }\n\t\telse if(e[py  ][px-1] & 1) { d=2; e[py  ][px-1]-=1; }\n\t\telse if(e[py-1][px  ] & 2) { d=3; e[py-1][px  ]-=2; }\n\n\t\tif(d==-1) break;\n\t\tif(d!=pd)\n\t\t{\n\t\t\tg.push_back(Pt2(px-1,H+1-py));\n\t\t}\n\n\t\tconst int dx[] = {+1, 0,-1, 0};\n\t\tconst int dy[] = { 0,+1, 0,-1};\n\t\tpx+=dx[d]; py+=dy[d]; pd=d;\n\t}\n\n\tvector<Num> ang;\n\tfor(int i=0; i<g.size(); i++)\n\t{\n\t\tif(equal(g[0],Pt2(0,0))) continue;\n\t\tang.push_back(arg(g[i]));\n\t}\n\tsort(ang.begin(), ang.end());\n\tang.erase(unique(ang.begin(), ang.end()), ang.end());\n\n\tint cnt_max=0;\n\tfor(int k=0; k<ang.size()-1; k++)\n\t{\n\t\tint cnt=0;\n\t\tLine2 s(Pt2(0,0), polar(1.0,(ang[k]+ang[k+1])/2.0));\n\t\tfor(int i=0; i<g.size(); i++)\n\t\t{\n\t\t\tif(intersectLS(s, Line2(g[i], g[(i+1)%g.size()]))) cnt++;\n\t\t}\n\t\tcnt_max=max(cnt_max,cnt);\n\t}\n\n\tcout << (cnt_max/2)+1 << endl;\n\n}\n\n/*\n3 3\na #.#\na ###\na #.#\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Arg {\n  int x, y, t;\n  bool operator < (const Arg &a) const {\n    if(y * a.x == a.y * x) return t < a.t;\n    else y * a.x < a.y * x;\n  }\n};\n\nconst int MAXH = 666;\nconst int MAXW = 666;\n\nint H, W;\nchar G[MAXH][MAXW];\n\nint main() {\n  cin >> H >> W;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> G[i][j];\n    }\n  }\n  vector<Arg> v;\n  for(int i = 0; i <= H; ++i) {\n    for(int j = 0; j <= W; ++j) {\n      bool a = i && j && G[i-1][j-1] == '#';\n      bool b = i && G[i-1][j] == '#';\n      bool c = j && G[i][j-1] == '#';\n      bool d = G[i][j] == '#';\n      if(a && !b && !c && !d) v.push_back((Arg){j, H-i,  1});\n      if(!a && b && c && d)   v.push_back((Arg){j, H-i,  1});\n      if(!a && !b && !c && d) v.push_back((Arg){j, H-i, -1});\n      if(a && b && c && !d)   v.push_back((Arg){j, H-i, -1});\n    }\n  }\n  sort(v.begin(), v.end());\n  int now = 1;\n  int maxi = now;\n  for(int i = 0; i < v.size(); ++i) {\n    now += v[i].t;\n    maxi = max(maxi, now);\n  }\n  cout << maxi << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct angle{\n\tint x,y,delta;\n\tbool operator<(const angle &a)const{\n\t\treturn y*a.x==x*a.y ? delta<a.delta : y*a.x<x*a.y;\n\t}\n};\n\n#define O(i,j) (0<=i && i<h && 0<=j && j<w && B[i][j]=='#')\n#define X(i,j) (!O(i,j))\n\nint main(){\n\tint h,w; scanf(\"%d%d\",&h,&w);\n\tchar B[600][601];\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tvector<angle> A;\n\trep(i,h+1) rep(j,w+1) {\n\t\tif(O(i-1,j-1) && X(i-1,j)\n\t\t&& X( i ,j-1) && X( i ,j)) A.push_back((angle){j,h-i,1});\n\t\tif(X(i-1,j-1) && O(i-1,j)\n\t\t&& O( i ,j-1) && O( i ,j)) A.push_back((angle){j,h-i,1});\n\t\tif(O(i-1,j-1) && O(i-1,j)\n\t\t&& O( i ,j-1) && X( i ,j)) A.push_back((angle){j,h-i,-1});\n\t\tif(X(i-1,j-1) && X(i-1,j)\n\t\t&& X( i ,j-1) && O( i ,j)) A.push_back((angle){j,h-i,-1});\n\t}\n\tsort(A.begin(),A.end());\n\n\tint ans=1,num=1;\n\trep(i,A.size()) num+=A[i].delta, ans=max(ans,num);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nbool comp2(pair<pair<int,int>,int>a,pair<pair<int,int>,int>b){\n    int x = a.first.first;\n    int y = a.first.second;\n    int w = b.first.first;\n    int z = b.first.second;\n    if(x*z==y*w){\n        return 1;\n    }\n    if(x*z>y*w){\n        return 0;\n    }\n    if(x*z<y*w){\n        return 0;\n    }\n}\n\nbool comp(pair<pair<int,int>,int>a,pair<pair<int,int>,int>b){\n    int x = a.first.first;\n    int y = a.first.second;\n    int w = b.first.first;\n    int z = b.first.second;\n    if(x*z==y*w){\n        return 0;\n    }\n    if(x*z>y*w){\n        return 1;\n    }\n    if(x*z<y*w){\n        return 0;\n    }\n}\n\nint main(){\n    int h,w;\n    cin >> h >> w;\n    vector<string>v(h);\n    rep(i,h)cin >> v[h-i-1];\n    rep(i,h)v[i].push_back('.');\n    string ssss;\n    rep(i,w+1)ssss.push_back('.');\n    v.push_back(ssss);\n    vector<pair<pair<int,int>,int> > p;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(v[i][j]=='#'&&v[i][j+1]=='#'&&v[i+1][j]=='.'&&v[i+1][j+1]=='#'){\n                p.push_back(make_pair(make_pair(i+1,j+1),-1));\n            }\n            if(v[i][j]=='.'&&v[i][j+1]=='.'&&v[i+1][j]=='#'&&v[i+1][j+1]=='.'){\n                p.push_back(make_pair(make_pair(i+1,j+1),-1));\n            }\n            if(v[i][j]=='#'&&v[i][j+1]=='.'&&v[i+1][j]=='#'&&v[i+1][j+1]=='#'){\n                p.push_back(make_pair(make_pair(i+1,j+1),1));\n            }\n            if(v[i][j]=='.'&&v[i][j+1]=='#'&&v[i+1][j]=='.'&&v[i+1][j+1]=='.'){\n                p.push_back(make_pair(make_pair(i+1,j+1),1));\n            }\n        }\n    }\n    sort(p.begin(),p.end(),comp);\n    int mx = 2;\n    int cnt = 2;\n    bool flag = 1;\n    for(int i=0;i<h+1;i++){\n        if(v[i][0]!='.'){\n            flag = 0;\n        }\n    }\n    if(flag){\n        cnt--;\n    }\n    // rep(i,h+1){\n    //     rep(j,w+1){\n    //         cout << v[i][j];\n    //     }\n    //     cout <<endl;\n    // }\n    for(int i=0;i<p.size();i++){\n        //cout << p[i].first.first << \" \" << p[i].first.second << \" \" << p[i].second << \" \" << cnt<< endl;\n        if(i==p.size()-1){\n            cnt += p[i].second;\n            mx = max(mx,cnt);\n        }else{\n            if(!comp2(p[i],p[i+1])){\n                cnt += p[i].second;\n                mx = max(mx,cnt);\n            }else{\n                cnt += p[i].second;\n            }\n        }\n    }\n    cout << mx << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nbool field[660][660];\n\nstruct frac{\n\tint x,y;\n\tfrac(){}\n\tfrac(int x,int y):x(x),y(y){}\n};\n\nbool operator<(const frac &f1,const frac &f2)\n{\n\tif(f1.x==0) return true;\n\tif(f2.x==0) return false;\n\tif(f1.y==0) return false;\n\tif(f2.y==0) return true;\n\treturn f1.y*f2.x>f2.y*f1.x;\n}\n\nmap<frac,int> events;\n\nint gcd(int x,int y)\n{\n\tif(x<y) swap(x,y);\n\tif(y==0) return x;\n\treturn gcd(y,x%y);\n}\n\nint main()\n{\n\tint H,W;\n\tscanf(\"%d%d\",&H,&W);\n\tmemset(field,false,sizeof(field));\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tchar ch[660];\n\t\tscanf(\"%s\",ch);\n\t\tfor(int j=0;j<W;j++)\n\t\t{\n\t\t\tfield[i+1][j+1]=(ch[j]=='#');\n\t\t}\n\t}\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tfor(int j=1;j<=W;j++)\n\t\t{\n\t\t\tif(field[i][j]==true&&field[i-1][j-1]==false&&field[i-1][j]==false&&field[i][j-1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j-1,H-i+1,true));\n\t\t\t\t//events[m]=event(j-1,H-i+1,true);\n\t\t\t\t//m++;\n\t\t\t\tint d=gcd(j-1,H-i+1);\n\t\t\t\tevents[frac((j-1)/d,(H-i+1)/d)]++;\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i+1][j]==false&&field[i][j+1]==false&&field[i+1][j+1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j,H-i,false));\n\t\t\t\t//events[m]=event(j,H-i,false);\n\t\t\t\t//m++;\n\t\t\t\tint d=gcd(j,H-i);\n\t\t\t\tevents[frac(j/d,(H-i)/d)]--;\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i+1][j]==true&&field[i][j+1]==true&&field[i+1][j+1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j,H-i,true));\n\t\t\t\t//events[m]=event(j,H-i,true);\n\t\t\t\t//m++;\n\t\t\t\tint d=gcd(j,H-i);\n\t\t\t\tevents[frac(j/d,(H-i)/d)]++;\n\t\t\t}\n\t\t\tif(field[i][j]==true&&field[i-1][j]==true&&field[i][j-1]==true&&field[i-1][j-1]==false)\n\t\t\t{\n\t\t\t\t//events.push_back(event(j-1,H-i+1,false));\n\t\t\t\t//events[m]=event(j-1,H-i+1,false);\n\t\t\t\t//m++;\n\t\t\t\tint d=gcd(j-1,H-i+1);\n\t\t\t\tevents[frac((j-1)/d,(H-i+1)/d)]--;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=1,cur=1;\n\tmap<frac,int>::iterator it=events.begin();\n\tfor(;it!=events.end();it++)\n\t{\n\t\tcur+=(*it).second;\n\t\tans=max(ans,cur);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H + 2, vector<int>(W + 2));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '#') {\n\t\t\t\tfield[H- i][j + 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<Line>walls;\n\tfor (int x = 0; x < W + 1; ++x) {\n\t\tfor (int y = 0; y < H + 2; ++y) {\n\t\t\tif (field[y][x]^field[y][x + 1]) {\n\t\t\t\twalls.push_back(Line(Point(x + 1, y + 1), Point(x+1, y)));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < W + 2; ++x) {\n\t\tfor (int y = 0; y < H + 1; ++y) {\n\t\t\tif (field[y][x] ^ field[y+1][x]) {\n\t\t\t\twalls.push_back(Line(Point(x, y + 1), Point(x + 1, y + 1)));\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (int x = 1; x < W + 1; ++x) {\n\t\tfor (int y = 1; y < H + 1; ++y) {\n\t\t\tif(gcd(x,y)==1)tans.emplace_back(ld(y) / x);\n\t\t\t\n\t\t}\n\t}\n\ttans.emplace_back(0);\n\ttans.emplace_back(-1e18);\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int t = 0; t < tans.size()-1; ++t) {\n\t\t\tntans.emplace_back((tans[t + 1] + tans[t]) / 2);\n\t\t}\n\t\ttans = ntans;\n\t}\n\tint ans = 0;\n\tfor (auto t : tans) {\n\t\tint num = 0;\n\t\tLine l(Point(1, 1), Point(2, t+1));\n\t\tfor (auto w : walls) {\n\t\t\tif (isis_ls(l, w))num++;\n\t\t}\n\t\tans = max(ans, (num + 2) / 2);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nchar cps[4][2][3]={\n\t{\"#.\",  //-d\n\t \"##\"},\n\t{\".#\",  //-d\n\t \"..\"},\n\t{\"..\",  //+d\n\t \"#.\"},\n\t{\"##\",  //+d\n\t \".#\"}\n};\n\nint h,w;\nchar s[605][605];\ntypedef pair<double,int> dip;\nvector<dip> ps;\n\nint main(void){\n\tscanf(\"%d%d\",&h,&w);\n\tireg(y,1,h)scanf(\"%s\",s[y]+1);\n\treg(y,0,h+1)s[y][0]=s[y][w+1]='.';\n\treg(x,0,w+1)s[0][x]=s[h+1][x]='.';\n\t\n\treg(y,0,h){\n\t\treg(x,0,w){\n\t\t\trep(k,4){\n\t\t\t\tbool mc=true;\n\t\t\t\trep(p,2)rep(q,2){\n\t\t\t\t\tif(s[y+p][x+q]!=cps[k][p][q])mc=false;\n\t\t\t\t}\n\t\t\t\tif(mc){\n\t\t\t\t\tdouble r=atan2(y,x);\n\t\t\t\t\tint a;\n\t\t\t\t\tif(k<2)a=-1;\n\t\t\t\t\telse a=1;\n\t\t\t\t\tif(k<2)r-=1e-6;\n\t\t\t\t\telse r+=1e-6;\n\t\t\t\t\tps.push_back(dip(r,a));\n\t\t\t\t\t//printf(\"%d %d %lf %d\\n\",x,y,r,a);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsort(ps.begin(),ps.end());\n\tint ans=0,ns=1;\n\trep(i,ps.size()){\n\t\t//printf(\"%lf %d\\n\",ps[i].fir,ps[i].sec);\n\t\tns+=ps[i].sec;\n\t\tans=max(ans,ns);\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\nconst double EPS=1e-10;\nchar str[700][700];\nint array[700][700];\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;\n\t\tint c=b;\n\t\tb=a;\n\t\ta=c;\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[a-1-i]);\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<b;j++)array[i][j]=(str[i][j]=='#'?1:0);\n\tint ret=0;\n\t\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(gcd(i+1,j+1)>1)continue;\n\t\t\tint val=0;\n\t\t\tdouble X=i+1;\n\t\t\tdouble Y=(1e-8)+j+1;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tval+=(array[k][d]^array[k+1][d]);\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tval+=(array[d][k]^array[d][k+1]);\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t\tval=0;\n\t\t\tY=-(1e-8)+j+1;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=b)break;\n\t\t\t\tval+=(array[k][d]^array[k+1][d]);\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tint d=(int)(Y*(k+1)/X);\n\t\t\t\tif(d>=a)break;\n\t\t\t\tval+=(array[d][k]^array[d][k+1]);\n\t\t\t}\n\t\t//\tif(val==18)printf(\"%d %d\\n\",i,j);\n\t\t\tret=max(ret,val);\n\t\t}\n\t}\n\tif(str[0][0]=='#')ret++;\n\tprintf(\"%d\\n\",1+ret/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\nint f[605][605];\nint memo[1205][1205];\nvector<int> vec;\n\nint gcd(int a, int b){\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nint main(void)\n{\n\tcin >> H >> W;\n\t\n\tchar c;\n\tfor(int y = H-1; y >= 0; y--){\n\t\tfor(int x = 0; x < W; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == '#') f[x][y] = 1;\n\t\t\telse f[x][y] = 0;\n\t\t}\n\t}\n\t\n\tint ans = 0, cnt, x, y, px, py, prev;\n\t\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(x = 1; x <= 2*W; x++){\n\t\t\tfor(y = 1; y <= 2*H; y++){\n\t\t\t\tmemo[x][y] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int bx = 1; bx <= W; bx++){\n\t\t\tfor(int by = 1; by <= H; by++){\n\t\t\t\tvec.clear();\n\t\t\t\t\n\t\t\t\tif(i) px = 2*bx, py = 2*by-1;\n\t\t\t\telse px = 2*bx-1, py = 2*by;\n\t\t\t\t\n\t\t\t\tint rx, ry, d = gcd(px, py);\n\t\t\t\trx = px / d, ry = py / d;\n\t\t\t\tif(memo[rx][ry] != -1){\n\t\t\t\t\tans = max(ans, memo[rx][ry]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(px > py){\n\t\t\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\t\t\ty = x*py/px;\n\t\t\t\t\t\tif(x % px){\n\t\t\t\t\t\t\tvec.push_back(f[x-1][y]);\n\t\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tvec.push_back(f[x-1][y-1]);\n\t\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int y = 1; y <= H; y++){\n\t\t\t\t\t\tx = y*px/py;\n\t\t\t\t\t\tif(y % py){\n\t\t\t\t\t\t\tvec.push_back(f[x][y-1]);\n\t\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tvec.push_back(f[x-1][y-1]);\n\t\t\t\t\t\t\tvec.push_back(f[x][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcnt = prev = 0;\n\t\t\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\t\t\tif(prev != vec[i]) cnt++;\n\t\t\t\t\tprev = vec[i];\n\t\t\t\t}\n\t\t\t\tmemo[rx][ry] = cnt;\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans / 2 + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nbool lkado(vector<string> &v, int i, int j) {\n  char c = v[i+1][j];\n  return c != v[i][j] && c != v[i][j+1] && c != v[i+1][j+1];\n}\nbool rkado(vector<string> &v, int i, int j) {\n  char c = v[i][j+1];\n  return c != v[i][j] && c != v[i+1][j] && c != v[i+1][j+1];\n}\nbool inkado(vector<string> &v, int i, int j) {\n  return v[i][j] == '.' && v[i][j] == '#';\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int h, w; cin >> h >> w;\n  vector<string> v(h);\n  for(int i=0;i<(h);++i) {\n    cin >> v[i];\n  }\n  reverse((v).begin(),(v).end());\n  vvi kado(h-1, vi (w-1, -1));\n  for(int i=0;i<(h-1);++i) {\n    for(int j=0;j<(w-1);++j) {\n      if(lkado(v, i, j)) {\n        kado[i][j] = 0;\n      } else if(rkado(v, i, j)) {\n        kado[i][j] = 1;\n      } else if(inkado(v, i, j)) {\n        kado[i][j] = 2;\n      }\n    }\n  }\n  int ma = 0;\n  for(int i=0;i<(h);++i) {\n    for(int j=0;j<(w);++j) {\n      if(i != h-1 && j != w-1 && kado[i][j] == -1) continue;\n      int l = 0, r = 0;\n      int g = __gcd(i+1, j+1);\n      int tmpi = (i+1)/g, tmpj = (j+1)/g;\n      for(int k=0;k<(h-1);++k) {\n        if((k+1) % tmpi == 0) {\n          int idx = (k+1)*tmpj/tmpi-1;\n          if(idx >= w-1) continue;\n          int nowkado = kado[k][idx];\n          if(nowkado == 0) {\n            l++;\n          } else if(nowkado == 1) {\n            r++;\n          } else if(nowkado == 2) {\n            l++;\n            r++;\n          }\n        } else {\n          double tmp = (double)(k+1) * tmpj / tmpi;\n          int idx = floor(tmp);\n          if(idx >= w) continue;\n          if(v[k][idx] == '.' && v[k+1][idx] == '#') {\n            l++;\n            r++;\n          }\n        }\n      }\n      for(int k=0;k<(w-1);++k) {\n        if((k+1)%tmpj) {\n          double tmp = (double)(k+1) * tmpi / tmpj;\n          int idx = floor(tmp);\n          if(idx >= h) continue;\n          if(v[idx][k] == '.' && v[idx][k+1] == '#') {\n            l++;\n            r++;\n          }\n        }\n      }\n      chmax(ma, l);\n      chmax(ma, r);\n    }\n  }\n  cout << (ma + 1 + (v[0][0] == '#')) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint H, W;\nint count(int rx, int ry, const vector<string>& grid){\n    int res = 1;\n    int curr = 0;\n    bool state = false;\n    for(int x = 0; x < W; x++){\n        int next = ry * (x + 1) / rx;\n        for(int y = curr; y <= min(next, H - 1); y++){\n            char c = grid[y][x];\n            // printf(\"x = %d y = %d c = %c state = %d\\n\", x, y, c, state);\n            if(c == '#' && !state){\n                state = true;\n                res ++;\n            }else if(c == '.' && state){\n                state = false;\n            }\n        }\n        if(next >= H) break;\n        curr = next;\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> H >> W){\n        vector<string> grid(H);\n        REP(y, H) cin >> grid[H - 1 - y];\n\n        int ans = 0;\n        for(int y = 1; y <= H + 1; y++){\n            for(int x = 1; x <= W + 1; x++){\n                ans = max(ans, count(x, y, grid));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct PQ {\n\tint den, num;\n\tPQ(int den, int num) : den(den), num(num) {}\n};\nbool operator>(const PQ& pq1, const PQ& pq2) {\n\treturn pq1.num * pq2.den > pq1.den * pq2.num;\n}\nbool operator<(const PQ& pq1, const PQ& pq2) {\n\treturn pq2 > pq1;\n}\nbool operator==(const PQ& pq1, const PQ& pq2) {\n\treturn !(pq1 > pq2) && !(pq1 < pq2);\n}\nbool operator>=(const PQ& pq1, const PQ& pq2) {\n\treturn pq1 == pq2 || pq1 > pq2;\n}\nbool operator<=(const PQ& pq1, const PQ& pq2) {\n\treturn pq2 >= pq1;\n}\n\ntypedef pair<PQ, PQ> PQP;\n\nint H, W;\nvector<string> M;\nbool dot[601][601] = {0};\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nbool inRange2(int x, int y) {\n\treturn 0 <= x && x <= W && 0 <= y && y <= H;\n}\nbool isWall(int x, int y) {\n\tif ( !inRange(x, y) ) return false;\n\treturn M[y][x] == '#';\n}\nbool getDot(int x, int y) {\n\tif ( !inRange2(x, y) ) return false;\n\treturn dot[y][x];\n}\nbool moveCheck(int x1, int y1, int x2, int y2) {\n\tif ( !getDot(x2, y2) ) return false;\n\tmap<P, int> cnt;\n\tfor (int dy = -1; dy <= 0; ++dy) {\n\t\tfor (int dx = -1; dx <= 0; ++dx) {\n\t\t\tcnt[P(x1+dx, y1+dy)]++;\n\t\t\tcnt[P(x2+dx, y2+dy)]++;\n\t\t}\n\t}\n\tset<bool> s;\n\tfor ( pair<const P, int>& p : cnt ) {\n\t\tif (p.second == 2 ) {\n\t\t\ts.insert(isWall(p.first.first, p.first.second));\n\t\t}\n\t}\n\treturn s.size() == 2;\n}\nint moveX(int x0, int y0) {\n\tbool bfl = true, bfr = true;\n\tbool fl = true, fr = true;\n\tfor (int dx = 1; dx <= W+3; ++dx) {\n\t\tfr = fr && moveCheck(x0+dx-1, y0, x0+dx, y0);\n\t\tfl = fl && moveCheck(x0-(dx-1), y0, x0-dx, y0);\n\t\tif ( !fr && !fl ) {\n\t\t\tif (bfl) return x0-(dx-1);\n\t\t\treturn x0+dx-1;\n\t\t}\n\t\tbfl = fl, bfr = fr;\n\t}\n}\nint moveY(int x0, int y0) {\n\tbool bfl = true, bfr = true;\n\tbool fl = true, fr = true;\n\tfor (int dy = 1; dy <= H+3; ++dy) {\n\t\tfr = fr && moveCheck(x0, y0+(dy-1), x0, y0+dy);\n\t\tfl = fl && moveCheck(x0, y0-(dy-1), x0, y0-dy);\n\t\tif ( !fr && !fl ) {\n\t\t\tif (bfl) return y0-(dy-1);\n\t\t\treturn y0+dy-1;\n\t\t}\n\t\tbfl = fl, bfr = fr;\n\t}\n}\n\nPQ f(int x, int y) {\n\treturn PQ(x, y);\n}\n\nint da = 0;\nvector<PQP> r;\nvoid addLine(int x1, int y1, int x2, int y2) {\n\ty1 = H-y1, y2 = H-y2;\n\tif ((x1 == 0 && y1 == 0) || (x2 == 0 && y2 == 0)) {\n\t\tda = 1;\n\t\treturn;\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << (double)y1/x1 << \" \" << (double)y2/x2 << endl;\n\tPQ pq1 = f(x1, y1);\n\tPQ pq2 = f(x2, y2);\n\tif (pq2 < pq1) swap(pq1, pq2);\n\tr.push_back( PQP(pq1, pq2) );\n}\nsigned main() {\n\tcin >> H >> W;\n\tM.resize(H);\n\tfor (int i = 0; i < H; ++i) cin >> M[i];\n\tfor (int y = 0; y <= H; ++y) {\n\t\tfor (int x = 0; x <= W; ++x) {\n\t\t\tset<bool> s;\n\t\t\tfor (int dx = -1; dx <= 0; ++dx) {\n\t\t\t\tfor (int dy = -1; dy <= 0; ++dy) {\n\t\t\t\t\ts.insert( isWall(x+dx, y+dy) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tdot[y][x] = s.size() == 2;\n\t\t}\n\t}\n\tint sx = -1, sy = -1;\n\tfor (int y = 0; y < H; ++y) {\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tif ( isWall(x, y) ) {\n\t\t\t\tsx = x, sy = y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sx >= 0) break;\n\t}\n\t{\n\t\tint x = sx, y = sy;\n\t\twhile (1) {\n\t\t\tint nx = moveX(x, y);\n\t\t\tint ny = moveY(nx, y);\n//\t\t\tassert(nx != x);\n//\t\t\tassert(ny != y);\n\t\t\taddLine(x, y, nx, y);\n\t\t\taddLine(nx, y, nx, ny);\n\t\t\tif (nx == sx && ny == sy) break;\n\t\t\tx = nx, y = ny;\n\t\t}\n\t\tsort(r.begin(), r.end());\n\t\tint mx = 0;\n\t\tmap<PQ, int> m;\n\t\t{\n\t\t\tvector<PQ> v;\n\t\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\t\tv.push_back(r[i].first);\n\t\t\t\tv.push_back(r[i].second);\n\t\t\t}\n\t\t\tsort(v.begin(), v.end());\n\t\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t\t\tfor (int i = 0; i < v.size(); ++i) {\n\t//\t\t\tcout << v[i].first.num << \" \" << v[i].\n\t\t\t\tm[v[i]] = i+1;\n\t\t\t}\n\t\t\tmx = v.size();\n\t\t}\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < r.size(); ++i) {\n//\t\t\tcout << r[i].first.den << \" \" << r[i].first.num << \" \" << r[i].second.den << \" \" << r[i].second.num << endl;\n\t\t}\n\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\tv.push_back( P(m[r[i].first]-1, m[r[i].second]-1) );\n\t\t}\n\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\tv[i] = P(v[i].first*2, v[i].second*2);\n\t\t}\n\t\tfor (int i = 0; i < v.size(); ++i) {\n//\t\t\tcout << v[i].first << \" \" << v[i].second << endl;\n\t\t}\n\t\tvector<int> cnt(mx*3, 0);\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tif (v[i].first < v[i].second) {\n\t\t\t\t++cnt[v[i].first+1];\n\t\t\t\t--cnt[v[i].second];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < cnt.size(); ++i) {\n\t\t\tcnt[i] += cnt[i-1];\n\t\t}\n/*\n\t\t{\n\t\t\tset<P> s;\n\t\t\tfor (int i = 0; i < r.size(); ++i) {\n\t\t\t\ts.insert( P(r[i].first.den, r[i].first.num) );\n\t\t\t\ts.insert( P(r[i].second.den, r[i].second.num) );\n\t\t\t}\n\t\t\tfor ( const P& p : s ) {\n\t\t\t\tint x = p.first, y = H-p.second;\n\t\t\t\tint d = 0;\n\t\t\t\td += isWall(x-1, y);\n\t\t\t\td += isWall(x, y-1);\n\t\t\t\tcnt[(m[PQ(p.first, p.second)]-1)*2] += d;\n\t\t\t\tcout << x << \" \" << y << \" \" << d << \" \" << m[PQ(p.first, p.second)]-1 << endl;\n\t\t\t}\n\t\t}\n//\t\tcout << cnt[4] << endl;\n//\t\tcout << m[PQ(1, 1)] << endl;\n*/\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < cnt.size(); ++i) {\n//\t\t\tif (cnt[i] > ans) cout << i << endl;\n\t\t\tans = max(ans, cnt[i]);\n\t\t}\n\t\tans += da;\n//\t\tcout << ans << endl;\n\t\tassert(ans%2 == 0);\n\t\tcout << ans/2+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\n\nint main(){\n  // ????????§???????§£???????????????????????\\???????§£????????????. \n  //   http://mofupp.info/pukiwiki/?plugin=attach&pcmd=open&file=2011-4A_pes.cpp&refer=ICPC%2FSummerCamp%2F2011_4A\n  int H, W;\n  while (cin >> H >> W){\n    vector<string> B(H);\n    REP(i, H) cin >> B[H - 1 - i];\n\n    vector<pair<double, int> > events;\n\n    REP(i, H + 1) REP(j, W + 1) if (i){\n      int count = 0;\n      REP(k, 4){\n        int ni = i - k % 2;\n        int nj = j - k / 2;\n        if (0 <= ni && ni < H && 0 <= nj && nj < W && B[ni][nj] == '#'){\n          count++;\n        }\n      }\n\n      if (count % 2 == 0) continue;\n\n\n      if (0 <= i - 1 && j < W && B[i - 1][j] == (count == 1 ? '#' : '.')){\n        events.emplace_back((double)j / i, 1);\n      }\n\n      if (i < H && 0 <= j - 1 && B[i][j - 1] == (count == 1 ? '#' : '.')){\n        events.emplace_back((double)j / i, -1);\n      }\n    }\n    \n    sort(ALL(events));\n    \n\n    int res = 1;\n    int cur = 1;\n    for (size_t i = 0; i < events.size();){\n      double p = events[i].first;\n      while (i < events.size() && abs(events[i].first - p) < 1e-6){\n        cur += events[i++].second;\n      }\n      res = max(res, cur);\n    }\n    cout << res << endl;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int W = 666;\nconst int INF = 1000000007;\nint h,w;\nvector<string> board;\n\nbool input(){\n\tcin>>h>>w;\n\tboard.clear();\n\trep(i,h){\n\t\tstring s;\n\t\tcin>>s;\n\t\tboard.pb(s);\n\t}\n\treturn true;\n}\n\nint gcd(int n, int m) {\n\treturn (n % m) ? gcd(m, n %m) : m;\n}\n\nint isBlock(char c){\n\tif(c=='#')return 1;\n\treturn 0;\n}\n\nint getState(int y,int x){\n\tint ret = 0;\n\tret += (1<<0)*isBlock(board[y][x-1]);\n\tret += (1<<1)*isBlock(board[y][x]);\n\tret += (1<<2)*isBlock(board[y-1][x-1]);\n\tret += (1<<3)*isBlock(board[y-1][x]);\n\treturn ret;\n}\n\nint cup[16];\nint cdown[16];\n\nint _cup(int state){\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 2;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 0;\n\t\tcase 8:return 0;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 2;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n\t\n}\n\nint _cdown(int state){\n\tswitch(state){\n\t\tcase 0:return 0;\n\t\tcase 1:return 0;\n\t\tcase 2:return 1;\n\t\tcase 3:return 1;\n\t\tcase 4:return 1;\n\t\tcase 5:return 1;\n\t\tcase 6:return 2;\n\t\tcase 7:return 2;\n\t\tcase 8:return 2;\n\t\tcase 9:return 2;\n\t\tcase 10:return 1;\n\t\tcase 11:return 1;\n\t\tcase 12:return 1;\n\t\tcase 13:return 1;\n\t\tcase 14:return 0;\n\t\tcase 15:return 0;\n\t}\n\treturn -INF;\n}\n\nvoid setCount(){\n\trep(i,16)cup[i] = _cup(i);\n\trep(i,16)cdown[i] = _cdown(i);\n}\n\nint getCountUp(int y,int x){\n\tint state = getState(y,x);\n\t\n\treturn cup[state];\n\t\n}\n\nint getCountDown(int y,int x){\n\t\n\tint state = getState(y,x);\n\t\n\treturn cdown[state];\n}\n\nint splitCount(int y,int x){\n\t\n\t\n\t\n\tint countUp = 0;\n\tint countDown = 0;\n\t\n\treps(i,1,w+1){\n        double dy = (double)y/x;\n        if(i%x==0){\n            int ny = y*(i/x);\n            int nx = i;\n            if(ny>h)break;\n             \n            int dup = getCountUp(ny,nx);\n            int ddown = getCountDown(ny,nx);\n             \n            if(x==2 && y==1 || true){\n                //printf(\"nx=%d  ny=%d,  dup=%d  ddown=%d\\n\",nx,ny,dup,ddown);\n            }\n             \n            countUp += dup;\n            countDown += ddown;\n        }\n    }\n     \n\t\n\treps(i,1,w+1){\n\t\tdouble dy = (double)y/x;\n\t\tif(i%x!=0){\n\t\t\tdouble ny = dy*i;\n\t\t\t\n\t\t\tint nh = (int)ny;\n\t\t\tif(nh>h)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[nh][i-1];\n\t\t\tchar right = board[nh][i];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\treps(i,1,h+1){\n\t\t\n\t\tdouble dx = (double)x/y;\n\t\tif(i%y!=0){\n\t\t\tdouble nx = dx*i;\n\t\t\t\n\t\t\tint nh = (int)nx;\n\t\t\tif(nh>w)break;\n\t\t\t\n\t\t\t\n\t\t\tchar left = board[i-1][nh];\n\t\t\tchar right = board[i][nh];\n\t\t\t\n\t\t\tif(left!=right){\n\t\t\t\tcountUp++;\n\t\t\t\tcountDown++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans1 = (countUp+1)/2 + 1;\n\tint ans2 = (countDown+1)/2 + 1;\n\t\n\t//printf(\"x=%d y=%d  up=%d  down=%d\\n\",x,y,countUp, countDown);\n\t\n\treturn max(ans1, ans2);\n}\n\nvoid addBanpei(){\n\treverse(board.begin(), board.end());\n\trep(i,board.size()){\n\t\tboard[i] += \".\";\n\t}\n\tstring tmp = \"\";\n\trep(i,w+1)tmp += \".\";\n\tboard.pb(tmp);\n}\n\nvoid solve(){\n\t\n\taddBanpei();\n\tsetCount();\n\t\n\tint ans = 0;\n\treps(i,1,h+1){\n\t\treps(j,1,w+1){\n\t\t\tif(gcd(i,j)==1){\n\t\t\t\tint sp = splitCount(i,j);\n\t\t\t\tans = max(ans, sp);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> s(h+2, string(w+2, '.'));\n\tfor(int i=1; i<=h; ++i){\n\t\tfor(int j=1; j<=w; ++j){\n\t\t\tcin >> s[i][j];\n\t\t}\n\t}\n\n\tvector<pair<double, bool> > corner;\n\tfor(int y=1; y<=h; ++y){\n\t\tfor(int x=1; x<=w; ++x){\n\t\t\tif(s[y][x-1] != s[y][x] && s[y-1][x] != s[y][x]){\n\t\t\t\tdouble tmp = atan2(h-y+1.0, x-1.0);\n\t\t\t\tcorner.push_back(make_pair(tmp, false));\n\t\t\t}\n\t\t\tif(s[y][x+1] != s[y][x] && s[y+1][x] != s[y][x]){\n\t\t\t\tdouble tmp = atan2(h-y, (double)x);\n\t\t\t\tcorner.push_back(make_pair(tmp, true));\n\t\t\t}\n\t\t}\n\t}\n\tsort(corner.begin(), corner.end());\n\n\tint m = corner.size();\n\tint num = 1;\n\tint ret = 1;\n\tfor(int i=0; i<m; ++i){\n\t\tif(corner[i].second)\n\t\t\t++ num;\n\t\telse\n\t\t\t-- num;\n\t\tif(i < m-1 && corner[i+1].first - corner[i].first < EPS)\n\t\t\tcontinue;\n\t\tret = max(ret, num);\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<double,int> Pa;\nvector<Pa> v;\n\nint W,H;\nchar fie[605][605];\n\ndouble getAngle(P a, P b ){\n  return atan2(b.real()-a.real(),b.imag()-a.imag());\n}\n\nint main(){\n  cin >> H >> W;\n  for(int i=0;i<=H+1;i++)\n    for(int j=0;j<=W+1;j++)\n      fie[j][i] = '.';\n\n  for(int i=1;i<=H;i++)\n    for(int j=1;j<=W;j++)\n      cin >> fie[j][i];\n\n  P o = P(1,H+1);\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      if( fie[j][i] == '#' ){\n        if( fie[j-1][i] == '.' &&\n            fie[j-1][i-1] == '.' &&\n            fie[j][i-1] == '.' ) {\n          v.push_back( Pa(getAngle(o,P(j,i)),1) );\n        }\n        if( fie[j+1][i] == '#' &&\n            fie[j+1][i+1] == '.' &&\n            fie[j][i+1] == '#' ) {\n          v.push_back( Pa(getAngle(o,P(j+1,i+1)),1) );\n        }\n\n        if( fie[j+1][i] == '.' &&\n            fie[j+1][i+1] == '.' &&\n            fie[j][i+1] == '.' ) {\n          v.push_back( Pa(getAngle(o,P(j+1,i+1)), -1) );\n        }\n        if( fie[j-1][i] == '#' &&\n            fie[j-1][i-1] == '.' &&\n            fie[j][i-1] == '#' ) {\n          v.push_back( Pa(getAngle(o,P(j,i)),-1) );\n        } \n      }\n    }\n  }\n  sort(v.rbegin(),v.rend());\n  int res = 1;\n  int cnt = 1;\n  for(int i=0;i<(int)v.size();i++){\n    //  cout << v[i].first / 2.0 / M_PI * 360.0 << \" \" << v[i].second << endl;\n    cnt += v[i].second;\n    if( i == (int)v.size()-1 ||  abs(v[i+1].first - v[i].first) > 1e-8 )\n      res = max( res, cnt );\n  } \n  cout << res << endl;\n      \n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2310 Rose Garden Witch\n// 2018.3.13 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct { double a; int f; } T;\nT tbl[100000]; int sz;\nchar map[605][605];\nint f[16] = {0,-1,0,0,0,0,0,1,1,0,0,0,0,0,-1,0};\n\nint cmp(T *a, T *b) {\n\tif (fabs(a->a - b->a) < 1e-7) return a->f - b->f;\n\tif (a->a <= b->a) return -1; return 1;\n}\n\nint main()\n{\n\tint H, W, r, c, t, i, ans;\n\tchar buf[20];\n\n\tfgets(buf, 10, stdin), sscanf(buf, \"%d%d\", &H, &W);\n\tfor (r = 1; r <= H; r++) {\n\t\tfgets(map[r], 603, stdin);\n\t\tfor (c = 1; c <= W; c++) map[r][c] &= 1; map[r][c] = 0;\n\t}\n\n\tsz = 0;\tfor (r = 0; r <= H; r++) for (c = 0; c <= W; c++) {\n\t\tint x = ((map[r][c]<<3) | (map[r][c+1]<<2) | (map[r+1][c]<<1) | map[r+1][c+1]) & 0xf;\n\t\tif (f[x]) tbl[sz].a = atan2(H-r, c+1), tbl[sz++].f = f[x];\n\t}\n\n\tqsort(tbl, sz, sizeof(T), cmp);\n\tans = 0; for (t = 1, i = 0; i < sz; i++) if ((t += tbl[i].f) > ans) ans = t;\n\tif (ans < 2) ans = 2;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2310 Rose Garden Witch\n// 2018.3.14 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct { double a; int f; } T;\nT tbl[100000]; int sz;\nchar map[605][605];\nint f[16] = {0,-1,0,0,0,0,0,1,1,0,0,0,0,0,-1,0};\n\nint cmp(T *a, T *b) {\n\tif (fabs(a->a - b->a) < 1e-7) return a->f - b->f;\n\tif (a->a <= b->a) return -1; return 1;\n}\n\nint main()\n{\n\tint H, W, r, c, t, i, ans;\n\tchar buf[20];\n\n\tfgets(buf, 10, stdin), sscanf(buf, \"%d%d\", &H, &W);\n\tfor (r = 1; r <= H; r++) {\n\t\tfgets(map[r]+1, 603, stdin);\n\t\tfor (c = 1; c <= W; c++) map[r][c] &= 1; map[r][c] = 0;\n\t}\n\n\tsz = 0;\tfor (r = 0; r <= H; r++) for (c = 0; c <= W; c++) {\n\t\tint x = ((map[r][c]<<3) | (map[r][c+1]<<2) | (map[r+1][c]<<1) | map[r+1][c+1]) & 0xf;\n\t\tif (f[x]) tbl[sz].a = atan2(H-r, c), tbl[sz++].f = f[x];\n\t}\n\n\tqsort(tbl, sz, sizeof(T), cmp);\n\tans = 0; for (t = 1, i = 0; i < sz; i++) if ((t += tbl[i].f) > ans) ans = t;\n\tif (ans < 2) ans = 2;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tdouble EPS = 1e-8;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] table = new char[h][w];\n\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\ttable[i] = sc.next().toCharArray();\n\t\t}\n\t\tArrayList<Pair> vd = new ArrayList<>();\n\t\tfor (int i = 0; i <= h; i++) {\n\t\t\tfor (int j = 0; j <= w; j++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ni = i - (k & 1);\n\t\t\t\t\tint nj = j - (k >> 1);\n\t\t\t\t\tif (0 <= ni && ni < h && 0 <= nj && nj < w && table[ni][nj] == '#')\n\t\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt % 2 == 1) {\n\t\t\t\t\tif (0 <= i - 1 && i - 1 < h && 0 <= j && j < w && table[i - 1][j] == (cnt == 1 ? '#' : '.')) {\n\t\t\t\t\t\t// |# .|. #|\n\t\t\t\t\t\t// |# #|. .|\n\t\t\t\t\t\t// System.out.println(j + \" \" + i);\n\t\t\t\t\t\tif (j != 0) {\n\t\t\t\t\t\t\tvd.add(new Pair(((double) i) / ((double) j), 1, j, i));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvd.add(new Pair(1e9, 1, j, i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (0 <= i && i < h && 0 <= j - 1 && j - 1 < w && table[i][j - 1] == (cnt == 1 ? '#' : '.')) {\n\t\t\t\t\t\t// |# #|. .|\n\t\t\t\t\t\t// |. #|# .|\n\t\t\t\t\t\tvd.add(new Pair(((double) i) / ((double) j), -1, j, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvd.sort(new Comparator<Pair>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\treturn -Double.compare(o1.a, o2.a);\n\t\t\t}\n\t\t});\n\t\tint res = 1, cur = 1;\n\t\tfor (int i = 0; i < vd.size();) {\n\t\t\tint idx = i;\n\t\t\twhile (idx < vd.size() && Math.abs(vd.get(i).a - vd.get(idx).a) < EPS) {\n//\t\t\t\tSystem.out.println(\"diff\" + vd.get(idx).b + \" tan\" + vd.get(idx).a + \" cur\" + cur + \" x\" + vd.get(idx).x\n//\t\t\t\t\t\t+ \" y\" + vd.get(idx).y);\n\t\t\t\tcur += vd.get(idx).b;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\ti = idx;\n\t\t\tres = Math.max(cur, res);\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tclass Pair {\n\t\tdouble a;\n\t\tint b;\n\t\tint x, y;\n\n\t\tPair(double a, int b, int x, int y) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tdouble EPS = 1e-8;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] table = new char[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\ttable[i] = sc.next().toCharArray();\n\t\t}\n\t\tArrayList<Pair> vd=new ArrayList<>();\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=0;j<=w;j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni=i-k%2;\n\t\t\t\t\tint nj=j-k/2;\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&table[ni][nj]=='#')\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\tif(cnt%2==1){\n\t\t\t\t\t\tif(0<=i-1&&i-1<h&&0<=j&&j<w&&table[i-1][j]==(cnt==1?'#':'.'))\n\t\t\t\t\t\t\tvd.add(new Pair((double)j/i,1));\n\t\t\t\t\t\tif(0<=i&&i<h&&0<=j-1&&j-1<w&&table[i][j-1]==(cnt==1?'#':'.'))\n\t\t\t\t\t\t\tvd.add(new Pair((double)j/i,-1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvd.sort(null);\n\t\tint res=1,cur=1;\n\t\tfor(int i=0;i<vd.size();i++){\n\t\t\tint idx=i;\n\t\t\twhile(idx<vd.size()&&Math.abs(vd.get(i).a-vd.get(idx).a)<EPS){\n\t\t\t\tcur+=vd.get(idx++).b;\n\t\t\t}\n\t\t\ti=idx;\n\t\t\tres=Math.max(cur, res);\n\t\t}\n\t\tSystem.out.println(res);\n\n\t}\n\n\tclass Pair implements Comparable<Pair>{\n\t\tdouble a;\n\t\tint b;\n\n\t\tPair(double a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn Double.compare(this.a, o.a);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tdouble EPS = 1e-8;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] table = new char[h][w];\n\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\ttable[i] = sc.next().toCharArray();\n\t\t}\n\t\tArrayList<Pair> vd = new ArrayList<>();\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 0; j <= w; j++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ni = i - k % 2;\n\t\t\t\t\tint nj = j - k / 2;\n\t\t\t\t\tif (0 <= ni && ni < h && 0 <= nj && nj < w && table[ni][nj] == '#')\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\tif (cnt % 2 == 1) {\n\t\t\t\t\t\tif (0 <= i - 1 && i - 1 < h && 0 <= j && j < w && table[i - 1][j] == (cnt == 1 ? '#' : '.')) {\n\t\t\t\t\t\t\t// # .\t\t. #\n\t\t\t\t\t\t\t// # #\t\t. .\n\t\t\t\t\t\t\tvd.add(new Pair((double) j / (double) i, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= i && i < h && 0 <= j - 1 && j - 1 < w && table[i][j - 1] == (cnt == 1 ? '#' : '.')) {\n\t\t\t\t\t\t\t// # #\t\t. .\n\t\t\t\t\t\t\t// . # \t\t# .\n\t\t\t\t\t\t\tvd.add(new Pair((double) j / (double) i, -1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvd.sort(null);\n\t\tint res = 1, cur = 1;\n\t\tfor (int i = 0; i < vd.size(); i++) {\n\t\t\tint idx = i;\n\t\t\twhile (idx < vd.size() && Math.abs(vd.get(i).a - vd.get(idx).a) < EPS) {\n\t\t\t\tcur += vd.get(idx++).b;\n\t\t\t}\n\t\t\ti = idx;\n\t\t\tres = Math.max(cur, res);\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble a;\n\t\tint b;\n\n\t\tPair(double a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn Double.compare(this.a, o.a);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tchar[][] f = new char[H + 2][W + 2];\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tchar[] row = sc.next().toCharArray();\n\t\t\tSystem.arraycopy(row, 0, f[H - i], 1, W);\n\t\t}\n\t\tArrayList<State> states = new ArrayList<State>();\n\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\t\tif (f[i][j] == '#' && f[i - 1][j] != '#' && f[i][j + 1] != '#') {\n\t\t\t\t\tstates.add(new State(Math.atan2(i - 1, j), 1));\n\t\t\t\t} else if (f[i][j] != '#' && f[i - 1][j] == '#' && f[i][j + 1] == '#') {\n\t\t\t\t\tstates.add(new State(Math.atan2(i - 1, j), 1));\n\t\t\t\t} else if (f[i][j] == '#' && f[i + 1][j] != '#' && f[i][j - 1] != '#') {\n\t\t\t\t\tstates.add(new State(Math.atan2(i, j - 1), -1));\n\t\t\t\t} else if (f[i][j] != '#' && f[i + 1][j] == '#' && f[i][j - 1] == '#') {\n\t\t\t\t\tstates.add(new State(Math.atan2(i, j - 1), -1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(states);\n\t\tint count = 1;\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < states.size();) {\n\t\t\tState st = states.get(i);\n\t\t\twhile (i < states.size() && states.get(i).a - st.a < 1e-8) {\n\t\t\t\tcount += states.get(i).add;\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tans = Math.max(ans, count);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic class State implements Comparable<State> {\n\t\tdouble a;\n\t\tint add;\n\n\t\tpublic State(double a, int add) {\n\t\t\tthis.a = a;\n\t\t\tthis.add = add;\n\t\t}\n\n\t\tpublic int compareTo(State o) {\n\t\t\treturn Double.compare(this.a, o.a);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint main(){\n\tint H, W;\n\tstring f[600];\n\twhile(cin >> H >> W){\n\t\tfor(int i=H-1;i>=0;i--) cin >> f[i];\n\n\t\tvector< pair<double, int> > vd;\n\t\t// ????????°??????????????????????????????.\n\t\t// ??????(j/i)?????§??????????????¨??????????????°????¢????????????£?????????\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=0;j<=W;j++){\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i-k%2, nj = j-k/2;\n\t\t\t\t\tif(0<=ni&&ni<H&&0<=nj&&nj<W&&f[ni][nj]=='#') cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt%2 == 1){\n\t\t\t\t\tif(0<=i-1&&i-1<H&&0<=j&&j<W&&f[i-1][j]==(cnt==1?'#':'.'))\n\t\t\t\t\t\tvd.push_back(make_pair((double)j/i,  1));\n\t\t\t\t\tif(0<=i&&i<H&&0<=j-1&&j-1<W&&f[i][j-1]==(cnt==1?'#':'.'))\n\t\t\t\t\t\tvd.push_back(make_pair((double)j/i, -1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vd.begin(), vd.end());\n\n\t\tint res = 1, cur = 1;\n\t\t// ???????????§?????????????????????????????°????¢????????????????\n\t\tfor(int i=0;i<vd.size(); ){\n\t\t\tint idx = i;\n\t\t\twhile(idx < vd.size() && abs(vd[i].first-vd[idx].first) < EPS)\n\t\t\t\tcur += vd[idx++].second;\n\t\t\ti = idx;\n\t\t\tres = max(cur, res);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var h = ri;\n            var w = ri;\n            var mat = Enumerate(h + 2, x => new char[w + 2]);\n            for (int i = 0; i < h + 2; i++)\n                for (int j = 0; j < w + 2; j++)\n                    mat[i][j] = '.';\n            var ev = new List<KeyValuePair<Complex, int>>();\n            for (int i = 0; i < h; i++)\n            {\n                var s = rs;\n                for (int j = 0; j < w; j++)\n                    mat[i + 1][j + 1] = s[j];\n            }\n            for (int i = 0; i <= h; i++)\n                for (int j = 0; j <= w; j++)\n                {\n                    var v = f(mat[i][j], mat[i][j + 1], mat[i + 1][j], mat[i + 1][j + 1]);\n                    var p = new Point(j, h - i);\n                    if (v != 0)\n                        ev.Add(new KeyValuePair<Point, int>(p, v));\n                }\n            ev.Sort((l, r) =>\n            {\n                var u = l.Key.Phase.CompareTo(r.Key.Phase);\n                if (u != 0) return u;\n                else return l.Value.CompareTo(r.Value);\n            });\n            var all = 1;\n            var ans = 1;\n            foreach (var e in ev)\n            {\n                all += e.Value;\n                ans = Max(ans, all);\n            }\n            Console.WriteLine(ans);\n        }\n        int f(char a, char b, char c, char d) {\n            if (a == '#' && b == '.' && c == '.' && d == '.') return 1;\n            if (a == '.' && b == '#' && c == '#' && d == '#') return 1;\n            if (a == '#' && b == '#' && c == '#' && d == '.') return -1;\n            if (a == '.' && b == '.' && c == '.' && d == '#') return -1;\n            return 0;\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nrequire 'mathn'\n\nh, w = gets.split.map &:to_i\nf = []\n\nh.times do\n\tf.unshift gets.chomp.split(\"\")\nend\nf.reverse.each{|x| puts x.join}\n\nas = Set.new\nlines = []\n\n(0..h).each do |y|\n\tx = 0\n\tlen = 0\n\tloop do\n\t\tif (y != 0 && f[y-1][x] == ?#) ^ (y != h && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\tlines << [[x - len, y], [x, y]]\n\t\t\t\tas << y / x\n\t\t\t\tas << y / (x - len) unless x - len == 0\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\tx += 1\n\n\t\tif x == w\n\t\t\tif len > 0\n\t\t\t\tlines << [[x - len, y], [x, y]]\n\t\t\t\tas << y / x\n\t\t\t\tas << y / (x - len) unless x - len == 0\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend\n\n(0..w).each do |x|\n\ty = 0\n\tlen = 0\n\tloop do\n\t\tif (x != 0 && f[y][x-1] == ?#) ^ (x != w && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\tlines << [[x, y - len], [x, y]]\n\t\t\t\tas << y / x unless x == 0\n\t\t\t\tas << (y - len) / x unless x == 0\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\ty += 1\n\n\t\tif y == h\n\t\t\tif len > 0\n\t\t\t\tlines << [[x, y - len], [x, y]]\n\t\t\t\tas << y / x unless x == 0\n\t\t\t\tas << (y - len) / x unless x == 0\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend \n\nas.delete(0)\n\np as.map {|a|\n\ta -= 1 / 1000000\t\n\t#y - a x = 0\n\tk = 0\n\tlines.each do |(x1, y1), (x2, y2)|\n\t\tk += 1 if (y1 - a * x1) * (y2 - a * x2) <= 0\n\tend\n\tk -= 1 if f[0][0] == ?#\n\tk / 2 + 1\n}.max"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef Rational(y, x)\n    y / x.to_f\nend\n\nclass Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nh, w = gets.split.map &:to_i\nf = []\n\nh.times do\n\tf.unshift gets.chomp.split(\"\")\nend\n\nas = Set.new\n\nh_lines = (0..h).map { [] }\n(0..h).each do |y|\n\tx = 0\n\tlen = 0\n\tloop do\n\t\tif (y != 0 && f[y-1][x] == ?#) ^ (y != h && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\th_lines[y] << [x - len, x]\n\t\t\t\tas << Rational(y, x)\n\t\t\t\tas << Rational(y, x - len) unless x - len == 0\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\tx += 1\n\n\t\tif x == w\n\t\t\tif len > 0\n\t\t\t\th_lines[y] << [x - len, x]\n\t\t\t\tas << Rational(y, x)\n\t\t\t\tas << Rational(y, x - len) unless x - len == 0\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend\n\nv_lines = (0..w).map { [] }\n(0..w).each do |x|\n\ty = 0\n\tlen = 0\n\tloop do\n\t\tif (x != 0 && f[y][x-1] == ?#) ^ (x != w && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\tv_lines[x] << [y - len, y]\n\t\t\t\tas << Rational(y, x) unless x == 0\n\t\t\t\tas << Rational(y - len, x) unless x == 0\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\ty += 1\n\n\t\tif y == h\n\t\t\tif len > 0\n\t\t\t\tv_lines[x] << [y - len, y]\n\t\t\t\tas << Rational(y, x) unless x == 0\n\t\t\t\tas << Rational(y - len, x) unless x == 0\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend \n\nas << Float::INFINITY\na_map = compress(as)\n\npile = [0] * a_map.size\n\n(1..h).each do |y|\n\th_lines[y].each do |x1, x2|\n\t\ti = a_map[x1 == 0 ? Float::INFINITY : Rational(y, x1)]\n\t\tj = a_map[Rational(y, x2)]\n\t\tpile[j] += 1\n\t\tpile[i] -= 1\n\tend\nend\n\n(1..w).each do |x|\n\tv_lines[x].each do |y1, y2|\n\t\ti = a_map[Rational(y1, x)]\n\t\tj = a_map[Rational(y2, x)]\n\t\tpile[i] += 1\n\t\tpile[j] -= 1\n\tend\nend\n\nk = pile.accum.max\nk += 1 if f[0][0] == ?#\np k / 2 + 1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nh, w = gets.split.map &:to_i\nf = []\n\nh.times do\n\tf.unshift gets.chomp.split(\"\")\nend\n\nas = Set.new\n\nh_lines = (0..h).map { [] }\n(0..h).each do |y|\n\tx = 0\n\tlen = 0\n\tloop do\n\t\tif (y != 0 && f[y-1][x] == ?#) ^ (y != h && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\th_lines[y] << [x - len, x]\n\t\t\t\tas << Rational(y, x)\n\t\t\t\tas << Rational(y, x - len) unless x - len == 0\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\tx += 1\n\n\t\tif x == w\n\t\t\tif len > 0\n\t\t\t\th_lines[y] << [x - len, x]\n\t\t\t\tas << Rational(y, x)\n\t\t\t\tas << Rational(y, x - len) unless x - len == 0\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend\n\nv_lines = (0..w).map { [] }\n(0..w).each do |x|\n\ty = 0\n\tlen = 0\n\tloop do\n\t\tif (x != 0 && f[y][x-1] == ?#) ^ (x != w && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\tv_lines[x] << [y - len, y]\n\t\t\t\tas << Rational(y, x) unless x == 0\n\t\t\t\tas << Rational(y - len, x) unless x == 0\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\ty += 1\n\n\t\tif y == h\n\t\t\tif len > 0\n\t\t\t\tv_lines[x] << [y - len, y]\n\t\t\t\tas << Rational(y, x) unless x == 0\n\t\t\t\tas << Rational(y - len, x) unless x == 0\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend \n\nas << Float::INFINITY\na_map = compress(as)\n\npile = [0] * a_map.size\n\n(1..h).each do |y|\n\th_lines[y].each do |x1, x2|\n\t\ti = a_map[x1 == 0 ? Float::INFINITY : Rational(y, x1)]\n\t\tj = a_map[Rational(y, x2)]\n\t\tpile[j] += 1\n\t\tpile[i] -= 1\n\tend\nend\n\n(1..w).each do |x|\n\tv_lines[x].each do |y1, y2|\n\t\ti = a_map[Rational(y1, x)]\n\t\tj = a_map[Rational(y2, x)]\n\t\tpile[i] += 1\n\t\tpile[j] -= 1\n\tend\nend\n\nk = pile.accum.max\nk += 1 if f[0][0] == ?#\np k / 2 + 1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nrequire 'mathn'\n\nh, w = gets.split.map &:to_i\nf = []\n\nh.times do\n\tf.unshift gets.chomp.split(\"\")\nend\n\nas = Set.new\nlines = []\n\n(0..h).each do |y|\n\tx = 0\n\tlen = 0\n\tloop do\n\t\tif (y != 0 && f[y-1][x] == ?#) ^ (y != h && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\tlines << [[x - len, y], [x, y]]\n\t\t\t\tas << y / x\n\t\t\t\tas << y / (x - len) unless x - len == 0\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\tx += 1\n\n\t\tif x == w\n\t\t\tif len > 0\n\t\t\t\tlines << [[x - len, y], [x, y]]\n\t\t\t\tas << y / x\n\t\t\t\tas << y / (x - len) unless x - len == 0\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend\n\n(0..w).each do |x|\n\ty = 0\n\tlen = 0\n\tloop do\n\t\tif (x != 0 && f[y][x-1] == ?#) ^ (x != w && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\tlines << [[x, y - len], [x, y]]\n\t\t\t\tas << y / x unless x == 0\n\t\t\t\tas << (y - len) / x unless x == 0\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\ty += 1\n\n\t\tif y == h\n\t\t\tif len > 0\n\t\t\t\tlines << [[x, y - len], [x, y]]\n\t\t\t\tas << y / x unless x == 0\n\t\t\t\tas << (y - len) / x unless x == 0\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend \n\nas.delete(0)\n\np as.map {|a|\n\ta -= 0.0001\n\t#y - a x = 0\n\tk = 0\n\tlines.each do |(x1, y1), (x2, y2)|\n\t\tk += 1 if (y1 - a * x1) * (y2 - a * x2) <= 0\n\tend\n\tk -= 1 if f[0][0] == ?#\n\tk / 2 + 1\n}.max"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nh, w = gets.split.map &:to_i\nf = []\n\nh.times do\n\tf.unshift gets.chomp.split(\"\")\nend\n\npile = Hash.new(0)\n\n(1..h).each do |y|\n\tx = 0\n\tlen = 0\n\tloop do\n\t\tif (f[y-1][x] == ?#) ^ (y != h && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\ta1 = Rational(y, x)\n\t\t\t\ta2 = (x - len == 0 ? Float::INFINITY : Rational(y, x - len))\n\t\t\t\tpile[a1] += 1\n\t\t\t\tpile[a2] -= 1\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\tx += 1\n\n\t\tif x == w\n\t\t\tif len > 0\n\t\t\t\ta1 = Rational(y, x)\n\t\t\t\ta2 = (x - len == 0 ? Float::INFINITY : Rational(y, x - len))\n\t\t\t\tpile[a1] += 1\n\t\t\t\tpile[a2] -= 1\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend\n\n(1..w).each do |x|\n\ty = 0\n\tlen = 0\n\tloop do\n\t\tif (f[y][x-1] == ?#) ^ (x != w && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\ta1 = (x == 0 ? Float::INFINITY : Rational(y, x))\n\t\t\t\ta2 = (x == 0 ? Float::INFINITY : Rational(y - len, x))\n\t\t\t\tpile[a2] += 1\n\t\t\t\tpile[a1] -= 1\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\ty += 1\n\n\t\tif y == h\n\t\t\tif len > 0\n\t\t\t\ta1 = (x == 0 ? Float::INFINITY : Rational(y, x))\n\t\t\t\ta2 = (x == 0 ? Float::INFINITY : Rational(y - len, x))\n\t\t\t\tpile[a2] += 1\n\t\t\t\tpile[a1] -= 1\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend \n\nk = pile.sort.map(&:last).accum.max\nk += 1 if f[0][0] == ?#\np k / 2 + 1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nrequire 'mathn'\n\nh, w = gets.split.map &:to_i\nf = []\n\nh.times do\n\tf.unshift gets.chomp.split(\"\")\nend\n\nas = Set.new\nlines = []\n\n(0..h).each do |y|\n\tx = 0\n\tlen = 0\n\tloop do\n\t\tif (y != 0 && f[y-1][x] == ?#) ^ (y != h && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\tlines << [[x - len, y], [x, y]]\n\t\t\t\tas << y / x\n\t\t\t\tas << y / (x - len) unless x - len == 0\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\tx += 1\n\n\t\tif x == w\n\t\t\tif len > 0\n\t\t\t\tlines << [[x - len, y], [x, y]]\n\t\t\t\tas << y / x\n\t\t\t\tas << y / (x - len) unless x - len == 0\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend\n\n(0..w).each do |x|\n\ty = 0\n\tlen = 0\n\tloop do\n\t\tif (x != 0 && f[y][x-1] == ?#) ^ (x != w && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\tlines << [[x, y - len], [x, y]]\n\t\t\t\tas << y / x unless x == 0\n\t\t\t\tas << (y - len) / x unless x == 0\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\ty += 1\n\n\t\tif y == h\n\t\t\tif len > 0\n\t\t\t\tlines << [[x, y - len], [x, y]]\n\t\t\t\tas << y / x unless x == 0\n\t\t\t\tas << (y - len) / x unless x == 0\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend \n\nas.delete(0)\n\np as.map {|a|\n\ta -= 1 / 1000000\t\n\t#y - a x = 0\n\tk = 0\n\tlines.each do |(x1, y1), (x2, y2)|\n\t\tk += 1 if (y1 - a * x1) * (y2 - a * x2) <= 0\n\tend\n\tk -= 1 if f[0][0] == ?#\n\tk / 2 + 1\n}.max"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tac = Array.new(size + 1)\n\t\tac[0] = 0\n\t\t(1..size).each do |i|\n\t\t\tac[i] = ac[i-1] + self[i-1]\n\t\tend\n\t\tac\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nh, w = gets.split.map &:to_i\nf = []\n\nh.times do\n\tf.unshift gets.chomp.split(\"\")\nend\n\npile = Hash.new(0)\n\n(1..h).each do |y|\n\tx = 0\n\tlen = 0\n\tloop do\n\t\tif (f[y-1][x] == ?#) ^ (y != h && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\ta1 = Rational(y, x)\n\t\t\t\ta2 = (x - len == 0 ? Float::INFINITY : Rational(y, x - len))\n\t\t\t\tpile[a1] += 1\n\t\t\t\tpile[a2] -= 1\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\tx += 1\n\n\t\tif x == w\n\t\t\tif len > 0\n\t\t\t\ta1 = Rational(y, x)\n\t\t\t\ta2 = (x - len == 0 ? Float::INFINITY : Rational(y, x - len))\n\t\t\t\tpile[a1] += 1\n\t\t\t\tpile[a2] -= 1\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend\n\n(1..w).each do |x|\n\ty = 0\n\tlen = 0\n\tloop do\n\t\tif (f[y][x-1] == ?#) ^ (x != w && f[y][x] == ?#)\n\t\t\tlen += 1\n\t\telse\n\t\t\tif len > 0\n\t\t\t\ta1 = (x == 0 ? Float::INFINITY : Rational(y, x))\n\t\t\t\ta2 = (x == 0 ? Float::INFINITY : Rational(y - len, x))\n\t\t\t\tpile[a2] += 1\n\t\t\t\tpile[a1] -= 1\n\t\t\tend\n\t\t\tlen = 0\n\t\tend\n\t\ty += 1\n\n\t\tif y == h\n\t\t\tif len > 0\n\t\t\t\ta1 = (x == 0 ? Float::INFINITY : Rational(y, x))\n\t\t\t\ta2 = (x == 0 ? Float::INFINITY : Rational(y - len, x))\n\t\t\t\tpile[a2] += 1\n\t\t\t\tpile[a1] -= 1\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend \n\nk = pile.sort.map(&:last).accum.max\nk += 1 if f[0][0] == ?#\np k / 2 + 1"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import atan2\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef gcd(m, n):\n    while n:\n        m, n = n, m % n\n    return m\ndef solve():\n    H, W = map(int, readline().split())\n\n    MP = []\n    MP.append([0]*(W+2))\n    MP.extend([[0] + list(map(\".#\".index, readline().strip())) + [0] for i in range(H)])\n    MP.append([0]*(W+2))\n\n    R = defaultdict(int)\n    for i in range(H+1):\n        for j in range(W+1):\n            if MP[i+1][j] != MP[i][j+1] or MP[i][j] == MP[i+1][j+1]:\n                continue\n            if MP[i][j] == MP[i][j+1]:\n                v = 1\n            else:\n                v = -1\n            x = j; y = H-i\n            if x == 0:\n                R[0, 1] += v\n            elif y == 0:\n                R[1, 0] += v\n            else:\n                g = gcd(x, y)\n                R[x//g, y//g] += v\n    *PS, = R.items()\n    PS.sort(key = lambda p: atan2(p[0][1], p[0][0]), reverse=1)\n    ans = 0; cur = 1\n    for (x, y), v in PS:\n        cur += v\n        ans = max(ans, cur)\n    write(\"%d\\n\" % ans)\nsolve()\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BinaryHeap, BTreeMap};\nuse std::fmt::{Display, Formatter, Error};\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n#[derive(Copy, Clone)]\nstruct Coordinate {\n    x: i32, y: i32\n}\nimpl Coordinate {\n    fn new(x: i32, y: i32) -> Coordinate {\n        Coordinate{x: x, y: y}\n    }\n}\n#[derive(Copy, Clone)]\nenum Corner {\n    Out{coordinate: Coordinate}, In{coordinate: Coordinate},\n}\nimpl Corner {\n    fn in_corner(x: usize, y: usize) -> Corner {\n        Corner::In{coordinate: Coordinate::new(x as i32, y as i32)}\n    }\n    fn out_corner(x: usize, y: usize) -> Corner {\n        Corner::Out {coordinate: Coordinate::new(x as i32, y as i32)}\n    }\n}\nimpl Ord for Corner {\n    fn cmp(&self, other: &Self) -> Ordering {\n        match (self, other) {\n            (&Corner::In {coordinate: i}, &Corner::Out{coordinate: o}) => {\n                match (i.x * o.y).cmp(&(o.x * i.y)) {\n                    Ordering::Equal => Ordering::Greater,\n                    o => o,\n                }\n            }\n            (&Corner::Out {coordinate: i}, &Corner::In {coordinate: o}) => {\n                match (i.x * o.y).cmp(&(o.x * i.y)) {\n                    Ordering::Equal => Ordering::Less,\n                    o => o,\n                }\n            }\n            (&Corner::Out {coordinate: i}, &Corner::Out {coordinate: o}) => {\n                (i.x * o.y).cmp(&(o.x * i.y))\n            }\n            (&Corner::In{coordinate: i}, &Corner::In {coordinate: o}) => {\n                (i.x * o.y).cmp(&(o.x * i.y))\n            }\n        }\n    }\n}\nimpl PartialOrd for Corner {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\nimpl PartialEq for Corner {\n    fn eq(&self, other: &Self) -> bool {\n        self.cmp(other).eq(&Ordering::Equal)\n    }\n}\nimpl Eq for Corner {}\nimpl Display for Corner {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        match self {\n            &Corner::In {coordinate: c} => write!(f, \"In(x: {}, y: {})\", c.x, c.y),\n            &Corner::Out {coordinate: c} => write!(f, \"Out(x: {}, y: {})\", c.x, c.y),\n        }\n    }\n}\nfn main(){\n    let_all!(h: usize, w: usize);\n    let mut state = Vec::<Vec<char>>::with_capacity(h);\n    for _ in 0 .. h{\n        state.push(read_line!().chars().collect());\n    }\n    state.reverse();\n    let state = state;\n    let mut corners = Vec::new();\n    for x in 0 .. w {\n        for y in 0 .. h {\n            match state[y][x] {\n                '#' => {\n                    if (x < 1 || state[y][x - 1] == '.') && (y + 1 >= h || state[y + 1][x] == '.') {\n                        corners.push(Corner::in_corner(x, y + 1))\n                    }\n                    if (x + 1 >= w || state[y][x + 1] == '.') && (y < 1 || state[y - 1][x] == '.') {\n                        corners.push(Corner::out_corner(x + 1, y))\n                    }\n                }\n                '.' => {\n                    if (x >= 1 && state[y][x - 1] == '#') && (y + 1 < h && state[y + 1][x] == '#') {\n                        corners.push(Corner::in_corner(x, y + 1))\n                    }\n                    if (x + 1 < w && state[y][x + 1] == '#') && (y >= 1 && state[y - 1][x] == '#') {\n                        corners.push(Corner::out_corner(x + 1, y))\n                    }\n                }\n                _ => unreachable!()\n            }\n        }\n    }\n    corners.sort();\n    let corners = corners;\n    let mut max = 1;\n    let mut count = 1;\n    for &c in &corners {\n        //println!(\"{}\", c);\n        match c {\n            Corner::In {coordinate: _} => count += 1,\n            Corner::Out {coordinate: _} => count -= 1,\n        }\n        if max < count {\n            max = count;\n        }\n    }\n    println!(\"{}\", max);\n\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BinaryHeap, BTreeMap};\nuse std::fmt::{Display, Formatter, Error};\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n#[derive(Copy, Clone)]\nstruct Coordinate {\n    x: i32, y: i32\n}\nimpl Coordinate {\n    fn new(x: i32, y: i32) -> Coordinate {\n        Coordinate{x: x, y: y}\n    }\n}\n#[derive(Copy, Clone)]\nenum Corner {\n    Out{coordinate: Coordinate}, In{coordinate: Coordinate},\n}\nimpl Corner {\n    fn in_corner(x: usize, y: usize) -> Corner {\n        Corner::In{coordinate: Coordinate::new(x as i32, y as i32)}\n    }\n    fn out_corner(x: usize, y: usize) -> Corner {\n        Corner::Out {coordinate: Coordinate::new(x as i32, y as i32)}\n    }\n}\nimpl Ord for Corner {\n    fn cmp(&self, other: &Self) -> Ordering {\n        match (self, other) {\n            (Corner::In {coordinate: i}, Corner::Out{coordinate: o}) => {\n                match (i.x * o.y).cmp(&(o.x * i.y)) {\n                    Ordering::Equal => Ordering::Greater,\n                    o => o,\n                }\n            }\n            (Corner::Out {coordinate: i}, Corner::In {coordinate: o}) => {\n                match (i.x * o.y).cmp(&(o.x * i.y)) {\n                    Ordering::Equal => Ordering::Less,\n                    o => o,\n                }\n            }\n            (Corner::Out {coordinate: i}, Corner::Out {coordinate: o}) => {\n                (i.x * o.y).cmp(&(o.x * i.y))\n            }\n            (Corner::In{coordinate: i}, Corner::In {coordinate: o}) => {\n                (i.x * o.y).cmp(&(o.x * i.y))\n            }\n        }\n    }\n}\nimpl PartialOrd for Corner {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\nimpl PartialEq for Corner {\n    fn eq(&self, other: &Self) -> bool {\n        self.cmp(other).eq(&Ordering::Equal)\n    }\n}\nimpl Eq for Corner {}\nimpl Display for Corner {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        match self {\n            Corner::In {coordinate: c} => write!(f, \"In(x: {}, y: {})\", c.x, c.y),\n            Corner::Out {coordinate: c} => write!(f, \"Out(x: {}, y: {})\", c.x, c.y),\n        }\n    }\n}\nfn main(){\n    let_all!(h: usize, w: usize);\n    let mut state = Vec::<Vec<char>>::with_capacity(h);\n    for _ in 0 .. h{\n        state.push(read_line!().chars().collect());\n    }\n    state.reverse();\n    let state = state;\n    let mut corners = Vec::new();\n    for x in 0 .. w {\n        for y in 0 .. h {\n            match state[y][x] {\n                '#' => {\n                    if (x < 1 || state[y][x - 1] == '.') && (y + 1 >= h || state[y + 1][x] == '.') {\n                        corners.push(Corner::in_corner(x, y + 1))\n                    }\n                    if (x + 1 >= w || state[y][x + 1] == '.') && (y < 1 || state[y - 1][x] == '.') {\n                        corners.push(Corner::out_corner(x + 1, y))\n                    }\n                }\n                '.' => {\n                    if (x >= 1 && state[y][x - 1] == '#') && (y + 1 < h && state[y + 1][x] == '#') {\n                        corners.push(Corner::in_corner(x, y + 1))\n                    }\n                    if (x + 1 < w && state[y][x + 1] == '#') && (y >= 1 && state[y - 1][x] == '#') {\n                        corners.push(Corner::out_corner(x + 1, y))\n                    }\n                }\n                _ => unreachable!()\n            }\n        }\n    }\n    corners.sort();\n    let corners = corners;\n    let mut max = 0;\n    let mut count = 1;\n    for &c in &corners {\n        //println!(\"{}\", c);\n        match c {\n            Corner::In {coordinate: _} => count += 1,\n            Corner::Out {coordinate: _} => count -= 1,\n        }\n        if max < count {\n            max = count;\n        }\n    }\n    println!(\"{}\", max);\n\n}\n\n\n"
  }
]