[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_CUBES 4\n#define FACES 6\n\nint min_repaints = 1 << 30;\n\ntypedef struct {\n    char colors[FACES];\n} Cube;\n\nCube cubes[MAX_CUBES];\nint n;\n\nint is_equivalent(Cube a, Cube b) {\n    char temp;\n    int i, j, k, l, m;\n    for (i = 0; i < 4; i++) {\n        for (j = 0; j < 4; j++) {\n            for (k = 0; k < 4; k++) {\n                if (a.colors[0] == b.colors[0] && a.colors[1] == b.colors[1] &&\n                    a.colors[2] == b.colors[2] && a.colors[3] == b.colors[3] &&\n                    a.colors[4] == b.colors[4] && a.colors[5] == b.colors[5]) {\n                    return 1;\n                }\n                // Rotate around vertical axis (top stays top)\n                temp = b.colors[1];\n                b.colors[1] = b.colors[2];\n                b.colors[2] = b.colors[3];\n                b.colors[3] = b.colors[4];\n                b.colors[4] = temp;\n            }\n            // Rotate around horizontal axis (front becomes top)\n            temp = b.colors[0];\n            b.colors[0] = b.colors[1];\n            b.colors[1] = b.colors[5];\n            b.colors[5] = b.colors[3];\n            b.colors[3] = temp;\n        }\n        // Rotate around another axis (side becomes top)\n        temp = b.colors[0];\n        b.colors[0] = b.colors[2];\n        b.colors[2] = b.colors[5];\n        b.colors[5] = b.colors[4];\n        b.colors[4] = temp;\n    }\n    return 0;\n}\n\nvoid check_repaints(Cube target) {\n    int total = 0;\n    for (int i = 0; i < n; i++) {\n        int min = FACES;\n        Cube temp = cubes[i];\n        for (int j = 0; j < 4; j++) {\n            for (int k = 0; k < 4; k++) {\n                for (int l = 0; l < 4; l++) {\n                    int diff = 0;\n                    for (int m = 0; m < FACES; m++) {\n                        if (temp.colors[m] != target.colors[m]) {\n                            diff++;\n                        }\n                    }\n                    if (diff < min) {\n                        min = diff;\n                    }\n                    // Rotate around vertical axis\n                    char t = temp.colors[1];\n                    temp.colors[1] = temp.colors[2];\n                    temp.colors[2] = temp.colors[3];\n                    temp.colors[3] = temp.colors[4];\n                    temp.colors[4] = t;\n                }\n                // Rotate around horizontal axis\n                char t = temp.colors[0];\n                temp.colors[0] = temp.colors[1];\n                temp.colors[1] = temp.colors[5];\n                temp.colors[5] = temp.colors[3];\n                temp.colors[3] = t;\n            }\n            // Rotate around another axis\n            char t = temp.colors[0];\n            temp.colors[0] = temp.colors[2];\n            temp.colors[2] = temp.colors[5];\n            temp.colors[5] = temp.colors[4];\n            temp.colors[4] = t;\n        }\n        total += min;\n        if (total >= min_repaints) {\n            return;\n        }\n    }\n    if (total < min_repaints) {\n        min_repaints = total;\n    }\n}\n\nvoid generate_targets(int index, Cube target) {\n    if (index == n) {\n        check_repaints(target);\n        return;\n    }\n    Cube temp = cubes[index];\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            for (int k = 0; k < 4; k++) {\n                generate_targets(index + 1, temp);\n                // Rotate around vertical axis\n                char t = temp.colors[1];\n                temp.colors[1] = temp.colors[2];\n                temp.colors[2] = temp.colors[3];\n                temp.colors[3] = temp.colors[4];\n                temp.colors[4] = t;\n            }\n            // Rotate around horizontal axis\n            char t = temp.colors[0];\n            temp.colors[0] = temp.colors[1];\n            temp.colors[1] = temp.colors[5];\n            temp.colors[5] = temp.colors[3];\n            temp.colors[3] = t;\n        }\n        // Rotate around another axis\n        char t = temp.colors[0];\n        temp.colors[0] = temp.colors[2];\n        temp.colors[2] = temp.colors[5];\n        temp.colors[5] = temp.colors[4];\n        temp.colors[4] = t;\n    }\n}\n\nint main() {\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < FACES; j++) {\n                scanf(\" %c\", &cubes[i].colors[j]);\n            }\n        }\n        min_repaints = 1 << 30;\n        Cube target = cubes[0];\n        generate_targets(1, target);\n        printf(\"%d\\n\", min_repaints);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CubeRepainting {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        \n        for (int d = 0; d < datasets; d++) {\n            int numCubes = scanner.nextInt();\n            int[][] cubes = new int[numCubes][6];\n            \n            for (int i = 0; i < numCubes; i++) {\n                for (int j = 0; j < 6; j++) {\n                    cubes[i][j] = scanner.nextInt();\n                }\n            }\n            \n            int minRepaints = findMinRepaints(cubes);\n            System.out.println(minRepaints);\n        }\n        \n        scanner.close();\n    }\n    \n    private static int findMinRepaints(int[][] cubes) {\n        int minRepaints = Integer.MAX_VALUE;\n        \n        for (int targetColor = 1; targetColor <= 6; targetColor++) {\n            int[][] rotations = {\n                {0, 1, 2, 3, 4, 5},\n                {0, 2, 4, 1, 3, 5},\n                {0, 3, 1, 4, 2, 5},\n                {0, 4, 3, 2, 1, 5}\n            };\n            \n            for (int[] rotation : rotations) {\n                int currentRepaints = 0;\n                \n                for (int[] cube : cubes) {\n                    int minCubeRepaints = 6;\n                    \n                    for (int color = 1; color <= 6; color++) {\n                        int cubeRepaints = 0;\n                        for (int face = 0; face < 6; face++) {\n                            if (cube[rotation[face]] != color) {\n                                cubeRepaints++;\n                            }\n                        }\n                        minCubeRepaints = Math.min(minCubeRepaints, cubeRepaints);\n                    }\n                    \n                    currentRepaints += minCubeRepaints;\n                }\n                \n                minRepaints = Math.min(minRepaints, currentRepaints);\n            }\n        }\n        \n        return minRepaints;\n    }\n}",
    "timestamp": "2025-08-05 19:17:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> rotateUp(const vector<string> &cube) {\n    return {cube[4], cube[0], cube[2], cube[3], cube[5], cube[1]};\n}\n\nvector<string> rotateRight(const vector<string> &cube) {\n    return {cube[0], cube[2], cube[1], cube[5], cube[4], cube[3]};\n}\n\nvector<string> normalizeCube(vector<string> cube) {\n    vector<vector<string>> rotations;\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            rotations.push_back(cube);\n            cube = rotateRight(cube);\n        }\n        cube = rotateUp(cube);\n    }\n    cube = rotateRight(rotateUp(cube));\n    for (int j = 0; j < 4; ++j) {\n        rotations.push_back(cube);\n        cube = rotateRight(cube);\n    }\n    cube = rotateRight(rotateRight(rotateUp(cube)));\n    for (int j = 0; j < 4; ++j) {\n        rotations.push_back(cube);\n        cube = rotateRight(cube);\n    }\n    sort(rotations.begin(), rotations.end());\n    return rotations[0];\n}\n\nint main() {\n    int n;\n    while (cin >> n && n != 0) {\n        vector<vector<string>> cubes(n);\n        for (int i = 0; i < n; ++i) {\n            vector<string> cube(6);\n            for (int j = 0; j < 6; ++j) {\n                cin >> cube[j];\n            }\n            cubes[i] = normalizeCube(cube);\n        }\n        map<vector<string>, int> count;\n        for (const auto &cube : cubes) {\n            count[cube]++;\n        }\n        int maxSame = 0;\n        for (const auto &p : count) {\n            if (p.second > maxSame) {\n                maxSame = p.second;\n            }\n        }\n        cout << n - maxSame << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:18:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_CUBES 10\n#define FACES 6\n\nint min_repaints(char cubes[MAX_CUBES][FACES + 1], int n) {\n    int min_repaint = INT_MAX;\n    \n    // Try all possible target colors\n    for (int target = 0; target < FACES; target++) {\n        int total_repaints = 0;\n        \n        // Check each cube's minimum repaints to target color\n        for (int i = 0; i < n; i++) {\n            int cube_repaints = FACES;\n            \n            // Try each possible rotation\n            for (int rot = 0; rot < FACES; rot++) {\n                int current_repaints = 0;\n                \n                // Count repaints needed for current rotation\n                for (int j = 0; j < FACES; j++) {\n                    if (cubes[i][(j + rot) % FACES] - '0' != target) {\n                        current_repaints++;\n                    }\n                }\n                \n                // Update minimum repaints for this cube\n                cube_repaints = (current_repaints < cube_repaints) ? current_repaints : cube_repaints;\n            }\n            \n            total_repaints += cube_repaints;\n        }\n        \n        // Update minimum total repaints\n        min_repaint = (total_repaints < min_repaint) ? total_repaints : min_repaint;\n    }\n    \n    return min_repaint;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    for (int d = 0; d < datasets; d++) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        char cubes[MAX_CUBES][FACES + 1];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", cubes[i]);\n        }\n        \n        printf(\"%d\\n\", min_repaints(cubes, n));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:18:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <climits>\n\nusing namespace std;\n\nvector<string> getAllRotations(const vector<string>& cube) {\n    vector<string> rotations = {\n        cube[0] + cube[1] + cube[2] + cube[3] + cube[4] + cube[5],\n        cube[0] + cube[2] + cube[4] + cube[1] + cube[3] + cube[5],\n        cube[0] + cube[3] + cube[1] + cube[4] + cube[2] + cube[5],\n        cube[0] + cube[4] + cube[3] + cube[2] + cube[1] + cube[5],\n        \n        cube[1] + cube[0] + cube[2] + cube[3] + cube[4] + cube[5],\n        cube[1] + cube[2] + cube[4] + cube[0] + cube[3] + cube[5],\n        cube[1] + cube[3] + cube[0] + cube[4] + cube[2] + cube[5],\n        cube[1] + cube[4] + cube[3] + cube[2] + cube[0] + cube[5],\n        \n        cube[2] + cube[0] + cube[1] + cube[3] + cube[4] + cube[5],\n        cube[2] + cube[1] + cube[4] + cube[0] + cube[3] + cube[5],\n        cube[2] + cube[3] + cube[0] + cube[4] + cube[1] + cube[5],\n        cube[2] + cube[4] + cube[3] + cube[1] + cube[0] + cube[5],\n        \n        cube[3] + cube[0] + cube[2] + cube[1] + cube[4] + cube[5],\n        cube[3] + cube[2] + cube[4] + cube[0] + cube[1] + cube[5],\n        cube[3] + cube[1] + cube[0] + cube[4] + cube[2] + cube[5],\n        cube[3] + cube[4] + cube[2] + cube[1] + cube[0] + cube[5],\n        \n        cube[4] + cube[0] + cube[1] + cube[3] + cube[2] + cube[5],\n        cube[4] + cube[1] + cube[3] + cube[0] + cube[2] + cube[5],\n        cube[4] + cube[3] + cube[2] + cube[0] + cube[1] + cube[5],\n        cube[4] + cube[2] + cube[1] + cube[3] + cube[0] + cube[5],\n        \n        cube[5] + cube[0] + cube[1] + cube[3] + cube[4] + cube[2],\n        cube[5] + cube[1] + cube[4] + cube[0] + cube[3] + cube[2],\n        cube[5] + cube[3] + cube[0] + cube[4] + cube[1] + cube[2],\n        cube[5] + cube[4] + cube[3] + cube[1] + cube[0] + cube[2]\n    };\n    return rotations;\n}\n\nint countRepaints(const vector<string>& target, const vector<string>& cube) {\n    int minRepaints = INT_MAX;\n    for (const string& rotation : getAllRotations(cube)) {\n        int repaints = 0;\n        for (int i = 0; i < 6; ++i) {\n            if (rotation[i] != target[i]) {\n                repaints++;\n            }\n        }\n        minRepaints = min(minRepaints, repaints);\n    }\n    return minRepaints;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    \n    for (int d = 0; d < datasets; ++d) {\n        int n;\n        cin >> n;\n        \n        vector<string> target(6);\n        for (int i = 0; i < 6; ++i) {\n            cin >> target[i];\n        }\n        \n        int totalRepaints = 0;\n        for (int i = 0; i < n; ++i) {\n            vector<string> cube(6);\n            for (int j = 0; j < 6; ++j) {\n                cin >> cube[j];\n            }\n            totalRepaints += countRepaints(target, cube);\n        }\n        \n        cout << totalRepaints << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:18:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class CubeRepaint {\n    private static final String[] OPPOSITE_FACES = {\n        \"front\", \"back\",\n        \"left\", \"right\",\n        \"top\", \"bottom\"\n    };\n\n    private static final Map<String, Integer> FACE_INDEX = new HashMap<>();\n    static {\n        FACE_INDEX.put(\"front\", 0);\n        FACE_INDEX.put(\"back\", 1);\n        FACE_INDEX.put(\"left\", 2);\n        FACE_INDEX.put(\"right\", 3);\n        FACE_INDEX.put(\"top\", 4);\n        FACE_INDEX.put(\"bottom\", 5);\n    }\n\n    private static List<String> generateAllOrientations(String[] cube) {\n        List<String[]> orientations = new ArrayList<>();\n        String[] base = cube.clone();\n        orientations.add(base);\n\n        for (int i = 0; i < 4; i++) {\n            base = rotateY(base);\n            orientations.add(base.clone());\n        }\n        base = rotateX(base);\n        orientations.add(base.clone());\n        for (int i = 0; i < 3; i++) {\n            base = rotateY(base);\n            orientations.add(base.clone());\n        }\n        base = rotateX(base);\n        orientations.add(base.clone());\n        for (int i = 0; i < 3; i++) {\n            base = rotateY(base);\n            orientations.add(base.clone());\n        }\n        base = rotateX(base);\n        orientations.add(base.clone());\n        for (int i = 0; i < 3; i++) {\n            base = rotateY(base);\n            orientations.add(base.clone());\n        }\n        base = rotateX(base);\n        base = rotateY(base);\n        orientations.add(base.clone());\n        base = rotateY(base);\n        orientations.add(base.clone());\n        base = rotateY(base);\n        orientations.add(base.clone());\n\n        return orientations.stream()\n                .map(arr -> String.join(\",\", arr))\n                .distinct()\n                .collect(Collectors.toList());\n    }\n\n    private static String[] rotateX(String[] cube) {\n        String[] rotated = new String[6];\n        rotated[0] = cube[5];\n        rotated[1] = cube[4];\n        rotated[2] = cube[2];\n        rotated[3] = cube[3];\n        rotated[4] = cube[0];\n        rotated[5] = cube[1];\n        return rotated;\n    }\n\n    private static String[] rotateY(String[] cube) {\n        String[] rotated = new String[6];\n        rotated[0] = cube[0];\n        rotated[1] = cube[1];\n        rotated[2] = cube[4];\n        rotated[3] = cube[5];\n        rotated[4] = cube[3];\n        rotated[5] = cube[2];\n        return rotated;\n    }\n\n    private static int calculateMinRepaints(List<String[]> cubes) {\n        if (cubes.isEmpty()) return 0;\n        int minRepaints = Integer.MAX_VALUE;\n\n        List<List<String>> allOrientations = cubes.stream()\n                .map(cube -> generateAllOrientations(cube))\n                .collect(Collectors.toList());\n\n        for (String orientation : allOrientations.get(0)) {\n            String[] target = orientation.split(\",\");\n            int totalRepaints = 0;\n\n            for (List<String> cubeOrientations : allOrientations) {\n                int minCubeRepaints = Integer.MAX_VALUE;\n                for (String cubeOrientation : cubeOrientations) {\n                    String[] current = cubeOrientation.split(\",\");\n                    int repaints = 0;\n                    for (int i = 0; i < 6; i++) {\n                        if (!current[i].equals(target[i])) {\n                            repaints++;\n                        }\n                    }\n                    if (repaints < minCubeRepaints) {\n                        minCubeRepaints = repaints;\n                    }\n                }\n                totalRepaints += minCubeRepaints;\n            }\n\n            if (totalRepaints < minRepaints) {\n                minRepaints = totalRepaints;\n            }\n        }\n\n        return minRepaints;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            List<String[]> cubes = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                String[] cube = new String[6];\n                for (int j = 0; j < 6; j++) {\n                    cube[j] = scanner.next();\n                }\n                cubes.add(cube);\n            }\n            System.out.println(calculateMinRepaints(cubes));\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 19:19:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\n# Define all possible rotations for a cube\n# Each tuple (a,b,c,d,e,f) represents a rotation\n# a, b, c, d, e, f refers to the indices of new positions for U, D, L, R, F, B respectively\nrotations = [\n    (0, 1, 2, 3, 4, 5), (0, 1, 4, 5, 3, 2), (0, 1, 3, 2, 5, 4), (0, 1, 5, 4, 2, 3),\n    (1, 0, 2, 3, 5, 4), (1, 0, 5, 4, 3, 2), (1, 0, 3, 2, 4, 5), (1, 0, 4, 5, 2, 3),\n    (2, 3, 1, 0, 4, 5), (2, 3, 4, 5, 0, 1), (2, 3, 0, 1, 5, 4), (2, 3, 5, 4, 1, 0),\n    (3, 2, 1, 0, 5, 4), (3, 2, 5, 4, 0, 1), (3, 2, 0, 1, 4, 5), (3, 2, 4, 5, 1, 0),\n    (4, 5, 1, 0, 2, 3), (4, 5, 2, 3, 0, 1), (4, 5, 0, 1, 3, 2), (4, 5, 3, 2, 1, 0),\n    (5, 4, 1, 0, 3, 2), (5, 4, 3, 2, 0, 1), (5, 4, 0, 1, 2, 3), (5, 4, 2, 3, 1, 0),\n]\n\ndef rotate_cube(cube, rotation):\n    return tuple(cube[i] for i in rotation)\n\ndef all_rotations(cube):\n    return [rotate_cube(cube, rotation) for rotation in rotations]\n\ndef min_repaints(cubes):\n    # Store all unique rotated versions of the cubes\n    normalized_cubes = [min(all_rotations(cube)) for cube in cubes]\n    \n    # Count frequency of each rotated version\n    counter = {}\n    for norm_cube in normalized_cubes:\n        if norm_cube not in counter:\n            counter[norm_cube] = 0\n        counter[norm_cube] += 1\n    \n    # Find the maximum occurrences of a color pattern\n    max_common_faces = 0\n    for norm_cube, count in counter.items():\n        max_common_faces = max(max_common_faces, count)\n    \n    # Total number of cubes - maximum occurrences gives the minimum repaints needed\n    return len(cubes) - max_common_faces\n\n# Process input for multiple datasets\ndef process_datasets(datasets):\n    results = []\n    for cubes in datasets:\n        results.append(min_repaints(cubes))\n    return results\n\n# Example usage:\ndatasets = [\n    [(1, 2, 3, 4, 5, 6), (6, 5, 4, 3, 2, 1)],\n    [(1, 1, 1, 1, 1, 1), (1, 1, 2, 2, 2, 2)],\n]\nprint(process_datasets(datasets))",
    "timestamp": "2025-08-13 03:26:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CubePainter {\n    private static final int[][] CUBE_ROTATIONS = {\n        {0, 1, 2, 3, 4, 5},\n        {0, 3, 1, 4, 2, 5},\n        {0, 2, 4, 1, 3, 5},\n        {0, 4, 3, 2, 1, 5},\n        {1, 0, 4, 5, 2, 3},\n        {1, 2, 0, 5, 3, 4},\n        {1, 3, 2, 5, 4, 0},\n        {1, 4, 3, 5, 0, 2},\n        {2, 1, 5, 3, 0, 4},\n        {2, 0, 1, 5, 4, 3},\n        {2, 4, 0, 5, 1, 3},\n        {2, 3, 4, 5, 0, 1},\n        {3, 1, 0, 4, 5, 2},\n        {3, 2, 5, 4, 1, 0},\n        {3, 0, 1, 4, 2, 5},\n        {3, 5, 2, 4, 0, 1},\n        {4, 1, 5, 2, 3, 0},\n        {4, 2, 1, 0, 5, 3},\n        {4, 0, 3, 2, 5, 1},\n        {4, 3, 0, 2, 5, 1},\n        {5, 1, 2, 3, 0, 4},\n        {5, 0, 1, 3, 2, 4},\n        {5, 2, 4, 3, 1, 0},\n        {5, 3, 2, 3, 4, 0}\n    };\n\n    private static String rotateCube(String cube, int[] rotation) {\n        char[] rotated = new char[6];\n        for (int i = 0; i < 6; i++) {\n            rotated[i] = cube.charAt(rotation[i]);\n        }\n        return new String(rotated);\n    }\n\n    public static int minRepaintsToIdentical(List<String> cubes) {\n        int n = cubes.size();\n        Map<String, Integer> cubeFreq = new HashMap<>();\n\n        for (String cube : cubes) {\n            int minRep = Integer.MAX_VALUE;\n            for (int[] rotation : CUBE_ROTATIONS) {\n                String rotated = rotateCube(cube, rotation);\n                cubeFreq.put(rotated, cubeFreq.getOrDefault(rotated, 0) + 1);\n            }\n        }\n\n        int maxCount = Collections.max(cubeFreq.values());\n\n        return n * 6 - maxCount * 6;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int n = Integer.parseInt(scanner.nextLine().trim());\n            List<String> cubes = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                cubes.add(scanner.nextLine().trim());\n            }\n            System.out.println(minRepaintsToIdentical(cubes));\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 03:26:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define NUM_FACES 6\n\nint transformations[24][NUM_FACES] = {\n    {0, 1, 2, 3, 4, 5}, {0, 4, 1, 3, 5, 2}, {0, 3, 4, 5, 1, 2}, {0, 2, 5, 1, 3, 4}, \n    {1, 0, 3, 2, 4, 5}, {1, 4, 0, 2, 5, 3}, {1, 2, 4, 5, 0, 3}, {1, 3, 5, 0, 2, 4},\n    {2, 0, 1, 4, 3, 5}, {2, 3, 0, 4, 5, 1}, {2, 5, 3, 1, 0, 4}, {2, 1, 4, 0, 5, 3},\n    {3, 0, 5, 4, 1, 2}, {3, 1, 0, 4, 2, 5}, {3, 2, 1, 0, 4, 5}, {3, 4, 2, 5, 0, 1},\n    {4, 0, 2, 5, 3, 1}, {4, 3, 0, 5, 1, 2}, {4, 1, 3, 0, 5, 2}, {4, 5, 1, 2, 0, 3},\n    {5, 0, 4, 2, 3, 1}, {5, 3, 2, 0, 4, 1}, {5, 4, 3, 1, 2, 0}, {5, 1, 0, 3, 2, 4}\n};\n\nvoid apply_transformation(char dst[NUM_FACES], char src[NUM_FACES], int transform[NUM_FACES]) {\n    for (int i = 0; i < NUM_FACES; i++)\n        dst[i] = src[transform[i]];\n}\n\nint compute_difference(char cube1[NUM_FACES], char cube2[NUM_FACES]) {\n    int diff = 0;\n    for (int i = 0; i < NUM_FACES; i++) {\n        if (cube1[i] != cube2[i])\n            diff++;\n    }\n    return diff;\n}\n\nint find_minimum_repaints(int n, char cubes[n][NUM_FACES]) {\n    int min_repaints = NUM_FACES * n;\n    for (int target = 0; target < n; target++) {\n        char transformed_cube[NUM_FACES];\n        \n        for (int t = 0; t < 24; t++) {\n            apply_transformation(transformed_cube, cubes[target], transformations[t]);\n            int repaints = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int current_min = NUM_FACES;\n                for (int t2 = 0; t2 < 24; t2++) {\n                    char cube_match[NUM_FACES];\n                    apply_transformation(cube_match, cubes[i], transformations[t2]);\n                    int difference = compute_difference(transformed_cube, cube_match);\n                    if (difference < current_min) {\n                        current_min = difference;\n                    }\n                }\n                repaints += current_min;\n            }\n            \n            if (repaints < min_repaints) {\n                min_repaints = repaints;\n            }\n        }\n    }\n    return min_repaints;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) && n > 0) {\n        char cubes[n][NUM_FACES];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < NUM_FACES; j++) {\n                scanf(\" %c\", &cubes[i][j]);\n            }\n        }\n        printf(\"%d\\n\", find_minimum_repaints(n, cubes));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 03:26:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_cube_repainting(cubes):\n    def rotate_cube(cube):\n        rotations = [\n            [cube[0], cube[1], cube[2], cube[3], cube[4], cube[5]],\n            [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]],\n            [cube[4], cube[1], cube[0], cube[5], cube[3], cube[2]],\n            [cube[5], cube[1], cube[3], cube[0], cube[4], cube[2]],\n            [cube[2], cube[0], cube[4], cube[3], cube[5], cube[1]],\n            [cube[3], cube[5], cube[1], cube[4], cube[2], cube[0]]\n        ]\n        return rotations\n\n    def count_different_faces(cube1, cube2):\n        return sum(1 for a, b in zip(cube1, cube2) if a != b)\n\n    min_repaints = float('inf')\n    n = len(cubes)\n\n    for target in cubes:\n        for target_rotations in rotate_cube(target):\n            current_repaints = 0\n            for cube in cubes:\n                min_cube_repaints = float('inf')\n                for cube_rotations in rotate_cube(cube):\n                    min_cube_repaints = min(min_cube_repaints, count_different_faces(target_rotations, cube_rotations))\n                current_repaints += min_cube_repaints\n            min_repaints = min(min_repaints, current_repaints)\n\n    return min_repaints\n\ndef main():\n    num_datasets = int(input())\n    for _ in range(num_datasets):\n        n = int(input())\n        cubes = []\n        for _ in range(n):\n            cube = list(input().split())\n            cubes.append(cube)\n        \n        result = solve_cube_repainting(cubes)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:26:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef rotate_up(cube):\n    # Rotate the cube upwards (around the x-axis)\n    return [cube[4], cube[0], cube[2], cube[3], cube[5], cube[1]]\n\ndef rotate_right(cube):\n    # Rotate the cube to the right (around the y-axis)\n    return [cube[2], cube[1], cube[5], cube[0], cube[4], cube[3]]\n\ndef generate_rotations(cube):\n    rotations = set()\n    from collections import deque\n    queue = deque()\n    queue.append(tuple(cube))\n    rotations.add(tuple(cube))\n    \n    while queue:\n        current = list(queue.popleft())\n        # Generate all possible rotations\n        for _ in range(4):\n            current = rotate_right(current)\n            for __ in range(4):\n                current = rotate_up(current)\n                t_current = tuple(current)\n                if t_current not in rotations:\n                    rotations.add(t_current)\n                    queue.append(t_current)\n            current = rotate_right(current)\n            current = rotate_up(current)\n            current = rotate_up(current)\n            t_current = tuple(current)\n            if t_current not in rotations:\n                rotations.add(t_current)\n                queue.append(t_current)\n    return rotations\n\ndef solve():\n    while True:\n        line = sys.stdin.readline().strip()\n        if not line:\n            break\n        n = int(line)\n        cubes = []\n        for _ in range(n):\n            faces = sys.stdin.readline().strip().split()\n            cubes.append(faces)\n        \n        # Generate all possible rotations for each cube and count color frequencies\n        rotation_colors = []\n        for cube in cubes:\n            rotations = generate_rotations(cube)\n            rotation_colors.append(rotations)\n        \n        min_repaints = float('inf')\n        # Choose the first cube's rotation as reference\n        for ref_rot in rotation_colors[0]:\n            total = 0\n            for i in range(1, n):\n                min_diff = float('inf')\n                for rot in rotation_colors[i]:\n                    diff = 0\n                    for j in range(6):\n                        if rot[j] != ref_rot[j]:\n                            diff += 1\n                    if diff < min_diff:\n                        min_diff = diff\n                total += min_diff\n            if total < min_repaints:\n                min_repaints = total\n        print(min_repaints)\n\nsolve()",
    "timestamp": "2025-08-13 03:27:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <array>\n#include <algorithm>\n\nusing namespace std;\n\n// rotations according to symmetry of the cube\nconst vector<vector<int>> rotations = {\n    {0, 1, 2, 3, 4, 5},\n    {0, 1, 4, 5, 3, 2},\n    {0, 1, 3, 2, 5, 4},\n    {0, 1, 5, 4, 2, 3},\n    {1, 0, 2, 3, 5, 4},\n    {1, 0, 5, 4, 2, 3},\n    {1, 0, 3, 2, 4, 5},\n    {1, 0, 4, 5, 3, 2},\n    {2, 3, 1, 0, 4, 5},\n    {2, 3, 4, 5, 0, 1},\n    {2, 3, 0, 1, 5, 4},\n    {2, 3, 5, 4, 1, 0},\n    {3, 2, 1, 0, 5, 4},\n    {3, 2, 5, 4, 0, 1},\n    {3, 2, 0, 1, 4, 5},\n    {3, 2, 4, 5, 1, 0},\n    {4, 5, 1, 0, 3, 2},\n    {4, 5, 3, 2, 0, 1},\n    {4, 5, 0, 1, 2, 3},\n    {4, 5, 2, 3, 1, 0},\n    {5, 4, 1, 0, 2, 3},\n    {5, 4, 2, 3, 0, 1},\n    {5, 4, 0, 1, 3, 2},\n    {5, 4, 3, 2, 1, 0}\n};\n\n// function to get all rotated versions of a cube\nvector<array<int, 6>> generateAllRotations(const array<int, 6>& cube) {\n    vector<array<int, 6>> all_rotations;\n    for (const auto& rot : rotations) {\n        array<int, 6> rotated;\n        for (int i = 0; i < 6; ++i) {\n            rotated[i] = cube[rot[i]];\n        }\n        all_rotations.push_back(rotated);\n    }\n    sort(all_rotations.begin(), all_rotations.end());\n    all_rotations.erase(unique(all_rotations.begin(), all_rotations.end()), all_rotations.end());\n    return all_rotations;\n}\n\nint calculateMinRepaints(const vector<array<int, 6>>& cubes) {\n    map<array<int, 6>, int> colorDistribution;\n    for (const auto& cube : cubes) {\n        auto rotations = generateAllRotations(cube);\n        auto normalized = *min_element(rotations.begin(), rotations.end());\n        colorDistribution[normalized]++;\n    }\n    \n    int maxFrequency = 0;\n    for (const auto& [color, freq] : colorDistribution) {\n        maxFrequency = max(maxFrequency, freq);\n    }\n    \n    return cubes.size() - maxFrequency;\n}\n\nint main() {\n    int datasetCount;\n    cin >> datasetCount;\n    \n    while (datasetCount--) {\n        int cubeCount;\n        cin >> cubeCount;\n        \n        vector<array<int, 6>> cubes(cubeCount);\n        for (auto& cube : cubes) {\n            for (int i = 0; i < 6; ++i) {\n                cin >> cube[i];\n            }\n        }\n        \n        cout << calculateMinRepaints(cubes) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:12:07"
  }
]