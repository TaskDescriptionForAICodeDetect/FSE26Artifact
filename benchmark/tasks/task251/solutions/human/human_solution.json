[
  {
    "language": "C++",
    "code": "int dice24[24][6]=\n{\n\t{2,1,5,0,4,3},{2,0,1,4,5,3},{2,4,0,5,1,3},{2,5,4,1,0,3},{4,2,5,0,3,1},\n\t{5,2,1,4,3,0},{1,2,0,5,3,4},{0,2,4,1,3,5},{0,1,2,3,4,5},{4,0,2,3,5,1},\n\t{5,4,2,3,1,0},{1,5,2,3,0,4},{5,1,3,2,4,0},{1,0,3,2,5,4},{0,4,3,2,1,5},\n\t{4,5,3,2,0,1},{1,3,5,0,2,4},{0,3,1,4,2,5},{4,3,0,5,2,1},{5,3,4,1,2,0},\n\t{3,4,5,0,1,2},{3,5,1,4,0,2},{3,1,0,5,4,2},{3,0,4,1,5,2},\n};\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=4;\nint n,dice[maxn][6],ans;\n\nvector<string> names;\nint  ID(const char* name)\n{\n\tstring s(name);\n\tint n=names.size();\n\tfor (int i=0;i<n;i++)\n\tif (names[i]==s) return i;\n\tnames.push_back(s);\n\treturn n;\n}\n\nint r[maxn],color[maxn][6];\n\nvoid check()\n{\n\tfor (int i=0;i<n;i++)\n\t\tfor (int j=0;j<6;j++)\n\t\tcolor[i][dice24[r[i]][j]]=dice[i][j];\n\tint tot=0;\n\tfor (int j=0;j<6;j++)\n\t{\n\t\tint cnt[maxn*6];\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tint maxface=0;\n\t\tfor (int i=0;i<n;i++)\n\t\t\tmaxface=max(maxface,++cnt[color[i][j]]);\n\t\ttot+=n-maxface;\n\t}\n\tans=min(ans,tot);\n}\n\nvoid dfs(int d)\n{\n\tif (d==n) check();\n\telse for(int i=0;i<24;i++)\n\t{\n\t\tr[d]=i;\n\t\tdfs(d+1);\n\t}\n}\nint main()\n{\n\twhile (scanf(\"%d\",&n)==1&&n)\n\t{\n\t\tnames.clear();\n\t\tfor (int i=0;i<n;i++)\n\t\t\tfor (int j=0;j<6;j++)\n\t\t\t{\n\t\t\t\tchar name[30];\n\t\t\t\tscanf(\"%s\",name);\n\t\t\t\tdice[i][j]=ID(name);\n\t\t\t}\n\t\tans=n*6;\n\t\tr[0]=0;\n\t\tdfs(1);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\n// 28ñÅ³ÉàÇé\nclass Dice{\nprivate:\n  int yoko;\n  int tate;\n  int round;\n  \nprivate:\n    int face[3][4];\n  \npublic:\n  int getFace(int i,int j)const{\n    return face[i][j];\n  }\n  Dice(vector<int> &v){\n    init();\n    face[1][1]=v[0];\n    face[2][1]=v[1];\n    face[1][2]=v[2];\n    face[1][0]=v[3];\n    face[0][1]=v[4];\n    face[1][3]=v[5];\n  }\nprivate:\n  // _CXÌú»\n  void init(){\n    for(int i = 0; i < 3; i++){\n      for(int j = 0; j < 4; j++){\n\tface[i][j]=-1;\n      }\n    }\n    yoko=0;\n    tate=0;\n    round=0;\n  }\npublic:\n  // _CXÌñ]\n  void rotate(){\n    if(round<4){\n      int tmp = face[2][1];\n      face[2][1]=face[1][2];\n      face[1][2]=face[0][1];\n      face[0][1]=face[1][0];\n      face[1][0]=tmp;\n      round++;\n    }\n    if(round>=4){\n      round=0;\n      // àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n      if(yoko<4){\n\tint tmp = face[1][3];\n\tfor(int i = 2; i >= 0; i--){\n\t  face[1][i+1]=face[1][i];\n\t}\n\tface[1][0]=tmp;\n\tyoko++;\n      }\n      // àÇÁÄ«½çAcÌXbgðñ]³¹é\n      if(yoko>=4){\n\tif(tate<4){\n\t  tate++;\n\t  int tmp = face[1][3];\n\t  face[1][3]=face[0][1];\n\t  for(int i = 0; i < 2; i++){\n\t    face[i][1]=face[i+1][1];\n\t  }\n\t  face[2][1]=tmp;\n\t}\n\tif(tate>=4){\n\t  round=0;\n\t  tate=0;\n\t  yoko=0;\n\t}\n      }\n    }\n  };\n};\n\nconst int INF=1000000000;\nint n;\nvector<Dice> dices;\nint minCost;\nint msi[1001];\n\nvoid dfs(int depth){\n  if(depth==n){\n    int sum=0;\n    // Ê²ÆÉf[^ðûW\n    for(int i = 0; i < 6; i++){\n      memset(msi,0,sizeof(msi));\n      int maxNum=0;\n      for(int j = 0; j < n; j++){\n\tif(i==0){\n\t  msi[dices[j].getFace(1,1)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,1)]);\n\t}\n\telse if(i==1){\n\t  msi[dices[j].getFace(2,1)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(2,1)]);\n\t}\n\telse if(i==2){\n\t  msi[dices[j].getFace(1,2)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,2)]);\n\t}\n\telse if(i==3){\n\t  msi[dices[j].getFace(1,0)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,0)]);\n\t}\n\telse if(i==4){\n\t  msi[dices[j].getFace(0,1)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(0,1)]);\n\t}\n\telse{\n\t  msi[dices[j].getFace(1,3)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,3)]);\n\t}\n      }\n      sum+=n-maxNum;\n    }\n    minCost=min(sum,minCost);\n  }\n  else{\n    // ñ]Èµ\n    dfs(depth+1);\n    if(depth!=0){\n      for(int i = 0; i < 28; i++){\n\tdices[depth].rotate();\n\tdfs(depth+1);\n      }\n    }\n  }\n}\n\nint main(){\n  \n  while(cin>>n&&n!=0){\n    minCost=INF;\n    int idx=0;\n    map<string,int> idxs;\n    for(int i = 0; i < n; i++){\n      vector<int> v;\n      for(int j = 0; j < 6; j++){\n\tstring s;\n\tcin>>s;\n\tif(idxs.find(s)==idxs.end())\n\t  idxs[s]=idx++;\n\tv.push_back(idxs[s]);\n      }\n      dices.push_back(Dice(v));\n    }\n    dfs(0);\n    dices.clear();\n    cout<<minCost<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> rotate_map[24];\nvoid init(){\n  int idx = 0;\n  vector<int> per(3);\n  REP(i, 3) per[i] = i;\n  do{\n    REP(S, (1<<3)){\n      int cnt = 0;\n      REP(i, 3) if(per[i] != i + 1) cnt ++;\n      if(cnt == 0) cnt ++;\n      if((cnt + __builtin_popcount(S)) % 2 == 0) continue;\n      //if(__builtin_popcount(S) != 2 && __builtin_popcount(S) != 0) continue;\n      rotate_map[idx] = vector<int>(6);\n      REP(i, 6){\n        if(i < 3){\n          if(S & (1<<i)) rotate_map[idx][i] = (5 - per[i]);\n          else rotate_map[idx][i] = per[i];\n        }else{\n          rotate_map[idx][i] = (5 - rotate_map[idx][5-i]);\n        }\n      }\n      idx += 1;\n    }\n  }while(next_permutation(per.begin(), per.end()));\n  assert(idx == 24);\n}\nvector<string> face[4];\n/*\nint memo[4][4][1<<6][1<<6];\nbool judge(int idx1, int idx2, int S1, int S2){\n  S1 &= (1<<6) - 1;\n  S2 &= (1<<6) - 1;\n  int& res = memo[idx1][idx2][S1][S2];\n  if(res != -1) return res;\n  vector<string>& f1 = face[idx1];\n  vector<string>& f2 = face[idx2];\n  REP(k, 24){\n    bool ok = true;\n    REP(i, 6)if(f1[i] != f2[rotate_map[k][i]] && (!(S1 & (1<<i))) && (!(S2 & (1<<(rotate_map[k][i]))))) ok = false;\n\n    if(!ok) continue;\n    REP(i, 6) cout<<((S1 & (1<<i)) ? \"******\" : f1[i])<<\" \"; cout<<endl;\n    REP(i, 6) cout<<((S2 & (1<<rotate_map[k][i])) ? \"******\" : f2[rotate_map[k][i]])<<\" \"; cout<<endl;\n    cout<<endl;\n\n    if(ok) return res = true;\n  }\n  return res = false;\n}\n*/\nint main(){\n  int N;\n  init();\n  while(cin>>N && N){\n    //memset(memo, -1, sizeof(memo));\n    REP(i, N){\n      face[i] = vector<string>(6);\n      REP(j, 6){\n        cin>>face[i][j];\n      }\n    }\n    int ans = INF;\n    int MS = 1;\n    REP(i, N-1) MS *= 24;\n    for(int S = 0; S < MS; S++){\n      int m_idx[4] = {0};\n      int tmp_S = S;\n      REP(i, N-1){\n        m_idx[i + 1] = tmp_S % 24;\n        tmp_S /= 24;\n      }\n      int r_ans = 0;\n      REP(i, 6){\n        map<string, int> cnt;\n        REP(j, N) cnt[face[j][rotate_map[m_idx[j]][i]]]++;\n        int need = N - 1;\n        FORIT(it, cnt) need = min(need, N - it->second);\n        r_ans += need;\n      }\n      ans = min(ans, r_ans);\n    }\n    /*\n    for(int S = 0; S < (1<<(6 * N)); S++){\n      if(ans <= __builtin_popcount(S)) continue;\n      bool ok = true;\n      REP(i, N)FOR(j, i + 1, N){\n        if(!judge(i, j, S >> (6 * i), S >> (6 * j))) ok = false;\n      }\n      if(ok) ans = __builtin_popcount(S);\n      if(ok && __builtin_popcount(S) == 12){\n        REP(i, 4){\n          REP(j, 6) cout<<((S & (1<<(6 * i + j))) ? \"******\" : face[i][j])<<\" \";\n          cout<<endl;\n        }\n      }\n    }\n    */\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// Colored Cubes \n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1259\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#include<functional>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nenum AXIS {X, Y, Z};\nconst int INF = INT_MAX / 3;\nconst vector<vector<int>> pattern = {\n    {3, 1, 0, 5, 4, 2}, // x????????¢\n    {4, 0, 2, 3, 5, 1}, // y????????¢\n    {0, 3, 1, 4, 2, 5}  // z????????¢\n};\n\nint N;\nint ans, max_color;\nvector<vector<int>> cubes;\n\nvoid roll(int n, int axis) {\n    vector<int> result;\n    vector<int> cube = cubes[n];\n    for (int p : pattern[axis]) {\n        result.push_back(cube[p]);\n    }\n    cubes[n] = result;\n}\n\nint repaint() {\n    int res = 0;\n    for (int j = 0; j < 6; ++j) {\n        vector<int> counter(max_color);\n        for (int i = 0; i < N; ++i) {\n            ++counter[cubes[i][j]];\n        }\n        int most = *max_element(ALL(counter));\n        res += N - most;\n    }\n    return res;\n}\n\nvoid dfs(int n) {\n    if (n == N) {\n        ans = min(ans, repaint());\n        return;\n    }\n    for (int i = 0; i < 6; ++i) {\n        for (int x = 0; x < 4; ++x) {\n            dfs(n + 1);\n            roll(n, X);\n        }\n        if (i % 2 == 0) {\n            roll(n, Y);\n        } else {\n            roll(n, Z);\n        }\n    }\n    return;\n}\n\nint main() { \n    while (cin >> N) {\n        if (N == 0) break;\n\n        map<string, int> converter;\n        const function<int(string)> encode = [&](const string &color) -> int {\n            if (!converter.count(color)) converter.emplace(color, converter.size());\n            return converter[color];\n        };\n\n        cubes.assign(4, vector<int>(6, 0));\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < 6; ++j) {\n                string color;\n                cin >> color;\n                cubes[i][j] = encode(color);\n            }\n        }\n\n        ans = INF, max_color = converter.size();\n        dfs(0);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\n// 28ñÅ³ÉàÇé\nclass Dice{\nprivate:\n\tint yoko;\n\tint tate;\n\tint round;\n\nprivate:\n\tstring face[3][4];\n\npublic:\n\tstring getFace(int i,int j)const{\n\t\treturn face[i][j];\n\t}\n\n\tDice(vector<string> &v){\n\t\tinit();\n\t\tface[1][1]=v[0];\n\t\tface[2][1]=v[1];\n\t\tface[1][2]=v[2];\n\t\tface[1][0]=v[3];\n\t\tface[0][1]=v[4];\n\t\tface[1][3]=v[5];\n\t}\nprivate:\n\t// _CXÌú»\n\tvoid init(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tface[i][j]=\"\";\n\t\t\t}\n\t\t}\n\t\tyoko=0;\n\t\ttate=0;\n\t\tround=0;\n\t}\npublic:\n\t// _CXÌñ]\n\tvoid rotate(){\n\t\tif(round<4){\n\t\t\tstring tmp = face[2][1];\n\t\t\tface[2][1]=face[1][2];\n\t\t\tface[1][2]=face[0][1];\n\t\t\tface[0][1]=face[1][0];\n\t\t\tface[1][0]=tmp;\n\t\t\tround++;\n\t\t}\n\t\tif(round>=4){\n\t\t\tround=0;\n\t\t\t// àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n\t\t\tif(yoko<4){\n\t\t\t\tstring tmp = face[1][3];\n\t\t\t\tfor(int i = 2; i >= 0; i--){\n\t\t\t\t\tface[1][i+1]=face[1][i];\n\t\t\t\t}\n\t\t\t\tface[1][0]=tmp;\n\t\t\t\tyoko++;\n\t\t\t}\n\t\t\t// àÇÁÄ«½çAcÌXbgðñ]³¹é\n\t\t\tif(yoko>=4){\n\t\t\t\tif(tate<4){\n\t\t\t\t\ttate++;\n\t\t\t\t\tstring tmp = face[1][3];\n\t\t\t\t\tface[1][3]=face[0][1];\n\t\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\t\tface[i][1]=face[i+1][1];\n\t\t\t\t\t}\n\t\t\t\t\tface[2][1]=tmp;\n\t\t\t\t}\n\t\t\t\tif(tate>=4){\n\t\t\t\t\tround=0;\n\t\t\t\t\ttate=0;\n\t\t\t\t\tyoko=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\nconst int INF=1000000000;\nint n;\nvector<Dice> dices;\nint minCost;\n\nstring data[10][10];\nmap<string,int> msi;\n\nvoid dfs(int depth){\n    if(depth==n){\n        int sum=0;\n        // Ê²ÆÉf[^ðûW\n        for(int i = 0; i < 6; i++){\n            msi.clear();\n            for(int j = 0; j < n; j++){\n                if(i==0)\n                    msi[dices[j].getFace(1,1)]++;\n                else if(i==1)\n                    msi[dices[j].getFace(2,1)]++;\n                else if(i==2)\n                    msi[dices[j].getFace(1,2)]++;\n                else if(i==3)\n                    msi[dices[j].getFace(1,0)]++;\n                else if(i==4)\n                    msi[dices[j].getFace(0,1)]++;\n                else\n                    msi[dices[j].getFace(1,3)]++;\n            }\n            int maxNum=0;\n            for(map<string,int>::iterator it=msi.begin();it!=msi.end();it++){\n                if(it->second>maxNum){\n                    maxNum=it->second;\n                }\n            }\n            sum+=n-maxNum;\n        }\n        minCost=min(sum,minCost);\n    }\n    else{\n        // ñ]Èµ\n        dfs(depth+1);\n        for(int i = 0; i < 28; i++){\n            dices[depth].rotate();\n            dfs(depth+1);\n        }\n    }\n}\n\nint main(){\n    \n    while(cin>>n&&n!=0){\n        minCost=INF;\n        for(int i = 0; i < n; i++){\n            vector<string> v;\n            for(int j = 0; j < 6; j++){\n                string s;\n                cin>>s;\n                v.push_back(s);\n            }\n            dices.push_back(Dice(v));\n        }\n        dfs(0);\n        dices.clear();\n        cout<<minCost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nenum FACE { BACK, RIGHT, TOP, BOTTOM, LEFT, FRONT };\n\ntemplate <class T>\nclass Dice\n{\npublic:\n  Dice() {\n    id[TOP] = 2; id[FRONT] = 5; id[LEFT] = 4;\n    id[RIGHT] = 1; id[BACK] = 0; id[BOTTOM] = 3;\n  }\n\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const  { return var[id[f]]; }\n\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    int tmp = id[a];\n    id[a] = id[b];\n    id[b] = id[c];\n    id[c] = id[d];\n    id[d] = tmp;\n  }\n\n  T var[6];\n  int id[6];\n};\n\nint repaint(vector<Dice<int> >& cubes) {\n  int res = 0, N = cubes.size();\n  for(int j=0; j<6; j++) {\n    int C[50] = {0}, same = 0;\n    for(int i=0; i<N; i++) {\n      same = max(same, ++C[cubes[i][(FACE)j]]);\n    }\n\n    res += N - same;\n\n  }\n\n  return res;\n}\n\nint dfs(int p, int N, vector<Dice<int> >& cubes) {\n  if(p == N) return repaint(cubes);\n\n  int res = (1<<28);\n\n  Dice<int>& d = cubes[p];\n  for(int k=0; k<6; (k&1?d.roll_y():d.roll_x()),k++) {\n    for(int i=0; i<4; d.roll_z(), i++) {\n      res = min(res, dfs(p+1, N, cubes));\n    }\n  }\n\n  return res;\n}\n\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    vector<Dice<int> > cubes(N);\n    map<string, int> dic;\n    int color = 0;\n\n    for(int i=0; i<N; i++) {\n      for(int j=0; j<6; j++) {\n        string s;\n        cin >> s;\n        if(!dic.count(s)) dic[s] = color++;\n\n        cubes[i][(FACE)j] = dic[s];\n      }\n    }\n\n    cout << dfs(0, N, cubes) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct Dice{\n  int s[6];\n  void roll(char c){\n    int b;\n\n    if(c=='S'){\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n    if(c=='E'){\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='R'){\n      b=s[1];\n      s[1]=s[3];\n      s[3]=s[4];\n      s[4]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      b=s[1];\n      s[1]=s[2];\n      s[2]=s[4];\n      s[4]=s[3];\n      s[3]=b;\n    }\n  }\n};\n\nDice D[6];\nstring s[10][10];\nint a[10][10];\n\nint n,ans;\nint used[25];\n\nvoid dfs(int dep){\n  if(dep==n){\n    int T=n*6;\n    r(i,6){\n      memset(used,0,sizeof(used));\n      int MAX=0;\n      r(j,n){\n\tused[D[j].s[i]]++;\n\tMAX=max(MAX,used[D[j].s[i]]);\n      }\n      T-=MAX;\n    }\n    ans=min(T,ans);\n    return ;\n  }\n  r(k,2){\n    D[dep].roll('E');\n    r(i,4){\n      D[dep].roll('S');\n      r(j,4){\n\tD[dep].roll('R');\n\tdfs(dep+1);\n      }\n    }\n  }\n}\n\nint main(){\n  while( cin>>n , n ){\n    ans=1e9;\n    vector<string>v;\n    r(i,n){\n      r(j,6){\n\tcin>>s[i][j];\n\tv.push_back(s[i][j]);\n      }\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    map<string,int>M;\n    r(i,v.size()){\n      M[v[i]]=i;\n    }\n    r(i,n){\n      r(j,6){\n\ta[i][j]=M[s[i][j]];\n\tD[i].s[j]=a[i][j];\n      }\n    }\n    dfs(0);\n    cout<<ans<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  int id[6];\n  dice() {}\n  dice(T *v) {\n    id[TOP] = 2; id[FRONT] = 0; id[LEFT] = 4;\n    id[RIGHT] = 1; id[BACK] = 5; id[BOTTOM] = 3;\n    REP(i,6)\n      var[i] = v[i];\n  }\n  T& operator[] (int f) { return var[id[f]]; }\n  const T& operator[] (int f) const { return var[id[f]]; }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    int tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n};\n\nint n;\nvector<dice<int> > vd[4];\ndice<int> nowd[4];\n\nint solve(int now) {\n  if (now == n) {\n    int res = 0;\n    REP(i, 6) {\n      int table[24] = {};\n      REP(j, n) {\n        table[nowd[j][i]]++;\n      }\n      res += n - *max_element(table, table+24);\n    }\n    // REP(i, n) {\n    //   REP(j, 6)\n    //     cout << nowd[i].var[j] << \" \";\n    //   cout << endl;\n    // }\n    // cout << res << endl;\n    return res;\n  }\n  int res = INF;\n  FOR(it, vd[now]) {\n    nowd[now] = *it;\n    res = min(res, solve(now+1));\n  }\n  return res;\n}\n\n\nint main() {\n  while(cin>>n,n) {\n    dice<int> di[n];\n    map<string, int> mp;\n    int num = 0;\n    REP(i, n) {\n      int a[6];\n      REP(j, 6) {\n        string s;\n        cin >> s;\n        int id;\n        if (mp.count(s))\n          id = mp[s];\n        else\n          id = mp[s] = num++;\n        a[j] = id;\n      }\n      di[i] = dice<int>(a);\n    }\n    REP(i, n)\n      vd[i] = di[i].all_rolls();\n\n    if (n == 1) {\n      cout << 0 << endl;\n      continue;\n    }\n    cout << solve(0) << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Dice{\n  \npublic:\n  int TOP = 2, FRONT = 0, LEFT = 4, RIGHT = 1, BACK = 5, BOTTOM = 3;\n  vector<int> val;\n  Dice():val(6){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(vector<int> val):val(val){assert(val.size()==6);}\n  int& operator [](int a){return val[a];}\n  \n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n  \n  void rotS(){\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n  \n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n  \n  void rotW(){\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n  \n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n  \n  void rotCCW(){\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n  \n};\n\nDice dice[4][30];\nint N, ans;\nint ID[4];\n\nvoid cal(){\n  \n  int cnt = 0;\n  \n  for(int i=0;i<6;i++){\n    \n    unordered_map<int,int> A;\n    \n    for(int j=0;j<N;j++) A[dice[j][ID[j]][i]]++;\n    \n    int maxc = 0;\n    \n    for(auto p : A ) maxc = max( maxc, p.second );\n    \n    cnt += N - maxc;\n    \n  }\n  \n  ans = min( ans, cnt );\n  \n}\n\nvoid dfs(int x){\n  \n  if( x == N ){\n    cal();\n    return;\n  }\n  \n  for(int i=0;i<24;i++){\n    ID[x] = i;\n    dfs( x + 1 );\n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>N;\n    if( N == 0 ) break;\n    \n    vector<string> d[4];\n    map<string,int> memo;\n    int idx = 0;\n    \n    for(int i=0;i<N;i++){\n      \n      for(int j=0;j<6;j++){\n\tstring s;\n\tcin>>s;\n\td[i].push_back(s);\n\tif( memo.count(s) == 0 ) memo[s] = idx++;\n      }\n                  \n    }\n    \n    Dice di[4];\n    \n    for(int i=0;i<N;i++){\n      \n      vector<int> A;\n      \n      for(int j=0;j<6;j++){\n\t\n\tA.push_back( memo[d[i][j]] );\n\t\n      }\n      \n      di[i] = Dice(A);\n      \n    }\n        \n    for(int I=0;I<N;I++){\n      \n      int idx = 0;\n      \n      for(int i=0;i<4;i++){\n    \n\tfor(int j=0;j<4;j++){\n\t  \n\t  dice[I][idx++] = di[I];\n      \n\t  di[I].rotCW();\n      \n\t}\n    \n\tdi[I].rotN();\n\t\n      }\n\n      for(int i=0;i<4;i++){\n      \n\tif(i%2){\n      \n\t  for(int j=0;j<4;j++){\n      \n\t    dice[I][idx++] = di[I];\n      \n\t    di[I].rotCW();\n      \n\t  }\n      \n\t}\n\t\n\tdi[I].rotE();\n\t\n      }\n      \n      \n    }\n    \n    for(int i=0;i<N;i++){\n      \n      vector<int> A;\n      \n      for(int j=0;j<6;j++){\n\t\n\tA.push_back( memo[d[i][j]] );\n\t\n      }\n      \n      di[i] = Dice(A);\n      \n    }\n    \n    ans = 100;\n    \n    dfs( 1 );\n    \n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef vector<vector<int> > VVI;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint ans;\n\nclass Dice{\npublic:\n   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n   Dice(){}\n   Dice(int _t, int _s, int _e, int _n, int _w, int _b){\n       t = _t, s = _s,e = _e,n = _n,w = _w,b = _b;\n   }\n\n   Dice rotate_front(){\n      return Dice(s,b,e,t,w,n);\n   }\n\n   Dice rotate_left(){\n      return Dice(e,s,b,n,t,w);\n   }\n\n   Dice rotate_right(){\n      return Dice(w,s,t,n,b,e);\n   }\n\n   Dice rotate_back(){\n      return Dice(n,t,e,b,w,s);\n   }\n\n   Dice move_right(){\n      return Dice(t,e,n,w,s,b);\n   }\n\n   Dice move_left(){\n      return Dice(t,w,s,e,n,b);\n   }\n\n   void print(){\n      cout << \"t=\" << t << \"s=\" << s << \"e=\" << e << \"n=\" << n\n           << \"w=\" << w << \"b=\" << b << endl;\n   }\n};\n\nvector<Dice>all;\n\nDice getDice(int top, int south){\n   for(int i=0; i<24; i++){\n      if(all[i].t == top && all[i].s == south){\n         return all[i];\n      }\n   }\n}\n\nvoid allState(int a, int b, int c, int d, int e, int f){\n   all.clear();\n   Dice dice(a,b,c,d,e,f);\n   for(int i=0; i<6; i++){\n      for(int j=0; j<4; j++){\n         all.push_back(dice);\n         dice = dice.move_right();\n      }\n      if(i < 4) dice = dice.rotate_front();\n      if(i == 3) dice = dice.rotate_right();\n      if(i == 4) dice = dice.rotate_right().rotate_right();\n   }\n}\n\n\n/*VVI make(vector<int> v){ // from dice, make all dice pattern\n  VVI ret;\n\n  vector<int> org = v;  \n  \n  for(int i = 0 ; i < 6 ; i++){\n    vector<int> nex = org;\n    \n    ret.push_back(nex);\n    \n    swap(nex[0], nex[5]);\n    ret.push_back(nex);      \n    nex = org;\n    \n    swap(nex[1], nex[4]);\n    ret.push_back(nex);\n    \n    swap(nex[0], nex[5]);\n    ret.push_back(nex);      \n  }\n  \n  return ret;\n  }*/\n\n\n\nint N;\nvector<vector<vector<int> > >v;\n\n\nint check(vector<int> vv){\n  int res = 0;\n  vector<vector<int> >d;\n  d.resize(6);\n  for(int i=0; i<vv.size(); i++){\n    for(int j=0; j<6; j++){\n      d[j].push_back(v[i][vv[i]][j]);\n    }\n    /*\n    Dice dice = v[i][vv[i]];\n    d[0].push_back(dice.t);\n    d[1].push_back(dice.s);\n    d[2].push_back(dice.e);\n    d[3].push_back(dice.n);\n    d[4].push_back(dice.w);\n    d[5].push_back(dice.b);\n    */\n  }\n\n  for(int i=0; i<6; i++){\n    map<int,int>m;\n    for(int j=0; j<N; j++){\n      m[d[i][j]]++;\n    }\n\n    int Max = 0;\n    for(map<int,int>::iterator it=m.begin(); it != m.end(); it++){\n      Max = max(Max,it->second);\n    }\n    res += N - Max;\n    if(res >= ans) return 1<<29;\n  }\n  return res;\n}\n\n\nvoid dfs(int cnt, vector<int>vv){\n  if(ans == 0) return;\n  if(cnt == N){\n    ans = min(ans,check(vv));\n    return;\n  }\n\n  for(int i=0; i<v[cnt].size(); i++){\n    vector<int>tmp = vv;\n    tmp.push_back(i);\n    dfs(cnt+1,tmp);\n  }\n\n}\n\nint main(){\n\n  while(cin >> N, N){\n    set<string> S;\n    \n    string in[4][6];\n    \n    string s;\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tcin >> s;\n\tin[i][j] = s;\n\tS.insert(s);\n      }\n    }\n    \n    map<string, int> mp;\n    \n    int cnt = 1;\n    for(set<string>::iterator it = S.begin() ; it != S.end() ; it++){\n      mp[*it] = cnt++;\n    }\n    \n    int dice[4][6];\n    memset(dice, 0, sizeof(dice));\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tdice[i][j] = mp[in[i][j]];\n      }\n    }\n\n    //   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n\n    v.clear();\n\n    for(int i=0; i<N; i++){\n      allState(dice[i][2],dice[i][0],dice[i][1],dice[i][5],dice[i][4],dice[i][3]);\n\n\n      vector<vector<int> >tmp2;\n\n      for(int j=0; j<all.size(); j++){\n\tvector<int>tmp;\n\ttmp.push_back(all[j].t);\n\ttmp.push_back(all[j].s);\n\ttmp.push_back(all[j].e);\n\ttmp.push_back(all[j].n);\n\ttmp.push_back(all[j].w);\n\ttmp.push_back(all[j].b);\n\ttmp2.push_back(tmp);\n      }\n      v.push_back(tmp2);\n    }\n\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n\n\n    ans = 1<<29;\n    vector<int>e;\n    dfs(0,e);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct dice{\n  int x[6];\n  void roll_x(){roll(0,4,5,1);}\n  void roll_y(){roll(0,2,5,3);}\n  void roll_z(){roll(1,3,4,2);}\n\n  vector<dice> all_rolls(){\n    vector<dice> res;\n    for(int k=0; k<6; (k&1 ? roll_y() : roll_x()), k++){\n      for(int i=0; i<4; roll_z(),i++){\n        res.push_back(*this);\n      }\n    }\n    return res;\n  }\n\n  void roll(int a,int b,int c,int d){\n    int tmp = x[a];\n    x[a] = x[b];\n    x[b] = x[c];\n    x[c] = x[d];\n    x[d] = tmp;\n  }\n};\n\nvector<dice> a[4];\nint n,ans;\n\nvoid solve(vector<int> z) {\n  if(z.size()==n) {\n    int sum=0;\n    dice v[n];\n    for(int i=0; i<n; i++) v[i]=a[i][z[i]];\n    for(int i=0; i<6; i++) {\n      int c[30];\n      memset(c,0,sizeof(c));\n      for(int j=0; j<n; j++) c[v[j].x[i]]++;\n      int ma=0;\n      for(int i=0; i<30; i++) ma=max(ma,c[i]);\n      sum+=n-ma;\n    }\n    ans=min(ans,sum);\n    return;\n  }\n  for(int i=0; i<a[z.size()].size(); i++) {\n    vector<int> y=z;\n    y.push_back(i);\n    solve(y);\n  }\n}\n\nint main() {\n  while(cin >> n && n) {\n    for(int i=0; i<n; i++) a[i].clear();\n    ans=1000000007;\n\n    map<string, int> m;m.clear();\n    for(int i=0; i<n; i++) {\n      dice b;\n      for(int j=0; j<6; j++) {\n\tstring s;\n\tcin >> s;\n\tif(!m[s]) {\n\t  int q=m.size()+1;\n\t  m[s]=q;\n\t}\n\tb.x[j]=m[s];\n      }\n      a[i]=b.all_rolls();\n    }\n    vector<int> y;\n    solve(y);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint p[24][6]=\n{\n    {0,1,2,3,4,5},\n    {0,2,3,4,1,5},\n    {0,3,4,1,2,5},\n    {0,4,1,2,3,5},\n    {1,4,5,2,0,3},\n    {1,5,2,0,4,3},\n    {1,2,0,4,5,3},\n    {1,0,4,5,2,3},\n    {2,3,0,1,5,4},\n    {2,0,1,5,3,4},\n    {2,1,5,3,0,4},\n    {2,5,3,0,1,4},\n    {3,4,0,2,5,1},\n    {3,0,2,5,4,1},\n    {3,2,5,4,0,1},\n    {3,5,4,0,2,1},\n    {4,1,0,3,5,2},\n    {4,0,3,5,1,2},\n    {4,3,5,1,0,2},\n    {4,5,1,0,3,2},\n    {5,4,3,2,1,0},\n    {5,3,2,1,4,0},\n    {5,2,1,4,3,0},\n    {5,1,4,3,2,0}\n};\n\nint t[4];\nint mat[4][6];\nint n;\nint ans;\n\nvoid getans()\n{\n    int ret=0;\n    for (int i=0;i<6;i++)\n    {\n        int tmp[4];\n        for (int j=0;j<n;j++)\n            tmp[j]=mat[j][p[t[j]][i]];\n        int mymax=0;\n        for (int j=0;j<n;j++)\n        {\n            int count=0;\n            for (int k=0;k<n;k++)\n            {\n                if (tmp[j]==tmp[k])\n                    count++;\n            }\n            if (count>mymax)\n                mymax=count;\n        }\n        ret+=(n-mymax);\n    }\n    if (ret<ans)\n        ans=ret;\n}\nvoid dfs(int now)\n{\n    if (now==n)\n        getans();\n    else\n    {\n        for (int i=0;i<24;i++)\n        {\n            t[now]=i;\n            dfs(now+1);\n        }\n    }\n\n}\n\nmap<string,int> hash;\n\nint main()\n{\n\n    while(scanf(\"%d\",&n),n)\n    {\n        hash.clear();\n        int tot=0;\n        for (int i=0;i<n;i++)\n        {\n            string s;\n            for (int j=0;j<6;j++)\n            {\n                int tc=j;\n                if (j==3)   tc=4;\n                else if (j==4)  tc=3;\n                cin>>s;\n                if (hash.find(s)==hash.end())\n                {\n                    mat[i][tc]=hash[s]=tot++;\n                }\n                else mat[i][tc]=hash[s];\n            }\n        }\n        if (n==1)\n        {\n            puts(\"0\");\n            continue;\n        }\n        ans=10000000;\n        dfs(0);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(a) (cerr << #a << \" = \" << (a) << endl)\n\n#define REP(i,a,b) for(int i=(a);i < (int)(b); i++)\n#define rep(i,n) REP(i,0,n)\n#define ALL(v) begin(v), end(v)\n\nenum FACE {SOUTH, EAST, TOP, BOTTOM, WEST, NORTH};\n\ntypedef array<int, 6> A;\n\nstruct dice {\n  A value;\n\n  dice(const A &value_):value(value_) {}\n\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    const int t = value[a];\n    value[a] = value[b];\n    value[b] = value[c];\n    value[c] = value[d];\n    value[d] = t;\n  }\n\n  int operator[](const int f) const { return value[f]; }\n\n  void north() { roll(TOP, SOUTH, BOTTOM, NORTH); }\n  void south() { roll(TOP, NORTH, BOTTOM, SOUTH); }\n  void east()  { roll(TOP, WEST,  BOTTOM, EAST ); }\n  void west()  { roll(TOP, EAST,  BOTTOM, WEST ); }\n  void ccw()   { roll(NORTH, EAST, SOUTH, WEST ); }\n  void cw()    { roll(NORTH, WEST, SOUTH, EAST ); }\n};\n\nint ans;\nint n;\nvector<dice> dies;\n\nint calc() {\n  int res = 0;\n  for(int i = 0; i < 6; ++i) {\n    unordered_map<int, int> cnt;\n    for(const auto &d : dies) {\n      ++cnt[d[i]];\n    }\n\n    int mx = 0;\n    for(const auto &e : cnt) {\n      mx = max(mx, e.second);\n    }\n\n    res += n - mx;\n  }\n\n  return res;\n}\n\nvoid dfs(int idx) {\n  if(idx == n) {\n    ans = min(ans, calc());\n    return;\n  }\n\n  for(int i = 0; i < 4; ++i) {\n    for(int j = 0; j < 4; ++j) {\n      dies[idx].north();\n      dfs(idx + 1);\n    }\n\n    dies[idx].ccw();\n  }\n\n  dies[idx].east();\n  for(int i = 0; i < 2; ++i) {\n    for(int j = 0; j < 4; ++j) {\n      dies[idx].north();\n      dfs(idx + 1);\n    }\n    dies[idx].ccw();\n    dies[idx].ccw();\n  }\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  while(cin >> n && n) {\n    unordered_map<string, int> enc;\n    dies.clear();\n\n    for(int i = 0; i < n; ++i) {\n      A value;\n      for(auto &e : value) {\n\tstring s;\n\tcin >> s;\n\n\tif(!enc.count(s)) enc.insert({s, enc.size()});\n\te = enc[s];\n      }\n\n      dies.emplace_back(value);\n    }\n\n    ans = INT_MAX;\n    dfs(1);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\n// Library - cycoro - begin -7:26\n\nenum FACE {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\n\ntemplate<class T>\nclass dice{\npublic:\n  dice(){\n    //id[FRONT] = 0; id[RIGHT] = 1; id[TOP] = 2;\n    //id[BOTTOM] = 3; id[LEFT] = 4; id[BACK] = 5;\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f){ return var[id[f]]; }\n  const T& operator[] (FACE f)const { return var[id[f]];}\n  bool operator == (const dice<T> &b)const{\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] && \n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n\n  void roll_x() { roll(TOP,BACK,BOTTOM,FRONT); }\n  void roll_y() { roll(TOP,LEFT,BOTTOM,RIGHT); }\n  void roll_z() { roll(FRONT,RIGHT,BACK,LEFT); }\n\n  vector<dice> all_rolls(){\n  vector<dice> ret;\n  for(int k=0;k<6;(k&1?roll_y():roll_x()),++k)\n    for(int i=0;i<4;roll_z(),++i)\n      ret.push_back(*this);\n  return ret;\n  }\n\n  bool equivalent_to(const dice& di){\n    for(int k=0;k<6;(k&1?roll_y():roll_x()),++k)\n      for(int i=0;i<4;roll_z(),++i)\n\tif(*this == di)return true;\n    return false;\n  }\n\nprivate:\n  void roll(FACE a,FACE b,FACE c,FACE d){\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nFACE face[] = {FRONT,RIGHT,TOP,BOTTOM,LEFT,BACK};\n\n// Library - cycoro - end 07:34\n\nint n,mincost;\nvector<dice<int> > ALL[4];\n/*\nint getCost(int sp,vector<dice<int> >& dices){\n  int res = 0;\n  rep(i,n){\n    if(i == sp)continue;\n    rep(j,6){\n      if(dices[i][face[j]] != dices[sp][face[j]])res++;\n    }\n  }\n  return res;\n}\n*/\nvoid dfs(int cur,vector<dice<int> >&tmp){\n  if(cur >= n){\n    int cost = 0;\n    //int counter[6];\n    map<int,int> counter;\n    rep(fc,6){\n      counter.clear();\n      //rep(i,6)counter[i] = 0;\n      int mex = 0;\n      rep(i,n){\n\tcounter[tmp[i][face[fc]]]++;\n\tmex = max(mex,counter[tmp[i][face[fc]]]);\t\n      }\n      cost += (n - mex);\n      assert(n-mex >= 0);\n    }\n    mincost = min(cost,mincost);\n    return;\n  }\n\n  rep(i,ALL[cur].size()){\n    tmp[cur] = ALL[cur][i];\n    dfs(cur+1,tmp);\n  }\n\n}\n\nint main(){\n\n  while(cin >> n,n){\n    int idx = 0;\n    mincost= IINF;\n    map<string,int> getIndex;\n    vector<dice<int> > dices(n);\n    rep(i,n){\n      rep(j,6){\n\tstring color;\n\tcin >> color;\n\tif(getIndex.find(color) == getIndex.end())getIndex[color] = idx++;\n\tint index = getIndex[color];\n\tdices[i][face[j]] = index; \n      }\n    }\n\n    rep(i,n)ALL[i] = dices[i].all_rolls();\n    vector<dice<int> > tmp(n);\n\n    dfs(0,tmp);\n\n\n    cout << mincost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct cube{\n  string a[6];\n\n  int count=1;\n  \n  void move_N(){\n    string b[6]=a;\n    a[0]=b[1];\n    a[1]=b[2];\n    a[2]=b[3];\n    a[3]=b[0];\n  }\n\n  void move_E(){\n    string b[6]=a;\n    a[4]=b[1];\n    a[1]=b[5];\n    a[5]=b[3];\n    a[3]=b[4];\n  }\n\n  void move_R(){\n    string b[6]=a;\n    a[4]=b[2];\n    a[2]=b[5];\n    a[5]=b[0];\n    a[0]=b[4];\n  }\n\n  bool operator == (const cube &C){return C.a==a;}\n\n  void rotate(){\n    move_R();\n    if(count%4){}\n    else if(count/4<4){\n      move_N();\n    }\n    else if(count/4==4){\n      move_E();\n    }\n    else if(count/4==5){\n      move_E();\n      move_E();\n    }\n    count++;\n  }\n\n  cube(vector<string> &A){\n    a[0]=A[5];\n    a[1]=A[2];\n    a[2]=A[0];\n    a[3]=A[3];\n    a[4]=A[1];\n    a[5]=A[4];\n  }\n\n  cube(){}\n\n  void init(vector<string> &A){\n    for(int i=0;i<6;i++){a[i]=A[i];}\n  }\n\n  void operator = (const cube &C){\n    for(int i=0;i<6;i++){a[i]=C.a[i];}\n    count=C.count;\n  }\n};\n\nvector<cube> C(6);\nll n;\nll mi=1e18;\n\nll count(){\n  ll cost=0;\n  for(int i=0;i<6;i++){\n    map<string,ll> M;\n    ll mx=0;\n    for(int t=0;t<n;t++){\n      M[C[t].a[i]]++;\n      mx=max(mx,M[C[t].a[i]]);\n    }\n    cost+=n-mx;\n  }\n  return cost;\n}\n\nvoid dfs(ll d){\n  C[d].count=1;\n  if(d==n-1){\n    for(int i=0;i<24;i++){\n      mi=min(mi,count());\n      C[d].rotate();\n    }\n    return;\n  }\n  else{\n    for(int i=0;i<24;i++){\n      dfs(d+1);\n      C[d].rotate();\n    }\n  }\n}\n\nint main(){\n  while(cin>>n && n){\n    mi=1e9;\n  vector<vector<string>> a(n,vector<string>(6));\n  for(int i=0;i<n;i++){\n    for(int t=0;t<6;t++){\n      cin>>a[i][t];\n    }\n  }\n  if(n==1){cout<<0<<endl; continue;}\n  for(int i=0;i<n;i++){C[i]=cube(a[i]);}\n  dfs(1);\n  cout<<mi<<endl;\n  \n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nenum FACE {FRONT, RIGHT, TOP, BOTTOM, LEFT, BACK};\nvoid roll(string v[6], int a, int b, int c, int d){\n  string tmp = v[a];\n  v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = tmp;\n}\nvoid roll_x(string v[6]){\n  roll(v, TOP, BACK, BOTTOM, FRONT);\n}\nvoid roll_y(string v[6]){\n  roll(v, TOP, LEFT, BOTTOM, RIGHT);\n}\nvoid roll_z(string v[6]){\n  roll(v, FRONT, RIGHT, BACK, LEFT);\n}\nint N;\nstring dice[4][6];\nint min_ans;\nvoid dfs(int k){\n  if(k == N){\n    int res = 0;\n    for(int i = 0; i < 6; i++){\n      map<string, int> cnt;\n      int max_c = 0;\n      for(int j = 0; j < N; j++){\n        cnt[dice[j][i]]++;\n        max_c = max(max_c, cnt[dice[j][i]]);\n      }\n      res += N - max_c;\n      if(res >= min_ans) return;\n    }\n    min_ans = res;\n  }else{\n    for(int i = 0; i < 6; (i & 1 ? roll_x(dice[k]) : roll_y(dice[k])), ++i){\n      for(int j = 0; j < 4; roll_z(dice[k]), ++j){\n        dfs(k + 1);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> N && N){\n    REP(i, N) REP(j, 6) cin >> dice[i][j];\n    min_ans = INF;\n    dfs(0);\n    cout << min_ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<fstream>\n#include<sstream>\n#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<map>\n#include <algorithm>\n\n#define INF 0x7fffffff\n\nusing namespace std;\n\nint i,j,k,l,m,n;\n int c[5][6],t[30],z[6];\n int w[24][6]={2,3,0,5,4,1, 3,2,0,5,1,4, 4,1,0,5,3,2, 1,4,0,5,2,3,\n2,3,1,4,0,5, 3,2,1,4,5,0, 0,5,1,4,3,2, 5,0,1,4,2,3,\n5,0,2,3,4,1, 0,5,2,3,1,4, 4,1,2,3,0,5, 1,4,2,3,5,0,\n5,0,3,2,1,4, 0,5,3,2,4,1, 1,4,3,2,0,5, 4,1,3,2,5,0,\n2,3,4,1,5,0, 3,2,4,1,0,5, 5,0,4,1,3,2, 0,5,4,1,2,3,\n2,3,5,0,1,4, 3,2,5,0,4,1, 1,4,5,0,3,2, 4,1,5,0,2,3};\nstring st;\nint dfs(int o) {\nint ans=INF,i,j,k;\nif (o>n) {\nans=0;\nfor(int i=0;i<=5;i++) {\nmemset(t,0,sizeof(t));int ma=0;\nfor(int j=0;j<=n;j++) ma=max(ma,++t[c[j][w[z[j]][i]]]);\nans+=(n-ma);\n}\nreturn ans;}\nfor(int i=0;i<=23;i++) {\nz[o]=i;ans=min(ans,dfs(o+1));}\nreturn ans;\n}\nint main() {\n\nmap <string,int> a;\nwhile (scanf(\"%d\",&n)!=EOF && n) {\nfor(int i=1;i<=n;i++) for(int j=0;j<=5;j++) {\ncin>>st;if (!a[st]) a[st]=++m;\nc[i][j]=a[st];}\nz[1]=0;printf(\"%d\\n\",dfs(2));\nmap<string,int>::iterator o=a.begin();\nfor (;o!=a.end();o++) o->second=0;\n\nm=0;}\nreturn 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b)a=b;};\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b)a=b;};\n\nstruct Dice{\n  Int s[6];\n  void roll(char c){\n    Int b;\n    if(c == 'E'){\n      b = s[0];\n      s[0] = s[3];\n      s[3] = s[5];\n      s[5] = s[2];\n      s[2] = b;\n    }\n\n    if(c == 'W'){\n      b = s[0];\n      s[0] = s[2];\n      s[2] = s[5];\n      s[5] = s[3];\n      s[3] = b;\n    }\n\n    if(c == 'N'){\n      b = s[0];\n      s[0] = s[1];\n      s[1] = s[5];\n      s[5] = s[4];\n      s[4] = b;\n    }\n\n    if(c == 'S'){\n      b = s[0];\n      s[0] = s[4];\n      s[4] = s[5];\n      s[5] = s[1];\n      s[1] = b;\n    }\n\n    if(c == 'R'){\n      b= s[1];\n      s[1] = s[2];\n      s[2] = s[4];\n      s[4] = s[3];\n      s[3] = b;\n    }\n    \n    if(c == 'L'){\n      b = s[1];\n      s[1] = s[3];\n      s[3] = s[4];\n      s[4] = s[2];\n      s[2] = b;\n    }\n  }\n};\n\n\nvector<Dice> makeDices(Dice d){\n  vector<Dice> res;\n  for(Int i=0;i<6;i++){\n    Dice t(d);\n    if(i == 1) t.roll('N');\n    if(i == 2) t.roll('S');\n    if(i == 3) t.roll('S'), t.roll('S');\n    if(i == 4) t.roll('L');\n    if(i == 5) t.roll('R');\n    for(Int k=0;k<4;k++){\n      res.push_back(t);\n      t.roll('E');\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  while(cin>>n,n){\n    vector<Dice> vs;\n    Int sz=0;\n    map<string, Int> cm;\n    for(Int i=0;i<n;i++){\n      vs.emplace_back();\n      for(Int j=0;j<6;j++){\n\tstring s;\n\tcin>>s;\n\tif(!cm.count(s)) cm[s]=sz++;\n\tvs[i].s[j]=cm[s];\n      }     \n    }\n    \n    if(n==1){\n      cout<<0<<endl;\n    }else if(n==2){\n      auto A = makeDices(vs[0]);\n      auto B = makeDices(vs[1]);\n      Int ans=1e9;      \n      for(auto &a:A){\n\tfor(auto &b:B){\n\t  Int res=0;\n\t  for(Int j=0;j<6;j++){\n\t    map<Int, Int> x;\n\t    x[a.s[j]]++;\n\t    x[b.s[j]]++;\n\t    Int y=0;\n\t    for(auto p:x) chmax(y,p.second);\n\t    res+=2-y;\n\t  }\t  \n\t  chmin(ans,res);\n\t}\n      }      \n      cout<<ans<<endl;\n    }else if(n==3){\n      auto A = makeDices(vs[0]);\n      auto B = makeDices(vs[1]);\n      auto C = makeDices(vs[2]);\n      Int ans=1e9;\n      \n      for(auto &a:A){\n\tfor(auto &b:B){\n\t  for(auto &c:C){\n\t    Int res=0;\n\t    for(Int j=0;j<6;j++){\n\t      map<Int, Int> x;\n\t      x[a.s[j]]++;\n\t      x[b.s[j]]++;\n\t      x[c.s[j]]++;\n\t      Int y=0;\n\t      for(auto p:x) chmax(y,p.second);\n\t      res+=3-y;\n\t    }\t  \n\t    chmin(ans,res);\n\t  }\n\t}\n      }\n      cout<<ans<<endl;\n    }else{\n      auto A = makeDices(vs[0]);\n      auto B = makeDices(vs[1]);\n      auto C = makeDices(vs[2]);\n      auto D = makeDices(vs[3]);\n      Int ans=1e9;      \n      for(auto &a:A){\n\tfor(auto &b:B){\n\t  for(auto &c:C){\n\t    for(auto &d:D){\n\t      Int res=0;\n\t      for(Int j=0;j<6;j++){\n\t\tmap<Int, Int> x;\n\t\tx[a.s[j]]++;\n\t\tx[b.s[j]]++;\n\t\tx[c.s[j]]++;\n\t\tx[d.s[j]]++;\n\t\tInt y=0;\n\t\tfor(auto p:x) chmax(y,p.second);\n\t\tres+=4-y;\n\t      }\t  \n\t      chmin(ans,res);\n\t    }\n\t  }\n\t}\n      }\n      cout<<ans<<endl;\n    }    \n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b)a=b;};\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b)a=b;};\n\nstruct Dice{\n  Int s[6];\n  void roll(char c){\n    Int b;\n    if(c == 'E'){\n      b = s[0];\n      s[0] = s[3];\n      s[3] = s[5];\n      s[5] = s[2];\n      s[2] = b;\n    }\n\n    if(c == 'W'){\n      b = s[0];\n      s[0] = s[2];\n      s[2] = s[5];\n      s[5] = s[3];\n      s[3] = b;\n    }\n\n    if(c == 'N'){\n      b = s[0];\n      s[0] = s[1];\n      s[1] = s[5];\n      s[5] = s[4];\n      s[4] = b;\n    }\n\n    if(c == 'S'){\n      b = s[0];\n      s[0] = s[4];\n      s[4] = s[5];\n      s[5] = s[1];\n      s[1] = b;\n    }\n\n    if(c == 'R'){\n      b= s[1];\n      s[1] = s[2];\n      s[2] = s[4];\n      s[4] = s[3];\n      s[3] = b;\n    }\n    \n    if(c == 'L'){\n      b = s[1];\n      s[1] = s[3];\n      s[3] = s[4];\n      s[4] = s[2];\n      s[2] = b;\n    }\n  }\n};\n\n\nvector<Dice> makeDices(Dice d){\n  vector<Dice> res;\n  for(Int i=0;i<6;i++){\n    Dice t(d);\n    if(i == 1) t.roll('N');\n    if(i == 2) t.roll('S');\n    if(i == 3) t.roll('S'), t.roll('S');\n    if(i == 4) t.roll('L');\n    if(i == 5) t.roll('R');\n    for(Int k=0;k<4;k++){\n      res.push_back(t);\n      t.roll('E');\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  while(cin>>n,n){\n    vector<Dice> vs;\n    Int sz=0;\n    map<string, Int> cm;\n    for(Int i=0;i<n;i++){\n      vs.emplace_back();\n      for(Int j=0;j<6;j++){\n\tstring s;\n\tcin>>s;\n\tif(!cm.count(s)) cm[s]=sz++;\n\tvs[i].s[j]=cm[s];\n      }     \n    }\n    \n    if(n==1){\n      cout<<0<<endl;\n    }else if(n==2){\n      auto A = makeDices(vs[0]);\n      auto B = makeDices(vs[1]);\n      Int ans=1e9;      \n      for(auto &a:A){\n\tfor(auto &b:B){\n\t  Int res=0;\n\t  for(Int j=0;j<6;j++){\n\t    map<Int, Int> x;\n\t    x[a.s[j]]++;\n\t    x[b.s[j]]++;\n\t    Int y=0;\n\t    for(auto p:x) chmax(y,p.second);\n\t    res+=2-y;\n\t  }\t  \n\t  chmin(ans,res);\n\t}\n      }      \n      cout<<ans<<endl;\n    }else if(n==3){\n      auto A = makeDices(vs[0]);\n      auto B = makeDices(vs[1]);\n      auto C = makeDices(vs[2]);\n      Int ans=1e9;\n      \n      for(auto &a:A){\n\tfor(auto &b:B){\n\t  for(auto &c:C){\n\t    Int res=0;\n\t    for(Int j=0;j<6;j++){\n\t      map<Int, Int> x;\n\t      x[a.s[j]]++;\n\t      x[b.s[j]]++;\n\t      x[c.s[j]]++;\n\t      Int y=0;\n\t      for(auto p:x) chmax(y,p.second);\n\t      res+=3-y;\n\t    }\t  \n\t    chmin(ans,res);\n\t  }\n\t}\n      }\n      cout<<ans<<endl;\n    }else{\n      auto A = makeDices(vs[0]);\n      auto B = makeDices(vs[1]);\n      auto C = makeDices(vs[2]);\n      auto D = makeDices(vs[3]);\n      Int ans=1e9;      \n      for(auto &a:A){\n\tfor(auto &b:B){\n\t  for(auto &c:C){\n\t    for(auto &d:D){\n\t      Int res=0;\n\t      for(Int j=0;j<6;j++){\n\t\tmap<Int, Int> x;\n\t\tx[a.s[j]]++;\n\t\tx[b.s[j]]++;\n\t\tx[c.s[j]]++;\n\t\tx[d.s[j]]++;\n\t\tInt y=0;\n\t\tfor(auto p:x) chmax(y,p.second);\n\t\tres+=4-y;\n\t      }\t  \n\t      chmin(ans,res);\n\t    }\n\t  }\n\t}\n      }\n      cout<<ans<<endl;\n    }    \n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\n// 28ñÅ³ÉàÇé\nclass Dice{\nprivate:\n\tint yoko;\n\tint tate;\n\tint round;\n\nprivate:\n    int face[3][4];\n\npublic:\n\tint getFace(int i,int j)const{\n\t\treturn face[i][j];\n\t}\n\tDice(vector<int> &v){\n\t\tinit();\n\t\tface[1][1]=v[0];\n\t\tface[2][1]=v[1];\n\t\tface[1][2]=v[2];\n\t\tface[1][0]=v[3];\n\t\tface[0][1]=v[4];\n\t\tface[1][3]=v[5];\n\t}\nprivate:\n\t// _CXÌú»\n\tvoid init(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tface[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tyoko=0;\n\t\ttate=0;\n\t\tround=0;\n\t}\npublic:\n\t// _CXÌñ]\n\tvoid rotate(){\n\t\tif(round<4){\n            int tmp = face[2][1];\n\t\t\tface[2][1]=face[1][2];\n\t\t\tface[1][2]=face[0][1];\n\t\t\tface[0][1]=face[1][0];\n\t\t\tface[1][0]=tmp;\n\t\t\tround++;\n\t\t}\n\t\tif(round>=4){\n\t\t\tround=0;\n\t\t\t// àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n\t\t\tif(yoko<4){\n                int tmp = face[1][3];\n\t\t\t\tfor(int i = 2; i >= 0; i--){\n\t\t\t\t\tface[1][i+1]=face[1][i];\n\t\t\t\t}\n\t\t\t\tface[1][0]=tmp;\n\t\t\t\tyoko++;\n\t\t\t}\n\t\t\t// àÇÁÄ«½çAcÌXbgðñ]³¹é\n\t\t\tif(yoko>=4){\n\t\t\t\tif(tate<4){\n\t\t\t\t\ttate++;\n\t\t\t\t\tint tmp = face[1][3];\n\t\t\t\t\tface[1][3]=face[0][1];\n\t\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\t\tface[i][1]=face[i+1][1];\n\t\t\t\t\t}\n\t\t\t\t\tface[2][1]=tmp;\n\t\t\t\t}\n\t\t\t\tif(tate>=4){\n\t\t\t\t\tround=0;\n\t\t\t\t\ttate=0;\n\t\t\t\t\tyoko=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\nconst int INF=1000000000;\nint n;\nvector<Dice> dices;\nint minCost;\nint msi[1001];\n\nvoid dfs(int depth){\n    if(depth==n){\n        int sum=0;\n        // Ê²ÆÉf[^ðûW\n        for(int i = 0; i < 6; i++){\n            memset(msi,0,sizeof(msi));\n            int maxNum=0;\n            for(int j = 0; j < n; j++){\n                if(i==0){\n                    msi[dices[j].getFace(1,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,1)]);\n                }\n                else if(i==1){\n                    msi[dices[j].getFace(2,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(2,1)]);\n                }\n                else if(i==2){\n                    msi[dices[j].getFace(1,2)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,2)]);\n                }\n                else if(i==3){\n                    msi[dices[j].getFace(1,0)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,0)]);\n                }\n                else if(i==4){\n                    msi[dices[j].getFace(0,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(0,1)]);\n                }\n                else{\n                    msi[dices[j].getFace(1,3)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,3)]);\n                }\n            }\n            sum+=n-maxNum;\n        }\n        minCost=min(sum,minCost);\n    }\n    else{\n        // ñ]Èµ\n        dfs(depth+1);\n        for(int i = 0; i < 28; i++){\n            dices[depth].rotate();\n            dfs(depth+1);\n        }\n    }\n}\n\nint main(){\n    \n    while(cin>>n&&n!=0){\n        minCost=INF;\n        int idx=0;\n        map<string,int> idxs;\n        for(int i = 0; i < n; i++){\n            vector<int> v;\n            for(int j = 0; j < 6; j++){\n                string s;\n                cin>>s;\n                if(idxs.find(s)==idxs.end())\n                    idxs[s]=idx++;\n                v.push_back(idxs[s]);\n            }\n            dices.push_back(Dice(v));\n        }\n        dfs(0);\n        dices.clear();\n        cout<<minCost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\n// 28ñÅ³ÉàÇé\nclass Dice{\nprivate:\n\tint yoko;\n\tint tate;\n\tint round;\n\nprivate:\n    int face[3][4];\n\npublic:\n\tint getFace(int i,int j)const{\n\t\treturn face[i][j];\n\t}\n\tDice(vector<int> &v){\n\t\tinit();\n\t\tface[1][1]=v[0];\n\t\tface[2][1]=v[1];\n\t\tface[1][2]=v[2];\n\t\tface[1][0]=v[3];\n\t\tface[0][1]=v[4];\n\t\tface[1][3]=v[5];\n\t}\nprivate:\n\t// _CXÌú»\n\tvoid init(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tface[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tyoko=0;\n\t\ttate=0;\n\t\tround=0;\n\t}\npublic:\n\t// _CXÌñ]\n\tvoid rotate(){\n\t\tif(round<4){\n            int tmp = face[2][1];\n\t\t\tface[2][1]=face[1][2];\n\t\t\tface[1][2]=face[0][1];\n\t\t\tface[0][1]=face[1][0];\n\t\t\tface[1][0]=tmp;\n\t\t\tround++;\n\t\t}\n\t\tif(round>=4){\n\t\t\tround=0;\n\t\t\t// àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n\t\t\tif(yoko<4){\n                int tmp = face[1][3];\n\t\t\t\tfor(int i = 2; i >= 0; i--){\n\t\t\t\t\tface[1][i+1]=face[1][i];\n\t\t\t\t}\n\t\t\t\tface[1][0]=tmp;\n\t\t\t\tyoko++;\n\t\t\t}\n\t\t\t// àÇÁÄ«½çAcÌXbgðñ]³¹é\n\t\t\tif(yoko>=4){\n\t\t\t\tif(tate<4){\n\t\t\t\t\ttate++;\n\t\t\t\t\tint tmp = face[1][3];\n\t\t\t\t\tface[1][3]=face[0][1];\n\t\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\t\tface[i][1]=face[i+1][1];\n\t\t\t\t\t}\n\t\t\t\t\tface[2][1]=tmp;\n\t\t\t\t}\n\t\t\t\tif(tate>=4){\n\t\t\t\t\tround=0;\n\t\t\t\t\ttate=0;\n\t\t\t\t\tyoko=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\nconst int INF=1000000000;\nint n;\nvector<Dice> dices;\nint minCost;\nint msi[1001];\n\nvoid dfs(int depth){\n    if(depth==n){\n        int sum=0;\n        // Ê²ÆÉf[^ðûW\n        for(int i = 0; i < 6; i++){\n            memset(msi,0,sizeof(msi));\n            int maxNum=0;\n            for(int j = 0; j < n; j++){\n                if(i==0){\n                    msi[dices[j].getFace(1,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,1)]);\n                }\n                else if(i==1){\n                    msi[dices[j].getFace(2,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(2,1)]);\n                }\n                else if(i==2){\n                    msi[dices[j].getFace(1,2)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,2)]);\n                }\n                else if(i==3){\n                    msi[dices[j].getFace(1,0)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,0)]);\n                }\n                else if(i==4){\n                    msi[dices[j].getFace(0,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(0,1)]);\n                }\n                else{\n                    msi[dices[j].getFace(1,3)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,3)]);\n                }\n            }\n            sum+=n-maxNum;\n        }\n        minCost=min(sum,minCost);\n    }\n    else{\n        // ñ]Èµ\n        dfs(depth+1);\n        for(int i = 0; i < 24; i++){\n            dices[depth].rotate();\n            dfs(depth+1);\n        }\n    }\n}\n\nint main(){\n    \n    while(cin>>n&&n!=0){\n        minCost=INF;\n        int idx=0;\n        map<string,int> idxs;\n        for(int i = 0; i < n; i++){\n            vector<int> v;\n            for(int j = 0; j < 6; j++){\n                string s;\n                cin>>s;\n                if(idxs.find(s)==idxs.end())\n                    idxs[s]=idx++;\n                v.push_back(idxs[s]);\n            }\n            dices.push_back(Dice(v));\n        }\n        dfs(0);\n        dices.clear();\n        cout<<minCost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\n#include<complex>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cctype>\n#include<cstring>\nusing namespace std;\n \n#define REP(i,x,n) for(int i = x ; i < (int)(n) ; i++)\n#define rep(i,n) REP(i, 0, n)\n \nstruct Dice{\n  //top, front, right, left, back, bottom\n  string side[6];\n  Dice(){}\n  Dice(string s[]){\n    rep(i,6) side[i] = s[i];\n  }\n    \n  void rotate(int op){\n    string tmp = \"\";\n    //右に倒す\n    if(op==0){\n      tmp = side[0];\n      side[0] = side[3];\n      side[3] = side[5];\n      side[5] = side[2];\n      side[2] = tmp;\n    }\n  \n    //前に倒す\n    if(op==1){\n      tmp = side[0];\n      side[0] = side[4];\n      side[4] = side[5];\n      side[5] = side[1];\n      side[1] = tmp;\n    }\n        \n    //左に倒す\n    if(op==2){\n      tmp = side[0];\n      side[0] = side[2];\n      side[2] = side[5];\n      side[5] = side[3];\n      side[3] = tmp;\n    }\n        \n    //後ろに倒す\n    if(op==3){\n      tmp = side[0];\n      side[0] = side[1];\n      side[1] = side[5];\n      side[5] = side[4];\n      side[4] = tmp;\n    }\n  \n    //topとbottomを軸に右回転\n    if(op==4){\n      tmp = side[1];\n      side[1] = side[2];\n      side[2] = side[4];\n      side[4] = side[3];\n      side[3] = tmp;\n    }\n        \n    //topとbottomを軸に左回転\n    if(op==5){\n      tmp = side[1];\n      side[1] = side[3];\n      side[3] = side[4];\n      side[4] = side[2];\n      side[2] = tmp;\n    }\n  }\n};\n \nint n;\nint ans;\nDice dice[4];\n \nvoid solve(){\n  int res = 0;\n   \n  rep(j,6){\n    if(ans <= res) break;\n    vector<string> s;\n    rep(i,n) s.push_back(dice[i].side[j]);\n    sort(s.begin(), s.end());\n    if(n==2){\n      if(s[0] != s[1]) res++;\n    }\n    if(n==3){\n      if(s[0] != s[1] && s[1] != s[2]) res+=2;\n      else if(s[0] != s[1] || s[1] != s[2]) res++;\n    }\n    if(n==4){\n      if(s[0] != s[1] && s[1] != s[2] && s[2] != s[3]) res+=3;\n      else if(s[0] == s[1] && s[1] != s[2] && s[2] != s[3]) res+=2;\n      else if(s[0] != s[1] && s[1] == s[2] && s[2] != s[3]) res+=2;\n      else if(s[0] != s[1] && s[1] != s[2] && s[2] == s[3]) res+=2;\n      else if(s[0] == s[1] && s[1] != s[2] && s[2] == s[3]) res+=2;\n      else if(s[0] == s[1] && s[1] == s[2] && s[2] != s[3]) res+=1;\n      else if(s[0] != s[1] && s[1] == s[2] && s[2] == s[3]) res+=1;\n    }\n  }\n \n  ans = min(ans, res);\n}\n \nvoid dfs(int idx){\n  if(idx==n) solve();\n  else{\n    rep(i,24){\n      if(i==4) dice[idx].rotate(1);\n      if(i==8) dice[idx].rotate(1);\n      if(i==12)dice[idx].rotate(1);\n      if(i==16){\n        dice[idx].rotate(1);\n        dice[idx].rotate(0);\n      }\n      if(i==20){\n        dice[idx].rotate(2);\n        dice[idx].rotate(2);\n      }\n       \n      dice[idx].rotate(4);\n      dfs(idx + 1);\n    }\n  }\n}\n \nint main(){\n  while(cin >> n && n){\n    rep(i,n){\n      rep(j,6){\n        cin >> dice[i].side[j];\n      }\n    }\n    ans = 6 * n;\n    if(n > 1) dfs(1);\n    else ans = 0;\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> rotate_map[24];\nvoid init(){\n  int idx = 0;\n  vector<int> per(3);\n  REP(i, 3) per[i] = i;\n  do{\n    REP(S, (1<<3)){\n      int cnt = 0;\n      REP(i, 3) if(per[i] != i + 1) cnt ++;\n      if(cnt == 0) cnt ++;\n      if((cnt + __builtin_popcount(S)) % 2 == 0) continue;\n      //if(__builtin_popcount(S) != 2 && __builtin_popcount(S) != 0) continue;\n      rotate_map[idx] = vector<int>(6);\n      REP(i, 6){\n        if(i < 3){\n          if(S & (1<<i)) rotate_map[idx][i] = (5 - per[i]);\n          else rotate_map[idx][i] = per[i];\n        }else{\n          rotate_map[idx][i] = (5 - rotate_map[idx][5-i]);\n        }\n      }\n      idx += 1;\n    }\n  }while(next_permutation(per.begin(), per.end()));\n}\nvector<string> face[4];\ntypedef pair<int,int> P;\ntypedef pair<P, P> PP;\nint memo[4][4][1<<6][1<<6];\nbool judge(int idx1, int idx2, int S1, int S2){\n  S1 &= (1<<6) - 1;\n  S2 &= (1<<6) - 1;\n  int& res = memo[idx1][idx2][S1][S2];\n  if(res != -1) return res;\n  vector<string> f1 = face[idx1];\n  vector<string> f2 = face[idx2];\n  REP(k, 24){\n    bool ok = true;\n    REP(i, 6)if(f1[i] != f2[rotate_map[k][i]] && (!(S1 & (1<<i))) && (!(S2 & (1<<(rotate_map[k][i]))))) ok = false;\n    if(ok) return res = true;\n  }\n  return res = false;\n}\nint main(){\n  int N;\n  init();\n  while(cin>>N && N){\n    memset(memo, -1, sizeof(memo));\n    REP(i, N){\n      face[i] = vector<string>(6);\n      REP(j, 6){\n        cin>>face[i][j];\n      }\n    }\n    int ans = INF;\n    for(int S = 0; S < (1<<(6 * N)); S++){\n      if(ans <= __builtin_popcount(S)) continue;\n      bool ok = true;\n      REP(i, N)FOR(j, i + 1, N){\n        if(!judge(i, j, S >> (6 * i), S >> (6 * j))) ok = false;\n      }\n      if(ok) ans = __builtin_popcount(S);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nmap<string, int> idx;\nint cube[4][6], buf[4][6];\nint res, color, n;\nconst int move[24][6] = {\n    {0, 1, 2, 3 ,4, 5}, {0, 2, 4, 1, 3, 5}, {0, 4, 3, 2, 1, 5}, {0, 3, 1, 4, 2, 5},\n    {3, 1, 0, 5, 4, 2}, {3, 0, 4, 1, 5, 2}, {3, 4, 5, 0, 1, 2}, {3, 5, 1, 4, 0, 2},\n    {5, 1, 3, 2, 4, 0}, {5, 3, 4, 1, 2, 0}, {5, 4, 2, 3, 1, 0}, {5, 2, 1, 4, 3, 0},\n    {2, 1, 5, 0, 4, 3}, {2, 5, 4, 1, 0, 3}, {2, 4, 0, 5, 1, 3}, {2, 0, 1, 4, 5, 3},\n    {4, 0, 2, 3, 5, 1}, {4, 2, 5, 0, 3, 1}, {4, 5, 3, 2, 0, 1}, {4, 3, 0, 5, 2, 1},\n    {1, 0, 3, 2, 5, 4}, {1, 3, 5, 0, 2, 4}, {1, 5, 2, 3, 0, 4}, {1, 2, 0, 5, 3, 4}\n};\n\nvoid dfs(int dep)\n{\n    int tmp = 0;\n    if (dep == n)\n    {\n        for (int i = 0; i < 6; i++)\n        {\n            int cnt[24] = {0};\n            for (int j = 0; j < n; j++)\n                cnt[buf[j][i]]++;\n            int mx = 0;\n            for (int j = 0; j < color; j++)\n                mx = max(mx, cnt[j]);\n            tmp += n - mx;\n        }\n        res = min(tmp, res);\n        return;\n    }\n    for (int i = 0; i < 24; i++)\n        for (int j = 0; j < 6; j++)\n        {\n            buf[dep][j] = cube[dep][move[i][j]];\n            dfs(dep + 1);\n        }\n}\n\nint main()\n{\n    while (cin>>n)\n    {\n        color = 0;\n        idx.clear();\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < 6; j++)\n            {\n                string str;\n                cin>>str;\n                if (idx.find(str) == idx.end())\n                    idx[str] = color++;\n                cube[i][j] = idx[str];\n            }\n        for (int j = 0; j < 6; j++)\n            buf[0][j] = cube[0][j];\n        res = 100000;\n        if (n == 1)\n            res = 0;\n        else\n            dfs(1);\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n \nusing namespace std;\n\n//   swap(d[], d[]);\nvoid rot1(vector <int> &d) {\n  swap(d[1], d[2]);\n  swap(d[2], d[4]);\n  swap(d[4], d[3]);\n}\nvoid rot2(vector <int> &d) {\n  swap(d[1], d[0]);\n  swap(d[0], d[4]);\n  swap(d[4], d[5]);\n}\nvoid rot3(vector <int> &d) {\n  swap(d[0], d[3]);\n  swap(d[3], d[5]);\n  swap(d[5], d[2]);\n}\nvoid rev1(vector <int> &d) {\n  swap(d[1], d[3]);\n  swap(d[3], d[4]);\n  swap(d[4], d[2]);\n}\nvoid rev2(vector <int> &d) {\n  swap(d[1], d[5]);\n  swap(d[5], d[4]);\n  swap(d[4], d[0]);\n}\nvoid rev3(vector <int> &d) {\n  swap(d[0], d[2]);\n  swap(d[2], d[5]);\n  swap(d[5], d[3]);\n}\n\nint main() {\n  int ttt = 0;\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    int cnt = 0;\n    map <string, int> memo;\n    vector <int> d[n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 6; j++){\n        string s;\n        cin >> s;\n        if (memo.find(s) == memo.end()) {\n          d[i].push_back(cnt);\n          memo[s] = cnt;\n          cnt++;\n        }else {\n          d[i].push_back(memo[s]);\n        }\n      }\n    }\n    if (n == 1) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    set<vector<vector<int> > > cut;\n    stack <vector<vector<int> > > st;\n    int ans = INT_MAX;\n    bool same = true;\n    for (int i = 0; i < 6; i++) {\n      for (int j = 1; j < n; j++) {\n        if (d[j][i] != d[j-1][i]) {\n          same = false;\n          break;\n        }\n      }\n      if (!same) break;\n    }\n    if (same) {\n      ans = 0;\n    }\n    vector <vector <int> > t;\n    for (int i = 0; i < n; i++) {\n      t.push_back(d[i]);\n    }\n    st.push(t);\n    cut.insert(t);\n    while (!st.empty()) {\n      vector <vector<int> > np = st.top(); st.pop();\n\n      for (int i = 1; i < n; i++) {\n        for (int ch = 0; ch < 6; ch++) {\n          vector <vector<int> > tnp = np;\n          if (ch == 0) {\n            rot1(tnp[i]);\n          }else if (ch == 1) {\n            rot2(tnp[i]);\n          }else if (ch == 2){\n            rot3(tnp[i]);\n          }else if (ch == 3) {\n            rev1(tnp[i]);\n          }else if (ch == 4) {\n            rev2(tnp[i]);\n          }else if (ch == 5) {\n            rev3(tnp[i]);\n          }\n          if (cut.find(tnp) != cut.end()) {\n            continue;\n          }\n          st.push(tnp);\n          cut.insert(tnp);\n          int tsum = 0;\n          for (int j = 0; j < 6; j++) {\n            int tcnt[cnt];\n            memset(tcnt, 0, sizeof(tcnt));\n            int maxp = 0;\n            for (int k = 0; k < n; k++) {\n              tcnt[tnp[k][j]]++;\n              if (tcnt[tnp[k][j]] > tcnt[maxp]) {\n                maxp = tnp[k][j];\n              }\n            }\n            tsum += n-tcnt[maxp];\n          }\n          ans = min(ans, tsum);\n        }\n      }\n    }\n    int tsum = 0;\n    for (int j = 0; j < 6; j++) {\n      int tcnt[cnt];\n      memset(tcnt, 0, sizeof(tcnt));\n      int maxp = 0;\n      for (int k = 0; k < n; k++) {\n        tcnt[d[k][j]]++;\n        if (tcnt[d[k][j]] > tcnt[maxp]) {\n          maxp = d[k][j];\n        }\n      }\n      tsum += n-tcnt[maxp];\n    }\n\n    cout << min(ans, tsum) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Dice\n{\n    int t;\npublic:\n    vector<int> pip; // 東南西北上下の目\n    Dice(){\n        t = 0;\n        pip.assign(6, -1);\n    }\n    void roll(int d){ // 東南西北右左に回転\n        int dir[][4] = {{4,2,5,0},{4,3,5,1},{4,0,5,2},{4,1,5,3},{0,3,2,1},{0,1,2,3}};\n        int tmp = pip[dir[d][0]];\n        for(int i=0; i<3; ++i)\n            pip[dir[d][i]] = pip[dir[d][i+1]];\n        pip[dir[d][3]] = tmp;\n    }\n    void next()\n    {\n        roll(0);\n        ++ t;\n        if(t % 4 == 0){\n            if(t % 24 == 16)\n                roll(4);\n            else if(t % 24 == 20)\n                roll(4), roll(4);\n            else\n                roll(1);\n        }\n    }\n    bool operator==(const Dice& d) const{\n        return pip == d.pip;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<Dice> d(4);\n        map<string, int> color;\n        for(int i=0; i<n; ++i){\n            vector<int> a(6);\n            for(int j=0; j<6; ++j){\n                string s;\n                cin >> s;\n                if(color.find(s) == color.end()){\n                    int k = color.size();\n                    color[s] = k;\n                }\n                a[j] = color[s];\n            }\n            d[i].pip[1] = a[0];\n            d[i].pip[0] = a[1];\n            d[i].pip[4] = a[2];\n            d[i].pip[5] = a[3];\n            d[i].pip[2] = a[4];\n            d[i].pip[3] = a[5];\n        }\n\n        int ret = INT_MAX;\n        for(int a=0; a<24; ++a){\n            for(int b=0; b<24; ++b){\n                for(int c=0; c<24; ++c){\n                    int tmp = 0;\n                    for(int i=0; i<6; ++i){\n                        int x = 0;\n                        map<int, int> m;\n                        for(int j=0; j<n; ++j)\n                            x = max(x, ++m[d[j].pip[i]]);\n                        tmp += n - x;\n                    }\n                    ret = min(ret, tmp);\n\n                    d[3].next();\n                }\n                d[2].next();\n            }\n            d[1].next();\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n \nusing namespace std;\n\n//   swap(d[], d[]);\nvoid rot1(vector <int> &d) {\n  swap(d[1], d[2]);\n  swap(d[2], d[4]);\n  swap(d[4], d[3]);\n}\nvoid rot2(vector <int> &d) {\n  swap(d[1], d[0]);\n  swap(d[5], d[1]);\n  swap(d[4], d[5]);\n}\nvoid rot3(vector <int> &d) {\n  swap(d[0], d[3]);\n  swap(d[3], d[5]);\n  swap(d[5], d[2]);\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    int cnt = 0;\n    map <string, int> memo;\n    vector <int> d[n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 6; j++){\n        string s;\n        cin >> s;\n        if (memo.find(s) == memo.end()) {\n          d[i].push_back(cnt);\n          memo[s] = cnt;\n          cnt++;\n        }else {\n          d[i].push_back(memo[s]);\n        }\n      }\n    }\n    if (n == 1) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    int move[] = {1,1,1,1,2,\n                  1,1,1,1,2,\n                  1,1,1,1,2,\n                  1,1,1,1,2,3,\n                  1,1,1,1,3,3,\n                  1,1,1,1};\n    set<vector<int> > cut;\n    stack <vector<int> > st;\n    vector <int> t;\n    int ans = INT_MAX;\n    stack <vector<int> > dst;\n    for (int i = 0; i < n; i++) {\n      t.push_back(0);\n    }\n    st.push(t);\n    for (int i = 0; i < n; i++) {\n      vector <int> dt;\n      for (int j = 0; j < 6; j++) {\n        dt.push_back(d[i][j]);\n      }\n      dst.push(dt);\n    }\n    int count = 0;\n    while (!st.empty()) {\n      count++;\n      vector <int> p = st.top(); st.pop();\n      vector <int> nd[n];\n      for (int i = 0; i < n; i++) {\n        nd[i] = dst.top(); dst.pop();\n      }\n      int tcnt = 0;\n      for (int i = 1; i < n; i++) {\n        if (p[i] < 31) {\n          p[i]++;\n          if (cut.find(p) != cut.end()) continue;\n          st.push(p);\n          cut.insert(p); p[i]--;\n\n          vector <int> ndt[n];\n          for (int j = 0; j < n; j++) {\n            ndt[j] = nd[j];\n          }\n\n          switch(move[p[i]]) {\n            case 1: rot1(ndt[i]); break;\n            case 2: rot2(ndt[i]); break;\n            case 3: rot3(ndt[i]); break;\n          }\n\n          for (int j = 0; j < 6; j++) {\n            int cntmemo[cnt]; memset(cntmemo, 0, sizeof(cntmemo));\n            int maxp = 0;\n            for (int k = 0; k < n; k++) {\n              cntmemo[ndt[k][j]]++;\n              if(cntmemo[ndt[k][j]] > cntmemo[maxp]) maxp = ndt[k][j];\n            }\n            tcnt += n-cntmemo[maxp];\n            if (tcnt >= ans) break;\n          }\n          ans = min(ans, tcnt);\n          for (int j = 0; j < n; j++) dst.push(ndt[j]);\n        }\n      }\n    }\n    // cout << count << endl;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "3\nscarlet green blue yellow magenta cyan\nblue pink green magenta cyan lemon\npurple red blue yellow cyan green\n2\nred green blue yellow magenta cyan\ncyan green blue yellow magenta red\n2\nred green gray gray magenta cyan\ncyan green gray gray magenta red\n2\nred green blue yellow magenta cyan\nmagenta red blue yellow cyan green\n3\nred green blue yellow magenta cyan\ncyan green blue yellow magenta red\nmagenta red blue yellow cyan green\n3\nblue green green green green blue\ngreen blue blue green green green\ngreen green green green green sea-green\n3\nred yellow red yellow red yellow\nred red yellow yellow red yellow\nred red red red red red\n4\nviolet violet salmon salmon salmon salmon\nviolet salmon salmon salmon salmon violet\nviolet violet salmon salmon violet violet\nviolet violet violet violet salmon salmon\n1\nred green blue yellow magenta cyan\n4\nmagenta pink red scarlet vermilion wine-red\naquamarine blue cyan indigo sky-blue turquoise-blue\nblond cream chrome-yellow lemon olive yellow\nchrome-green emerald-green green olive vilidian sky-blue\n0"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<map>\n#include <algorithm>\n\n#define INF 0x7fffffff\n\nusing namespace std;\n\nint i,j,k,l,m,n;\nstatic int c[5][6],t[30],z[6];\nconst int w[24][6]={2,3,0,5,4,1, 3,2,0,5,1,4, 4,1,0,5,3,2, 1,4,0,5,2,3,\n2,3,1,4,0,5, 3,2,1,4,5,0, 0,5,1,4,3,2, 5,0,1,4,2,3,\n5,0,2,3,4,1, 0,5,2,3,1,4, 4,1,2,3,0,5, 1,4,2,3,5,0,\n5,0,3,2,1,4, 0,5,3,2,4,1, 1,4,3,2,0,5, 4,1,3,2,5,0,\n2,3,4,1,5,0, 3,2,4,1,0,5, 5,0,4,1,3,2, 0,5,4,1,2,3,\n2,3,5,0,1,4, 3,2,5,0,4,1, 1,4,5,0,3,2, 4,1,5,0,2,3};\nstring st;\nint dfs(int o) {\nint ans=INF,i,j,k;\nif (o>n) {\nans=0;\nfor(int i=0;i<=5;i++) {\nmemset(t,0,sizeof(t));int ma=0;\nfor(int j=0;j<=n;j++) ma=max(ma,++t[c[j][w[z[j]][i]]]);\nans+=(n-ma);\n}\nreturn ans;}\nfor(int i=0;i<=23;i++) {\nz[o]=i;ans=min(ans,dfs(o+1));}\nreturn ans;\n}\nint main() {\n\nmap <string,int> a;\nwhile (scanf(\"%d\",&n)!=EOF && n) {\nfor(int i=1;i<=n;i++) for(int j=0;j<=5;j++) {\ncin>>st;if (!a[st]) a[st]=++m;\nc[i][j]=a[st];}\nz[1]=0;printf(\"%d\\n\",dfs(2));\nmap<string,int>::iterator o=a.begin();\nfor (;o!=a.end();o++) o->second=0;\n\nm=0;}\nreturn 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unordered_map>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/06/20  Problem: AOJ 2703 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2703  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\n\nusing uLL = unsigned long long;\n\nconst uLL MOD = 1e9;\n//BEGIN CUT HERE\nstruct Dice {\n\tint s[6];\n\tvoid roll(char c) {\n\t\t//the view from above\n\t\t// N\n\t\t//W E\n\t\t// S\n\t\t//s[0]:top\n\t\t//s[1]:south\n\t\t//s[2]:east\n\t\t//s[3]:west\n\t\t//s[4]:north\n\t\t//s[5]:bottom\n\t\tint b;\n\t\tif (c == 'E') {\n\t\t\tb = s[0];\n\t\t\ts[0] = s[3];\n\t\t\ts[3] = s[5];\n\t\t\ts[5] = s[2];\n\t\t\ts[2] = b;\n\t\t}\n\t\tif (c == 'W') {\n\t\t\tb = s[0];\n\t\t\ts[0] = s[2];\n\t\t\ts[2] = s[5];\n\t\t\ts[5] = s[3];\n\t\t\ts[3] = b;\n\t\t}\n\t\tif (c == 'N') {\n\t\t\tb = s[0];\n\t\t\ts[0] = s[1];\n\t\t\ts[1] = s[5];\n\t\t\ts[5] = s[4];\n\t\t\ts[4] = b;\n\t\t}\n\t\tif (c == 'S') {\n\t\t\tb = s[0];\n\t\t\ts[0] = s[4];\n\t\t\ts[4] = s[5];\n\t\t\ts[5] = s[1];\n\t\t\ts[1] = b;\n\t\t}\n\n\t\t// migi neji \n\t\tif (c == 'R') {\n\t\t\tb = s[1];\n\t\t\ts[1] = s[2];\n\t\t\ts[2] = s[4];\n\t\t\ts[4] = s[3];\n\t\t\ts[3] = b;\n\t\t}\n\n\t\tif (c == 'L') {\n\t\t\tb = s[1];\n\t\t\ts[1] = s[3];\n\t\t\ts[3] = s[4];\n\t\t\ts[4] = s[2];\n\t\t\ts[2] = b;\n\t\t}\n\n\t}\n\tint top() {\n\t\treturn s[0];\n\t}\n\tint bottom() {\n\t\treturn s[5];\n\t}\n\tuLL hash() {\n\t\tuLL res = 1;\n\t\tfor (int i = 0; i < 6; i++) res = res * (MOD)+s[i];\n\t\treturn res;\n\t}\n\tvoid print() {\n\t\tcout << \"Dice num: \";\n\t\tFOR(i, 0, 6) {\n\t\t\tcout << s[i] << \" \";\n\t\t}\n\t\tcout << \"Hash: \" << this->hash() << endl;\n\t\tcout << endl;\n\t}\n};\nvector<Dice> makeDices(Dice d) {\n\tvector<Dice> res;\n\tfor (int i = 0; i < 6; i++) {\n\t\tDice t(d);\n\t\tif (i == 1) t.roll('N');\n\t\tif (i == 2) t.roll('S');\n\t\tif (i == 3) t.roll('S'), t.roll('S');\n\t\tif (i == 4) t.roll('L');\n\t\tif (i == 5) t.roll('R');\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tres.push_back(t);\n\t\t\tt.roll('E');\n\t\t}\n\t}\n\treturn res;\n}\n//END CUT HERE\n\nvoid solve_AOJ_ITP1_11_A() {\n\tint N = 6;\n\tDice D;\n\tFOR(i, 0, N) {\n\t\tint val; cin >> val;\n\t\tD.s[i] = val;\n\t}\n\tstring s; cin >> s;\n\tFOR(i, 0, SZ(s)) {\n\t\tD.roll(s[i]);\n\t}\n\tcout << D.top() << endl;\n}\n\nvoid solve_AOJ_ITP1_11_B() {\n\tDice D;\n\tint N = 6;\n\tFOR(i, 0, N) {\n\t\tint val; cin >> val;\n\t\tD.s[i] = val;\n\t}\n\tvector<Dice> dices = makeDices(D);\n\tint Q; cin >> Q;\n\tFOR(i, 0, Q) {\n\t\tint TOP, FRONT;\n\t\tcin >> TOP >> FRONT;\n\t\tFOR(i, 0, SZ(dices)) { //24個\n\t\t\tif (dices[i].top() == TOP && dices[i].s[1] == FRONT) {\n\t\t\t\tcout << dices[i].s[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve_AOJ_ITP1_11_C() {\n\tDice d[2];\n\tFOR(k, 0, 2) {\n\t\tFOR(i, 0, 6) {\n\t\t\tint val; cin >> val;\n\t\t\td[k].s[i] = val;\n\t\t}\n\t}\n\tuLL hashval = d[0].hash();\n\tvector<Dice>dices = makeDices(d[1]);\n\tFOR(i, 0, SZ(dices)) {\n\t\tif (hashval == dices[i].hash()) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n}\nvoid solve_AOJ_ITP1_11_D() {\n\tint N; cin >> N;\n\tvector<Dice>d(N);\n\tFOR(k, 0, N) {\n\t\tFOR(i, 0, 6) {\n\t\t\tint val; cin >> val;\n\t\t\td[k].s[i] = val;\n\t\t}\n\t}\n\tset<uLL>Se;\n\tSe.insert(d[0].hash());\n\tFOR(i, 1, N) {\n\t\tvector<Dice>dices = makeDices(d[i]);\n\t\tint flag = 0;\n\t\tFOR(j, 0, SZ(dices)) {\n\t\t\tflag |= (Se.count(dices[j].hash()));\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tSe.insert(dices[i].hash());\n\n\t}\n\tcout << \"Yes\" << endl;\n}\n\nvoid solve_AOJ_0502() {\n\tint Q;\n\twhile (cin >> Q, Q) {\n\t\tDice d; FOR(i, 0, 6)d.s[i] = i + 1;\n\t\tint ans = 1;\n\t\tFOR(kim, 0, Q) {\n\t\t\tstring s; cin >> s;\n\t\t\td.roll(s[0]);\n\t\t\tans += d.top();\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n}\n\nusing PII = pair<int, int>;\nmap<char, char>changeC;\ninline  int  mhash(const PII &a) {\n\treturn (a.first + 1200) * 2400 + a.second + 1200;\n}\nvoid solve_AOJ_2703() { // えーサイコロ関係なくないですか？ないですね\n\tconst string ORIG = \"EWNS\";\n\tconst string TO = \"RLBF\";\n\tFOR(i, 0, 4) {\n\t\tchangeC[TO[i]] = ORIG[i];\n\t}\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<map<PII, int>>Map(N);\n\t\tint x, y;\n\t\tDice dice;\n\t\tFOR(i, 0, N) {\n\t\t\tcin >> x >> y;\n\t\t\tcin >> dice.s[3] >> dice.s[2] >> dice.s[1] >> dice.s[4] >> dice.s[5] >> dice.s[0];\n\t\t\tstring s; cin >> s;\n\t\t\tMap[i][PII(y, x)] = dice.bottom();\n\t\t\tFOR(j, 0, SZ(s)) {\n\t\t\t\tdice.roll(changeC[s[j]]);\n\t\t\t\t// R,L,B,F\n\t\t\t\tif (s[j] == 'R')x++;\n\t\t\t\tif (s[j] == 'L')x--;\n\t\t\t\tif (s[j] == 'B')y++;\n\t\t\t\tif (s[j] == 'F')y--;\n\t\t\t\t// y x の移動\n\t\t\t\tMap[i][PII(y, x)] = dice.bottom();\n\t\t\t}\n\t\t}\n\n\t\tvector<int>bitdp(1 << N, 0);\n\t\tFOR(state, 0, 1 << N) {\n\t\t\tunordered_map<int, bool>used; // orderedだと結構遅かった\n\t\t\tFOR(i, 0, N) {\n\t\t\t\tif (state & 1 << i) {\n\t\t\t\t\tfor (auto it : Map[i]) {\n\t\t\t\t\t\tused[mhash(it.first)] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 記録した\n\t\t\tFOR(i, 0, N) {\n\t\t\t\tif (state & 1 << i)continue;\n\t\t\t\tint addv = 0;\n\n\t\t\t\tfor (auto it : Map[i]) {\n\t\t\t\t\tif (!used.count(mhash(it.first))) {\n\t\t\t\t\t\taddv += it.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbitdp[state | (1 << i)] = max(bitdp[state | (1 << i)], bitdp[state] + addv);\n\t\t\t}\n\t\t}\n\t\tcout << bitdp[(1 << N) - 1] << endl;\n\n\t}\n}\n\nvoid solve_AOJ_1181() {\n\tint N;\n\tDice BaseDi;\n\tFOR(i, 0, 6)BaseDi.s[i] = i + 1;\n\tvector<Dice>dices = makeDices(BaseDi);\n\twhile (cin >> N, N) {\n\t\tVVI masu(210, VI(210, 0));\n\t\tvector<VVI>valset(210, VVI(210, VI()));\n\t\tFOR(okaduki, 0, N) {\n\t\t\tint tp, fr; cin >> tp >> fr;\n\t\t\tint X = 100, Y = 100;\n\t\t\tDice d;\n\t\t\tFOR(i, 0, SZ(dices)) {\n\t\t\t\tif (dices[i].top() == tp&&dices[i].s[1] == fr) {\n\t\t\t\t\td = dices[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (1) {\n\t\t\t\tmasu[Y][X]++;\n\t\t\t\t// 落ちる方向を決める\n\t\t\t\t// 大きな方に転がり落ちる\n\t\t\t\tint dy[] = { -1, 1, 0, 0, -1, };\n\t\t\t\tint dx[] = { -1, 0, 1, -1, 0, };\n\t\t\t\tint dir = -1;\n\t\t\t\tFOR(num, 4, 6 + 1) {\n\t\t\t\t\tif (d.top() != num && d.bottom() != num) { //面があれ\n\t\t\t\t\t\tFOR(i, 1, 4 + 1) {\n\t\t\t\t\t\t\tif (d.s[i] == num) {\n\t\t\t\t\t\t\t\tif (masu[Y][X] > masu[Y + dy[i]][X + dx[i]] + 1) {\n\t\t\t\t\t\t\t\t\tdir = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dir == -1) {\n\t\t\t\t\tvalset[Y][X].push_back(d.top());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmasu[Y][X]--;\n\t\t\t\tstring TO = \"$SEWN\";\n\t\t\t\tY += dy[dir]; X += dx[dir];\n\t\t\t\td.roll(TO[dir]);\n\t\t\t}\n\t\t}\n\t\tVI a(7, 0);\n\t\tFOR(i, 0, 210) {\n\t\t\tFOR(j, 0, 210) {\n\t\t\t\tif (!SZ(valset[i][j]))continue;\n\t\t\t\tint val = valset[i][j].back();\n\t\t\t\ta[val]++;\n\t\t\t}\n\t\t}\n\t\tFOR(i, 1, 6 + 1) {\n\t\t\tcout << a[i] << \" \\n\"[i == 6];\n\t\t}\n\n\t}\n\n}\n\nvector<Dice>dices;\nint tops[3][3], fronts[3][3];\nvector<int> ans;\nDice putdice[3][3][3];\nvoid dfs(int state) {\n\tif (state == 27) {\n\t\tint ret = 0;\n\t\tFOR(i, 0, 3) {// 右の右をとる s[2]\n\t\t\tFOR(j, 0, 3) {\n\t\t\t\tret += putdice[i][2][j].s[2];\n\t\t\t}\n\t\t}\n\n\t\tans.push_back(ret);\n\t}\n\telse {\n\t\tint X = (state / 3) % 3;\n\t\tint Y = state % 3;\n\t\tint Z = state / 9;\n\t\tFOR(i, 0, 24) { // put dices to putdice\n\t\t\t// ダメなもの top .front がちゃう\n\t\t\tif (Z == 0 && tops[X][Y] && tops[X][Y] != dices[i].top())continue;\n\t\t\tif (X == 2 && fronts[Z][Y] && fronts[Z][Y] != dices[i].s[1])continue;\n\t\t\t// ダメなもの 7じゃない\n\t\t\tif (X&& putdice[X - 1][Y][Z].s[4] + dices[i].s[1] != 7)continue; // 奥\n\t\t\tif (Y&& putdice[X][Y - 1][Z].s[2] + dices[i].s[3] != 7)continue; // 左\n\t\t\tif (Z&& putdice[X][Y][Z - 1].s[5] + dices[i].s[0] != 7)continue; // 上\n\n\t\t\tputdice[X][Y][Z] = dices[i];\n\t\t\tdfs(state + 1);\n\t\t}\n\n\n\t}\n\n}\n\n\n// 24^27なきもちになるけど前処理すればだいたい決まるので解析しなくても投げる気持ちが固まる\n// パラメータの管理壊れる\nvoid solve_AOJ_1253() {\n\t// 条件を見たすように配置したときの右面の種類\n\tDice Base;\n\tFOR(i, 0, 6)Base.s[i] = i + 1;\n\tdices = makeDices(Base);\n\n\tint Case; cin >> Case;\n\tFOR(kyo, 0, Case) {\n\t\tFOR(i, 0, 3)FOR(j, 0, 3)cin >> tops[i][j];\n\t\tFOR(i, 0, 3)FOR(j, 0, 3)cin >> fronts[i][j];\n\t\tdfs(0);\n\t\tSORT(ans); UNIQ(ans);\n\t\tFOR(i, 0, SZ(ans)) {\n\t\t\tcout << ans[i] << \" \\n\"[i == SZ(ans) - 1];\n\t\t}\n\t\tif (SZ(ans) == 0)cout << 0 << endl;\n\t\tans.clear();\n\t}\n\n\n\n\n}\nDice resDice[4];\nvector<Dice>diceState[4];\n\nvoid Dfs(int state, const int N, int& ans) {\n\tif (N == state) {\n\t\tint res = 0;\n\t\t// あるおきかたについて\n\t\t// 一緒になるように最小の塗り分けをする\n\n\t\tFOR(i, 0, 6) { //ある面について\n\t\t\tmap<int, int>cnt;\n\t\t\tFOR(k, 0, N) {\n\t\t\t\tcnt[resDice[k].s[i]]++;\n\t\t\t}\n\t\t\tint mx = 0;\n\t\t\tfor (auto it : cnt) {\n\t\t\t\tmx = max(mx, it.second); // 重複maxが保存すべきもの\n\t\t\t}\n\t\t\tres += N - mx;\n\t\t}\n\n\n\n\n\t\tans = min(ans, res);\n\t\treturn;\n\t}\n\tFOR(i, 0, 24) {\n\t\tresDice[state] = diceState[state][i];\n\t\tDfs(state + 1, N, ans);\n\t}\n}\n\nvoid solve_AOJ_1259() {\n\t// N diff checkする 全探索 同じにするための塗り替えを最小にする\n\tint N;\n\twhile (cin >> N, N) {\n\t\tif (N == 1) {\n\t\t\tstring s; FOR(i, 0, 6)cin >> s;\n\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\n\t\t\tvector<Dice>baseDice(N);\n\t\t\tFOR(i, 0, 4)diceState[i].clear();\n\t\t\tmap<string, int>sHash;\n\t\t\tint hp = 1;\n\t\t\tFOR(i, 0, N) {\n\t\t\t\tFOR(j, 0, 6) {\n\t\t\t\t\tstring s;  cin >> s;\n\t\t\t\t\tif (sHash.find(s) == sHash.end())sHash[s] = hp++;\n\t\t\t\t\tbaseDice[i].s[j] = sHash[s];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 値をいれたので24^(N-1)全部つくる\n\t\t\tFOR(i, 0, N) {\n\t\t\t\tdiceState[i] = makeDices(baseDice[i]);\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tresDice[0] = baseDice[0];\n\t\t\tDfs(1, N, ans);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\n}\n \n\n// R S Vは解けそう\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\t//solve_AOJ_ITP1_11_A();\n\t//solve_AOJ_ITP1_11_B();\n\t//solve_AOJ_ITP1_11_C();\n\t//solve_AOJ_ITP1_11_D();\n\t//solve_AOJ_0502();\n\n\t//solve_AOJ_1181();\n\t//solve_AOJ_2703();\n\t//solve_AOJ_1253();\n\tsolve_AOJ_1259();\n\n\treturn 0;\n}\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nenum FACE {FRONT, RIGHT, TOP, BOTTOM, LEFT, BACK};\nvoid roll(string v[6], int a, int b, int c, int d){\n  string tmp = v[a];\n  v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = tmp;\n}\nvoid roll_x(string v[6]){\n  roll(v, TOP, BACK, BOTTOM, FRONT);\n}\nvoid roll_y(string v[6]){\n  roll(v, TOP, LEFT, BOTTOM, RIGHT);\n}\nvoid roll_z(string v[6]){\n  roll(v, FRONT, RIGHT, BACK, LEFT);\n}\nint N;\nstring dice[4][6];\nint dfs(int k){\n  if(k == N){\n    int res = 0;\n    for(int i = 0; i < 6; i++){\n      map<string, int> cnt;\n      int max_c = 0;\n      for(int j = 0; j < N; j++){\n        cnt[dice[j][i]]++;\n        max_c = max(max_c, cnt[dice[j][i]]);\n      }\n      res += N - max_c;\n    }\n    return res;\n  }else{\n    int res = INF;\n    for(int i = 0; i < 6; (i & 1 ? roll_x(dice[k]) : roll_y(dice[k])), ++i){\n      for(int j = 0; j < 4; roll_z(dice[k]), ++j){\n        res = min(res, dfs(k + 1));\n      }\n    }\n    return res;\n  }\n}\n\nint main(){\n  while(cin >> N && N){\n    REP(i, N) REP(j, 6) cin >> dice[i][j];\n    cout << dfs(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nstruct die{\n  int t[6];\n  void ra(){\n    int tmp=t[0];\n    t[0]=t[2];\n    t[2]=t[5];\n    t[5]=t[3];\n    t[3]=tmp;\n  }\n  void rb(){\n    int tmp=t[1];\n    t[1]=t[2];\n    t[2]=t[4];\n    t[4]=t[3];\n    t[3]=tmp;\n  }\n  void rc(){\n    int tmp=t[0];\n    t[0]=t[4];\n    t[4]=t[5];\n    t[5]=t[1];\n    t[1]=tmp;\n  }\n};\n\nvector<die> calc(die d){\n  vector<die> res;\n  for(int i=0;i<4;i++){\n    for(int j=0;j<4;j++){\n      res.push_back(d);\n      d.rc();\n    }\n    d.ra();\n  }\n  d.rb();\n  for(int i=0;i<4;i++){\n    res.push_back(d);\n    d.rc();\n  }\n  d.rb();d.rb();\n  for(int i=0;i<4;i++){\n    res.push_back(d);\n    d.rc();\n  }\n  return res;\n}\n\nint n,cnt,ans;\ndie A[4];\nmap<string,int> mp;\nvector<die> B[4];\n\nvoid check(){\n  int cnt=0;\n  for(int i=0;i<6;i++){\n    int maxm=0;\n    map<int,int> mp;\n    for(int j=0;j<n;j++){\n      int num=A[j].t[i];\n      mp[num]++;\n      maxm=max(maxm,mp[num]);\n    }\n    cnt+=(n-maxm);\n  }\n  ans=min(ans,cnt);\n}\n\nvoid solve(int x){\n  if(x==n){\n    check(); \n  }else{\n    for(int i=0;i<24;i++){\n      A[x]=B[x][i];\n      solve(x+1);\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    cnt=0;\n    mp.clear();\n    string str;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<6;j++){\n\tcin>>str;\n\tif(mp[str]==0){\n\t  cnt++;\n\t  mp[str]=cnt;\n\t}\n\tA[i].t[j]=mp[str];\n      }\n      B[i]=calc(A[i]);\n    }\n    \n    ans=(1<<24);\n    solve(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*****************************************************\nAuthor : Yinthewind\nSun Aug 12 15:39:21 CST 2012\n*****************************************************/\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define dd double\n\nclass cube\n{\n\tpublic:\n\t\tint color[7];\n}q[5];\nstring s[5][7];\n\nmap<int,int> col[7];\nint ans,N;\n\nvoid dfs(int k)\n{\n\tif(k<=N)\n\t{\n\t\tfor(int i=1;i<=6;i++)\n\t\t{\n\t\t\tcol[1][q[k].color[i]]++;\n\t\t\tcol[6][q[k].color[7-i]]++;\n\t\t\tvector<int> tmp;\n\t\t\tif(i==1)\n\t\t\t{\n\t\t\t\ttmp.push_back(q[k].color[4]);\n\t\t\t\ttmp.push_back(q[k].color[2]);\n\t\t\t\ttmp.push_back(q[k].color[3]);\n\t\t\t\ttmp.push_back(q[k].color[5]);\n\t\t\t}\n\t\t\tif(i==2)\n\t\t\t{\n\t\t\t\ttmp.push_back(q[k].color[4]);\n\t\t\t\ttmp.push_back(q[k].color[6]);\n\t\t\t\ttmp.push_back(q[k].color[3]);\n\t\t\t\ttmp.push_back(q[k].color[1]);\n\t\t\t}\n\t\t\tif(i==3)\n\t\t\t{\n\t\t\t\ttmp.push_back(q[k].color[1]);\n\t\t\t\ttmp.push_back(q[k].color[2]);\n\t\t\t\ttmp.push_back(q[k].color[6]);\n\t\t\t\ttmp.push_back(q[k].color[5]);\n\t\t\t}\n\t\t\tif(i==4)\n\t\t\t{\n\t\t\t\ttmp.push_back(q[k].color[5]);\n\t\t\t\ttmp.push_back(q[k].color[6]);\n\t\t\t\ttmp.push_back(q[k].color[2]);\n\t\t\t\ttmp.push_back(q[k].color[1]);\n\t\t\t}\n\t\t\tif(i==5)\n\t\t\t{\n\t\t\t\ttmp.push_back(q[k].color[1]);\n\t\t\t\ttmp.push_back(q[k].color[3]);\n\t\t\t\ttmp.push_back(q[k].color[6]);\n\t\t\t\ttmp.push_back(q[k].color[4]);\n\t\t\t}\n\t\t\tif(i==6)\n\t\t\t{\n\t\t\t\ttmp.push_back(q[k].color[5]);\n\t\t\t\ttmp.push_back(q[k].color[3]);\n\t\t\t\ttmp.push_back(q[k].color[2]);\n\t\t\t\ttmp.push_back(q[k].color[4]);\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int j=1;j<=6;j++)\n\t\t\t{\n\t\t\t\tif(j!=i&&j!=7-i)\n\t\t\t\t{\n\t\t\t\t\tfor(int l=j+1;l<=6;l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(l!=i&&l!=7-i&&l!=j&&l!=7-j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp.push_back(q[i].color[j]);\n\t\t\t\t\t\t\ttmp.push_back(q[i].color[l]);\n\t\t\t\t\t\t\ttmp.push_back(q[i].color[7-j]);\n\t\t\t\t\t\t\ttmp.push_back(q[i].color[7-l]);\n\t\t\t\t\t\t\tgoto nextstep;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nnextstep:\t\n*/\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tcol[2][tmp[(0+j)%4]]++;\n\t\t\t\tcol[3][tmp[(1+j)%4]]++;\n\t\t\t\tcol[4][tmp[(2+j)%4]]++;\n\t\t\t\tcol[5][tmp[(3+j)%4]]++;\n\t\t\t\tdfs(k+1);\n\t\t\t\tif(--col[2][tmp[(0+j)%4]]==0) col[2].erase(tmp[(0+j)%4]);\n\t\t\t\tif(--col[3][tmp[(1+j)%4]]==0) col[3].erase(tmp[(1+j)%4]);\n\t\t\t\tif(--col[4][tmp[(2+j)%4]]==0) col[4].erase(tmp[(2+j)%4]);\n\t\t\t\tif(--col[5][tmp[(3+j)%4]]==0) col[5].erase(tmp[(3+j)%4]);\n\t\t\t}\n\t\t\tif(--col[1][q[k].color[i]]==0) col[1].erase(q[k].color[i]);\n\t\t\tif(--col[6][q[k].color[7-i]]==0) col[6].erase(q[k].color[7-i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tint res=0;\n\t\tfor(int i=1;i<=6;i++) res+=col[i].size()-1;\n\t\tans=min(ans,res);\n\t}\n}\nint main()\n{\n\twhile(scanf(\"%d\",&N),N)\n\t{\n\t\tans=999999;\n\t\tmap<string,int> m;\n\t\tmap<string,int>:: iterator it;\n\t\tfor(int i=1;i<=N;i++) \n\t\t{\n\t\t\tfor(int j=1;j<=6;j++)\n\t\t\t{\n\t\t\t\tcin>>s[i][j];\n\t\t\t\tm[s[i][j]]=0;\n\t\t\t}\n\t\t} \n\t\tint cnt=0;\n\t\tfor(it=m.begin();it!=m.end();it++) it->second=++cnt;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tfor(int j=1;j<=6;j++) q[i].color[j]=m[s[i][j]];\n\t\tfor(int i=1;i<=6;i++) col[i].clear();\n\t\tcol[1][q[1].color[3]]=1;\n\t\tcol[2][q[1].color[1]]=1;\n\t\tcol[3][q[1].color[2]]=1;\n\t\tcol[4][q[1].color[6]]=1;\n\t\tcol[5][q[1].color[5]]=1;\n\t\tcol[6][q[1].color[4]]=1;\n\t\tdfs(2);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\n// 28ñÅ³ÉàÇé\nclass Dice{\nprivate:\n\tint yoko;\n\tint tate;\n\tint round;\n\nprivate:\n    int face[3][4];\n\npublic:\n\tint getFace(int i,int j)const{\n\t\treturn face[i][j];\n\t}\n\tDice(vector<int> &v){\n\t\tinit();\n\t\tface[1][1]=v[0];\n\t\tface[2][1]=v[1];\n\t\tface[1][2]=v[2];\n\t\tface[1][0]=v[3];\n\t\tface[0][1]=v[4];\n\t\tface[1][3]=v[5];\n\t}\nprivate:\n\t// _CXÌú»\n\tvoid init(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tface[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tyoko=0;\n\t\ttate=0;\n\t\tround=0;\n\t}\npublic:\n\t// _CXÌñ]\n\tvoid rotate(){\n\t\tif(round<4){\n            int tmp = face[2][1];\n\t\t\tface[2][1]=face[1][2];\n\t\t\tface[1][2]=face[0][1];\n\t\t\tface[0][1]=face[1][0];\n\t\t\tface[1][0]=tmp;\n\t\t\tround++;\n\t\t}\n\t\tif(round>=4){\n\t\t\tround=0;\n\t\t\t// àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n\t\t\tif(yoko<4){\n                int tmp = face[1][3];\n\t\t\t\tfor(int i = 2; i >= 0; i--){\n\t\t\t\t\tface[1][i+1]=face[1][i];\n\t\t\t\t}\n\t\t\t\tface[1][0]=tmp;\n\t\t\t\tyoko++;\n\t\t\t}\n\t\t\t// àÇÁÄ«½çAcÌXbgðñ]³¹é\n\t\t\tif(yoko>=4){\n\t\t\t\tif(tate<4){\n\t\t\t\t\ttate++;\n\t\t\t\t\tint tmp = face[1][3];\n\t\t\t\t\tface[1][3]=face[0][1];\n\t\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\t\tface[i][1]=face[i+1][1];\n\t\t\t\t\t}\n\t\t\t\t\tface[2][1]=tmp;\n\t\t\t\t}\n\t\t\t\tif(tate>=4){\n\t\t\t\t\tround=0;\n\t\t\t\t\ttate=0;\n\t\t\t\t\tyoko=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\nconst int INF=1000000000;\nint n;\nvector<Dice> dices;\nint minCost;\nint msi[1001];\n\nvoid dfs(int depth){\n    if(depth==n){\n        int sum=0;\n        // Ê²ÆÉf[^ðûW\n        for(int i = 0; i < 6; i++){\n            memset(msi,0,sizeof(msi));\n            int maxNum=0;\n            for(int j = 0; j < n; j++){\n                if(i==0){\n                    msi[dices[j].getFace(1,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,1)]);\n                }\n                else if(i==1){\n                    msi[dices[j].getFace(2,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(2,1)]);\n                }\n                else if(i==2){\n                    msi[dices[j].getFace(1,2)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,2)]);\n                }\n                else if(i==3){\n                    msi[dices[j].getFace(1,0)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,0)]);\n                }\n                else if(i==4){\n                    msi[dices[j].getFace(0,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(0,1)]);\n                }\n                else{\n                    msi[dices[j].getFace(1,3)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,3)]);\n                }\n            }\n            sum+=n-maxNum;\n        }\n        minCost=min(sum,minCost);\n    }\n    else{\n        // ñ]Èµ\n        dfs(depth+1);\n        for(int i = 0; i < 27; i++){\n            dices[depth].rotate();\n            dfs(depth+1);\n        }\n    }\n}\n\nint main(){\n    \n    while(cin>>n&&n!=0){\n        minCost=INF;\n        int idx=0;\n        map<string,int> idxs;\n        for(int i = 0; i < n; i++){\n            vector<int> v;\n            for(int j = 0; j < 6; j++){\n                string s;\n                cin>>s;\n                if(idxs.find(s)==idxs.end())\n                    idxs[s]=idx++;\n                v.push_back(idxs[s]);\n            }\n            dices.push_back(Dice(v));\n        }\n        dfs(0);\n        dices.clear();\n        cout<<minCost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n\nstruct Info{\n\tchar buf[21];\n\tint count;\n};\n\nclass Dice{\npublic:\n\n\tvoid setPos(int num){\n\n\t\tfor(int i = 0; i < 6; i++)work[i] = index[i];\n\n\t\tswitch(num){\n\t\tcase 0:\n\t\t\tsetindex(work[4],work[0],work[2],work[3],work[5],work[1]);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tsetindex(work[5],work[4],work[2],work[3],work[1],work[0]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsetindex(work[1],work[5],work[2],work[3],work[0],work[4]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsetindex(work[0],work[1],work[2],work[3],work[4],work[5]);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tsetindex(work[2],work[1],work[5],work[0],work[4],work[3]);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tsetindex(work[4],work[2],work[5],work[0],work[3],work[1]);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tsetindex(work[3],work[4],work[5],work[0],work[1],work[2]);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tsetindex(work[1],work[3],work[5],work[0],work[2],work[4]);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tsetindex(work[5],work[3],work[4],work[1],work[2],work[0]);\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tsetindex(work[2],work[5],work[4],work[1],work[0],work[3]);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tsetindex(work[0],work[2],work[4],work[1],work[3],work[5]);\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tsetindex(work[3],work[0],work[4],work[1],work[5],work[2]);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tsetindex(work[1],work[0],work[3],work[2],work[5],work[4]);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tsetindex(work[5],work[1],work[3],work[2],work[4],work[0]);\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tsetindex(work[4],work[5],work[3],work[2],work[0],work[1]);\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tsetindex(work[0],work[4],work[3],work[2],work[1],work[5]);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tsetindex(work[2],work[4],work[0],work[5],work[1],work[3]);\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\tsetindex(work[1],work[2],work[0],work[5],work[3],work[4]);\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tsetindex(work[3],work[1],work[0],work[5],work[4],work[2]);\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\tsetindex(work[4],work[3],work[0],work[5],work[2],work[1]);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tsetindex(work[0],work[3],work[1],work[4],work[2],work[5]);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tsetindex(work[2],work[0],work[1],work[4],work[5],work[3]);\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tsetindex(work[5],work[2],work[1],work[4],work[3],work[0]);\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tsetindex(work[3],work[5],work[1],work[4],work[0],work[2]);\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t//Do nothing\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvoid setindex(int w0,int w1,int w2,int w3,int w4,int w5){\n\t\tindex[0] = w0;\n\t\tindex[1] = w1;\n\t\tindex[2] = w2;\n\t\tindex[3] = w3;\n\t\tindex[4] = w4;\n\t\tindex[5] = w5;\n\t}\n\n\tvoid init(){\n\t\tindex[0] = 2;\n\t\tindex[1] = 5;\n\t\tindex[2] = 1;\n\t\tindex[3] = 4;\n\t\tindex[4] = 0;\n\t\tindex[5] = 3;\n\t}\n\n\tint index[6];\n\tint work[6];\n};\n\nint N,info_index;\nDice dice[4];\nchar color[4][6][21];\nInfo info[24];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\n\nvoid func(){\n\n\tinfo_index = 0;\n\tbool FLG;\n\n\tfor(int i = 0; i < N; i++){\n\t\tdice[i].init();\n\t\tfor(int k = 0; k < 6; k++){\n\t\t\tscanf(\"%s\",color[i][k]);\n\n\t\t\tFLG = false;\n\t\t\tfor(int a = 0;a < info_index; a++){\n\t\t\t\tif(strCmp(info[a].buf,color[i][k])){\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG){\n\t\t\t\tstrcpy(info[info_index].buf,color[i][k]);\n\t\t\t\tinfo_index++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(N == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tint minimum,tmp,tmp_sum,maximum;\n\n\tif(N == 2){\n\n\t\tminimum = BIG_NUM;\n\n\t\tfor(int i = 0; i <= 24; i++){\n\t\t\tdice[1].init();\n\t\t\tdice[1].setPos(i);\n\n\t\t\ttmp = 0;\n\n\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\tif(strCmp(color[0][dice[0].index[k]],color[1][dice[1].index[k]]) == false){\n\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tminimum = min(minimum,tmp);\n\t\t}\n\n\t\tprintf(\"%d\\n\",minimum);\n\n\t}else if(N == 3){\n\n\t\tminimum = BIG_NUM;\n\n\t\tfor(int a = 0; a <= 24; a++){\n\t\t\tdice[1].init();\n\t\t\tdice[1].setPos(a);\n\t\t\tfor(int b = 0; b <= 24; b++){\n\t\t\t\tdice[2].init();\n\t\t\t\tdice[2].setPos(b);\n\n\t\t\t\ttmp_sum = 0;\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tfor(int k = 0; k < info_index; k++)info[k].count = 0;\n\n\t\t\t\t\tfor(int p = 0; p < 3; p++){\n\t\t\t\t\t\tfor(int k = 0; k < info_index; k++){\n\t\t\t\t\t\t\tif(strCmp(info[k].buf,color[p][dice[p].index[i]])){\n\t\t\t\t\t\t\t\tinfo[k].count++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmaximum = 1;\n\t\t\t\t\tfor(int k = 0; k < info_index; k++)maximum = max(maximum,info[k].count);\n\n\t\t\t\t\ttmp_sum += N-maximum;\n\t\t\t\t}\n\t\t\t\tminimum = min(minimum,tmp_sum);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",minimum);\n\n\t}else{ //N == 4\n\n\t\tminimum = BIG_NUM;\n\n\t\tfor(int a = 0; a <= 24; a++){\n\t\t\tdice[1].init();\n\t\t\tdice[1].setPos(a);\n\t\t\tfor(int b = 0; b <= 24; b++){\n\t\t\t\tdice[2].init();\n\t\t\t\tdice[2].setPos(b);\n\n\t\t\t\tfor(int c = 0; c <= 24; c++){\n\t\t\t\t\tdice[3].init();\n\t\t\t\t\tdice[3].setPos(c);\n\n\t\t\t\t\ttmp_sum = 0;\n\t\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\t\tfor(int k = 0; k < info_index; k++)info[k].count = 0;\n\n\t\t\t\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\t\t\t\tfor(int k = 0; k < info_index; k++){\n\t\t\t\t\t\t\t\tif(strCmp(info[k].buf,color[p][dice[p].index[i]])){\n\t\t\t\t\t\t\t\t\tinfo[k].count++;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaximum = 1;\n\t\t\t\t\t\tfor(int k = 0; k < info_index; k++)maximum = max(maximum,info[k].count);\n\n\t\t\t\t\t\ttmp_sum += N-maximum;\n\t\t\t\t\t}\n\t\t\t\t\tminimum = min(minimum,tmp_sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n\nmap < string, int >mapped;\nint total = 0, n, tj[100], b[100][100], a[100][100], ans;\n\n\nconst int G[7][4] = {\n\t{},\n\t{2, 3, 5, 4},\n\t{6, 3, 1, 4},\n\t{2, 6, 5, 1},\n\t{2, 1, 5, 6},\n\t{1, 3, 6, 4},\n\t{3, 2, 4, 5}\n};\n\n\nint find(const string & s) {\n\tif (mapped.count(s))\n\t\treturn mapped[s];\n\telse\n\t\treturn (mapped[s] = ++total);\n}\n\n\nint check() {\n\tint ans = 0, i, tmp, j;\n\tfor (i = 1; i <= 6; ++i) {\n\t\ttmp = 0;\n\t\tfor (j = 1; j <= n; ++j) {\n\t\t\ttmp = max(tmp, ++tj[b[j][i]]);\n\t\t}\n\t\tans += n - tmp;\n\t\tfor (j = 1; j <= n; ++j) {\n\t\t\t--tj[b[j][i]];\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid dfs(int k) {\n\tif (k > n) {\n\t\tans = min(ans, check());\n\t\treturn;\n\t}\n\tint i, j, p;\n\tfor (i = 1; i <= 6; ++i) {\n\t\tb[k][1] = a[k][i];\n\t\tb[k][6] = a[k][7 - i];\n\t\tfor (j = 0; j <= 3; ++j) {\n\t\t\tfor (p = 0; p <= 3; ++p) {\n\t\t\t\tb[k][p + 2] = a[k][G[i][(j + p) % 4]];\n\t\t\t}\n\t\t\tdfs(k + 1);\n\t\t}\n\t}\n}\n\n\nint main() {\n\tfor (;;) {\n\t\tmapped.clear();\n\t\ttotal = 0;\n\t\tcin >> n;\n\t\tif (n == 0)\n\t\t\treturn 0;\n\t\tint i, j;\n\t\tstring s;\n\t\tfor (i = 1; i <= n; ++i)\n\t\t\tfor (j = 1; j <= 6; ++j) {\n\t\t\t\tcin >> s;\n\t\t\t\ta[i][j] = find(s);\n\t\t\t}\n\t\tif (n == 1) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\tans = 24;\n\t\tdfs(1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass Cube{\npublic:\n  string sides[6];\n};\n\nint n;\nCube data[4];\nint next[4][6];\nint d[6][6] = {\n  {0, 1, 2, 3, 4, 5},\n  {0, 4, 3, 2, 1, 5},\n  {0, 2, 4, 1, 3, 5},\n  {2, 1, 5, 0, 4, 3},\n  {3, 1, 0, 5, 4, 2},\n  {0, 3, 1, 4, 2, 5}\n};\n\nvoid rotate(int p){\n  int tmp = next[p][5];\n  next[p][5] = next[p][1];\n  next[p][1] = next[p][0];\n  next[p][0] = next[p][4];\n  next[p][4] = tmp;\n}\n\nint comp(){\n  if(n == 1) return 0;\n  int res = 0;\n  for(int i=0;i<6;++i){\n    int tmp = INF;\n    for(int j=0;j<n;j++){\n      int sum = 0;\n      for(int k=0;k<n;k++){\n\tif(j == k) continue;\n\tif(data[j].sides[next[j][i]] != data[k].sides[next[k][i]]){\n\t  sum++;\n\t}\n      }\n      tmp = min(tmp, sum);\n    }\n    res += tmp;\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<6;j++){\n\tcin >> data[i].sides[j];\n      }\n    }\n    int ans = INF;\n    for(int i1=0;i1<6;i1++){\n      for(int j1=0;j1<6;j1++){\n\tnext[0][j1] = d[i1][j1];\n      }\n      for(int j1=0;j1<4;j1++){\n\trotate(0);\n\tif(n>1){\n\t  for(int i2=0;i2<6;i2++){\n\t    for(int j2=0;j2<6;j2++){\n\t      next[1][j2] = d[i2][j2];\n\t    }\n\t    for(int j2=0;j2<4;j2++){\n\t      rotate(1);\n\t      if(n>2){\n\t\tfor(int i3=0;i3<6;i3++){\n\t\t  for(int j3=0;j3<6;j3++){\n\t\t    next[2][j3] = d[i3][j3];\n\t\t  }\n\t\t  for(int j3=0;j3<4;j3++){\n\t\t    rotate(2);\n\t\t    if(n>3){\n\t\t      for(int i4=0;i4<6;i4++){\n\t\t\tfor(int j4=0;j4<6;j4++){\n\t\t\t  next[3][j4] = d[i4][j4];\n\t\t\t}\t\t\t\n\t\t\tfor(int j4=0;j4<4;j4++){\n\t\t\t  rotate(3);\n\t\t\t  ans = min(ans, comp());\n\t\t\t}\n\t\t      }\n\t\t    }\n\t\t    ans = min(ans, comp());\n\t\t  }\n\t\t}\n\t      }\n\t      ans = min(ans, comp());\n\t    }\n\t  }\n\t}\n\tans = min(ans, comp());\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\nusing namespace std;\n\nenum {TOP=0,FRONT,RIGHT,LEFT,BACK,BOTTOM};\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rotate_swap(x,a,b,c,d) swap(x.m[a],x.m[b]);swap(x.m[b],x.m[c]);swap(x.m[c],x.m[d]);\n\nclass Dice{\npublic:\n  int m[6];\n  bool operator<(const Dice &a)const{\n    rep(i,6)if(m[i]!=a.m[i])return m[i]<a.m[i];\n    return false;\n  }  \n};\n\nvoid rotate_r(Dice &x){\n  rotate_swap(x,TOP,LEFT,BOTTOM,RIGHT);\n}\nvoid rotate_f(Dice &x){\n  rotate_swap(x,TOP,BACK,BOTTOM,FRONT);\n}\nvoid rotate_cw(Dice &x){\n  rotate_swap(x,BACK,LEFT,FRONT,RIGHT);\n}\n\nDice ds[4];\nDice data[4][24];\n\nvoid generate_all( int id, Dice x ){\n   rep(i,6){\n     rep(j,4){\n       data[id][i*4+j]=x;\n       rotate_cw(x);\n     }\n\n     if(i%2==0)rotate_r(x);\n     else rotate_f(x);\n   }\n }\n\n\nint main()\n{\n  int n;\n  while(cin>>n&&n){\n    int id = 0;\n    map<string,int> D;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j <  6; ++j){\n        string color;\n        cin >> color;\n        if( D.find(color) == D.end() ){\n          D[color] = id++;\n        }\n        ds[i].m[j] = D[color];\n        //cout << ds[i].m[j] << ' ';\n      }\n      //cout << endl;\n      generate_all(i,ds[i]);\n    }\n    //cout <<\"input end\" << endl;\n\n    int res = 1000;\n    for(int a = 0; a < 24; ++a){\n      for(int b = 0; b < (n>=2?24:1); ++b){\n        for(int c = 0; c < (n>=3?24:1); ++c){\n          for(int d = 0; d < (n>=4?24:1); ++d){\n            int cost = 0;\n            for(int k = 0; k < 6; ++k){\n              map<int,int> M;\n              if( n >= 1 ){\n                M[data[0][a].m[k]]++;\n              }\n              if( n >= 2 ){\n                M[data[1][b].m[k]]++;\n              }\n              if( n >= 3 ){\n                M[data[2][c].m[k]]++;\n              }\n              if( n >= 4 ){\n                M[data[3][d].m[k]]++;\n              }\n              //cout << data[0][a].m[k] << ' ' << data[1][b].m[k] << ' ' <<  data[2][c].m[k] << endl;\n\n              int sz = M.size();\n              //cout << sz << endl;\n              if( sz == 4 ){\n                cost += 3;\n              }else if( sz == 3 ){\n                cost += 2;\n              }else if( sz == 2 ){\n                if( n == 2 ){\n                  cost += 1;\n                }else{\n                  for(map<int,int>::iterator it = M.begin(); it != M.end(); ++it){\n                    if( (n==4 && (it->second == 3||it->second==1) ) || n == 3 ){\n                      cost += 1; break;\n                    }else if( n == 4 && it->second == 2 ){\n                      cost += 2; break;\n                    }\n                  }\n                }\n              }\n              else if( sz == 1 ) continue;\n              if( cost >= res ) break;\n            }\n            //cout << a << ' ' << b << ' ' << c << ' ' << d << ' ' << cost << endl;\n            res = min( res, cost );\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//03\n#include<iostream>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nstring d[4][6];\n\nvoid rot(int x,string *d){\n  int r[][4]={{0,1,5,4},{0,2,5,3},{1,3,4,2}};\n  string t=d[r[x][0]];\n  d[r[x][0]]=d[r[x][1]];\n  d[r[x][1]]=d[r[x][2]];\n  d[r[x][2]]=d[r[x][3]];\n  d[r[x][3]]=t;\n}\n\nint dfs(int r){\n  if(r==n){\n    int s=0;\n    for(int i=0;i<6;i++){\n      int m=1;\n      for(int j=0;j<n;j++){\n\tint c=0;\n\tfor(int k=0;k<n;k++){\n\t  c+=d[j][i]==d[k][i];\n\t}\n\tm=max(c,m);\n      }\n      s+=n-m;\n    }\n    return s;\n  }else{\n    int m=99;\n    for(int i=0;i<6;i++){\n      rot(i&1,d[r]);\n      for(int j=0;j<4;j++){\n\trot(2,d[r]);\n\tm=min(m,dfs(r+1));\n      }\n    }\n    return m;\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<6;j++){\n\tcin>>d[i][j];\n      }\n    }\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass Cube{\npublic:\n  string sides[6];\n};\n\nint n, i[4], j[4], ans;\nCube data[4];\nint next[4][6][4][6];\nint d[6][6] = {\n  {0, 1, 2, 3, 4, 5},\n  {0, 4, 3, 2, 1, 5},\n  {0, 2, 4, 1, 3, 5},\n  {2, 1, 5, 0, 4, 3},\n  {3, 1, 0, 5, 4, 2},\n  {0, 3, 1, 4, 2, 5}\n};\n\nint comp(){\n  if(n == 1) return 0;\n  int res = 0;\n  for(int i1=0;i1<6;++i1){\n    int tmp = INF;\n    for(int j1=0;j1<n;j1++){\n      int sum = 0;\n      for(int k=0;k<n;k++){\n\tif(j1 == k) continue;\n\tif(data[j1].sides[next[j1][i[j1]][j[j1]][i1]] != data[k].sides[next[k][i[k]][j[k]][i1]]){\n\t  sum++;\n\t}\n      }\n      tmp = min(tmp, sum);\n    }\n    res += tmp;\n    if(res>=ans) return res;\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i1=0;i1<n;i1++){\n      for(int j1=0;j1<6;j1++){\n\tcin >> data[i1].sides[j1];\n      }\n    }\n    for(int l=0;l<4;l++){\n      for(int i1=0;i1<6;i1++){\n\tfor(int k=0;k<3;k++){\t\n\t  if(k == 0){\n\t    for(int j1=0;j1<6;j1++){\n\t      if(k == 0){\n\t\tnext[l][i1][k][j1] = d[i1][j1];\n\t      }\n\t    }\n\t  }else{\n\t    next[l][i1][k][3] = next[l][i1][k-1][3];\n\t    next[l][i1][k][2] = next[l][i1][k-1][2];\n\t    next[l][i1][k][5] = next[l][i1][k-1][1];\n\t    next[l][i1][k][1] = next[l][i1][k-1][0];\n\t    next[l][i1][k][0] = next[l][i1][k-1][4];\n\t    next[l][i1][k][4] = next[l][i1][k-1][5];\n\t  }\n\t}\n      }\n    }\n    ans = INF;\n    for(i[0]=0;i[0]<6;i[0]++){\n      for(j[0]=0;j[0]<3;j[0]++){\n\tif(n>1){\n\t  for(i[1]=0;i[1]<6;i[1]++){\n\t    for(j[1]=0;j[1]<3;j[1]++){\n\t      if(n>2){\n\t\tfor(i[2]=0;i[2]<6;i[2]++){\n\t\t  for(j[2]=0;j[2]<3;j[2]++){\n\t\t    if(n>3){\n\t\t      for(i[3]=0;i[3]<6;i[3]++){\n\t\t\tfor(j[3]=0;j[3]<3;j[3]++){\n\t\t\t  ans = min(ans, comp());\n\t\t\t}\n\t\t      }\n\t\t    }\n\t\t    else ans = min(ans, comp());\n\t\t  }\n\t\t}\n\t      }\n\t      else ans = min(ans, comp());\n\t    }\n\t  }\n\t}\n\telse ans = min(ans, comp());\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\n// 28ñÅ³ÉàÇé\nclass Dice{\nprivate:\n  int yoko;\n  int tate;\n  int round;\n  \nprivate:\n    int face[3][4];\n  \npublic:\n  int getFace(int i,int j)const{\n    return face[i][j];\n  }\n  Dice(vector<int> &v){\n    init();\n    face[1][1]=v[0];\n    face[2][1]=v[1];\n    face[1][2]=v[2];\n    face[1][0]=v[3];\n    face[0][1]=v[4];\n    face[1][3]=v[5];\n  }\nprivate:\n  // _CXÌú»\n  void init(){\n    for(int i = 0; i < 3; i++){\n      for(int j = 0; j < 4; j++){\n\tface[i][j]=-1;\n      }\n    }\n    yoko=0;\n    tate=0;\n    round=0;\n  }\npublic:\n  // _CXÌñ]\n  void rotate(){\n    if(round<4){\n      int tmp = face[2][1];\n      face[2][1]=face[1][2];\n      face[1][2]=face[0][1];\n      face[0][1]=face[1][0];\n      face[1][0]=tmp;\n      round++;\n    }\n    if(round>=4){\n      round=0;\n      // àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n      if(yoko<4){\n\tint tmp = face[1][3];\n\tfor(int i = 2; i >= 0; i--){\n\t  face[1][i+1]=face[1][i];\n\t}\n\tface[1][0]=tmp;\n\tyoko++;\n      }\n      // àÇÁÄ«½çAcÌXbgðñ]³¹é\n      if(yoko>=4){\n\tif(tate<4){\n\t  tate++;\n\t  int tmp = face[1][3];\n\t  face[1][3]=face[0][1];\n\t  for(int i = 0; i < 2; i++){\n\t    face[i][1]=face[i+1][1];\n\t  }\n\t  face[2][1]=tmp;\n\t}\n\tif(tate>=4){\n\t  round=0;\n\t  tate=0;\n\t  yoko=0;\n\t}\n      }\n    }\n  };\n};\n\nconst int INF=1000000000;\nint n;\nvector<Dice> dices;\nint minCost;\nint msi[1001];\n\nvoid dfs(int depth){\n  if(depth==n){\n    int sum=0;\n    // Ê²ÆÉf[^ðûW\n    for(int i = 0; i < 6; i++){\n      memset(msi,0,sizeof(msi));\n      int maxNum=0;\n      for(int j = 0; j < n; j++){\n\tif(i==0){\n\t  msi[dices[j].getFace(1,1)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,1)]);\n\t}\n\telse if(i==1){\n\t  msi[dices[j].getFace(2,1)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(2,1)]);\n\t}\n\telse if(i==2){\n\t  msi[dices[j].getFace(1,2)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,2)]);\n\t}\n\telse if(i==3){\n\t  msi[dices[j].getFace(1,0)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,0)]);\n\t}\n\telse if(i==4){\n\t  msi[dices[j].getFace(0,1)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(0,1)]);\n\t}\n\telse{\n\t  msi[dices[j].getFace(1,3)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,3)]);\n\t}\n      }\n      sum+=n-maxNum;\n    }\n    minCost=min(sum,minCost);\n  }\n  else{\n    // ñ]Èµ\n    dfs(depth+1);\n    for(int i = 0; i < 10; i++){\n      dices[depth].rotate();\n      dfs(depth+1);\n    }\n  }\n}\n\nint main(){\n  \n  while(cin>>n&&n!=0){\n    minCost=INF;\n    int idx=0;\n    map<string,int> idxs;\n    for(int i = 0; i < n; i++){\n      vector<int> v;\n      for(int j = 0; j < 6; j++){\n\tstring s;\n\tcin>>s;\n\tif(idxs.find(s)==idxs.end())\n\t  idxs[s]=idx++;\n\tv.push_back(idxs[s]);\n      }\n      dices.push_back(Dice(v));\n    }\n    dfs(0);\n    dices.clear();\n    cout<<minCost<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef vector<vector<int> > VVI;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint ans;\n\nclass Dice{\npublic:\n   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n   Dice(){}\n   Dice(int _t, int _s, int _e, int _n, int _w, int _b){\n       t = _t, s = _s,e = _e,n = _n,w = _w,b = _b;\n   }\n\n   Dice rotate_front(){\n      return Dice(s,b,e,t,w,n);\n   }\n\n   Dice rotate_left(){\n      return Dice(e,s,b,n,t,w);\n   }\n\n   Dice rotate_right(){\n      return Dice(w,s,t,n,b,e);\n   }\n\n   Dice rotate_back(){\n      return Dice(n,t,e,b,w,s);\n   }\n\n   Dice move_right(){\n      return Dice(t,e,n,w,s,b);\n   }\n\n   Dice move_left(){\n      return Dice(t,w,s,e,n,b);\n   }\n\n   void print(){\n      cout << \"t=\" << t << \"s=\" << s << \"e=\" << e << \"n=\" << n\n           << \"w=\" << w << \"b=\" << b << endl;\n   }\n};\n\nvector<Dice>all;\n\nDice getDice(int top, int south){\n   for(int i=0; i<24; i++){\n      if(all[i].t == top && all[i].s == south){\n         return all[i];\n      }\n   }\n}\n\nvoid allState(int a, int b, int c, int d, int e, int f){\n   all.clear();\n   Dice dice(a,b,c,d,e,f);\n   for(int i=0; i<6; i++){\n      for(int j=0; j<4; j++){\n         all.push_back(dice);\n         dice = dice.move_right();\n      }\n      if(i < 4) dice = dice.rotate_front();\n      if(i == 3) dice = dice.rotate_right();\n      if(i == 4) dice = dice.rotate_right().rotate_right();\n   }\n}\n\nint N;\nvector<vector<vector<int> > >v;\n\n\nint check(vector<int> vv){\n  int res = 0;\n  vector<vector<int> >d;\n  d.resize(N);\n\n  for(int i=0; i<vv.size(); i++){\n    for(int j=0; j<6; j++){\n      d[i].push_back(v[i][vv[i]][j]);\n    }\n  }\n\n  for(int i=0; i<6; i++){\n    map<int,int>m;\n    for(int j=0; j<N; j++){\n      m[d[j][i]]++;\n    }\n\n    int Max = 0;\n    for(map<int,int>::iterator it=m.begin(); it != m.end(); it++){\n      Max = max(Max,it->second);\n    }\n    res += N - Max;\n    if(res >= ans) return 1<<29;\n  }\n  return res;\n}\n\n\nvoid dfs(int cnt, vector<int>vv){\n  if(ans == 0) return;\n\n  if(cnt == N){\n    ans = min(ans,check(vv));\n    return;\n  }\n\n  for(int i=0; i<v[cnt].size(); i++){\n    vector<int>tmp = vv;\n    tmp.push_back(i);\n    dfs(cnt+1,tmp);\n  }\n\n}\n\nint main(){\n\n  while(cin >> N, N){\n    set<string> S;\n    \n    string in[4][6];\n    \n    string s;\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tcin >> s;\n\tin[i][j] = s;\n\tS.insert(s);\n      }\n    }\n    \n    map<string, int> mp;\n    \n    int cnt = 1;\n    for(set<string>::iterator it = S.begin() ; it != S.end() ; it++){\n      mp[*it] = cnt++;\n    }\n    \n    int dice[4][6];\n    memset(dice, 0, sizeof(dice));\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tdice[i][j] = mp[in[i][j]];\n      }\n    }\n\n    //   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n\n    v.clear();\n\n    for(int i=0; i<N; i++){\n      allState(dice[i][2],dice[i][0],dice[i][1],dice[i][5],dice[i][4],dice[i][3]);\n\n\n      vector<vector<int> >tmp2;\n\n      for(int j=0; j<all.size(); j++){\n\tvector<int>tmp;\n\ttmp.push_back(all[j].t);\n\ttmp.push_back(all[j].s);\n\ttmp.push_back(all[j].e);\n\ttmp.push_back(all[j].n);\n\ttmp.push_back(all[j].w);\n\ttmp.push_back(all[j].b);\n\ttmp2.push_back(tmp);\n      }\n      v.push_back(tmp2);\n    }\n\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n\n\n    ans = 1<<29;\n    vector<int>e;\n    dfs(0,e);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<complex>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#include<vector>\n\n#define repi(i,a,b) for(int i = int(a); i < int(b); i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i = int(a); i >= int(b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\nconst double pi = acos(-1.0);\n\nusing namespace std;\n\ntypedef long long ll;\n\nvoid swap4(int &a, int &b, int &c, int &d) {\n    int tmp = a;\n    a = b;\n    b = c;\n    c = d;\n    d = tmp;\n}\n\nvoid up(vector<int> &d) {\n    swap4(d[0], d[2], d[5], d[4]);\n}\n\nvoid right(vector<int> &d) {\n    swap4(d[4], d[3], d[2], d[1]);\n}\n\n\nvoid next_dice(vector<int> &d, int k) {\n    up(d);\n    if(k % 4 == 3) right(d);\n    if(k == 15) {\n        up(d);\n        right(d);\n    } else if(k == 19) right(d);\n}\n\n\nint n;\nsigned main(){\n    while(cin >> n, n) {\n        vector<vector<int> > d(4);\n        map<string, int> table;\n        int id = 0;\n        rep(i, 4) d[i].resize(6);\n\n        rep(i, n) {\n            string ts;\n            rep(j, 6) {\n                cin >> ts;\n                if(table.find(ts) == table.end()) table[ts] = id++;\n                d[i][j] = table[ts];\n            }\n            swap(d[i][3], d[i][4]);\n        }\n\n        if(n == 1) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        int ans = 1000;\n        rep(i1, 24) {\n            rep(i2, 24) {\n                rep(i3, 24) {\n                    int tmp = 0;\n                    rep(k, 6) {\n                        vector<int> cnt(id);\n                        rep(i, n) {\n                            cnt[d[i][k]]++;\n                        }\n                        tmp += n - *max_element(all(cnt));\n                    }\n                    ans = min(ans, tmp);\n                    next_dice(d[3], i3);\n                    if(n <= 3) break;\n                }\n                next_dice(d[2], i2);\n                if(n <= 2) break;\n            }\n            next_dice(d[1], i1);\n            if(n <= 1) break;\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\n\nint n;\nint ans;\nint sz;\nvector<vector<int> > dices;\n\n\nint count(){\n\tint ret = 0;\n\n\tfor(int j = 1; j <= 6; ++j){\n\t\tvector<int> c(sz);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\t++c[ dices[i][j] ];\n\t\t}\n\t\t\n\t\tint m = *max_element(c.begin(), c.end());\n\t\t\n\t\tret += n - m;\n\t}\n\t\n\treturn ret;\n}\n\n\nvoid rollfront(vector<int> &dice){\n\tint next[7] = {\n\t\t-1,\n\t\tdice[3],\n\t\tdice[2],\n\t\tdice[6],\n\t\tdice[1],\n\t\tdice[5],\n\t\tdice[4],\n\t};\n\tcopy(next, next + 7, dice.begin());\n}\n\nvoid rollright(vector<int> &dice){\n\tint next[7] = {\n\t\t-1,\n\t\tdice[1],\n\t\tdice[3],\n\t\tdice[5],\n\t\tdice[2],\n\t\tdice[4],\n\t\tdice[6],\n\t};\n\tcopy(next, next + 7, dice.begin());\n}\n\nvoid round(vector<int> &dice){\n\tint next[7] = {\n\t\t-1,\n\t\tdice[5],\n\t\tdice[1],\n\t\tdice[3],\n\t\tdice[4],\n\t\tdice[6],\n\t\tdice[2],\n\t};\n\tcopy(next, next + 7, dice.begin());\n}\n\n\nvoid func(int x){\n\tif( x == n ){\n\t\tans = min(ans, count());\n\t}\n\telse{\n\t\tfor(int i = 1; i <= 6; ++i){\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tfunc(x + 1);\n\t\t\t\tround( dices[x] );\n\t\t\t}\n\t\t\t\n\t\t\tif( i & 1 ){\n\t\t\t\trollfront( dices[x] );\n\t\t\t}\n\t\t\telse{\n\t\t\t\trollright( dices[x] );\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\twhile( cin >> n, n != 0 ){\n\t\tvector<vector<string> > s(n + 1, vector<string>(7) );\n\t\tmap<string,int> mp;\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 1; j <= 6; ++j){\n\t\t\t\tcin >> s[i][j];\n\t\t\t\tmp.insert( make_pair(s[i][j], mp.size() ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tsz = mp.size();\n\n\t\tdices.resize(n, vector<int>(7, -1));\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 1; j <= 6; ++j){\n\t\t\t\tdices[i][j] = mp[ s[i][j] ];\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = 99;\n\t\tfunc(1);\n\t\t\n\t\tcout << ans << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dice[6][6]={\n{0,1,2,4,3,5},\n{2,0,1,5,4,3},\n{1,2,0,3,5,4},\n{4,5,3,0,2,1},\n{5,3,4,2,1,0},\n{3,4,5,1,0,2},\n};\nint q[4];\nstring str[4][6];\nchar in[30];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<6;j++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tstr[i][j]=in;\n\t\t}\n\t\t//swap(str[0][3],str[0][4]);\n\t\tif(a==1){\n\t\t\tprintf(\"0\\n\");continue;\n\t\t}\n\t\tint ret=99999999;\n\t\tfor(int i=0;i<24;i++){\n\t\t\tq[1]=i;\n\t\t\tif(a>2){\n\t\t\t\tfor(int j=0;j<24;j++){\n\t\t\t\t\tq[2]=j;\n\t\t\t\t\tif(a>3){\n\t\t\t\t\t\tfor(int k=0;k<24;k++){\n\t\t\t\t\t\t\tq[3]=k;\n\t\t\t\t\t\t\tvector<string>v[6];\n\t\t\t\t\t\t\tint val=0;\n\t\t\t\t\t\t\tfor(int t=0;t<a;t++)\n\t\t\t\t\t\t\t\tfor(int x=0;x<6;x++){\n\t\t\t\t\t\t\t\t\tif(x==0||x==5)v[x].push_back(str[t][dice[q[t]/4][x]]);\n\t\t\t\t\t\t\t\t\telse v[x].push_back(str[t][dice[q[t]/4][1+(q[t]+x)%4]]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int t=0;t<6;t++){\n\t\t\t\t\t\t\t\tint tmp=0;\n\t\t\t\t\t\t\t\tfor(int x=0;x<v[t].size();x++){\n\t\t\t\t\t\t\t\t\tint t2=0;\n\t\t\t\t\t\t\t\t\tfor(int y=0;y<v[t].size();y++)if(v[t][x]==v[t][y])t2++;\n\t\t\t\t\t\t\t\t\ttmp=max(tmp,t2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tval+=v[t].size()-tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret=min(ret,val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<string>v[6];\n\t\t\t\t\t\tint val=0;\n\t\t\t\t\t\tfor(int t=0;t<a;t++)\n\t\t\t\t\t\t\tfor(int x=0;x<6;x++){\n\t\t\t\t\t\t\t\tif(x==0||x==5)v[x].push_back(str[t][dice[q[t]/4][x]]);\n\t\t\t\t\t\t\t\telse v[x].push_back(str[t][dice[q[t]/4][1+(q[t]+x)%4]]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int t=0;t<6;t++){\n\t\t\t\t\t\t\tint tmp=0;\n\t\t\t\t\t\t\tfor(int x=0;x<v[t].size();x++){\n\t\t\t\t\t\t\t\tint t2=0;\n\t\t\t\t\t\t\t\tfor(int y=0;y<v[t].size();y++)if(v[t][x]==v[t][y])t2++;\n\t\t\t\t\t\t\t\ttmp=max(tmp,t2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tval+=v[t].size()-tmp;\n\t\t\t\t\t\t}ret=min(ret,val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tvector<string>v[6];\n\t\t\t\tfor(int t=0;t<a;t++)\n\t\t\t\t\tfor(int x=0;x<6;x++){\n\t\t\t\t\t\tif(x==0||x==5)v[x].push_back(str[t][dice[q[t]/4][x]]);\n\t\t\t\t\t\telse v[x].push_back(str[t][dice[q[t]/4][1+(q[t]+x)%4]]);\n\t\t\t\t\t}\n\t\t\t\tint val=0;\n\t\t\t\tfor(int t=0;t<6;t++){\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int x=0;x<v[t].size();x++){\n\t\t\t\t\t\tint t2=0;\n\t\t\t\t\t\tfor(int y=0;y<v[t].size();y++)if(v[t][x]==v[t][y])t2++;\n\t\t\t\t\t\ttmp=max(tmp,t2);\n\t\t\t\t\t}\n\t\t\t\t\tval+=v[t].size()-tmp;\n\t\t\t\t}\n\t\t\t\tret=min(ret,val);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<string>\n#include<iostream>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct cube{\n\tint a[6];\n\tcube(){ rep(i,6) a[i]=i; }\n\tvoid rotx(){\n\t\tint tmp=a[0];\n\t\ta[0]=a[2];\n\t\ta[2]=a[5];\n\t\ta[5]=a[4];\n\t\ta[4]=tmp;\n\t}\n\tvoid roty(){\n\t\tint tmp=a[0];\n\t\ta[0]=a[1];\n\t\ta[1]=a[5];\n\t\ta[5]=a[3];\n\t\ta[3]=tmp;\n\t}\n\tvoid rotz(){\n\t\tint tmp=a[1];\n\t\ta[1]=a[2];\n\t\ta[2]=a[3];\n\t\ta[3]=a[4];\n\t\ta[4]=tmp;\n\t}\n};\n\nint dfs(int i,int n,cube C[4],const string color[4][6]){\n\tif(i==n-1){\n\t\tint res=0;\n\t\trep(j,6){\n\t\t\tint cntmax=0;\n\t\t\tmap<string,int> f;\n\t\t\trep(k,n) cntmax=max(cntmax,++f[color[k][C[k].a[j]]]);\n\t\t\tres+=n-cntmax;\n\t\t}\n\t\treturn res;\n\t}\n\n\tint res=6*n;\n\trep(s,6){\n\t\trep(t,4){\n\t\t\tres=min(res,dfs(i+1,n,C,color));\n\t\t\tC[i].rotz();\n\t\t}\n\t\tif(s&1) C[i].rotx();\n\t\telse    C[i].roty();\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;cin>>n,n;){\n\t\tstring color[4][6];\n\t\trep(i,n){\n\t\t\tcin>>color[i][2];\n\t\t\tcin>>color[i][3];\n\t\t\tcin>>color[i][0];\n\t\t\tcin>>color[i][5];\n\t\t\tcin>>color[i][1];\n\t\t\tcin>>color[i][4];\n\t\t}\n\n\t\tcube C[4];\n\t\tcout<<dfs(0,n,C,color)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n \nusing namespace std;\n\n//   swap(d[], d[]);\nvoid rot1(vector <int> &d) {\n  swap(d[1], d[2]);\n  swap(d[2], d[4]);\n  swap(d[4], d[3]);\n}\nvoid rot2(vector <int> &d) {\n  swap(d[1], d[0]);\n  swap(d[5], d[1]);\n  swap(d[4], d[5]);\n}\nvoid rot3(vector <int> &d) {\n  swap(d[0], d[3]);\n  swap(d[3], d[5]);\n  swap(d[5], d[2]);\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    int cnt = 0;\n    map <string, int> memo;\n    vector <int> d[n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 6; j++){\n        string s;\n        cin >> s;\n        if (memo.find(s) == memo.end()) {\n          d[i].push_back(cnt);\n          memo[s] = cnt;\n          cnt++;\n        }else {\n          d[i].push_back(memo[s]);\n        }\n      }\n    }\n    if (n == 1) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    int move[] = {1,1,1,1,2,\n                  1,1,1,1,2,\n                  1,1,1,1,2,\n                  1,1,1,1,2,3,\n                  1,1,1,1,3,3,\n                  1,1,1,1};\n    set<vector<int> > cut;\n    stack <vector<int> > st;\n    vector <int> t;\n    int ans = INT_MAX;\n    stack <vector<int> > dst;\n    for (int i = 0; i < n; i++) {\n      t.push_back(0);\n    }\n    st.push(t);\n    for (int i = 0; i < n; i++) {\n      vector <int> dt;\n      for (int j = 0; j < 6; j++) {\n        dt.push_back(d[i][j]);\n      }\n      dst.push(dt);\n    }\n    int count = 0;\n    while (!st.empty()) {\n      count++;\n      vector <int> p = st.top(); st.pop();\n      vector <int> nd[n];\n      for (int i = 0; i < n; i++) {\n        nd[i] = dst.top(); dst.pop();\n      }\n      int tcnt = 0;\n      for (int i = 0; i < n; i++) {\n        if (p[i] < 31) {\n          p[i]++;\n          if (cut.find(p) != cut.end()) continue;\n          st.push(p);\n          cut.insert(p); p[i]--;\n\n          vector <int> ndt[n];\n          for (int j = 0; j < n; j++) {\n            ndt[j] = nd[j];\n          }\n\n          switch(move[p[i]]) {\n            case 1: rot1(ndt[i]); break;\n            case 2: rot2(ndt[i]); break;\n            case 3: rot3(ndt[i]); break;\n          }\n\n          for (int j = 0; j < 6; j++) {\n            int cntmemo[cnt]; memset(cntmemo, 0, sizeof(cntmemo));\n            int maxp = 0;\n            for (int k = 0; k < n; k++) {\n              cntmemo[ndt[k][j]]++;\n              if(cntmemo[ndt[k][j]] > cntmemo[maxp]) maxp = ndt[k][j];\n            }\n            tcnt += n-cntmemo[maxp];\n            if (tcnt >= ans) break;\n          }\n          ans = min(ans, tcnt);\n          for (int j = 0; j < n; j++) dst.push(ndt[j]);\n        }\n      }\n    }\n    // cout << count << endl;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<unordered_map>\n#include<cassert>\n#include<climits>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n \nusing namespace std;\n \n// Library - cycoro - begin -7:26\n \nenum FACE {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\n \ntemplate<class T>\nclass dice{\npublic:\n  dice(){\n    //id[FRONT] = 0; id[RIGHT] = 1; id[TOP] = 2;\n    //id[BOTTOM] = 3; id[LEFT] = 4; id[BACK] = 5;\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f){ return var[id[f]]; }\n  const T& operator[] (FACE f)const { return var[id[f]];}\n  bool operator == (const dice<T> &b)const{\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] && \n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n \n  void roll_x() { roll(TOP,BACK,BOTTOM,FRONT); }\n  void roll_y() { roll(TOP,LEFT,BOTTOM,RIGHT); }\n  void roll_z() { roll(FRONT,RIGHT,BACK,LEFT); }\n \n  vector<dice> all_rolls(){\n  vector<dice> ret;\n  for(int k=0;k<6;(k&1?roll_y():roll_x()),++k)\n    for(int i=0;i<4;roll_z(),++i)\n      ret.push_back(*this);\n  return ret;\n  }\n \n  bool equivalent_to(const dice& di){\n    for(int k=0;k<6;(k&1?roll_y():roll_x()),++k)\n      for(int i=0;i<4;roll_z(),++i)\n    if(*this == di)return true;\n    return false;\n  }\n \nprivate:\n  void roll(FACE a,FACE b,FACE c,FACE d){\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n \nFACE face[] = {FRONT,RIGHT,TOP,BOTTOM,LEFT,BACK};\n \n// Library - cycoro - end 07:34\n \nint n,mincost;\nvector<dice<int> > ALL[4];\n\nvoid dfs(int cur,vector<dice<int> >&tmp){\n  if(cur >= n){\n    int cost = 0;\n    unordered_map<int,int> counter;\n    rep(fc,6){\n      counter.clear();\n      int mex = 0;\n      rep(i,n){\n    counter[tmp[i][face[fc]]]++;\n    mex = max(mex,counter[tmp[i][face[fc]]]);   \n      }\n      cost += (n - mex);\n      assert(n-mex >= 0);\n    }\n    mincost = min(cost,mincost);\n    return;\n  }\n \n  rep(i,ALL[cur].size()){\n    tmp[cur] = ALL[cur][i];\n    dfs(cur+1,tmp);\n  }\n \n}\n \nint main(){\n \n  while(cin >> n,n){\n    int idx = 0;\n    mincost= IINF;\n    map<string,int> getIndex;\n    vector<dice<int> > dices(n);\n    rep(i,n){\n      rep(j,6){\n    string color;\n    cin >> color;\n    if(getIndex.find(color) == getIndex.end())getIndex[color] = idx++;\n    int index = getIndex[color];\n    dices[i][face[j]] = index; \n      }\n    }\n \n    rep(i,n)ALL[i] = dices[i].all_rolls();\n    vector<dice<int> > tmp(n);\n \n    dfs(0,tmp);\n \n \n    cout << mincost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> rotate_map[24];\nvoid init(){\n  int idx = 0;\n  vector<int> per(3);\n  REP(i, 3) per[i] = i;\n  do{\n    REP(S, (1<<3)){\n      int cnt = 0;\n      REP(i, 3) if(per[i] != i + 1) cnt ++;\n      if(cnt == 0) cnt ++;\n      if((cnt + __builtin_popcount(S)) % 2 == 0) continue;\n      //if(__builtin_popcount(S) != 2 && __builtin_popcount(S) != 0) continue;\n      rotate_map[idx] = vector<int>(6);\n      REP(i, 6){\n        if(i < 3){\n          if(S & (1<<i)) rotate_map[idx][i] = (5 - per[i]);\n          else rotate_map[idx][i] = per[i];\n        }else{\n          rotate_map[idx][i] = (5 - rotate_map[idx][5-i]);\n        }\n      }\n      idx += 1;\n    }\n  }while(next_permutation(per.begin(), per.end()));\n  assert(idx == 24);\n}\nvector<string> face[4];\n/*\nint memo[4][4][1<<6][1<<6];\nbool judge(int idx1, int idx2, int S1, int S2){\n  S1 &= (1<<6) - 1;\n  S2 &= (1<<6) - 1;\n  int& res = memo[idx1][idx2][S1][S2];\n  if(res != -1) return res;\n  vector<string>& f1 = face[idx1];\n  vector<string>& f2 = face[idx2];\n  REP(k, 24){\n    bool ok = true;\n    REP(i, 6)if(f1[i] != f2[rotate_map[k][i]] && (!(S1 & (1<<i))) && (!(S2 & (1<<(rotate_map[k][i]))))) ok = false;\n\n    if(!ok) continue;\n    REP(i, 6) cout<<((S1 & (1<<i)) ? \"******\" : f1[i])<<\" \"; cout<<endl;\n    REP(i, 6) cout<<((S2 & (1<<rotate_map[k][i])) ? \"******\" : f2[rotate_map[k][i]])<<\" \"; cout<<endl;\n    cout<<endl;\n\n    if(ok) return res = true;\n  }\n  return res = false;\n}\n*/\nint main(){\n  int N;\n  init();\n  while(cin>>N && N){\n    //memset(memo, -1, sizeof(memo));\n    REP(i, N){\n      face[i] = vector<string>(6);\n      REP(j, 6){\n        cin>>face[i][j];\n      }\n    }\n    int ans = INF;\n    int MS = 1;\n    REP(i, N) MS *= 24;\n    for(int S = 0; S < MS; S++){\n      int m_idx[4] = {0};\n      int tmp_S = S;\n      REP(i, N){\n        m_idx[i] = tmp_S % 24;\n        tmp_S /= 24;\n      }\n      int r_ans = 0;\n      REP(i, 6){\n        map<string, int> cnt;\n        REP(j, N) cnt[face[j][rotate_map[m_idx[j]][i]]]++;\n        int need = N - 1;\n        FORIT(it, cnt) need = min(need, N - it->second);\n        r_ans += need;\n      }\n      ans = min(ans, r_ans);\n    }\n    /*\n    for(int S = 0; S < (1<<(6 * N)); S++){\n      if(ans <= __builtin_popcount(S)) continue;\n      bool ok = true;\n      REP(i, N)FOR(j, i + 1, N){\n        if(!judge(i, j, S >> (6 * i), S >> (6 * j))) ok = false;\n      }\n      if(ok) ans = __builtin_popcount(S);\n      if(ok && __builtin_popcount(S) == 12){\n        REP(i, 4){\n          REP(j, 6) cout<<((S & (1<<(6 * i + j))) ? \"******\" : face[i][j])<<\" \";\n          cout<<endl;\n        }\n      }\n    }\n    */\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\n// 28ñÅ³ÉàÇé\nclass Dice{\nprivate:\n\tint yoko;\n\tint tate;\n\tint round;\n\nprivate:\n    int face[3][4];\n\npublic:\n\tint getFace(int i,int j)const{\n\t\treturn face[i][j];\n\t}\n\tDice(vector<int> &v){\n\t\tinit();\n\t\tface[1][1]=v[0];\n\t\tface[2][1]=v[1];\n\t\tface[1][2]=v[2];\n\t\tface[1][0]=v[3];\n\t\tface[0][1]=v[4];\n\t\tface[1][3]=v[5];\n\t}\nprivate:\n\t// _CXÌú»\n\tvoid init(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tface[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tyoko=0;\n\t\ttate=0;\n\t\tround=0;\n\t}\npublic:\n\t// _CXÌñ]\n\tvoid rotate(){\n\t\tif(round<4){\n            int tmp = face[2][1];\n\t\t\tface[2][1]=face[1][2];\n\t\t\tface[1][2]=face[0][1];\n\t\t\tface[0][1]=face[1][0];\n\t\t\tface[1][0]=tmp;\n\t\t\tround++;\n\t\t}\n\t\tif(round>=4){\n\t\t\tround=0;\n\t\t\t// àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n\t\t\tif(yoko<4){\n                int tmp = face[1][3];\n\t\t\t\tfor(int i = 2; i >= 0; i--){\n\t\t\t\t\tface[1][i+1]=face[1][i];\n\t\t\t\t}\n\t\t\t\tface[1][0]=tmp;\n\t\t\t\tyoko++;\n\t\t\t}\n\t\t\t// àÇÁÄ«½çAcÌXbgðñ]³¹é\n\t\t\tif(yoko>=4){\n\t\t\t\tif(tate<4){\n\t\t\t\t\ttate++;\n\t\t\t\t\tint tmp = face[1][3];\n\t\t\t\t\tface[1][3]=face[0][1];\n\t\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\t\tface[i][1]=face[i+1][1];\n\t\t\t\t\t}\n\t\t\t\t\tface[2][1]=tmp;\n\t\t\t\t}\n\t\t\t\tif(tate>=4){\n\t\t\t\t\tround=0;\n\t\t\t\t\ttate=0;\n\t\t\t\t\tyoko=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\nconst int INF=1000000000;\nint n;\nvector<Dice> dices;\nint minCost;\nint msi[1001];\n\nvoid dfs(int depth){\n    if(depth==n){\n        int sum=0;\n        // Ê²ÆÉf[^ðûW\n        for(int i = 0; i < 6; i++){\n            memset(msi,0,sizeof(msi));\n            int maxNum=0;\n            for(int j = 0; j < n; j++){\n                if(i==0){\n                    msi[dices[j].getFace(1,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,1)]);\n                }\n                else if(i==1){\n                    msi[dices[j].getFace(2,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(2,1)]);\n                }\n                else if(i==2){\n                    msi[dices[j].getFace(1,2)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,2)]);\n                }\n                else if(i==3){\n                    msi[dices[j].getFace(1,0)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,0)]);\n                }\n                else if(i==4){\n                    msi[dices[j].getFace(0,1)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(0,1)]);\n                }\n                else{\n                    msi[dices[j].getFace(1,3)]++;\n                    maxNum=max(maxNum,msi[dices[j].getFace(1,3)]);\n                }\n            }\n            //for(map<int,int>::iterator it=msi.begin();it!=msi.end();it++){\n            //    if(it->second>maxNum){\n            //        maxNum=it->second;\n            //    }\n            //}\n            sum+=n-maxNum;\n        }\n        minCost=min(sum,minCost);\n    }\n    else{\n        // ñ]Èµ\n        dfs(depth+1);\n        for(int i = 0; i < 28; i++){\n            dices[depth].rotate();\n            dfs(depth+1);\n        }\n    }\n}\n\nint main(){\n    \n    while(cin>>n&&n!=0){\n        minCost=INF;\n        int idx=0;\n        map<string,int> idxs;\n        for(int i = 0; i < n; i++){\n            vector<int> v;\n            for(int j = 0; j < 6; j++){\n                string s;\n                cin>>s;\n                if(idxs.find(s)==idxs.end())\n                    idxs[s]=idx++;\n                v.push_back(idxs[s]);\n            }\n            dices.push_back(Dice(v));\n        }\n        dfs(0);\n        dices.clear();\n        cout<<minCost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n \nstruct die{\n  int t[6];\n  void ra(){\n    int tmp=t[0];\n    t[0]=t[2];\n    t[2]=t[5];\n    t[5]=t[3];\n    t[3]=tmp;\n  }\n  void rb(){\n    int tmp=t[1];\n    t[1]=t[2];\n    t[2]=t[4];\n    t[4]=t[3];\n    t[3]=tmp;\n  }\n  void rc(){\n    int tmp=t[0];\n    t[0]=t[4];\n    t[4]=t[5];\n    t[5]=t[1];\n    t[1]=tmp;\n  }\n};\n \nvector<die> calc(die d){\n  vector<die> res;\n  for(int i=0;i<4;i++){\n    for(int j=0;j<4;j++){\n      res.push_back(d);\n      d.rc();\n    }\n    d.ra();\n  }\n  d.rb();\n  for(int i=0;i<4;i++){\n    res.push_back(d);\n    d.rc();\n  }\n  d.rb();d.rb();\n  for(int i=0;i<4;i++){\n    res.push_back(d);\n    d.rc();\n  }\n  return res;\n}\n \nint n,cnt,ans;\ndie A[4];\nmap<string,int> mp;\nvector<die> B[4];\n \nvoid check(){\n  int cnt=0;\n  for(int i=0;i<6;i++){\n    int maxm=0;\n    map<int,int> mp;\n    for(int j=0;j<n;j++){\n      int num=A[j].t[i];\n      mp[num]++;\n      maxm=max(maxm,mp[num]);\n    }\n    cnt+=(n-maxm);\n  }\n  ans=min(ans,cnt);\n}\n \nvoid solve(int x){\n  if(x==n){\n    check();\n  }else{\n    for(int i=0;i<24;i++){\n      A[x]=B[x][i];\n      solve(x+1);\n    }\n  }\n}\n \nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    cnt=0;\n    mp.clear();\n    string str;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<6;j++){\n    cin>>str;\n    if(mp[str]==0){\n      cnt++;\n      mp[str]=cnt;\n    }\n    A[i].t[j]=mp[str];\n      }\n      B[i]=calc(A[i]);\n    }\n     \n    ans=(1<<24);\n    solve(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint mat[7][6] = {{1, 2, 3, 4, 5, 6},\n                 {2, 6, 3, 1, 5, 4},\n                 {3, 1, 2, 6, 4, 5},\n                 {4, 1, 3, 6, 5, 2},\n                 {5, 4, 6, 2, 1, 3},\n                 {6, 4, 3, 2, 5, 1}};\nconst int INFI = 99999999;\nmap<string, int> colors;\n\nstruct Cube {\n\n    int face[7], face_backup[7];\n\n\n    int GetIndex(const string& color) {\n        if (colors.find(color) == colors.end()) {\n            colors[color] = colors.size() - 1;\n        }\n        return colors[color];\n    }\n\n    void read() {\n        string color;\n        for (int i = 1; i <= 6; ++i) {\n            cin >> color;\n            face[i] = GetIndex(color);\n        }\n        swap(face[4], face[5]);\n        for (int i = 1; i <= 6; ++i) face_backup[i] = face[i];\n    }\n\n    void rotate(int iter_number) {\n        if (iter_number % 4 == 0) {\n            int ino = iter_number / 4;\n            for (int i = 1; i <= 6; ++i)\n                face[i] = face_backup[mat[ino][i-1]];\n/*\n            for (int i = 1; i <= 6; ++i)\n                printf(\"%d \",face[i]);\n            printf(\"\\n\");\n*/\n            //system(\"pause\");\n        } else {\n            int face_5 = face[5];\n            for (int i = 5; i > 2; --i)\n                face[i] = face[i-1];\n            face[2] = face_5;\n        }\n    }\n\n    void show() const {\n        for (int fno = 1; fno <= 6; ++fno) {\n            printf(\"%d \", face[fno]);\n        }\n        cout << endl;\n    }\n};\nvector<Cube> cubes;\nint ans;\n\nint CalcDiff(const vector<Cube>& cubes) {\n    int counter[30];\n    int total_diff = 0;\n    for (int fno = 1; fno <= 6; ++fno) {\n        for (int i = 0; i < colors.size(); ++i) counter[i] = 0;\n        for (int cno = 0; cno < cubes.size(); ++cno) {\n            ++counter[ cubes[cno].face[fno] ];\n        }\n        int most_color_number = 0;\n        for (int i = 0; i < colors.size(); ++i)\n        if (counter[i] > most_color_number) {\n            most_color_number = counter[i];\n        }\n        total_diff += cubes.size() - most_color_number;\n        //cout << \"cubes.size() = \" << cubes.size() - most_color_number << endl;\n    }\n    //for (int i = 0; i < cubes.size(); ++i) cubes[i].show();\n    //cout << \"total_diff = \" << total_diff << \" \" << ans << endl << endl;\n    //if (total_diff == 1) { total_diff /= 0; }\n    return total_diff;\n}\n\nvoid dfs(int cno) {\n    if (cno == cubes.size()) {\n        ans = min(ans, CalcDiff(cubes));\n        return;\n    }\n    for (int i = 0; i < 24; ++i) {\n        cubes[cno].rotate(i);\n        dfs(cno + 1);\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n && n != 0) {\n        colors.clear();\n        cubes.resize(n);\n        for (int i = 0; i < n; ++i)\n            cubes[i].read();\n\n        //cout << \"colors.size() = \" << colors.size() << endl;\n        assert(colors.size() <= 24);\n        ans = INFI;\n        dfs(0);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF (long long)(1e18)\n#define MOD (int)(1e9+7)\n#define MAX_N 103\n#define MAX_V 10\n#define MAX_M 101\n#define yn(f) (f?\"Yes\":\"No\")\n#define YN(f) (f?\"YES\":\"NO\")\n#define pro \"はいプロ　世界一○○が上手　○○界のtourist　○○時代の終焉を告げる者　実質○○　○○するために生まれてきた男\"\n\nstruct Cube{\n\tstring co[10];\n};\n\n\nCube huga(Cube b){\n\tCube a = b;\n\tstring temp = a.co[1];\n\ta.co[1] = a.co[5];\n\ta.co[5] = a.co[6];\n\ta.co[6] = a.co[2]; \n\ta.co[2] = temp;\n\treturn a;\n}\n\nCube hoge(Cube b){\n\tCube a = b;\n\tstring temp = a.co[1];\n\ta.co[1] = a.co[4];\n\ta.co[4] = a.co[6];\n\ta.co[6] = a.co[3];\n\ta.co[3] = temp;\n\treturn a;\n}\n\nCube hugahuga(Cube b){\n\tCube a = b;\n\tstring temp = a.co[3];\n\ta.co[3] = a.co[5];\n\ta.co[5] = a.co[4];\n\ta.co[4] = a.co[2]; \n\ta.co[2] = temp;\n\treturn a;\n}\n\nCube foo(Cube c, int b){\n\tCube a = c;\n\tswitch(b){\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\ta=huga(a);a=huga(a);a=huga(a);\n\t\tbreak;\n\tcase 3:\n\t\ta=hoge(a); a=hoge(a);a=hoge(a);\n\t\tbreak;\n\tcase 4:\n\t\ta=hoge(a);\n\t\tbreak;\n\tcase 5:\n\t\ta=huga(a);\n\t\tbreak;\n\tcase 6:\n\t\ta=huga(a);a=huga(a);\n\t\tbreak;\n\t}\n\treturn a;\n}\n\nint cou(Cube a,Cube b){\n\tint count = 0;\n\tfor(int i = 1; i <= 6; i++){\n\t\tif(a.co[i] != b.co[i])count++;\n\t}\n\treturn count;\n}\n\nint ans(int cc[10][10],int n,int used[],int k){\n\tint count = 0;\n\tfor(int i = 1; i <= n; i++) count+=cc[k][i];\n\treturn count;\n}\n\nint ha(Cube a[], int n){//cout<<\" a \"<<endl;\n\tint ans = 0;\n\tfor(int i = 1; i <= 6; i++){\n\t\tint ma = 0;\n\t\tmap<string,int> m;\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tma = max(ma, ++m[a[j].co[i]]);\n\t\t}\n\t\tans += n-ma;\n\t}\n\t\n\treturn ans;\n}\n\nint so(Cube a[], int n, int k){//cout<<k<<\" \"<<n<<endl;\n\tCube tt = a[k];\n\tint ans = INF;\n\t//if(n+1== k) return ha(a,n);\n\tfor(int i = 1; i <= 6; i++){\n\t\tCube temp = foo(tt,i);\n\t\tfor(int j = 1; j <= 4;j++){\n\t\t\ttemp = hugahuga(temp);\n\t\t\ta[k] = temp;\n\t\t\tif(k<n-1)ans = min(ans,so(a,n,k+1));\n\t\t\telse ans = min(ans,ha(a,n));\n\t\t}\n\t}\n\treturn ans;\n}\n\nsigned main(){\n\twhile(true){\n\t\tint n;\n\t\tCube s[5];\n\t\tcin>>n;\n\t\tif(!n)break;\n\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tfor(int j = 1; j <= 6; j++)\n\t\t\t\tcin>>s[i].co[j];\n\t\n\t\tcout<<so(s,n,1)<<endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<numeric>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n\n\n#define rotate_swap(x,a,b,c,d) swap(x.a,x.b);swap(x.b,x.c);swap(x.c,x.d);\n\nclass Dice{\npublic:\n  int top,front,right,left,back,bottom;\n};\n\nvoid rotate_r(Dice &x){\n  rotate_swap(x,top,left,bottom,right);\n}\n\nvoid rotate_f(Dice &x){\n  rotate_swap(x,top,back,bottom,front);\n}\n\nvoid rotate_cw(Dice &x){\n  rotate_swap(x,back,left,front,right);\n}\n\n\nDice data[4][24];\nvoid generate_all(Dice *x,int n){\n  rep(k,n){\n    rep(i,6){\n      rep(j,4){\n\tdata[k][i*4+j]=x[k];\n\trotate_cw(x[k]);\n      }\n      if (i%2 == 0)rotate_r(x[k]);\n      else rotate_f(x[k]);\n    }\n  }\n}\n\n\nint ans;\n\nvoid count_min(int n,Dice *in){\n  int color[6];\n  rep(i,6)color[i]=(1<<20);\n  rep(i,n){\n    int tcolor[6]={0};\n    rep(j,n){\n      if (in[i].front  != in[j].front)tcolor[0]++;\n      if (in[i].right  != in[j].right)tcolor[1]++;\n      if (in[i].left   != in[j].left) tcolor[2]++;\n      if (in[i].bottom != in[j].bottom)tcolor[3]++;\n      if (in[i].top    != in[j].top)   tcolor[4]++;\n      if (in[i].back   != in[j].back)tcolor[5]++;\n    }\n    rep(j,6)color[j]=min(color[j],tcolor[j]);\n  }\n  ans=min(ans,accumulate(color,color+6,0));\n}\n\nvoid search(int n,int now,Dice *in){\n  if (n == now){\n    count_min(n,in);\n    return;\n  }\n  rep(i,24){\n    in[now]=data[now][i];\n    search(n,now+1,in);\n  }\n}\n\nint solve(Dice *in,int n){\n  ans=(1<<21);\n  generate_all(in,n);\n  search(n,0,in);\n  return ans;\n}\n\nint getname(string &in,map<string,int> & M){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index;\n  return M[in];\n}\n\nmain(){\n  int n;\n  Dice in[4];\n  while(cin>>n && n){\n    map<string,int> M;\n    rep(i,n){\n      string tmp;\n      cin>>tmp;\n      in[i].front=getname(tmp,M);\n      cin>>tmp;\n      in[i].right=getname(tmp,M);\n      cin>>tmp;\n      in[i].top=getname(tmp,M);\n      cin>>tmp;\n      in[i].bottom=getname(tmp,M);\n      cin>>tmp;\n      in[i].left=getname(tmp,M);\n      cin>>tmp;\n      in[i].back=getname(tmp,M);\n    }\n    cout << solve(in,n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n \nusing namespace std;\n\n//   swap(d[], d[]);\nvoid rot1(vector <int> &d) {\n  swap(d[1], d[2]);\n  swap(d[2], d[4]);\n  swap(d[4], d[3]);\n}\nvoid rot2(vector <int> &d) {\n  swap(d[1], d[0]);\n  swap(d[0], d[4]);\n  swap(d[4], d[5]);\n}\nvoid rot3(vector <int> &d) {\n  swap(d[0], d[3]);\n  swap(d[3], d[5]);\n  swap(d[5], d[2]);\n}\nvoid rev1(vector <int> &d) {\n  swap(d[1], d[3]);\n  swap(d[3], d[4]);\n  swap(d[4], d[2]);\n}\nvoid rev2(vector <int> &d) {\n  swap(d[1], d[5]);\n  swap(d[5], d[4]);\n  swap(d[4], d[0]);\n}\nvoid rev3(vector <int> &d) {\n  swap(d[0], d[2]);\n  swap(d[2], d[5]);\n  swap(d[5], d[3]);\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    int cnt = 0;\n    map <string, int> memo;\n    vector <int> d[n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 6; j++){\n        string s;\n        cin >> s;\n        if (memo.find(s) == memo.end()) {\n          d[i].push_back(cnt);\n          memo[s] = cnt;\n          cnt++;\n        }else {\n          d[i].push_back(memo[s]);\n        }\n      }\n    }\n    if (n == 1) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    set<vector<vector<int> > > cut;\n    stack <vector<vector<int> > > st;\n    int ans = INT_MAX;\n    vector <vector <int> > t;\n    for (int i = 0; i < n; i++) {\n      t.push_back(d[i]);\n    }\n    st.push(t);\n    cut.insert(t);\n    while (!st.empty()) {\n      vector <vector<int> > np = st.top(); st.pop();\n\n      for (int i = 1; i < n; i++) {\n        for (int ch = 0; ch < 6; ch++) {\n          vector <vector<int> > tnp = np;\n          if (ch == 0) {\n            rot1(tnp[i]);\n          }else if (ch == 1) {\n            rot2(tnp[i]);\n          }else if (ch == 2){\n            rot3(tnp[i]);\n          }else if (ch == 3) {\n            rev1(tnp[i]);\n          }else if (ch == 4) {\n            rev2(tnp[i]);\n          }else if (ch == 5) {\n            rev3(tnp[i]);\n          }\n          if (cut.find(tnp) != cut.end()) {\n            continue;\n          }\n          st.push(tnp);\n          cut.insert(tnp);\n          int tsum = 0;\n          for (int j = 0; j < 6; j++) {\n            int tcnt[cnt];\n            memset(tcnt, 0, sizeof(tcnt));\n            int maxp = 0;\n            for (int k = 0; k < n; k++) {\n              tcnt[tnp[k][j]]++;\n              if (tcnt[tnp[k][j]] > tcnt[maxp]) {\n                maxp = tnp[k][j];\n              }\n            }\n            tsum += n-tcnt[maxp];\n          }\n          ans = min(ans, tsum);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef vector<vector<int> > VVI;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint ans;\n\nclass Dice{\npublic:\n   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n   Dice(){}\n   Dice(int _t, int _s, int _e, int _n, int _w, int _b){\n       t = _t, s = _s,e = _e,n = _n,w = _w,b = _b;\n   }\n\n   Dice rotate_front(){\n      return Dice(s,b,e,t,w,n);\n   }\n\n   Dice rotate_left(){\n      return Dice(e,s,b,n,t,w);\n   }\n\n   Dice rotate_right(){\n      return Dice(w,s,t,n,b,e);\n   }\n\n   Dice rotate_back(){\n      return Dice(n,t,e,b,w,s);\n   }\n\n   Dice move_right(){\n      return Dice(t,e,n,w,s,b);\n   }\n\n   Dice move_left(){\n      return Dice(t,w,s,e,n,b);\n   }\n\n   void print(){\n      cout << \"t=\" << t << \"s=\" << s << \"e=\" << e << \"n=\" << n\n           << \"w=\" << w << \"b=\" << b << endl;\n   }\n};\n\nvector<Dice>all;\n\nDice getDice(int top, int south){\n   for(int i=0; i<24; i++){\n      if(all[i].t == top && all[i].s == south){\n         return all[i];\n      }\n   }\n}\n\nvoid allState(int a, int b, int c, int d, int e, int f){\n   all.clear();\n   Dice dice(a,b,c,d,e,f);\n   for(int i=0; i<6; i++){\n      for(int j=0; j<4; j++){\n         all.push_back(dice);\n         dice = dice.move_right();\n      }\n      if(i < 4) dice = dice.rotate_front();\n      if(i == 3) dice = dice.rotate_right();\n      if(i == 4) dice = dice.rotate_right().rotate_right();\n   }\n}\n\n\n/*VVI make(vector<int> v){ // from dice, make all dice pattern\n  VVI ret;\n\n  vector<int> org = v;  \n  \n  for(int i = 0 ; i < 6 ; i++){\n    vector<int> nex = org;\n    \n    ret.push_back(nex);\n    \n    swap(nex[0], nex[5]);\n    ret.push_back(nex);      \n    nex = org;\n    \n    swap(nex[1], nex[4]);\n    ret.push_back(nex);\n    \n    swap(nex[0], nex[5]);\n    ret.push_back(nex);      \n  }\n  \n  return ret;\n  }*/\n\n\n\nint N;\nvector<vector<Dice> >v;\n\n\nint check(vector<int> vv){\n  int res = 0;\n  vector<vector<int> >d;\n  d.resize(6);\n  for(int i=0; i<vv.size(); i++){\n    Dice dice = v[i][vv[i]];\n    d[0].push_back(dice.t);\n    d[1].push_back(dice.s);\n    d[2].push_back(dice.e);\n    d[3].push_back(dice.n);\n    d[4].push_back(dice.w);\n    d[5].push_back(dice.b);\n  }\n\n  for(int i=0; i<6; i++){\n    map<int,int>m;\n    for(int j=0; j<N; j++){\n      m[d[i][j]]++;\n    }\n\n    int Max = 0;\n    for(map<int,int>::iterator it=m.begin(); it != m.end(); it++){\n      Max = max(Max,it->second);\n    }\n    res += N - Max;\n  }\n  return res;\n}\n\n\nvoid dfs(int cnt, vector<int>vv){\n  if(cnt == N){\n    ans = min(ans,check(vv));\n    return;\n  }\n\n  for(int i=0; i<v[cnt].size(); i++){\n    vector<int>tmp = vv;\n    tmp.push_back(i);\n    dfs(cnt+1,tmp);\n  }\n\n}\n\nint main(){\n\n  while(cin >> N, N){\n    set<string> S;\n    \n    string in[4][6];\n    \n    string s;\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tcin >> s;\n\tin[i][j] = s;\n\tS.insert(s);\n      }\n    }\n    \n    map<string, int> mp;\n    \n    int cnt = 1;\n    for(set<string>::iterator it = S.begin() ; it != S.end() ; it++){\n      mp[*it] = cnt++;\n    }\n    \n    int dice[4][6];\n    memset(dice, 0, sizeof(dice));\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tdice[i][j] = mp[in[i][j]];\n      }\n    }\n    //   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n    v.clear();\n    for(int i=0; i<N; i++){\n      allState(dice[i][2],dice[i][0],dice[i][1],dice[i][5],dice[i][4],dice[i][3]);\n      v.push_back(all);\n    }\n\n\n    ans = 1<<29;\n    vector<int>e;\n\n\n    for(int i=0; i<v.size(); i++){\n      for(int j=0; j<v[i].size(); j++){\n\tDice dice = v[i][j];\n\t//\tdice.print();\n      }\n      //      cout << endl;\n    }\n\n\n    dfs(0,e);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define lp(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define lps(i, n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nconst ll MOD = (ll)1e9+7;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n\nstruct dice{\n  string f,r,t,d,l,b;\n  dice(){};\n  dice(string v1,string v2,string v3,string v4,string v5,string v6){\n    f=v1;r=v2;t=v3;d=v4;l=v5;b=v6;\n  }\n  int same(dice d2){\n    int cnt=6;\n    if(f==d2.f)cnt--;\n    if(r==d2.r)cnt--;\n    if(t==d2.t)cnt--;\n    if(d==d2.d)cnt--;\n    if(l==d2.l)cnt--;\n    if(b==d2.b)cnt--;\n    return cnt;\n  }\n  void roll(char c){\n    if(c=='s'){\n      string x=f;\n      f=r;\n      r=b;\n      b=l;\n      l=x;\n      return;\n    }\n    else{\n      string x=f;\n      f=t;\n      t=b;\n      b=d;\n      d=x;\n    }\n  }\n};\n\nstring task=\"sssstsssstsssstsssststssssttssss\";\n\nvector<dice> v;\n\nint acnt(){\n  vector<string> x;\n  int cnt=0;\n  x.clear();\n  lp(i,v.size()){\n    x.push_back(v[i].f);\n  }\n  sort(x.begin(),x.end());\n  if(v.size()==3){\n    if(x[0]==x[1]&&x[1]==x[2])cnt+=0;\n    else if(x[0]==x[1]||x[1]==x[2])cnt+=1;\n    else{\n      cnt+=2;\n    }\n  }\n  else{\n    if(x[0]==x[1]&&x[1]==x[2]&&x[2]==x[3])cnt+=0;\n    else if(x[0]==x[1]&&x[1]==x[2]){\n      cnt+=1;\n    }\n    else if(x[1]==x[2]&&x[2]==x[3]){\n      cnt++;\n    }\n    else if(x[0]==x[1]||x[2]==x[3]||x[1]==x[2])cnt+=2;\n    else cnt+=3;\n  }\n\n  x.clear();\n  lp(i,v.size()){\n    x.push_back(v[i].r);\n  }\n  sort(x.begin(),x.end());\n  if(v.size()==3){\n    if(x[0]==x[1]&&x[1]==x[2])cnt+=0;\n    else if(x[0]==x[1]||x[1]==x[2])cnt+=1;\n    else{\n      cnt+=2;\n    }\n  }\n  else{\n    if(x[0]==x[1]&&x[1]==x[2]&&x[2]==x[3])cnt+=0;\n    else if(x[0]==x[1]&&x[1]==x[2]){\n      cnt+=1;\n    }\n    else if(x[1]==x[2]&&x[2]==x[3]){\n      cnt++;\n    }\n    else if(x[0]==x[1]||x[2]==x[3]||x[1]==x[2])cnt+=2;\n    else cnt+=3;\n  }\n  \n  x.clear();\n  lp(i,v.size()){\n    x.push_back(v[i].t);\n  }\n  sort(x.begin(),x.end());\n  if(v.size()==3){\n    if(x[0]==x[1]&&x[1]==x[2])cnt+=0;\n    else if(x[0]==x[1]||x[1]==x[2])cnt+=1;\n    else{\n      cnt+=2;\n    }\n  }\n  else{\n    if(x[0]==x[1]&&x[1]==x[2]&&x[2]==x[3])cnt+=0;\n    else if(x[0]==x[1]&&x[1]==x[2]){\n      cnt+=1;\n    }\n    else if(x[1]==x[2]&&x[2]==x[3]){\n      cnt++;\n    }\n    else if(x[0]==x[1]||x[2]==x[3]||x[1]==x[2])cnt+=2;\n    else cnt+=3;\n  }\nx.clear();\n  lp(i,v.size()){\n    x.push_back(v[i].d);\n  }\n  sort(x.begin(),x.end());\n  if(v.size()==3){\n    if(x[0]==x[1]&&x[1]==x[2])cnt+=0;\n    else if(x[0]==x[1]||x[1]==x[2])cnt+=1;\n    else{\n      cnt+=2;\n    }\n  }\n  else{\n    if(x[0]==x[1]&&x[1]==x[2]&&x[2]==x[3])cnt+=0;\n    else if(x[0]==x[1]&&x[1]==x[2]){\n      cnt+=1;\n    }\n    else if(x[1]==x[2]&&x[2]==x[3]){\n      cnt++;\n    }\n    else if(x[0]==x[1]||x[2]==x[3]||x[1]==x[2])cnt+=2;\n    else cnt+=3;\n  }\nx.clear();\n  lp(i,v.size()){\n    x.push_back(v[i].l);\n  }\n  sort(x.begin(),x.end());\n  if(v.size()==3){\n    if(x[0]==x[1]&&x[1]==x[2])cnt+=0;\n    else if(x[0]==x[1]||x[1]==x[2])cnt+=1;\n    else{\n      cnt+=2;\n    }\n  }\n  else{\n    if(x[0]==x[1]&&x[1]==x[2]&&x[2]==x[3])cnt+=0;\n    else if(x[0]==x[1]&&x[1]==x[2]){\n      cnt+=1;\n    }\n    else if(x[1]==x[2]&&x[2]==x[3]){\n      cnt++;\n    }\n    else if(x[0]==x[1]||x[2]==x[3]||x[1]==x[2])cnt+=2;\n    else cnt+=3;\n  }\nx.clear();\n  lp(i,v.size()){\n    x.push_back(v[i].b);\n  }\n  sort(x.begin(),x.end());\n  if(v.size()==3){\n    if(x[0]==x[1]&&x[1]==x[2])cnt+=0;\n    else if(x[0]==x[1]||x[1]==x[2])cnt+=1;\n    else{\n      cnt+=2;\n    }\n  }\n  else{\n    if(x[0]==x[1]&&x[1]==x[2]&&x[2]==x[3])cnt+=0;\n    else if(x[0]==x[1]&&x[1]==x[2]){\n      cnt+=1;\n    }\n    else if(x[1]==x[2]&&x[2]==x[3]){\n      cnt++;\n    }\n    else if(x[0]==x[1]||x[2]==x[3]||x[1]==x[2])cnt+=2;\n    else cnt+=3;\n  }\n  return cnt;\n}\n\nint solve(){\n  if(v.size()==1)return 0;\n  if(v.size()==2){\n    int ans=INF;\n    lp(i,task.size()){\n      v[0].roll(task[i]);\n      ans=min(ans,v[0].same(v[1]));\n    }\n    return ans;\n  }\n  if(v.size()==3){\n    int ans=INF;\n    lp(i,task.size()){\n      v[0].roll(task[i]);\n      lp(j,task.size()){\n\tv[1].roll(task[j]);\n\tans=min(ans,acnt());\n      }\n    }\n    return ans;\n  }\n  else{\n    int ans=INF;\n    lp(i,task.size()){\n      v[0].roll(task[i]);\n      lp(j,task.size()){\n\tv[1].roll(task[j]);\n\tlp(k,task.size()){\n\t  v[2].roll(task[k]);\n\t  ans=min(ans,acnt());\n\t}\n      }\n    }\n    return ans;\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n      v.clear();\n    lp(i,n){\n      string a,b,c,d,e,f;\n      cin>>a>>b>>c>>d>>e>>f;\n      dice k(a,b,c,d,e,f);\n      v.push_back(k);\n    }\n    int ans=INF;\n    cout<<solve()<<endl;\n  }\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <algorithm>\n#define FOR(i,l,r) for (i=l;i<=r;i++)\n#define INF 0x3f3f3f3f\n\nusing namespace std;\n\nint i,j,k,l,m,n;\nstatic int c[5][6],t[30],z[6];\nconst int w[24][6]={2,3,0,5,4,1, 3,2,0,5,1,4, 4,1,0,5,3,2, 1,4,0,5,2,3,\n\t2,3,1,4,0,5, 3,2,1,4,5,0, 0,5,1,4,3,2, 5,0,1,4,2,3, \n\t5,0,2,3,4,1, 0,5,2,3,1,4, 4,1,2,3,0,5, 1,4,2,3,5,0,\n\t5,0,3,2,1,4, 0,5,3,2,4,1, 1,4,3,2,0,5, 4,1,3,2,5,0,\n\t2,3,4,1,5,0, 3,2,4,1,0,5, 5,0,4,1,3,2, 0,5,4,1,2,3,\n\t2,3,5,0,1,4, 3,2,5,0,4,1, 1,4,5,0,3,2, 4,1,5,0,2,3};\nstring st;\nint dfs(int o)\n{\n\tint ans=INF,i,j,k;\n\tif (o>n)\n\t{\n\t\tans=0;\n\t\tFOR(i,0,5)\n\t\t{\n\t\t\tmemset(t,0,sizeof(t));\n\t\t\tint ma=0;\n\t\t\tFOR(j,0,n)\n\t\t\t\tma=max(ma,++t[c[j][w[z[j]][i]]]);\n\t\t\tans+=(n-ma);\n\t\t}\n\t\treturn ans;\n\t}\n\tFOR(i,0,23)\n\t{\n\t\tz[o]=i;\n\t\tans=min(ans,dfs(o+1));\n\t}\n\treturn ans;   \n}\nint main() {\n\tmap <string,int> a;\n\twhile (scanf(\"%d\",&n)!=EOF && n)\n\t{\n\t\tFOR(i,1,n) FOR(j,0,5) {\n\t\tcin>>st;if (!a[st]) a[st]=++m;\n\t\tc[i][j]=a[st];} \n\t\tz[1]=0;\n\t\tprintf(\"%d\\n\",dfs(2));\n\t\tmap<string,int>::iterator o=a.begin();\n\t\tfor (;o!=a.end();o++)\n\t\t\to->second=0;\n\t\tm=0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstruct dice{\n  int x[6];\n  void roll_x(){roll(0,4,5,1);}\n  void roll_y(){roll(0,2,5,3);}\n  void roll_z(){roll(1,3,4,2);}\n \n  vector<dice> all_rolls(){\n    vector<dice> res;\n    for(int k=0; k<6; (k&1 ? roll_y() : roll_x()), k++){\n      for(int i=0; i<4; roll_z(),i++){\n        res.push_back(*this);\n      }\n    }\n    return res;\n  }\n \n  void roll(int a,int b,int c,int d){\n    int tmp = x[a];\n    x[a] = x[b];\n    x[b] = x[c];\n    x[c] = x[d];\n    x[d] = tmp;\n  }\n};\n \nvector<dice> a[4];\nint n,ans;\n \nvoid solve(vector<int> z) {\n  if(z.size()==n) {\n    int sum=0;\n    dice v[n];\n    for(int i=0; i<n; i++) v[i]=a[i][z[i]];\n    for(int i=0; i<6; i++) {\n      int c[30];\n      memset(c,0,sizeof(c));\n      for(int j=0; j<n; j++) c[v[j].x[i]]++;\n      int ma=0;\n      for(int i=0; i<30; i++) ma=max(ma,c[i]);\n      sum+=n-ma;\n    }\n    ans=min(ans,sum);\n    return;\n  }\n  for(int i=0; i<a[z.size()].size(); i++) {\n    vector<int> y=z;\n    y.push_back(i);\n    solve(y);\n  }\n}\n \nint main() {\n  while(cin >> n && n) {\n    for(int i=0; i<n; i++) a[i].clear();\n    ans=1000000007;\n \n    map<string, int> m;m.clear();\n    for(int i=0; i<n; i++) {\n      dice b;\n      for(int j=0; j<6; j++) {\n    string s;\n    cin >> s;\n    if(!m[s]) {\n      int q=m.size()+1;\n      m[s]=q;\n    }\n    b.x[j]=m[s];\n      }\n      a[i]=b.all_rolls();\n    }\n    vector<int> y;\n    solve(y);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Dice\n{\n    int t;\npublic:\n    vector<string> pip; // 東南西北上下の目\n    Dice(){\n        t = 0;\n        pip.assign(6, \"\");\n    }\n    void roll(int d){ // 東南西北右左に回転\n        int dir[][4] = {{4,2,5,0},{4,3,5,1},{4,0,5,2},{4,1,5,3},{0,3,2,1},{0,1,2,3}};\n        string tmp = pip[dir[d][0]];\n        for(int i=0; i<3; ++i)\n            pip[dir[d][i]] = pip[dir[d][i+1]];\n        pip[dir[d][3]] = tmp;\n    }\n    void next()\n    {\n        roll(0);\n        ++ t;\n        if(t % 4 == 0){\n            if(t == 16)\n                roll(4);\n            else if(t == 20)\n                roll(4), roll(4);\n            else\n                roll(1);\n        }\n    }\n    bool operator==(const Dice& d) const{\n        return pip == d.pip;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<Dice> d(4);\n        for(int i=0; i<n; ++i){\n            cin >> d[i].pip[0]\n                >> d[i].pip[3]\n                >> d[i].pip[4]\n                >> d[i].pip[5]\n                >> d[i].pip[1]\n                >> d[i].pip[2];\n        }\n\n        int ret = INT_MAX;\n        for(int a=0; a<24; ++a){\n            for(int b=0; b<24; ++b){\n                for(int c=0; c<24; ++c){\n                    int tmp = 0;\n                    for(int i=0; i<6; ++i){\n                        int x = 0;\n                        map<string, int> m;\n                        for(int j=0; j<n; ++j)\n                            x = max(x, ++m[d[j].pip[i]]);\n                        tmp += n - x;\n                    }\n                    ret = min(ret, tmp);\n\n                    d[3].next();\n                }\n                d[2].next();\n            }\n            d[1].next();\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <climits>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n \nenum FACE {SOUTH, EAST, TOP, BOTTOM, WEST, NORTH};\n \ntypedef array<int, 6> A;\n \nstruct dice {\n\tA value;\n \n\tdice(const A &value_):value(value_) {}\n \n\tvoid roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tconst int t = value[a];\n\t\tvalue[a] = value[b];\n\t\tvalue[b] = value[c];\n\t\tvalue[c] = value[d];\n\t\tvalue[d] = t;\n\t}\n \n\tint operator[](int f) const { return value[f]; }\n \n\tvoid north() { roll(TOP, SOUTH, BOTTOM, NORTH); }\n\tvoid east()  { roll(TOP, WEST,  BOTTOM, EAST ); }\n\tvoid ccw()   { roll(NORTH, EAST, SOUTH, WEST ); }\n};\n \nint calc(vector<dice> &dies) {\n\tint res = 0;\n\tfor(int i = 0; i < 6; ++i) {\n\t\tunordered_map<int, int> cnt;\n\t\tfor(const auto &d : dies) {\n\t\t\t++cnt[d[i]];\n\t\t}\n \n\t\tint mx = 0;\n\t\tfor(const auto &e : cnt) {\n\t\t\tmx = max(mx, e.second);\n\t\t}\n \n\t\tres += dies.size() - mx;\n\t}\n \n\treturn res;\n}\n \nint dfs(unsigned idx, vector<dice> &dies) {\n\tif(idx == dies.size()) return calc(dies);\n\n\tint res = INT_MAX;\n \n\tfor(int i = 0; i < 4; ++i) {\n\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\tdies[idx].north();\n\t\t\tchmin(res, dfs(idx + 1, dies));\n\t\t}\n\t\tdies[idx].ccw();\n\t}\n\n\tdies[idx].east();\n\tfor(int i = 0; i < 2; ++i) {\n\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\tdies[idx].north();\n\t\t\tchmin(res, dfs(idx + 1, dies));\n\t\t}\n\t\tdies[idx].ccw();\n\t\tdies[idx].ccw();\n\t}\n\n\treturn res;\n}\n \nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tunordered_map<string, int> encoder;\n\t\tvector<dice> dies;\n\t\tdies.reserve(n);\n \n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tA value;\n\t\t\tfor(auto &e : value) {\n\t\t\t\tstring s;\n\t\t\t\tcin >> s;\n \n\t\t\t\tif(!encoder.count(s)) encoder.insert({s, encoder.size()});\n\t\t\t\te = encoder.at(s);\n\t\t\t}\n \n\t\t\tdies.emplace_back(value);\n\t\t}\n \n\t\tcout << dfs(1, dies) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Dice {\n  string f[6];\n  int id[6];\n  Dice() {\n    init();\n  }\n  void init() {\n    for(int i = 0; i < 6; ++i) {\n      f[i] = \"@\";\n      id[i] = i;\n    }\n  }\n  void rotate1() {\n    int t = id[0];\n    id[0] = id[4];\n    id[4] = id[5];\n    id[5] = id[1];\n    id[1] = t;\n  }\n  void rotate2() {\n    int t = id[1];\n    id[1] = id[3];\n    id[3] = id[4];\n    id[4] = id[2];\n    id[2] = t;\n  }\n  void rotate3() {\n    int t = id[2];\n    id[2] = id[5];\n    id[5] = id[3];\n    id[3] = id[0];\n    id[0] = t;\n  }\n  string getFace(int i) {\n   return f[id[i]];\n  }\n\n  int compare(Dice &d) {\n    int cnt = 0;\n    for(int i = 0; i < 6; ++i) {\n      if(getFace(i) != d.getFace(i)) ++cnt;\n    }\n    return cnt;\n  }\n};\n\nint N;\nDice dice[4];\nint Cost;\n/*\nint calc(Dice &a, Dice &b) {\n  int res = 999;\n  for(int k = 1; k <= 6; ++k) {\n    for(int i = 1; i <= 4; ++i) {\n      int tmp;\n      if((tmp = a.compare(b)) == 0) return 0;\n      res = min(res,tmp);\n      b.rotate1();\n    }\n    if(k <= 4) b.rotate2();\n    if(k == 4) b.rotate3();\n    if(k == 5) {\n      b.rotate3();\n      b.rotate3();\n    }\n    if(k == 6) b.rotate3();\n  }\n  return res;\n}\n*/\n\nvoid calcCost() {\n  int cnt = 0;\n  for(int i = 0; i < 6; ++i) {\n    map<string,int> m;\n    int maxi = 0;\n    for(int j = 0; j < N; ++j) {\n      maxi = max(maxi,++m[dice[j].getFace(i)]);\n    }\n    cnt += N-maxi;\n    if(cnt > Cost) return;\n  }\n  Cost = min(Cost, cnt);\n}\n\nvoid dfs(int p) {\n  if(p == N) {\n    calcCost();\n    return;\n  }\n  for(int k = 1; k <= 6; ++k) {\n    for(int i = 1; i <= 4; ++i) {\n      dfs(p+1);\n      dice[p].rotate1();\n    }\n    if(k <= 4) dice[p].rotate2();\n    if(k == 4) dice[p].rotate3();\n    if(k == 5) {\n      dice[p].rotate3();\n      dice[p].rotate3();\n    }\n    if(k == 6) dice[p].rotate3();\n  }\n}\n\nint solve() {\n  Cost = 99999;\n  dfs(0);\n  return Cost;\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      dice[i].init();\n      for(int j = 0; j < 6; ++j) {\n\tcin >> dice[i].f[j];\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\nusing namespace std;\n\nenum {TOP=0,FRONT,RIGHT,LEFT,BACK,BOTTOM};\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rotate_swap(x,a,b,c,d) swap(x.m[a],x.m[b]);swap(x.m[b],x.m[c]);swap(x.m[c],x.m[d]);\n\nclass Dice{\npublic:\n  int m[6];\n  bool operator<(const Dice &a)const{\n    rep(i,6)if(m[i]!=a.m[i])return m[i]<a.m[i];\n    return false;\n  }  \n};\n\nvoid rotate_r(Dice &x){\n  rotate_swap(x,TOP,LEFT,BOTTOM,RIGHT);\n}\nvoid rotate_f(Dice &x){\n  rotate_swap(x,TOP,BACK,BOTTOM,FRONT);\n}\nvoid rotate_cw(Dice &x){\n  rotate_swap(x,BACK,LEFT,FRONT,RIGHT);\n}\n\nDice ds[4];\nDice data[4][24];\n\nvoid generate_all( int id, Dice x ){\n  rep(i,6){\n    rep(j,4){\n      data[id][i*4+j]=x;\n      rotate_cw(x);\n    }\n    \n    if(i%2==0)rotate_r(x);\n    else rotate_f(x);\n  }\n}\n\n\nint main()\n{\n  int n;\n  while(cin>>n&&n){\n    int id = 0;\n    map<string,int> D;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j <  6; ++j){\n        string color;\n        cin >> color;\n        if( D.find(color) == D.end() ){\n          D[color] = id++;\n        }\n        ds[i].m[j] = D[color];\n        //cout << ds[i].m[j] << ' ';\n      }\n      //cout << endl;\n      generate_all(i,ds[i]);\n    }\n    //cout <<\"input end\" << endl;\n\n    int res = 1000;\n    map<int,int> M;\n    for(int a = 0; a < 24; ++a){\n      for(int b = 0; b < (n>=2?24:1); ++b){\n        for(int c = 0; c < (n>=3?24:1); ++c){\n          for(int d = 0; d < (n>=4?24:1); ++d){\n            int cost = 0;\n            for(int k = 0; k < 6; ++k){\n              int cs[24]={0,};\n              int sz = 0;\n              if(n>=1)\n                cs[data[0][a].m[k]]++;\n              if(n>=2)\n                cs[data[1][b].m[k]]++;\n              if(n>=3)\n                cs[data[2][c].m[k]]++;\n              if(n>=4)\n                cs[data[3][d].m[k]]++;\n\n              for(int l = 0; l < 24; ++l)sz+=cs[l]!=0?1:0;\n              \n              if( sz == 4 ){\n                cost += 3;\n              }else if( sz == 3 ){\n                cost += 2;\n              }else if( sz == 2 ){\n                if( n == 2 ){\n                  cost += 1;\n                }else{\n                  for(int l = 0; l < 24; ++l){\n                    if( cs[l] != 0 ){\n                      if( (n==4 && (cs[l] == 3||cs[l]==1) ) || n == 3 ){\n                        cost += 1; break;\n                      }else if( n == 4 && cs[l] == 2 ){\n                        cost += 2; break;\n                      }\n                    }\n                  }\n                }\n              }\n              else if( sz == 1 ) continue;\n              if( cost >= res ) break;\n            }\n            //cout << a << ' ' << b << ' ' << c << ' ' << d << ' ' << cost << endl;\n            res = min( res, cost );\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\n// 28ñÅ³ÉàÇé\nclass Dice{\nprivate:\n\tint yoko;\n\tint tate;\n\tint round;\n\nprivate:\n    int face[3][4];\n\npublic:\n\tint getFace(int i,int j)const{\n\t\treturn face[i][j];\n\t}\n\n\tDice(vector<int> &v){\n\t\tinit();\n\t\tface[1][1]=v[0];\n\t\tface[2][1]=v[1];\n\t\tface[1][2]=v[2];\n\t\tface[1][0]=v[3];\n\t\tface[0][1]=v[4];\n\t\tface[1][3]=v[5];\n\t}\nprivate:\n\t// _CXÌú»\n\tvoid init(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tface[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tyoko=0;\n\t\ttate=0;\n\t\tround=0;\n\t}\npublic:\n\t// _CXÌñ]\n\tvoid rotate(){\n\t\tif(round<4){\n            int tmp = face[2][1];\n\t\t\tface[2][1]=face[1][2];\n\t\t\tface[1][2]=face[0][1];\n\t\t\tface[0][1]=face[1][0];\n\t\t\tface[1][0]=tmp;\n\t\t\tround++;\n\t\t}\n\t\tif(round>=4){\n\t\t\tround=0;\n\t\t\t// àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n\t\t\tif(yoko<4){\n                int tmp = face[1][3];\n\t\t\t\tfor(int i = 2; i >= 0; i--){\n\t\t\t\t\tface[1][i+1]=face[1][i];\n\t\t\t\t}\n\t\t\t\tface[1][0]=tmp;\n\t\t\t\tyoko++;\n\t\t\t}\n\t\t\t// àÇÁÄ«½çAcÌXbgðñ]³¹é\n\t\t\tif(yoko>=4){\n\t\t\t\tif(tate<4){\n\t\t\t\t\ttate++;\n\t\t\t\t\tint tmp = face[1][3];\n\t\t\t\t\tface[1][3]=face[0][1];\n\t\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\t\tface[i][1]=face[i+1][1];\n\t\t\t\t\t}\n\t\t\t\t\tface[2][1]=tmp;\n\t\t\t\t}\n\t\t\t\tif(tate>=4){\n\t\t\t\t\tround=0;\n\t\t\t\t\ttate=0;\n\t\t\t\t\tyoko=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\nconst int INF=1000000000;\nint n;\nvector<Dice> dices;\nint minCost;\n\nstring data[10][10];\nmap<int,int> msi;\n\nvoid dfs(int depth){\n    if(depth==n){\n        int sum=0;\n        // Ê²ÆÉf[^ðûW\n        for(int i = 0; i < 6; i++){\n            msi.clear();\n            for(int j = 0; j < n; j++){\n                if(i==0)\n                    msi[dices[j].getFace(1,1)]++;\n                else if(i==1)\n                    msi[dices[j].getFace(2,1)]++;\n                else if(i==2)\n                    msi[dices[j].getFace(1,2)]++;\n                else if(i==3)\n                    msi[dices[j].getFace(1,0)]++;\n                else if(i==4)\n                    msi[dices[j].getFace(0,1)]++;\n                else\n                    msi[dices[j].getFace(1,3)]++;\n            }\n            int maxNum=0;\n            for(map<int,int>::iterator it=msi.begin();it!=msi.end();it++){\n                if(it->second>maxNum){\n                    maxNum=it->second;\n                }\n            }\n            sum+=n-maxNum;\n        }\n        minCost=min(sum,minCost);\n    }\n    else{\n        // ñ]Èµ\n        dfs(depth+1);\n        for(int i = 0; i < 28; i++){\n            dices[depth].rotate();\n            dfs(depth+1);\n        }\n    }\n}\n\nint main(){\n    \n    while(cin>>n&&n!=0){\n        minCost=INF;\n        int idx=0;\n        map<string,int> idxs;\n        for(int i = 0; i < n; i++){\n            vector<int> v;\n            for(int j = 0; j < 6; j++){\n                string s;\n                cin>>s;\n                if(idxs.find(s)==idxs.end())\n                    idxs[s]=idx++;\n                v.push_back(idxs[s]);\n            }\n            dices.push_back(Dice(v));\n        }\n        dfs(0);\n        dices.clear();\n        cout<<minCost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\n// 28ñÅ³ÉàÇé\nclass Dice{\nprivate:\n  int yoko;\n  int tate;\n  int round;\n  \nprivate:\n    int face[3][4];\n  \npublic:\n  int getFace(int i,int j)const{\n    return face[i][j];\n  }\n  Dice(vector<int> &v){\n    init();\n    face[1][1]=v[0];\n    face[2][1]=v[1];\n    face[1][2]=v[2];\n    face[1][0]=v[3];\n    face[0][1]=v[4];\n    face[1][3]=v[5];\n  }\nprivate:\n  // _CXÌú»\n  void init(){\n    for(int i = 0; i < 3; i++){\n      for(int j = 0; j < 4; j++){\n\tface[i][j]=-1;\n      }\n    }\n    yoko=0;\n    tate=0;\n    round=0;\n  }\npublic:\n  // _CXÌñ]\n  void rotate(){\n    if(round<4){\n      int tmp = face[2][1];\n      face[2][1]=face[1][2];\n      face[1][2]=face[0][1];\n      face[0][1]=face[1][0];\n      face[1][0]=tmp;\n      round++;\n    }\n    if(round>=4){\n      round=0;\n      // àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n      if(yoko<4){\n\tint tmp = face[1][3];\n\tfor(int i = 2; i >= 0; i--){\n\t  face[1][i+1]=face[1][i];\n\t}\n\tface[1][0]=tmp;\n\tyoko++;\n      }\n      // àÇÁÄ«½çAcÌXbgðñ]³¹é\n      if(yoko>=4){\n\tif(tate<4){\n\t  tate++;\n\t  int tmp = face[1][3];\n\t  face[1][3]=face[0][1];\n\t  for(int i = 0; i < 2; i++){\n\t    face[i][1]=face[i+1][1];\n\t  }\n\t  face[2][1]=tmp;\n\t}\n\tif(tate>=4){\n\t  round=0;\n\t  tate=0;\n\t  yoko=0;\n\t}\n      }\n    }\n  };\n};\n\nconst int INF=1000000000;\nint n;\nvector<Dice> dices;\nint minCost;\nint msi[1001];\n\nvoid dfs(int depth){\n  if(depth==n){\n    int sum=0;\n    // Ê²ÆÉf[^ðûW\n    for(int i = 0; i < 6; i++){\n      memset(msi,0,sizeof(msi));\n      int maxNum=0;\n      for(int j = 0; j < n; j++){\n\tif(i==0){\n\t  msi[dices[j].getFace(1,1)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,1)]);\n\t}\n\telse if(i==1){\n\t  msi[dices[j].getFace(2,1)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(2,1)]);\n\t}\n\telse if(i==2){\n\t  msi[dices[j].getFace(1,2)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,2)]);\n\t}\n\telse if(i==3){\n\t  msi[dices[j].getFace(1,0)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,0)]);\n\t}\n\telse if(i==4){\n\t  msi[dices[j].getFace(0,1)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(0,1)]);\n\t}\n\telse{\n\t  msi[dices[j].getFace(1,3)]++;\n\t  maxNum=max(maxNum,msi[dices[j].getFace(1,3)]);\n\t}\n      }\n      sum+=n-maxNum;\n    }\n    minCost=min(sum,minCost);\n  }\n  else{\n    // ñ]Èµ\n    dfs(depth+1);\n    for(int i = 0; i < 20; i++){\n      dices[depth].rotate();\n      dfs(depth+1);\n    }\n  }\n}\n\nint main(){\n  \n  while(cin>>n&&n!=0){\n    minCost=INF;\n    int idx=0;\n    map<string,int> idxs;\n    for(int i = 0; i < n; i++){\n      vector<int> v;\n      for(int j = 0; j < 6; j++){\n\tstring s;\n\tcin>>s;\n\tif(idxs.find(s)==idxs.end())\n\t  idxs[s]=idx++;\n\tv.push_back(idxs[s]);\n      }\n      dices.push_back(Dice(v));\n    }\n    dfs(0);\n    dices.clear();\n    cout<<minCost<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<fstream>\n#include<sstream>\n#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<map>\n#define FOR(i,l,r) for (i=l;i<=r;i++)\n#define INF 0x3f3f3f3f\nusing namespace std;\nint i,j,k,l,m,n;\nstatic int c[5][6],t[30],z[6];\nconst int w[24][6]={2,3,0,5,4,1, 3,2,0,5,1,4, 4,1,0,5,3,2, 1,4,0,5,2,3,\n2,3,1,4,0,5, 3,2,1,4,5,0, 0,5,1,4,3,2, 5,0,1,4,2,3, \n5,0,2,3,4,1, 0,5,2,3,1,4, 4,1,2,3,0,5, 1,4,2,3,5,0,\n5,0,3,2,1,4, 0,5,3,2,4,1, 1,4,3,2,0,5, 4,1,3,2,5,0,\n2,3,4,1,5,0, 3,2,4,1,0,5, 5,0,4,1,3,2, 0,5,4,1,2,3,\n2,3,5,0,1,4, 3,2,5,0,4,1, 1,4,5,0,3,2, 4,1,5,0,2,3};\nstring st;\nint dfs(int o) {\nint ans=INF,i,j,k;\nif (o>n) {\nans=0;\nFOR(i,0,5) {\nmemset(t,0,sizeof(t));int ma=0;\nFOR(j,0,n) ma=max(ma,++t[c[j][w[z[j]][i]]]);\nans+=(n-ma);\n}\nreturn ans;}\nFOR(i,0,23) {\nz[o]=i;ans=min(ans,dfs(o+1));}\nreturn ans;   \n}            \nint main() {\n\nmap <string,int> a;\nwhile (scanf(\"%d\",&n)!=EOF && n) {\nFOR(i,1,n) FOR(j,0,5) {\ncin>>st;if (!a[st]) a[st]=++m;\nc[i][j]=a[st];} \nz[1]=0;printf(\"%d\\n\",dfs(2));\nmap<string,int>::iterator o=a.begin();\nfor (;o!=a.end();o++) o->second=0;\n//a.begin()=a.end();\nm=0;}\nreturn 1;\n}         "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <map>\n#include <iostream>\n\nusing namespace std;\n\nconst int mov[24][6]= {\n  {0,1,2,3,4,5},{0,2,4,1,3,5},{0,4,3,2,1,5},{0,3,1,4,2,5},\n  {3,1,0,5,4,2},{3,0,4,1,5,2},{3,4,5,0,1,2},{3,5,1,4,0,2},\n  {5,1,3,2,4,0},{5,3,4,1,2,0},{5,4,2,3,1,0},{5,2,1,4,3,0},\n  {2,1,5,0,4,3},{2,5,4,1,0,3},{2,4,0,5,1,3},{2,0,1,4,5,3},\n  {4,0,2,3,5,1},{4,2,5,0,3,1},{4,5,3,2,0,1},{4,3,0,5,2,1},\n  {1,0,3,2,5,4},{1,3,5,0,2,4},{1,5,2,3,0,4},{1,2,0,5,3,4}\n};\n\nstruct Cube {\n\tint num[7];\n};\n\nint n, cnt, ans;\nchar str[1000];\nCube c[5], now[5];\nmap<string,int> id;\n\nint ID(char *st) {\n\tif (id[st] == 0) return id[st] = ++cnt;\n\treturn id[st];\n}\n\nvoid dfs(int dep) {\n\tif (n == dep) {\n\t\tint ans1 = 0;\n\t\tfor (int j = 0; j < 6; ++j) {\n\t\t\tint count[30] = {0};\n\t\t\tfor (int i = 0; i < n; ++i) ++count[now[i].num[j]];\n\t\t\tint up = 0;\n\t\t\tfor (int i = 1; i <= cnt; ++i) up = max(up, count[i]);\n\t\t\tans1 += n - up;\n\t\t}\n\t\tans = min(ans, ans1);\n\t\treturn ;\t\n\t}\n\tfor (int i = 0; i < 24; ++i) {\n\t\tfor (int j = 0; j < 6; ++j) {\n\t\t\tnow[dep].num[j] = c[dep].num[mov[i][j]];\n\t\t}\n\t\tdfs(dep + 1);\n\t}\n}\n\nvoid Clear() {\n\tmemset(c, 0, sizeof c);\n\tmemset(now, 0, sizeof now);\n\tid.clear();\n\tcnt = 0;\n}\n\nint main() {\n\twhile (1 == scanf(\"%d\", &n)) {\n\t\tif (0 == n) break;\n\t\tClear();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 6; ++j) {\n\t\t\t\tscanf(\"%s\", str);\n\t\t\t\tc[i].num[j] = ID(str);\n\t\t\t}\n\t\t}\n\t\tif (1 == n) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tans = (int)1e9;\n\t\tnow[0] = c[0];\n\t\tdfs(1);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nclass Dice{\nprivate:\n    int tmp;\npublic:\n    int d[6];\n \n    void rollN(){\n\ttmp = d[0];\n\td[0] = d[1];\n\td[1] = d[5];\n\td[5] = d[4];\n\td[4] = tmp;\n    }\n    void rollE(){\n\ttmp = d[0];\n\td[0] = d[3];\n\td[3] = d[5];\n\td[5] = d[2];\n\td[2] = tmp;\n    }\n    void rotation(){\n\ttmp = d[1];\n\td[1] = d[3];\n\td[3] = d[4];\n\td[4] = d[2];\n\td[2] = tmp;\n    }\n    bool operator < (const Dice &die)const{\n\tfor(int i = 0 ; i < 6 ; i++){\n\t    if(d[i] != die.d[i]) return d[i] < die.d[i];\n\t}\n\treturn false;\n    }\n};\n \nint N,ans,p[4];\nmap<string,int> mp;\nvector<Dice> dice[4];\n \nint getCost(){\n    int res = 0;\n    for(int i = 0 ; i < 6 ; i++){\n\tint cnt[25] = {0}, max = 0;\n\tfor(int j = 0 ; j < N ; j++){\n\t    cnt[dice[j][p[j]].d[i]]++;\n\t    max = std::max(max,cnt[dice[j][p[j]].d[i]]);\n\t}\n\tres += N-max;\n    }\n    return res;\n}\n \nvoid solve(int x){\n    if(x == N){\n\tans = min(ans,getCost());\n\treturn;\n    }\n    for(int i = 0 ; i < (int)dice[x].size() ; i++){\n\tp[x] = i;\n\tsolve(x+1);\n    }\n}\n \nvector<Dice> make(Dice die){\n    vector<Dice> res;\n    set<Dice> visited;\n    for(int i = 0 ; i < 4 ; i++){\n\tfor(int j = 0 ; j < 4 ; j++){\n\t    if(!visited.count(die)){\n\t\tvisited.insert(die);\n\t\tres.push_back(die);\n\t    }\n\t    die.rollN();\n\t}\n\tfor(int j = 0 ; j < 4 ; j++){\n\t    if(!visited.count(die)){\n\t\tvisited.insert(die);\n\t\tres.push_back(die);\n\t    }\n\t    die.rollE();\n\t}\n\tdie.rotation();\n    }\n    return res;\n}\n \nint main(){\n    Dice in;\n    while(cin >> N, N){\n\tint n = 0;\n\tmp.clear();\n\tfor(int i = 0 ; i < N ; i++){\n\t    p[i] = -1;\n\t    for(int j = 0 ; j < 6 ; j++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(mp.find(s) != mp.end()){\n\t\t    in.d[j] = mp[s];\n\t\t}else{\n\t\t    mp[s] = n++;\n\t\t    in.d[j] = mp[s];\n\t\t}\n\t    }\n\t    dice[i] = make(in);\n\t}\n\tans = 1e9;\n\tsolve(0);\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<map>\n#include <algorithm>\n\n#define INF 0x7fffffff\n\nusing namespace std;\n\nint i,j,k,l,m,n;\n int c[5][6],t[30],z[6];\n int w[24][6]={2,3,0,5,4,1, 3,2,0,5,1,4, 4,1,0,5,3,2, 1,4,0,5,2,3,\n2,3,1,4,0,5, 3,2,1,4,5,0, 0,5,1,4,3,2, 5,0,1,4,2,3,\n5,0,2,3,4,1, 0,5,2,3,1,4, 4,1,2,3,0,5, 1,4,2,3,5,0,\n5,0,3,2,1,4, 0,5,3,2,4,1, 1,4,3,2,0,5, 4,1,3,2,5,0,\n2,3,4,1,5,0, 3,2,4,1,0,5, 5,0,4,1,3,2, 0,5,4,1,2,3,\n2,3,5,0,1,4, 3,2,5,0,4,1, 1,4,5,0,3,2, 4,1,5,0,2,3};\nstring st;\nint dfs(int o) {\nint ans=INF,i,j,k;\nif (o>n) {\nans=0;\nfor(int i=0;i<=5;i++) {\nmemset(t,0,sizeof(t));int ma=0;\nfor(int j=0;j<=n;j++) ma=max(ma,++t[c[j][w[z[j]][i]]]);\nans+=(n-ma);\n}\nreturn ans;}\nfor(int i=0;i<=23;i++) {\nz[o]=i;ans=min(ans,dfs(o+1));}\nreturn ans;\n}\nint main() {\n\nmap <string,int> a;\nwhile (scanf(\"%d\",&n)!=EOF && n) {\nfor(int i=1;i<=n;i++) for(int j=0;j<=5;j++) {\ncin>>st;if (!a[st]) a[st]=++m;\nc[i][j]=a[st];}\nz[1]=0;printf(\"%d\\n\",dfs(2));\nmap<string,int>::iterator o=a.begin();\nfor (;o!=a.end();o++) o->second=0;\n\nm=0;}\nreturn 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef vector<vector<int> > VVI;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint ans;\n\nclass Dice{\npublic:\n   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n   Dice(){}\n   Dice(int _t, int _s, int _e, int _n, int _w, int _b){\n       t = _t, s = _s,e = _e,n = _n,w = _w,b = _b;\n   }\n\n   Dice rotate_front(){\n      return Dice(s,b,e,t,w,n);\n   }\n\n   Dice rotate_left(){\n      return Dice(e,s,b,n,t,w);\n   }\n\n   Dice rotate_right(){\n      return Dice(w,s,t,n,b,e);\n   }\n\n   Dice rotate_back(){\n      return Dice(n,t,e,b,w,s);\n   }\n\n   Dice move_right(){\n      return Dice(t,e,n,w,s,b);\n   }\n\n   Dice move_left(){\n      return Dice(t,w,s,e,n,b);\n   }\n\n   void print(){\n      cout << \"t=\" << t << \"s=\" << s << \"e=\" << e << \"n=\" << n\n           << \"w=\" << w << \"b=\" << b << endl;\n   }\n};\n\nvector<Dice>all;\n\nDice getDice(int top, int south){\n   for(int i=0; i<24; i++){\n      if(all[i].t == top && all[i].s == south){\n         return all[i];\n      }\n   }\n}\n\nvoid allState(int a, int b, int c, int d, int e, int f){\n   all.clear();\n   Dice dice(a,b,c,d,e,f);\n   for(int i=0; i<6; i++){\n      for(int j=0; j<4; j++){\n         all.push_back(dice);\n         dice = dice.move_right();\n      }\n      if(i < 4) dice = dice.rotate_front();\n      if(i == 3) dice = dice.rotate_right();\n      if(i == 4) dice = dice.rotate_right().rotate_right();\n   }\n}\n\nint N;\nvector<vector<vector<int> > >v;\n\n\nint check(vector<int> vv){\n  int res = 0;\n  vector<vector<int> >d;\n  d.resize(N);\n\n  for(int i=0; i<vv.size(); i++){\n    for(int j=0; j<6; j++){\n      d[i].push_back(v[i][vv[i]][j]);\n    }\n  }\n\n  for(int i=0; i<6; i++){\n    map<int,int>m;\n    for(int j=0; j<N; j++){\n      m[d[j][i]]++;\n    }\n\n    int Max = 0;\n    for(map<int,int>::iterator it=m.begin(); it != m.end(); it++){\n      Max = max(Max,it->second);\n    }\n    res += N - Max;\n    if(res >= ans) return 1<<29;\n  }\n  return res;\n}\n\n\nvoid dfs(int cnt, vector<int>vv){\n  if(ans == 0) return;\n\n  if(cnt == N){\n    ans = min(ans,check(vv));\n    return;\n  }\n\n  for(int i=0; i<v[cnt].size(); i++){\n    vector<int>tmp = vv;\n    tmp.push_back(i);\n    dfs(cnt+1,tmp);\n  }\n\n}\n\nint main(){\n\n  while(cin >> N, N){\n    set<string> S;\n    \n    string in[4][6];\n    \n    string s;\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tcin >> s;\n\tin[i][j] = s;\n\tS.insert(s);\n      }\n    }\n    \n    map<string, int> mp;\n    \n    int cnt = 1;\n    for(set<string>::iterator it = S.begin() ; it != S.end() ; it++){\n      mp[*it] = cnt++;\n    }\n    \n    int dice[4][6];\n    memset(dice, 0, sizeof(dice));\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tdice[i][j] = mp[in[i][j]];\n      }\n    }\n\n    //   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n\n    v.clear();\n\n    for(int i=0; i<N; i++){\n      allState(dice[i][2],dice[i][0],dice[i][1],dice[i][5],dice[i][4],dice[i][3]);\n\n\n      vector<vector<int> >tmp2;\n\n      for(int j=0; j<all.size(); j++){\n\tvector<int>tmp;\n\ttmp.push_back(all[j].t);\n\ttmp.push_back(all[j].s);\n\ttmp.push_back(all[j].e);\n\ttmp.push_back(all[j].n);\n\ttmp.push_back(all[j].w);\n\ttmp.push_back(all[j].b);\n\ttmp2.push_back(tmp);\n      }\n      sort(tmp2.begin(),tmp2.end());\n      tmp2.erase(unique(tmp2.begin(),tmp2.end()),tmp2.end());\n      v.push_back(tmp2);\n    }\n\n\n\n\n    ans = 1<<29;\n    vector<int>e;\n    dfs(0,e);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef vector<vector<int> > VVI;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint ans;\n\nclass Dice{\npublic:\n   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n   Dice(){}\n   Dice(int _t, int _s, int _e, int _n, int _w, int _b){\n       t = _t, s = _s,e = _e,n = _n,w = _w,b = _b;\n   }\n\n   Dice rotate_front(){\n      return Dice(s,b,e,t,w,n);\n   }\n\n   Dice rotate_left(){\n      return Dice(e,s,b,n,t,w);\n   }\n\n   Dice rotate_right(){\n      return Dice(w,s,t,n,b,e);\n   }\n\n   Dice rotate_back(){\n      return Dice(n,t,e,b,w,s);\n   }\n\n   Dice move_right(){\n      return Dice(t,e,n,w,s,b);\n   }\n\n   Dice move_left(){\n      return Dice(t,w,s,e,n,b);\n   }\n\n   void print(){\n      cout << \"t=\" << t << \"s=\" << s << \"e=\" << e << \"n=\" << n\n           << \"w=\" << w << \"b=\" << b << endl;\n   }\n};\n\nvector<Dice>all;\n\nDice getDice(int top, int south){\n   for(int i=0; i<24; i++){\n      if(all[i].t == top && all[i].s == south){\n         return all[i];\n      }\n   }\n}\n\nvoid allState(int a, int b, int c, int d, int e, int f){\n   all.clear();\n   Dice dice(a,b,c,d,e,f);\n   for(int i=0; i<6; i++){\n      for(int j=0; j<4; j++){\n         all.push_back(dice);\n         dice = dice.move_right();\n      }\n      if(i < 4) dice = dice.rotate_front();\n      if(i == 3) dice = dice.rotate_right();\n      if(i == 4) dice = dice.rotate_right().rotate_right();\n   }\n}\n\nint N;\nvector<vector<vector<int> > >v;\n\n\nint check(vector<int> vv){\n  int res = 0;\n  vector<vector<int> >d;\n  d.resize(6);\n\n  for(int i=0; i<vv.size(); i++){\n    for(int j=0; j<6; j++){\n      d[i].push_back(v[i][vv[i]][j]);\n    }\n  }\n\n  for(int i=0; i<6; i++){\n    map<int,int>m;\n    for(int j=0; j<N; j++){\n      m[d[j][i]]++;\n    }\n\n    int Max = 0;\n    for(map<int,int>::iterator it=m.begin(); it != m.end(); it++){\n      Max = max(Max,it->second);\n    }\n    res += N - Max;\n    if(res >= ans) return 1<<29;\n  }\n  return res;\n}\n\n\nvoid dfs(int cnt, vector<int>vv){\n  if(ans == 0) return;\n\n  if(cnt == N){\n    ans = min(ans,check(vv));\n    return;\n  }\n\n  for(int i=0; i<v[cnt].size(); i++){\n    vector<int>tmp = vv;\n    tmp.push_back(i);\n    dfs(cnt+1,tmp);\n  }\n\n}\n\nint main(){\n\n  while(cin >> N, N){\n    set<string> S;\n    \n    string in[4][6];\n    \n    string s;\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tcin >> s;\n\tin[i][j] = s;\n\tS.insert(s);\n      }\n    }\n    \n    map<string, int> mp;\n    \n    int cnt = 1;\n    for(set<string>::iterator it = S.begin() ; it != S.end() ; it++){\n      mp[*it] = cnt++;\n    }\n    \n    int dice[4][6];\n    memset(dice, 0, sizeof(dice));\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tdice[i][j] = mp[in[i][j]];\n      }\n    }\n\n    //   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n\n    v.clear();\n\n    for(int i=0; i<N; i++){\n      allState(dice[i][2],dice[i][0],dice[i][1],dice[i][5],dice[i][4],dice[i][3]);\n\n\n      vector<vector<int> >tmp2;\n\n      for(int j=0; j<all.size(); j++){\n\tvector<int>tmp;\n\ttmp.push_back(all[j].t);\n\ttmp.push_back(all[j].s);\n\ttmp.push_back(all[j].e);\n\ttmp.push_back(all[j].n);\n\ttmp.push_back(all[j].w);\n\ttmp.push_back(all[j].b);\n\ttmp2.push_back(tmp);\n      }\n      v.push_back(tmp2);\n    }\n\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n\n\n    ans = 1<<29;\n    vector<int>e;\n    dfs(0,e);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <climits>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n \nenum FACE {SOUTH, EAST, TOP, BOTTOM, WEST, NORTH};\n \ntypedef array<int, 6> A;\n \nstruct dice {\n\tA value;\n \n\tdice(const A &value_):value(value_) {}\n \n\tvoid roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tconst int t = value[a];\n\t\tvalue[a] = value[b];\n\t\tvalue[b] = value[c];\n\t\tvalue[c] = value[d];\n\t\tvalue[d] = t;\n\t}\n \n\tint operator[](int f) const { return value[f]; }\n \n\tvoid north() { roll(TOP, SOUTH, BOTTOM, NORTH); }\n\tvoid east()  { roll(TOP, WEST,  BOTTOM, EAST ); }\n\tvoid ccw()   { roll(NORTH, EAST, SOUTH, WEST ); }\n};\n \nint calc(vector<dice> &dies) {\n\tint res = 0;\n\tfor(int i = 0; i < 6; ++i) {\n\t\tunordered_map<int, int> cnt;\n\t\tfor(const auto &d : dies) {\n\t\t\t++cnt[d[i]];\n\t\t}\n \n\t\tint mx = 0;\n\t\tfor(const auto &e : cnt) {\n\t\t\tchmax(mx, e.second);\n\t\t}\n \n\t\tres += dies.size() - mx;\n\t}\n \n\treturn res;\n}\n \nint dfs(unsigned idx, vector<dice> &dies) {\n\tif(idx == dies.size()) return calc(dies);\n\n\tint res = INT_MAX;\n \n\tfor(int i = 0; i < 4; ++i) {\n\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\tdies[idx].north();\n\t\t\tchmin(res, dfs(idx + 1, dies));\n\t\t}\n\t\tdies[idx].ccw();\n\t}\n\n\tdies[idx].east();\n\tfor(int i = 0; i < 2; ++i) {\n\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\tdies[idx].north();\n\t\t\tchmin(res, dfs(idx + 1, dies));\n\t\t}\n\t\tdies[idx].ccw();\n\t\tdies[idx].ccw();\n\t}\n\n\treturn res;\n}\n \nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tunordered_map<string, int> encoder;\n\t\tvector<dice> dies;\n\t\tdies.reserve(n);\n \n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tA value;\n\t\t\tfor(auto &e : value) {\n\t\t\t\tstring s;\n\t\t\t\tcin >> s;\n \n\t\t\t\tif(!encoder.count(s)) encoder.insert({s, encoder.size()});\n\t\t\t\te = encoder.at(s);\n\t\t\t}\n \n\t\t\tdies.emplace_back(value);\n\t\t}\n \n\t\tcout << dfs(1, dies) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef vector<vector<int> > VVI;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint ans;\n\nclass Dice{\npublic:\n   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n   Dice(){}\n   Dice(int _t, int _s, int _e, int _n, int _w, int _b){\n       t = _t, s = _s,e = _e,n = _n,w = _w,b = _b;\n   }\n\n   Dice rotate_front(){\n      return Dice(s,b,e,t,w,n);\n   }\n\n   Dice rotate_left(){\n      return Dice(e,s,b,n,t,w);\n   }\n\n   Dice rotate_right(){\n      return Dice(w,s,t,n,b,e);\n   }\n\n   Dice rotate_back(){\n      return Dice(n,t,e,b,w,s);\n   }\n\n   Dice move_right(){\n      return Dice(t,e,n,w,s,b);\n   }\n\n   Dice move_left(){\n      return Dice(t,w,s,e,n,b);\n   }\n\n   void print(){\n      cout << \"t=\" << t << \"s=\" << s << \"e=\" << e << \"n=\" << n\n           << \"w=\" << w << \"b=\" << b << endl;\n   }\n};\n\nvector<Dice>all;\n\nDice getDice(int top, int south){\n   for(int i=0; i<24; i++){\n      if(all[i].t == top && all[i].s == south){\n         return all[i];\n      }\n   }\n}\n\nvoid allState(int a, int b, int c, int d, int e, int f){\n   all.clear();\n   Dice dice(a,b,c,d,e,f);\n   for(int i=0; i<6; i++){\n      for(int j=0; j<4; j++){\n         all.push_back(dice);\n         dice = dice.move_right();\n      }\n      if(i < 4) dice = dice.rotate_front();\n      if(i == 3) dice = dice.rotate_right();\n      if(i == 4) dice = dice.rotate_right().rotate_right();\n   }\n}\n\nint N;\nvector<vector<vector<int> > >v;\n\n\nint check(vector<int> vv){\n  int res = 0;\n  vector<vector<int> >d;\n  d.resize(N);\n\n  for(int i=0; i<vv.size(); i++){\n    for(int j=0; j<6; j++){\n      d[i].push_back(v[i][vv[i]][j]);\n    }\n  }\n\n  for(int i=0; i<6; i++){\n    map<int,int>m;\n    for(int j=0; j<N; j++){\n      m[d[j][i]]++;\n    }\n\n    int Max = 0;\n    for(map<int,int>::iterator it=m.begin(); it != m.end(); it++){\n      Max = max(Max,it->second);\n    }\n    res += N - Max;\n    if(res >= ans) return 1<<29;\n  }\n  return res;\n}\n\n\nvoid dfs(int cnt, vector<int>vv){\n  if(ans == 0) return;\n\n  if(cnt == N){\n    ans = min(ans,check(vv));\n    return;\n  }\n\n  for(int i=0; i<v[cnt].size(); i++){\n    vector<int>tmp = vv;\n    tmp.push_back(i);\n    dfs(cnt+1,tmp);\n  }\n\n}\n\nint main(){\n\n  while(cin >> N, N){\n    set<string> S;\n    \n    string in[4][6];\n    \n    string s;\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tcin >> s;\n\tin[i][j] = s;\n\tS.insert(s);\n      }\n    }\n    \n    map<string, int> mp;\n    \n    int cnt = 1;\n    for(set<string>::iterator it = S.begin() ; it != S.end() ; it++){\n      mp[*it] = cnt++;\n    }\n    \n    int dice[4][6];\n    memset(dice, 0, sizeof(dice));\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tdice[i][j] = mp[in[i][j]];\n      }\n    }\n\n    //   int t,s,e,n,w,b; //t=top,s=south,e=east,n=north,w=west,b=bottom\n\n    v.clear();\n\n    for(int i=0; i<N; i++){\n      allState(dice[i][2],dice[i][0],dice[i][1],dice[i][5],dice[i][4],dice[i][3]);\n\n\n      vector<vector<int> >tmp2;\n\n      for(int j=0; j<all.size(); j++){\n\tvector<int>tmp;\n\ttmp.push_back(all[j].t);\n\ttmp.push_back(all[j].s);\n\ttmp.push_back(all[j].e);\n\ttmp.push_back(all[j].n);\n\ttmp.push_back(all[j].w);\n\ttmp.push_back(all[j].b);\n\ttmp2.push_back(tmp);\n      }\n      v.push_back(tmp2);\n    }\n\n    //    sort(v.begin(),v.end());\n    //    v.erase(unique(v.begin(),v.end()),v.end());\n\n\n    ans = 1<<29;\n    vector<int>e;\n    dfs(0,e);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\nclass Dice{\npublic:\n  int t,s,e,n,w,b; //Ã¤Â¸Â,Ã¥ÂÂ,Ã¦ÂÂ±,Ã¥ÂÂ,Ã¨Â¥Â¿,Ã¤Â¸Â\n  Dice(){}\n  Dice(int _t,int _s,int _e,int _n,int _w,int _b){\n    t = _t; s = _s; e = _e; n = _n; w = _w; b = _b;\n  }\n  Dice moveEast(){\n    return Dice(w,s,t,n,b,e);\n  }\n  Dice moveNorth(){\n    return Dice(s,b,e,t,w,n);\n  }\n  Dice moveRight(){\n    return Dice(t,e,n,w,s,b);\n  }\n  bool operator==(const Dice &d)const{\n    return t==d.t && s==d.s && e==d.e && n==d.n && w==d.w && b==d.b;\n  }\n\n  void toTable(int *res){\n    res[0] = t;\n    res[1] = s;\n    res[2] = e;\n    res[3] = n;\n    res[4] = w;\n    res[5] = b;\n  }\n\n  void show(){\n    printf(\"[top:%d,south:%d,east:%d,north:%d,west:%d,bottom%d]\\n\",t,s,e,n,w,b);\n  }\n};\n\nvector<Dice> makeDice(Dice d){\n  vector<Dice> res;\n\n  rep(i,6){\n    rep(j,4){\n      res.push_back(d);\n      d = d.moveRight();\n    }\n    if(i < 4) d = d.moveEast();\n    else if(i == 4) d = d.moveNorth();\n    else if(i == 5) d = d.moveNorth().moveNorth();\n  }\n\n  return res;\n}\n\nmap<string,int> name;\nint n;\nvector<Dice> d[4];\n\nint trans(string s){\n  if(name.find(s) == name.end()){\n    int tmp = name.size();\n    name[s] = tmp;\n  }\n  return name[s];\n}\n\nint calc(int *t){\n  int res = 0;\n  int v[n][6];\n  rep(i,n) d[i][t[i]].toTable(v[i]);\n\n  rep(i,6){\n    int maxCnt = 0;\n    int cnt[24];\n    memset(cnt,0,sizeof(cnt));\n    rep(j,n){\n      cnt[v[j][i]]++;\n      if(maxCnt < cnt[v[j][i]]) maxCnt = cnt[v[j][i]];\n    }\n    res += n - maxCnt;\n  }\n\n  return res;\n}\n\nint solve(int idx,int *t){\n  if(idx == n){\n    return calc(t);\n  }\n\n  int res = INT_MAX;\n  rep(i,24){\n    t[idx] = i;\n    res = min(res,solve(idx+1,t));\n  }\n\n  return res;\n}\n\nint main(void){\n  while(cin>>n,n){\n    name.clear();\n\n    rep(i,n){\n      int num[6];\n\n      rep(j,6){\n        string s;\n        cin>>s;\n        num[j] = trans(s);\n      }\n\n      d[i] = makeDice(Dice(num[2],num[0],num[1],num[5],num[4],num[3]));\n    }\n\n    int t[n];\n    cout<<solve(0,t)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n  > File Name: c.cpp\n  > Author: X__X\n  > Mail: Kinderlas@gmail.com \n  > Created Time: 2012/8/12 14:35:54\n ************************************************************************/\n\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<utility>\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define IT iterator\n#define B begin() \n#define E end()\n#define X first\n#define Y second\n#define foreach(it, container) \\\n    for(typeof((container).begin()) it = (container).begin();it!=(container).end();++it)\n#define CLR(a, x) memset(a, x, sizeof (a));\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\nVI::IT it;\nvoid op(int n){cout << n << ' ';}\n\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1e8+10;\nint ELFhash(char *key, long N)\n{\n    unsigned long h = 0;\n    unsigned long x = 0;\n    while(*key)\n    {\n        h = (h << 4) + (*key++);\n        if( (x = h & 0xF0000000L) != 0)\n        {\n            h ^= (x >> 24);\n            h &= ~x;\n        }\n    }\n    return h % N;\n}\n\nint cube[4][10];\nint tcube[4][10];\nint ttcube[4][10];\nint _rotate[6][6] = \n{\n    {1, 2, 3, 4, 5, 6}, {5, 1, 3, 4, 6, 2},\n    {4, 2, 1, 6, 5, 3}, {2, 6, 3, 4, 1, 5},\n    {6, 5, 3, 4, 2, 1}, {3, 2, 6, 1, 5, 4}\n};\nint _Rotate[40][6];\n\n\nchar s[100];\n\nint cnts[10];\nint tt[10][10];\nint n, ans;\nvoid dfs(int k)\n{ \n    if(n == k)\n    {\n        int tans = 0, cnt = 0;\n        for(int i = 1; i <= 6; i++)\n        {\n            for(int j = 0; j < n; j++)\n                tt[i][j] = tcube[j][i];\n        }\n        for(int i = 1; i <= 6; i++)\n        {\n            cnt = 0;\n            for(int j = 0; j < n; j++)\n                cnt = max(cnt, (int)count(tt[i], tt[i]+n, tt[i][j]));\n            tans += cnt;\n        }\n        ans = min(ans, n*6-tans);\n        return ;\n    }\n    for(int i = 0; i < 36; i++)\n    {\n        if(_Rotate[i][0] != -1)\n        {\n            for(int j = 1; j <= 6; j++)\n            {\n                tcube[k][j] = cube[k][_Rotate[i][j-1]];\n                /*for(int ii = 0; ii < 6; ii++)\n                  {\n                  for(int jj = 1; jj <= 6; jj++)\n                  ttcube[k][jj] = tcube[k][_rotate[ii][jj-1]];\n                  dfs(k+1);\n                  }*/\n            }\n            dfs(k+1);\n        }\n    }\n}\n\nvoid solve()\n{\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 1; j <= 6; j++)\n        {\n            scanf(\"%s\", s);\n            cube[i][j] = ELFhash(s, 10000007);\n        }\n    }\n    ans = inf;\n    dfs(0);\n    printf(\"%d\\n\", ans);\n}\n\nbool check(int ii, int jj)\n{\n    for(int i = 0; i < 6; i++)\n        if(_Rotate[ii][i] != _Rotate[jj][i])\n            return false;\n    return true;\n}\n\nint main()\n{\n    for(int i = 0, cnt = 0; i < 6; i++)\n    {\n        for(int j = 0; j < 6; j++)\n        {\n            for(int k = 0; k < 6; k++)\n                _Rotate[cnt][k] = _rotate[i][_rotate[j][k]-1];\n            cnt++;\n        }\n    }\n    for(int i = 0; i < 36; i++)\n        for(int j = 0; j < 36; j++)\n            if(i != j && check(i, j))\n                for(int k = 0; k < 6; k++)\n                    _Rotate[i][k] = -1;\n    while(scanf(\"%d\", &n), n)\n        solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nenum FACE {FRONT, RIGHT, TOP, BOTTOM, LEFT, BACK};\nvoid roll(int v[6], int a, int b, int c, int d){\n  int tmp = v[a];\n  v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = tmp;\n}\nvoid roll_x(int v[6]){\n  roll(v, TOP, BACK, BOTTOM, FRONT);\n}\nvoid roll_y(int v[6]){\n  roll(v, TOP, LEFT, BOTTOM, RIGHT);\n}\nvoid roll_z(int v[6]){\n  roll(v, FRONT, RIGHT, BACK, LEFT);\n}\nint N;\nint dice[4][6];\nstring dice_str[4][6];\nint min_ans;\nvoid dfs(int k){\n  if(k == N){\n    int res = 0;\n    for(int i = 0; i < 6; i++){\n      int cnt[100] = {};\n      int max_c = 0;\n      for(int j = 0; j < N; j++){\n        cnt[dice[j][i]]++;\n        max_c = max(max_c, cnt[dice[j][i]]);\n      }\n      res += N - max_c;\n      if(res >= min_ans) return;\n    }\n    min_ans = res;\n  }else{\n    for(int i = 0; i < 6; (i & 1 ? roll_x(dice[k]) : roll_y(dice[k])), ++i){\n      for(int j = 0; j < 4; roll_z(dice[k]), ++j){\n        dfs(k + 1);\n      }\n    }\n  }\n}\nstruct ID{\n  map<string, int> provider;\n  int get(string s){\n    if(provider.count(s)) return provider[s];\n    int t = provider.size();\n    return provider[s] = t;\n  }\n};\n\nint main(){\n  while(cin >> N && N){\n    REP(i, N) REP(j, 6) cin >> dice_str[i][j];\n    ID id;\n    REP(i, N) REP(j, 6){\n      dice[i][j] = id.get(dice_str[i][j]);\n    }\n    min_ans = INF;\n    dfs(0);\n    cout << min_ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n \nusing namespace std;\n \n// Library - cycoro - begin -7:26\n \nenum FACE {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\n \ntemplate<class T>\nclass dice{\npublic:\n  dice(){\n    //id[FRONT] = 0; id[RIGHT] = 1; id[TOP] = 2;\n    //id[BOTTOM] = 3; id[LEFT] = 4; id[BACK] = 5;\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f){ return var[id[f]]; }\n  const T& operator[] (FACE f)const { return var[id[f]];}\n  bool operator == (const dice<T> &b)const{\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] && \n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n \n  void roll_x() { roll(TOP,BACK,BOTTOM,FRONT); }\n  void roll_y() { roll(TOP,LEFT,BOTTOM,RIGHT); }\n  void roll_z() { roll(FRONT,RIGHT,BACK,LEFT); }\n \n  vector<dice> all_rolls(){\n  vector<dice> ret;\n  for(int k=0;k<6;(k&1?roll_y():roll_x()),++k)\n    for(int i=0;i<4;roll_z(),++i)\n      ret.push_back(*this);\n  return ret;\n  }\n \n  bool equivalent_to(const dice& di){\n    for(int k=0;k<6;(k&1?roll_y():roll_x()),++k)\n      for(int i=0;i<4;roll_z(),++i)\n    if(*this == di)return true;\n    return false;\n  }\n \nprivate:\n  void roll(FACE a,FACE b,FACE c,FACE d){\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n \nFACE face[] = {FRONT,RIGHT,TOP,BOTTOM,LEFT,BACK};\n \n// Library - cycoro - end 07:34\n \nint n,mincost;\nvector<dice<int> > ALL[4];\n\nvoid dfs(int cur,vector<dice<int> >&tmp){\n  if(cur >= n){\n    int cost = 0;\n    //int counter[6];\n    map<int,int> counter;\n    rep(fc,6){\n      counter.clear();\n      //rep(i,6)counter[i] = 0;\n      int mex = 0;\n      rep(i,n){\n    counter[tmp[i][face[fc]]]++;\n    mex = max(mex,counter[tmp[i][face[fc]]]);   \n      }\n      cost += (n - mex);\n      assert(n-mex >= 0);\n    }\n    mincost = min(cost,mincost);\n    return;\n  }\n \n  rep(i,ALL[cur].size()){\n    tmp[cur] = ALL[cur][i];\n    dfs(cur+1,tmp);\n  }\n \n}\n \nint main(){\n \n  while(cin >> n,n){\n    int idx = 0;\n    mincost= IINF;\n    map<string,int> getIndex;\n    vector<dice<int> > dices(n);\n    rep(i,n){\n      rep(j,6){\n    string color;\n    cin >> color;\n    if(getIndex.find(color) == getIndex.end())getIndex[color] = idx++;\n    int index = getIndex[color];\n    dices[i][face[j]] = index; \n      }\n    }\n \n    rep(i,n)ALL[i] = dices[i].all_rolls();\n    vector<dice<int> > tmp(n);\n \n    dfs(0,tmp);\n \n \n    cout << mincost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Dice{\nprivate:\n  int tmp;\npublic:\n  int d[6];\n\n  void rollN(){\n    tmp = d[0];\n    d[0] = d[1];\n    d[1] = d[5];\n    d[5] = d[4];\n    d[4] = tmp;\n  }\n  void rollE(){\n    tmp = d[0];\n    d[0] = d[3];\n    d[3] = d[5];\n    d[5] = d[2];\n    d[2] = tmp;\n  }\n  void rotation(){\n    tmp = d[1];\n    d[1] = d[3];\n    d[3] = d[4];\n    d[4] = d[2];\n    d[2] = tmp;\n  }\n  bool operator < (const Dice &die)const{\n    for(int i = 0 ; i < 6 ; i++){\n      if(d[i] != die.d[i]) return d[i] < die.d[i];\n    }\n    return false;\n  }\n};\n\nint N,ans,p[4];\nmap<string,int> mp;\nvector<Dice> dice[4];\n\nint getCost(){\n  int res = 0;\n  for(int i = 0 ; i < 6 ; i++){\n    int cnt[25] = {0}, max = 0;\n    for(int j = 0 ; j < N ; j++){\n      cnt[dice[j][p[j]].d[i]]++;\n      max = std::max(max,cnt[dice[j][p[j]].d[i]]);\n    }\n    res += N-max;\n  }\n  return res;\n}\n\nvoid solve(int x){\n  if(x == N){\n    ans = min(ans,getCost());\n    return;\n  }\n  for(int i = 0 ; i < (int)dice[x].size() ; i++){\n    p[x] = i;\n    solve(x+1);\n  }\n}\n\nvector<Dice> make(Dice die){\n  vector<Dice> res;\n  set<Dice> visited;\n  for(int i = 0 ; i < 4 ; i++){\n    for(int j = 0 ; j < 4 ; j++){\n      if(!visited.count(die)){\n        visited.insert(die);\n        res.push_back(die);\n      }\n      die.rollN();\n    }\n    for(int j = 0 ; j < 4 ; j++){\n      if(!visited.count(die)){\n        visited.insert(die);\n        res.push_back(die);\n      }\n      die.rollE();\n    }\n    die.rotation();\n  }\n  return res;\n}\n\nint main(){\n  Dice in;\n  while(cin >> N, N){\n    int n = 0;\n    mp.clear();\n    for(int i = 0 ; i < N ; i++){\n      p[i] = -1;\n      for(int j = 0 ; j < 6 ; j++){\n        string s;\n        cin >> s;\n        if(mp.find(s) != mp.end()){\n          in.d[j] = mp[s];\n        }else{\n          mp[s] = n++;\n          in.d[j] = mp[s];\n        }\n      }\n      dice[i] = make(in);\n    }\n    ans = 1e9;\n    solve(0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n\nstruct Info{\n\tchar buf[25];\n\tint count;\n};\n\nclass Dice{\npublic:\n\n\tvoid setPos(int num){\n\n\t\tfor(int i = 0; i < 6; i++)work[i] = index[i];\n\n\t\tswitch(num){\n\t\tcase 0:\n\t\t\tsetindex(work[4],work[0],work[2],work[3],work[5],work[1]);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tsetindex(work[5],work[4],work[2],work[3],work[1],work[0]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsetindex(work[1],work[5],work[2],work[3],work[0],work[4]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsetindex(work[0],work[1],work[2],work[3],work[4],work[5]);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tsetindex(work[2],work[1],work[5],work[0],work[4],work[3]);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tsetindex(work[4],work[2],work[5],work[0],work[3],work[1]);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tsetindex(work[3],work[4],work[5],work[0],work[1],work[2]);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tsetindex(work[1],work[3],work[5],work[0],work[2],work[4]);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tsetindex(work[5],work[3],work[4],work[1],work[2],work[0]);\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tsetindex(work[2],work[5],work[4],work[1],work[0],work[3]);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tsetindex(work[0],work[2],work[4],work[1],work[3],work[5]);\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tsetindex(work[3],work[0],work[4],work[1],work[5],work[2]);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tsetindex(work[1],work[0],work[3],work[2],work[5],work[4]);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tsetindex(work[5],work[1],work[3],work[2],work[4],work[0]);\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tsetindex(work[4],work[5],work[3],work[2],work[0],work[1]);\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tsetindex(work[0],work[4],work[3],work[2],work[1],work[5]);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tsetindex(work[2],work[4],work[0],work[5],work[1],work[3]);\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\tsetindex(work[1],work[2],work[0],work[5],work[3],work[4]);\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tsetindex(work[3],work[1],work[0],work[5],work[4],work[2]);\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\tsetindex(work[4],work[3],work[0],work[5],work[2],work[1]);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tsetindex(work[0],work[3],work[1],work[4],work[2],work[5]);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tsetindex(work[2],work[0],work[1],work[4],work[5],work[3]);\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tsetindex(work[5],work[2],work[1],work[4],work[3],work[0]);\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tsetindex(work[3],work[5],work[1],work[4],work[0],work[2]);\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t//Do nothing\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvoid setindex(int w0,int w1,int w2,int w3,int w4,int w5){\n\t\tindex[0] = w0;\n\t\tindex[1] = w1;\n\t\tindex[2] = w2;\n\t\tindex[3] = w3;\n\t\tindex[4] = w4;\n\t\tindex[5] = w5;\n\t}\n\n\tvoid init(){\n\t\tindex[0] = 2;\n\t\tindex[1] = 5;\n\t\tindex[2] = 1;\n\t\tindex[3] = 4;\n\t\tindex[4] = 0;\n\t\tindex[5] = 3;\n\t}\n\n\tint index[6];\n\tint work[6];\n};\n\nint N,info_index;\nDice dice[4];\nchar color[4][6][25];\nInfo info[24];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\n\nvoid func(){\n\n\tinfo_index = 0;\n\tbool FLG;\n\n\tfor(int i = 0; i < N; i++){\n\t\tdice[i].init();\n\t\tfor(int k = 0; k < 6; k++){\n\t\t\tscanf(\"%s\",color[i][k]);\n\n\t\t\tFLG = false;\n\t\t\tfor(int a = 0;a < info_index; a++){\n\t\t\t\tif(strCmp(info[a].buf,color[i][k])){\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG){\n\t\t\t\tstrcpy(info[info_index].buf,color[i][k]);\n\t\t\t\tinfo_index++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(N == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tint minimum,tmp,tmp_sum,maximum;\n\n\tif(N == 2){\n\n\t\tminimum = BIG_NUM;\n\n\t\tfor(int i = 0; i <= 24; i++){\n\t\t\tdice[1].init();\n\t\t\tdice[1].setPos(i);\n\n\t\t\ttmp = 0;\n\n\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\tif(strCmp(color[0][dice[0].index[k]],color[1][dice[1].index[k]]) == false){\n\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tminimum = min(minimum,tmp);\n\t\t}\n\n\t\tprintf(\"%d\\n\",minimum);\n\n\t}else if(N == 3){\n\n\t\tminimum = BIG_NUM;\n\n\t\tfor(int a = 0; a <= 24; a++){\n\t\t\tdice[1].init();\n\t\t\tdice[1].setPos(a);\n\t\t\tfor(int b = 0; b <= 24; b++){\n\t\t\t\tdice[2].init();\n\t\t\t\tdice[2].setPos(b);\n\n\t\t\t\ttmp_sum = 0;\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tfor(int k = 0; k < info_index; k++)info[k].count = 0;\n\n\t\t\t\t\tfor(int p = 0; p < 3; p++){\n\t\t\t\t\t\tfor(int k = 0; k < info_index; k++){\n\t\t\t\t\t\t\tif(strCmp(info[k].buf,color[p][dice[p].index[i]])){\n\t\t\t\t\t\t\t\tinfo[k].count++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmaximum = 1;\n\t\t\t\t\tfor(int k = 0; k < info_index; k++)maximum = max(maximum,info[k].count);\n\n\t\t\t\t\ttmp_sum += N-maximum;\n\t\t\t\t}\n\t\t\t\tminimum = min(minimum,tmp_sum);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",minimum);\n\n\t}else{ //N == 4\n\n\t\tminimum = BIG_NUM;\n\n\t\tfor(int a = 0; a <= 24; a++){\n\t\t\tdice[1].init();\n\t\t\tdice[1].setPos(a);\n\t\t\tfor(int b = 0; b <= 24; b++){\n\t\t\t\tdice[2].init();\n\t\t\t\tdice[2].setPos(b);\n\n\t\t\t\tfor(int c = 0; c <= 24; c++){\n\t\t\t\t\tdice[3].init();\n\t\t\t\t\tdice[3].setPos(c);\n\n\t\t\t\t\ttmp_sum = 0;\n\t\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\t\tfor(int k = 0; k < info_index; k++)info[k].count = 0;\n\n\t\t\t\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\t\t\t\tfor(int k = 0; k < info_index; k++){\n\t\t\t\t\t\t\t\tif(strCmp(info[k].buf,color[p][dice[p].index[i]])){\n\t\t\t\t\t\t\t\t\tinfo[k].count++;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaximum = 1;\n\t\t\t\t\t\tfor(int k = 0; k < info_index; k++)maximum = max(maximum,info[k].count);\n\n\t\t\t\t\t\ttmp_sum += N-maximum;\n\t\t\t\t\t}\n\t\t\t\t\tminimum = min(minimum,tmp_sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1259: Colored Cubes\n// 2017.10.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define HASHSIZ 101\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\t\t\t// Hash table\nchar color[25][25]; int sz;\nchar dice[4][7], dice2[4][7]; int n;\nint ans;\n\nint lookup(char *s, int id)\n{\n\tint w = strlen(s);\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nchar rot[24][7] = {\n\t{ 0,1,2,3,4,5,6 },{ 0,1,3,5,2,4,6 },{ 0,1,4,2,5,3,6 },{ 0,1,5,4,3,2,6 },\n\t{ 0,2,6,3,4,1,5 },{ 0,2,3,1,6,4,5 },{ 0,2,1,4,3,6,5 },{ 0,2,4,6,1,3,5 },\n\t{ 0,3,1,2,5,6,4 },{ 0,3,2,6,1,5,4 },{ 0,3,5,1,6,2,4 },{ 0,3,6,5,2,1,4 },\n\t{ 0,4,1,5,2,6,3 },{ 0,4,2,1,6,5,3 },{ 0,4,5,6,1,2,3 },{ 0,4,6,2,5,1,3 },\n\t{ 0,5,1,3,4,6,2 },{ 0,5,3,6,1,4,2 },{ 0,5,4,1,6,3,2 },{ 0,5,6,4,3,1,2 },\n\t{ 0,6,2,4,3,5,1 },{ 0,6,3,2,5,4,1 },{ 0,6,5,3,4,2,1 },{ 0,6,4,5,2,3,1 } };\n\nint combi(int m)\n{\n\tint i, j, k, l, min;\n\tchar tmp[7];\n\tchar f[4];\n\n\tif (m == n) {\n\t\tfor (min = 0, k = 1; k <= 6; k++) {\n\t\t\tf[0] = dice2[0][k], l = 1;\n\t\t\tfor (i = 1; i < n; i++) {\n\t\t\t\tfor (j = 0; j < l && dice2[i][k] != f[j]; j++);\n\t\t\t\tif (j == l) f[l++] = dice2[i][k];\n\t\t\t}\n\t\t\tmin += l-1;\n\t\t}\n\t\tif (min < ans) {\n\t\t\tans = min;\n\t\t\tif (ans == 0) return 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tmemcpy(dice2[m], dice[m], 7);\n\tif (combi(m+1)) return 1;\n\tfor (i = 1; i < 24; i++) {\n\t\tfor (k = 1; k <= 6; k++) tmp[k] = dice[m][rot[i][k]];\n\t\tif (memcmp(tmp+1, dice2[m]+1, 6) == 0) continue;\n\t\tmemcpy(dice2[m], tmp, 7);\n\t\tif (combi(m+1)) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tif (n == 1) {\n\t\t\tfor (j = 0; j < 6; j++) scanf(\"%s\", color[0]);\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tmemset(hash, 0, sizeof(hash)); sz = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 6; j++) {\n\t\t\t\tscanf(\"%s\", color[sz]);\n\t\t\t\tif ((k = lookup(color[sz], sz)) < 0) k = sz++;\n\t\t\t\tdice[i][j+1] = k;\n\t\t\t}\n\t\t}\n\n\t\tans = 128;\n\t\tmemcpy(dice2[0], dice[0], 7);\n\t\tcombi(1);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1259: Colored Cubes\n// 2017.10.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define HASHSIZ 101\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\t\t\t// Hash table\nchar color[25][25]; int sz;\nchar dice[4][7], dice2[4][7]; int n;\nint ans;\n\nint lookup(char *s, int id)\n{\n\tint w = strlen(s);\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nchar rot[24][7] = {\n\t{ 0,1,2,3,4,5,6 },{ 0,1,3,5,2,4,6 },{ 0,1,4,2,5,3,6 },{ 0,1,5,4,3,2,6 },\n\t{ 0,2,6,3,4,1,5 },{ 0,2,3,1,6,4,5 },{ 0,2,1,4,3,6,5 },{ 0,2,4,6,1,3,5 },\n\t{ 0,3,1,2,5,6,4 },{ 0,3,2,6,1,5,4 },{ 0,3,5,1,6,2,4 },{ 0,3,6,5,2,1,4 },\n\t{ 0,4,1,5,2,6,3 },{ 0,4,2,1,6,5,3 },{ 0,4,5,6,1,2,3 },{ 0,4,6,2,5,1,3 },\n\t{ 0,5,1,3,4,6,2 },{ 0,5,3,6,1,4,2 },{ 0,5,4,1,6,3,2 },{ 0,5,6,4,3,1,2 },\n\t{ 0,6,2,4,3,5,1 },{ 0,6,3,2,5,4,1 },{ 0,6,5,3,4,2,1 },{ 0,6,4,5,2,3,1 } };\n\nint combi(int m)\n{\n\tint i, j, k, l, min, max;\n\tchar tmp[7];\n\tchar f[4], c[4];\n\n\tif (m == n) {\n\t\tfor (min = 0, k = 1; k <= 6; k++) {\n\t\t\tc[0] = dice2[0][k], f[0] = 1, l = 1, max = 1;\n\t\t\tfor (i = 1; i < n; i++) {\n\t\t\t\tfor (j = 0; j < l && dice2[i][k] != c[j]; j++);\n\t\t\t\tif (j < l) { if (++f[j] > max) max++; }\n\t\t\t\telse c[l] = dice2[i][k], f[l++] = 1;\n\t\t\t}\n\t\t\tmin += n-max;\n\t\t}\n\t\tif (min < ans) {\n\t\t\tans = min;\n\t\t\tif (ans == 0) return 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tmemcpy(dice2[m], dice[m], 7);\n\tif (combi(m+1)) return 1;\n\tfor (i = 1; i < 24; i++) {\n\t\tfor (k = 1; k <= 6; k++) tmp[k] = dice[m][rot[i][k]];\n\t\tif (memcmp(tmp+1, dice2[m]+1, 6) == 0) continue;\n\t\tmemcpy(dice2[m], tmp, 7);\n\t\tif (combi(m+1)) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tif (n == 1) {\n\t\t\tfor (j = 0; j < 6; j++) scanf(\"%s\", color[0]);\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tmemset(hash, 0, sizeof(hash)); sz = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 6; j++) {\n\t\t\t\tscanf(\"%s\", color[sz]);\n\t\t\t\tif ((k = lookup(color[sz], sz)) < 0) k = sz++;\n\t\t\t\tdice[i][j+1] = k;\n\t\t\t}\n\t\t}\n\n\t\tans = 128;\n\t\tmemcpy(dice2[0], dice[0], 7);\n\t\tcombi(1);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#define fors(i, n) for (int i = 0; i < n; i++)\n\nchar maps[4][6][50];\nint cases[24][6] = {{1, 2, 0, 5, 3, 4}, {1, 5, 2, 3, 0, 4}, {1, 3, 5, 0, 2, 4}, {1, 0, 3, 2, 5, 4}, {2, 1, 5, 0, 4, 3}, {2, 0, 1, 4, 5, 3}, {2, 4, 0, 5, 1, 3}, {2, 5, 4, 1, 0, 3}, {3, 4, 5, 0, 1, 2}, {3, 5, 1, 4, 0, 2}, {3, 1, 0, 5, 4, 2}, {3, 0, 4, 1, 5, 2}, {4, 0, 2, 3, 5, 1}, {4, 2, 5, 0, 3, 1}, {4, 5, 3, 2, 0, 1}, {4, 3, 0, 5, 2, 1}, {5, 2, 1, 4, 3, 0}, {5, 4, 2, 3, 1, 0}, {5, 1, 3, 2, 4, 0}, {5, 3, 4, 1, 2, 0}, {0, 2, 4, 1, 3, 5}, {0, 1, 2, 3, 4, 5}, {0, 3, 1, 4, 2, 5}, {0, 4, 3, 2, 1, 5}};\n\nint min = 100000, n, data[4];\n\nint color(char ch[5][50]) // input is rotated dices same face\n{\n\tint counts[5] = {0};\n\tfors(i, n)\n\t{\n\t\tfors(j, n)\n\t\t{\n\t\t\tif (!strcmp(ch[i], ch[j])) // same color\n\t\t\t\tcounts[i]++;\n\t\t}\n\t}\n\tint max = 0;\n\tfors(c, n)\n\t{\n\t\tif (counts[c] > counts[max]) // best color\n\t\t\tmax = c;\n\t}\n\tint flag = 0;\n\tfors(i, n) if (strcmp(ch[i], ch[max])) // diff color count\n\t\tflag++;\n\treturn flag;// return repaint count\n}\n\nvoid min_repaint()\n{\n\tint sum = 0;\n\tfors(i, 6)\n\t{\n\t\tchar temp[5][50]; //dices's same face\n\t\tfors(j, n)\n\t\t{\n\t\t\tstrcpy(temp[j], maps[j][cases[data[j]][i]]); //set surface name, rotate by data\n\t\t}\n\t\tsum += color(temp);\n\t}\n\tif (sum < min)\n\t\tmin = sum;\n}\n\nvoid set_data_dfs(int depth)\n{\n\tif (depth == n - 1)\n\t\tmin_repaint();\n\telse\n\t\tfors(i, 24)\n\t\t{\n\t\t\tdata[depth] = i;\n\t\t\tset_data_dfs(depth + 1);\n\t\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &n) && n != 0)\n\t{\n\t\tfors(i, n) fors(j, 6)\n\t\t\tscanf(\"%s\", maps[i][j]);\n\t\tmin = 1000000;\n\t\tset_data_dfs(0);\n\t\tprintf(\"%d\\n\", min);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\nusing namespace std;\n#define INF 1000000000\nconst int mov[24][6]={\n  {0,1,2,3,4,5},{0,2,4,1,3,5},{0,4,3,2,1,5},{0,3,1,4,2,5},\n  {3,1,0,5,4,2},{3,0,4,1,5,2},{3,4,5,0,1,2},{3,5,1,4,0,2},\n  {5,1,3,2,4,0},{5,3,4,1,2,0},{5,4,2,3,1,0},{5,2,1,4,3,0},\n  {2,1,5,0,4,3},{2,5,4,1,0,3},{2,4,0,5,1,3},{2,0,1,4,5,3},\n  {4,0,2,3,5,1},{4,2,5,0,3,1},{4,5,3,2,0,1},{4,3,0,5,2,1},\n  {1,0,3,2,5,4},{1,3,5,0,2,4},{1,5,2,3,0,4},{1,2,0,5,3,4}\n};\nint n,res;\nstruct CUBE{\n  int num[6];\n}cube[4],buf[4];\nmap<string,int> idx;\nint top;\nvoid dfs(int dep){\n  int i,j;\n  if(dep==n){\n    int tmp=0;\n    for(i=0;i<6;i++){\n      int cnt[24]={0};\n      for(j=0;j<n;j++) cnt[buf[j].num[i]]++;\n      int mx=0;\n      for(j=0;j<top;j++) mx=max(mx,cnt[j]);\n      tmp+=(n-mx);\n    }\n    res=min(res,tmp);\n    return;\n  }\n  for(i=0;i<24;i++){\n    for(j=0;j<6;j++)\n      buf[dep].num[j]=cube[dep].num[mov[i][j]];\n    dfs(dep+1);\n  }\n}\nint main(){\n  int i,j;\n  while(scanf(\"%d\",&n),n){\n    idx.clear(); top=0;\n    for(i=0;i<n;i++)\n      for(j=0;j<6;j++){\n        string str;\n        cin>>str;\n        if(idx.find(str)==idx.end())\n          idx[str]=top++;\n        cube[i].num[j]=idx[str];\n      }\n    if(n==1){\n      printf(\"0\\n\");\n      continue;\n    }\n    res=INF;\n    buf[0]=cube[0];\n    dfs(1);\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n//\tint[][] map = { { 0, 1, 2, 4, 3, 5 }, { 0, 2, 4, 3, 1, 5 },\n//\t\t\t{ 0, 4, 3, 1, 2, 5 }, { 0, 3, 1, 2, 4, 5 },\n//\n//\t\t\t{ 1, 2, 0, 3, 5, 4 }, { 1, 5, 2, 0, 3, 4 }, { 1, 3, 5, 2, 0, 4 },\n//\t\t\t{ 1, 5, 2, 0, 3, 4 },\n//\n//\t\t\t{ 2, 0, 1, 5, 4, 3 }, { 2, 1, 5, 4, 0, 3 }, { 2, 5, 4, 0, 1, 3 },\n//\t\t\t{ 2, 4, 0, 1, 5, 3 },\n//\n//\t\t\t{}, {}, {}, {},\n//\n//\t\t\t{}, {}, {}, {},\n//\n//\t\t\t{}, {}, {}, {} };\n\n\tint[][] map = { { 0, 1, 2, 3, 4, 5 }, { 0, 2, 4, 1, 3, 5 },\n\t\t\t{ 0, 4, 3, 2, 1, 5 }, { 0, 3, 1, 4, 2, 5 }, { 3, 1, 0, 5, 4, 2 },\n\t\t\t{ 3, 0, 4, 1, 5, 2 }, { 3, 4, 5, 0, 1, 2 }, { 3, 5, 1, 4, 0, 2 },\n\t\t\t{ 5, 1, 3, 2, 4, 0 }, { 5, 3, 4, 1, 2, 0 }, { 5, 4, 2, 3, 1, 0 },\n\t\t\t{ 5, 2, 1, 4, 3, 0 }, { 2, 1, 5, 0, 4, 3 }, { 2, 5, 4, 1, 0, 3 },\n\t\t\t{ 2, 4, 0, 5, 1, 3 }, { 2, 0, 1, 4, 5, 3 }, { 4, 0, 2, 3, 5, 1 },\n\t\t\t{ 4, 2, 5, 0, 3, 1 }, { 4, 5, 3, 2, 0, 1 }, { 4, 3, 0, 5, 2, 1 },\n\t\t\t{ 1, 0, 3, 2, 5, 4 }, { 1, 3, 5, 0, 2, 4 }, { 1, 5, 2, 3, 0, 4 },\n\t\t\t{ 1, 2, 0, 5, 3, 4 } };\n\n\tint[] rev(int[] a) {\n\t\tint[] ret = new int[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid run() {\n\t\t{\n\t\t\tint n = 12;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t// map[i + n] = rev(map[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 24; i++) {\n\t\t\t// System.out.println(Arrays.toString(map[i]));\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tsc.next();\n\t\t\t\t}\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\n\t\t\tint dice[][] = new int[n][6];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tString buffer = sc.next();\n\t\t\t\t\tint v = 0;\n\t\t\t\t\tif (!hm.containsKey(buffer)) {\n\t\t\t\t\t\tv = hm.size();\n\t\t\t\t\t\thm.put(buffer, hm.size());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv = hm.get(buffer);\n\t\t\t\t\t}\n\t\t\t\t\tdice[i][j] = v;\n\t\t\t\t}\n\t\t\t\t// System.out.println(Arrays.toString(dice[i]));\n\t\t\t}\n\n\t\t\tint dice2[][] = new int[n][6];\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tdice2[0][i] = dice[0][map[0][i]];\n\t\t\t}\n\n\t\t\tlong patmax = 1;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tpatmax *= 24;\n\t\t\t}\n\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (long pat = 0; pat < patmax; pat++) {\n\t\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\t\tint p = exe(j, pat, n);\n\t\t\t\t\t// System.out.print(p+\" \");\n\t\t\t\t\tint[] m = map[p];\n\t\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\t\tdice2[j][k] = dice[j][m[k]];\n\t\t\t\t\t}\n\t\t\t\t\t// System.out.println(Arrays.toString(dice2[j]));\n\t\t\t\t}\n\t\t\t\t// System.out.println();\n\n\t\t\t\tmin = check(dice2, min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tint check(int[][] dice, int min) {\n\t\tint value = 0;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tint hind[] = new int[24];\n\t\t\tfor (int i = 0; i < dice.length; i++) {\n\t\t\t\thind[dice[i][j]]++;\n\t\t\t}\n\t\t\tint maxHind = 0;\n\t\t\tfor (int i = 0; i < 24; i++) {\n\t\t\t\tmaxHind = Math.max(maxHind, hind[i]);\n\t\t\t}\n\t\t\tvalue += dice.length - maxHind;\n\t\t\tif (min <= value)\n\t\t\t\treturn min;\n\t\t}\n\t\t// System.out.println(value);\n\t\tfor (int i = 0; i < dice.length; i++) {\n\t\t\t// System.out.println(Arrays.toString(dice[i]));\n\t\t}\n\t\treturn Math.min(value, min);\n\t}\n\n\tint exe(int j, long pat, int n) {\n\t\tfor (int i = 1; i < j; i++) {\n\t\t\tpat /= 24;\n\t\t}\n\t\treturn (int) (pat % 24);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Colored Cubes\npublic class Main{\n\n\tpublic static class Dice <T>{\n\t\tpublic T[] id;\n\t\t\tenum Face{TOP, BOTTOM, FRONT, BACK, RIGHT, LEFT};\n\t\t\tpublic T get(int k){\n\t\t\t\treturn id[k];\n\t\t\t}\n\t\t\tpublic Dice<T> copy(){\n\t\t\t\treturn new Dice<T>(id[0], id[1], id[2], id[3], id[4], id[5]);\n\t\t\t}\n\t\t\tpublic Dice() {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] tid = (T[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t}\n\t\t\tpublic Dice(T top, T bottom, T front, T back, T right, T left) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] tid = (T[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t\tid[Face.TOP.ordinal()] = top;\n\t\t\t\tid[Face.BOTTOM.ordinal()]= bottom;\n\t\t\t\tid[Face.FRONT.ordinal()] = front;\n\t\t\t\tid[Face.BACK.ordinal()] = back;\n\t\t\t\tid[Face.RIGHT.ordinal()] = right;\n\t\t\t\tid[Face.LEFT.ordinal()] = left;\n\t\t\t}\n\t\t\tvoid rollX(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.FRONT, Face.BOTTOM, Face.BACK);\n\t\t\t\telse roll(Face.TOP, Face.BACK, Face.BOTTOM, Face.FRONT);\n\t\t\t}\n\t\t\tvoid rollY(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.LEFT, Face.BOTTOM, Face.RIGHT);\n\t\t\t\telse roll(Face.TOP, Face.RIGHT, Face.BOTTOM, Face.LEFT);\n\t\t\t}\n\t\t\tvoid rollZ(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.FRONT, Face.LEFT, Face.BACK, Face.RIGHT);\n\t\t\t\telse roll(Face.FRONT, Face.RIGHT, Face.BACK, Face.LEFT);\n\t\t\t}\n\t\t\tprivate void roll(Face w, Face x, Face y, Face z) {\n\t\t\t\tT tmp = id[w.ordinal()];\n\t\t\t\tid[w.ordinal()] = id[x.ordinal()];\n\t\t\t\tid[x.ordinal()] = id[y.ordinal()];\n\t\t\t\tid[y.ordinal()] = id[z.ordinal()];\n\t\t\t\tid[z.ordinal()] = tmp;\n\t\t\t}\n\t\t\tList<Dice<T>> getAllState(){\n\t\t\t\tList<Dice<T>> lst = new ArrayList<Dice<T>>();\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tlst.add(new Dice<T>(id[Face.TOP.ordinal()], id[Face.BOTTOM.ordinal()], id[Face.FRONT.ordinal()], id[Face.BACK.ordinal()], id[Face.RIGHT.ordinal()], id[Face.LEFT.ordinal()]));\n\t\t\t\t\t\trollZ(false);\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2 == 1) rollY(false);\n\t\t\t\t\telse rollX(false);\n\t\t\t\t}\n\t\t\t\treturn lst;\n\t\t\t}\n\t}\n\t\n\tMap<String, Integer> ref;\n\tint ID;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\t\n\tDice<Integer>[][] d;\n\tint[] s;\n\tint res, n;\n\t\n\tvoid dfs(int k){\n\t\tif(k==n){\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint max = 0;\n\t\t\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint x = d[j][s[j]].get(i);\n\t\t\t\t\tif(map.containsKey(x)){\n\t\t\t\t\t\tmax = Math.max(max, map.get(x)+1);\n\t\t\t\t\t\tmap.put(x, map.get(x)+1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap.put(x, 1);\n\t\t\t\t\t\tmax = Math.max(max, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc+=n-max;\n\t\t\t}\n\t\t\tres = Math.min(res, c);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<24;i++){\n\t\t\ts[k] = i;\n\t\t\tdfs(k+1);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\ts = new int[4];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\td = new Dice[n][24];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint[] c = new int[6];\n\t\t\t\tfor(int j=0;j<6;j++)c[j]=reg(sc.next());\n\t\t\t\tDice<Integer> D = new Dice<Integer>(c[2], c[3], c[0], c[5], c[1], c[4]);\n\t\t\t\tList<Dice<Integer>> l = D.getAllState();\n\t\t\t\tfor(int j=0;j<24;j++)d[i][j] = l.get(j);\n\t\t\t}\n\t\t\tres = 24;\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint[][] map = { { 0, 1, 2, 4, 3, 5 }, { 0, 2, 4, 3, 1, 5 },\n\t\t\t{ 0, 4, 3, 1, 2, 5 }, { 0, 3, 1, 2, 4, 5 },\n\n\t\t\t{ 1, 2, 0, 3, 5, 4 }, { 1, 5, 2, 0, 3, 4 }, { 1, 3, 5, 2, 0, 4 },\n\t\t\t{ 1, 5, 2, 0, 3, 4 },\n\n\t\t\t{ 2, 0, 1, 5, 4, 3 }, { 2, 1, 5, 4, 0, 3 }, { 2, 5, 4, 0, 1, 3 },\n\t\t\t{ 2, 4, 0, 1, 5, 3 },\n\n\t\t\t{}, {}, {}, {},\n\n\t\t\t{}, {}, {}, {},\n\n\t\t\t{}, {}, {}, {} };\n\n\tint[] rev(int[] a) {\n\t\tint[] ret = new int[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid run() {\n\t\t{\n\t\t\tint n = 12;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i + n] = rev(map[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 24; i++) {\n\t\t\t// System.out.println(Arrays.toString(map[i]));\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tsc.next();\n\t\t\t\t}\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\n\t\t\tint dice[][] = new int[n][6];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tString buffer = sc.next();\n\t\t\t\t\tint v = 0;\n\t\t\t\t\tif (!hm.containsKey(buffer)) {\n\t\t\t\t\t\tv = hm.size();\n\t\t\t\t\t\thm.put(buffer, hm.size());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv = hm.get(buffer);\n\t\t\t\t\t}\n\t\t\t\t\tdice[i][j] = v;\n\t\t\t\t}\n\t\t\t\t// System.out.println(Arrays.toString(dice[i]));\n\t\t\t}\n\n\t\t\tint dice2[][] = new int[n][6];\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tdice2[0][i] = dice[0][map[0][i]];\n\t\t\t}\n\n\t\t\tlong patmax = 1;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tpatmax *= 24;\n\t\t\t}\n\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (long pat = 0; pat < patmax; pat++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tint p = exe(j, pat);\n//\t\t\t\t\t System.out.print(p+\" \");\n\t\t\t\t\tint[] m = map[p];\n\t\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\t\tdice2[j][k] = dice[j][m[k]];\n\t\t\t\t\t}\n\t\t\t\t\t// System.out.println(Arrays.toString(dice2[j]));\n\t\t\t\t}\n//\t\t\t\t System.out.println();\n\n\t\t\t\tmin = check(dice2, min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tint check(int[][] dice, int min) {\n\t\tint value = 0;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tint hind[] = new int[24];\n\t\t\tfor (int i = 0; i < dice.length; i++) {\n\t\t\t\thind[dice[i][j]]++;\n\t\t\t}\n\t\t\tint maxHind = 0;\n\t\t\tfor (int i = 0; i < 24; i++) {\n\t\t\t\tmaxHind = Math.max(maxHind, hind[i]);\n\t\t\t}\n\t\t\tvalue += dice.length - maxHind;\n\t\t\tif (min <= value)\n\t\t\t\treturn min;\n\t\t}\n//\t\tSystem.out.println(value);\n\t\tfor (int i = 0; i < dice.length; i++) {\n//\t\t\tSystem.out.println(Arrays.toString(dice[i]));\n\t\t}\n\t\treturn Math.min(value, min);\n\t}\n\n\tint exe(int j, long pat) {\n\t\tfor (int i = 0; i < j; i++) {\n\t\t\tpat /= 24;\n\t\t}\n\t\treturn (int) (pat % 24);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tString [] order = {\"\",\"n\",\"s\", \"e\", \"w\", \"nn\"};\n\tString [] orderrev = {\"\",\"s\",\"n\", \"w\", \"e\", \"nn\"};\n\tint n, ans;\n\tDice [] d;\n\t\n\tclass Dice{\n\t\t//dice is, 0 = south, 1 = east, 2 = top, 3 = bottom, 4 = west, 5 = north;\n\t\tint [] dice;\n\n\t\tpublic Dice(int[] dice) {\n\t\t\tthis.dice = dice;\n\t\t}\n\t\t\n\t\tprivate void slide() {\n\t\t\tswap(0,4,5,1);\n\t\t}\n\t\t\n\t\tprivate void turn(char c) {\n\t\t\tswitch(c){\n\t\t\tcase 'n':\n\t\t\t\tswap(2,5,3,0); break;\n\t\t\tcase 's':\n\t\t\t\tswap(2,0,3,5); break;\n\t\t\tcase 'w':\n\t\t\t\tswap(2,4,3,1); break;\n\t\t\tcase 'e':\n\t\t\t\tswap(2,1,3,4); break;\n\t\t\t}\n\t\t}\n\n\t\tprivate void swap(int i, int j, int k, int l) {\n\t\t\tint temp = dice[l];\n\t\t\tdice[l] = dice[k];\n\t\t\tdice[k] = dice[j];\n\t\t\tdice[j] = dice[i];\n\t\t\tdice[i] = temp;\n\t\t}\n\t\t\n\t}\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> tonum = new HashMap<String, Integer>();\n\t\t\td = new Dice[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint [] input = new int[6];\n\t\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\t\tString s = sc.next();\n\t\t\t\t\tint ind = -1;\n\t\t\t\t\tif(tonum.containsKey(s)){\n\t\t\t\t\t\tind = tonum.get(s);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tind = tonum.size() + 1;\n\t\t\t\t\t\ttonum.put(s, ind);\n\t\t\t\t\t}\n\t\t\t\t\tinput[j] = ind;\n\t\t\t\t}\n\t\t\t\td[i] = new Dice(input);\n\t\t\t}\n\t\t\tans = 1 << 24;\n\t\t\tif(n == 1){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate void dfs(int deep){\n\t\tif(deep == n-1){\n\t\t\t//判定\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\tHashMap<Integer,Integer> s = new HashMap<Integer, Integer>();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < d.length; j++){\n\t\t\t\t\tif(s.containsKey(d[j].dice[i])){\n\t\t\t\t\t\ts.put(d[j].dice[i], s.get(d[j].dice[i]) + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ts.put(d[j].dice[i] , 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(n == 4 && s.size() == 2){\n\t\t\t\t\tfor(int key: s.keySet()){\n\t\t\t\t\t\tif(s.get(key) == 2){\n\t\t\t\t\t\t\tsum += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tsum += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.min(sum, ans);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < order.length; i++){\n\t\t\tfor(int j = 0; j < order[i].length(); j++){\n\t\t\t\td[deep + 1].turn(order[i].charAt(j));\n\t\t\t}\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\td[deep + 1].slide();\n\t\t\t\tdfs(deep + 1);\n\t\t\t}\n\t\t\tfor(int j = 0; j < orderrev[i].length(); j++){\n\t\t\t\td[deep + 1].turn(orderrev[i].charAt(j));\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0418 start\n\t//0503 cording end\n\t//0515 find a fatal error and sleep\n\t//1210 restart\n\t//1300 sample match\n\t\n\t//dice is, 0 = south, 1 = east, 2 = top, 3 = bottom, 4 = west, 5 = north;\n\tString [] order = {\"\",\"n\",\"s\", \"e\", \"w\", \"nn\"};\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> tonum = new HashMap<String, Integer>();\n\t\t\tint [][] dice = new int[n][6];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\t\tString s = sc.next();\n\t\t\t\t\tint ind = -1;\n\t\t\t\t\tif(tonum.containsKey(s)){\n\t\t\t\t\t\tind = tonum.get(s);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tind = tonum.size();\n\t\t\t\t\t\ttonum.put(s, ind);\n\t\t\t\t\t}\n\t\t\t\t\tdice[i][j] = ind;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 1){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse if(n == 2){\n\t\t\t\tSystem.out.println(solve(dice));\n\t\t\t}\n\t\t\telse if(n == 3){\n\t\t\t\tint res = solve3(dice);\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint res = solve4(dice);\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int solve4(int[][] dice) {\n\t\tint [][] work =new int[4][6];\n\t\tint res = 1 << 24;\n\t\twork[0] = Arrays.copyOf(dice[0], dice[0].length);\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\twork[1] = Arrays.copyOf(dice[1], dice[1].length);\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\tturn(work[1], order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\tslide(work[1]);\n\t\t\t\t\n\t\t\t\t//2個目\n\t\t\t\tfor(int j2 = 0; j2 < order.length; j2++){\n\t\t\t\t\twork[2] = Arrays.copyOf(dice[2], dice[2].length);\n\t\t\t\t\tfor(int i2 = 0; i2 < order[j2].length(); i2++){\n\t\t\t\t\t\tturn(work[2], order[j2].charAt(i2));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i2 = 0; i2 < 4; i2++){\n\t\t\t\t\t\tslide(work[2]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j3 = 0; j3 < order.length; j3++){\n\t\t\t\t\t\t\twork[3] = Arrays.copyOf(dice[3], dice[3].length);\n\t\t\t\t\t\t\tfor(int i3 = 0; i3 < order[j3].length(); i3++){\n\t\t\t\t\t\t\t\tturn(work[3],order[j3].charAt(i3));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int i3 = 0; i3 < 4; i3++){\n\t\t\t\t\t\t\t\tslide(work[3]);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//ある面に対して、その面の種類が同じであればok\n\t\t\t\t\t\t\t\t//setを使って、size - 1の値を足していく\n\t\t\t\t\t\t\t\t//その値の足し算が答えとなる\n\t\t\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\t\t\t\t\ts.add(work[j][i]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int solve3(int[][] dice) {\n\t\tint [][] work =new int[3][6];\n\t\tint res = 1 << 24;\n\t\twork[0] = Arrays.copyOf(dice[0], dice[0].length);\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\twork[1] = Arrays.copyOf(dice[1], dice[1].length);\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\tturn(work[1], order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\tslide(work[1]);\n\t\t\t\t\n\t\t\t\t//2個目\n\t\t\t\tfor(int j2 = 0; j2 < order.length; j2++){\n\t\t\t\t\twork[2] = Arrays.copyOf(dice[2], dice[2].length);\n\t\t\t\t\tfor(int i2 = 0; i2 < order[j2].length(); i2++){\n\t\t\t\t\t\tturn(work[2], order[j2].charAt(i2));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i2 = 0; i2 < 4; i2++){\n\t\t\t\t\t\tslide(work[2]);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//ある面に対して、その面の種類が同じであればok\n\t\t\t\t\t\t//setを使って、size - 1の値を足していく\n\t\t\t\t\t\t//その値の足し算が答えとなる\n\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\t\t\t\ts.add(work[j][i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int solve(int[][] dice) {\n\t\tint [][] work =new int[2][6];\n\t\tint res = 1 << 24;\n\t\twork[0] = Arrays.copyOf(dice[0], dice[0].length);\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\twork[1] = Arrays.copyOf(dice[1], dice[1].length);\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\tturn(work[1], order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\tslide(work[1]);\n\t\t\t\t\n\t\t\t\t//ある面に対して、その面の種類が同じであればok\n\t\t\t\t//setを使って、size - 1の値を足していく\n\t\t\t\t//その値の足し算が答えとなる\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\t\ts.add(work[j][i]);\n\t\t\t\t\t}\n\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t}\n\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate void slide(int [] dice) {\n\t\tswap(dice, 0,4,5,1);\n\t}\n\n\t//dice is, 0 = south, 1 = east, 2 = top, 3 = bottom, 4 = west, 5 = north;\n\tprivate void turn(int [] dice, char c) {\n\t\tswitch(c){\n\t\tcase 'n':\n\t\t\tswap(dice, 2,5,3,0);\n\t\t\tbreak;\n\t\t\n\t\tcase 's':\n\t\t\tswap(dice, 2,0,3,5);\n\t\t\tbreak;\n\t\t\n\t\tcase 'w':\n\t\t\tswap(dice, 2,4,3,1);\n\t\t\tbreak;\n\t\t\n\t\tcase 'e':\n\t\t\tswap(dice, 2,1,3,4);\n\t\t\tbreak;\n\t\t\n\t\t}\n\t}\n\n\tprivate void swap(int [] dice, int i, int j, int k, int l) {\n\t\tint temp = dice[l];\n\t\tdice[l] = dice[k];\n\t\tdice[k] = dice[j];\n\t\tdice[j] = dice[i];\n\t\tdice[i] = temp;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tString [] order = {\"\",\"n\",\"s\", \"e\", \"w\", \"nn\"};\n\t\n\tclass Dice{\n\t\t//dice is, 0 = south, 1 = east, 2 = top, 3 = bottom, 4 = west, 5 = north;\n\t\tint [] dice;\n\n\t\tpublic Dice(int[] dice) {\n\t\t\tthis.dice = dice;\n\t\t}\n\t\t\n\t\tprivate void slide() {\n\t\t\tswap(0,4,5,1);\n\t\t}\n\t\t\n\t\tprivate void turn(char c) {\n\t\t\tswitch(c){\n\t\t\tcase 'n':\n\t\t\t\tswap(2,5,3,0); break;\n\t\t\tcase 's':\n\t\t\t\tswap(2,0,3,5); break;\n\t\t\tcase 'w':\n\t\t\t\tswap(2,4,3,1); break;\n\t\t\tcase 'e':\n\t\t\t\tswap(2,1,3,4); break;\n\t\t\t}\n\t\t}\n\n\t\tprivate void swap(int i, int j, int k, int l) {\n\t\t\tint temp = dice[l];\n\t\t\tdice[l] = dice[k];\n\t\t\tdice[k] = dice[j];\n\t\t\tdice[j] = dice[i];\n\t\t\tdice[i] = temp;\n\t\t}\n\t\t\n\t}\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> tonum = new HashMap<String, Integer>();\n\t\t\tDice [] d = new Dice[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint [] input = new int[6];\n\t\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\t\tString s = sc.next();\n\t\t\t\t\tint ind = -1;\n\t\t\t\t\tif(tonum.containsKey(s)){\n\t\t\t\t\t\tind = tonum.get(s);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tind = tonum.size() + 1;\n\t\t\t\t\t\ttonum.put(s, ind);\n\t\t\t\t\t}\n\t\t\t\t\tinput[j] = ind;\n\t\t\t\t}\n\t\t\t\td[i] = new Dice(input);\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 1){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse if(n == 2){\n\t\t\t\tSystem.out.println(solve(d));\n\t\t\t}\n\t\t\telse if(n == 3){\n\t\t\t\tint res = solve3(d);\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint res = solve4(d);\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int solve4(Dice [] d) {\n\t\tint res = 1 << 24;\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\td[1].turn(order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\td[1].slide();\n\t\t\t\t\n\t\t\t\t//2個目\n\t\t\t\tfor(int j2 = 0; j2 < order.length; j2++){\n\t\t\t\t\tfor(int i2 = 0; i2 < order[j2].length(); i2++){\n\t\t\t\t\t\td[2].turn(order[j2].charAt(i2));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i2 = 0; i2 < 4; i2++){\n\t\t\t\t\t\td[2].slide();\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j3 = 0; j3 < order.length; j3++){\n\t\t\t\t\t\t\tfor(int i3 = 0; i3 < order[j3].length(); i3++){\n\t\t\t\t\t\t\t\td[3].turn(order[j3].charAt(i3));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int i3 = 0; i3 < 4; i3++){\n\t\t\t\t\t\t\t\td[3].slide();\n\t\t\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\t\t\t\t\tHashMap<Integer,Integer> s = new HashMap<Integer, Integer>();\n\t\t\t\t\t\t\t\t\tfor(int j = 0; j < d.length; j++){\n\t\t\t\t\t\t\t\t\t\tif(s.containsKey(d[j].dice[i])){\n\t\t\t\t\t\t\t\t\t\t\ts.put(d[j].dice[i], s.get(d[j].dice[i] + 1));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\ts.put(d[j].dice[i], 1);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(s.size() == 2){\n\t\t\t\t\t\t\t\t\t\tfor(int key: s.keySet()){\n\t\t\t\t\t\t\t\t\t\t\tif(s.get(key) == 2){\n\t\t\t\t\t\t\t\t\t\t\t\tsum += 2;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\tsum += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int solve3(Dice [] d) {\n\t\tint res = 1 << 24;\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\td[1].turn(order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\td[1].slide();\n\t\t\t\t\n\t\t\t\t//2個目\n\t\t\t\tfor(int j2 = 0; j2 < order.length; j2++){\n\t\t\t\t\tfor(int i2 = 0; i2 < order[j2].length(); i2++){\n\t\t\t\t\t\td[2].turn(order[j2].charAt(i2));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i2 = 0; i2 < 4; i2++){\n\t\t\t\t\t\td[2].slide();\n\n\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\t\t\tfor(int j = 0; j <  d.length; j++){\n\t\t\t\t\t\t\t\ts.add(d[j].dice[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int solve(Dice [] d) {\n\t\tint res = 1 << 24;\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\td[1].turn(order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\td[1].slide();\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\tfor(int j = 0; j <  d.length; j++){\n\t\t\t\t\t\ts.add(d[j].dice[i]);\n\t\t\t\t\t}\n\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t}\n\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0418 start\n\t//0503 cording end\n\t//0515 find a fatal error and sleep\n\t//1210 restart\n\t//1300 sample match WA\n\t\n\t//dice is, 0 = south, 1 = east, 2 = top, 3 = bottom, 4 = west, 5 = north;\n\tString [] order = {\"\",\"n\",\"s\", \"e\", \"w\", \"nn\"};\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> tonum = new HashMap<String, Integer>();\n\t\t\tint [][] dice = new int[n][6];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\t\tString s = sc.next();\n\t\t\t\t\tint ind = -1;\n\t\t\t\t\tif(tonum.containsKey(s)){\n\t\t\t\t\t\tind = tonum.get(s);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tind = tonum.size() + 1;\n\t\t\t\t\t\ttonum.put(s, ind);\n\t\t\t\t\t}\n\t\t\t\t\tdice[i][j] = ind;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 1){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse if(n == 2){\n\t\t\t\tSystem.out.println(solve(dice));\n\t\t\t}\n\t\t\telse if(n == 3){\n\t\t\t\tint res = solve3(dice);\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint res = solve4(dice);\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t\t//debug\n//\t\t\tfor( String key : tonum.keySet()){\n//\t\t\t\tSystem.out.println(key + \" \" + tonum.get(key));\n//\t\t\t}\n\t\t}\n\t}\n\n\tprivate int solve4(int[][] dice) {\n\t\tint [][] work =new int[4][6];\n\t\tint res = 1 << 24;\n\t\twork[0] = Arrays.copyOf(dice[0], dice[0].length);\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\twork[1] = Arrays.copyOf(dice[1], dice[1].length);\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\tturn(work[1], order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\tslide(work[1]);\n\t\t\t\t\n\t\t\t\t//2個目\n\t\t\t\tfor(int j2 = 0; j2 < order.length; j2++){\n\t\t\t\t\twork[2] = Arrays.copyOf(dice[2], dice[2].length);\n\t\t\t\t\tfor(int i2 = 0; i2 < order[j2].length(); i2++){\n\t\t\t\t\t\tturn(work[2], order[j2].charAt(i2));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i2 = 0; i2 < 4; i2++){\n\t\t\t\t\t\tslide(work[2]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j3 = 0; j3 < order.length; j3++){\n\t\t\t\t\t\t\twork[3] = Arrays.copyOf(dice[3], dice[3].length);\n\t\t\t\t\t\t\tfor(int i3 = 0; i3 < order[j3].length(); i3++){\n\t\t\t\t\t\t\t\tturn(work[3],order[j3].charAt(i3));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int i3 = 0; i3 < 4; i3++){\n\t\t\t\t\t\t\t\tslide(work[3]);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//ある面に対して、その面の種類が同じであればok\n\t\t\t\t\t\t\t\t//setを使って、size - 1の値を足していく\n\t\t\t\t\t\t\t\t//その値の足し算が答えとなる\n\t\t\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\t\t\t\t\tHashMap<Integer,Integer> s = new HashMap<Integer, Integer>();\n\t\t\t\t\t\t\t\t\tfor(int j = 0; j < work.length; j++){\n\t\t\t\t\t\t\t\t\t\tif(s.containsKey(s)){\n\t\t\t\t\t\t\t\t\t\t\ts.put(work[j][i], s.get(work[j][i]) + 1);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\ts.put(work[j][i], 1);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(s.size() == 2){\n\t\t\t\t\t\t\t\t\t\tfor(int key: s.keySet()){\n\t\t\t\t\t\t\t\t\t\t\tif(s.get(key) == 2){\n\t\t\t\t\t\t\t\t\t\t\t\tsum += 2;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\tsum += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int solve3(int[][] dice) {\n\t\tint [][] work =new int[3][6];\n\t\tint res = 1 << 24;\n\t\twork[0] = Arrays.copyOf(dice[0], dice[0].length);\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\twork[1] = Arrays.copyOf(dice[1], dice[1].length);\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\tturn(work[1], order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\tslide(work[1]);\n\t\t\t\t\n\t\t\t\t//2個目\n\t\t\t\tfor(int j2 = 0; j2 < order.length; j2++){\n\t\t\t\t\twork[2] = Arrays.copyOf(dice[2], dice[2].length);\n\t\t\t\t\tfor(int i2 = 0; i2 < order[j2].length(); i2++){\n\t\t\t\t\t\tturn(work[2], order[j2].charAt(i2));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i2 = 0; i2 < 4; i2++){\n\t\t\t\t\t\tslide(work[2]);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//ある面に対して、その面の種類が同じであればok\n\t\t\t\t\t\t//setを使って、size - 1の値を足していく\n\t\t\t\t\t\t//その値の足し算が答えとなる\n\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\t\t\tfor(int j = 0; j <  work.length; j++){\n\t\t\t\t\t\t\t\ts.add(work[j][i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int solve(int[][] dice) {\n\t\tint [][] work =new int[2][6];\n\t\tint res = 1 << 24;\n\t\twork[0] = Arrays.copyOf(dice[0], dice[0].length);\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\twork[1] = Arrays.copyOf(dice[1], dice[1].length);\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\tturn(work[1], order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\tslide(work[1]);\n\t\t\t\t\n\t\t\t\t//ある面に対して、その面の種類が同じであればok\n\t\t\t\t//setを使って、size - 1の値を足していく\n\t\t\t\t//その値の足し算が答えとなる\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\tfor(int j = 0; j <  work.length; j++){\n\t\t\t\t\t\ts.add(work[j][i]);\n\t\t\t\t\t}\n\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t}\n\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate void slide(int [] dice) {\n\t\tswap(dice, 0,4,5,1);\n\t}\n\n\t//dice is, 0 = south, 1 = east, 2 = top, 3 = bottom, 4 = west, 5 = north;\n\tprivate void turn(int [] dice, char c) {\n\t\tswitch(c){\n\t\tcase 'n':\n\t\t\tswap(dice, 2,5,3,0);\n\t\t\tbreak;\n\t\t\n\t\tcase 's':\n\t\t\tswap(dice, 2,0,3,5);\n\t\t\tbreak;\n\t\t\n\t\tcase 'w':\n\t\t\tswap(dice, 2,4,3,1);\n\t\t\tbreak;\n\t\t\n\t\tcase 'e':\n\t\t\tswap(dice, 2,1,3,4);\n\t\t\tbreak;\n\t\t\n\t\t}\n\t}\n\n\tprivate void swap(int [] dice, int i, int j, int k, int l) {\n\t\tint temp = dice[l];\n\t\tdice[l] = dice[k];\n\t\tdice[k] = dice[j];\n\t\tdice[j] = dice[i];\n\t\tdice[i] = temp;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0418 start\n\t//0503 cording end\n\t//0515 find a fatal error and sleep\n\t//1210 restart\n\t//1300 sample match WA\n\t//1320 WA modi {x,x,y,y}patttern\n\t\n\t//dice is, 0 = south, 1 = east, 2 = top, 3 = bottom, 4 = west, 5 = north;\n\tString [] order = {\"\",\"n\",\"s\", \"e\", \"w\", \"nn\"};\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> tonum = new HashMap<String, Integer>();\n\t\t\tint [][] dice = new int[n][6];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\t\tString s = sc.next();\n\t\t\t\t\tint ind = -1;\n\t\t\t\t\tif(tonum.containsKey(s)){\n\t\t\t\t\t\tind = tonum.get(s);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tind = tonum.size() + 1;\n\t\t\t\t\t\ttonum.put(s, ind);\n\t\t\t\t\t}\n\t\t\t\t\tdice[i][j] = ind;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 1){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse if(n == 2){\n\t\t\t\tSystem.out.println(solve(dice));\n\t\t\t}\n\t\t\telse if(n == 3){\n\t\t\t\tint res = solve3(dice);\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint res = solve4(dice);\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t\t//debug\n//\t\t\tfor( String key : tonum.keySet()){\n//\t\t\t\tSystem.out.println(key + \" \" + tonum.get(key));\n//\t\t\t}\n\t\t}\n\t}\n\n\tprivate int solve4(int[][] dice) {\n\t\tint [][] work =new int[4][6];\n\t\tint res = 1 << 24;\n\t\twork[0] = Arrays.copyOf(dice[0], dice[0].length);\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\twork[1] = Arrays.copyOf(dice[1], dice[1].length);\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\tturn(work[1], order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\tslide(work[1]);\n\t\t\t\t\n\t\t\t\t//2個目\n\t\t\t\tfor(int j2 = 0; j2 < order.length; j2++){\n\t\t\t\t\twork[2] = Arrays.copyOf(dice[2], dice[2].length);\n\t\t\t\t\tfor(int i2 = 0; i2 < order[j2].length(); i2++){\n\t\t\t\t\t\tturn(work[2], order[j2].charAt(i2));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i2 = 0; i2 < 4; i2++){\n\t\t\t\t\t\tslide(work[2]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j3 = 0; j3 < order.length; j3++){\n\t\t\t\t\t\t\twork[3] = Arrays.copyOf(dice[3], dice[3].length);\n\t\t\t\t\t\t\tfor(int i3 = 0; i3 < order[j3].length(); i3++){\n\t\t\t\t\t\t\t\tturn(work[3],order[j3].charAt(i3));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int i3 = 0; i3 < 4; i3++){\n\t\t\t\t\t\t\t\tslide(work[3]);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//ある面に対して、その面の種類が同じであればok\n\t\t\t\t\t\t\t\t//setを使って、size - 1の値を足していく\n\t\t\t\t\t\t\t\t//その値の足し算が答えとなる\n\t\t\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\t\t\t\t\tHashMap<Integer,Integer> s = new HashMap<Integer, Integer>();\n\t\t\t\t\t\t\t\t\tfor(int j = 0; j < work.length; j++){\n\t\t\t\t\t\t\t\t\t\tif(s.containsKey(work[j][i])){\n\t\t\t\t\t\t\t\t\t\t\ts.put(work[j][i], s.get(work[j][i]) + 1);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\ts.put(work[j][i], 1);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(s.size() == 2){\n\t\t\t\t\t\t\t\t\t\tfor(int key: s.keySet()){\n\t\t\t\t\t\t\t\t\t\t\tif(s.get(key) == 2){\n\t\t\t\t\t\t\t\t\t\t\t\tsum += 2;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\tsum += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int solve3(int[][] dice) {\n\t\tint [][] work =new int[3][6];\n\t\tint res = 1 << 24;\n\t\twork[0] = Arrays.copyOf(dice[0], dice[0].length);\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\twork[1] = Arrays.copyOf(dice[1], dice[1].length);\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\tturn(work[1], order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\tslide(work[1]);\n\t\t\t\t\n\t\t\t\t//2個目\n\t\t\t\tfor(int j2 = 0; j2 < order.length; j2++){\n\t\t\t\t\twork[2] = Arrays.copyOf(dice[2], dice[2].length);\n\t\t\t\t\tfor(int i2 = 0; i2 < order[j2].length(); i2++){\n\t\t\t\t\t\tturn(work[2], order[j2].charAt(i2));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i2 = 0; i2 < 4; i2++){\n\t\t\t\t\t\tslide(work[2]);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//ある面に対して、その面の種類が同じであればok\n\t\t\t\t\t\t//setを使って、size - 1の値を足していく\n\t\t\t\t\t\t//その値の足し算が答えとなる\n\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\t\t\tfor(int j = 0; j <  work.length; j++){\n\t\t\t\t\t\t\t\ts.add(work[j][i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int solve(int[][] dice) {\n\t\tint [][] work =new int[2][6];\n\t\tint res = 1 << 24;\n\t\twork[0] = Arrays.copyOf(dice[0], dice[0].length);\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\twork[1] = Arrays.copyOf(dice[1], dice[1].length);\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\tturn(work[1], order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\tslide(work[1]);\n\t\t\t\t\n\t\t\t\t//ある面に対して、その面の種類が同じであればok\n\t\t\t\t//setを使って、size - 1の値を足していく\n\t\t\t\t//その値の足し算が答えとなる\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\tfor(int j = 0; j <  work.length; j++){\n\t\t\t\t\t\ts.add(work[j][i]);\n\t\t\t\t\t}\n\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t}\n\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate void slide(int [] dice) {\n\t\tswap(dice, 0,4,5,1);\n\t}\n\n\t//dice is, 0 = south, 1 = east, 2 = top, 3 = bottom, 4 = west, 5 = north;\n\tprivate void turn(int [] dice, char c) {\n\t\tswitch(c){\n\t\tcase 'n':\n\t\t\tswap(dice, 2,5,3,0);\n\t\t\tbreak;\n\t\t\n\t\tcase 's':\n\t\t\tswap(dice, 2,0,3,5);\n\t\t\tbreak;\n\t\t\n\t\tcase 'w':\n\t\t\tswap(dice, 2,4,3,1);\n\t\t\tbreak;\n\t\t\n\t\tcase 'e':\n\t\t\tswap(dice, 2,1,3,4);\n\t\t\tbreak;\n\t\t\n\t\t}\n\t}\n\n\tprivate void swap(int [] dice, int i, int j, int k, int l) {\n\t\tint temp = dice[l];\n\t\tdice[l] = dice[k];\n\t\tdice[k] = dice[j];\n\t\tdice[j] = dice[i];\n\t\tdice[i] = temp;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint[][] map = { { 0, 1, 2, 4, 3, 5 }, { 0, 2, 4, 3, 1, 5 },\n\t\t\t{ 0, 4, 3, 1, 2, 5 }, { 0, 3, 1, 2, 4, 5 },\n\n\t\t\t{ 1, 2, 0, 3, 5, 4 }, { 1, 5, 2, 0, 3, 4 }, { 1, 3, 5, 2, 0, 4 },\n\t\t\t{ 1, 5, 2, 0, 3, 4 },\n\n\t\t\t{ 2, 0, 1, 5, 4, 3 }, { 2, 1, 5, 4, 0, 3 }, { 2, 5, 4, 0, 1, 3 },\n\t\t\t{ 2, 4, 0, 1, 5, 3 },\n\n\t\t\t{ 0, 1, 2, 4, 3, 5 }, { 0, 2, 4, 3, 1, 5 }, { 0, 4, 3, 1, 2, 5 },\n\t\t\t{ 0, 3, 1, 2, 4, 5 },\n\n\t\t\t{ 1, 3, 1, 2, 5, 4 }, { 1, 1, 2, 5, 3, 4 }, { 1, 2, 5, 3, 1, 4 },\n\t\t\t{ 1, 5, 3, 1, 2, 4 },\n\n\t\t\t{ 2, 0, 1, 5, 4, 3 }, { 2, 1, 5, 4, 0, 3 }, { 2, 5, 4, 0, 1, 3 },\n\t\t\t{ 2, 4, 0, 1, 5, 3 }, };\n\n\tint[] rev(int[] a) {\n\t\tint[] ret = new int[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid run() {\n\t\t{\n\t\t\tint n = 12;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i + n] = rev(map[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 24; i++) {\n\t\t\t// System.out.println(Arrays.toString(map[i]));\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tsc.next();\n\t\t\t\t}\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\n\t\t\tint dice[][] = new int[n][6];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tString buffer = sc.next();\n\t\t\t\t\tint v = 0;\n\t\t\t\t\tif (!hm.containsKey(buffer)) {\n\t\t\t\t\t\tv = hm.size();\n\t\t\t\t\t\thm.put(buffer, hm.size());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv = hm.get(buffer);\n\t\t\t\t\t}\n\t\t\t\t\tdice[i][j] = v;\n\t\t\t\t}\n\t\t\t\t// System.out.println(Arrays.toString(dice[i]));\n\t\t\t}\n\n\t\t\tint dice2[][] = new int[n][6];\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tdice2[0][i] = dice[0][map[0][i]];\n\t\t\t}\n\n\t\t\tlong patmax = 1;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tpatmax *= 24;\n\t\t\t}\n\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (long pat = 0; pat < patmax; pat++) {\n\t\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\t\tint p = exe(j, pat, n);\n\t\t\t\t\t// System.out.print(p+\" \");\n\t\t\t\t\tint[] m = map[p];\n\t\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\t\tdice2[j][k] = dice[j][m[k]];\n\t\t\t\t\t}\n\t\t\t\t\t// System.out.println(Arrays.toString(dice2[j]));\n\t\t\t\t}\n\t\t\t\t// System.out.println();\n\n\t\t\t\tmin = check(dice2, min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tint check(int[][] dice, int min) {\n\t\tint value = 0;\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tint hind[] = new int[24];\n\t\t\tfor (int i = 0; i < dice.length; i++) {\n\t\t\t\thind[dice[i][j]]++;\n\t\t\t}\n\t\t\tint maxHind = 0;\n\t\t\tfor (int i = 0; i < 24; i++) {\n\t\t\t\tmaxHind = Math.max(maxHind, hind[i]);\n\t\t\t}\n\t\t\tvalue += dice.length - maxHind;\n\t\t\tif (min <= value)\n\t\t\t\treturn min;\n\t\t}\n\t//\tSystem.out.println(value);\n\t\tfor (int i = 0; i < dice.length; i++) {\n\t//\t\tSystem.out.println(Arrays.toString(dice[i]));\n\t\t}\n\t\treturn Math.min(value, min);\n\t}\n\n\tint exe(int j, long pat, int n) {\n\t\tfor (int i = 1; i < j; i++) {\n\t\t\tpat /= 24;\n\t\t}\n\t\treturn (int) (pat % 24);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    //0418 start\n    //0503 cording end\n    //0515 find a fatal error and sleep\n    //1210 restart\n    //1300 sample match WA\n    //1320 WA modi {x,x,y,y}patttern\n     \n    //dice is, 0 = south, 1 = east, 2 = top, 3 = bottom, 4 = west, 5 = north;\n    String [] order = {\"\",\"n\",\"s\", \"e\", \"w\", \"nn\"};\n    private void doit(){\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            int n = sc.nextInt();\n            if(n == 0) break;\n            HashMap<String, Integer> tonum = new HashMap<String, Integer>();\n            int [][] dice = new int[n][6];\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < 6; j++){\n                    String s = sc.next();\n                    int ind = -1;\n                    if(tonum.containsKey(s)){\n                        ind = tonum.get(s);\n                    }\n                    else{\n                        ind = tonum.size() + 1;\n                        tonum.put(s, ind);\n                    }\n                    dice[i][j] = ind;\n                }\n            }\n             \n            if(n == 1){\n                System.out.println(0);\n            }\n            else if(n == 2){\n                System.out.println(solve(dice));\n            }\n            else if(n == 3){\n                int res = solve3(dice);\n                System.out.println(res);\n            }\n            else{\n                int res = solve4(dice);\n                System.out.println(res);\n            }\n        }\n    }\n \n    private int solve4(int[][] dice) {\n        int [][] work =new int[4][6];\n        int res = 1 << 24;\n        work[0] = Arrays.copyOf(dice[0], dice[0].length);\n        //1個目\n        for(int j1 = 0; j1 < order.length; j1++){\n            work[1] = Arrays.copyOf(dice[1], dice[1].length);\n            for(int i1 = 0; i1 < order[j1].length(); i1++){\n                turn(work[1], order[j1].charAt(i1));\n            }\n             \n            for(int i1 = 0; i1 < 4; i1++){\n                slide(work[1]);\n                 \n                //2個目\n                for(int j2 = 0; j2 < order.length; j2++){\n                    work[2] = Arrays.copyOf(dice[2], dice[2].length);\n                    for(int i2 = 0; i2 < order[j2].length(); i2++){\n                        turn(work[2], order[j2].charAt(i2));\n                    }\n                    for(int i2 = 0; i2 < 4; i2++){\n                        slide(work[2]);\n                         \n                         //3個目\n                        for(int j3 = 0; j3 < order.length; j3++){\n                            work[3] = Arrays.copyOf(dice[3], dice[3].length);\n                            for(int i3 = 0; i3 < order[j3].length(); i3++){\n                                turn(work[3],order[j3].charAt(i3));\n                            }\n                             \n                            for(int i3 = 0; i3 < 4; i3++){\n                                slide(work[3]);\n                                 \n                                //4個目\n                                int sum = 0;\n                                for(int i = 0; i < 6;i++){\n                                    HashMap<Integer,Integer> s = new HashMap<Integer, Integer>();\n                                    for(int j = 0; j < work.length; j++){\n                                        if(s.containsKey(work[j][i])){\n                                            s.put(work[j][i], s.get(work[j][i]) + 1);\n                                        }\n                                        else{\n                                            s.put(work[j][i], 1);\n                                        }\n                                         \n                                    }\n                                     \n                                    if(s.size() == 2){\n                                        for(int key: s.keySet()){\n                                            if(s.get(key) == 2){\n                                                sum += 2;\n                                                break;\n                                            }\n                                            else{\n                                                sum += 1;\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    else{\n                                        sum += s.size() - 1;\n                                    }\n                                }\n                                res = Math.min(sum, res);\n                            }\n                        }\n                    }\n                }\n                 \n            }\n        }\n        return res;\n    }\n \n    private int solve3(int[][] dice) {\n        int [][] work =new int[3][6];\n        int res = 1 << 24;\n        work[0] = Arrays.copyOf(dice[0], dice[0].length);\n        //1個目\n        for(int j1 = 0; j1 < order.length; j1++){\n            work[1] = Arrays.copyOf(dice[1], dice[1].length);\n            for(int i1 = 0; i1 < order[j1].length(); i1++){\n                turn(work[1], order[j1].charAt(i1));\n            }\n             \n            for(int i1 = 0; i1 < 4; i1++){\n                slide(work[1]);\n                 \n                //2個目\n                for(int j2 = 0; j2 < order.length; j2++){\n                    work[2] = Arrays.copyOf(dice[2], dice[2].length);\n                    for(int i2 = 0; i2 < order[j2].length(); i2++){\n                        turn(work[2], order[j2].charAt(i2));\n                    }\n                    for(int i2 = 0; i2 < 4; i2++){\n                        slide(work[2]);\n                         \n                        //3個目\n                        int sum = 0;\n                        for(int i = 0; i < 6;i++){\n                            HashSet<Integer> s = new HashSet<Integer>();\n                            for(int j = 0; j <  work.length; j++){\n                                s.add(work[j][i]);\n                            }\n                            sum += s.size() - 1;\n                        }\n                        res = Math.min(sum, res);\n                    }\n                }\n                 \n            }\n        }\n        return res;\n    }\n \n    private int solve(int[][] dice) {\n        int [][] work =new int[2][6];\n        int res = 1 << 24;\n        work[0] = Arrays.copyOf(dice[0], dice[0].length);\n        //1個目\n        for(int j1 = 0; j1 < order.length; j1++){\n            work[1] = Arrays.copyOf(dice[1], dice[1].length);\n            for(int i1 = 0; i1 < order[j1].length(); i1++){\n                turn(work[1], order[j1].charAt(i1));\n            }\n             \n            for(int i1 = 0; i1 < 4; i1++){\n                slide(work[1]);\n                 \n                //2個目\n                int sum = 0;\n                for(int i = 0; i < 6;i++){\n                    HashSet<Integer> s = new HashSet<Integer>();\n                    for(int j = 0; j <  work.length; j++){\n                        s.add(work[j][i]);\n                    }\n                    sum += s.size() - 1;\n                }\n                res = Math.min(sum, res);\n                 \n            }\n        }\n        return res;\n    }\n \n    private void slide(int [] dice) {\n        swap(dice, 0,4,5,1);\n    }\n \n    private void turn(int [] dice, char c) {\n        switch(c){\n        case 'n':\n            swap(dice, 2,5,3,0);\n            break;\n         \n        case 's':\n            swap(dice, 2,0,3,5);\n            break;\n         \n        case 'w':\n            swap(dice, 2,4,3,1);\n            break;\n         \n        case 'e':\n            swap(dice, 2,1,3,4);\n            break;\n         \n        }\n    }\n \n    private void swap(int [] dice, int i, int j, int k, int l) {\n        int temp = dice[l];\n        dice[l] = dice[k];\n        dice[k] = dice[j];\n        dice[j] = dice[i];\n        dice[i] = temp;\n    }\n \n    public static void main(String[] args) {\n        Main obj = new Main();\n        obj.doit();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tString [] order = {\"\",\"n\",\"s\", \"e\", \"w\", \"nn\"};\n\t\n\tclass Dice{\n\t\t//dice is, 0 = south, 1 = east, 2 = top, 3 = bottom, 4 = west, 5 = north;\n\t\tint [] dice;\n\n\t\tpublic Dice(int[] dice) {\n\t\t\tthis.dice = dice;\n\t\t}\n\t\t\n\t\tprivate void slide() {\n\t\t\tswap(0,4,5,1);\n\t\t}\n\t\t\n\t\tprivate void turn(char c) {\n\t\t\tswitch(c){\n\t\t\tcase 'n':\n\t\t\t\tswap(2,5,3,0); break;\n\t\t\tcase 's':\n\t\t\t\tswap(2,0,3,5); break;\n\t\t\tcase 'w':\n\t\t\t\tswap(2,4,3,1); break;\n\t\t\tcase 'e':\n\t\t\t\tswap(2,1,3,4); break;\n\t\t\t}\n\t\t}\n\n\t\tprivate void swap(int i, int j, int k, int l) {\n\t\t\tint temp = dice[l];\n\t\t\tdice[l] = dice[k];\n\t\t\tdice[k] = dice[j];\n\t\t\tdice[j] = dice[i];\n\t\t\tdice[i] = temp;\n\t\t}\n\t\t\n\t}\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> tonum = new HashMap<String, Integer>();\n\t\t\tDice [] d = new Dice[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint [] input = new int[6];\n\t\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\t\tString s = sc.next();\n\t\t\t\t\tint ind = -1;\n\t\t\t\t\tif(tonum.containsKey(s)){\n\t\t\t\t\t\tind = tonum.get(s);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tind = tonum.size() + 1;\n\t\t\t\t\t\ttonum.put(s, ind);\n\t\t\t\t\t}\n\t\t\t\t\tinput[j] = ind;\n\t\t\t\t}\n\t\t\t\td[i] = new Dice(input);\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 1){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse if(n == 2){\n\t\t\t\tSystem.out.println(solve(d));\n\t\t\t}\n\t\t\telse if(n == 3){\n\t\t\t\tint res = solve3(d);\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint res = solve4(d);\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int solve4(Dice [] d) {\n\t\tint res = 1 << 24;\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\td[1].turn(order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\td[1].slide();\n\t\t\t\t\n\t\t\t\t//2個目\n\t\t\t\tfor(int j2 = 0; j2 < order.length; j2++){\n\t\t\t\t\tfor(int i2 = 0; i2 < order[j2].length(); i2++){\n\t\t\t\t\t\td[2].turn(order[j2].charAt(i2));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i2 = 0; i2 < 4; i2++){\n\t\t\t\t\t\td[2].slide();\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j3 = 0; j3 < order.length; j3++){\n\t\t\t\t\t\t\tfor(int i3 = 0; i3 < order[j3].length(); i3++){\n\t\t\t\t\t\t\t\td[3].turn(order[j3].charAt(i3));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int i3 = 0; i3 < 4; i3++){\n\t\t\t\t\t\t\t\td[3].slide();\n\t\t\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\t\t\t\t\tHashMap<Integer,Integer> s = new HashMap<Integer, Integer>();\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tfor(int j = 0; j < d.length; j++){\n\t\t\t\t\t\t\t\t\t\tif(s.containsKey(d[j].dice[i])){\n\t\t\t\t\t\t\t\t\t\t\ts.put(d[j].dice[i], s.get(d[j].dice[i]) + 1);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\ts.put(d[j].dice[i] , 1);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(s.size() == 2){\n\t\t\t\t\t\t\t\t\t\tfor(int key: s.keySet()){\n\t\t\t\t\t\t\t\t\t\t\tif(s.get(key) == 2){\n\t\t\t\t\t\t\t\t\t\t\t\tsum += 2;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\tsum += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int solve3(Dice [] d) {\n\t\tint res = 1 << 24;\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\td[1].turn(order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\td[1].slide();\n\t\t\t\t\n\t\t\t\t//2個目\n\t\t\t\tfor(int j2 = 0; j2 < order.length; j2++){\n\t\t\t\t\tfor(int i2 = 0; i2 < order[j2].length(); i2++){\n\t\t\t\t\t\td[2].turn(order[j2].charAt(i2));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i2 = 0; i2 < 4; i2++){\n\t\t\t\t\t\td[2].slide();\n\n\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\t\t\tfor(int j = 0; j <  d.length; j++){\n\t\t\t\t\t\t\t\ts.add(d[j].dice[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int solve(Dice [] d) {\n\t\tint res = 1 << 24;\n\t\tfor(int j1 = 0; j1 < order.length; j1++){\n\t\t\tfor(int i1 = 0; i1 < order[j1].length(); i1++){\n\t\t\t\td[1].turn(order[j1].charAt(i1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i1 = 0; i1 < 4; i1++){\n\t\t\t\td[1].slide();\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int i = 0; i < 6;i++){\n\t\t\t\t\tHashSet<Integer> s = new HashSet<Integer>();\n\t\t\t\t\tfor(int j = 0; j <  d.length; j++){\n\t\t\t\t\t\ts.add(d[j].dice[i]);\n\t\t\t\t\t}\n\t\t\t\t\tsum += s.size() - 1;\n\t\t\t\t}\n\t\t\t\tres = Math.min(sum, res);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Colored Cubes\npublic class Main{\n\n\tpublic static class Dice <T>{\n\t\tpublic T[] id;\n\t\t\tenum Face{TOP, BOTTOM, FRONT, BACK, RIGHT, LEFT};\n\t\t\tpublic T get(int k){\n\t\t\t\treturn id[k];\n\t\t\t}\n\t\t\tpublic Dice<T> copy(){\n\t\t\t\treturn new Dice<T>(id[0], id[1], id[2], id[3], id[4], id[5]);\n\t\t\t}\n\t\t\tpublic Dice() {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] tid = (T[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t}\n\t\t\tpublic Dice(T top, T bottom, T front, T back, T right, T left) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] tid = (T[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t\tid[Face.TOP.ordinal()] = top;\n\t\t\t\tid[Face.BOTTOM.ordinal()]= bottom;\n\t\t\t\tid[Face.FRONT.ordinal()] = front;\n\t\t\t\tid[Face.BACK.ordinal()] = back;\n\t\t\t\tid[Face.RIGHT.ordinal()] = right;\n\t\t\t\tid[Face.LEFT.ordinal()] = left;\n\t\t\t}\n\t\t\tvoid rollX(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.FRONT, Face.BOTTOM, Face.BACK);\n\t\t\t\telse roll(Face.TOP, Face.BACK, Face.BOTTOM, Face.FRONT);\n\t\t\t}\n\t\t\tvoid rollY(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.LEFT, Face.BOTTOM, Face.RIGHT);\n\t\t\t\telse roll(Face.TOP, Face.RIGHT, Face.BOTTOM, Face.LEFT);\n\t\t\t}\n\t\t\tvoid rollZ(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.FRONT, Face.LEFT, Face.BACK, Face.RIGHT);\n\t\t\t\telse roll(Face.FRONT, Face.RIGHT, Face.BACK, Face.LEFT);\n\t\t\t}\n\t\t\tprivate void roll(Face w, Face x, Face y, Face z) {\n\t\t\t\tT tmp = id[w.ordinal()];\n\t\t\t\tid[w.ordinal()] = id[x.ordinal()];\n\t\t\t\tid[x.ordinal()] = id[y.ordinal()];\n\t\t\t\tid[y.ordinal()] = id[z.ordinal()];\n\t\t\t\tid[z.ordinal()] = tmp;\n\t\t\t}\n\t\t\tList<Dice<T>> getAllState(){\n\t\t\t\tList<Dice<T>> lst = new ArrayList<Dice<T>>();\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tlst.add(new Dice<T>(id[Face.TOP.ordinal()], id[Face.BOTTOM.ordinal()], id[Face.FRONT.ordinal()], id[Face.BACK.ordinal()], id[Face.RIGHT.ordinal()], id[Face.LEFT.ordinal()]));\n\t\t\t\t\t\trollZ(false);\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2 == 1) rollY(false);\n\t\t\t\t\telse rollX(false);\n\t\t\t\t}\n\t\t\t\treturn lst;\n\t\t\t}\n\t}\n\t\n\tMap<String, Integer> ref;\n\tint ID;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\t\n\tDice<Integer>[][] d;\n\tint[] s;\n\tint res, n;\n\t\n\tvoid dfs(int k){\n\t\tif(k==n){\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint max = 0;\n\t\t\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint x = d[j][s[j]].get(i);\n\t\t\t\t\tif(map.containsKey(x)){\n\t\t\t\t\t\tmax = Math.max(max, map.get(x)+1);\n\t\t\t\t\t\tmap.put(x, map.get(x)+1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap.put(x, 1);\n\t\t\t\t\t\tmax = Math.max(max, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc+=n-max;\n\t\t\t}\n\t\t\tres = Math.min(res, c);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<24;i++){\n\t\t\ts[k] = i;\n\t\t\tdfs(k+1);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\ts = new int[4];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\td = new Dice[n][24];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint[] c = new int[6];\n\t\t\t\tfor(int j=0;j<6;j++)c[j]=reg(sc.next());\n\t\t\t\tDice<Integer> D = new Dice<Integer>(c[2], c[3], c[0], c[5], c[1], c[4]);\n\t\t\t\tList<Dice<Integer>> l = D.getAllState();\n\t\t\t\tfor(int j=0;j<24;j++)d[i][j] = l.get(j);\n\t\t\t}\n\t\t\tres = 24;\n\t\t\tdfs(1);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\n#     (+x,+y,+z,-z,-y,-x)\nDICE = [0, 1, 2, 3, 4, 5]\n\nINF = 1 << 30\n\n### subroutines\n\ndef rot_x(dc0, n = 1)\n  d = dc0.clone\n  n.times do\n    t = d[1]; d[1] = d[3]; d[3] = d[4]; d[4] = d[2]; d[2] = t\n  end\n  d\nend\n\ndef rot_y(dc0, n = 1)\n  d = dc0.clone\n  n.times do\n    t = d[2]; d[2] = d[5]; d[5] = d[3]; d[3] = d[0]; d[0] = t\n  end\n  d\nend\n\ndef rot_z(dc0, n = 1)\n  d = dc0.clone\n  n.times do\n    t = d[0]; d[0] = d[4]; d[4] = d[5]; d[5] = d[1]; d[1] = t\n  end\n  d\nend\n\ndef calc_min_repaint(dcs)\n  count = 0\n  \n  for i in (0...6)\n    cs = [0] * $nc\n    (0...$n).each{|k| cs[dcs[k][i]] +=1}\n    count += $n - cs.max\n  end\n\n  count\nend\n\ndef min_r_rec(k, dcs)\n  if k >= $n\n    return calc_min_repaint(dcs)\n  end\n\n  min_r = INF\n\n  $rots.each do |rot|\n    dc = (0...6).map{|i| $dices[k][rot[i]]}\n    r = min_r_rec(k + 1, dcs + [dc])\n    min_r = r if min_r > r\n  end\n\n  min_r\nend\n\ndef min_repaint\n  min_r_rec(1, [$dices.first])\nend\n\n### main\n\n$rots = []\n\nfor zr in (0...4)\n  for yr in (0...4)\n    for xr in (0...4)\n      $rots << rot_z(rot_y(rot_x(DICE, xr), yr), zr)\n    end\n  end\nend\n$rots.sort!.uniq!\n$nrots = $rots.length\n#p $rots; exit\n\nloop do\n  $n = gets.to_i\n  break if $n == 0\n\n  cnmhash = {}\n  $nc = 0\n  $dices = []\n  \n  $n.times do\n    cnms = gets.strip.split\n    $dices << cnms.map do |cnm|\n      if cnmhash[cnm].nil?\n        cnmhash[cnm] = $nc\n        $nc += 1\n      end\n      cnmhash[cnm]\n    end\n  end\n  #p $nc\n  #p $dices\n\n  p min_repaint\nend"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from itertools import product\n    from sys import stdin\n    f_i = stdin\n    \n    # idices of faces\n    indices = ((0, 1, 2, 3, 4, 5), (0, 2, 4, 1, 3, 5),\n               (0, 4, 3, 2, 1, 5), (0, 3, 1, 4, 2, 5),\n               (1, 0, 3, 2, 5, 4), (1, 3, 5, 0, 2, 4),\n               (1, 5, 2, 3, 0, 4), (1, 2, 0, 5, 3, 4),\n               (2, 0, 1, 4, 5, 3), (2, 1, 5, 0, 4, 3),\n               (2, 5, 4, 1, 0, 3), (2, 4, 0, 5, 1, 3),\n               (3, 0, 4, 1, 5, 2), (3, 4, 5, 0, 1, 2),\n               (3, 5, 1, 4, 0, 2), (3, 1, 0, 5, 4, 2),\n               (4, 0, 2, 3, 5, 1), (4, 2, 5, 0, 3, 1),\n               (4, 5, 3, 2, 0, 1), (4, 3, 0, 5, 2, 1),\n               (5, 1, 3, 2, 4, 0), (5, 3, 4, 1, 2, 0),\n               (5, 4, 2, 3, 1, 0), (5, 2, 1, 4, 3, 0))\n    \n    while True:\n        n = int(f_i.readline())\n        if n == 0:\n            break\n        \n        cubes = tuple(tuple(f_i.readline().split()) for i in range(n))\n        \n        if n == 1:\n            print(0)\n            continue\n        \n        cube1 = cubes[0]\n        cubes = cubes[1:]\n        \n        cnt = 6 * (n - 1)\n        for tpl in product(indices, repeat=n-1):\n            tmp = 0\n            for idx, color1 in zip(zip(*tpl), cube1):\n                d = {color1: 1}\n                for c, i in zip(cubes, idx):\n                    color = c[i]\n                    if color in d:\n                        d[color] += 1\n                    else:\n                        d[color] = 1\n                tmp += n - max(d.values())\n                if tmp >= cnt:\n                    break\n            else:\n                cnt = tmp\n        \n        print(cnt)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def rotateX(dice):\n    d1, d2, d3, d4, d5, d6 = dice\n    return [d2, d6, d3, d4, d1, d5]\n\n\ndef rotateY(dice):\n    d1, d2, d3, d4, d5, d6 = dice\n    return [d4, d2, d1, d6, d5, d3]\n\n\ndef rotateZ(dice):\n    d1, d2, d3, d4, d5, d6 = dice\n    return [d1, d3, d5, d2, d4, d6]\n\n\ndef check():\n    global n, s_count\n    diff = [[0 for i in range(s_count)] for j in range(6)]\n    for dice in color_list[:-1]:\n        for i in range(6):\n            if color_list[-1][i] != dice[i]:\n                diff[i][dice[i]] += 1\n    count = 0\n\n    for c in diff:\n        c_max = max(c)\n        c_sum = sum(c)\n        if n - c_max < c_sum:\n            count += n - c_max\n        else:\n            count += c_sum\n\n    return count\n\n\ndef solve(i):\n    global ans\n    if i == len(color_list) - 1:\n        count = check()\n        if ans > count:\n            ans = count\n    else:\n        dice_memo = []\n        for x in range(4):\n            temp_dice = rotateX(color_list[i])\n            for y in range(4):\n                temp_dice = rotateY(temp_dice)\n                for z in range(4):\n                    temp_dice = rotateZ(temp_dice)\n                    color_list[i] = temp_dice\n                    if color_list[i] in dice_memo:\n                        continue\n                    dice_memo.append(color_list[i])\n                    solve(i + 1)\n\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n\n    memo = {}\n    s_count = 0\n    color_list = [[0 for j in range(6)] for i in range(n)]\n    for i in range(n):\n        for j, s in enumerate(input().split(\" \")):\n            if s not in memo:\n                color_list[i][j] = memo.setdefault(s, s_count)\n                s_count += 1\n            else:\n                color_list[i][j] = memo[s]\n\n    if n == 1:\n        print(0)\n        continue\n    ans = float(\"inf\")\n    solve(0)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from itertools import product\n    from sys import stdin\n    f_i = stdin\n\n    # idices of faces\n    indices = ((0, 1, 2, 3, 4, 5), (0, 2, 4, 1, 3, 5),\n               (0, 4, 3, 2, 1, 5), (0, 3, 1, 4, 2, 5),\n               (1, 0, 3, 2, 5, 4), (1, 3, 5, 0, 2, 4),\n               (1, 5, 2, 3, 0, 4), (1, 2, 0, 5, 3, 4),\n               (2, 0, 1, 4, 5, 3), (2, 1, 5, 0, 4, 3),\n               (2, 5, 4, 1, 0, 3), (2, 4, 0, 5, 1, 3),\n               (3, 0, 4, 1, 5, 2), (3, 4, 5, 0, 1, 2),\n               (3, 5, 1, 4, 0, 2), (3, 1, 0, 5, 4, 2),\n               (4, 0, 2, 3, 5, 1), (4, 2, 5, 0, 3, 1),\n               (4, 5, 3, 2, 0, 1), (4, 3, 0, 5, 2, 1),\n               (5, 1, 3, 2, 4, 0), (5, 3, 4, 1, 2, 0),\n               (5, 4, 2, 3, 1, 0), (5, 2, 1, 4, 3, 0))\n\n    while True:\n        n = int(f_i.readline())\n        if n == 0:\n            break\n\n        cubes = tuple(tuple(f_i.readline().split()) for i in range(n))\n\n        if n == 1:\n            print(0)\n            continue\n\n        cube1 = cubes[0]\n        cubes = cubes[1:]\n\n        cnt = 6 * (n - 1)\n        for tpl in product(indices, repeat=n-1):\n            tmp = 0\n            for idx, color1 in zip(zip(*tpl), cube1):\n                d = {color1: 1}\n                for c, i in zip(cubes, idx):\n                    color = c[i]\n                    if color in d:\n                        d[color] += 1\n                    else:\n                        d[color] = 1\n                tmp += n - max(d.values())\n                if tmp >= cnt:\n                    break\n            else:\n                cnt = tmp\n\n        print(cnt)\n\nif __name__ == '__main__':\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\n# 回転方法の全列挙\ndef turn(box):\n    turnlist = []\n    for j in range(4):\n        for i in range(4):\n            turnlist.append(box)\n            box = [box[0], box[3], box[1], box[4], box[2], box[5]]\n        box = [box[3], box[1], box[0], box[5], box[4], box[2]]\n    box = [box[1], box[5], box[2], box[3], box[0], box[4]]\n    for j in range(2):\n        for i in range(4):\n            turnlist.append(box)\n            box = [box[0], box[3], box[1], box[4], box[2], box[5]]\n        box = [box[0], box[3], box[1], box[4], box[2], box[5]]\n        box = [box[5], box[4], box[2], box[3], box[1], box[0]]\n\n    return turnlist\n\n# 回転した先がどれだけ一致しているかどうかの確認\ndef solve():\n    ans = float('inf')\n    if n == 1:\n        return 0\n\n    for d1 in turn(color[0]):\n        if n > 2:\n            for d2 in turn(color[1]):\n                if n > 3:\n                    for d3 in turn(color[2]):\n                        tmp = 0\n                        for num in range(6):\n                            tmp += fourcheck([d1[num], d2[num], d3[num], color[3][num]])\n                        ans = min(ans, tmp)\n                else:\n                    tmp = 0\n                    for num in range(6):\n                        tmp += threecheck(d1[num], d2[num], color[2][num])\n                    ans = min(ans, tmp)\n        else:\n            tmp = 0\n            for num in range(6):\n                if color[1][num] != d1[num]:\n                    tmp += 1\n            ans = min(tmp, ans)\n    return ans\n\n# 3つの時のチェック\ndef threecheck(a, b, c):\n    if a == b and b == c:\n        return 0\n    if a == b or b == c or c == a:\n        return 1\n    return 2\n\n# 4つの時のチェック\ndef fourcheck(dlist):\n    tdict = {}\n    for check in dlist:\n        if check not in tdict:\n            tdict[check] = 0\n        tdict[check] += 1\n\n    if max(tdict.values()) == 4:\n        return 0\n    if max(tdict.values()) == 3:\n        return 1\n    if max(tdict.values()) == 2:\n        return 2\n    return 3\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n\n    color = [input().split() for i in range(n)]\n    colordict = dict()\n\n    tmp = 0\n    for i in range(n):\n        for j in range(6):\n            if color[i][j] not in colordict.keys():\n                colordict[color[i][j]] = tmp\n                tmp += 1\n            color[i][j] = colordict[color[i][j]]\n    print(solve())\n\n"
  }
]