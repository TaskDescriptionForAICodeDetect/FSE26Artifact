[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint h(char c){\n  return (int)c-'0';\n}\n\nint n;\nstring input;\nint vis[1<<10];\nvector<int> g[1<<10];\n\nbool dfs(int v){\n  vis[v]=1;\n  rep(i,g[v].size()){\n    int nv=g[v][i];\n    if(vis[nv]==1)return false;\n    if(vis[nv]==0&&!dfs(nv))return false;\n  }\n  vis[v]=2;\n  return true;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,1<<10)g[i].clear();\n    cin>>input;\n    vector<string> s;\n    int l=0;\n    rep(i,n){\n      if(input[i]=='u'){\n        s.pb(input.substr(l,i-l));\n        l=i+1;\n      }\n    }\n    bool ok=true;\n    n=s.size();\n    rep(i,n){\n      int len=s[i].length();\n      bool used[10];\n      memset(used,0,sizeof(used));\n      rep(j,len){\n        if(used[h(s[i][j])])ok=false;\n        else used[h(s[i][j])]=true;\n      }\n    }\n    if(!ok){\n      cout<<\"UNSAFE\"<<endl;\n      continue;\n    }\n    rep(i,n){\n      int len=s[i].length();\n      int nS=1<<h(s[i][0]);\n      repl(j,1,len){\n        rep(S,1<<10){\n          if((S&nS)==0&&((S>>h(s[i][j]))&1)==1){\n            g[nS].pb(S);\n          }\n        }\n        nS|=(1<<h(s[i][j]));\n      }\n    }\n    memset(vis,0,sizeof(vis));\n    rep(S,1<<10){\n      if(vis[S]==0&&!dfs(S))ok=false;\n    }\n    if(ok)cout<<\"SAFE\"<<endl;\n    else cout<<\"UNSAFE\"<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define stop char nyaa;cin>>nyaa;\nconst ll mod = 1000000007;\ntypedef pair<int, int> P;\n\nint n;\nstring s;\n\nvoid solve() {\n\tcin >> s;\n\tvector<int> v(n+1);\n\t{\n\t\tint cur = 0;\n\t\trep(i, n) {\n\t\t\tif (s[i] == 'u') {\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = s[i] - '0';\n\t\t\t\tif (cur&(1 << t)) {\n\t\t\t\t\tcout << \"UNSAFE\" << endl; return;\n\t\t\t\t}\n\t\t\t\tcur ^= (1 << t);\n\t\t\t}\n\t\t\tv[i+1] = cur;\n\t\t}\n\t}\n\tvector<int> a[10];\n\trep(i, n) {\n\t\tif (s[i] != 'u') {\n\t\t\tint t = s[i] - '0';\n\t\t\ta[t].push_back(v[i]);\n\t\t}\n\t}\n\trep(i, 10) {\n\t\tsort(a[i].begin(), a[i].end());\n\t\ta[i].erase(unique(a[i].begin(), a[i].end()), a[i].end());\n\t}\n\trep(i, 1024) {\n\t\tvector<int> c;\n\t\trep(j, 10) {\n\t\t\tif (i&(1 << j))c.push_back(j);\n\t\t}\n\t\tif (c.size() < 2)continue;\n\t\tint ss = 0;\n\t\trep(j, c.size())ss ^= (1 << c[j]);\n\t\tbitset<1024> dp=0;\n\t\tdp[0] = true;\n\t\trep(j, c.size()) {\n\t\t\tint id = c[j];\n\t\t\trep(l, 1024) {\n\t\t\t\tif (!dp[l])continue;\n\t\t\t\trep(k, a[id].size()) {\n\t\t\t\t\tif (l&a[id][k])continue;\n\t\t\t\t\tdp[l + a[id][k]] = true;\n\t\t\t\t\tif (((l + a[id][k])&ss) == ss) {\n\t\t\t\t\t\tcout << \"UNSAFE\" << endl; return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"SAFE\" << endl; return;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (cin >> n, n) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <set>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<set<int> > > tu;\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    set<int> se;\n    a.assign(n+1,10);\n    tu.assign(10,vector<set<int> >(10,se));\n    char s;\n    en=0;\n    a[0]=10;\n    int ss=0;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        if(a[t-1]!=10){\n          tu[a[t-1]][a[t]].insert(ss);\n          ss=ss|mm(a[t-1]);\n          if((ss&mm(a[t]))!=0){\n            en=1;\n          }\n        }\n        else{\n          ss=0;\n        }\n        t++;\n      }\n      else{\n        ss=0;\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n\n/*    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }*/\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()){\n      if((f&mm(t))==0){\n        next(t,f,route);\n      }\n      else{\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        /*int q=0;\n        for(q=0;q<int(route.size())&&route[q]!=t;q++){\n        }\n        if(q>0){\n          route.erase(route.begin(),route.begin()+q-1);\n        }*/\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        /*else{\n          for(int z=0;(z<int(route.size())-1)&&en!=1;z++){\n            for(int w=z+1;(w<int(route.size())-1)&&en!=1;w++){\n              for(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end()&&en==0;++x){\n                for(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end()&&en==0;++y) {\n                  if((*x&*y)==0){\n                    en=1;\n                  }\n                }\n              }\n            }\n          }\n        }*/\n        //printf(\"V=%d,T=%d\\n\",v,t);\n      }\n    }\n  }\n}\n/*\nfor(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end();++x){\nfor(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end();++y) {\n  if((*x&*y)==0){\n    en=1;\n  }\n}\n}*/\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n\nその前にrouteのかぶり\n//自分とのかぶりはバツ\n共通のかぶりバツ\nその上条件に適した組みが一つ以上ある\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nvoid print(int a){\n\trep(i,10){\n\t\tcout << (bool)(a&(1<<i));\n\t}\n\tcout << endl;\n}\n\nvoid nex(int &n, int mask){\n\tn += 1;\n\twhile( n & mask ){\n\t\tn += n&mask;\n\t}\n}\nvoid nex(pii &p, int mask){\n\tint n = p.X;\n\tn += 1;\n\twhile( n & ~mask ){\n\t\tn += n&~mask;\n\t}\n\tp.X = n;\n\tp.Y = mask ^ n;\n}\n\nint main(){\n//\t\tint a = 6;\n//\t\tcout << \"a=\" << a << endl;\n//\t\tprint(a);\n//\t\tfor(int b=0; b<32; nex(b,a)) print(b);\n//\t\tcout << endl;\n//\t\treturn 0;\n\n\tint n;\n\twhile(cin >> n, n){\n\t\tbool ans = true;\n\t\tstring s;\n\t\tcin >> s;\n\t\t\n\t\t//bool memo[1<<10][1<<10] = {};\n\t\tset<int> memo[1<<10];\n\t\tint st=0;\n\t\tfor(auto c: s){\n\t\t\tif( c == 'u' ){\n\t\t\t\tst = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint k = c - '0';\n\t\t\tint nx = (1<<k);\n\t\t\tif( st & nx ) ans = false;\n\t\t\t//memo[st][nx] = true;\n\t\t\tmemo[st].insert( nx );\n\t\t\tst |= nx;\n\t\t}\n\n\t\trep(n,1<<10) for(pii p={0,0}; p.X<(1<<10); nex(p,n)){\n\t\t\tint a = p.X;\n\t\t\tint b = p.Y;\n\t\t\tif(a&&b) for(auto x: memo[a]) for(auto y: memo[b]){\n\t\t\t\t//if( a & b ) continue;\n\t\t\t\t//int x = memo[a];\n\t\t\t\t//int y = memo[b];\n\t\t\t\t//if( (b&x) && (a&y) ) ans = false;\n\t\t\t\t//memo[ a|b ][ x|y ] = true;\n\t\t\t\tmemo[ a|b ].insert( x|y );\n\t\t\t}\n\t\t\tif( p.X == n ) break;\n\t\t}\n\n\t\trep(a,1<<10) for(auto x: memo[a]){\n\t\t\tif( (a&x) == x ) ans = false;\n\t\t}\n\n\t\tcout << (ans ? \"SAFE\" : \"UNSAFE\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nvoid print(int mask,int to){\n\tfor(int i=0;i<10;i++){\n\t\tif((mask>>i)&1)cout << 1;\n\t\telse cout << 0;\n\t}\n\tcout << ' ' << to << endl;\n}\nstruct Data{\n\tint mask;\n\tint want;\n\tData(){}\n\tData(int mask,int want):mask(mask),want(want){}\n};\nint N;\nstring S;\nvector<Data> vec;\nbool used[12];\nbool f[1<<10][10];\nbool solve() {\t\n\tcin >> N;\n\tif(N==0)return false;\n\tcin >> S;\n\tmemset(f,false,sizeof(f));\n\tvec.clear();\n\tmemset(used,false,sizeof(used));\n\tint mask = 0;\n\tfor(int i=0;i<N;i++){\n\t\tif(S[i]=='u'){\n\t\t\tmask = 0;\n\t\t\tmemset(used,false,sizeof(used));\n\t\t}else{\n\t\t\tint idx = S[i]-'0';\n\t\t\tif((mask>>idx)&1){\n\t\t\t\tcout << \"UNSAFE\" << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(mask!=0&&!f[mask][idx]){\n\t\t\t\tvec.pb(Data(mask,idx));\n\t\t\t\tf[mask][idx]=true;\n\t\t\t\t//print(mask,idx);\n\t\t\t}\n\t\t\tmask |= (1<<idx);\n\t\t}\n\t}\n\tint pre = 0;\n\twhile(1){\n\t\tint cnt=0;\n\t\tint cur_size = vec.size();\n\t\tfor(int i=0;i<cur_size;i++){\n\t\t\tfor(int j=((i<pre)?pre:0);j<cur_size;j++){\n\t\t\t\tif((vec[i].mask&vec[j].mask)!=0)continue;\n\t\t\t\tif((vec[j].mask>>vec[i].want)&1){\n\t\t\t\t\tint nmask = vec[j].mask|vec[i].mask;\n\t\t\t\t\tint nwant = vec[j].want;\n\t\t\t\t\tif(!f[nmask][nwant]){\n\t\t\t\t\t\tvec.pb(Data(nmask,nwant));\n\t\t\t\t\t\tf[nmask][nwant]=true;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t//print(nmask,nwant);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpre = cur_size;\n\t\tif(cnt==0)break;\n\t}\n\tfor(int i=0;i<vec.size();i++){\n\t\tif((vec[i].mask>>vec[i].want)&1){\n\t\t\tcout << \"UNSAFE\" << endl;\n\t\t\treturn true;\n\t\t}\n\t}\n\tcout << \"SAFE\" << endl;\n\treturn true;\n}\n\nint main() {\n\twhile (solve());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n#define ALL(x)      begin(x),end(x)\n\nusing namespace std;\nusing vecint = vector<int>;\nusing ll = int64_t;\n\nint main()\n{\n  while(1) {\n    int n;\n    cin>>n;\n    if(!n) break;\n    string s;\n    cin>>s;\n    uint32_t l = 0;\n    vector<uint32_t> p(1024);\n    bool ok = true;\n    REP(i,n-1) {\n      if (isdigit(s[i])) {\n        l |= 1 << (s[i] - '0');\n      } else {\n        l = 0;\n      }\n      if (!isdigit(s[i+1])) continue;\n      int next = s[i+1] - '0';\n      if ((l >> next) & 1) ok = false;\n      p[l] |= 1 << next;\n    }\n    REP(i,1<<10) {\n      for(int u = (1 << 10) - 1; u >= 0; --u) {\n        u &= i;\n        uint32_t v = i ^ u;\n        if (!u || !v) continue;\n        if (p[v] & u) {\n          if (p[u] & v) {\n            ok = false;\n          } else {\n            p[i] |= p[u];\n          }\n        } else if (p[u] & v) {\n          p[i] |= p[v];\n        }\n      }\n    }\n    if (ok) {\n      cout << \"SAFE\" << endl;\n    } else {\n      cout << \"UNSAFE\" << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<int, int> PP;\n\n\nint N;\nchar S[10010];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tscanf(\"%s\", S);\n\t\tset<PP> pat1, pat2;\n\t\t\n\t\tint prev = 0;;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(S[i] == 'u'){\n\t\t\t\tprev = 0;\n\t\t\t}else{\n\t\t\t\tint mask = 1 << (S[i] - '0');\n\t\t\t\tpat1.insert(make_pair(prev, mask));\n\t\t\t\tprev |= mask;\n\t\t\t}\n\t\t}\n\t\tvector<PP> tmp;\n\t\tint bsize;\n\t\tdo{\n\t\t\tbsize = pat1.size();\n\t\t\ttmp.clear();\n\t\t\tfor(auto v1 : pat1){\n\t\t\t\tfor(auto v2 : pat1){\n\t\t\t\t\tif((v1.first & v2.first) == 0 && (v1.first & v2.second) != 0){\n\t\t\t\t\t\ttmp.push_back(make_pair(v1.first | v2.first, v1.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto v : tmp){\n\t\t\t\tpat1.insert(v);\n\t\t\t}\n\t\t}while(bsize != pat1.size());\n\n\t\tbool flg = true;\n\t\tfor(auto v : pat1){\n\t\t\tif((v.first & v.second) != 0){\n\t\t\t\tflg = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flg){\n\t\t\tprintf(\"SAFE\\n\");\n\t\t}else{\n\t\t\tprintf(\"UNSAFE\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 10001\n\nstruct Info{\n\tInfo(int arg_have_lock,int arg_next){\n\t\thave_lock = arg_have_lock;\n\t\tnext = arg_next;\n\t}\n\tint have_lock,next;\n};\n\nint POW[11];\nint length;\nbool check[1024][10];\nchar buf[NUM];\nvector<Info> V;\n\n\nvoid func(){\n\n\tfor(int i = 0; i < POW[10]; i++){\n\t\tfor(int k = 0; k < 10; k++)check[i][k] = false;\n\t}\n\n\tscanf(\"%s\",buf);\n\n\tint have_lock = 0,next;\n\tV.clear();\n\n\tfor(int i = 0; i < length; i++){\n\n\t\tif(buf[i] == 'u'){\n\n\t\t\thave_lock = 0;\n\n\t\t}else{\n\n\t\t\tnext = buf[i]-'0';\n\n\t\t\tif(have_lock & (POW[next])){\n\t\t\t\tprintf(\"UNSAFE\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!check[have_lock][next]){\n\t\t\t\tV.push_back(Info(have_lock,next));\n\t\t\t\tcheck[have_lock][next] = true;\n\t\t\t}\n\t\t\thave_lock += POW[next];\n\t\t}\n\t}\n\n\tvector<Info> ADD;\n\tint new_have_lock,new_next;\n\tbool FLG;\n\n\twhile(true){\n\n\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\tfor(int k = 0; k < V.size(); k++){\n\n\t\t\t\tif(i == k || (V[i].have_lock & V[k].have_lock) != 0)continue;\n\n\t\t\t\tif((POW[V[i].next] & V[k].have_lock) != 0 && (POW[V[k].next] & V[i].have_lock) != 0){\n\t\t\t\t\tprintf(\"UNSAFE\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tFLG = false;\n\n\t\t\t\tif((POW[V[i].next] & V[k].have_lock) != 0 && (POW[V[k].next] & V[i].have_lock) == 0){\n\n\t\t\t\t\tnew_next = V[k].next;\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t}else if((POW[V[k].next] & V[i].have_lock) != 0 && (POW[V[i].next] & V[k].have_lock) == 0){\n\n\t\t\t\t\tnew_next = V[i].next;\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\n\t\t\t\tif(FLG){\n\t\t\t\t\tnew_have_lock = V[i].have_lock|V[k].have_lock;\n\t\t\t\t\tif(!check[new_have_lock][new_next]){\n\t\t\t\t\t\tADD.push_back(Info(new_have_lock,new_next));\n\t\t\t\t\t\tcheck[new_have_lock][new_next] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ADD.size() == 0)break;\n\n\t\tfor(int i = 0; i < ADD.size(); i++){\n\t\t\tV.push_back(ADD[i]);\n\t\t}\n\t\tADD.clear();\n\t}\n\n\tprintf(\"SAFE\\n\");\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d\",&length);\n\t\tif(length == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> e[11][11];\nvector<int> G[11];\nint visit[11];\n\nvoid dfs(int u,int& id,vvi& route,vi& hoge)\n{\n    visit[u] = id++;\n    rep(i,len(G[u])){\n        if(visit[G[u][i]] != -1 && visit[G[u][i]] <= visit[u]){\n            vi ag;\n            rep(j,len(hoge)){\n                if(hoge[j] == G[u][i]){\n                    for(;j<len(hoge);j++){\n                        ag.pb(hoge[j]);\n                    }\n                }\n            }\n            ag.pb(u);\n            route.pb(ag);\n        }else{\n            hoge.pb(u);\n            dfs(G[u][i],id,route,hoge);\n            hoge.pop_back();\n        }\n    }\n}\n\nint main()\n{\n    // cin.tie(0);\n    // ios::sync_with_stdio(false);ccccc\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        string s;\n        cin >> s;\n        int kp = 0;\n        bool end = false;\n        rep(i,10){\n            rep(j,10){\n                e[i][j].clear();\n            }\n        }\n        rep(i,10){\n            G[i].clear();\n            visit[i] = -1;\n        }\n        rep(i,len(s)){\n            if(s[i] == 'u'){\n                kp = 0;\n            }else if(kp & (1 << (int)(s[i]-'0'))){\n                cout << \"UNSAFE\\n\";\n                end = true;\n                break;\n            }else{\n                kp |= (1 << (int)(s[i]-'0'));\n            }\n        }\n        if(end){\n            continue;\n        }\n        kp = 0;\n        rep(i,len(s)-1){\n            if(s[i] != 'u'){\n                if(s[i+1] != 'u'){\n                    int a = (int)(s[i]-'0'),b = (int)(s[i+1]-'0');\n                    e[a][b].pb(kp);\n                    kp |= (1 << (int)(s[i]-'0'));\n                }\n            }else{\n                kp = 0;\n            }\n        }\n        rep(i,10){\n            rep(j,10){\n                if(len(e[i][j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        rep(i,10){\n            if(visit[i] == -1){\n                vvi route;\n                vi hoge;\n                int id = 0;\n                dfs(i,id,route,hoge);\n                // rep(i,len(route)){\n                //     svec(route[i]);\n                // }\n                rep(j,len(route)){\n                    int loop = len(route[j]);\n                    vvi vec(loop);\n                    rep(k,len(route[j])){\n                        int a = route[j][k],b = route[j][(k+1)%loop];\n                        vec[k] = e[a][b];\n                        // if(len(vec[k])==0){\n                        //     svec(route[j]);\n                        //     cout << a << \" \" << b << \"\\n\";\n                        // }\n                    }\n                    set<int> dp[11];\n                    dp[0].insert(0);\n                    rep(j,loop){\n                        each(k,dp[j]){\n                            rep(l,len(vec[j])){\n                                if(!(k & vec[j][l])){\n                                    dp[j+1].insert(k|vec[j][l]);\n                                }\n                            }\n                        }\n                    }\n                    if(len(dp[loop])){\n                        cout << \"UNSAFE\\n\";\n                        end = true;\n                        break;\n                    }\n                }\n                if(end){\n                    break;\n                }\n            }\n        }\n        if(!end){\n            cout << \"SAFE\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    string str;\n    bool dp[1<<10][10];  // dp[S][t] = ロックしている数の集がSで次にロックする数がtのみである場合が存在するか\n    while(cin >> n, n){\n        cin >> str;\n        for(int i=0; i<(1<<10); ++i) fill(dp[i], dp[i]+10, false);\n        int S = 0, t;  // S=ロックの集合, t=次の数\n        bool ok = true;\n        for(int i=0; i<n; ++i){\n            if(str[i] == 'u'){\n                S = 0;\n            } else {\n                t = str[i]-'0';\n                dp[S][t] = true;\n                if((S>>t)&1) ok = false;\n                S |= 1<<t;\n            }\n        }\n        // 複数のスレッドをマージする\n        for(int S1=0; S1<(1<<10); ++S1){\n            for(int S2=0; S2<(1<<10); ++S2){\n                if(S1 & S2) continue;  // このようなスレッドはともに存在しない\n                for(int t1=0; t1<10; ++t1){\n                    for(int t2=0; t2<10; ++t2){\n                        if(dp[S1][t1] && dp[S2][t2]){\n                            if(((S1>>t2)&1) && ((S2>>t1)&1)) ok = false;  // デッドロック発生\n                            // 一方が停止しているならばまとめてよい\n                            if((S1>>t2)&1) dp[S1|S2][t1] = true;\n                            if((S2>>t1)&1) dp[S1|S2][t2] = true;\n                        }\n                    }\n                }\n            }\n        }\n        cout << (ok ? \"SAFE\" : \"UNSAFE\" ) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <cinttypes>\n#include <set>\n\nusing namespace std;\n\n\nstruct State {\n  int locked;\n  int get;\n  State(): locked(0), get(-1) { }\n};\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n\n    string str;\n    cin >> str;\n    string ans = \"SAFE\";\n\n    int bits = 0;\n    for (int i = 0; i < n; i++) {\n      if (str[i] == 'u') {\n        bits = 0;\n      } else {\n        if (bits & (1 << (str[i] - '0'))) {\n          ans = \"UNSAFE\";\n        } \n        bits |= (1 << (str[i] - '0'));\n      }\n    }\n\n    vector<State> vec;\n    State s;\n    for (int i = 0; i < n; i++) {\n      if (str[i] != 'u') {\n        if (s.get != -1) {\n          s.locked |= (1 << s.get);\n        }\n        s.get = str[i] - '0';\n      } else {\n        s.locked = 0;\n        s.get = -1;\n      }\n      vec.push_back(s);\n    }\n\n    vector<State> vec2;\n    for (int i = 0; i < vec.size(); i++) {\n      for (int j = i + 1; j < vec.size(); j++) {\n        State s1 = vec[i];\n        State s2 = vec[j];\n        if ((s1.locked & s2.locked) == 0) {\n          if (s1.locked & (1 << s2.get)) {\n            State t;\n            t.locked = s1.locked | s2.locked;\n            t.get = s1.get;\n            vec2.push_back(t);\n          }\n        }\n      }\n    }\n\n    for (auto e : vec2) {\n      vec.push_back(e);\n    }\n\n\n    for (int i = 0; i < vec.size(); i++) {\n      for (int j = i + 1; j < vec.size(); j++) {\n        if ((vec[i].locked & vec[j].locked) == 0) {\n          if ((vec[i].locked & (1 << vec[j].get)) && (vec[j].locked & (1 << vec[i].get))) {\n            ans = \"UNSAFE\";\n          }\n        }\n      }\n    }\n\n    cout << ans << endl;\n\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> b(1);      //何番目の命令を実行しているか 0-9 ->1-n 初期値0\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<vector<int> > > tu(1,vector<vector<int> >(1,vector<int>(1,0)));\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    a.assign(n+1,10);\n    b.assign(10,0);\n    tu.assign(10,vector<vector<int> >(10,vector<int>(0,0)));\n    char s;\n    int e=0;\n    en=0;\n    a[0]=10;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        e=e|mm(s-'0');\n        t++;\n      }\n      else{\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n    int ss=0;\n    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()){\n      if((f&mm(t))==0){\n        next(t,f,route);\n      }\n      else{\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          int d=0;\n          for(int z=0;(z<int(route.size())-1)&&d!=1;z++){\n            for(int w=0;(w<int(route.size())-1)&&d!=1;w++){\n              if(z!=w){\n                for(int x=0;(x<int(tu[route[z]][route[z+1]].size()))&&d!=1;x++){\n                  for(int y=0;(y<int(tu[route[w]][route[w+1]].size()))&&d!=1;y++){\n                    if((tu[route[z]][route[z+1]][x]&tu[route[w]][route[w+1]][y])==0){\n                      d=1;\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if(d==1){\n            en=1;\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n      }\n    }\n  }\n}\n\n\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> b(1);      //何番目の命令を実行しているか 0-9 ->1-n 初期値0\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<vector<int> > > tu(1,vector<vector<int> >(1,vector<int>(1,0)));\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    a.assign(n+1,10);\n    b.assign(10,0);\n    tu.assign(10,vector<vector<int> >(10,vector<int>(0,0)));\n    char s;\n    int e=0;\n    en=0;\n    a[0]=10;\n    int ss=0;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        e=e|mm(s-'0');\n        if(a[t-1]!=10){\n          tu[a[t-1]][a[t]].push_back(ss);\n          ss=ss|mm(a[t-1]);\n        }\n        else{\n          ss=0;\n        }\n        t++;\n      }\n      else{\n        ss=0;\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n\n/*    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }*/\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()){\n      if((f&mm(t))==0){\n        next(t,f,route);\n      }\n      else{\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          int d=0;\n          for(int z=0;(z<int(route.size())-1)&&d!=1;z++){\n            for(int w=0;(w<int(route.size())-1)&&d!=1;w++){\n              if(z!=w){\n                for(int x=0;(x<int(tu[route[z]][route[z+1]].size()))&&d!=1;x++){\n                  for(int y=0;(y<int(tu[route[w]][route[w+1]].size()))&&d!=1;y++){\n                    if((tu[route[z]][route[z+1]][x]&tu[route[w]][route[w+1]][y])==0){\n                      d=1;\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if(d==1){\n            en=1;\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n      }\n    }\n  }\n}\n\n\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[1<<10][1<<10];\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    string s;\n    cin>>s;\n    memset(dp,0,sizeof(dp));\n    vector<vector<Int> > sp(1<<10);\n    dp[0][0]=1;\n    sp[0].emplace_back(0);\n    bool flg=0;\n    for(Int i=0;i<n;i++){\n      if(s[i]=='u') continue;\n      Int b=0;\n      while(s[i+1]!='u'){\n\tb|=1<<(s[i]-'0');\n\tInt ne=1<<(s[i+1]-'0');\n\tif(b&ne) flg=1;\n\tif(flg) break;\n\tfor(Int x=(1<<10)-1;x>=0;x--){\n\t  if(x&b) continue;\n\t  if(sp[x].empty()) continue;\n\t  \n\t  //using BS = bitset<10>;\n\t  \n\t  for(Int y:sp[x]){\n\t    //cout<<BS(x)<<\" \"<<BS(y)<<\":\"<<BS(b)<<\" \"<<BS(ne)<<endl;\n\t    //if((x&ne)&&((y|b)==b)) cout<<x<<\" \"<<y<<endl;\n\t    \n\t    if((x&ne)&&((y|b)==b)) flg=1;\n\t    int nx=x|b,ny=y|ne;\n\t    if((y&b)==b) ny^=b;\n\t    if(!dp[nx][ny]){\n\t      dp[nx][ny]=1;\n\t      sp[nx].emplace_back(ny);\n\t    }\n\t    if(flg) break;\n\t  }\n\t  if(flg) break;\n\t}\n\ti++;\n      }\n      Int ne=1<<(s[i]-'0');\n      if(b&ne) flg=1;\n      if(flg) break;\n    }\n    cout<<(flg?\"UNSAFE\":\"SAFE\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nvector<string> parse(const string &s) {\n  vector<string> ret;\n  string buf;\n  REP(i,s.size()) {\n    if(s[i] == 'u') {\n      ret.push_back(buf);\n      buf.clear();\n    }\n    else {\n      buf += s[i];\n    }\n  }\n  return ret;\n}\nvector<pair<int, int>> toStates(const vector<string> &ops) {\n  vector<pair<int, int>> states;\n  for(const string &op : ops) {\n    // DEBUG(op);\n    int locked = 0;\n    for(char c : op) {\n      states.emplace_back(locked, c - '0');\n      locked |= (1 << (c - '0'));\n    }\n  }\n  return states;\n}\nbool contains(int A, int B) {\n  // A contains B\n  while(B > 0) {\n    if(B & 1) {\n      if((A & 1) == 0) return false;\n    }\n    A >>= 1;\n    B >>= 1;\n  }\n  return true;\n}\nbool noIntersect(int A, int B) {\n  return (A & B) == 0;\n}\ntemplate <class T> void shrink(vector<T> &v) {\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    int N; cin >> N;\n    if(N == 0) break;\n    string S; cin >> S;\n    vector<string> ops = parse(S);\n    vector<pair<int, int>> states = toStates(ops);\n    shrink(states);\n    bool unsafe = false;\n    while(!unsafe) {\n      bool update = false;\n      vector<pair<int, int>> add;\n#if 0\n      cerr << \"@@\" << endl;\n      for(const auto &state : states) {\n        cerr << \"[\";\n        for(int i = 0; i < 10; ++i) {\n          if((state.first >> i) & 1) cerr << i;\n        }\n        cerr << \"]\";\n        cerr << \" \" << state.second << endl;\n      }\n#endif\n      REP(i,states.size()) {\n        if((states[i].first >> states[i].second) & 1) unsafe = true;\n        REP(j,states.size()) {\n          if(noIntersect(states[i].first, states[j].first)) {\n            if((states[i].first & (1 << states[j].second)) && (states[j].first & (1 << states[i].second))) {\n              unsafe = true;\n            }\n            else if((states[i].first & (1 << states[j].second)) == 0 && (states[j].first >> states[i].first) & 1) {\n              auto p = make_pair(states[i].first | states[j].first, states[j].second);\n              // cerr << \"[\";\n              // for(int k = 0; k < 10; ++k) {\n              //   if((p.first >> k) & 1) cerr << k;\n              // }\n              // cerr << \"]\";\n              // cerr << \" \" << p.second << endl;\n              if(binary_search(states.begin(), states.end(), p) == false) {\n#if 0\n                cerr << i << \" <-> \" << j << endl;\n#endif\n                update = true;\n                add.push_back(p);\n              }\n            }\n          }\n        }\n      }\n      if(!update) break;\n      states.insert(states.end(), add.begin(), add.end());\n      shrink(states);\n    }\n    cout << (unsafe ? \"UNSAFE\" : \"SAFE\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool solve(const string &s) {\n\tvector<vector<bool>> dp(1 << 10, vector<bool>(10, false));\n\tset<pair<int, int>> states;\n\n\tint S = 0;\n\tfor(const auto &c : s) {\n\t\tif(c == 'u') {\n\t\t\tS = 0;\n\t\t} else {\n\t\t\tconst int x = c - '0';\n\t\t\tif(S) {\n\t\t\t\tif(S & (1 << x)) return false;\n\t\t\t\tdp[S][x] = true;\n\t\t\t\tstates.emplace(S, x);\n\t\t\t}\n\t\t\tS |= 1 << x;\n\t\t}\n\t}\n\n\tfor(int lock = 1; lock < (1 << 10); ++lock) {\n\t\tfor(int want = 0; want < 10; ++want) {\n\t\t\tif(!dp[lock][want]) continue;\n\n\t\t\tconst int S_want = 1 << want;\n\t\t\tif(lock & S_want) return false;\n\n\t\t\tfor(const auto &e : states) {\n\t\t\t\tif((lock & e.first) == 0 && (S_want & e.first)) {\n\t\t\t\t\tdp[lock | e.first][e.second] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tcout << (solve(s) ? \"SAFE\" : \"UNSAFE\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dat[1<<10];\nint memo[1<<10][1<<10];\nint issafe(int mask, int succ){\n  if(memo[mask][succ] >= 0) return memo[mask][succ];\n  int& res = memo[mask][succ];\n  if(succ && (~mask & succ) == succ) return res = 0;\n  for(int bit=mask;bit;(bit-=(mask&-mask))&=mask){\n\tREP(i,10){\n\t  if(dat[bit]>>i&1){\n\t\tif(!issafe(mask^bit, succ|(1<<i))){\n\t\t  return res = 0;\n\t\t}\n\t  }\n\t}\n  }\n  return res = 1;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tstring S;\n\tcin >> S;\n\tfill(dat, dat+(1<<10), 0);\n\tfill((int*)memo, (int*)memo+(1<<20), -1);\n\tbool safe = true;\n\tint bit = 0;\n\tfor(int i=0;i<N;++i){\n\t  if(S[i] == 'u'){\n\t\tbit = 0;\n\t  }\n\t  else{\n\t\tint a = S[i] - '0';\n\t\tif(bit>>a&1){\n\t\t  safe = false;\n\t\t  break;\n\t\t}\n\t\tdat[bit] |= 1<<a;\n\t\tbit |= 1<<a;\n\t  }\n\t}\n\tif(!safe){\n\t  cout << \"UNSAFE\" << endl;\n\t  continue;\n\t}\n\tcout << (issafe((1<<10)-1, 0)?\"SAFE\": \"UNSAFE\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\n//\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n//\n\nvs ss;\nbool sw;\nint tran[] = { 1,2,4,8,16,32,64,128,256,512,1024 };\n\nvoid check(int used, int poss) {\n\tif (used != 0 && (used&poss) == poss) {\n\t\tsw = false;\n\t}\n}\n\nvoid red(int used, int poss, int t, int it) {\n\tif (!sw)return;\n\tcheck(used, poss);\n\tif (it == 0) {\n\t\tif (t<ss.size() - 1) red(used, poss, t + 1, 0);\n\n\t}\n\tif (it < ss[t].size()-1) {\n\t\tint nused;\n\t\tint nposs;\n\t\tif (!(tran[ss[t][it] - '0'] & used)) {\n\n\t\t\tnused = tran[ss[t][it] - '0'] + used;\n\t\t\tnposs = poss;\n\t\t\tif (!(tran[ss[t][it+1] - '0'] & poss)) {\n\t\t\t\tnposs += tran[ss[t][it+1] - '0'];\n\t\t\t}\n\t\t\tif(it)nposs -= tran[ss[t][it] - '0'];\n\t\t\tred(nused, nposs, t, it + 1);\n\t\t}\n\t}\n\tif (t<ss.size() - 1)red(used, poss, t + 1, 0);\n\n}\n\nvoid solve(int n) {\n\tstring s;\n\tsw = true;\n\tss.clear();\n\tcin >> s;\n\tint t = 0;\n\trep(i, n) {\n\t\tif (s[i] == 'u') {\n\t\t\tss.push_back(s.substr(t, i - t));\n\t\t\tt = i + 1;\n\t\t}\n\t}\n\n\tred(0, 0, 0, 0);\n\tcout << (sw ? \"SAFE\" : \"UNSAFE\") << endl;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tsolve(n);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> e[11][11];\nvector<int> G[11];\nbool visit[11];\nvector<int> dp[11];\n\nvoid dfs(int u,vvi& route,vi& hoge)\n{\n    visit[u] = true;\n    rep(i,len(G[u])){\n        if(visit[G[u][i]]){\n            vi ag;\n            rep(j,len(hoge)){\n                if(hoge[j] == G[u][i]){\n                    for(;j<len(hoge);j++){\n                        ag.pb(hoge[j]);\n                    }\n                }\n            }\n            ag.pb(u);\n            route.pb(ag);\n        }else{\n            hoge.pb(u);\n            dfs(G[u][i],route,hoge);\n            hoge.pop_back();\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        string s;\n        cin >> s;\n        int kp = 0;\n        bool end = false;\n        rep(i,10){\n            rep(j,10){\n                e[i][j].clear();\n            }\n        }\n        rep(i,10){\n            G[i].clear();\n            visit[i] = false;\n        }\n        rep(i,len(s)){\n            if(s[i] == 'u'){\n                kp = 0;\n            }else if(kp & (1 << (int)(s[i]-'0'))){\n                cout << \"UNSAFE\\n\";\n                end = true;\n                break;\n            }else{\n                kp |= (1 << (int)(s[i]-'0'));\n            }\n        }\n        if(end){\n            continue;\n        }\n        kp = 0;\n        rep(i,len(s)-1){\n            if(s[i] != 'u'){\n                if(s[i+1] != 'u'){\n                    int a = (int)(s[i]-'0'),b = (int)(s[i+1]-'0');\n                    e[a][b].pb(kp);\n                    kp |= (1 << (int)(s[i]-'0'));\n                }\n            }else{\n                kp = 0;\n            }\n        }\n        rep(i,10){\n            rep(j,10){\n                if(len(e[i][j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        rep(i,10){\n            if(!visit[i]){\n                vvi route;\n                vi hoge;\n                dfs(i,route,hoge);\n                // rep(i,len(route)){\n                //     svec(route[i]);\n                // }\n                rep(j,len(route)){\n                    int loop = len(route[j]);\n                    vvi vec(loop);\n                    rep(k,len(route[j])){\n                        int a = route[j][k],b = route[j][(k+1)%loop];\n                        vec[k] = e[a][b];\n                    }\n                    rep(j,loop+1){\n                        dp[j].clear();\n                    }\n                    dp[0].pb(0);\n                    rep(j,loop){\n                        rep(k,len(dp[j])){\n                            rep(l,len(vec[j])){\n                                if(!(dp[j][k] & vec[j][l])){\n                                    dp[j+1].pb(dp[j][k]|vec[j][l]);\n                                }\n                            }\n                        }\n                    }\n                    if(len(dp[loop])){\n                        cout << \"UNSAFE\\n\";\n                        end = true;\n                        break;\n                    }\n                }\n                if(end){\n                    break;\n                }\n            }\n        }\n        if(!end){\n            cout << \"SAFE\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?2e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,N=1<<10;\n\twhile(cin>>n,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\ts=\"u\"+s;\n\t\tqueue<pii>que;\n\t\tint used[1<<10][10]={0};\n\t\tint a=0;\n\t\tbool h=false;\n\t\trep(i,n){\n\t\t\tif(s[i+1]=='u'){\n\t\t\t\ta=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to=s[i+1]-'0';\n\t\t\tque.push(pii(a,to));\n\t\t\tused[a][to]=true;\n\t\t\tif(a&1<<to)h=true;\n\t\t\ta|=1<<to;\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tpii p=que.front();\n\t\t\tque.pop();\n\t\t\trep(i,N)rep(j,10){\n\t\t\t\tif(!used[i][j])continue;\n\t\t\t\tif(i&p.first)continue;\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<p.first<<\" \"<<p.second<<endl;\n\t\t\t\tif(i&1<<p.second&&p.first&1<<j)h=true;\n\t\t\t\telse if(i&1<<p.second){\n\t\t\t\t\tint A=i|p.first,B=j;\n\t\t\t\t\tif(!used[A][B]){\n\t\t\t\t\t\tused[A][B]=true;\n\t\t\t\t\t\tque.push({A,B});\n\t\t\t\t\t}\n\t\t\t\t}else if(p.first&1<<j){\n\t\t\t\t\tint A=i|p.first,B=p.second;\n\t\t\t\t\tif(!used[A][B]){\n\t\t\t\t\t\tused[A][B]=true;\n\t\t\t\t\t\tque.push({A,B});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!h)cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"UNSAFE\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double Double;\n\nbitset<1024> dp[1024];\n\nbitset<1024> masks[10];\nbitset<1024> inv_masks[10];\n\nbool f(string s) {\n    for (auto &c : s) if (c == 'u') c = ' ';\n    stringstream ss(s);\n\n    memset(dp, 0, sizeof(dp));\n    vector<string> vs;\n    string t;\n\n    while (ss >> t) vs.push_back(t);\n\n\n    set<pair<int, int> > itms;\n\n    for (auto t : vs) {\n        int lock = 0;\n        for (int i = 0; i < t.size(); i++) {\n            itms.insert({lock, t[i] - '0'});\n            if (lock >> (t[i] - '0') & 1) {\n                return false;\n            }\n            lock |= (1 << (t[i] - '0'));\n        }\n    }\n    dp[0][0] = true;\n\n    for (auto itm : itms) {\n        for (int locked = 0; locked < 1024; locked++) {\n            int new_locked = locked | itm.first;\n            if ((locked & itm.first) == 0) {\n                const int shift = (1 << itm.second);\n                bitset<1024> compress =\n                        (dp[locked]) | ((dp[locked] & masks[itm.second]) >> shift);\n                dp[new_locked] |= (compress & masks[itm.second]) | ((compress & inv_masks[itm.second]) << shift);\n            }\n        }\n    }\n    for (int i = 1; i < 1024; i++) {\n        int j = i;\n        while (j) {\n            if (dp[i][j]) {\n                return false;\n            }\n            j = (j-1) & i;\n        }\n    }\n    return true;\n}\n\nint main() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 1024; j++) {\n            masks[i][j] = j / (1 << i) % 2;\n            inv_masks[i][j] = !masks[i][j];\n        }\n    }\n    int n;\n    while (cin >> n && n) {\n        string s;\n        cin >> s;\n        cout << (f(s) ? \"SAFE\" : \"UNSAFE\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<vector<int>, int>;\n\nint main()\n{\n\tint n;\n\tstring s;\n\twhile (cin >> n, n) {\n\t\tcin >> s;\n\t\tvector<string> ss;\n\t\tbool res = false;\n\t\tint tmp = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == 'u') {\n\t\t\t\tss.push_back(s.substr(tmp, i - tmp));\n\t\t\t\ttmp = i + 1;\n\t\t\t}\n\t\t}\n\t\tif (tmp < n) {\n\t\t\tss.push_back(s.substr(tmp, n - tmp));\n\t\t}\n\t\tset<P> sss;\n\t\tfor (auto str : ss) {\n\t\t\tvector<int> v(10);\n\t\t\tfor (auto c : str) {\n\t\t\t\tsss.insert(P(v, c - '0'));\n\t\t\t\tif (v[c - '0']) {\n\t\t\t\t\tres = true;\n\t\t\t\t}\n\t\t\t\tv[c - '0'] = 1;\n\t\t\t}\n\t\t}\n\t\tif (res) {\n\t\t\tcout << \"UNSAFE\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int k = 1; k < 10; k++) {\n\t\t\tauto tmp = sss;\n\t\t\tfor (auto p1 : tmp) {\n\t\t\t\tfor (auto p2 : tmp) {\n\t\t\t\t\tbool f = false;\n\t\t\t\t\tvector<int> v(10);\n\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\tif (p1.first[i] && p2.first[i]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (p1.first[i] || p2.first[i]) {\n\t\t\t\t\t\t\tv[i] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) continue;\n\t\t\t\t\tif (p1.first[p2.second]) {\n\t\t\t\t\t\tsss.insert(P(v, p1.second));\n\t\t\t\t\t}\n\t\t\t\t\telse if (p2.first[p1.second]) {\n\t\t\t\t\t\tsss.insert(P(v, p2.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<P> se(sss.begin(), sss.end());\n\t\tint ko = se.size();\n\t\tfor (int i = 0; i < ko; i++) {\n\t\t\tfor (int j = 0; j < ko; j++) {\n\t\t\t\tbool f = false;\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tif (se[i].first[k] && se[j].first[k]) {\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) continue;\n\t\t\t\tif (se[i].first[se[j].second] && se[j].first[se[i].second]) res = true;\n\t\t\t}\n\t\t}\n\t\tcout << (res ? \"UNSAFE\" : \"SAFE\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<pair<set<char>, int> >locks;\nset<set<char> >check;\n\nset<char> product(set<char>& l, set<char>& r){\n  set<char>ret;\n  for(set<char>::iterator it = l.begin(); it != l.end(); it++)\n    if(r.find(*it) != r.end()) ret.insert(*it);\n  return ret;\n}\n\nset<char> set_union(set<char>& l, set<char> & r){\n  set<char>ret;\n  for(set<char>::iterator it = l.begin(); it != l.end(); it++) ret.insert(*it);\n  for(set<char>::iterator it = r.begin(); it != r.end(); it++) ret.insert(*it);\n  return ret;\n}\n\nint main(){\n  while(1){\n    int n; cin >> n;\n    if(!n) break;\n    locks.clear();\n    check.clear();\n    string s; cin >> s;\n    set<char>lock;\n    int xflag = 0;\n    for(int i=0;i<s.size();i++){\n      if(s[i] == 'u'){\n\tlock.clear();\n\tcontinue;\n      }\n      locks.push_back(make_pair(lock, s[i]));\n      check.insert(lock);\n      if(lock.find(s[i]) != lock.end()){\n\txflag = 1;\n\tbreak;\n      }\n      lock.insert(s[i]);\n      \n    }\n\n    if(xflag){\n      cout << \"UNSAFE\\n\";\n    }else{\n\n    while(1){\n\n      int flag = 0;\n      for(int i=0;i<locks.size();i++){\n\tpair<set<char>, int> l = locks[i];\n\tfor(int j=i+1;j<locks.size();j++){\n\t  //\t  cout << i << endl;                              \t\n\t  pair<set<char>, int> r = locks[j];\n\t  if(product(l.first, r.first).size() == 0 && l.first.find(r.second) == l.first.end() && r.first.find(l.second) != r.first.end() && check.find(set_union(l.first, r.first)) == check.end()){\n\t    //\t    for(set<char>::iterator it = l.first.begin(); it != l.first.end(); it++) cout << *it; \n\t    //\t    for(set<char>::iterator it = r.first.begin(); it != r.first.end(); it++) cout << *it; cout << endl;\n\t    set<char> x = set_union(l.first, r.first);\n\t    //\t    for(set<char>::iterator it = x.begin(); it != x.end(); it++) cout << *it; cout << endl;\n\t    //\t    cout << \"-------------------\\n\";\n\t    locks.push_back(make_pair(set_union(l.first, r.first), r.second));\n\t    check.insert(set_union(l.first, r.first));\n\t    flag = 1;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    \n    int flag = 0;\n    for(int i=0;i<locks.size();i++){\n      pair<set<char>, int> l = locks[i];\n      //      for(set<char>::iterator it = l.first.begin(); it != l.first.end(); it++) cout << *it; cout << endl;\n      for(int j=i+1;j<locks.size();j++){\n\tpair<set<char>, int> r = locks[j];\n\tif(product(l.first, r.first).size() == 0 &&\n\t   l.first.find(r.second) != l.first.end() &&\n\t   r.first.find(l.second) != r.first.end()){\n\t  cout << \"UNSAFE\\n\";\n\t  flag = 1;\n\t  i = locks.size();\n\t  break;\n\t}\n      }\n    }\n    if(!flag) cout << \"SAFE\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nconst int num = 10;\n\nint main() {\n\twhile (1) {\n\t\tvector<vector<int>>oks(1024, vector<int>(10, 0));\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tstring st; cin >> st;\n\t\tvector<vector<int>>vs;\n\t\tvector<int>v;\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'u') {\n\t\t\t\tvs.emplace_back(v);\n\t\t\t\tv.clear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv.emplace_back(st[i]-'0');\n\t\t\t}\n\t\t}\n\t\tfor (auto v : vs) {\n\t\t\tif (v.empty())continue;\n\t\t\tbitset<10>bs;\n\t\t\tbs[v[0]] = true;\n\t\t\toks[0][v[0]] = true;\n\t\t\tfor (int i = 1; i < v.size(); ++i) {\n\t\t\t\toks[bs.to_ulong()][v[i]] = true;\n\t\t\t\tif (bs[v[i]]) {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbs[v[i]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tfor (int k = 0; k < 10; ++k) {\n\t\t\t\tif (!oks[j][k])continue;\n\t\t\t\tfor (int l = 0; l < 1024; ++l) {\n\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\tif ((!oks[j][k]) || (!oks[l][m]))continue;\n\t\t\t\t\t\tif (j&l)continue;\n\t\t\t\t\t\tif ((j&(1 << m)) && !(l&(1 << k)))oks[j | l][m] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tfor (int k = 0; k < 10; ++k) {\n\t\t\t\tif (!oks[j][k])continue;\n\t\t\t\tfor (int l = 0; l < 1024; ++l) {\n\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\tif ((!oks[j][k]) || (!oks[l][m]))continue;\n\t\t\t\t\t\tif (j&l)continue;\n\t\t\t\t\t\tif ((j&(1 << m)) && l&(1 << k)) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"SAFE\" << endl;\n\t\telse cout << \"UNSAFE\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> b(1);      //何番目の命令を実行しているか 0-9 ->1-n 初期値0\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<vector<int> > > tu(1,vector<vector<int> >(1,vector<int>(1,0)));\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    a.assign(n+1,10);\n    b.assign(10,0);\n    tu.assign(10,vector<vector<int> >(10,vector<int>(0,0)));\n    char s;\n    int e=0;\n    en=0;\n    a[0]=10;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        e=e|mm(s-'0');\n        t++;\n      }\n      else{\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n    int ss=0;\n    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  int y=1;\n  for(int z=1;z<=k;z++){\n    y=y*2;\n  }\n  return y;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()){\n      if((f&mm(t))==0){\n        next(t,f,route);\n      }\n      else{\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          int d=0;\n          for(int z=0;z<int(route.size())-1;z++){\n            for(int w=0;w<int(route.size())-1;w++){\n              if(z!=w){\n                for(int x=0;x<int(tu[route[z]][route[z+1]].size());x++){\n                  for(int y=0;y<int(tu[route[w]][route[w+1]].size());y++){\n                    if((tu[route[z]][route[z+1]][x]&tu[route[w]][route[w+1]][y])==0){\n                      d=1;\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if(d==1){\n            en=1;\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n      }\n    }\n  }\n}\n\n\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nconst int num = 10;\n\nint main() {\n\twhile (1) {\n\t\tvector<vector<int>>oks(1024, vector<int>(10, 0));\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tstring st; cin >> st;\n\t\tvector<vector<int>>vs;\n\t\tvector<int>v;\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'u') {\n\t\t\t\tvs.emplace_back(v);\n\t\t\t\tv.clear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv.emplace_back(st[i]-'0');\n\t\t\t}\n\t\t}\n\t\tfor (auto v : vs) {\n\t\t\tbitset<10>bs;\n\t\t\tbs[v[0]] = true;\n\t\t\toks[0][v[0]] = true;\n\t\t\tfor (int i = 1; i < v.size(); ++i) {\n\t\t\t\toks[bs.to_ulong()][v[i]] = true;\n\t\t\t\tif (bs[v[i]]) {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbs[v[i]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tfor (int k = 0; k < 10; ++k) {\n\t\t\t\tfor (int l = 0; l < 1024; ++l) {\n\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\tif ((!oks[j][k]) || (!oks[l][m]))continue;\n\t\t\t\t\t\tif (j&l)continue;\n\t\t\t\t\t\tif (!(j&(1 << m)) && (l&(1 << k)))oks[j | l][m] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tfor (int k = 0; k < 10; ++k) {\n\t\t\t\tfor (int l = 0; l < 1024; ++l) {\n\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\tif ((!oks[j][k]) || (!oks[l][m]))continue;\n\t\t\t\t\t\tif (j&l)continue;\n\t\t\t\t\t\tif ((j&(1 << m)) && l&(1 << k)) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"SAFE\" << endl;\n\t\telse cout << \"UNSAFE\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint h(char c){\n  return (int)c-'0';\n}\n\nint n;\nstring input;\nint vis[1<<10];\nvector<int> g[1<<10];\n\nbool dfs(int v,int dame){\n  vis[v]=1;\n  rep(i,g[v].size()){\n    int nv=g[v][i];\n    if(vis[nv]==1)return false;\n    if(vis[nv]==0&&(dame&nv)==0&&!dfs(nv,dame|nv))return false;\n  }\n  vis[v]=2;\n  return true;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,1<<10)g[i].clear();\n    cin>>input;\n    vector<string> s;\n    int l=0;\n    rep(i,n){\n      if(input[i]=='u'){\n        s.pb(input.substr(l,i-l));\n        l=i+1;\n      }\n    }\n    bool ok=true;\n    n=s.size();\n    rep(i,n){\n      int len=s[i].length();\n      bool used[10];\n      memset(used,0,sizeof(used));\n      rep(j,len){\n        if(used[h(s[i][j])])ok=false;\n        else used[h(s[i][j])]=true;\n      }\n    }\n    if(!ok){\n      cout<<\"UNSAFE\"<<endl;\n      continue;\n    }\n    rep(i,n){\n      int len=s[i].length();\n      int nS=1<<h(s[i][0]);\n      repl(j,1,len){\n        rep(S,1<<10){\n          if((S&nS)==0&&((S>>h(s[i][j]))&1)==1){\n            g[nS].pb(S);\n          }\n        }\n        nS|=(1<<h(s[i][j]));\n      }\n    }\n    rep(S,1<<10){\n      memset(vis,0,sizeof(vis));\n      if(!dfs(S,S))ok=false;\n    }\n    if(ok)cout<<\"SAFE\"<<endl;\n    else cout<<\"UNSAFE\"<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool fail() {\n    cout << \"UNSAFE\" << endl;\n    return true;\n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n\n    string S;\n    cin >> S;\n\n    vector<vector<bool>> dp(1 << 10, vector<bool>(10, false));\n    int bit = 0;\n    for (char c : S) {\n        if (c == 'u') {\n            bit = 0;\n        } else {\n            int ci = c - '0';\n            int b = 1 << ci;\n            if ((b & bit) != 0) return fail();\n\n            dp[bit][ci] = true;\n            bit |= (1 << ci);\n        }\n    }\n\n    for (int A = 0; A < (1 << 10); ++A) {\n        for (int B = 0; B < 10; ++B) {\n            if (!dp[A][B]) continue;\n\n            for (int C = 0; C < (1 << 10); ++C) {\n                if ((A & C) || !((C >> B) & 1)) continue;\n\n                for (int D = 0; D < 10; ++D) {\n                    if (!dp[C][D]) continue;\n                    dp[A | C][D] = true;\n                }\n            }\n        }\n    }\n\n    for (int A = 0; A < (1 << 10); ++A) {\n        for (int B = 0; B < 10; ++B) {\n            if (!dp[A][B]) continue;\n\n            for (int C = 0; C < (1 << 10); ++C) {\n                if (A & C) continue;\n                for (int D = 0; D < 10; ++D) {\n                    if (!dp[C][D]) continue;\n\n                    if (((A >> D) & 1) && ((C >> B) & 1)) {\n                        return fail();\n                    }\n                }\n            }\n        }\n    }\n\n    cout << \"SAFE\" << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n// #define DEBUG\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    typedef pair<bitset<10>, int> State;\n\n    int N;\n    while (cin >> N, N) {\n#ifdef DEBUG\n        cerr << \"===============================\" << endl;\n#endif\n        bool ans = true;\n        vector<State> SS;\n        bool memo[1<<11][10] = {};\n\n        string S; cin >> S;\n        bitset<10> now(0);\n        for (auto s : S) {\n            if (s == 'u') {\n                now = bitset<10>(0);\n            } else {\n                int l = s - '0';\n                if (now.test(l)) {\n                    ans = false;\n                } \n                SS.emplace_back(now, l);\n                memo[now.to_ulong()][l] = true;\n                now.set(l);\n            }\n        }\n\n        bool update = true;\n        while (update && ans) {\n#ifdef DEBUG\n            cerr << \"---------------------\" << endl;\n            for (auto s : SS) cerr << s.first << \" \" << s.second << endl;\n#endif\n            update = false;\n            vector<State> nSS = SS;\n\n            for (int i=0; i<SS.size(); i++) {\n                for (int j=i+1; j<SS.size(); j++) {\n                    State s1 = SS[i], s2 = SS[j];\n                    if ((s1.first & s2.first).count() == 0) {\n                        if (s2.first.test(s1.second) && s1.first.test(s2.second)) {\n                            ans = false;\n                            goto END;\n                        } else if (s2.first.test(s1.second)) {\n                            State ns((s1.first | s2.first), s2.second);\n                            if (!memo[ns.first.to_ulong()][ns.second]) {\n                                nSS.push_back(ns);\n                                memo[ns.first.to_ulong()][ns.second] = true;\n                                update = true;\n                            }\n                        }\n                    }\n                }\n            }\n\n            SS = nSS;\n        }\nEND:\n        cout << (ans ? \"SAFE\" : \"UNSAFE\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> b(1);      //何番目の命令を実行しているか 0-9 ->1-n 初期値0\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<vector<int> > > tu(1,vector<vector<int> >(1,vector<int>(1,0)));\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    a.assign(n+1,10);\n    b.assign(10,0);\n    tu.assign(10,vector<vector<int> >(10,vector<int>(0,0)));\n    char s;\n    int e=0;\n    en=0;\n    a[0]=10;\n    int ss=0;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        e=e|mm(a[t]);\n        if(a[t-1]!=10){\n          tu[a[t-1]][a[t]].push_back(ss);\n          ss=ss|mm(a[t-1]);\n          if((ss&mm(a[t]))!=0){\n            en=1;\n          }\n        }\n        else{\n          ss=0;\n        }\n        t++;\n      }\n      else{\n        ss=0;\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n\n/*    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }*/\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()){\n      if((f&mm(t))==0){\n        next(t,f,route);\n      }\n      else{\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        /*int q=0;\n        for(q=0;q<int(route.size())&&route[q]!=t;q++){\n        }\n        if(q>0){\n          route.erase(route.begin(),route.begin()+q-1);\n        }*/\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          for(int z=0;(z<int(route.size())-1)&&en!=1;z++){\n            for(int w=z+1;(w<int(route.size())-1)&&en!=1;w++){\n              for(int x=0;(x<int(tu[route[z]][route[z+1]].size()))&&en!=1;x++){\n                for(int y=0;(y<int(tu[route[w]][route[w+1]].size()))&&en!=1;y++){\n                  if((tu[route[z]][route[z+1]][x]&tu[route[w]][route[w+1]][y])==0){\n                    en=1;\n                  }\n                }\n              }\n            }\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n      }\n    }\n  }\n}\n\n\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n\nその前にrouteのかぶり、自分とのかぶりはバツ\n共通のかぶりバツ\nその上条件に適した組みが一つ以上ある\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n\nvector<int> per;\nint e[1030];\nbool aru[1030];\n\nbool func(int sude, int to, int st)\n{\n\tint tmp=0;\n\tfor(int i=0; i+sude<10; i++)\n\t{\n\t\ttmp|=(1<<per[sude+i]);\n\t\tif((to&tmp) && aru[tmp])\n\t\t{\n\t\t\tif(e[tmp]&(st|tmp))\n\t\t\t{\n\t\t\t\t//cout << tmp << ' ' << st << ' ' << e[tmp] << endl;\n\t\t\t\t//cout << 'a' << sude << ' ' << sude+i << ' ' << (st|tmp) << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(func(sude+i+1, e[tmp], (st|tmp)))\n\t\t\t{\n\t\t\t\t//cout << 'b' << sude << ' ' << sude+i << ' ' << (st|tmp) << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\tstring s;\n\tint u[10010];\n\twhile(cin >> n && n>0)\n\t{\n\t\tper.clear();\n\t\trep(i, 10) per.push_back(i);\n\t\tcin >> s;\n\t\trep(i, 1024)\n\t\t{\n\t\t\te[i]=0;\n\t\t\taru[i]=false;\n\t\t}\n\t\tint sz=0;\n\t\tu[0]=-1;\n\t\trep(i, n)\n\t\t{\n\t\t\tif(s[i]=='u')\n\t\t\t{\n\t\t\t\tsz++;\n\t\t\t\tu[sz]=i;\n\t\t\t}\n\t\t}\n\t\trep(i, sz)\n\t\t{\n\t\t\tint tmp=0;\n\t\t\tfor(int j=u[i]+1; j<u[i+1]-1; j++)\n\t\t\t{\n\t\t\t\ttmp|=(1<<((int)s[j]-(int)'0'));\n\t\t\t\taru[tmp]=true;\n\t\t\t\te[tmp]|=(1<<((int)s[j+1]-(int)'0'));\n\t\t\t}\n\t\t}\n\t\t//cout << e[1] << ' ' << e[2] << e[4] << endl;\n\t\tbool ikeru=false;\n\t\tdo{\n\t\t\tif(func(0, (1<<10)-1 ,0))\n\t\t\t{\n\t\t\t\tikeru=true;\n\t\t\t\t//rep(i, 10) cout << per[i];\n\t\t\t\t//cout << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while(next_permutation(per.begin(), per.end()));\n\t\tif(ikeru) cout << \"UNSAFE\" << endl;\n\t\telse cout << \"SAFE\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        string process;\n        cin >> process;\n        vector<int> locked(N);\n        vector<set<int>> next(1<<12);\n        vector<int> is(1<<12);\n        bool ans = true;\n\n        for (int i = 0, now = 0; i < N; i++) {\n            is[now] = true;\n            if (process[i] == 'u') {\n                now = 0;\n                continue;\n            }\n            int s = process[i] - '0';\n            if (now & (1 << s)) ans = false;\n\n            next[now].insert(s);\n            now += (1 << s);\n        }\n\n        for (int i = 0; ans && i < (1 << 11); i++) {\n            for (int j = 0; j < (1 << 11); j++) {\n                if ((i & j) != j) continue;\n                int nj = i ^ j;\n                bool flag = false;\n\n                if (j == nj) continue;\n                if (!is[j] || !is[nj]) continue;\n                if (next[j].size() == 0 || next[nj].size() == 0) continue;\n                is[i] = true;\n\n                for (auto k : next[j]) {\n                    if (!(nj & (1 << k))) flag = true;\n                    if (!(j & (1 << k)) && !(nj & (1 << k)))\n                        next[i].insert(k);\n                }\n                for (auto k : next[nj]) {\n                    if (!(j & (1 << k))) flag = true;\n                    if (!(j & (1 << k)) && !(nj & (1 << k)))\n                        next[i].insert(k);\n                }\n\n                if (!flag) {\n                    ans = false;\n                }\n            }\n        }\n\n        if (ans) cout << \"SAFE\" << endl;\n        else cout << \"UNSAFE\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint n;\nstd::string str;\n\nbool connected[16][16];\nuint32_t flags[16][16];\n\nbool init() {\n  scanf(\"%d\", &n);\n  if( n == 0 ) return true;\n  std::cin >> str;\n  for(int i = 0; i < 16; ++i) {\n    for(int j = 0; j < 16; ++j) {\n      connected[i][j] = false;\n      flags[i][j] = 0xffff;\n    }\n  }\n  uint32_t flag = 0;\n  int prev = -1;\n  for(int i = 0; i < n; ++i) {\n    if( str[i] == 'u' ) {\n      flag = 0;\n      prev = -1;\n      continue;\n    }\n    int x = str[i] - '0';\n    if( flag & (1 << x) ) return false;\n    if( prev != -1 ) {\n      connected[prev][x] = true;\n      flags[prev][x] = flag;\n    }\n    prev = x;\n    flag |= (1 << x);\n  }\n  return true;\n}\n\nint main() {\n  for(;;) {\n    if( not init() ) {\n      printf(\"UNSAFE\\n\");\n      continue;\n    }\n    if( n == 0 ) break;\n    for(int i = 0; i < 10; ++i) {\n      for(int j = 0; j < 10; ++j) {\n        for(int k = 0; k < 10; ++k) {\n          if( connected[i][j] and connected[j][k] ) {\n            connected[i][k] = true;\n            flags[i][k] &= (flags[i][j] & flags[j][k]);\n          }\n        }\n      }\n    }\n    bool res = true;\n    for(int i = 0; i < 10; ++i) {\n      if( connected[i][i] and flags[i][i] == 0 ) res = false;\n    }\n    puts(res ? \"SAFE\" : \"UNSAFE\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<functional>\n#define LL long long\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPA(i,n) for(int i=1;i<(n);++i)\n#define PII pair<int,int>\n#define PLI pair<long long, int>\n#define MOD ((int)1e9 + 7)\n#define INF ((int)1e9)\n#define INFLL ((LL)1e18)\n#define ALL(x) (x).begin(),(x).end()\n#define ctoi(x) (x - 'a') \n#define CTOI(x) (x - 'A')\n#define BIT(x) (1 << (x))\nusing namespace std;\nvector<int> map[10][10];\nbool check(vector<int> line,int cul,int start){\n    REP(i,10){\n        vector<int> nline;\n        REP(j,line.size()){\n            REP(k,map[cul][i].size()){\n                if(line[j]&map[cul][i][k])continue;\n                nline.push_back(line[j]|map[cul][i][k]);\n            }\n        }\n        sort(ALL(nline));\n        nline.erase(unique(ALL(nline)),nline.end());\n        if(nline.size()==0)continue;\n        if(start == i)return true;\n        if(check(nline,i,start))return true;\n    }\n    return false;\n}\nstring func(){\n    string str;\n    cin >> str;\n    REP(i,10){\n        REP(j,10){\n            map[i][j].clear();\n        }\n    }\n    int num = 0;\n    REP(i,str.size()){\n        if(str[i] == 'u'){\n            num = 0;\n        }else{\n            int nn = str[i] - '0';\n            if(num != 0){\n                if(num & BIT(nn))return \"UNSAFE\";\n                REP(j,10){\n                    if(BIT(j) & num){\n                        map[j][nn].push_back(num);\n                    }\n                }\n            }\n            num |= BIT(nn);\n        }\n    }\n    REP(i,10){\n        REP(j,10){\n            sort(ALL(map[i][j]));\n            map[i][j].erase(unique(ALL(map[i][j])),map[i][j].end());\n        }\n    }\n    REP(i,10){\n        REP(j,10){\n            if(check(map[i][j],j,i))return \"UNSAFE\";\n        }\n    }\n    return \"SAFE\";\n}\nint main(){\n    int n;\n    while(cin >> n && n){\n        cout << func() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint N; string S;\n\nchar memo[1 << 10][10];\n\nbool solve() {\n    for (int i = 0; i < (1 << 10); ++i)\n        fill(memo[i], memo[i]+10, 0);\n\n    {\n        int st = 0;\n        for (char ch : S) {\n            if (ch == 'u')\n                st = 0;\n            else {\n                int v = ch - '0';\n                memo[st][v] = 1;\n                st |= 1 << v;\n            }\n        }\n    }\n\n    // j & k == 0\n    // -> P(j, s)\n    // -> P(k, t)\n    // -> s <- k\n    // -> P(j | k, t)\n\n    for (int i = 1; i < (1 << 10); ++i) {\n        for (int j = 1; j < i; ++j) {\n            if ((i | j) != i) continue;\n\n            for (int x = 0; x < 10; ++x) {\n                for (int y = 0; y < 10; ++y) {\n                    if (memo[j][x] && memo[i^j][y] && ((i^j) >> x)%2)\n                        memo[i][y] = 1;\n                }\n            }\n        }\n    }\n\n    for (int i = 1; i < (1 << 10); ++i) {\n        for (int d = 0; d < 10; ++d) {\n            if (memo[i][d] && (i >> d)%2) return false;\n        }\n    }\n\n    return true;\n}\n\nint main(void) {\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> S;\n        cout << (solve() ? \"SAFE\" : \"UNSAFE\") << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tstring ans = \"SAFE\";\n\t\tvector<set<int>> vsi(10);\n\t\tint memo = 0;\n\t\tREP(i, s.length()) {\n\t\t\tif (s[i] == 'u') {\n\t\t\t\tmemo = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (((memo >> (s[i] - '0')) & 1)) {\n\t\t\t\t\tans = \"UNSAFE\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvsi[s[i] - '0'].insert(memo);\n\t\t\t\tmemo |= 1 << (s[i] - '0');\n\t\t\t}\n\t\t}\n\t\tREP(k, 8)\n\t\t\tREP(i, 9)\n\t\t\tFOR(j, i + 1, 10)\n\t\t\tfor (auto x1 : vsi[i])\n\t\t\t\tfor (auto x2 : vsi[j]) {\n\t\t\t\t\tif (!(x1&x2)) {\n\t\t\t\t\t\tif (((x1 >> j) & 1)) {\n\t\t\t\t\t\t\tvsi[i].insert(x1 | x2);\n\t\t\t\t\t\t\tif(((x1 | x2)>>i)&1) {\n\t\t\t\t\t\t\t\tans = \"UNSAFE\";\n\t\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((x2 >> i) & 1) {\n\t\t\t\t\t\t\tvsi[j].insert(x1 | x2);\n\t\t\t\t\t\t\tif (((x1 | x2) >> j) & 1) {\n\t\t\t\t\t\t\t\tans = \"UNSAFE\";\n\t\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tREP(i, 9)\n\t\tFOR(j, i + 1, 10)\n\t\t\tfor (auto x1 : vsi[i])\n\t\t\t\tfor (auto x2 : vsi[j]) {\n\t\t\t\t\tif (((x1 >> j) & 1)&& ((x2 >> i) & 1)&&!(x1&x2)) {\n\t\t\t\t\t\tans = \"UNSAFE\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tfinish:\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <set>\n\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n &&n!=0){\n        string s;\n        cin >> s;\n        set<pair<int,int> > st;\n        int tmp=0;\n        bool flag = 0;\n        for(int i=0;i<n;i++){\n            if(s[i]=='u'){\n                tmp =0;\n            }else{\n                if(s[i+1]!='u'){\n                    tmp += 1<<(s[i]-'0');\n                    int tmp2 = 1<<(int)(s[i+1]-'0');\n                    st.insert(make_pair(tmp,tmp2));\n                    if((tmp&tmp2)==tmp2){\n                        flag = 1;\n                    }\n                }\n            }\n        }\n        \n        set<pair<int,int> > st2=st;\n        for(int j=0;j<10;j++){\n            set<pair<int,int> > st3;\n            for(auto x:st){\n                for(auto y:st2){\n                    if((x.first&y.first)==0){\n                        int p =x.first|y.first;\n                        int q =x.second|y.second;\n                        st3.insert(make_pair(p,q));\n                        if((p&q)==q){\n                            flag = 1;\n                            break;\n                        }\n                    }\n                }\n                if(flag)break;\n            }\n            st2 = st3;\n        }\n        if(flag){\n            cout << \"UNSAFE\" << endl;\n        }else{\n            cout << \"SAFE\" << endl;\n        }\n    }\n\n\n\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> b(1);      //何番目の命令を実行しているか 0-9 ->1-n 初期値0\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<vector<int> > > tu(1,vector<vector<int> >(1,vector<int>(1,0)));\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    a.assign(n+1,10);\n    b.assign(10,0);\n    tu.assign(10,vector<vector<int> >(10,vector<int>(0,0)));\n    char s;\n    int e=0;\n    en=0;\n    a[0]=10;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        e=e|mm(s-'0');\n        t++;\n      }\n      else{\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n    int ss=0;\n    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()){\n      if((f&mm(t))==0){\n        next(t,f,route);\n      }\n      else{\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          int d=0;\n          for(int z=0;z<int(route.size())-1;z++){\n            for(int w=0;w<int(route.size())-1;w++){\n              if(z!=w){\n                for(int x=0;x<int(tu[route[z]][route[z+1]].size());x++){\n                  for(int y=0;y<int(tu[route[w]][route[w+1]].size());y++){\n                    if((tu[route[z]][route[z+1]][x]&tu[route[w]][route[w+1]][y])==0){\n                      d=1;\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if(d==1){\n            en=1;\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n      }\n    }\n  }\n}\n\n\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\n#define ALL(v) (v).begin(),v.end()\nusing namespace std;\n\n#ifdef _DEBUG\n#define debug_io fstream cin(\"input.txt\");ofstream cout(\"output.txt\");\n#else\n#define debug_io ;\n#endif\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nbool start[10] = { false };\nbool is_c[10] = { false };\nbool ed[10] = { false };\nbool self[10] = { false };\n\nint main()\n{\n\tdebug_io;\n\tint kkk;\n\twhile (cin >> kkk, kkk) {\n\t\tvi g(10);\n\t\tvector<vi> e(10);\n\t\tREP(i, 10) {\n\t\t\tis_c[i] = false;\n\t\t}\n\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(i, s.size() - 1) {\n\t\t\tif (s[i] != 'u' && s[i + 1] != 'u') {\n\t\t\t\te[s[i] - '0'].push_back(s[i + 1] - '0');\n\t\t\t}\n\t\t}\n\t\tREP(i, 10) {\n\t\t\tqueue<int> q;\n\t\t\tq.push(i);\n\t\t\tREP(i, 10) {\n\t\t\t\ted[i] = false;\n\t\t\t}\n\t\t\twhile (q.size()) {\n\t\t\t\tauto a = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tif (ed[a] == true)continue;\n\t\t\t\ted[a] = true;\n\t\t\t\tfor (auto x : e[a]) {\n\t\t\t\t\tq.push(x);\n\t\t\t\t\tif (x == i)\n\t\t\t\t\t\tis_c[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 10) {\n\t\t\tstart[i] = false;\n\t\t}\n\t\tint m = 0;\n\t\tREP(i, s.size()) {\n\t\t\tint a = s[i] - '0';\n\t\t\tstart[a] |= is_c[a];\n\n\t\t\tREP(i, 10) {\n\t\t\t\tself[i] = false;\n\t\t\t}\n\t\t\tself[s[i] - '0'] = true;\n\t\t\tfor (int j = i + 1; j < s.size(); ++j) {\n\t\t\t\tif (s[j] == 'u')break;\n\t\t\t\tstart[a] |= is_c[s[j] - '0'];\n\t\t\t\ti = j + 1;\n\t\t\t\tif (self[s[j] - '0'])\n\t\t\t\t\tm = 100;\n\n\t\t\t\tself[s[j] - '0'] = true;\n\t\t\t}\n\t\t}\n\t\tREP(i, 10) {\n\t\t\tif (start[i]) {\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tif (2 <= m) {\n\t\t\tcout << \"UNSAFE\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <set>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nint ff;\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<set<int> > > tu;\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    set<int> se;\n    a.assign(n+1,10);\n    tu.assign(10,vector<set<int> >(10,se));\n    char s;\n    en=0;\n    a[0]=10;\n    int ss=0;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        if(a[t-1]!=10){\n          tu[a[t-1]][a[t]].insert(ss);\n          ss=ss|mm(a[t-1]);\n          if((ss&mm(a[t]))!=0){\n            en=1;\n          }\n        }\n        else{\n          ss=0;\n        }\n        t++;\n      }\n      else{\n        ss=0;\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n\n/*    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }*/\n    vector<int> route2;\n    ff=0;\n    for(int t=0;t<10&&en==0;t++){\n      if((ff&mm(t))==0){\n        next(t,0,route2);\n      }\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  ff=ff|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()>0){\n      if((f&mm(t))!=0){\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        /*int q=0;\n        for(q=0;q<int(route.size())&&route[q]!=t;q++){\n        }\n        if(q>0){\n          route.erase(route.begin(),route.begin()+q-1);\n        }*/\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        /*else{\n          for(int z=0;(z<int(route.size())-1)&&en!=1;z++){\n            for(int w=z+1;(w<int(route.size())-1)&&en!=1;w++){\n              for(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end()&&en==0;++x){\n                for(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end()&&en==0;++y) {\n                  if((*x&*y)==0){\n                    en=1;\n                  }\n                }\n              }\n            }\n          }\n        }*/\n        //printf(\"V=%d,T=%d\\n\",v,t);\n        \n      }\n      else{\n        next(t,f,route);\n      }\n    }\n  }\n}\n/*\nfor(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end();++x){\nfor(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end();++y) {\n  if((*x&*y)==0){\n    en=1;\n  }\n}\n}*/\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n\nその前にrouteのかぶり\n//自分とのかぶりはバツ\n共通のかぶりバツ\nその上条件に適した組みが一つ以上ある\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <set>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<set<int> > > tu;\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    set<int> se;\n    a.assign(n+1,10);\n    tu.assign(10,vector<set<int> >(10,se));\n    char s;\n    en=0;\n    a[0]=10;\n    int ss=0;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        if(a[t-1]!=10){\n          tu[a[t-1]][a[t]].insert(ss);\n          ss=ss|mm(a[t-1]);\n          if((ss&mm(a[t]))!=0){\n            en=1;\n          }\n        }\n        else{\n          ss=0;\n        }\n        t++;\n      }\n      else{\n        ss=0;\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n\n/*    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }*/\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      //next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()){\n      if((f&mm(t))==0){\n        next(t,f,route);\n      }\n      else{\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        /*int q=0;\n        for(q=0;q<int(route.size())&&route[q]!=t;q++){\n        }\n        if(q>0){\n          route.erase(route.begin(),route.begin()+q-1);\n        }*/\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          for(int z=0;(z<int(route.size())-1)&&en!=1;z++){\n            for(int w=z+1;(w<int(route.size())-1)&&en!=1;w++){\n              for(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end()&&en==0;++x){\n                for(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end()&&en==0;++y) {\n                  if((*x&*y)==0){\n                    en=1;\n                  }\n                }\n              }\n            }\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n      }\n    }\n  }\n}\n/*\nfor(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end();++x){\nfor(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end();++y) {\n  if((*x&*y)==0){\n    en=1;\n  }\n}\n}*/\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n\nその前にrouteのかぶり\n//自分とのかぶりはバツ\n共通のかぶりバツ\nその上条件に適した組みが一つ以上ある\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nset<int> dp[1<<11];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<(1<<10);i++){\n\t\t\tdp[i].clear();\n\t\t}\n\t\tstring str;\n\t\tcin >> str;\n\t\tint bits=0;\n\t\tbool flag=true;\n\t\tint v2=-1;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif(str[i]=='u'){\n\t\t\t\tbits=0;\n\t\t\t\tv2=-1;\n\t\t\t}else{\n\t\t\t\tif(v2==-1){\n\t\t\t\t\tv2=str[i]-'0';\n\t\t\t\t\tbits=(1<<v2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v=str[i]-'0';\n\t\t\t\tif((bits>>v) & 1)flag=false;\n\t\t\t\tdp[bits].insert(1<<v);\n\t\t\t\tbits|=(1<<v);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif((i&j)==j){\n\t\t\t\t\tset<int>::iterator it=dp[j].begin();\n\t\t\t\t\tfor(;it!=dp[j].end();it++){\n\t\t\t\t\t\tset<int>::iterator it2=dp[i-j].begin();\n\t\t\t\t\t\tfor(;it2!=dp[i-j].end();it2++){\n\t\t\t\t\t\t\tint v=(*it)|(*it2);\n\t\t\t\t\t\t\tdp[i].insert(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tset<int>::iterator it=dp[i].begin();\n\t\t\tfor(;it!=dp[i].end();it++){\n\t\t\t\tbool ok=false;\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tif((!(i>>k & 1)) && ((*it)>>k & 1))ok=true;\n\t\t\t\t}\n\t\t\t\tif(!ok)flag=false;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"SAFE\":\"UNSAFE\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nbool solve() {\n    int n;\n    std::cin >> n;\n    if (n == 0) return false;\n\n    std::vector<int> nxts(1 << 10, 0);\n    {\n        int b = 0;\n        while (n--) {\n            char c;\n            std::cin >> c;\n            if (c == 'u') {\n                b = 0;\n            } else {\n                int d = c - '0';\n                nxts[b] |= (1 << d);\n                b |= (1 << d);\n            }\n        }\n    }\n\n    for (int a = 0; a < (1 << 10); ++a) {\n        for (int b = 0; b < (1 << 10); ++b) {\n            if (a & b) continue;\n            if (nxts[a] & b) {\n                nxts[a | b] |= nxts[b];\n            }\n        }\n    }\n\n    for (int b = 0; b < (1 << 10); ++b) {\n        if (nxts[b] & b) {\n            std::cout << \"UNSAFE\" << std::endl;\n            return true;\n        }\n    }\n\n    std::cout << \"SAFE\" << std::endl;\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nvector<string> parse(const string &s) {\n  vector<string> ret;\n  string buf;\n  REP(i,s.size()) {\n    if(s[i] == 'u') {\n      ret.push_back(buf);\n      buf.clear();\n    }\n    else {\n      buf += s[i];\n    }\n  }\n  return ret;\n}\nvector<pair<int, int>> toStates(const vector<string> &ops) {\n  vector<pair<int, int>> states;\n  for(const string &op : ops) {\n    // DEBUG(op);\n    int locked = 0;\n    for(char c : op) {\n      states.emplace_back(locked, c - '0');\n      locked |= (1 << (c - '0'));\n    }\n  }\n  return states;\n}\nbool contains(int A, int B) {\n  // A contains B\n  while(B > 0) {\n    if(B & 1) {\n      if((A & 1) == 0) return false;\n    }\n    A >>= 1;\n    B >>= 1;\n  }\n  return true;\n}\nbool dp[1 << 10][10];\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    int N; cin >> N;\n    if(N == 0) break;\n    string T; cin >> T;\n    vector<string> ops = parse(T);\n    vector<pair<int, int>> states = toStates(ops);\n    memset(dp, 0, sizeof(dp));\n    bool unsafe = false;\n    queue<pair<int, int>> que;\n    for(const auto &p : states) {\n      if((p.first >> p.second) & 1) unsafe = true;\n      que.emplace(p);\n      dp[p.first][p.second] = true;\n    }\n    while(!que.empty()) {\n      auto p = que.front(); que.pop();\n      for(int S = 0; S < (1 << 10); ++S) {\n        for(int next = 0; next < 10; ++next) {\n          if(dp[S][next] == false) continue;\n          auto q = make_pair(S, next);\n          if((p.first & q.first) != 0) continue;\n          if((p.first >> q.second) & 1 && dp[p.first | q.first][p.second] == false) {\n            dp[p.first | q.first][p.second] = true;\n            que.emplace(p.first | q.first, p.second);\n          }\n          if((q.first >> p.second) & 1 && dp[p.first | q.first][q.second] == false) {\n            dp[p.first | q.first][q.second] = true;\n            que.emplace(p.first | q.first, q.second);\n          }\n        }\n      }\n    }\n    REP(S1,1<<10) {\n      REP(n1,10) {\n        if(dp[S1][n1] == false) continue;\n#if 0\n        if(dp[S1][n1]) {\n          cerr << \"[\";\n          REP(i,10) {\n            if((S1 >> i) & 1) cerr << i;\n          }\n          cerr << \"] \" << n1 << endl;\n        }\n#endif\n        REP(S2,1<<10) {\n          REP(n2,10) {\n            if((S1 & S2) == 0 && dp[S1][n1] && dp[S2][n2]) {\n              if((S1 >> n2) & 1 && (S2 >> n1) & 1) {\n                unsafe = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << (unsafe ? \"UNSAFE\" : \"SAFE\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    string s;\n    cin >> s;\n    vector<string> sec;\n    int pre=0;\n    REP(i,s.size()){\n      if(s[i]=='u') {\n\tsec.push_back(string(s.begin()+pre,s.begin()+i));\n\tpre=i+1;\n      }\n    }\n    bool flag=true;\n    REP(i,sec.size()) if(sec[i].size()>10) flag=false;\n    if(!flag){\n      cout << \"UNSAFE\" << endl;\n      continue;\n    }\n    vector<set<int> > lone(1<<10);\n    //lock,next;\n    REP(i,sec.size()){\n      int lock=0;\n      REP(j,sec[i].size()-1){\n\tlock=(lock|(1<<(sec[i][j]-'0')));\n\tlone[lock].insert(1<<(sec[i][j+1]-'0'));\n      }\n    }\n    REP(i,lone.size()){\n      if(lone[i].empty()) continue;\n      for(int ne:lone[i]){\n\tif((i&ne)==ne){\n\t  flag=false;\n\t  break;\n\t}\n      }\n      if(!flag) break;\n      REP(j,lone.size()){\n\tif(i&j) continue;\n\tint suc=i|j;\n\tfor(int nei:lone[i]){\n\t  for(int nej:lone[j]){\n\t    lone[suc].insert(nei|nej);\n\t  }\n\t}\n      }\n    }\n    if(flag) cout << \"SAFE\" << endl;\n    else cout << \"UNSAFE\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\n#include<vector>\n \nusing namespace std;\n \ntypedef pair<int, int> PP;\n \n \nint N;\nchar S[10010];\n \nint main(){\n    while(1){\n        scanf(\"%d\", &N);\n        if(N == 0) break;\n        scanf(\"%s\", S);\n        set<PP> pat1, pat2;\n         \n        int prev = 0;;\n        for(int i = 0; i < N; i++){\n            if(S[i] == 'u'){\n                prev = 0;\n            }else{\n                int mask = 1 << (S[i] - '0');\n                pat1.insert(make_pair(prev, mask));\n                prev |= mask;\n            }\n        }\n        vector<PP> tmp;\n        bool flg = true;\n        int bsize;\n        do{\n            bsize = pat1.size();\n            tmp.clear();\n            for(auto v1 : pat1){\n                for(auto v2 : pat1){\n                    if((v1.first & v2.first) == 0 && (v1.first & v2.second) != 0){\n\t\t\t\t\t\tPP np = make_pair(v1.first | v2.first, v1.second);\n\t\t\t\t\t\tif((np.first & np.second) != 0){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tgoto LOOP;\t\t\t\t\t\n\t\t\t\t\t\t}\n                        tmp.push_back(np);\n                    }\n                }\n            }\n            for(auto v : tmp){\n                pat1.insert(v);\n            }\n        }while(bsize != pat1.size());\n \n\t\tLOOP:\n\n        if(flg){\n            printf(\"SAFE\\n\");\n        }else{\n            printf(\"UNSAFE\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define encode(state,lock) (state|(lock<<10))\n#define getState(v) (v&((1<<10)-1))\n#define getLock(v) (v>>10)\n#define isLock(state, lock) (state&(1<<lock))\n\nvoid init(int n,string s,unordered_set<int> &S) {\n  int state = 0;\n  rep(i,n) {\n    if( s[i] == 'u' ) {\n      state = 0;\n    } else {\n      int lock = s[i] - '0';\n      S.insert(encode(state,lock));\n      state = state | (1<<lock);\n    }\n  }\n}\n\nbool hasDeadlock(int n,string s) {\n  rep(i,n-1) if( s[i] != 'u' && s[i] == s[i+1] ) return true;\n\n  unordered_set<int> S;\n  init(n,s,S);\n  bool update = true;\n  while(update) {\n    update = false;\n    vector<int> buffer;\n    for(auto v1 : S) {\n      int state1 = getState(v1);\n      int lock1  = getLock(v1);\n      for(auto v2 : S) {\n        int state2 = getState(v2);\n        int lock2  = getLock(v2);\n        if( state1 & state2 ) continue;\n        if( state2 & (1<<lock1) ) buffer.push_back(encode((state1|state2),lock2));\n        if( isLock(state1,lock2) && isLock(state2,lock1) ) {\n          return true;\n        }\n      }\n    }\n    rep(i,(int)buffer.size()) {\n      if( S.count(buffer[i]) ) continue;\n      S.insert(buffer[i]);\n      update = true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  int n;\n  string s;\n  while( cin >> n, n ) {\n    cin >> s;\n    puts(hasDeadlock(n,s)?\"UNSAFE\":\"SAFE\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  int s, to;\n};\nbool operator<(const data &l, const data &r) {\n  if(l.s != r.s) return l.s < r.s;\n  return l.to < r.to;\n}\n\nint n;\nvector<int> memo, nodeid;\nstring s;\nvector<string> v;\nvector<data> dv;\nset<data> st;\n\nbool solve();\n\nint main() {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    cin >> s;\n    if(solve())\n      cout << \"SAFE\" << endl;\n    else\n      cout << \"UNSAFE\" << endl;\n    v.erase(v.begin(), v.end());\n    dv.erase(dv.begin(), dv.end());\n    st.clear();\n  }\n  return 0;\n}\n\nbool solve() {\n  // parse\n  for(int i = 0; i < n; ++i) {\n    data now = {0, 0};\n    while(i < n && s[i] != 'u') {\n      if((now.s >> (s[i] - '0')) & 1) return 0;\n      now.to = s[i] - '0';\n      if(st.find(now) == st.end()) {\n        st.insert(now);\n        dv.push_back(now);\n      }\n      now.s |= 1 << (s[i++] - '0');\n    }\n  }\n  for(int t = 0; t < 10; ++t) {\n    int nowsize = st.size();\n    for(int i = 0; i < nowsize; ++i)\n      for(int j = i + 1; j < nowsize; ++j) {\n        data nextd = {0, 0};\n        if((dv[i].s & dv[j].s) != 0) continue;\n        if((dv[i].s >> dv[j].to) & (dv[j].s >> dv[i].to) &\n           1)\n          return 0;\n        nextd.s = dv[i].s | dv[j].s;\n        if((dv[i].s >> dv[j].to) & 1) {\n          nextd.to = dv[i].to;\n          if(st.find(nextd) == st.end()) {\n            st.insert(nextd);\n            dv.push_back(nextd);\n          }\n        }\n        if((dv[j].s >> dv[i].to) & 1) {\n          nextd.to = dv[j].to;\n          if(st.find(nextd) == st.end()) {\n            st.insert(nextd);\n            dv.push_back(nextd);\n          }\n        }\n      }\n  }\n  return 1;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tstring ans = \"SAFE\";\n\t\tvector<set<int>> vsi(10);\n\t\tint memo = 0;\n\t\tREP(i, s.length()) {\n\t\t\tif (s[i] == 'u') {\n\t\t\t\tmemo = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (((memo >> (s[i] - '0')) & 1)) {\n\t\t\t\t\tans = \"UNSAFE\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvsi[s[i] - '0'].insert(memo);\n\t\t\t\tmemo |= 1 << (s[i] - '0');\n\t\t\t}\n\t\t}\n\t\tREP(k, 8)\n\t\t\tREP(i, 9)\n\t\t\tFOR(j, i + 1, 10)\n\t\t\tfor (auto x1 : vsi[i])\n\t\t\t\tfor (auto x2 : vsi[j]) {\n\t\t\t\t\tif (!(x1&x2)) {\n\t\t\t\t\t\tif (((x1 >> j) & 1))\n\t\t\t\t\t\t\tvsi[i].insert(x1 | x2);\n\t\t\t\t\t\tif ((x2 >> i) & 1)\n\t\t\t\t\t\t\tvsi[j].insert(x1 | x2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tREP(i, 9)\n\t\tFOR(j, i + 1, 10)\n\t\t\tfor (auto x1 : vsi[i])\n\t\t\t\tfor (auto x2 : vsi[j]) {\n\t\t\t\t\tif (((x1 >> j) & 1)&& ((x2 >> i) & 1)&&!(x1&x2)) {\n\t\t\t\t\t\tans = \"UNSAFE\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < (n); i++)\nusing namespace std;\n\nint n;\nstring s;\nbool dp[1024][1025];\t//dp[S][T] = (ロック資源の集合がS, 待ち資源の集合がT)になることがあるか\n\nbool solve() {\n\tint i, j, k, l;\n\t\n\tint locked = 0, waiting = 0;\n\trep(i, s.length()) {\n\t\tif ('0' <= s[i] && s[i] <= '9') {\n\t\t\twaiting = s[i] - '0';\n\t\t\tdp[locked][1 << waiting] = true;\n\t\t\tlocked = locked + (1 << waiting);\n\t\t}\n\t\telse {\n\t\t\twaiting = 10;\t//T is covered Sが常に偽になる設定.\n\t\t\tdp[locked][1 << waiting] = true;\n\t\t\tlocked = 0;\n\t\t}\n\t}\n\t\n\trep(i, 1024) {\n\t\t//iと排反なnumberを探す.\n\t\tint digit[10]; int dNum = 0;\n\t\trep(k, 10) {\n\t\t\tif ((i >> k) % 2 == 0) {\n\t\t\t\tdigit[dNum++] = k;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(j, 1025) {\n\t\t\tif (!dp[i][j]) continue;\n\t\t\trep(k, 1<<dNum) {\n\t\t\t\tint locked = 0;\n\t\t\t\trep(l, dNum) if ((k >> l) & 1) locked += (1 << digit[l]);\n\t\t\t\t//waiting = 2^0, 2^1, …, 2^10\n\t\t\t\trep(l, 11) {\n\t\t\t\t\tif (dp[locked][1 << l]) {\n\t\t\t\t\t\tdp[i | locked][min(1024, j | (1 << l))] = true;\t//範囲外参照に注意！\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, 1024) {\n\t\trep(j, 1025) {\n\t\t\tif (!dp[i][j]) continue;\n\t\t\tif ((i | j) == i) return true;\t//UNSAFE\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tint i, j;\n\t\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\tcin >> s;\n\t\trep(i, 1024) rep(j, 1025) dp[i][j] = false;\n\t\tbool res = solve();\n\t\tif (res) cout << \"UNSAFE\" << endl;\n\t\telse cout << \"SAFE\" << endl;\n\t}\n\treturn 0;\n}\n\n//ポイント：\n//・2段がまえの論理。\n//・「全体集合から、ありえる状態集合を抽出☆」→「ありえる状態集合から、デッドロックが起きるものを抽出★」\n//・「初期状態から「ある状態」に至れるか」の判定を直接的にできるのが、この問題のポイント。\n//・「初期状態から「デッドロックが起きる状態」に至れるか」を直接判定しようとすると、再帰を考えることになり、このアプローチでは高速化を大して望めない。\n//\n//自分用解説：\n//「各kについて、スレッドkで命令がa_k個処理された状態」になりえるかは、容易に求まる。（現在ロックしている資源がかぶっていないかを判定するだけ）\n//なりえる状態のうち、(次確保したい資源の集合)が(ロックした資源の集合)の部分集合になるものでは、デッドロックが起きる。\n//そういうものがない場合は、デッドロックは決して起きない。\n//\n//{a_1,…,a_10}をすべて試すとO(10000^10)くらいになり間に合わない。a_1, a_2, …の順で決めていくと考えると、わざわざ{a_k}を直接持たなくて良いことに気付く。\n//なぜかというと、可能な{a_[i+1], …, a_10}の組み合わせは、\n//・現在i個のスレッドのカーソルを確定させた。現在ロックしている資源はS\n//という情報から定まり、\n//デッドロックの判定は、この情報に\n//・確保したい資源はT\n//という情報を追加すればできるからである。よって、{a}の情報を持たずに探索ができる。(典型的なDP\n//さらに、もう少し考えるとT - S(次確保「できる」資源の集合)を保存することでもデッドロックの判定ができるので、\n//・i, S, T - S\n//を使ってDPできることが分かる。\n//\n//また、この探索において、a_iの値を決めることは、「スレッドiでロックしている資源s_i, ロックしたい資源t_iを確定させる」\n//ことに他ならないため、a_iを試す代わりに(s_i, t_i)組を試してもよい。\n//しかし今回は文字列の長さがそこまで長くないため、直接a_iの値を試せばよい。(10000 < 2^10 * 10なので、上記の工夫はあまり意味がない)\n//\n//計算量は、(S, T - S)の組み合わせが3^10通り, iが11通り, 遷移が高々n(<=10000)通りより、3^10 * 11 * nくらいになる。\n//…あれ、間に合わない。\n//\n//\n//自分用解説2:\n//デッドロックは、次欲しい資源がすべてロックされていることである。\n//ロックされている資源の集合をS, 次欲しい資源の集合をTとして、ありえる(S, T)の組み合わせを列挙することを考える。(☆)\n//1スレッドのとき、ありえる(S, T)の組み合わせは簡単に求まる。その集合を{(s_i, t_i), 1≦i≦hoge}とおく。\n//2スレッドのときは、すでにロックしている資源をロックしなければよく、命令列も全スレッド共通なので、\n//・(s_i or s_j, t_i or t_j) (s_i and s_j = empty)\n//を列挙すればいいことに気付く。\n//3スレッドのときも同様。\n//今回の問題は、資源の個数≦スレッドの数より、スレッドの数に限りがないと考えてよく、\n//ありえる(S, T)について、(S or s_i, T or t_i) (S and s_i = empty)を更新が止まるまでやればいいことが分かる。\n//↑はS or s_iがSやs_iを含むことから、Sを2進数で表し、S=0,1,2,…の順で更新していけばいいことが分かる。\n//\n//一見, hoge=n, Sが2^10通り, Tが2^10通りで、2^20 * 10000 = 100億で間に合わないように見えるが、S and s_i = emptyとなるiだけを列挙すると、\n//間に合う。計算量解析：1がk個立っているSはcomb[10][k]通り. そのSについて、S and s_i = emptyなるs_iは2^(10-k)通り. Tは2^10通り. t_iは高々11通り.\n//Σcomb[10][k] * 2^(10 - k) = 3^10より、計算量は3^10 * 2^10 * 11 ≒ 6.6 * 10^8となる。(ダメやんけ)\n//\n//余談：\n//☆で「スレッドのカーソルの位置」を列挙したくなりがちだが、デッドロックの条件から、(S, T)の組み合わせを列挙する方が後々筋が良い。\n//「列挙するもの」は必ずしも「愚直な全探索」と同一にしなくても良いので、都合の良いものを列挙しよう。\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\n#include<vector>\n \nusing namespace std;\n \ntypedef pair<int, int> PP;\n \n \nint N;\nchar S[10010];\n \nint main(){\n    while(1){\n        scanf(\"%d\", &N);\n        if(N == 0) break;\n        scanf(\"%s\", S);\n        set<PP> pat1, pat2;\n         \n        int prev = 0;;\n        for(int i = 0; i < N; i++){\n            if(S[i] == 'u'){\n                prev = 0;\n            }else{\n                int mask = 1 << (S[i] - '0');\n                pat1.insert(make_pair(prev, mask));\n                prev |= mask;\n            }\n        }\n        vector<PP> tmp;\n        bool flg = true;\n        int bsize;\n        do{\n            bsize = pat1.size();\n            tmp.clear();\n            for(auto v1 : pat1){\n                for(auto v2 : pat1){\n                    if((v1.first & v2.first) == 0 && (v1.first & v2.second) != 0){\n\t\t\t\t\t\tPP np = make_pair(v1.first | v2.first, v1.second);\n\t\t\t\t\t\tif((np.first & np.second) != 0){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tgoto LOOP;\t\t\t\t\t\n\t\t\t\t\t\t}\n                        tmp.push_back(np);\n                    }\n                }\n            }\n            for(auto v : tmp){\n                pat1.insert(v);\n            }\n        }while(bsize != pat1.size());\n \n\t\tLOOP:\n\n        if(flg){\n            printf(\"SAFE\\n\");\n        }else{\n            printf(\"UNSAFE\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        string s;\n        cin>>s;\n        vector<vector<int>> chunk;\n        for(int i=0;i<n;i++){\n            vector<int> ch;\n            for(;i<n;i++){\n                if(s[i]=='u') break;\n                ch.push_back(s[i]-'0');\n            }\n            if(ch.size()!=0){\n                chunk.push_back(ch);\n            }\n        }\n        bool isdead=false;\n        for(int i=0;i<chunk.size();i++){\n            vector<int> check(10,0);\n            for(int j=0;j<chunk[i].size();j++){\n                if(check[chunk[i][j]]==true){\n                    isdead=true;\n                }\n                check[chunk[i][j]]=true;\n            }\n        }\n\n        if(isdead){\n            cout<<\"UNSAFE\"<<endl;\n            continue;\n        }\n        set<pair<int,int>> st;\n        queue<pair<int,int>> que;\n        for(int i=0;i<chunk.size();i++){\n            int ss=0;\n            for(int j=0;j<chunk[i].size();j++){\n                pair<int,int> x=make_pair(ss,chunk[i][j]);\n                st.insert(x);\n                que.push(x);\n                ss+=(1<<chunk[i][j]);\n            }\n        }\n\n        while(!que.empty()){\n            pair<int,int> val=que.front(); que.pop();\n            int ss=val.first;\n            int dea=val.second;\n            for(auto it=st.begin();it!=st.end();it++){\n                int sss=it->first;\n                int deaa=it->second;\n                if(sss+ss==(sss|ss)){\n                    if((sss&(1<<dea))&&(ss&(1<<deaa))){\n                       isdead=true; \n                    }\n                    else if(sss&(1<<dea)){\n                        pair<int,int> x=make_pair(ss|sss,deaa);\n                        if(!st.count(x)){\n                            st.insert(x);\n                            que.push(x);\n                        }\n                    }\n                    else if(ss&(1<<deaa)){\n                        pair<int,int> x=make_pair(ss|sss,dea);\n                        if(!st.count(x)){\n                            st.insert(x);\n                            que.push(x);\n                        }\n                    }\n                }\n            }\n\n\n        }\n        cout<<(isdead ? \"UNSAFE\" : \"SAFE\")<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <utility>\n#include <tuple>\n#include <math.h>\n#include <iomanip>\n#include <string>\n\nusing namespace std;\n\nclass Sover {\n};\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tstring s;\n\t\tcin >> s;\n\t\tset<tuple<int, int>> commands;\n\t\tint now = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == 'u') {\n\t\t\t\tnow = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint num = s[i] - '0';\n\t\t\t\tcommands.emplace(now, num);\n\t\t\t\tnow += 1 << num;\n\t\t\t}\n\t\t}\n\n\t\tset<tuple<int, int>> dp;\n\t\tfor (tuple<int, int> tpl : commands) {\n\t\t\tdp.emplace(tpl);\n\t\t}\n\t\tbool can = true;\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tset<tuple<int, int>> next;\n\t\t\tfor (tuple<int, int> val : dp) {\n\t\t\t\tint pat, num;\n\t\t\t\ttie(pat, num) = val;\n\t\t\t\tnext.emplace(val);\n\t\t\t\tfor (tuple<int, int> tmp : commands) {\n\t\t\t\t\tint pat_tmp, num_tmp;\n\t\t\t\t\ttie(pat_tmp, num_tmp) = tmp;\n\t\t\t\t\tif ((pat ^ pat_tmp) == pat + pat_tmp) {\n\t\t\t\t\t\tif ((((1 << num) & (pat + pat_tmp)) > 0)\n\t\t\t\t\t\t\t&& (((1 << num_tmp) & (pat + pat_tmp)) == 0)) {\n\t\t\t\t\t\t\tnext.emplace(pat + pat_tmp, num_tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((((1 << num) & (pat + pat_tmp)) == 0)\n\t\t\t\t\t\t\t&& (((1 << num_tmp) & (pat + pat_tmp)) > 0)) {\n\t\t\t\t\t\t\tnext.emplace(pat + pat_tmp, num);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((((1 << num) & (pat + pat_tmp)) > 0)\n\t\t\t\t\t\t\t&& (((1 << num_tmp) & (pat + pat_tmp)) > 0)) {\n\t\t\t\t\t\t\tcan = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!can)break;\n\t\t\t\t}\n\t\t\t\tif (!can)break;\n\t\t\t}\n\t\t\tdp = next;\n\t\t\tif (!can)break;\n\t\t}\n\n\t\tif (can)\t\tcout << \"SAFE\" << endl;\n\t\telse cout << \"UNSAFE\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n \nusing namespace std;\n \ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n \nconst int MAX_N = 100005;\n \nvector<int> e[11][11];\nvector<int> G[11];\nint visit[11];\n \nvoid dfs(int u,int& id,vvi& route,vi& hoge)\n{\n    visit[u] = id++;\n    rep(i,len(G[u])){\n        if(visit[G[u][i]] != -1 && visit[G[u][i]] <= visit[u]){\n            vi ag;\n            rep(j,len(hoge)){\n                if(hoge[j] == G[u][i]){\n                    for(;j<len(hoge);j++){\n                        ag.pb(hoge[j]);\n                    }\n                }\n            }\n            ag.pb(u);\n            route.pb(ag);\n        }else{\n            hoge.pb(u);\n            dfs(G[u][i],id,route,hoge);\n            hoge.pop_back();\n        }\n    }\n}\n \nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        string s;\n        cin >> s;\n        int kp = 0;\n        bool end = false;\n        rep(i,10){\n            rep(j,10){\n                e[i][j].clear();\n            }\n        }\n        rep(i,10){\n            G[i].clear();\n            visit[i] = -1;\n        }\n        rep(i,len(s)){\n            if(s[i] == 'u'){\n                kp = 0;\n            }else if(kp & (1 << (int)(s[i]-'0'))){\n                cout << \"UNSAFE\\n\";\n                end = true;\n                break;\n            }else{\n                kp |= (1 << (int)(s[i]-'0'));\n            }\n        }\n        if(end){\n            continue;\n        }\n        kp = 0;\n        rep(i,len(s)-1){\n            if(s[i] != 'u'){\n                if(s[i+1] != 'u'){\n                    int a = (int)(s[i]-'0'),b = (int)(s[i+1]-'0');\n                    e[a][b].pb(kp);\n                    kp |= (1 << (int)(s[i]-'0'));\n                }\n            }else{\n                kp = 0;\n            }\n        }\n        rep(i,10){\n            rep(j,10){\n                if(len(e[i][j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        rep(i,10){\n            if(visit[i] == -1){\n                vvi route;\n                vi hoge;\n                int id = 0;\n                dfs(i,id,route,hoge);\n                // rep(i,len(route)){\n                //     svec(route[i]);\n                // }\n                rep(j,len(route)){\n                    int loop = len(route[j]);\n                    vvi vec(loop);\n                    rep(k,len(route[j])){\n                        int a = route[j][k],b = route[j][(k+1)%loop];\n                        vec[k] = e[a][b];\n                        // if(len(vec[k])==0){\n                        //     svec(route[j]);\n                        //     cout << a << \" \" << b << \"\\n\";\n                        // }\n                    }\n                    set<int> dp[11];\n                    dp[0].insert(0);\n                    rep(j,loop){\n                        each(k,dp[j]){\n                            rep(l,len(vec[j])){\n                                if(!(k & vec[j][l])){\n                                    dp[j+1].insert(k|vec[j][l]);\n                                }\n                            }\n                        }\n                    }\n                    if(len(dp[loop])){\n                        cout << \"UNSAFE\\n\";\n                        end = true;\n                        break;\n                    }\n                }\n                if(end){\n                    break;\n                }\n            }\n        }\n        if(!end){\n            cout << \"SAFE\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n// #define DEBUG\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    typedef pair<bitset<10>, int> State;\n\n    int N;\n    while (cin >> N, N) {\n#ifdef DEBUG\n        cerr << \"===============================\" << endl;\n#endif\n        bool ans = true;\n        vector<State> SS;\n\n        string S; cin >> S;\n        bitset<10> now(0);\n        for (auto s : S) {\n            if (s == 'u') {\n                now = bitset<10>(0);\n            } else {\n                int l = s - '0';\n                if (now.test(l)) {\n                    ans = false;\n                } \n                SS.emplace_back(now, l);\n                now.set(l);\n            }\n        }\n\n        bool update = true;\n        while (update && ans) {\n#ifdef DEBUG\n            cerr << \"---------------------\" << endl;\n            for (auto s : SS) cerr << s.first << \" \" << s.second << endl;\n#endif\n            update = false;\n            vector<State> nSS = SS;\n\n            for (int i=0; i<SS.size(); i++) {\n                for (int j=i+1; j<SS.size(); j++) {\n                    State s1 = SS[i], s2 = SS[j];\n                    if ((s1.first & s2.first).count() == 0) {\n                        if (s2.first.test(s1.second) && s1.first.test(s2.second)) {\n                            ans = false;\n                            goto END;\n                        } else if (s2.first.test(s1.second)) {\n                            State ns((s1.first | s2.first), s2.second);\n                            if (find(SS.begin(), SS.end(), ns) == SS.end()) {\n                                nSS.push_back(ns);\n                                update = true;\n                            }\n                        }\n                    }\n                }\n            }\n\n            SS = nSS;\n        }\nEND:\n        cout << (ans ? \"SAFE\" : \"UNSAFE\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstring solve(string s){\n    int n = 1<<10;\n    vector<int> dp(n, 0);\n    int curr = 0;\n    for(char c: s){\n        if(c == 'u'){\n            curr = 0;\n        }else{\n            dp[curr] |= 1<<(c-'0');\n            curr |= 1<<(c-'0');\n        }\n    }\n    for(int i=0; i<n; i++){\n        for(int j=0; j<i; j++){\n            if(!(i&j) and (dp[j]&i)){\n                dp[i|j] |= dp[i];\n            }\n        }\n    }\n    for(int i=0; i<n; i++){\n        if(dp[i]&i){\n            return \"UNSAFE\";\n        }\n    }\n    return \"SAFE\";\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        string s;\n        cin >> s;\n        cout << solve(s) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\n\nvector<vector<int> > A;\nvoid Min(int &a,int b){a=min(a,b);}\n\nbool DP(){\n  sort(A.begin(),A.end());\n  A.erase(unique(A.begin(),A.end()),A.end());\n    \n  int n = A.size();\n  for(int i=0;i<n;i++)\n    for(int j=0,used[10]={};j<A[i].size();j++)if(used[A[i][j]]++) return 1;\n\n\n  vector<vector<int> >dp(1<<10,vector<int>(1<<10,INF));\n  dp[0][0] = 0;\n\n  for(int i=0;i<n;i++){\n    for(int j=(1<<10)-1;j>=0;j--)\n      for(int k=(1<<10)-1;k>=0;k--){\n\tif(dp[j][k] == INF||dp[j][k] == 10) continue;\n\tif((j&&k)&&__builtin_popcount(j&k) == dp[j][k]) return 1;\n\n\tfor(int l=0,nj=j;l<(int)A[i].size();l++){\n\t  int num = A[i][l];\n\t  if(l)Min(dp[nj][k|(1<<num)],dp[j][k]+1);\n\t  if(j&(1<<num))break;\n\t  nj |= (1<<num);\n\t  Min(dp[nj][k],dp[j][k]+1);\n\t}\n      }\n  }\n  \n\n  for(int i=1;i<(1<<10);i++)\n    for(int j=1;j<(1<<10);j++){\n      if(__builtin_popcount(i&j) == dp[i][j]) return 1;\n    }\n\n  return 0;\n}\n\n\ntypedef pair<int,int> P;\nbool bfs(){\n  sort(A.begin(),A.end());\n  A.erase(unique(A.begin(),A.end()),A.end());\n    \n  int n = A.size();\n  for(int i=0;i<n;i++)\n    for(int j=0,used[10]={};j<A[i].size();j++)if(used[A[i][j]]++) return 1;\n  \n  queue<P> Q;\n  vector<vector<int> >D(1<<10,vector<int>(1<<10,INF));\n  D[0][0] = 0;\n  Q.push(P(0,0));\n\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int I = t.first,J = t.second;\n    if(I&&J&&__builtin_popcount(I&J) == D[I][J]) return 1;\n    if(D[I][J]==10) continue;    \n\n    for(int i=0;i<n;i++){\n      for(int l=0,ni=I;l<(int)A[i].size();l++){\n\tint num = A[i][l];\n\tif(l&&D[ni][J|(1<<num)]==INF){\n\t  D[ni][J|(1<<num)] = D[I][J]+1;\n\t  Q.push(P(ni,J|(1<<num)));\n\t} \n\tif(I&(1<<num))break;\n\tni |= (1<<num);\n\tif(D[ni][J]==INF)D[ni][J] = D[I][J] + 1,Q.push(P(ni,J));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    string str;\n    cin>>str;\n    A.clear();\n    for(int i=0;i<str.size();i++){\n      A.push_back(vector<int>());\n      while(str[i]!='u') A.back().push_back(str[i++]-'0');\n    }\n    cout<<(bfs()? \"UN\":\"\")<<\"SAFE\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\nvector<vector<int> > A;\ntypedef pair<short,short> P;\n\nbool bfs(){\n  sort(A.begin(),A.end());\n  A.erase(unique(A.begin(),A.end()),A.end());\n  int n = A.size();\n  for(int i=0;i<n;i++)\n    for(int j=0,used[10]={};j<A[i].size();j++)if(used[A[i][j]]++) return 1;\n  \n  queue<P> Q;\n  bool D[1<<10][1<<10]={};\n  D[0][0]=1;\n  Q.push(P(0,0));\n\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int I = t.first,J = t.second;\n    if(I&&J&&__builtin_popcount(I&J) == __builtin_popcount(J)) return 1;\n\n    for(int i=0;i<n;i++){\n      for(int k=0,ni=I;k<A[i].size();k++){\n\tint num = A[i][k],nj =(J|1<<num);\n\tif(k&&D[ni][nj]==0&&J!=nj)D[ni][nj]=1, Q.push(P(ni,nj));\n\tif(I&(1<<num))break;\n\tni |= (1<<num);\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    string str;\n    cin>>str;\n    A.clear();\n    for(int i=0;i<str.size();i++){\n      A.push_back(vector<int>());\n      while(str[i]!='u') A.back().push_back(str[i++]-'0');\n    }\n    cout<<(bfs()? \"UN\":\"\")<<\"SAFE\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n    while(1){\n        int n;\n        scanf(\"%d\",&n);\n        if(n == 0)return 0;\n        string s;\n        cin >> s;\n        bool used[1<<10][1<<10];\n        for(int i = 0 ; i < (1<<10) ; i ++){\n            for(int j = 0 ; j < (1<<10) ; j ++){\n                used[i][j] = false;\n            }\n        }\n        int a = 0;\n        for(int i = 0 ; i < s.size() ; i ++){\n            if(s[i] == 'u'){\n                a = 0;\n                continue;\n            }\n            if(((1<<(s[i]-'0'))&a) != 0){\n                a = -1;\n                break;\n            }\n            used[1<<(s[i]-'0')][a] = true;\n            a += 1<<(s[i]-'0');\n        }\n        if(a == -1){\n            puts(\"UNSAFE\");\n            continue;\n        }\n        \n        /*for(int i = 0 ; i < 4 ; i ++){\n            for(int j = 0 ; j < 4 ; j ++){\n                if(used[i][j])printf(\"1\");\n                else printf(\"0\");\n            }\n            cout << endl;\n        }*/\n        \n        bool ret = false;\n        for(int i = 0 ; i < (1<<10) ; i ++){\n            for(int j = 0 ; j < (1<<10) ; j ++){\n                if(!used[i][j])continue;\n                if((i&j) == i)ret = true;\n                for(int k = 0 ; k < 10 ; k ++){\n                    if(((1<<k)&j) == 0)continue;\n                    int sub = ((1<<10)-1)^j;\n                    for(int t = (1<<10)-1 ; t >= 0 ; t --){\n                        t &= sub;\n                        if(!used[(1<<k)][t])continue;\n                        used[i|(1<<k)][j|t] = true;\n                    }\n                }\n            }\n        }\n        \n        /*for(int i = 0 ; i < 4 ; i ++){\n            for(int j = 0 ; j < 4 ; j ++){\n                if(used[i][j])printf(\"1\");\n                else printf(\"0\");\n            }\n            cout << endl;\n        }*/\n        \n        if(ret)puts(\"UNSAFE\");\n        else puts(\"SAFE\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int m = 10;\n\nbool exist_loop(const vector<vector<int>>& edge, int p, vector<int>& st, vector<vector<int>>& bc, const vector<int>& parbc) {\n    if (st[p] == 1) {\n        for (int i = 0; i < m; ++i)\n            if (parbc[i] > bc[p][i] + 1) return false;\n\n        return true;\n    }\n    if (st[p] == 2) return false;\n    st[p] = 1;\n    for (int i = 0; i < m; ++i)\n        bc[p][i] = parbc[i] + ((p >> i) & 1);\n    for (int e : edge[p])\n        if (exist_loop(edge, e, st, bc, bc[p]))\n            return true;\n\n    st[p] = 2;\n    return false;\n}\n\nbool exist_loop(const vector<vector<int>>& edge) {\n    int n = edge.size();\n    vector<int> st(n);\n    for (int i = 0; i < n; ++i) {\n        vector<vector<int>> bc(n, vector<int>(m));\n        if (exist_loop(edge, i, st, bc, vector<int>(m)))\n            return true;\n    }\n    return false;\n}\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n        string s;\n        cin >> s;\n        vector<vector<bool>> v(1 << m, vector<bool>(m));\n        vector<vector<int>> edge(1 << m);\n        vector<int> par(1 << m, -1);\n        int st = 0;\n        for (char c : s) {\n            if (c == 'u') st = 0;\n            else {\n                int i = c - '0';\n                if (st & (1 << i)) goto A;\n                v[st][i] = true;\n                st |= 1 << i;\n            }\n        }\n        for (int i = 0; i < (1 << m); ++i) {\n            int msk = 0;\n            for (int j = 0; j < m; ++j)\n                if (v[i][j])\n                    msk |= 1 << j;\n\n            if (!msk) continue;\n            for (int j = 0; j < (1 << m); ++j)\n                if (!(i & j) && (j & msk))\n                    edge[i].push_back(j);\n        }\n        if (exist_loop(edge)) goto A;\n\n        cout << \"SAFE\\n\";\n        continue;\n        A:\n        cout << \"UNSAFE\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <cinttypes>\n#include <set>\n\nusing namespace std;\n\n\nstruct State {\n  int locked;\n  int get;\n  State(): locked(0), get(-1) { }\n};\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n\n    string str;\n    cin >> str;\n    string ans = \"SAFE\";\n\n    int bits = 0;\n    for (int i = 0; i < n; i++) {\n      if (str[i] == 'u') {\n        bits = 0;\n      } else {\n        if (bits & (1 << (str[i] - '0'))) {\n          ans = \"UNSAFE\";\n        } \n        bits |= (1 << (str[i] - '0'));\n      }\n    }\n\n    vector<State> vec;\n    State s;\n    for (int i = 0; i < n; i++) {\n      if (str[i] != 'u') {\n        if (s.get != -1) {\n          s.locked |= (1 << s.get);\n        }\n        s.get = str[i] - '0';\n      } else {\n        s.locked = 0;\n        s.get = -1;\n      }\n      vec.push_back(s);\n    }\n\n    vector<State> vec2;\n    for (int i = 0; i < vec.size(); i++) {\n      for (int j = i + 1; j < vec.size(); j++) {\n        State s1 = vec[i];\n        State s2 = vec[j];\n        if ((s1.locked & s2.locked) == 0) {\n          if (s1.locked & (1 << s2.get)) {\n            State t;\n            t.locked = s1.locked | s2.locked;\n            t.get = s1.get;\n            vec2.push_back(t);\n          }\n        }\n      }\n    }\n\n    for (auto e : vec2) {\n      vec.push_back(e);\n    }\n\n\n    bool flag = true;\n    for (int i = 0; i < vec.size() && flag; i++) {\n      for (int j = i + 1; j < vec.size() && flag; j++) {\n        if ((vec[i].locked & vec[j].locked) == 0) {\n          if ((vec[i].locked & (1 << vec[j].get)) && (vec[j].locked & (1 << vec[i].get))) {\n            ans = \"UNSAFE\";\n            break;\n            flag = false;\n          }\n        }\n      }\n    }\n\n    cout << ans << endl;\n\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nvector<string> parse(const string &s) {\n  vector<string> ret;\n  string buf;\n  REP(i,s.size()) {\n    if(s[i] == 'u') {\n      ret.push_back(buf);\n      buf.clear();\n    }\n    else {\n      buf += s[i];\n    }\n  }\n  return ret;\n}\nvector<pair<int, int>> toStates(const vector<string> &ops) {\n  vector<pair<int, int>> states;\n  for(const string &op : ops) {\n    // DEBUG(op);\n    int locked = 0;\n    for(char c : op) {\n      states.emplace_back(locked, c - '0');\n      locked |= (1 << (c - '0'));\n    }\n  }\n  return states;\n}\nbool contains(int A, int B) {\n  // A contains B\n  while(B > 0) {\n    if(B & 1) {\n      if((A & 1) == 0) return false;\n    }\n    A >>= 1;\n    B >>= 1;\n  }\n  return true;\n}\nbool dp[1 << 10][10];\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    int N; cin >> N;\n    if(N == 0) break;\n    string T; cin >> T;\n    vector<string> ops = parse(T);\n    vector<pair<int, int>> states = toStates(ops);\n    memset(dp, 0, sizeof(dp));\n    bool unsafe = false;\n    queue<pair<int, int>> que;\n    for(const auto &p : states) {\n      if((p.first >> p.second) & 1) unsafe = true;\n      que.emplace(p);\n      dp[p.first][p.second] = true;\n    }\n    while(!que.empty()) {\n      auto p = que.front(); que.pop();\n      for(int S = 0; S < (1 << 10); ++S) {\n        for(int next = 0; next < 10; ++next) {\n          if(dp[S][next] == false) continue;\n          auto q = make_pair(S, next);\n          if((p.first & q.first) != 0) continue;\n          if((p.first >> q.second) & 1 && dp[p.first | q.first][p.second] == false) {\n            dp[p.first | q.first][p.second] = true;\n            que.emplace(p.first | q.first, p.second);\n          }\n          if((q.first >> p.second) & 1 && dp[p.first | q.first][q.second] == false) {\n            dp[p.first | q.first][q.second] = true;\n            que.emplace(p.first | q.first, q.second);\n          }\n        }\n      }\n    }\n    REP(S1,1<<10) {\n      REP(n1,10) {\n#if 0\n        if(dp[S1][n1]) {\n          cerr << \"[\";\n          REP(i,10) {\n            if((S1 >> i) & 1) cerr << i;\n          }\n          cerr << \"] \" << n1 << endl;\n        }\n#endif\n        REP(S2,1<<10) {\n          REP(n2,10) {\n            if((S1 & S2) == 0 && dp[S1][n1] && dp[S2][n2]) {\n              if((S1 >> n2) & 1 && (S2 >> n1) & 1) {\n                unsafe = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << (unsafe ? \"UNSAFE\" : \"SAFE\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\nvvint vv;\nint dp[1<<10][1<<10];\ninline int saiki(int a,int b,int c){\n\tif(dp[a][b]>=0) return dp[a][b];\n\tdp[a][b]=2;\n\tfor(int y:vv[a]){\n\t\tif(y==c) return dp[a][b]=1;\n\t\tif(y+b!=(y|b)) continue;\n\t\tif(saiki(y,y|b,c)==1) return dp[a][b]=1;\n\t}\n\treturn 2;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tvv=vvint(1<<10);\n\t\trep(i,1<<10) rep(j,1<<10) dp[i][j]=-1;\n\t\tint state=0;\n\t\tvvint ww(1<<10);\n\t\tbool ans=false;\n\t\trep(i,s.size()){\n\t\t\tif(s[i]=='u'){\n\t\t\t\tstate=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint t=s[i]-'0';\n\t\t\tif(state&(1<<t)) ans=true;\n\t\t\tif(s[i+1]=='u') continue;\n\t\t\tstate|=1<<t;\n\t\t\tww[state].PB(s[i+1]-'0');\n\t\t}\n\t\trep(i,1<<10){\n\t\t\tfor(int x:ww[i]){\n\t\t\t\trep(j,1<<10){\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tif(!(j&(1<<x))) continue;\n\t\t\t\t\tif(i+j!=(i|j)) continue;\n\t\t\t\t\tvv[i].PB(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,1<<10){\n\t\t\tif(ww[i].size()==0) continue;\n\t\t\tif(saiki(i,i,i)==1) ans=true;\n\t\t}\n\t\tputs(ans?\"UNSAFE\":\"SAFE\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <tuple>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> b(1);      //何番目の命令を実行しているか 0-9 ->1-n 初期値0\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<vector<int> > > tu(1,vector<vector<int> >(1,vector<int>(1,0)));\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    a.assign(n+1,10);\n    b.assign(10,0);\n    tu.assign(10,vector<vector<int> >(10,vector<int>(0,0)));\n    char s;\n    int e=0;\n    en=0;\n    a[0]=10;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        e=e|mm(s-'0');\n        t++;\n      }\n      else{\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n    int ss=0;\n    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  int y=1;\n  for(int z=1;z<=k;z++){\n    y=y*2;\n  }\n  return y;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()){\n      if((f&mm(t))==0){\n        next(t,f,route);\n      }\n      else{\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          int d=0;\n          for(int z=0;z<int(route.size())-1;z++){\n            for(int w=0;w<int(route.size())-1;w++){\n              if(z!=w){\n                for(int x=0;x<int(tu[route[z]][route[z+1]].size());x++){\n                  for(int y=0;y<int(tu[route[w]][route[w+1]].size());y++){\n                    if((tu[route[z]][route[z+1]][x]&tu[route[w]][route[w+1]][y])==0){\n                      d=1;\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if(d==1){\n            en=1;\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n      }\n    }\n  }\n}\n\n\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool fail() {\n    cout << \"UNSAFE\" << endl;\n    return true;\n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n\n    string S;\n    cin >> S;\n\n    vector<vector<bool>> dp(1 << 10, vector<bool>(10, false));\n    // dp[A][B] <=> Aをreserveした状態でBをlockしたいような状況にできる\n\n    // 入力の処理\n    int bit = 0;\n    for (char c : S) {\n        if (c == 'u') {\n            bit = 0;\n        } else {\n            int ci = c - '0';\n            int b = 1 << ci;\n\n            // 同じ区間に同じ数字があったらアウト\n            if ((b & bit) != 0) return fail();\n\n            dp[bit][ci] = true;\n            bit |= (1 << ci);\n        }\n    }\n\n    // AとC: reserveしている資源\n    // BとD: lockしたい資源\n    // dp[A][B]かつdp[C][D]でB in Cならdp[A|C][D]もtrue\n    for (int A = 0; A < (1 << 10); ++A) {\n        for (int B = 0; B < 10; ++B) {\n            if (!dp[A][B]) continue;\n\n            for (int C = 0; C < (1 << 10); ++C) {\n                if ((A & C) || !((C >> B) & 1)) continue;\n                // reserveする資源が重複するケースを弾く\n\n                for (int D = 0; D < 10; ++D) {\n                    if (!dp[C][D]) continue;\n                    dp[A | C][D] = true;\n                }\n            }\n        }\n    }\n\n    // dp[A][B]かつdp[C][D]でB in C, D in Aならデッドロック\n    for (int A = 0; A < (1 << 10); ++A) {\n        for (int B = 0; B < 10; ++B) {\n            if (!dp[A][B]) continue;\n\n            for (int C = 0; C < (1 << 10); ++C) {\n                if (A & C) continue;\n                // reserveする資源が重複するケースを弾く\n                for (int D = 0; D < 10; ++D) {\n                    if (!dp[C][D]) continue;\n\n                    if (((A >> D) & 1) && ((C >> B) & 1)) {\n                        return fail();\n                    }\n                }\n            }\n        }\n    }\n\n    cout << \"SAFE\" << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nint main(){\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) return 0;\n\t\tstd::string order; std::cin >> order;\n\t\tstd::vector<int> state(n + 1, 0);\n\t\tstd::vector<std::vector<int>> locking_thread(10);\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tif (order[i] != 'u') {\n\t\t\t\tfor (auto m = 0; m < 10; ++m) {\n\t\t\t\t\tif ((state[i] & (1 << m)) != 0) locking_thread[m].push_back(i);\n\t\t\t\t}\n\t\t\t\tstate[i + 1] = state[i] | (1 << (order[i] - '0'));\n\t\t\t}\n\t\t}\n\t\tstd::vector<std::vector<bool>> memo(n, std::vector<bool>(1 << 10, false));\n\t\tauto has_dead_lock = false;\n\t\tstd::queue<std::pair<int, int>> queue;\n\t\tfor (auto i = 0; i < n && !has_dead_lock; ++i) if (order[i] != 'u') {\n\t\t\tqueue.emplace(i, state[i]);\n\t\t\tmemo[i][state[i]] = true;\n\t\t\twhile (!queue.empty()) {\n\t\t\t\tauto front = queue.front(); queue.pop();\n\t\t\t\tif ((front.second & (1 << (order[front.first] - '0'))) != 0) {\n\t\t\t\t\thas_dead_lock = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (const auto other : locking_thread[order[front.first] - '0']) {\n\t\t\t\t\tif ((front.second & state[other]) == 0 && !memo[other][front.second | state[other]]) {\n\t\t\t\t\t\tmemo[other][front.second | state[other]] = true;\n\t\t\t\t\t\tqueue.emplace(other, front.second | state[other]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (has_dead_lock) std::cout << \"UNSAFE\" << std::endl;\n\t\telse std::cout << \"SAFE\" << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<int, int> P;\nint check[1 << 10][10];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tstring s;\n\twhile(cin >> N, N) {\n\t\t//cout << N << endl;\n\t\tmemset(check, 0, sizeof check);\n\t\tcin >> s;\n\n\t\tbool ok = true;\n\t\tvector<P> v;\n\t\tint x = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(s[i] == 'u') {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint y = s[i] - '0';\n\t\t\t\tif(!check[x][y]) {\n\t\t\t\t\tv.push_back({ x, y });\n\t\t\t\t\tcheck[x][y] = 1;\n\t\t\t\t}\n\n\t\t\t\tif(x >> y & 1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx |= 1 << y;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok) {\n\t\t\tcout << \"UNSAFE\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint n = 0;\n\n\t\twhile(1) {\n\t\t\tvector<P> add;\n\t\t\tfor(int i = 0; i < v.size() && ok; i++) {\n\t\t\t\tfor(int j = 0; j < v.size() && ok; j++) {\n\t\t\t\t\tif(i == j) continue;\n\t\t\t\t\tint s1 = v[i].first, t1 = v[i].second;\n\t\t\t\t\tint s2 = v[j].first, t2 = v[j].second;\n\t\t\t\t\tif(s1 & s2) continue;\n\t\t\t\t\tint ns = s1 | s2;\n\t\t\t\t\tif((s1 >> t2 & 1) && (s2 >> t1 & 1)) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((s1 >> t2 & 1) && !(s2 >> t1 & 1)) {\n\t\t\t\t\t\tif(!check[ns][t1]) {\n\t\t\t\t\t\t\tadd.push_back({ ns, t1 });\n\t\t\t\t\t\t\tcheck[ns][t1] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!(s1 >> t2 & 1) && (s2 >> t1 & 1)) {\n\t\t\t\t\t\tif(!check[ns][t2]) {\n\t\t\t\t\t\t\tadd.push_back({ ns, t2 });\n\t\t\t\t\t\t\tcheck[ns][t2] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!ok || add.size() == 0) break;\n\n\t\t\tn = v.size();\n\t\t\tfor(auto p : add) {\n\t\t\t\tv.push_back(p);\n\t\t\t}\n\t\t}\n\n\t\tif(ok) cout << \"SAFE\" << endl;\n\t\telse cout << \"UNSAFE\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\nvector<vector<int> > A;\ntypedef pair<int,int> P;\n\nbool bfs(){\n  sort(A.begin(),A.end());\n  A.erase(unique(A.begin(),A.end()),A.end());\n  int n = A.size();\n  for(int i=0;i<n;i++)\n    for(int j=0,used[10]={};j<A[i].size();j++)if(used[A[i][j]]++) return 1;\n  \n  queue<P> Q;\n  vector<vector<int> >D(1<<10,vector<int>(1<<10,INF));\n  D[0][0] = 0;\n  Q.push(P(0,0));\n\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int I = t.first,J = t.second;\n    if(I&&J&&__builtin_popcount(I&J) == D[I][J]) return 1;\n    if(D[I][J]==10) continue;    \n\n    for(int i=0;i<n;i++){\n      for(int l=0,ni=I;l<(int)A[i].size();l++){\n\tint num = A[i][l],nj =(J|1<<num);\n\tif(l&&D[ni][nj]==INF)D[ni][nj] = D[I][J]+1,Q.push(P(ni,nj));\n\tif(I&(1<<num))break;\n\tni |= (1<<num);\n\tif(D[ni][J]==INF)D[ni][J] = D[I][J] + 1,Q.push(P(ni,J));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    string str;\n    cin>>str;\n    A.clear();\n    for(int i=0;i<str.size();i++){\n      A.push_back(vector<int>());\n      while(str[i]!='u') A.back().push_back(str[i++]-'0');\n    }\n    cout<<(bfs()? \"UN\":\"\")<<\"SAFE\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <set>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<set<int> > > tu;\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    set<int> se;\n    a.assign(n+1,10);\n    tu.assign(10,vector<set<int> >(10,se));\n    char s;\n    en=0;\n    a[0]=10;\n    int ss=0;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        if(a[t-1]!=10){\n          tu[a[t-1]][a[t]].insert(ss);\n          ss=ss|mm(a[t-1]);\n          if((ss&mm(a[t]))!=0){\n            en=1;\n          }\n        }\n        else{\n          ss=0;\n        }\n        t++;\n      }\n      else{\n        ss=0;\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n\n/*    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }*/\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()){\n      if((f&mm(t))==0){\n        next(t,f,route);\n      }\n      else{\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        /*int q=0;\n        for(q=0;q<int(route.size())&&route[q]!=t;q++){\n        }\n        if(q>0){\n          route.erase(route.begin(),route.begin()+q-1);\n        }*/\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          for(int z=0;(z<int(route.size())-1)&&en!=1;z++){\n            for(int w=z+1;(w<int(route.size())-1)&&en!=1;w++){\n              for(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end()&&en==0;++x){\n                for(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end()&&en==0;++y) {\n                  if((*x&*y)==0){\n                    en=1;\n                  }\n                }\n              }\n            }\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n      }\n    }\n  }\n}\n/*\nfor(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end();++x){\nfor(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end();++y) {\n  if((*x&*y)==0){\n    en=1;\n  }\n}\n}*/\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n\nその前にrouteのかぶり\n//自分とのかぶりはバツ\n共通のかぶりバツ\nその上条件に適した組みが一つ以上ある\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint dp[1<<10][10];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    string s;\n    cin >> s;\n\n    memset(dp, false, sizeof(dp));\n    int now = 0;\n    bool safe = true;\n    REP(i, n) {\n      if(s[i] == 'u') now = 0;\n      else {\n        dp[now][s[i]-'0'] = true;\n        if(now & 1<<(s[i]-'0')) {\n          safe = false;\n          break;\n        }\n        now |= 1<<(s[i]-'0');\n      }\n    }\n\n    if(!safe) {\n      cout << \"UNSAFE\" << endl;\n      continue;\n    }\n\n    REP(s1, 1<<10) REP(t1, 10) {\n      if(!dp[s1][t1]) continue;\n      // dp[s1][t1] と マージ\n      REP(s2, 1<<10) REP(t2, 10) {\n        if(!dp[s2][t2]) continue;\n        bool cond1 = !(s1&s2) && (s2 & 1 << t1),\n             cond2 = !(s1&s2) && (s1 & 1 << t2);\n        if(cond1 && cond2) {\n          safe = false;\n        } else if(cond1) {\n          dp[s1 | s2][t2] = true;\n        } else if(cond2) {\n          dp[s1 | s2][t1] = true;\n        }\n      }\n    }\n\n    if(safe) cout << \"SAFE\" << endl;\n    else cout << \"UNSAFE\" << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n\nusing namespace std;\n\nvoid print(int a){\n\trep(i,10){\n\t\tcout << (bool)(a&(1<<i));\n\t}\n\tcout << endl;\n}\n\nvoid nex(int &n, int mask){\n\tn += 1;\n\twhile( n & mask ){\n\t\tn += n&mask;\n\t}\n}\n\nint main(){\n//\t\tint a = 6;\n//\t\tcout << \"a=\" << a << endl;\n//\t\tprint(a);\n//\t\tfor(int b=0; b<32; nex(b,a)) print(b);\n//\t\tcout << endl;\n//\t\treturn 0;\n\n\tint n;\n\twhile(cin >> n, n){\n\t\tbool ans = true;\n\t\tstring s;\n\t\tcin >> s;\n\t\t\n\t\t//bool memo[1<<10][1<<10] = {};\n\t\tset<int> memo[1<<10];\n\t\tint st=0;\n\t\tfor(auto c: s){\n\t\t\tif( c == 'u' ){\n\t\t\t\tst = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint k = c - '0';\n\t\t\tint nx = (1<<k);\n\t\t\tif( st & nx ) ans = false;\n\t\t\t//memo[st][nx] = true;\n\t\t\tmemo[st].insert( nx );\n\t\t\tst |= nx;\n\t\t}\n\n\t\trep(a,1<<10) for(int b=0; b<(1<<10); nex(b,a)) if(a&&b) for(auto x: memo[a]) for(auto y: memo[b]){\n\t\t\t//if( a & b ) continue;\n\t\t\t//int x = memo[a];\n\t\t\t//int y = memo[b];\n\t\t\t//if( (b&x) && (a&y) ) ans = false;\n\t\t\t//memo[ a|b ][ x|y ] = true;\n\t\t\tmemo[ a|b ].insert( x|y );\n\t\t}\n\n\t\trep(a,1<<10) for(auto x: memo[a]){\n\t\t\tif( (a&x) == x ) ans = false;\n\t\t}\n\n\t\tcout << (ans ? \"SAFE\" : \"UNSAFE\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int N;\n\n    while(cin >> N, N) {\n        string s; cin >> s;\n\n        vector< vector<int> > dp(1 << 10, vector<int>(10));\n        int bit = 0, ok = true, ok1 = true;\n        for(int i=0; i<N; i++) {\n            if(s[i] == 'u') {\n                bit = 0;\n                ok1 = true;\n            }\n            else {\n                int c = s[i] - '0';\n                if(bit >> c & 1) {\n                    ok = ok1 = false;\n                    continue;\n                }\n                bit |= (1 << c);\n\n                if(s[i+1] != 'u' && ok1) {\n                    dp[bit][ s[i+1] - '0' ] = true;\n                    // printf(\"bit = %d, nxt = %d -> true\\n\", bit, s[i+1] - '0');\n                }\n            }\n        }\n\n        while(1) {\n            bool update = false;\n            vector< vector<int> > nxt = dp;\n            for(int bita=0; bita<(1<<10); bita++) {\n                for(int x=0; x<10; x++) {\n                    if(dp[bita][x] == false) continue;\n                    int rest = ((1 << 10) - 1) ^ bita;\n                    for(int bitb=rest; ; bitb=(bitb-1)&rest) {\n                        for(int y=0; y<10; y++) {\n                            if(dp[bitb][y] == false) continue;\n\n                            int nbit = bita | bitb;\n                            if(nxt[nbit][y]) continue;\n                            if(!(bitb >> x & 1)) continue;\n                            if( (bitb >> x & 1) && (bita >> y & 1) ) ok = false;\n                            // printf(\"nbit = %d, y = %d -> true\\n\", nbit, y);\n                            update = nxt[nbit][y] = true;\n                        }\n                        if(bitb == 0) break;\n                    }\n                }\n            }\n            if(!update) break;\n            swap(dp, nxt);\n        }\n        printf(\"%s\\n\", ok ? \"SAFE\" : \"UNSAFE\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint popcount(int x){\n  int ans=0;\n  while(x!=0){ans+=x&1;x>>=1;}\n  return ans;\n}\n\n\nint main(){\n    while(1){\n        int n; cin >> n;\n        if(n==0) break;\n        bool jotai[1<<10][10]={};\n        string po;\n        cin >> po;\n        for(int i=0;i<po.size();i++){\n          if(po[i]=='u'){\n            int j=i-1;\n            while(j>=0&&po[j]!='u')j--;\n            j++;\n            for(int k=j+1;k<min(i,j+11);k++){\n              int S=0;\n              for(int l=j;l<k;l++)S|=1<<(po[l]-'0');\n              jotai[S][po[k]-'0']=true;\n            }\n          }\n        }\n        for(int len=2;len<=10;len++){\n          for(int S=1;S<(1<<10);S++){\n            if(popcount(S)==len){\n\n              for(int x=0;x<=9;x++){\n                for(int Sprime1=1;Sprime1<S;Sprime1++){\n                  if(jotai[Sprime1][x]==true&&(S^Sprime1)==S-Sprime1){\n                    for(int y=0;y<=9;y++){\n                      if((Sprime1>>y)%2==1&&jotai[S^Sprime1][y]==1)jotai[S][x]=true;\n                    }\n                  }\n                }\n              }\n\n            }\n          }\n        }\n        int isOK=1;\n        for(int x=0;x<=9;x++)for(int S=1;S<(1<<10);S++)if(jotai[S][x]==true&&(S>>x)%2==1)isOK=0;\n      //  printf(\"%d\",jotai[3][1]);\n        if(isOK)printf(\"SAFE\\n\");\n        else printf(\"UNSAFE\\n\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\twhile(1){\n\t\tint n; string s; cin >> n; if(n==0) return 0; cin >> s;\n\t\tint dp[(1<<10)+5]={};\n\t\tint cur = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(s[i] == 'u'){\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[cur] |= (1<<(s[i]-'0')); //cout << cur << \" \" << (1<<(s[i]-'0'));\n\t\t\t\tcur |= (1<<(s[i]-'0'));\n\t\t\t}\n\t\t}\n\t\tint dp2[(1<<10)+5]={};\n\t\tfor(int i=0;i<(1<<10);i++){\n\t\t        dp2[i] = dp[i];\n\t\t        //if(i<8) cout << i <<\" \" << dp[i] <<  endl;\n\t\t}\n\t\tfor(int R=0;R<9;R++){\n\t\t\tfor(int i=0;i<(1<<10);i++){\n\t\t\t\tfor(int j=0;j<(1<<10);j++){\n\t\t\t\t\tif( (i&j) != j ) continue;\n\t\t\t\t\tif(!dp2[i-j] || !dp[j]) continue;\n\t\t\t\t\tdp2[i] |= dp2[i-j];\n\t\t\t\t\tdp2[i] |= dp[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){\n\t\t\tif( dp2[i] != 0 && (dp2[i]&i) == dp2[i] ){\n\t\t\t    //if(n==8) cout << i << \" \" << dp2[i] << endl;\n\t\t\t\tputs(\"UNSAFE\"); goto ok;\n\t\t\t}\n\t\t}\n\t\tputs(\"SAFE\"); ok:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\n\nvector<vector<int> > A;\nvoid Min(int &a,int b){a=min(a,b);}\n\nbool DP(){\n  int n = A.size();\n  for(int i=0;i<n;i++)\n    for(int j=0,used[10]={};j<A[i].size();j++)if(used[A[i][j]]++) return 1;\n\n\n  vector<vector<int> >dp(1<<10,vector<int>(1<<10,INF));\n  dp[0][0] = 0;\n\n\n\n  for(int i=0;i<n;i++)\n    for(int j=(1<<10)-1;j>=0;j--)\n      for(int k=(1<<10)-1;k>=0;k--){\n\tif(dp[j][k] == INF||dp[j][k] == 10) continue;\n\n\tfor(int l=0,nj=j;l<(int)A[i].size();l++){\n\t  int num = A[i][l];\n\t  if(l)Min(dp[nj][k|(1<<num)],dp[j][k]+1);\n\t  if(j&(1<<num))break;\n\t  nj |= (1<<num);\n\t  Min(dp[nj][k],dp[j][k]+1);\n\t}\n      }\n  \n\n  for(int i=1;i<(1<<10);i++)\n    for(int j=1;j<(1<<10);j++){\n      int c = __builtin_popcount(i&j);\n      if(c == dp[i][j]) return 1;\n    }\n  return 0;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    string str;\n    cin>>str;\n    A.clear();\n    for(int i=0;i<str.size();i++){\n      A.push_back(vector<int>());\n      while(str[i]!='u') A.back().push_back(str[i++]-'0');\n    }\n    cout<<(DP()? \"UN\":\"\")<<\"SAFE\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nvector<string> split(string s, string p) {\n  vector<string> ret;\n  ll h = 0;\n\n  REP(i, 0, s.size() - p.size() + 1) if(s.substr(i, p.size()) == p) {\n    ret.push_back(s.substr(h, i - h));\n    h = i + p.size();\n    i += (ll) p.size() - 1;\n  }\n  ret.push_back(s.substr(h, (ll) s.size() - h));\n\n  return ret;\n}\n\nclass StronglyConnectedComponent {\npublic:\n  const ll N;\n  vector< vector<ll> > E, R;\n  vector<ll> component;\n\n  StronglyConnectedComponent(ll N): N(N), E(N), R(N), component(N) {}\n\n  void add_edge(ll u, ll v) {\n    E[u].push_back(v);\n    R[v].push_back(u);\n  }\n\n  ll discomposit() {\n    vector<ll> vs;\n    vector<bool> used1(N, false);\n    REP(i, 0, N) if(!used1[i]) dfs(i, vs, used1);\n\n    vector<bool> used2(N, false);\n    ll k = 0;\n    for(ll i = vs.size() - 1; i >= 0; i--) if(!used2[vs[i]]) rdfs(vs[i], k++, used2);\n    return k;\n  }\n\nprivate:\n  void dfs(ll v, vector<ll> &vs, vector<bool> &used) {\n    used[v] = true;\n    REP(i, 0, E[v].size()) if(!used[E[v][i]]) dfs(E[v][i], vs, used);\n    vs.push_back(v);\n  }\n\n  void rdfs(ll v, ll k, vector<bool> &used) {\n    used[v] = true;\n    component[v] = k;\n    REP(i, 0, R[v].size()) if(!used[R[v][i]]) rdfs(R[v][i], k, used);\n  }\n};\n\nint main(void) {\n  ll N;\n  while(cin >> N, N) {\n    string S;\n    cin >> S;\n    S.resize(S.size() - 1);\n\n    vector<string> seq = split(S, \"u\");\n\n    // cerr << \"  seq: \";\n    // REP(i, 0, seq.size()) cerr << seq[i] << \" \";\n    // cerr << endl;\n\n    StronglyConnectedComponent scc(10);\n    for(string s : seq) if(s.size() > 0) {\n      REP(i, 0, s.size() - 1) {\n        ll u = s[i] - '0', v = s[i + 1] - '0';\n        scc.add_edge(u, v);\n      }\n    }\n    ll k = scc.discomposit();\n\n    // cerr << \"  component: \";\n    // REP(i, 0, 10) cerr << scc.component[i] << \" \";\n    // cerr << endl;\n\n    vector<ll> cnt(k, 0);\n    vector<bool> loop(k, false);\n    REP(i, 0, 10) cnt[scc.component[i]]++;\n    REP(i, 0, k) if(cnt[i] > 1) loop[i] = true;\n\n    // cerr << \"  loop: \";\n    // REP(i, 0, k) cerr << loop[i] << \" \";\n    // cerr << endl;\n\n    vector<vector<ll>> ref(k);\n    for(string s : seq) if(s.size() > 0) {\n      ll t = scc.component[s[0] - '0'];\n      if(loop[t]) ref[t].push_back(s[0] - '0' + 100);\n\n      REP(i, 0, s.size() - 1) {\n        ll u = scc.component[s[i] - '0'];\n        ll v = scc.component[s[i + 1] - '0'];\n        if(u != v && loop[v]) ref[v].push_back(u);\n      }\n    }\n    REP(i, 0, k) {\n      sort(ref[i].begin(), ref[i].end());\n      ref[i].erase(unique(ref[i].begin(), ref[i].end()), ref[i].end());\n    }\n\n    bool ok = true;\n    REP(i, 0, k) if(loop[i]) ok = ok && ref[i].size() <= 1;\n    for(string s : seq) if(s.size() > 0) {\n      vector<bool> used(10, false);\n      REP(i, 0, s.size()) {\n        ll d = s[i] - '0';\n        ok = ok && !used[d];\n        used[d] = true;\n      }\n    }\n\n    cout << (ok ? \"SAFE\" : \"UNSAFE\") << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nset<int> dp[1<<11];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<(1<<10);i++){\n\t\t\tdp[i].clear();\n\t\t}\n\t\tstring str;\n\t\tcin >> str;\n\t\tint bits=0;\n\t\tbool flag=true;\n\t\tint v2=-1;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif(str[i]=='u'){\n\t\t\t\tbits=0;\n\t\t\t\tv2=-1;\n\t\t\t}else{\n\t\t\t\tif(v2==-1){\n\t\t\t\t\tv2=str[i]-'0';\n\t\t\t\t\tbits=(1<<v2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v=str[i]-'0';\n\t\t\t\tif((bits>>v) & 1)flag=false;\n\t\t\t\tdp[bits].insert(1<<v);\n\t\t\t\tbits|=(1<<v);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){\n\t\t\tif(!flag)break;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif((i&j)==j){\n\t\t\t\t\tset<int>::iterator it=dp[j].begin();\n\t\t\t\t\tfor(;it!=dp[j].end();it++){\n\t\t\t\t\t\tset<int>::iterator it2=dp[i-j].begin();\n\t\t\t\t\t\tfor(;it2!=dp[i-j].end();it2++){\n\t\t\t\t\t\t\tint v=(*it)|(*it2);\n\t\t\t\t\t\t\tdp[i].insert(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tset<int>::iterator it=dp[i].begin();\n\t\t\tfor(;it!=dp[i].end();it++){\n\t\t\t\tbool ok=false;\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tif((!(i>>k & 1)) && ((*it)>>k & 1))ok=true;\n\t\t\t\t}\n\t\t\t\tif(!ok)flag=false;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"SAFE\":\"UNSAFE\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nbool check(vector<int>& dp){\n\trep(i,dp.size()){\n\t\tif(i == 0) continue;\n\t\tif((i bitand dp[i]) == dp[i]) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tset<pair<int,int>> st;\n\n\t\tint bit = 0;\n\t\trep(i,s.size() - 1){\n\t\t\tif(s[i] == 'u') bit = 0;\n\t\t\telse bit |= 1 << (s[i] - '0');\n\n\t\t\t//show(bitset<10>(bit))\n\t\t\tif(s[i + 1] != 'u' and bit != 0) st.emplace(bit, s[i + 1] - '0');\n\t\t}\n\n\t\t//for(auto i : st){\n\t\t//\tcout << bitset<10>(i.first) << ' ' << i.second << endl;\n\t\t//}\n\n\t\tvector<int> dp(1 << 10, -1);\n\t\tdp[0] = 0;\n\t\trep(s,1 << 10){\n\t\t\tif(dp[s] == -1) continue;\n\t\t\tfor(auto p : st){\n\t\t\t\tbit = p.first;\n\t\t\t\tint nxt = p.second;\n\n\t\t\t\tif((bit bitand s) != 0) continue;\n\n\t\t\t\tint nbit = bit bitor s;\n\t\t\t\tif(dp[nbit] == -1) dp[nbit] = 1 << nxt;\n\t\t\t\telse dp[nbit] |= 1 << nxt;\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,dp.size()){\n\t\t//\tif(dp[i] != -1) cout << bitset<10>(i) << ' ' << bitset<10>(dp[i]) << endl;\n\t\t//}\n\n\t\tcout << (check(dp) ? \"SAFE\" : \"UNSAFE\") << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n \nint n;\nchar s[MAX_N];\nbool t[11][(1<<10)];\nbool dp[11][(1<<10)];\n \nbool check(int S){\n  memset(dp,false,sizeof(dp));\n  dp[0][0]=true;\n  int a=1;\n  for(int i=0;i<10;i++){\n    if(~S>>i&1)continue;\n    for(int j=0;j<(1<<10);j++){\n      if(!t[i][j])continue;\n      int k=(1<<10)-1-j;\n      while(1){\n        dp[a][j+k]|=dp[a-1][k];\n        if(dp[a][j+k] && ((j+k)&S)==S )return true;\n        if(k==0)break;\n        k=(k-1)&(~j);\n      }\n    }\n    a++;\n  }\n  return false;\n}\n \nbool solve(){\n  for(int bit=0;bit<(1<<10);bit++)\n    if(check(bit))return true;\n  return false;\n}\n \nint main(){\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    memset(t,false,sizeof(t));\n    scanf(\"%s\",s);\n    int bit=0;\n    for(int i=0;i<n;i++){\n      if(s[i]=='u')bit=0;\n      if('0'<=s[i]&&s[i]<='9'){\n        int num=s[i]-'0';\n        t[ num ][ bit ] = true;\n        bit|=(1<<num);\n      }\n    }\n    if(solve() )printf(\"UNSAFE\\n\");\n    else printf(\"SAFE\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\n\nint main() {\n   for(;;) {\n      Int n;\n      std::cin >> n;\n      if( n == 0 ) break;\n      std::string ss;\n      std::cin >> ss;\n      std::set<std::pair<Int,Int>> set;\n      bool res = true;\n      {\n         Int state = 0;\n         for(Int i = 0; i < n; ++i) {\n            if( ss[i] == 'u' ) {\n               state = 0;\n               continue;\n            }\n            set.insert(std::make_pair(state, ss[i]-'0'));\n            if( (state & (1 << (ss[i]-'0'))) != 0 ) {\n               res = false;\n            }\n            state |= 1 << (ss[i]-'0');\n         }\n      }\n      for(Int i = 0; i < 10; ++i) {\n         std::vector<std::pair<Int,Int>> buf;\n         for(auto a : set) {\n            for(auto b : set) {\n               Int as, at, bs, bt;\n               std::tie(as,at) = a;\n               std::tie(bs,bt) = b;\n               if( (as & bs) == 0 ) {\n                  if( ( (as & (1 << bt)) == 0 ) and ( (bs & (1 << at)) != 0 ) ) {\n                     buf.emplace_back(as|bs, bt);\n                  }\n                  if( ( (bs & (1 << at)) == 0 ) and ( (as & (1 << bt)) != 0 ) ) {\n                     buf.emplace_back(as|bs, at);\n                  }\n               }\n            }\n         }\n         for(auto t : buf) {\n            set.insert(t);\n         }\n      }\n      for(auto a : set) {\n         for(auto b : set) {\n            Int as, at, bs, bt;\n            std::tie(as,at) = a;\n            std::tie(bs,bt) = b;\n            if( (as & bs) == 0 and (as & (1 << bt)) != 0 and (bs & (1 << at)) != 0 ) {\n               res = false;\n            }\n         }\n      }\n      puts(res ? \"SAFE\" : \"UNSAFE\");\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\nvvint vv;\nbool vis1[1<<10];\nint vis2[1<<10][1<<10];\nint saiki(int a,int b,int c){\n\tif(vis2[a][b]>=0) return vis2[a][b];\n\tvis2[a][b]=2;\n\tfor(int y:vv[a]){\n\t\tif(y==c) return vis2[a][b]=1;\n\t\tif(y+b!=(y|b)) continue;\n\t\tif(saiki(y,y|b,c)==1) return vis2[a][b]=1;\n\t}\n\treturn 2;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tvv=vvint(1<<10);\n\t\trep(i,1<<10) vis1[i]=false;\n\t\trep(i,1<<10) rep(j,1<<10) vis2[i][j]=-1;\n\t\tint state=0;\n\t\tvvint ww(1<<10);\n\t\tbool ans=false;\n\t\trep(i,s.size()){\n\t\t\tif(s[i]=='u'){\n\t\t\t\tstate=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint t=s[i]-'0';\n\t\t\tif(state&(1<<t)) ans=true;\n\t\t\tif(s[i+1]=='u') continue;\n\t\t\tstate|=1<<t;\n\t\t\tww[state].PB(s[i+1]-'0');\n\t\t}\n\t\trep(i,1<<10){\n\t\t\tfor(int x:ww[i]){\n\t\t\t\trep(j,1<<10){\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tif(!(j&(1<<x))) continue;\n\t\t\t\t\tif(i+j!=(i|j)) continue;\n\t\t\t\t\tvv[i].PB(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,1<<10){\n\t\t\tif(ww[i].size()==0) continue;\n\t\t\tif(saiki(i,i,i)==1) ans=true;\n\t\t}\n\t\tputs(ans?\"UNSAFE\":\"SAFE\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> e[11][11];\nvector<int> G[11];\nbool visit[11];\n\nvoid dfs(int u,vvi& route,vi& hoge)\n{\n    visit[u] = true;\n    rep(i,len(G[u])){\n        if(visit[G[u][i]]){\n            vi ag;\n            rep(j,len(hoge)){\n                if(hoge[j] == G[u][i]){\n                    for(;j<len(hoge);j++){\n                        ag.pb(hoge[j]);\n                    }\n                }\n            }\n            ag.pb(u);\n            route.pb(ag);\n        }else{\n            hoge.pb(u);\n            dfs(G[u][i],route,hoge);\n            hoge.pop_back();\n        }\n    }\n}\n\nint main()\n{\n    // cin.tie(0);\n    // ios::sync_with_stdio(false);ccccc\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        string s;\n        cin >> s;\n        int kp = 0;\n        bool end = false;\n        rep(i,10){\n            rep(j,10){\n                e[i][j].clear();\n            }\n        }\n        rep(i,10){\n            G[i].clear();\n            visit[i] = false;\n        }\n        rep(i,len(s)){\n            if(s[i] == 'u'){\n                kp = 0;\n            }else if(kp & (1 << (int)(s[i]-'0'))){\n                cout << \"UNSAFE\\n\";\n                end = true;\n                break;\n            }else{\n                kp |= (1 << (int)(s[i]-'0'));\n            }\n        }\n        if(end){\n            continue;\n        }\n        kp = 0;\n        rep(i,len(s)-1){\n            if(s[i] != 'u'){\n                if(s[i+1] != 'u'){\n                    int a = (int)(s[i]-'0'),b = (int)(s[i+1]-'0');\n                    e[a][b].pb(kp);\n                    kp |= (1 << (int)(s[i]-'0'));\n                }\n            }else{\n                kp = 0;\n            }\n        }\n        rep(i,10){\n            rep(j,10){\n                if(len(e[i][j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        rep(i,10){\n            if(!visit[i]){\n                vvi route;\n                vi hoge;\n                dfs(i,route,hoge);\n                // rep(i,len(route)){\n                //     svec(route[i]);\n                // }\n                rep(j,len(route)){\n                    int loop = len(route[j]);\n                    vvi vec(loop);\n                    rep(k,len(route[j])){\n                        int a = route[j][k],b = route[j][(k+1)%loop];\n                        vec[k] = e[a][b];\n                    }\n                    set<int> dp[11];\n                    dp[0].insert(0);\n                    rep(j,loop){\n                        each(k,dp[j]){\n                            rep(l,len(vec[j])){\n                                if(!(k & vec[j][l])){\n                                    dp[j+1].insert(k|vec[j][l]);\n                                }\n                            }\n                        }\n                    }\n                    if(len(dp[loop])){\n                        cout << \"UNSAFE\\n\";\n                        end = true;\n                        break;\n                    }\n                }\n                if(end){\n                    break;\n                }\n            }\n        }\n        if(!end){\n            cout << \"SAFE\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n// VI tsort(VVI g) {\n//   int n = g.size();\n//   vector<bool> used(n, false);\n//   vector<int> ans;\n//\n//   function<void(int)> dfs = [&](int u) {\n//     if(used[u]) return;\n//     used[u] = true;\n//     for(auto& i: g[u]) dfs(i);\n//     ans.push_back(u);\n//   };\n//\n//   for(int i=0; i<n; ++i) dfs(i);\n//   reverse(ans.begin(), ans.end());\n//   return ans;\n// }\n\nVI tsort(VVI g) {\n  const int n = g.size();\n  VI h(n, 0);\n  REP(i, n) for(int j: g[i]) h[j]++;\n\n  stack<int> st;\n  REP(i, n) if(h[i] == 0) st.push(i);\n\n  VI ans;\n  while(st.size()) {\n    int i = st.top(); st.pop();\n    ans.push_back(i);\n    for(auto& j: g[i]) {\n      h[j]--;\n      if(h[j] == 0) st.push(j);\n    }\n  }\n\n  return ans;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    bool safe;\n    int n;\n    cin >> n;\n    if(!n) break;\n    string s;\n    cin >> s;\n\n    safe = true;\n    vector<PII> v(n);\n    int now = 0;\n    REP(i, n) {\n      int nxt = -1;\n      if(i < n && isdigit(s[i])) nxt = s[i] - '0';\n      v[i] = {now, nxt};\n\n      if(s[i] == 'u') {\n        now = 0;\n      } else {\n        if(now & 1 << (s[i] - '0')) {\n          safe = false;\n          break;\n        }\n        now |= 1 << (s[i] - '0');\n      }\n    }\n    if(!safe) {\n      cout << \"UNSAFE\" << endl;\n      continue;\n    }\n\n    VVI g(n, VI(0));\n    REP(i, n) FOR(j, i+1, n) {\n      if(v[i].second == -1 || v[j].second == -1) continue;\n      if(v[i].first & v[j].first) continue;\n      if((v[i].first & 1 << v[j].second)) {\n        // j->iに辺を貼る\n        g[j].PB(i);\n      }\n      if(v[j].first & 1 << v[i].second) {\n        // i->jに辺を貼る\n        g[i].PB(j);\n      }\n    }\n\n    // REP(i, n) cout << g[i] << endl;\n\n    VI ans = tsort(g);\n    // cout << ans << endl;\n    if(ans.size() != n) safe = false;\n\n    if(safe) cout << \"SAFE\" << endl;\n    else cout << \"UNSAFE\" << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < (n); i++)\nusing namespace std;\n\nint n;\nstring s;\nbool dp[1024][1025];\t//dp[S][T] = (ロック資源の集合がS, 待ち資源の集合がT)になることがあるか\n\nbool solve() {\n\tint i, j, k, l;\n\t\n\tint locked = 0, waiting = 0;\n\trep(i, s.length()) {\n\t\tif ('0' <= s[i] && s[i] <= '9') {\n\t\t\twaiting = s[i] - '0';\n\t\t\tdp[locked][1 << waiting] = true;\n\t\t\tlocked = locked + (1 << waiting);\n\t\t}\n\t\telse {\n\t\t\twaiting = 10;\t//T is covered Sが常に偽になる設定.\n\t\t\tdp[locked][1 << waiting] = true;\n\t\t\tlocked = 0;\n\t\t}\n\t}\n\t\n\trep(i, 1024) {\n\t\t//iと排反なnumberを探す.\n\t\tint digit[10]; int dNum = 0;\n\t\trep(k, 10) {\n\t\t\tif ((i >> k) % 2 == 0) {\n\t\t\t\tdigit[dNum++] = k;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(j, 1025) {\n\t\t\tif (!dp[i][j]) continue;\n\t\t\tif ((i | j) == i) return true;\n\t\t\t\n\t\t\trep(k, 1<<dNum) {\n\t\t\t\tint locked = 0;\n\t\t\t\trep(l, dNum) if ((k >> l) & 1) locked += (1 << digit[l]);\n\t\t\t\t//waiting = 2^0, 2^1, …, 2^10\n\t\t\t\trep(l, 11) {\n\t\t\t\t\tif (dp[locked][1 << l]) {\n\t\t\t\t\t\tdp[i | locked][min(1024, j | (1 << l))] = true;\t//範囲外参照に注意！\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, 1024) {\n\t\trep(j, 1025) {\n\t\t\tif (!dp[i][j]) continue;\n\t\t\tif ((i | j) == i) return true;\t//UNSAFE\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tint i, j;\n\t\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\tcin >> s;\n\t\trep(i, 1024) rep(j, 1025) dp[i][j] = false;\n\t\tbool res = solve();\n\t\tif (res) cout << \"UNSAFE\" << endl;\n\t\telse cout << \"SAFE\" << endl;\n\t}\n\treturn 0;\n}\n\n//ポイント：\n//・2段がまえの論理。\n//・「全体集合から、ありえる状態集合を抽出☆」→「ありえる状態集合から、デッドロックが起きるものを抽出★」\n//・「初期状態から「ある状態」に至れるか」の判定を直接的にできるのが、この問題のポイント。\n//・「初期状態から「デッドロックが起きる状態」に至れるか」を直接判定しようとすると、再帰を考えることになり、このアプローチでは高速化を大して望めない。\n//\n//自分用解説：\n//「各kについて、スレッドkで命令がa_k個処理された状態」になりえるかは、容易に求まる。（現在ロックしている資源がかぶっていないかを判定するだけ）\n//なりえる状態のうち、(次確保したい資源の集合)が(ロックした資源の集合)の部分集合になるものでは、デッドロックが起きる。\n//そういうものがない場合は、デッドロックは決して起きない。\n//\n//{a_1,…,a_10}をすべて試すとO(10000^10)くらいになり間に合わない。a_1, a_2, …の順で決めていくと考えると、わざわざ{a_k}を直接持たなくて良いことに気付く。\n//なぜかというと、可能な{a_[i+1], …, a_10}の組み合わせは、\n//・現在i個のスレッドのカーソルを確定させた。現在ロックしている資源はS\n//という情報から定まり、\n//デッドロックの判定は、この情報に\n//・確保したい資源はT\n//という情報を追加すればできるからである。よって、{a}の情報を持たずに探索ができる。(典型的なDP\n//さらに、もう少し考えるとT - S(次確保「できる」資源の集合)を保存することでもデッドロックの判定ができるので、\n//・i, S, T - S\n//を使ってDPできることが分かる。\n//\n//また、この探索において、a_iの値を決めることは、「スレッドiでロックしている資源s_i, ロックしたい資源t_iを確定させる」\n//ことに他ならないため、a_iを試す代わりに(s_i, t_i)組を試してもよい。\n//しかし今回は文字列の長さがそこまで長くないため、直接a_iの値を試せばよい。(10000 < 2^10 * 10なので、上記の工夫はあまり意味がない)\n//\n//計算量は、(S, T - S)の組み合わせが3^10通り, iが11通り, 遷移が高々n(<=10000)通りより、3^10 * 11 * nくらいになる。\n//…あれ、間に合わない。\n//\n//\n//自分用解説2:\n//デッドロックは、次欲しい資源がすべてロックされていることである。\n//ロックされている資源の集合をS, 次欲しい資源の集合をTとして、ありえる(S, T)の組み合わせを列挙することを考える。(☆)\n//1スレッドのとき、ありえる(S, T)の組み合わせは簡単に求まる。その集合を{(s_i, t_i), 1≦i≦hoge}とおく。\n//2スレッドのときは、すでにロックしている資源をロックしなければよく、命令列も全スレッド共通なので、\n//・(s_i or s_j, t_i or t_j) (s_i and s_j = empty)\n//を列挙すればいいことに気付く。\n//3スレッドのときも同様。\n//今回の問題は、資源の個数≦スレッドの数より、スレッドの数に限りがないと考えてよく、\n//ありえる(S, T)について、(S or s_i, T or t_i) (S and s_i = empty)を更新が止まるまでやればいいことが分かる。\n//↑はS or s_iがSやs_iを含むことから、Sを2進数で表し、S=0,1,2,…の順で更新していけばいいことが分かる。\n//\n//一見, hoge=n, Sが2^10通り, Tが2^10通りで、2^20 * 10000 = 100億で間に合わないように見えるが、S and s_i = emptyとなるiだけを列挙すると、\n//間に合う。計算量解析：1がk個立っているSはcomb[10][k]通り. そのSについて、S and s_i = emptyなるs_iは2^(10-k)通り. Tは2^10通り. t_iは高々11通り.\n//Σcomb[10][k] * 2^(10 - k) = 3^10より、計算量は3^10 * 2^10 * 11 ≒ 6.6 * 10^8となる。(ダメやんけ)\n//\n//余談：\n//☆で「スレッドのカーソルの位置」を列挙したくなりがちだが、デッドロックの条件から、(S, T)の組み合わせを列挙する方が後々筋が良い。\n//「列挙するもの」は必ずしも「愚直な全探索」と同一にしなくても良いので、都合の良いものを列挙しよう。\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\nvector<vector<int> > A;\ntypedef pair<short,short> P;\n\nbool bfs(){\n  sort(A.begin(),A.end());\n  A.erase(unique(A.begin(),A.end()),A.end());\n  int n = A.size();\n  for(int i=0;i<n;i++)\n    for(int j=0,used[10]={};j<A[i].size();j++)if(used[A[i][j]]++) return 1;\n  \n  queue<P> Q;\n  vector<vector<int> >D(1<<10,vector<int>(1<<10,INF));\n  D[0][0] = 0;\n  Q.push(P(0,0));\n\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    short I = t.first,J = t.second;\n    if(I&&J&&__builtin_popcount(I&J) == D[I][J]) return 1;\n    if(D[I][J]==10) continue;    \n\n    for(int i=0;i<n;i++){\n      for(int l=0,ni=I;l<(int)A[i].size();l++){\n\tshort num = A[i][l],nj =(J|1<<num);\n\tif(l&&D[ni][nj]==INF)D[ni][nj] = D[I][J]+1,Q.push(P(ni,nj));\n\tif(I&(1<<num))break;\n\tni |= (1<<num);\n\tif(D[ni][J]==INF)D[ni][J] = D[I][J] + 1,Q.push(P(ni,J));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    string str;\n    cin>>str;\n    A.clear();\n    for(int i=0;i<str.size();i++){\n      A.push_back(vector<int>());\n      while(str[i]!='u') A.back().push_back(str[i++]-'0');\n    }\n    cout<<(bfs()? \"UN\":\"\")<<\"SAFE\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint n; bool ok[1028]; string s;\nint main() {\n\twhile (cin >> n, n) {\n\t\tcin >> s;\n\t\tbool flag = false;\n\t\tfor (int i = 1; i < 1024; i++) {\n\t\t\tfor (int j = 0; j < 1024; j++) ok[j] = false;\n\t\t\tint bit = 0;\n\t\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\t\tif (s[j] == 'u') bit = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (i & (1 << (s[j] - 48))) ok[bit] = true;\n\t\t\t\t\tbit |= 1 << (s[j] - 48);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tfor (int k = j; k > 0; k = (k - 1) & j) {\n\t\t\t\t\tif ((j & k) == k && ok[j - k] && ok[k]) ok[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok[i]) flag = true;\n\t\t}\n\t\tcout << (flag ? \"UNSAFE\" : \"SAFE\") << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\nint nextO[10];\nint have_lock[10];\nint N;\nstring s;\n\nbool dfs(int thread_i){\n\tif(thread_i > 9){\n\t\treturn false;\n\t}\n\n\tbool used_u = false;\n\tbool res = false;\n\tfor(int s_i = 0;s_i < N;s_i++){\n\t\tif(s[s_i] == 'a'){\n\t\t\tnextO[thread_i] = 1 << (s[s_i + 1] - '0');\n\t\t\tbool already_used = false;\n\t\t\tREP(i,thread_i){\n\t\t\t\tif(have_lock[i] & (1 << (s[s_i + 1] - '0'))){\n\t\t\t\t\talready_used = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(already_used) return false;\n\t\t}else if(s[s_i] == 'u'){\n\t\t\thave_lock[thread_i] = 0;\n\t\t\tif(s_i + 1 < N && s[s_i + 1] != 'u'){\n\t\t\t\tnextO[thread_i] = 1 << (s[s_i + 1] - '0');\n\t\t\t}else{\n\t\t\t\tnextO[thread_i] = 0;\n\t\t\t}\n\t\t}else{\n\t\t\tbool already_used = false;\n\t\t\tREP(i,thread_i + 1){\n\t\t\t\tif(have_lock[i] & (1 << (s[s_i] - '0'))){\n\t\t\t\t\talready_used = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(already_used){ //?????¢???\n\t\t\t\tREP(i,thread_i + 1){\n\t\t\t\t\tif(have_lock[thread_i] & nextO[i]){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{ //???????????????,??????????????????\n\t\t\t\thave_lock[thread_i] |= 1 << (s[s_i] - '0');\t\t\t\t\n\t\t\t}\n\t\t\tif(s_i + 1 < N && s[s_i + 1] != 'u'){\n\t\t\t\tnextO[thread_i] = 1 << (s[s_i + 1] - '0');\n\t\t\t}else{\n\t\t\t\tnextO[thread_i] = 0;\n\t\t\t}\n\t\t\tres = dfs(thread_i + 1);\n\t\t\tif(res) break;\n\t\t\tif(already_used){\n\t\t\t\twhile(s_i + 1 < N && s[s_i + 1] != 'u'){\n\t\t\t\t\ts_i++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\thave_lock[thread_i] = 0;\n\tnextO[thread_i] = 0;\n\treturn res;\n}\n\nint main(){\n\n\twhile(cin >> N, N){\n\t\tcin >> s;\n\t\ts = 'a' + s;\n\t\tN++;\n\t\tcout << (dfs(0) ? \"UNSAFE\" : \"SAFE\") << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nvector<string> split(string s, string p) {\n  vector<string> ret;\n  ll h = 0;\n\n  REP(i, 0, s.size() - p.size() + 1) if(s.substr(i, p.size()) == p) {\n    ret.push_back(s.substr(h, i - h));\n    h = i + p.size();\n    i += (ll) p.size() - 1;\n  }\n  ret.push_back(s.substr(h, (ll) s.size() - h));\n\n  return ret;\n}\n\nint main(void) {\n  ll N;\n  while(cin >> N, N) {\n    string S;\n    cin >> S;\n    S.resize(S.size() - 1);\n\n    vector<string> seq = split(S, \"u\");\n\n    bool ok = true;\n    vector<vector<bool>> dp(1 << 10, vector<bool>(10));\n    queue<pll> q;\n\n    for(string s : seq) if(s.size() > 0) {\n      ll x = 0;\n      for(char c : s) {\n        ll d = c - '0';\n        dp[x][d] = true;\n        q.push(pll(x, d));\n        if(x & (1 << d)) ok = false;\n        x = x | (1 << d);\n      }\n    }\n\n    while(q.size()) {\n      ll x1 = q.front().first, d1 = q.front().second;\n      q.pop();\n      dp[x1][d1] = true;\n      REP(x2, 0, 1 << 10) REP(d2, 0, 10) if(!(x1 & x2) && dp[x2][d2]) {\n        if((x1 & (1 << d2)) && !dp[x1 | x2][d1]) {\n          dp[x1 | x2][d1] = true;\n          q.push(pll(x1 | x2, d1));\n        }\n        if((x2 & (1 << d1)) && !dp[x1 | x2][d2]) {\n          dp[x1 | x2][d2] = true;\n          q.push(pll(x1 | x2, d2));\n        }\n      }\n    }\n\n    REP(x1, 0, 1 << 10) REP(d1, 0, 10) if(dp[x1][d1]) {\n      REP(x2, 0, 1 << 10) REP(d2, 0, 10) if(dp[x2][d2]) {\n        if(!(x1 & x2) && (x1 & (1 << d2)) && (x2 & (1 << d1))) ok = false;\n      }\n    }\n\n    cout << (ok ? \"SAFE\" : \"UNSAFE\") << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nstring solve(string s) {\n    vector<vector<int>> vec(10);\n    int locks = 0;\n    for (char c: s) {\n        if (c == 'u') {\n            locks = 0;\n        } else {\n            vec[c - '0'].emplace_back(locks);\n            locks |= 1 << (c - '0');\n        }\n    }\n    for (int n = 0; n < 10; n++) {\n        vector<int> dp(1 << 10);\n        for (int s0: vec[n]) dp[s0] = true;\n        for (int s = 0; s < (1 << 10); s++) if (dp[s]) {\n            if (s >> n & 1) return \"UNSAFE\";\n            for (int nxt = 0; nxt < 10; nxt++) if (s >> nxt & 1) {\n                for (int has: vec[nxt]) {\n                    if ((s & has) == 0) dp[s | has] = true;\n                }\n            }\n        }\n    }\n    return \"SAFE\";\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        string s; cin >> s;\n        cout << solve(s) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[1<<10][1<<10];\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    string s;\n    cin>>s;\n    memset(dp,0,sizeof(dp));\n    vector<vector<Int> > sp(1<<10);\n    dp[0][0]=1;\n    sp[0].emplace_back(0);\n    bool flg=0;\n    for(Int i=0;i<n;i++){\n      if(s[i]=='u') continue;\n      Int b=0;\n      while(s[i+1]!='u'){\n\tb|=1<<(s[i]-'0');\n\tInt ne=1<<(s[i+1]-'0');\n\tif(b&ne) flg=1;\n\tif(flg) break;\n\tfor(Int x=(1<<10)-1;x>=0;x--){\n\t  if(x&b) continue;\n\t  if(sp[x].empty()) continue;\n\t  \n\t  for(Int y:sp[x]){\n\t    if((x&ne)&&((y|b)==b)) flg=1;\n\t    Int nx=x|b,ny=y|ne;\n\t    if((y&b)==b) ny^=b;\n\t    if(!dp[nx][ny]){\n\t      dp[nx][ny]=1;\n\t      sp[nx].emplace_back(ny);\n\t    }\n\t    if(flg) break;\n\t  }\n\t  if(flg) break;\n\t}\n\ti++;\n      }\n      Int ne=1<<(s[i]-'0');\n      if(b&ne) flg=1;\n      if(flg) break;\n    }\n    cout<<(flg?\"UNSAFE\":\"SAFE\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) {a = b; return true;}\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if(a > b) {a = b; return true;}\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if(i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T, typename U>\nostream &operator<<(ostream &os, const map<T,U> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp.first << \":\" << tp.second;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n        string s; cin >> s;\n        vvi dp(1<<10, vi(10));\n        int now = 0;\n        bool safe = true;\n        REP(i, n) {\n            if (s[i] == 'u') {\n                now = 0;\n                continue;\n            }\n            if (now & 1<<s[i]-'0') {\n                safe = false;\n                break;\n            }\n            dp[now][s[i] - '0'] = 1;\n            // DEBUG(bitset<10>(now));\n            // DEBUG(s[i]);\n            // cerr << endl;\n            now |= 1<<s[i]-'0';\n        }\n\n        if (!safe) {\n            cout << \"UNSAFE\" << endl;\n            continue;\n        }\n\n        REP(S, 1<<10) {\n            REP(i, 10) {\n                if (!dp[S][i]) continue;\n                REP(T, 1<<10) {\n                    REP(j, 10) {\n                        if (!dp[T][j]) continue;\n\n                        // DEBUG(bitset<10>(S));\n                        // DEBUG(i);\n                        // DEBUG(bitset<10>(T));\n                        // DEBUG(j);\n                        // cerr << endl;\n\n                        if (S & T) continue;\n                        if (T & 1<<i and S & 1<<j) {\n                            safe = false;\n                            // DEBUG(\"UNSAFE\");\n                            break;\n                        }\n                        if (S & 1<<j) dp[S | T][i] = 1;\n                        if (T & 1<<i) dp[S | T][j] = 1;\n                    }\n                }\n            }\n        }\n\n        cout << (safe ? \"SAFE\" : \"UNSAFE\") << endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nvoid _main() {\n    int n;\n    while (cin >> n, n) {\n        string s;\n        cin >> s;\n        vector<vector<bool>> dp(1 << 10, vector<bool>(10, false));\n        bool ng = false;\n        for (int i = 0, j = 0; i < n; ++i, ++j) {\n            int bit = 0;\n            while (j < n && s[j] != 'u') {\n                if (bit >> (s[j] - '0') & 1) ng = true;\n                dp[bit][s[j] - '0'] = true;\n                bit |= (1LL << (s[j++] - '0'));\n            }\n            i = j;\n        }\n        if (ng) {\n            cout << \"UNSAFE\" << endl;\n            continue;\n        }\n        REP (s1, 1LL << 10) REP (t1, 10) if (dp[s1][t1]) {\n            REP (s2, 1LL << 10) REP (t2, 10) if (dp[s2][t2]) {\n                bool flag1 = !(s1 & s2) && (s2 >> t1 & 1);\n                bool flag2 = !(s1 & s2) && (s1 >> t2 & 1);\n                if (flag1 && flag2) ng = true;\n                else if (flag1) dp[s1 | s2][t2] = true;\n                else if (flag2) dp[s1 | s2][t1] = true;\n            }\n        }\n        cout << (ng ? \"UNSAFE\" : \"SAFE\") << endl;\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <bitset>\nusing namespace std;\n\nvector<pair<int, int> >locks;\nset<pair<int,int> >check;\n\nint product(int l, int r){\n  return l&r;\n}\n\nint set_union(int l, int r){\n  return l|r;\n}\n\nint bit(char x){\n  return (x-'0');\n}\n\nint main(){\n  while(1){\n    int n; cin >> n;\n    if(!n) break;\n    locks.clear();\n    check.clear();\n    string s; cin >> s;\n    int lock= 0;\n    int xflag = 0;\n    for(int i=0;i<s.size();i++){\n      if(s[i] == 'u'){\n\tlock = 0;\n\tcontinue;\n      }\n      pair<int, int> p = make_pair(lock, bit(s[i]));\n      if(check.find(p) == check.end()){\n\tlocks.push_back(p);\n\tcheck.insert(p);\n      }\n      //      cout << static_cast<std::bitset<10> >(lock)<< endl;      \n      if(lock & 1<<bit(s[i])){\n\txflag = 1;\n\tbreak;\n      }\n      lock |= 1<<bit(s[i]);\n      \n    }\n\n    if(xflag){\n      cout << \"UNSAFE\\n\";\n    }else{\n\n    while(1){\n      //      cout << \"x\\n\";\n      int flag = 0;\n      for(int i=0;i<locks.size();i++){\n\tpair<int, int> l = locks[i];\n\t//\tcout << i << endl;\n\tfor(int j=i+1;j<locks.size();j++){\n\t  pair<int, int> r = locks[j];\n\t  int x = set_union(l.first, r.first);\n\t  pair<int, int> p = make_pair(x, r.second);\t  \n\t  if(!product(l.first, r.first) && !(l.first & 1<<r.second) && r.first & 1<<l.second  && check.find(p) == check.end()){\n\t    //\t    for(set<char>::iterator it = l.first.begin(); it != l.first.end(); it++) cout << *it; \n\t    //\t    for(set<char>::iterator it = r.first.begin(); it != r.first.end(); it++) cout << *it; cout << endl;\n\t    // for(set<char>::iterator it = x.begin(); it != x.end(); it++) cout << *it; cout << endl;\n\t    //\t    cout << \"-------------------\\n\";\n\t    locks.push_back(p);\n\t    check.insert(p);\n\t    flag = 1;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    //    cout << \"----\\n\";\n    int flag = 0;\n    for(int i=0;i<locks.size();i++){\n      pair<int, int> l = locks[i];\n      //      cout << static_cast<std::bitset<10> >(l.first) << \" \" << l.second<< endl;\n      for(int j=i+1;j<locks.size();j++){\n\tpair<int, int> r = locks[j];\n\tif(!product(l.first, r.first) &&\n\t   l.first & 1<<r.second  &&\n\t   r.first & 1<<l.second){\n\t  cout << \"UNSAFE\\n\";\n\t  flag = 1;\n\t  i = locks.size();\n\t  break;\n\t}\n      }\n    }\n    if(!flag) cout << \"SAFE\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        string s; cin >> s;\n        vector<int> dp(1 << 10);\n        vector<bool> used(1 << 10);\n        int state = 0;\n        for(int i = 0; i + 1 < n; ++i) {\n            if(s[i] == 'u') {\n                state = 0;\n            } else {\n                state |= (1 << (s[i] - '0'));\n            }\n            if(s[i + 1] != 'u') {\n                int d = s[i + 1] - '0';\n                dp[state] |= (1 << d);\n                used[state] = true;\n            }\n        }\n\n        for(int S = 0; S < (1 << 10); ++S) {\n            for(int T = S + 1; T < (1 << 10); ++T) {\n                if(used[S] && used[T] && (S & T) == 0) {\n                    dp[S | T] |= dp[S] | dp[T];\n                    used[S | T] = true;\n                }\n            }\n        }\n\n        bool ng = false;\n        for(int S = 1; S < (1 << 10); ++S) {\n            if(used[S]) {\n                ng |= (dp[S] & S) == dp[S];\n            }\n        }\n        if(ng) {\n            cout << \"UNSAFE\" << endl;\n        } else {\n            cout << \"SAFE\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[1<<10][1<<10];\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    string s;\n    cin>>s;\n    memset(dp,0,sizeof(dp));\n    vector<vector<Int> > sp(1<<10);\n    dp[0][0]=1;\n    sp[0].emplace_back(0);\n    bool flg=0;\n    for(Int i=0;i<n;i++){\n      if(s[i]=='u') continue;\n      Int b=0;\n      while(s[i+1]!='u'){\n\tb|=1<<(s[i]-'0');\n\tInt ne=1<<(s[i+1]-'0');\n\tif(b&ne) flg=1;\n\tif(flg) break;\n\tfor(Int x=(1<<10)-1;x>=0;x--){\n\t  if(x&b) continue;\n\t  for(Int y:sp[x]){\n\t    //cout<<x<<\" \"<<y<<endl;\n\t    if((y&b)&&(x&ne)) flg=1;\n\t    if(!dp[x|b][y|ne]){\n\t      dp[x|b][y|ne]=1;\n\t      sp[x|b].emplace_back(y|ne);\n\t    }\n\t    if(flg) break;\n\t  }\n\t}\n\ti++;\n      }\n      Int ne=1<<(s[i]-'0');\n      if(b&ne) flg=1;\n      if(flg) break;\n    }\n    /*\n    for(Int i=0;i<(1<<10);i++)\n      for(Int j=0;j<(1<<10);j++)\n\tif(dp[i][j]) cout<<i<<\" \"<<j<<\":\"<<dp[i][j]<<endl;\n    */\n    cout<<(flg?\"UNSAFE\":\"SAFE\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define encode(state,lock) (state|(lock<<10))\n#define getState(v) (v&((1<<10)-1))\n#define getLock(v) (v>>10)\n#define isLock(state, lock) (state&(1<<lock))\n\nvoid init(int n,string s,set<int> &S) {\n  int state = 0;\n  rep(i,n) {\n    if( s[i] == 'u' ) {\n      state = 0;\n    } else {\n      int lock = s[i] - '0';\n      S.insert(encode(state,lock));\n      state = state | (1<<lock);\n    }\n  }\n}\n\nbool hasDeadlock(int n,string s) {\n  rep(i,n-1) if( s[i] != 'u' && s[i] == s[i+1] ) return true;\n\n  set<int> S;\n  init(n,s,S);\n  bool update = true;\n  while(update) {\n    update = false;\n    vector<int> buffer;\n    /*\n    for(auto v : S) {\n      bitset<10> BIT(v&((1<<10)-1));\n      cout << BIT << \" : \" << (v>>10) << endl;\n    }\n    puts(\"\");\n    */\n    for(auto v1 : S) {\n      int state1 = getState(v1);\n      int lock1  = getLock(v1);\n      for(auto v2 : S) {\n        int state2 = getState(v2);\n        int lock2  = getLock(v2);\n        if( state1 & state2 ) continue;\n        if( state2 & (1<<lock1) ) buffer.push_back(encode((state1|state2),lock2));\n        if( isLock(state1,lock2) && isLock(state2,lock1) ) {\n          return true;\n        }\n      }\n    }\n    rep(i,(int)buffer.size()) {\n      if( S.count(buffer[i]) ) continue;\n      S.insert(buffer[i]);\n      update = true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  int n;\n  string s;\n  while( cin >> n, n ) {\n    cin >> s;\n    puts(hasDeadlock(n,s)?\"UNSAFE\":\"SAFE\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n\nstruct State {\n    int lock, need;\n    bool operator <  (const State &r) const { return lock == r.lock ? need < r.need : lock < r.lock; }\n    bool operator ==  (const State &r) const { return lock == r.lock and need == r.need; }\n};\n\nbool solve() {\n    int N; cin >> N;\n    if(N == 0) return false;\n    string S; cin >> S;\n\n    bool dead_lock = false;\n    vector<State> states;\n    {\n        State s;\n        rep(i, S.size()) {\n            if(S[i] != 'u') {\n                int n = S[i] - '0';\n                if(s.lock & (1 << n)) dead_lock = true;\n                s.need = n;\n                states.push_back(s);\n                s.lock |= (1 << n);\n            } else {\n                s = State();  \n            }\n        }\n        sort(all(states));\n        states.erase(unique(all(states)), end(states));\n    }\n    auto dead_locking = [&] (const State &a, const State &b) {\n        if(a.lock & b.lock) return false;\n        if(a.lock & (1 << b.need) and b.lock & (1 << a.need)) return true;\n        return false;\n    };\n    auto merge = [&] (const State a, const State b) {\n        if(a.lock & b.lock) return;\n        if(a.lock & (1 << b.need)) {\n            states.push_back(State{a.lock | b.lock, a.need});\n        }\n        if(b.lock & (1 << a.need)) {\n            states.push_back(State{a.lock | b.lock, b.need});\n        }\n    };\n    while(not dead_lock) {  \n        int M = states.size();\n        rep(i, M) rep(j, i) {\n            dead_lock |= dead_locking(states[i], states[j]);\n            merge(states[i], states[j]);\n        }\n        sort(all(states));\n        states.erase(unique(all(states)), end(states));\n        if(states.size() == M) break;\n    }   \n    cout << (dead_lock ? \"UNSAFE\" : \"SAFE\") << endl;\n    \n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<int, int> PP;\n\n\nint N;\nchar S[10010];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tscanf(\"%s\", S);\n\t\tset<PP> pat1, pat2;\n\t\t\n\t\tint prev = 0;;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(S[i] == 'u'){\n\t\t\t\tprev = 0;\n\t\t\t}else{\n\t\t\t\tint mask = 1 << (S[i] - '0');\n\t\t\t\tpat1.insert(make_pair(prev, mask));\n\t\t\t\tprev |= mask;\n\t\t\t}\n\t\t}\n\t\tvector<PP> tmp;\n\t\tint bsize;\n\t\tdo{\n\t\t\tbsize = pat1.size();\n\t\t\ttmp.clear();\n\t\t\tfor(auto v1 : pat1){\n\t\t\t\tfor(auto v2 : pat1){\n\t\t\t\t\tif((v1.first & v2.first) == 0 && (v1.first & v2.second) != 0){\n\t\t\t\t\t\ttmp.push_back(make_pair(v1.first | v2.first, v1.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto v : tmp){\n\t\t\t\tpat1.insert(v);\n\t\t\t}\n\t\t}while(bsize != pat1.size());\n\n\t\tbool flg = true;\n\t\tfor(auto v : pat1){\n\t\t\tif((v.first & v.second) != 0){\n\t\t\t\tflg = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flg){\n\t\t\tprintf(\"SAFE\\n\");\n\t\t}else{\n\t\t\tprintf(\"UNSAFE\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<int, int> P;\nint check[1 << 10][10];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tstring s;\n\twhile(cin >> N, N) {\n\t\tcout << N << endl;\n\t\tmemset(check, 0, sizeof check);\n\t\tcin >> s;\n\n\t\tbool ok = true;\n\t\tvector<P> v;\n\t\tint x = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(s[i] == 'u') {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint y = s[i] - '0';\n\t\t\t\tif(!check[x][y]) {\n\t\t\t\t\tv.push_back({ x, y });\n\t\t\t\t\tcheck[x][y] = 1;\n\t\t\t\t}\n\n\t\t\t\tif(x >> y & 1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx |= 1 << y;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok) {\n\t\t\tcout << \"UNSAFE\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint n = 0;\n\n\t\twhile(1) {\n\t\t\tvector<P> add;\n\t\t\tfor(int i = 0; i < v.size() && ok; i++) {\n\t\t\t\tfor(int j = 0; j < v.size() && ok; j++) {\n\t\t\t\t\tif(i == j) continue;\n\t\t\t\t\tint s1 = v[i].first, t1 = v[i].second;\n\t\t\t\t\tint s2 = v[j].first, t2 = v[j].second;\n\t\t\t\t\tif(s1 & s2) continue;\n\t\t\t\t\tint ns = s1 | s2;\n\t\t\t\t\tif((s1 >> t2 & 1) && (s2 >> t1 & 1)) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((s1 >> t2 & 1) && !(s2 >> t1 & 1)) {\n\t\t\t\t\t\tif(!check[ns][t1]) {\n\t\t\t\t\t\t\tadd.push_back({ ns, t1 });\n\t\t\t\t\t\t\tcheck[ns][t1] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!(s1 >> t2 & 1) && (s2 >> t1 & 1)) {\n\t\t\t\t\t\tif(!check[ns][t2]) {\n\t\t\t\t\t\t\tadd.push_back({ ns, t2 });\n\t\t\t\t\t\t\tcheck[ns][t2] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!ok || add.size() == 0) break;\n\n\t\t\tn = v.size();\n\t\t\tfor(auto p : add) {\n\t\t\t\tv.push_back(p);\n\t\t\t}\n\t\t}\n\n\t\tif(ok) cout << \"SAFE\" << endl;\n\t\telse cout << \"UNSAFE\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nvoid print(int a){\n\trep(i,10){\n\t\tcout << (bool)(a&(1<<i));\n\t}\n\tcout << endl;\n}\n\n//void nex(int &n, int mask){\n//\tn += 1;\n//\twhile( n & mask ){\n//\t\tn += n&mask;\n//\t}\n//}\nvoid nex(pii &p, int mask){\n\tint n = p.X;\n\tn += 1;\n\twhile( n & ~mask ){\n\t\tn += n&~mask;\n\t}\n\tp.X = n;\n\tp.Y = mask ^ n;\n}\n\nint main(){\n//\t\tint a = 6;\n//\t\tcout << \"a=\" << a << endl;\n//\t\tprint(a);\n//\t\tfor(int b=0; b<32; nex(b,a)) print(b);\n//\t\tcout << endl;\n//\t\treturn 0;\n\n\tint n;\n\twhile(cin >> n, n){\n\t\tbool ans = true;\n\t\tstring s;\n\t\tcin >> s;\n\t\t\n\t\t//bool memo[1<<10][1<<10] = {};\n\t\tset<int> memo[1<<10];\n\t\tint st=0;\n\t\tfor(auto c: s){\n\t\t\tif( c == 'u' ){\n\t\t\t\tst = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint k = c - '0';\n\t\t\tint nx = (1<<k);\n\t\t\tif( st & nx ) ans = false;\n\t\t\t//memo[st][nx] = true;\n\t\t\tmemo[st].insert( nx );\n\t\t\tst |= nx;\n\t\t}\n\n\t\trep(n,1<<10) for(pii p={0,0}; p.X<(1<<10); nex(p,n)){\n\t\t\tint a = p.X;\n\t\t\tint b = p.Y;\n\t\t\tif( a > b ) break;\n\t\t\tif(a&&b) for(auto x: memo[a]) for(auto y: memo[b]){\n\t\t\t\t//if( a & b ) continue;\n\t\t\t\t//int x = memo[a];\n\t\t\t\t//int y = memo[b];\n\t\t\t\t//if( (b&x) && (a&y) ) ans = false;\n\t\t\t\t//memo[ a|b ][ x|y ] = true;\n\t\t\t\tmemo[ a|b ].insert( x|y );\n\t\t\t}\n\t\t\tif( p.X == n ) break;\n\t\t}\n\n\t\trep(a,1<<10) for(auto x: memo[a]){\n\t\t\tif( (a&x) == x ) ans = false;\n\t\t}\n\n\t\tcout << (ans ? \"SAFE\" : \"UNSAFE\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <set>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<set<int> > > tu;\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    set<int> se;\n    a.assign(n+1,10);\n    tu.assign(10,vector<set<int> >(10,se));\n    char s;\n    en=0;\n    a[0]=10;\n    int ss=0;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        if(a[t-1]!=10){\n          tu[a[t-1]][a[t]].insert(ss);\n          ss=ss|mm(a[t-1]);\n          if((ss&mm(a[t]))!=0){\n            en=1;\n          }\n        }\n        else{\n          ss=0;\n        }\n        t++;\n      }\n      else{\n        ss=0;\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n\n/*    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }*/\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()>0){\n      if((f&mm(t))!=0){\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        /*int q=0;\n        for(q=0;q<int(route.size())&&route[q]!=t;q++){\n        }\n        if(q>0){\n          route.erase(route.begin(),route.begin()+q-1);\n        }*/\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          for(int z=0;(z<int(route.size())-1)&&en!=1;z++){\n            for(int w=z+1;(w<int(route.size())-1)&&en!=1;w++){\n              for(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end()&&en==0;++x){\n                for(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end()&&en==0;++y) {\n                  if((*x&*y)==0){\n                    en=1;\n                  }\n                }\n              }\n            }\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n        \n      }\n      else{\n        next(t,f,route);\n      }\n    }\n  }\n}\n/*\nfor(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end();++x){\nfor(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end();++y) {\n  if((*x&*y)==0){\n    en=1;\n  }\n}\n}*/\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n\nその前にrouteのかぶり\n//自分とのかぶりはバツ\n共通のかぶりバツ\nその上条件に適した組みが一つ以上ある\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint n; bool ok[1028]; string s;\nint main() {\n\twhile (cin >> n, n) {\n\t\tcin >> s;\n\t\tbool flag = false;\n\t\tfor (int i = 1; i < 1024; i++) {\n\t\t\tfor (int j = 0; j < 1024; j++) ok[j] = false;\n\t\t\tint bit = 0;\n\t\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\t\tif (s[j] == 'u') bit = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (i & (1 << (s[j] - 48))) ok[bit] = true;\n\t\t\t\t\tbit |= 1 << (s[j] - 48);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\t\tif ((j & k) == k && ok[j - k] && ok[k]) ok[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok[i]) flag = true;\n\t\t}\n\t\tcout << (flag ? \"UNSAFE\" : \"SAFE\") << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\n\nbool comb[1<<10][10];\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tstring s;\n\t\tcin >> s;\n\t\tmemset(comb,false,sizeof(comb));\n\t\tbool safe=true;\n\t\t\n\t\tint mask=0;\n\t\trep(i,n){\n\t\t\tif(s[i]=='u')\n\t\t\t\tmask=0;\n\t\t\telse{\n\t\t\t\tint get=s[i]-'0';\n\t\t\t\tif((mask&(1<<get))==0)\n\t\t\t\t\tcomb[mask][get]=true;\n\t\t\t\telse\n\t\t\t\t\tsafe=false;\n\t\t\t\tmask|=(1<<get);\n\t\t\t}\n\t\t}\n\n\t\trep(mask1,1<<10)rep(get1,10)rep(mask2,1<<10)rep(get2,10){\n\t\t\tif(comb[mask1][get1]==false) continue;\n\t\t\tif(comb[mask2][get2]==false) continue;\n\t\t\tif(mask1&mask2) continue;\n\t\t\tif( (mask2&(1<<get1))!=0 &&  (mask1&(1<<get2))==0) comb[mask1|mask2][get2]=true;\n\t\t}\n\n\t\t\n\t\trep(mask1,1<<10)rep(get1,10)rep(mask2,1<<10)rep(get2,10){\n\t\t\tif(comb[mask1][get1]==false) continue;\n\t\t\tif(comb[mask2][get2]==false) continue;\n\t\t\tif(mask1&mask2) continue;\n\t\t\tif( (mask2&(1<<get1))!=0 &&  (mask1&(1<<get2)) !=0) safe=false;\n\t\t}\n\n\t\tif(safe)\n\t\t\tputs(\"SAFE\");\n\t\telse\n\t\t\tputs(\"UNSAFE\");\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <set>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nint ff;\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<set<int> > > tu;\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    set<int> se;\n    a.assign(n+1,10);\n    tu.assign(10,vector<set<int> >(10,se));\n    char s;\n    en=0;\n    a[0]=10;\n    int ss=0;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        if(a[t-1]!=10){\n          tu[a[t-1]][a[t]].insert(ss);\n          ss=ss|mm(a[t-1]);\n          if((ss&mm(a[t]))!=0){\n            en=1;\n          }\n        }\n        else{\n          ss=0;\n        }\n        t++;\n      }\n      else{\n        ss=0;\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n\n/*    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }*/\n    vector<int> route2;\n    ff=0;\n    for(int t=0;t<10&&en==0;t++){\n      if((ff&mm(t))==0){\n        next(t,0,route2);\n      }\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  ff=ff|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()>0){\n      if((f&mm(t))!=0){\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        /*int q=0;\n        for(q=0;q<int(route.size())&&route[q]!=t;q++){\n        }\n        if(q>0){\n          route.erase(route.begin(),route.begin()+q-1);\n        }*/\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          for(int z=0;(z<int(route.size())-1)&&en!=1;z++){\n            for(int w=z+1;(w<int(route.size())-1)&&en!=1;w++){\n              for(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end()&&en==0;++x){\n                for(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end()&&en==0;++y) {\n                  if((*x&*y)==0){\n                    en=1;\n                  }\n                }\n              }\n            }\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n        \n      }\n      else{\n        next(t,f,route);\n      }\n    }\n  }\n}\n/*\nfor(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end();++x){\nfor(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end();++y) {\n  if((*x&*y)==0){\n    en=1;\n  }\n}\n}*/\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n\nその前にrouteのかぶり\n//自分とのかぶりはバツ\n共通のかぶりバツ\nその上条件に適した組みが一つ以上ある\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <set>\n\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n &&n!=0){\n        string s;\n        cin >> s;\n        set<pair<int,int> > st;\n        int tmp=0;\n        bool flag = 0;\n        for(int i=0;i<n;i++){\n            if(s[i]=='u'){\n                tmp =0;\n            }else{\n                if(s[i+1]!='u'){\n                    tmp += 1<<(s[i]-'0');\n                    int tmp2 = 1<<(int)(s[i+1]-'0');\n                    st.insert(make_pair(tmp,tmp2));\n                    if((tmp&tmp2)==tmp2){\n                        flag = 1;\n                    }\n                }\n            }\n        }\n        \n        set<pair<int,int> > st2=st;\n        for(int j=0;j<10;j++){\n            set<pair<int,int> > st3;\n            st3 = st2;\n            for(auto x:st){\n                for(auto y:st2){\n                    if((x.first&y.first)==0){\n                        int p =x.first|y.first;\n                        int q =x.second|y.second;\n                        st3.insert(make_pair(p,q));\n                        if((p&q)==q){\n                            flag = 1;\n                            break;\n                        }\n                    }\n                }\n                if(flag)break;\n            }\n            st2 = st3;\n        }\n        if(flag){\n            cout << \"UNSAFE\" << endl;\n        }else{\n            cout << \"SAFE\" << endl;\n        }\n    }\n\n\n\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define encode(state,lock) (state|(lock<<10))\n#define getState(v) (v&((1<<10)-1))\n#define getLock(v) (v>>10)\n#define isLock(state, lock) (state&(1<<lock))\n\nvoid init(int n,string s,set<int> &S) {\n  int state = 0;\n  rep(i,n) {\n    if( s[i] == 'u' ) {\n      state = 0;\n    } else {\n      int lock = s[i] - '0';\n      S.insert(encode(state,lock));\n      state = state | (1<<lock);\n    }\n  }\n}\n\nbool hasDeadlock(int n,string s) {\n  rep(i,n-1) if( s[i] != 'u' && s[i] == s[i+1] ) return true;\n\n  set<int> S;\n  init(n,s,S);\n  bool update = true;\n  while(update) {\n    update = false;\n    vector<int> buffer;\n    /*\n    for(auto v : S) {\n      bitset<10> BIT(v&((1<<10)-1));\n      cout << BIT << \" : \" << (v>>10) << endl;\n    }\n    puts(\"\");\n    */\n    for(auto v1 : S) {\n      int state1 = getState(v1);\n      int lock1  = getLock(v1);\n      for(auto v2 : S) {\n        int state2 = getState(v2);\n        int lock2  = getLock(v2);\n        if( state1 & state2 ) continue;\n        if( state2 & (1<<lock1) ) buffer.push_back(encode((state1|state2),lock2));\n        if( isLock(state1,lock2) && isLock(state2,lock1) ) {\n          return true;\n        }\n      }\n    }\n    rep(i,(int)buffer.size()) {\n      if( S.count(buffer[i]) ) continue;\n      S.insert(buffer[i]);\n      update = true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  int n;\n  string s;\n  while( cin >> n, n ) {\n    cin >> s;\n    puts(hasDeadlock(n,s)?\"UNSAFE\":\"SAFE\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n// VI tsort(VVI g) {\n//   int n = g.size();\n//   vector<bool> used(n, false);\n//   vector<int> ans;\n//\n//   function<void(int)> dfs = [&](int u) {\n//     if(used[u]) return;\n//     used[u] = true;\n//     for(auto& i: g[u]) dfs(i);\n//     ans.push_back(u);\n//   };\n//\n//   for(int i=0; i<n; ++i) dfs(i);\n//   reverse(ans.begin(), ans.end());\n//   return ans;\n// }\n\nVI tsort(VVI g) {\n  const int n = g.size();\n  VI h(n, 0);\n  REP(i, n) for(int j: g[i]) h[j]++;\n\n  stack<int> st;\n  REP(i, n) if(h[i] == 0) st.push(i);\n\n  VI ans;\n  while(st.size()) {\n    int i = st.top(); st.pop();\n    ans.push_back(i);\n    for(auto& j: g[i]) {\n      h[j]--;\n      if(h[j] == 0) st.push(j);\n    }\n  }\n\n  return ans;\n}\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 10010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    bool safe;\n    int n;\n    cin >> n;\n    if(!n) break;\n    string s;\n    cin >> s;\n\n    safe = true;\n    vector<PII> v(n);\n    int now = 0;\n    REP(i, n) {\n      int nxt = -1;\n      if(i < n && isdigit(s[i])) nxt = s[i] - '0';\n      v[i] = {now, nxt};\n\n      if(s[i] == 'u') {\n        now = 0;\n      } else {\n        if(now & 1 << (s[i] - '0')) {\n          safe = false;\n          break;\n        }\n        now |= 1 << (s[i] - '0');\n      }\n    }\n    if(!safe) {\n      cout << \"UNSAFE\" << endl;\n      continue;\n    }\n\n    VVI g(n, VI(0));\n    REP(i, n) FOR(j, i+1, n) {\n      if(v[i].second == -1 || v[j].second == -1) continue;\n      if(v[i].first & v[j].first) continue;\n      if((v[i].first & 1 << v[j].second)) {\n        // j->iに辺を貼る\n        g[j].PB(i);\n      }\n      if(v[j].first & 1 << v[i].second) {\n        // i->jに辺を貼る\n        g[i].PB(j);\n      }\n    }\n\n    VI ans = tsort(g);\n    if(ans.size() != n) safe = false;\n\n    vector<bool> loop(n, true);\n    REP(i, ans.size()) loop[ans[i]] = false;\n\n    // 長さ10より大きいループがあってもデッドロックは起きない\n    // トポソしてansにないやつ→ループに使われてる\n    // UFでつないで要素数が11以上の連結成分しかなければsafe\n    uf.init();\n    REP(i, n) {\n      if(!loop[i]) continue;\n      for(int j: g[i]) {\n        uf.unite(i, j);\n      }\n    }\n    REP(i, n) {\n      if(!loop[i]) continue;\n      if(uf.s[uf.find(i)] <= 10) {\n        safe = false;\n        break;\n      }\n    }\n\n    if(safe) cout << \"SAFE\" << endl;\n    else cout << \"UNSAFE\" << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool clear;\nmap<int, set<int>> Next;\n\nvoid check(vector<int> &v);\nvoid f(vector<int> &v, int val) {\n    if(val == 10) {\n        check(v);\n        return;\n    }\n    f(v, val + 1);\n    for(int i = 0; i < v.size(); i++) {\n        v[i] |= (1 << val);\n        f(v, val + 1);\n        v[i] &= ~(1<<val);\n    }\n    v.push_back(1 << val);\n    f(v, val + 1);\n    v.pop_back();\n}\n\nvoid check(vector<int> &v) {\n    if(v.size() <= 1) return;\n    int used = 0;\n    for(int i = 0; i < v.size(); i++) {\n        used |= v[i];\n    }\n    bool deadlock = true;\n    for(int i = 0; i < v.size(); i++) {\n        bool NowDeadlock = false;\n        for(auto itr = Next[v[i]].begin(); itr != Next[v[i]].end(); itr++) {\n            if((used >> *itr) & 1) NowDeadlock = true;\n        }\n        if(!NowDeadlock) deadlock = false;\n    }\n    if(deadlock) clear = false;\n    /*\n    if(deadlock) {\n        cerr << used << endl;\n        for(int i = 0; i < v.size(); i++) {\n            cerr << v[i] << \" \";\n        }\n        cerr << endl;\n    }\n    */\n    return;\n}\n\nint main() {\n    while(true) {\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        string S;\n        cin >> S;\n        clear = true;\n        Next.clear();\n        int now = 0;\n        for(int i = 0; i < S.size(); i++) {\n            if(S[i] == 'u') {\n                now = 0;\n                continue;\n            }\n            int nownum = (int)(S[i] - '0');\n            if((now >> nownum) & 1) clear = false;\n            Next[now].insert(nownum);\n            now |= (1 << nownum);\n        }\n        /*\n        for(int i = 0; i < (1 << 10); i++) {\n            if(Next[i].empty()) continue;\n            cerr << \"----\" << i << \"----\" << endl;\n            for(auto itr = Next[i].begin(); itr != Next[i].end(); itr++) {\n                cerr << *itr << \" \";\n            }\n            cerr << endl;\n        }\n        */\n        vector<int> v;\n        f(v, 0);\n        if(clear) cout << \"SAFE\" << endl;\n        else cout << \"UNSAFE\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > A;\ntypedef pair<int,int> P;\n\nbool bfs(){\n  sort(A.begin(),A.end());\n  A.erase(unique(A.begin(),A.end()),A.end());\n  int n = A.size();\n  for(int i=0;i<n;i++)\n    for(int j=0,used[10]={};j<A[i].size();j++)if(used[A[i][j]]++) return 1;\n\n  queue<P> Q;\n  bool D[1<<10][1<<10]={};\n  D[0][0]=1;\n  Q.push(P(0,0));\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int I = t.first,J = t.second;\n    if(I&&J&&__builtin_popcount(I&J) == __builtin_popcount(J)) return 1;\n\n    for(int i=0;i<n;i++){\n      for(int k=0,ni=I;k<A[i].size();k++){\n\tint num = A[i][k],nj =(J|1<<num);\n\tif(k&&D[ni][nj]==0&&J!=nj)D[ni][nj]=1, Q.push(P(ni,nj));\n\tif(I&(1<<num))break;\n\tni |= (1<<num);\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    string str;\n    cin>>str;\n    A.clear();\n    for(int i=0;i<str.size();i++){\n      A.push_back(vector<int>());\n      while(str[i]!='u') A.back().push_back(str[i++]-'0');\n    }\n    cout<<(bfs()? \"UN\":\"\")<<\"SAFE\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> e[11][11];\nvector<int> G[11];\nbool visit[11];\n\nvoid dfs(int u,vvi& route,vi& hoge)\n{\n    visit[u] = true;\n    rep(i,len(G[u])){\n        if(visit[G[u][i]]){\n            vi ag;\n            rep(j,len(hoge)){\n                if(hoge[j] == G[u][i]){\n                    for(;j<len(hoge);j++){\n                        ag.pb(hoge[j]);\n                    }\n                }\n            }\n            ag.pb(u);\n            route.pb(ag);\n        }else{\n            hoge.pb(u);\n            dfs(G[u][i],route,hoge);\n            hoge.pop_back();\n        }\n    }\n}\n\nint main()\n{\n    // cin.tie(0);\n    // ios::sync_with_stdio(false);ccccc\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        string s;\n        cin >> s;\n        int kp = 0;\n        bool end = false;\n        rep(i,10){\n            rep(j,10){\n                e[i][j].clear();\n            }\n        }\n        rep(i,10){\n            G[i].clear();\n            visit[i] = false;\n        }\n        rep(i,len(s)){\n            if(s[i] == 'u'){\n                kp = 0;\n            }else if(kp & (1 << (int)(s[i]-'0'))){\n                cout << \"UNSAFE\\n\";\n                end = true;\n                break;\n            }else{\n                kp |= (1 << (int)(s[i]-'0'));\n            }\n        }\n        if(end){\n            continue;\n        }\n        kp = 0;\n        rep(i,len(s)-1){\n            if(s[i] != 'u'){\n                if(s[i+1] != 'u'){\n                    int a = (int)(s[i]-'0'),b = (int)(s[i+1]-'0');\n                    e[a][b].pb(kp);\n                    kp |= (1 << (int)(s[i]-'0'));\n                }\n            }else{\n                kp = 0;\n            }\n        }\n        rep(i,10){\n            rep(j,10){\n                if(len(e[i][j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        rep(i,10){\n            if(!visit[i]){\n                vvi route;\n                vi hoge;\n                dfs(i,route,hoge);\n                // rep(i,len(route)){\n                //     svec(route[i]);\n                // }\n                rep(j,len(route)){\n                    int loop = len(route[j]);\n                    vvi vec(loop);\n                    rep(k,len(route[j])){\n                        int a = route[j][k],b = route[j][(k+1)%loop];\n                        vec[k] = e[a][b];\n                    }\n                    set<int> dp[11];\n                    dp[0].insert(0);\n                    rep(j,loop){\n                        each(k,dp[j]){\n                            rep(l,len(vec[j])){\n                                if(!(k & vec[j][l])){\n                                    dp[j+1].insert(k|vec[j][l]);\n                                }\n                            }\n                        }\n                    }\n                    if(len(dp[loop])){\n                        cout << \"UNSAFE\\n\";\n                        end = true;\n                        break;\n                    }\n                }\n                if(end){\n                    break;\n                }\n            }\n        }\n        if(!end){\n            cout << \"SAFE\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nconst int num = 10;\n\nint main() {\n\twhile (1) {\n\t\tvector<vector<int>>oks(1024, vector<int>(10, 0));\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tstring st; cin >> st;\n\t\tvector<vector<int>>vs;\n\t\tvector<int>v;\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'u') {\n\t\t\t\tvs.emplace_back(v);\n\t\t\t\tv.clear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv.emplace_back(st[i]-'0');\n\t\t\t}\n\t\t}\n\t\tfor (auto v : vs) {\n\t\t\tif (v.empty())continue;\n\t\t\tbitset<10>bs;\n\t\t\tbs[v[0]] = true;\n\t\t\toks[0][v[0]] = true;\n\t\t\tfor (int i = 1; i < v.size(); ++i) {\n\t\t\t\toks[bs.to_ulong()][v[i]] = true;\n\t\t\t\tif (bs[v[i]]) {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbs[v[i]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tfor (int k = 0; k < 10; ++k) {\n\t\t\t\tif (!oks[j][k])continue;\n\t\t\t\tfor (int l = 0; l < 1024; ++l) {\n\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\tif ((!oks[j][k]) || (!oks[l][m]))continue;\n\t\t\t\t\t\tif (j&l)continue;\n\t\t\t\t\t\tif (!(j&(1 << m)) && (l&(1 << k)))oks[j | l][m] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tfor (int k = 0; k < 10; ++k) {\n\t\t\t\tif (!oks[j][k])continue;\n\t\t\t\tfor (int l = 0; l < 1024; ++l) {\n\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\tif ((!oks[j][k]) || (!oks[l][m]))continue;\n\t\t\t\t\t\tif (j&l)continue;\n\t\t\t\t\t\tif ((j&(1 << m)) && l&(1 << k)) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"SAFE\" << endl;\n\t\telse cout << \"UNSAFE\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define inf (int)(1e9+7)\n#define mod (ll)(1e9+7)\n#define eb emplace_back\n#define All(v) v.begin(), v.end()\nlong power(long a,long b){return b?power(a*a%inf,b/2)*(b%2?a:1)%inf:1;}\n\n/*\n dead_rock term\n 01, 10\n ...\n 01, 12, 23, ..., 90\n とは限らない\n \n 1.\n 201 130\n a_nxt is 0\n b_nxt is 1\n a_have has 1\n b_have has 0\n \n 2. not\n 201u210u\n \n 3つ以上でdead_rock起きるケース\n a  b  c\n 01 12 20\n \n merge a, b -> d\n d_nxt is 2\n d_have has 0, 1\n \n */\nbool self_deadlock(string S) {\n    map<int, int> mp;\n    rep(i, S.size()) {\n        if (S[i] == 'u') {\n            for (auto e : mp) mp[e.first] = 0;\n        }\n        if (mp[S[i] - '0'] == 1) {cout << \"UNSAFE\" << endl; return 1;}\n        else mp[S[i] - '0'] = 1;\n    }\n    return 0;\n}\nbool comp(pii a, pii b) {\n    return a.second < b.second;\n}\nvoid deadlock(string S) {\n    vector<pii> s;\n    int tmp = 0;\n    rep(i, S.size()) {\n        if (S[i] == 'u') {tmp = 0; continue;}\n        int num = S[i] - '0';\n        if (tmp != 0) s.eb(tmp, num);\n        tmp += (1 << num);\n    }\n    //rep(i, s.size()) cout << bitset<8>(s[i].first) << \" \" << s[i].second << endl;\n    sort(s.begin(), s.end(), comp);\n    rrep(i, 1, s.size()) {\n        if (s[i].first == s[i - 1].first && s[i].second == s[i - 1].second) {\n            s.erase(s.begin() + i);\n        }\n    }\n    //rep(i, s.size()) cout << bitset<8>(s[i].first) << \" \" << s[i].second << endl;\n    rep(loop, 10) { //10周でいいのか\n        //merge combination\n        int flg = 0;\n        rep(i, s.size()) {\n            rrep(j, i + 1, s.size()) {\n                if (s[i].first & s[j].first) continue;\n                if (s[i].second == s[j].second) continue;\n                //2つでdeadlock\n                if ((s[i].first & (1 << s[j].second)) &&\n                    (s[j].first & (1 << s[i].second))) {cout << \"UNSAFE\" << endl; return;}\n                else if ((s[i].first & (1 << s[j].second))) {\n                    s[i].first |= s[j].first;\n                    s.erase(s.begin() + j);\n                    flg = 1;\n                } else if ((s[j].first & (1 << s[i].second))) {\n                    s[j].first |= s[i].first;\n                    s.erase(s.begin() + i);\n                    i++;\n                    flg = 1;\n                }\n            }\n        }\n        if (flg == 0) break;\n    }\n    cout << \"SAFE\" << endl;\n}\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int N; string S;\n    while (cin >> N && N) {\n        cin >> S;\n        if (self_deadlock(S)) continue;\n        deadlock(S);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\nusing pi = pair<bitset<10>, int>;\n\nint main()\n{\n    bool B[1 << 10][10];\n    while (true)\n    {\n        int N; cin >> N;\n        if(N == 0) return 0;\n        string S; cin >> S;\n\n        vector<pi> state;\n        bitset<10> lock; \n        bool unsafe = false;\n        memset(B, 0, sizeof(B));\n\n        for(auto c : S)\n        {\n            if (c == 'u')\n            {\n                lock.reset();\n            }\n            else\n            {\n                int x = c - '0';\n                if (lock[x])\n                {\n                    unsafe = true;\n                    printf(\"UNSAFE\\n\");\n                    break;\n                }\n                auto locks = pi(lock, x);\n                if (!B[lock.to_ulong()][x])\n                {\n                    state.emplace_back(locks);\n                    B[lock.to_ulong()][x] = true;\n                }\n\n                lock[x] = true;\n            }                     \n        }\n\n        if(unsafe)continue;\n        // for(auto p: state)\n        // {\n        //     cout << p.first <<  \" \" << p.second << \"\\n\";\n        // }\n\n        vector<pi> single;\n        for(auto p : state)\n        {\n            single.emplace_back(p);\n        }\n\n        rep(t, 9)\n        {\n            int N = state.size();\n            rep(i, N)\n            {\n                rep(j, single.size())\n                {\n                    auto a = state[i].first;\n                    auto b = single[j].first;\n\n                    //ロックがかぶっていたら評価しない\n                    if ((a & b).any())\n                    {\n                        continue;\n                    }\n\n                    int a_want = state[i].second;\n                    int b_want = single[j].second;\n                    if (a[b_want] && b[a_want])\n                    {\n                        unsafe = true;\n                        printf(\"UNSAFE\\n\");\n                        // cout << a << \" \" << a_want << \" \" << b << \" \"<< b_want << \"\\n\";\n                        // for (auto p : state)\n                        // {\n                        //     cout << p.first << \" \" << p.second << \"\\n\";\n                        // }\n                        break;\n                    }\n                    if (!a[b_want] && b[a_want])\n                    {\n                        auto locks = pi(a | b, b_want);\n                        if (!B[(a|b).to_ulong()][b_want])\n                        {\n                            state.emplace_back(locks);\n                            B[(a|b).to_ulong()][b_want] = true;\n                        }\n                    }\n                    if (!b[a_want] && a[b_want])\n                    {\n                        auto locks = pi(a | b, a_want);\n                        if (!B[(a | b).to_ulong()][a_want])\n                        {\n                            state.emplace_back(locks);\n                            B[(a | b).to_ulong()][a_want] = true;\n                        }\n                    }\n                }\n                if(unsafe)break;\n            }\n            if(unsafe)break;\n            \n        }\n        \n        if (!unsafe)\n        {\n            printf(\"SAFE\\n\");\n        }      \n        \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int N, dp1[1 << 10], dp2[1 << 10];\n\n  string S;\n  while(cin >> N, N) {\n    memset(dp1, 0, sizeof(dp1));\n\n    cin >> S;\n    for(int i = 0, curr = 0; i < N; i++) {\n      if(S[i] == 'u') {\n        curr = 0;\n      } else {\n        dp1[curr] |= 1 << (S[i] - '0');\n        curr |= 1 << (S[i] - '0');\n      }\n    }\n    for(int i = 0; i < (1 << 10); i++) {\n      dp2[i] = dp1[i];\n    }\n    for(int i = 1; i < 10; i++) {\n      for(int j = 0; j < (1 << 10); j++) {\n        for(int k = 0; k < (1 << 10); k++) {\n          if((j & k) != k) continue;\n          if(dp2[j - k] == 0) continue;\n          if(dp1[k] == 0) continue;\n          dp2[j] |= dp2[j - k] | dp1[k];\n        }\n      }\n    }\n    if([&]()\n    {\n      for(int i = 0; i < (1 << 10); i++) {\n        if(dp2[i] && (dp2[i] & i) == dp2[i]) return (false);\n      }\n      return (true);\n    }\n        ())\n      cout << \"SAFE\" << endl;\n    else {\n      cout << \"UNSAFE\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\nbool exist[1100][10];\nstruct State {\n    bitset<10> bit;\n    int t;\n    State() {\n        t = 0;\n        bit = 0;\n    }\n    void show() {\n        cerr << bit << endl;\n        cerr << \"t:\" << t << endl;\n    }\n    bool operator<(const State &b) { return t < b.t; }\n};\nbool ign(State &a, State &b) {\n    if (!a.bit[b.t] && !b.bit[a.t]) return true;\n    REP(i, 10) {\n        if (a.bit[i] && b.bit[i]) return true;\n    }\n    return false;\n}\nbool dead(State &a, State &b) {\n    if (a.bit[b.t] && b.bit[a.t]) return true;\n    return false;\n}\nbool canmerge(State &a, State &b) { return (a.bit[b.t] && !b.bit[a.t]) || (!a.bit[b.t] && b.bit[a.t]); }\nState merge(State &a, State &b) {\n    State nw;\n    if (a.bit[b.t] && !b.bit[a.t]) {\n        nw.bit = a.bit | b.bit;\n        nw.t = a.t;\n        return nw;\n    } else if (!a.bit[b.t] && b.bit[a.t]) {\n        nw.bit = a.bit | b.bit;\n        nw.t = b.t;\n        return nw;\n    } else {\n        cerr << \"cannot merge!!!!!\" << endl;\n    }\n}\nbool solve() {\n    int N;\n    cin >> N;\n    REP(i, 1 << 10) REP(j, 10) exist[i][j] = false;\n    if (N == 0) return false;\n    string S;\n    cin >> S;\n    // set<State> ss;\n    State now;\n    vector<State> vs;\n    REP(i, N) {\n        if (S[i] == 'u') {\n            now.t = 0;\n            now.bit = 0;\n        } else {\n            int num = S[i] - '0';\n            now.t = num;\n            if (now.bit[now.t]) {\n                cout << \"UNSAFE\" << endl;\n                return true;\n            }\n            int bi = now.bit.to_ulong();\n            if (!exist[bi][now.t]) {\n                exist[bi][now.t] = true;\n                // ss.insert(now);\n                // now.show();\n                vs.push_back(now);\n            }\n\n            now.bit[now.t] = true;\n        }\n    }\n\n    // for (auto s : ss) vs.push_back(s);\n    bool found = true;\n    while (found) {\n        found = false;\n        int n = vs.size();\n        REP(i, n) {\n            FOR(j, i + 1, n) {\n                if (ign(vs[i], vs[j])) continue;\n                if (dead(vs[i], vs[j])) {\n                    // vs[i].show();\n                    // vs[j].show();\n                    cout << \"UNSAFE\" << endl;\n                    return true;\n                }\n                State nw = merge(vs[i], vs[j]);\n                int bi = nw.bit.to_ulong();\n                if (!exist[bi][nw.t]) {\n                    found = true;\n                    vs.push_back(nw);\n                    // ss.insert(nw);\n                    exist[bi][nw.t] = true;\n                }\n            }\n        }\n    }\n    cout << \"SAFE\" << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nconst int M=10;\n\nint n;\nstring s;\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\tcin>>s;\n\t\ts+=\"0u\";\n\t\tvi dp(1<<M),b(M);\n\t\tdp[0]=1;\n\t\tvvi a;\n\t\tint I=0;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(s[i]=='u'){\n\t\t\t\tif(I!=i){\n\t\t\t\t\tstring t=s.substr(I,i-I-1);\n\t\t\t\t\tint T=t.size();\n\t\t\t\t\tvi c(T);\n\t\t\t\t\tfor(int j=0;j<T;j++){\n\t\t\t\t\t\tc[j]=t[j]-'0';\n\t\t\t\t\t\tb[t[j]-'0']++;\n\t\t\t\t\t}\n\t\t\t\t\tb[s[i-1]-'0']++;\n\t\t\t\t\ta.push_back(c);\n\t\t\t\t}\n\t\t\t\tI=i+1;\n\t\t\t}\n\t\t}\n\t\tb[0]--;\n\t\tint sum=0;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tsum+=b[i];\n\t\t\tif(!b[i]){\n\t\t\t\tvi c(1);\n\t\t\t\tc[0]=i;\n\t\t\t\ta.push_back(c);\n\t\t\t}\n\t\t}\n\t\tif(!sum){\n\t\t\tcout<<\"SAFE\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint A=a.size();\n\t\tfor(int i=0;i<A;i++){\n\t\t\tint S=a[i].size(),bit=0;\n\t\t\tfor(int j=0;j<S;j++){\n\t\t\t\tint v=a[i][j];\n\t\t\t\tif(bit&1<<v) break;\n\t\t\t\tbit+=1<<v;\n\t\t\t\tfor(int k=0;k<1<<M;k++) if((k&bit)==bit) dp[k]|=dp[k-bit];\n\t\t\t}\n\t\t}\n\t\tcout<<(dp[(1<<M)-1]?\"UNSAFE\":\"SAFE\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n \nint n;\nchar s[MAX_N];\nbool t[11][(1<<10)];\nbool dp[11][(1<<10)];\n \nbool check(int S){\n  memset(dp,false,sizeof(dp));\n  dp[0][0]=true;\n  int a=1;\n  for(int i=0;i<10;i++){\n    if(~S>>i&1)continue;\n    for(int j=0;j<(1<<10);j++){\n      if(!t[i][j])continue;\n      int k=(1<<10)-1-j;\n      while(1){\n        dp[a][j+k]|=dp[a-1][k];\n        if(dp[a][j+k] && ((j+k)&S)==S )return true;\n        if(k==0)break;\n        k=(k-1)&(~j);\n      }\n    }\n    a++;\n  }\n  return false;\n}\n \nbool solve(){\n  for(int bit=0;bit<(1<<10);bit++)\n    if(check(bit))return true;\n  return false;\n}\n \nint main(){\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    memset(t,false,sizeof(t));\n    scanf(\"%s\",s);\n    int bit=0;\n    for(int i=0;i<n;i++){\n      if(s[i]=='u')bit=0;\n      if('0'<=s[i]&&s[i]<='9'){\n        int num=s[i]-'0';\n        t[ num ][ bit ] = true;\n        bit|=(1<<num);\n      }\n    }\n    if(solve())printf(\"UNSAFE\\n\");\n    else printf(\"SAFE\\n\");\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\nusing namespace std;\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<map>\n#include<string.h>\n\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntemplate<typename T>\nbool chmin(T &l, T r) {\n\tbool f = l > r; if (f)l = r; return f;\n}\ntemplate<typename T>\nbool chmax(T &l, T r) {\n\tbool f = l < r; if (f)l = r; return f;\n}\nint g[1 << 10];\nint val[1 << 10];\nint f(int sup) {\n\tif (val[sup] != -1)return val[sup];\n\tint &ret = val[sup];\n\tret = 11;\n\tint sub = sup;\n\tdo {\n\t\tif (g[sub])chmin(ret, f(sup - sub) + 1);\n\t\tsub = (sub - 1)&sup;\n\t} while (sub != sup);\n\n\treturn ret;\n}\nint main() {\n\tint n; string s;\n\twhile (cin >> n, n) {\n\t\tcin >> s;\n\t\tint bit = 0;\n\t\tVV e(10,V(1 << 10,0));\n\t\tREP(i, n) {\n\t\t\tif (s[i] == 'u')bit = 0;\n\t\t\telse {\n\t\t\t\te[s[i] - '0'][bit] = 1;\n\t\t\t\tbit |= 1 << (s[i] - '0');\n\t\t\t}\n\t\t}\n\n\t\tbool ok = true;\n\t\tFOR(i, 1, 1 << 10) if(ok){\n\t\t\tREP(j, 1 << 10)g[j] = 0, val[j] = -1;\n\t\t\tval[0] = 0;\n\t\t\tREP(k, 10)if ((i >> k) & 1)REP(j, 1 << 10)g[j] |= e[k][j];\n\t\t\tif (f(i) <= 10) {\n\t\t\t\t//cout << i << endl;\n\t\t\t\tok = false; break;\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"SAFE\" << endl;\n\t\telse cout << \"UNSAFE\" << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nchar s[10010];\nbool comb[1<<10][10];\n\nint main(void){\n\tint n;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tscanf(\"%s\",s);\n\t\t\n\t\tmemset(comb,false,sizeof(comb));\n\t\tbool safe=true;\n\t\t\n\t\tint mask=0;\n\t\trep(i,n){\n\t\t\tif(s[i]=='u')\n\t\t\t\tmask=0;\n\t\t\telse{\n\t\t\t\tint get=s[i]-'0';\n\t\t\t\tif((mask&(1<<get))==0)\n\t\t\t\t\tcomb[mask][get]=true;\n\t\t\t\telse\n\t\t\t\t\tsafe=false;\n\t\t\t\tmask|=(1<<get);\n\t\t\t}\n\t\t}\n\n\t\tif(safe==false){\n\t\t\tputs(\"UNSAFE\");\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(mask1,1<<10)rep(get1,10)rep(mask2,1<<10)rep(get2,10){\n\t\t\tif(comb[mask1][get1]==false) continue;\n\t\t\tif(comb[mask2][get2]==false) continue;\n\t\t\tif(mask1&mask2) continue;\n\t\t\tif( (mask2&(1<<get1))!=0 &&  (mask1&(1<<get2))==0) comb[mask1|mask2][get2]=true;\n\t\t}\n\n\t\t\n\t\trep(mask1,1<<10)rep(get1,10)rep(mask2,1<<10)rep(get2,10){\n\t\t\tif(comb[mask1][get1]==false) continue;\n\t\t\tif(comb[mask2][get2]==false) continue;\n\t\t\tif(mask1&mask2) continue;\n\t\t\tif( (mask2&(1<<get1))!=0 &&  (mask1&(1<<get2)) !=0){\n\t\t\t\tsafe=false;\n\t\t\t\tmask1=1<<10,get1=10,mask2=1<<10,get2=10;\n\t\t\t}\n\t\t}\n\n\t\tif(safe)\n\t\t\tputs(\"SAFE\");\n\t\telse\n\t\t\tputs(\"UNSAFE\");\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <bitset>\n#include <set>\n\nusing ul = unsigned long;\n\nusing namespace std;\n\nusing BS = bitset<10>;\n\nstruct edge {\n    BS from;\n    int to;\n    ul hash() const { return ((ul)to << 10) + from.to_ulong(); }\n};\n\nbool operator<(const edge l, const edge r) {\n    return l.hash() < r.hash();\n}\n\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        string s;\n        cin >> s;\n        set<edge> st[11];\n        BS acc;\n        bool safe = true;\n        for (auto &c:s) {\n            if (c == 'u') {\n                acc.reset();\n            } else {\n                int d = c - '0';\n                if (acc[d]) {\n                    safe = false;\n                    break;\n                } else {\n                    st[acc.count()].insert(edge{acc, d});\n                    acc.set(d);\n                }\n            }\n        }\n\n        for (int i=1; i<=10; i++) {\n            for (int j=1; j<=i; j++) {\n                for (auto &ex:st[i]) {\n                    for (auto &ey:st[j]) {\n                        if ((ex.from & ey.from).count()) continue;\n                        if (ey.from[ex.to] && ex.from[ey.to]) {\n                            safe = false;\n                            break;\n                        } else if (ey.from[ex.to]) {\n                            st[i+j].insert(edge{ex.from | ey.from, ey.to});\n                        } else if (ex.from[ey.to]) {\n                            st[i+j].insert(edge{ex.from | ey.from, ex.to});\n                        }\n                    }\n                }\n            }\n        }\n        cout << (safe ? \"SAFE\" : \"UNSAFE\") << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,n) for (int i=(a);i<(n);i++)\nusing namespace std;\n\nbool p[1 << 10][10];//lock, nextorder\nbool used[1 << 10][10];\nint N;\nstring s;\n\nstruct State{\n\tint lock, nextorder;\n};\nint main(){\n\twhile(cin >> N,N){\n\t\tcin >> s;\n\t\ts = 'u' + s;\n\t\tN++;\n\t\tint Lock = 0;\n\t\tint nextOrder;\n\t\tbool deadLock = false;\n\t\t// single thread\n\t\tREP(i,N){\n\t\t\tif(s[i] == 'u' && s[i + 1] == 'u') continue;\n\t\t\tint nowOrder = s[i] - '0';\n\t\t\tif(isdigit(s[i])){\n\t\t\t\tif(Lock & (1 << nowOrder)){\n\t\t\t\t\tdeadLock = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tLock |= (1 << (nowOrder));\n\t\t\t}else{\n\t\t\t\tLock = 0;\n\t\t\t}\n\t\t\tif(i + 1 < N && isdigit(s[i + 1])){\n\t\t\t\tnextOrder = s[i + 1] - '0';\n\t\t\t\tp[Lock][nextOrder] = true;\n\t\t\t}\n\t\t}\n\t\t// multi thread\n\t\tREP(lock_s,1 << 10){\n\t\t\tif(deadLock) break;\n\t\t\tREP(next_s,10){\n\t\t\t\tif(!p[lock_s][next_s]) continue;\n\t\t\t\tqueue<State> que;\n\t\t\t\tque.push({lock_s, next_s});\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tState state = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tint lock_i = state.lock;\n\t\t\t\t\tint next_i = state.nextorder;\n\t\t\t\t\tREP(lock_j,1 << 10){\n\t\t\t\t\t\tif(lock_i & lock_j) continue;\n\t\t\t\t\t\tREP(next_j,10){\n\t\t\t\t\t\t\tif(!p[lock_j][next_j]) continue;\n\t\t\t\t\t\t\tint locks = lock_i | lock_j;\n\t\t\t\t\t\t\tif((1 << next_i) & lock_j && (1 << next_j) & lock_i){\n\t\t\t\t\t\t\t\tdeadLock = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((lock_j & (1 << next_i)) && !used[locks][next_j]){\n\t\t\t\t\t\t\t\tque.push({locks, next_j});\n\t\t\t\t\t\t\t\tused[locks][next_j] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((lock_i & (1 << next_j)) && !used[locks][next_i]){\n\t\t\t\t\t\t\t\tque.push({locks, next_i});\n\t\t\t\t\t\t\t\tused[locks][next_i] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(deadLock) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(deadLock) break;\n\t\t\t\t}\n\t\t\t\tif(deadLock) break;\n\t\t\t}\n\t\t}\n\t\tif(deadLock){\n\t\t\tcout << \"UNSAFE\" << endl;\n\t\t}else{\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t\tfill(p[0], p[1 << 10], false);\n\t\tfill(used[0], used[1 << 10], false);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing p = pair<int, int>;\n\nbool SetInit(string op, vector<p> &state, vector<vector<bool>> &memo) {\n    int now = 0, num = 0;\n    for (size_t i = 0; i < op.size() - 1; ++i) {\n        if (op[i + 1] == 'u')\n            now = 0;\n        else {\n            int t = (int)(op[i + 1] - '0'), add = (int)(op[i] - '0');\n\n            if (op[i] != 'u')\n                now |= (1 << add);\n            if (now & (1 << t))\n                return false;\n\n            if (!memo[t][now]) {\n                ++num;\n                memo[t][now] = true;\n            }\n        }\n    }\n\n    state.resize(num);\n    int idx = 0;\n    for (int t = 0; t < 10; ++t)\n        for (int s = 0; s < 1 << 10; ++s)\n            if (memo[t][s])\n                state[idx++] = p(t, s);\n\n    // cout << op << endl;\n    // for (auto x : state)\n    //     cout << x.first << \", \" << x.second << endl;\n\n    return true;\n}\n\nstring Solve(string op) {\n    vector<vector<bool>> memo(10, vector<bool>(1 << 10, false));\n    vector<p> cur;\n\n    if (!SetInit(op, cur, memo))\n        return \"UNSAFE\";\n\n    for (int i = 0; i < 10; ++i) {\n        const int n = cur.size();\n        vector<bool> used(n, false);\n        vector<p> nxt;\n\n        for (int j = 0; j < n; ++j) {\n            if (used[j])\n                continue;\n            for (int k = j + 1; k < n; ++k) {\n                if (used[k] || (cur[j].second & cur[k].second))\n                    continue;\n                if ((cur[j].second & (1 << cur[k].first)) &&\n                    (cur[k].second & (1 << cur[j].first)))\n                    return \"UNSAFE\";\n\n                if (cur[j].second & (1 << cur[k].first)) { // t_k \\in s_j\n                    used[k] = true;\n                    nxt.emplace_back(p(cur[j].first, cur[k].second | cur[j].second));\n                }\n                if (cur[k].second & (1 << cur[j].first)) { // t_j \\in s_k\n                    used[j] = true;\n                    nxt.emplace_back(p(cur[k].first, cur[k].second | cur[j].second));\n                }\n            }\n        }\n\n        for (int i = 0; i < n; ++i)\n            if (!used[i])\n                nxt.emplace_back(cur[i]);\n\n        cur = nxt;\n    }\n\n    return \"SAFE\";\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n\n    while (cin >> n, n) {\n        string s;\n\n        cin >> s;\n        cout << Solve(\"u\" + s) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\nint nextO[10];\nint have_lock[10];\nint N;\nstring s;\nvector<string> ss;\n\nvoid split(){\n\tss.clear();\n\tint l = 0;\n\tREP(i,N){\n\t\tif(s[i] == 'u'){\n\t\t\tss.push_back(s.substr(l,i - l));\n\t\t\tl = i + 1;\n\t\t}\n\t}\n}\n\nbool res = false;\nbool dfs(int thread_i, int end_i){\n\tif(thread_i > 9){\n\t\treturn false;\n\t}\n\tfor(int st_i = 0;st_i < end_i;st_i++){\n\t\tstring st = ss[st_i];\n\t\thave_lock[thread_i] = 0;\n\t\tnextO[thread_i] = 1 << (st[0] - '0');\n\t\tbool already_used = false;\n\t\tREP(i,thread_i){\n\t\t\tif(have_lock[i] & (1 << (st[0] - '0'))){\n\t\t\t\talready_used = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(already_used) continue;\n\t\tfor(int s_i = 0;s_i < st.size();s_i++){\n\t\t\tbool already_used = false;\n\t\t\tREP(i,thread_i + 1){\n\t\t\t\tif(have_lock[i] & (1 << (st[s_i] - '0'))){\n\t\t\t\t\talready_used = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(already_used){ //?????¢???\n\t\t\t\tREP(i,thread_i + 1){\n\t\t\t\t\tif(have_lock[thread_i] & nextO[i]){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{ //???????????????,??????????????????\n\t\t\t\thave_lock[thread_i] |= 1 << (st[s_i] - '0');\t\t\t\t\n\t\t\t}\n\t\t\tif(s_i + 1 < st.size() && st[s_i + 1] != 'u'){\n\t\t\t\tnextO[thread_i] = (1 << (st[s_i + 1] - '0'));\n\t\t\t}else{\n\t\t\t\tnextO[thread_i] = 0;\n\t\t\t}\n\t\t\tres |= dfs(thread_i + 1, st_i + 1);\n\t\t\tif(res || already_used) break;\n\t\t}\n\t\tif(res) break;\n\t}\n\t\t\thave_lock[thread_i] = 0;\n\tnextO[thread_i] = 0;\n\treturn res;\n}\n\nint main(){\n\n\twhile(cin >> N, N){\n\t\tcin >> s;\n\t\tsplit();\n\t\tres = false;\n\t\tcout << (dfs(0, ss.size()) ? \"UNSAFE\" : \"SAFE\") << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define whole(xs) xs.begin(),xs.end()\n#define uniq(xs) ((xs).erase(unique((xs).begin(), (xs).end()), (xs).end()))\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < int(vs.size()); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int INF = 1<<28;\n\n    int N;\n    string S;\n    bool input() {\n        cin >> N;\n        if (N == 0) return false;\n        cin >> S;\n        return true;\n    }\n\n    struct X {\n        int bit;\n        int n;\n        X() {}\n        X(int bit, int n) : bit(bit), n(n) {}\n    };\n    bool operator<(const X& a, const X& b) { return (a.bit == b.bit ? a.n < b.n : a.bit < b.bit); }\n    bool operator==(const X& a, const X& b) { return a.bit == b.bit && a.n == b.n; }\n\n    bool dominate(const X& a, const X& b) {\n        return a.bit & (1 << b.n);\n    }\n\n    bool conflict(const X& a, const X& b) {\n        assert((a.bit & b.bit) == 0);\n        return dominate(a, b) && dominate(b, a);\n    }\n\n    X merge(const X& a, const X& b) {\n        assert(dominate(a, b));\n        return X(a.bit | b.bit, a.n);\n    }\n\n    void solve() {\n        vector<string> ss;\n        int p = 0;\n        for (int i = 0; i < N; i++) {\n            if (S[i] == 'u') {\n                ss.push_back(S.substr(p, i - p));\n                p = i + 1;\n            }\n        }\n\n        int M = int(ss.size());\n\n        vector<X> xs;\n        for (int i = 0; i < M; i++) {\n            const string& s = ss[i];\n            int bit = 0;\n            for (int j = 0; j < int(s.size()); j++) {\n                int p = s[j] - '0';\n                xs.push_back(X(bit, p));\n                if (bit & (1 << p)) {\n                    cout << \"UNSAFE\" << endl;\n                    return;\n                }\n                bit |= (1 << p);\n            }\n        }\n\n        for (int k = 0; k < 10; k++) {\n            sort(whole(xs));\n            uniq(xs);\n            int T = xs.size();\n            vector<bool> used(T, false);\n            vector<X> ys;\n            for (int i = 0; i < T; i++) {\n                X x = xs[i];\n                for (int j = i + 1; j < T; j++) {\n                    X y = xs[j];\n                    if (x.bit & y.bit) continue;\n                    if (conflict(x, y)) {\n                        cout << \"UNSAFE\" << endl;\n                        return;\n                    }\n                    if (dominate(x, y)) {\n                        xs.push_back(merge(x, y));\n                    }\n                }\n            }\n        }\n\n        cout << \"SAFE\" << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nconst int M=10;\n\nint n;\nstring s;\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\tcin>>s;\n\t\ts+=\"0u\";\n\t\tvi dp(1<<M),b(M);\n\t\tdp[0]=1;\n\t\tvvi a;\n\t\tint I=0;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(s[i]=='u'){\n\t\t\t\tstring t=s.substr(I,i-I-1);\n\t\t\t\tint T=t.size();\n\t\t\t\tvi c(T);\n\t\t\t\tfor(int j=0;j<T;j++){\n\t\t\t\t\tc[j]=t[j]-'0';\n\t\t\t\t\tb[t[j]-'0']++;\n\t\t\t\t}\n\t\t\t\tb[s[i-1]-'0']++;\n\t\t\t\ta.push_back(c);\n\t\t\t\tI=i+1;\n\t\t\t}\n\t\t}\n\t\tb[0]--;\n\t\tfor(int i=0;i<M;i++) if(!b[i]){\n\t\t\tvi c(1);\n\t\t\tc[0]=i;\n\t\t\ta.push_back(c);\n\t\t}\n\t\tint A=a.size();\n\t\tfor(int i=0;i<A;i++){\n\t\t\tint S=a[i].size(),bit=0;\n\t\t\tfor(int j=0;j<S;j++){\n\t\t\t\tint v=a[i][j];\n\t\t\t\tif(bit&1<<v) break;\n\t\t\t\tbit+=1<<v;\n\t\t\t\tfor(int k=0;k<1<<M;k++) if((k&bit)==bit) dp[k]|=dp[k-bit];\n\t\t\t}\n\t\t}\n\t\tcout<<(dp[(1<<M)-1]?\"UNSAFE\":\"SAFE\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\n\nint main() {\n\twhile (1) {\n\t\tvector<vector<int>>oks(10, vector<int>(1024, -1));\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tstring st; cin >> st;\n\t\tvector<vector<int>>vs;\n\t\tvector<int>v;\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'u') {\n\t\t\t\tvs.emplace_back(v);\n\t\t\t\tv.clear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (v[st[i] - '0'])ok = false;\n\t\t\t\telse v[st[i] - '0']=true;\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\n\t\t}\n\t\tfor (auto v : vs) {\n\t\t\tbitset<10>bs;\n\t\t\tbs[v[0]] = true;\n\t\t\tfor (int i = 1; i < v.size(); ++i) {\n\t\t\t\toks[v[i]][bs.to_ulong()] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tfor (int k = 0; k < 10; ++k) {\n\t\t\t\tfor (int l = 0; l < 1024; ++l) {\n\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\tif (!oks[j][k] || !oks[l][m])continue;\n\t\t\t\t\t\tif (j&l)continue;\n\t\t\t\t\t\tif ((j&(1 << m)) && !(l&(1 << k)))oks[j | l][k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tfor (int k = 0; k < 10; ++k) {\n\t\t\t\tfor (int l = 0; l < 1024; ++l) {\n\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\tif (!oks[j][k] || !oks[l][m])continue;\n\t\t\t\t\t\tif (j&l)continue;\n\t\t\t\t\t\tif ((j&(1 << m)) && l&(1 << l)) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"safe\" << endl;\n\t\telse cout << \"unsafe\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nconst int num = 10;\n\nint main() {\n\twhile (1) {\n\t\tvector<vector<int>>oks(1024, vector<int>(10, 0));\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tstring st; cin >> st;\n\t\tvector<vector<int>>vs;\n\t\tvector<int>v;\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'u') {\n\t\t\t\tvs.emplace_back(v);\n\t\t\t\tv.clear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv.emplace_back(st[i]-'0');\n\t\t\t}\n\t\t}\n\t\tfor (auto v : vs) {\n\t\t\tif (v.empty())continue;\n\t\t\tbitset<10>bs;\n\t\t\tbs[v[0]] = true;\n\t\t\toks[0][v[0]] = true;\n\t\t\tfor (int i = 1; i < v.size(); ++i) {\n\t\t\t\toks[bs.to_ulong()][v[i]] = true;\n\t\t\t\tif (bs[v[i]]) {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbs[v[i]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tfor (int k = 0; k < 10; ++k) {\n\t\t\t\tfor (int l = 0; l < 1024; ++l) {\n\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\tif ((!oks[j][k]) || (!oks[l][m]))continue;\n\t\t\t\t\t\tif (j&l)continue;\n\t\t\t\t\t\tif (!(j&(1 << m)) && (l&(1 << k)))oks[j | l][m] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tfor (int k = 0; k < 10; ++k) {\n\t\t\t\tfor (int l = 0; l < 1024; ++l) {\n\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\tif ((!oks[j][k]) || (!oks[l][m]))continue;\n\t\t\t\t\t\tif (j&l)continue;\n\t\t\t\t\t\tif ((j&(1 << m)) && l&(1 << k)) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"SAFE\" << endl;\n\t\telse cout << \"UNSAFE\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(int arg_have_lock,int arg_next_lock){\n\t\thave_lock = arg_have_lock;\n\t\tnext_lock = arg_next_lock;\n\t}\n\tint have_lock,next_lock;\n};\n\nint length,POW[11];\nbool check[1<<10][10];\nchar buf[10001];\n\nvoid func(){\n\n\tfor(int state = 0; state < POW[10]; state++){\n\t\t\tfor(int next = 0; next < 10; next++)check[state][next] = false;\n\t}\n\n\tvector<Info> V,NEW;\n\n\tscanf(\"%s\",buf);\n\n\t\tint state,next,k;\n\n\t\t//あり得る状態を列挙\n\t\tfor(int i = 0; i < length; ){\n\t\t\tif(buf[i] != 'u'){\n\t\t\t\tstate = 0;\n\t\t\t\tfor(k = i; buf[k] != 'u'; k++){\n\t\t\t\t\tnext = buf[k]-'0';\n\t\t\t\t\tif(state & (1 << next)){\n\t\t\t\t\t\tprintf(\"UNSAFE\\n\"); //既に持っているデータをロックしようとしたらunsafe\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!check[state][next]){ //初出の状態\n\t\t\t\t\t\tcheck[state][next] = true;\n\t\t\t\t\t\tV.push_back(Info(state,next));\n\t\t\t\t\t}\n\t\t\t\t\tstate += POW[next];\n\t\t\t\t}\n\t\t\t\ti = k+1;\n\t\t\t}\n\t\t}\n\n\t\tint next_state;\n\t\tbool in_i,in_k;\n\n\n\t\twhile(true){\n\n\t\t\t//状態同士で演算\n\t\t\tfor(int i = 0; i < V.size()-1; i++){\n\t\t\t\tfor(int k = i+1; k < V.size(); k++){\n\t\t\t\t\tif(V[i].have_lock&V[k].have_lock)continue; //共通資源があったらSKIP\n\n\t\t\t\t\t//次の資源の共有関係を見る\n\t\t\t\t\tif(V[k].have_lock&(1 << V[i].next_lock)){\n\t\t\t\t\t\tin_k = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tin_k = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(V[i].have_lock&(1 << V[k].next_lock)){\n\t\t\t\t\t\tin_i = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tin_i = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(in_i == true && in_k == true){\n\t\t\t\t\t\tprintf(\"UNSAFE\\n\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(in_i == false && in_k == false)continue;\n\n\t\t\t\t\tnext_state = V[i].have_lock|V[k].have_lock;\n\t\t\t\t\tif(in_i){\n\t\t\t\t\t\tnext = V[i].next_lock;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext = V[k].next_lock;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!check[next_state][next]){\n\t\t\t\t\t\tcheck[next_state][next] = true;\n\t\t\t\t\t\tNEW.push_back(Info(next_state,next));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(NEW.size() == 0)break;\n\n\t\t\tfor(int i = 0; i < NEW.size(); i++)V.push_back(NEW[i]);\n\t\t\tNEW.clear();\n\t\t}\n\n\t\tprintf(\"SAFE\\n\");\n\n\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d\",&length);\n\t\tif(length == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n\nstruct State {\n    int lock, need;\n    bool operator <  (const State &r) const { return lock == r.lock ? need < r.need : lock < r.lock; }\n    bool operator ==  (const State &r) const { return lock == r.lock and need == r.need; }\n};\n\nbool solve() {\n    int N; cin >> N;\n    if(N == 0) return false;\n    string S; cin >> S;\n\n    bool dead_lock = false;\n    vector<State> states;\n    {\n        State s;\n        rep(i, S.size()) {\n            if(S[i] != 'u') {\n                int n = S[i] - '0';\n                if(s.lock & (1 << n)) dead_lock = true;\n                s.need = n;\n                states.push_back(s);\n                s.lock |= (1 << n);\n            } else {\n                s = State();  \n            }\n        }\n        sort(all(states));\n        states.erase(unique(all(states)), end(states));\n    }\n    auto dead_locking = [&] (const State &a, const State &b) {\n        if(a.lock & b.lock) return false;\n        if(a.lock & (1 << b.need) and b.lock & (1 << a.need)) return true;\n        return false;\n    };\n    auto merge = [&] (const State &a, const State &b) {\n        if(a.lock & b.lock) return;\n        if(a.lock & (1 << b.need)) {\n            states.push_back(State{a.lock | b.lock, a.need});\n        }\n        if(b.lock & (1 << a.need)) {\n            states.push_back(State{a.lock | b.lock, b.need});\n        }\n    };\n    while(not dead_lock) {  \n        int M = states.size();\n        rep(i, M) rep(j, i) {\n            dead_lock |= dead_locking(states[i], states[j]);\n            merge(states[i], states[j]);\n        }\n        sort(all(states));\n        states.erase(unique(all(states)), end(states));\n        if(states.size() == M) break;\n    }   \n    cout << (dead_lock ? \"UNSAFE\" : \"SAFE\") << endl;\n    \n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nconst int M=10;\n\nint n;\nstring s;\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\tcin>>s;\n\t\ts+=\"0u\";\n\t\tvi dp(1<<M),b(M);\n\t\tdp[0]=1;\n\t\tvvi a;\n\t\tint I=0;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(s[i]=='u'){\n\t\t\t\tstring t=s.substr(I,i-I-1);\n\t\t\t\tint T=t.size();\n\t\t\t\tvi c(T);\n\t\t\t\tfor(int j=0;j<T;j++){\n\t\t\t\t\tc[j]=t[j]-'0';\n\t\t\t\t\tb[t[j]-'0']++;\n\t\t\t\t}\n\t\t\t\tb[s[i-1]-'0']++;\n\t\t\t\ta.push_back(c);\n\t\t\t\tI=i+1;\n\t\t\t}\n\t\t}\n\t\tb[0]--;\n\t\tfor(int i=0;i<M;i++) if(!b[i]){\n\t\t\tvi c(1);\n\t\t\tc[0]=i;\n\t\t\ta.push_back(c);\n\t\t}\n\t\tint A=a.size();\n\t\tfor(int i=0;i<A;i++){\n\t\t\tint S=a[i].size(),bit=0;\n\t\t\tfor(int j=0;j<S;j++){\n\t\t\t\tint v=a[i][j];\n\t\t\t\tif(bit&1<<v) break;\n\t\t\t\tbit+=1<<v;\n\t\t\t\tfor(int k=0;k<1<<M;k++) if((k&bit)==bit) dp[k]|=dp[k-bit];\n\t\t\t}\n\t\t}\n\t\tcout<<(dp[(1<<M)-1]?\"UNSAFE\":\"SAFE\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    string s;\n    cin >> s;\n    vector<string> sec;\n    int pre=0;\n    REP(i,s.size()){\n      if(s[i]=='u') {\n\tsec.push_back(string(s.begin()+pre,s.begin()+i));\n\tpre=i+1;\n      }\n    }\n    bool flag=true;\n    REP(i,sec.size()) if(sec[i].size()>10) flag=false;\n    if(!flag){\n      cout << \"UNSAFE\" << endl;\n      continue;\n    }\n    vector<set<int> > lone(1<<10);\n    //lock,next;\n    REP(i,sec.size()){\n      int lock=0;\n      REP(j,sec[i].size()-1){\n\tlock=(lock|(1<<(sec[i][j]-'0')));\n\tlone[lock].insert(1<<(sec[i][j+1]-'0'));\n      }\n    }\n    REP(i,1<<10){\n      if(lone[i].empty()) continue;\n      for(int ne:lone[i]){\n\tif((i&ne)==ne){\n\t  flag=false;\n\t  break;\n\t}\n      }\n      if(!flag) break;\n      REP(j,1<<10){\n\tif(i&j) continue;\n\tint suc=i|j;\n\tfor(int nei:lone[i]){\n\t  for(int nej:lone[j]){\n\t    lone[suc].insert(nei|nej);\n\t  }\n\t}\n      }\n    }\n    if(flag) cout << \"SAFE\" << endl;\n    else cout << \"UNSAFE\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nint main(){\n    ll n;\n    while(cin>>n){\n        if(n==0){break;}\n    string s;\n    cin>>s;\n    vector<vector<bool>> dp(10,vector<bool>(1LL<<10,false));\n    ll k=0;\n    bool j=false;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='u'){k=0; continue;}\n        if(i+1==s.size() || s[i+1]=='u'){continue;}\n        k|=1LL<<(s[i]-'0');\n        ll n=s[i+1]-'0';\n        if(k>>n&1){j=true;}\n        dp[n][k]=true;\n    }\n    for(ll i=0;i<(1LL<<10) && !j;i++){\n        for(int t=0;t<10;t++){\n            if(dp[t][i]==false){continue;}\n            ll z=((1LL<<10)-1)^i;\n            for(ll k=z;k>0;k=(k-1)&z){\n                if((k>>t&1)==0){continue;}\n                for(int h=0;h<10;h++){\n                    if(dp[h][k]){\n                        dp[h][i^k]=true;\n                        if((i^k)>>h&1){j=true;}\n                    }\n                }\n            }\n            for(int h=0;h<10;h++){\n                if(dp[h][0]){\n                    dp[h][i]=true;\n                    if(i>>h&1){j=true;}\n                }\n            }\n        }\n    }\n    cout<<(j?\"UNSAFE\":\"SAFE\")<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n\nint n;\nchar s[MAX_N];\nbool t[11][(1<<10)];\nbool dp[11][(1<<10)];\n\nbool check(int S){\n  memset(dp,false,sizeof(dp));\n  dp[0][0]=true;\n  int a=1;\n  for(int i=0;i<10;i++){\n    if(~S>>i&1)continue;\n    for(int j=0;j<(1<<10);j++){\n      if(!t[i][j])continue;\n      int k=(1<<10)-1-j;\n      while(1){\n        dp[a][j+k]|=dp[a-1][k];\n        if(dp[a][j+k] && ((j+k)&S)==S )return true;\n        if(k==0)break;\n        k=(k-1)&(~j);\n      }\n    }\n    a++;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int bit=0;bit<(1<<10);bit++)\n    if(check(bit))return true;\n  return false;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    memset(t,false,sizeof(t));\n    scanf(\"%s\",s);\n    int bit=0;\n    for(int i=0;i<n;i++){\n      if(s[i]=='u')bit=0;\n      if('0'<=s[i]&&s[i]<='9'){\n        int num=s[i]-'0';\n        t[ num ][ bit ] = true;\n        bit|=(1<<num);\n      }\n    }\n    if(solve())printf(\"UNSAFE\\n\");\n    else printf(\"SAFE\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint dp[1<<11];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tstring str;\n\t\tcin >> str;\n\t\tint bits=0;\n\t\tbool flag=true;\n\t\tint v2=-1;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif(str[i]=='u'){\n\t\t\t\tbits=0;\n\t\t\t\tv2=-1;\n\t\t\t}else{\n\t\t\t\tif(v2==-1){\n\t\t\t\t\tv2=str[i]-'0';\n\t\t\t\t\tbits=(1<<v2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v=str[i]-'0';\n\t\t\t\tif((bits>>v) & 1)flag=false;\n\t\t\t\tdp[bits]|=(1<<v);\n\t\t\t\tbits|=(1<<v);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif((i&j)==j){\n\t\t\t\t\tif(dp[j]==0 || dp[i-j]==0)continue;\n\t\t\t\t\tdp[i]=dp[i]|dp[j];\n\t\t\t\t\tdp[i]=dp[i]|dp[i-j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tif((!(i>>k & 1)) && (dp[i]>>k & 1))ok=true;\n\t\t\t}\n\t\t\tif(!ok && dp[i]>0)flag=false;\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"SAFE\":\"UNSAFE\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nbool dp[1<<10];\n\nbool solve(){\n  int n;\n  char s[SIZE];\n  vector<int> vec[10];\n  \n  scanf(\"%d\", &n);\n\n  if(n == 0) return false;\n\n  scanf(\"%s\", s);\n\n  int p = 0;\n  \n  for(int i=0;i<n;i++){\n    int b = s[i] - '0';\n    if(p != 0 && s[i] != 'u') vec[b].push_back(p);\n\n    if(s[i] == 'u'){\n      p = 0; continue;\n    }\n\n    if(p & (1 << b)){\n      puts(\"UNSAFE\");\n      return true;\n    }\n\n    p |= 1 << b;\n  }\n\n  for(int i=0;i<10;i++){\n    for(int j=0;j<(1<<10);j++) dp[j] = false;\n\n    \n    for(int j=0;j<vec[i].size();j++){\n      dp[vec[i][j]] = true;\n    }\n\n    for(int j=0;j<(1<<10);j++){\n      if(dp[j] && (j & (1 << i))){\n        puts(\"UNSAFE\");\n        return true;\n      }\n      for(int k=0;k<10;k++){\n        if(dp[j] && (j & (1 << k))){\n          for(int l=0;l<vec[k].size();l++){\n            if((j & vec[k][l]) == 0) dp[j|vec[k][l]] = true;\n          }\n        }\n      }\n    }\n  }\n\n  puts(\"SAFE\");\n  return true;\n}\n\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<int, int> P;\nint check[1 << 10][10];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tstring s;\n\twhile(cin >> N, N) {\n\t\tmemset(check, 0, sizeof check);\n\t\tcin >> s;\n\n\t\tbool ok = true;\n\t\tvector<P> v;\n\t\tint x = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(s[i] == 'u') {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint y = s[i] - '0';\n\t\t\t\tif(!check[x][y]) {\n\t\t\t\t\tv.push_back({ x, y });\n\t\t\t\t\tcheck[x][y] = 1;\n\t\t\t\t}\n\n\t\t\t\tif(x >> y & 1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx |= 1 << y;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok) cout << \"UNSAFE\" << endl;\n\n\t\tint n = 0;\n\n\t\twhile(1) {\n\t\t\tvector<P> add;\n\t\t\tfor(int i = 0; i < v.size() && ok; i++) {\n\t\t\t\tfor(int j = 0; j < v.size() && ok; j++) {\n\t\t\t\t\tif(i == j) continue;\n\t\t\t\t\tint s1 = v[i].first, t1 = v[i].second;\n\t\t\t\t\tint s2 = v[j].first, t2 = v[j].second;\n\t\t\t\t\tif(s1 & s2) continue;\n\t\t\t\t\tint ns = s1 | s2;\n\t\t\t\t\tif((s1 >> t2 & 1) && (s2 >> t1 & 1)) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((s1 >> t2 & 1) && !(s2 >> t1 & 1)) {\n\t\t\t\t\t\tif(!check[ns][t1]) {\n\t\t\t\t\t\t\tadd.push_back({ ns, t1 });\n\t\t\t\t\t\t\tcheck[ns][t1] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!(s1 >> t2 & 1) && (s2 >> t1 & 1)) {\n\t\t\t\t\t\tif(!check[ns][t2]) {\n\t\t\t\t\t\t\tadd.push_back({ ns, t2 });\n\t\t\t\t\t\t\tcheck[ns][t2] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!ok || add.size() == 0) break;\n\n\t\t\tn = v.size();\n\t\t\tfor(auto p : add) {\n\t\t\t\tv.push_back(p);\n\t\t\t}\n\t\t}\n\n\t\tif(ok) cout << \"SAFE\" << endl;\n\t\telse cout << \"UNSAFE\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <set>\nusing namespace std;\n\nint mm(int k);\nint n;\nint en;\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<set<int> > > tu;\nvoid next(int v,int f,vector<int> route);\n\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    set<int> se;\n    a.assign(n+1,10);\n    tu.assign(10,vector<set<int> >(10,se));\n    char s;\n    en=0;\n    a[0]=10;\n    int ss=0;\n    scanf (\"\\n\");\n    for(int t=1;t<=n;){\n      scanf (\"%c\",&s);\n      if('0'<=s&&s<='9'){\n        a[t]=s-'0';\n        if(a[t-1]!=10){\n          tu[a[t-1]][a[t]].insert(ss);\n          ss=ss|mm(a[t-1]);\n          if((ss&mm(a[t]))!=0){\n            en=1;\n          }\n        }\n        else{\n          ss=0;\n        }\n        t++;\n      }\n      else{\n        ss=0;\n        if(a[t-1]==10){\n          n--;\n        }\n        else{\n          a[t]=10;\n          t++;\n        }\n      }\n    }\n\n/*    for(int t=1;t<n;t++){\n      if(a[t]!=10&&a[t+1]!=10){\n        tu[a[t]][a[t+1]].push_back(ss);\n        ss=ss|mm(a[t]);\n      }\n      else{\n        ss=0;\n      }\n    }*/\n    vector<int> route2;\n    for(int t=0;t<10&&en==0;t++){\n      next(t,0,route2);\n    }\n    if(en==1){\n      printf(\"UNSAFE\\n\");\n    }\n    else{\n      printf(\"SAFE\\n\");\n    }\n    //printf(\"%d\\n\",f);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint mm(int k){\n  return 1<<k;\n}\n\nvoid next(int v,int f,vector<int> route){\n  f=f|mm(v);\n  route.push_back(v);\n  for(int t=0;t<10&&en==0;t++){\n    if(tu[v][t].size()){\n      if((f&mm(t))==0){\n        next(t,f,route);\n      }\n      else{\n        route.push_back(t);\n        //printf(\"%ld\\n\",tu[7][7].size());\n        //printf(\"%ld %d %d %d %d\\n\",route.size(),route[0],route[1],route[2],route[3]);\n        for(int w=0;w<int(route.size())&&route[w]!=t;){\n          route.erase(route.begin());\n        }\n        /*int q=0;\n        for(q=0;q<int(route.size())&&route[q]!=t;q++){\n        }\n        if(q>0){\n          route.erase(route.begin(),route.begin()+q-1);\n        }*/\n        //printf(\"%d\\n\",route[0]);\n        if(route.size()==2){\n          en=1;\n          //printf(\"%d %d\\n\",route[0],route[1]);\n        }\n        else{\n          for(int z=0;(z<int(route.size())-1)&&en!=1;z++){\n            for(int w=z+1;(w<int(route.size())-1)&&en!=1;w++){\n              for(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end()&&en==0;++x){\n                for(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end()&&en==0;++y) {\n                  if((*x&*y)==0){\n                    en=1;\n                  }\n                }\n              }\n            }\n          }\n        }\n        //printf(\"V=%d,T=%d\\n\",v,t);\n      }\n    }\n  }\n}\n/*\nfor(auto x=tu[route[z]][route[z+1]].begin();x!=tu[route[z]][route[z+1]].end();++x){\nfor(auto y=tu[route[w]][route[w+1]].begin();y!=tu[route[w]][route[w+1]].end();++y) {\n  if((*x&*y)==0){\n    en=1;\n  }\n}\n}*/\n\n\n/*\nuからはじまる場合\n\nmapはダメ\n配列bit処理\nまたは？\n深さ優先探索で訪問済みの印が付いたら終わり\n\n\nその前にrouteのかぶり\n//自分とのかぶりはバツ\n共通のかぶりバツ\nその上条件に適した組みが一つ以上ある\n\n\n*/\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1604 Deadlock Detection\n// 2018.4.18 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar str[10005];\nchar dp[1024][10];\nint  a[10005][2], sz;\n\nint calc(int n)\n{\n\tint i, s, k, l, w, sw;\n\tchar *p;\n\n\tmemset(dp, 0, sizeof(dp));\n\ts = 0, sz = 0;\n\tfor (p = str; *p > ' '; p++) {\n\t\tif (*p == 'u') s = 0;\n\t\telse {\n\t\t\tk = *p & 0xf;\n\t\t\tif (s) {\n\t\t\t\tif (s & (1<<k)) return 0;\n\t\t\t\tdp[s][k] = 1;\n\t\t\t\ta[sz][0] = s, a[sz++][1] = k;\n\t\t\t}\n\t\t\ts |= 1<<k;\n\t\t}\n\t}\n \tfor (l = 1; l < 1024; l++) for (w = 0; w < 10; w++) {\n\t\tif (!dp[l][w]) continue;\n\t\tsw = 1<<w;\n\t\tif (l & sw) return 0;\n \n\t\tfor (i = 0; i < sz; i++) {\n\t\t\tif ((l & a[i][0]) == 0 && (sw & a[i][0])) {\n\t\t\t\tdp[l|a[i][0]][a[i][1]] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n \nint main()\n {\n\tint n;\n\t\n\twhile (fgets(str, 10, stdin) && *str != '0') {\n\t\tn = atoi(str);\n\t\tfgets(str, sizeof(str), stdin);\n\t\tputs(calc(n)? \"SAFE\": \"UNSAFE\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing P = System.Numerics.Complex;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            for (; ; )\n            {\n                var n = ri;\n                if (n == 0) break;\n                var s = rs;\n\n                var die = false;\n                var next = new int[1 << 10];\n                const int ALL = 1023;\n                next[0] = ALL;\n                {\n                    var mask = 0;\n                    for (int i = 0; i < n; i++)\n                    {\n                        if (s[i] == 'u') mask = 0;\n                        else\n                        {\n                            var v = 1 << (s[i] - '0');\n                            next[mask] |= v;\n                            die |= (mask & v) > 0;\n                            mask |= v;\n                        }\n                    }\n                }\n                var vis = new bool[1 << 10, 10];\n                Action<int, int> dfs = null;\n                dfs = (used, nex) =>\n                {\n                    if (vis[used, nex]) return;\n                    vis[used, nex] = true;\n                    var rem = ALL ^ used;\n                    var need = 1 << nex;\n                    for (int sub = rem; sub > 0; sub = ((sub - 1) & rem))\n                    {\n                        if (next[sub] == 0) continue;\n                        if ((sub & need) > 0)\n                        {\n                            for (int d = 0; d < 10; d++)\n                                if ((next[sub] >> d & 1) == 1)\n                                {\n                                    if ((used >> d & 1) == 1) die |= true;\n                                    else dfs(sub | used, d);\n                                }\n                        }\n                    }\n                };\n                for (int i = 0; i < 10; i++)\n                    dfs(0, i);\n                Console.WriteLine(die ? \"UNSAFE\" : \"SAFE\");\n            }\n\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n"
  },
  {
    "language": "Ruby",
    "code": "\ndef deadlock?(commands)\n  if commands.any? {|c| samelock? c }\n    true\n  elsif rotatelock? commands\n    true\n  elsif commands.combination(2).to_a.any? {|a, b| swaplock? a, b }\n    true\n  else\n    false\n  end\nend\n\ndef rotatelock?(commands)\n  commands.any? do |command|\n    endlock = command[0]\n    looks = [command]\n    while looks.size > 0\n      look_command = looks.pop\n\n      return true if  endlock == look_command[-1]\n\n      looks.concat commands.select {|c| c[0] == look_command[-1] }\n    end\n    false\n  end\nend\n\ndef swaplock?(command1, command2)\n  combi = command1.split(\"\").combination(2).to_a\n  if combi.any? {|arr| swaplock_match? arr, command1, command2 }\n    true\n  else\n    false\n  end\nend\n\ndef swaplock_match?(char_combi, command1, command2)\n  if /(.*)#{char_combi[1]}(.*)#{char_combi[0]}/ =~ command2\n    search_s = $1 + $2\n    if search_s.split(\"\").any? {|c| command1[0..search_s.length+1].include? c }\n      false\n    else\n      true\n    end\n  else\n    false\n  end\nend\n\ndef samelock?(command)\n  command.size != command.split(\"\").uniq.size\nend\n\nwhile true\n  n = gets.chomp.to_i\n\n  break if n == 0\n\n  commands = gets.chomp.split(\"u\")\n\n  if deadlock? commands\n    puts \"UNSAFE\"\n  else\n    puts \"SAFE\"\n  end\nend"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    s = raw_input()\n    lock = 0\n    P = set()\n    for c in s:\n        if c is 'u':\n            lock = 0\n        else:\n            P.add((lock, 1 << int(c)))\n            lock |= 1 << int(c)\n    while 1:\n        Q = set()\n        for lock1, c1 in P:\n            for lock2, c2 in P:\n                if lock1 & lock2 == 0 and c1 & lock2 == c1:\n                    Q.add((lock1 | lock2, c2))\n        if not Q - P:\n            break\n        P |= Q\n    ok = 1\n    for lock1, c1 in P:\n        for lock2, c2 in P:\n            if lock1 & lock2 == 0 and c1 & lock2 == c1 and c2 & lock1 == c2:\n                ok = 0\n    for lock, c in P:\n        if lock & c == c:\n            ok = 0\n    print \"SAFE\"*ok or \"UNSAFE\""
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    s = raw_input()\n    lock = 0\n    P = []\n    for c in s:\n        if c is 'u':\n            lock = 0\n        else:\n            P.append((lock, 1 << int(c)))\n            lock |= 1 << int(c)\n    Q = set()\n    i = 0; ok = 1\n    while i < len(P) and ok:\n        lock1, t1 = P[i]\n        if lock1 & t1 == t1:\n            ok = 0\n        for j in xrange(i):\n            lock2, t2 = P[j]\n            if lock1 & lock2 == 0 and t1 & lock2 == t1:\n                if t2 & lock1 == t2:\n                    ok = 0\n                v = (lock1 | lock2, t2)\n                if v not in Q:\n                    P.append(v)\n        i += 1\n    print \"SAFE\"*ok or \"UNSAFE\""
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    s = raw_input()\n    lock = 0\n    P = []\n    for c in s:\n        if c is 'u':\n            lock = 0\n        else:\n            P.append((lock, 1 << int(c)))\n            lock |= 1 << int(c)\n    Q = set()\n    i = 0\n    while i < len(P):\n        lock1, t1 = P[i]\n        for j in xrange(i):\n            lock2, t2 = P[j]\n            if lock1 & lock2 == 0 and t1 & lock2 == t1:\n                v = (lock1 | lock2, t2)\n                if v not in Q:\n                    P.append(v)\n        i += 1\n    ok = 1\n    for lock1, c1 in P:\n        for lock2, c2 in P:\n            if lock1 & lock2 == 0 and c1 & lock2 == c1 and c2 & lock1 == c2:\n                ok = 0\n    for lock, c in P:\n        if lock & c == c:\n            ok = 0\n    print \"SAFE\"*ok or \"UNSAFE\""
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    s = raw_input()\n    Q = set()\n    lock = 0\n    P = []\n    for c in s:\n        if c is 'u':\n            lock = 0\n        else:\n            v = (lock, 1 << int(c))\n            P.append(v)\n            Q.add(v)\n            lock |= 1 << int(c)\n    i = 0; ok = 1\n    while i < len(P) and ok:\n        lock1, t1 = P[i]\n        if lock1 & t1 == t1:\n            ok = 0\n        for j in xrange(i):\n            lock2, t2 = P[j]\n            if lock1 & lock2 == 0 and t1 & lock2 == t1:\n                if t2 & lock1 == t2:\n                    ok = 0\n                v = (lock1 | lock2, t2)\n                if v not in Q:\n                    P.append(v)\n                    Q.add(v)\n        i += 1\n    print \"SAFE\"*ok or \"UNSAFE\""
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    s = raw_input()\n    Q = set()\n    lock = 0\n    P = []\n    for c in s:\n        if c is 'u':\n            lock = 0\n        else:\n            v = (lock, 1 << int(c))\n            if v not in Q:\n                P.append(v)\n                Q.add(v)\n            lock |= 1 << int(c)\n    i = 0; ok = 1\n    while i < len(P) and ok:\n        lock1, t1 = P[i]\n        if lock1 & t1 == t1:\n            ok = 0\n        for j in xrange(i):\n            lock2, t2 = P[j]\n            if lock1 & lock2 == 0 and t1 & lock2 == t1:\n                if t2 & lock1 == t2:\n                    ok = 0\n                v = (lock1 | lock2, t2)\n                if v not in Q:\n                    P.append(v)\n                    Q.add(v)\n        i += 1\n    print \"SAFE\"*ok or \"UNSAFE\""
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    s = raw_input()\n    lock = 0\n    P = set()\n    for c in s:\n        if c is 'u':\n            lock = 0\n        else:\n            P.add((lock, 1 << int(c)))\n            lock |= 1 << int(c)\n    while 1:\n        Q = set()\n        for lock1, c1 in P:\n            for lock2, c2 in P:\n                if lock1 & lock2 == 0 and c1 & lock2 == c1:\n                    v = (lock1 | lock2, c2)\n                    if v not in P:\n                        Q.add(v)\n        if not Q:\n            break\n        P |= Q\n    ok = 1\n    for lock1, c1 in P:\n        for lock2, c2 in P:\n            if lock1 & lock2 == 0 and c1 & lock2 == c1 and c2 & lock1 == c2:\n                ok = 0\n    for lock, c in P:\n        if lock & c == c:\n            ok = 0\n    print \"SAFE\"*ok or \"UNSAFE\""
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn solve() {\n    loop {\n        let n: usize = get();\n        if n == 0 { break; }\n        let s: Vec<_> = get_word().chars().collect();\n        let mut set = vec![0; n + 1];\n        let mut self_broken = false;\n        for (i, ch) in s.into_iter().enumerate() {\n            set[i + 1] = match ch {\n                'u' => 0,\n                x => {\n                    let u = x as u8 - b'0';\n                    if (set[i] & 1 << u) != 0 {\n                        self_broken = true;\n                        0\n                    } else {\n                        set[i] | 1 << u\n                    }\n                },\n            }\n        }\n        if self_broken {\n            println!(\"UNSAFE\");\n            continue;\n        }\n        let mut nxt_cand = [0; 1 << 10];\n        for i in 1 .. n {\n            if set[i] != 0 {\n                nxt_cand[set[i - 1]] |= set[i] ^ set[i - 1];\n            }\n        }\n        let mut ok = true;\n        // TODO O(2^30) -> O(2^20)\n        for bits in 1 .. 1 << 10 {\n            let mut dp = vec![0; bits + 1];\n            dp[0] = 1;\n            let mut sub1iter = (bits - 1) & bits;\n            loop {\n                let sub1 = bits - sub1iter;\n                let mut sub2 = sub1;\n                loop {\n                    if sub2 == 0 { break; }\n                    if (nxt_cand[sub2] & bits) != 0 {\n                        dp[sub1] |= dp[sub1 ^ sub2];\n                    }\n                    sub2 = (sub2 - 1) & sub1;\n                }\n                if sub1iter == 0 { break; }\n                sub1iter = (sub1iter - 1) & bits;\n            }\n            if dp[bits] > 0 {\n                ok = false;\n                break;\n            }\n        }\n        println!(\"{}\", if ok { \"SAFE\" } else { \"UNSAFE\" });\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  }
]