[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LEN 1000\n\nint main() {\n    char sequence[MAX_LEN + 1];\n    scanf(\"%s\", sequence);\n    int len = strlen(sequence);\n    \n    int held[10] = {0};\n    int order[10];\n    int order_size = 0;\n    \n    for (int i = 0; i < len; ++i) {\n        char c = sequence[i];\n        if (c == 'u') {\n            if (order_size > 0) {\n                held[order[order_size - 1]] = 0;\n                order_size--;\n            }\n        } else if (c >= '0' && c <= '9') {\n            int lock = c - '0';\n            if (held[lock]) {\n                printf(\"UNSAFE\\n\");\n                return 0;\n            }\n            held[lock] = 1;\n            order[order_size++] = lock;\n        }\n    }\n    \n    printf(\"SAFE\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nbool hasCycle(const vector<vector<int>>& graph, vector<bool>& visited, vector<bool>& recStack, int node) {\n    if (!visited[node]) {\n        visited[node] = true;\n        recStack[node] = true;\n        \n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor] && hasCycle(graph, visited, recStack, neighbor)) {\n                return true;\n            } else if (recStack[neighbor]) {\n                return true;\n            }\n        }\n    }\n    recStack[node] = false;\n    return false;\n}\n\nbool isDeadlockPossible(const vector<vector<int>>& graph) {\n    int n = graph.size();\n    vector<bool> visited(n, false);\n    vector<bool> recStack(n, false);\n    \n    for (int i = 0; i < n; ++i) {\n        if (hasCycle(graph, visited, recStack, i)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    string sequence;\n    cin >> sequence;\n    \n    vector<vector<int>> graph(10);\n    vector<int> currentLocks;\n    unordered_set<int> heldLocks;\n    \n    for (char c : sequence) {\n        if (c == 'u') {\n            if (!currentLocks.empty()) {\n                int lock = currentLocks.back();\n                currentLocks.pop_back();\n                heldLocks.erase(lock);\n            }\n        } else {\n            int lock = c - '0';\n            for (int heldLock : heldLocks) {\n                graph[heldLock].push_back(lock);\n            }\n            if (heldLocks.find(lock) != heldLocks.end()) {\n                cout << \"UNSAFE\" << endl;\n                return 0;\n            }\n            currentLocks.push_back(lock);\n            heldLocks.insert(lock);\n        }\n    }\n    \n    if (isDeadlockPossible(graph)) {\n        cout << \"UNSAFE\" << endl;\n    } else {\n        cout << \"SAFE\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DeadlockDetection {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String instructions = scanner.nextLine();\n        System.out.println(isDeadlockPossible(instructions) ? \"UNSAFE\" : \"SAFE\");\n    }\n\n    private static boolean isDeadlockPossible(String instructions) {\n        Set<Character> heldLocks = new HashSet<>();\n        Set<Character> waitingLocks = new HashSet<>();\n\n        for (char c : instructions.toCharArray()) {\n            if (c == 'u') {\n                if (heldLocks.isEmpty()) {\n                    return true;\n                }\n                char lastLock = getLastLock(heldLocks);\n                heldLocks.remove(lastLock);\n                if (waitingLocks.contains(lastLock)) {\n                    waitingLocks.remove(lastLock);\n                }\n            } else {\n                if (heldLocks.contains(c)) {\n                    return true;\n                }\n                if (!heldLocks.isEmpty()) {\n                    waitingLocks.add(c);\n                }\n                heldLocks.add(c);\n            }\n        }\n        return false;\n    }\n\n    private static char getLastLock(Set<Character> locks) {\n        return locks.stream().max(Comparator.naturalOrder()).orElseThrow();\n    }\n}",
    "timestamp": "2025-08-05 21:02:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DeadlockDetector {\n    public static String detectDeadlock(String instructions) {\n        int[] lockHolders = new int[10];\n        Arrays.fill(lockHolders, -1);\n        Set<Integer> waitingThreads = new HashSet<>();\n\n        for (int threadId = 0; threadId < instructions.length(); threadId++) {\n            char instruction = instructions.charAt(threadId);\n\n            if (instruction == 'u') {\n                // Release all locks held by current thread\n                for (int i = 0; i < 10; i++) {\n                    if (lockHolders[i] == threadId) {\n                        lockHolders[i] = -1;\n                    }\n                }\n            } else {\n                int lockId = instruction - '0';\n\n                // Check if lock is already held\n                if (lockHolders[lockId] != -1) {\n                    // Thread is waiting for lock\n                    waitingThreads.add(threadId);\n\n                    // Check for circular dependency\n                    if (hasCircularDependency(instructions, threadId, lockId, lockHolders)) {\n                        return \"UNSAFE\";\n                    }\n                } else {\n                    // Acquire lock\n                    lockHolders[lockId] = threadId;\n                    waitingThreads.remove(threadId);\n                }\n            }\n        }\n\n        return \"SAFE\";\n    }\n\n    private static boolean hasCircularDependency(String instructions, int waitingThread, int lockId, int[] lockHolders) {\n        int holdingThread = lockHolders[lockId];\n        \n        for (int i = 0; i < instructions.length(); i++) {\n            if (instructions.charAt(i) == 'u' && lockHolders[lockId] == i) {\n                // Holding thread will release the lock\n                return false;\n            }\n\n            if (instructions.charAt(i) - '0' == lockId && i == waitingThread) {\n                // Waiting thread will eventually acquire the lock\n                return false;\n            }\n\n            if (i == holdingThread) {\n                // Check if holding thread is also waiting for a lock\n                for (int j = 0; j < 10; j++) {\n                    if (lockHolders[j] == waitingThread) {\n                        // Potential circular dependency\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String instructions = scanner.nextLine();\n        System.out.println(detectDeadlock(instructions));\n    }\n}",
    "timestamp": "2025-08-05 21:03:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_INSTRUCTIONS 1000\n\nbool is_deadlock_possible(char* instructions) {\n    bool locks[10] = {false};\n    int lock_count = 0;\n    \n    for (int i = 0; instructions[i] != '\\0'; i++) {\n        if (instructions[i] == 'u') {\n            if (lock_count == 0) return false;\n            lock_count--;\n        } else {\n            int lock_num = instructions[i] - '0';\n            if (locks[lock_num]) return true;\n            \n            locks[lock_num] = true;\n            lock_count++;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    char instructions[MAX_INSTRUCTIONS];\n    \n    while (scanf(\"%s\", instructions) != EOF) {\n        printf(\"%s\\n\", is_deadlock_possible(instructions) ? \"UNSAFE\" : \"SAFE\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:03:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n\nusing namespace std;\n\nbool detectDeadlock(const string& sequence) {\n    vector<bool> locksHeld(10, false);\n    unordered_map<int, int> lockOwners;\n    unordered_map<int, vector<int>> waitGraph;\n    \n    for (int i = 0; i < sequence.length(); i++) {\n        char instruction = sequence[i];\n        \n        if (instruction == 'u') {\n            // Find the most recently acquired lock to release\n            for (int j = 9; j >= 0; j--) {\n                if (locksHeld[j]) {\n                    locksHeld[j] = false;\n                    lockOwners.erase(j);\n                    break;\n                }\n            }\n        } else {\n            int lock = instruction - '0';\n            \n            // Check if lock is already held\n            if (locksHeld[lock]) {\n                // Build wait graph\n                int currentHolder = lockOwners[lock];\n                waitGraph[i].push_back(currentHolder);\n            } else {\n                // Acquire lock\n                locksHeld[lock] = true;\n                lockOwners[lock] = i;\n            }\n        }\n    }\n    \n    // Detect cycles in wait graph using BFS\n    vector<bool> visited(sequence.length(), false);\n    for (int start = 0; start < sequence.length(); start++) {\n        if (!waitGraph.count(start)) continue;\n        \n        queue<int> q;\n        q.push(start);\n        visited[start] = true;\n        \n        unordered_set<int> currentPath;\n        currentPath.insert(start);\n        \n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n            \n            for (int next : waitGraph[current]) {\n                if (currentPath.count(next)) {\n                    return true;  // Cycle detected, deadlock possible\n                }\n                \n                if (!visited[next]) {\n                    q.push(next);\n                    visited[next] = true;\n                    currentPath.insert(next);\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    string sequence;\n    cin >> sequence;\n    \n    cout << (detectDeadlock(sequence) ? \"UNSAFE\" : \"SAFE\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:03:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def detect_deadlock(instructions):\n    lock_held_by_thread = [None] * 10\n    locks_acquired = set()\n\n    for instruction in instructions:\n        if instruction == 'u':\n            # Release all locks\n            locks_acquired.clear()\n        else:\n            lock_num = int(instruction)\n            if lock_held_by_thread[lock_num] is None:\n                locks_acquired.add(lock_num)\n                lock_held_by_thread[lock_num] = True\n            else:\n                return \"UNSAFE\"\n    \n    return \"SAFE\"\n\n# Example Usage\ninstruction_sequence = \"123u456\"\nprint(detect_deadlock(instruction_sequence))",
    "timestamp": "2025-08-13 04:39:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class DeadlockDetection {\n    \n    public static String detectDeadlock(String instructions) {\n        int[] lockOwners = new int[10]; // To keep track of which lock is held by which thread (-1 means no owner)\n        for (int i = 0; i < 10; i++) {\n            lockOwners[i] = -1;\n        }\n\n        Set<Integer> acquiredLocks = new HashSet<>(); // To store currently acquired locks by a thread\n        int threadId = 0; // Thread identifier, incremented for each parallel processing\n        \n        for (int i = 0; i < instructions.length(); i++) {\n            char instruction = instructions.charAt(i);\n            \n            if (instruction >= '0' && instruction <= '9') {\n                int lockId = instruction - '0';\n                if (lockOwners[lockId] == -1) {\n                    lockOwners[lockId] = threadId;\n                    acquiredLocks.add(lockId);\n                } else {\n                    // Deadlock scenario: If the lock is already held by another thread\n                    return \"UNSAFE\";\n                }\n            } else if (instruction == 'u') {\n                // Release all locks held by the current thread\n                for (int lockId : acquiredLocks) {\n                    lockOwners[lockId] = -1;\n                }\n                acquiredLocks.clear();\n                threadId++; // Move to the next thread/action sequence\n            }\n        }\n        \n        // If no deadlock is detected through the instructions\n        return \"SAFE\";\n    }\n    \n    public static void main(String[] args) {\n        String instructionSequence = \"0123456789u9876543210\";\n        System.out.println(detectDeadlock(instructionSequence)); // Expect \"SAFE\" or \"UNSAFE\"\n    }\n}",
    "timestamp": "2025-08-13 04:39:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define NUM_LOCKS 10\n\nbool can_deadlock(const char *sequence) {\n    bool locks[NUM_LOCKS] = {false};\n    int held_count = 0;\n\n    for (int i = 0; sequence[i] != '\\0'; ++i) {\n        char instruction = sequence[i];\n        if (instruction >= '0' && instruction <= '9') {\n            int lock_id = instruction - '0';\n            if (!locks[lock_id]) {\n                locks[lock_id] = true;\n                held_count++;\n                if (held_count > 1) {\n                    return true;\n                }\n            }\n        } else if (instruction == 'u') {\n            if (held_count > 0) {\n                for (int j = 0; j < NUM_LOCKS; ++j) {\n                    if (locks[j]) {\n                        locks[j] = false;\n                        held_count--;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    const char *sequence = \"012u34u\";\n    if (can_deadlock(sequence)) {\n        printf(\"UNSAFE\\n\");\n    } else {\n        printf(\"SAFE\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 04:39:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_deadlock_possible(instructions):\n    locks_held = set()\n    lock_request_order = {}\n\n    for i, inst in enumerate(instructions):\n        if inst == 'u':\n            if not locks_held:\n                continue\n            locks_held.pop()\n        else:\n            lock = int(inst)\n            if lock in locks_held:\n                continue\n            \n            for held_lock in locks_held:\n                if held_lock in lock_request_order and lock in lock_request_order[held_lock]:\n                    return \"UNSAFE\"\n                \n                if lock not in lock_request_order:\n                    lock_request_order[lock] = set()\n                lock_request_order[lock].add(held_lock)\n            \n            locks_held.add(lock)\n\n    return \"SAFE\"\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    instructions = input().strip()\n    print(is_deadlock_possible(instructions))",
    "timestamp": "2025-08-13 04:39:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def check_deadlock(sequence):\n    locks_held = set()\n    lock_order = {}\n    stack = []\n    \n    for i, char in enumerate(sequence):\n        if char == 'u':\n            if stack:\n                released_lock = stack.pop()\n                locks_held.remove(released_lock)\n        else:\n            lock = int(char)\n            if lock in locks_held:\n                continue  # already held by this thread\n            if lock in locks_held:\n                return \"UNSAFE\"  # trying to acquire a lock already held (shouldn't happen here)\n            for held_lock in locks_held:\n                if (held_lock, lock) in lock_order:\n                    if lock_order[(held_lock, lock)] == 'after':\n                        return \"UNSAFE\"\n                else:\n                    lock_order[(held_lock, lock)] = 'before'\n            for held_lock in locks_held:\n                if (lock, held_lock) not in lock_order:\n                    lock_order[(lock, held_lock)] = 'after'\n            locks_held.add(lock)\n            stack.append(lock)\n    return \"SAFE\"\n\nsequence = input().strip()\nprint(check_deadlock(sequence))",
    "timestamp": "2025-08-13 04:39:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nbool detectDeadlock(const vector<string>& instructionSequences) {\n    unordered_map<char, vector<int>> lockWait;\n    unordered_map<int, unordered_set<char>> threadLocks;\n    unordered_set<int> blockedThreads;\n\n    for (int i = 0; i < instructionSequences.size(); ++i) {\n        for (char inst : instructionSequences[i]) {\n            if (isdigit(inst)) {\n                char lock = inst;\n                if (lockWait[lock].empty()) {\n                    threadLocks[i].insert(lock);\n                } else {\n                    blockedThreads.insert(i);\n                }\n                lockWait[lock].push_back(i);\n            } else if (inst == 'u') {\n                for (auto it = threadLocks[i].begin(); it != threadLocks[i].end();) {\n                    char lock = *it;\n                    if (!lockWait[lock].empty() && lockWait[lock].front() == i) {\n                        lockWait[lock].erase(lockWait[lock].begin());\n                        if (!lockWait[lock].empty()) {\n                            blockedThreads.erase(lockWait[lock].front());\n                        }\n                        it = threadLocks[i].erase(it);\n                    } else {\n                        ++it;\n                    }\n                }\n            }\n        }\n\n        if (!blockedThreads.empty()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    // 'instructionSequences' can be initialized by reading user input or any other means\n    vector<string> instructionSequences = {\"u1u1\", \"u1\", \"1u\"};\n\n    if (detectDeadlock(instructionSequences)) {\n        cout << \"UNSAFE\" << endl;\n    } else {\n        cout << \"SAFE\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:20:47"
  }
]