[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define MAX_DEGREE 10\n\ntypedef struct {\n    int coeff[MAX_DEGREE + 1];\n    int degree;\n} Polynomial;\n\nPolynomial polys[MAX_N][MAX_N];\nint N;\n\nPolynomial add(Polynomial a, Polynomial b) {\n    Polynomial res;\n    int max_degree = (a.degree > b.degree) ? a.degree : b.degree;\n    res.degree = max_degree;\n    for (int i = 0; i <= max_degree; i++) {\n        res.coeff[i] = a.coeff[i] + b.coeff[i];\n    }\n    return res;\n}\n\nPolynomial multiply(Polynomial a, Polynomial b) {\n    Polynomial res;\n    res.degree = a.degree + b.degree;\n    for (int i = 0; i <= res.degree; i++) {\n        res.coeff[i] = 0;\n    }\n    for (int i = 0; i <= a.degree; i++) {\n        for (int j = 0; j <= b.degree; j++) {\n            res.coeff[i + j] += a.coeff[i] * b.coeff[j];\n        }\n    }\n    return res;\n}\n\nPolynomial max_poly(Polynomial a, Polynomial b, int year) {\n    long long val_a = 0, val_b = 0;\n    long long pow = 1;\n    for (int i = 0; i <= a.degree; i++) {\n        val_a += a.coeff[i] * pow;\n        pow *= year;\n    }\n    pow = 1;\n    for (int i = 0; i <= b.degree; i++) {\n        val_b += b.coeff[i] * pow;\n        pow *= year;\n    }\n    return (val_a > val_b) ? a : b;\n}\n\nPolynomial dijkstra(int start, int end, int year) {\n    Polynomial dist[MAX_N];\n    int visited[MAX_N] = {0};\n\n    for (int i = 0; i < N; i++) {\n        dist[i].degree = 0;\n        dist[i].coeff[0] = 0;\n    }\n    dist[start] = polys[start][start];\n\n    for (int count = 0; count < N - 1; count++) {\n        int u = -1;\n        for (int v = 0; v < N; v++) {\n            if (!visited[v] && (u == -1 || max_poly(dist[v], dist[u], year).coeff[0] == dist[v].coeff[0])) {\n                u = v;\n            }\n        }\n        if (u == -1) break;\n        visited[u] = 1;\n        for (int v = 0; v < N; v++) {\n            if (!visited[v] && polys[u][v].degree != -1) {\n                Polynomial new_dist = multiply(dist[u], polys[u][v]);\n                if (dist[v].degree == -1 || max_poly(new_dist, dist[v], year).coeff[0] == new_dist.coeff[0]) {\n                    dist[v] = new_dist;\n                }\n            }\n        }\n    }\n    return dist[end];\n}\n\nint main() {\n    int M, year;\n    scanf(\"%d %d %d\", &N, &M, &year);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            polys[i][j].degree = -1;\n        }\n    }\n\n    for (int i = 0; i < M; i++) {\n        int u, v, degree;\n        scanf(\"%d %d %d\", &u, &v, &degree);\n        u--; v--;\n        polys[u][v].degree = degree;\n        polys[v][u].degree = degree;\n        for (int j = 0; j <= degree; j++) {\n            scanf(\"%d\", &polys[u][v].coeff[j]);\n            polys[v][u].coeff[j] = polys[u][v].coeff[j];\n        }\n    }\n\n    Polynomial result = dijkstra(0, N - 1, year);\n    long long bandwidth = 0;\n    long long pow = 1;\n    for (int i = 0; i <= result.degree; i++) {\n        bandwidth += result.coeff[i] * pow;\n        pow *= year;\n    }\n\n    printf(\"%lld\\n\", bandwidth);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    vector<int> polynomial;\n};\n\nvector<vector<Edge>> graph;\n\nvector<int> addPolynomials(const vector<int>& a, const vector<int>& b) {\n    int size = max(a.size(), b.size());\n    vector<int> res(size, 0);\n    for (int i = 0; i < a.size(); ++i) res[i] += a[i];\n    for (int i = 0; i < b.size(); ++i) res[i] += b[i];\n    return res;\n}\n\nvector<int> multiplyPolynomials(const vector<int>& a, const vector<int>& b) {\n    vector<int> res(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j < b.size(); ++j) {\n            res[i + j] += a[i] * b[j];\n        }\n    }\n    return res;\n}\n\nvector<int> maxPolynomial(const vector<int>& a, const vector<int>& b) {\n    if (a.size() > b.size()) return a;\n    if (b.size() > a.size()) return b;\n    for (int i = a.size() - 1; i >= 0; --i) {\n        if (a[i] > b[i]) return a;\n        if (b[i] > a[i]) return b;\n    }\n    return a;\n}\n\nvector<int> dijkstra(int n, int start) {\n    vector<vector<int>> dist(n + 1, vector<int>(1, INT_MIN));\n    dist[start] = vector<int>(1, 0);\n    priority_queue<pair<vector<int>, int>> pq;\n    pq.push({dist[start], start});\n\n    while (!pq.empty()) {\n        auto current = pq.top().second;\n        auto currentDist = pq.top().first;\n        pq.pop();\n\n        if (currentDist != dist[current]) continue;\n\n        for (const auto& edge : graph[current]) {\n            auto newDist = multiplyPolynomials(currentDist, edge.polynomial);\n            if (dist[edge.to].size() == 1 && dist[edge.to][0] == INT_MIN) {\n                dist[edge.to] = newDist;\n                pq.push({dist[edge.to], edge.to});\n            } else {\n                auto maxDist = maxPolynomial(dist[edge.to], newDist);\n                if (maxDist != dist[edge.to]) {\n                    dist[edge.to] = maxDist;\n                    pq.push({dist[edge.to], edge.to});\n                }\n            }\n        }\n    }\n\n    return dist[n];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    graph.resize(n + 1);\n\n    for (int i = 0; i < m; ++i) {\n        int u, v, k;\n        cin >> u >> v >> k;\n        vector<int> poly(k + 1);\n        for (int j = 0; j <= k; ++j) {\n            cin >> poly[j];\n        }\n        graph[u].push_back({v, poly});\n        graph[v].push_back({u, poly});\n    }\n\n    auto result = dijkstra(n, 1);\n\n    for (int coeff : result) {\n        cout << coeff << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Edge {\n    int to;\n    String polynomial;\n\n    Edge(int to, String polynomial) {\n        this.to = to;\n        this.polynomial = polynomial;\n    }\n}\n\npublic class MaxBandwidth {\n    static List<List<Edge>> graph;\n    static int[] parent;\n    static double[] bandwidth;\n    static boolean[] inQueue;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] parts = br.readLine().split(\" \");\n        int N = Integer.parseInt(parts[0]);\n        int M = Integer.parseInt(parts[1]);\n        int T = Integer.parseInt(parts[2]);\n\n        graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            parts = br.readLine().split(\" \");\n            int u = Integer.parseInt(parts[0]);\n            int v = Integer.parseInt(parts[1]);\n            String poly = parts[2];\n            graph.get(u).add(new Edge(v, poly));\n            graph.get(v).add(new Edge(u, poly));\n        }\n\n        double maxBandwidth = 0.0;\n        for (int year = 0; year <= T; year++) {\n            double current = dijkstra(N, year);\n            if (current > maxBandwidth) {\n                maxBandwidth = current;\n            }\n        }\n\n        System.out.printf(\"%.6f\\n\", maxBandwidth);\n    }\n\n    static double dijkstra(int N, int year) {\n        parent = new int[N + 1];\n        bandwidth = new double[N + 1];\n        inQueue = new boolean[N + 1];\n        Arrays.fill(bandwidth, -1.0);\n        bandwidth[1] = Double.POSITIVE_INFINITY;\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> Double.compare(bandwidth[b], bandwidth[a]));\n        pq.add(1);\n\n        while (!pq.isEmpty()) {\n            int u = pq.poll();\n            inQueue[u] = false;\n\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                double currentBW = evaluatePolynomial(edge.polynomial, year);\n                double newBW = Math.min(bandwidth[u], currentBW);\n\n                if (newBW > bandwidth[v]) {\n                    bandwidth[v] = newBW;\n                    parent[v] = u;\n                    if (!inQueue[v]) {\n                        pq.add(v);\n                        inQueue[v] = true;\n                    }\n                }\n            }\n        }\n\n        return bandwidth[N];\n    }\n\n    static double evaluatePolynomial(String poly, int year) {\n        String[] terms = poly.split(\"\\\\+\");\n        double result = 0.0;\n        for (String term : terms) {\n            term = term.trim();\n            if (term.contains(\"x\")) {\n                String[] parts = term.split(\"x\\\\^\");\n                double coeff = parts[0].isEmpty() ? 1.0 : Double.parseDouble(parts[0]);\n                int power = Integer.parseInt(parts[1]);\n                result += coeff * Math.pow(year, power);\n            } else {\n                result += Double.parseDouble(term);\n            }\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-05 21:27:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int MAX_NODES = 1000;\n    private static final int INF = Integer.MAX_VALUE;\n\n    public static int calculateMaxBandwidth(int n, int[][] edges, int[] yearCoefficients) {\n        // Create adjacency matrix to represent graph\n        int[][] graph = new int[n + 1][n + 1];\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], bandwidth = calculateBandwidth(edge[2], yearCoefficients);\n            graph[u][v] = bandwidth;\n            graph[v][u] = bandwidth;\n        }\n\n        // Ford-Fulkerson algorithm for max flow\n        return fordFulkerson(graph, 1, n);\n    }\n\n    private static int calculateBandwidth(int year, int[] coefficients) {\n        int bandwidth = 0;\n        for (int i = 0; i < coefficients.length; i++) {\n            bandwidth += coefficients[i] * Math.pow(year, i);\n        }\n        return bandwidth;\n    }\n\n    private static int fordFulkerson(int[][] graph, int source, int sink) {\n        int[][] residualGraph = new int[graph.length][graph.length];\n        for (int i = 0; i < graph.length; i++) {\n            residualGraph[i] = Arrays.copyOf(graph[i], graph[i].length);\n        }\n\n        int[] parent = new int[graph.length];\n        int maxFlow = 0;\n\n        while (bfs(residualGraph, source, sink, parent)) {\n            int pathFlow = INF;\n            for (int v = sink; v != source; v = parent[v]) {\n                int u = parent[v];\n                pathFlow = Math.min(pathFlow, residualGraph[u][v]);\n            }\n\n            for (int v = sink; v != source; v = parent[v]) {\n                int u = parent[v];\n                residualGraph[u][v] -= pathFlow;\n                residualGraph[v][u] += pathFlow;\n            }\n\n            maxFlow += pathFlow;\n        }\n\n        return maxFlow;\n    }\n\n    private static boolean bfs(int[][] graph, int source, int sink, int[] parent) {\n        boolean[] visited = new boolean[graph.length];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(source);\n        visited[source] = true;\n        parent[source] = -1;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n\n            for (int v = 0; v < graph.length; v++) {\n                if (!visited[v] && graph[u][v] > 0) {\n                    queue.offer(v);\n                    parent[v] = u;\n                    visited[v] = true;\n                }\n            }\n        }\n\n        return visited[sink];\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        int n = 4;\n        int[][] edges = {{1, 2, 2020}, {1, 3, 2021}, {2, 4, 2022}, {3, 4, 2023}};\n        int[] yearCoefficients = {10, 2, 1}; // a0 + a1*year + a2*year^2\n        \n        int maxBandwidth = calculateMaxBandwidth(n, edges, yearCoefficients);\n        System.out.println(\"Maximum Bandwidth: \" + maxBandwidth);\n    }\n}",
    "timestamp": "2025-08-05 21:27:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_STATIONS 1000\n#define MAX_YEAR 2050\n\ntypedef struct {\n    int stations;\n    int connections[MAX_STATIONS][MAX_STATIONS];\n    int bandwidth[MAX_STATIONS][MAX_STATIONS];\n} Network;\n\nint calculate_bandwidth_polynomial(int year) {\n    return year * year + 10 * year + 100;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint ford_fulkerson(Network* network, int source, int sink) {\n    int max_flow = 0;\n    int residual[MAX_STATIONS][MAX_STATIONS];\n    memcpy(residual, network->connections, sizeof(residual));\n\n    int parent[MAX_STATIONS];\n    int visited[MAX_STATIONS];\n\n    while (1) {\n        memset(parent, -1, sizeof(parent));\n        memset(visited, 0, sizeof(visited));\n\n        int queue[MAX_STATIONS];\n        int front = 0, rear = 0;\n        queue[rear++] = source;\n        visited[source] = 1;\n\n        while (front < rear) {\n            int current = queue[front++];\n            for (int next = 0; next < network->stations; next++) {\n                if (!visited[next] && residual[current][next] > 0) {\n                    queue[rear++] = next;\n                    parent[next] = current;\n                    visited[next] = 1;\n                }\n            }\n        }\n\n        if (!visited[sink]) break;\n\n        int path_flow = INT_MAX;\n        for (int v = sink; v != source; v = parent[v]) {\n            int u = parent[v];\n            path_flow = min(path_flow, residual[u][v]);\n        }\n\n        for (int v = sink; v != source; v = parent[v]) {\n            int u = parent[v];\n            residual[u][v] -= path_flow;\n            residual[v][u] += path_flow;\n        }\n\n        max_flow += path_flow;\n    }\n\n    return max_flow;\n}\n\nint maximal_bandwidth(Network* network, int current_year) {\n    for (int i = 0; i < network->stations; i++) {\n        for (int j = 0; j < network->stations; j++) {\n            if (network->connections[i][j]) {\n                network->bandwidth[i][j] = calculate_bandwidth_polynomial(current_year);\n            }\n        }\n    }\n\n    return ford_fulkerson(network, 0, network->stations - 1);\n}\n\nint main() {\n    Network network;\n    int year;\n\n    scanf(\"%d\", &network.stations);\n    scanf(\"%d\", &year);\n\n    for (int i = 0; i < network.stations; i++) {\n        for (int j = 0; j < network.stations; j++) {\n            scanf(\"%d\", &network.connections[i][j]);\n        }\n    }\n\n    int max_bandwidth = maximal_bandwidth(&network, year);\n    printf(\"%d\\n\", max_bandwidth);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nclass NetworkBandwidth {\nprivate:\n    int nodes;\n    vector<vector<pair<int, int>>> graph;\n\n    int dinicBFS(int source, int sink, vector<int>& level) {\n        fill(level.begin(), level.end(), -1);\n        level[source] = 0;\n        queue<int> q;\n        q.push(source);\n\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n\n            for (auto& edge : graph[u]) {\n                int v = edge.first;\n                int capacity = edge.second;\n\n                if (level[v] == -1 && capacity > 0) {\n                    level[v] = level[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n\n        return level[sink] != -1;\n    }\n\n    int dinicDFS(int u, int sink, int flow, vector<int>& level, vector<int>& ptr) {\n        if (u == sink)\n            return flow;\n\n        for (; ptr[u] < graph[u].size(); ptr[u]++) {\n            int v = graph[u][ptr[u]].first;\n            int& capacity = graph[u][ptr[u]].second;\n\n            if (level[v] == level[u] + 1 && capacity > 0) {\n                int curr_flow = dinicDFS(v, sink, min(flow, capacity), level, ptr);\n\n                if (curr_flow > 0) {\n                    capacity -= curr_flow;\n                    for (auto& edge : graph[v]) {\n                        if (edge.first == u) {\n                            edge.second += curr_flow;\n                            break;\n                        }\n                    }\n                    return curr_flow;\n                }\n            }\n        }\n\n        return 0;\n    }\n\npublic:\n    NetworkBandwidth(int n) : nodes(n), graph(n) {}\n\n    void addEdge(int u, int v, int bandwidth) {\n        graph[u].push_back({v, bandwidth});\n        graph[v].push_back({u, 0});\n    }\n\n    int calculateMaxBandwidth(int source, int sink) {\n        int max_flow = 0;\n        vector<int> level(nodes);\n        vector<int> ptr(nodes);\n\n        while (dinicBFS(source, sink, level)) {\n            fill(ptr.begin(), ptr.end(), 0);\n            while (int flow = dinicDFS(source, sink, numeric_limits<int>::max(), level, ptr)) {\n                max_flow += flow;\n            }\n        }\n\n        return max_flow;\n    }\n};\n\nint polynomialBandwidth(int year) {\n    return year * year + year + 41;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    NetworkBandwidth network(n);\n\n    for (int i = 0; i < n - 1; i++) {\n        int u, v, year;\n        cin >> u >> v >> year;\n        int bandwidth = polynomialBandwidth(year);\n        network.addEdge(u - 1, v - 1, bandwidth);\n    }\n\n    int maxBandwidth = network.calculateMaxBandwidth(0, n - 1);\n    cout << maxBandwidth << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:28:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adj_list = {i: [] for i in range(vertices)}\n\n    def add_edge(self, u, v, poly):\n        self.adj_list[u].append((v, poly))\n        self.adj_list[v].append((u, poly))\n\ndef maximal_bandwidth_bfs(graph, start, end, years):\n    from collections import deque\n    max_bandwidth = [0] * graph.vertices\n    visited = [False] * graph.vertices\n    queue = deque([(start, float('inf'))])\n\n    while queue:\n        node, bandwidth = queue.popleft()\n        visited[node] = True\n        if node == end:\n            continue\n\n        for neighbor, poly in graph.adj_list[node]:\n            if not visited[neighbor]:\n                current_bandwidth = min(bandwidth, evaluate_bandwidth(poly, years))\n                if max_bandwidth[neighbor] < current_bandwidth:\n                    max_bandwidth[neighbor] = current_bandwidth\n                    queue.append((neighbor, current_bandwidth))\n\n    return max_bandwidth[end]\n\ndef evaluate_bandwidth(polynomial, years):\n    bandwidth = 0\n    for i, coef in enumerate(polynomial):\n        bandwidth += coef * (years ** i)\n    return bandwidth\n\ndef main():\n    years = 2023  # Example, this can be parameterized\n    num_stations = int(input())\n    num_edges = int(input())\n\n    graph = Graph(num_stations)\n    for _ in range(num_edges):\n        u, v = map(int, input().split())\n        polynomial = list(map(int, input().split()))\n        graph.add_edge(u - 1, v - 1, polynomial)\n\n    start = 0\n    end = num_stations - 1\n\n    result = maximal_bandwidth_bfs(graph, start, end, years)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:27:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MaximalBandwidth {\n\n    static class Edge {\n        int to;\n        Polynomial bandwidth;\n\n        Edge(int to, Polynomial bandwidth) {\n            this.to = to;\n            this.bandwidth = bandwidth;\n        }\n    }\n\n    static class Polynomial implements Comparable<Polynomial> {\n        List<Integer> coefficients;\n\n        Polynomial(List<Integer> coefficients) {\n            this.coefficients = coefficients;\n        }\n\n        // Compare two polynomials based on their values for a specific year t\n        @Override\n        public int compareTo(Polynomial other) {\n            return Integer.compare(this.getValueForYear(1), other.getValueForYear(1));\n        }\n\n        // Calculate the polynomial value for a specific year t\n        int getValueForYear(int year) {\n            int value = 0;\n            for (int i = 0; i < coefficients.size(); i++) {\n                value += coefficients.get(i) * Math.pow(year, i);\n            }\n            return value;\n        }\n\n        @Override\n        public String toString() {\n            return coefficients.toString();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt(); // Number of base stations\n        int m = scanner.nextInt(); // Number of connections\n        List<Edge>[] graph = new ArrayList[n + 1];\n\n        // Initialize the adjacency list\n        for (int i = 1; i <= n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        // Read input and construct the graph with polynomial bandwidths\n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int k = scanner.nextInt();\n            List<Integer> coefficients = new ArrayList<>();\n            for (int j = 0; j <= k; j++) {\n                coefficients.add(scanner.nextInt());\n            }\n            Polynomial bandwidth = new Polynomial(coefficients);\n            graph[u].add(new Edge(v, bandwidth));\n            graph[v].add(new Edge(u, bandwidth));\n        }\n\n        // Run Dijkstra's algorithm to find maximal bandwidth path\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> b.bandwidth.compareTo(a.bandwidth));\n        Polynomial[] maxBandwidth = new Polynomial[n + 1];\n        Arrays.fill(maxBandwidth, new Polynomial(Collections.singletonList(0)));\n        maxBandwidth[1] = new Polynomial(Collections.singletonList(Integer.MAX_VALUE));\n\n        pq.add(new Edge(1, maxBandwidth[1]));\n\n        while (!pq.isEmpty()) {\n            Edge current = pq.poll();\n            int u = current.to;\n\n            for (Edge edge : graph[u]) {\n                Polynomial newBandwidth = edge.bandwidth;\n                if (newBandwidth.compareTo(maxBandwidth[edge.to]) > 0) {\n                    maxBandwidth[edge.to] = newBandwidth;\n                    pq.add(new Edge(edge.to, newBandwidth));\n                }\n            }\n        }\n\n        System.out.println(maxBandwidth[n]);\n    }\n}",
    "timestamp": "2025-08-13 06:27:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n#define INF 1000000000\n\ntypedef struct {\n    int u, v, degree;\n    int coeffs[MAX];\n} Edge;\n\ntypedef struct {\n    int n, m;\n    Edge edges[MAX];\n} Network;\n\nint evaluatePolynomial(int degree, int coeffs[], int year) {\n    int result = 0;\n    int powerOfYear = 1;\n    for (int i = 0; i <= degree; i++) {\n        result += coeffs[i] * powerOfYear;\n        powerOfYear *= year;\n    }\n    return result;\n}\n\nint findMaxBandwidth(Network* network, int year) {\n    int maxBandwidth = 0;\n    int bandwidth[MAX];\n    int visited[MAX] = {0};\n\n    for (int i = 0; i < MAX; i++) {\n        bandwidth[i] = -INF;\n    }\n    \n    bandwidth[0] = INF;\n\n    for (int i = 0; i < network->n - 1; i++) {\n        int max_bw = -1;\n        int max_index = -1;\n\n        for (int j = 0; j < network->n; j++) {\n            if (!visited[j] && bandwidth[j] > max_bw) {\n                max_bw = bandwidth[j];\n                max_index = j;\n            }\n        }\n\n        if (max_index == -1) {\n            break;\n        }\n\n        visited[max_index] = 1;\n\n        for (int j = 0; j < network->m; j++) {\n            Edge edge = network->edges[j];\n            if (edge.u == max_index || edge.v == max_index) {\n                int neighbor = (edge.u == max_index) ? edge.v : edge.u;\n                int bw = evaluatePolynomial(edge.degree, edge.coeffs, year);\n\n                if (!visited[neighbor] && bandwidth[neighbor] < bw) {\n                    bandwidth[neighbor] = bw;\n                }\n            }\n        }\n    }\n\n    maxBandwidth = bandwidth[network->n - 1];\n    return maxBandwidth;\n}\n\nint main() {\n    Network network;\n    int year;\n\n    // Input number of base stations and connections\n    scanf(\"%d %d\", &network.n, &network.m);\n\n    // Input the connections and their bandwidth polynomials\n    for (int i = 0; i < network.m; i++) {\n        scanf(\"%d %d %d\", &network.edges[i].u, &network.edges[i].v, &network.edges[i].degree);\n        for (int j = 0; j <= network.edges[i].degree; j++) {\n            scanf(\"%d\", &network.edges[i].coeffs[j]);\n        }\n    }\n\n    // Input the year for evaluation\n    scanf(\"%d\", &year);\n\n    // Calculate and print the maximal bandwidth for the given year\n    int result = findMaxBandwidth(&network, year);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:27:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_max_bandwidth(N, graph, bandwidths):\n    # Create adjacency matrix and initialize max bandwidth\n    adj_matrix = [[float('inf')] * N for _ in range(N)]\n    max_bandwidth = [0] * N\n    \n    # Populate adjacency matrix with given graph connections\n    for u, v, w in graph:\n        adj_matrix[u-1][v-1] = w\n        adj_matrix[v-1][u-1] = w\n    \n    # Set initial bandwidth for base stations\n    for i in range(N):\n        max_bandwidth[i] = bandwidths[i]\n    \n    # Floyd-Warshall algorithm to find max bandwidth paths\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                # Update max bandwidth considering intermediate station k\n                if adj_matrix[i][k] != float('inf') and adj_matrix[k][j] != float('inf'):\n                    path_bandwidth = min(adj_matrix[i][k], adj_matrix[k][j])\n                    adj_matrix[i][j] = max(adj_matrix[i][j], path_bandwidth)\n    \n    # Return maximum bandwidth to N-th base station\n    return max_bandwidth[N-1]\n\n# Example usage\nN = 5\ngraph = [(1,2,3), (1,3,5), (2,3,2), (2,4,1), (3,4,4), (3,5,6), (4,5,2)]\nbandwidths = [2, 3, 4, 5, 6]\nresult = calculate_max_bandwidth(N, graph, bandwidths)\nprint(result)",
    "timestamp": "2025-08-13 06:27:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    \n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        adj[u].append((v, a, b))\n        adj[v].append((u, a, b))\n    \n    low = 0.0\n    high = 1e18\n    best = 0.0\n    \n    for _ in range(100):\n        mid = (low + high) / 2\n        # Check if there's a path where all edges have a >= mid\n        visited = [False] * (N + 1)\n        q = deque()\n        q.append(1)\n        visited[1] = True\n        found = False\n        while q and not found:\n            u = q.popleft()\n            for (v, a, b) in adj[u]:\n                if not visited[v] and (a - mid * b) >= 0:\n                    if v == N:\n                        found = True\n                        break\n                    visited[v] = True\n                    q.append(v)\n            if found:\n                break\n        if found:\n            best = mid\n            low = mid\n        else:\n            high = mid\n    print(\"{0:.10f}\".format(best))\n\nsolve()",
    "timestamp": "2025-08-13 06:27:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <map>\n#include <functional>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    vector<int> coeff;\n};\n\nint evaluatePolynomial(const vector<int>& coeff, int year) {\n    int bandwidth = 0;\n    for (int i = 0; i < coeff.size(); ++i) {\n        bandwidth = bandwidth * year + coeff[i];\n    }\n    return bandwidth;\n}\n\nint findMaxBandwidth(const map<int, vector<Edge>>& graph, int start, int end, int year) {\n    map<int, int> maxBandwidth;\n    maxBandwidth[start] = numeric_limits<int>::min();\n    function<void(int)> dfs = [&](int node) {\n        for (const auto& edge : graph.at(node)) {\n            int bandwidth = evaluatePolynomial(edge.coeff, year);\n            if (maxBandwidth[node] > maxBandwidth[edge.to]) {\n                maxBandwidth[edge.to] = maxBandwidth[node];\n                dfs(edge.to);\n            }\n        }\n    };\n    dfs(start);\n    return maxBandwidth[end];\n}\n\nint main() {\n    int N, M, year;\n    cin >> N >> M >> year;\n    map<int, vector<Edge>> graph;\n    for (int i = 0; i < M; ++i) {\n        int u, v, degree;\n        cin >> u >> v >> degree;\n        vector<int> coeff(degree);\n        for (int j = 0; j < degree; ++j) {\n            cin >> coeff[j];\n        }\n        graph[u].push_back({v, coeff});\n    }\n    int result = findMaxBandwidth(graph, 1, N, year);\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:32:09"
  }
]