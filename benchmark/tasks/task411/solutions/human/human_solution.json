[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\nconstexpr int MAX_L = 51;\n\nusing weight = vector<int>;\n\nvector<int> operator-(vector<int> l, vector<int> const& r) {\n    for(int i = 0; i < (int)l.size(); ++i) {\n        l[i] -= r[i];\n    }\n    return l;\n}\nvector<int> operator+(vector<int> l, vector<int> const& r) {\n    for(int i = 0; i < (int)l.size(); ++i) {\n        l[i] += r[i];\n    }\n    return l;\n}\n\nstruct edge {\n    int to;\n    weight cap;\n    int rev;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, weight cap) {\n    g[from].push_back(edge{to, cap, static_cast<int>(g[to].size())});\n    g[to].push_back(edge{from, vector<int>(MAX_L), static_cast<int>(g[from].size()-1)});\n}\n\nvoid bfs(graph& g, std::vector<int>& level, int s) {\n    for(int i=0; i<level.size(); ++i) {\n        level[i] = -1;\n    }\n    level[s] = 0;\n    std::queue<int> que;\n    que.push(s);\n    while(!que.empty()) {\n        int v = que.front(); que.pop();\n        for(int i = 0; i < (int)g[v].size(); ++i) {\n            edge& e = g[v][i];\n            if(e.cap > vector<int>(MAX_L) && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nweight dfs(graph& g, std::vector<int>& level, std::vector<int>& iter, int v, int t, weight f) {\n    if(v == t) {\n        return f;\n    }\n    vector<int> const zero(MAX_L);\n    for(int& i = iter[v]; i < g[v].size(); ++i) {\n        edge& e = g[v][i];\n        if(e.cap > zero && level[v] < level[e.to]) {\n            weight d = dfs(g, level, iter, e.to, t, std::min(f, e.cap));\n            if(d > zero) {\n                e.cap = e.cap - d;\n                g[e.to][e.rev].cap = g[e.to][e.rev].cap + d;\n                return d;\n            }\n        }\n    }\n    return zero;\n}\n\nweight max_flow(graph& g, int s, int t) {\n    vector<int> zero(MAX_L);\n    vector<int> inf(MAX_L, INF);\n    weight flow = zero;\n    std::vector<int> level(g.size(), -1);\n    std::vector<int> iter(g.size(), 0);\n    while(true) {\n        bfs(g, level, s);\n        if(level[t] < 0) {\n            return flow;\n        }\n        for(int i = 0; i < iter.size(); ++i) {\n            iter[i] = 0;\n        }\n        weight f;\n        while((f = dfs(g, level, iter, s, t, inf)) > zero) {\n            flow = flow + f;\n        }\n    }\n}\n\nint number(string const& s, int& p) {\n    int res = 0;\n    while(isdigit(s[p])) {\n        res *= 10;\n        res += s[p++] - '0';\n    }\n    return res;\n}\n\npair<int, int> term(string const& s, int& p) {\n    int a = number(s, p);\n    if(a == 0) {\n        a = 1;\n    }\n    int l = 0;\n    if(p < s.size()) {\n        if(p + 1 < s.size() && s[p + 1] == '^') {\n            p += 2;\n            l = number(s, p);\n        } else {\n            l = 1;\n            p++;\n        }\n    }\n    return make_pair(a, l);\n}\n\nvector<int> parse(string const& s) {\n    int p = 0;\n    vector<int> res(MAX_L);\n    while(p < s.size()) {\n        auto t = term(s, p);\n        res[t.second] = t.first;\n        p++; // +\n    }\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        graph g(N);\n        int const source = 0, sink = N - 1;\n        for(int i = 0; i < M; ++i) {\n            int u, v;\n            string p;\n            cin >> u >> v >> p;\n            auto cap = parse(p);\n            add_edge(g, u - 1, v - 1, cap);\n            add_edge(g, v - 1, u - 1, cap);\n        }\n        auto flow = max_flow(g, source, sink);\n        string res;\n        for(int i = 0; i < MAX_L; ++i) {\n            if(flow[i] != 0) {\n                if(res.size() != 0) {\n                    res += '+';\n                }\n                if(i == MAX_L - 1 || flow[i] != 1) {\n                    res += to_string(flow[i]);\n                }\n                if(MAX_L - 1 - i >= 1) {\n                    res += 'x';\n                }\n                if(MAX_L - 1 - i > 1) {\n                    res += \"^\" + to_string(MAX_L - 1 - i);\n                }\n            }\n        }\n        if(res.empty()) {\n            res = \"0\";\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nvi& operator+=(vi &a, const vi &b){\n\twhile(a.size() < b.size()) a.pb(0);\n\trep(i, min(a.size(), b.size())) a[i] += b[i];\n\twhile(a.size() && a.back() == 0) a.pop_back();\n\treturn a;\n}\nvi& operator-=(vi &a, const vi &b){\n\twhile(a.size() < b.size()) a.pb(0);\n\trep(i, min(a.size(), b.size())) a[i] -= b[i];\n\twhile(a.size() && a.back() == 0) a.pop_back();\n\treturn a;\n}\nvi min(const vi &a, const vi &b){\n\tfor(int i = max(a.size(), b.size()) - 1; i >= 0; i--)\n\tif((i < a.size() ? a[i] : 0) != (i < b.size() ? b[i] : 0))\n\treturn (i < a.size() ? a[i] : 0) < (i < b.size() ? b[i] : 0) ? a : b;\n\treturn b;\n}\n\nstruct flowGraph{\n\tstruct edge{\n\t\tint to, rev; \n\t\tvi cap;\n\t\tedge(int to, const vi &c, int rev) : to(to), rev(rev){\n\t\t\tcap = c;\n\t\t}\n\t};\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tflowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~flowGraph(){\n\t\tdelete iter; delete level;\n\t}\n\t\n\tvoid add(int s, int t, const vi &cap){\n\t\tG[s].pb(edge(t, cap, G[t].size()));\n\t\tG[t].pb(edge(s, vi(0), G[s].size() - 1));\n\t}\n\t\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap.size() && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvi dfs(int v, int t, vi f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap.size() && level[v] < level[e.to]){\n\t\t\t\tvi d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d.size()){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vi(0);\n\t}\n\tvi max_flow(int s, int t){\n\t\tvi flow;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tvi f;\n\t\t\twhile((f = dfs(s, t, vi(51, inf))).size()) flow += f;\n\t\t}\n\t}\n};\nvi parse(string s){\n\teach(i, s) if(*i == '+') *i = ' ';\n\tstringstream ss(s);\n\tvi v;\n\twhile(ss >> s){\n\t\tint p, e = s.find(\"x\") != s.npos;\n\t\tif((p = s.find(\"^\")) != s.npos){\n\t\t\te = atoi(s.substr(p + 1).c_str());\n\t\t}\n\t\twhile(v.size() <= e) v.pb(0);\n\t\t\n\t\tif((p = s.find(\"x\")) != s.npos) s = s.substr(0, p);\n\t\tif(s == \"\") s += \"1\";\n\t\tv[e] = atoi(s.c_str());\n\t}\n\treturn v;\n}\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tflowGraph g(n);\n\t\trep(i, m){\n\t\t\tint a, b;\n\t\t\tstring c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tvi v = parse(c);\n\t\t\tg.add(a, b, v);\n\t\t\tg.add(b, a, v);\n\t\t}\n\t\tvi ans = g.max_flow(0, n - 1);\n\t\tif(ans.empty()){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = ans.size() - 1; i >= 0; i--){\n\t\t\tif(ans[i] == 0) continue;\n\t\t\tif(i < ans.size() - 1) cout << \"+\";\n\t\t\tif(ans[i] != 1 || i == 0) cout << ans[i];\n\t\t\tif(i > 0) cout << \"x\";\n\t\t\tif(i > 1) cout << \"^\" << i;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\nconst int L=50;\n\nvi parse(string s)\n{\n\treplace(all(s),'+',' ');\n\tistringstream iss(s);\n\tvi res(L+1);\n\tfor(string t;iss>>t;){\n\t\tint c=isdigit(t[0])?0:1,i=0;\n\t\tfor(;i<t.size() && isdigit(t[i]);i++)\n\t\t\tc=c*10+t[i]-'0';\n\t\tif(i==t.size()){ // c*x^0\n\t\t\tres[0]+=c;\n\t\t\tcontinue;\n\t\t}\n\t\tassert(t[i]=='x');\n\t\ti++;\n\t\tif(i==t.size()){ // c*x^1\n\t\t\tres[1]+=c;\n\t\t\tcontinue;\n\t\t}\n\t\tassert(t[i]=='^');\n\t\ti++;\n\t\tint r=0;\n\t\tfor(;i<t.size() && isdigit(t[i]);i++)\n\t\t\tr=r*10+t[i]-'0';\n\t\tres[r]+=c;\n\t}\n\treturn res;\n}\n\nstruct Edge{\n\tint src,dst,cap,flow;\n\tEdge(){}\n\tEdge(int s,int d,int c,int f=0):src(s),dst(d),cap(c),flow(f){}\n};\nstruct Graph{\n\tvector<Edge> es;\n\tvi head,next;\n\tGraph(){}\n\tGraph(int n):head(n,-1){}\n\t// 有向辺を追加するとき逆辺の容量c2は普通0である．\n\t// 両方向に容量があるならc2も指定する．\n\tvoid AddEdge(int u,int v,int c1,int c2=0){\n\t\tes.emplace_back(u,v,c1); next.push_back(head[u]); head[u]=es.size()-1;\n\t\tes.emplace_back(v,u,c2); next.push_back(head[v]); head[v]=es.size()-1;\n\t}\n};\n\nvoid BFS(const Graph& g,int tap,vi& layer)\n{\n\tqueue<pii> q; q.emplace(tap,0);\n\twhile(q.size()){\n\t\tint u,d; tie(u,d)=q.front(); q.pop();\n\t\tif(layer[u]!=INF) continue;\n\t\tlayer[u]=d;\n\t\tfor(int i=g.head[u];i!=-1;i=g.next[i])\n\t\t\tif(g.es[i].cap-g.es[i].flow>0)\n\t\t\t\tq.emplace(g.es[i].dst,d+1);\n\t}\n}\n\nint DFS(Graph& g,int v,int sink,const vi& layer,int flow)\n{\n\tif(v==sink) return flow;\n\tint f=flow;\n\tfor(int& i=g.head[v];i!=-1;i=g.next[i]){\n\t\tEdge& e=g.es[i];\n\t\tif(layer[e.src]>=layer[e.dst]) continue;\n\t\tint residue=e.cap-e.flow;\n\t\tif(residue==0) continue;\n\t\tint augment=DFS(g,e.dst,sink,layer,min(residue,f));\n\t\te.flow+=augment;\n\t\tg.es[i^1].flow-=augment;\n\t\tf-=augment;\n\t\tif(f==0) break;\n\t}\n\treturn flow-f;\n}\n\nint Dinic(Graph& g,int tap,int sink)\n{\n\tint res=0;\n\tfor(int n=g.head.size();;){\n\t\tvi layer(n,INF);\n\t\tBFS(g,tap,layer);\n\t\tif(layer[sink]==INF) break;\n\t\tvi temp=g.head;\n\t\tres+=DFS(g,tap,sink,layer,INF);\n\t\tswap(g.head,temp);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvvvi c(n,vvi(n,vi(L+1)));\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tstring s; cin>>s;\n\t\t\tvi tmp=parse(s);\n\t\t\trep(j,L+1){\n\t\t\t\tc[u][v][j]+=tmp[j];\n\t\t\t\tc[v][u][j]+=tmp[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi res(L+1);\n\t\tper(k,L+1){\n\t\t\tGraph g(n);\n\t\t\trep(i,n) repi(j,i+1,n) if(c[i][j][k])\n\t\t\t\tg.AddEdge(i,j,c[i][j][k],c[i][j][k]);\n\t\t\tres[k]=Dinic(g,0,n-1);\n\t\t\tif(k==0) continue;\n\t\t\tfor(auto e:g.es)\n\t\t\t\tif(e.cap-e.flow>0)\n\t\t\t\t\tc[e.src][e.dst][k-1]=INF;\n\t\t}\n\t\t\n\t\tbool first=true;\n\t\tper(i,L+1) if(res[i] || (first && i==0)){\n\t\t\tif(!first) cout<<'+';\n\t\t\telse       first=false;\n\t\t\tif(res[i]>1 || i==0) cout<<res[i];\n\t\t\tif(i>0) cout<<'x';\n\t\t\tif(i>1) cout<<'^'<<i;\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Weight weight; Capacity cap;\n\tEdge(int s, int d, Weight w, Capacity c) : src(s), dst(d), weight(w), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct FordFulkerson {\n\ttypedef vector<vector<Capacity>> Matrix;\n\tint n, t;\n\tvector<bool> vis;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tFordFulkerson(int n)\n\t\t: n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t}\n\tFordFulkerson(const Graph &graph) {\n\t\t*this = FordFulkerson(graph.size());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n\t\t}\n\t}\n\tvoid addEdge(int u, int v, Capacity c) {\n\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tCapacity solve(int s, int t) {\n\t\tthis->t = t;\n\t\tCapacity res = 0, aug = 1;\n\t\twhile(aug > 0) {\n\t\t\tvis.assign(n, false);\n\t\t\tres += (aug = augment(s, inf));\n\t\t}\n\t\treturn res;\n\t}\n\tCapacity augment(const int &v, const Capacity &lim) {\n\t\tvis[v] = true;\n\t\tif(v == t) return lim;\n\t\tfor(const int &d : g[v]) {\n\t\t\tif(vis[d] || flow[v][d] == cap[v][d]) continue;\n\t\t\tCapacity aug = augment(d, min(lim, cap[v][d] - flow[v][d]));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tif(aug > 0) return aug;\n\t\t}\n\t\treturn 0;\n\t}\n};\n\ntypedef pair<int, int> Pii;\n\nvector<int> f(string s) {\n\treplace(s.begin(), s.end(), '+', ' ');\n\t//cout << s << endl;\n\tvector<int> ret(51);\n\n\tstringstream ss(s);\n\twhile(ss >> s) {\n\t\tstringstream ss2(s);\n\t\tif(s.find('x') == string::npos) {\n\t\t\tss2 >> ret[0];\n\t\t}\n\t\telse {\n\t\t\tchar c;\n\t\t\tint a = 1, L = 1;\n\t\t\tif(s[0] != 'x') ss2 >> a;\n\t\t\tif(s.find('^') != string::npos) {\n\t\t\t\tss2 >> c >> c >> L; // x^L\n\t\t\t}\n\t\t\tret[L] = a;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint u[500];\nint v[500];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M;\n\twhile(cin >> N >> M, N) {\n\t\tmap<Pii, vector<int> > poly;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tstring p;\n\t\t\tcin >> u[i] >> v[i] >> p;\n\t\t\tu[i]--, v[i]--;\n\t\t\tpoly[Pii(u[i], v[i])] = f(p);\n\t\t}\n\n\t\tvector<int> ans(51);\n\t\tfor(int i = 50; i >= 0; i--) {\n\t\t\tGraph G(N);\n\n\t\t\tfor(auto&& p : poly) {\n\t\t\t\tint a = p.first.first, b = p.first.second, c = p.second[i];\n\t\t\t\tG[a].emplace_back(a, b, 0, c);\n\t\t\t\tG[b].emplace_back(b, a, 0, c);\n\t\t\t}\n\n\t\t\tFordFulkerson ff(G);\n\t\t\tint f = ff.solve(0, N - 1);\n\t\t\tans[i] = f;\n\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tint a = u[j], b = v[j];\n\t\t\t\tif(ff.flow[a][b] != 0 && ff.flow[a][b] != ff.cap[a][b]) {\n\t\t\t\t\tfor(int l = 0; l <= i; l++) {\n\t\t\t\t\t\tpoly[Pii(a, b)][l] = 1e8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor(int i = 50; i >= 0; i--) {\n\t\t\tif(ans[i] == 0) continue;\n\t\t\tif(flag) cout << \"+\";\n\t\t\tflag = true;\n\t\t\tif(i == 0 || ans[i] != 1) cout << ans[i];\n\t\t\tif(i != 0) cout << \"x\";\n\t\t\tif(i >= 2) cout << \"^\" << i;\n\t\t}\n\t\tif(!flag) cout << 0;\n\t\tcout << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2328\n#include<iostream>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<sstream>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nconst int VMAX = 100;\nconst int INF = 1e7;\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[VMAX];\nbool used[VMAX];\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, cap, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n  used[v] = true;\n\n  for (int i = 0; i < G[v].size(); i++) {\n    edge &e = G[v][i];\n    if (!used[e.to] and e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n\n  while (true) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nconst int NMAX = 60, MMAX = 600, LMAX = 52;\n\nvector<int> coefficients[NMAX];\nint from[MMAX], to[MMAX];\n\nvoid init(int N) {\n  REP(i, N) {\n    coefficients[i].clear();\n  }\n}\n\nvoid init_flow(int v) {\n  REP(i, v) {\n    G[i].clear();\n  }\n}\n\nvector<string> split_by(char div, string str) {\n  vector<string> xs;\n  string x;\n  for (char c : str) {\n    if (c == div) {\n      xs.push_back(x);\n      x = \"\";\n    } else {\n      x.push_back(c);\n    }\n  }\n  xs.push_back(x);\n  return xs;\n}\n\npair<int,int> factor2pair(string factor) {\n  int a, n;\n  pair<int,int> p;\n  cout << \"(\" << factor << \":\";\n  auto index = factor.find('x', 0);\n  if (index == string::npos) {\n    istringstream is(factor);\n    is >> a;\n    p = pair<int,int>(a,0);\n  } else if (factor.find('^', 0) == string::npos) {\n    factor = factor.substr(0, factor.length() - 1);\n    cout << \"<<\" << factor << \">>\";\n    istringstream is((factor.empty() ? \"1\" : factor));\n    is >> a;\n    p = pair<int,int>(a, 1);\n  } else {\n    string astr = factor.substr(0, index - 1),\n           nstr = factor.substr(index + 2);\n    cout << \"<\" << astr << \" \" << nstr << \">\";\n    istringstream is(astr);\n    is >> a;\n    is.clear();\n    is.str(nstr);\n    is >> n;\n    p = pair<int,int>(a,n);\n  }\n    cout << p.first << \",\" << p.second << \")\" << endl;\n  return p;\n}\n\nvector<int> polynomial2vector(string poly) {\n  vector<string> factors = split_by('+', poly);\n  vector<int> ans(LMAX);\n  for (string factor : factors) {\n    pair<int,int> p = factor2pair(factor);\n    ans[p.first] = p.second;\n  }\n  return ans;\n}\n\nstring vector2polynomial(vector<int> poly) {\n  string ans = \"\";\n  for (int i = 0, len = poly.size(); i < len; i++) {\n    if (! poly[i]) continue;\n    ans = poly[i] + (i == 0 ? \"\":\"x\") \n      + (i <= 1 ? \"\":\"^\" + to_string(i))+ ans;\n  }\n  return (ans.empty() ? \"0\" : ans);\n}\n\nint get_coefficient(int m, int l) {\n  return coefficients[m][l];\n}\n\nint main() {\n  int N, M;\n  while (cin >> N >> M and N) {\n    init(N);\n    REP(i, M) {\n      int u, v;\n      string poly;\n      cin >> u >> v >> poly;\n\n      from[i] = u;\n      to[i] = v;\n      coefficients[i] = polynomial2vector(poly);\n    }\n\n    int lmax;\n    vector<int> ans;\n\n    REP(l, lmax) {\n      init_flow(N);\n      REP(m, M) {\n        add_edge(from[m], to[m], get_coefficient(m, l));\n        add_edge(to[m], from[m], get_coefficient(m, l));\n      }\n      ans.push_back(max_flow(1, N));\n    }\n\n    reverse(ans.begin(), ans.end());\n\n    cout << vector2polynomial(ans) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 100\nusing namespace std;\ntypedef vector<int> V;\nconst V zero(51,0);\nstruct edge{\n  int to,rev;\n  V cap;\n  edge();\n  edge(int to,V cap,int rev):to(to),cap(cap),rev(rev){};\n};\n\nbool compare (const V &a,const V &b){\n  for(int i=a.size()-1;i>=0;i--)if(a[i]!=b[i])return a[i]<b[i];\n  return 0;\n}\nV min(V a,V b){return compare(a,b)? a:b;}\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,V cap){\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,zero,G[from].size()-1));  \n}\n\nvoid add(V &a,V b){for(int i=0;i<(int)a.size();i++)a[i]+=b[i];}\nvoid sub(V &a,V b){for(int i=0;i<(int)a.size();i++)a[i]-=b[i];}\n\n//?¢?????????????DFS??§??¢???\nV dfs(int v,int t,V f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap != zero){\n      V d = dfs(e.to ,t , min(f,e.cap));\n      if(d != zero){\n\tsub(e.cap,d);\n\tadd(G[e.to][e.rev].cap,d);\n\treturn d;\n      }\n    }\n  }\n  return zero;\n}\n\n//s??????t???????????§???????±???????\nV max_flow(int s,int t){\n  V flow=zero;\n  for(;;){\n    memset(used,0,sizeof(used));\n    V f = dfs(s, t, V(51,1e4));\n    if(f == zero)return flow;\n    add(flow,f);\n  }\n}\n\n\nint StoI(string &a,int &i){\n  int res=0;\n  while(isdigit(a[i])) res=res*10+a[i++]-'0';\n  return res;\n}\n\nstring ItoS(int a){\n  string res;\n  while(a) res=char(a%10+'0')+res,a/=10;\n  if(res.empty()) res=\"0\";\n  return res;\n}\n\nV StoV(string s){\n  V res(51);\n  if(s==\"0\") return zero;\n  for(int i=0;i<s.size();i++){\n    int a = max(1,StoI(s,i));\n    int L = 0;\n    if(s[i]=='x')i+=1+(s[i+1]=='^'),L=max(1,StoI(s,i));\n    res[L] = a;\n  }\n  return res;\n}\n\nstring VtoS(V a){\n  string res;\n  for(int i=a.size()-1;i>=0;i--){\n    if(a[i]==0)continue;\n    if(!res.empty()) res+='+';\n    if(a[i]>1||i==0) res+=ItoS(a[i]);\n    if(i)res+='x';\n    if(i>1) res+='^'+ItoS(i);\n  }\n  if(res.empty()) res=\"0\";\n  return res;\n}\n\nint main(){\n  while(1){\n  int n,m;\n  cin>>n>>m;\n  if(!n&&!m) return 0;\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  for(int i=0,a,b;i<m;i++){\n    string c;\n    cin>>a>>b>>c;\n    V vc = StoV(c);\n    add_edge(a-1,b-1,vc);\n    add_edge(b-1,a-1,vc);\n  }\n\n  V ans = max_flow(0,n-1);\n  cout<<VtoS(ans)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\n\n\n#define _GLIBCXX_DEBUG\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\nconst long long int L_INF = 9223372036854775807;\n\ntypedef vector<int> Weight;\nconst Weight INF = vector<int>(100, 1);\nconst Weight ZERO = vector<int>(100, 0);\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator <(const Weight&l, const Weight&r) {\n\tfor (int i = 99; i >=0; --i) {\n\t\tif (l[i] != r[i])return l[i] < r[i];\n\t}\n\treturn false;\n}\nbool operator >(const Weight&l, const Weight&r) {\n\tfor (int i = 99; i >= 0; --i) {\n\t\tif (l[i] != r[i])return l[i] > r[i];\n\t}\n\treturn false;\n}\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nWeight operator+(const Weight&l, const Weight&r) {\n\tvector<int>ans(100);\n\tfor (int i = 0; i < 100; ++i) {\n\t\tans[i] = l[i] + r[i];\n\t}\n\treturn ans;\n}\nWeight operator-(const Weight&l, const Weight&r) {\n\tvector<int>ans(100);\n\tfor (int i = 0; i < 100; ++i) {\n\t\tans[i] = l[i] - r[i];\n\t}\n\treturn ans;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\n//??????0??????????????????????????¨??£???????±??????????????????§??¨???\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, ag[i][j].weight));\n\t\t\t}\n\t\t}\n\t}\n\tint n = g.size();\n\tMatrix flow(n, Array(n,ZERO)), capacity(n, Array(n, ZERO));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] =capacity[e->src][e->dst]+ e->weight;\n\n\n\tWeight total = ZERO;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > ZERO) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0)break; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j]) {\n\t\t\tauto v(RESIDUE(prev[j], j));\n\t\t\tif (inc > v) {\n\t\t\t\tinc =v;\n\t\t\t}\n\t\t}\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] =flow[prev[j]][j]+inc, flow[j][prev[j]] =flow[j][prev[j]]- inc;\n\t\ttotal =total+ inc;\n\t}\n\n\treturn total;\n}\nint a = 0;\nstring st;\nint getnum() {\n\tint num = 0;\n\twhile (a!=st.size()&&isdigit(st[a])) {\n\t\tnum = num * 10 + st[a] - '0';\n\t\ta++;\n\t}\n\treturn num;\n}\npair<int, int>getx() {\n\tint num = 1;\n\tif (isdigit(st[a])) {\n\t\tnum = getnum();\n\t}\n\tint base;\n\tif (a == st.size() || st[a] == '+') {\n\t\tbase = 0;\n\t}\n\telse {\n\t\tassert(st[a] == 'x');\n\t\ta++;\n\t\tif (a == st.size() || st[a] == '+') {\n\t\t\tbase = 1;\n\t\t}\n\t\telse {\n\t\t\tassert(st[a] == '^');\n\t\t\ta++;\n\t\t\tbase = getnum();\n\t\t}\n\t}\n\treturn make_pair(base, num);\n}\nvector<int>getvec() {\n\tvector<int>v(100);\n\tauto p = getx();\n\tv[p.first] = p.second;\n\twhile (a != st.size()) {\n\t\ta++;\n\t\tauto p = getx();\n\t\tv[p.first] = p.second;\n\t}\n\treturn v;\n}\nvoid makest(const vector<int>&vs) {\n\n\tbool fst = true;\n\tfor (int i = 99; i >= 0; --i) {\n\t\tif (vs[i]) {\n\t\t\tif (!fst)cout << \"+\";\n\t\t\tif (i) {\n\t\t\t\tif (vs[i] >= 2) {\n\t\t\t\t\tcout << vs[i];\n\t\t\t\t}\n\t\t\t\tif (i >= 1) {\n\t\t\t\t\tcout << 'x';\n\t\t\t\t\tif (i >= 2) {\n\t\t\t\t\t\tcout << '^';\n\t\t\t\t\t\tcout << i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << vs[i];\n\t\t\t}\n\t\t\t\n\t\t\tfst =false;\n\t\t}\n\t}\n\tif (fst)cout << '0';\n\tcout << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tGraph g(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u, v; string p; cin >> u >> v >> p;\n\t\t\tst = p;\n\t\t\tu--; v--;\n\t\t\ta = 0;\n\t\t\tauto aa(getvec());\n\t\t\tg[u].emplace_back(u, v, aa);\n\t\t}\n\t\tWeight ans = maximumFlow(g, 0, N - 1);\n\t\tmakest(ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<map>\n#include<utility>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[52];\nbool used[52];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back({to,cap,(int)G[to].size()});\n  G[to].push_back({from,cap,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,1e9);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  for(int N,M;cin>>N>>M,N|M;){\n    bool nz=false;\n    map<pair<int,int>,vector<int> >pols;\n    for(int i=0;i<M;i++){\n      int u,v;\n      char p[1234];\n      cin>>u>>v>>p;\n      vector<int> c(51);\n      for(char *pp=p;*pp;){\n\tint cc=1;\n\tif(*pp!='x'){\n\t  cc=strtol(pp,&pp,10);\n\t}\n\tint f=0;\n\tif(*pp){\n\t  pp++;\n\t  f=1;\n\t  if(*pp=='^'){\n\t    f=strtol(pp+1,&pp,10);\n\t  }\n\t}\n\tc[f]=cc;\n      }\n      pols[make_pair(u,v)]=c;\n    }\n    for(int i=51;i>=0;i--){\n      for(auto &e:G){\n\te.clear();\n      }\n      for(auto e:pols){\n\tadd_edge(e.first.first,e.first.second,e.second[i]);\n      }\n      int f=max_flow(1,N);\n      if(f){\n\tif(nz){\n\t  cout<<'+';\n\t}\n\tnz=true;\n\tif(f>1||i==0){\n\t  cout<<f;\n\t}\n\tif(i){\n\t  cout<<'x';\n\t  if(i>1){\n\t    cout<<i;\n\t  }\n\t}\n      }\n      for(int j=1;j<=N;j++){\n\tfor(auto e:G[j]){\n\t  auto k=make_pair(j,e.to);\n\t  if(pols.count(k)&&e.cap!=0&&e.cap!=pols[k][i]*2){\n\t    for(int l=i;l>=0;l--){\n\t      pols[k][l]=1e9;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(!nz){\n      cout<<0;\n    }\n    cout<<endl;\n  }\n}\n\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<map>\n#include<utility>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[52];\nbool used[52];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back({to,cap,(int)G[to].size()});\n  G[to].push_back({from,cap,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,1e9);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  for(int N,M;cin>>N>>M,N|M;){\n    bool nz=false;\n    map<pair<int,int>,vector<int> >pols;\n    for(int i=0;i<M;i++){\n      int u,v;\n      char p[1234];\n      cin>>u>>v>>p;\n      vector<int> c(51);\n      for(char *pp=p;*pp;){\n\tint cc=1;\n\tif(*pp!='x'){\n\t  cc=strtol(pp,&pp,10);\n\t}\n\tint f=0;\n\tif(*pp){\n\t  pp++;\n\t  f=1;\n\t  if(isdigit(*pp)){\n\t    f=strtol(pp,&pp,10);\n\t  }\n\t}\n\tc[f]=cc;\n      }\n      pols[make_pair(u,v)]=c;\n    }\n    for(int i=51;i>=0;i--){\n      for(auto &e:G){\n\te.clear();\n      }\n      for(auto e:pols){\n\tadd_edge(e.first.first,e.first.second,e.second[i]);\n      }\n      int f=max_flow(1,N);\n      if(f){\n\tif(nz){\n\t  cout<<'+';\n\t}\n\tnz=true;\n\tif(f>1||i==0){\n\t  cout<<f;\n\t}\n\tif(i){\n\t  cout<<'x';\n\t  if(i>1){\n\t    cout<<i;\n\t  }\n\t}\n      }\n      for(int j=1;j<=N;j++){\n\tfor(auto e:G[j]){\n\t  auto k=make_pair(j,e.to);\n\t  if(pols.count(k)&&e.cap!=0&&e.cap!=pols[k][i]*2){\n\t    for(int l=i;l>=0;l--){\n\t      pols[k][l]=1e9;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(!nz){\n      cout<<0;\n    }\n    cout<<endl;\n  }\n}\n\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 55;\nconst int INF = 1 << 28;\nconst int L = 53;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\nvector<int> vec_INF = vec_zero;\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero && e.cap != vec_INF){\n\t\t\t//cout << v << ' ' << i << ' ' << endl;\n\t\t\t//for(int j=0;j<L;j++) cout << e.cap[j] << ' '; cout << endl;\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n\t\t\t\t/*\n\t\t\t\tbool skip = false;\n        for(int j=0;j<L;j++){\n\t\t\t\t\tif(skip){\n\t\t\t\t\t\te.cap[j] = max(0, e.cap[j] - d[j]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(e.cap[j] > d[j]) skip = true;\n\t\t\t\t\te.cap[j] -= d[j];\n        }\n\t\t\t\t*/\n        for(int j=0;j<L;j++) e.cap[j] -= d[j];\n\t\t\t\t//for(int j=0;j<L;j++) cout << G[e.to][e.rev].cap[j] << ' '; cout << endl;\n\t\t\t\t//for(int j=0;j<L;j++) cout << d[j] << ' '; cout << endl;\n        for(int j=0;j<L;j++) G[e.to][e.rev].cap[j] += d[j];\n\t\t\t\t//for(int j=0;j<L;j++) cout << G[e.to][e.rev].cap[j] << ' '; cout << endl;\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vec_INF[0] = 1;\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n    if(f == vec_zero) return flow;\n    for(int j=0;j<L;j++) flow[j] += f[j];\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n\t\tG[i].clear();\n\t\tused[i] = false;\n\t}\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == 'x') x = i;\n  if(x == -1) return make_pair(0, atoi(s.c_str()));\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0) res.second = 1;\n\telse res.second = atoi(tmp.c_str());\n  int h = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == '^') res.first = atoi(s.substr(i+1).c_str());\n\tif(h == -1) res.first = 1;\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size() || s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      if(i == s.size()) break;\n\t\t\tpre = i + 1;\n    }\n  }\n  return res;\n}\n\nmain(){\n\tint V, E;\n  while(cin >> V >> E && (V|E)){\n\t\tinit();\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      vector<int> tmp = calc(s);\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n    bool first = true;\n    for(int i=L-1;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else cout << \"+\";\n      if(i == 0) cout << ans[i];\n\t\t\telse{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1) cout << \"x\";\n\t\t\t\telse cout << \"x^\" << i;\n      }\n    }\n\t\tif(first) cout << 0;\n\t\tcout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 110\n#define MAX_DEGREE 50\n\n//辺を表す構造体(行先、容量、逆辺のインデックス)\nstruct Edge{\n\tEdge(int arg_to,vector<int> arg_capacity,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t}\n\tint to,rev_index;\n\tvector<int> capacity;\n};\n\nint V,E;\nint max_degree;\n\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint dist[NUM]; //sourceからの距離\nint cheked_index[NUM]; //どこまで調べ終わったか\n\n//fromからtoへ向かう容量capacityの辺をグラフに追加する\nvoid add_edge(int from,int to,vector<int> capacity){\n\n\tvector<int> ZERO;\n\tfor(int i = 0; i <= MAX_DEGREE; i++)ZERO.push_back(0);\n\n\tG[from].push_back(Edge(to,capacity,G[to].size()));\n\tG[to].push_back(Edge(from,ZERO,G[from].size()-1)); //逆辺の、初期容量は0\n}\n\nvector<int> get_smaller(vector<int> A,vector<int> B){\n\n\tfor(int i = max_degree; i >= 0; i--){\n\t\tif(A[i] != B[i]){\n\t\t\tif(A[i] > B[i]){ //最高次数が小さい方を採用\n\t\t\t\treturn B;\n\t\t\t}else{\n\t\t\t\treturn A;\n\t\t\t}\n\t\t}\n\t}\n\treturn A;\n}\n\n\nbool is_zero(vector<int> add){\n\tfor(int i = 0; i <= max_degree; i++){\n\t\tif(add[i] != 0){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n//sourceからの最短距離をBFSで計算する\nvoid bfs(int source){\n\tfor(int i = 0; i < V; i++)dist[i] = -1;\n\tqueue<int> Q;\n\tdist[source] = 0;\n\tQ.push(source);\n\n\twhile(!Q.empty()){\n\t\tint node_id = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tEdge &e = G[node_id][i];\n\t\t\tif(is_zero(e.capacity) == false && dist[e.to] < 0){ //辺の容量が正で、かつエッジの行先に未訪問の場合\n\t\t\t\tdist[e.to] = dist[node_id]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//増加パスをDFSで探す\nvector<int> dfs(int node_id,int sink,vector<int> tmp_min){\n\n\tif(node_id == sink)return tmp_min; //終点についたらtmp_min[★最小の容量★]をreturn\n\n\tvector<int> ret;\n\n\tfor(int &i = cheked_index[node_id]; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\n\t\tEdge &e = G[node_id][i];\n\n\t\tif(is_zero(e.capacity) == false && dist[node_id] < dist[e.to]){ //流せる余裕があり、かつsourceからの距離が増加する方法である場合\n\n\t\t\tret = dfs(e.to,sink,get_smaller(tmp_min,e.capacity)); //流せるだけ流す\n\n\t\t\tif(!is_zero(ret)){ //流せた場合\n\t\t\t\tfor(int k = 0; k <= max_degree; k++){\n\t\t\t\t\te.capacity[k] -= ret[k]; //流した分、エッジの容量を削減する\n\t\t\t\t\tG[e.to][e.rev_index].capacity[k] += ret[k]; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\t//★★エッジのused状況により、for文の内部に到達しない場合あり★★\n\tif(ret.size() == 0){\n\t\tfor(int i = 0; i <= max_degree; i++)ret.push_back(0);\n\t}\n\n\treturn ret;\n}\n\n//sourceからsinkへの最大流を求める\nvector<int> max_flow(int source,int sink){ //source:始点 sink:終点\n\n\tvector<int> ret,add,tmp_min;\n\tfor(int i = 0; i <= max_degree; i++)ret.push_back(0);\n\n\twhile(true){ //増加パスが存在する限り、流量を追加し続ける\n\t\tbfs(source);\n\t\tif(dist[sink] < 0)break; //sourceからsinkへと辿り着く残余グラフがない、つまり増加パスが無くなった場合、break\n\t\tfor(int i = 0; i < V; i++)cheked_index[i] = 0;\n\n\t\ttmp_min.clear();\n\t\tfor(int i = 0; i <= max_degree; i++)tmp_min.push_back(BIG_NUM);\n\n\t\twhile(!is_zero(add = dfs(source,sink,tmp_min))){ //増加パスが見つかる間、加算\n\t\t\tfor(int i = 0; i <= max_degree; i++){\n\t\t\t\tret[i] += add[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nbool is_number(char ch){\n\treturn ch >= '0' && ch <= '9';\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < NUM; i++)G[i].clear();\n\n\tint from,to,index,tmp,tmp_degree;\n\tchar buf[1000];\n\tvector<int> input;\n\n\tmax_degree = 0;\n\n\tfor(int loop = 0; loop < E; loop++){\n\n\t\tinput.clear();\n\t\tfor(int i = 0; i <= MAX_DEGREE; i++)input.push_back(0);\n\n\t\tscanf(\"%d %d %s\",&from,&to,buf);\n\t\tfrom--;\n\t\tto--;\n\n\t\tindex = 0;\n\n\t\twhile(buf[index] != '\\0'){\n\n\t\t\tif(is_number(buf[index])){ //係数の場合\n\n\t\t\t\ttmp = 0;\n\t\t\t\twhile(is_number(buf[index])){\n\t\t\t\t\ttmp = 10*tmp+buf[index]-'0';\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tif(buf[index] == 'x'){\n\n\t\t\t\t\tindex++;\n\n\t\t\t\t}else{ //★定数の場合:最後の項であるはず★\n\n\t\t\t\t\tinput[0] = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}else if(buf[index] == 'x'){\n\t\t\t\ttmp = 1;\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tif(buf[index] == '^'){ //ここに来るまでに係数が設定されているはず\n\n\t\t\t\ttmp_degree = 0;\n\t\t\t\tindex++;\n\t\t\t\twhile(is_number(buf[index])){\n\t\t\t\t\ttmp_degree = 10*tmp_degree+buf[index]-'0';\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t}else{ //xの一次項\n\t\t\t\ttmp_degree = 1;\n\t\t\t}\n\t\t\tinput[tmp_degree] = tmp;\n\t\t\tmax_degree = max(max_degree,tmp_degree);\n\t\t\tif(buf[index] == '+')index++;\n\t\t}\n\n\t\tadd_edge(from,to,input);\n\t\tadd_edge(to,from,input);\n\t}\n\n\tvector<int> ans = max_flow(0,V-1);\n\n\tbool is_First = true;\n\n\tfor(int i = max_degree; i >= 0; i--){\n\t\tif(ans[i] == 0)continue;\n\n\t\tif(is_First){\n\t\t\tis_First = false;\n\t\t}else{\n\t\t\tprintf(\"+\");\n\t\t}\n\t\tif(ans[i] > 1 || i == 0){\n\t\t\tprintf(\"%d\",ans[i]);\n\t\t}\n\t\tif(i > 0){\n\t\t\tprintf(\"x\");\n\t\t\tif(i > 1){\n\t\t\t\tprintf(\"^%d\",i);\n\t\t\t}\n\t\t}\n\t}\n\tif(is_First){\n\t\tprintf(\"0\");\n\t}\n\n\tprintf(\"\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&V,&E);\n\t\tif(V == 0 && E == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nvector<int> Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n  return res;\n}\n\nvector<int> Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n  return res;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(55,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(55,INF));\n    if(isall0(f))return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(55,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(55,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+='+';\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+='x';\n    else if(i) s+=\"x^\"+itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      /*      vector<int> r=tocap(s);\n      for(int j=0;j<r.size();j++) cout<<r[j]<<' ';\n      cout<<endl;*/\n      add_edge(a-1,b-1,tocap(s));\n      add_edge(b-1,a-1,tocap(s));\n    }\n    \n    output(max_flow(0,n-1));\n\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\n\nstruct poly {\n\tvector<int> c;\n\tpoly(vector<int> v) {\n\t\tc = v;\n\t}\n\tpoly(int x) {\n\t\tc = { x };\n\t}\n\tpoly() {};\n};\n\nbool operator<(const poly &a, const poly &b) {\n\tif (a.c.size() != b.c.size())return a.c.size() < b.c.size();\n\tper(i, (int)a.c.size()) {\n\t\tif (a.c[i] != b.c[i])return a.c[i] < b.c[i];\n\t}\n\treturn false;\n}\npoly operator-(const poly &a, const poly &b) {\n\tpoly ret;\n\tint len = max(a.c.size(), b.c.size());\n\tret.c.resize(len);\n\trep(i, len) {\n\t\tint s = 0;\n\t\tif (i < a.c.size())s += a.c[i];\n\t\tif (i < b.c.size())s -= b.c[i];\n\t\tret.c[i]=s;\n\t}\n\twhile (ret.c.size() > 1 && ret.c.back() == 0)ret.c.pop_back();\n\treturn ret;\n}\npoly operator+(const poly &a, const poly &b) {\n\tpoly ret;\n\tint len = max(a.c.size(), b.c.size());\n\tret.c.resize(len,0);\n\trep(i, len) {\n\t\tint s = 0;\n\t\tif (i < a.c.size())s += a.c[i];\n\t\tif (i < b.c.size())s += b.c[i];\n\t\tret.c[i]=s;\n\t}\n\twhile (ret.c.size() > 1 && ret.c.back() == 0)ret.c.pop_back();\n\treturn ret;\n}\nbool operator==(const poly &a, const poly &b) {\n\treturn a.c == b.c;\n}\npoly min(poly a, poly b) {\n\tif (a < b)return a;\n\treturn b;\n}\npoly in() {\n\tpoly ret; ret.c.resize(52, 0);\n\tstring s; cin >> s;\n\tint loc = 0;\n\trep(i, s.length()) {\n\t\tif (s[i] == '+') {\n\t\t\tstring t = s.substr(loc, i - loc);\n\t\t\tint c = 1;\n\t\t\tif (isdigit(t[0])) {\n\t\t\t\tint j = 0;\n\t\t\t\twhile (j < t.length() && isdigit(t[j]))j++;\n\t\t\t\tc = stoi(t.substr(0, j));\n\t\t\t}\n\t\t\tbool f = false;\n\t\t\tint d = 1;\n\t\t\trep(j, t.length()) {\n\t\t\t\tif (t[j] == 'x') {\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif (t[j] == '^') {\n\t\t\t\t\tint le = j + 1;\n\t\t\t\t\tj++;\n\t\t\t\t\twhile (j < t.length() && isdigit(t[j]))j++;\n\t\t\t\t\td = stoi(t.substr(le, j - le));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f)d = 0;\n\t\t\tret.c[d] = c;\n\t\t\tloc = i + 1;\n\t\t}\n\t}\n\tstring t = s.substr(loc, t.length() - loc);\n\tint c = 1;\n\tif (isdigit(t[0])) {\n\t\tint j = 0;\n\t\twhile (j < t.length() && isdigit(t[j]))j++;\n\t\tc = stoi(t.substr(0, j));\n\t}\n\tbool f = false;\n\tint d = 1;\n\trep(j, t.length()) {\n\t\tif (t[j] == 'x') {\n\t\t\tf = true;\n\t\t}\n\t\tif (t[j] == '^') {\n\t\t\tint le = j + 1;\n\t\t\tj++;\n\t\t\twhile (j < t.length() && isdigit(t[j]))j++;\n\t\t\td = stoi(t.substr(le, j - le));\n\t\t}\n\t}\n\tif (!f)d = 0;\n\tret.c[d] = c;\n\twhile (ret.c.size() > 1 && ret.c.back() == 0)ret.c.pop_back();\n\treturn ret;\n}\nvoid out(poly p) {\n\tif (p == 0) {\n\t\tcout << 0 << endl; return;\n\t}\n\tstring ret;\n\tper(i, (int)p.c.size()) {\n\t\tif (p.c[i]) {\n\t\t\tif (i == 0 && p.c[i] == 1) {\n\t\t\t\tret.push_back('1');\n\t\t\t}\n\t\t\tif (p.c[i] != 1) {\n\t\t\t\tstring z = to_string(p.c[i]);\n\t\t\t\tret += z;\n\t\t\t}\n\t\t\tif (i >= 1) {\n\t\t\t\tret.push_back('x');\n\t\t\t\tif (i > 1) {\n\t\t\t\t\tret.push_back('^');\n\t\t\t\t\tstring z = to_string(i);\n\t\t\t\t\tret += z;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret.push_back('+');\n\t\t}\n\t}\n\tret.pop_back();\n\tcout << ret << endl;\n}\n\n\nstruct edge { int to; poly cap; int rev; };\n\n\nvector<edge> G[100000];\nbool used[100000];\nvoid add_edge(int from, int to, poly cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\npoly dfs(int v, int t, poly f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && 0<e.cap) {\n\t\t\tpoly d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (0<d) {\n\t\t\t\te.cap = e.cap-d;\n\t\t\t\tG[e.to][e.rev].cap = G[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nconst poly inf(vector<int>(52, 1));\npoly max_flow(int s, int t,int sz) {\n\tpoly flow = 0;\n\tfor (;;) {\n\t\tfill(used, used + sz, false);\n\t\tpoly f = dfs(s, t, inf);\n\t\t//out(f);\n\t\tif (f == poly(0))return flow;\n\t\tflow = flow+f;\n\t\t//out(flow);\n\t}\n}\nbool isdigit(char t) {\n\treturn '0' <= t && t <= '9';\n}\nint n, m;\nvoid solve() {\n\trep(i, n)G[i].clear();\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tpoly p = in();\n\t\tadd_edge(a, b, p);\n\t\tadd_edge(b, a, p);\n\t}\n\tpoly ans = max_flow(0, n - 1,n);\n\t//cout << \"ans is \";\n\tout(ans);\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t//cout << fixed << setprecision(10);\n\t//init();\n\twhile(cin>>n>>m,n)solve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct capacity {\n  vector<int> val;\n  capacity():val(55, 0){}\n  capacity(vector<int> ini):val(ini){}\n  capacity operator + (capacity r) {\n    vector<int> res(55);\n    for(int i = 0; i < 55; i++) res[i] = val[i] + r.val[i];\n    return capacity(res);\n  }\n  capacity operator - (capacity r) {\n    vector<int> res(55);\n    for(int i = 0; i < 55; i++) res[i] = val[i] - r.val[i];\n    return capacity(res);\n  }\n  capacity operator * (int k) {\n    vector<int> res(55);\n    for(int i = 0; i < 55; i++) res[i] = val[i] * k;\n    return capacity(res);\n  }\n  capacity& operator - () {\n    for(int i = 0; i < 55; i++) val[i] = -val[i];\n    return *this;\n  }\n  bool operator == (const capacity& r) const {\n    return val == r.val;\n  }\n  bool operator < (const capacity& r) const {\n    vector<int> x = val, y = r.val;\n    reverse(all(x));\n    reverse(all(y));\n    return x < y;\n  }\n  bool operator > (const capacity& r) const {\n    vector<int> x = val, y = r.val;\n    reverse(all(x));\n    reverse(all(y));\n    return x > y;\n  }\n};\n\nconst capacity INF = capacity(vector<int>(55, inf));\nconst capacity ZERO = capacity(vector<int>(55, 0));\n\nstruct Dinic {\n  struct edge {\n    int to, rev;\n    capacity cap;\n    edge(){}\n    edge(int to, capacity cap, int rev)\n      :to(to), cap(cap), rev(rev){}\n  };\n  vector< vector<edge> > graph;\n  vector<int> level, iter;\n  Dinic(){}\n  Dinic(int V):graph(V), level(V), iter(V){}\n  void add_edge(int from, int to, capacity cap) {\n    graph[from].emplace_back(to, cap, graph[to].size());\n    graph[to].emplace_back(from, ZERO, graph[from].size()-1);\n  }\n  void bfs(int s) {\n    fill(all(level), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(que.size()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < graph[v].size(); i++) {\n\tedge& e = graph[v][i];\n\tif(e.cap > ZERO && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  capacity dfs(int v, int t, capacity f) {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < graph[v].size(); i++) {\n      edge& e = graph[v][i];\n      if(e.cap > ZERO && level[v] < level[e.to]) {\n\tcapacity d = dfs(e.to, t, min(f, e.cap));\n\tif(d > ZERO) {\n\t  e.cap = e.cap - d;\n\t  graph[e.to][e.rev].cap = graph[e.to][e.rev].cap + d;\n\t  return d;\n\t}\n      }\n    }\n    return ZERO;\n  }\n  capacity max_flow(int s, int t) {\n    capacity flow = ZERO;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      fill(all(iter), 0);\n      capacity f; while((f = dfs(s, t, INF)) > ZERO) flow = flow + f;\n    }\n  }\n};\n\ncapacity to_cap(string s) {\n  vector<char> vec;\n  //s += \"x^0\";\n  s += '+';\n  for(char c : s) {\n    if(c == '+' && vec.back() == 'x') vec.push_back('^'), vec.push_back('1');\n    else if(c == 'x' && (vec.empty() || vec.back() == '+')) vec.push_back('1');\n    vec.push_back(c);\n  }\n  vec.pop_back();\n  if((vec.size() == 1 || (vec.size() > 1 && vec[vec.size()-2] != '^')) && isdigit(vec.back())) vec.push_back('x'), vec.push_back('^'), vec.push_back('0');\n  string t = \"\";\n  for(char c : vec) t += c;\n  vector<int> cap(55, 0);\n  char buf[256], a[256], b[256];\n  strcpy(buf, t.c_str());\n  int of = 0;\n  while(sscanf(buf + of, \"%[^x]x^%[^+]\", a, b) != EOF) {\n    of += strlen(a) + 2 + strlen(b);\n    cap[atoi(b)] = atoi(a);\n  }\n  return capacity(cap);\n}\n\nstring to_str(capacity cap) {\n  string res = \"\";\n  bool flag = false;\n  rep(i, cap.val.size()) {\n    if(cap.val[i] != 0) {\n      string tmp = (i && cap.val[i] == 1 ? \"\" : to_string(cap.val[i]));\n      if(i > 0) tmp += \"x\";\n      if(i > 1) tmp += \"^\"+to_string(i);\n      if(flag) tmp = tmp + \"+\";\n      res = tmp + res;\n      flag = true;\n    }\n  }\n  return (res == \"\" ? \"0\" : res);\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M;\n  while(cin >> N >> M, N || M) {\n    Dinic graph(N);\n    rep(i, M) {\n      int u, v;\n      string p;\n      cin >> u >> v >> p;\n      --u, --v;\n      auto c = to_cap(p);\n      // rep(j, 4) cout << c.val[j] << \" \";\n      // cout << endl;\n      graph.add_edge(u, v, to_cap(p));\n      graph.add_edge(v, u, to_cap(p));\n    }\n    capacity res = graph.max_flow(0, N-1);\n    //cout << \"rem\" << endl;\n    // rep(i, graph.graph.size()) {\n    //   cout << i << \" : \" << endl;\n    //   rep(j, graph.graph[i].size()) {\n    //  \tcout << graph.graph[i][j].to << \"\\\\\";\n    //  \trep(k, 5) cout << graph.graph[i][j].cap.val[k] << \" \";\n    //  \tcout << endl;\n    //   }\n    //   cout << endl;\n    // }\n    //cout <<\"ans\" << endl;\n    //rep(j, 4) cout << res.val[j] << \" \";\n    //cout << endl;\n    cout << to_str(res) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=100;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct weight {\n\tstatic constexpr int MAX_L = 50;\n\ttypedef array<int, MAX_L + 1> A;\n\n\tA coefficients;\n\n\tinline static int number(string::const_iterator &it) {\n\t\tint res = 0;\n\t\twhile(isdigit(*it)) {\n\t\t\tres = res * 10 + *it - '0';\n\t\t\t++it;\n\t\t}\n\t\treturn res;\n\t}\n\n\tinline void parse(string::const_iterator &it) {\n\t\tconst int c = (isdigit(*it) ? number(it) : 1);\n\n\t\tif(*it != 'x') {\n\t\t\tcoefficients.back() = c;\n\t\t\treturn;\n\t\t}\n\n\t\t++it;\n\n\t\tint e = 1;\n\t\tif(*it == '^') {\n\t\t\t++it;\n\t\t\te = number(it);\n\t\t}\n\n\t\tcoefficients[MAX_L - e] = c;\n\t}\n\n\tweight(const string &s = \"0\") {\n\t\tcoefficients.fill(0);\n\n\t\tstring::const_iterator it = s.cbegin();\n\t\tparse(it);\n\t\twhile(*it == '+') {\n\t\t\t++it;\n\t\t\tparse(it);\n\t\t}\n\t}\n\n\tweight(const A &a):coefficients(a) {}\n\tweight(const weight &w):coefficients(w.coefficients) {}\n\n\tinline bool operator<(const weight &w) const {\n\t\treturn coefficients < w.coefficients;\n\t}\n\n\n\tinline weight &operator+=(const weight &w) {\n\t\tfor(unsigned i = 0; i < coefficients.size(); ++i) {\n\t\t\tcoefficients[i] += w.coefficients[i];\n\t\t}\n\t\treturn *this;\n\t}\n\n\tinline weight &operator-=(const weight &w) {\n\t\tfor(unsigned i = 0; i < coefficients.size(); ++i) {\n\t\t\tcoefficients[i] -= w.coefficients[i];\n\t\t}\n\t\treturn *this;\n\t}\n\n\tinline string to_string() const {\n\t\tstring res;\n\t\tfor(unsigned i = 0; i < coefficients.size(); ++i) {\n\t\t\tif(coefficients[i] != 0) {\n\t\t\t\tif(res.size()) res += '+';\n\n\t\t\t\tconst int e = MAX_L - i;\n\n\t\t\t\tif(e == 0 || coefficients[i] > 1) {\n\t\t\t\t\tres += std::to_string(coefficients[i]);\n\t\t\t\t}\n\n\t\t\t\tif(e >= 1) {\n\t\t\t\t\tres += 'x';\n\t\t\t\t\tif(e >= 2) res += \"^\" + std::to_string(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(res == \"\") res = \"0\";\n\t\treturn res;\n\t}\n};\n\nstruct edge {\n\tint to;\n\tweight cap;\n\tint rev;\n\tedge(int to_, weight cap_, int rev_):to(to_), cap(cap_), rev(rev_){}\n};\n\nconst weight INF(\"1000x^50\");\nconst weight ZERO;\n\nvector<vector<edge> > G;\nvector<int> level;\nvector<int> iter;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n\tlevel.resize(V);\n\titer.resize(V);\n}\n\nvoid add_edge(int from, int to, weight cap) {\n\tG[from].emplace_back(to, cap, G[to].size());\n\tG[to].emplace_back(from, cap, G[from].size() - 1);\n}\n\nvoid bfs(int s) {\n\tfill(level.begin(), level.end(), -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(ZERO < e.cap && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nweight dfs(int v, int t, weight f) {\n\tif(v == t) return f;\n\n\tfor(int &i = iter[v]; i < static_cast<int>(G[v].size()); ++i) {\n\t\tedge &e = G[v][i];\n\t\tif(ZERO < e.cap && level[v] < level[e.to]) {\n\t\t\tconst weight d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(ZERO < d) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ZERO;\n}\n\nweight max_flow(int s, int t) {\n\tweight flow = ZERO;\n\n\tfor(;;) {\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\n\t\tfill(iter.begin(), iter.end(), 0);\n\t\tfor(weight f; ZERO < (f = dfs(s, t, INF)); flow += f);\n\t}\n}\n\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tinit(n);\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b;\n\t\t\tstring p;\n\t\t\tcin >> a >> b >> p;\n\t\t\tadd_edge(a - 1, b - 1, weight(p));\n\t\t}\n\n\t\tcout << max_flow(0, n - 1).to_string() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconstexpr int MAX_V = 55;\nconstexpr int INF = (1 << 29);\n\nstruct CAP {\n    vector<int> c;\n \n    CAP () { c = vector<int>(51); }\n    \n    CAP (int v) {\n        c = vector<int>(51, v);\n    }\n     \n    bool operator < (const CAP& w) const {\n        return c > w.c;\n    }\n \n    bool operator > (const CAP& w) const {\n        return c > w.c;\n    }\n\n    bool operator == (const CAP& w) const {\n        return c == w.c;\n    }\n     \n    CAP& operator += (const CAP& w) {        \n        for (int i = 0; i < 51; i++) {\n            c[i] += w.c[i];\n        }\n        return *this;\n    }    \n    \n    CAP& operator -= (const CAP& w) {        \n        for (int i = 0; i < 51; i++) {\n            c[i] -= w.c[i];\n        }\n        return *this;\n    }    \n};\n\nCAP min_cap(const CAP& a, const CAP& b)\n{\n    for (int i = 0; i <= 50; i++) {\n        if (a.c[i] < b.c[i]) {\n            return a;\n        } else if (a.c[i] > b.c[i]) {\n            return b;\n        }\n    }\n    return a;\n}\n\nstruct edge {\n    int to;\n    CAP cap;\n    int rev;    \n    edge(int to, CAP cap, int rev) :\n        to{to}, cap{cap}, rev{rev} {}\n};\n\nvector<edge> G[MAX_V];\nint level[MAX_V], iter[MAX_V];\n\nvoid add_edge(int from, int to, CAP cap)\n{\n    G[from].emplace_back(to, cap, G[to].size());\n    G[to].emplace_back(from, CAP(0), G[from].size() - 1);\n}\n\nvoid bfs(int s)\n{\n    memset(level, -1, sizeof(level));\n    queue<int> Q;\n    level[s] = 0;\n    Q.push(s);\n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > CAP(0) && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                Q.push(e.to);\n            }\n        }\n    }\n}\n\nCAP dfs(int v, int t, const CAP& f)\n{\n    if (v == t) return f;\n    for (int &i = iter[v]; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > CAP(0) && level[v] < level[e.to]) {\n            CAP d = dfs(e.to, t, min_cap(f, e.cap));\n            if (d > CAP(0)) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nCAP max_flow(int s, int t)\n{\n    CAP flow;\n    for (;;) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        CAP f;\n        while ((f = dfs(s, t, CAP(INF))) > CAP(0)) {\n            flow += f;\n        }\n    }\n}\n\nvoid init(int N)\n{\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n    }\n}\n\npair<int, int> get_num(const string& s)\n{\n    int j = -1;\n    int N = s.size();\n    for (int i = 0; i < N; i++) {\n        if (s[i] == 'x') {\n            j = i;\n            break;\n        }\n    }\n    if (j == -1) {\n        return {50, stoi(s)};\n    } else {\n        int v = (j + 1 == N ? 1 : stoi(s.substr(j + 2)));\n        return {50 - v, (j == 0 ? 1 : stoi(s.substr(0, j)))};\n    }   \n}\n\nCAP get_cap(const string& p)\n{\n    CAP cap;\n    string s;\n    for (auto& v : p) {\n        if (v == '+') {\n            auto r = get_num(s);\n            cap.c[r.first] = r.second;\n            s.clear();\n        } else {\n            s += v;\n        }\n    }\n\n    if (!s.empty()) {\n        auto r = get_num(s);\n        cap.c[r.first] = r.second;\n    }        \n    return cap;\n}\n\nint main()\n{\n    int N, M;\n    while (1) {\n        cin >> N >> M;\n        if (N == 0 && M == 0) break;\n\n        init(N);\n        \n        int S = 0, T = N - 1;\n        int u, v;\n        string p;\n        for (int i = 0; i < M; i++) {\n            cin >> u >> v >> p;\n            u--; v--;\n            CAP c = get_cap(p);\n            add_edge(u, v, c);\n            add_edge(v, u, c);\n        }\n\n        auto f = max_flow(S, T);\n        \n        vector<pair<int, int>> res;\n        for (int i = 0; i <= 50; i++) {\n            if (f.c[i] > 0) {\n                res.emplace_back(f.c[i], 50 - i);              \n            }\n        }\n\n        if (res.size() == 0) {\n            cout << 0 << endl;\n        } else {\n            for (int i = 0; i < (int)res.size(); i++) {\n                if (i > 0) cout << \"+\";\n                if (res[i].second == 0 || res[i].first != 1) {\n                    cout << res[i].first;   \n                }\n                if (res[i].second != 0) {\n                    cout << \"x\";\n                    if (res[i].second > 1) {\n                        cout << \"^\" << res[i].second;\n                    }\n                }\n            }\n            cout << endl;\n        }\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return true;\n  return false;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct Polynomial {\n\tusing Val = int;\n\tusing Coef = int;\n\tint n; // dimension = degree + 1\n\tvector<Coef> coefs;\n\tPolynomial() :n(1), coefs(1) {}\n\texplicit Polynomial(int n) :n(n), coefs(n) {}\n\texplicit Polynomial(int n, Coef c) :n(n), coefs(n) { coefs[n - 1] = c; }\n\tvoid resize(int n) { this->n = n; coefs.resize(n); }\n\tvoid normalize() {\n\t\tint i = n;\n\t\twhile (i > 1 && coefs[i - 1] == Coef())i--;\n\t\tresize(i);\n\t}\n\tbool operator<(const Polynomial &that)const {\n\t\tfor (int i = that.n; i > n; i--)\n\t\t\tif (that.coefs[i - 1] > Coef())\n\t\t\t\treturn true;\n\t\t\telse if (that.coefs[i - 1] < Coef())\n\t\t\t\treturn false;\n\t\tfor (int i = n; i > that.n; i--)\n\t\t\tif (coefs[i - 1] > Coef())\n\t\t\t\treturn false;\n\t\t\telse if (coefs[i - 1] < Coef())\n\t\t\t\treturn true;\n\t\tfor (int i = min(n, that.n); i > 0; i--)\n\t\t\tif (coefs[i - 1] < that.coefs[i - 1])\n\t\t\t\treturn true;\n\t\t\telse if (coefs[i - 1] > that.coefs[i - 1])\n\t\t\t\treturn false;\n\t\treturn false;\n\t}\n\tbool operator>(const Polynomial &that)const { return that < *this; }\n\tbool operator<=(const Polynomial &that)const { return !(that < *this); }\n\tbool operator>=(const Polynomial &that)const { return !(*this < that); }\n\tbool operator==(const Polynomial &that)const { return !(*this < that) && !(that < *this); }\n\tbool operator!=(const Polynomial &that)const { return !(*this == that); }\n\tPolynomial &operator+=(const Polynomial &that) {\n\t\tif (n < that.n)\n\t\t\tresize(that.n);\n\t\tfor (int i = 0; i < that.n; i++)\n\t\t\tcoefs[i] += that.coefs[i];\n\t\tnormalize();\n\t\treturn *this;\n\t}\n\tPolynomial &operator-=(const Polynomial &that) {\n\t\tif (n < that.n)\n\t\t\tresize(that.n);\n\t\tfor (int i = 0; i < that.n; i++)\n\t\t\tcoefs[i] -= that.coefs[i];\n\t\tnormalize();\n\t\treturn *this;\n\t}\n\tPolynomial operator+(const Polynomial &that)const { return Polynomial(*this) += that; }\n\tPolynomial operator-(const Polynomial &that)const { return Polynomial(*this) -= that; }\n\n\tVal evaluate(Val a)const {\n\t\tVal ans = 0, x = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += x*coefs[i];\n\t\t\tx *= a;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nostream &operator<<(ostream &o, const Polynomial &p) {\n\tbool first = true;\n\tfor (int i = p.n - 1; i >= 0; i--) {\n\t\tPolynomial::Coef c = p.coefs[i];\n\t\tif (c != 0) {\n\t\t\tif (first && c < 0)o << \"-\";\n\t\t\telse if (first)o << \"\";\n\t\t\telse if (c < 0)o << \"-\";\n\t\t\telse o << \"+\";\n\n\t\t\tif (i != 0 && (c == 1 || c == -1))o << \"\";\n\t\t\telse if (c < 0)o << -c;\n\t\t\telse o << c;\n\n\t\t\tif (i == 0)o << \"\";\n\t\t\telse if (i == 1)o << \"x\";\n\t\t\telse o << \"x^\" << i;\n\n\t\t\tfirst = false;\n\t\t}\n\t}\n\tif (first)o << \"0\";\n\treturn o;\n}\n\nconst Polynomial kPolynomialInf(55, INF);\n\n\n\nstruct Dinic {\n\tusing Flow = Polynomial;\n\tconst Flow kInf = kPolynomialInf;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap) :to(to), rev(rev), cap(cap) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<bool> used;\n\tvector<int> level;\n\tvector<int> iter;\n\tDinic(int n) :n(n), g(n), used(n), level(n), iter(n) {};\n\tvoid addArc(int from, int to, Flow cap) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, Flow());\n\t}\n\tvoid addEdge(int a, int b, Flow cap) {\n\t\tg[a].emplace_back(b, (int)g[b].size(), cap);\n\t\tg[b].emplace_back(a, (int)g[a].size() - 1, cap);\n\t}\n\tFlow maximumFlow(int s, int t) {\n\t\tFlow total = Flow();\n\t\twhile (true) {\n\t\t\tlevelize(s);\n\t\t\tif (level[t] < 0)return total;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tFlow f;\n\t\t\twhile (true) {\n\t\t\t\tf = augment(s, t, kInf);\n\t\t\t\tif (f == Flow())break;\n\t\t\t\ttotal += f;\n\t\t\t}\n\t\t}\n\t}\n\tFlow augment(int v, int t, Flow f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < g[v].size(); i++) {\n\t\t\tEdge &e = g[v][i];\n\t\t\tif (e.cap > Flow() && level[v] < level[e.to]) {\n\t\t\t\tFlow d = augment(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > Flow()) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Flow();\n\t}\n\tvoid levelize(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile (q.size()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > Flow() && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nstruct Parser {\n\tusing Iter = string::const_iterator;\n\tconst char kTerminator = '$';\n\tstring s;\n\tIter it;\n\tParser(const string &t) :s(t) { s += kTerminator; it = s.begin(); }\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\tPolynomial a() {\n\t\tPolynomial ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == '+') {\n\t\t\t\tit++;\n\t\t\t\tret += b();\n\t\t\t}\n\t\t\telse if (*it == '-') {\n\t\t\t\tit++;\n\t\t\t\tret -= b();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tPolynomial b() {\n\t\tint coef = integer();\n\t\tint degree = 0;\n\t\tif (*it == 'x') {\n\t\t\tcoef = max(1, coef);\n\t\t\tit++;\n\t\t\tif (*it == '^') {\n\t\t\t\tit++;\n\t\t\t\tdegree = integer();\n\t\t\t}\n\t\t\telse\n\t\t\t\tdegree = 1;\n\t\t}\n\t\treturn Polynomial(degree + 1, coef);\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M; cin >> N >> M&&N;) {\n\t\tDinic dinic(N);\n\t\trep(i, 0, M) {\n\t\t\tint u, v; string p;\n\t\t\tcin >> u >> v >> p; u--, v--;\n\t\t\tParser parser(p);\n\t\t\tPolynomial poly = parser.a();\n\t\t\tdinic.addEdge(u, v, poly);\n\t\t}\n\t\tcout << dinic.maximumFlow(0, N - 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int INF = 1<<28;\nconst int L = 51;\n \nstruct Edge {\n  int to, cost, rev;\n  vector<int> cap;\n  Edge(int to, int cost, vector<int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n \ntypedef vector<vector<Edge> > Graph;\n \nvoid addEdgeF(int from, int to, int cost, vector<int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, vector<int>(L), (int)g[from].size()-1));\n}\n \ninline void add(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] += b[i];\n}\n \ninline void subtract(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] -= b[i];\n}\n \ninline bool lt(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return false;\n}\n \ninline bool le(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return true;\n}\n \nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0 &&\n     *min_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(i == 0) {\n      cout << abs(ans[i]);\n    } else {\n      if(abs(ans[i]) != 1) cout << abs(ans[i]);\n      if(i > 1) cout << \"x^\" << i;\n      else if(i == 1) cout << \"x\";\n    }\n    j++;\n  }\n  cout << endl;\n}\n\nvoid bfs(int s, vector<int> &level, Graph &g) {\n  int n = g.size();\n  level = vector<int>(n, -1);\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    for(int i = 0; i < g[v].size(); ++i) {\n      const Edge &e = g[v][i];\n      if(level[e.to] < 0 && lt(vector<int>(L), e.cap)) {\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nvector<int> dfs(int v, int t, vector<int> f, vector<int> &level, vector<int> &iter, Graph &g) {\n  if(v == t) return f;\n  for(int &i = iter[v]; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(level[v] < level[e.to] && lt(vector<int>(L), e.cap)) {\n      vector<int> d = dfs(e.to, t, lt(f, e.cap) ? f : e.cap, level, iter, g);\n      if(lt(vector<int>(L), d)) {\n        subtract(e.cap, d);\n        add(g[e.to][e.rev].cap, d);\n        return d;\n      }\n    }\n  }\n  return vector<int>(L);\n}\n\nvector<int> maxFlow(int s, int t, Graph g) {\n  vector<int> flow(L);\n  while(1) {\n    vector<int> level;\n    bfs(s, level, g);\n    if(level[t] < 0) return flow;\n    vector<int> iter(g.size());\n    vector<int> f;\n    while(lt(vector<int>(L), f = dfs(s, t, vector<int>(L, INF), level, iter, g))) {\n      add(flow, f);\n    }\n  }\n  return flow;\n}\n \nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      vector<int> cap(L);\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n        int a = 1;\n        {\n          int i = 0;\n          while(i < s.size() && isdigit(s[i])) ++i;\n          if(i) {\n            a = atoi(s.substr(0, i).c_str());\n            s = s.substr(i);\n          }\n        }\n        int k = 0;\n        // \"\" or \"x\" or \"x^y\"\n        if(s == \"x\") {\n          k = 1;\n        } else if(s.size()) {\n          k = atoi(s.substr(2).c_str());\n        }\n        cap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      addEdgeF(v, u, 0, cap, g);\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sst stringstream\n#define sz size()\n#define vc vector\ntypedef vc<int> vi;\ntypedef vc<ll> vl;\ntypedef vc<string> vs;\n\nstruct edge{int to,cap,rev,type;};\n\nvector<edge> g[55];\nbool used[55];\n\nvoid addEdge(int from,int to,int cap){\n\tedge e;\n\te.to=to;e.cap=cap;e.rev=g[to].size();e.type=1;\n\tg[from].push_back(e);\n\te.to=from;e.cap=0;e.rev=g[from].size()-1;e.type=0;\n\tg[to].push_back(e);\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=1;\n\trep(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tfill(used,used+55,0);\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint N,M;\nint from[510],to[510],a[510][55];\n\nint main(){\n\twhile(cin>>N>>M && N){\n\t\trep(i,M)rep(j,51)a[i][j]=0;\n\t\trep(i,M){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>from[i]>>to[i]>>p;\n\t\t\tfrom[i]--,to[i]--;\n\t\t\trep(j,p.sz){\n\t\t\t\tif(p[j]=='+')p[j]=' ';\n\t\t\t}\n\t\t\tiss is(p);\n\t\t\tstring s;\n\t\t\twhile(is>>s){\n\t\t\t\tint A=0,B=0;\n\t\t\t\tint x=0;\n\t\t\t\twhile(x<s.sz && isdigit(s[x])){\n\t\t\t\t\tA=A*10+s[x]-'0';\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(x==0)A=1;\n\t\t\t\tif(x==s.sz){\n\t\t\t\t\ta[i][0]=A;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tassert(s[x]=='x');\n\t\t\t\tx++;\n\t\t\t\tif(x==s.sz){\n\t\t\t\t\ta[i][1]=A;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tassert(s[x]=='^');\n\t\t\t\tx++;\n\t\t\t\twhile(x<s.sz && isdigit(s[x])){\n\t\t\t\t\tB=B*10+s[x]-'0';\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\ta[i][B]=A;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi ans(51);\n\t\tint higherDeg[55][510]={};\n\t\tfor(int i=50;i>=0;i--){\n\t\t\trep(j,N)g[j].clear();\n\t\t\trep(j,M){\n\t\t\t\tif(higherDeg[from[j]][g[from[j]].sz]){\n\t\t\t\t\taddEdge(from[j],to[j],INF);\n\t\t\t\t}else{\n\t\t\t\t\taddEdge(from[j],to[j],a[j][i]);\n\t\t\t\t}\n\t\t\t\tif(higherDeg[to[j]][g[to[j]].sz]){\n\t\t\t\t\taddEdge(to[j],from[j],INF);\n\t\t\t\t}else{\n\t\t\t\t\taddEdge(to[j],from[j],a[j][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i]=maxFlow(0,N-1);\n\t\t\trep(j,N)rep(k,g[j].sz){\n\t\t\t\tif(g[j][k].type==1 && g[j][k].cap>0){\n\t\t\t\t\thigherDeg[j][k]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsst ss;\n\t\tfor(int i=50;i>=0;i--)if(ans[i]>0){\n\t\t\tif(i>1){\n\t\t\t\tif(ans[i]>1)ss<<ans[i]<<\"x^\"<<i<<\"+\";\n\t\t\t\telse ss<<\"x^\"<<i<<\"+\";\n\t\t\t}\n\t\t\telse if(i==1){\n\t\t\t\tif(ans[i]>1)ss<<ans[i]<<\"x+\";\n\t\t\t\telse ss<<\"x+\";\n\t\t\t}\n\t\t\telse ss<<ans[i]<<\"+\";\n\t\t}\n\t\tstring out=ss.str();\n\t\tif(out!=\"\")cout<<out.substr(0,out.sz-1)<<endl;\n\t\telse cout<<0<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nvi& operator+=(vi &a, const vi &b){\n\twhile(a.size() < b.size()) a.pb(0);\n\trep(i, min(a.size(), b.size())) a[i] += b[i];\n\twhile(a.size() && a.back() == 0) a.pop_back();\n\treturn a;\n}\nvi& operator-=(vi &a, const vi &b){\n\twhile(a.size() < b.size()) a.pb(0);\n\trep(i, min(a.size(), b.size())) a[i] -= b[i];\n\twhile(a.size() && a.back() == 0) a.pop_back();\n\treturn a;\n}\nvi min(const vi &a, const vi &b){\n\tif(a.size() != b.size()) return a.size() < b.size() ? a : b;\n\tfor(int i = a.size() - 1; i >= 0; i--) if(a[i] < b[i]) return a;\n\treturn b;\n}\nbool operator>(const vi &a, int b){\n\treturn a.size() && a.back() > b;\n}\nstruct flowGraph{\n\tstruct edge{\n\t\tint to, rev; \n\t\tvi cap;\n\t\tedge(int to, const vi &c, int rev) : to(to), rev(rev){\n\t\t\tcap = c;\n\t\t}\n\t};\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tflowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~flowGraph(){\n\t\tdelete iter; delete level;\n\t}\n\t\n\tvoid add(int s, int t, const vi &cap){\n\t\tG[s].pb(edge(t, cap, G[t].size()));\n\t\tG[t].pb(edge(s, vi(0), G[s].size() - 1));\n\t}\n\t\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvi dfs(int v, int t, vi f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\tvi d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vi(0);\n\t}\n\tvi max_flow(int s, int t){\n\t\tvi flow;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tvi f;\n\t\t\twhile((f = dfs(s, t, vi(51, inf))) > 0) flow += f;\n\t\t}\n\t}\n};\nvi parse(string s){\n\teach(i, s) if(*i == '+') *i = ' ';\n\tstringstream ss(s);\n\tvi v;\n\twhile(ss >> s){\n\t\tint p, e = s.find(\"x\") != s.npos;\n\t\tif((p = s.find(\"^\")) != s.npos){\n\t\t\te = atoi(s.substr(p + 1).c_str());\n\t\t}\n\t\twhile(v.size() <= e) v.pb(0);\n\t\t\n\t\tif((p = s.find(\"x\")) != s.npos) s = s.substr(0, p);\n\t\tif(s == \"\") s += \"1\";\n\t\tv[e] = atoi(s.c_str());\n\t}\n\treturn v;\n}\nint main(){\n\tint n, m, cs = 0;\n\twhile(cin >> n >> m, n){\n\t\tcs++;\n\t\tflowGraph g(n);\n\t\trep(i, m){\n\t\t\tint a, b;\n\t\t\tstring c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif(cs == 26){\n\t\t\t\tcout << a << \" \" << b << \" \" << c << endl;\n\t\t\t}\n\t\t\ta--; b--;\n\t\t\tvi v = parse(c);\n\t\t\tg.add(a, b, v);\n\t\t\tg.add(b, a, v);\n\t\t}\n\t\tvi ans = g.max_flow(0, n - 1);\n\t\tif(ans.empty()){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = ans.size() - 1; i >= 0; i--){\n\t\t\tif(ans[i] == 0) continue;\n\t\t\tif(i < ans.size() - 1) cout << \"+\";\n\t\t\tif(ans[i] != 1 || i == 0) cout << ans[i];\n\t\t\tif(i > 0) cout << \"x\";\n\t\t\tif(i > 1) cout << \"^\" << i;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define min(x,y) (x<y?x:y)\nusing namespace std;\nusing namespace rel_ops;\ntypedef vector<int> poly;\nconst int MX=50;\t\t\t//max deg\nint deg(poly x){\n\tfor(int i=MX;i>=0;i--) if(x[i]!=0) return i;\n\treturn -1;\n}\nbool operator<(poly x,poly y){\n\tfor(int i=MX;i>=0;i--){\n\t\tif(x[i]<y[i]) return 1;\n\t\tif(x[i]>y[i]) return 0;\n\t}\n\treturn 0;\n}\npoly operator+(poly x,poly y){\n\trep(i,MX+1) x[i]+=y[i];\n\treturn x;\n}\npoly operator-(poly x,poly y){\n\trep(i,MX+1) x[i]-=y[i];\n\treturn x;\n}\nvoid operator+=(poly &x,poly y){\n\trep(i,MX+1) x[i]+=y[i];\n}\nvoid operator-=(poly &x,poly y){\n\trep(i,MX+1) x[i]-=y[i];\n}\npoly operator*(poly x,poly y){\n\tpoly z(MX+1,0);\n\trep(i,MX+1) rep(j,MX+1-i) z[i+j]+=x[i]*y[j];\n\treturn z;\n}\npoly operator*(int x,poly y){\n\trep(i,MX+1) y[i]*=x;\n\treturn y;\n}\nvoid showpoly(poly x){\n\tint N=deg(x);\n\tif(N==-1){\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(x[i]==0) continue;\n\t\tif(i!=N&&x[i]>0) cout<<\"+\";\n\t\tif(x[i]==-1) cout<<\"-\";\n\t\telse if(x[i]!=1) cout<<x[i];\n\t\tif(i==0){\n\t\t\tif(x[i]==1||x[i]==-1) cout<<\"1\";\n\t\t}else if(i==1){\n\t\t\tcout<<\"x\";\n\t\t}else{\n\t\t\tcout<<\"x^\"<<i;\n\t\t}\n\t}\n\tputs(\"\");\n}\nint num(string &s,int &it){\n\tint n=1;\n\tif(s[it]=='-'){\n\t\tit++;\n\t\tn=-1;\n\t}\n\tint x=0;\n\twhile(isdigit(s[it])){\n\t\tx=x*10+s[it++]-'0';\n\t}\n\treturn x*n;\n}\npoly term(string &s,int& it){\n\tint c=1;\n\tint d=0;\n\tif(isdigit(s[it])||s[it]=='-') c=num(s,it);\n\tif(s[it]=='x'){\n\t\tit++;\n\t\td=1;\n\t\tif(s[it]=='^'){\n\t\t\tit++;\n\t\t\td=num(s,it);\n\t\t}\n\t}\n\tpoly ret(MX+1);\n\tret[d]=c;\n\treturn ret;\n}\npoly sttopoly(string s){\n\ts+=\"$\";\n\tint it=0;\n\tpoly ret=term(s,it);\n\twhile(s[it]=='+'||s[it]=='-'){\n\t\tif(s[it]=='+'){\n\t\t\tit++;\n\t\t\tret=ret+term(s,it);\n\t\t}else{\n\t\t\tit++;\n\t\t\tret=ret-term(s,it);\n\t\t}\n\t}\n\treturn ret;\n}\n\ntypedef poly D;\nstruct edge {\n\tint to;\n\tD cap;\n\tint rev;\n\tedge(int to,D cap,int rev) :to(to),cap(cap),rev(rev){}\n};\nconst int MAX_V=50;\nD inf(51),zero(51);\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from, int to, D cap){\n\tedge e1(to,cap,G[to].size()),e2(from,cap,G[from].size());\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(edge& e:G[v]){\n\t\t\tif(e.cap>zero && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nD dfs(int v,int t,D f){\n//\tcout<<v<<\"v\"<<endl;\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>zero && level[v]<level[e.to]){\n\t\t\t// cout<<\"f=\";\n\t\t\t// showpoly(f);\n\t\t\t// cout<<\"e.cap=\";\n\t\t\t// showpoly(e.cap);\n\t\t\t// cout<<\"min=\";\n\t\t\t// showpoly(min(f,e.cap));\n\t\t\t// bool b=(f<e.cap);\n\t\t\t// show(b);\n\t\t\tD d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>zero){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero;\n}\nD max_flow(int s,int t){\n\tD flow=zero;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tD f=zero;\n\t\twhile( (f=dfs(s,t,inf))>zero ) flow+=f;\n\t}\n}\nint main(){\n\tinf[50]=100000000;\n\twhile(true){\n\t\tint N,M;\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\trep(i,N) G[i].clear();\n\t\trep(i,M){\n\t\t\tint x,y;\n\t\t\tstring s;\n\t\t\tcin>>x>>y>>s;\n\t\t\tadd_edge(x-1,y-1,sttopoly(s));\n\t\t}\n\t\tshowpoly(max_flow(0,N-1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nint L = 51;\n\nstruct Edge {\n  int to, cost, rev;\n  vector<int> cap;\n  Edge(int to, int cost, vector<int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdgeF(int from, int to, int cost, vector<int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, vector<int>(L), (int)g[from].size()-1));\n}\n\ninline vector<int>& add(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] += b[i];\n  return a;\n}\n\ninline vector<int>& subtract(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] -= b[i];\n  return a;\n}\n\ninline bool lt(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return false;\n}\n\ninline bool le(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return true;\n}\n\nvector<int> dfsF(int v, int t, vector<int> f, vector<int> &used, Graph &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(!used[e.to] && lt(vector<int>(L), e.cap)) {\n      vector<int> nf;\n      if(lt(f, e.cap)) nf = f;\n      else nf = e.cap;\n      vector<int> d = dfsF(e.to, t, nf, used, g);\n      if(lt(vector<int>(L), d)) {\n\tsubtract(e.cap, d);\n\tadd(g[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>(L);\n}\n\nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0 &&\n     *min_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(abs(ans[i]) != 1) cout << abs(ans[i]);\n    if(i > 1) cout << \"x^\" << i;\n    else if(i == 1) cout << \"x\";\n    j++;\n  }\n  cout << endl;\n}\n\nvector<int> maxFlow(int s, int t, Graph g) {\n  vector<int> flow(L);\n  while(1) {\n    vector<int> used(g.size());\n    vector<int> f = dfsF(s, t, vector<int>(L, INF), used, g);\n    if(le(f, vector<int>(L))) break;\n    add(flow, f);\n  }\n  return flow;\n}\n\nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    L = 1;\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      vector<int> cap(51);\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n\tint a = 1;\n\t{\n\t  int i = 0;\n\t  while(i < s.size() && isdigit(s[i])) ++i;\n\t  if(i) {\n\t    a = atoi(s.substr(0, i).c_str());\n\t    s = s.substr(i);\n\t  }\n\t}\n\tint k = 0;\n\t// \"\" or \"x\" or \"x^y\"\n\tif(s == \"x\") {\n\t  k = 1;\n\t} else if(s.size()) {\n\t  k = atoi(s.substr(2).c_str());\n\t}\n\tL = max(L, k+1);\n\tcap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      addEdgeF(v, u, 0, cap, g);\n    }\n    for(int i = 0; i < g.size(); ++i) {\n      for(int j = 0; j < g[i].size(); ++j) {\n\tg[i][j].cap.resize(L);\n      }\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nvoid Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      for(int j=0;j<d.size();j++)\n\tif(d[j]>=INF) d[j]=0;\n      if(check(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> tmp=vector<int>(V,0);\n    tmp[0]=INF;\n    vector<int> f = dfs(s, t, tmp);\n    if(isall0(f))return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    vector<int> r=max_flow(0,n-1);\n    for(int i=0;i<r.size(); i++)\n      if(r[i]<0) r[i]=0;\n    output(r);\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<map>\n#include<utility>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[52];\nbool used[52];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back({to,cap,(int)G[to].size()});\n  G[to].push_back({from,cap,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,1e9);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  for(int N,M;cin>>N>>M,N|M;){\n    bool nz=false;\n    map<pair<int,int>,vector<int> >pols;\n    for(int i=0;i<M;i++){\n      int u,v;\n      char p[1234];\n      cin>>u>>v>>p;\n      vector<int> c(51);\n      for(char *pp=p;*pp;){\n\tint cc=1;\n\tif(*pp!='x'){\n\t  cc=strtol(pp,&pp,10);\n\t}\n\tint f=0;\n\tif(*pp){\n\t  pp++;\n\t  f=1;\n\t  if(isdigit(*pp)){\n\t    f=strtol(pp,&pp,10);\n\t  }\n\t}\n\tc[f]=cc;\n      }\n      pols[make_pair(u,v)]=c;\n    }\n    for(int i=51;i>=0;i--){\n      for(auto &e:G){\n\te.clear();\n      }\n      for(auto e:pols){\n\tadd_edge(e.first.first,e.first.second,e.second[i]);\n      }\n      int f=max_flow(1,N);\n      if(f){\n\tif(nz){\n\t  cout<<'+';\n\t}\n\tnz=true;\n\tif(f>1){\n\t  cout<<f;\n\t}\n\tif(i){\n\t  cout<<'x';\n\t  if(i>1){\n\t    cout<<i;\n\t  }\n\t}\n      }\n      for(int j=1;j<=N;j++){\n\tfor(auto e:G[j]){\n\t  auto k=make_pair(j,e.to);\n\t  if(pols.count(k)&&e.cap!=0&&e.cap!=pols[k][i]*2){\n\t    for(int l=i;l>=0;l--){\n\t      pols[k][l]=1e9;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(!nz){\n      cout<<0;\n    }\n    cout<<endl;\n  }\n}\n\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Weight weight; Capacity cap;\n\tEdge(int s, int d, Weight w, Capacity c) : src(s), dst(d), weight(w), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct FordFulkerson {\n\ttypedef vector<vector<Capacity>> Matrix;\n\tint n, t;\n\tvector<bool> vis;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tFordFulkerson(int n)\n\t\t: n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t}\n\tFordFulkerson(const Graph &graph) {\n\t\t*this = FordFulkerson(graph.size());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n\t\t}\n\t}\n\tvoid addEdge(int u, int v, Capacity c) {\n\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tCapacity solve(int s, int t) {\n\t\tthis->t = t;\n\t\tCapacity res = 0, aug = 1;\n\t\twhile(aug > 0) {\n\t\t\tvis.assign(n, false);\n\t\t\tres += (aug = augment(s, inf));\n\t\t}\n\t\treturn res;\n\t}\n\tCapacity augment(const int &v, const Capacity &lim) {\n\t\tvis[v] = true;\n\t\tif(v == t) return lim;\n\t\tfor(const int &d : g[v]) {\n\t\t\tif(vis[d] || flow[v][d] == cap[v][d]) continue;\n\t\t\tCapacity aug = augment(d, min(lim, cap[v][d] - flow[v][d]));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tif(aug > 0) return aug;\n\t\t}\n\t\treturn 0;\n\t}\n};\n\ntypedef pair<int, int> Pii;\n\nvector<int> f(string s) {\n\treplace(s.begin(), s.end(), '+', ' ');\n\t//cout << s << endl;\n\tvector<int> ret(51);\n\n\tstringstream ss(s);\n\twhile(ss >> s) {\n\t\tstringstream ss2(s);\n\t\tif(s.find('x') == string::npos) {\n\t\t\tss2 >> ret[0];\n\t\t}\n\t\telse {\n\t\t\tchar c;\n\t\t\tint a = 1, L = 1;\n\t\t\tif(s[0] != 'x') ss2 >> a;\n\t\t\tif(s.find('^') != string::npos) {\n\t\t\t\tss2 >> c >> c >> L; // x^L\n\t\t\t}\n\t\t\tret[L] = a;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint u[500];\nint v[500];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M;\n\twhile(cin >> N >> M, N) {\n\t\tmap<Pii, vector<int> > poly;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tstring p;\n\t\t\tcin >> u[i] >> v[i] >> p;\n\t\t\tu[i]--, v[i]--;\n\t\t\tpoly[Pii(u[i], v[i])] = f(p);\n\t\t}\n\n\t\tvector<int> ans(51);\n\t\tfor(int i = 50; i >= 0; i--) {\n\t\t\tGraph G(N);\n\n\t\t\tfor(auto&& p : poly) {\n\t\t\t\tint a = p.first.first, b = p.first.second, c = p.second[i];\n\t\t\t\tG[a].emplace_back(a, b, 0, c);\n\t\t\t\tG[b].emplace_back(b, a, 0, c);\n\t\t\t}\n\n\t\t\tFordFulkerson ff(G);\n\t\t\tint f = ff.solve(0, N - 1);\n\n\t\t\tans[i] = f;\n\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tint a = u[j], b = v[j];\n\t\t\t\tif(ff.flow[a][b] != 0 && ff.flow[a][b] != ff.cap[a][b]) {\n\t\t\t\t\tfor(int l = 0; l <= i; l++) {\n\t\t\t\t\t\tpoly[Pii(a, b)][l] = 1e6;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor(int i = 50; i >= 0; i--) {\n\t\t\tif(ans[i] == 0) continue;\n\t\t\tif(flag) cout << \"+\";\n\t\t\tflag = true;\n\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\tif(i != 0) cout << \"x\";\n\t\t\tif(i >= 2) cout << \"^\" << i;\n\t\t}\n\t\tif(!flag) cout << 0;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int INF = 1<<28;\nconst int L = 51;\n \nstruct Edge {\n  int to, cost, rev;\n  vector<int> cap;\n  Edge(int to, int cost, vector<int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n \ntypedef vector<vector<Edge> > Graph;\n \nvoid addEdgeF(int from, int to, int cost, vector<int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, cap, (int)g[from].size()-1));\n}\n \ninline vector<int>& add(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] += b[i];\n  return a;\n}\n \ninline vector<int>& subtract(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] -= b[i];\n  return a;\n}\n \ninline bool lt(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return false;\n}\n \ninline bool le(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return true;\n}\n \nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0 &&\n     *min_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(abs(ans[i]) != 1) cout << abs(ans[i]);\n    if(i > 1) cout << \"x^\" << i;\n    else if(i == 1) cout << \"x\";\n    j++;\n  }\n  cout << endl;\n}\n \nvector<int> dfsF(int v, int t, vector<int> f, vector<int> &used, Graph &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(!used[e.to] && lt(vector<int>(L), e.cap)) {\n      vector<int> d = dfsF(e.to, t, lt(f, e.cap) ? f : e.cap, used, g);\n      if(lt(vector<int>(L), d)) {\n        subtract(e.cap, d);\n        add(g[e.to][e.rev].cap, d);\n        return d;\n      }\n    }\n  }\n  return vector<int>(L);\n}\n \nvector<int> maxFlow(int s, int t, Graph g) {\n  vector<int> flow(L);\n  while(1) {\n    vector<int> used(g.size());\n    vector<int> f = dfsF(s, t, vector<int>(L, INF), used, g);\n    if(le(f, vector<int>(L))) break;\n    add(flow, f);\n  }\n  return flow;\n}\n \nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      vector<int> cap(L);\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n        int a = 1;\n        {\n          int i = 0;\n          while(i < s.size() && isdigit(s[i])) ++i;\n          if(i) {\n            a = atoi(s.substr(0, i).c_str());\n            s = s.substr(i);\n          }\n        }\n        int k = 0;\n        // \"\" or \"x\" or \"x^y\"\n        if(s == \"x\") {\n          k = 1;\n        } else if(s.size()) {\n          k = atoi(s.substr(2).c_str());\n        }\n        cap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      //addEdgeF(v, u, 0, cap, g);\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 1e8);\n\nPoly operator-(const Poly a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\nPoly min(const Poly &a, const Poly &b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\tif (a[i] < b[i]) return a;\n\t\telse return b;\n\t}\n\treturn b;\n}\n\ntypedef int Weight;\ntypedef Poly Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, ZERO, 0 });\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > ZERO)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > ZERO)\n\t\t\t{\n\t\t\t\te.cap = e.cap - d;\n\t\t\t\tg[e.dest][e.rev].cap = g[e.dest][e.rev].cap + d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = ZERO;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == ZERO) return flow;\n\t\tflow = f + flow;\n\t}\n}\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[50 - m] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[49] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[50] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = ford_fulkerson(g, 0, n - 1);\n\t\tstring anss;\n\t\tREP(i, ans.size())\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i < 49)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(50-i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(50-i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 49)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 50)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\nstruct Poly {\n    int a[60],md;\n    Poly() { md = 0,memset(a,0,sizeof(a)); }\n};\n\nPoly inf;\n\nbool operator<(const Poly &p,const Poly &q) {\n    if(p.md != q.md) return p.md < q.md;\n    for(int k=p.md; k>=0; --k)\n        if(p.a[k] != q.a[k]) return p.a[k] < q.a[k];\n    return false;\n}\n\nPoly minPoly(const Poly p,const Poly q) {\n    if(p < q) return p;\n    else return q;\n}\n\nPoly operator-(const Poly &p,const Poly &q) {\n    Poly ret;\n    for(int k = max(p.md,q.md); k>=0; --k) {\n        ret.a[k] = p.a[k] - q.a[k];\n        if(ret.a[k] != 0) ret.md = max(k,ret.md);\n    }\n    return ret;\n}\n\nPoly operator+(const Poly &p,const Poly &q) {\n    Poly ret;\n    for(int k=max(p.md,q.md); k>=0; --k) {\n        ret.a[k] = p.a[k] + q.a[k];\n        if(ret.a[k] != 0) ret.md = max(k,ret.md);\n    }\n    return ret;\n}\n\nstd::vector<string> splitAll(string s,string t){\n  std::vector<string> v;\n  for(int p=0; (p = s.find(t)) != s.npos; ){\n    v.push_back(s.substr(0,p));\n    s=s.substr(p+t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\nvoid parseMono(string &s,Poly &poly) {\n    // constant\n    if(s.find(\"x\") == s.npos) {\n//        cout<<\"constant \"<<atoi(s.c_str())<<endl;\n        poly.a[0] = atoi(s.c_str());\n        return;\n    }\n\n    vector<string> r = splitAll(s,\"x\");\n\n    int hoge = atoi(r[0].c_str());\n    if(r[0] == \"\") hoge = 1;\n    // linear\n    if(r[1] == \"\") {\n        poly.a[1] = hoge;\n        poly.md = max(poly.md,1);\n//        cout<<\"linear \"<<hoge<<endl;\n        return;\n    }\n\n    int dim = atoi(r[1].substr(1).c_str());\n//    cout<<dim<<\" \"<<hoge<<endl;\n    poly.a[dim] = hoge;\n    poly.md = max(poly.md,dim);\n    return;\n}\n\nPoly parse(string s) {\n    if(s.find(\"+\") == s.npos) {\n        // mono\n        Poly ret;\n        parseMono(s,ret);\n        return ret;\n    }\n\n    vector<string> p = splitAll(s,\"+\");\n\n    Poly ret;\n    for(int i=0; i<p.size(); ++i) {\n        if(p[i] == \"\") continue;\n        parseMono(p[i],ret);\n    }\n    return ret;\n}\n\nstring toStr(Poly &p) {\n    string ret = \"\";\n    bool already = false;\n    if(p.md == 0 && p.a[0] == 0) {\n        ret = \"0\";\n        return ret;\n    }\n    stringstream ss;\n    for(int k=p.md; k>=0; --k) {\n        if(p.a[k] == 0) continue;\n        if(already) ret += \"+\";\n        if(k > 0) {\n            if(p.a[k] > 1) {\n                ss << p.a[k];\n                ret += ss.str();\n                ss.str(\"\");\n            }\n            ret += \"x\";\n            if(k > 1) {\n                ret += \"^\";\n                ss << k;\n                ret += ss.str();\n                ss.str(\"\");\n            }\n        }else{\n            ss << p.a[k];\n            ret += ss.str();\n            ss.str(\"\");\n        }\n        already = true;\n    }\n\n    return ret;\n}\n\nint n,m,l;\nint u,v;\n\nPoly adj[52][52];\nbool edge[52][52];\n\nPoly maxFlow(int s,int t) {\n    Poly flow[51][51];\n    Poly total;\n\n    while(1) {\n        queue<int> Q;\n        Q.push(s);\n        vector<int> prev(51,-1);\n        prev[s] = s;\n\n        while(!Q.empty() && prev[t] < 0) {\n            int u = Q.front(); Q.pop();\n            for(int i=0; i<51; ++i) {\n                if(!edge[u][i]) continue;\n                if(prev[i] < 0 && flow[u][i] < adj[u][i]) {\n//                    cout<<u<<\" -> \"<<i<<endl;\n                    prev[i] = u;\n                    Q.push(i);\n                }\n            }\n        }\n\n        if(prev[t] < 0) return total;\n        Poly inc = inf;\n\n        for(int j=t; prev[j] != j; j = prev[j]) {\n            inc = minPoly(inc, adj[prev[j]][j]-flow[prev[j]][j]);\n        }\n        for(int j=t; prev[j] != j; j = prev[j])\n            flow[prev[j]][j] = flow[prev[j]][j] + inc,\n                flow[j][prev[j]] = flow[j][prev[j]] - inc;\n        total = total + inc;\n    }\n\n    cout<<\"hoge\"<<endl;\n    return Poly();\n}\n\nint main() {\n    inf.md = 59;\n    for(int k=inf.md; k>=0; --k) inf.a[k] = 1<<29;\n    while(cin>>n>>m, n|m) {\n        for(int i=0; i<51; ++i)\n            for(int j=0; j<51; ++j) {\n                adj[i][j] = adj[j][i] = Poly();\n                edge[i][j] = edge[j][i] = false;\n            }\n        string s;\n        for(int i=0; i<m; ++i) {\n            cin>>u>>v>>s;\n//            cout<<s<<endl;\n            Poly p = parse(s);\n            adj[u][v] = adj[v][u] = p;\n            edge[u][v] = edge[v][u] = true;\n//            cout<<toStr(p)<<endl;\n            // for(int j=0; j<50; ++i) cout<<p.a[j]<<\" \";\n            // cout<<endl;\n        }\n//        cin>>u>>v;\n        Poly p = maxFlow(1,n);\n\n//        cout<<\"Case \"<<n<<\" \"<<m<<endl;\n        cout<<toStr(p)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check3(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check3(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> tmp=vector<int>(V,INF);\n    vector<int> f = dfs(s, t, tmp);\n    if(isall0(f))return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    vector<int> r=max_flow(0,n-1);\n    for(int i=0;i<r.size(); i++)\n      if(r[i]>=2000||r[i]<0) r[i]=0;\n    output(r);\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(a[i]){\n\t\t\t\tif(i<n){\n\t\t\t\t\tret+=\"+\";\n\t\t\t\t}\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tret+=\"^\";\n\t\t\t\t\t\tret+=toString(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)+(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)-(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\n\nvoid add_edge(int from,int to,poly& cap,vve &g,const poly &Zero){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used,const poly &Zero){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used,Zero);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tconst poly Zero=to_poly(string(\"0\"));\n\tconst poly Inf=to_poly(string(\"x^51\"));\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g,Zero);\n\t\t\tadd_edge(v,u,pol,g,Zero);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used,Zero);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Weight weight; Capacity cap;\n\tEdge(int s, int d, Weight w, Capacity c) : src(s), dst(d), weight(w), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct FordFulkerson {\n\ttypedef vector<vector<Capacity>> Matrix;\n\tint n, t;\n\tvector<bool> vis;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tFordFulkerson(int n)\n\t\t: n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t}\n\tFordFulkerson(const Graph &graph) {\n\t\t*this = FordFulkerson(graph.size());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n\t\t}\n\t}\n\tvoid addEdge(int u, int v, Capacity c) {\n\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tCapacity solve(int s, int t) {\n\t\tthis->t = t;\n\t\tCapacity res = 0, aug = 1;\n\t\twhile(aug > 0) {\n\t\t\tvis.assign(n, false);\n\t\t\tres += (aug = augment(s, inf));\n\t\t}\n\t\treturn res;\n\t}\n\tCapacity augment(const int &v, const Capacity &lim) {\n\t\tvis[v] = true;\n\t\tif(v == t) return lim;\n\t\tfor(const int &d : g[v]) {\n\t\t\tif(vis[d] || flow[v][d] == cap[v][d]) continue;\n\t\t\tCapacity aug = augment(d, min(lim, cap[v][d] - flow[v][d]));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tif(aug > 0) return aug;\n\t\t}\n\t\treturn 0;\n\t}\n};\n\ntypedef pair<int, int> Pii;\n\nvector<int> f(string s) {\n\treplace(s.begin(), s.end(), '+', ' ');\n\t//cout << s << endl;\n\tvector<int> ret(51);\n\n\tstringstream ss(s);\n\twhile(ss >> s) {\n\t\tstringstream ss2(s);\n\t\tif(s.find('x') == string::npos) {\n\t\t\tss2 >> ret[0];\n\t\t}\n\t\telse {\n\t\t\tchar c;\n\t\t\tint a = 1, L = 1;\n\t\t\tif(s[0] != 'x') ss2 >> a;\n\t\t\tif(s.find('^') != string::npos) {\n\t\t\t\tss2 >> c >> c >> L; // x^L\n\t\t\t}\n\t\t\tret[L] = a;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint u[500];\nint v[500];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M;\n\twhile(cin >> N >> M, N) {\n\t\tmap<Pii, vector<int> > poly;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tstring p;\n\t\t\tcin >> u[i] >> v[i] >> p;\n\t\t\tu[i]--, v[i]--;\n\t\t\tpoly[Pii(u[i], v[i])] = f(p);\n\t\t}\n\n\t\tvector<int> ans(51);\n\t\tfor(int i = 50; i >= 0; i--) {\n\t\t\tGraph G(N);\n\n\t\t\tfor(auto&& p : poly) {\n\t\t\t\tint a = p.first.first, b = p.first.second, c = p.second[i];\n\t\t\t\tG[a].emplace_back(a, b, 0, c);\n\t\t\t\tG[b].emplace_back(b, a, 0, c);\n\t\t\t}\n\n\t\t\tFordFulkerson ff(G);\n\t\t\tint f = ff.solve(0, N - 1);\n\t\t\tans[i] = f;\n\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tint a = u[j], b = v[j];\n\t\t\t\tif(ff.flow[a][b] != 0 && ff.flow[a][b] != ff.cap[a][b]) {\n\t\t\t\t\tfor(int l = 0; l <= i; l++) {\n\t\t\t\t\t\tpoly[Pii(a, b)][l] = 1e8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor(int i = 50; i >= 0; i--) {\n\t\t\tif(ans[i] == 0) continue;\n\t\t\tif(flag) cout << \"+\";\n\t\t\tflag = true;\n\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\tif(i != 0) cout << \"x\";\n\t\t\tif(i >= 2) cout << \"^\" << i;\n\t\t}\n\t\tif(!flag) cout << 0;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e4\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      \n      for(int j=0;j<d.size();j++) assert(d[j]!=INF);\n      \n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> r=vector<int>(V,0);\n    r[0]=INF;\n    vector<int> f = dfs(s, t, r);\n    if(isall0(f)) return flow;\n    /*if(isallnotINF(f)) */Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    assert(0!=n-1);\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 55;\nconst int INF = 1 << 28;\nconst int L = 53;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\nvector<int> vec_INF = vec_zero;\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero){\n\t\t\t//cout << v << ' ' << i << ' ' << endl;\n\t\t\t//for(int j=0;j<L;j++) cout << e.cap[j] << ' '; cout << endl;\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n\t\t\t\t/*\n\t\t\t\tbool skip = false;\n        for(int j=0;j<L;j++){\n\t\t\t\t\tif(skip){\n\t\t\t\t\t\te.cap[j] = max(0, e.cap[j] - d[j]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(e.cap[j] > d[j]) skip = true;\n\t\t\t\t\te.cap[j] -= d[j];\n        }\n\t\t\t\t*/\n        for(int j=0;j<L;j++) e.cap[j] -= d[j];\n\t\t\t\t//for(int j=0;j<L;j++) cout << G[e.to][e.rev].cap[j] << ' '; cout << endl;\n\t\t\t\t//for(int j=0;j<L;j++) cout << d[j] << ' '; cout << endl;\n        for(int j=0;j<L;j++) G[e.to][e.rev].cap[j] += d[j];\n\t\t\t\t//for(int j=0;j<L;j++) cout << G[e.to][e.rev].cap[j] << ' '; cout << endl;\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vec_INF[0] = 1;\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n    if(f == vec_zero) return flow;\n    for(int j=0;j<L;j++) flow[j] += f[j];\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n\t\tG[i].clear();\n\t\tused[i] = false;\n\t}\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == 'x') x = i;\n  if(x == -1) return make_pair(0, atoi(s.c_str()));\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0) res.second = 1;\n\telse res.second = atoi(tmp.c_str());\n  int h = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == '^') res.first = atoi(s.substr(i+1).c_str());\n\tif(h == -1) res.first = 1;\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size() || s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      if(i == s.size()) break;\n\t\t\tpre = i + 1;\n    }\n  }\n  return res;\n}\n\nmain(){\n\tint V, E;\n  while(cin >> V >> E && (V|E)){\n\t\tinit();\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      vector<int> tmp = calc(s);\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n    bool first = true;\n    for(int i=L-1;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else cout << \"+\";\n      if(i == 0) cout << ans[i];\n\t\t\telse{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1) cout << \"x\";\n\t\t\t\telse cout << \"x^\" << i;\n      }\n    }\n\t\tif(first) cout << 0;\n\t\tcout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct capacity {\n  vector<int> val;\n  capacity():val(55, 0){}\n  capacity(vector<int> ini):val(ini){}\n  capacity operator + (capacity r) {\n    vector<int> res(55);\n    for(int i = 0; i < 55; i++) res[i] = val[i] + r.val[i];\n    return capacity(res);\n  }\n  capacity operator - (capacity r) {\n    vector<int> res(55);\n    for(int i = 0; i < 55; i++) res[i] = val[i] - r.val[i];\n    return capacity(res);\n  }\n  capacity operator * (int k) {\n    vector<int> res(55);\n    for(int i = 0; i < 55; i++) res[i] = val[i] * k;\n    return capacity(res);\n  }\n  capacity& operator - () {\n    for(int i = 0; i < 55; i++) val[i] = -val[i];\n    return *this;\n  }\n  bool operator == (const capacity& r) const {\n    return val == r.val;\n  }\n  bool operator < (const capacity& r) const {\n    vector<int> x = val, y = r.val;\n    reverse(all(x));\n    reverse(all(y));\n    return x < y;\n  }\n  bool operator > (const capacity& r) const {\n    vector<int> x = val, y = r.val;\n    reverse(all(x));\n    reverse(all(y));\n    return x > y;\n  }\n};\n\nconst capacity INF = capacity(vector<int>(55, inf));\nconst capacity ZERO = capacity(vector<int>(55, 0));\n\nstruct Dinic {\n  struct edge {\n    int to, rev;\n    capacity cap;\n    edge(){}\n    edge(int to, capacity cap, int rev)\n      :to(to), cap(cap), rev(rev){}\n  };\n  vector< vector<edge> > graph;\n  vector<int> level, iter;\n  Dinic(){}\n  Dinic(int V):graph(V), level(V), iter(V){}\n  void add_edge(int from, int to, capacity cap) {\n    graph[from].emplace_back(to, cap, graph[to].size());\n    graph[to].emplace_back(from, ZERO, graph[from].size()-1);\n  }\n  void bfs(int s) {\n    fill(all(level), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(que.size()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < graph[v].size(); i++) {\n\tedge& e = graph[v][i];\n\tif(e.cap > ZERO && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  capacity dfs(int v, int t, capacity f) {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < graph[v].size(); i++) {\n      edge& e = graph[v][i];\n      if(e.cap > ZERO && level[v] < level[e.to]) {\n\tcapacity d = dfs(e.to, t, min(f, e.cap));\n\tif(d > ZERO) {\n\t  e.cap = e.cap - d;\n\t  graph[e.to][e.rev].cap = graph[e.to][e.rev].cap + d;\n\t  return d;\n\t}\n      }\n    }\n    return ZERO;\n  }\n  capacity max_flow(int s, int t) {\n    capacity flow = ZERO;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      fill(all(iter), 0);\n      capacity f; while((f = dfs(s, t, INF)) > ZERO) flow = flow + f;\n    }\n  }\n};\n\ncapacity to_cap(string s) {\n  vector<char> vec;\n  s += '+';\n  for(char c : s) {\n    if(c == '+') {\n      if(vec.back() == 'x') vec.push_back('^'), vec.push_back('1');\n      else if(isdigit(vec.back())) {\n \tif(vec.size() == 1 || (vec.size() > 1 && vec[vec.size()-2] != '^')) {\n \t  vec.push_back('x');\n \t  vec.push_back('^');\n \t  vec.push_back('0');\n \t}\n      }\n    }\n    else if(c == 'x' && (vec.empty() || vec.back() == '+')) vec.push_back('1');\n    vec.push_back(c);\n  }\n  vec.pop_back();\n  string t = \"\";\n  for(char c : vec) t += c;\n  vector<int> cap(55, 0);\n  char buf[1024], a[1024], b[1024];\n  strcpy(buf, t.c_str());\n  int of = 0;\n  while(sscanf(buf + of, \"%[^x]x^%[^+]\", a, b) != EOF) {\n    of += strlen(a) + 2 + strlen(b);\n    cap[atoi(b)] = atoi(a);\n  }\n  return capacity(cap);\n}\n\nstring to_str(capacity cap) {\n  string res = \"\";\n  bool flag = false;\n  rep(i, cap.val.size()) {\n    if(cap.val[i] != 0) {\n      string tmp = (i && cap.val[i] == 1 ? \"\" : to_string(cap.val[i]));\n      if(i > 0) tmp += \"x\";\n      if(i > 1) tmp += \"^\"+to_string(i);\n      if(flag) tmp = tmp + \"+\";\n      res = tmp + res;\n      flag = true;\n    }\n  }\n  return (res == \"\" ? \"0\" : res);\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M;\n  while(cin >> N >> M, N || M) {\n    Dinic graph(N);\n    rep(i, M) {\n      int u, v;\n      string p;\n      cin >> u >> v >> p;\n      --u, --v;\n      capacity c = to_cap(p);\n      // rep(j, 4) cout << c.val[j] << \" \";\n      // cout << endl;\n      graph.add_edge(u, v, c);\n      graph.add_edge(v, u, c);\n    }\n    capacity res = graph.max_flow(0, N-1);\n    //cout << \"rem\" << endl;\n    // rep(i, graph.graph.size()) {\n    //   cout << i << \" : \" << endl;\n    //   rep(j, graph.graph[i].size()) {\n    //  \tcout << graph.graph[i][j].to << \"\\\\\";\n    //  \trep(k, 5) cout << graph.graph[i][j].cap.val[k] << \" \";\n    //  \tcout << endl;\n    //   }\n    //   cout << endl;\n    // }\n    //cout <<\"ans\" << endl;\n    //rep(j, 4) cout << res.val[j] << \" \";\n    //cout << endl;\n    cout << to_str(res) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct Poly {\n    map<int, int> coefs;\n    vi coefs_freeze;\n\n    int& operator [](int n) {\n        return coefs[n];\n    }\n\n    Poly& operator +=(Poly q) {\n        for (auto& kv : q.coefs) {\n            coefs[kv.first] += q[kv.first];\n        }\n        return *this;\n    }\n\n    Poly& operator *=(Poly q) {\n        Poly p;\n        for (auto& kv1 : coefs) {\n            int n = kv1.first;\n            int a = coefs[n];\n            for (auto& kv2 : q.coefs) {\n                int m = kv2.first;\n                int b = q.coefs[m];\n                Poly w;\n                w[n+m] = a*b;\n                p += w;\n            }\n        }\n        coefs = p.coefs;\n        return *this;\n    }\n\n    Poly& operator ^=(int n) {\n        Poly p;\n        p.coefs = coefs;\n        REP(i, n-1) {\n            *this *= p;\n        }\n        return *this;\n    }\n\n    string dump() {\n        stringstream ss;\n        bool first = true;\n        for (auto it = coefs.rbegin(); it != coefs.rend(); it++) {\n            if (!first) {\n                ss << \"+\";\n            } else {\n                first = false;\n            }\n            int a = it->second;\n            int n = it->first;\n            if (a > 1 || n == 0) ss << a;\n            if (n != 0) {\n                ss << \"x\";\n                if (n > 1) {\n                    ss << \"^\" << n;\n                }\n            }\n        }\n        string ret = ss.str();\n        if (ret.length() == 0) {\n            return \"0\";\n        }\n        return ret;\n    }\n\n    void freeze() {\n        coefs_freeze.resize(51);\n        REP(i, 51) {\n            if (EXIST(coefs, i)) {\n                coefs_freeze[i] = coefs[i];\n            }\n        }\n    }\n\n    bool operator <(const Poly& p) const {\n        RREP(i, 51) {\n            if (coefs_freeze[i] != p.coefs_freeze[i]) {\n                return coefs_freeze[i] < p.coefs_freeze[i];\n            }\n        }\n        return true;\n    }\n};\n\n/*\n * BNF??????\n *\n * number     := [0-9] | number\n * primary    := 'x' | number\n * factor     := primary | primary '^' number\n * term       := factor | number factor\n * expression := term | term '+' term\n *\n */\n\nint number(string& s, int& idx) {\n    int n = 0;\n    while (isdigit(s[idx])) {\n        n *= 10;\n        n += s[idx] - '0';\n        idx++;\n    }\n    return n;\n}\n\nPoly primary(string& s, int& idx) {\n    Poly p;\n    if (s[idx] == 'x') {\n        idx++;\n        p[1] = 1;\n    } else {\n        p[0] = number(s, idx);\n    }\n    return p;\n}\n\nPoly factor(string& s, int& idx) {\n    Poly p = primary(s, idx);\n    if (s[idx] == '^') {\n        idx++;\n        int n = number(s, idx);\n        p ^= n;\n    }\n    return p;\n}\n\nPoly term(string& s, int& idx) {\n    Poly p;\n    p[0] = 1;\n    for (; idx < (int)s.length();) {\n        if (s[idx] == '+') {\n            break;\n        }\n        p *= factor(s, idx);\n    }\n    return p;\n}\n\nPoly expression(string& s, int& idx) {\n    Poly p;\n    for (; idx < (int)s.length();) {\n        if (s[idx] == '+') {\n            idx++;\n        }\n        p += term(s, idx);\n    }\n    return p;\n}\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N | M) {\n        vector<Poly> ps(N);\n        REP(i, M) {\n            int u, v;\n            string s;\n            cin >> u >> v >> s;\n            u--;\n            v--;\n            int idx = 0;\n            Poly p = expression(s, idx);\n            ps[u] += p;\n            ps[v] += p;\n        }\n        REP(i, N) {\n            ps[i].freeze();\n        }\n        SORT(ps);\n        cout << ps[0].dump() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 50;\nconst int INF = 1 << 28;\nconst int L = 52;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero){\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n\t\t\t\tbool zero = false;\n        //e.cap -= d;\n        for(int j=0;j<L;j++){\n\t\t\t\t\tif(e.cap[j] - d[j] > 0){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(zero) e.cap[j] = 0;\n\t\t\t\t\telse{\n\t\t\t\t\t\te.cap[j] -= d[j];\n\t\t\t\t\t}\n\n        }\n        //G[e.to][e.rev].cap += d;\n        for(int j=0;j<L;j++){\n          G[e.to][e.rev].cap[j] += d[j];\n        }\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vector<int> vec_INF = vec_zero;\n  vec_INF[0] = 1;\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n/*\n\t\tfor(int j=0;j<L;j++){\n\t\t\tcout << f[j] << ' ';\n\t\t}\n\t\tcout << endl;\n*/\n    if(f == vec_zero) return flow;\n/*\n\t\tcout << \"*\"\n\t\tfor(int j=0;j<L;j++){\n\t\t\tcout << f[j] << ' ';\n\t\t}\n\t\tcout << endl;\n*/\n    //flow += f;\n    for(int j=0;j<L;j++){\n      flow[j] += f[j];\n    }\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n    G[i].clear();\n  }\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++){\n    if(s[i] == 'x'){\n      x = i;\n    }\n  }\n  if(x == -1){\n    return make_pair(0, atoi(s.c_str()));\n  }\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0){\n\t\tres.second = 1;\n\t}else{\n\t\tres.second = atoi(tmp.c_str());\n\t}\n  int h = -1;\n  for(int i=0;i<s.size();i++){\n    if(s[i] == '^'){\n      res.first = atoi(s.substr(i+1).c_str());\n    }\n  }\n\tif(h == -1){\n\t\tres.first = 1;\n\t}\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size()){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      break;\n    }\n    if(s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      pre = i + 1;\n    }\n  }\n  return res;\n}\n\nint V, E;\n\nmain(){\n  while(cin >> V >> E && (V|E)){\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      //cout << i << endl;\n      vector<int> tmp = calc(s);\n\t\t\t//for(int i=0;i<10;i++) cout << tmp[i] << ' '; cout << endl;\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n/*\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tcout << ans[i] << ' ';\n\t\t}\n\t\tcout << endl;\n*/\n    bool first = true;\n    for(int i=L-1;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else{\n        cout << \"+\";\n      }\n      if(i == 0){\n        cout << ans[i];\n      }else{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1){\n\t\t\t\t\tcout << \"x\";\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"x^\" << i;\n\t\t\t\t}\n      }\n    }\n    if(first){\n      cout << 0 << endl;\n    }else{\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring toStr(int n)\n{\n\tchar buf[50];\n\tsprintf(buf, \"%d\", n);\n\treturn buf;\n}\n\nstruct poly{\n\tint a[55];\n\tpoly(){\n\t\tfor(int i = 0; i <= 50; i++) a[i] = 0;\n\t}\n\tpoly(string s)\n\t{\n\t\tfor(int i = 0; i <= 50; i++) a[i] = 0;\n\t\t\n\t\ts = s + \"+\";\n\t\tstring buf;\n\t\tint state = 0, coe;\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tif(state == 0){\n\t\t\t\tif(s[i] == 'x'){\n\t\t\t\t\tif(buf == \"\") buf = \"1\";\n\t\t\t\t\tcoe = atoi(buf.c_str());\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\t\t\t\telse if(s[i] == '+'){\n\t\t\t\t\ta[0] = atoi(buf.c_str());\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbuf += s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(state == 1){\n\t\t\t\tif(s[i] == '^'){\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse if(s[i] == '+'){\n\t\t\t\t\ta[1] = coe;\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(state == 2){\n\t\t\t\tif(s[i] == '+'){\n\t\t\t\t\ta[atoi(buf.c_str())] = coe;\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbuf += s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstring output()\n\t{\n\t\tstring ret;\n\t\tfor(int i = 50; i > 0; i--){\n\t\t\tif(a[i] == 0) continue;\n\t\t\tif(a[i] != 1) ret += toStr(a[i]);\n\t\t\tret += \"x\";\n\t\t\tif(i > 1) ret += \"^\" + toStr(i);\n\t\t\tret += \"+\";\n\t\t}\n\t\tif(ret.size() > 0){\n\t\t\tif(a[0] == 0) ret.erase(ret.end()-1);\n\t\t\telse ret += toStr(a[0]);\n\t\t}\n\t\telse ret = toStr(a[0]);\n\t\treturn ret;\n\t}\n\tpoly operator+(const poly& obj)\n\t{\n\t\tpoly ret;\n\t\tfor(int i = 0; i <= 50; i++){\n\t\t\tret.a[i] = a[i] + obj.a[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpoly operator-(const poly& obj)\n\t{\n\t\tpoly ret;\n\t\tfor(int i = 0; i <= 50; i++){\n\t\t\tret.a[i] = a[i] - obj.a[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tbool operator<(const poly& obj)const\n\t{\n\t\tfor(int i = 50; i >= 0; i--){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator<=(const poly& obj)const\n\t{\n\t\tfor(int i = 50; i >= 0; i--){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\n\nstruct edge{\n\tint to, rev;\n\tpoly cap;\n\tedge(int a, string b, int c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nint N, M;\nvector<edge> G[205];\nint S, T;\nbool used[205];\nconst poly zero, inf(\"10000000x^50\");\n\npoly dfs(int v, poly f)\n{\n\tused[v] = true;\n\tif(v == T) return f;\n\t\n\tpoly ret;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap <= zero) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(zero < ret){\n\t\t\tG[v][i].cap = G[v][i].cap - ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap = G[G[v][i].to][G[v][i].rev].cap + ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn zero;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= N; i++) G[i].clear();\n\t\t\n\t\tint u, v; string s;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> u >> v >> s;\n\t\t\tG[u].push_back(edge(v, s, G[v].size()));\n\t\t\tG[v].push_back(edge(u, \"\", G[u].size()-1));\n\t\t\tG[v].push_back(edge(u, s, G[u].size()));\n\t\t\tG[u].push_back(edge(v, \"\", G[v].size()-1));\n\t\t}\n\t\tS = 1, T = N;\n\t\t\n\t\tpoly ans, flow;\n\t\twhile(1){\n\t\t\tfor(int i = 1; i <= T; i++) used[i] = false;\n\t\t\tflow = dfs(S, inf);\n\t\t\tif(flow <= zero) break;\n\t\t\tans = ans + flow;\n\t\t}\n\t\t\n\t\tcout << ans.output() << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 1e8);\n\nPoly operator-(const Poly a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\nPoly min(const Poly &a, const Poly &b)\n{\n\tREP(i, 51)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\tif (a[i] < b[i]) return a;\n\t\telse return b;\n\t}\n\treturn b;\n}\n\ntypedef int Weight;\ntypedef Poly Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, ZERO, 0 });\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > ZERO)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > ZERO)\n\t\t\t{\n\t\t\t\te.cap = e.cap - d;\n\t\t\t\tg[e.dest][e.rev].cap = g[e.dest][e.rev].cap + d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = ZERO;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == ZERO) return flow;\n\t\tflow = f + flow;\n\t}\n}\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[50 - m] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[49] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[50] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = ford_fulkerson(g, 0, n - 1);\n\t\tstring anss;\n\t\tREP(i, ans.size())\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i < 49)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(50-i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(50-i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 49)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 50)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool resflag[50][50];\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\nWeight edmonds_karp(Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix flow(n, Array(n)), capacity(n, Array(n));\n  REP(u,n) FOR(e,g[u]) capacity[e->src][e->dst] += e->weight;\n  \n  Weight total = 0;\n  while(1) {\n    queue<int> Q; Q.push(s);\n    vector<int> prev(n, -1); prev[s] = s;\n    while(!Q.empty() && prev[t] < 0) { // s ツつゥツづァ t ツづ鳴猟ャツつケツづゥツ路ツづーBFSツづ個ゥツづつつッツづゥツ。\n      int u = Q.front(); Q.pop();\n      REP(v, n) if (prev[v] < 0 && RESIDUE(u, v) > 0) { // Spaghetti Source ツづ陛渉つヲツつスツ。\n        prev[v] = u;\n        Q.push(v);\n      }\n    }\n    if (prev[t] < 0) break;\n    Weight inc = INF;\n    for (int j=t; prev[j]!=j; j=prev[j])\n      inc = min(inc, RESIDUE(prev[j], j));\n    for (int j=t; prev[j]!=j; j=prev[j])\n      flow[prev[j]][j] += inc, flow[j][prev[j]] -= inc; // ツ逆ツ陛督づ掲low ツつゥツづァツ暗クツつュツつアツづづ可淞つオツ姪淞つケツづゥツづヲツつ、ツづ可つキツづゥツ。\n    // ツづつづ慊づィツ、flow ツつェツ猟ャツづェツつスツづつアツづォツづ個逆ツ古シツつォツづ個陛督づ可甘鳴つオツづСESIDUE ツつェツつサツづ個閉ェツ妥・ツつォツつュツづ按づゥツ。\n    total += inc;\n  }\n  REP(i, n) {\n    REP(j, i) {\n      if (RESIDUE(i,j)&&RESIDUE(j,i)) {\n        resflag[i][j] = 1;\n        resflag[j][i] = 1;\n      }\n    }\n  }\n  return total;\n}\ntypedef pair<int,int> pii;\npii func(string s) {\n  int a, b=INF;\n  REP(i, s.size()) {\n    if (s[i]=='x') {\n      if(i==0) {\n        b = 1;\n      } else {\n        b = atoi(s.substr(0, i).c_str());\n      }\n      if (s[i+1]=='^') {\n        a = atoi(s.substr(i+2).c_str());\n      } else {\n        a = 1;\n      }\n    }\n  }\n  if (b == INF) {\n    b = atoi(s.c_str());\n    a = 0;\n  }\n  return pii(a,b);\n}\nvoid parse(string s, int *arr) {\n  int last = 0;\n  REP(i, s.size()) {\n    if (s[i] == '+') {\n      pii p = func(s.substr(last, i-last));\n      arr[p.first] = p.second;\n      last = i+1;\n    }\n  }\n  pii p = func(s.substr(last));\n  arr[p.first] = p.second;\n\n  // cout << s << endl;\n  // REP(i, 51) {\n  //   cout << arr[i] << \" \";\n  // }\n  // cout << endl;\n}\n\nint main() {\n  int n,m;\n  while(cin>>n>>m,n||m) {\n    int a[m][51];\n    memset(a, 0, sizeof(a));\n    int s[m], t[m];\n    REP(i, m) {\n      cin >> s[i] >> t[i];\n      s[i]--; t[i]--;\n      string ss;\n      cin >> ss;\n      parse(ss, a[i]);\n    }\n    int res[51];\n    memset(resflag, 0, sizeof(resflag));\n    for (int i=50; i>=0; --i) {\n      Graph g(n);\n      REP(j, m) {\n        int wei = a[j][i];\n        if (resflag[s[j]][t[j]]) {\n          wei = INF;\n        }\n        g[s[j]].push_back(Edge(s[j], t[j], wei));\n        g[t[j]].push_back(Edge(t[j], s[j], wei));\n      }\n      res[i] = edmonds_karp(g, 0, n-1);\n      //cout << res[i] << endl;\n    }\n    string ans;\n    bool f = 0;\n    for (int i=50; i>=0; --i) {\n      if (res[i]) {\n        if (f) ans+=\"+\";\n        f = 1;\n        stringstream ss;\n        ss<<res[i];\n        if (res[i] > 1 || i==0)\n          ans+=ss.str();\n        if (i>=2) {\n          stringstream ss2;\n          ss2<<i;\n          ans+=\"x^\"+ss2.str();\n        } else if(i==1)\n          ans += \"x\";\n      }\n    }\n    if (!f) {\n      ans = \"0\";\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<map>\n#include<utility>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[52];\nbool used[52];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back({to,cap,(int)G[to].size()});\n  G[to].push_back({from,cap,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,1e9);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  for(int N,M;cin>>N>>M,N|M;){\n    bool nz=false;\n    map<pair<int,int>,vector<int> >pols;\n    for(int i=0;i<M;i++){\n      int u,v;\n      char p[1234];\n      cin>>u>>v>>p;\n      vector<int> c(51);\n      for(char *pp=p;*pp;){\n\tint cc=1;\n\tif(*pp!='x'){\n\t  cc=strtol(pp,&pp,10);\n\t}\n\tint f=0;\n\tif(*pp){\n\t  pp++;\n\t  f=1;\n\t  if(isdigit(*pp)){\n\t    f=strtol(pp,&pp,10);\n\t  }\n\t}\n\tc[f]=cc;\n      }\n      pols[make_pair(u,v)]=c;\n    }\n    for(int i=51;i>=0;i--){\n      for(auto &e:G){\n\te.clear();\n      }\n      for(auto e:pols){\n\tadd_edge(e.first.first,e.first.second,e.second[i]);\n      }\n      int f=max_flow(1,N);\n      if(f){\n\tif(nz){\n\t  cout<<'+';\n\t}\n\tnz=true;\n\tif(f>1){\n\t  cout<<f;\n\t}\n\tif(i){\n\t  cout<<'x';\n\t  if(i>1){\n\t    cout<<i;\n\t  }\n\t}\n      }\n      for(int j=1;j<=N;j++){\n\tfor(auto e:G[j]){\n\t  auto k=make_pair(j,e.to);\n\t  if(pols.count(k)&&e.cap!=0&&e.cap!=pols[k][i]*2){\n\t    for(int l=i;l>=0;l--){\n\t      pols[k][l]=1e9;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(!nz){\n      cout<<0;\n    }\n    cout<<endl;\n  }\n}\n\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(a[i]){\n\t\t\t\tif(i<n){\n\t\t\t\t\tret+=\"+\";\n\t\t\t\t}\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tret+=\"^\";\n\t\t\t\t\t\tret+=toString(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)+(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)-(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\n\nvoid add_edge(int from,int to,poly& cap,vve &g,const poly &Zero){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used,const poly &Zero){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used,Zero);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tconst poly Zero=to_poly(string(\"0\"));\n\tconst poly Inf=to_poly(string(\"x^51\"));\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g,Zero);\n\t\t\tadd_edge(v,u,pol,g,Zero);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used,Zero);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 100\nusing namespace std;\ntypedef vector<int> V;\nconst V zero(51,0);\nstruct edge{\n  int to,rev;\n  V cap;\n  edge();\n  edge(int to,V cap,int rev):to(to),cap(cap),rev(rev){};\n};\n\nbool compare (const V &a,const V &b){\n  for(int i=a.size()-1;i>=0;i--)if(a[i]!=b[i])return a[i]<b[i];\n  return 0;\n}\nV min(V &a,V &b){return compare(a,b)? a:b;}\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,V cap){\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,cap,G[from].size()-1));  \n}\n\nvoid add(V &a,V &b){for(int i=0;i<(int)a.size();i++)a[i]+=b[i];}\nvoid sub(V &a,V &b){for(int i=0;i<(int)a.size();i++)a[i]-=b[i];}\n\n//?¢?????????????DFS??§??¢???\nV dfs(int v,int t,V f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap != zero){\n      V d = dfs(e.to ,t , min(f,e.cap));\n      if(d != zero){\n\tsub(e.cap,d);\n\tadd(G[e.to][e.rev].cap,d);\n\treturn d;\n      }\n    }\n  }\n  return zero;\n}\n\n//s??????t???????????§???????±???????\nV max_flow(int s,int t){\n  V flow=V(51,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    V f = dfs(s, t, V(51,1e4));\n    if(f == zero)return flow;\n    add(flow,f);\n  }\n}\n\n\nint StoI(string &a,int &i){\n  int res=0;\n  while(isdigit(a[i])) res=res*10+a[i++]-'0';\n  return res;\n}\n\nstring ItoS(int a){\n  string res;\n  while(a) res=char(a%10+'0')+res,a/=10;\n  if(res.empty()) res=\"0\";\n  return res;\n}\n\nV StoV(string s){\n  V res(51);\n  if(s==\"0\") return zero;\n  for(int i=0;i<s.size();i++){\n    int a = max(1,StoI(s,i));\n    int L = 0;\n    if(s[i]=='x')i+=1+(s[i+1]=='^'),L=max(1,StoI(s,i));\n    res[L] = a;\n  }\n  return res;\n}\n\nstring VtoS(V a){\n  string res;\n  for(int i=a.size()-1;i>=0;i--){\n    if(a[i]==0)continue;\n    if(!res.empty()) res+='+';\n    if(a[i]>1||i==0) res+=ItoS(a[i]);\n    if(i)res+='x';\n    if(i>1) res+='^'+ItoS(i);\n  }\n  if(res.empty()) res=\"0\";\n  return res;\n}\n\nint main(){\n  while(1){\n  int n,m;\n  cin>>n>>m;\n  if(!n&&!m) return 0;\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  for(int i=0,a,b;i<m;i++){\n    string c;\n    cin>>a>>b>>c;\n    V vc = StoV(c);\n    add_edge(a-1,b-1,vc);\n  }\n\n  V ans = max_flow(0,n-1);\n  cout<<VtoS(ans)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e4\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> r=vector<int>(V,0);\n    r[0]=INF;\n    vector<int> f = dfs(s, t, r);\n    if(isall0(f)) return flow;\n    /*if(isallnotINF(f)) */Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    assert(0!=n-1);\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint number(string s) {\n    int ret = 0, pos = 0;\n    while (pos < (int)s.size() && isdigit(s[pos])) {\n        ret = ret * 10 + (s[pos] - '0');\n        pos++;\n    }\n    return ret;\n}\n\nclass Capacity {\npublic:\n    int coef[102] = {};\n    int dim = 0;\n\n    Capacity(){};\n    Capacity(string s) {\n        int prev_pos = 0;\n        int x_pos = -1, pow_pos = -1;\n        for (int i = 0; i <= (int)s.size(); i++) {\n            if (i == (int)s.size() || s[i] == '+') {\n                auto term = s.substr(prev_pos, i-prev_pos);\n\n                int c = 1;\n                if (x_pos != prev_pos) c = number(term);\n\n                int d = 0;\n                if (pow_pos != -1) d = number(term.substr(pow_pos-prev_pos+1));\n                else if (x_pos != -1) d = 1;\n\n                coef[d] = c;\n                dim = max(dim, d);\n\n                x_pos = -1, pow_pos = -1;\n                prev_pos = i + 1;\n            } else if (s[i] == 'x') {\n                x_pos = i;\n            } else if (s[i] == '^') {\n                pow_pos = i;\n            }\n        }\n    }\n    bool is_zero(){\n        return (dim == 0 && coef[0] == 0);\n    }\n\n    void output() {\n        string ret = \"\";\n        for (int i = dim; i >= 0; i--) {\n            if (coef[i] == 0 && ret.size() > 0)\n                continue;\n\n            if (ret.size() && coef[i] >= 0) ret += \"+\";\n            if (coef[i] > 1 || (i == 0 && coef[i] == 1) || (i == 0 && ret.size() == 0))\n                ret += to_string(coef[i]);\n            if (i != 0) ret += \"x\";\n            if (i > 1){\n                ret += \"^\";\n                ret += to_string(i);\n            }\n        }\n        cout << ret << endl;\n    }\n};\nCapacity operator+(const Capacity &lv, const Capacity &rv) {\n    Capacity ret;\n    int dim = max(lv.dim, rv.dim);\n    for (int i = 0; i <= dim; i++) {\n        ret.coef[i] = lv.coef[i] + rv.coef[i];\n    }\n    ret.dim = dim;\n    return ret;\n}\nCapacity operator-(const Capacity &lv, const Capacity &rv) {\n    Capacity ret;\n\n    int dim = max(lv.dim, rv.dim);\n    bool erase = true;\n    for (int i = dim; i >= 0; i--) {\n        ret.coef[i] = lv.coef[i] - rv.coef[i];\n\n        if (erase && ret.coef[i] == 0) dim--;\n        else erase = false;\n    }\n    if (dim < 0) dim = 0;\n    ret.dim = dim;\n    return ret;\n}\nbool operator>(const Capacity &lv, const Capacity &rv) {\n    if (lv.dim != rv.dim) return lv.dim > rv.dim;\n    for (int i = lv.dim; i >= 0; i--) {\n        if (lv.coef[i] == rv.coef[i])\n            continue;\n        return lv.coef[i] > rv.coef[i];\n    }\n    return false;\n}\nCapacity min(Capacity &a, Capacity &b) {\n    if (a > b) return b;\n    return a;\n}\n\nstruct edge {\n    int to;\n    Capacity cap;\n    int rev;\n};\n\nint N, M;\nvector<vector<edge>> G;\nbool used[51];\nCapacity max_cap(\"101x^101\");\n\nvoid add_edge(int from, int to, const Capacity &cap) {\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, Capacity(), (int)G[from].size() - 1});\n}\n\nCapacity dfs(int v, int t, Capacity f) {\n    if (v == N-1) return f;\n    used[v] = true;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && !e.cap.is_zero()) {\n            Capacity d = dfs(e.to, t, min(f, e.cap));\n            if (!d.is_zero()) {\n                e.cap = e.cap - d;\n                G[e.to][e.rev].cap = G[e.to][e.rev].cap + d;\n                return d;\n            }\n        }\n    }\n    return Capacity();\n}\n\nint main() {\n    while (cin >> N >> M, N + M) {\n        G = vector<vector<edge>>(N);\n        for (int i = 0; i < M; i++) {\n            int from, to; string exp;\n            cin >> from >> to >> exp;\n            from--, to--;\n            add_edge(from, to, Capacity(exp));\n            add_edge(to, from, Capacity(exp));\n        }\n\n        Capacity flow;\n        while (true)\n        {\n            memset(used, false, sizeof(used));\n            Capacity f = dfs(0, N-1, max_cap);\n            if (f.is_zero()) break;\n            flow = flow + f;\n        }\n        flow.output();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconstexpr int MAX_V = 55;\nconstexpr int INF = (1 << 29);\n\nstruct CAP {\n    vector<int> c;\n \n    CAP () { c = vector<int>(51); }\n    \n    CAP (int v) {\n        c = vector<int>(51, v);\n    }\n     \n    bool operator < (const CAP& w) const {\n        return c > w.c;\n    }\n \n    bool operator > (const CAP& w) const {\n        return c > w.c;\n    }\n\n    bool operator == (const CAP& w) const {\n        return c == w.c;\n    }\n     \n    CAP& operator += (const CAP& w) {        \n        for (int i = 0; i < 51; i++) {\n            c[i] += w.c[i];\n        }\n        return *this;\n    }    \n    \n    CAP& operator -= (const CAP& w) {        \n        for (int i = 0; i < 51; i++) {\n            c[i] -= w.c[i];\n        }\n        return *this;\n    }    \n};\n\nCAP min_cap(const CAP& a, const CAP& b)\n{\n    for (int i = 0; i <= 50; i++) {\n        if (a.c[i] < b.c[i]) {\n            return a;\n        } else if (a.c[i] > b.c[i]) {\n            return b;\n        }\n    }\n    return a;\n}\n\nstruct edge {\n    int to;\n    CAP cap;\n    int rev;    \n    edge(int to, CAP cap, int rev) :\n        to{to}, cap{cap}, rev{rev} {}\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, CAP cap)\n{\n    G[from].emplace_back(to, cap, G[to].size());\n    G[to].emplace_back(from, CAP(0), G[from].size() - 1);\n}\n\nvoid print(const CAP& c)\n{\n    for (int i = 0; i < c.c.size(); i++) {\n        cout << c.c[i] << \" \";\n    }\n    cout << endl;\n}\n\n\nCAP dfs(int v, int t, const CAP& f)\n{\n    if (v == t) return f;\n    used[v] = 1;    \n    for (int i = 0; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > CAP(0)) {\n            CAP d = dfs(e.to, t, min_cap(f, e.cap));\n            if (d > CAP(0)) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return CAP(0);\n}\n\nCAP max_flow(int s, int t)\n{\n    CAP flow;\n    for (;;) {\n        memset(used, 0, sizeof(used));\n        CAP f = dfs(s, t, CAP(INF));\n        if (f == CAP(0)) return flow;        \n        flow += f;\n    }\n}\n\nvoid init(int N)\n{\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n    }\n}\n\npair<int, int> get_num(const string& s)\n{\n    int j = -1;\n    int N = s.size();\n    for (int i = 0; i < N; i++) {\n        if (s[i] == 'x') {\n            j = i;\n            break;\n        }\n    }\n    if (j == -1) {\n        return {50, stoi(s)};\n    } else {\n        int v = (j + 1 == N ? 1 : stoi(s.substr(j + 2)));\n        return {50 - v, (j == 0 ? 1 : stoi(s.substr(0, j)))};\n    }   \n}\n\nCAP get_cap(const string& p)\n{\n    CAP cap;\n    string s;\n    for (auto& v : p) {\n        if (v == '+') {\n            auto r = get_num(s);\n            cap.c[r.first] = r.second;\n            s.clear();\n        } else {\n            s += v;\n        }\n    }\n\n    if (!s.empty()) {\n        auto r = get_num(s);\n        cap.c[r.first] = r.second;\n    }        \n    return cap;\n}\n\nint main()\n{\n    int N, M;\n    while (1) {\n        cin >> N >> M;\n        if (N == 0 && M == 0) break;\n\n        init(N);\n        \n        int S = 0, T = N - 1;\n        int u, v;\n        string p;\n        for (int i = 0; i < M; i++) {\n            cin >> u >> v >> p;\n            u--; v--;\n            CAP c = get_cap(p);\n            add_edge(u, v, c);\n            add_edge(v, u, c);\n        }\n\n        auto f = max_flow(S, T);\n        \n        vector<pair<int, int>> res;\n        for (int i = 0; i <= 50; i++) {\n            if (f.c[i] > 0) {\n                res.emplace_back(f.c[i], 50 - i);              \n            }\n        }\n\n        if (res.size() == 0) {\n            cout << 0 << endl;\n        } else {\n            for (int i = 0; i < (int)res.size(); i++) {\n                if (i > 0) cout << \"+\";\n                if (res[i].second == 0 || res[i].first != 1) {\n                    cout << res[i].first;   \n                }\n                if (res[i].second != 0) {\n                    cout << \"x\";\n                    if (res[i].second > 1) {\n                        cout << \"^\" << res[i].second;\n                    }\n                }\n            }\n            cout << endl;\n        }\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,rev;\n\tvector<int> cap;\n\tedge(){}\n\tedge(int tt,vector<int> cc,int rr){\n\t\tto=tt;\n\t\trev=rr;\n\t\tcap.resize(cc.size());\n\t\tfor(int i=0;i<cc.size();i++){\n\t\t\tcap[i]=cc[i];\n\t\t}\n\t}\n};\n\nclass dinic{\npublic:\n\tconst int INF=100000;\n\tvector<edge> G[501];\n\tint level[501];\n\tint iter[501];\n\tvoid add_edge(int from,int to,vector<int> cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,cap,G[from].size()-1));\n\t}\n\n\tbool checkemp(vector<int> &cap){\n\t\tint s=cap.size();\n\t\tfor(int i=s-1;i>=0;i--){\n\t\t\tif(cap[i]>0)return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvector<int> getmin(vector<int> a,vector<int> b){\n\t\tvector<int> c(a.size());\n\t\tfor(int i=(int)a.size()-1;i>=0;i--){\n\t\t\tif(a[i]<b[i])return a;\n\t\t\tif(a[i]>b[i])return b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tvoid bfs(int s){\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(!checkemp(e.cap) && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dfs(int v,int t,vector<int> f){\n\t\tif(v==t)return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(!checkemp(e.cap) && level[v]<level[e.to]){\n\t\t\t\tvector<int> d=dfs(e.to,t,getmin(f,e.cap));\n\t\t\t\tif(!checkemp(d)){\n\t\t\t\t\tfor(int j=0;j<e.cap.size();j++){\n\t\t\t\t\t\te.cap[j]-=d[j];\n\t\t\t\t\t\tG[e.to][e.rev].cap[j]+=d[j];\n\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> zer(f.size(),0);\n\t\treturn zer;\n\t}\n\tvector<int> max_flow(int s,int t,int size){\n\t\tvector<int> flow(size,0);\n\t\tvector<int> alINF(size,INF);\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\tvector<int> f;\n\t\t\twhile(!checkemp(f=dfs(s,t,alINF))){\n\t\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\t\tflow[i]+=f[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nstring get_string(int v){\n\tstring ret=\"\";\n\twhile(v>0){\n\t\tret+=('0'+v%10);\n\t\tv/=10;\n\t}\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\n\n\ndinic di;\n\nint n,m;\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdi.G[i].clear();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v;\n\t\t\tstring str;\n\t\t\tcin >> u >> v >> str;\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tint digit=0;\n\t\t\tvector<int> tp(51,0);\n\t\t\tfor(int j=0;j<str.size();j++){\n\t\t\t\tif(str[j]>='0' && str[j]<='9'){\n\t\t\t\t\tdigit*=10;\n\t\t\t\t\tdigit+=(str[j]-'0');\n\t\t\t\t}else if(str[j]=='x'){\n\t\t\t\t\tif(digit==0)digit=1;\n\t\t\t\t\tif(j+1<str.size() && str[j+1]=='^'){\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tint dg2=0;\n\t\t\t\t\t\twhile((str[j]>='0' && str[j]<='9')){\n\t\t\t\t\t\t\tdg2*=10;\n\t\t\t\t\t\t\tdg2+=(str[j]-'0');\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttp[dg2]=digit;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttp[1]=digit;\n\t\t\t\t\t}\n\t\t\t\t\tdigit=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(digit>0){\n\t\t\t\ttp[0]=digit;\n\t\t\t}\n\t\t\tdi.add_edge(u,v,tp);\n\t\t\t\n\t\t}\n\t\tvector<int> ans=di.max_flow(0,n-1,51);\n\t\tstring best=\"\";\n\t\tbool flag=false;\n\t\tfor(int i=50;i>=0;i--){\n\t\t\tif(ans[i]>0){\n\t\t\t\tif(flag)best+='+';\n\t\t\t\tbest+=get_string(ans[i]);\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(ans[i]==1){\n\t\t\t\t\t\tbest.erase(best.end()-1);\n\t\t\t\t\t}\n\t\t\t\t\tbest+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tbest+=\"^\";\n\t\t\t\t\t\tbest+=get_string(i);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tif(best.size()==0)best+='0';\n\t\tcout << best << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(a[i]){\n\t\t\t\tif(i<n){\n\t\t\t\t\tret+=\"+\";\n\t\t\t\t}\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tret+=\"^\";\n\t\t\t\t\t\tret+=toString(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.n?left.a[i]:0)+(i<right.n?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.n?left.a[i]:0)-(i<right.n?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nconst poly Zero=to_poly(string(\"0\"));\nconst poly Inf=to_poly(string(\"x^51\"));\n\nvoid add_edge(int from,int to,poly& cap,vve &g){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g);\n\t\t\tadd_edge(v,u,pol,g);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nvi& operator+=(vi &a, const vi &b){\n\twhile(a.size() < b.size()) a.pb(0);\n\trep(i, a.size()) a[i] += b[i];\n\twhile(a.size() && a.back() == 0) a.pop_back();\n\treturn a;\n}\nvi& operator-=(vi &a, const vi &b){\n\twhile(a.size() < b.size()) a.pb(0);\n\trep(i, a.size()) a[i] -= b[i];\n\twhile(a.size() && a.back() == 0) a.pop_back();\n\treturn a;\n}\nvi min(const vi &a, const vi &b){\n\tif(a.size() != b.size()) return a.size() < b.size() ? a : b;\n\tfor(int i = a.size() - 1; i >= 0; i--) if(a[i] < b[i]) return a;\n\treturn b;\n}\nbool operator>(const vi &a, int b){\n\trep(i, a.size()) if(a[i] > 0) return 1;\n\treturn 0;\n}\nstruct flowGraph{\n\tstruct edge{\n\t\tint to, rev; \n\t\tvi cap;\n\t\tedge(int to, const vi &c, int rev) : to(to), rev(rev){\n\t\t\tcap = c;\n\t\t}\n\t};\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tflowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~flowGraph(){\n\t\tdelete iter; delete level;\n\t}\n\t\n\tvoid add(int s, int t, const vi &cap){\n\t\tG[s].pb(edge(t, cap, G[t].size()));\n\t\tG[t].pb(edge(s, vi(0), G[s].size() - 1));\n\t}\n\t\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvi dfs(int v, int t, vi f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\tvi d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vi(0);\n\t}\n\tvi max_flow(int s, int t){\n\t\tvi flow;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tvi f(51, inf);\n\t\t\twhile((f = dfs(s, t, f)) > 0) flow += f;\n\t\t}\n\t}\n};\nvi parse(string s){\n\teach(i, s) if(*i == '+') *i = ' ';\n\tstringstream ss(s);\n\tvi v;\n\twhile(ss >> s){\n\t\tint p, e = s.find(\"x\") != s.npos;\n\t\tif((p = s.find(\"^\")) != s.npos){\n\t\t\te = atoi(s.substr(p + 1).c_str());\n\t\t}\n\t\twhile(v.size() <= e) v.pb(0);\n\t\t\n\t\tif((p = s.find(\"x\")) != s.npos) s = s.substr(0, p);\n\t\tif(s == \"\") s += \"1\";\n\t\tv[e] = atoi(s.c_str());\n\t}\n\treturn v;\n}\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tflowGraph g(n);\n\t\trep(i, m){\n\t\t\tint a, b;\n\t\t\tstring c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tvi v = parse(c);\n\t\t\tg.add(a, b, v);\n\t\t\tg.add(b, a, v);\n\t\t}\n\t\tvi ans = g.max_flow(0, n - 1);\n\t\tif(ans.empty()){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = ans.size() - 1; i >= 0; i--){\n\t\t\tif(ans[i] == 0) continue;\n\t\t\tif(i < ans.size() - 1) cout << \"+\";\n\t\t\tif(ans[i] != 1 || i == 0) cout << ans[i];\n\t\t\tif(i > 0) cout << \"x\";\n\t\t\tif(i > 1) cout << \"^\" << i;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nvector<string> split(string& s,char c){\n  int n=s.size();\n  vector<string> res;\n  for(int i=0;i<n;i++){\n    if(s[i]==c) continue;\n    string t;\n    while(i<n&&s[i]!=c) t.push_back(s[i++]);\n    res.push_back(t);\n  }\n  return res;\n}\n\n\nstruct Dinic{\n  const int INF=1<<28;\n  \n  struct edge {\n    int to,cap,rev;\n    edge(){}\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  vector<vector<edge> > G;\n  vector<map<int,int> > M;\n  vector<int> level,iter;\n\n  Dinic(){}\n  Dinic(int V){init(V);}\n\n  void init(int V){\n    for(int i=0;i<(int)G.size();i++) G[i].clear();\n    G.clear();\n    for(int i=0;i<(int)M.size();i++) M[i].clear();\n    M.clear();\n    level.clear();\n    iter.clear();\n    G.resize(V);\n    M.resize(V);\n    level.resize(V);\n    iter.resize(V);\n  }\n  \n  void add_edge(int from,int to,int cap){\n    M[from][to]=G[from].size();\n    M[to][from]=G[to].size();\n    G[from].push_back(edge(to,cap,G[to].size()));\n    // undirected\n    G[to].push_back(edge(from,cap,G[from].size()-1));\n    // directed\n    // G[to].push_back(edge(from,0,G[from].size()-1));\n  }\n  \n  void bfs(int s){\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e = G[v][i];\n\tif(e.cap>0&&level[e.to]<0){\n\t  level[e.to]=level[v]+1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  \n  int dfs(int v,int t,int f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n\tint d = dfs(e.to,t,min(f,e.cap));\n\tif(d>0){\n\t  e.cap-=d;\n\t  G[e.to][e.rev].cap+=d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  int max_flow(int s,int t,int lim){\n    int flow=0;\n    for(;;){\n      bfs(s);\n      if(level[t]<0||lim==0) return flow;\n      fill(iter.begin(),iter.end(),0);\n      int f;\n      while((f=dfs(s,t,lim))>0){\n\tflow+=f;\n\tlim-=f;\n      }\n    }\n  }\n\n  int max_flow(int s,int t){\n    return max_flow(s,t,INF);\n  }\n\n  //cap==1 only\n  bool back_edge(int s,int t,int from, int to){\n    for(int i=0;i<(int)G[from].size();i++) {\n      edge& e=G[from][i];\n      if(e.to==to) {\n\tif(e.cap==0&&max_flow(from,to,1)==0) {\n\t  max_flow(from,s,1);\n\t  max_flow(t,to,1);\n\t  return 1;\n\t}\n      }\n    }\n    return 0;\n  }\n};\n\nconst int DEG=55;\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    Dinic flow(n);\n    int ed[DEG][55][55];\n    memset(ed,0,sizeof(ed));\n    \n    for(int i=0;i<m;i++){\n      int a,b;\n      string s;\n      cin>>a>>b>>s;\n      a--;b--;\n      flow.add_edge(a,b,0);\n      for(string t:split(s,'+')){\n\t//cout<<t<<endl;\n\tif(!count(t.begin(),t.end(),'x')){\n\t  ed[0][a][b]+=stoi(t);\n\t  ed[0][b][a]+=stoi(t);\n\t}else if(t.back()=='x'){\n\t  t.pop_back();\n\t  if(t.empty()) t=\"1\";\n\t  ed[1][a][b]+=stoi(t);\n\t  ed[1][b][a]+=stoi(t);\n\t}else{\n\t  auto v=split(t,'^');\n\t  v[0].pop_back();\n\t  if(v[0].empty()) v[0]=\"1\";\n\t  ed[stoi(v[1])][a][b]+=stoi(v[0]);\n\t  ed[stoi(v[1])][b][a]+=stoi(v[0]);\n\t}\n      }\n    }\n    vector<int> ans(DEG);\n    for(int i=DEG-1;i>=0;i--){\n      for(auto& v:flow.G){\n\tfor(auto& e:v){\n\t  if(e.cap) e.cap=flow.INF;\n\t  e.cap+=ed[i][e.to][flow.G[e.to][e.rev].to];\n\t}\n      }\n      ans[i]=flow.max_flow(0,n-1);\n    }\n    bool f=1;\n    for(int i=DEG-1;i>=0;i--){\n      if(!ans[i]){\n\tif(i) continue;\n\tif(f) cout<<ans[i],f=0;\n\tcontinue;\n      }\n      if(!f) cout<<\"+\";\n      f=0;\n      if(!(i&&ans[i]==1)) cout<<ans[i];\n      if(i) cout<<\"x\";\n      if(i>1) cout<<\"^\"<<i;\n    }\n    assert(!f);\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> polynomial;\n\nconst polynomial ZERO(51,0);\n\nvoid operator+=(polynomial &p,const polynomial &q){ rep(i,51) p[i]+=q[i]; }\nvoid operator-=(polynomial &p,const polynomial &q){ rep(i,51) p[i]-=q[i]; }\n\npolynomial operator-(const polynomial &p,const polynomial &q){\n\tpolynomial r=p;\n\trep(i,51) r[i]-=q[i];\n\treturn r;\n}\n\npolynomial parse(const char *s){\n\tpolynomial p(51);\n\tint len=strlen(s),a=0;\n\trep(i,len+1){\n\t\tif(i==len || s[i]=='x'){\n\t\t\tif(a==0) a=1; // 係数 1 が省略されていた\n\t\t\tint e=0;\n\t\t\tif(s[i]=='x'){\n\t\t\t\ti++;\n\t\t\t\tif(s[i]!='^'){\n\t\t\t\t\te=1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ti++;\n\t\t\t\t\tfor(;isdigit(s[i]);i++) e=e*10+(s[i]-'0');\n\t\t\t\t}\n\t\t\t}\n\t\t\tp[50-e]=a;\n\t\t\ta=0;\n\t\t}\n\t\telse{\n\t\t\ta=10*a+(s[i]-'0');\n\t\t}\n\t}\n\treturn p;\n}\n\nvoid print(const polynomial &p){\n\tbool b=false;\n\trep(i,51) if(p[i]>0) {\n\t\tint e=50-i;\n\t\tif(b) putchar('+');\n\t\tif(p[i]>1 || e==0) printf(\"%d\",p[i]);\n\t\tif(e>=1) putchar('x');\n\t\tif(e>=2) printf(\"^%d\",e);\n\t\tb=true;\n\t}\n\tputs(b?\"\":\"0\");\n}\n\nconst int V_MAX=50;\nconst int E_MAX=500;\n\ntemplate<class T>\nstruct graph{\n\tint n,m,head[V_MAX],next[2*E_MAX],to[2*E_MAX];\n\tT capa[2*E_MAX],flow[2*E_MAX];\n\n\tvoid init(int N){\n\t\tn=N;\n\t\tm=0;\n\t\trep(u,n) head[u]=-1;\n\t}\n\n\tvoid add_undirected_edge(int u,int v,T ca){\n\t\tnext[m]=head[u]; head[u]=m; to[m]=v; capa[m]=ca; flow[m]=ZERO; m++;\n\t\tnext[m]=head[v]; head[v]=m; to[m]=u; capa[m]=ca; flow[m]=ZERO; m++;\n\t}\n};\n\nconst polynomial INF(51,1<<29);\n\nint layer[V_MAX],now[V_MAX];\n\ntemplate<class T>\nbool make_layer(const graph<T> &G,int s,int t){\n\tint n=G.n;\n\trep(u,n) layer[u]=(u==s?0:-1);\n\n\tint head=0,tail=0;\n\tstatic int Q[V_MAX]; Q[tail++]=s;\n\twhile(head<tail && layer[t]==-1){\n\t\tint u=Q[head++];\n\n\t\tfor(int e=G.head[u];e!=-1;e=G.next[e]){\n\t\t\tint v=G.to[e];\n\t\t\tT capa=G.capa[e],flow=G.flow[e];\n\n\t\t\tif(capa-flow>ZERO && layer[v]==-1){\n\t\t\t\tlayer[v]=layer[u]+1;\n\t\t\t\tQ[tail++]=v;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn layer[t]!=-1;\n}\n\ntemplate<class T>\nT augment(graph<T> &G,int u,int t,T water){\n\tif(u==t) return water;\n\n\tfor(int &e=now[u];e!=-1;e=G.next[e]){\n\t\tint v=G.to[e];\n\t\tT capa=G.capa[e],flow=G.flow[e];\n\n\t\tif(capa-flow>ZERO && layer[v]>layer[u]){\n\t\t\tT w=augment(G,v,t,min(water,capa-flow));\n\t\t\tif(w>ZERO){\n\t\t\t\tG.flow[ e ]+=w;\n\t\t\t\tG.flow[e^1]-=w;\n\t\t\t\treturn w;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\ntemplate<class T>\nT Dinic(graph<T> &G,int s,int t){\n\tint n=G.n;\n\tT ans=ZERO;\n\twhile(make_layer(G,s,t)){\n\t\trep(u,n) now[u]=G.head[u];\n\t\tfor(T water(51,1);water>ZERO;ans+=water) water=augment(G,s,t,INF);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tgraph<polynomial> G;\n\t\tG.init(n);\n\t\trep(i,m){\n\t\t\tint u,v;\n\t\t\tchar s[512]; scanf(\"%d%d%s\",&u,&v,s); u--; v--;\n\t\t\tG.add_undirected_edge(u,v,parse(s));\n\t\t}\n\t\tprint(Dinic(G,0,n-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<queue>\nusing namespace std;\nconst int N = 51;\n\nclass E{\npublic:\n  int a[N];\n  E(){\n    for(int i=0;i<N;i++)a[i]=0;\n  }\n  E(int n){\n    for(int i=0;i<N;i++)a[i]=0;\n  }\n  E(int n,int val){\n    for(int i=0;i<N;i++)a[i]=val;\n  }\n  E(int n,int v,int s){\n    for(int i=0;i<N;i++)a[i]=0;\n    a[0]=1;\n  }\n  E operator+(const E &c)const{\n    E ret(N);\n    for(int i=0;i<N;i++)ret.a[i]=a[i]+c.a[i];\n    return ret;\n  }\n  E operator-(const E &c)const{\n    E ret(N);\n    for(int i=0;i<N;i++)ret.a[i]=a[i]-c.a[i];\n    return ret;\n  }\n  E& operator+=(const E &b){\n    for(int i=0;i<N;i++)a[i]+=b.a[i];\n    return *this;\n  }\n  E& operator-=(const E &b){\n    for(int i=0;i<N;i++)a[i]-=b.a[i];\n    return *this;\n  }\n  bool operator<(const E & b)const{\n    for(int i=N-1;i>=0;i--)if (a[i] != b.a[i])return a[i] < b.a[i];\n    return false;\n  }\n  bool operator>(const E &b)const{\n    for(int i=N-1;i>=0;i--){\n      if (a[i] != b.a[i])return a[i] > b.a[i];\n    }\n    return false;\n  }\n  bool operator==(const E &b)const{\n    for(int i=0;i<N;i++)if (a[i] != b.a[i])return false;\n    return true;\n  }\n  void op(){\n    bool isf=true;\n    for(int i=N-1;i>=1;i--){\n      if (a[i] == 0)continue;\n      if (a[i] > 0){\n        if (!isf)cout <<\"+\";\n        if (a[i] > 1)cout << a[i];\n      }else {\n        if (a[i] == -1)cout <<\"-\";\n        else cout << a[i];\n      }\n      cout <<\"x\";\n      if (i > 1)cout <<\"^\"<< i; \n      isf=false;\n    }\n    if (isf)cout << a[0];\n    else if (a[0] != 0){\n      if (a[0] > 0)cout <<\"+\" << a[0];\n      if (a[0] < 0)cout << a[0];\n    }\n    cout << endl;\n  }\n};\n\nE parse(string &in){\n  E ret(N);\n  int p=0;\n  while(p < (int)in.size()){\n    int neg=1;\n    int a=0,x=0;\n    if (in[p] == '+')p++;\n    if (in[p] == '-')neg=-1,p++;\n    if (isdigit(in[p])){\n      while(p < (int)in.size() && isdigit(in[p]))\n        a=a*10+in[p++]-'0';\n    }else a=1;\n    \n    if (in[p] == 'x'){\n      p++;\n      if (in[p] != '^')x=1;\n      else p++;\n      while(p < (int)in.size() && isdigit(in[p]))x=x*10+in[p++]-'0';\n    }\n    ret.a[x]=a;\n    ret.a[x]*=neg;\n  }\n  return ret;\n}\n\nconst int MAX = 100;\nconst E ZERO(N);\nconst E INF(N,(1<<25));\nconst E ONE(N,1,1);\nE cap[MAX][MAX];\nbool vis[MAX];\nint parent[MAX];\nE flow[MAX][MAX];\nint layer[MAX]; \n\nvoid make_layer(int n,int s,int t){\n  queue<int> Q;\n  Q.push(s);\n  layer[s]=0;\n  while(!Q.empty()){\n    int now = Q.front();Q.pop();\n    for(int i=0;i<n;i++){\n      if (cap[now][i]-flow[now][i] > ZERO && layer[i] == -1){\n        layer[i] = layer[now]+1;\n        Q.push(i);\n      }\n    }\n  }\n}\n\nE augment(int now,int t,int n,E f){\n  if (now == t || f == ZERO)return f;\n  if (vis[now])return ZERO;\n  vis[now]=true;\n  for(int i=0;i<n;i++){\n    if (layer[now] < layer[i]){\n      E tmp = augment(i,t,n,min(f,cap[now][i]-flow[now][i]));\n      if (tmp > ZERO){\n        flow[now][i]+=tmp;\n        flow[i][now]=ZERO-flow[now][i];\n        vis[now]=false;\n        return tmp;\n      }      \n    }\n  }\n  return ZERO;\n}\n\nvoid dinic(int n,int s,int t){\n  E ansflow=ZERO;\n  bool flag=true;\n  for(int i=0;i<n;i++)for(int j=0;j<n;j++)flow[i][j]=ZERO;\n  while(flag){\n    fill(layer,layer+n,-1);\n    fill(vis,vis+n,false);\n    make_layer(n,s,t);\n    if (layer[t] == -1)break;\n    \n    for(E f=ZERO;;flag=true){\n      f=augment(s,t,n,INF);\n      bool fg=false;\n      for(int i=0;i<N;i++)if (f.a[i]!=0)fg=true;\n      if (!fg)break;\n      ansflow+=f;\n    }\n  }\n  ansflow.op();\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        cap[i][j]=ZERO;\n    for(int i=0;i<m;i++){\n      int f,t;\n      string tmp;\n      cin>>f>>t>>tmp;\n      f--;t--;\n      E a=parse(tmp);\n      cap[f][t]+=a;\n      cap[t][f]+=a;\n    }\n    dinic(n,0,n-1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(a[i]){\n\t\t\t\tif(i<n){\n\t\t\t\t\tret+=\"+\";\n\t\t\t\t}\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tret+=\"^\";\n\t\t\t\t\t\tret+=toString(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)+(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)-(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nconst poly Zero=to_poly(string(\"0\"));\nconst poly Inf=to_poly(string(\"x^51\"));\n\nvoid add_edge(int from,int to,poly& cap,vve &g){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tint n,m;\n\tint cs=0;\n\twhile(cin>>n>>m,n|m){\n\t\tcs++;\n\t\tif(cs==20){\n\t\t\tint aaa=0;\n\t\t}\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g);\n\t\t\tadd_edge(v,u,pol,g);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Weight weight; Capacity cap;\n\tEdge(int s, int d, Weight w, Capacity c) : src(s), dst(d), weight(w), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct Dinic {\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tDinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) {\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tCapacity c = e.cap;\n\t\t\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\t\t\tg[u].push_back(v); g[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tinline Capacity residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tCapacity solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tCapacity res = 0;\n\t\twhile(levelize()) { prog.assign(n, 0); res += augment(s, inf); }\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1); level[s] = 0; que[r++] = s;\n\t\twhile(l != r) {\n\t\t\tint v = que[l++]; if(v == t) break;\n\t\t\tfor(const int &d : g[v]) if(level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\tlevel[d] = level[v] + 1; que[r++] = d;\n\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tCapacity augment(int v, Capacity lim) {\n\t\tCapacity res = 0;\n\t\tif(v == t) return lim;\n\t\tfor(int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif(residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst Capacity aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug; flow[d][v] -= aug;\n\t\t\tres += aug; lim -= aug;\n\t\t\tif(lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef pair<int, int> Pii;\n\nvector<int> f(string s) {\n\treplace(s.begin(), s.end(), '+', ' ');\n\t//cout << s << endl;\n\tvector<int> ret(51);\n\n\tstringstream ss(s);\n\twhile(ss >> s) {\n\t\tstringstream ss2(s);\n\t\tif(s.find('x') == string::npos) {\n\t\t\tss2 >> ret[0];\n\t\t}\n\t\telse {\n\t\t\tchar c;\n\t\t\tint a = 1, L = 1;\n\t\t\tif(s[0] != 'x') ss2 >> a;\n\t\t\tif(s.find('^') != string::npos) {\n\t\t\t\tss2 >> c >> c >> L; // x^L\n\t\t\t}\n\t\t\tret[L] = a;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint u[500];\nint v[500];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M;\n\twhile(cin >> N >> M, N) {\n\t\tmap<Pii, vector<int> > poly;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tstring p;\n\t\t\tcin >> u[i] >> v[i] >> p;\n\t\t\tu[i]--, v[i]--;\n\t\t\tpoly[Pii(u[i], v[i])] = f(p);\n\t\t}\n\n\t\tvector<int> ans(51);\n\t\tfor(int i = 50; i >= 0; i--) {\n\t\t\tGraph G(N);\n\t\t\tfor(auto&& p : poly) {\n\t\t\t\tint a = p.first.first, b = p.first.second, c = p.second[i];\n\t\t\t\tG[a].emplace_back(a, b, 0, c);\n\t\t\t\tG[b].emplace_back(b, a, 0, c);\n\t\t\t}\n\n\t\t\tDinic dinic(G);\n\t\t\tint f = dinic.solve(0, N - 1);\n\t\t\tans[i] = f;\n\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tint a = u[j], b = v[j];\n\t\t\t\tif(dinic.flow[a][b] != 0 && dinic.cap[a][b] != dinic.flow[a][b]) {\n\t\t\t\t\tfor(int l = 0; l <= i; l++) {\n\t\t\t\t\t\tpoly[Pii(a, b)][l] = 1e6;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor(int i = 50; i >= 0; i--) {\n\t\t\tif(ans[i] == 0) continue;\n\t\t\tif(flag) cout << \"+\";\n\t\t\tflag = true;\n\t\t\tif(i == 0 || ans[i] != 1) cout << ans[i];\n\t\t\tif(i != 0) cout << \"x\";\n\t\t\tif(i >= 2) cout << \"^\" << i;\n\t\t}\n\t\tif(!flag) cout << 0;\n\t\tcout << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nvector<int> Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n  return res;\n}\n\nvector<int> Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n  return res;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f))return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+='+';\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+='x';\n    else if(i) s+=\"x^\"+itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing vi = vector<int>;\n\n// (?????????,??????,??????)\nstruct edge{\n    int to;\n    vi cap;\n    int rev;\n};\n\nconst int MAX_V = 50; // TODO:initialize\nconst vi F_INF = vi(51,19191919); // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\nvoid show(vi f)\n{\n    string ans = \"\";\n    for(int i=50; i>0; --i)if(f[i]!=0)\n    {\n        if(f[i]>0) ans += \"+\";\n        else ans += \"-\";\n\n        if(abs(f[i])>1) ans += to_string(abs(f[i]));\n\n        if(i>0)\n        {\n            ans += \"x\";\n            if(i>1) ans += \"^\" + to_string(i);\n        }\n    }\n\n    if(f[0]!=0)\n    {\n        if(f[0]>0) ans += \"+\";\n        else ans += \"-\";\n        ans += to_string(abs(f[0]));\n    }\n\n    if(ans==\"\") ans = \"0\";\n    if(ans[0]=='+') ans = ans.substr(1);\n    cout << ans << endl;\n}\n\nvoid add_edge(int from, int to, vi cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,cap,(int)G[from].size()-1});\n}\n\ninline bool positive(vi v)\n{\n    for(int i=50; i>=0; --i)if(v[i]!=0) return v[i]>0;\n    return false;\n}\n\ninline vi ADD(vi a, vi b)\n{\n    vi ret(51);\n    rep(i,51) ret[i]=a[i]+b[i];\n    return ret;\n}\n\ninline vi SUB(vi a, vi b)\n{\n    vi ret(51);\n    rep(i,51) ret[i]=a[i]-b[i];\n    return ret;\n}\n\ninline vi vi_min(vi a, vi b)\n{\n    for(int i=50; i>=0; --i)\n    {\n        int d = a[i]-b[i];\n        if(d>0) return b;\n        else if(d<0) return a;\n    }\n    return a;\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(positive(e.cap) && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// ?¢?????????????dfs??§??¢???\nvi dinic_dfs(int v, int t, vi f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(positive(e.cap) && level[v]<level[e.to]){\n            vi d = dinic_dfs(e.to,t,vi_min(f,e.cap));\n            if(positive(d)){\n                e.cap = SUB(e.cap,d);\n                G[e.to][e.rev].cap = ADD(G[e.to][e.rev].cap,d);\n                return d;\n            }\n        }\n    }\n    return vector<int>(51,0);\n}\n\n// s??????t???????????§???\nvi max_flow(int s, int t){\n    vi flow(51);\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        vi f;\n        while( positive(f=dinic_dfs(s,t,F_INF)) ) flow = ADD(flow,f);\n    }\n}\n\nvector<string> split(const string &s, char d)\n{\n    vector<string> ret;\n    stringstream ss(s);\n    string item;\n    while(getline(ss,item,d))\n    {\n        if(!item.empty()) ret.pb(item);\n    }\n    return ret;\n}\n\nvi convert(string s)\n{\n    vi ret(51);\n    for(const auto &t:split(s,'+'))\n    {\n        int idx = t.find(\"x\");\n        if(idx==-1) ret[0]=atoi(t.c_str());\n        else\n        {\n            string i=t.substr(idx+1);\n            int n = 1;\n            if(i.size()) n = atoi(i.c_str());\n\n            string a=t.substr(0,idx);\n            int val = 1;\n            if(a.size()) val = atoi(a.c_str());\n\n            ret[n] = val;\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    int n,m;\n    while(cin >>n >>m,n)\n    {\n        rep(i,MAX_V) G[i].clear();\n        rep(i,m)\n        {\n            int u,v;\n            string s;\n            cin >>u >>v >>s;\n            add_edge(u-1,v-1,convert(s));\n        }\n        show(max_flow(0,n-1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <sstream>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n  int id;\n  Edge(){}\n  Edge(int c, int t, int r, int i) :\n    cap(c), to(t), rev(r), id(i){}\n};\n\ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap, int id){\n    g[from].push_back(E(cap, to, g[to].size(), id));\n    g[to].push_back(E(cap, from, g[from].size() - 1, id));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nclass Dinic{\n  typedef typename Graph<E>::G G;\n  G &g;\n  std::size_t n; // size of graph\n\n  std::vector<int> level;\n  std::vector<int> iter;\n\n  // other utilities\n\n  // search length of shortest path from s\n  void bfs(int s){\n    std::queue<int> que;\n    level = std::vector<int>(n, -1);\n\n    level[s] = 0;\n    que.push(s);\n\n    while(!que.empty()){\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)g[v].size(); i++){\n        E &e = g[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n  // search path\n  int dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)g[v].size(); i++){\n      E &e = g[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n        int d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0){\n          e.cap -= d;\n          g[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\npublic:\n  Dinic(Graph<E> &graph) : g(graph.getRowGraph()){\n    n = g.size();\n  }\n\n  // Max flow of the flow from s to t.\n  int solve(int s, int t){\n    int flow = 0;\n    while(true){\n      int f;\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter  = std::vector<int>(n, 0);\n      while((f = dfs(s, t, INT_MAX)) > 0){\n        flow += f;\n      }\n    }\n  }\n};\n\ntemplate<class E>\nint dinic(Graph<E> &g, int s, int d){\n  return Dinic<E>(g).solve(s, d);\n}\n\nvector<string> split(string str, char sp){\n  vector<string> ret;\n\n  while(str.find(sp) != string::npos){\n    int pos = (int)str.find(sp);\n\n    ret.push_back(str.substr(0, pos));\n    str = str.substr(pos + 1);\n  }\n  ret.push_back(str);\n\n  return ret;\n}\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n + m){\n    vector<int> u(m);\n    vector<int> v(m);\n    vector<vector<int> > p(m, vector<int>(51));\n\n    REP(i,m){\n      string str;\n      cin >> u[i] >> v[i] >> str;\n      u[i]--; v[i]--;\n\n      vector<string> tmp = split(str, '+');\n\n      REP(j, tmp.size()){\n        int a, l;\n        if(tmp[j].find('x') != string::npos){\n          if(tmp[j][0] == 'x'){\n            if(tmp[j].find('^') != string::npos)\n              sscanf(tmp[j].c_str(), \"x^%d\", &l);\n            else\n              l = 1;\n            a = 1;\n          }else{\n            if(tmp[j].find('^') != string::npos)\n              sscanf(tmp[j].c_str(), \"%dx^%d\", &a, &l);\n            else{\n              sscanf(tmp[j].c_str(), \"%dx\", &a);\n              l = 1;\n            }\n          }\n        }else{\n          l = 0;\n          sscanf(tmp[j].c_str(), \"%d\", &a);\n        }\n        // cout << tmp[j] << \" : \" << a << \" \" << l << endl;\n        p[i][l] = a;\n      }\n    }\n\n    vector<int> ans(51);\n    vector<bool> inf(m);\n    for(int i = 50; i >= 0; i--){\n      Graph<Edge> g(n);\n\n      REP(j,m){\n        int cap = inf[j] ? (1 << 30) : p[j][i];\n\n        if(cap > 0){\n          g.addEdge(u[j], v[j], cap, j);\n        }\n      }\n\n      ans[i] = dinic(g, 0, n - 1);\n\n      const vector<vector<Edge> > &gg(g.getRowGraph());\n      vector<int> tmp(m);\n      REP(k,gg.size()){\n        REP(j,gg[k].size()){\n          if(gg[k][j].cap > 0){\n            tmp[gg[k][j].id]++;\n            if(tmp[gg[k][j].id] == 2){\n              inf[gg[k][j].id] = true;\n            }\n          }\n        }\n      }\n    }\n\n    stringstream ss;\n    bool flag = false;\n\n    for(int i = 50; i >= 0; i--){\n      if(ans[i] > 0){\n        if(!flag){\n          flag = true;\n        }else{\n          ss << \"+\";\n        }\n\n        if(i == 0 || ans[i] != 1) ss << ans[i];\n        if(i > 1) ss << \"x^\" << i;\n        if(i == 1) ss << \"x\";\n      }\n    }\n\n    string sans = ss.str();\n    if(sans.size() == 0) sans = \"0\";\n\n    cout << sans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> polynomial;\n\nconst polynomial ZERO(51,0);\n\nvoid operator+=(polynomial &p,const polynomial &q){ rep(i,51) p[i]+=q[i]; }\nvoid operator-=(polynomial &p,const polynomial &q){ rep(i,51) p[i]-=q[i]; }\n\npolynomial operator-(const polynomial &p,const polynomial &q){\n\tpolynomial r=p;\n\trep(i,51) r[i]-=q[i];\n\treturn r;\n}\n\npolynomial parse(const char *s){\n\tpolynomial p(51);\n\tint len=strlen(s),a=0;\n\trep(i,len+1){\n\t\tif(i==len || s[i]=='x'){\n\t\t\tint e=0;\n\t\t\tif(s[i]=='x'){\n\t\t\t\ti++;\n\t\t\t\tif(s[i]!='^'){\n\t\t\t\t\tif(i==1 || s[i-2]=='+') a=1; // 1*x^1 のときだけ例外\n\t\t\t\t\te=1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ti++;\n\t\t\t\t\tfor(;isdigit(s[i]);i++) e=e*10+(s[i]-'0');\n\t\t\t\t}\n\t\t\t}\n\t\t\tp[50-e]=a;\n\t\t\ta=0;\n\t\t}\n\t\telse{\n\t\t\ta=10*a+(s[i]-'0');\n\t\t}\n\t}\n\treturn p;\n}\n\nvoid print(const polynomial &p){\n\tbool b=false;\n\trep(i,51) if(p[i]>0) {\n\t\tint e=50-i;\n\t\tif(b) putchar('+');\n\t\tif(p[i]>1 || e==0) printf(\"%d\",p[i]);\n\t\tif(e>=1) putchar('x');\n\t\tif(e>=2) printf(\"^%d\",e);\n\t\tb=true;\n\t}\n\tputs(b?\"\":\"0\");\n}\n\nconst int V_MAX=50;\nconst int E_MAX=500;\n\ntemplate<class T>\nstruct graph{\n\tint n,m,head[V_MAX],next[2*E_MAX],to[2*E_MAX];\n\tT capa[2*E_MAX],flow[2*E_MAX];\n\n\tvoid init(int N){\n\t\tn=N;\n\t\tm=0;\n\t\trep(u,n) head[u]=-1;\n\t}\n\n\tvoid add_undirected_edge(int u,int v,T ca){\n\t\tnext[m]=head[u]; head[u]=m; to[m]=v; capa[m]=ca; flow[m]=ZERO; m++;\n\t\tnext[m]=head[v]; head[v]=m; to[m]=u; capa[m]=ca; flow[m]=ZERO; m++;\n\t}\n};\n\nconst polynomial INF(51,1<<29);\n\nint layer[V_MAX],now[V_MAX];\n\ntemplate<class T>\nbool make_layer(const graph<T> &G,int s,int t){\n\tint n=G.n;\n\trep(u,n) layer[u]=(u==s?0:-1);\n\n\tint head=0,tail=0;\n\tstatic int Q[V_MAX]; Q[tail++]=s;\n\twhile(head<tail && layer[t]==-1){\n\t\tint u=Q[head++];\n\n\t\tfor(int e=G.head[u];e!=-1;e=G.next[e]){\n\t\t\tint v=G.to[e];\n\t\t\tT capa=G.capa[e],flow=G.flow[e];\n\n\t\t\tif(capa-flow>ZERO && layer[v]==-1){\n\t\t\t\tlayer[v]=layer[u]+1;\n\t\t\t\tQ[tail++]=v;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn layer[t]!=-1;\n}\n\ntemplate<class T>\nT augment(graph<T> &G,int u,int t,T water){\n\tif(u==t) return water;\n\n\tfor(int &e=now[u];e!=-1;e=G.next[e]){\n\t\tint v=G.to[e];\n\t\tT capa=G.capa[e],flow=G.flow[e];\n\n\t\tif(capa-flow>ZERO && layer[v]>layer[u]){\n\t\t\tT w=augment(G,v,t,min(water,capa-flow));\n\t\t\tif(w>ZERO){\n\t\t\t\tG.flow[ e ]+=w;\n\t\t\t\tG.flow[e^1]-=w;\n\t\t\t\treturn w;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\ntemplate<class T>\nT Dinic(graph<T> &G,int s,int t){\n\tint n=G.n;\n\tT ans=ZERO;\n\twhile(make_layer(G,s,t)){\n\t\trep(u,n) now[u]=G.head[u];\n\t\tfor(T water(51,1);water>ZERO;ans+=water) water=augment(G,s,t,INF);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tgraph<polynomial> G;\n\t\tG.init(n);\n\t\trep(i,m){\n\t\t\tint u,v;\n\t\t\tchar s[1024]; scanf(\"%d%d%s\",&u,&v,s); u--; v--;\n\t\t\tG.add_undirected_edge(u,v,parse(s));\n\t\t}\n\t\tprint(Dinic(G,0,n-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 50;\nconst int INF = 1 << 28;\nconst int L = 52;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero){\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n\t\t\t\tbool zero = false;\n        //e.cap -= d;\n        for(int j=0;j<L;j++){\n\t\t\t\t\tif(e.cap[j] - d[j] <= 0){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(zero) e.cap[j] = 0;\n\t\t\t\t\telse{\n\t\t\t\t\t\te.cap[j] -= d[j];\n\t\t\t\t\t}\n\n        }\n        //G[e.to][e.rev].cap += d;\n        for(int j=0;j<L;j++){\n          G[e.to][e.rev].cap[j] += d[j];\n        }\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vector<int> vec_INF = vec_zero;\n  vec_INF[0] = 1;\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n/*\n\t\tfor(int j=0;j<L;j++){\n\t\t\tcout << f[j] << ' ';\n\t\t}\n\t\tcout << endl;\n*/\n    if(f == vec_zero) return flow;\n/*\n\t\tcout << \"*\"\n\t\tfor(int j=0;j<L;j++){\n\t\t\tcout << f[j] << ' ';\n\t\t}\n\t\tcout << endl;\n*/\n    //flow += f;\n    for(int j=0;j<L;j++){\n      flow[j] += f[j];\n    }\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n    G[i].clear();\n  }\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++){\n    if(s[i] == 'x'){\n      x = i;\n    }\n  }\n  if(x == -1){\n    return make_pair(0, atoi(s.c_str()));\n  }\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0){\n\t\tres.second = 1;\n\t}else{\n\t\tres.second = atoi(tmp.c_str());\n\t}\n  int h = -1;\n  for(int i=0;i<s.size();i++){\n    if(s[i] == '^'){\n      res.first = atoi(s.substr(i+1).c_str());\n    }\n  }\n\tif(h == -1){\n\t\tres.first = 1;\n\t}\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size()){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      break;\n    }\n    if(s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      pre = i + 1;\n    }\n  }\n  return res;\n}\n\nint V, E;\n\nmain(){\n  while(cin >> V >> E && (V|E)){\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      //cout << i << endl;\n      vector<int> tmp = calc(s);\n\t\t\t//for(int i=0;i<10;i++) cout << tmp[i] << ' '; cout << endl;\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n/*\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tcout << ans[i] << ' ';\n\t\t}\n\t\tcout << endl;\n*/\n    bool first = true;\n    for(int i=L-1;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else{\n        cout << \"+\";\n      }\n      if(i == 0){\n        cout << ans[i];\n      }else{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1){\n\t\t\t\t\tcout << \"x\";\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"x^\" << i;\n\t\t\t\t}\n      }\n    }\n    if(first){\n      cout << 0 << endl;\n    }else{\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 1e8);\n\nPoly operator-(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\nbool operator<(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] < b[i];\n\t}\n\treturn false;\n}\n\nbool operator>(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] > b[i];\n\t}\n\treturn false;\n}\n\nPoly min(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\tif (a[i] < b[i]) return a;\n\t\telse return b;\n\t}\n\treturn b;\n}\n\nbool residual(Poly& a)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] != 0) return a[i] > 0;\n\t}\n\treturn false;\n}\n\ntypedef int Weight;\ntypedef Poly Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, ZERO, 0 });\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t || !residual(f)) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > ZERO)\n\t\t{\n\t\t\tFlow mn = min(f, e.cap);\n\t\t\tFlow d = dfs(g, used, e.dest, t, mn);\n\t\t\tif (residual(f))\n\t\t\t{\n\t\t\t\te.cap = e.cap - d;\n\t\t\t\tg[e.dest][e.rev].cap = g[e.dest][e.rev].cap + d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = ZERO;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == ZERO) return flow;\n\t\tflow = f + flow;\n\t}\n}\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (p < n && isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (p < n && s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[m] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[1] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[0] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = ford_fulkerson(g, 0, n - 1);\n\t\tstring anss;\n\t\tfor (int i = 50; i >= 0; i--)\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i > 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 0)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2328\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\nvector<string> split(string& s,char c){\n  int n=s.size();\n  vector<string> res;\n  for(int i=0;i<n;i++){\n    if(s[i]==c) continue;\n    string t;\n    while(i<n&&s[i]!=c) t.push_back(s[i++]);\n    res.push_back(t);\n  }\n  return res;\n}\n//END CUT HERE\n#ifndef call_from_test\nsigned YUKI_932(){\n  string s;\n  cin>>s;\n  auto ss=split(s,',');\n  cout<<(ss==vector<string>(ss.size(),\"AC\")?\"Done!\":\"Failed...\")<<endl;\n  return 0;\n}\n/*\n  verified 2019/11/30\n  https://yukicoder.me/problems/no/932\n*/\n\nsigned main(){\n  YUKI_932();\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#endif\n//BEGIN CUT HERE\ntemplate<typename T,bool directed>\nstruct Dinic{\n  struct edge {\n    int to;\n    T cap;\n    int rev;\n    edge(){}\n    edge(int to,T cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  vector<vector<edge> > G;\n  vector<int> level,iter;\n\n  Dinic(){}\n  Dinic(int n):G(n),level(n),iter(n){}\n\n  int add_edge(int from,int to,T cap){\n    G[from].emplace_back(to,cap,G[to].size());\n    G[to].emplace_back(from,directed?0:cap,G[from].size()-1);\n    return G[to].back().rev;\n  }\n\n  void bfs(int s){\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[s]=0;\n    que.emplace(s);\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&level[e.to]<0){\n          level[e.to]=level[v]+1;\n          que.emplace(e.to);\n        }\n      }\n    }\n  }\n\n  T dfs(int v,int t,T f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n        T d=dfs(e.to,t,min(f,e.cap));\n        if(d==0) continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n    return 0;\n  }\n\n  T flow(int s,int t,T lim){\n    T fl=0;\n    while(1){\n      bfs(s);\n      if(level[t]<0||lim==0) break;\n      fill(iter.begin(),iter.end(),0);\n\n      while(1){\n        T f=dfs(s,t,lim);\n        if(f==0) break;\n        fl+=f;\n        lim-=f;\n      }\n    }\n    return fl;\n  }\n\n  T flow(int s,int t){\n    return flow(s,t,numeric_limits<T>::max()/2);\n  }\n\n  T cut(int s,int t,int x,int a){\n    static_assert(directed, \"must be directed\");\n    auto &e=G[x][a];\n    int y=e.to;\n    T cr=G[y][e.rev].cap;\n    if(cr==0) return e.cap=0;\n    e.cap=G[y][e.rev].cap=0;\n    T cap=cr-flow(x,y,cr);\n    if(x!=s&&cap!=0) flow(x,s,cap);\n    if(t!=y&&cap!=0) flow(t,y,cap);\n    return cap;\n  }\n\n  T link(int s,int t,int x,int a,T f){\n    auto &e=G[x][a];\n    e.cap+=f;\n    return flow(s,t,f);\n  }\n};\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nsigned SPOJ_FASTFLOW(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m;\n  cin>>n>>m;\n  Dinic<Int, false> G(n);\n  for(Int i=0;i<m;i++){\n    Int a,b,c;\n    cin>>a>>b>>c;\n    if(a==b) continue;\n    a--;b--;\n    G.add_edge(a,b,c);\n  }\n  cout<<G.flow(0,n-1)<<endl;\n  return 0;\n}\n/*\n  verified on 2019/06/10\n  https://www.spoj.com/problems/FASTFLOW/\n*/\n\nsigned SPOJ_BANKROB(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  const int INF=5050;\n  Dinic<int, true> G(n*2);\n  for(int i=0;i<m;i++){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G.add_edge(n+x,y,INF);\n    G.add_edge(n+y,x,INF);\n  }\n\n  for(int i=0;i<n;i++)\n    G.add_edge(i,n+i,1);\n\n  cout<<G.flow(n+s,t)<<endl;\n  return 0;\n}\n/*\n  verified on 2019/06/10\n  https://www.spoj.com/problems/BANKROB/\n*/\n\nsigned main(){\n  //SPOJ_FASTFLOW();\n  //SPOJ_BANKROB();\n  return 0;\n}\n#endif\n\n#undef call_from_test\n\nsigned main(){\n  const int DEG = 55;\n  const int INF = 1<<28;\n  int n,m;\n  while(cin>>n>>m,n){\n    Dinic<int, false> flow(n);\n    int ed[DEG][55][55];\n    memset(ed,0,sizeof(ed));\n\n    for(int i=0;i<m;i++){\n      int a,b;\n      string s;\n      cin>>a>>b>>s;\n      a--;b--;\n      flow.add_edge(a,b,0);\n      for(string t:split(s,'+')){\n        if(!count(t.begin(),t.end(),'x')){\n          ed[0][a][b]+=stoi(t);\n          ed[0][b][a]+=stoi(t);\n        }else if(t.back()=='x'){\n          t.pop_back();\n          if(t.empty()) t=\"1\";\n          ed[1][a][b]+=stoi(t);\n          ed[1][b][a]+=stoi(t);\n        }else{\n          auto v=split(t,'^');\n          v[0].pop_back();\n          if(v[0].empty()) v[0]=\"1\";\n          ed[stoi(v[1])][a][b]+=stoi(v[0]);\n          ed[stoi(v[1])][b][a]+=stoi(v[0]);\n        }\n      }\n    }\n\n    vector<int> ans(DEG);\n    for(int i=DEG-1;i>=0;i--){\n      for(auto& v:flow.G){\n        for(auto& e:v){\n          if(e.cap) e.cap=INF;\n          e.cap+=ed[i][e.to][flow.G[e.to][e.rev].to];\n        }\n      }\n      ans[i]=flow.flow(0,n-1);\n    }\n\n    bool f=1;\n    for(int i=DEG-1;i>=0;i--){\n      if(!ans[i]){\n        if(i) continue;\n        if(f) cout<<ans[i],f=0;\n        continue;\n      }\n      if(!f) cout<<\"+\";\n      f=0;\n      if(!(i&&ans[i]==1)) cout<<ans[i];\n      if(i>0) cout<<\"x\";\n      if(i>1) cout<<\"^\"<<i;\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  assert(res.size()==v.size());\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  assert(res.size()==v.size());\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  assert(A.size()==B.size());\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n/*bool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n  }*/\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      assert(d.size()==f.size());\n      //assert(isallnotINF(e.cap));\n      /*      for(int j=0;j<d.size();j++){\n\tcout<<j<<' '<<d[j]<<endl;\n\tassert(d[j]!=INF);\n\t}*/\n      \n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> r=vector<int>(V,0);\n    r[0]=INF;\n    vector<int> f = dfs(s, t, r);\n    if(isall0(f)) return flow;\n    /*if(isallnotINF(f)) */Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    assert(0!=n-1);\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 55;\nconst int INF = 1 << 28;\nconst int L = 53;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero){\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n\t\t\t\tint zero = -1;\n        for(int j=0;j<L;j++){\n\t\t\t\t\tif(zero == -1 && e.cap[j] < d[j]) zero = 1;\n\t\t\t\t\tif(zero == -1 && e.cap[j] > d[j]) zero = 0;\n\t\t\t\t\tif(zero == 1 || zero == -1) e.cap[j] -= d[j];\n\t\t\t\t\telse e.cap[j] = 0;\n        }\n        for(int j=0;j<L;j++) G[e.to][e.rev].cap[j] += d[j];\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vector<int> vec_INF = vec_zero;\n  vec_INF[0] = 1;\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n    if(f == vec_zero) return flow;\n    for(int j=0;j<L;j++) flow[j] += f[j];\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == 'x') x = i;\n  if(x == -1) return make_pair(0, atoi(s.c_str()));\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0) res.second = 1;\n\telse res.second = atoi(tmp.c_str());\n  int h = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == '^') res.first = atoi(s.substr(i+1).c_str());\n\tif(h == -1) res.first = 1;\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size() || s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      if(i == s.size()) break;\n\t\t\tpre = i + 1;\n    }\n  }\n  return res;\n}\n\nmain(){\n\tint V, E;\n  while(cin >> V >> E && (V|E)){\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      vector<int> tmp = calc(s);\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n    bool first = true;\n    for(int i=L-1;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else cout << \"+\";\n      if(i == 0) cout << ans[i];\n\t\t\telse{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1) cout << \"x\";\n\t\t\t\telse cout << \"x^\" << i;\n      }\n    }\n\t\tif(first) cout << 0;\n\t\tcout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nvector<int> Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n  return res;\n}\n\nvector<int> Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n  return res;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=51;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f))return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+='+';\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+='x';\n    else if(i) s+=\"x^\"+itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int L = 51;\n\nstruct Edge {\n  int to, cost, rev;\n  vector<int> cap;\n  Edge(int to, int cost, vector<int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdgeF(int from, int to, int cost, vector<int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, vector<int>(L), (int)g[from].size()-1));\n}\n\ninline vector<int>& add(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] += b[i];\n  return a;\n}\n\ninline vector<int>& subtract(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] -= b[i];\n  return a;\n}\n\ninline bool lt(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return false;\n}\n\ninline bool le(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return true;\n}\n\nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0 &&\n     *min_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(abs(ans[i]) != 1) cout << abs(ans[i]);\n    if(i > 1) cout << \"x^\" << i;\n    else if(i == 1) cout << \"x\";\n    j++;\n  }\n  cout << endl;\n}\n\nvector<int> dfsF(int v, int t, vector<int> f, vector<int> &used, Graph &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(!used[e.to] && lt(vector<int>(L), e.cap)) {\n      vector<int> nf(L);\n      bool iszero = true;\n      for(int j = L-1, k = -1; j >= 0; --j) {\n\tif(k == -1) {\n\t  if(f[j] < e.cap[j]) k = 0;\n\t  else if(f[j] > e.cap[j]) k = 1;\n\t}\n\tif(k <= 0) nf[j] = f[j];\n\telse       nf[j] = e.cap[j];\n\tiszero = iszero && nf[j] == 0;\n      }\n      if(iszero) continue;\n      vector<int> d = dfsF(e.to, t, nf, used, g);\n      if(lt(vector<int>(L), d)) {\n\tsubtract(e.cap, d);\n\tadd(g[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>(L);\n}\n\nvector<int> maxFlow(int s, int t, Graph g) {\n  vector<int> flow(L);\n  while(1) {\n    vector<int> used(g.size());\n    vector<int> f = dfsF(s, t, vector<int>(L, INF), used, g);\n    if(le(f, vector<int>(L))) break;\n    add(flow, f);\n  }\n  return flow;\n}\n\nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      vector<int> cap(L);\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n\tint a = 1;\n\t{\n\t  int i = 0;\n\t  while(i < s.size() && isdigit(s[i])) ++i;\n\t  if(i) {\n\t    a = atoi(s.substr(0, i).c_str());\n\t    s = s.substr(i);\n\t  }\n\t}\n\tint k = 0;\n\t// \"\" or \"x\" or \"x^y\"\n\tif(s == \"x\") {\n\t  k = 1;\n\t} else if(s.size()) {\n\t  k = atoi(s.substr(2).c_str());\n\t}\n\tcap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      addEdgeF(v, u, 0, cap, g);\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 55;\nconst int INF = 1 << 28;\nconst int L = 53;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero){\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n\t\t\t\tint zero = -1;\n        for(int j=L-1;j>=0;j--){\n\t\t\t\t\tif(zero == -1 && e.cap[j] < d[j]) zero = 1;\n\t\t\t\t\tif(zero == -1 && e.cap[j] > d[j]) zero = 0;\n\t\t\t\t\tif(zero) e.cap[j] = 0;\n\t\t\t\t\telse e.cap[j] -= d[j];\n        }\n        for(int j=0;j<L;j++) G[e.to][e.rev].cap[j] += d[j];\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vector<int> vec_INF = vec_zero;\n  vec_INF[0] = 1;\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n    if(f == vec_zero) return flow;\n    for(int j=0;j<L;j++) flow[j] += f[j];\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == 'x') x = i;\n  if(x == -1) return make_pair(0, atoi(s.c_str()));\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0) res.second = 1;\n\telse res.second = atoi(tmp.c_str());\n  int h = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == '^') res.first = atoi(s.substr(i+1).c_str());\n\tif(h == -1) res.first = 1;\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size() || s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      if(i == s.size()) break;\n\t\t\tpre = i + 1;\n    }\n  }\n  return res;\n}\n\nmain(){\n\tint V, E;\n  while(cin >> V >> E && (V|E)){\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      vector<int> tmp = calc(s);\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n    bool first = true;\n    for(int i=L-1;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else cout << \"+\";\n      if(i == 0) cout << ans[i];\n\t\t\telse{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1) cout << \"x\";\n\t\t\t\telse cout << \"x^\" << i;\n      }\n    }\n\t\tif(first) cout << 0;\n\t\tcout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int L = 51;\n\nstruct Edge {\n  int to, cost, rev;\n  map<int, int> cap;\n  Edge(int to, int cost, map<int, int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdgeF(int from, int to, int cost, map<int, int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, map<int, int>(), (int)g[from].size()-1));\n}\n\ninline map<int, int>& add(map<int, int> &a, const map<int, int> &b) {\n  for(map<int, int>::const_iterator it = b.begin();\n      it != b.end(); ++it) {\n    a[it->first] += it->second;\n    if(a[it->first] == 0) a.erase(it->first);\n  }\n  return a;\n}\n\ninline map<int, int>& subtract(map<int, int> &a, const map<int, int> &b) {\n  for(map<int, int>::const_iterator it = b.begin();\n      it != b.end(); ++it) {\n    a[it->first] -= it->second;\n    if(a[it->first] == 0) a.erase(it->first);\n  }\n  return a;\n}\n\ninline bool lt(const map<int, int> &a, const map<int, int> &b) {\n  for(map<int, int>::const_reverse_iterator i = a.rbegin(), j = b.rbegin();\n      i != a.rend() || j != b.rend(); ++i, ++j) {\n    if(i == a.rend()) return true;\n    if(j == b.rend()) return false;\n    if(*i == *j) continue;\n    else return *i < *j;\n  }\n  return false;\n}\n\ninline bool le(const map<int, int> &a, const map<int, int> &b) {\n  for(map<int, int>::const_reverse_iterator i = a.rbegin(), j = b.rbegin();\n      i != a.rend() || j != b.rend(); ++i, ++j) {\n    if(i == a.rend()) return true;\n    if(j == b.rend()) return false;\n    if(*i == *j) continue;\n    else return *i < *j;\n  }\n  return true;\n}\n\nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0 &&\n     *min_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(abs(ans[i]) != 1) cout << abs(ans[i]);\n    if(i > 1) cout << \"x^\" << i;\n    else if(i == 1) cout << \"x\";\n    j++;\n  }\n  cout << endl;\n}\n\nmap<int, int> dfsF(int v, int t, map<int, int> f, vector<int> &used, Graph &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(!used[e.to] && lt(map<int, int>(), e.cap)) {\n      map<int, int> d = dfsF(e.to, t, lt(f, e.cap) ? f : e.cap, used, g);\n      if(lt(map<int, int>(), d)) {\n\tsubtract(e.cap, d);\n\tadd(g[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return map<int, int>();\n}\n\nvector<int> maxFlow(int s, int t, Graph g) {\n  map<int, int> flow;\n  while(1) {\n    vector<int> used(g.size());\n    map<int, int> minf;\n    for(int i = 0; i < L; ++i) minf[i] = INF;\n    map<int, int> f = dfsF(s, t, minf, used, g);\n    if(le(f, map<int, int>())) break;\n    add(flow, f);\n  }\n  vector<int> ans(L);\n  for(map<int, int>::iterator it = flow.begin();\n      it != flow.end(); ++it) {\n    ans[it->first] = it->second;\n  }\n  return ans;\n}\n\nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      map<int, int> cap;\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n\tint a = 1;\n\t{\n\t  int i = 0;\n\t  while(i < s.size() && isdigit(s[i])) ++i;\n\t  if(i) {\n\t    a = atoi(s.substr(0, i).c_str());\n\t    s = s.substr(i);\n\t  }\n\t}\n\tint k = 0;\n\t// \"\" or \"x\" or \"x^y\"\n\tif(s == \"x\") {\n\t  k = 1;\n\t} else if(s.size()) {\n\t  k = atoi(s.substr(2).c_str());\n\t}\n\tcap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      addEdgeF(v, u, 0, cap, g);\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\n\n#define MAX_V (55)\n#define INF (1<<29)\n\nconst vector<int> zero_cap = vector<int>(51);\nconst vector<int> inf_flow = vector<int>(51, INF);\n\nstruct edge {\n  int to, rev;\n  vector<int> cap;\n  edge(int to, vector<int> cap, int rev) : to(to), cap(cap), rev(rev) {\n    assert(cap.size() == 51);\n  }\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, vector<int> cap) {\n  G[from].push_back(edge(to, cap, G[to].size()));\n  G[to].push_back(edge(from, zero_cap, G[from].size() - 1));\n}\n\nbool larger_than_0(vector<int> const& a) {\n  rep(i, a.size()) if(a[i] > 0) return 1;\n  return 0;\n}\n\nvector<int> min(vector<int> const& a, vector<int> const& b) {\n  for(int i=50; i>=0; i--) {\n    if(a[i] == b[i]) continue;\n    if(a[i] < b[i]) return a;\n    return b;\n  }\n  return a;\n}\n\nvoid assign_minus(vector<int>& v, vector<int> const& r) {\n  for(int i=50; i>=0; i--) {\n    v[i] -= r[i];\n  }\n}\n\nvoid assign_plus(vector<int>& v, vector<int> const& r) {\n  for(int i=50; i>=0; i--) {\n    v[i] += r[i];\n  }\n}\n\nvector<int> dfs(int v, int t, vector<int> f) {\n  if(v == t) return f;\n  used[v] = 1;\n//  cout << \"v = \" << v << endl;\n  rep(i, G[v].size()) {\n    edge& e = G[v][i];\n    if(!used[e.to] && larger_than_0(e.cap)) {\n      auto d = dfs(e.to, t, min(f, e.cap));\n      if(larger_than_0(d)) {\n        assign_minus(e.cap, d);\n        assign_plus(G[e.to][e.rev].cap, d);\n        return d;\n      }\n    }\n  }\n\n  return zero_cap;\n}\n\nvector<int> max_flow(int s, int t) {\n  vector<int> flow = zero_cap;\n  for(;;) {\n    memset(used, 0, sizeof(used));\n    auto f = dfs(s, t, inf_flow);\n    if(f == zero_cap) return flow;\n    assign_plus(flow, f);\n  }\n}\n\nvoid init() {\n  rep(i, MAX_V) G[i].clear();\n}\n\nint N, M;\n\ntypedef string::const_iterator Iter;\nIter it;\n\nint number() {\n  int ret = 0;\n  assert(isdigit(*it));\n  while(isdigit(*it)) {\n    ret *= 10; ret += *it - '0';\n    it++;\n  }\n  return ret;\n}\n\nvector<string> split(string& s) {\n  int n = s.size();\n  int prev = 0;\n  vector<string> ret;\n  rep(i, n) {\n    if(s[i] == '+') {\n      ret.push_back(string(s.begin() + prev, s.begin() + i));\n      prev = i + 1;\n    }\n  }\n  ret.push_back(string(s.begin() + prev, s.end()));\n  return ret;\n}\n\nint get_coef(string& term) {\n  assert(!term.empty());\n  if(term[0] == 'x') return 1;\n  int n = term.size();\n  rep(i, n) {\n    if(term[i] == 'x') {\n      return stoi(string(term.begin(), term.begin() + i));\n    }\n  }\n  return stoi(term);\n}\n\nint get_expo(string& term) {\n  if(term.find('x') == string::npos) return 0;\n  if(term.find('^') == string::npos) return 1;\n  int n = term.size();\n  string expos;\n  for(int i=n-1; i>=0; i--) {\n    if(term[i] == '^') break;\n    expos += term[i];\n  }\n  reverse(expos.begin(), expos.end());\n  return stoi(expos);\n}\n\nvector<int> change_poly(string& s) {\n  vector<int> ret(51);\n  auto v = split(s);\n  for(auto && e: v)\n    ret[get_expo(e)] = get_coef(e);\n  return ret;\n}\n\nvoid output(vector<int>& ans) {\n  bool first = 0;\n  for(int i=50; i>=0; i--) {\n    if(ans[i] > 0) {\n      if(first) cout << '+';\n      first = 1;\n      if(ans[i] > 1 || (ans[i] == 1 && i == 0)) cout << ans[i];\n      if(i > 0) cout << 'x';\n      if(i > 1) cout << \"^\" << i;\n    }\n  }\n  cout << endl;\n}\n\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\nint main() {\n\n  while(cin >> N >> M && (N | M)) {\n    vector<tuple<int, int, vector<int>>> in;\n    rep(i, M) {\n      int s, t; cin >> s >> t; s--, t--;\n      string poly; cin >> poly; auto r = change_poly(poly);\n      in.emplace_back(s, t, r);\n    }\n\n    init();\n\n    rep(i, M) {\n      add_edge(get<0>(in[i]), get<1>(in[i]), get<2>(in[i]));\n      add_edge(get<1>(in[i]), get<0>(in[i]), get<2>(in[i]));\n    }\n\n//    add_edge(S, 0, inf_flow);\n//    add_edge(N-1, T, inf_flow);\n    auto ans = max_flow(0, N-1);\n\n    int all0 = 1;\n    rep(i, ans.size()) {\n      all0 &= ans[i] == 0;\n    }\n\n    if(all0) cout << 0 << endl;\n    else output(ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int L = 51;\n\nstruct Edge {\n  int to, cost, rev;\n  map<int, int> cap;\n  Edge(int to, int cost, map<int, int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdgeF(int from, int to, int cost, map<int, int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, map<int, int>(), (int)g[from].size()-1));\n}\n\ninline map<int, int>& add(map<int, int> &a, const map<int, int> &b) {\n  for(map<int, int>::const_iterator it = b.begin();\n      it != b.end(); ++it) {\n    a[it->first] += it->second;\n    if(a[it->first] == 0) a.erase(it->first);\n  }\n  return a;\n}\n\ninline map<int, int>& subtract(map<int, int> &a, const map<int, int> &b) {\n  for(map<int, int>::const_iterator it = b.begin();\n      it != b.end(); ++it) {\n    a[it->first] -= it->second;\n    if(a[it->first] == 0) a.erase(it->first);\n  }\n  return a;\n}\n\ninline bool lt(const map<int, int> &a, const map<int, int> &b) {\n  for(map<int, int>::const_reverse_iterator i = a.rbegin(), j = b.rbegin();\n      i != a.rend() || j != b.rend(); ++i, ++j) {\n    if(i == a.rend()) return true;\n    if(j == b.rend()) return false;\n    if(*i == *j) continue;\n    else return *i < *j;\n  }\n  return false;\n}\n\ninline bool le(const map<int, int> &a, const map<int, int> &b) {\n  for(map<int, int>::const_reverse_iterator i = a.rbegin(), j = b.rbegin();\n      i != a.rend() || j != b.rend(); ++i, ++j) {\n    if(i == a.rend()) return true;\n    if(j == b.rend()) return false;\n    if(*i == *j) continue;\n    else return *i < *j;\n  }\n  return true;\n}\n\nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0 &&\n     *min_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(abs(ans[i]) != 1) cout << abs(ans[i]);\n    if(i > 1) cout << \"x^\" << i;\n    else if(i == 1) cout << \"x\";\n    j++;\n  }\n  cout << endl;\n}\n\nmap<int, int> dfsF(int v, int t, map<int, int> f, vector<int> &used, Graph &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(!used[e.to] && lt(map<int, int>(), e.cap)) {\n      map<int, int> d = dfsF(e.to, t, lt(f, e.cap) ? f : e.cap, used, g);\n      if(lt(map<int, int>(), d)) {\n\tsubtract(e.cap, d);\n\tadd(g[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return map<int, int>();\n}\n\nvector<int> maxFlow(int s, int t, Graph g) {\n  map<int, int> flow;\n  while(1) {\n    vector<int> used(g.size());\n    map<int, int> minf; minf[L-1] = INF;\n    map<int, int> f = dfsF(s, t, minf, used, g);\n    if(le(f, map<int, int>())) break;\n    add(flow, f);\n  }\n  vector<int> ans(L);\n  for(map<int, int>::iterator it = flow.begin();\n      it != flow.end(); ++it) {\n    ans[it->first] = it->second;\n  }\n  return ans;\n}\n\nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      map<int, int> cap;\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n\tint a = 1;\n\t{\n\t  int i = 0;\n\t  while(i < s.size() && isdigit(s[i])) ++i;\n\t  if(i) {\n\t    a = atoi(s.substr(0, i).c_str());\n\t    s = s.substr(i);\n\t  }\n\t}\n\tint k = 0;\n\t// \"\" or \"x\" or \"x^y\"\n\tif(s == \"x\") {\n\t  k = 1;\n\t} else if(s.size()) {\n\t  k = atoi(s.substr(2).c_str());\n\t}\n\tcap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      addEdgeF(v, u, 0, cap, g);\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge { int to,cap,rev; };\n#define MAX 60\n#define INF (1e7)\nint n;\nvector<int> G[MAX][MAX];\nbool used[MAX];\n\nvector<int> min(vector<int> &a,vector<int> &b){\n  for(int i=MAX-1;i>=0;i--){\n    if( a[i]==b[i] )continue;\n    if(a[i]>b[i])return b;\n    if(a[i]<b[i])return a;\n  }\n  return a;\n}\n\nvector<int> add(vector<int> &a,vector<int> &b){\n  for(int i=0;i<MAX;i++)\n    a[i]+=b[i];\n  return a;\n}\n\nvector<int> sub(vector<int> &a,vector<int> b){\n  for(int i=0;i<MAX;i++)\n    a[i]-=b[i];\n  return a;\n}\n\nbool check(vector<int> &a){\n  for(int i=0;i<MAX;i++)\n    if(a[i]>0)return true;\n  return false;\n}\n\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=1;i<=n;i++){\n    vector<int> &e=G[v][i];\n    if(!used[i] && check(e) ){\n      vector<int> d=dfs( i,t,min(f,e));\n      if( check(d) ){\n        G[v][i]=sub(G[v][i],d);\n        G[i][v]=add(G[i][v],d);\n        return d;\n      }\n    }\n  }\n  return vector<int>();\n}\n\nvector<int> max_flow(int s,int t){\n  vector<int> flow(MAX,0);\n  while(1){\n    memset(used,0,sizeof(used));\n    vector<int> tmp(MAX,INF);\n    vector<int> f=dfs(s,t,tmp);\n    if(f.size()==0)return flow;\n    flow=add(flow,f);\n  }\n  return flow;\n}\n\nint m;\nint t[MAX][MAX][MAX];\nint u[MAX][MAX];\n\nint s2i(string s){\n  stringstream ss;\n  int res;\n  ss<<s;\n  ss>>res;\n  return res;\n}\n\nvoid func(int a,int b,string &tmp){\n  int len=tmp.size();\n  int flg=0;\n  for(int i=0;i<len;i++){\n    if('0'<=tmp[i]&&tmp[i]<='9')continue;\n    flg=1;\n  }\n  if(flg==0){\n    t[a][b][0]=t[b][a][0]=s2i(tmp);\n    return;\n  }\n  \n  int v,w;\n  if(tmp[0]=='x')v=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='x'){\n        v=s2i(tmp.substr(0,i));\n        break;\n      }\n    }\n  }\n  \n  if(tmp[len-1]=='x')w=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='^'){\n        w=s2i(tmp.substr(i+1));\n        break;\n      }\n    }\n  }\n  t[a][b][w]=t[b][a][w]=v;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)break;\n    memset(t,0,sizeof(t));\n    memset(u,0,sizeof(u));\n    for(int i=0;i<m;i++){\n      int a,b;\n      string s,tmp;\n      cin>>a>>b>>s;\n      for(int j=0;j<(int)s.size();j++)\n        if(s[j]=='+')s[j]=' ';\n      stringstream ss(s);\n      while(ss>>tmp){\n        func(a,b,tmp);\n      }\n    }\n\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n        G[i][j].clear();\n        for(int k=0;k<MAX;k++){\n          G[i][j].push_back(t[i][j][k]);\n        }\n      }\n    }\n\n    vector<int> ans=max_flow(1,n);\n    bool cnt=0;\n    for(int i=MAX-1;i>=0;i--){\n      if(ans[i]==0)continue;\n      if(cnt>0)cout<<'+';\n      cnt++;\n      if(i==0||ans[i]>1)cout<<ans[i];\n      if(i)cout<<'x';\n      if(i>1)cout<<\"^\"<<i;\n    }\n    if(cnt==0)cout<<0;\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\nconst int L=50;\n\nvi parse(string s)\n{\n\treplace(all(s),'+',' ');\n\tistringstream iss(s);\n\tvi res(L+1);\n\tfor(string t;iss>>t;){\n\t\tint c=isdigit(t[0])?0:1,i=0;\n\t\tfor(;i<t.size() && isdigit(t[i]);i++)\n\t\t\tc=c*10+t[i]-'0';\n\t\tif(i==t.size()){ // c*x^0\n\t\t\tres[0]+=c;\n\t\t\tcontinue;\n\t\t}\n\t\tassert(t[i]=='x');\n\t\ti++;\n\t\tif(i==t.size()){ // c*x^1\n\t\t\tres[1]+=c;\n\t\t\tcontinue;\n\t\t}\n\t\tassert(t[i]=='^');\n\t\ti++;\n\t\tint r=0;\n\t\tfor(;i<t.size() && isdigit(t[i]);i++)\n\t\t\tr=r*10+t[i]-'0';\n\t\tres[r]+=c;\n\t}\n\treturn res;\n}\n\nstruct Edge{\n\tint src,dst,cap,flow;\n\tEdge(){}\n\tEdge(int s,int d,int c,int f=0):src(s),dst(d),cap(c),flow(f){}\n};\nstruct Graph{\n\tvector<Edge> es;\n\tvi head,next;\n\tGraph(){}\n\tGraph(int n):head(n,-1){}\n\t// 有向辺を追加するとき逆辺の容量c2は普通0である．\n\t// 両方向に容量があるならc2も指定する．\n\tvoid AddEdge(int u,int v,int c1,int c2=0){\n\t\tes.emplace_back(u,v,c1); next.push_back(head[u]); head[u]=es.size()-1;\n\t\tes.emplace_back(v,u,c2); next.push_back(head[v]); head[v]=es.size()-1;\n\t}\n};\n\nvoid BFS(const Graph& g,int tap,vi& layer)\n{\n\tqueue<pii> q; q.emplace(tap,0);\n\twhile(q.size()){\n\t\tint u,d; tie(u,d)=q.front(); q.pop();\n\t\tif(layer[u]!=INF) continue;\n\t\tlayer[u]=d;\n\t\tfor(int i=g.head[u];i!=-1;i=g.next[i])\n\t\t\tif(g.es[i].cap-g.es[i].flow>0)\n\t\t\t\tq.emplace(g.es[i].dst,d+1);\n\t}\n}\n\nint DFS(Graph& g,int v,int sink,const vi& layer,int flow)\n{\n\tif(v==sink) return flow;\n\tint f=flow;\n\tfor(int& i=g.head[v];i!=-1;i=g.next[i]){\n\t\tEdge& e=g.es[i];\n\t\tif(layer[e.src]>=layer[e.dst]) continue;\n\t\tint residue=e.cap-e.flow;\n\t\tif(residue==0) continue;\n\t\tint augment=DFS(g,e.dst,sink,layer,min(residue,f));\n\t\te.flow+=augment;\n\t\tg.es[i^1].flow-=augment;\n\t\tf-=augment;\n\t\tif(f==0) break;\n\t}\n\treturn flow-f;\n}\n\nint Dinic(Graph& g,int tap,int sink)\n{\n\tint res=0;\n\tfor(int n=g.head.size();;){\n\t\tvi layer(n,INF);\n\t\tBFS(g,tap,layer);\n\t\tif(layer[sink]==INF) break;\n\t\tvi temp=g.head;\n\t\tres+=DFS(g,tap,sink,layer,INF);\n\t\tswap(g.head,temp);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvvvi c(n,vvi(n,vi(L+1)));\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tstring s; cin>>s;\n\t\t\tvi tmp=parse(s);\n\t\t\trep(j,L+1){\n\t\t\t\tc[u][v][j]+=tmp[j];\n\t\t\t\tc[v][u][j]+=tmp[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi res(L+1);\n\t\tper(k,L+1){\n\t\t\tGraph g(n);\n\t\t\trep(i,n) repi(j,i+1,n) if(c[i][j][k] || c[j][i][k])\n\t\t\t\tg.AddEdge(i,j,c[i][j][k],c[j][i][k]);\n\t\t\tres[k]=Dinic(g,0,n-1);\n\t\t\tif(k==0) continue;\n\t\t\tfor(auto e:g.es)\n\t\t\t\tif(e.cap-e.flow>0)\n\t\t\t\t\tc[e.src][e.dst][k-1]=INF;\n\t\t}\n\t\t\n\t\tbool first=true;\n\t\tper(i,res.size()) if(res[i] || (first && i==0)){\n\t\t\tif(!first) cout<<'+';\n\t\t\telse       first=false;\n\t\t\tif(res[i]>1 || i==0) cout<<res[i];\n\t\t\tif(i>0) cout<<'x';\n\t\t\tif(i>1) cout<<'^'<<i;\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\n\n\n#define _GLIBCXX_DEBUG\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\nconst long long int L_INF = 9223372036854775807;\n\ntypedef vector<int> Weight;\nconst Weight INF = vector<int>(100, 1);\nconst Weight ZERO = vector<int>(100, 0);\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator <(const Weight&l, const Weight&r) {\n\tfor (int i = 99; i >=0; --i) {\n\t\tif (l[i] != r[i])return l[i] < r[i];\n\t}\n\treturn false;\n}\nbool operator >(const Weight&l, const Weight&r) {\n\tfor (int i = 99; i >= 0; --i) {\n\t\tif (l[i] != r[i])return l[i] > r[i];\n\t}\n\treturn false;\n}\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nWeight operator+(const Weight&l, const Weight&r) {\n\tvector<int>ans(100);\n\tfor (int i = 0; i < 100; ++i) {\n\t\tans[i] = l[i] + r[i];\n\t}\n\treturn ans;\n}\nWeight operator-(const Weight&l, const Weight&r) {\n\tvector<int>ans(100);\n\tfor (int i = 0; i < 100; ++i) {\n\t\tans[i] = l[i] - r[i];\n\t}\n\treturn ans;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\n//??????0??????????????????????????¨??£???????±??????????????????§??¨???\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, ag[i][j].weight));\n\t\t\t}\n\t\t}\n\t}\n\tint n = g.size();\n\tMatrix flow(n, Array(n,ZERO)), capacity(n, Array(n, ZERO));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] =capacity[e->src][e->dst]+ e->weight;\n\n\n\tWeight total = ZERO;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > ZERO) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0)break; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j]) {\n\t\t\tauto v(RESIDUE(prev[j], j));\n\t\t\tif (inc > v) {\n\t\t\t\tinc =v;\n\t\t\t}\n\t\t}\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] =flow[prev[j]][j]+inc, flow[j][prev[j]] =flow[j][prev[j]]- inc;\n\t\ttotal =total+ inc;\n\t}\n\n\treturn total;\n}\nint a = 0;\nstring st;\nint getnum() {\n\tint num = 0;\n\twhile (a!=st.size()&&isdigit(st[a])) {\n\t\tnum = num * 10 + st[a] - '0';\n\t\ta++;\n\t}\n\treturn num;\n}\npair<int, int>getx() {\n\tint num = 1;\n\tif (isdigit(st[a])) {\n\t\tnum = getnum();\n\t}\n\tint base;\n\tif (a == st.size() || st[a] == '+') {\n\t\tbase = 0;\n\t}\n\telse {\n\t\tassert(st[a] == 'x');\n\t\ta++;\n\t\tif (a == st.size() || st[a] == '+') {\n\t\t\tbase = 1;\n\t\t}\n\t\telse {\n\t\t\tassert(st[a] == '^');\n\t\t\ta++;\n\t\t\tbase = getnum();\n\t\t}\n\t}\n\treturn make_pair(base, num);\n}\nvector<int>getvec() {\n\tvector<int>v(100);\n\tauto p = getx();\n\tv[p.first] = p.second;\n\twhile (a != st.size()) {\n\t\ta++;\n\t\tauto p = getx();\n\t\tv[p.first] = p.second;\n\t}\n\treturn v;\n}\nvoid makest(const vector<int>&vs) {\n\n\tbool fst = true;\n\tfor (int i = 99; i >= 0; --i) {\n\t\tif (vs[i]) {\n\t\t\tif (!fst)cout << \"+\";\n\t\t\tif (i) {\n\t\t\t\tif (vs[i] >= 2) {\n\t\t\t\t\tcout << vs[i];\n\t\t\t\t}\n\t\t\t\tif (i >= 1) {\n\t\t\t\t\tcout << 'x';\n\t\t\t\t\tif (i >= 2) {\n\t\t\t\t\t\tcout << '^';\n\t\t\t\t\t\tcout << i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << vs[i] << endl;\n\t\t\t}\n\t\t\t\n\t\t\tfst =false;\n\t\t}\n\t}\n\tif (fst)cout << '0';\n\tcout << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tGraph g(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u, v; string p; cin >> u >> v >> p;\n\t\t\tst = p;\n\t\t\tu--; v--;\n\t\t\ta = 0;\n\t\t\tauto aa(getvec());\n\t\t\tg[u].emplace_back(u, v, aa);\n\t\t}\n\t\tWeight ans = maximumFlow(g, 0, N - 1);\n\t\tmakest(ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e4\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  assert(res.size()==v.size());\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  assert(res.size()==v.size());\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  assert(A.size()==B.size());\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      assert(d.size()==f.size());\n      /*      for(int j=0;j<d.size();j++){\n\tcout<<j<<endl;\n\tassert(d[j]!=INF);\n\t}*/\n      \n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> r=vector<int>(V,0);\n    r[0]=INF;\n    vector<int> f = dfs(s, t, r);\n    if(isall0(f)) return flow;\n    /*if(isallnotINF(f)) */Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    assert(0!=n-1);\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 111);\n\nPoly operator-(const Poly a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\n\ntypedef int Weight;\ntypedef Poly Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, ZERO, 0 });\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > ZERO)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > ZERO)\n\t\t\t{\n\t\t\t\te.cap = e.cap - d;\n\t\t\t\tg[e.dest][e.rev].cap = g[e.dest][e.rev].cap + d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = ZERO;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == ZERO) return flow;\n\t\tflow = f + flow;\n\t}\n}\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[50 - m] = c;\n\t\t\t\tassert(s[p] == '+');\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[49] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[50] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = ford_fulkerson(g, 0, n - 1);\n\t\tstring anss;\n\t\tREP(i, ans.size())\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i < 49)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(50-i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(50-i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 49)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 50)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int L = 51;\n\nstruct Edge {\n  int to, cost, rev;\n  vector<int> cap;\n  Edge(int to, int cost, vector<int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdgeF(int from, int to, int cost, vector<int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, vector<int>(L), (int)g[from].size()-1));\n}\n\ninline vector<int>& add(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] += b[i];\n  return a;\n}\n\ninline vector<int>& subtract(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] -= b[i];\n  return a;\n}\n\ninline bool lt(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return false;\n}\n\ninline bool le(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return true;\n}\n\nvector<int> dfsF(int v, int t, vector<int> f, vector<int> &used, Graph &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(!used[e.to] && lt(vector<int>(L), e.cap)) {\n      vector<int> nf;\n      if(lt(f, e.cap)) nf = f;\n      else nf = e.cap;\n      vector<int> d = dfsF(e.to, t, nf, used, g);\n      if(lt(vector<int>(L), d)) {\n\tsubtract(e.cap, d);\n\tadd(g[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>(L);\n}\n\nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(abs(ans[i]) != 1) cout << abs(ans[i]);\n    if(i > 1) cout << \"x^\" << i;\n    else if(i == 1) cout << \"x\";\n    j++;\n  }\n  cout << endl;\n}\n\nvector<int> maxFlow(int s, int t, Graph g) {\n  vector<int> flow(L);\n  while(1) {\n    vector<int> used(g.size());\n    vector<int> f = dfsF(s, t, vector<int>(L, INF), used, g);\n    if(le(f, vector<int>(L))) break;\n    add(flow, f);\n  }\n  return flow;\n}\n\nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      vector<int> cap(L);\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n\tint a = 1;\n\t{\n\t  int i = 0;\n\t  while(i < s.size() && isdigit(s[i])) ++i;\n\t  if(i) {\n\t    a = atoi(s.substr(0, i).c_str());\n\t    s = s.substr(i);\n\t  }\n\t}\n\tint k = 0;\n\t// \"\" or \"x\" or \"x^y\"\n\tif(s == \"x\") {\n\t  k = 1;\n\t} else if(s.size()) {\n\t  k = atoi(s.substr(2).c_str());\n\t}\n\tcap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      addEdgeF(v, u, 0, cap, g);\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>calc(string s) {\n\ts += \"+\";\n\tvector<int>res(51);\n\tstring t;\n\tfor (char c : s) {\n\t\tif (c == '+') {\n\t\t\tif (t.back() == 'x')t += \"^1\";\n\t\t\tif (t.front() == 'x')t = \"1\" + t;\n\t\t\tif (count(t.begin(), t.end(), 'x') == 0)res[50] = stoi(t);\n\t\t\tint a = 0, b = 0;\n\t\t\tbool flag = true;\n\t\t\tfor (char c : t) {\n\t\t\t\tif (c == 'x')flag = false;\n\t\t\t\telse if (c == '^')continue;\n\t\t\t\telse if (flag)a = a * 10 + c - '0';\n\t\t\t\telse b = b * 10 + c - '0';\n\t\t\t}\n\t\t\tres[50 - b] = a;\n\t\t\tt = \"\";\n\t\t}\n\t\telse t += c;\n\t}\n\treturn res;\n}\nvoid add(vector<int>&a, vector<int>b) {\n\trep(i, a.size())a[i] += b[i];\n}\nvoid sub(vector<int>&a, vector<int>b) {\n\trep(i, a.size())a[i] -= b[i];\n}\nstruct edge { int to; vector<int>cap; int rev; };\nbool used[50];\nvector<edge>E[50];\n\nvoid add_edge(int from, int to, vector<int>cap) {\n\tE[from].push_back({ to,cap,(int)E[to].size() });\n\tE[to].push_back({ from,cap,(int)E[from].size() - 1 });\n}\nvector<int>dfs(int v, int t, vector<int>f) {\n\tused[v] = true;\n\tif (v == t)return f;\n\tfor (edge&e : E[v]) {\n\t\tif (used[e.to] || e.cap == vector<int>(51))continue;\n\t\tvector<int>d = dfs(e.to, t, min(f, e.cap));\n\t\tif (d != vector<int>(51)) {\n\t\t\tsub(e.cap, d); add(E[e.to][e.rev].cap, d);\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn vector<int>(51);\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\trep(i, n)E[i].clear();\n\t\trep(i, m) {\n\t\t\tint a, b; string s; cin >> a >> b >> s; a--; b--;\n\t\t\tadd_edge(a, b, calc(s));\n\t\t}\n\t\tvector<int>INF(51, INT_MAX);\n\t\tvector<int>res(51);\n\t\twhile (1) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tvector<int>f = dfs(0, n - 1, INF);\n\t\t\tif (f == vector<int>(51))break;\n\t\t\tadd(res, f);\n\t\t}\n\t\tbool flag = false;\n\t\trep(i, 51) {\n\t\t\tif (res[i] == 0)continue;\n\t\t\tif (flag)printf(\"+\");\n\t\t\tif (i == 50)printf(\"%d\", res[i]);\n\t\t\telse if (i == 49) {\n\t\t\t\tif (res[i] == 1)printf(\"x\");\n\t\t\t\telse printf(\"%dx\", res[i]);\n\t\t\t}\n\t\t\telse if (res[i] == 1)printf(\"x^%d\", 50 - i);\n\t\t\telse printf(\"%dx^%d\", res[i], 50 - i);\n\t\t\tflag = true;\n\t\t}\n\t\tif (!flag)printf(\"0\");\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,rev;\n\tvector<int> cap;\n\tedge(){}\n\tedge(int tt,vector<int> cc,int rr){\n\t\tto=tt;\n\t\trev=rr;\n\t\tcap.resize(cc.size());\n\t\tfor(int i=0;i<cc.size();i++){\n\t\t\tcap[i]=cc[i];\n\t\t}\n\t}\n};\n\nclass dinic{\npublic:\n\tconst int INF=100000;\n\tvector<edge> G[501];\n\tint level[501];\n\tint iter[501];\n\tvoid add_edge(int from,int to,vector<int> cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,cap,G[from].size()-1));\n\t}\n\n\tbool checkemp(vector<int> &cap){\n\t\tint s=cap.size();\n\t\tfor(int i=s-1;i>=0;i--){\n\t\t\tif(cap[i]>0)return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvector<int> getmin(vector<int> a,vector<int> b){\n\t\tvector<int> c(a.size());\n\t\tbool flag=false;\n\t\tbool flag2=false;\n\t\tfor(int i=(int)c.size()-1;i>=0;i--){\n\t\t\tif(flag){\n\t\t\t\tc[i]=max(a[i],b[i]);\n\t\t\t}else if(flag2){\n\t\t\t\tc[i]=b[i];\n\t\t\t}else{\n\t\t\t\tc[i]=min(a[i],b[i]);\n\t\t\t}\n\t\t\tif(a[i]<b[i]){\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t\tif(a[i]>b[i]){\n\t\t\t\tflag2=true;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\n\tvoid bfs(int s){\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(!checkemp(e.cap) && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dfs(int v,int t,vector<int> f){\n\t\tif(v==t)return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(!checkemp(e.cap) && level[v]<level[e.to]){\n\t\t\t\tvector<int> d=dfs(e.to,t,getmin(f,e.cap));\n\t\t\t\tif(!checkemp(d)){\n\t\t\t\t\tfor(int j=0;j<e.cap.size();j++){\n\t\t\t\t\t\te.cap[j]-=d[j];\n\t\t\t\t\t\tG[e.to][e.rev].cap[j]+=d[j];\n\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> zer(f.size(),0);\n\t\treturn zer;\n\t}\n\tvector<int> max_flow(int s,int t,int size){\n\t\tvector<int> flow(size,0);\n\t\tvector<int> alINF(size,INF);\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\tvector<int> f;\n\t\t\twhile(!checkemp(f=dfs(s,t,alINF))){\n\t\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\t\tflow[i]+=f[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nstring get_string(int v){\n\tstring ret=\"\";\n\twhile(v>0){\n\t\tret+=('0'+v%10);\n\t\tv/=10;\n\t}\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\n\n\ndinic di;\n\nint n,m;\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdi.G[i].clear();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v;\n\t\t\tstring str;\n\t\t\tcin >> u >> v >> str;\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tint digit=0;\n\t\t\tvector<int> tp(51,0);\n\t\t\tfor(int j=0;j<str.size();j++){\n\t\t\t\tif(str[j]>='0' && str[j]<='9'){\n\t\t\t\t\tdigit*=10;\n\t\t\t\t\tdigit+=(str[j]-'0');\n\t\t\t\t}else if(str[j]=='x'){\n\t\t\t\t\tif(digit==0)digit=1;\n\t\t\t\t\tif(j+1<str.size() && str[j+1]=='^'){\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tint dg2=0;\n\t\t\t\t\t\twhile((str[j]>='0' && str[j]<='9')){\n\t\t\t\t\t\t\tdg2*=10;\n\t\t\t\t\t\t\tdg2+=(str[j]-'0');\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttp[dg2]=digit;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttp[1]=digit;\n\t\t\t\t\t}\n\t\t\t\t\tdigit=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(digit>0){\n\t\t\t\ttp[0]=digit;\n\t\t\t}\n\t\t\tdi.add_edge(u,v,tp);\n\t\t\t\n\t\t}\n\t\tvector<int> ans=di.max_flow(0,n-1,51);\n\t\tstring best=\"\";\n\t\tbool flag=false;\n\t\tfor(int i=50;i>=0;i--){\n\t\t\tif(ans[i]>0){\n\t\t\t\tif(flag)best+='+';\n\t\t\t\tbest+=get_string(ans[i]);\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(ans[i]==1){\n\t\t\t\t\t\tbest.erase(best.end()-1);\n\t\t\t\t\t}\n\t\t\t\t\tbest+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tbest+=\"^\";\n\t\t\t\t\t\tbest+=get_string(i);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tif(best.size()==0)best+='0';\n\t\tcout << best << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>calc(string s) {\n\tvector<int>res(51);\n\tint u = 0, v = 0;\n\tbool flag = true;\n\tfor (char c : s) {\n\t\tif (isdigit(c)) {\n\t\t\tif (flag)u = u * 10 + c - '0';\n\t\t\telse v = v * 10 + c - '0';\n\t\t}\n\t\tif (c == '^')flag = false;\n\t\tif (c == '+') {\n\t\t\tflag = true;\n\t\t\tif (u == 0)u = 1;\n\t\t\tif (v == 0)v = 1;\n\t\t\tres[50 - v] = u; u = v = 0;\n\t\t}\n\t}\n\treturn res;\n}\nvoid add(vector<int>&a, vector<int>b) {\n\trep(i, a.size())a[i] += b[i];\n}\nvoid sub(vector<int>&a, vector<int>b) {\n\trep(i, a.size())a[i] -= b[i];\n}\nstruct edge { int to; vector<int>cap; int rev; };\nbool used[50];\nvector<edge>E[50];\n\nvoid add_edge(int from, int to, vector<int>cap) {\n\tE[from].push_back({ to,cap,(int)E[to].size() });\n\tE[to].push_back({ from,cap,(int)E[from].size() - 1 });\n}\nvector<int>dfs(int v, int t, vector<int>f) {\n\tused[v] = true;\n\tif (v == t)return f;\n\tfor (edge&e : E[v]) {\n\t\tif (used[e.to] || e.cap == vector<int>(51))continue;\n\t\tvector<int>d = dfs(e.to, t, min(f, e.cap));\n\t\tif (d != vector<int>(51)) {\n\t\t\tsub(e.cap, d); add(E[e.to][e.rev].cap, d);\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn vector<int>(51);\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\trep(i, n)E[i].clear();\n\t\trep(i, m) {\n\t\t\tint a, b; string s; cin >> a >> b >> s; a--; b--;\n\t\t\tauto v = calc(s);\n\t\t\tadd_edge(a, b, calc(s));\n\t\t}\n\t\tvector<int>INF(51, INT_MAX);\n\t\tvector<int>res(51);\n\t\twhile (1) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tvector<int>f = dfs(0, n - 1, INF);\n\t\t\tif (f == vector<int>(51))break;\n\t\t\tadd(res, f);\n\t\t}\n\t\tbool flag = false;\n\t\trep(i, 51) {\n\t\t\tif (res[i] == 0)continue;\n\t\t\tif (flag)printf(\"+\");\n\t\t\tif (res[i] == 1)printf(\"x^%d\", 51 - i - 1);\n\t\t\telse printf(\"%dx^%d\", res[i], 51 - i - 1);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cassert>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_L = 50;\ntypedef array<int, MAX_L + 1> A;\n\nstruct weight {\n\tA coefficients;\n\n\tinline static int number(string::const_iterator &it) {\n\t\tint res = 0;\n\t\twhile(isdigit(*it)) {\n\t\t\tres = res * 10 + *it - '0';\n\t\t\t++it;\n\t\t}\n\t\treturn res;\n\t}\n\n\tinline void parse(string::const_iterator &it) {\n\t\tconst int c = (isdigit(*it) ? number(it) : 1);\n\n\t\tif(*it != 'x') {\n\t\t\tcoefficients.back() = c;\n\t\t\treturn;\n\t\t}\n\n\t\t++it;\n\n\t\tint e = 1;\n\t\tif(*it == '^') {\n\t\t\t++it;\n\t\t\te = number(it);\n\t\t}\n\n\t\tcoefficients[MAX_L - e] = c;\n\t}\n\n\tweight(const string &s = \"0\") {\n\t\tcoefficients.fill(0);\n\n\t\tstring::const_iterator it = s.cbegin();\n\t\tparse(it);\n\t\twhile(*it == '+') {\n\t\t\t++it;\n\t\t\tparse(it);\n\t\t}\n\t}\n\n\tweight(const A &a):coefficients(a) {}\n\tweight(const weight &w):coefficients(w.coefficients) {}\n\n\tinline bool operator<(const weight &w) const {\n\t\treturn coefficients < w.coefficients;\n\t}\n\n\n\tinline weight &operator+=(const weight &w) {\n\t\tfor(unsigned i = 0; i < coefficients.size(); ++i) {\n\t\t\tcoefficients[i] += w.coefficients[i];\n\t\t}\n\t\treturn *this;\n\t}\n\n\tinline weight &operator-=(const weight &w) {\n\t\tfor(unsigned i = 0; i < coefficients.size(); ++i) {\n\t\t\tcoefficients[i] = max(0, coefficients[i] - w.coefficients[i]);\n\t\t}\n\t\treturn *this;\n\t}\n\n\tinline string to_string() const {\n\t\tstring res;\n\t\tfor(unsigned i = 0; i < coefficients.size(); ++i) {\n\t\t\tif(coefficients[i] != 0) {\n\t\t\t\tif(res.size()) res += '+';\n\n\t\t\t\tconst int e = MAX_L - i;\n\n\t\t\t\tif(e == 0 || coefficients[i] > 1) {\n\t\t\t\t\tres += std::to_string(coefficients[i]);\n\t\t\t\t}\n\n\t\t\t\tif(e >= 1) {\n\t\t\t\t\tres += 'x';\n\t\t\t\t\tif(e >= 2) res += \"^\" + std::to_string(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(res == \"\") res = \"0\";\n\t\treturn res;\n\t}\n};\n\nstruct edge {\n\tint to;\n\tweight cap;\n\tint rev;\n\tedge(int to_, weight cap_, int rev_):to(to_), cap(cap_), rev(rev_){}\n};\n\nconst weight INF(\"1000x^50\");\nconst weight ZERO;\n\nvector<vector<edge> > G;\nvector<int> level;\nvector<int> iter;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n\tlevel.resize(V);\n\titer.resize(V);\n}\n\nvoid add_edge(int from, int to, weight cap) {\n\tG[from].emplace_back(to, cap, G[to].size());\n\tG[to].emplace_back(from, cap, G[from].size() - 1);\n}\n\nvoid bfs(int s) {\n\tfill(level.begin(), level.end(), -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(ZERO < e.cap && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nweight dfs(int v, int t, weight f) {\n\tif(v == t) return f;\n\n\tfor(int &i = iter[v]; i < static_cast<int>(G[v].size()); ++i) {\n\t\tedge &e = G[v][i];\n\t\tif(ZERO < e.cap && level[v] < level[e.to]) {\n\t\t\tconst weight d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(ZERO < d) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ZERO;\n}\n\nweight max_flow(int s, int t) {\n\tweight flow = ZERO;\n\n\tfor(;;) {\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\n\t\tfill(iter.begin(), iter.end(), 0);\n\t\tfor(weight f; ZERO < (f = dfs(s, t, INF)); flow += f);\n\t}\n}\n\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tinit(n);\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b;\n\t\t\tstring p;\n\t\t\tcin >> a >> b >> p;\n\t\t\tadd_edge(a - 1, b - 1, weight(p));\n\t\t}\n\n\t\tcout << max_flow(0, n - 1).to_string() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define min(x,y) (x<y?x:y)\nusing namespace std;\nusing namespace rel_ops;\ntypedef vector<int> poly;\nconst int MX=50;\t\t\t//max deg\nint deg(poly x){\n\tfor(int i=MX;i>=0;i--) if(x[i]!=0) return i;\n\treturn -1;\n}\nbool operator<(poly x,poly y){\n\tfor(int i=MX;i>=0;i--){\n\t\tif(x[i]<y[i]) return 1;\n\t\tif(x[i]>y[i]) return 0;\n\t}\n\treturn 0;\n}\nbool operator>(poly x,poly y){return (y<x);}\npoly operator+(poly x,poly y){\n\trep(i,MX+1) x[i]+=y[i];\n\treturn x;\n}\npoly operator-(poly x,poly y){\n\trep(i,MX+1) x[i]-=y[i];\n\treturn x;\n}\nvoid operator+=(poly &x,poly y){\n\trep(i,MX+1) x[i]+=y[i];\n}\nvoid operator-=(poly &x,poly y){\n\trep(i,MX+1) x[i]-=y[i];\n}\npoly operator*(poly x,poly y){\n\tpoly z(MX+1,0);\n\trep(i,MX+1) rep(j,MX+1-i) z[i+j]+=x[i]*y[j];\n\treturn z;\n}\npoly operator*(int x,poly y){\n\trep(i,MX+1) y[i]*=x;\n\treturn y;\n}\nvoid showpoly(poly x){\n\tint N=deg(x);\n\tif(N==-1){\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(x[i]==0) continue;\n\t\tif(i!=N&&x[i]>0) cout<<\"+\";\n\t\tif(x[i]==-1) cout<<\"-\";\n\t\telse if(x[i]!=1) cout<<x[i];\n\t\tif(i==0){\n\t\t\tif(x[i]==1||x[i]==-1) cout<<\"1\";\n\t\t}else if(i==1){\n\t\t\tcout<<\"x\";\n\t\t}else{\n\t\t\tcout<<\"x^\"<<i;\n\t\t}\n\t}\n\tputs(\"\");\n}\nint num(string &s,int &it){\n\tint n=1;\n\tif(s[it]=='-'){\n\t\tit++;\n\t\tn=-1;\n\t}\n\tint x=0;\n\twhile(isdigit(s[it])){\n\t\tx=x*10+s[it++]-'0';\n\t}\n\treturn x*n;\n}\npoly term(string &s,int& it){\n\tint c=1;\n\tint d=0;\n\tif(isdigit(s[it])||s[it]=='-') c=num(s,it);\n\tif(s[it]=='x'){\n\t\tit++;\n\t\td=1;\n\t\tif(s[it]=='^'){\n\t\t\tit++;\n\t\t\td=num(s,it);\n\t\t}\n\t}\n\tpoly ret(MX+1);\n\tret[d]=c;\n\treturn ret;\n}\npoly sttopoly(string s){\n\ts+=\"$\";\n\tint it=0;\n\tpoly ret=term(s,it);\n\twhile(s[it]=='+'||s[it]=='-'){\n\t\tif(s[it]=='+'){\n\t\t\tit++;\n\t\t\tret=ret+term(s,it);\n\t\t}else{\n\t\t\tit++;\n\t\t\tret=ret-term(s,it);\n\t\t}\n\t}\n\treturn ret;\n}\n\ntypedef poly D;\nstruct edge {\n\tint to;\n\tD cap;\n\tint rev;\n\tedge(int to,D cap,int rev) :to(to),cap(cap),rev(rev){}\n};\nconst int MAX_V=50;\nD inf(51),zero(51);\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from, int to, D cap){\n\tedge e1(to,cap,G[to].size()),e2(from,cap,G[from].size());\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(edge& e:G[v]){\n\t\t\tif(e.cap>zero && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nD dfs(int v,int t,D f){\n//\tcout<<v<<\"v\"<<endl;\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>zero && level[v]<level[e.to]){\n\t\t\t// cout<<\"f=\";\n\t\t\t// showpoly(f);\n\t\t\t// cout<<\"e.cap=\";\n\t\t\t// showpoly(e.cap);\n\t\t\t// cout<<\"min=\";\n\t\t\t// showpoly(min(f,e.cap));\n\t\t\t// bool b=(f<e.cap);\n\t\t\t// show(b);\n\t\t\tD d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>zero){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero;\n}\nD max_flow(int s,int t){\n\tD flow=zero;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tD f=zero;\n\t\twhile( (f=dfs(s,t,inf))>zero ) flow+=f;\n\t}\n}\nint main(){\n\tinf[50]=100000000;\n\twhile(true){\n\t\tint N,M;\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\trep(i,N) G[i].clear();\n\t\trep(i,M){\n\t\t\tint x,y;\n\t\t\tstring s;\n\t\t\tcin>>x>>y>>s;\n\t\t\tadd_edge(x-1,y-1,sttopoly(s));\n\t\t}\n\t\tshowpoly(max_flow(0,N-1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(a[i]){\n\t\t\t\tif(i<n){\n\t\t\t\t\tret+=\"+\";\n\t\t\t\t}\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tret+=\"^\";\n\t\t\t\t\t\tret+=toString(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.n+1?left.a[i]:0)+(i<right.n+1?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.n+1?left.a[i]:0)-(i<right.n+1?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nconst poly Zero=to_poly(string(\"0\"));\nconst poly Inf=to_poly(string(\"x^51\"));\n\nvoid add_edge(int from,int to,poly& cap,vve &g){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly m=f<e.cap?f:e.cap;\n\t\t\tpoly d=dfs(e.to,t,m,g,used);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g);\n\t\t\tadd_edge(v,u,pol,g);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i,n) for (ll i=0; i<(ll)(n); ++i)\n#define FOR(i,k,n) for (ll i=(k); i<(ll)(n); ++i)\n#define FOREQ(i,k,n) for (ll i=(k); i<=(ll)(n); ++i)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define SZ(v) (ll)((v).size())\n#define MEMSET(v,h) memset((v),(h),sizeof(v))\n\ntypedef ll Weight;\nstruct Edge {\n  ll src;\n  ll dest;\n  Weight weight;\n  Edge() {;}\n  Edge(ll src, ll dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n/*\n   void PrllMatrix(const Matrix &mat) {\n   REP(y, h) {\n   REP(x, w) {\n   prllf(\"%d \", mat[y][x]);\n   }\n   puts(\"\");\n   }\n   }\n   */\n\nll MaxFlow(const Graph &g, ll s, ll t, Matrix &flow) {\n  const ll n = g.size();\n  flow = Matrix(n, Array(n, 0));\n  Matrix capacity(n, Array(n, 0));\n  REP(i, n) {\n    FORIT(it, g[i]) {\n      capacity[it->src][it->dest] += it->weight;\n    }\n  }\n  ll ret = 0;\n  vector<ll> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.front();\n      que.pop();\n      if (parent[node.dest] != -1) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      ll from = node.dest;\n      FORIT(it, g[from]) {\n        ll to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight f = 1 << 30;\n    ll from = parent[t];\n    ll to = t;\n    while (from != to) {\n      f = min(f, capacity[from][to]) ;\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      flow[from][to] += f;\n      flow[to][from] -= f;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += f;\n  }\n  return ret;\n}\n\nvoid AddEdge(Graph &g, ll from, ll to, ll weight) {\n  if (weight == 0) { return; }\n  g[from].push_back(Edge(from, to, weight));\n  g[to].push_back(Edge(to, from, weight));\n  cout << from << \" \" << to << \" \" << weight << endl;\n}\n\n//====================================\n\nll Getll(const char *str, ll &index) {\n  ll ret = 1;\n  if (isdigit(str[index])) {\n    ret = atoi(str + index);\n    while (isdigit(str[index])) { index++; }\n  }\n  return ret;\n}\n\nvector<ll> Parse(const char *str) {\n  vector<ll> ret(52, 0);\n  //ll len = strlen(str);\n  ll index = 0;\n  while (str[index]) {\n    ll a = Getll(str, index);;\n    ll degree = 0;\n    if (str[index] == 'x') {\n      degree = 1;\n      index++;\n      if (str[index] == '^') {\n        index++;\n        degree = Getll(str, index);\n      }\n    }\n    if (str[index] == '+') { index++; }\n    ret[degree] = a;\n  }\n  return ret;\n}\n\nvoid PrintAns(vector<ll> &ans) {\n  bool first = true;\n  for (ll i = 51; i >= 0; i--) {\n    if (ans[i] == 0) { continue; }\n    if (!first) { printf(\"+\"); }\n    first = false;\n    if (i == 0) {\n      printf(\"%lld\", ans[i]);\n    } else if (i >= 1) {\n      if (ans[i] >= 2) {\n        printf(\"%lld\", ans[i]);\n      }\n      printf(\"x\");\n      if (i >= 2) {\n        printf(\"^%lld\", i);\n      }\n    }\n  }\n  if (first) {\n    printf(\"0\");\n  }\n  puts(\"\");\n}\n\n\nconst ll INF = 1 << 28;\nll n, m;\n//ll u[1000];\n//ll v[1000];\nvector<ll> poly[60][60];\n//vector<ll> poly[1000];\nchar str[6666];\n\nint main() {\n  while (scanf(\"%lld %lld\", &n, &m), n|m) {\n    REP(y, 60) REP(x, 60) { poly[y][x] = vector<ll>(52, 0); }\n    REP(i, m) {\n      ll u, v;\n      scanf(\"%lld %lld %s\", &u, &v, str);\n      u--; v--;\n      vector<ll> p = Parse(str);\n      REP(j, 51) {\n        poly[u][v][j] += p[j];\n        poly[v][u][j] += p[j];\n      }\n    }\n    vector<ll> ans(52, 0);\n    for (ll i = 51; i >= 0; i--) {\n      Graph g(n);\n      REP(y, n) {\n        REP(x, n) {\n          if (poly[y][x][i] == 0) { continue; }\n          g[y].push_back(Edge(y, x, poly[y][x][i]));\n        }\n      }\n      Matrix flow;\n      ans[i] = MaxFlow(g, 0, n - 1, flow);\n      if (i != 0) {\n        REP(y, n) {\n          REP(x, n) {\n            if (poly[y][x][i] - flow[y][x] == 0) { continue; }\n            //if (poly[y][x][i] + flow[y][x] == 0) { continue; }\n            poly[y][x][i - 1] = INF;\n          }\n        }\n      }\n    }\n    PrintAns(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2328\n#include<iostream>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<sstream>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nconst int VMAX = 100;\nconst int INF = 1e7;\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[VMAX];\nbool used[VMAX];\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, cap, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n  used[v] = true;\n\n  for (int i = 0; i < G[v].size(); i++) {\n    edge &e = G[v][i];\n    if (!used[e.to] and e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n\n  while (true) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nconst int NMAX = 60, MMAX = 600, LMAX = 52;\n\nvector<int> coefficients[NMAX];\nint from[MMAX], to[MMAX];\n\nvoid init(int N) {\n  REP(i, N) {\n    coefficients[i].clear();\n  }\n}\n\nvoid init_flow(int v) {\n  REP(i, v) {\n    G[i].clear();\n  }\n}\n\nvector<string> split_by(char div, string str) {\n  vector<string> xs;\n  string x;\n  for (char c : str) {\n    if (c == div) {\n      xs.push_back(x);\n    } else {\n      x.push_back(c);\n    }\n  }\n  return xs;\n}\n\npair<int,int> factor2pair(string factor) {\n  auto index = factor.find('x', 0);\n  if (index == string::npos) {\n    int a;\n    istringstream is(factor);\n    is >> a;\n    return pair<int,int>(a,0);\n  } else if (factor.find('^', 0) == string::npos) {\n    factor = factor.substr(0, factor.length() - 1);\n    int a;\n    istringstream is(factor);\n    is >> a;\n    return pair<int,int>(a, 1);\n  } else {\n    int a, n;\n    string astr = factor.substr(0, index - 1),\n           nstr = factor.substr(index + 2);\n    istringstream is(astr);\n    is >> a;\n    is.clear();\n    is.str(nstr);\n    is >> n;\n    return pair<int,int>(a,n);\n  }\n}\n\nvector<int> polynomial2vector(string poly) {\n  vector<string> factors = split_by('+', poly);\n  vector<int> ans(LMAX);\n  for (string factor : factors) {\n    pair<int,int> p = factor2pair(factor);\n    ans[p.first] = p.second;\n  }\n  return ans;\n}\n\nstring vector2polynomial(vector<int> poly) {\n  string ans = \"\";\n  for (int i = 0, len = poly.size(); i < len; i++) {\n    if (! poly[i]) continue;\n    ans = poly[i] + (i == 0 ? \"\":\"x\") \n      + (i <= 1 ? \"\":\"^\" + to_string(i))+ ans;\n  }\n  return (ans.empty() ? \"0\" : ans);\n}\n\nint get_coefficient(int m, int l) {\n  return coefficients[m][l];\n}\n\nint main() {\n  int N, M;\n  while (cin >> N >> M and N) {\n    init(N);\n    REP(i, M) {\n      int u, v;\n      string poly;\n      cin >> u >> v >> poly;\n\n      from[i] = u;\n      to[i] = v;\n      coefficients[i] = polynomial2vector(poly);\n    }\n\n    int lmax;\n    vector<int> ans;\n\n    REP(l, lmax) {\n      init_flow(N);\n      REP(m, M) {\n        add_edge(from[m], to[m], get_coefficient(m, l));\n        add_edge(to[m], from[m], get_coefficient(m, l));\n      }\n      ans.push_back(max_flow(1, N));\n    }\n\n    reverse(ans.begin(), ans.end());\n\n    cout << vector2polynomial(ans) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  assert(res.size()==v.size());\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  assert(res.size()==v.size());\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  assert(A.size()==B.size());\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n/*bool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n  }*/\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      assert(d.size()==f.size());\n      //assert(isallnotINF(e.cap));\n      /*      for(int j=0;j<d.size();j++){\n\tcout<<j<<' '<<d[j]<<endl;\n\tassert(d[j]!=INF);\n\t}*/\n      \n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> r=vector<int>(V,0);\n    r[0]=INF;\n    vector<int> f = dfs(s, t, r);\n    if(isall0(f)) return flow;\n    /*if(isallnotINF(f)) */Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    assert(0!=n-1);\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring toStr(long long n)\n{\n\tchar buf[50];\n\tsprintf(buf, \"%d\", n);\n\treturn buf;\n}\n\nstruct poly{\n\tlong long a[55];\n\tpoly(){\n\t\tfor(long long i = 0; i <= 51; i++) a[i] = 0;\n\t}\n\tpoly(string s)\n\t{\n\t\tfor(long long i = 0; i <= 51; i++) a[i] = 0;\n\t\t\n\t\ts = s + \"+\";\n\t\tstring buf;\n\t\tlong long state = 0, coe;\n\t\tfor(long long i = 0; i < s.size(); i++){\n\t\t\tif(state == 0){\n\t\t\t\tif(s[i] == 'x'){\n\t\t\t\t\tif(buf == \"\") buf = \"1\";\n\t\t\t\t\tcoe = atoi(buf.c_str());\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\t\t\t\telse if(s[i] == '+'){\n\t\t\t\t\ta[0] = atoi(buf.c_str());\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbuf += s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(state == 1){\n\t\t\t\tif(s[i] == '^'){\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse if(s[i] == '+'){\n\t\t\t\t\ta[1] = coe;\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(state == 2){\n\t\t\t\tif(s[i] == '+'){\n\t\t\t\t\ta[atoi(buf.c_str())] = coe;\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbuf += s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstring output()\n\t{\n\t\tstring ret;\n\t\tfor(long long i = 51; i > 0; i--){\n\t\t\tif(a[i] == 0) continue;\n\t\t\tif(a[i] != 1) ret += toStr(a[i]);\n\t\t\tret += \"x\";\n\t\t\tif(i > 1) ret += \"^\" + toStr(i);\n\t\t\tret += \"+\";\n\t\t}\n\t\tif(ret.size() > 0){\n\t\t\tif(a[0] == 0) ret.erase(ret.end()-1);\n\t\t\telse ret += toStr(a[0]);\n\t\t}\n\t\telse ret = toStr(a[0]);\n\t\treturn ret;\n\t}\n\tpoly operator+(const poly& obj)\n\t{\n\t\tpoly ret;\n\t\tfor(long long i = 0; i <= 51; i++){\n\t\t\tret.a[i] = a[i] + obj.a[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpoly operator-(const poly& obj)\n\t{\n\t\tpoly ret;\n\t\tfor(long long i = 0; i <= 51; i++){\n\t\t\tret.a[i] = a[i] - obj.a[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tbool operator<(const poly& obj)const\n\t{\n\t\tfor(long long i = 51; i >= 0; i--){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator<=(const poly& obj)const\n\t{\n\t\tfor(long long i = 51; i >= 0; i--){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\n\nstruct edge{\n\tlong long to, rev;\n\tpoly cap;\n\tedge(long long a, string b, long long c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nlong long N, M;\nvector<edge> G[205];\nlong long S, T;\nbool used[205];\nconst poly zero, inf(\"x^51\");\n\npoly dfs(long long v, poly f)\n{\n\tused[v] = true;\n\tif(v == T) return f;\n\t\n\tpoly ret;\n\tfor(long long i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap <= zero) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(zero < ret){\n\t\t\tG[v][i].cap = G[v][i].cap - ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap = G[G[v][i].to][G[v][i].rev].cap + ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn zero;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0) break;\n\t\t\n\t\tfor(long long i = 1; i <= N; i++) G[i].clear();\n\t\t\n\t\tlong long u, v; string s;\n\t\tfor(long long i = 0; i < M; i++){\n\t\t\tcin >> u >> v >> s;\n\t\t\tG[u].push_back(edge(v, s, G[v].size()));\n\t\t\tG[v].push_back(edge(u, \"0\", G[u].size()-1));\n\t\t\tG[v].push_back(edge(u, s, G[u].size()));\n\t\t\tG[u].push_back(edge(v, \"0\", G[v].size()-1));\n\t\t}\n\t\tS = 1, T = N;\n\t\t\n\t\tpoly ans, flow;\n\t\twhile(1){\n\t\t\tfor(long long i = 1; i <= T; i++) used[i] = false;\n\t\t\tflow = dfs(S, inf);\n\t\t\tif(flow <= zero) break;\n\t\t\tans = ans + flow;\n\t\t}\n\t\t\n\t\tcout << ans.output() << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=102;\nconst int D_v_size=102;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nvector<int>D_sub[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_sub[from].push_back(1);\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n\tD_sub[to].push_back(0);\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint g[60][60][60];\nint res[60];\nchar in[1000];\nint cur;\nint val[60];\npair<int,int>fact(){\n\tint tmp=0;\n\twhile('0'<=in[cur]&&in[cur]<='9'){\n\t\ttmp*=10;tmp+=in[cur]-'0';cur++;\n\t}\n\tif(tmp==0)tmp=1;\n\tif(in[cur]!='x')return make_pair(0,tmp);\n\tcur++;\n\tif(in[cur]!='^')return make_pair(1,tmp);\n\tcur++;\n\tint t2=0;\n\twhile('0'<=in[cur]&&in[cur]<='9'){\n\t\tt2*=10;t2+=in[cur]-'0';cur++;\n\t}\n\treturn make_pair(t2,tmp);\n}\nvoid expr(){\n\tpair<int,int> tmp=fact();\n\tval[tmp.first]+=tmp.second;\n\twhile(in[cur]=='+'){\n\t\tcur++;\n\t\ttmp=fact();\n\t\tval[tmp.first]+=tmp.second;\n\t}\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<60;i++)for(int j=0;j<60;j++)for(int k=0;k<60;k++)\n\t\t\tg[i][j][k]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;\n\t\t\tscanf(\"%d%d%s\",&p,&q,in);\n\t\t\tp--;q--;\n\t\t\tcur=0;\n\t\t\tfor(int j=0;j<60;j++)val[j]=0;\n\t\t\texpr();\n\t\t\tfor(int j=0;j<60;j++)g[j][p][q]=g[j][q][p]=val[j];\n\t\t}\n\t\tfor(int i=59;i>=0;i--){\n\t\t\tfor(int j=0;j<D_MAX_V;j++){\n\t\t\t\tD_G[j].clear();\n\t\t\t\tD_sub[j].clear();\n\t\t\t\tD_level[j]=D_iter[j]=0;\n\t\t\t}\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<a;k++){\n\t\t\t\tadd_edge(j,k,g[i][j][k]);\n\t\t\t}\n\t\t\tres[i]=max_flow(0,a-1);\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tfor(int k=0;k<D_G[j].size();k++){\n\t\t\t\t\tif(D_sub[j][k]&&D_G[j][k].c){\n\t\t\t\t\t\tfor(int l=i-1;l>=0;l--)g[l][j][D_G[j][k].t]=999999999;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool yet=true;\n\t\tfor(int i=59;i>=0;i--){\n\t\t\tif(res[i]==0)continue;\n\t\t\tif(!yet)printf(\"+\");\n\t\t\tyet=false;\n\t\t\tif(i==0||res[i]>1)printf(\"%d\",res[i]);\n\t\t\tif(i)printf(\"x\");\n\t\t\tif(i>1)printf(\"^%d\",i);\n\t\t}\n\t\tif(yet)printf(\"0\");\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<map>\n#include<utility>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[52];\nbool used[52];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back({to,cap,(int)G[to].size()});\n  G[to].push_back({from,cap,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,1e9);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  for(int N,M;cin>>N>>M,N|M;){\n    bool nz=false;\n    map<pair<int,int>,vector<int> >pols;\n    for(int i=0;i<M;i++){\n      int u,v;\n      char p[1234];\n      cin>>u>>v>>p;\n      vector<int> c(51);\n      for(char *pp=p;*pp;){\n\tpp+=*pp=='+';\n\tint cc=1;\n\tif(*pp!='x'){\n\t  cc=strtol(pp,&pp,10);\n\t}\n\tint f=0;\n\tif(*pp){\n\t  pp++;\n\t  f=1;\n\t  if(*pp=='^'){\n\t    f=strtol(pp+1,&pp,10);\n\t  }\n\t}\n\tc[f]=cc;\n      }\n      pols[make_pair(u,v)]=c;\n    }\n    for(int i=50;i>=0;i--){\n      for(auto &e:G){\n\te.clear();\n      }\n      for(auto e:pols){\n\tadd_edge(e.first.first,e.first.second,e.second[i]);\n      }\n      int f=max_flow(1,N);\n      if(f){\n\tif(nz){\n\t  cout<<'+';\n\t}\n\tnz=true;\n\tif(f>1||i==0){\n\t  cout<<f;\n\t}\n\tif(i){\n\t  cout<<'x';\n\t  if(i>1){\n\t    cout<<'^'<<i;\n\t  }\n\t}\n      }\n      for(int j=1;j<=N;j++){\n\tfor(auto e:G[j]){\n\t  auto k=make_pair(j,e.to);\n\t  if(pols.count(k)&&e.cap!=0&&e.cap!=pols[k][i]*2){\n\t    for(int l=i;l>=0;l--){\n\t      pols[k][l]=1e9;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(!nz){\n      cout<<0;\n    }\n    cout<<endl;\n  }\n}\n\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 1e8);\n\nPoly operator-(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\nbool operator<(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] < b[i];\n\t}\n\treturn false;\n}\n\nbool operator>(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] > b[i];\n\t}\n\treturn false;\n}\n\nPoly min(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\tif (a[i] < b[i]) return a;\n\t\telse return b;\n\t}\n\treturn b;\n}\n\ntypedef int Weight;\ntypedef Poly Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, ZERO, 0 });\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > ZERO)\n\t\t{\n\t\t\tFlow mn = min(f, e.cap);\n\t\t\tFlow d = dfs(g, used, e.dest, t, mn);\n\t\t\tif (d > ZERO)\n\t\t\t{\n\t\t\t\te.cap = e.cap - d;\n\t\t\t\tg[e.dest][e.rev].cap = g[e.dest][e.rev].cap + d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = ZERO;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == ZERO) return flow;\n\t\tflow = f + flow;\n\t}\n}\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[m] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[1] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[0] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = ford_fulkerson(g, 0, n - 1);\n\t\tstring anss;\n\t\tfor (int i = 50; i >= 0; i--)\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i > 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 0)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct Polynomial{\n  using P = Polynomial;\n  vector<Int> co;\n  Polynomial():co(1,1){}\n  Polynomial(Int s):co(s,0){}\n  Polynomial(vector<Int> co):co(co){}\n  \n  size_t size() const{\n    return co.size();\n  };\n\n  void shrink(){\n    while(co.size()>1u&&!co.back())\n      co.pop_back();\n  }\n\n  void reduce(){\n    Int g=abs(co.back());\n    if(!g) return;\n    for(Int c:co)\n      if(c!=0) g=__gcd(g,abs(c));\n    if(co.back()<0) g*=-1;\n    for(Int &c:co) c/=g;\n  }\n\n  void print(){\n    shrink();\n    // reduce();    \n    Int n=size(),flg=0;    \n    if(n==1){      \n      cout<<co[0]<<endl;\n      return;\n    }\n    for(Int i=n-1;i>0;i--){\n      if(!co[i]) continue;\n      flg=1;\n      if(i!=n-1&&co[i]>0) cout<<\"+\";\n      if(co[i]==-1) cout<<\"-\";\n      else if(co[i]!=1) cout<<co[i];\n      \n      cout<<\"x\";\n      if(i!=1) cout<<\"^\"<<i;\n    }\n    if(co[0]){\n      if(flg&&co[0]>0) cout<<\"+\";\n      cout<<co[0];\n    }\n    cout<<endl;\n  }\n\n  Int operator[](Int i) const{\n    return co[i];\n  }\n\n  Int &operator[](Int i){\n    return co[i];\n  }\n\n  P operator-() const{\n    P res=*this;\n    for(Int &c:res.co) c*=-1;\n    return res;\n  }\n\n  P operator+(const P &a) const{\n    Int n=size(),m=a.size();\n    P res(max(n,m));\n    for(Int i=0;i<n;i++) res[i]+=co[i];\n    for(Int i=0;i<m;i++) res[i]+=a[i];\n    return res;\n  }\n  P operator-(const P &a) const{return *this+(-a);};\n\n  P operator*(const P &a) const{\n    Int n=size(),m=a.size();\n    P res(n+m);\n    for(Int i=0;i<n;i++)\n      for(Int j=0;j<m;j++)\n        res[i+j]+=co[i]*a[j];\n    res.shrink();\n    return res;\n  }\n\n  P pow(Int k) const{\n    P a(*this);\n    P res;\n    for(Int i=0;i<k;i++) res=res*a;\n    return res;\n  }\n  \n  pair<P, P> divide(const P &a) const{\n    Int n=size(),m=a.size(),s=n-m+1;\n    if(s<0) return make_pair(P(1),*this);\n    P div(s);\n    P rest=*this;\n    for(Int i=0;i<s;i++){\n      if(rest[n-(i+1)]%a[m-1]!=0)\n        for(Int &c:rest.co) c*=a[m-1];\n      Int d=rest[n-(i+1)]/a[m-1];\n      div[s-(i+1)]=d;\n      for(Int j=m;j>0;j--) rest[n-(i+j)]-=a[m-j]*d;\n    }\n    return make_pair(div,rest);\n  }\n  \n  P operator/(const P &a) const{return divide(a).first;};\n  P operator%(const P &a) const{return divide(a).second;};  \n};\n\nPolynomial gcd(Polynomial a,Polynomial b){\n  a.shrink();a.reduce();\n  b.shrink();b.reduce();\n  if(a.size()<b.size()) swap(a,b);\n  if(b.size()==1u&&!b[0]) return a;\n  return gcd(b,a%b);\n}\n\nPolynomial expr(string s,Int &p);\nPolynomial factor(string s,Int &p);\nPolynomial term(string s,Int &p);\nInt number(string s,Int &p);\n\nPolynomial expr(string s,Int &p){\n  //cout<<\"expr\"<<endl;\n  Polynomial res;\n  if(s[p]=='-'){\n    p++;\n    res=-factor(s,p);\n  }else res=factor(s,p);\n  \n  while(p<(Int)s.size()){\n    //res.print();\n    if(s[p]=='+'){\n      p++;\n      res=res+factor(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res=res-factor(s,p);\n      continue;\n    }\n    break;\n  }\n  //res.print();\n  return res;\n}\nPolynomial factor(string s,Int &p){\n  //cout<<\"factor\"<<endl;\n  Polynomial res=term(s,p);\n  while(p<(Int)s.size()){\n    //res.print();\n    if(s[p]=='+') break;\n    if(s[p]=='-') break;\n    if(s[p]==')') break;\n    res=res*term(s,p);\n  }\n  return res;\n}\nPolynomial term(string s,Int &p){\n  //cout<<\"term\"<<endl;\n  if(s[p]=='('){\n    p++;\n    Polynomial res=expr(s,p);\n    assert(s[p]==')');\n    p++;\n    if(s[p]=='^'){\n      p++;\n      Int k=number(s,p);\n      res=res.pow(k);\n    }\n    //res.print();\n    return res;\n  }\n  Int v=(s[p]=='x'?1:number(s,p));\n  if(p<(Int)s.size()&&s[p]=='x'){      \n    p++;\n    if(p<(Int)s.size()&&s[p]=='^'){\n      p++;\n      Int k=number(s,p);\n      Polynomial res(k+1);\n      res[k]=v;\n      //res.print();\n      return res;\n    }\n    Polynomial res(2);\n    res[1]=v;\n    //res.print();\n    return res;\n  }\n  Polynomial res(1);\n  res[0]=v;\n  return res;\n}\n\nInt number(string s,Int &p){\n  Int res=0;\n  while(p<(Int)s.size()&&isdigit(s[p]))\n    res=res*10+(s[p++]-'0');\n  return res;\n}\n\nPolynomial calc(string s){\n  Int p=0;\n  return expr(s,p);\n}\n\n\ntemplate<typename T,bool directed>\nstruct Dinic{\n  struct edge {\n    Int to;\n    T cap;\n    Int rev;\n    edge(){}\n    edge(Int to,T cap,Int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  T INF;\n  vector<vector<edge> > G;\n  vector<Int> level,iter;\n\n  Dinic(){}  \n  Dinic(Int n,T INF):INF(INF),G(n),level(n),iter(n){}\n  \n  void add_edge(Int from,Int to,Int cap){\n    G[from].emplace_back(to,cap,G[to].size());\n    G[to].emplace_back(from,directed?0:cap,G[from].size()-1);\n  }\n  \n  void bfs(Int s){\n    fill(level.begin(),level.end(),-1);\n    queue<Int> que;\n    level[s]=0;\n    que.emplace(s);\n    while(!que.empty()){\n      Int v=que.front();que.pop();\n      for(Int i=0;i<(Int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&level[e.to]<0){\n          level[e.to]=level[v]+1;\n          que.emplace(e.to);\n        }\n      }\n    }\n  }\n  \n  T dfs(Int v,Int t,T f){\n    if(v==t) return f;\n    for(Int &i=iter[v];i<(Int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n        T d=dfs(e.to,t,min(f,e.cap));\n        if(d==0) continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;      \n      }\n    }\n    return 0;\n  }\n  \n  T flow(Int s,Int t,T lim){\n    T fl=0;\n    while(1){\n      bfs(s);\n      if(level[t]<0||lim==0) break;\n      fill(iter.begin(),iter.end(),0);\n      \n      while(1){\n        T f=dfs(s,t,lim);\n        if(f==0) break;\n        fl+=f;\n        lim-=f;\n      }\n    }\n    return fl;\n  }\n\n  T flow(Int s,Int t){\n    return flow(s,t,INF);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  while(cin>>n>>m,n){\n    using P = pair<Int, Polynomial>;\n    vector<vector<P> > G(n);\n    for(Int i=0;i<m;i++){\n      Int x,y;\n      string s;\n      cin>>x>>y>>s;\n      auto p=calc(s);\n      x--;y--;\n      G[x].emplace_back(y,p);\n      G[y].emplace_back(x,p);\n    }\n    const Int INF = 1e5;\n    Dinic<Int, true> F(n,INF);\n    Polynomial ans(1);\n    \n    for(Int d=50;d>=0;d--){   \n      for(Int v=0;v<n;v++){\n        for(auto e:G[v]){\n          Int u=e.first;\n          auto &p=e.second;\n          if(d<(Int)p.size()&&p[d]){\n            F.add_edge(v,u,p[d]);\n          }          \n        }\n      }\n      Polynomial res(d+1);\n      res[d]=F.flow(0,n-1);\n      ans=ans+res;\n      \n      for(auto &v:F.G)\n        for(auto &e:v)\n          if(e.cap>0) e.cap=INF;\n    }\n    ans.print();\n  } \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e4\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct Polynomial {\n\tusing Val = int;\n\tusing Coef = int;\n\tint n; // dimension = degree + 1\n\tvector<Coef> coefs;\n\tPolynomial() :n(1), coefs(1) {}\n\texplicit Polynomial(int n) :n(n), coefs(n) {}\n\texplicit Polynomial(int n, Coef c) :n(n), coefs(n) { coefs[n - 1] = c; }\n\tvoid resize(int n) { this->n = n; coefs.resize(n); }\n\tvoid normalize() {\n\t\tint i = n;\n\t\twhile (i > 1 && coefs[i - 1] == Coef())i--;\n\t\tresize(i);\n\t}\n\tbool operator<(const Polynomial &that)const {\n\t\tfor (int i = that.n; i > n; i--)\n\t\t\tif (that.coefs[i - 1] > Coef())\n\t\t\t\treturn true;\n\t\t\telse if (that.coefs[i - 1] < Coef())\n\t\t\t\treturn false;\n\t\tfor (int i = n; i > that.n; i--)\n\t\t\tif (coefs[i - 1] > Coef())\n\t\t\t\treturn false;\n\t\t\telse if (coefs[i - 1] < Coef())\n\t\t\t\treturn true;\n\t\tfor (int i = min(n, that.n); i > 0; i--)\n\t\t\tif (coefs[i - 1] >= that.coefs[i - 1])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tbool operator>(const Polynomial &that)const { return that < *this; }\n\tbool operator<=(const Polynomial &that)const { return !(that < *this); }\n\tbool operator>=(const Polynomial &that)const { return !(*this < that); }\n\tbool operator==(const Polynomial &that)const { return !(*this < that) && !(that < *this); }\n\tbool operator!=(const Polynomial &that)const { return !(*this == that); }\n\tPolynomial &operator+=(const Polynomial &that) {\n\t\tif (n < that.n)\n\t\t\tresize(that.n);\n\t\tfor (int i = 0; i < that.n; i++)\n\t\t\tcoefs[i] += that.coefs[i];\n\t\treturn *this;\n\t}\n\tPolynomial &operator-=(const Polynomial &that) {\n\t\tif (n < that.n)\n\t\t\tresize(that.n);\n\t\tfor (int i = 0; i < that.n; i++)\n\t\t\tcoefs[i] -= that.coefs[i];\n\t\tnormalize();\n\t\treturn *this;\n\t}\n\tPolynomial operator+(const Polynomial &that)const { return Polynomial(*this) += that; }\n\tPolynomial operator-(const Polynomial &that)const { return Polynomial(*this) -= that; }\n\n\tVal evaluate(Val a)const {\n\t\tVal ans = 0, x = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += x*coefs[i];\n\t\t\tx *= a;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nostream &operator<<(ostream &o, const Polynomial &p) {\n\tbool first = true;\n\tfor (int i = p.n - 1; i >= 0; i--) {\n\t\tPolynomial::Coef c = p.coefs[i];\n\t\tif (c != 0) {\n\t\t\tif (first && c < 0)o << \"-\";\n\t\t\telse if (first)o << \"\";\n\t\t\telse if (c < 0)o << \"-\";\n\t\t\telse o << \"+\";\n\n\t\t\tif (i != 0 && (c == 1 || c == -1))o << \"\";\n\t\t\telse if (c < 0)o << -c;\n\t\t\telse o << c;\n\n\t\t\tif (i == 0)o << \"\";\n\t\t\telse if (i == 1)o << \"x\";\n\t\t\telse o << \"x^\" << i;\n\n\t\t\tfirst = false;\n\t\t}\n\t}\n\tif (first)o << \"0\";\n\treturn o;\n}\n\nconst Polynomial kPolynomialInf(100, INF);\n\n\n\nstruct Dinic {\n\tusing Flow = Polynomial;\n\tconst Flow kInf = kPolynomialInf;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap) :to(to), rev(rev), cap(cap) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<bool> used;\n\tvector<int> level;\n\tvector<int> iter;\n\tDinic(int n) :n(n), g(n), used(n), level(n), iter(n) {};\n\tvoid addArc(int from, int to, Flow cap) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, Flow());\n\t}\n\tvoid addEdge(int a, int b, Flow cap) {\n\t\tg[a].emplace_back(b, (int)g[b].size(), cap);\n\t\tg[b].emplace_back(a, (int)g[a].size() - 1, cap);\n\t}\n\tFlow maximumFlow(int s, int t) {\n\t\tFlow total = Flow();\n\t\twhile (true) {\n\t\t\tlevelize(s);\n\t\t\tif (level[t] < 0)return total;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tFlow f;\n\t\t\twhile (true) {\n\t\t\t\tf = augment(s, t, kInf);\n\t\t\t\tif (f == Flow())break;\n\t\t\t\ttotal += f;\n\t\t\t}\n\t\t}\n\t}\n\tFlow augment(int v, int t, Flow f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < g[v].size(); i++) {\n\t\t\tEdge &e = g[v][i];\n\t\t\tif (e.cap > Flow() && level[v] < level[e.to]) {\n\t\t\t\tFlow d = augment(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > Flow()) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Flow();\n\t}\n\tvoid levelize(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile (q.size()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > Flow() && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nstruct Parser {\n\tusing Iter = string::const_iterator;\n\tconst char kTerminator = '$';\n\tstring s;\n\tIter it;\n\tParser(const string &t) :s(t) { s += kTerminator; it = s.begin(); }\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\tPolynomial a() {\n\t\tPolynomial ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == '+') {\n\t\t\t\tit++;\n\t\t\t\tret += b();\n\t\t\t}\n\t\t\telse if (*it == '-') {\n\t\t\t\tit++;\n\t\t\t\tret -= b();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tPolynomial b() {\n\t\tint coef = integer();\n\t\tint degree = 0;\n\t\tif (*it == 'x') {\n\t\t\tcoef = max(1, coef);\n\t\t\tit++;\n\t\t\tif (*it == '^') {\n\t\t\t\tit++;\n\t\t\t\tdegree = integer();\n\t\t\t}\n\t\t\telse\n\t\t\t\tdegree = 1;\n\t\t}\n\t\treturn Polynomial(degree + 1, coef);\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M; cin >> N >> M&&N;) {\n\t\tDinic dinic(N);\n\t\trep(i, 0, M) {\n\t\t\tint u, v; string p;\n\t\t\tcin >> u >> v >> p; u--, v--;\n\t\t\tParser parser(p);\n\t\t\tPolynomial poly = parser.a();\n\t\t\tdinic.addEdge(u, v, poly);\n\t\t}\n\t\tcout << dinic.maximumFlow(0, N - 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e4\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n \nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check3(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> tmp=vector<int>(V,INF);\n    vector<int> f = dfs(s, t, tmp);\n    if(isall0(f))return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    vector<int> r=max_flow(0,n-1);\n    for(int i=0;i<r.size(); i++)\n      if(r[i]>=2000||r[i]<0) r[i]=0;\n    output(r);\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 55;\nconst int INF = 1 << 28;\nconst int L = 53;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\nvector<int> vec_INF = vec_zero;\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero && e.cap != vec_INF){\n\t\t\t//cout << v << ' ' << i << ' ' << endl;\n\t\t\t//for(int j=0;j<L;j++) cout << e.cap[j] << ' '; cout << endl;\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n\t\t\t\tbool skip = false;\n        for(int j=0;j<L;j++){\n\t\t\t\t\tif(skip){\n\t\t\t\t\t\te.cap[j] = max(0, e.cap[j] - d[j]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(e.cap[j] > d[j]) skip = true;\n\t\t\t\t\te.cap[j] -= d[j];\n        }\n\t\t\t\t//for(int j=0;j<L;j++) cout << G[e.to][e.rev].cap[j] << ' '; cout << endl;\n\t\t\t\t//for(int j=0;j<L;j++) cout << d[j] << ' '; cout << endl;\n        for(int j=0;j<L;j++) G[e.to][e.rev].cap[j] += d[j];\n\t\t\t\t//for(int j=0;j<L;j++) cout << G[e.to][e.rev].cap[j] << ' '; cout << endl;\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vec_INF[0] = 1;\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n    if(f == vec_zero) return flow;\n    for(int j=0;j<L;j++) flow[j] += f[j];\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n\t\tG[i].clear();\n\t\tused[i] = false;\n\t}\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == 'x') x = i;\n  if(x == -1) return make_pair(0, atoi(s.c_str()));\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0) res.second = 1;\n\telse res.second = atoi(tmp.c_str());\n  int h = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == '^') res.first = atoi(s.substr(i+1).c_str());\n\tif(h == -1) res.first = 1;\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size() || s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      if(i == s.size()) break;\n\t\t\tpre = i + 1;\n    }\n  }\n  return res;\n}\n\nmain(){\n\tint V, E;\n  while(cin >> V >> E && (V|E)){\n\t\tinit();\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      vector<int> tmp = calc(s);\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n    bool first = true;\n    for(int i=L-1;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else cout << \"+\";\n      if(i == 0) cout << ans[i];\n\t\t\telse{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1) cout << \"x\";\n\t\t\t\telse cout << \"x^\" << i;\n      }\n    }\n\t\tif(first) cout << 0;\n\t\tcout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<map>\n#include<utility>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[52];\nbool used[52];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back({to,cap,(int)G[to].size()});\n  G[to].push_back({from,cap,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,1e9);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  for(int N,M;cin>>N>>M,N|M;){\n    bool nz=false;\n    map<pair<int,int>,vector<int> >pols;\n    for(int i=0;i<M;i++){\n      int u,v;\n      char p[1234];\n      cin>>u>>v>>p;\n      vector<int> c(51);\n      for(char *pp=p;*pp;){\n\tpp+=*pp=='+';\n\tint cc=1;\n\tif(*pp!='x'){\n\t  cc=strtol(pp,&pp,10);\n\t}\n\tint f=0;\n\tif(*pp){\n\t  pp++;\n\t  f=1;\n\t  if(*pp=='^'){\n\t    f=strtol(pp+1,&pp,10);\n\t  }\n\t}\n\tc[f]=cc;\n      }\n      pols[make_pair(u,v)]=c;\n    }\n    for(int i=51;i>=0;i--){\n      for(auto &e:G){\n\te.clear();\n      }\n      for(auto e:pols){\n\tadd_edge(e.first.first,e.first.second,e.second[i]);\n      }\n      int f=max_flow(1,N);\n      if(f){\n\tif(nz){\n\t  cout<<'+';\n\t}\n\tnz=true;\n\tif(f>1||i==0){\n\t  cout<<f;\n\t}\n\tif(i){\n\t  cout<<'x';\n\t  if(i>1){\n\t    cout<<'^'<<i;\n\t  }\n\t}\n      }\n      for(int j=1;j<=N;j++){\n\tfor(auto e:G[j]){\n\t  auto k=make_pair(j,e.to);\n\t  if(pols.count(k)&&e.cap!=0&&e.cap!=pols[k][i]*2){\n\t    for(int l=i;l>=0;l--){\n\t      pols[k][l]=1e9;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(!nz){\n      cout<<0;\n    }\n    cout<<endl;\n  }\n}\n\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 1e8);\n\nPoly operator-(const Poly a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\nPoly min(const Poly &a, const Poly &b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\tif (a[i] < b[i]) return a;\n\t\telse return b;\n\t}\n\treturn b;\n}\n\ntypedef int Weight;\ntypedef Poly Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, ZERO, 0 });\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > ZERO)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > ZERO)\n\t\t\t{\n\t\t\t\te.cap = e.cap - d;\n\t\t\t\tg[e.dest][e.rev].cap = g[e.dest][e.rev].cap + d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = ZERO;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == ZERO) return flow;\n\t\tflow = f + flow;\n\t}\n}\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[m] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[1] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[0] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = ford_fulkerson(g, 0, n - 1);\n\t\tstring anss;\n\t\tfor (int i = 50; i >= 0; i--)\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i > 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 0)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(a[i]){\n\t\t\t\tif(i<n){\n\t\t\t\t\tret+=\"+\";\n\t\t\t\t}\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tret+=\"^\";\n\t\t\t\t\t\tret+=toString(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.n+1?left.a[i]:0)+(i<right.n+1?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.n+1?left.a[i]:0)-(i<right.n+1?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nconst poly Zero=to_poly(string(\"0\"));\nconst poly Inf=to_poly(string(\"x^51\"));\n\nvoid add_edge(int from,int to,poly& cap,vve &g){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g);\n\t\t\tadd_edge(v,u,pol,g);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 50;\nconst int INF = 1 << 25;\nconst int L = 52;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\nvector<int> vec_INF(L, 0);\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero){\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n        for(int j=0;j<L;j++) e.cap[j] -= d[j];\n        for(int j=0;j<L;j++) G[e.to][e.rev].cap[j] += d[j];\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n    if(f == vec_zero) return flow;\n    for(int j=0;j<L;j++) flow[j] += f[j];\n  }\n}\n\nvoid init(){\n  vec_INF[0] = 1;\n  for(int i=0;i<MAX_V;i++){\n\t\tG[i].clear();\n\t\tused[i] = false;\n\t}\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == 'x') x = i;\n  if(x == -1) return make_pair(0, atoi(s.c_str()));\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0) res.second = 1;\n\telse res.second = atoi(tmp.c_str());\n  int h = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == '^') res.first = atoi(s.substr(i+1).c_str());\n\tif(h == -1) res.first = 1;\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size() || s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      if(i == s.size()) break;\n\t\t\tpre = i + 1;\n    }\n  }\n  return res;\n}\n\nmain(){\n\tint V, E;\n  while(cin >> V >> E && (V|E)){\n\t\tinit();\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n\t\t\tif(a == b) continue;\n\t\t\tif(s == \"0\") continue;\n      vector<int> tmp = calc(s);\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n    bool first = true;\n    for(int i=L-2;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else cout << \"+\";\n      if(i == 0) cout << ans[i];\n\t\t\telse{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1) cout << \"x\";\n\t\t\t\telse cout << \"x^\" << i;\n      }\n    }\n\t\tif(first) cout << 0;\n\t\tcout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(i<n){\n\t\t\t\tret+=\"+\";\n\t\t\t}\n\t\t\tif(a[i]){\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=a[i]+'0';\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=a[i]+'0';\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)+(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)-(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nconst poly Zero=to_poly(string(\"0\"));\nconst poly Inf=to_poly(string(\"x^51\"));\n\nvoid add_edge(int from,int to,poly& cap,vve &g){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g);\n\t\t\tadd_edge(v,u,pol,g);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int L = 51;\n\nstruct Edge {\n  int to, cost, rev;\n  vector<int> cap;\n  Edge(int to, int cost, vector<int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdgeF(int from, int to, int cost, vector<int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, vector<int>(L), (int)g[from].size()-1));\n}\n\ninline vector<int>& add(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] += b[i];\n  return a;\n}\n\ninline vector<int>& subtract(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] -= b[i];\n  return a;\n}\n\ninline bool lt(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return false;\n}\n\ninline bool le(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return true;\n}\n\nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0 &&\n     *min_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(abs(ans[i]) != 1) cout << abs(ans[i]);\n    if(i > 1) cout << \"x^\" << i;\n    else if(i == 1) cout << \"x\";\n    j++;\n  }\n  cout << endl;\n}\n\nvector<int> dfsF(int v, int t, vector<int> f, vector<int> &used, Graph &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(!used[e.to] && lt(vector<int>(L), e.cap)) {\n      vector<int> d = dfsF(e.to, t, lt(f, e.cap) ? f : e.cap, used, g);\n      if(lt(vector<int>(L), d)) {\n\tsubtract(e.cap, d);\n\tadd(g[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>(L);\n}\n\nvector<int> maxFlow(int s, int t, Graph g) {\n  vector<int> flow(L);\n  while(1) {\n    vector<int> used(g.size());\n    vector<int> f = dfsF(s, t, vector<int>(L, INF), used, g);\n    if(le(f, vector<int>(L))) break;\n    add(flow, f);\n  }\n  return flow;\n}\n\nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      vector<int> cap(L);\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n\tint a = 1;\n\t{\n\t  int i = 0;\n\t  while(i < s.size() && isdigit(s[i])) ++i;\n\t  if(i) {\n\t    a = atoi(s.substr(0, i).c_str());\n\t    s = s.substr(i);\n\t  }\n\t}\n\tint k = 0;\n\t// \"\" or \"x\" or \"x^y\"\n\tif(s == \"x\") {\n\t  k = 1;\n\t} else if(s.size()) {\n\t  k = atoi(s.substr(2).c_str());\n\t}\n\tcap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      addEdgeF(v, u, 0, cap, g);\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2328.cc: Mobile Network\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int L = 50;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Poly {\n  int as[L + 1];\n  Poly() { _clear(); }\n  Poly(string &s) {\n    _clear();\n    int pos = 0, sn = s.size();\n    while (pos < sn) {\n      int ai = _read_int(s, pos);\n      int k = 0;\n      if (pos < sn && s[pos] == 'x') {\n\tpos++;\n\tk = 1;\n\tif (ai == 0) ai = 1;\n\tif (pos < sn && s[pos] == '^') {\n\t  pos++;\n\t  k = _read_int(s, pos);\n\t}\n      }\n      as[k] = ai;\n      if (pos < sn && s[pos] == '+') pos++;\n    }\n  }\n\n  void _clear() { memset(as, 0, sizeof(as)); }\n\n  int _read_int(string &s, int &pos) {\n    int num = 0, sn = s.size();\n    while (pos < sn && s[pos] >= '0' && s[pos] <= '9')\n      num = num * 10 + s[pos++] - '0';\n    return num;\n  }\n\n  bool operator<(const Poly &p) const {\n    for (int i = L; i >= 0; i--)\n      if (as[i] != p.as[i]) return (as[i] < p.as[i]);\n    return false;\n  }\n  \n  bool operator>(const Poly &p) const { return (p < *this); }\n\n  Poly operator+(const Poly &p) const {\n    Poly r;\n    for (int i = 0; i <= L; i++) r.as[i] = as[i] + p.as[i];\n    return r;\n  }\n\n  Poly operator-(const Poly &p) const {\n    Poly r;\n    for (int i = 0; i <= L; i++) r.as[i] = as[i] - p.as[i];\n    return r;\n  }\n\n  void print() {\n    bool first = true;\n    for (int i = L; i >= 0; i--) {\n      if (as[i]) {\n\tif (! first) putchar('+');\n\tfirst = false;\n\tif (i == 0 || as[i] > 1) printf(\"%d\", as[i]);\n\tif (i) {\n\t  putchar('x');\n\t  if (i > 1) printf(\"^%d\", i);\n\t}\n      }\n      else if (i == 0 && first) putchar('0');\n    }\n    putchar('\\n');\n  }\n};\n\ntypedef queue<int> qi;\ntypedef pair<int,Poly> pip;\ntypedef vector<pip> vpip;\n\n/* global variables */\n\nvpip nbrs[MAX_N];\nPoly minfs[MAX_N], flows[MAX_N][MAX_N], pinf, pzero;\nint prvs[MAX_N];\n\n/* subroutines */\n\nPoly maxflow(int st, int gl) {\n  memset(flows, 0, sizeof(flows));\n  Poly max_flow;\n\n  for (;;) {\n    //printf(\"max_flow = %d, limit = %d\\n\", max_flow, limit);\n\n    memset(prvs, -1, sizeof(prvs));\n    prvs[st] = st;\n    minfs[st] = pinf;\n\n    qi q;\n    q.push(st);\n\n    while (! q.empty()) {\n      int ui = q.front(); q.pop();\n\n      if (ui == gl) break;\n      vpip& nbru = nbrs[ui];\n      for (vpip::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n        int vi = vit->first;\n        Poly vc = vit->second - flows[ui][vi];\n        if (prvs[vi] < 0 && vc > pzero) {\n          prvs[vi] = ui;\n          minfs[vi] = (minfs[ui] < vc) ? minfs[ui] : vc;\n          q.push(vi);\n        }\n      }\n    }\n\n    if (prvs[gl] < 0) break;\n\n    Poly min_flow = minfs[gl];\n    for (int j = gl; j != st;) {\n      int i = prvs[j];\n      flows[i][j] = flows[i][j] + min_flow;\n      flows[j][i] = flows[j][i] - min_flow;\n      j = i;\n    }\n\n    max_flow = max_flow + min_flow;\n  }\n\n  return max_flow;\n}\n\n/* main */\n\nint main() {\n  pinf.as[L] = INF;\n\n  for (;;) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0) break;\n\n    for (int i = 0; i < n; i++) nbrs[i].clear();\n    \n    for (int i = 0; i < m; i++) {\n      int ai, bi;\n      string ps;\n      cin >> ai >> bi >> ps;\n      ai--, bi--;\n      Poly p(ps);\n\n      nbrs[ai].push_back(pip(bi, p));\n      nbrs[bi].push_back(pip(ai, p));\n    }\n\n    Poly mf = maxflow(0, n - 1);\n    mf.print();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 1e8);\n\nPoly operator-(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\nbool operator<(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] < b[i];\n\t}\n\treturn false;\n}\n\nbool operator>(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] > b[i];\n\t}\n\treturn false;\n}\n\ntypedef int Weight;\ntypedef Poly Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, ZERO, 0 });\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > ZERO)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > ZERO)\n\t\t\t{\n\t\t\t\te.cap = e.cap - d;\n\t\t\t\tg[e.dest][e.rev].cap = g[e.dest][e.rev].cap + d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = ZERO;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == ZERO) return flow;\n\t\tflow = f + flow;\n\t}\n}\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[m] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[1] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[0] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = ford_fulkerson(g, 0, n - 1);\n\t\tstring anss;\n\t\tfor (int i = 50; i >= 0; i--)\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i > 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 0)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 1e8);\n\nPoly operator-(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\nbool operator<(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] < b[i];\n\t}\n\treturn false;\n}\n\nbool operator<=(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] < b[i];\n\t}\n\treturn true;\n}\n\nbool operator>(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] > b[i];\n\t}\n\treturn false;\n}\n\nPoly min(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\tif (a[i] < b[i]) return a;\n\t\telse return b;\n\t}\n\treturn b;\n}\n\nbool resid(const Poly& a)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == 0) continue;\n\t\treturn a[i] > 0;\n\t}\n\treturn false;\n}\n\ntemplate <typename Flow>\nstruct FEdge {\n\tint from, to;\n\tFlow cap; int rev;\n\tFEdge(int s, int t, Flow f, int r) : from(s), to(t), cap(f), rev(r) {}\n};\n\ntemplate<typename Flow> using FGraph = vector<vector<FEdge<Flow>>>;\n\ntemplate <typename Flow>\nvoid add_edge(FGraph<Flow> &g, int from, int to, Flow cap) {\n\tg[from].emplace_back(from, to, cap, (int)g[to].size());\n\tg[to].emplace_back(to, from, 0, (int)g[from].size() - 1);\n}\n\ntemplate <typename Flow>\nFlow augment(FGraph<Flow> &g, vi &d, vector<int> &iter, int v, int t, const Flow &f) \n{\n\tif (v == t || !resid(f)) return f;\n\tfor (int &i = iter[v]; i < (int)g[v].size(); i++) {\n\t\tauto &e = g[v][i];\n\t\tif (e.cap > ZERO && d[v] < d[e.to]) {\n\t\t\tFlow ff = augment(g, d, iter, e.to, t, min(f, e.cap));\n\t\t\tif (resid(f)) {\n\t\t\t\te.cap = e.cap - ff;\n\t\t\t\tg[e.to][e.rev].cap = g[e.to][e.rev].cap + ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\ntemplate <typename Flow>\nFlow max_flow(FGraph<Flow> &g, int s, int t, Flow zero = ZERO) {\n\tint V = g.size();\n\tFlow flow = zero;\n\tfor (;;) {\n\t\tvi d(V, -1);\n\t\tqueue<int> que;\n\t\td[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (const auto &e : g[v]) {\n\t\t\t\tif (e.cap <= zero ||  d[e.to] >= 0) continue;\n\t\t\t\td[e.to] = d[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tif (d[t] < 0) return flow;\n\t\tvector<int> iter(V, 0);\n\t\tFlow f;\n\t\twhile ((f = augment(g, d, iter, s, t, INF)) > ZERO) flow = flow + f;\n\t}\n}\n\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[m] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[1] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[0] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tFGraph<Poly> g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = max_flow(g, 0, n - 1);\n\t\tstring anss;\n\t\tfor (int i = 50; i >= 0; i--)\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i > 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 0)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,bool directed>\nstruct Dinic{\n    struct edge {\n        int to;\n        T cap;\n        int rev;\n        edge(){}\n        edge(int to,T cap,int rev):to(to),cap(cap),rev(rev){}\n    };\n    \n    T INF;\n    vector<vector<edge> > G;\n    vector<int> level,iter;\n    \n    Dinic(){}\n    Dinic(int n,T INF):INF(INF),G(n),level(n),iter(n){}\n    \n    pll add_edge(int from,int to,int cap){\n        G[from].emplace_back(to,cap,G[to].size());\n        G[to].emplace_back(from,directed?0:cap,G[from].size()-1);\n        return {G[from].size()-1,G[to].size()-1};\n    }\n    \n    void bfs(int s){\n        fill(level.begin(),level.end(),-1);\n        queue<int> que;\n        level[s]=0;\n        que.emplace(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(int i=0;i<(int)G[v].size();i++){\n                edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    que.emplace(e.to);\n                }\n            }\n        }\n    }\n    \n    T dfs(int v,int t,T f){\n        if(v==t) return f;\n        for(int &i=iter[v];i<(int)G[v].size();i++){\n            edge &e=G[v][i];\n            if(e.cap>0&&level[v]<level[e.to]){\n                T d=dfs(e.to,t,min(f,e.cap));\n                if(d==0) continue;\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    \n    T flow(int s,int t,T lim){\n        T fl=0;\n        while(1){\n            bfs(s);\n            if(level[t]<0||lim==0) break;\n            fill(iter.begin(),iter.end(),0);\n            \n            while(1){\n                T f=dfs(s,t,lim);\n                if(f==0) break;\n                fl+=f;\n                lim-=f;\n            }\n        }\n        return fl;\n    }\n    \n    T flow(int s,int t){\n        return flow(s,t,INF);\n    }\n};\n\nconst ll MX=1LL<<30;\n\nbool number(char c){return '0'<=c && c<='9';}\n\nvoid toNum(string &s,vector<ll> &ret){\n    ll k=0;\n    for(int t=0;t<s.size();t++){\n        if(s[t]=='x'){\n            ll z=0;\n            while(t<s.size() && s[t]!='+'){\n                if(number(s[t])){z*=10; s[t]-='0'; z+=s[t];}\n                ++t;\n            }\n            ret[max(z,1LL)]=max(k,1LL);\n            k=0;\n            continue;\n        }\n        else{\n            k*=10;\n            s[t]-='0';\n            k+=s[t];\n        }\n    }\n    ret[0]=k;\n}\n\nvoid toStr(vector<ll> &ans){\n    while(ans.size()>0 && ans.back()==0){ans.pop_back();}\n    ll last=0;\n    while(last<ans.size() && ans[last]==0){last++;}\n    if(last==ans.size()){cout<<0<<endl; return;}\n    for(ll i=ans.size()-1;i>=last;i--){\n        if(ans[i]==0){continue;}\n        if(ans[i]!=1 || i==0){cout<<ans[i];}\n        if(i>0){cout<<\"x\";}\n        if(i>1){cout<<\"^\"<<i;}\n        if(i!=last){cout<<\"+\";}\n    }\n    cout<<endl;\n}\n\nint main(){\n    ll n,m;\n    while(cin>>n>>m){\n        if(n==0){break;}\n    vector<pll> Edge(m);\n    vector<vector<ll>> Cost(m,vector<ll>(51,0));\n    vector<pll> num(m);\n    for(int i=0;i<m;i++){\n        cin>>Edge[i].F>>Edge[i].S;\n        Edge[i].F--; Edge[i].S--;\n        if(Edge[i].F>Edge[i].S){swap(Edge[i].F,Edge[i].S);}\n        string s;\n        cin>>s;\n        toNum(s,Cost[i]);\n    }\n    vector<ll> ans(51,0);\n    Dinic<ll,false> Flow(n,MX);\n    for(int i=0;i<m;i++){\n        num[i]=Flow.add_edge(Edge[i].F,Edge[i].S,0);\n    }\n    for(ll time=50;time>=0;time--){\n        for(int i=0;i<m;i++){\n            if(Flow.G[Edge[i].F][num[i].F].cap>0){Flow.G[Edge[i].F][num[i].F].cap=MX;}\n            if(Flow.G[Edge[i].S][num[i].S].cap>0){Flow.G[Edge[i].S][num[i].S].cap=MX;}\n        }\n        for(int i=0;i<m;i++){\n            Flow.G[Edge[i].F][num[i].F].cap+=Cost[i][time];\n            Flow.G[Edge[i].S][num[i].S].cap+=Cost[i][time];\n        }\n        ans[time]=Flow.flow(0,n-1);\n    }\n    toStr(ans);\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,rev;\n\tvector<int> cap;\n\tedge(){}\n\tedge(int tt,vector<int> cc,int rr){\n\t\tto=tt;\n\t\trev=rr;\n\t\tcap.resize(cc.size());\n\t\tfor(int i=0;i<cc.size();i++){\n\t\t\tcap[i]=cc[i];\n\t\t}\n\t}\n};\n\nclass dinic{\npublic:\n\tconst int INF=100000;\n\tvector<edge> G[501];\n\tint level[501];\n\tint iter[501];\n\tvoid add_edge(int from,int to,vector<int> cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,cap,G[from].size()-1));\n\t}\n\n\tbool checkemp(vector<int> &cap){\n\t\tint s=cap.size();\n\t\tfor(int i=s-1;i>=0;i--){\n\t\t\tif(cap[i]>0)return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvector<int> getmin(vector<int> a,vector<int> b){\n\t\tvector<int> c(a.size());\n\t\tfor(int i=a.size();i>=0;i--){\n\t\t\tif(a[i]<b[i])return a;\n\t\t\tif(a[i]>b[i])return b;\n\t\t}\n\t\treturn a;\n\t}\n\n\tvoid bfs(int s){\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(!checkemp(e.cap) && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dfs(int v,int t,vector<int> f){\n\t\tif(v==t)return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(!checkemp(e.cap) && level[v]<level[e.to]){\n\t\t\t\tvector<int> d=dfs(e.to,t,getmin(f,e.cap));\n\t\t\t\tif(!checkemp(d)){\n\t\t\t\t\tfor(int j=0;j<e.cap.size();j++){\n\t\t\t\t\t\te.cap[j]-=d[j];\n\t\t\t\t\t\tG[e.to][e.rev].cap[j]+=d[j];\n\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> zer(f.size(),0);\n\t\treturn zer;\n\t}\n\tvector<int> max_flow(int s,int t,int size){\n\t\tvector<int> flow(size,0);\n\t\tvector<int> alINF(size,INF);\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\tvector<int> f;\n\t\t\twhile(!checkemp(f=dfs(s,t,alINF))){\n\t\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\t\tflow[i]+=f[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nstring get_string(int v){\n\tstring ret=\"\";\n\twhile(v>0){\n\t\tret+=('0'+v%10);\n\t\tv/=10;\n\t}\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\n\n\ndinic di;\n\nint n,m;\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdi.G[i].clear();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v;\n\t\t\tstring str;\n\t\t\tcin >> u >> v >> str;\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tint digit=0;\n\t\t\tvector<int> tp(51,0);\n\t\t\tfor(int j=0;j<str.size();j++){\n\t\t\t\tif(str[j]>='0' && str[j]<='9'){\n\t\t\t\t\tdigit*=10;\n\t\t\t\t\tdigit+=(str[j]-'0');\n\t\t\t\t}else if(str[j]=='x'){\n\t\t\t\t\tif(digit==0)digit=1;\n\t\t\t\t\tif(j+1<str.size() && str[j+1]=='^'){\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tint dg2=0;\n\t\t\t\t\t\twhile((str[j]>='0' && str[j]<='9')){\n\t\t\t\t\t\t\tdg2*=10;\n\t\t\t\t\t\t\tdg2+=(str[j]-'0');\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttp[dg2]=digit;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttp[1]=digit;\n\t\t\t\t\t}\n\t\t\t\t\tdigit=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(digit>0){\n\t\t\t\ttp[0]=digit;\n\t\t\t}\n\t\t\tdi.add_edge(u,v,tp);\n\t\t\t\n\t\t}\n\t\tvector<int> ans=di.max_flow(0,n-1,51);\n\t\tstring best=\"\";\n\t\tbool flag=false;\n\t\tfor(int i=50;i>=0;i--){\n\t\t\tif(ans[i]>0){\n\t\t\t\tif(flag)best+='+';\n\t\t\t\tbest+=get_string(ans[i]);\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(ans[i]==1){\n\t\t\t\t\t\tbest.erase(best.end()-1);\n\t\t\t\t\t}\n\t\t\t\t\tbest+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tbest+=\"^\";\n\t\t\t\t\t\tbest+=get_string(i);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tif(best.size()==0)best+='0';\n\t\tcout << best << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 1e8);\n\nPoly operator-(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\nbool operator<(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] < b[i];\n\t}\n\treturn false;\n}\n\nbool operator>(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] > b[i];\n\t}\n\treturn false;\n}\n\nPoly min(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\tif (a[i] < b[i]) return a;\n\t\telse return b;\n\t}\n\treturn b;\n}\n\ntypedef int Weight;\ntypedef Poly Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, ZERO, 0 });\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > ZERO)\n\t\t{\n\t\t\tFlow mn = min(f, e.cap);\n\t\t\tFlow d = dfs(g, used, e.dest, t, mn);\n\t\t\tif (d > ZERO)\n\t\t\t{\n\t\t\t\te.cap = e.cap - d;\n\t\t\t\tg[e.dest][e.rev].cap = g[e.dest][e.rev].cap + d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = ZERO;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == ZERO) return flow;\n\t\tflow = f + flow;\n\t}\n}\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (p < n && isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (p < n && s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[m] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[1] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[0] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = ford_fulkerson(g, 0, n - 1);\n\t\tstring anss;\n\t\tfor (int i = 50; i >= 0; i--)\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i > 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 0)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n#define INF 1e4\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  assert(res.size()==v.size());\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  assert(res.size()==v.size());\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  assert(A.size()==B.size());\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n/*bool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n  }*/\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      assert(d.size()==f.size());\n      //assert(isallnotINF(e.cap));\n      /*      for(int j=0;j<d.size();j++){\n\tcout<<j<<' '<<d[j]<<endl;\n\tassert(d[j]!=INF);\n\t}*/\n      \n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> r=vector<int>(V,0);\n    r[0]=INF;\n    vector<int> f = dfs(s, t, r);\n    if(isall0(f)) return flow;\n    /*if(isallnotINF(f)) */Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    assert(0!=n-1);\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(a[i]){\n\t\t\t\tif(i<n){\n\t\t\t\t\tret+=\"+\";\n\t\t\t\t}\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tret+=\"^\";\n\t\t\t\t\t\tret+=toString(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)+(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)-(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\n\nvoid add_edge(int from,int to,poly& cap,vve &g,const poly &Zero){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used,const poly &Zero){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used,Zero);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tconst poly Zero=to_poly(string(\"0\"));\n\tconst poly Inf=to_poly(string(\"x^51\"));\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g,Zero);\n\t\t\tadd_edge(v,u,pol,g,Zero);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used,Zero);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 51\nusing namespace std;\ntypedef vector<int> V;\nconst V zero(51,0);\nstruct edge{\n  int to,rev;\n  V cap;\n  edge();\n  edge(int to,V cap,int rev):to(to),cap(cap),rev(rev){};\n};\n\nbool compare (const V &a,const V &b){\n  for(int i=a.size()-1;i>=0;i--)if(a[i]!=b[i])return a[i]<b[i];\n  return 0;\n}\nV min(V &a,V &b){return compare(a,b)? a:b;}\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,V cap){\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,cap,G[from].size()-1));  \n}\n\nvoid add(V &a,V &b){for(int i=0;i<(int)a.size();i++)a[i]+=b[i];}\nvoid sub(V &a,V &b){for(int i=0;i<(int)a.size();i++)a[i]-=b[i];}\n\n//?¢?????????????DFS??§??¢???\nV dfs(int v,int t,V f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap != zero){\n      V d = dfs(e.to ,t , min(f,e.cap));\n      if(d != zero){\n\tsub(e.cap,d);\n\tadd(G[e.to][e.rev].cap,d);\n\treturn d;\n      }\n    }\n  }\n  return zero;\n}\n\n//s??????t???????????§???????±???????\nV max_flow(int s,int t){\n  V flow=zero;\n  for(;;){\n    memset(used,0,sizeof(used));\n    V f = dfs(s, t, V(51,1e4));\n    if(f == zero)return flow;\n    add(flow,f);\n  }\n}\n\nint StoI(string &a,int &i){\n  int res=0;\n  while(isdigit(a[i])) res=res*10+a[i++]-'0';\n  return res;\n}\n\nstring ItoS(int a){\n  string res;\n  while(a) res=char(a%10+'0')+res,a/=10;\n  if(res.empty()) res=\"0\";\n  return res;\n}\n\nV StoV(string s){\n  if(s==\"0\") return zero;\n  V res(51);\n  for(int i=0;i<s.size();i++){\n    int a = max(1,StoI(s,i));\n    int L = 0;\n    if(s[i]=='x')i+=1+(s[i+1]=='^'),L=max(1,StoI(s,i));\n    res[L] = a;\n  }\n  return res;\n}\n\nstring VtoS(V a){\n  string res;\n  for(int i=a.size()-1;i>=0;i--){\n    if(a[i]==0)continue;\n    if(!res.empty()) res+='+';\n    if(a[i]>1||i==0) res+=ItoS(a[i]);\n    if(i)res+='x';\n    if(i>1) res+='^'+ItoS(i);\n  }\n  if(res.empty()) res=\"0\";\n  return res;\n}\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m) return 0;\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n    for(int i=0,a,b;i<m;i++){\n      string c;\n      cin>>a>>b>>c;\n      V vc = StoV(c);\n      add_edge(a-1,b-1,vc);\n    }\n\n    V ans = max_flow(0,n-1);\n    cout<<VtoS(ans)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,rev;\n\tvector<int> cap;\n\tedge(){}\n\tedge(int tt,vector<int> cc,int rr){\n\t\tto=tt;\n\t\trev=rr;\n\t\tcap.resize(cc.size());\n\t\tfor(int i=0;i<cc.size();i++){\n\t\t\tcap[i]=cc[i];\n\t\t}\n\t}\n};\n\nclass dinic{\npublic:\n\tconst int INF=100000;\n\tvector<edge> G[501];\n\tint level[501];\n\tint iter[501];\n\tvoid add_edge(int from,int to,vector<int> cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,cap,G[from].size()-1));\n\t}\n\n\tbool checkemp(vector<int> &cap){\n\t\tint s=cap.size();\n\t\tfor(int i=s-1;i>=0;i--){\n\t\t\tif(cap[i]>0)return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvector<int> getmin(vector<int> a,vector<int> b){\n\t\tvector<int> c(a.size());\n\t\tbool flag=false;\n\t\tbool flag2=false;\n\t\tfor(int i=(int)c.size()-1;i>=0;i--){\n\t\t\tif(flag){\n\t\t\t\tc[i]=max(a[i],b[i]);\n\t\t\t}else if(flag2){\n\t\t\t\tc[i]=b[i];\n\t\t\t}else{\n\t\t\t\tc[i]=min(a[i],b[i]);\n\t\t\t}\n\t\t\tif(a[i]<b[i]){\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t\tif(a[i]>b[i]){\n\t\t\t\tflag2=true;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\n\tvoid bfs(int s){\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(!checkemp(e.cap) && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dfs(int v,int t,vector<int> f){\n\t\tif(v==t)return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(!checkemp(e.cap) && level[v]<level[e.to]){\n\t\t\t\tvector<int> d=dfs(e.to,t,getmin(f,e.cap));\n\t\t\t\tif(!checkemp(d)){\n\t\t\t\t\tfor(int j=0;j<e.cap.size();j++){\n\t\t\t\t\t\tint bx=min(e.cap[j],d[j]);\n\t\t\t\t\t\te.cap[j]-=bx;\n\t\t\t\t\t\tG[e.to][e.rev].cap[j]+=bx;\n\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> zer(f.size(),0);\n\t\treturn zer;\n\t}\n\tvector<int> max_flow(int s,int t,int size){\n\t\tvector<int> flow(size,0);\n\t\tvector<int> alINF(size,INF);\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\tvector<int> f;\n\t\t\twhile(!checkemp(f=dfs(s,t,alINF))){\n\t\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\t\tflow[i]+=f[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nstring get_string(int v){\n\tstring ret=\"\";\n\twhile(v>0){\n\t\tret+=('0'+v%10);\n\t\tv/=10;\n\t}\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\n\n\ndinic di;\n\nint n,m;\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdi.G[i].clear();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v;\n\t\t\tstring str;\n\t\t\tcin >> u >> v >> str;\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tint digit=0;\n\t\t\tvector<int> tp(51,0);\n\t\t\tfor(int j=0;j<str.size();j++){\n\t\t\t\tif(str[j]>='0' && str[j]<='9'){\n\t\t\t\t\tdigit*=10;\n\t\t\t\t\tdigit+=(str[j]-'0');\n\t\t\t\t}else if(str[j]=='x'){\n\t\t\t\t\tif(digit==0)digit=1;\n\t\t\t\t\tif(j+1<str.size() && str[j+1]=='^'){\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tint dg2=0;\n\t\t\t\t\t\twhile((str[j]>='0' && str[j]<='9')){\n\t\t\t\t\t\t\tdg2*=10;\n\t\t\t\t\t\t\tdg2+=(str[j]-'0');\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttp[dg2]=digit;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttp[1]=digit;\n\t\t\t\t\t}\n\t\t\t\t\tdigit=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(digit>0){\n\t\t\t\ttp[0]=digit;\n\t\t\t}\n\t\t\tdi.add_edge(u,v,tp);\n\t\t\t\n\t\t}\n\t\tvector<int> ans=di.max_flow(0,n-1,51);\n\t\tstring best=\"\";\n\t\tbool flag=false;\n\t\tfor(int i=50;i>=0;i--){\n\t\t\tif(ans[i]>0){\n\t\t\t\tif(flag)best+='+';\n\t\t\t\tbest+=get_string(ans[i]);\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(ans[i]==1){\n\t\t\t\t\t\tbest.erase(best.end()-1);\n\t\t\t\t\t}\n\t\t\t\t\tbest+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tbest+=\"^\";\n\t\t\t\t\t\tbest+=get_string(i);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tif(best.size()==0)best+='0';\n\t\tcout << best << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\n\n\n#define _GLIBCXX_DEBUG\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\nconst long long int L_INF = 9223372036854775807;\n\ntypedef vector<int> Weight;\nconst Weight INF = vector<int>(100, 1);\nconst Weight ZERO = vector<int>(100, 0);\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator <(const Weight&l, const Weight&r) {\n\tfor (int i = 99; i >=0; --i) {\n\t\tif (l[i] != r[i])return l[i] < r[i];\n\t}\n\treturn false;\n}\nbool operator >(const Weight&l, const Weight&r) {\n\tfor (int i = 99; i >= 0; --i) {\n\t\tif (l[i] != r[i])return l[i] > r[i];\n\t}\n\treturn false;\n}\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nWeight operator+(const Weight&l, const Weight&r) {\n\tvector<int>ans(100);\n\tfor (int i = 0; i < 100; ++i) {\n\t\tans[i] = l[i] + r[i];\n\t}\n\treturn ans;\n}\nWeight operator-(const Weight&l, const Weight&r) {\n\tvector<int>ans(100);\n\tfor (int i = 0; i < 100; ++i) {\n\t\tans[i] = l[i] - r[i];\n\t}\n\treturn ans;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\n//??????0??????????????????????????¨??£???????±??????????????????§??¨???\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, ag[i][j].weight));\n\t\t\t}\n\t\t}\n\t}\n\tint n = g.size();\n\tMatrix flow(n, Array(n,ZERO)), capacity(n, Array(n, ZERO));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] =capacity[e->src][e->dst]+ e->weight;\n\n\n\tWeight total = ZERO;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > ZERO) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0)break; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j]) {\n\t\t\tauto v(RESIDUE(prev[j], j));\n\t\t\tif (inc > v) {\n\t\t\t\tinc =v;\n\t\t\t}\n\t\t}\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] =flow[prev[j]][j]+inc, flow[j][prev[j]] =flow[j][prev[j]]- inc;\n\t\ttotal =total+ inc;\n\t}\n\n\treturn total;\n}\nint a = 0;\nstring st;\nint getnum() {\n\tint num = 0;\n\twhile (a!=st.size()&&isdigit(st[a])) {\n\t\tnum = num * 10 + st[a] - '0';\n\t\ta++;\n\t}\n\treturn num;\n}\npair<int, int>getx() {\n\tint num = 1;\n\tif (isdigit(st[a])) {\n\t\tnum = getnum();\n\t}\n\tint base;\n\tif (a == st.size() || st[a] == '+') {\n\t\tbase = 0;\n\t}\n\telse {\n\t\tassert(st[a] == 'x');\n\t\ta++;\n\t\tif (a == st.size() || st[a] == '+') {\n\t\t\tbase = 1;\n\t\t}\n\t\telse {\n\t\t\tassert(st[a] == '^');\n\t\t\tbase = getnum();\n\t\t}\n\t}\n\treturn make_pair(base, num);\n}\nvector<int>getvec() {\n\tvector<int>v(100);\n\tauto p = getx();\n\tv[p.first] = p.second;\n\twhile (a != st.size()) {\n\t\ta++;\n\t\tauto p = getx();\n\t\tv[p.first] = p.second;\n\t}\n\treturn v;\n}\nvoid makest(const vector<int>&vs) {\n\n\tbool fst = true;\n\tfor (int i = 99; i >= 0; --i) {\n\t\tif (vs[i]) {\n\t\t\tif (!fst)cout << \"+\";\n\t\t\tif (vs[i] >= 2) {\n\t\t\t\tcout << vs[i];\n\t\t\t}\n\t\t\tif (i >= 1) {\n\t\t\t\tcout << 'x';\n\t\t\t\tif (i >= 2) {\n\t\t\t\t\tcout << '^';\n\t\t\t\t\tcout << i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfst =false;\n\t\t}\n\t}\n\tif (fst)cout << '0';\n\tcout << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tGraph g(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u, v; string p; cin >> u >> v >> p;\n\t\t\tst = p;\n\t\t\tu--; v--;\n\t\t\ta = 0;\n\t\t\tauto aa(getvec());\n\t\t\tg[u].emplace_back(u, v, aa);\n\t\t}\n\t\tWeight ans = maximumFlow(g, 0, N - 1);\n\t\tmakest(ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nvoid Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> tmp=vector<int>(V,INF);\n    vector<int> f = dfs(s, t, tmp);\n    if(isall0(f))return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    vector<int> r=max_flow(0,n-1);\n    for(int i=0;i<r.size(); i++)\n      if(r[i]>=2000||r[i]<0) r[i]=0;\n    output(r);\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int INF = 1<<28;\nconst int L = 51;\n \nstruct Edge {\n  int to, cost, rev;\n  vector<int> cap;\n  Edge(int to, int cost, vector<int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n \ntypedef vector<vector<Edge> > Graph;\n \nvoid addEdgeF(int from, int to, int cost, vector<int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, vector<int>(L), (int)g[from].size()-1));\n}\n \ninline void add(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] += b[i];\n}\n \ninline void subtract(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] -= b[i];\n}\n \ninline bool lt(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return false;\n}\n \ninline bool le(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return true;\n}\n \nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0 &&\n     *min_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(abs(ans[i]) != 1) cout << abs(ans[i]);\n    if(i > 1) cout << \"x^\" << i;\n    else if(i == 1) cout << \"x\";\n    j++;\n  }\n  cout << endl;\n}\n\nvoid bfs(int s, vector<int> &level, Graph &g) {\n  int n = g.size();\n  level = vector<int>(n, -1);\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    for(int i = 0; i < g[v].size(); ++i) {\n      const Edge &e = g[v][i];\n      if(level[e.to] < 0 && lt(vector<int>(L), e.cap)) {\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nvector<int> dfs(int v, int t, vector<int> f, vector<int> &level, vector<int> &iter, Graph &g) {\n  if(v == t) return f;\n  for(int &i = iter[v]; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(level[v] < level[e.to] && lt(vector<int>(L), e.cap)) {\n      vector<int> d = dfs(e.to, t, lt(f, e.cap) ? f : e.cap, level, iter, g);\n      if(lt(vector<int>(L), d)) {\n        subtract(e.cap, d);\n        add(g[e.to][e.rev].cap, d);\n        return d;\n      }\n    }\n  }\n  return vector<int>(L);\n}\n\nvector<int> maxFlow(int s, int t, Graph g) {\n  vector<int> flow(L);\n  while(1) {\n    vector<int> level;\n    bfs(s, level, g);\n    if(level[t] < 0) return flow;\n    vector<int> iter(g.size());\n    vector<int> f;\n    while(lt(vector<int>(L), f = dfs(s, t, vector<int>(L, INF), level, iter, g))) {\n      add(flow, f);\n    }\n  }\n  return flow;\n}\n \nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      vector<int> cap(L);\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n        int a = 1;\n        {\n          int i = 0;\n          while(i < s.size() && isdigit(s[i])) ++i;\n          if(i) {\n            a = atoi(s.substr(0, i).c_str());\n            s = s.substr(i);\n          }\n        }\n        int k = 0;\n        // \"\" or \"x\" or \"x^y\"\n        if(s == \"x\") {\n          k = 1;\n        } else if(s.size()) {\n          k = atoi(s.substr(2).c_str());\n        }\n        cap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      addEdgeF(v, u, 0, cap, g);\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 51\nusing namespace std;\ntypedef vector<int> V;\nconst V zero(51,0);\nstruct edge{\n  int to,rev;\n  V cap;\n  edge();\n  edge(int to,V cap,int rev):to(to),cap(cap),rev(rev){};\n};\n\nbool compare (const V &a,const V &b){\n  for(int i=a.size()-1;i>=0;i--)if(a[i]!=b[i])return a[i]<b[i];\n  return 0;\n}\nV min(V &a,V &b){return compare(a,b)? a:b;}\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,V cap){\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,cap,G[from].size()-1));  \n}\n\nvoid add(V &a,V &b){for(int i=0;i<(int)a.size();i++)a[i]+=b[i];}\nvoid sub(V &a,V &b){for(int i=0;i<(int)a.size();i++)a[i]-=b[i];}\n\n//?¢?????????????DFS??§??¢???\nV dfs(int v,int t,V f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap != zero){\n      V d = dfs(e.to ,t , min(f,e.cap));\n      if(d != zero){\n\tsub(e.cap,d);\n\tadd(G[e.to][e.rev].cap,d);\n\treturn d;\n      }\n    }\n  }\n  return zero;\n}\n\n//s??????t???????????§???????±???????\nV max_flow(int s,int t){\n  V flow=zero;\n  for(;;){\n    memset(used,0,sizeof(used));\n    V f = dfs(s, t, V(51,1e4));\n    if(f == zero)return flow;\n    add(flow,f);\n  }\n}\n\nint StoI(string &a,int &i){\n  int res=0;\n  while(isdigit(a[i])) res=res*10+a[i++]-'0';\n  return res;\n}\n\nstring ItoS(int a){\n  string res;\n  while(a) res=char(a%10+'0')+res,a/=10;\n  if(res.empty()) res=\"0\";\n  return res;\n}\n\nV StoV(string s){\n  if(s==\"0\") return zero;\n  V res(51);\n  for(int i=0;i<s.size();i++){\n    int a = max(1,StoI(s,i));\n    int L = 0;\n    if(s[i]=='x')i+=1+(s[i+1]=='^'),L=max(1,StoI(s,i));\n    res[L] = a;\n  }\n  return res;\n}\n\nstring VtoS(V a){\n  string res;\n  for(int i=a.size()-1;i>=0;i--){\n    if(a[i]==0)continue;\n    if(!res.empty()) res+='+';\n    if(a[i]>1||i==0) res+=ItoS(a[i]);\n    if(i)res+='x';\n    if(i>1) res+='^'+ItoS(i);\n  }\n  if(res.empty()) res=\"0\";\n  return res;\n}\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m) return 0;\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n    for(int i=0,a,b;i<m;i++){\n      string c;\n      cin>>a>>b>>c;\n      V vc = StoV(c);\n      add_edge(a-1,b-1,vc);\n    }\n\n    V ans = max_flow(0,n-1);\n    cout<<VtoS(ans)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 50;\nconst int INF = 1 << 20;\nconst int L = 52;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\nvector<int> vec_INF = vec_zero;\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero){\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n        for(int j=0;j<L;j++) e.cap[j] -= d[j];\n        for(int j=0;j<L;j++) G[e.to][e.rev].cap[j] += d[j];\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n    if(f == vec_zero) return flow;\n    for(int j=0;j<L;j++) flow[j] += f[j];\n  }\n}\n\nvoid init(){\n  vec_INF[0] = 1;\n  for(int i=0;i<MAX_V;i++){\n\t\tG[i].clear();\n\t\tused[i] = false;\n\t}\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == 'x') x = i;\n  if(x == -1) return make_pair(0, atoi(s.c_str()));\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0) res.second = 1;\n\telse res.second = atoi(tmp.c_str());\n  int h = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == '^') res.first = atoi(s.substr(i+1).c_str());\n\tif(h == -1) res.first = 1;\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size() || s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      if(i == s.size()) break;\n\t\t\tpre = i + 1;\n    }\n  }\n  return res;\n}\n\nmain(){\n\tint V, E;\n  while(cin >> V >> E && (V|E)){\n\t\tinit();\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      vector<int> tmp = calc(s);\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n    bool first = true;\n    for(int i=L-1;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else cout << \"+\";\n      if(i == 0) cout << ans[i];\n\t\t\telse{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1) cout << \"x\";\n\t\t\t\telse cout << \"x^\" << i;\n      }\n    }\n\t\tif(first) cout << 0;\n\t\tcout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nvi& operator+=(vi &a, const vi &b){\n\twhile(a.size() < b.size()) a.pb(0);\n\trep(i, a.size()) a[i] += b[i];\n\twhile(a.back() == 0) a.pop_back();\n\treturn a;\n}\nvi& operator-=(vi &a, const vi &b){\n\twhile(a.size() < b.size()) a.pb(0);\n\trep(i, a.size()) a[i] -= b[i];\n\twhile(a.back() == 0) a.pop_back();\n\treturn a;\n}\nvi min(const vi &a, const vi &b){\n\tif(a.size() != b.size()) return a.size() < b.size() ? a : b;\n\tfor(int i = a.size() - 1; i >= 0; i--) if(a[i] < b[i]) return a;\n\treturn b;\n}\nbool operator>(const vi &a, int b){\n\trep(i, a.size()) if(a[i] > 0) return 1;\n\treturn 0;\n}\nstruct flowGraph{\n\tstruct edge{\n\t\tint to, rev; \n\t\tvi cap;\n\t\tedge(int to, const vi &c, int rev) : to(to), rev(rev){\n\t\t\tcap = c;\n\t\t}\n\t};\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tflowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~flowGraph(){\n\t\tdelete iter; delete level;\n\t}\n\t\n\tvoid add(int s, int t, const vi &cap){\n\t\tG[s].pb(edge(t, cap, G[t].size()));\n\t\tG[t].pb(edge(s, vi(0), G[s].size() - 1));\n\t}\n\t\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvi dfs(int v, int t, vi f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\tvi d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vi(0);\n\t}\n\tvi max_flow(int s, int t){\n\t\tvi flow;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tvi f(51, inf);\n\t\t\twhile((f = dfs(s, t, f)) > 0) flow += f;\n\t\t}\n\t}\n};\nvi parse(string s){\n\teach(i, s) if(*i == '+') *i = ' ';\n\tstringstream ss(s);\n\tvi v;\n\twhile(ss >> s){\n\t\tint p, e = s.find(\"x\") != s.npos;\n\t\tif((p = s.find(\"^\")) != s.npos){\n\t\t\te = atoi(s.substr(p + 1).c_str());\n\t\t}\n\t\twhile(v.size() <= e) v.pb(0);\n\t\t\n\t\tif((p = s.find(\"x\")) != s.npos) s = s.substr(0, p);\n\t\tif(s == \"\") s += \"1\";\n\t\tv[e] = atoi(s.c_str());\n\t}\n\treturn v;\n}\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tflowGraph g(n);\n\t\trep(i, m){\n\t\t\tint a, b;\n\t\t\tstring c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tvi v = parse(c);\n\t\t\tg.add(a, b, v);\n\t\t\tg.add(b, a, v);\n\t\t}\n\t\tvi ans = g.max_flow(0, n - 1);\n\t\tif(ans.empty()){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = ans.size() - 1; i >= 0; i--){\n\t\t\tif(ans[i] == 0) continue;\n\t\t\tif(i < ans.size() - 1) cout << \"+\";\n\t\t\tif(ans[i] != 1 || i == 0) cout << ans[i];\n\t\t\tif(i > 0) cout << \"x\";\n\t\t\tif(i > 1) cout << \"^\" << i;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i,n) for (ll i=0; i<(ll)(n); ++i)\n#define FOR(i,k,n) for (ll i=(k); i<(ll)(n); ++i)\n#define FOREQ(i,k,n) for (ll i=(k); i<=(ll)(n); ++i)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define SZ(v) (ll)((v).size())\n#define MEMSET(v,h) memset((v),(h),sizeof(v))\n\ntypedef ll Weight;\nstruct Edge {\n  ll src;\n  ll dest;\n  Weight weight;\n  Edge() {;}\n  Edge(ll src, ll dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n/*\n   void PrllMatrix(const Matrix &mat) {\n   REP(y, h) {\n   REP(x, w) {\n   prllf(\"%d \", mat[y][x]);\n   }\n   puts(\"\");\n   }\n   }\n   */\n\nll MaxFlow(const Graph &g, ll s, ll t, Matrix &flow) {\n  const ll n = g.size();\n  flow = Matrix(n, Array(n, 0));\n  Matrix capacity(n, Array(n, 0));\n  REP(i, n) {\n    FORIT(it, g[i]) {\n      capacity[it->src][it->dest] += it->weight;\n    }\n  }\n  ll ret = 0;\n  vector<ll> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.front();\n      que.pop();\n      if (parent[node.dest] != -1) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      ll from = node.dest;\n      FORIT(it, g[from]) {\n        ll to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight f = 1 << 30;\n    ll from = parent[t];\n    ll to = t;\n    while (from != to) {\n      f = min(f, capacity[from][to]) ;\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      flow[from][to] += f;\n      flow[to][from] -= f;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += f;\n  }\n  return ret;\n}\n\nvoid AddEdge(Graph &g, ll from, ll to, ll weight) {\n  if (weight == 0) { return; }\n  g[from].push_back(Edge(from, to, weight));\n  g[to].push_back(Edge(to, from, weight));\n  cout << from << \" \" << to << \" \" << weight << endl;\n}\n\n//====================================\n\nll Getll(const char *str, ll &index) {\n  ll ret = 1;\n  if (isdigit(str[index])) {\n    ret = atoi(str + index);\n    while (isdigit(str[index])) { index++; }\n  }\n  return ret;\n}\n\nvector<ll> Parse(const char *str) {\n  vector<ll> ret(52, 0);\n  //ll len = strlen(str);\n  ll index = 0;\n  while (str[index]) {\n    ll a = Getll(str, index);;\n    ll degree = 0;\n    if (str[index] == 'x') {\n      degree = 1;\n      index++;\n      if (str[index] == '^') {\n        index++;\n        degree = Getll(str, index);\n      }\n    }\n    if (str[index] == '+') { index++; }\n    ret[degree] = a;\n  }\n  return ret;\n}\n\nvoid PrintAns(vector<ll> &ans) {\n  bool first = true;\n  for (ll i = 51; i >= 0; i--) {\n    if (ans[i] == 0) { continue; }\n    if (!first) { printf(\"+\"); }\n    first = false;\n    if (i == 0) {\n      printf(\"%lld\", ans[i]);\n    } else if (i >= 1) {\n      if (ans[i] >= 2) {\n        printf(\"%lld\", ans[i]);\n      }\n      printf(\"x\");\n      if (i >= 2) {\n        printf(\"^%lld\", i);\n      }\n    }\n  }\n  if (first) {\n    printf(\"0\");\n  }\n  puts(\"\");\n}\n\n\nconst ll INF = 1 << 28;\nll n, m;\n//ll u[1000];\n//ll v[1000];\nvector<ll> poly[60][60];\n//vector<ll> poly[1000];\nchar str[6666];\n\nint main() {\n  while (scanf(\"%lld %lld\", &n, &m), n|m) {\n    REP(y, 60) REP(x, 60) { poly[y][x] = vector<ll>(52, 0); }\n    REP(i, m) {\n      ll u, v;\n      scanf(\"%lld %lld %s\", &u, &v, str);\n      u--; v--;\n      vector<ll> p = Parse(str);\n      REP(j, 51) {\n        poly[u][v][j] += p[j];\n        poly[v][u][j] += p[j];\n      }\n    }\n    vector<ll> ans(52, 0);\n    for (ll i = 51; i >= 0; i--) {\n      Graph g(n);\n      REP(y, n) {\n        REP(x, n) {\n          if (poly[y][x][i] == 0) { continue; }\n          g[y].push_back(Edge(y, x, poly[y][x][i]));\n        }\n      }\n      Matrix flow;\n      ans[i] = MaxFlow(g, 0, n - 1, flow);\n      if (i != 0) {\n        REP(y, n) {\n          REP(x, n) {\n            if (poly[y][x][i] - flow[y][x] == 0) { continue; }\n            if (poly[y][x][i] + flow[y][x] == 0) { continue; }\n            poly[y][x][i - 1] = INF;\n          }\n        }\n      }\n    }\n    PrintAns(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=100;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>calc(string s) {\n\tvector<int>res(51);\n\tif (s == \"x\") {\n\t\tres[49] = 1; return res;\n\t}\n\tint u = 0, v = 0;\n\tbool flag = true;\n\tfor (char c : s) {\n\t\tif (isdigit(c)) {\n\t\t\tif (flag)u = u * 10 + c - '0';\n\t\t\telse v = v * 10 + c - '0';\n\t\t}\n\t\tif (c == 'x')flag = false;\n\t\tif (c == '+') {\n\t\t\tflag = true;\n\t\t\tif (u == 0)u = 1;\n\t\t\tif (v == 0)v = 1;\n\t\t\tres[50 - v] = u; u = v = 0;\n\t\t}\n\t}\n\tif (u)res[50] = u;\n\treturn res;\n}\nvoid add(vector<int>&a, vector<int>b) {\n\trep(i, a.size())a[i] += b[i];\n}\nvoid sub(vector<int>&a, vector<int>b) {\n\trep(i, a.size())a[i] -= b[i];\n}\nstruct edge { int to; vector<int>cap; int rev; };\nbool used[50];\nvector<edge>E[50];\n\nvoid add_edge(int from, int to, vector<int>cap) {\n\tE[from].push_back({ to,cap,(int)E[to].size() });\n\tE[to].push_back({ from,cap,(int)E[from].size() - 1 });\n}\nvector<int>dfs(int v, int t, vector<int>f) {\n\tused[v] = true;\n\tif (v == t)return f;\n\tfor (edge&e : E[v]) {\n\t\tif (used[e.to] || e.cap == vector<int>(51))continue;\n\t\tvector<int>d = dfs(e.to, t, min(f, e.cap));\n\t\tif (d != vector<int>(51)) {\n\t\t\tsub(e.cap, d); add(E[e.to][e.rev].cap, d);\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn vector<int>(51);\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\trep(i, n)E[i].clear();\n\t\trep(i, m) {\n\t\t\tint a, b; string s; cin >> a >> b >> s; a--; b--;\n\t\t\tadd_edge(a, b, calc(s));\n\t\t}\n\t\tvector<int>INF(51, INT_MAX);\n\t\tvector<int>res(51);\n\t\twhile (1) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tvector<int>f = dfs(0, n - 1, INF);\n\t\t\tif (f == vector<int>(51))break;\n\t\t\tadd(res, f);\n\t\t}\n\t\tbool flag = false;\n\t\trep(i, 51) {\n\t\t\tif (res[i] == 0)continue;\n\t\t\tif (flag)printf(\"+\");\n\t\t\tif (i == 50)printf(\"%d\", res[i]);\n\t\t\telse if (i == 49) {\n\t\t\t\tif (res[i] == 1)printf(\"x\");\n\t\t\t\telse printf(\"%dx\", res[i]);\n\t\t\t}\n\t\t\telse if (res[i] == 1)printf(\"x^%d\", 50 - i);\n\t\t\telse printf(\"%dx^%d\", res[i], 50 - i);\n\t\t\tflag = true;\n\t\t}\n\t\tif (!flag)printf(\"0\");\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Weight weight; Capacity cap;\n\tEdge(int s, int d, Weight w, Capacity c) : src(s), dst(d), weight(w), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct FordFulkerson {\n\ttypedef vector<vector<Capacity>> Matrix;\n\tint n, t;\n\tvector<bool> vis;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tFordFulkerson(int n)\n\t\t: n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t}\n\tFordFulkerson(const Graph &graph) {\n\t\t*this = FordFulkerson(graph.size());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n\t\t}\n\t}\n\tvoid addEdge(int u, int v, Capacity c) {\n\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tCapacity solve(int s, int t) {\n\t\tthis->t = t;\n\t\tCapacity res = 0, aug = 1;\n\t\twhile(aug > 0) {\n\t\t\tvis.assign(n, false);\n\t\t\tres += (aug = augment(s, inf));\n\t\t}\n\t\treturn res;\n\t}\n\tCapacity augment(const int &v, const Capacity &lim) {\n\t\tvis[v] = true;\n\t\tif(v == t) return lim;\n\t\tfor(const int &d : g[v]) {\n\t\t\tif(vis[d] || flow[v][d] == cap[v][d]) continue;\n\t\t\tCapacity aug = augment(d, min(lim, cap[v][d] - flow[v][d]));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tif(aug > 0) return aug;\n\t\t}\n\t\treturn 0;\n\t}\n};\n\ntypedef pair<int, int> Pii;\n\nvector<int> f(string s) {\n\treplace(s.begin(), s.end(), '+', ' ');\n\t//cout << s << endl;\n\tvector<int> ret(51);\n\n\tstringstream ss(s);\n\twhile(ss >> s) {\n\t\tstringstream ss2(s);\n\t\tif(s.find('x') == string::npos) {\n\t\t\tss2 >> ret[0];\n\t\t}\n\t\telse {\n\t\t\tchar c;\n\t\t\tint a = 1, L = 1;\n\t\t\tif(s[0] != 'x') ss2 >> a;\n\t\t\tif(s.find('^') != string::npos) {\n\t\t\t\tss2 >> c >> c >> L; // x^L\n\t\t\t}\n\t\t\tret[L] = a;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint u[500];\nint v[500];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M;\n\twhile(cin >> N >> M, N) {\n\t\tmap<Pii, vector<int> > poly;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tstring p;\n\t\t\tcin >> u[i] >> v[i] >> p;\n\t\t\tu[i]--, v[i]--;\n\t\t\tpoly[Pii(u[i], v[i])] = f(p);\n\t\t}\n\n\t\tvector<int> ans(51);\n\t\tfor(int i = 50; i >= 0; i--) {\n\t\t\tGraph G(N);\n\n\t\t\tfor(auto&& p : poly) {\n\t\t\t\tint a = p.first.first, b = p.first.second, c = p.second[i];\n\t\t\t\tG[a].emplace_back(a, b, 0, c);\n\t\t\t\tG[b].emplace_back(b, a, 0, c);\n\t\t\t}\n\n\t\t\tFordFulkerson ff(G);\n\t\t\tint f = ff.solve(0, N - 1);\n\t\t\tans[i] = f;\n\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tint a = u[j], b = v[j];\n\t\t\t\tif(ff.flow[a][b] != 0 && ff.flow[a][b] != ff.cap[a][b]) {\n\t\t\t\t\tfor(int l = 0; l <= i; l++) {\n\t\t\t\t\t\tpoly[Pii(a, b)][l] = 1e8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor(int i = 50; i >= 0; i--) {\n\t\t\tif(ans[i] == 0) continue;\n\t\t\tif(flag) cout << \"+\";\n\t\t\tflag = true;\n\t\t\tif(i == 0 || ans[i] != 1) cout << ans[i];\n\t\t\tif(i != 0) cout << \"x\";\n\t\t\tif(i >= 2) cout << \"^\" << i;\n\t\t}\n\t\tif(!flag) cout << 0;\n\t\tcout << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e4\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  assert(res.size()==v.size());\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  assert(res.size()==v.size());\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  assert(A.size()==B.size());\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      \n      /*      for(int j=0;j<d.size();j++){\n\tcout<<j<<endl;\n\tassert(d[j]!=INF);\n\t}*/\n      \n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> r=vector<int>(V,0);\n    r[0]=INF;\n    vector<int> f = dfs(s, t, r);\n    if(isall0(f)) return flow;\n    /*if(isallnotINF(f)) */Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    assert(0!=n-1);\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 1e8);\n\nPoly operator-(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly& a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\nbool operator<(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] < b[i];\n\t}\n\treturn false;\n}\n\nbool operator<=(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] < b[i];\n\t}\n\treturn true;\n}\n\nbool operator>(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\treturn a[i] > b[i];\n\t}\n\treturn false;\n}\n\nPoly min(const Poly& a, const Poly& b)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == b[i]) continue;\n\t\tif (a[i] < b[i]) return a;\n\t\telse return b;\n\t}\n\treturn b;\n}\n\nbool resid(const Poly& a)\n{\n\tfor (int i = 50; i >= 0; i--)\n\t{\n\t\tif (a[i] == 0) continue;\n\t\treturn a[i] > 0;\n\t}\n\treturn false;\n}\n\ntemplate <typename Flow>\nstruct FEdge {\n\tint from, to;\n\tFlow cap; int rev;\n\tFEdge(int s, int t, Flow f, int r) : from(s), to(t), cap(f), rev(r) {}\n};\n\ntemplate<typename Flow> using FGraph = vector<vector<FEdge<Flow>>>;\n\ntemplate <typename Flow>\nvoid add_edge(FGraph<Flow> &g, int from, int to, Flow cap) {\n\tg[from].emplace_back(from, to, cap, (int)g[to].size());\n\tg[to].emplace_back(to, from, ZERO, (int)g[from].size() - 1);\n}\n\ntemplate <typename Flow>\nFlow augment(FGraph<Flow> &g, vi &d, vector<int> &iter, int v, int t, const Flow &f) \n{\n\tif (v == t || !resid(f)) return f;\n\tfor (int &i = iter[v]; i < (int)g[v].size(); i++) {\n\t\tauto &e = g[v][i];\n\t\tif (e.cap > ZERO && d[v] < d[e.to]) {\n\t\t\tFlow ff = augment(g, d, iter, e.to, t, min(f, e.cap));\n\t\t\tif (resid(ff)) {\n\t\t\t\te.cap = e.cap - ff;\n\t\t\t\tg[e.to][e.rev].cap = g[e.to][e.rev].cap + ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\ntemplate <typename Flow>\nFlow max_flow(FGraph<Flow> &g, int s, int t, Flow zero = ZERO) {\n\tint V = g.size();\n\tFlow flow = zero;\n\tfor (;;) {\n\t\tvi d(V, -1);\n\t\tqueue<int> que;\n\t\td[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (const auto &e : g[v]) {\n\t\t\t\tif (e.cap <= zero ||  d[e.to] >= 0) continue;\n\t\t\t\td[e.to] = d[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tif (d[t] < 0) return flow;\n\t\tvector<int> iter(V, 0);\n\t\tFlow f;\n\t\twhile ((f = augment(g, d, iter, s, t, INF)) > ZERO) flow = flow + f;\n\t}\n}\n\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[m] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[1] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[0] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tFGraph<Poly> g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = max_flow(g, 0, n - 1);\n\t\tstring anss;\n\t\tfor (int i = 50; i >= 0; i--)\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i > 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 1)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 0)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int INF = 1<<28;\nconst int L = 51;\n \nstruct Edge {\n  int to, cost, rev;\n  vector<int> cap;\n  Edge(int to, int cost, vector<int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n \ntypedef vector<vector<Edge> > Graph;\n \nvoid addEdgeF(int from, int to, int cost, vector<int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, vector<int>(L), (int)g[from].size()-1));\n}\n \ninline void add(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] += b[i];\n}\n \ninline void subtract(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] -= b[i];\n}\n \ninline bool lt(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return false;\n}\n \ninline bool le(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return true;\n}\n \nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0 &&\n     *min_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(abs(ans[i]) != 1) cout << abs(ans[i]);\n    if(i > 1) cout << \"x^\" << i;\n    else if(i == 1) cout << \"x\";\n    j++;\n  }\n  cout << endl;\n}\n \nvector<int> dfsF(int v, int t, vector<int> f, vector<int> &used, Graph &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(!used[e.to] && lt(vector<int>(L), e.cap)) {\n      vector<int> d = dfsF(e.to, t, lt(f, e.cap) ? f : e.cap, used, g);\n      if(lt(vector<int>(L), d)) {\n        subtract(e.cap, d);\n        add(g[e.to][e.rev].cap, d);\n        return d;\n      }\n    }\n  }\n  return vector<int>(L);\n}\n \nvector<int> maxFlow(int s, int t, Graph g) {\n  vector<int> flow(L);\n  vector<int> used(g.size());\n  while(1) {\n    fill(used.begin(), used.end(), 0);\n    vector<int> f = dfsF(s, t, vector<int>(L, INF), used, g);\n    if(le(f, vector<int>(L))) break;\n    add(flow, f);\n  }\n  return flow;\n}\n \nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      vector<int> cap(L);\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n        int a = 1;\n        {\n          int i = 0;\n          while(i < s.size() && isdigit(s[i])) ++i;\n          if(i) {\n            a = atoi(s.substr(0, i).c_str());\n            s = s.substr(i);\n          }\n        }\n        int k = 0;\n        // \"\" or \"x\" or \"x^y\"\n        if(s == \"x\") {\n          k = 1;\n        } else if(s.size()) {\n          k = atoi(s.substr(2).c_str());\n        }\n        cap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      addEdgeF(v, u, 0, cap, g);\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(i<n){\n\t\t\t\tret+=\"+\";\n\t\t\t}\n\t\t\tif(a[i]){\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=a[i]+'0';\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=a[i]+'0';\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)+(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)-(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nconst poly Zero=to_poly(string(\"0\"));\nconst poly Inf=to_poly(string(\"x^51\"));\n\nvoid add_edge(int from,int to,poly& cap,vve &g){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g);\n\t\t\tadd_edge(v,u,pol,g);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 55;\nconst int INF = 1 << 28;\nconst int L = 53;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero){\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n\t\t\t\tint zero = -1;\n        for(int j=0;j<L;j++){\n\t\t\t\t\tif(zero == -1 && e.cap[j] < d[j]) zero = 1;\n\t\t\t\t\tif(zero == -1 && e.cap[j] > d[j]) zero = 0;\n\t\t\t\t\tif(zero) e.cap[j] -= d[j];\n\t\t\t\t\telse e.cap[j] = 0;\n        }\n        for(int j=0;j<L;j++) G[e.to][e.rev].cap[j] += d[j];\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vector<int> vec_INF = vec_zero;\n  vec_INF[0] = 1;\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n    if(f == vec_zero) return flow;\n    for(int j=0;j<L;j++) flow[j] += f[j];\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == 'x') x = i;\n  if(x == -1) return make_pair(0, atoi(s.c_str()));\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0) res.second = 1;\n\telse res.second = atoi(tmp.c_str());\n  int h = -1;\n  for(int i=0;i<s.size();i++) if(s[i] == '^') res.first = atoi(s.substr(i+1).c_str());\n\tif(h == -1) res.first = 1;\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size() || s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      if(i == s.size()) break;\n\t\t\tpre = i + 1;\n    }\n  }\n  return res;\n}\n\nmain(){\n\tint V, E;\n  while(cin >> V >> E && (V|E)){\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      vector<int> tmp = calc(s);\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n    bool first = true;\n    for(int i=L-1;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else cout << \"+\";\n      if(i == 0) cout << ans[i];\n\t\t\telse{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1) cout << \"x\";\n\t\t\t\telse cout << \"x^\" << i;\n      }\n    }\n\t\tif(first) cout << 0;\n\t\tcout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nvector<int> Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n  return res;\n}\n\nvector<int> Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n  return res;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(55,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(55,INF));\n    if(isall0(f))return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(55,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(55,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+='+';\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+='x';\n    else if(i) s+=\"x^\"+itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      /*      vector<int> r=tocap(s);\n      for(int j=0;j<r.size();j++) cout<<r[j]<<' ';\n      cout<<endl;*/\n      add_edge(a-1,b-1,tocap(s));\n      add_edge(b-1,a-1,tocap(s));\n    }\n    \n    output(max_flow(0,n-1));\n\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge { int to,cap,rev; };\n#define MAX 60\n#define INF (1e7)\nint n;\nvector<int> G[MAX][MAX];\nbool used[MAX];\n\nvector<int> min(vector<int> &a,vector<int> &b){\n  for(int i=MAX-1;i>=0;i--){\n    if( a[i]==b[i] )continue;\n    if(a[i]>b[i])return b;\n    if(a[i]<b[i])return a;\n  }\n  return a;\n}\n\nvoid add(vector<int> &a,vector<int> &b){\n  for(int i=0;i<MAX;i++)\n    a[i]+=b[i];\n}\n\nvoid sub(vector<int> &a,vector<int> b){\n  for(int i=0;i<MAX;i++)\n    a[i]-=b[i];\n}\n\nbool check(vector<int> &a){\n  for(int i=0;i<MAX;i++)\n    if(a[i]>0)return true;\n  return false;\n}\n\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=1;i<=n;i++){\n    vector<int> &e=G[v][i];\n    if(!used[i] && check(e) ){\n      vector<int> d=dfs( i,t,min(f,e));\n      if( d.size()==MAX && check(d) ){\n        sub(G[v][i],d);\n        add(G[i][v],d);\n        return d;\n      }\n    }\n  }\n  return vector<int>();\n}\n\nvector<int> max_flow(int s,int t){\n  vector<int> flow(MAX,0);\n  while(1){\n    memset(used,0,sizeof(used));\n    vector<int> tmp(MAX,INF);\n    vector<int> f=dfs(s,t,tmp);\n    if(f.size()==0)return flow;\n    add(flow,f);\n  }\n  return flow;\n}\n\nint m;\nint t[MAX][MAX][MAX];\nint u[MAX][MAX];\n\nint s2i(string s){\n  stringstream ss;\n  int res;\n  ss<<s;\n  ss>>res;\n  return res;\n}\n\nvoid func(int a,int b,string &tmp){\n  int len=tmp.size();\n  int flg=0;\n  for(int i=0;i<len;i++){\n    if('0'<=tmp[i]&&tmp[i]<='9')continue;\n    flg=1;\n  }\n  if(flg==0){\n    t[a][b][0]=t[b][a][0]=s2i(tmp);\n    return;\n  }\n  \n  int v,w;\n  if(tmp[0]=='x')v=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='x'){\n        v=s2i(tmp.substr(0,i));\n        break;\n      }\n    }\n  }\n  \n  if(tmp[len-1]=='x')w=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='^'){\n        w=s2i(tmp.substr(i+1));\n        break;\n      }\n    }\n  }\n  t[a][b][w]=t[b][a][w]=v;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)break;\n    memset(t,0,sizeof(t));\n    memset(u,0,sizeof(u));\n    for(int i=0;i<m;i++){\n      int a,b;\n      string s,tmp;\n      cin>>a>>b>>s;\n      for(int j=0;j<(int)s.size();j++)\n        if(s[j]=='+')s[j]=' ';\n      stringstream ss(s);\n      while(ss>>tmp){\n        func(a,b,tmp);\n      }\n    }\n\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n        G[i][j].clear();\n        for(int k=0;k<MAX;k++){\n          G[i][j].push_back(t[i][j][k]);\n        }\n      }\n    }\n\n    vector<int> ans=max_flow(1,n);\n    bool cnt=0;\n    for(int i=MAX-1;i>=0;i--){\n      if(ans[i]==0)continue;\n      if(cnt>0)cout<<'+';\n      cnt++;\n      if(i==0||ans[i]>1)cout<<ans[i];\n      if(i)cout<<'x';\n      if(i>1)cout<<\"^\"<<i;\n    }\n    if(cnt==0)cout<<0;\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Mobile Network\n//Level: 3\n//Category: グラフ,Graph,最大流\n//Note:\n\n/**\n * x^kの項に対する係数をL-k番目の要素としてもつようなvectorを考え、これを辞書順で最大にすればよい。\n * フローの型がベクトル値である以外は、普通の最大流で求められる。\n * ただし、residual flowがあるかどうかの判定は、0でない最高次の項の正負で判定する。\n *\n * オーダーは O(M^2 NL)。\n */\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <string>\n\nusing namespace std;\n\ntypedef vector<int> Poly;\nnamespace std {\n    Poly& operator +=(Poly &a, const Poly &b) {\n        for(int i = 0; i < a.size(); ++i) {\n            a[i] += b[i];\n        }\n        return a;\n    }\n    Poly& operator -=(Poly &a, const Poly &b) {\n        for(int i = 0; i < a.size(); ++i) {\n            a[i] -= b[i];\n        }\n        return a;\n    }\n    Poly operator -(const Poly &a, const Poly &b) {\n        Poly res = a;\n        res -= b;\n        return res;\n    }\n};\n\nbool is_residual(const Poly &a) {\n    for(int v : a) {\n        if(v != 0) return v > 0;\n    }\n    return false;\n}\n\nconst int L = 50;\n\ntemplate<class Flow>\nstruct Edge {\n    int from, to;\n    Flow capacity, flow;\n    Edge *back;\n    Edge() {}\n    Edge(int from, int to, Flow c, Edge *b) : from(from), to(to), capacity(c), flow(Poly(L+1, 0)), back(b) {}\n};\n\ntemplate<class Flow>\nvoid make_edge(vector<vector<Edge<Flow>*>> &g, int src, int dst, Flow c) {\n    auto *e = new Edge<Flow>(src, dst, c, nullptr);\n    auto *back = e->back = new Edge<Flow>(dst, src, c, e);\n    g[src].push_back(e);\n    g[dst].push_back(back);\n}\n\ntemplate <class T>\nT dinic_augment(vector<vector<Edge<T>*>> &graph, vector<int> &level, vector<bool> &finished, int u, int sink, T cur)/*{{{*/\n{\n    if (u == sink || !is_residual(cur)) {\n        return cur;\n    }\n    if (finished[u]) {\n        return Poly(L+1, 0);\n    }\n    finished[u] = true;\n    for(auto e : graph[u]) {\n        if(e->capacity > e->flow && level[e->to] > level[u]) {\n            const T f = dinic_augment(graph, level, finished, e->to, sink, min(cur, e->capacity - e->flow));\n            if (is_residual(f)) {\n                e->flow += f;\n                e->back->flow -= f;\n                finished[u] = false;\n                return f;\n            }\n        }\n    }\n    return Poly(L+1, 0);\n}/*}}}*/\n\n// O(V^2 E)\ntemplate <typename T>\nT dinic(vector<vector<Edge<T>*>> &graph, int source, int sink)/*{{{*/\n{\n    const int N = graph.size();\n    T max_flow(L+1, 0);\n\n    vector<int> level(N);\n    vector<bool> finished(N);\n    while (true) {\n        fill(level.begin(), level.end(), -1);\n        level[source] = 0;\n        queue<int> q;\n        q.push(source);\n\n        int d = N;\n        while (!q.empty() && level[q.front()] < d) {\n            const int u = q.front();\n            q.pop();\n\n            if (u == sink) {\n                d = level[u];\n            }\n            for(auto e : graph[u]) {\n                if (level[e->to] < 0 && e->capacity > e->flow) {\n                    q.push(e->to);\n                    level[e->to] = level[u] + 1;\n                }\n            }\n        }\n\n        fill(finished.begin(), finished.end(), false);\n        bool updated = false;\n        while (true) {\n            const T f = dinic_augment<T>(graph, level, finished, source, sink, Poly(L+1, 100*500*100));\n            if (!is_residual(f)) {\n                break;\n            }\n            max_flow += f;\n            updated = true;\n        }\n\n        if (!updated) {\n            break;\n        }\n    }\n\n    return max_flow;\n}/*}}}*/\n\ntypedef string::const_iterator Iterator;\nint number(Iterator &it) {\n    int res = 0;\n    while(isdigit(*it)) {\n        res *= 10;\n        res += *it - '0';\n        ++it;\n    }\n    return res;\n}\n\npair<int,int> term(Iterator &it) {\n    pair<int,int> res(1, 0);\n    if(isdigit(*it)) res.first = number(it);\n    if(*it == 'x') {\n        res.second = 1;\n        ++it;\n        if(*it == '^') {\n            ++it;\n            res.second = number(it);\n        }\n    }\n    return res;\n}\n\nPoly parse(const string &s) {\n    Iterator it = s.begin();\n    Poly res(L+1, 0);\n    do {\n        const auto t = term(it);\n        res[L-t.second] = t.first;\n    } while(*it++ == '+');\n    return res;\n}\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if(!N && !M) return false;\n\n    vector<vector<Edge<Poly>*>> g(N);\n    for(int i = 0; i < M; ++i) {\n        int a, b;\n        string expr;\n        cin >> a >> b >> expr;\n        --a; --b;\n        make_edge(g, a, b, parse(expr));\n    }\n    const auto ans = dinic(g, 0, N-1);\n    bool first = true;\n    for(int i = 0; i <= L; ++i) {\n        if(ans[i] != 0) {\n            if(!first) cout << \"+\";\n            if(ans[i] > 1 || i == L) cout << ans[i];\n            const int ord = L - i;\n            if(ord >= 1) {\n                cout << \"x\";\n                if(ord >= 2) {\n                    cout << \"^\" << ord;\n                }\n            }\n            first = false;\n        }\n    }\n    if(first) cout << 0;\n    cout << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i,n) for (ll i=0; i<(ll)(n); ++i)\n#define FOR(i,k,n) for (ll i=(k); i<(ll)(n); ++i)\n#define FOREQ(i,k,n) for (ll i=(k); i<=(ll)(n); ++i)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define SZ(v) (ll)((v).size())\n#define MEMSET(v,h) memset((v),(h),sizeof(v))\n\ntypedef ll Weight;\nstruct Edge {\n  ll src;\n  ll dest;\n  Weight weight;\n  Edge() {;}\n  Edge(ll src, ll dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n/*\n   void PrllMatrix(const Matrix &mat) {\n   REP(y, h) {\n   REP(x, w) {\n   prllf(\"%d \", mat[y][x]);\n   }\n   puts(\"\");\n   }\n   }\n   */\n\nll MaxFlow(const Graph &g, ll s, ll t, Matrix &flow) {\n  const ll n = g.size();\n  flow = Matrix(n, Array(n, 0));\n  Matrix capacity(n, Array(n, 0));\n  REP(i, n) {\n    FORIT(it, g[i]) {\n      capacity[it->src][it->dest] += it->weight;\n    }\n  }\n  ll ret = 0;\n  vector<ll> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.front();\n      que.pop();\n      if (parent[node.dest] != -1) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      ll from = node.dest;\n      FORIT(it, g[from]) {\n        ll to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight f = 1 << 30;\n    ll from = parent[t];\n    ll to = t;\n    while (from != to) {\n      f = min(f, capacity[from][to]) ;\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      flow[from][to] += f;\n      flow[to][from] -= f;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += f;\n  }\n  return ret;\n}\n\nvoid AddEdge(Graph &g, ll from, ll to, ll weight) {\n  if (weight == 0) { return; }\n  g[from].push_back(Edge(from, to, weight));\n  g[to].push_back(Edge(to, from, weight));\n  cout << from << \" \" << to << \" \" << weight << endl;\n}\n\n//====================================\n\nll Getll(const char *str, ll &index) {\n  ll ret = 1;\n  if (isdigit(str[index])) {\n    ret = atoi(str + index);\n    while (isdigit(str[index])) { index++; }\n  }\n  return ret;\n}\n\nvector<ll> Parse(const char *str) {\n  vector<ll> ret(52, 0);\n  //ll len = strlen(str);\n  ll index = 0;\n  while (str[index]) {\n    ll a = Getll(str, index);;\n    ll degree = 0;\n    if (str[index] == 'x') {\n      degree = 1;\n      index++;\n      if (str[index] == '^') {\n        index++;\n        degree = Getll(str, index);\n      }\n    }\n    if (str[index] == '+') { index++; }\n    ret[degree] = a;\n  }\n  return ret;\n}\n\nvoid PrintAns(vector<ll> &ans) {\n  bool first = true;\n  for (ll i = 51; i >= 0; i--) {\n    if (ans[i] == 0) { continue; }\n    if (!first) { printf(\"+\"); }\n    first = false;\n    if (i == 0) {\n      printf(\"%lld\", ans[i]);\n    } else if (i >= 1) {\n      if (ans[i] >= 2) {\n        printf(\"%lld\", ans[i]);\n      }\n      printf(\"x\");\n      if (i >= 2) {\n        printf(\"^%lld\", i);\n      }\n    }\n  }\n  if (first) {\n    printf(\"0\");\n  }\n  puts(\"\");\n}\n\n\nconst ll INF = 1 << 20;\nll n, m;\n//ll u[1000];\n//ll v[1000];\nvector<ll> poly[60][60];\n//vector<ll> poly[1000];\nchar str[6666];\n\nint main() {\n  while (scanf(\"%lld %lld\", &n, &m), n|m) {\n    REP(y, 60) REP(x, 60) { poly[y][x] = vector<ll>(52, 0); }\n    REP(i, m) {\n      ll u, v;\n      scanf(\"%lld %lld %s\", &u, &v, str);\n      u--; v--;\n      vector<ll> p = Parse(str);\n      REP(j, 51) {\n        poly[u][v][j] += p[j];\n        poly[v][u][j] += p[j];\n      }\n    }\n    vector<ll> ans(52, 0);\n    for (ll i = 51; i >= 0; i--) {\n      Graph g(n);\n      REP(y, n) {\n        REP(x, n) {\n          if (poly[y][x][i] == 0) { continue; }\n          g[y].push_back(Edge(y, x, poly[y][x][i]));\n          g[x].push_back(Edge(x, y, 0));\n        }\n      }\n      Matrix flow;\n      ans[i] = MaxFlow(g, 0, n - 1, flow);\n      if (i != 0) {\n        REP(y, n) {\n          REP(x, n) {\n            if (poly[y][x][i] - flow[y][x] == 0) { continue; }\n            //if (poly[y][x][i] + flow[y][x] == 0) { continue; }\n            poly[y][x][i - 1] = INF;\n          }\n        }\n      }\n    }\n    PrintAns(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge { int to,cap,rev; };\n#define MAX 60\n#define INF (1e7)\nint n;\nvector<int> G[MAX][MAX];\nbool used[MAX];\n\nvector<int> min(vector<int> &a,vector<int> &b){\n  for(int i=MAX-1;i>=0;i--){\n    if( a[i]==b[i] )continue;\n    if(a[i]>b[i])return b;\n    if(a[i]<b[i])return a;\n  }\n  return a;\n}\n\nvector<int> add(vector<int> &a,vector<int> &b){\n  for(int i=0;i<MAX;i++)\n    a[i]+=b[i];\n  return a;\n}\n\nvector<int> sub(vector<int> &a,vector<int> b){\n  for(int i=0;i<MAX;i++)\n    a[i]-=b[i];\n  return a;\n}\n\nbool check(vector<int> &a){\n  for(int i=0;i<MAX;i++)\n    if(a[i]>0)return true;\n  return false;\n}\n\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=1;i<=n;i++){\n    vector<int> &e=G[v][i];\n    if(!used[i] && check(e) ){\n      vector<int> d=dfs( i,t,min(f,e));\n      if( d.size()==MAX && check(d) ){\n        G[v][i]=sub(G[v][i],d);\n        G[i][v]=add(G[i][v],d);\n        return d;\n      }\n    }\n  }\n  return vector<int>();\n}\n\nvector<int> max_flow(int s,int t){\n  vector<int> flow(MAX,0);\n  while(1){\n    memset(used,0,sizeof(used));\n    vector<int> tmp(MAX,INF);\n    vector<int> f=dfs(s,t,tmp);\n    if(f.size()==0)return flow;\n    flow=add(flow,f);\n  }\n  return flow;\n}\n\nint m;\nint t[MAX][MAX][MAX];\nint u[MAX][MAX];\n\nint s2i(string s){\n  stringstream ss;\n  int res;\n  ss<<s;\n  ss>>res;\n  return res;\n}\n\nvoid func(int a,int b,string &tmp){\n  int len=tmp.size();\n  int flg=0;\n  for(int i=0;i<len;i++){\n    if('0'<=tmp[i]&&tmp[i]<='9')continue;\n    flg=1;\n  }\n  if(flg==0){\n    t[a][b][0]=t[b][a][0]=s2i(tmp);\n    return;\n  }\n  \n  int v,w;\n  if(tmp[0]=='x')v=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='x'){\n        v=s2i(tmp.substr(0,i));\n        break;\n      }\n    }\n  }\n  \n  if(tmp[len-1]=='x')w=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='^'){\n        w=s2i(tmp.substr(i+1));\n        break;\n      }\n    }\n  }\n  t[a][b][w]=t[b][a][w]=v;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)break;\n    memset(t,0,sizeof(t));\n    memset(u,0,sizeof(u));\n    for(int i=0;i<m;i++){\n      int a,b;\n      string s,tmp;\n      cin>>a>>b>>s;\n      for(int j=0;j<(int)s.size();j++)\n        if(s[j]=='+')s[j]=' ';\n      stringstream ss(s);\n      while(ss>>tmp){\n        func(a,b,tmp);\n      }\n    }\n\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n        G[i][j].clear();\n        for(int k=0;k<MAX;k++){\n          G[i][j].push_back(t[i][j][k]);\n        }\n      }\n    }\n\n    vector<int> ans=max_flow(1,n);\n    bool cnt=0;\n    for(int i=MAX-1;i>=0;i--){\n      if(ans[i]==0)continue;\n      if(cnt>0)cout<<'+';\n      cnt++;\n      if(i==0||ans[i]>1)cout<<ans[i];\n      if(i)cout<<'x';\n      if(i>1)cout<<\"^\"<<i;\n    }\n    if(cnt==0)cout<<0;\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge { int to,cap,rev; };\n#define MAX 51\n#define INF (1e7)\nint n;\nvector<int> G[MAX][MAX];\nbool used[MAX];\n\nvector<int> min(vector<int> &a,vector<int> &b){\n  for(int i=MAX-1;i>=0;i--){\n    if( a[i]==b[i] )continue;\n    if(a[i]>b[i])return b;\n    if(a[i]<b[i])return a;\n  }\n  return a;\n}\n\nvoid add(vector<int> &a,vector<int> &b){\n  for(int i=0;i<MAX;i++)\n    a[i]+=b[i];\n}\n\nvoid sub(vector<int> &a,vector<int> b){\n  for(int i=0;i<MAX;i++)\n    a[i]-=b[i];\n}\n\nbool check(vector<int> &a){\n  for(int i=0;i<MAX;i++)\n    if(a[i]>0)return true;\n  return false;\n}\n\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=1;i<=n;i++){\n    vector<int> &e=G[v][i];\n    if(!used[i] && check(e) ){\n      vector<int> d=dfs( i,t,min(f,e));\n      if( d.size()==MAX && check(d) ){\n        sub(G[v][i],d);\n        add(G[i][v],d);\n        return d;\n      }\n    }\n  }\n  return vector<int>();\n}\n\nvector<int> max_flow(int s,int t){\n  vector<int> flow(MAX,0);\n  while(1){\n    memset(used,0,sizeof(used));\n    vector<int> tmp(MAX,INF);\n    vector<int> f=dfs(s,t,tmp);\n    if(f.size()==0)return flow;\n    add(flow,f);\n  }\n  return flow;\n}\n\nint m;\nint t[MAX][MAX][MAX];\nint u[MAX][MAX];\n\nint s2i(string s){\n  stringstream ss;\n  int res;\n  ss<<s;\n  ss>>res;\n  return res;\n}\n\nvoid func(int a,int b,string &tmp){\n  int len=tmp.size();\n  int flg=0;\n  for(int i=0;i<len;i++){\n    if('0'<=tmp[i]&&tmp[i]<='9')continue;\n    flg=1;\n  }\n  if(flg==0){\n    t[a][b][0]=t[b][a][0]=s2i(tmp);\n    return;\n  }\n  \n  int v,w;\n  if(tmp[0]=='x')v=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='x'){\n        v=s2i(tmp.substr(0,i));\n        break;\n      }\n    }\n  }\n  \n  if(tmp[len-1]=='x')w=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='^'){\n        w=s2i(tmp.substr(i+1));\n        break;\n      }\n    }\n  }\n  t[a][b][w]=t[b][a][w]=v;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)break;\n    memset(t,0,sizeof(t));\n    memset(u,0,sizeof(u));\n    for(int i=0;i<m;i++){\n      int a,b;\n      string s,tmp;\n      cin>>a>>b>>s;\n      for(int j=0;j<(int)s.size();j++)\n        if(s[j]=='+')s[j]=' ';\n      stringstream ss(s);\n      while(ss>>tmp){\n        func(a,b,tmp);\n      }\n    }\n\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n        G[i][j].clear();\n        G[i][j].resize(MAX);\n        for(int k=0;k<MAX;k++){\n          G[i][j][k]=t[i][j][k];\n        }\n      }\n    }\n\n    vector<int> ans=max_flow(1,n);\n    bool cnt=0;\n    for(int i=MAX-1;i>=0;i--){\n      if(ans[i]==0)continue;\n      if(cnt>0)cout<<'+';\n      cnt++;\n      if(i==0||ans[i]>1)cout<<ans[i];\n      if(i)cout<<'x';\n      if(i>1)cout<<\"^\"<<i;\n    }\n    if(cnt==0)cout<<0;\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(a[i]){\n\t\t\t\tif(i<n){\n\t\t\t\t\tret+=\"+\";\n\t\t\t\t}\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tret+=\"^\";\n\t\t\t\t\t\tret+=toString(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)+(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)-(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\n\nvoid add_edge(int from,int to,poly& cap,vve &g,poly Zero){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used,poly Zero){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used,Zero);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tconst poly Zero=to_poly(string(\"0\"));\n\tconst poly Inf=to_poly(string(\"x^51\"));\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g,Zero);\n\t\t\tadd_edge(v,u,pol,g,Zero);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used,Zero);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <sstream>\nusing namespace std;\nconstexpr int siz = 51;\ntypedef array<long long int, siz> poly;\npoly& operator +=(poly &a, const poly &b){\n    for(int i=0; i<siz; i++){\n        a[i] += b[i];\n    }\n    return a;\n}\npoly& operator -=(poly &a, const poly &b){\n    for(int i=0; i<siz; i++){\n        a[i] -= b[i];\n    }\n    return a;\n}\n\ntemplate <typename T>\nstruct MaxFlow{\n    struct edge{\n        int to, rev;\n        T cap;\n        edge(int t, int r, T c):to(t),rev(r),cap(c){\n            cap = c;\n        }\n        edge(){}\n    };\n    vector<vector<edge>> graph;\n    T zero;\n    T inf;\n    \n    MaxFlow(int n, T zero, T inf):zero(zero),inf(inf){\n        graph.resize(n);\n    }\n    void add_edge(int from, int to, T cap){\n        graph[from].emplace_back(to, graph[to].size(), cap);\n        graph[to].emplace_back(from, (int)graph[from].size()-1, zero);\n    }\n    void add_bidirectional_edge(int from, int to, T cap){\n        graph[from].emplace_back(to, graph[to].size(), cap);\n        graph[to].emplace_back(from, (int)graph[from].size()-1, cap);\n    }\n    T dfs(int v, int g, T flow, vector<bool>& used){\n        if(used[v]) return zero;\n        used[v] = true;\n        if(v == g) return flow;\n    \n        for(auto &e: graph[v]){\n            if(zero < e.cap){\n                T ret = dfs(e.to, g, min(flow, e.cap), used);\n                if(zero < ret){\n                    e.cap -= ret;\n                    graph[e.to][e.rev].cap += ret;\n                    return ret;\n                }\n            }\n        }\n        return zero;\n    }\n    T exec(int s, int g){\n        T res = zero;\n        while(1){\n            vector<bool> used(graph.size(), false);\n            T ret = dfs(s, g, inf, used);\n            if(ret == zero) break;\n            res += ret;\n        }\n        return res;\n    }\n};\n\npoly str2poly(string s){\n    for(char &c: s){\n        if(c == '+') c = ' ';\n    }\n    stringstream ss(s);\n    poly res{};\n    string t;\n    while(ss >> t){\n        int n = t.length();\n        int xpos = find(t.begin(), t.end(), 'x') -t.begin();\n        if(xpos == n){\n            res[siz-1] = stoi(t);\n            continue;\n        }\n        int coef = 1;\n        if(xpos != 0) coef = stoi(t.substr(0, xpos));\n        int deg = 1;\n        if(xpos != n-1) deg = stoi(t.substr(xpos+2, n-(xpos+2)));\n        res[siz-1-deg] = coef;\n    }\n    return res;\n}\nstring poly2str(const poly &p){\n    string res = \"\";\n    for(int i=0; i<siz; i++){\n        if(p[i] == 0) continue;\n        if(p[i]>0 and res!=\"\") res += \"+\";\n        if(i < siz-1){\n            if(p[i] == -1){\n                res += \"-\";\n            }else if(p[i] != 1){\n                res += to_string(p[i]);\n            }\n        }else{\n            res += to_string(p[i]);\n        }\n        if(i==siz-1) continue;\n        res += \"x\";\n        if(i==siz-2) continue;\n        res += \"^\" + to_string(siz-1-i);\n    }\n    if(res == \"\") res = \"0\";\n    return res;\n}\n\nint main(){\n    poly zero{}, inf;\n    for(int i=0; i<siz; i++){\n        inf[i] = 1e9;\n    }\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0) break;\n\n        MaxFlow<poly> mf(n, zero, inf);\n        for(int i=0; i<m; i++){\n            int u,v;\n            string s;\n            cin >> u >> v >> s;\n            u--; v--;\n            mf.add_bidirectional_edge(u, v, str2poly(s));\n        }\n        poly ret = mf.exec(0, n-1);\n        cout << poly2str(ret) << endl;\n    }    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring toStr(int n)\n{\n\tchar buf[50];\n\tsprintf(buf, \"%d\", n);\n\treturn buf;\n}\n\nstruct poly{\n\tint a[55];\n\tpoly(){\n\t\tfor(int i = 0; i <= 50; i++) a[i] = 0;\n\t}\n\tpoly(string s)\n\t{\n\t\tfor(int i = 0; i <= 50; i++) a[i] = 0;\n\t\t\n\t\ts = s + \"+\";\n\t\tstring buf;\n\t\tint state = 0, coe;\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tif(state == 0){\n\t\t\t\tif(s[i] == 'x'){\n\t\t\t\t\tif(buf == \"\") buf = \"1\";\n\t\t\t\t\tcoe = atoi(buf.c_str());\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\t\t\t\telse if(s[i] == '+'){\n\t\t\t\t\ta[0] = atoi(buf.c_str());\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbuf += s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(state == 1){\n\t\t\t\tif(s[i] == '^'){\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse if(s[i] == '+'){\n\t\t\t\t\ta[1] = coe;\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(state == 2){\n\t\t\t\tif(s[i] == '+'){\n\t\t\t\t\ta[atoi(buf.c_str())] = coe;\n\t\t\t\t\tbuf = \"\";\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbuf += s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstring output()\n\t{\n\t\tstring ret;\n\t\tfor(int i = 50; i > 0; i--){\n\t\t\tif(a[i] == 0) continue;\n\t\t\tif(a[i] != 1) ret += toStr(a[i]);\n\t\t\tret += \"x\";\n\t\t\tif(i > 1) ret += \"^\" + toStr(i);\n\t\t\tret += \"+\";\n\t\t}\n\t\tif(ret.size() > 0){\n\t\t\tif(a[0] == 0) ret.erase(ret.end()-1);\n\t\t\telse ret += toStr(a[0]);\n\t\t}\n\t\telse ret = toStr(a[0]);\n\t\treturn ret;\n\t}\n\tpoly operator+(const poly& obj)\n\t{\n\t\tpoly ret;\n\t\tfor(int i = 0; i <= 50; i++){\n\t\t\tret.a[i] = a[i] + obj.a[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpoly operator-(const poly& obj)\n\t{\n\t\tpoly ret;\n\t\tfor(int i = 0; i <= 50; i++){\n\t\t\tret.a[i] = a[i] - obj.a[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tbool operator<(const poly& obj)const\n\t{\n\t\tfor(int i = 50; i >= 0; i--){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator<=(const poly& obj)const\n\t{\n\t\tfor(int i = 50; i >= 0; i--){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\n\nstruct edge{\n\tint to, rev;\n\tpoly cap;\n\tedge(int a, string b, int c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nint N, M;\nvector<edge> G[205];\nint S, T;\nbool used[205];\n\npoly dfs(int v, poly f)\n{\n\tused[v] = true;\n\tif(v == T) return f;\n\t\n\tpoly ret;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap <= poly()) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(poly() < ret){\n\t\t\tG[v][i].cap = G[v][i].cap - ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap = G[G[v][i].to][G[v][i].rev].cap + ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn poly();\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= N; i++) G[i].clear();\n\t\t\n\t\tint u, v; string s;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> u >> v >> s;\n\t\t\tG[u].push_back(edge(v, s, G[v].size()));\n\t\t\tG[v].push_back(edge(u, \"\", G[u].size()-1));\n\t\t\tG[v].push_back(edge(u, s, G[u].size()));\n\t\t\tG[u].push_back(edge(v, \"\", G[v].size()-1));\n\t\t}\n\t\tS = 1, T = N;\n\t\t\n\t\tpoly ans, flow;\n\t\twhile(1){\n\t\t\tfor(int i = 1; i <= T; i++) used[i] = false;\n\t\t\tflow = dfs(S, poly(\"10000000x^50\"));\n\t\t\tif(flow <= poly()) break;\n\t\t\tans = ans + flow;\n\t\t}\n\t\t\n\t\tcout << ans.output() << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <stdexcept>\n#include <iostream>\n#include <functional>\n#include <queue>\n\nclass polynomial;\nstatic const std::vector<std::string> ops={\"+-\", \"*/%\", \"^\"};\n// operator % を定義していると多項式の GCD とかも簡単に書けるんですよね\n// べき乗の演算子はふつう右結合のはずなんですが，そういう入力はこないと\n// 思うので，左結合で書いてしまいます．\n\npolynomial parse(const std::string&, size_t&, size_t);\n\nstd::string normalize(const std::string& s) {\n  std::string res;\n  enum { NONE, PAREN, FACTOR, OPERATOR } last = NONE;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '(') {\n      if (last == FACTOR) res += '*';\n      res += '(';\n      last = PAREN;\n    } else if (s[i] == ')') {\n      res += ')';\n      last = FACTOR;\n    } else if (isalnum(s[i])) {\n      if (last == FACTOR) res += '*';\n      res += s[i];\n      if (isdigit(s[i])) {\n        while (isdigit(s[i+1]))\n          res += s[++i];\n      }\n      last = FACTOR;\n    } else if (!isspace(s[i])) {\n      res += s[i];\n      last = OPERATOR;\n    }\n  }\n  return res;\n}\n\nclass polynomial {\n  using deg_type = int;\n  using coef_type = intmax_t;\n  // e.g., polynomial(\"2x^2+1\") => cs: {\"xx\": 2, \"\": 1}\n  // 冷静に考えると，polynomial(\"x^100000\") でつらくなりますね\n  // {(\"x\", 2): 2, (\"\", 0): 1} みたいにするべき？\n  // そうした方がいい気がするのでそのうちします\n  // と思ったけど ab みたいなのをどう扱いますか？ やめます．\n  // やっぱりやめません．\n  // というか文字を決めうちでいいなら上の式も {2: 2, 0: 1} でいいですね\n  std::map<deg_type, coef_type> cs;\n\n  polynomial& normalized() {\n    for (auto it=cs.begin(); it!=cs.end();) {\n      if (it->second == 0) {\n        it = cs.erase(it);\n      } else {\n        ++it;\n      }\n    }\n    return *this;\n  }\n\npublic:\n  /* constructors */\n  polynomial(const std::string& s) {\n    std::string t = normalize(s);\n    size_t i = 0;\n    polynomial tmp = parse(t, i, 0);\n    cs = std::move(tmp.cs);\n  }\n\n  polynomial(deg_type d, coef_type c) {\n    cs[d] = c;\n  }\n\n  polynomial(coef_type c) {\n    cs[0] = c;\n  }\n\n  polynomial() {}\n\n  /* binary operations (@=) */\n  polynomial& operator +=(const polynomial& rhs) {\n    for (const auto& p: rhs.cs) cs[p.first] += p.second;\n\n    // Poly(\"+x\") + Poly(\"-x\") の結果 Poly(\"0\") になりますが，このとき\n    // cs は {\"\": 0} になるべきで {\"x\": 0} になるべきではありません\n    return normalized();\n  }\n\n  polynomial& operator -=(const polynomial& rhs) {\n    for (const auto& p: rhs.cs) cs[p.first] -= p.second;\n    return normalized();\n  }\n\n  polynomial& operator *=(const polynomial& rhs) {\n    // Note: this と *rhs が identical でもつらくならない必要がある\n    std::map<deg_type, coef_type> tmp;\n    for (const auto& p1: cs)\n      for (const auto& p2: rhs.cs) {\n        deg_type param = p1.first+p2.first;\n        tmp[param] += p1.second * p2.second;\n      }\n    cs = std::move(tmp);\n    return normalized();\n  }\n\n  // not implemented\n  polynomial& operator /=(const polynomial& rhs);  \n  polynomial& operator %=(const polynomial& rhs);  \n\n  polynomial& operator ^=(const polynomial& rhs) {\n    if (!(rhs.cs.size() == 1 && rhs.cs.begin()->first == 0))\n      throw std::logic_error(\"y should be constant in x^y\");\n\n    int iexp = rhs.cs.at(0);\n    if (iexp < 0)\n      throw std::logic_error(\"y should be non-negative in x^y\");\n\n    polynomial dbl(*this);\n    cs.clear();\n    cs[0] = 1;\n    for (; iexp; iexp>>=1) {\n      if (iexp & 1) (*this) *= dbl;\n      dbl *= dbl;\n    }\n    return normalized();\n  }\n\n  // wrapper\n  polynomial& op_eq(char op, const polynomial& rhs) {\n    switch (op) {\n    case '+': return (*this) += rhs;\n    case '-': return (*this) -= rhs;\n    case '*': return (*this) *= rhs;\n    // case '/': return (*this) /= rhs;\n    // case '%': return (*this) %= rhs;\n    case '^': return (*this) ^= rhs;\n    default: assert(false);\n    }\n  }\n\n  /* binary opeartions (@) */\n  polynomial operator +(const polynomial& other) const { return polynomial(*this) += other; }\n  polynomial operator -(const polynomial& other) const { return polynomial(*this) -= other; }\n  polynomial operator *(const polynomial& other) const { return polynomial(*this) *= other; }\n  // polynomial operator %(const polynomial& other) const { return polynomial(*this) %= other; }\n  // polynomial operator /(const polynomial& other) const { return polynomial(*this) /= other; }\n  polynomial operator ^(const polynomial& other) const { return polynomial(*this) ^= other; }\n\n  /* binary opeartions (relations) */\n  bool operator <(const polynomial& rhs) const {\n    polynomial tmp(*this);\n    tmp -= rhs;\n    // lhs-rhs < 0 <=> lhs < rhs\n    // で，最高次的なやつのの符号で決めます\n    if (tmp.cs.empty()) return false;\n    return std::prev(tmp.cs.end())->second < 0;\n  }\n\n  bool operator ==(const polynomial& rhs) const {\n    return cs == rhs.cs;\n  }\n\n  operator std::string() const {\n    std::string res;\n    for (auto it=cs.rbegin(); it!=cs.rend(); ++it) {\n      deg_type d = it->first;\n      coef_type c = it->second;\n      if (c == 0) continue;\n      if (c > 0) {\n        if (!res.empty()) res += '+';\n      } else {\n        res += '-';\n        c = -c;\n      }\n      if (c > 1 || d == 0) res += std::to_string(c);\n      if (d > 0) {\n        res += 'x';\n        if (d > 1) {\n          res += '^';\n          res += std::to_string(d);\n        }\n      }\n    }\n    if (res.empty()) res = \"0\";\n    return res;\n  }\n};\n\npolynomial parse(const std::string& s, size_t& i, size_t preced) {\n  if (preced == ops.size()) {\n    if (s[i] == '(') {\n      polynomial res = parse(s, ++i, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    if (isalpha(s[i])) {\n      assert(s[i] == 'x');\n      ++i;\n      return polynomial(1, 1);\n    }\n    if (isdigit(s[i])) {\n      intmax_t res = s[i]-'0';\n      while (++i < s.length() && isdigit(s[i]))\n        res = res*10+s[i]-'0';\n      return polynomial(0, res);\n    }\n    assert(false);\n  }\n\n  polynomial res = parse(s, i, preced+1);\n  while (i < s.length()) {\n    char op = s[i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    polynomial tmp = parse(s, ++i, preced+1);\n    res.op_eq(op, tmp);\n  }\n  return res;\n}\n\ntemplate <class Tp>\nTp inf() { return Tp(); }\ntemplate <>\npolynomial inf() { return polynomial(100, 1); }\n\ntemplate <class Tp>\nstruct Edge {\n  size_t src, dst;\n  Tp cap;\n  size_t rev;\n  Edge(size_t src, size_t dst, Tp cap, size_t rev):\n    src(src), dst(dst), cap(cap), rev(rev)\n  {}\n};\n\ntemplate <class Tp>\nstruct graph: public std::vector<std::vector<Edge<Tp>>> {\n  graph(size_t n): std::vector<std::vector<Edge<Tp>>>(n) {}\n\n  void connect_with(size_t src, size_t dst, Tp cap) {\n    (*this)[src].emplace_back(src, dst, cap, (*this)[dst].size());\n    (*this)[dst].emplace_back(dst, src, cap, (*this)[src].size()-1);\n  }\n};\n\ntemplate <class Tp>\nstd::vector<int> distance(graph<Tp>& g, size_t s) {\n  std::vector<int> cost(g.size(), -1);\n  std::queue<size_t> q;\n  cost[s] = 0;\n  q.emplace(s);\n  while (!q.empty()) {\n    size_t v = q.front();\n    q.pop();\n    for (const auto& e: g[v]) {\n      if (Tp(0) < e.cap && cost[e.dst] < 0) {\n        cost[e.dst] = cost[v] + 1;\n        q.push(e.dst);\n      }\n    }\n  }\n  return cost;\n}\n\ntemplate <class Tp>\nTp max_flow(graph<Tp>& g, size_t s, size_t t) {\n  Tp flow = Tp(0);\n  std::vector<size_t> iter;\n  std::vector<int> cost;\n\n  std::function<Tp (size_t, Tp)> augment=[&](size_t v, Tp f)->Tp {\n    if (v == t) return f;\n    for (size_t& i=iter[v]; i<g[v].size(); ++i) {\n      Edge<Tp>& e = g[v][i];\n      if (Tp(0) < e.cap && cost[v] < cost[e.dst]) {\n        Tp d = augment(e.dst, std::min(f, e.cap));\n        if (Tp(0) < d) {\n          e.cap -= d;\n          g[e.dst][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return Tp(0);\n  };\n\n  while (true) {\n    cost = distance(g, s);\n    if (cost[t] < 0) return flow;\n    iter.assign(g.size(), 0);\n    Tp f;\n    while (Tp(0) < (f = augment(s, inf<Tp>())))\n      flow += f;\n  }\n}\n\nint testcase_ends() {\n  size_t N, M;\n  scanf(\"%zu %zu\", &N, &M);\n\n  if (N == 0 && M == 0) return 1;\n\n  graph<polynomial> g(N);\n  for (size_t i=0; i<M; ++i) {\n    size_t src, dst;\n    scanf(\"%zu %zu\", &src, &dst);\n    --src;\n    --dst;\n\n    char buf[1024];\n    scanf(\"%s\", buf);\n    std::string s = buf;\n\n    polynomial p(s);\n    g.connect_with(src, dst, p);\n  }\n\n  printf(\"%s\\n\", std::string(max_flow(g, 0, N-1)).c_str());\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(i<n){\n\t\t\t\tret+=\"+\";\n\t\t\t}\n\t\t\tif(a[i]){\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=a[i]+'0';\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=a[i]+'0';\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)+(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)-(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nconst poly Zero=to_poly(string(\"0\"));\nconst poly Inf=to_poly(string(\"x^51\"));\n\nvoid add_edge(int from,int to,poly& cap,vve &g){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g);\n\t\t\tadd_edge(v,u,pol,g);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,rev;\n\tvector<int> cap;\n\tedge(){}\n\tedge(int tt,vector<int> cc,int rr){\n\t\tto=tt;\n\t\trev=rr;\n\t\tcap.resize(cc.size());\n\t\tfor(int i=0;i<cc.size();i++){\n\t\t\tcap[i]=cc[i];\n\t\t}\n\t}\n};\n\nclass dinic{\npublic:\n\tconst int INF=100000;\n\tvector<edge> G[501];\n\tint level[501];\n\tint iter[501];\n\tvoid add_edge(int from,int to,vector<int> cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,cap,G[from].size()-1));\n\t}\n\n\tbool checkemp(vector<int> &cap){\n\t\tint s=cap.size();\n\t\tfor(int i=s-1;i>=0;i--){\n\t\t\tif(cap[i]>0)return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvector<int> getmin(vector<int> a,vector<int> b){\n\t\tvector<int> c(a.size());\n\t\tbool flag=false;\n\t\tbool flag2=false;\n\t\tfor(int i=(int)c.size()-1;i>=0;i--){\n\t\t\tif(flag){\n\t\t\t\tc[i]=max(a[i],b[i]);\n\t\t\t}else if(flag2){\n\t\t\t\tc[i]=b[i];\n\t\t\t}else{\n\t\t\t\tc[i]=min(a[i],b[i]);\n\t\t\t}\n\t\t\tif(a[i]<b[i]){\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t\tif(a[i]>b[i]){\n\t\t\t\tflag2=true;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\n\tvoid bfs(int s){\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(!checkemp(e.cap) && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dfs(int v,int t,vector<int> f){\n\t\tif(v==t)return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(!checkemp(e.cap) && level[v]<level[e.to]){\n\t\t\t\tvector<int> d=dfs(e.to,t,getmin(f,e.cap));\n\t\t\t\tif(!checkemp(d)){\n\t\t\t\t\tfor(int j=0;j<e.cap.size();j++){\n\t\t\t\t\t\tint bx=min(e.cap[j],d[j]);\n\t\t\t\t\t\te.cap[j]-=bx;\n\t\t\t\t\t\tG[e.to][e.rev].cap[j]+=bx;\n\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> zer(f.size(),0);\n\t\treturn zer;\n\t}\n\tvector<int> max_flow(int s,int t,int size){\n\t\tvector<int> flow(size,0);\n\t\tvector<int> alINF(size,INF);\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\tvector<int> f;\n\t\t\twhile(!checkemp(f=dfs(s,t,alINF))){\n\t\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\t\tflow[i]+=f[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nstring get_string(int v){\n\tstring ret=\"\";\n\twhile(v>0){\n\t\tret+=('0'+v%10);\n\t\tv/=10;\n\t}\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\n\n\ndinic di;\n\nint n,m;\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdi.G[i].clear();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v;\n\t\t\tstring str;\n\t\t\tcin >> u >> v >> str;\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tint digit=0;\n\t\t\tvector<int> tp(51,0);\n\t\t\tfor(int j=0;j<str.size();j++){\n\t\t\t\tif(str[j]>='0' && str[j]<='9'){\n\t\t\t\t\tdigit*=10;\n\t\t\t\t\tdigit+=(str[j]-'0');\n\t\t\t\t}else if(str[j]=='x'){\n\t\t\t\t\tif(digit==0)digit=1;\n\t\t\t\t\tif(j+1<str.size() && str[j+1]=='^'){\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tint dg2=0;\n\t\t\t\t\t\twhile(!(str[j]>='0' && str[j]<='9')){\n\t\t\t\t\t\t\tdg2*=10;\n\t\t\t\t\t\t\tdg2+=(str[j]-'0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttp[dg2]=digit;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttp[1]=digit;\n\t\t\t\t\t}\n\t\t\t\t\tdigit=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(digit>0){\n\t\t\t\ttp[0]=digit;\n\t\t\t}\n\t\t\tdi.add_edge(u,v,tp);\n\t\t\t\n\t\t}\n\t\tvector<int> ans=di.max_flow(0,n-1,51);\n\t\tstring best=\"\";\n\t\tbool flag=false;\n\t\tfor(int i=50;i>=0;i--){\n\t\t\tif(ans[i]>0){\n\t\t\t\tif(flag)best+='+';\n\t\t\t\tbest+=get_string(ans[i]);\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(ans[i]==1){\n\t\t\t\t\t\tbest.erase(best.end()-1);\n\t\t\t\t\t}\n\t\t\t\t\tbest+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tbest+=\"^\";\n\t\t\t\t\t\tbest+=get_string(i);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tif(best.size()==0)best+='0';\n\t\tcout << best << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int L = 51;\n\nstruct Edge {\n  int to, cost, rev;\n  vector<int> cap;\n  Edge(int to, int cost, vector<int> cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  Edge() {}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdgeF(int from, int to, int cost, vector<int> cap, Graph &g) {\n  g[from].push_back(Edge(to, cost, cap, g[to].size()));\n  g[to].push_back(Edge(from, -cost, vector<int>(L), (int)g[from].size()-1));\n}\n\ninline vector<int>& add(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] += b[i];\n  return a;\n}\n\ninline vector<int>& subtract(vector<int> &a, const vector<int> &b) {\n  for(int i = 0; i < L; ++i) a[i] -= b[i];\n  return a;\n}\n\ninline bool lt(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return false;\n}\n\ninline bool le(const vector<int> &a, const vector<int> &b) {\n  for(int i = L-1; i >= 0; --i) if(a[i] != b[i]) return a[i] < b[i];\n  return true;\n}\n\nvoid show(const vector<int> &ans) {\n  if(*max_element(ans.begin(), ans.end()) == 0 &&\n     *min_element(ans.begin(), ans.end()) == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  for(int i = L-1, j = 0; i >= 0; --i) {\n    if(!ans[i]) continue;\n    if(j) {\n      if(ans[i] > 0) cout << \"+\";\n      else cout << \"-\";\n    } else if(ans[i] < 0) cout << \"-\";\n    if(abs(ans[i]) != 1) cout << abs(ans[i]);\n    if(i > 1) cout << \"x^\" << i;\n    else if(i == 1) cout << \"x\";\n    j++;\n  }\n  cout << endl;\n}\n\nvector<int> dfsF(int v, int t, vector<int> f, vector<int> &used, Graph &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    Edge &e = g[v][i];\n    if(!used[e.to]) {\n      vector<int> nf(L);\n      bool iszero = true;\n      for(int j = L-1, k = -1; j >= 0; --j) {\n\tif(k == -1) {\n\t  if(f[j] < e.cap[j]) k = 0;\n\t  else if(f[j] > e.cap[j]) k = 1;\n\t}\n\tif(k <= 0) nf[j] = f[j];\n\telse       nf[j] = e.cap[j];\n\tiszero = iszero && nf[j] == 0;\n      }\n      if(iszero) continue;\n      vector<int> d = dfsF(e.to, t, nf, used, g);\n      if(lt(vector<int>(L), d)) {\n\tsubtract(e.cap, d);\n\tadd(g[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>(L);\n}\n\nvector<int> maxFlow(int s, int t, Graph g) {\n  vector<int> flow(L);\n  while(1) {\n    vector<int> used(g.size());\n    vector<int> f = dfsF(s, t, vector<int>(L, INF), used, g);\n    if(le(f, vector<int>(L))) break;\n    add(flow, f);\n  }\n  return flow;\n}\n\nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    Graph g(N);\n    for(int i = 0; i < M; ++i) {\n      int u, v; cin >> u >> v; --u; --v;\n      string s; cin >> s;\n      vector<int> cap(L);\n      replace(s.begin(), s.end(), '+', ' ');\n      stringstream ss(s);\n      while(ss >> s) {\n\tint a = 1;\n\t{\n\t  int i = 0;\n\t  while(i < s.size() && isdigit(s[i])) ++i;\n\t  if(i) {\n\t    a = atoi(s.substr(0, i).c_str());\n\t    s = s.substr(i);\n\t  }\n\t}\n\tint k = 0;\n\t// \"\" or \"x\" or \"x^y\"\n\tif(s == \"x\") {\n\t  k = 1;\n\t} else if(s.size()) {\n\t  k = atoi(s.substr(2).c_str());\n\t}\n\tcap[k] = a;\n      }\n      addEdgeF(u, v, 0, cap, g);\n      addEdgeF(v, u, 0, cap, g);\n    }\n    show(maxFlow(0, N-1, g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Mobile Network\n//Level: 3\n//Category: グラフ,Graph,最大流\n//Note:\n\n/**\n * x^kの項に対する係数をL-k番目の要素としてもつようなvectorを考え、これを辞書順で最大にすればよい。\n * フローの型がベクトル値である以外は、普通の最大流で求められる。\n * ただし、residual flowがあるかどうかの判定は、0でない最高次の項の正負で判定する。\n *\n * オーダーは O(M^2 NL)。\n */\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <string>\n\nusing namespace std;\n\ntypedef vector<int> Poly;\nnamespace std {\n    Poly& operator +=(Poly &a, const Poly &b) {\n        for(int i = 0; i < a.size(); ++i) {\n            a[i] += b[i];\n        }\n        return a;\n    }\n    Poly& operator -=(Poly &a, const Poly &b) {\n        for(int i = 0; i < a.size(); ++i) {\n            a[i] -= b[i];\n        }\n        return a;\n    }\n    Poly operator -(const Poly &a, const Poly &b) {\n        Poly res = a;\n        res -= b;\n        return res;\n    }\n};\n\nbool is_residual(const Poly &a) {\n    for(int v : a) {\n        if(v != 0) return v > 0;\n    }\n    return false;\n}\n\nconst int L = 50;\n\ntemplate<class Flow>\nstruct Edge {\n    int from, to;\n    Flow capacity, flow;\n    Edge *back;\n    Edge() {}\n    Edge(int from, int to, Flow c, Edge *b) : from(from), to(to), capacity(c), flow(Poly(L+1, 0)), back(b) {}\n};\n\ntemplate<class Flow>\nvoid make_edge(vector<vector<Edge<Flow>*>> &g, int src, int dst, Flow c) {\n    auto *e = new Edge<Flow>(src, dst, c, nullptr);\n    auto *back = e->back = new Edge<Flow>(dst, src, Poly(L+1, 0), e);\n    g[src].push_back(e);\n    g[dst].push_back(back);\n}\n\ntemplate <class T>\nT dinic_augment(vector<vector<Edge<T>*>> &graph, vector<int> &level, vector<bool> &finished, int u, int sink, T cur)/*{{{*/\n{\n    if (u == sink || !is_residual(cur)) {\n        return cur;\n    }\n    if (finished[u]) {\n        return Poly(L+1, 0);\n    }\n    finished[u] = true;\n    for(auto e : graph[u]) {\n        if(e->capacity > e->flow && level[e->to] > level[u]) {\n            const T f = dinic_augment(graph, level, finished, e->to, sink, min(cur, e->capacity - e->flow));\n            if (is_residual(f)) {\n                e->flow += f;\n                e->back->flow -= f;\n                finished[u] = false;\n                return f;\n            }\n        }\n    }\n    return Poly(L+1, 0);\n}/*}}}*/\n\n// O(V^2 E)\ntemplate <typename T>\nT dinic(vector<vector<Edge<T>*>> &graph, int source, int sink)/*{{{*/\n{\n    const int N = graph.size();\n    T max_flow(L+1, 0);\n\n    vector<int> level(N);\n    vector<bool> finished(N);\n    while (true) {\n        fill(level.begin(), level.end(), -1);\n        level[source] = 0;\n        queue<int> q;\n        q.push(source);\n\n        int d = N;\n        while (!q.empty() && level[q.front()] < d) {\n            const int u = q.front();\n            q.pop();\n\n            if (u == sink) {\n                d = level[u];\n            }\n            for(auto e : graph[u]) {\n                if (level[e->to] < 0 && e->capacity > e->flow) {\n                    q.push(e->to);\n                    level[e->to] = level[u] + 1;\n                }\n            }\n        }\n\n        fill(finished.begin(), finished.end(), false);\n        bool updated = false;\n        while (true) {\n            const T f = dinic_augment<T>(graph, level, finished, source, sink, Poly(L+1, 100*500*100));\n            if (!is_residual(f)) {\n                break;\n            }\n            max_flow += f;\n            updated = true;\n        }\n\n        if (!updated) {\n            break;\n        }\n    }\n\n    return max_flow;\n}/*}}}*/\n\ntypedef string::const_iterator Iterator;\nint number(Iterator &it) {\n    int res = 0;\n    while(isdigit(*it)) {\n        res *= 10;\n        res += *it - '0';\n        ++it;\n    }\n    return res;\n}\n\npair<int,int> term(Iterator &it) {\n    pair<int,int> res(1, 0);\n    if(isdigit(*it)) res.first = number(it);\n    if(*it == 'x') {\n        res.second = 1;\n        ++it;\n        if(*it == '^') {\n            ++it;\n            res.second = number(it);\n        }\n    }\n    return res;\n}\n\nPoly parse(const string &s) {\n    Iterator it = s.begin();\n    Poly res(L+1, 0);\n    do {\n        const auto t = term(it);\n        res[L-t.second] = t.first;\n    } while(*it++ == '+');\n    return res;\n}\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if(!N && !M) return false;\n\n    vector<vector<Edge<Poly>*>> g(N);\n    for(int i = 0; i < M; ++i) {\n        int a, b;\n        string expr;\n        cin >> a >> b >> expr;\n        --a; --b;\n        make_edge(g, a, b, parse(expr));\n        make_edge(g, b, a, parse(expr));\n    }\n    const auto ans = dinic(g, 0, N-1);\n    bool first = true;\n    for(int i = 0; i <= L; ++i) {\n        if(ans[i] != 0) {\n            if(!first) cout << \"+\";\n            if(ans[i] > 1 || i == L) cout << ans[i];\n            const int ord = L - i;\n            if(ord >= 1) {\n                cout << \"x\";\n                if(ord >= 2) {\n                    cout << \"^\" << ord;\n                }\n            }\n            first = false;\n        }\n    }\n    if(first) cout << 0;\n    cout << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <stack>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <deque>\n\n#define LL long long\n#define DB double\n#define SI(a) scanf(\"%d\",&a)\n#define SD(a) scanf(\"%lf\",&a)\n#define SS(a) scanf(\"%s\",a)\n#define PF printf\n#define MM(a,b) memset(a,b,sizeof(a))\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define REPD(i,a,b) for(int i=a;i>b;i--)\n#define INF 0x3f3f3f3f\n#define EPS 1e-8\n#define bug puts(\"bug\")\nusing namespace std;\nconst int N = 55;\nint re[N][N][55];\nint res[N][N];\nint n,m;\nvoid ini()\n{\n    MM(re,0);\n    MM(res,0);\n}\nvoid oper_i(char a[],int &e,int &f)\n{\n    int flag = 0,flag1 = 0;\n    int len = strlen(a);\n    REP(i,0,len)\n    {\n        if(a[i]=='x')\n            flag = 1;\n        if(a[i]=='^')\n            flag1 = 1;\n    }\n    if(flag == 0)\n    {\n        e = 0;\n        sscanf(a,\"%d\",&f);\n        return;\n    }\n    if(flag1 == 1)\n    {\n        if(a[0]=='x')\n        {\n            f = 1;\n            sscanf(a,\"x^%d\",&e);\n            return;\n        }\n        sscanf(a,\"%dx^%d\",&f,&e);\n        return;\n    }else\n    {\n        if(a[0]=='x')\n        {\n            f = 1;e = 1;\n            return;\n        }\n        sscanf(a,\"%dx\",&f);\n        e = 1;\n        return;\n    }\n}\nvoid oper(char ch[],int c[])//\n{\n    REP(i,0,51) c[i] = 0;\n    char tmp[50];\n    int j=0,len = strlen(ch);\n    int e,f;\n    REP(i,0,len+1)\n    {\n        if(ch[i]=='+'||ch[i]=='\\0'||ch[i]=='\\n')\n        {\n            tmp[j] = '\\0';\n            oper_i(tmp,e,f);\n            //cout<<f<<\"^\"<<e<<endl;\n            c[e] += f;\n            j = 0;\n        }else\n        {\n            tmp[j] = ch[i];\n            j++;\n        }\n    }\n}\n\nint g[N][N],gap[N],dist[N],pre[N],cur[N];\n///s1->t1 size{1...n}\nint sap(int s1,int t1,int n)\n{\n    int ret = 0,aug = INF,u,v;\n    memset(gap,0,sizeof(gap));\n    memset(dist,0,sizeof(dist));\n    for(int i=0;i<=n;i++) cur[i] = 1;\n    u = pre[s1] = s1;\n    gap[0] = n;\n    while(dist[s1]<=n){\n    loop:\n        for(v = cur[u];v<=n;v++)\n        if(g[u][v]>0&&dist[u] ==dist[v]+1)\n        {\n            cur[u] = v;aug = min(aug,g[u][v]);\n            pre[v] = u;\n            u = v;\n            if(u==t1){\n                ret+=aug;\n                for(u=pre[u];v!=s1;v=u,u=pre[u])\n                g[u][v]-=aug,g[v][u]+=aug;\n                aug = INF;\n            }\n            goto loop;\n        }\n        int mind =n;\n        for(v=1;v<=n;v++)\n        \tif(g[u][v]>0&&mind>dist[v])\n        \tmind = dist[v],cur[u] = v;\n        if(--gap[dist[u]]<=0) break;\n        gap[dist[u]=mind+1]++;\n        u=pre[u];\n    }return ret;\n}\nvoid solve()\n{\n    int ans[109];\n    MM(ans,0);\n    REPD(t,50,-1)\n    {\n        REP(i,1,n+1)\n        REP(j,1,n+1)\n        {\n            if(res[i][j])\n                g[i][j] = INF;\n            else\n                g[i][j] = re[i][j][t];\n        }\n        ans[t] = sap(1,n,n);\n        //if(ans[t]>0)\n        //cout<<t<<\" \"<<ans[t]<<endl;\n        REP(i,1,n+1)\n        REP(j,1,n+1)\n        if(res[i][j]==0&&re[i][j][t])\n        {\n            if(g[i][j]>0)\n            {\n                res[i][j] = 1;\n                //cout<<i<<\"---\"<<j<<endl;\n            }\n            else\n            {\n                REP(k,1,n+1)\n                REP(l,1,n+1)\n                {\n                    if(res[k][l])\n                        g[k][l] = INF;\n                    else\n                        g[k][l] = re[k][l][t];\n                }\n                g[i][j] -= 1;\n                if(ans[t]==sap(1,n,n))\n                {\n                    res[i][j] = 1;\n                    //cout<<i<<\"---\"<<j<<endl;\n                }\n            }\n        }\n    }\n\n    int flag = 0;\n    REPD(i,50,-1)\n    {\n        if(ans[i])\n        {\n            if(flag) printf(\"+\");\n            flag = 1;\n            if(i>1)\n            {\n                if(ans[i]==1)\n                    printf(\"x^%d\",i);\n                else\n                    printf(\"%dx^%d\",ans[i],i);\n            }else if(i==1)\n            {\n                if(ans[i]==1)\n                    printf(\"x\");\n                else\n                    printf(\"%dx\",ans[i]);\n            }else\n            {\n                printf(\"%d\",ans[i]);\n            }\n        }\n    }\n    if(flag==0) printf(\"0\");\n    printf(\"\\n\");\n}\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\",\"r\",stdin);\n    #endif\n    int tmp[100];\n    while(1)\n    {\n        SI(n),SI(m);\n        if(n==0&&m==0) break;\n        ini();\n\n        int a,b;\n        char ch[1024];\n        REP(i,0,m)\n        {\n            SI(a),SI(b);\n            SS(ch);\n            oper(ch,tmp);\n            REP(j,0,51)\n            if(tmp[j])\n            {\n                re[a][b][j]+=tmp[j];\n                re[b][a][j]+=tmp[j];\n            }\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(a[i]){\n\t\t\t\tif(i<n){\n\t\t\t\t\tret+=\"+\";\n\t\t\t\t}\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tret+=\"^\";\n\t\t\t\t\t\tret+=toString(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)+(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)-(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nconst poly Zero=to_poly(string(\"0\"));\nconst poly Inf=to_poly(string(\"x^51\"));\n\nvoid add_edge(int from,int to,poly& cap,vve &g){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g);\n\t\t\tadd_edge(v,u,pol,g);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge { int to,cap,rev; };\n#define MAX 52\n#define INF (1e7)\nint n;\nvector<int> G[MAX][MAX];\nbool used[MAX];\nvector<int> g[MAX];\nvector<int> min(vector<int> &a,vector<int> &b){\n  for(int i=MAX-1;i>=0;i--){\n    if( a[i]==b[i] )continue;\n    if(a[i]>b[i])return b;\n    if(a[i]<b[i])return a;\n  }\n  return a;\n}\n \nvoid add(vector<int> &a,vector<int> &b){\n  for(int i=0;i<MAX;i++)\n    a[i]+=b[i];\n}\n \nvoid sub(vector<int> &a,vector<int> b){\n  for(int i=0;i<MAX;i++)\n    a[i]-=b[i];\n}\n \nbool check(vector<int> &a){\n  for(int i=0;i<MAX;i++)\n    if(a[i]>0)return true;\n  return false;\n}\n \nvector<int> dfs(int v,int t,vector<int> f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int to=0;to<g[v].size();to++){\n    int i=g[v][to];\n    vector<int> &e=G[v][i];\n    if(!used[i] && check(e) ){\n      vector<int> d=dfs( i,t,min(f,e));\n      if( d.size()==MAX && check(d) ){\n        sub(G[v][i],d);\n        add(G[i][v],d);\n        return d;\n      }\n    }\n  }\n  return vector<int>();\n}\n \nvector<int> max_flow(int s,int t){\n  vector<int> flow(MAX,0);\n  while(1){\n    memset(used,0,sizeof(used));\n    vector<int> tmp(MAX,INF);\n    vector<int> f=dfs(s,t,tmp);\n    if(f.size()==0)return flow;\n    add(flow,f);\n  }\n  return flow;\n}\n \nint m;\nint t[MAX][MAX][MAX];\nint u[MAX][MAX];\n \nint s2i(string s){\n  stringstream ss;\n  int res;\n  ss<<s;\n  ss>>res;\n  return res;\n}\n \nvoid func(int a,int b,string &tmp){\n  int len=tmp.size();\n  int flg=0;\n  for(int i=0;i<len;i++){\n    if('0'<=tmp[i]&&tmp[i]<='9')continue;\n    flg=1;\n  }\n  if(flg==0){\n    t[a][b][0]=t[b][a][0]=s2i(tmp);\n    return;\n  }\n   \n  int v,w;\n  if(tmp[0]=='x')v=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='x'){\n        v=s2i(tmp.substr(0,i));\n        break;\n      }\n    }\n  }\n   \n  if(tmp[len-1]=='x')w=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='^'){\n        w=s2i(tmp.substr(i+1));\n        break;\n      }\n    }\n  }\n  t[a][b][w]=t[b][a][w]=v;\n}\n \nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)break;\n    memset(t,0,sizeof(t));\n    memset(u,0,sizeof(u));\n    for(int i=0;i<MAX;i++)g[i].clear();\n    \n    for(int i=0;i<m;i++){\n      int a,b;\n      string s,tmp;\n      cin>>a>>b>>s;\n      g[a].push_back(b);\n      g[b].push_back(a);\n      for(int j=0;j<(int)s.size();j++)\n        if(s[j]=='+')s[j]=' ';\n      stringstream ss(s);\n      while(ss>>tmp){\n        func(a,b,tmp);\n      }\n    }\n \n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n        G[i][j].clear();\n        G[i][j].resize(MAX);\n        for(int k=0;k<MAX;k++){\n          G[i][j][k]=t[i][j][k];\n        }\n      }\n    }\n \n    vector<int> ans=max_flow(1,n);\n    bool cnt=0;\n    for(int i=MAX-1;i>=0;i--){\n      if(ans[i]==0)continue;\n      if(cnt>0)cout<<'+';\n      cnt++;\n      if(i==0||ans[i]>1)cout<<ans[i];\n      if(i)cout<<'x';\n      if(i>1)cout<<\"^\"<<i;\n    }\n    if(cnt==0)cout<<0;\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<map>\n#include<utility>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[52];\nbool used[52];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back({to,cap,(int)G[to].size()});\n  G[to].push_back({from,cap,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,1e9);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  for(int N,M;cin>>N>>M,N|M;){\n    bool nz=false;\n    map<pair<int,int>,vector<int> >pols;\n    for(int i=0;i<M;i++){\n      int u,v;\n      char p[1234];\n      cin>>u>>v>>p;\n      vector<int> c(51);\n      for(char *pp=p;*pp;){\n\tint cc=1;\n\tif(*pp!='x'){\n\t  cc=strtol(pp,&pp,10);\n\t}\n\tint f=0;\n\tif(*pp){\n\t  pp++;\n\t  f=1;\n\t  if(*pp=='^'){\n\t    f=strtol(pp+1,&pp,10);\n\t  }\n\t}\n\tc[f]=cc;\n      }\n      pols[make_pair(u,v)]=c;\n    }\n    for(int i=51;i>=0;i--){\n      for(auto &e:G){\n\te.clear();\n      }\n      for(auto e:pols){\n\tadd_edge(e.first.first,e.first.second,e.second[i]);\n      }\n      int f=max_flow(1,N);\n      if(f){\n\tif(nz){\n\t  cout<<'+';\n\t}\n\tnz=true;\n\tif(f>1||i==0){\n\t  cout<<f;\n\t}\n\tif(i){\n\t  cout<<'x';\n\t  if(i>1){\n\t    cout<<'^'<<i;\n\t  }\n\t}\n      }\n      for(int j=1;j<=N;j++){\n\tfor(auto e:G[j]){\n\t  auto k=make_pair(j,e.to);\n\t  if(pols.count(k)&&e.cap!=0&&e.cap!=pols[k][i]*2){\n\t    for(int l=i;l>=0;l--){\n\t      pols[k][l]=1e9;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(!nz){\n      cout<<0;\n    }\n    cout<<endl;\n  }\n}\n\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to; vector<int> cap; int rev; };\n\nconst int MAX_V = 50;\nconst int INF = 1 << 28;\nconst int L = 52;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvector<int> vec_zero(L, 0);\n\nvoid add_edge(int from, int to, vector<int> cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, vec_zero, G[from].size() - 1});\n}\n\nvector<int> dfs(int v, int t, vector<int> f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > vec_zero){\n      vector<int> d = dfs(e.to, t, min(f, e.cap));\n      if(d > vec_zero){\n\t\t\t\tbool zero = false;\n        //e.cap -= d;\n        for(int j=0;j<L;j++){\n\t\t\t\t\tif(e.cap[j] - d[j] <= 0){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(zero) e.cap[j] = 0;\n\t\t\t\t\telse{\n\t\t\t\t\t\te.cap[j] -= d[j];\n\t\t\t\t\t}\n\n        }\n        //G[e.to][e.rev].cap += d;\n        for(int j=0;j<L;j++){\n          G[e.to][e.rev].cap[j] += d[j];\n        }\n        return d;\n      }\n    }\n  }\n  return vec_zero;\n}\n\nvector<int> max_flow(int s, int t){\n  vector<int> vec_INF = vec_zero;\n  vec_INF[0] = 1;\n  vector<int> flow = vec_zero;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    vector<int> f = dfs(s, t, vec_INF);\n/*\n\t\tfor(int j=0;j<L;j++){\n\t\t\tcout << f[j] << ' ';\n\t\t}\n\t\tcout << endl;\n*/\n    if(f == vec_zero) return flow;\n/*\n\t\tcout << \"*\"\n\t\tfor(int j=0;j<L;j++){\n\t\t\tcout << f[j] << ' ';\n\t\t}\n\t\tcout << endl;\n*/\n    //flow += f;\n    for(int j=0;j<L;j++){\n      flow[j] += f[j];\n    }\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n    G[i].clear();\n  }\n}\n\nP calc2(string s){\n  int x = -1;\n  for(int i=0;i<s.size();i++){\n    if(s[i] == 'x'){\n      x = i;\n    }\n  }\n  if(x == -1){\n    return make_pair(0, atoi(s.c_str()));\n  }\n  P res;\n\tstring tmp = s.substr(0, x);\n\tif(tmp.size() == 0){\n\t\tres.second = 1;\n\t}else{\n\t\tres.second = atoi(tmp.c_str());\n\t}\n  int h = -1;\n  for(int i=0;i<s.size();i++){\n    if(s[i] == '^'){\n      res.first = atoi(s.substr(i+1).c_str());\n    }\n  }\n\tif(h == -1){\n\t\tres.first = 1;\n\t}\n  return res;\n}\n\nvector<int> calc(string s){\n  vector<int> res(L, 0);\n  int pre = 0;\n  for(int i=0;;i++){\n    if(i == s.size()){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      break;\n    }\n    if(s[i] == '+'){\n      P tmp = calc2(s.substr(pre, pre + (i - pre)));\n      res[tmp.first] += tmp.second;\n      pre = i + 1;\n    }\n  }\n  return res;\n}\n\nint V, E;\n\nmain(){\n  while(cin >> V >> E && (V|E)){\n    for(int i=0;i<E;i++){\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      //cout << i << endl;\n      vector<int> tmp = calc(s);\n\t\t\t//for(int i=0;i<10;i++) cout << tmp[i] << ' '; cout << endl;\n\t\t\treverse(tmp.begin(), tmp.end());\n      add_edge(a, b, tmp);\n      add_edge(b, a, tmp);\n    }\n    vector<int> ans = max_flow(0, V-1);\n\t\treverse(ans.begin(), ans.end());\n/*\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tcout << ans[i] << ' ';\n\t\t}\n\t\tcout << endl;\n*/\n    bool first = true;\n    for(int i=L-1;i>=0;i--){\n      if(ans[i] == 0) continue;\n      if(first) first = false;\n      else{\n        cout << \"+\";\n      }\n      if(i == 0){\n        cout << ans[i];\n      }else{\n\t\t\t\tif(ans[i] != 1) cout << ans[i];\n\t\t\t\tif(i == 1){\n\t\t\t\t\tcout << \"x\";\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"x^\" << i;\n\t\t\t\t}\n      }\n    }\n    if(first){\n      cout << 0 << endl;\n    }else{\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e4\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> r=vector<int>(V,0);\n    r[0]=INF;\n    vector<int> f = dfs(s, t, r);\n    if(isall0(f)) return flow;\n    /*if(isallnotINF(f)) */Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      //assert(s[p+1]=='^'&&('0'<=s[p+2]&&s[p+2]<='9'));\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef vi Poly;\n\nconst Poly ZERO(51, 0);\nconst Poly INF(51, 111);\n\nPoly operator-(const Poly a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] - b[i];\n\treturn res;\n}\n\nPoly operator+(const Poly a, const Poly b)\n{\n\tPoly res(51);\n\tREP(i, 51) res[i] = a[i] + b[i];\n\treturn res;\n}\n\n\ntypedef int Weight;\ntypedef Poly Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, ZERO, 0 });\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > ZERO)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > ZERO)\n\t\t\t{\n\t\t\t\te.cap = e.cap - d;\n\t\t\t\tg[e.dest][e.rev].cap = g[e.dest][e.rev].cap + d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ZERO;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = ZERO;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == ZERO) return flow;\n\t\tflow = f + flow;\n\t}\n}\n\nint num(const string& s, int& p)\n{\n\tassert(isdigit(s[p]));\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nPoly parse(const string& s)\n{\n\tPoly res(51);\n\tint n = s.size();\n\tint p = 0;\n\twhile (p < n)\n\t{\n\t\tint c = 1;\n\t\tif (isdigit(s[p]))\n\t\t{\n\t\t\tc = num(s, p);\n\t\t}\n\t\tif (s[p] == 'x')\n\t\t{\n\t\t\tp++;\n\t\t\tif (s[p] == '^')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tint m = num(s, p);\n\t\t\t\tres[50 - m] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres[49] = c;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(p == n);\n\t\t\tres[50] = c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tstring s; cin >> s;\n\t\t\tPoly t = parse(s);\n\t\t\tadd_edge(g, a, b, t);\n\t\t\tadd_edge(g, b, a, t);\n\t\t}\n\t\tPoly ans = ford_fulkerson(g, 0, n - 1);\n\t\tstring anss;\n\t\tREP(i, ans.size())\n\t\t{\n\t\t\tif (ans[i] > 0)\n\t\t\t{\n\t\t\t\tif (i < 49)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1) \n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x^\" + to_string(50-i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x^\" + to_string(50-i) + \"+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 49)\n\t\t\t\t{\n\t\t\t\t\tif (ans[i] > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += to_string(ans[i]) + \"x+\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanss += \"x+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 50)\n\t\t\t\t{\n\t\t\t\t\tanss += to_string(ans[i]) + \"+\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anss.size() > 0)\n\t\t{\n\t\t\tanss.pop_back();\n\t\t\tcout << anss << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge { int to,cap,rev; };\n#define MAX 60\n#define INF (1e7)\nint n;\nvector<int> G[MAX][MAX];\nbool used[MAX];\n\nvector<int> min(vector<int> a,vector<int> b){\n  for(int i=MAX-1;i>=0;i--){\n    if( a[i]==b[i] )continue;\n    if(a[i]>b[i])return b;\n    if(a[i]<b[i])return a;\n  }\n  return a;\n}\n\nvector<int> add(vector<int> a,vector<int> b){\n  for(int i=0;i<MAX;i++)\n    a[i]+=b[i];\n  return a;\n}\n\nvector<int> sub(vector<int> a,vector<int> b){\n  for(int i=0;i<MAX;i++)\n    a[i]-=b[i];\n  return a;\n}\n\nbool check(vector<int> a){\n  for(int i=0;i<MAX;i++)\n    if(a[i]>0)return true;\n  return false;\n}\n\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=1;i<=n;i++){\n    vector<int> &e=G[v][i];\n    if(!used[i] && check(e) ){\n      vector<int> d=dfs( i,t,min(f,e));\n      if(d.size()>0){\n        G[v][i]=sub(G[v][i],d);\n        G[i][v]=add(G[i][v],d);\n        return d;\n      }\n    }\n  }\n  return vector<int>();\n}\n\nvector<int> max_flow(int s,int t){\n  vector<int> flow(MAX,0);\n  while(1){\n    memset(used,0,sizeof(used));\n    vector<int> tmp(MAX,INF);\n    vector<int> f=dfs(s,t,tmp);\n    if(f.size()==0)return flow;\n    flow=add(flow,f);\n  }\n  return flow;\n}\n\nint m;\nint t[MAX][MAX][MAX];\nint u[MAX][MAX];\n\nint s2i(string s){\n  stringstream ss;\n  int res;\n  ss<<s;\n  ss>>res;\n  return res;\n}\n\nvoid func(int a,int b,string &tmp){\n  int len=tmp.size();\n  int flg=0;\n  for(int i=0;i<len;i++){\n    if('0'<=tmp[i]&&tmp[i]<='9')continue;\n    flg=1;\n  }\n  if(flg==0){\n    t[a][b][0]=t[b][a][0]=s2i(tmp);\n    return;\n  }\n  \n  int v,w;\n  if(tmp[0]=='x')v=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='x'){\n        v=s2i(tmp.substr(0,i));\n        break;\n      }\n    }\n  }\n  \n  if(tmp[len-1]=='x')w=1;\n  else{\n    for(int i=0;i<len;i++){\n      if(tmp[i]=='^'){\n        w=s2i(tmp.substr(i+1));\n        break;\n      }\n    }\n  }\n  t[a][b][w]=t[b][a][w]=v;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)break;\n    memset(t,0,sizeof(t));\n    memset(u,0,sizeof(u));\n    for(int i=0;i<m;i++){\n      int a,b;\n      string s,tmp;\n      cin>>a>>b>>s;\n      for(int j=0;j<(int)s.size();j++)\n        if(s[j]=='+')s[j]=' ';\n      stringstream ss(s);\n      while(ss>>tmp){\n        func(a,b,tmp);\n      }\n    }\n\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n        G[i][j].clear();\n        for(int k=0;k<MAX;k++){\n          G[i][j].push_back(t[i][j][k]);\n        }\n      }\n    }\n\n    vector<int> ans=max_flow(1,n);\n    bool cnt=0;\n    for(int i=MAX-1;i>=0;i--){\n      if(ans[i]==0)continue;\n      if(cnt>0)cout<<'+';\n      cnt++;\n      if(i==0||ans[i]>1)cout<<ans[i];\n      if(i)cout<<'x';\n      if(i>1)cout<<\"^\"<<i;\n    }\n    if(cnt==0)cout<<0;\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing vi = vector<int>;\n\n// (?????????,??????,??????)\nstruct edge{\n    int to;\n    vi cap;\n    int rev;\n};\n\nconst int MAX_V = 50; // TODO:initialize\nconst vi F_INF = vi(51,19191919); // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\nvoid show(vi f)\n{\n    string ans = \"\";\n    for(int i=50; i>0; --i)if(f[i]!=0)\n    {\n        if(f[i]>0) ans += \"+\";\n        else ans += \"-\";\n\n        if(abs(f[i])>1) ans += to_string(abs(f[i]));\n\n        if(i>0)\n        {\n            ans += \"x\";\n            if(i>1) ans += \"^\" + to_string(i);\n        }\n    }\n\n    if(f[0]!=0)\n    {\n        if(f[0]>0) ans += \"+\";\n        else ans += \"-\";\n        ans += to_string(abs(f[0]));\n    }\n\n    if(ans==\"\") ans = \"0\";\n    if(ans[0]=='+') ans = ans.substr(1);\n    cout << ans << endl;\n}\n\nvoid add_edge(int from, int to, vi cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,cap,(int)G[from].size()-1});\n}\n\ninline bool positive(vi v)\n{\n    for(int i=50; i>=0; --i)if(v[i]!=0) return v[i]>0;\n    return false;\n}\n\ninline vi ADD(vi a, vi b)\n{\n    vi ret(51);\n    rep(i,51) ret[i]=a[i]+b[i];\n    return ret;\n}\n\ninline vi SUB(vi a, vi b)\n{\n    vi ret(51);\n    rep(i,51) ret[i]=a[i]-b[i];\n    return ret;\n}\n\ninline vi vi_min(vi a, vi b)\n{\n    for(int i=50; i>=0; --i)\n    {\n        int d = a[i]-b[i];\n        if(d>0) return b;\n        else if(d<0) return a;\n    }\n    return a;\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(positive(e.cap) && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// ?¢?????????????dfs??§??¢???\nvi dinic_dfs(int v, int t, vi f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(positive(e.cap) && level[v]<level[e.to]){\n            vi d = dinic_dfs(e.to,t,vi_min(f,e.cap));\n            if(positive(d)){\n                e.cap = SUB(e.cap,d);\n                G[e.to][e.rev].cap = ADD(G[e.to][e.rev].cap,d);\n                return d;\n            }\n        }\n    }\n    return vector<int>(51,0);\n}\n\n// s??????t???????????§???\nvi max_flow(int s, int t){\n    vi flow(51);\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        vi f;\n        while( positive(f=dinic_dfs(s,t,F_INF)) ) flow = ADD(flow,f);\n    }\n}\n\nvector<string> split(const string &s, char d)\n{\n    vector<string> ret;\n    stringstream ss(s);\n    string item;\n    while(getline(ss,item,d))\n    {\n        if(!item.empty()) ret.pb(item);\n    }\n    return ret;\n}\n\nvi convert(string s)\n{\n    vi ret(51);\n    for(const auto &t:split(s,'+'))\n    {\n        int idx = t.find(\"x\");\n        if(idx==-1) ret[0]=atoi(t.c_str());\n        else\n        {\n            int n = 1;\n            if(idx+2<t.size())\n            {\n                string i=t.substr(idx+2);\n                n = atoi(i.c_str());\n            }\n\n            string a=t.substr(0,idx);\n            int val = 1;\n            if(a.size()) val = atoi(a.c_str());\n\n            ret[n] = val;\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    int n,m;\n    while(cin >>n >>m,n)\n    {\n        rep(i,MAX_V) G[i].clear();\n        rep(i,m)\n        {\n            int u,v;\n            string s;\n            cin >>u >>v >>s;\n            add_edge(u-1,v-1,convert(s));\n        }\n        show(max_flow(0,n-1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nvector<int> Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n  return res;\n}\n\nvector<int> Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n  return res;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f))return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+='+';\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+='x';\n    else if(i) s+=\"x^\"+itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    V=n;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      /*      vector<int> r=tocap(s);\n      for(int j=0;j<r.size();j++) cout<<r[j]<<' ';\n      cout<<endl;*/\n      add_edge(a-1,b-1,tocap(s));\n      add_edge(b-1,a-1,tocap(s));\n    }\n    \n    output(max_flow(0,n-1));\n\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nvector<int> Minus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n  return res;\n}\n\nvector<int> Plus(vector<int> &res, vector<int> v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n  return res;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , min(f,e.cap));\n      if(check(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nint V=51;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f))return flow;\n    Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      Plus(res,tov(t));\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+='+';\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+='x';\n    else if(i) s+=\"x^\"+itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nint main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n    \n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cassert>\n#include <stack>\n#include <memory>\n\nusing namespace std;\n\nstruct Link {\n\tint value;\n\tshared_ptr<Link> prev;\n};\n\nstruct polynomial {\n\tvector<int> coefficients = vector<int>(105, 0);\n\n\tpolynomial() {}\n\n\tpolynomial(vector<int> v) {\n\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\tcoefficients[i] = v[i];\n\t\t}\n\t}\n\n\tint degree() {\n\t\tfor (int i = 104; i >= 0; i--) {\n\t\t\tif (coefficients[i] != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid shift_down() {\n\t\tfor (int i = 0; i < 104; i++) {\n\t\t\tcoefficients[i] = coefficients[i + 1];\n\t\t}\n\t\tcoefficients[104] = 0;\n\t}\n\n\tfriend polynomial &operator -=(polynomial &lhs, polynomial const& rhs) {\n\t\tfor (int i = 0; i < 105; i++) {\n\t\t\tlhs.coefficients[i] -= rhs.coefficients[i];\n\t\t}\n\t\treturn lhs;\n\t}\n\n\tfriend polynomial &operator +=(polynomial &lhs, polynomial const& rhs) {\n\t\tfor (int i = 0; i < 105; i++) {\n\t\t\tlhs.coefficients[i] += rhs.coefficients[i];\n\t\t}\n\t\treturn lhs;\n\t}\n\n\tfriend bool operator <=(polynomial const& lhs, polynomial const& rhs) {\n\t\tfor (int i = 104; i >= 0; i--) {\n\t\t\tif (lhs.coefficients[i] != rhs.coefficients[i]) {\n\t\t\t\treturn lhs.coefficients[i] < rhs.coefficients[i];\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint parse_natural(string::const_iterator &begin, string::const_iterator end) {\n\tint x = 0;\n\twhile (begin != end && ('0' <= *begin && *begin <= '9')) {\n\t\tx *= 10;\n\t\tx += (*begin - '0');\n\t\tbegin++;\n\t}\n\treturn x;\n}\n\npolynomial parse_impl(string::const_iterator &begin, string::const_iterator end) {\n\tif (begin == end) {\n\t\treturn polynomial{};\n\t}\n\tint coefficient;\n\tif (*begin != 'x') {\n\t\tcoefficient = parse_natural(begin, end);\n\t\tif (begin == end) {\n\t\t\treturn polynomial{ vector<int>{ coefficient } };\n\t\t}\n\t}\n\telse {\n\t\tcoefficient = 1;\n\t}\n\tassert(*begin == 'x');\n\tbegin++;\n\tif (begin == end) {\n\t\treturn polynomial{ vector<int>{ 0, coefficient } };\n\t}\n\tint exponent;\n\tif (*begin == '^') {\n\t\tbegin++;\n\t\texponent = parse_natural(begin, end);\n\n\t\tif (begin == end) {\n\t\t\tpolynomial ret;\n\t\t\tret.coefficients[exponent] = coefficient;\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse {\n\t\texponent = 1;\n\t}\n\tassert(*begin == '+');\n\tbegin++;\n\tauto ret = parse_impl(begin, end);\n\tret.coefficients[exponent] = coefficient;\n\treturn ret;\n}\n\npolynomial parse(string const& input) {\n\tstring::const_iterator begin = input.cbegin();\n\treturn parse_impl(begin, input.cend());\n}\n\nvoid print_polynomial(polynomial const& poly) {\n\tbool is_zero = true;\n\tbool first = true;\n\tfor (int i = poly.coefficients.size() - 1; i >= 0; i--) {\n\t\tauto c = poly.coefficients[i];\n\t\tif (c != 0) {\n\t\t\tis_zero = false;\n\t\t\tif (!first) {\n\t\t\t\tcout << '+';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tif (i != 0) {\n\t\t\t\tif (c != 1) {\n\t\t\t\t\tcout << c;\n\t\t\t\t}\n\t\t\t\tcout << 'x';\n\t\t\t\tif (i != 1) {\n\t\t\t\t\tcout << '^' << i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << c;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_zero) {\n\t\tcout << '0';\n\t}\n\tcout << endl;\n}\n\nvoid solve(int n, int e) {\n\tvector<vector<polynomial>> capacity(n + 1, vector<polynomial>(n + 1, polynomial{}));\n\n\tint max_deg = 0;\n\tfor (int i = 0; i < e; i++) {\n\t\tint from, to;\n\t\tstring poly;\n\t\tcin >> from >> to >> poly;\n\t\tauto polynomial = parse(poly);\n\t\tif (max_deg < polynomial.degree()) {\n\t\t\tmax_deg = polynomial.degree();\n\t\t}\n\t\tcapacity[from][to] = polynomial;\n\t\tcapacity[to][from] = polynomial;\n\t}\n\n\tpolynomial result;\n\tpolynomial diff;\n\tdiff.coefficients[max_deg] = 1;\n\twhile (true) {\n\t\tstack<shared_ptr<Link>> fringe;\n\t\tfringe.push(make_shared<Link>(Link{ 1, nullptr }));\n\t\tvector<bool> visited(n + 1, false);\n\t\t\n\t\tbool found = false;\n\t\twhile (!fringe.empty()) {\n\t\t\tauto top = fringe.top();\n\t\t\tfringe.pop();\n\n\t\t\tif (visited[top->value]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisited[top->value] = true;\n\n\t\t\tif (top->value == n) {\n\t\t\t\tfor (auto link = top; link->prev != nullptr; link = link->prev) {\n\t\t\t\t\tcapacity[link->prev->value][link->value] -= diff;\n\t\t\t\t\tcapacity[link->value][link->prev->value] += diff;\n\t\t\t\t}\n\n\t\t\t\tresult += diff;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tauto const& cap = capacity[top->value][i];\n\t\t\t\tif (diff <= cap) {\n\t\t\t\t\tfringe.push(make_shared<Link>(Link{ i, top }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!found) {\n\t\t\tif (diff.degree() <= 0) {\n\t\t\t\tprint_polynomial(result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdiff.shift_down();\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, e;\n\twhile (cin >> n >> e) {\n\t\tif (n == 0 && e == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsolve(n, e);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=102;\nconst int D_v_size=102;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nvector<int>D_sub[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_sub[from].push_back(1);\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n\tD_sub[to].push_back(0);\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint g[60][60][60];\nint res[60];\nchar in[1000];\nint cur;\nint val[60];\npair<int,int>fact(){\n\tint tmp=0;\n\twhile('0'<=in[cur]&&in[cur]<='9'){\n\t\ttmp*=10;tmp+=in[cur]-'0';cur++;\n\t}\n\tif(tmp==0)tmp=1;\n\tif(in[cur]!='x')return make_pair(0,tmp);\n\tcur++;\n\tif(in[cur]!='^')return make_pair(1,tmp);\n\tcur++;\n\tint t2=0;\n\twhile('0'<=in[cur]&&in[cur]<='9'){\n\t\tt2*=10;t2+=in[cur]-'0';cur++;\n\t}\n\treturn make_pair(t2,tmp);\n}\nvoid expr(){\n\tpair<int,int> tmp=fact();\n\tval[tmp.first]+=tmp.second;\n\twhile(in[cur]=='+'){\n\t\tcur++;\n\t\ttmp=fact();\n\t\tval[tmp.first]+=tmp.second;\n\t}\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<60;i++)for(int j=0;j<60;j++)for(int k=0;k<60;k++)\n\t\t\tg[i][j][k]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;\n\t\t\tscanf(\"%d%d%s\",&p,&q,in);\n\t\t\tp--;q--;\n\t\t\tcur=0;\n\t\t\tfor(int j=0;j<60;j++)val[j]=0;\n\t\t\texpr();\n\t\t\tfor(int j=0;j<60;j++)g[j][p][q]=g[j][q][p]=val[j];\n\t\t}\n\t\tfor(int i=59;i>=0;i--){\n\t\t\tfor(int j=0;j<D_MAX_V;j++){\n\t\t\t\tD_G[j].clear();\n\t\t\t\tD_sub[j].clear();\n\t\t\t\tD_level[j]=D_iter[j]=0;\n\t\t\t}\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<a;k++){\n\t\t\t\tadd_edge(j,k,g[i][j][k]);\n\t\t\t}\n\t\t\tres[i]=max_flow(0,a-1);\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tfor(int k=0;k<D_G[j].size();k++){\n\t\t\t\t\tif(D_sub[j][k]&&D_G[j][k].c){\n\t\t\t\t\t\tfor(int l=i-1;l>=0;l--)g[l][j][D_G[j][k].t]=999999999;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool yet=true;\n\t\tfor(int i=59;i>=0;i--){\n\t\t\tif(res[i]==0)continue;\n\t\t\tif(!yet)printf(\"+\");\n\t\t\tyet=false;\n\t\t\tif(res[i]>1)printf(\"%d\",res[i]);\n\t\t\tif(i)printf(\"x\");\n\t\t\tif(i>1)printf(\"^%d\",i);\n\t\t}\n\t\tif(yet)printf(\"0\");\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//flow-dinic(use option -std=gnu++11 for const int INF=10000)\n/*caution!!! this library can use for directed graph!!!*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\n\nclass dinic{\npublic:\n\tconst int INF=1000000;\n\tvector<edge> G[10001];\n\tint level[10001];\n\tint iter[10001];\n\tvoid add_edge(int from,int to,int cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,0,G[from].size()-1));\n\t}\n\n\tvoid bfs(int s){\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(int v,int t,int f){\n\t\tif(v==t)return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tint d=dfs(e.to,t,min(e.cap,f));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint max_flow(int s,int t){\n\t\tint flow=0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\tint f;\n\t\t\twhile((f=dfs(s,t,INF))>0){\n\t\t\t\tflow+=f;\n\t\t\t}\n\t\t}\n\t}\n};"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct poly{\n\tvi a;\n\tint n;\n\tstring to_s()const{\n\t\tstring ret;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(a[i]){\n\t\t\t\tif(i<n){\n\t\t\t\t\tret+=\"+\";\n\t\t\t\t}\n\t\t\t\tif(i==0){\n\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i]!=1){\n\t\t\t\t\t\tret+=toString(a[i]);\n\t\t\t\t\t}\n\t\t\t\t\tret+=\"x\";\n\t\t\t\t\tif(i>1){\n\t\t\t\t\t\tret+=\"^\";\n\t\t\t\t\t\tret+=toString(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(n==0){\n\t\t\t\tret+=\"0\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool operator< (const poly& left,const poly& right){\n\tif(left.n==right.n){\n\t\tfor(int i=left.n;i>=0;i--){\n\t\t\tif(left.a[i]!=right.a[i]){\n\t\t\t\treturn left.a[i]<right.a[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\treturn left.n<right.n;\n\t}\n}\npoly operator+(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)+(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\npoly operator-(const poly& left,const poly& right){\n\tpoly ret;\n\tret.n=max(left.n,right.n);\n\tret.a.resize(ret.n+1);\n\tint last=0;\n\tREP(i,ret.n+1){\n\t\tret.a[i]=(i<left.a.size()?left.a[i]:0)-(i<right.a.size()?right.a[i]:0);\n\t\tif(ret.a[i]){\n\t\t\tlast=i;\n\t\t}\n\t}\n\tret.n=last;\n\tret.a.resize(last+1);\n\treturn ret;\n}\nint num(const string &s,int &i){\n\tint n=0;\n\twhile(isdigit(s[i])){\n\t\tn*=10;\n\t\tn+=s[i]-'0';\n\t\ti++;\n\t}\n\treturn n;\n}\npoly to_poly(const string &s){\n\tint i=0;\n\tpoly p;\n\twhile(i<s.size()){\n\t\tint k=1;\n\t\tif(isdigit(s[i])){\n\t\t\tk=num(s,i);\n\t\t}\n\t\tint n=0;\n\t\tif(s[i]=='x'){\n\t\t\ti++;\n\t\t\tif(s[i]=='^'){\n\t\t\t\ti++;\n\t\t\t\tn=num(s,i);\n\t\t\t}else{\n\t\t\t\tn=1;\n\t\t\t}\n\t\t}\n\t\tp.n=max(p.n,n);\n\t\tp.a.resize(p.n+1);\n\t\tp.a[n]=k;\n\t\tif(s[i]=='+'){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn p;\n}\nstruct edge{\n\tint to,rev;\n\tpoly cap;\n\tedge(int to,int rev,poly cap):to(to),rev(rev),cap(cap){}\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nconst poly Zero=to_poly(string(\"0\"));\nconst poly Inf=to_poly(string(\"x^51\"));\n\nvoid add_edge(int from,int to,poly& cap,vve &g){\n\tg[from].push_back(edge(to,g[to].size(),cap));\n\tg[to].push_back(edge(from,g[from].size()-1,Zero));\n}\n\npoly dfs(int v,int t,poly f,vve &g,vi &used){\n\tif(v==t)return f;\n\tused[v]=true;\n\tREP(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&Zero<e.cap){\n\t\t\tpoly d=dfs(e.to,t,min(f,e.cap),g,used);\n\t\t\tif(Zero<d){\n\t\t\t\te.cap=e.cap-d;\n\t\t\t\tg[e.to][e.rev].cap=g[e.to][e.rev].cap+d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn Zero;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvve g(n,ve());\n\t\tREP(i,m){\n\t\t\tint u,v;\n\t\t\tstring p;\n\t\t\tcin>>u>>v>>p,u--,v--;\n\t\t\tpoly pol=to_poly(p);\n\t\t\tadd_edge(u,v,pol,g);\n\t\t\tadd_edge(v,u,pol,g);\n\t\t}\n\t\tpoly ans=Zero;\n\t\twhile(1){\n\t\t\tvi used(n);\n\t\t\tpoly f=dfs(0,n-1,Inf,g,used);\n\t\t\tif(f.n==0&&f.a[0]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans=ans+f;\n\t\t}\n\t\tcout<<ans.to_s()<<endl;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2328 Mobile Network\n// 2018.3.13 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define CZ       0\n#define CINF     1\n\n#define VMAX 53\ntypedef struct { short to, cap, rev; } EDGE;\nEDGE edge[VMAX][VMAX]; short hi[VMAX];\nint V;\t\t\t\t// 頂点数\nshort level[VMAX], iter[VMAX];\nint queue[2*VMAX], qtop;\n\ntypedef struct { short w, c[55]; } CAP;\nCAP cap[15000]; int cid;\n\nchar buf[600], *p;\nint in()\n{\n\tint n = 0;\n\twhile (isdigit(*p)) n = 10*n + (*p++ & 0xf); p++;\n\treturn n;\n}\n\nint cap_new() { int id = cid++;\tcap[id].w = 1, cap[id].c[0] = 0; return id; }\nvoid cap_set(int id1, int id2) { memcpy(cap+id1, cap+id2, sizeof(CAP)); }\nint cap_zero(int id) { return cap[id].c[cap[id].w-1]; }\n\nvoid cap_norm(int id)\n{\n\tint w = cap[id].w - 1;\n\twhile (w > 0 && cap[id].c[w] == 0) w--;\n\tcap[id].w = w + 1;\n}\n\nint cap_cmp(int id1, int id2)\n{\n\tint i, w1 = cap[id1].w-1, w2 = cap[id2].w-1;\n\tif (w1 > w2) return  cap[id1].c[w1];\n\tif (w2 > w1) return  -cap[id2].c[w2];\n\tfor (i = w1; i >= 0; i--) {\n\t\tif (cap[id1].c[i] != cap[id2].c[i]) return cap[id1].c[i] - cap[id2].c[i];\n\t}\n\treturn 0;\n}\n\nvoid cap_add(int id1, int id2)\n{\n\tint i, w1 = cap[id1].w, w2 = cap[id2].w;\n\tif (w1 > w2) for (i = 0; i < w2; i++) cap[id1].c[i] += cap[id2].c[i];\n\telse {\n\t\tfor (i = 0; i < w1; i++) cap[id1].c[i] += cap[id2].c[i];\n\t\tfor (     ; i < w2; i++) cap[id1].c[i]  = cap[id2].c[i];\n\t\tcap[id1].w = cap[id2].w;\n\t\tcap_norm(id1);\n\t}\n}\n\nvoid cap_sub(int id1, int id2)\n{\n\tint i, w1 = cap[id1].w, w2 = cap[id2].w;\n\tif (w1 > w2) for (i = 0; i < w2; i++) cap[id1].c[i] -= cap[id2].c[i];\n\telse {\n\t\tfor (i = 0; i < w1; i++) cap[id1].c[i] -= cap[id2].c[i];\n\t\tfor (     ; i < w2; i++) cap[id1].c[i] = -cap[id2].c[i];\n\t\tcap[id1].w = cap[id2].w;\n\t\tcap_norm(id1);\n\t}\n}\n\nvoid str2cap(int id)\n{\n\tint c, e, w = 0;\n\n\twhile (*p > ' ') {\n\t\tif (*p == '+') p++;\n\t\tc = 1; if (isdigit(*p)) c = in(), p--;\n\t\te = 0; if (*p == 'x') {\n\t\t\tp++; e = 1;\n\t\t\tif (*p == '^') { p++; if (isdigit(*p)) e = in(), p--; }\n\t\t}\n\t\tcap[id].c[e] = c;\n\t\tif (e > w) w = e;\n\t}\n\tcap[id].w = w+1;\n}\n\nvoid coutcap(int id)\n{\n\tint f = 0, i;\n\n\tfor (i = cap[id].w-1; i > 0; i--) {\n\t\tif (cap[id].c[i] == 0) continue;\n\t\tif (f) putchar('+');\n\t\tif (cap[id].c[i] != 1) printf(\"%d\", cap[id].c[i]);\n\t\tf = 1, putchar('x');\n\t\tif (i > 1) printf(\"^%d\", i);\n\t}\n\tif (!f) printf(\"%d\", cap[id].c[0]);\n\telse if (cap[id].c[0]) printf(\"+%d\", cap[id].c[0]);\n\tputchar('\\n');\n}\n\nvoid add_edge(int from, int to, int id)\n{\n\tint f, t, c;\n\tEDGE *e;\n\n\tf = hi[from]++, t = hi[to]++;\n\te = &edge[from][f], e->to = to, e->cap = id, e->rev = t;\n\tc = cap_new(), cap_set(c, id);\n\te = &edge[to][t], e->to = from, e->cap = c, e->rev = f;\n}\n\nvoid bfs(int s)\n{\n\tint i, v;\n\tEDGE *e;\n\t\n\tmemset(level, -1, V << 1);\n\tlevel[s] = 0;\n\tqueue[0] = s, qtop =1;\n\twhile (qtop) {\n\t\tv = queue[--qtop];\n\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\te = &edge[v][i];\n\t\t\tif (cap_zero(e->cap) > 0 && level[e->to] < 0) {\n\t\t\t\tlevel[e->to] = level[v] + 1;\n\t\t\t\tqueue[qtop++] = e->to;\n\t\t\t}\n\t\t}\n\t}\n}\n \nint dfs(int v, int t, int f)\n{\n\tint  d, ff;\n\tEDGE *e;\n\tshort *i;\n\t\n\tif (v == t) return f;\n\tff = cap_new(), cap_set(ff, f);\n\td = cap_new();\n\tfor (i = &iter[v]; *i < hi[v]; (*i)++) {\n\t\te = &edge[v][*i];\n\t\tif (cap_zero(e->cap) > 0 && level[v] < level[e->to]) {\n\t\t\tif (cap_cmp(ff, e->cap) <= 0) cap_set(d, dfs(e->to, t, ff));\n\t\t\telse                          cap_set(d, dfs(e->to, t, e->cap));\n\t\t\tif (cap_zero(d) > 0) {\n\t\t\t\tcap_sub(e->cap, d);\n\t\t\t\tcap_add(edge[e->to][e->rev].cap, d);\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn CZ;\n}\n \nint maxFlow(int s, int t)\n{\n\tint f =\tcap_new();\n\tint flow = cap_new();\n\n\twhile (1) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) break;\n\t\tmemset(iter, 0, V << 1);\n\t\twhile (1) {\n\t\t\tcap_set(f, dfs(s, t, CINF));\n\t\t\tif (cap_zero(f) <= 0) break;\n\t\t\tcap_add(flow, f);\n\t\t}\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tint N, M, i, u, v;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tcap[CZ].w = 1, cap[CZ].c[0] = 0;\n\t\tcap[CINF].w = 53, cap[CINF].c[52] = 1;\n\t\tcid = 2;\n\n\t\tN = in(), M = in();\n\t\tV = N; memset(hi, 0, V << 1);\n\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tfgets(p=buf, 600, stdin);\n\t\t\tu = in()-1, v = in()-1, str2cap(cid++);\n\t\t\tadd_edge(u, v, cid-1);\n\t\t}\n\t\tcoutcap(maxFlow(0, N-1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2328 Mobile Network\n// 2018.3.13 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define INF      0x01010101\n#define CZ       0\n#define CINF     1\n\n#define VMAX 53\ntypedef struct { int to; short cap; int rev; } EDGE;\nEDGE edge[VMAX][VMAX]; int hi[VMAX];\nint V;\t\t\t\t// 頂点数\nint level[VMAX], iter[VMAX];\nint queue[2*VMAX], qtop;\n\ntypedef struct { char w; short c[55]; } CAP;\nCAP cap[15000]; int cid;\n\nchar buf[600], *p;\nint in()\n{\n\tint n = 0;\n\twhile (isdigit(*p)) n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint cap_new() { int id = cid++;\tcap[id].w = 1, cap[id].c[0] = 0; return id; }\nvoid cap_set(int id1, int id2) { memcpy(cap+id1, cap+id2, sizeof(CAP)); }\n\nvoid cap_norm(int id)\n{\n\tint w = cap[id].w - 1;\n\twhile (w > 0 && cap[id].c[w] == 0) w--;\n\tcap[id].w = w + 1;\n}\n\nint cap_zero(int id) { return cap[id].c[cap[id].w-1]; }\n\nint cap_cmp(int id1, int id2)\n{\n\tint i, w1 = cap[id1].w-1, w2 = cap[id2].w-1;\n\tif (w1 > w2) return  cap[id1].c[w1];\n\tif (w2 > w1) return  -cap[id2].c[w2];\n\tfor (i = w1; i >= 0; i--) {\n\t\tif (cap[id1].c[i] != cap[id2].c[i]) return cap[id1].c[i] - cap[id2].c[i];\n\t}\n\treturn 0;\n}\n\nvoid cap_add(int id1, int id2)\n{\n\tint i, w1 = cap[id1].w, w2 = cap[id2].w;\n\tif (w1 > w2) {\n\t\tfor (i = 0; i < w2; i++) cap[id1].c[i] += cap[id2].c[i];\n\t} else {\n\t\tfor (i = 0; i < w1; i++) cap[id1].c[i] += cap[id2].c[i];\n\t\tfor (     ; i < w2; i++) cap[id1].c[i]  = cap[id2].c[i];\n\t\tcap[id1].w = cap[id2].w;\n\t\tcap_norm(id1);\n\t}\n}\n\nvoid cap_sub(int id1, int id2)\n{\n\tint i, w1 = cap[id1].w, w2 = cap[id2].w;\n\tif (w1 > w2) {\n\t\tfor (i = 0; i < w2; i++) cap[id1].c[i] -= cap[id2].c[i];\n\t} else {\n\t\tfor (i = 0; i < w1; i++) cap[id1].c[i] -= cap[id2].c[i];\n\t\tfor (     ; i < w2; i++) cap[id1].c[i] = -cap[id2].c[i];\n\t\tcap[id1].w = cap[id2].w;\n\t\tcap_norm(id1);\n\t}\n}\n\nvoid str2cap(int id)\n{\n\tint c, e, w = 0;\n\n\twhile (*p > ' ') {\n\t\tif (*p == '+') p++;\n\t\tc = 1; if (isdigit(*p)) c = in(), p--;\n\t\te = 0; if (*p == 'x') {\n\t\t\tp++; e = 1;\n\t\t\tif (*p == '^') { p++; if (isdigit(*p)) e = in(), p--; }\n\t\t}\n\t\tcap[id].c[e] = c;\n\t\tif (e > w) w = e;\n\t}\n\tcap[id].w = w+1;\n}\n\nvoid coutcap(int id)\n{\n\tint f = 0, i, w = cap[id].w-1;\n\n\tfor (i = w; i > 0; i--) {\n\t\tif (cap[id].c[i] == 0) continue;\n\t\tif (f) putchar('+');\n\t\tif (cap[id].c[i] != 1) printf(\"%d\", cap[id].c[i]);\n\t\tputchar('x'); f = 1;\n\t\tif (i > 1) printf(\"^%d\", i);\n\t}\n\tif (!f) printf(\"%d\", cap[id].c[0]);\n\telse if (cap[id].c[0]) printf(\"+%d\", cap[id].c[0]);\n\tputchar('\\n');\n}\n\nvoid add_edge(int from, int to, int id)\n{\n\tint f, t, c;\n\tEDGE *e;\n\n\tf = hi[from]++, t = hi[to]++;\n\te = &edge[from][f], e->to = to, e->cap = id, e->rev = t;\n\tc = cap_new(), cap_set(c, id);\n\te = &edge[to][t], e->to = from, e->cap = c, e->rev = f;\n}\n\nvoid bfs(int s)\n{\n\tint i, v;\n\tEDGE *e;\n\t\n\tmemset(level, -1, V << 2);\n\tlevel[s] = 0;\n\tqueue[0] = s, qtop =1;\n\twhile (qtop) {\n\t\tv = queue[--qtop];\n\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\te = &edge[v][i];\n\t\t\tif (cap_zero(e->cap) > 0 && level[e->to] < 0) {\n\t\t\t\tlevel[e->to] = level[v] + 1;\n\t\t\t\tqueue[qtop++] = e->to;\n\t\t\t}\n\t\t}\n\t}\n}\n \nint dfs(int v, int t, int f)\n{\n\tint *i, d, ff;\n\tEDGE *e;\n\t\n\tff = cap_new(); cap_set(ff, f);\n\tif (v == t) return ff;\n\td = cap_new();\n\tfor (i = &iter[v]; *i < hi[v]; (*i)++) {\n\t\te = &edge[v][*i];\n\t\tif (cap_zero(e->cap) > 0 && level[v] < level[e->to]) {\n\t\t\tif (cap_cmp(ff, e->cap) <= 0) cap_set(d, dfs(e->to, t, ff));\n\t\t\telse                          cap_set(d, dfs(e->to, t, e->cap));\n\t\t\tif (cap_zero(d) > 0) {\n\t\t\t\tcap_sub(e->cap, d);\n\t\t\t\tcap_add(edge[e->to][e->rev].cap, d);\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn CZ;\n}\n \nint maxFlow(int s, int t)\n{\n\tint f =\tcap_new();\n\tint flow = cap_new();\n\n\twhile (1) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) break;\n\t\tmemset(iter, 0, V << 2);\n\t\twhile (1) {\n\t\t\tcap_set(f, dfs(s, t, CINF));\n\t\t\tif (cap_zero(f) <= 0) break;\n\t\t\tcap_add(flow, f);\n\t\t}\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tint N, M, i, u, v;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tcap[CZ].w = 1, cap[CZ].c[0] = 0;\n\t\tcap[CINF].w = 53, cap[CINF].c[52] = 1;\n\t\tcid = 2;\n\n\t\tN = in(), M = in();\n\t\tV = N; memset(hi, 0, V << 2);\n\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tfgets(p=buf, 600, stdin);\n\t\t\tu = in()-1, v = in()-1;\n\t\t\tstr2cap(cid++);\n\t\t\tadd_edge(u, v, cid-1);\n\t\t}\n\t\tcoutcap(maxFlow(0, N-1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2328 Mobile Network\n// 2018.3.13 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define CZ       0\n#define CINF     1\n\n#define VMAX 53\ntypedef struct { short to, cap, rev; } EDGE;\nEDGE edge[VMAX][VMAX]; short hi[VMAX];\nint V;\t\t\t\t// 頂点数\nshort level[VMAX], iter[VMAX];\nint queue[2*VMAX], qtop;\n\ntypedef struct { short w, c[55]; } CAP;\nCAP cap[15000]; int cid;\n\nchar buf[600], *p;\nint in()\n{\n\tint n = 0;\n\twhile (isdigit(*p)) n = 10*n + (*p++ & 0xf); p++;\n\treturn n;\n}\n\nint cap_new() { int id = cid++;\tcap[id].w = 1, cap[id].c[0] = 0; return id; }\nvoid cap_set(int id1, int id2) { memcpy(cap+id1, cap+id2, sizeof(CAP)); }\n// int cap_zero(int id) { return cap[id].c[cap[id].w-1]; }\n#define cap_zero(id)         (cap[id].c[cap[id].w-1])\n\nvoid cap_norm(int id)\n{\n\tint w = cap[id].w - 1;\n\twhile (w > 0 && cap[id].c[w] == 0) w--;\n\tcap[id].w = w + 1;\n}\n\nint cap_cmp(int id1, int id2)\n{\n\tint w1 = cap[id1].w-1, w2 = cap[id2].w-1;\n\tif (w1 > w2) return  cap[id1].c[w1];\n\tif (w2 > w1) return  -cap[id2].c[w2];\n\twhile (w1 > 0 && cap[id1].c[w1] == cap[id2].c[w1]) w1--;\n\treturn cap[id1].c[w1] - cap[id2].c[w1];\n}\n\nvoid cap_add(int id1, int id2)\n{\n\tint i, w1 = cap[id1].w, w2 = cap[id2].w;\n\tif (w1 > w2) for (i = 0; i < w2; i++) cap[id1].c[i] += cap[id2].c[i];\n\telse {\n\t\tfor (i = 0; i < w1; i++) cap[id1].c[i] += cap[id2].c[i];\n\t\tfor (     ; i < w2; i++) cap[id1].c[i]  = cap[id2].c[i];\n\t\tcap[id1].w = cap[id2].w;\n//\t\tcap_norm(id1);\n\t}\n}\n\nvoid cap_sub(int id1, int id2)\n{\n\tint i, w1 = cap[id1].w, w2 = cap[id2].w;\n\tif (w1 > w2) for (i = 0; i < w2; i++) cap[id1].c[i] -= cap[id2].c[i];\n\telse {\n\t\tfor (i = 0; i < w1; i++) cap[id1].c[i] -= cap[id2].c[i];\n\t\tfor (     ; i < w2; i++) cap[id1].c[i] = -cap[id2].c[i];\n\t\tcap[id1].w = cap[id2].w;\n\t\tcap_norm(id1);\n\t}\n}\n\nvoid str2cap(int id)\n{\n\tint c, e, w = 0;\n\n\twhile (*p > ' ') {\n\t\tif (*p == '+') p++;\n\t\tc = 1; if (isdigit(*p)) c = in(), p--;\n\t\te = 0; if (*p == 'x') {\n\t\t\tp++; e = 1;\n\t\t\tif (*p == '^') { p++; if (isdigit(*p)) e = in(), p--; }\n\t\t}\n\t\tcap[id].c[e] = c;\n\t\tif (e > w) w = e;\n\t}\n\tcap[id].w = w+1;\n}\n\nvoid coutcap(int id)\n{\n\tint f = 0, i;\n\n\tfor (i = cap[id].w-1; i > 0; i--) {\n\t\tif (cap[id].c[i] == 0) continue;\n\t\tif (f) putchar('+');\n\t\tif (cap[id].c[i] != 1) printf(\"%d\", cap[id].c[i]);\n\t\tf = 1, putchar('x');\n\t\tif (i > 1) printf(\"^%d\", i);\n\t}\n\tif (!f) printf(\"%d\", cap[id].c[0]);\n\telse if (cap[id].c[0]) printf(\"+%d\", cap[id].c[0]);\n\tputchar('\\n');\n}\n\nvoid add_edge(int from, int to, int id)\n{\n\tint f, t, c;\n\tEDGE *e;\n\n\tf = hi[from]++, t = hi[to]++;\n\te = &edge[from][f], e->to = to, e->cap = id, e->rev = t;\n\tc = cap_new(), cap_set(c, id);\n\te = &edge[to][t], e->to = from, e->cap = c, e->rev = f;\n}\n\nvoid bfs(int s)\n{\n\tint i, v;\n\tEDGE *e;\n\t\n\tmemset(level, -1, V << 1);\n\tlevel[s] = 0;\n\tqueue[0] = s, qtop =1;\n\twhile (qtop) {\n\t\tv = queue[--qtop];\n\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\te = &edge[v][i];\n\t\t\tif (cap_zero(e->cap) > 0 && level[e->to] < 0) {\n\t\t\t\tlevel[e->to] = level[v] + 1;\n\t\t\t\tqueue[qtop++] = e->to;\n\t\t\t}\n\t\t}\n\t}\n}\n \nint dfs(int v, int t, int f)\n{\n\tint  d, ff;\n\tEDGE *e;\n\tshort *i;\n\t\n\tif (v == t) return f;\n\tff = cap_new(), cap_set(ff, f);\n\td = cap_new();\n\tfor (i = &iter[v]; *i < hi[v]; (*i)++) {\n\t\te = &edge[v][*i];\n\t\tif (cap_zero(e->cap) > 0 && level[v] < level[e->to]) {\n\t\t\tif (cap_cmp(ff, e->cap) <= 0) cap_set(d, dfs(e->to, t, ff));\n\t\t\telse                          cap_set(d, dfs(e->to, t, e->cap));\n\t\t\tif (cap_zero(d) > 0) {\n\t\t\t\tcap_sub(e->cap, d);\n\t\t\t\tcap_add(edge[e->to][e->rev].cap, d);\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn CZ;\n}\n \nint maxFlow(int s, int t)\n{\n\tint f =\tcap_new();\n\tint flow = cap_new();\n\n\twhile (1) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) break;\n\t\tmemset(iter, 0, V << 1);\n\t\twhile (1) {\n\t\t\tcap_set(f, dfs(s, t, CINF));\n\t\t\tif (cap_zero(f) <= 0) break;\n\t\t\tcap_add(flow, f);\n\t\t}\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tint N, M, i, u, v;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tcap[CZ].w = 1, cap[CZ].c[0] = 0;\n\t\tcap[CINF].w = 53, cap[CINF].c[52] = 1;\n\t\tcid = 2;\n\n\t\tN = in(), M = in();\n\t\tV = N; memset(hi, 0, V << 1);\n\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tfgets(p=buf, 600, stdin);\n\t\t\tu = in()-1, v = in()-1, str2cap(cid++);\n\t\t\tadd_edge(u, v, cid-1);\n\t\t}\n\t\tcoutcap(maxFlow(0, N-1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\ndef get_path(s, t, reached = Set[s])\n\treturn [t] if s == t\n\ts.each_edge do |e|\n\t\tv = e.opposite[s]\n\t\tnext if reached.include?(v)\n\n\t\tcap = e.property[:capacity]\n\t\tflow = (e.property[:flow] ||= 0)\n\t\tto = (e.property[:flow_to] ||= v)\n\t\trest = (to == v ? cap - flow : cap + flow)\n\t\tnext if rest <= 0\n\n\t\treached << v\n\t\tif path = get_path(v, t, reached)\n\t\t\treturn [s, e, *path]\n\t\tend\n\tend\t\n\treturn nil\nend\n\ndef compute_min(path)\n\tm = Float::INFINITY\n\ti = 0\n\twhile i < path.size - 1\n\t\tu = path[i]\n\t\te = path[i+1]\n\t\tv = path[i+2]\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\t\trest = (to == v ? cap - flow : cap + flow)\n\t\tm = rest if rest < m\n\t\ti += 2\n\tend\n\tm\nend\n\ndef add_flow(df, path)\n\ti = 0\n\twhile i < path.size - 1\n\t\tu = path[i]\n\t\te = path[i+1]\n\t\tv = path[i+2]\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\n\t\tif to == v && flow >= df\n\t\t\te.property[:flow] -= df\n\t\telsif to == v && flow < df\n\t\t\te.property[:flow_to] = u\n\t\t\te.property[:flow] = df - flow\n\t\telsif to == u && flow >= df\n\t\t\te.property[:flow] -= df\n\t\telse\n\t\t\te.property[:flow_to] = v\n\t\t\te.property[:flow] = df - flow\n\t\tend\n\t\ti += 2\n\tend\nend\n\nclass Poly\n\tdef initialize(s)\n\t\t@hash = Hash.new(0)\n\t\ts.chomp.split(?+).each do |term|\n\t\t\tif term =~ /(\\d*)x(^(\\d+))?/\n\t\t\t\t@hash[$2 ? $3.to_i : 1] = ($1 == \"\" ? 1 : $1.to_i)\n\t\t\telse\n\t\t\t\t@hash[0] = term.to_i\n\t\t\tend\n\t\tend\n\tend\n\n\tdef +(poly)\n\t\tsum = self.class.new(\"\")\n\t\t@hash.each {|k, a| sum.hash[k] += a}\n\t\tpoly.hash.each {|k, a| sum.hash[k] += a}\n\t\tsum\n\tend\n\n\tdef to_s\n\t\tks = @hash.keys\n\t\tks.delete_if {|k| !@hash[k] || @hash[k] == 0}\n\t\treturn ?0 if ks.empty?\n\t\tks.sort!\n\t\tks.reverse!\t\n\t\tks.map {|k|\n\t\t\t[@hash[k] == 1 ? \"\" : @hash[k], k == 0 ? \"\" : ?x, k <= 1 ? \"\" : \"^#{k}\"].join\n\t\t}.join(?+)\n\tend\n\n\tattr_reader :hash\nend\n\nloop do\n\tn, m = gets.split.map(&:to_i)\t\n\tbreak if n == 0\n\tg = Graph.new\n\tnodes = (0..n).map { g.add_node }\n\tedges = []\n\n\tx = 100000\n\tm.times do\n\t\ti, j, poly = gets.chomp.split\n\t\tpoly.gsub!(?^, '**')\n\t\tpoly.gsub!(/\\dx/){|s| s[0..-2] + '*x'}\n\t\te = g.add_edge(nodes[i.to_i], nodes[j.to_i])\n\t\te.property[:poly_capacity] = poly\n\t\te.property[:capacity] = eval(poly)\n\t\tedges << e\n\tend\n\n\tloop do\n\t\tpath = get_path(nodes[1], nodes[n])\n\t\tbreak if !path\n\t\tmin = compute_min(path)\t\n\t\tadd_flow(min, path)\n\tend\n\tsaturated = edges.select{|e| e.property[:flow] == e.property[:capacity]}\n\tpolys = saturated.map {|e| Poly.new(e.property[:poly_capacity])}\n\tputs (polys.inject(:+) || Poly.new(\"\"))\nend"
  },
  {
    "language": "Ruby",
    "code": "\nrequire 'set'\n\nclass Graph\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\n# def get_path(s, t, reached = Set[s])\n# \treturn [t] if s == t\n# \ts.each_edge do |e|\n# \t\tv = e.opposite[s]\n# \t\tnext if reached.include?(v)\n#\n# \t\tcap = e.property[:capacity]\n# \t\tflow = (e.property[:flow] ||= 0)\n# \t\tto = (e.property[:flow_to] ||= v)\n# \t\trest = (to == v ? cap - flow : cap + flow)\n# \t\tnext if rest <= 0\n#\n# \t\treached << v\n# \t\tif path = get_path(v, t, reached)\n# \t\t\treturn [s, e, *path]\n# \t\tend\n# \tend\t\n# \treturn nil\n# end\n\ndef get_path(s, t)\n\treached = Set[s]\n\tqueue = [s]\n\tcomming_edge = {}\n\tuntil queue.empty?\n\t\tu = queue.shift\n\t\tu.each_edge do |e|\t\n\t\t\tv = e.opposite[u]\n\t\t\tnext if reached.include?(v)\n\n\t\t\tcap = e.property[:capacity]\n\t\t\tflow = (e.property[:flow] ||= 0)\n\t\t\tto = (e.property[:flow_to] ||= v)\n\t\t\trest = (to == v ? cap - flow : cap + flow)\n\t\t\tnext if rest <= 0\n\n\t\t\treached << v\n\t\t\tcomming_edge[v] = e\n\t\t\tqueue << v\n\n\t\t\tif v == t\n\t\t\t\tqueue = []\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\t\n\tend\n\n\tif comming_edge[t]\n\t\tpath = [t]\n\t\tv = t\n\t\tuntil path[0] == s\n\t\t\te = comming_edge[v]\n\t\t\tu = e.opposite[v]\n\t\t\tpath = [u, e, *path]\n\t\t\tv = u\n\t\tend\n\t\treturn path\n\tend\n\treturn nil\nend\n\ndef compute_min(path)\n\tm = Float::INFINITY\n\ti = 0\n\twhile i < path.size - 1\n\t\tu = path[i]\n\t\te = path[i+1]\n\t\tv = path[i+2]\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\t\trest = (to == v ? cap - flow : cap + flow)\n\t\tm = rest if rest < m\n\t\ti += 2\n\tend\n\tm\nend\n\ndef add_flow(df, path)\n\ti = 0\n\twhile i < path.size - 1\n\t\tu = path[i]\n\t\te = path[i+1]\n\t\tv = path[i+2]\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\n\t\tif to == v \n\t\t\te.property[:flow] += df\n\t\telsif flow >= df\n\t\t\te.property[:flow] -= df\n\t\telse\n\t\t\te.property[:flow_to] = v\n\t\t\te.property[:flow] = df - flow\n\t\tend\n\t\ti += 2\n\tend\nend\n\ndef reachable(s, reached = Set[s])\n\ts.each_edge do |e|\n\t\tv = e.opposite[s]\n\t\tnext if reached.include?(v)\n\n\t\tcap = e.property[:capacity]\n\t\tflow = (e.property[:flow] ||= 0)\n\t\tto = (e.property[:flow_to] ||= v)\n\t\trest = (to == v ? cap - flow : cap + flow)\n\t\tnext if rest <= 0\n\n\t\treached << v\n\t\treachable(v, reached)\n\tend\t\n\treached\nend\n\nclass Poly\n\tdef initialize(s)\n\t\t@hash = Hash.new(0)\n\t\ts.chomp.split(?+).each do |term|\n\t\t\tif term =~ /((\\d+)\\*)?x(\\*\\*(\\d+))?/\n\t\t\t\t@hash[$3 ? $4.to_i : 1] = ($2 ? $1.to_i : 1)\n\t\t\telse\n\t\t\t\t@hash[0] = term.to_i\n\t\t\tend\n\t\tend\n\tend\n\n\tdef +(poly)\n\t\tsum = self.class.new(\"\")\n\t\t@hash.each {|k, a| sum.hash[k] += a}\n\t\tpoly.hash.each {|k, a| sum.hash[k] += a}\n\t\tsum\n\tend\n\n\tdef to_s\n\t\tks = @hash.keys\n\t\tks.delete_if {|k| !@hash[k] || @hash[k] == 0}\n\t\treturn ?0 if ks.empty?\n\t\tks.sort!\n\t\tks.reverse!\t\n\t\tks.map {|k|\n\t\t\tif k == 0\n\t\t\t\t@hash[k]\n\t\t\telse\n\t\t\t\t[@hash[k] == 1 ? \"\" : @hash[k], ?x, k == 1 ? \"\" : \"^#{k}\"].join\n\t\t\tend\n\t\t}.join(?+)\n\tend\n\n\tattr_reader :hash\nend\n\nloop do\n\tn, m = gets.split.map(&:to_i)\t\n\tbreak if n == 0\n\tg = Graph.new\n\tnodes = (0..n).map { g.add_node }\n\tedges = []\n\n\tx = 1000000000\n\tm.times do\n\t\ti, j, poly = gets.chomp.split\n\t\tpoly.gsub!(?^, '**')\n\t\tpoly.gsub!(/\\dx/){|s| s[0..-2] + '*x'}\n\t\te = g.add_edge(nodes[i.to_i], nodes[j.to_i])\n\t\te.property[:poly_capacity] = poly\n\t\te.property[:capacity] = eval(poly)\n\t\tedges << e\n\tend\n\n\tloop do\n\t\tpath = get_path(nodes[1], nodes[n])\n\t\tbreak if !path\n\t\tmin = compute_min(path)\t\n\t\tadd_flow(min, path)\n\tend\n\n\tl_nodes = reachable(nodes[1])\n\tmin_cut = []\n\tedges.each do |e|\n\t\tu, v = e.opposite.keys\n\t\tif l_nodes.include?(u) ^ l_nodes.include?(v)\n\t\t\tmin_cut << e\n\t\tend\n\tend\n\n\t# saturated = edges.select{|e| e.property[:flow] == e.property[:capacity]}\n\tpolys = min_cut.map {|e| Poly.new(e.property[:poly_capacity])}\n\tputs (polys.inject(:+) || Poly.new(\"\"))\n\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\n# def get_path(s, t, reached = Set[s])\n# \treturn [t] if s == t\n# \ts.each_edge do |e|\n# \t\tv = e.opposite[s]\n# \t\tnext if reached.include?(v)\n#\n# \t\tcap = e.property[:capacity]\n# \t\tflow = (e.property[:flow] ||= 0)\n# \t\tto = (e.property[:flow_to] ||= v)\n# \t\trest = (to == v ? cap - flow : cap + flow)\n# \t\tnext if rest <= 0\n#\n# \t\treached << v\n# \t\tif path = get_path(v, t, reached)\n# \t\t\treturn [s, e, *path]\n# \t\tend\n# \tend\t\n# \treturn nil\n# end\n\ndef get_path(s, t)\n\treached = Set[s]\n\tqueue = [s]\n\tcomming_edge = {}\n\tuntil queue.empty?\n\t\tu = queue.shift\n\t\tu.each_edge do |e|\t\n\t\t\tv = e.opposite[u]\n\t\t\tnext if reached.include?(v)\n\n\t\t\tcap = e.property[:capacity]\n\t\t\tflow = (e.property[:flow] ||= 0)\n\t\t\tto = (e.property[:flow_to] ||= v)\n\t\t\trest = (to == v ? cap - flow : cap + flow)\n\t\t\tnext if rest <= 0\n\n\t\t\treached << v\n\t\t\tcomming_edge[v] = e\n\t\t\tqueue << v\n\n\t\t\tif v == t\n\t\t\t\tqueue = []\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\t\n\tend\n\n\tif comming_edge[t]\n\t\tpath = [t]\n\t\tv = t\n\t\tuntil path[0] == s\n\t\t\te = comming_edge[v]\n\t\t\tu = e.opposite[v]\n\t\t\tpath = [u, e, *path]\n\t\t\tv = u\n\t\tend\n\t\treturn path\n\tend\n\treturn nil\nend\n\ndef compute_min(path)\n\tm = Float::INFINITY\n\ti = 0\n\twhile i < path.size - 1\n\t\tu = path[i]\n\t\te = path[i+1]\n\t\tv = path[i+2]\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\t\trest = (to == v ? cap - flow : cap + flow)\n\t\tm = rest if rest < m\n\t\ti += 2\n\tend\n\tm\nend\n\ndef add_flow(df, path)\n\ti = 0\n\twhile i < path.size - 1\n\t\tu = path[i]\n\t\te = path[i+1]\n\t\tv = path[i+2]\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\n\t\tif to == v \n\t\t\te.property[:flow] += df\n\t\telsif flow >= df\n\t\t\te.property[:flow] -= df\n\t\telse\n\t\t\te.property[:flow_to] = v\n\t\t\te.property[:flow] = df - flow\n\t\tend\n\t\ti += 2\n\tend\nend\n\nclass Poly\n\tdef initialize(s)\n\t\t@hash = Hash.new(0)\n\t\ts.chomp.split(?+).each do |term|\n\t\t\tif term =~ /((\\d+)\\*)?x(\\*\\*(\\d+))?/\n\t\t\t\t@hash[$3 ? $4.to_i : 1] = ($2 ? $1.to_i : 1)\n\t\t\telse\n\t\t\t\t@hash[0] = term.to_i\n\t\t\tend\n\t\tend\n\tend\n\n\tdef +(poly)\n\t\tsum = self.class.new(\"\")\n\t\t@hash.each {|k, a| sum.hash[k] += a}\n\t\tpoly.hash.each {|k, a| sum.hash[k] += a}\n\t\tsum\n\tend\n\n\tdef to_s\n\t\tks = @hash.keys\n\t\tks.delete_if {|k| !@hash[k] || @hash[k] == 0}\n\t\treturn ?0 if ks.empty?\n\t\tks.sort!\n\t\tks.reverse!\t\n\t\tks.map {|k|\n\t\t\t[@hash[k] == 1 ? \"\" : @hash[k], k == 0 ? \"\" : ?x, k <= 1 ? \"\" : \"^#{k}\"].join\n\t\t}.join(?+)\n\tend\n\n\tattr_reader :hash\nend\n\nloop do\n\tn, m = gets.split.map(&:to_i)\t\n\tbreak if n == 0\n\tg = Graph.new\n\tnodes = (0..n).map { g.add_node }\n\tedges = []\n\n\tx = 1000000000\n\tm.times do\n\t\ti, j, poly = gets.chomp.split\n\t\tpoly.gsub!(?^, '**')\n\t\tpoly.gsub!(/\\dx/){|s| s[0..-2] + '*x'}\n\t\te = g.add_edge(nodes[i.to_i], nodes[j.to_i])\n\t\te.property[:poly_capacity] = poly\n\t\te.property[:capacity] = eval(poly)\n\t\tedges << e\n\tend\n\n\tloop do\n\t\tpath = get_path(nodes[1], nodes[n])\n\t\tbreak if !path\n\t\tmin = compute_min(path)\t\n\t\tadd_flow(min, path)\n\tend\n\tsaturated = edges.select{|e| e.property[:flow] == e.property[:capacity]}\n\tpolys = saturated.map {|e| Poly.new(e.property[:poly_capacity])}\n\tputs (polys.inject(:+) || Poly.new(\"\"))\nend"
  },
  {
    "language": "Python",
    "code": "import collections\nimport sys\nif sys.version[0] == '2':\n    input, range = raw_input, xrange\n\n\nclass MyList(list):\n    def __init__(self, x=[]):\n        list.__init__(self, x)\n\n    def __iadd__(self, A):\n        return MyList([a + b for a, b in zip(self, A)])\n\n    def __isub__(self, A):\n        return MyList([a - b for a, b in zip(self, A)])\n\n    def __gt__(self, A):\n        for a, b in zip(self, A):\n            if a != b:\n                return a > b\n        return False\n\n\nclass MaxFlow:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V, D):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        self.D = D\n\n    def zero(self):\n        return MyList([0] * self.D)\n\n    def add_edge(self, fr, to, cap):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to])))\n        self.E[to].append(self.Edge(fr, self.zero(), len(self.E[fr])-1))\n\n    def dinic(self, source, sink):\n        \"\"\"find max-flow\"\"\"\n        INF = MyList([10**9] * self.D)\n        maxflow = self.zero()\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = MyList([0] * self.V)\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > self.zero():\n                    maxflow += flow\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if e.cap > self.zero() and self.level[vertex] < self.level[e.to]:\n                if flow > e.cap:\n                    d = self.dfs(e.to, sink, e.cap)\n                else:\n                    d = self.dfs(e.to, sink, flow)\n                if d > self.zero():\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return self.zero()\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if e.cap > self.zero() and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\n\n\ndef to_poly(a, l):\n    if l == 0:\n        return str(a)\n    elif l == 1:\n        return \"{}x\".format('' if a == 1 else a)\n    else:\n        return \"{}x^{}\".format('' if a == 1 else a, l)\n\nwhile True:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    mf = MaxFlow(N, 51)\n    for _ in range(M):\n        u, v, p = input().split()\n        u, v = int(u)-1, int(v)-1\n        poly = MyList([0] * 51)\n        for x in p.split('+'):\n            try:\n                num = int(x)\n                poly[-1] = num\n            except ValueError:\n                a, l = x.split('x')\n                if l:\n                    poly[-int(l.strip(\"^\"))-1] = int(a) if a else 1\n                else:\n                    poly[-2] = int(a) if a else 1\n        mf.add_edge(u, v, poly)\n        mf.add_edge(v, u, poly)\n    maxflow = mf.dinic(0, N-1)\n    ans = '+'.join(to_poly(a, l) for a, l in zip(maxflow, reversed(range(51))) if a)\n    print(ans if ans else 0)"
  },
  {
    "language": "Python",
    "code": "import collections\n\n\ndef plus_list(A, B):\n    assert(len(A) == len(B))\n    return [a + b for a, b in zip(A, B)]\n\n\ndef minus_list(A, B):\n    assert(len(A) == len(B))\n    return [a - b for a, b in zip(A, B)]\n\n\ndef gt_list(A, B):\n    assert(len(A) == len(B))\n    for a, b in zip(A, B):\n        if a != b:\n            return a > b\n    return False\n\n\nclass MaxFlow:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V, D):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        self.D = D\n\n    def add_edge(self, fr, to, cap):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to])))\n        self.E[to].append(self.Edge(fr, [0] * self.D, len(self.E[fr])-1))\n\n    def dinic(self, source, sink):\n        \"\"\"find max-flow\"\"\"\n        INF = [10**9] * self.D\n        maxflow = [0] * self.D\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if gt_list(flow, [0] * self.D):\n                    maxflow = plus_list(maxflow, flow)\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if gt_list(e.cap, [0] * self.D) and self.level[vertex] < self.level[e.to]:\n                if gt_list(flow, e.cap):\n                    d = self.dfs(e.to, sink, e.cap)\n                else:\n                    d = self.dfs(e.to, sink, flow)\n                if gt_list(d, [0] * self.D):\n                    e.cap = minus_list(e.cap, d)\n                    self.E[e.to][e.rev].cap = plus_list(self.E[e.to][e.rev].cap, d)\n                    return d\n        return [0] * self.D\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if gt_list(e.cap, [0] * self.D) and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\n\n\ndef to_poly(a, l):\n    if l == 0:\n        return str(a)\n    elif l == 1:\n        return \"{}x\".format('' if a == 1 else a)\n    else:\n        return \"{}x^{}\".format('' if a == 1 else a, l)\n\nwhile True:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    mf = MaxFlow(N, 51)\n    for _ in range(M):\n        u, v, p = input().split()\n        u, v = int(u)-1, int(v)-1\n        poly = [0] * 51\n        for x in p.split('+'):\n            try:\n                num = int(x)\n                poly[-1] = num\n            except ValueError:\n                a, l = x.split('x')\n                if l:\n                    poly[-int(l.strip(\"^\"))-1] = int(a) if a else 1\n                else:\n                    poly[-2] = int(a) if a else 1\n        mf.add_edge(u, v, poly)\n        mf.add_edge(v, u, poly)\n    maxflow = mf.dinic(0, N-1)\n    ans = '+'.join(to_poly(a, l) for a, l in zip(maxflow, reversed(range(51))) if a)\n    print(ans if ans else 0)"
  },
  {
    "language": "Python",
    "code": "import collections\n\n\nclass MyList(list):\n    def __init__(self, x=[]):\n        list.__init__(self, x)\n\n    def __iadd__(self, A):\n        return MyList([a + b for a, b in zip(self, A)])\n\n    def __isub__(self, A):\n        return MyList([a - b for a, b in zip(self, A)])\n\n    def __gt__(self, A):\n        for a, b in zip(self, A):\n            if a != b:\n                return a > b\n        return False\n\n\nclass MaxFlow:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V, D):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        self.D = D\n\n    def zero(self):\n        return MyList([0] * self.D)\n\n    def add_edge(self, fr, to, cap):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to])))\n        self.E[to].append(self.Edge(fr, self.zero(), len(self.E[fr])-1))\n\n    def dinic(self, source, sink):\n        \"\"\"find max-flow\"\"\"\n        INF = MyList([10**9] * self.D)\n        maxflow = self.zero()\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = MyList([0] * self.V)\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > self.zero():\n                    maxflow += flow\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if e.cap > self.zero() and self.level[vertex] < self.level[e.to]:\n                if flow > e.cap:\n                    d = self.dfs(e.to, sink, e.cap)\n                else:\n                    d = self.dfs(e.to, sink, flow)\n                if d > self.zero():\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return self.zero()\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if e.cap > self.zero() and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\n\n\ndef to_poly(a, l):\n    if l == 0:\n        return str(a)\n    elif l == 1:\n        return \"{}x\".format('' if a == 1 else a)\n    else:\n        return \"{}x^{}\".format('' if a == 1 else a, l)\n\nwhile True:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    mf = MaxFlow(N, 51)\n    for _ in range(M):\n        u, v, p = input().split()\n        u, v = int(u)-1, int(v)-1\n        poly = MyList([0] * 51)\n        for x in p.split('+'):\n            try:\n                num = int(x)\n                poly[-1] = num\n            except ValueError:\n                a, l = x.split('x')\n                if l:\n                    poly[-int(l.strip(\"^\"))-1] = int(a) if a else 1\n                else:\n                    poly[-2] = int(a) if a else 1\n        mf.add_edge(u, v, poly)\n        mf.add_edge(v, u, poly)\n    maxflow = mf.dinic(0, N-1)\n    ans = '+'.join(to_poly(a, l) for a, l in zip(maxflow, reversed(range(51))) if a)\n    print(ans if ans else 0)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nfrom string import digits\n\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\ndef parse(S, L=50):\n    S = S + \"$\"\n    E = [0]*(L+1)\n    cur = 0\n    while 1:\n        if S[cur] in digits:\n            k = 0\n            while S[cur] in digits:\n                k = 10*k + int(S[cur])\n                cur += 1 # '0' ~ '9'\n        else:\n            k = 1\n        if S[cur] == 'x':\n            cur += 1 # 'x'\n            if S[cur] == '^':\n                cur += 1 # '^'\n                p = 0\n                while S[cur] in digits:\n                    p = 10*p + int(S[cur])\n                    cur += 1 # '0' ~ '9'\n            else:\n                p = 1\n        else:\n            p = 0\n        E[p] = k\n        if S[cur] != '+':\n            break\n        cur += 1 # '+'\n    return E\n\ndef solve():\n    N, M = map(int, readline().split())\n    if N == 0:\n        return False\n    L = 50\n    ds = [Dinic(N) for i in range(L+1)]\n    for i in range(M):\n        u, v, p = readline().split()\n        u = int(u)-1; v = int(v)-1\n        poly = parse(p, L)\n        for j in range(L+1):\n            if poly[j] > 0:\n                ds[j].add_multi_edge(u, v, poly[j], poly[j])\n    INF = 10**9\n    res = [0]*(L+1)\n    for j in range(L+1):\n        f = ds[j].flow(0, N-1)\n        res[j] = f\n    E = [[0]*N for i in range(N)]\n    for j in range(L-1, -1, -1):\n        d = ds[j]\n        used = [0]*N\n        used[N-1] = 1\n        que = deque([N-1])\n        G = ds[j+1].G\n        for v in range(N):\n            for w, cap, _ in G[v]:\n                if cap:\n                    E[v][w] = 1\n        for v in range(N):\n            for w in range(N):\n                if E[v][w]:\n                    d.add_edge(v, w, INF)\n        f = d.flow(0, N-1)\n        res[j] += f\n    ans = []\n    if res[0] > 0:\n        ans.append(str(res[0]))\n    if res[1] > 0:\n        ans.append((\"%dx\" % res[1]) if res[1] > 1 else \"x\")\n    for i in range(2, L+1):\n        if res[i] > 0:\n            ans.append((\"%dx^%d\" % (res[i], i)) if res[i] > 1 else (\"x^%d\" % i))\n    if not ans:\n        ans.append(\"0\")\n    ans.reverse()\n    write(\"+\".join(ans))\n    write(\"\\n\")\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "import collections\nimport sys\nif sys.version[0] == '2':\n    input, range = raw_input, xrange\n\n\nclass MyList(list):\n    def __init__(self, x=[]):\n        list.__init__(self, x)\n\n    def __iadd__(self, A):\n        return MyList([a + b for a, b in zip(self, A)])\n\n    def __isub__(self, A):\n        return MyList([a - b for a, b in zip(self, A)])\n\n    def __gt__(self, A):\n        for a, b in zip(self, A):\n            if a != b:\n                return a > b\n        return False\n\n\nclass MaxFlow:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V, D):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        self.D = D\n\n    def zero(self):\n        return MyList([0] * self.D)\n\n    def add_edge(self, fr, to, cap):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to])))\n        self.E[to].append(self.Edge(fr, self.zero(), len(self.E[fr])-1))\n\n    def dinic(self, source, sink):\n        \"\"\"find max-flow\"\"\"\n        INF = MyList([10**9] * self.D)\n        maxflow = self.zero()\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = MyList([0] * self.V)\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > self.zero():\n                    maxflow += flow\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if e.cap > self.zero() and self.level[vertex] < self.level[e.to]:\n                if flow > e.cap:\n                    d = self.dfs(e.to, sink, e.cap)\n                else:\n                    d = self.dfs(e.to, sink, flow)\n                if d > self.zero():\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return self.zero()\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if e.cap > self.zero() and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\n\n\ndef to_poly(a, l):\n    if l == 0:\n        return str(a)\n    elif l == 1:\n        return \"{}x\".format('' if a == 1 else a)\n    else:\n        return \"{}x^{}\".format('' if a == 1 else a, l)\n\nwhile True:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    mf = MaxFlow(N, 51)\n    for _ in range(M):\n        u, v, p = input().split()\n        u, v = int(u)-1, int(v)-1\n        poly = MyList([0] * 51)\n        for x in p.split('+'):\n            try:\n                num = int(x)\n                poly[-1] = num\n            except ValueError:\n                a, l = x.split('x')\n                if l:\n                    poly[-int(l.strip(\"^\"))-1] = int(a) if a else 1\n                else:\n                    poly[-2] = int(a) if a else 1\n        mf.add_edge(u, v, poly)\n        mf.add_edge(v, u, poly)\n    maxflow = mf.dinic(0, N-1)\n    ans = '+'.join(to_poly(a, l) for a, l in zip(maxflow, reversed(range(51))) if a)\n    print(ans if ans else 0)"
  },
  {
    "language": "Python",
    "code": "import collections\n\n\nclass MyList(list):\n    def __init__(self, x=[]):\n        list.__init__(self, x)\n\n    def __iadd__(self, A):\n        ret = MyList()\n        for a, b in zip(self, A):\n            ret.append(a + b)\n        return ret\n\n    def __isub__(self, A):\n        ret = MyList()\n        for a, b in zip(self, A):\n            ret.append(a - b)\n        return ret\n\n    def __gt__(self, A):\n        for a, b in zip(self, A):\n            if a != b:\n                return a > b\n        return False\n\n\nclass MaxFlow:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V, D):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        self.D = D\n\n    def zero(self):\n        return MyList([0] * self.D)\n\n    def add_edge(self, fr, to, cap):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to])))\n        self.E[to].append(self.Edge(fr, self.zero(), len(self.E[fr])-1))\n\n    def dinic(self, source, sink):\n        \"\"\"find max-flow\"\"\"\n        INF = MyList([10**9] * self.D)\n        maxflow = self.zero()\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = MyList([0] * self.V)\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > self.zero():\n                    maxflow += flow\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if e.cap > self.zero() and self.level[vertex] < self.level[e.to]:\n                if flow > e.cap:\n                    d = self.dfs(e.to, sink, e.cap)\n                else:\n                    d = self.dfs(e.to, sink, flow)\n                if d > self.zero():\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return self.zero()\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if e.cap > self.zero() and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\n\n\ndef to_poly(a, l):\n    if l == 0:\n        return str(a)\n    elif l == 1:\n        return \"{}x\".format('' if a == 1 else a)\n    else:\n        return \"{}x^{}\".format('' if a == 1 else a, l)\n\nwhile True:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    mf = MaxFlow(N, 51)\n    for _ in range(M):\n        u, v, p = input().split()\n        u, v = int(u)-1, int(v)-1\n        poly = MyList([0] * 51)\n        for x in p.split('+'):\n            try:\n                num = int(x)\n                poly[-1] = num\n            except ValueError:\n                a, l = x.split('x')\n                if l:\n                    poly[-int(l.strip(\"^\"))-1] = int(a) if a else 1\n                else:\n                    poly[-2] = int(a) if a else 1\n        mf.add_edge(u, v, poly)\n        mf.add_edge(v, u, poly)\n    maxflow = mf.dinic(0, N-1)\n    ans = '+'.join(to_poly(a, l) for a, l in zip(maxflow, reversed(range(51))) if a)\n    print(ans if ans else 0)"
  }
]