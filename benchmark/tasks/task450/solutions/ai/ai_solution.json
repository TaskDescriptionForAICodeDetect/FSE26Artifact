[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int u, v, cost;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    return edgeA->cost - edgeB->cost;\n}\n\nint find(int parent[], int i) {\n    if (parent[i] != i) {\n        parent[i] = find(parent, parent[i]);\n    }\n    return parent[i];\n}\n\nvoid unionSets(int parent[], int rank[], int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n\n    if (rank[xroot] < rank[yroot]) {\n        parent[xroot] = yroot;\n    } else if (rank[xroot] > rank[yroot]) {\n        parent[yroot] = xroot;\n    } else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint kruskal(Edge edges[], int n, int m) {\n    qsort(edges, m, sizeof(Edge), compare);\n\n    int *parent = (int *)malloc(n * sizeof(int));\n    int *rank = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int totalCost = 0;\n    int bridgesBuilt = 0;\n\n    for (int i = 0; i < m && bridgesBuilt < n - 1; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n\n        int uroot = find(parent, u);\n        int vroot = find(parent, v);\n\n        if (uroot != vroot) {\n            unionSets(parent, rank, uroot, vroot);\n            totalCost += edges[i].cost;\n            bridgesBuilt++;\n        }\n    }\n\n    free(parent);\n    free(rank);\n\n    if (bridgesBuilt == n - 1) {\n        return totalCost;\n    } else {\n        return -1;\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    Edge *edges = (Edge *)malloc(m * sizeof(Edge));\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].cost);\n        edges[i].u--;\n        edges[i].v--;\n    }\n\n    int result = kruskal(edges, n, m);\n\n    if (result != -1) {\n        printf(\"%d\\n\", result);\n    } else {\n        printf(\"No solution\\n\");\n    }\n\n    free(edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n    Edge(int u, int v, int cost) : u(u), v(v), cost(cost) {}\n    bool operator<(const Edge &other) const {\n        return cost < other.cost;\n    }\n};\n\nstruct DSU {\n    vector<int> parent, rank;\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n    }\n    int find(int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    }\n    bool unite(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v) return false;\n        if (rank[u] < rank[v])\n            parent[u] = v;\n        else {\n            parent[v] = u;\n            if (rank[u] == rank[v])\n                rank[u]++;\n        }\n        return true;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Edge> edges;\n    for (int i = 0; i < m; ++i) {\n        int u, v, cost;\n        cin >> u >> v >> cost;\n        edges.emplace_back(u, v, cost);\n    }\n    sort(edges.begin(), edges.end());\n    DSU dsu(n);\n    int total_cost = 0;\n    for (const Edge &e : edges) {\n        if (dsu.unite(e.u, e.v)) {\n            total_cost += e.cost;\n        }\n    }\n    cout << total_cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:36:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n\n    public UnionFind(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    public boolean union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) {\n            return false;\n        }\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return true;\n    }\n}\n\nclass Bridge implements Comparable<Bridge> {\n    int u, v, cost;\n\n    public Bridge(int u, int v, int cost) {\n        this.u = u;\n        this.v = v;\n        this.cost = cost;\n    }\n\n    @Override\n    public int compareTo(Bridge other) {\n        return Integer.compare(this.cost, other.cost);\n    }\n}\n\npublic class SinkingIslands {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<Bridge> bridges = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int cost = scanner.nextInt();\n            bridges.add(new Bridge(u, v, cost));\n        }\n\n        Collections.sort(bridges);\n        UnionFind uf = new UnionFind(n);\n        int totalCost = 0;\n        int bridgesBuilt = 0;\n\n        for (Bridge bridge : bridges) {\n            if (uf.union(bridge.u, bridge.v)) {\n                totalCost += bridge.cost;\n                bridgesBuilt++;\n                if (bridgesBuilt == n - 1) {\n                    break;\n                }\n            }\n        }\n\n        if (bridgesBuilt == n - 1) {\n            System.out.println(totalCost);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:37:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass SinkingIslands {\n    static class Edge implements Comparable<Edge> {\n        int src, dest, weight;\n        \n        Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n        \n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n    \n    static class DisjointSet {\n        int[] parent, rank;\n        \n        DisjointSet(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n    \n    public static int minimumBridgeCost(int n, int[][] connections) {\n        List<Edge> edges = new ArrayList<>();\n        \n        for (int[] connection : connections) {\n            edges.add(new Edge(connection[0], connection[1], connection[2]));\n        }\n        \n        Collections.sort(edges);\n        \n        DisjointSet ds = new DisjointSet(n);\n        int totalCost = 0;\n        \n        for (Edge edge : edges) {\n            if (ds.find(edge.src) != ds.find(edge.dest)) {\n                ds.union(edge.src, edge.dest);\n                totalCost += edge.weight;\n            }\n        }\n        \n        int connectedComponents = 0;\n        for (int i = 0; i < n; i++) {\n            if (ds.find(i) == i) {\n                connectedComponents++;\n            }\n        }\n        \n        return connectedComponents > 1 ? -1 : totalCost;\n    }\n    \n    public static void main(String[] args) {\n        int n = 4;\n        int[][] connections = {{0, 1, 5}, {1, 2, 3}, {2, 3, 4}, {0, 3, 2}};\n        \n        int result = minimumBridgeCost(n, connections);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:37:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_ISLANDS 100\n#define INFINITY 99999\n\ntypedef struct {\n    int parent;\n    int rank;\n} DisjointSet;\n\nint compareEdges(const void* a, const void* b) {\n    return (*(int**)a)[2] - (*(int**)b)[2];\n}\n\nvoid initializeSet(DisjointSet* sets, int n) {\n    for (int i = 0; i < n; i++) {\n        sets[i].parent = i;\n        sets[i].rank = 0;\n    }\n}\n\nint findSet(DisjointSet* sets, int x) {\n    if (sets[x].parent != x) {\n        sets[x].parent = findSet(sets, sets[x].parent);\n    }\n    return sets[x].parent;\n}\n\nvoid unionSets(DisjointSet* sets, int x, int y) {\n    int rootX = findSet(sets, x);\n    int rootY = findSet(sets, y);\n\n    if (rootX == rootY) return;\n\n    if (sets[rootX].rank < sets[rootY].rank) {\n        sets[rootX].parent = rootY;\n    } else if (sets[rootX].rank > sets[rootY].rank) {\n        sets[rootY].parent = rootX;\n    } else {\n        sets[rootY].parent = rootX;\n        sets[rootX].rank++;\n    }\n}\n\nint kruskalMST(int** edges, int edgeCount, int islandCount) {\n    DisjointSet sets[MAX_ISLANDS];\n    int totalCost = 0;\n\n    initializeSet(sets, islandCount);\n    qsort(edges, edgeCount, sizeof(int*), compareEdges);\n\n    for (int i = 0; i < edgeCount; i++) {\n        int u = edges[i][0];\n        int v = edges[i][1];\n        int cost = edges[i][2];\n\n        if (findSet(sets, u) != findSet(sets, v)) {\n            unionSets(sets, u, v);\n            totalCost += cost;\n        }\n    }\n\n    int firstSet = findSet(sets, 0);\n    for (int i = 1; i < islandCount; i++) {\n        if (findSet(sets, i) != firstSet) {\n            return -1;\n        }\n    }\n\n    return totalCost;\n}\n\nint main() {\n    int islandCount, edgeCount;\n    scanf(\"%d %d\", &islandCount, &edgeCount);\n\n    int** edges = malloc(edgeCount * sizeof(int*));\n    for (int i = 0; i < edgeCount; i++) {\n        edges[i] = malloc(3 * sizeof(int));\n        scanf(\"%d %d %d\", &edges[i][0], &edges[i][1], &edges[i][2]);\n    }\n\n    int minBridgeCost = kruskalMST(edges, edgeCount, islandCount);\n\n    if (minBridgeCost == -1) {\n        printf(\"Impossible\\n\");\n    } else {\n        printf(\"%d\\n\", minBridgeCost);\n    }\n\n    for (int i = 0; i < edgeCount; i++) {\n        free(edges[i]);\n    }\n    free(edges);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:37:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nclass UnionFind {\nprivate:\n    std::vector<int> parent;\n    std::vector<int> rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        std::iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    bool unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX == rootY) return false;\n\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return true;\n    }\n};\n\nstruct Edge {\n    int from;\n    int to;\n    int cost;\n\n    bool operator<(const Edge& other) const {\n        return cost < other.cost;\n    }\n};\n\nint minimumBridgeCost(int n, std::vector<Edge>& edges) {\n    std::sort(edges.begin(), edges.end());\n    UnionFind uf(n);\n    int totalCost = 0;\n    int connectedIslands = 0;\n\n    for (const auto& edge : edges) {\n        if (uf.unionSets(edge.from, edge.to)) {\n            totalCost += edge.cost;\n            connectedIslands++;\n            \n            if (connectedIslands == n - 1) break;\n        }\n    }\n\n    return (connectedIslands == n - 1) ? totalCost : -1;\n}\n\nint main() {\n    int n = 4;  // Number of islands\n    std::vector<Edge> edges = {\n        {0, 1, 10},\n        {0, 2, 6},\n        {0, 3, 5},\n        {1, 3, 15},\n        {2, 3, 4}\n    };\n\n    int result = minimumBridgeCost(n, edges);\n    std::cout << \"Minimum bridge construction cost: \" << result << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:37:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            if self.rank[root_u] > self.rank[root_v]:\n                self.parent[root_v] = root_u\n            elif self.rank[root_u] < self.rank[root_v]:\n                self.parent[root_u] = root_v\n            else:\n                self.parent[root_v] = root_u\n                self.rank[root_u] += 1\n            return True\n        return False\n\ndef minimum_cost_to_connect_islands(n, connections):\n    # Sort connections by cost (structure: [cost, island1, island2])\n    connections.sort()\n    uf = UnionFind(n)\n    \n    total_cost = 0\n    num_edges_used = 0\n    \n    for cost, island1, island2 in connections:\n        if uf.union(island1, island2):\n            total_cost += cost\n            num_edges_used += 1\n            if num_edges_used == n - 1:\n                break\n                \n    if num_edges_used != n - 1:\n        return -1\n    \n    return total_cost\n\n# Example usage:\n# Number of islands\nn = 5\n# Connections list, each element is [cost, island1, island2]\nconnections = [\n    [1, 0, 1],\n    [2, 0, 2],\n    [3, 1, 2],\n    [4, 1, 3],\n    [2, 3, 4],\n    [6, 0, 4]\n]\n\nprint(minimum_cost_to_connect_islands(n, connections))",
    "timestamp": "2025-08-13 07:14:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nclass SinkingIslands {\n    static class Edge implements Comparable<Edge> {\n        int src, dest, weight;\n\n        public Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n\n        public int compareTo(Edge compareEdge) {\n            return this.weight - compareEdge.weight;\n        }\n    }\n\n    static class Subset {\n        int parent, rank;\n    }\n\n    int vertices;\n    List<Edge> edges;\n\n    SinkingIslands(int vertices) {\n        this.vertices = vertices;\n        edges = new ArrayList<>();\n    }\n\n    void addEdge(int src, int dest, int weight) {\n        edges.add(new Edge(src, dest, weight));\n    }\n\n    int find(Subset[] subsets, int i) {\n        if (subsets[i].parent != i)\n            subsets[i].parent = find(subsets, subsets[i].parent);\n        return subsets[i].parent;\n    }\n\n    void union(Subset[] subsets, int x, int y) {\n        int xroot = find(subsets, x);\n        int yroot = find(subsets, y);\n\n        if (subsets[xroot].rank < subsets[yroot].rank) {\n            subsets[xroot].parent = yroot;\n        } else if (subsets[xroot].rank > subsets[yroot].rank) {\n            subsets[yroot].parent = xroot;\n        } else {\n            subsets[yroot].parent = xroot;\n            subsets[xroot].rank++;\n        }\n    }\n\n    List<Edge> kruskalMST() {\n        List<Edge> result = new ArrayList<>();\n        Collections.sort(edges);\n\n        Subset[] subsets = new Subset[vertices];\n        for (int v = 0; v < vertices; v++) {\n            subsets[v] = new Subset();\n            subsets[v].parent = v;\n            subsets[v].rank = 0;\n        }\n\n        for (Edge edge : edges) {\n            int x = find(subsets, edge.src);\n            int y = find(subsets, edge.dest);\n\n            if (x != y) {\n                result.add(edge);\n                union(subsets, x, y);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int vertices = 4; // Example number of islands\n        SinkingIslands graph = new SinkingIslands(vertices);\n\n        graph.addEdge(0, 1, 10);\n        graph.addEdge(0, 2, 6);\n        graph.addEdge(0, 3, 5);\n        graph.addEdge(1, 3, 15);\n        graph.addEdge(2, 3, 4);\n\n        List<Edge> mst = graph.kruskalMST();\n        for (Edge edge : mst) {\n            System.out.println(edge.src + \" -- \" + edge.dest + \" == \" + edge.weight);\n        }\n    }\n}",
    "timestamp": "2025-08-13 07:14:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n// Define a structure for an edge between islands\ntypedef struct Edge {\n    int src, dest, cost;\n} Edge;\n\n// Define a structure for a subset for union-find\ntypedef struct Subset {\n    int parent;\n    int rank;\n} Subset;\n\n// Function to find the subset of an element i\nint find(Subset subsets[], int i) {\n    if (subsets[i].parent != i) {\n        subsets[i].parent = find(subsets, subsets[i].parent);\n    }\n    return subsets[i].parent;\n}\n\n// Function to do union of two subsets\nvoid unionSubsets(Subset subsets[], int x, int y) {\n    int rootX = find(subsets, x);\n    int rootY = find(subsets, y);\n\n    if (subsets[rootX].rank < subsets[rootY].rank) {\n        subsets[rootX].parent = rootY;\n    } else if (subsets[rootX].rank > subsets[rootY].rank) {\n        subsets[rootY].parent = rootX;\n    } else {\n        subsets[rootY].parent = rootX;\n        subsets[rootX].rank++;\n    }\n}\n\n// Function to compare edges based on their cost, used in sorting\nint compareEdges(const void* a, const void* b) {\n    Edge* edge1 = (Edge*)a;\n    Edge* edge2 = (Edge*)b;\n    return edge1->cost - edge2->cost;\n}\n\n// Function to calculate the minimal cost bridge construction using Kruskal's algorithm\nint minimalBridgeCost(int numIslands, Edge edges[], int numEdges) {\n    // Sort edges based on their cost\n    qsort(edges, numEdges, sizeof(Edge), compareEdges);\n\n    // Allocate space for subsets for union-find\n    Subset* subsets = (Subset*)malloc(numIslands * sizeof(Subset));\n    for (int i = 0; i < numIslands; i++) {\n        subsets[i].parent = i;\n        subsets[i].rank = 0;\n    }\n\n    int resultCost = 0;\n    int edgeCount = 0;\n    int e = 0;\n\n    // Consider each edge and select if it does not form a cycle\n    while (edgeCount < numIslands - 1 && e < numEdges) {\n        Edge nextEdge = edges[e++];\n\n        int x = find(subsets, nextEdge.src);\n        int y = find(subsets, nextEdge.dest);\n\n        if (x != y) {\n            resultCost += nextEdge.cost;\n            unionSubsets(subsets, x, y);\n            edgeCount++;\n        }\n    }\n\n    // Free allocated memory\n    free(subsets);\n\n    return resultCost;\n}\n\nint main() {\n    int numIslands = 4; // Example: 4 islands\n    Edge edges[] = {\n        {0, 1, 10},\n        {0, 2, 6},\n        {0, 3, 5},\n        {1, 3, 15},\n        {2, 3, 4}\n    };\n    int numEdges = sizeof(edges) / sizeof(edges[0]);\n\n    int cost = minimalBridgeCost(numIslands, edges, numEdges);\n    printf(\"Minimum cost to keep all islands accessible: %d\\n\", cost);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:14:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class DisjointSet:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True\n\ndef minimize_bridge_cost(n, edges):\n    edges.sort(key=lambda x: x[2])\n    ds = DisjointSet(n)\n    total_cost = 0\n    bridges_built = 0\n\n    for u, v, cost in edges:\n        if ds.union(u, v):\n            total_cost += cost\n            bridges_built += 1\n            if bridges_built == n - 1:\n                break\n\n    return total_cost if bridges_built == n - 1 else -1",
    "timestamp": "2025-08-13 07:14:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom heapq import heappop, heappush\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    \n    edges = []\n    for _ in range(M):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        w = int(input[ptr])\n        ptr += 1\n        edges.append((w, u, v))\n    \n    edges.sort()\n    \n    parent = [i for i in range(N)]\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        root_u = find(u)\n        root_v = find(v)\n        if root_u != root_v:\n            parent[root_v] = root_u\n    \n    total_cost = 0\n    for w, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            total_cost += w\n    \n    print(total_cost)\n\nsolve()",
    "timestamp": "2025-08-13 07:15:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n};\n\nbool compareEdge(const Edge &a, const Edge &b) {\n    return a.weight < b.weight;\n}\n\nclass DisjointSet {\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int u) {\n        if (u != parent[u]) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    void unionSets(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU != rootV) {\n            if (rank[rootU] < rank[rootV]) {\n                parent[rootU] = rootV;\n            } else if (rank[rootU] > rank[rootV]) {\n                parent[rootV] = rootU;\n            } else {\n                parent[rootV] = rootU;\n                rank[rootU]++;\n            }\n        }\n    }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n};\n\nint kruskalMST(int n, vector<Edge> &edges) {\n    sort(edges.begin(), edges.end(), compareEdge);\n    DisjointSet ds(n);\n\n    int mstWeight = 0;\n    for (const auto &edge : edges) {\n        int u = ds.find(edge.u);\n        int v = ds.find(edge.v);\n        if (u != v) {\n            mstWeight += edge.weight;\n            ds.unionSets(u, v);\n        }\n    }\n    return mstWeight;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Edge> edges(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].weight;\n        edges[i].u--; // to make it zero-based indexed\n        edges[i].v--;\n    }\n\n    cout << kruskalMST(n, edges);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:36:51"
  }
]