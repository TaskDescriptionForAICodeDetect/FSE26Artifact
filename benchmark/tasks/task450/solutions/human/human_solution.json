[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\n/***** Union-Find *****/\n\nconst int MAX_N = 10000;\nint Par[MAX_N];\nint Rank[MAX_N];\n\nvoid union_find_init(int n){\n\tfor(int i=0; i<n; ++i){\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(Par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)\n\t\treturn ;\n\n\tif(Rank[x] < Rank[y]){\n\t\tPar[x] = y;\n\t} else{\n\t\tPar[y] = x;\n\t\tif(Rank[x] == Rank[y]){\n\t\t\t++Rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\n/***** /Union-Find *****/\n\nstruct edge {\n\tint from,\n\t\tto,\n\t\tcost;\n    bool operator < (const edge &e) const { return cost < e.cost; }\n};\n\nvector<edge> es;\nint V, E;\n\n// time, vs\nvector<pair<int, VI>> falls;\n\nVB falled;\nVB linked;\n\n// ????????????????????¶????????????????????£????????????\nbool all_unite() {\n    int v = -1;\n    REP(i, 0, V) {\n        if (falled[i]) continue;\n\n        if (v == -1) {\n            v = i;\n        } else {\n            if (!same(v, i)) return false;\n        }\n    }\n    return true;\n}\n\n// ??¨??????????????£????????£????????¨?????????\nvoid link_new_edge() {\n    rep(i, E) {\n        edge &e = es[i];\n        if (linked[i]) continue;\n        if (falled[e.from] || falled[e.to]) continue;\n        if (!same(e.from, e.to)){\n            unite(e.from, e.to);\n            linked[i] = true;\n        }\n    }\n}\n\n// ??¨??????????????????\nvoid link_edge() {\n    rep(i, E) {\n        edge &e = es[i];\n        if (falled[e.from] || falled[e.to]) continue;\n        unite(e.from, e.to);\n    }\n}\n\n// ????¨??????????????±???????\nint sum_cost() {\n    int cost = 0;\n    rep(i, E) {\n        if (linked[i]) {\n            cost += es[i].cost;\n        }\n    }\n    return cost;\n}\n\nint solve() {\n    falled = VB(V);\n\n    sort(ALL(es));\n    sort(ALL(falls));\n\n    // ?????????????°???????????±???????\n    int end_i = 0;\n    for (; end_i < (int)falls.size(); end_i++) {\n        // ?????????\n        for (auto v : falls[end_i].snd) { falled[v] = true; }\n\n        union_find_init(V);\n        link_edge();\n\n        if (!all_unite()) { break; }\n    }\n\n    // ??¨?????¨?????§?????????\n    if (end_i == 0) return 0;\n\n    // ??´?????§????????????????????????\n    if (end_i != (int)falls.size()) {\n        for (auto v : falls[end_i].snd) { falled[v] = false; }\n    }\n\n    // ????????????????????????\n    linked = VB(E);\n    union_find_init(V);\n    for (int i = end_i - 1; i >= 0; i--) {\n        // ??????\n        for (auto v : falls[i].snd) { falled[v] = false; }\n\n        link_new_edge();\n    }\n    \n    return sum_cost();\n}\n\nint main(void) {\n    while (cin >> V >> E, V) {\n        // ??\\???\n        falls.clear();\n        falls.EB(0, VI());\n        rep(i, V) {\n            int h;\n            cin >> h;\n\n            auto it = find_if(ALL(falls), [h](const pair<int, VI> &x) {\n                    return h == x.fst; });\n            if (it == falls.end()) {\n                falls.EB(h, VI({i}));\n            } else {\n                falls[it - falls.begin()].snd.PB(i);\n            }\n        }\n\n        es.clear(); es.resize(E);\n        rep(i, E) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            --a; --b;\n            es[i].to = a;\n            es[i].from = b;\n            es[i].cost = c;\n        }\n        // ??\\??????????????§\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\n\nclass UnionFind{\npublic:\n    vector<int> par;\n    vector<int> rank;\n    UnionFind(int n){\n        init(n);\n    }\n    void init(int n){\n        par.resize(n);\n        for(int i=0;i<n;i++){\n            par[i] = i;\n        }\n        rank.assign(n, 0);\n    }\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x,int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n\n        if(rank[x] < rank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\nstruct edge{\n    int u, v, c;\n    edge(int u, int v, int c) : u(u), v(v), c(c) {}\n    bool operator<(const edge& right) const {\n        return c < right.c;\n    }\n};\n\nint N, M;\nvector<vector<edge>> G;\nvector<bool> used;\nvector<bool> alive;\n\nvoid dfs(int v){\n    used[v] = true;\n    for(edge& e : G[v]){\n        if(!used[e.v] && alive[e.v]) dfs(e.v);\n    }\n}\n\nbool is_connect(){\n    used.assign(N, false);\n    for(int i=0;i<N;i++){\n        if(alive[i]){\n            dfs(i);\n            break;\n        }\n    }\n    for(int i=0;i<N;i++){\n        if(alive[i] && !used[i]){\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(true){\n        cin >> N >> M;\n        if(N == 0) break;\n\n        vector<P> h(N);\n        for(int i=0;i<N;i++){\n            cin >> h[i].first;\n            h[i].second = i;\n        }\n        vector<edge> edges;\n        G.assign(N, {});\n        for(int i=0;i<M;i++){\n            int u, v, c;\n            cin >> u >> v >> c;\n            u--; v--;\n            G[u].emplace_back(u, v, c);\n            G[v].emplace_back(v, u, c);\n            edges.emplace_back(u, v, c);\n        }\n\n        sort(h.begin(), h.end());\n        alive.assign(N, true);\n        if(!is_connect()){\n            cout << 0 << endl;\n            continue;\n        }\n\n        int k = 0;\n        for(;k<N;k++){\n            alive[h[k].second] = false;\n            if(!is_connect()) break;\n        }\n\n        alive.assign(N, false);\n        for(int i=k+1;i<N;i++){\n            alive[h[i].second] = true;\n        }\n\n        sort(edges.begin(), edges.end());\n        UnionFind uf(N);\n        int ans = 0;\n        for(int i=min(k, N-1);i>=0;){\n            int t = h[i].first;\n            while(i >= 0 && h[i].first == t){\n                alive[h[i].second] = true;\n                i--;\n            }\n            for(edge& e : edges){\n                if(alive[e.u] && alive[e.v] && !uf.same(e.u, e.v)){\n                    uf.unite(e.u, e.v);\n                    ans += e.c;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親\n\tvector<int> sz; // 数\n\t// 初期化\n\tUF(int n):par(n),sz(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\nvector<pair<ll,pair<ll,ll>>> v;\nvector<pair<ll,ll>> h;\nll n,m;\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\th.clear();\n\t\tv.clear();\n\t\tREP(i,n){\n\t\t\tll tmp;cin >> tmp;\n\t\t\th.PB(MP(tmp,i));\n\t\t}\n\t\tREP(i,m){\n\t\t\tll a,b,c;cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv.PB(MP(c,MP(a,b)));\n\t\t}\n\t\t\t\t\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\tvector<int> jun(n);\n\t\tREP(i,n)jun[h[i].SE] = i;\n\n\t\tUF seica(n);\n\t\tREP(i,m){\n\t\t\tint A = v[i].SE.FI;\n\t\t\tint B = v[i].SE.SE;\n\t\t\tif(!seica.same(A,B)){\n\t\t\t\tseica.unite(A,B);\n\t\t\t}\n\t\t}\n\t\tif(seica.size(0) != n){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\tvector<bool> sink(n);\n\t\t\t\n\t\t\tint cou = 0;\n\t\t\twhile(1){\n\t\t\t\tint tmp = cou;\n\t\t\t\twhile(cou < n-1 && h[cou].FI == h[cou+1].FI){\n\t\t\t\t\tcou++;\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"before cou \" << cou << endl;)\n\t\t\t\tif(cou == n-1){\n\t\t\t\t\tcou = tmp - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tUF uf(n);\n\t\t\t\tREP(i,m){\n\t\t\t\t\tint A = v[i].SE.FI;\n\t\t\t\t\tint B = v[i].SE.SE;\n\t\t\t\t\tif(jun[A] > cou && jun[B] > cou && !uf.same(A,B)){\n\t\t\t\t\t\tuf.unite(A,B);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ma = 0;\n\t\t\t\tREP(i,n)ma = max(ma,uf.size(i));\n\t\t\t\tif(ma != n - cou -1){\n\t\t\t\t\tcou = tmp - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"after cou \" << cou << endl;)\n\t\t\t\tcou++;\n\t\t\t}\n\t\t\tDBG(cout << \"OUT CHECK \" << cou << endl;);\n\t\t\tll ans = 0;\n\t\t\tUF uf(n);\n\t\t\twhile(1){\n\t\t\t\tREP(i,m){\n\t\t\t\t\tint A = v[i].SE.FI;\n\t\t\t\t\tint B = v[i].SE.SE;\n\t\t\t\t\tif(jun[A] > cou && jun[B] > cou && !uf.same(A,B)){\n\t\t\t\t\t\tuf.unite(A,B);\n\t\t\t\t\t\tans += v[i].FI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"cou \" << cou << endl;)\n\t\t\t\tif(cou < 0)break;\n\t\t\t\twhile(cou > 0 && h[cou].FI == h[cou-1].FI)cou--;\n\t\t\t\tcou--;\n\t\t\t}\n\t\t\t\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2511&lang=jp\n// references : http://mayokoex.hatenablog.com/entry/2016/05/03/233156\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n#define MAXT 1000100\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n\tedge() {}\n\tedge(int f, int t, int c) :from(f), to(t), cost(c) {}\n\tbool operator < (const edge& o) const { return cost < o.cost; }\n};\n\nstruct UnionFind {\n\tvector<int> par;\n\tint n, cnt;\n\tUnionFind(const int& x = 0) { init(x); }\n\tvoid init(const int& x) { par.assign(cnt = n = x, -1); }\n\tinline int find(const int& x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tinline bool same(const int& x, const int& y) { return find(x) == find(y); }\n\tinline bool unite(int x, int y) {\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\t--cnt;\n\t\tif (par[x] > par[y]) swap(x, y);\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\tinline int count() const { return cnt; }\n\tinline int count(int x) { return -par[find(x)]; }\n};\n\nvector<int> h[MAXT];\nvector<edge> G;\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M;\n\twhile (cin >> N >> M, N | M) {\n\n\t\tfor (int t = 0; t < MAXT;t++)h[t].clear();\n\t\tfor (int i = 0; i < N; i++) { int t; cin >> t; h[t].push_back(i); }\n\t\tG.clear();\n\t\tfor (int i = 0; i < M;i++) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tG.push_back(edge(a, b, c));\n\t\t}\n\t\tsort(G.begin(), G.end());\n\t\t\n\t\tUnionFind uf(N);\n\t\tfor (auto e : G) uf.unite(e.from, e.to);\n\t\tif (uf.count() > 1) { cout << 0 << endl; continue; }\n\n\t\tvector<int> f(N, 0);\n\t\tint cnt = 1;\n\t\tint last_t = -1;\n\t\tfor (int t = 0; t < MAXT;t++) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) { f[n] = 1; cnt++; }\n\t\t\tUnionFind uf(N);\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (f[e.from] == 1 || f[e.to] == 1)continue;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\t\t\tif (uf.count() != cnt) { last_t = t; break; }\n\t\t}\n\t\tif (last_t == -1)last_t = MAXT;\n\n\t\tuf = UnionFind(N);\n\t\tfor (int i = 0; i < N;i++)f[i] = 0;\n\t\tll ans = 0;\n\t\tfor (int t = last_t; t < MAXT;t++)for (auto n : h[t]) f[n] = 1;\n\t\t/* Minimum spanning tree */\n\t\tfor (auto e : G) {\n\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t}\n\t\t/*----------------------*/\n\n\t\tfor (int t = last_t - 1; t >= 0;t--) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) f[n] = 1;\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <functional>\n#include <stack>\n#include <utility>\n#include <map>\n#include <queue>\n#include <set>\n#include <array>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst ll MOD = ll(1e9) + 7;\nconst ll INF = LLONG_MAX;\nconst ll MAX_N = ll(1e5) + 5;\nconst double EPS = 10e-8;\nconst double PI = 3.14159265359;\n\n#define REP(i, n) for (ll i = 0; i < n; i++)\n#define REPR(i, n) for (ll i = n; i >= 0; i--)\n#define FOR(i, m, n) for (ll i = m; i < n; i++)\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\n#define MAX_E 50000\n\nstruct edge {\n    int u, v, cost;\n};\n\nint n, m, nalive;\nvector<edge> path[201];\nvector<P> h;\nbool is_sinked[201];\nvector<int> ok;\n\nclass UnionFindTree {\n    static const int MAX_V = 100000;\n    int par[MAX_V];\n    int rank[MAX_V];\n\n   public:\n    void init(int n) {\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\nbool comp(const edge &e1, const edge &e2) { return e1.cost < e2.cost; }\n\nvector<edge> es;\n\nint kruskal() {\n    sort(es.begin(), es.end(), comp);\n    UnionFindTree a;\n    a.init(n);\n    for (int i = 1; i < ok.size(); i++) {\n        a.unite(ok[i - 1], ok[i]);\n    }\n    int res = 0;\n    for (int i = 0; i < es.size(); i++) {\n        edge e = es[i];\n        if (!a.same(e.u, e.v) && !is_sinked[e.v]) {\n            a.unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nbool is_connected() {\n    int start = 0, cnt = 0;\n    for (; start < n; start++)\n        if (!is_sinked[start]) break;\n    queue<int> que;\n    vector<bool> visited(n + 1);\n    for (int i = 0; i <= n; i++) visited[i] = false;\n\n    visited[start] = true;\n    que.push(start);\n\n    while (!que.empty()) {\n        int cur = que.front();\n        que.pop();\n        for (auto next : path[cur]) {\n            if (!visited[next.v] && !is_sinked[next.v]) {\n                visited[next.v] = true;\n                que.push(next.v);\n            }\n        }\n        cnt++;\n    }\n    return cnt == nalive;\n}\n\nint main() {\n    while (1) {\n        cin >> n >> m;\n        int ans = 0;\n        ok.clear();\n        for (int i=0;i<n;i++) path[i].clear();\n        fill(is_sinked, is_sinked + n, false);\n        h.clear();\n        if (n == 0) break;\n        REP(i, n) {\n            int tmp;\n            cin >> tmp;\n            h.push_back({tmp, i});\n        }\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--;\n            b--;\n            path[a].push_back({a, b, c});\n            path[b].push_back({b, a, c});\n        }\n        sort(h.begin(), h.end());\n\n        int inum = 0;\n        nalive = n;\n        while (is_connected()) {\n            P tmp = h[inum];\n            while (inum < n && tmp.first == h[inum].first) {\n                is_sinked[h[inum].second] = true;\n                nalive--;\n                inum++;\n            }\n        }\n\n        es.clear();\n        inum--;\n        if(nalive==n){\n            cout << 0 << endl;\n            continue;\n        }\n        if (inum >= 0) {\n            P tmp = h[inum];\n            while (inum >= 0 && tmp.first == h[inum].first) {\n                is_sinked[h[inum].second] = false;\n                nalive++;\n                inum--;\n            }\n        }\n        REP(i, n) {\n            if (!is_sinked[i]) {\n                for (auto tmp : path[i]) {\n                    es.push_back(tmp);\n                }\n            }\n        }\n        ans += kruskal();\n        REP(i, n) {\n            if (!is_sinked[i]) ok.push_back(i);\n        }\n\n        while (inum >= 0) {\n            es.clear();\n            vector<int> ls;\n            if (inum >= 0) {\n                P tmp = h[inum];\n                while (inum >= 0 && tmp.first == h[inum].first) {\n                    is_sinked[h[inum].second] = false;\n                    nalive++;\n                    ls.push_back(h[inum].second);\n                    inum--;\n                }\n            }\n            for (int i = 0; i < ls.size(); i++) {\n                if (!is_sinked[ls[i]]) {\n                    for (auto tmp : path[ls[i]]) {\n                        es.push_back(tmp);\n                    }\n                }\n            }\n            ans += kruskal();\n            for (int i = 0; i < ls.size(); i++) {\n                if (!is_sinked[ls[i]]) \n                    ok.push_back(ls[i]);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tint n;\n\tvector<int> v;\n\t\n\tUnionFind(int n) : n(n){\n\t\tv.resize(n);\n\t\tfill(v.begin(), v.end(), -1);\n\t}\n\t\n\tint find(int x){\n\t\tif (v[x] < 0){\n\t\t\treturn (x);\n\t\t}\n\t\treturn (v[x] = find(v[x]));\n\t}\n\tbool same(int x, int y){\n\t\treturn (find(x) == find(y));\n\t}\n\tvoid merge(int x, int y){\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tv[y] += v[x];\n\t\tv[x] = y;\n\t}\n\tint size(int x){\n\t\treturn (-v[find(x)]);\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\t\n\twhile (scanf(\"%d %d\", &n, &m) && n){\n\t\tint h[1024], a[200 * 200], b[200 * 200], c[200 * 200], d[200 * 200] = {0};\n\t\tint hrec[1024], alive[1024], dead[1024] = {0};\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", h + i);\n\t\t\threc[i] = h[i];\n\t\t\talive[i] = 0;\n\t\t}\n\t\t\n\t\tsort(hrec, hrec + n);\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d %d %d\", a + i, b + i, c + i);\n\t\t\t--a[i]; --b[i];\n\t\t}\n\t\tint x = n - 2;\n\t\t\n\t\tfor (int i = 0; i < n - 1; i++){\n\t\t\tif (hrec[i] == hrec[i + 1]) continue;\n\t\t\tUnionFind tmp(n);\n\t\t\tint v;\n\t\t\t\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (h[j] == hrec[i]) dead[j] = true;\n\t\t\t\tif (!dead[j]) v = j;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (!dead[a[j]] && !dead[b[j]]) tmp.merge(a[j], b[j]);\n\t\t\t}\n\t\t\t\n\t\t\tif (tmp.size(v) != n - i - 1){\n\t\t\t\tx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint tot = 0;\n\t\t\n\t\tUnionFind uf(n);\n\t\tpriority_queue<pair<int, pair<int, int> >, vector<pair<int, pair<int, int> > >, greater<pair<int, pair<int, int> > > > pq;\n\t\t\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tint tmp, cnt = 0;\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (hrec[i] == h[j]) alive[j] = true;\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (alive[a[j]] && alive[b[j]] && !d[j]){\n\t\t\t\t\td[j] = 1;\n\t\t\t\t\tpq.push(make_pair(c[j], make_pair(a[j], b[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > x) continue;\n\t\t\tfor (; !pq.empty(); pq.pop()){\n\t\t\t\tpair<int, pair<int, int> > x = pq.top();\n\t\t\t\tif (!uf.same(x.second.first, x.second.second)){\n\t\t\t\t\tuf.merge(x.second.first, x.second.second);\n\t\t\t\t\ttot += x.first;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (uf.size(0) == n) printf(\"%d\\n\", tot);\n\t\telse printf(\"0\\n\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n  int x, hour;\n  node(){}\n  node(int x, int hour):x(x), hour(hour){}\n  bool operator < (const node& u) const {\n    return hour < u.hour;\n  }\n};\n\nstruct edge{\n  int u, v, cost;\n  edge(){}\n  edge(int u, int v, int cost):u(u), v(v), cost(cost){}\n  bool operator < (const edge& e) const {\n    return cost < e.cost;\n  }\n};\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n  int find(int k)\n  {\n    if(data[k] < 0) return k;\n    return data[k] = find(data[k]);\n  }\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y){\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n  int size(int k)\n  {\n    return -data[find(k)];\n  }\n};\n\nint main()\n{\n  int N, M;\n  while(cin >> N >> M, N || M){\n    vector<node> V;\n    vector<edge> E;\n    for(int i = 0; i < N; i++){\n      int h; cin >> h;\n      V.push_back(node(i, h));\n    }\n    for(int i = 0; i < M; i++){\n      int a, b, c; cin >> a >> b >> c; a--, b--;\n      E.push_back(edge(a, b, c));\n    }\n    sort(V.rbegin(), V.rend());\n    sort(E.begin(), E.end());\n    int dis = N+1; //????????????dis????????§??????MSP????????????\n    for(int i = N; i > 0; i--){\n      UnionFind msp(N);\n      vector<bool> exist(N, false);\n      for(int j = 0; j < i; j++) exist[V[j].x] = true;\n      for(int j = 0; j < M; j++){\n\tif(exist[E[j].u] && exist[E[j].v] && !msp.same(E[j].u, E[j].v)){\n\t  msp.unite(E[j].u, E[j].v);\n\t}\n      }\n      if(msp.size(V[0].x) == i) dis = i;\n      else break;\n    }\n    vector<bool> used(N, false);\n    UnionFind uf(N);\n    long long ans = 0LL;\n    for(int i = 0; i < dis; i++) used[V[i].x] = true;\n    for(int i = dis-1; i < N; i++){ //???????????§????????¶????£?????????????????????????????????????\n      used[V[i].x] = true;\n      for(int j = 0; j < M; j++){\n\tif(used[E[j].u] && used[E[j].v] && !uf.same(E[j].u, E[j].v)){\n\t  uf.unite(E[j].u, E[j].v);\n\t  ans += E[j].cost;\n\t}\n      }\n    }\t\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tint n;\n\tvector<int> v;\n\t\n\tUnionFind(int n) : n(n){\n\t\tv.resize(n);\n\t\tfill(v.begin(), v.end(), -1);\n\t}\n\t\n\tint find(int x){\n\t\tif (v[x] < 0){\n\t\t\treturn (x);\n\t\t}\n\t\treturn (v[x] = find(v[x]));\n\t}\n\tbool same(int x, int y){\n\t\treturn (find(x) == find(y));\n\t}\n\tvoid merge(int x, int y){\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tv[y] += v[x];\n\t\tv[x] = y;\n\t}\n\tint size(int x){\n\t\treturn (-v[find(x)]);\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\t\n\twhile (scanf(\"%d %d\", &n, &m) && n){\n\t\tint h[1024], a[2048], b[2048], c[2048], d[2048] = {0};\n\t\tint hrec[1024], alive[1024], dead[1024] = {0};\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", h + i);\n\t\t\threc[i] = h[i];\n\t\t\talive[i] = 0;\n\t\t}\n\t\t\n\t\tsort(hrec, hrec + n);\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d %d %d\", a + i, b + i, c + i);\n\t\t\t--a[i]; --b[i];\n\t\t}\n\t\tint x = n - 2;\n\t\t\n\t\tfor (int i = 0; i < n - 1; i++){\n\t\t\tif (hrec[i] == hrec[i + 1]) continue;\n\t\t\tUnionFind tmp(n);\n\t\t\tint v;\n\t\t\t\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (h[j] == hrec[i]) dead[j] = true;\n\t\t\t\tif (!dead[j]) v = j;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (!dead[a[j]] && !dead[b[j]]) tmp.merge(a[j], b[j]);\n\t\t\t}\n\t\t\t\n\t\t\tif (tmp.size(v) != n - i - 1){\n\t\t\t\tx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint tot = 0;\n\t\t\n\t\tUnionFind uf(n);\n\t\tpriority_queue<pair<int, pair<int, int> >, vector<pair<int, pair<int, int> > >, greater<pair<int, pair<int, int> > > > pq;\n\t\t\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tint tmp, cnt = 0;\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (hrec[i] == h[j]) alive[j] = true;\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (alive[a[j]] && alive[b[j]] && !d[j]){\n\t\t\t\t\td[j] = 1;\n\t\t\t\t\tpq.push(make_pair(c[j], make_pair(a[j], b[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > x) continue;\n\t\t\tfor (; !pq.empty(); pq.pop()){\n\t\t\t\tpair<int, pair<int, int> > x = pq.top();\n\t\t\t\tif (!uf.same(x.second.first, x.second.second)){\n\t\t\t\t\tuf.merge(x.second.first, x.second.second);\n\t\t\t\t\ttot += x.first;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (uf.size(0) == n) printf(\"%d\\n\", tot);\n\t\telse printf(\"0\\n\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> par, sz;\n\n\tUnionFind(int N) : par(N), sz(N, 1) {\n\t\tiota(par.begin(), par.end(), 0);\n\t}\n\n\tint find(int v) {\n\t\treturn (par[v] == v ? v : par[v] = find(par[v]));\n\t}\n\n\tvoid unite(int u, int v) {\n\t\tu = find(u), v = find(v);\n\t\tif (sz[u] < sz[v]) swap(u, v);\n\t\tpar[v] = u;\n\t\tsz[u] += sz[v];\n\t}\n};\n\nstruct Edge {\n\tint u, v, c;\n\tEdge(int u = 0, int v = 0, int c = 0) \n\t\t: u(u), v(v), c(c){}\n};\n\nvoid compress(vector<int>& v) {\n\tvector<int> w = v;\n\tsort(w.begin(), w.end());\n\tw.erase(unique(w.begin(), w.end()), w.end());\n\tmap<int, int> mp;\n\tfor(int i = 0; i < w.size(); ++i) {\n\t\tmp[w[i]] = i;\n\t}\n\tfor(auto& e : v) e = mp[e];\n}\n\nbool solve() {\n\tint N, M;\n\tcin >> N >> M;\n\tif (N == 0) return false;\n\n\tvector<int> H(N);\n\tfor(auto& h : H) cin >> h;\n\n\tcompress(H);\n\tint HMAX = *max_element(H.begin(), H.end());\n\n\tvector<Edge> edges(M);\n\tfor(auto& e : edges) {\n\t\tcin >> e.u >> e.v >> e.c;\n\t\t--e.u, --e.v;\n\t}\n\n\tsort(edges.begin(), edges.end(), [](Edge a, Edge b){\n\t\treturn a.c < b.c;\n\t});\n\n\tset<int> vs;\n\tint T = -1;\n\tfor(int t = HMAX; t >= 0; --t) {\n\t\tbool upd = false;\n\t\tfor(int v = 0; v < N; ++v) {\n\t\t\tif (H[v] == t) {\n\t\t\t\tvs.insert(v);\n\t\t\t\tupd = true;\n\t\t\t}\n\t\t}\n\t\tif (!upd) continue;\n\n\t\tUnionFind uf(N);\n\t\tfor(auto e : edges) {\n\t\t\tif (vs.count(e.u) && vs.count(e.v)) {\n\t\t\t\tuf.unite(e.u, e.v);\n\t\t\t}\n\t\t}\n\n\t\tset<int> pars;\n\t\tfor(auto v : vs) {\n\t\t\tpars.insert(uf.find(v));\n\t\t}\n\n\t\tif (pars.size() > 1) {\n\t\t\tT = -1;\n\t\t} else if (T < 0) {\n\t\t\tT = t;\n\t\t}\n\t}\n\n\tif (T < 0) {\n\t\tcout << 0 << endl;\n\t\treturn true;\n\t}\n\n\tvs.clear();\n\tfor(int v = 0; v < N; ++v) {\n\t\tif (H[v] >= T) vs.insert(v);\n\t}\n\n\tint ans = 0;\n\tUnionFind uf(N);\n\tfor(auto e : edges) {\n\t\tif (vs.count(e.u) && vs.count(e.v) &&\n\t\t\tuf.find(e.u) != uf.find(e.v)) {\n\t\t\tuf.unite(e.u, e.v);\n\t\t\tans += e.c;\n\t\t}\n\t}\n\n\tfor(int t = T - 1; t >= 0; --t) {\n\t\tbool upd = false;\n\t\tfor(int v = 0; v < N; ++v) {\n\t\t\tif (H[v] == t) {\n\t\t\t\tvs.insert(v);\n\t\t\t\tupd = true;\n\t\t\t}\n\t\t}\n\t\tif (!upd) continue;\n\n\t\tfor(auto e : edges) {\n\t\t\tif (vs.count(e.u) && vs.count(e.v) &&\n\t\t\t\tuf.find(e.u) != uf.find(e.v)) {\n\t\t\t\tuf.unite(e.u, e.v);\n\t\t\t\tans += e.c;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn true;\n}\n\nint main() {\n\twhile (solve());\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nvector<pll> uft;\n\nll parent(ll a){\n    if(uft[a].F==a){return a;}\n    return uft[a].F=parent(uft[a].F);\n}\n\nvoid merge(ll a,ll b){\n    if(parent(a)==parent(b)){return;}\n    if(uft[parent(a)].S<uft[parent(b)].S){swap(a,b);}\n    uft[parent(a)].S+=uft[parent(b)].S;\n    uft[parent(b)].F=parent(a);\n}\n\ntypedef pair<ll,pll> P;\n\n\nint main(){\n    ll n,m;\n    while(cin>>n>>m,n){\n    uft.resize(n);\n    for(int i=0;i<n;i++){uft[i]={i,1};}\n    vector<pll> h(n);\n    for(int i=0;i<n;i++){cin>>h[i].F; h[i].S=i;}\n    sort(h.begin(),h.end());\n    vector<ll> R(n);\n    for(int i=0;i<n;i++){R[h[i].S]=i;}\n    vector<vector<pll>> edge(n);\n    for(int i=0;i<m;i++){\n        ll a,b,c;\n        cin>>a>>b>>c;\n        a=R[a-1];\n        b=R[b-1];\n        if(a>b){swap(a,b);}\n        edge[a].push_back({b,c});\n    }\n    ll H=h.back().F;\n    ll mi=E;\n    for(ll i=n-1;i>=0;){\n        ll t=i;\n        H=h[i].F;\n        while(t>=0 && h[t].F==H){\n            for(auto &e:edge[t]){\n                merge(t,e.F);\n            }\n            t--;\n        }\n        //cout<<i<<\" \"<<uft[parent(n-1)].S<<endl;\n        if(uft[parent(n-1)].S!=n-t-1){mi=H;}\n        i=t;\n    }\n    priority_queue<P,vector<P>,greater<P>> Q;\n    ll ans=0;\n    for(int i=0;i<n;i++){uft[i]={i,1};}\n    ll i=n-1;\n    while(i>=0 && h[i].F>=mi){\n        for(auto &e:edge[i]){\n            Q.push({e.S,{e.F,i}});\n        }\n        i--;\n    }\n    for(;i>=0;){\n        mi=h[i].F;\n        while(i>=0 && h[i].F>=mi){\n            for(auto &e:edge[i]){\n                Q.push({e.S,{e.F,i}});\n            }\n            i--;\n        }\n        while(!Q.empty()){\n            P e=Q.top(); Q.pop();\n            if(parent(e.S.F)!=parent(e.S.S)){ans+=e.F; merge(e.S.F,e.S.S);}\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n#define repn(i,s,n) for (int i=int(s); i < int(n); i++)\n#define rep(i,n) repn(i,0,n)\n#define repd(i,n) for (int i=int(n)-1; i >= 0; i--)\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\n\nstruct UnionFind {\n  vector<int> p; \n  UnionFind(int n) : p(n, -1) { };\n  void unite(int u, int v) {\n    if ((u = find(u)) == (v = find(v))) return;\n    if (p[u] > p[v]) swap(u, v);\n    p[u] += p[v]; p[v] = u;\n  }\n  bool same(int u, int v) { return find(u) == find(v); }\n  int find(int u) { return p[u] < 0 ? u : p[u] = find(p[u]); }\n  int size(int u) { return -p[find(u)]; }\n};\n\n\nint n, m;\nVI h;\nconst int H_MAX = 1000010;\n\nstruct Edge\n{\n  int a, b, cost;\n\n  int getSinkTime() const {\n    return min(h[a], h[b]);\n  }\n\n  bool operator<(const Edge& o) const {\n    int sinkTime = getSinkTime();\n    int oSinkTime = o.getSinkTime();\n    if (sinkTime != oSinkTime) return sinkTime > oSinkTime;  // 最後に沈むのを先に\n    return cost < o.cost;\n  }\n};\n\nvoid solve() {\n  vector<Edge> es;\n  h = VI(n);\n  VI numSunk(H_MAX);\n  rep(i, n) {\n    cin >> h[i];\n    numSunk[h[i]]++;\n  }\n  rep(i, H_MAX-1) numSunk[i+1] += numSunk[i];\n  rep(i, m) {\n    Edge e;\n    cin >> e.a >> e.b >> e.cost;\n    e.a--;\n    e.b--;\n    es.push_back(e);\n  }\n\n  // 最初に非連結になる時間を得る\n  sort(es.begin(), es.end());\n  UnionFind uf(n);\n  int count = 1;\n  int first_unconnected_h = H_MAX-1;\n  for (int ei = 0; ei < m; ei++) {\n    Edge& e = es[ei];\n    int numV = n - numSunk[e.getSinkTime()];\n    if (numV > count) first_unconnected_h = e.getSinkTime();\n    if (!uf.same(e.a, e.b)) {\n      count++;\n      uf.unite(e.a, e.b);\n    }\n  }\n  if (count < n) {\n    cout << 0 << endl;\n    return;\n  }\n\n  // 非連結になる時間に全部同時に沈むようにする\n  rep(i, n) {\n    h[i] = min(h[i], first_unconnected_h);\n  }\n\n  sort(es.begin(), es.end());\n  uf = UnionFind(n);\n  int min_cost = 0;\n\n  rep(ei, es.size()) {\n    Edge& e = es[ei];\n    if (!uf.same(e.a, e.b)) {\n      min_cost += e.cost;\n      uf.unite(e.a, e.b);\n    }\n  }\n\n  cout << min_cost << endl;\n}\n\nint main() {\n  while (cin >> n >> m, n||m) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank,Size;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tSize=vi(n,1);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tint Find_Size(int x){\n\t\treturn Size[Find_Par(x)];\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]){\n\t\t\tPar[x]=y;\n\t\t\tSize[y]+=Size[x];\n\t\t}\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tSize[x]+=Size[y];\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nconst int M=1000001;\n\nint n,m;\nvvi a;\nvi u,v,c;\nvip e;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(!n) break;\n\t\ta=vvi(M);\n\t\tu=v=c=vi(m);\n\t\te=vip(m);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint h;\n\t\t\tcin>>h;\n\t\t\ta[h].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>u[i]>>v[i]>>c[i];\n\t\t\tu[i]--;\n\t\t\tv[i]--;\n\t\t\te[i]={c[i],{u[i],v[i]}};\n\t\t}\n\t\tsort(e.begin(),e.end());\n\t\tll res=0,V=n;\n\t\tvi used(n,1);\n\t\tfor(int i=0;i<M;i++) if(!a[i].empty()){\n\t\t\tUnion_Find_Tree uft(n);\n\t\t\tint S=a[i].size();\n\t\t\tV-=S;\n\t\t\tfor(int j=0;j<S;j++) used[a[i][j]]=0;\n\t\t\tfor(int j=0;j<m;j++) if(used[u[j]]&&used[v[j]]){\n\t\t\t\t uft.Unite(u[j],v[j]);\n\t\t\t}\n\t\t\tbool B=1;\n\t\t\tfor(int j=0;j<n;j++) for(int k=0;k<n;k++) if(used[j]&&used[k]&&!uft.Same(j,k)) B=0;\n\t\t\tif(!V||!B){\n\t\t\t\tUnion_Find_Tree UFT(n);\n\t\t\t\tdo{\n\t\t\t\t\tS=a[i].size();\n\t\t\t\t\tfor(int j=0;j<S;j++) used[a[i][j]]=1;\n\t\t\t\t\tif(S){\n\t\t\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\t\t\tP p=e[j].second;\n\t\t\t\t\t\t\tint s=p.first,t=p.second;\n\t\t\t\t\t\t\tif(used[s]&&used[t]&&!UFT.Same(s,t)){\n\t\t\t\t\t\t\t\tres+=e[j].first;\n\t\t\t\t\t\t\t\tUFT.Unite(s,t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti--;\n\t\t\t\t}while(i>=0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<cassert>\n#include<set>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 3000\nusing namespace std;\n\nclass UnionFindTree\n{\npublic:\n  int par[MAX];\n\n  void init(int N){ rep(i,N)par[i] = i; }  \n\n  int find(int x)\n  {\n    if(par[x] == x)return x;\n    return par[x] = find(par[x]);\n  }\n\n  void unit(int x,int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x != y)par[x] = y;\n  }\n\n  bool same(int x,int y){ return find(x) == find(y); }\n\n};\n\nstruct edge\n{\n  int x,y,cost;\n  edge(int x=inf,int y=inf,int cost=inf):x(x),y(y),cost(cost){}\n  bool operator < (const edge& a)const\n  {\n    return cost < a.cost;\n  }\n};\n\nstruct P\n{\n  int h,identifier;\n  P(int h=inf,int identifier=inf):h(h),identifier(identifier){}\n  bool operator < (const P& a)const\n  {\n    if(h != a.h)return h > a.h;\n    return identifier < a.identifier;\n  }\n};\n\nint N,M;\n//vector<int> h,ph;\nvector<P> h;\nvector<int> H;\nvector<edge> G;\n\nbool check()\n{\n  UnionFindTree UTF;\n  UTF.init(N);\n  rep(i,G.size())\n    if(!UTF.same(G[i].x,G[i].y))\n      UTF.unit(G[i].x,G[i].y);\n  rep(i,N)UTF.find(i);\n  rep(i,N)if(UTF.par[i] != UTF.par[0])return false;\n  return true;\n}\n\nvoid compute()\n{\n  \n  if(!check())\n    {\n      cout << 0 << endl;\n      return;\n    }\n\n  sort(all(h));\n  sort(all(G));\n\n  UnionFindTree group;\n  group.init(N);\n  long long ans = 0;\n\n  rep(i,H.size())\n    {\n      //int TM = ph[i];\n      int TM = h[i].h;\n      UnionFindTree UTF;\n      UTF.init(N);\n      rep(j,G.size())\n\t{\n\t  int x = G[j].x;\n\t  int y = G[j].y;\n\t  if(H[x] < TM || H[y] < TM)continue;\n\t  if(!UTF.same(x,y))\n\t    {\n\t      UTF.unit(x,y);\n\t    }\n\t}\n\n      rep(j,N)if(TM <= H[j])UTF.find(j);\n      /*\n      set<int> out;\n      rep(j,N)if(h[j] >= TM && UTF.par[j] != j)out.insert(UTF.par[j]);\n      if(out.size() >= 2)\n\t{\n\t  ans = 0;\n\t  group.init(N);\n\t  continue;\n\t}\n      */\n      \n      bool cont = false;\n      for(int j=0;j<N;j++)if(TM <= H[j] && !UTF.same(h[0].identifier,j))\n\t\t\t    {\n\t\t\t      ans = 0;\n\t\t\t      group.init(N);\n\t\t\t      cont = true;\n\t\t\t      break;\n\t\t\t    }\n      if(cont)continue;\n\n      rep(j,G.size())\n\t{\n\t  int x = G[j].x;\n\t  int y = G[j].y;\n\t  if(H[x] < TM || H[y] < TM)continue;\n\t  if(!group.same(x,y))\n\t    {\n\t      //cout << TM << \" unit(\" << x+1 << \",\" << y+1 << \")\" << endl;\n\t      group.unit(x,y);\n\t      ans += G[j].cost;\n\t    }\n\t}\n      //cout << \"ans = \" << ans << endl;\n    }\n\n  cout << ans << endl;\n\n}\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      h.clear(),G.clear(),H.clear();\n      h.resize(N),G.resize(M),H.resize(N);\n      //rep(i,N)cin >> h[i],ph[i] = h[i];\n      rep(i,N)cin >> h[i].h,h[i].identifier = i,H[i] = h[i].h;\n      rep(i,M)cin >> G[i].x >> G[i].y >> G[i].cost,G[i].x--,G[i].y--;\n\n      compute();\n\n    }\n  return 0;\n}\n\n/*\nstruct P\n{\n  int h,identifier;\n  P(int h=inf,int identifier=inf):h(h),identifier(identifier){}\n  bool operator < (const P& a)const\n  {\n    if(h != a.h)return h > a.h;\n    return identifier < a.identifier;\n  }\n};\n\nstruct edge\n{\n  int x,y,cost;\n  edge(int x=inf,int y=inf,int cost=inf):x(x),y(y),cost(cost){}\n  bool operator < (const edge& a)const\n  {\n    return cost < a.cost;\n  }\n};\n\nint par[MAX];\nint N,M;\nvector<int> h,ph;\nvector<edge> vec;\n\nint find(int x)\n{\n  if(par[x] == x)return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x == y)return;\n  par[x] = y;\n}\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      \n      ph.clear(),h.clear(),vec.clear();\n      ph.resize(N),h.resize(N),vec.resize(M);\n      rep(i,N)par[i] = i;\n\n      rep(i,N)cin >> h[i],ph[i] = h[i];\n\t\n      rep(i,M)cin >> vec[i].x >> vec[i].y >> vec[i].cost,vec[i].x--,vec[i].y--;\n      \n      sort(ph.begin(),ph.end(),greater<int>());\n      sort(vec.begin(),vec.end());\n\n\n \n      int ans = 0;\n      rep(i,ph.size())\n\t{\n\t  int TM = ph[i];\n\t  int cost = 0;\n\t  rep(j,vec.size())\n\t    {\n\t      int x = vec[j].x;\n\t      int y = vec[j].y;\n\n\t      if(h[x] < TM || h[y] < TM)continue;\n\t      if(find(x) != find(y))\n\t\t{\n\t\t  cout << TM << \" unit(\"<<x+1 <<\",\" <<y+1 << \") : \" << vec[j].cost << endl;\n\t\t  unit(x,y);\n\t\t  cost += vec[j].cost;\n\t\t}\n\n\t    }\n\t  cout << \"ans : \" << ans << endl;\n\t}\n\n      int ch = find(0);\n      bool out = false;\n      rep(i,N)if(find(i) != ch)\n\t{\n\t  out = true;\n\t  break;\n\t}\n\n      cout << (out?0:ans) << endl;\n      \n    }\n  return 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<numeric>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nclass UF{\n  vector<int> v;\npublic:\n  UF(int n):v(n+1){\n    iota(begin(v),end(v),0);\n  }\n  int find(int x){\n    return (x==v[x])?x:v[x]=find(v[x]);\n  }\n  void unite(int a,int b){\n    v[find(a)]=find(b);\n  }\n};\n\nstruct edge{\n  int a,b,c;\n  bool operator<(edge e)const{\n    return c<e.c;\n  }\n};\n\nint main(){\n  for(int N,M;cin>>N>>M,N;){\n    int h[201];\n    set<int> s{0};\n    for(int i=1;i<=N;i++){\n      cin>>h[i];\n      s.insert(h[i]);\n    }\n    int a[40000],b[40000],c[40000];\n    for(int i=0;i<M;i++){\n      cin>>a[i]>>b[i]>>c[i];\n    }\n    int t=1<<29;\n    for(auto e:s){\n      UF uf(N+1);\n      for(int i=0;i<M;i++){\n\tif(h[a[i]]>e&&h[b[i]]>e){\n\t  uf.unite(a[i],b[i]);\n\t}\n      }\n      set<int> ri;\n      for(int i=1;i<=N;i++){\n\tif(h[i]>e){\n\t  ri.insert(uf.find(i));\n\t}\n      }\n      if(ri.size()>1){\n\tt=e;\n\tbreak;\n      }\n    }\n    if(t==0){\n      cout<<0<<endl;\n    }else{\n      vector<edge> v;\n      for(int i=0;i<M;i++){\n\tif(h[a[i]]>=t&&h[b[i]]>=t){\n\t  v.push_back({a[i],b[i],c[i]});\n\t}\n      }\n      sort(begin(v),end(v));\n      UF kuf(N+1);\n      int w=0;\n      for(auto e:v){\n\tif(kuf.find(e.a)!=kuf.find(e.b)){\n\t  kuf.unite(e.a,e.b);\n\t  w+=e.c;\n\t}\n      }\n      vector<int> et(begin(s),end(s));\n      reverse(begin(et),end(et));\n      for(auto e:et){\n\tvector<edge> cv;\n\tfor(int i=0;i<M;i++){\n\t  if(h[a[i]]>=e&&h[b[i]]>=e){\n\t    cv.push_back({a[i],b[i],c[i]});\n\t  }\n\t}\n\tsort(begin(cv),end(cv));\n\tfor(auto f:cv){\n\t  if(kuf.find(f.a)!=kuf.find(f.b)){\n\t    kuf.unite(f.a,f.b);\n\t    w+=f.c;\n\t  }\n\t}\n      }\n      cout<<w<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvp ti(n+1,{1,-1});\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n){\n\t\t\tint a;cin>>a;\n\t\t\tti[i]={a*-1,i};\n\t\t}\n\t\tsort(all(ti));\n\t\tint t=0;\n\t\tUnionFind uf(n);\n\t\tvi used(n);\n\t\tvvi G(m,vi(3));\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tG[i]={a,b,c};\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\tint T=-1;\n\t\twhile(t!=n){\n\t\t\tused[ti[t].second]=true;\n\t\t\twhile(ti[t].second==ti[t+1].second){\n\t\t\t\tt++;\n\t\t\t\tused[ti[t].second]=true;\n\t\t\t}\n\t\t\trep(i,m)if(used[G[i][0]]&&used[G[i][1]])uf.unionSet(G[i][0],G[i][1]);\n\t\t\tt++;\n\t\t\tif(uf.size(ti[0].second)!=t)T=t;\n\t\t}\n\t\tif(uf.size(0)!=n){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tused=vi(n);\n\t\tint sum=0;\n\t\tvi d(n,inf);\n\t\td[ti[0].second]=0;\n\t\trep(j,n){\n\t\t\tint v;\n\t\t\tif(T<j)v=ti[j].second;\n\t\t\telse{\n\t\t\t\tv=-1;\n\t\t\t\trep(i,n)if(used[ti[i].second]==0&&ti[i].first<=ti[T].first&&(v==-1||d[v]>d[ti[i].second]))v=ti[i].second;\n\t\t\t}\n\t\t\tused[v]=true;\n\t\t\tsum+=d[v];\n\t\t\trep(i,n)d[i]=min(d[i],cost[v][i]);\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "3 3\n1\n2\n3\n1 2 1\n1 3 1\n2 3 10\n3 2\n100\n10000\n1000000\n1 2 2\n1 3 3\n6 6\n2\n3\n5\n7\n11\n13\n1 3 17\n3 5 19\n5 1 23\n2 4 29\n4 6 31\n6 2 37\n11 16\n74\n25\n3\n39\n55\n18\n74\n55\n74\n3\n18\n1 7 200\n9 1 423\n2 9 205\n6 2 255\n2 5 123\n4 2 193\n2 3 200\n10 2 333\n2 11 256\n3 10 171\n4 10 512\n1 2 201\n8 5 314\n6 7 150\n11 6 257\n7 9 315\n20 38\n412516\n185397\n509168\n712745\n966959\n101213\n666120\n790528\n275431\n677098\n623178\n240167\n4371\n299088\n925699\n72800\n121416\n796859\n810604\n142754\n13 5 1000000\n3 7 991832\n10 1 781938\n15 8 455731\n1 3 655887\n1 20 604802\n19 10 452912\n15 5 360121\n10 15 256967\n9 5 682599\n8 7 917302\n5 18 974821\n2 19 790778\n17 5 298105\n15 11 132405\n18 19 745543\n2 4 790778\n1 2 790778\n11 14 269668\n15 4 882901\n1 14 522591\n15 18 424799\n9 19 712540\n20 5 592132\n18 17 770826\n19 8 592380\n16 5 258739\n8 4 794157\n3 18 569611\n7 19 340021\n19 11 803293\n8 18 692318\n9 6 626882\n20 2 592133\n2 17 196463\n12 14 506077\n16 20 928375\n12 18 894053\n0 0"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n,m;\nint h[201];\n\nstruct edge{\n\tint f,t,c;\n\tedge(){}\n\tedge(int ff,int tt,int cc){\n\t\tf=ff;\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge& e1)const{\n\t\treturn c<e1.c;\n\t}\n};\n\nint par[1001],rank[1001];\n\nvoid init(){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\trank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(rank[x]<rank[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tif(rank[x]==rank[y])rank[x]++;\n\t\tpar[y]=x;\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tinit();\n\t\tvector<int> index;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&h[i]);\n\t\t\tindex.push_back(h[i]);\n\t\t}\n\t\tsort(index.begin(),index.end());\n\t\tindex.erase(unique(index.begin(),index.end()),index.end());\n\t\tint land=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\th[i]=lower_bound(index.begin(),index.end(),h[i])-index.begin();\n\t\t\tif(h[i]==index.size()-1)land=i;\n\t\t}\n\t\tvector<edge> G;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG.push_back(edge(a,b,c));\n\t\t}\n\t\tsort(G.begin(),G.end());\n\t\tint last=index.size();\n\t\tfor(int i=index.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(h[G[j].f]<i || h[G[j].t]<i)continue;\n\t\t\t\tif(!same(G[j].f,G[j].t))unite(G[j].f,G[j].t);\n\t\t\t}\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(!same(land,j) && h[j]>=i)flag=false;\n\t\t\t}\n\t\t\tif(!flag)last=i;\n\t\t}\n\t\tif(last==0){\n\t\t\tprintf(\"0\\n\");\n\t\t}else{\n\t\t\tinit();\n\t\t\tint res=0;\n\t\t\tfor(int i=last-1;i>=0;i--){\n\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\tif(h[G[j].f]<i || h[G[j].t]<i)continue;\n\t\t\t\t\tif(!same(G[j].f,G[j].t)){\n\t\t\t\t\t\tunite(G[j].f,G[j].t);\n\t\t\t\t\t\tres+=G[j].c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nconst int M = 1000000007;\n \nclass unionfind {\n    public:\n    int n;\n    vector<int> par;\n    unionfind(int m) {\n        n = m;\n        par.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int find(int x) { return par[x] == x ? x : (par[x] = find(par[x])); }\n    int isunion(int x, int y) { return find(x) == find(y); }\n    int tounion(int x, int y) {\n        int p = find(x), q = find(y);\n        if (p == q) return 0;\n        par[q] = p;\n        return 1;\n    }\n};\n \nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n \n        vector<int> h(n);\n        map<int, int> mp;\n        for (int i = 0; i < n; ++i) {\n            cin >> h[i];\n            mp[h[i]] = 1;\n        }\n        int cc = 0;\n        for (auto& i : mp)\n            i.second = cc++;\n \n        vector<vector<int>> lis(n);\n        for (int i = 0; i < n; ++i) {\n            h[i] = mp[h[i]];\n            lis[h[i]].push_back(i);\n        }\n        vector<vector<pair<int, pair<int, int>>>> edge(n);\n        for (int i = 0; i < m; ++i) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            --a;\n            --b;\n            edge[min(h[a], h[b])].push_back(make_pair(c, make_pair(a, b)));\n        }\n        for (int i = 0; i < n; ++i)\n            sort(edge[i].begin(), edge[i].end());\n \n        int lastsep = n;\n        unionfind puf(n);\n        for (int i = n - 1; i >= 0; --i) {\n            for (auto j : edge[i])\n                puf.tounion(j.second.first, j.second.second);\n \n            for (int j = 0; j < n; ++j) {\n                if (h[j] >= i) {\n                    for (int k = 0; k < n; ++k) {\n                        if (h[k] >= i && !puf.isunion(j, k)) {\n                            lastsep = i;\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        if (lastsep == 0) {\n            cout << \"0\\n\";\n            continue;\n        }\n        vector<pair<int, pair<int, int>>> fedge;\n        for (int i = lastsep - 1; i < n; ++i)\n            for (auto j : edge[i])\n                fedge.push_back(j);\n \n        sort(fedge.begin(), fedge.end());\n        unionfind uf(n);\n        long long sum = 0;\n        for (auto i : fedge)\n            if (uf.tounion(i.second.first, i.second.second))\n                sum += i.first;\n \n        for (int i = lastsep - 2; i >= 0; --i)\n            for (auto j : edge[i])\n                if (uf.tounion(j.second.first, j.second.second))\n                    sum += j.first;\n \n        cout << sum << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=200,INF=1E9;\nconst int MAX_DAY=1E6;\n\nstruct edge{\n\tint to,cost;\n};\n\nint N,M;\nvector<int> q[MAX_DAY+1];\nvector<edge> G[MAX_N];\n\nbool flg[MAX_N];\t//???????????????????????°\nint mincost[MAX_N];\n\nint last;\t//?????????????????¶\n\nvoid prim(){\n\tint ans=0,cost=0;\n\tfill(flg,flg+N,false);\n\tfill(mincost,mincost+N,INF);\n\tmincost[last]=0;\n\tfor (int i=MAX_DAY;i>=0;i--){\n\t\tif (q[i].empty()) continue;\n\t\tfor (int j=0;j<q[i].size();j++){\n\t\t\tflg[q[i][j]]=true;\n\t\t}\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor (int j=0;j<N;j++){\n\t\t\t\tif (flg[j] && mincost[j]!=INF && (v==-1 || mincost[j]<mincost[v])){\n\t\t\t\t\tv=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v==-1) break;\n\t\t\tcost+=mincost[v];\n\t\t\tflg[v]=false;\n\t\t\tfor (int j=0;j<G[v].size();j++){\n\t\t\t\tedge e=G[v][j];\n\t\t\t\tmincost[e.to]=min(mincost[e.to],e.cost);\n\t\t\t}\n\t\t}\n\t\tbool f=true;\n\t\tfor (int j=0;j<N;j++){\n\t\t\tif (flg[j]){\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (f){\n\t\t\tans+=cost;\n\t\t\tcost=0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif (N || M){\n\t\t\tint lastd=-1;\n\t\t\tlast=-1;\n\t\t\tfor (int i=0;i<=MAX_DAY;i++){\n\t\t\t\tq[i].clear();\n\t\t\t}\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tq[t].push_back(i);\n\t\t\t\tif (t>lastd){\n\t\t\t\t\tlastd=t;\n\t\t\t\t\tlast=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=0;i<M;i++){\n\t\t\t\tint a,b,c;\n\t\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\t\tG[a-1].push_back((edge){b-1,c});\n\t\t\t\tG[b-1].push_back((edge){a-1,c});\n\t\t\t}\n\t\t\tprim();\n\t\t}\n\t}while (N || M);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\nconst int MAX_V=200;\nconst ll INF=LONG_MAX;\n\nll cost[MAX_V][MAX_V];\nll mincost[MAX_V];\nbool used[MAX_V];\n\nvoid init(int V){\n    V++;\n    REP(i,MAX_V){\n        mincost[i]=INF;\n        used[i]=false;\n    }\n    mincost[0]=0;\n}\nll prim(int V,bool do_init=true){\n    if(do_init){\n        init(V);\n    }\n    V++;\n    ll res=0;\n    while(true){\n        int v=-1;\n        REP(u,V){\n            if(!used[u]&&(v==-1||mincost[u]<mincost[v])&&mincost[u]<INF)v=u;\n        }\n        if(v==-1)break;\n        used[v]=true;\n        res+=mincost[v];\n        REP(u,MAX_V){\n            mincost[u]=min(mincost[u],cost[v][u]);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n,m;\n    int cases=0;\n    while(cin>>n>>m,n|m){\n        cases++;\n        if(cases==72){\n            int aaa=1;\n        }\n        vector<pii> h(n);\n        REP(i,n){\n            cin>>h[i].first;\n            h[i].second=i;\n        }\n        sort(RALL(h));\n        vvi true_cost(n,vi(n,INF));\n        REP(i,m){\n            int a,b,c;\n            cin>>a>>b>>c;\n            true_cost[a-1][b-1]=c;\n            true_cost[b-1][a-1]=c;\n        }\n        REP(i,n){\n            REP(j,n){\n                cost[i][j]=true_cost[h[i].second][h[j].second];\n                cost[j][i]=true_cost[h[j].second][h[i].second];\n            }\n        }\n        int max_index=-1;\n        for(int i=n-1;i>=0;i--){\n            while(i<n-1&&i>=0&&h[i+1].first==h[i].first){\n                i--;\n            }\n            prim(i);\n            bool ok=true;\n            REP(j,i+1){\n                if(!used[j]){\n                    ok=false;\n                    break;\n                }\n            }\n            if(!ok){\n                max_index=i;\n                break;\n            }\n        }\n        ll ans=0;\n        if(max_index<n-1){\n            max_index++;\n            while(max_index<n-1&&max_index>=0&&h[max_index+1].first==h[max_index].first){\n                max_index++;\n            }\n            ans=prim(max_index);\n        }\n        for(int i=max_index;i<n;i++){\n            while(i<n-1&&h[i+1].first==h[i].first){\n                i++;\n            }\n            ans+=prim(i,false);\n            //int mmin=INF;\n            //REP(j,i){\n            //  mmin=min(mmin,cost[j][i]);\n            //}\n            //if(mmin<INF)\n            //ans+=mmin;\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\n#define F first\n#define S second\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    int h[n];\n    for(int i=0;i<n;i++) cin>>h[i];\n    int a[m],b[m],c[m];\n    for(int i=0;i<m;i++) cin>>a[i]>>b[i]>>c[i];\n    priority_queue<P> q1;\n    for(int i=0;i<n;i++) q1.emplace(h[i],i);\n    vector<P> G[n];\n    for(int i=0;i<m;i++){\n      a[i]--;b[i]--;\n      G[a[i]].push_back(P(b[i],c[i]));\n      G[b[i]].push_back(P(a[i],c[i]));\n    }\n    int INF=1LL<<55LL;\n    int cost[n];\n    for(int i=0;i<n;i++) cost[i]=INF;\n    bool used[n];\n    memset(used,0,sizeof(used));\n    int root=q1.top().S;\n    cost[root]=0;\n    used[root]=1;\n    int tmp=h[root];\n    q1.pop();\n    int ans=0;\n    while(!q1.empty()){\n      priority_queue<P,vector<P>,greater<P> > q2;\n      set<int> s,t;\n      while(!q1.empty()&&q1.top().F==tmp){\n\ts.insert(q1.top().S);\n\tt.insert(q1.top().S);\n\tq1.pop();\n      }\n      if(!q1.empty()) tmp=q1.top().F;\n      if(ans==0){\n\tfor(int i=0;i<n;i++) cost[i]=INF;\n\tcost[root]=0;\n\tfor(int i=0;i<n;i++)\n\t  if(used[i]&&root!=i) s.insert(i);\n\tfor(P p:G[root]){\n\t  if(cost[p.F]<=p.S) continue;\n\t  cost[p.F]=p.S;\n\t}\n      }else{\n\tfor(int i=0;i<n;i++){\n\t  if(!used[i]) continue;\n\t  for(P p:G[i]){\n\t    if(cost[p.F]<=p.S) continue;\n\t    cost[p.F]=p.S;\n\t  }\n\t}\n      }\n      //cout<<tmp<<\":\";for(int i:s) cout<<i<<\" \";cout<<endl;\n      for(int i=0;i<n;i++)\n\tif(s.count(i)) q2.emplace(cost[i],i);\n      while(!s.empty()&&!q2.empty()){\n\tP p=q2.top();q2.pop();\n\tif(!s.count(p.S)) continue;\n\tif(p.F==INF) break;\n\t//cout<<p.S<<endl;\n\ts.erase(p.S);\n\tans+=cost[p.S];\n\tfor(P u:G[p.S]){\n\t  if(cost[u.F]<=u.S) continue;\n\t  cost[u.F]=u.S;\n\t  if(s.count(u.F)) q2.emplace(cost[u.F],u.F);\n\t}\n      }\n      if(!s.empty()) ans=0;\n      for(int i:t) used[i]=1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define s second\n#define f first\n#define INF 1e9\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> iP;\nint  n,m,e[201][201],h[201],used2[201];\nP h2[201];\n\nint prim(int cnt,int f[201][201]){\n  int res=0,used[201]={};\n  priority_queue <P,vector<P>,greater<P> > Q;\n  Q.push(P(0,h2[n-1].s));\n  \n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    int cost=t.f,pos=t.s;\n    if(used[pos]||used2[pos])continue;\n    used[pos]=1,cnt++,res+=cost;\n    for(int i=0;i<n;i++)if(f[pos][i]<INF)Q.push(P(f[pos][i],i));\n  }\n  if(cnt==n)return res;\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=INF;\n    for(int i=0;i<n;i++) cin>>h[i],h2[i]=P(P(h[i],i));\n    sort(h2,h2+n);\n    for(int i=0,a,b,c;i<m;i++) cin>>a>>b>>c,e[--a][--b]=e[b][a]=c;\n    \n    memset(used2,0,sizeof(used2));\n    int res,ans=prim(0,e),H=0,flg=ans;\n    for(int i=0;i<n&&(res=prim(i,e));i++){\n      int I=h2[i].s;\n      ans=res,H=h[I];\n      for(int j=i--;j<n&&h[h2[j].s]==H;j++) used2[h2[j].s]=1,i++;\n    }\n    for(int i=0;i<n;i++) if(h[i]==H) used2[i]=0;\n    \n    reverse(h2,h2+n);\n    for(int i=0;i<n;i++){\n      int I=h2[i].s,cnt=i;\n      if(!used2[I]) continue;\n      while(cnt+1<n&&h[I]==h[h2[cnt+1].s])cnt++;\n      while(1){\n\tint J,mn=INF;\n\tfor(int j=i;j<=cnt;j++)\n\t  for(int k=0;k<n&&used2[h2[j].s];k++)\n\t    if(!used2[k]&&mn>e[h2[j].s][k])mn=e[h2[j].s][k],J=h2[j].s;\n\tif(mn==INF)break;\n\tans+=mn;\n\tused2[J]=0;\n      }\n      i=cnt;\n    }\n    \n    if(flg) cout <<ans<<endl;\n    else cout <<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define all(a) (a).begin(),(a).end()\n\ntypedef pair<int,int> P;\n\n// uf\nstruct unionfind {\n  vector<int> par;\n  unionfind(int n) : par(n) { for (int i = 0; i < n; ++i) par[i] = i; }\n  \n  int find(int x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  \n  void unite(int x, int y) {\n    par[find(x)] = par[find(y)] = find(x);\n  }\n  \n  bool same(int x, int y) { return find(x) == find(y); }\n};\n\nstruct edge {\n  int u, v, cost;\n  bool operator<(const edge& other) const {\n    return cost < other.cost;\n  }\n};\n\nint N, M;\nint H[202];\nint G[202][202];\n\n// 連結でなくなる時間を求める\nint getTime() {\n  vector<P> lands;\n  rep(i,N) lands.push_back(P(H[i], i));\n  sort(all(lands));\n  vector<int> enable(N, 1);\n  rep(z,N) {\n    unionfind uf(N);\n    // enable の島だけで掛けられそうな橋をとりあえず掛ける\n    rep(i,N) {\n      if (!enable[i]) continue;\n      rep(j,N) {\n        if (!enable[j] || i == j || (G[i][j] <= 0)) continue;\n        if (!uf.same(i,j)) {\n          uf.unite(i,j);\n        }\n      }\n    }\n    // 連結であるか\n    rep(i,N) {\n      if (!enable[i] || i == lands[z].second) continue;\n      if (!uf.same(i, lands[z].second)) {\n        if (z == 0) return -1;\n        return lands[z-1].first;\n      }\n    }\n    enable[lands[z].second] = 0;    \n  }\n  return lands.back().first + 1;\n}\n\nint solve() {\n  int time = getTime(), ans = 0;\n  vector<P> lands;\n  rep(i,N) lands.push_back(P(H[i], i));\n  sort(all(lands), greater<P>());\n  // printf(\"time : %d\\n\", time);\n  // 最初から連結でない\n  if (time == -1) {\n    return 0;\n  }\n \n  // 橋を掛ける\n  vector<edge> es;\n  rep(i,N) rep(j,N) if (G[i][j]) es.push_back((edge){i, j, G[i][j]});\n  sort(all(es));\n\n  vector<int> on(N, 0);\n  \n  unionfind uf(N);\n  rep(z,N) {\n    on[lands[z].second] = 1;\n    const int t = lands[z].first;\n    if (t > time) continue;\n    if ((z+1 < N) && (lands[z].first == lands[z+1].first)) continue;\n    \n    rep(i,es.size()) {\n      edge e = es[i];\n      int u = e.u, v = e.v;\n      if (on[u] && on[v]) {\n        if (G[u][v] && !uf.same(u, v)) {\n          ans += e.cost;\n          uf.unite(u, v);\n          // printf(\"%d - %d : %d | %d\\n\", u, v, e.cost, ans);\n        }\n      }\n    }\n  }\n  \n  return ans;\n}\n\nint main() {\n  while (scanf(\"%d%d\", &N, &M), N) {\n    // G[][] 初期化\n    rep(i,N) rep(j,N) G[i][j] = 0;\n    rep(i,N) G[i][i] = 0;\n    \n    rep(i,N) scanf(\"%d\", H+i);\n    rep(i,M) {\n      int a, b, c;      \n      scanf(\"%d%d%d\", &a, &b, &c);\n      --a; --b;\n      G[a][b] = G[b][a] = c;\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <functional>\n#include <stack>\n#include <utility>\n#include <map>\n#include <queue>\n#include <set>\n#include <array>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst ll MOD = ll(1e9) + 7;\nconst ll INF = LLONG_MAX;\nconst ll MAX_N = ll(1e5) + 5;\nconst double EPS = 10e-8;\nconst double PI = 3.14159265359;\n\n#define REP(i, n) for (ll i = 0; i < n; i++)\n#define REPR(i, n) for (ll i = n; i >= 0; i--)\n#define FOR(i, m, n) for (ll i = m; i < n; i++)\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\n#define MAX_E 50000\n\nstruct edge {\n    int u, v, cost;\n};\n\nint n, m, nalive;\nvector<edge> path[201];\nvector<P> h;\nbool is_sinked[201];\nvector<int> ok;\n\nclass UnionFindTree {\n    static const int MAX_V = 100000;\n    int par[MAX_V];\n    int rank[MAX_V];\n\n   public:\n    void init(int n) {\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\nbool comp(const edge &e1, const edge &e2) { return e1.cost < e2.cost; }\n\nvector<edge> es;\n\nint kruskal() {\n    sort(es.begin(), es.end(), comp);\n    UnionFindTree a;\n    a.init(n);\n    for (int i = 1; i < ok.size(); i++) {\n        a.unite(ok[i - 1], ok[i]);\n    }\n    int res = 0;\n    for (int i = 0; i < es.size(); i++) {\n        edge e = es[i];\n        if (!a.same(e.u, e.v) && !is_sinked[e.v]) {\n            a.unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nbool is_connected() {\n    int start = 0, cnt = 0;\n    for (; start < n; start++)\n        if (!is_sinked[start]) break;\n    queue<int> que;\n    vector<bool> visited(n + 1);\n    for (int i = 0; i <= n; i++) visited[i] = false;\n\n    visited[start] = true;\n    que.push(start);\n\n    while (!que.empty()) {\n        int cur = que.front();\n        que.pop();\n        for (auto next : path[cur]) {\n            if (!visited[next.v] && !is_sinked[next.v]) {\n                visited[next.v] = true;\n                que.push(next.v);\n            }\n        }\n        cnt++;\n    }\n    return cnt == nalive;\n}\n\nint main() {\n    while (1) {\n        cin >> n >> m;\n        int ans = 0;\n        ok.clear();\n        for (int i=0;i<n;i++) path[i].clear();\n        fill(is_sinked, is_sinked + n, false);\n        h.clear();\n        if (n == 0) break;\n        REP(i, n) {\n            int tmp;\n            cin >> tmp;\n            h.push_back({tmp, i});\n        }\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--;\n            b--;\n            path[a].push_back({a, b, c});\n            path[b].push_back({b, a, c});\n        }\n        sort(h.begin(), h.end());\n\n        int inum = 0;\n        nalive = n;\n        while (is_connected()) {\n            P tmp = h[inum];\n            while (inum < n && tmp.first == h[inum].first) {\n                is_sinked[h[inum].second] = true;\n                nalive--;\n                inum++;\n            }\n        }\n\n        es.clear();\n        inum--;\n        if(nalive==n){\n            cout << 0 << endl;\n            continue;\n        }\n        if (inum >= 0) {\n            P tmp = h[inum];\n            while (inum >= 0 && tmp.first == h[inum].first) {\n                is_sinked[h[inum].second] = false;\n                nalive++;\n                inum--;\n            }\n        }\n        REP(i, n) {\n            if (!is_sinked[i]) {\n                for (auto tmp : path[i]) {\n                    es.push_back(tmp);\n                }\n            }\n        }\n        ans += kruskal();\n        REP(i, n) {\n            if (!is_sinked[i]) ok.push_back(i);\n        }\n\n        while (inum >= 0) {\n            es.clear();\n            vector<int> ls;\n            if (inum >= 0) {\n                P tmp = h[inum];\n                while (inum >= 0 && tmp.first == h[inum].first) {\n                    is_sinked[h[inum].second] = false;\n                    nalive++;\n                    ls.push_back(h[inum].second);\n                    inum--;\n                }\n            }\n            for (int i = 0; i < ls.size(); i++) {\n                if (!is_sinked[ls[i]]) {\n                    for (auto tmp : path[ls[i]]) {\n                        es.push_back(tmp);\n                    }\n                }\n            }\n            ans += kruskal();\n            for (int i = 0; i < ls.size(); i++) {\n                if (!is_sinked[ls[i]]) \n                    ok.push_back(ls[i]);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nstruct edge {\n    int from, to, cost;\n    bool operator<(edge const& es) const {\n        return cost < es.cost;\n    }\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) {\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        vector<pii> h(N);\n        for(int i=0; i<N; ++i) {\n            cin >> h[i].first;\n            h[i].second = i;\n        }\n        sort(h.begin(), h.end());\n        edges es(M);\n        for(int i=0; i<M; ++i) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            es[i] = edge{a, b, c};\n        }\n        sort(es.begin(), es.end());\n        {\n            union_find uf(N);\n            for(auto& e : es) {\n                uf.unite(e.from, e.to);\n            }\n            if(uf.size(0) != N) {\n                cout << 0 << endl;\n                continue;\n            }\n        }\n        int i = 0;\n        int cnt = N;\n        vector<bool> sink(N);\n        vector<vector<int>> sinkv;\n        while(i < N) {\n            vector<int> v = {h[i].second};\n            sink[h[i].second] = true;\n            int j = i+1;\n            for(; j<N && h[i].first == h[j].first; ++j) {\n                v.push_back(h[j].second);\n                sink[h[j].second] = true;\n            }\n            i = j;\n            union_find uf(N);\n            int sz = 1;\n            for(auto& e : es) {\n                if(!sink[e.from] && !sink[e.to]) {\n                    uf.unite(e.from, e.to);\n                    sz = max(sz, uf.size(e.from));\n                }\n            }\n            if(sz != cnt - v.size()) {\n                for(auto x : v) {\n                    sink[x] = false;\n                }\n                break;\n            }\n            cnt -= v.size();\n            sinkv.push_back(move(v));\n        }\n\n        int res = 0;\n        union_find uf(N);\n        for(auto& e : es) {\n            if(!sink[e.from] && !sink[e.to] && !uf.same(e.from, e.to)) {\n                res += e.cost;\n                uf.unite(e.from, e.to);\n            }\n        }\n        reverse(sinkv.begin(), sinkv.end());\n        for(auto& vs : sinkv) {\n            for(auto x : vs) {\n                sink[x] = false;\n            }\n            for(auto& e : es) {\n                if(!sink[e.from] && !sink[e.to] && !uf.same(e.from, e.to)) {\n                    res += e.cost;\n                    uf.unite(e.from, e.to);\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &p)const{\n    return cost < p.cost;\n  }\n};\n\n#define MAX 205\nint pa[MAX];\nint ra[MAX];\n\nint n,m;\nmap< int , vector<int> > t;\n\nvector< edge > G[MAX];\nbool flg[MAX];\n\nvoid uf_init(){\n  for(int i=0;i<MAX;i++){\n    pa[i]=i;\n    ra[i]=0;\n  }\n}\n\nvoid init(){\n  t.clear();\n  for(int i=0;i<MAX;i++){\n    flg[i]=false;\n    G[i].clear();\n  }\n}\n\nint find(int x){\n  if(pa[x]==x)return x;\n  else return pa[x]=find(pa[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(ra[x]<ra[y])swap(x,y);\n  pa[y]=x;\n  if(ra[x]==ra[y])ra[x]++;\n}\n\nbool same(int x,int y){\n  return (find(x)==find(y));\n}\n\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&n,&m);    \n    if(n==0&&m==0)break;\n    uf_init();\n    init();\n    int a,b,c;\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&a);\n      t[-a].push_back(i+1);\n    }\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d\",&a,&b,&c);\n      G[a].push_back((edge){a,b,c});\n      G[b].push_back((edge){b,a,c});\n    }\n\n    int ans=0;\n    vector<edge> E;\n    map< int , vector<int> > :: iterator it,it2;    \n\n    for(it=t.begin();it!=t.end();it++){\n      int size=it->second.size();\n      for(int i=0;i<size;i++){\n        int v=it->second[i];\n        flg[v]=true;\n      }\n      for(int i=0;i<size;i++){\n        int v=it->second[i];\n        for(int j=0;j<(int)G[v].size();j++){\n          edge e=G[v][j];\n          if(flg[e.to])E.push_back(e);\n        }    \n      }\n      sort(E.begin(),E.end());\n\n      for(int i=0;i<(int)E.size();i++){\n        edge e=E[i];\n        if(same(e.from,e.to))continue;\n        unite(e.from,e.to);\n        ans+=e.cost;\n      }\n      \n      int cnt=0;\n      for(int i=1;i<=n;i++){\n        if(!flg[i])continue;\n        if(find(i)==i)cnt++;\n      }\n      if(cnt!=1){\n        uf_init();\n        ans=0;\n        E.clear();\n        for(int i=1;i<=n;i++){\n          if(!flg[i])continue;\n          for(int j=0;j<(int)G[i].size();j++){\n            edge e=G[i][j];\n            if(flg[e.to])E.push_back(e);\n          }\n        }\n      }else{\n        E.clear();\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n  int x, hour;\n  node(){}\n  node(int x, int hour):x(x), hour(hour){}\n  bool operator < (const node& u) const {\n    return hour < u.hour;\n  }\n};\n\nstruct edge{\n  int u, v, cost;\n  edge(){}\n  edge(int u, int v, int cost):u(u), v(v), cost(cost){}\n  bool operator < (const edge& e) const {\n    return cost < e.cost;\n  }\n};\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n  int find(int k)\n  {\n    if(data[k] < 0) return k;\n    return data[k] = find(data[k]);\n  }\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y){\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n  int size(int k)\n  {\n    return -data[find(k)];\n  }\n};\n\nint main()\n{\n  int N, M;\n  while(cin >> N >> M, N || M){\n    vector<node> V;\n    vector<edge> E;\n    for(int i = 0; i < N; i++){\n      int h; cin >> h;\n      V.push_back(node(i, h));\n    }\n    for(int i = 0; i < M; i++){\n      int a, b, c; cin >> a >> b >> c; a--, b--;\n      E.push_back(edge(a, b, c));\n    }\n    sort(V.rbegin(), V.rend());\n    sort(E.begin(), E.end());\n    vector<bool> exist(N, true);\n    int dis = N;\n    for(int i = N-1; i >= 0; i--){\n      if(i <= 0 || V[i].x != V[i-1].x){\n\tUnionFind msp(N);\n\tfor(int j = 0; j < M; j++){\n\t  if(exist[E[j].u] && exist[E[j].v] && !msp.same(E[j].u, E[j].v)){\n\t    msp.unite(E[j].u, E[j].v);\n\t  }\n\t}\n\tif(msp.size(V[0].x) == i+1) dis = i;\n\telse break;\n      }\n      exist[V[i].x] = false;\n    }\n    UnionFind uf(N);\n    long long ans = 0LL;\n    for(int i = dis; i < N; i++){   \n      exist[V[i].x] = true;\n      if(i < N-1 && V[i].x == V[i+1].x) continue;\n      for(int j = 0; j < M; j++){\n\tif(exist[E[j].u] && exist[E[j].v] && !uf.same(E[j].u, E[j].v)){\n\t  uf.unite(E[j].u, E[j].v);\n\t  ans += E[j].cost;\n\t}\n      }\n    }\t\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nstruct unionfind {\n    vector<int> data;\n    unionfind(int size) : data(size, -1) {}\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nstruct edge {\n    int u, v, cost;\n};\n\nint main(){\n    int V, E;\n    while (cin >> V >> E, V | E){\n        vector<int> h(V);\n        vector<edge> es(E);\n        set<int> hs;\n        hs.insert(0);\n        rep(i, V){\n            cin >> h[i];\n            hs.insert(h[i]);\n        }\n\n        rep(i, E){\n            int a, b, c; cin >> a >> b >> c;\n            a--; b--;\n            es[i] = { a, b, c };\n        }\n        sort(all(es), [](edge a, edge b){\n            return a.cost < b.cost;\n        });\n\n        int ans = 0;\n        unionfind uf(V);\n        for (auto it = hs.rbegin(); it != hs.rend(); ++it){\n            int th = *it;\n            set<int> s;\n            rep(i, V){\n                if (th <= h[i]){\n                    s.insert(i);\n                }\n            }\n            rep(j, E){\n                const edge& e = es[j];\n                if (!uf.same(e.u, e.v) && s.count(e.u) && s.count(e.v)){\n                    uf.unite(e.u, e.v);\n                    ans += e.cost;\n                }\n            }\n            if (s.size() != uf.size(*s.begin())){\n                ans = 0;\n                uf = unionfind(V);\n            }\n        }\n        if (uf.size(0) != V) ans = 0;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n  \nint p[222];\nvoid init(int n){ for(int i = 0; i <= n; i++) p[i] = i; }\nint find(int x){ return p[x] = ( (p[x] == x)?x:find(p[x])); }\nvoid merge(int x,int y){ p[find(x)] = find(y); }\nbool same(int x,int y){ return find(x) == find(y); }\n  \nbool used[222];\n  \nint n,m;\nint h[222];\nvector<int> s[1111111];\nint a[44444],b[44444],c[44444];\npair<int,pair<int,int> > e[44444];\nint main(void){\n  \n  while(cin >> n >> m && n){\n    int ans = 0;\n    init(n);\n    memset(used,false,sizeof(used));\n  \n    for(int i = 0; i < 1111111; i++) s[i].clear();\n  \n    for(int i = 0; i < n; i++){\n      cin >> h[i];\n      s[ h[i] ].push_back(i+1);\n    }\n  \n    for(int i = 0; i < m; i++){\n      cin >> a[i] >> b[i] >> c[i];\n      e[i] = make_pair(c[i],make_pair(a[i],b[i]));\n    }\n    sort(e,e+m);\n      \n    int c = 0;\n    int f = -1;\n    for(int t = 1000000; t > 0; t--){\n\n      bool flag = false;\n      for(int i = 0; i < (int)s[t].size(); i++){\n    used[ s[t][i] ] = true;\n    f++;\n    c++;\nflag = true;\n      }\n      if(flag && f > 0){\n    for(int i = 0; i < m; i++){\n      int u = e[i].second.first, v = e[i].second.second;\n      //cout << u << \" \" << v << endl;\n      if(used[u] && used[v] && !same(u,v) ){\n        merge(u,v);\n        ans += e[i].first;\n        f--;\n      }\n    }\n    if(f > 0){\n      ans = 0;\n      init(n);\n      f = c-1;\n    }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nstruct UnionFindTree{\n    vector<int> v;\n    vector<int> rank;\n    UnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        if(v[x] != x){\n            v[x] = Find(v[x]);\n        }\n        return v[x];\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nstruct edge{\n\tint x,y,c;\n\tedge(int x, int y, int c):x(x),y(y),c(c){}\n\tedge(){}\n\tbool operator < (const edge &a) const{\n\t\treturn c < a.c;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<pair<int,int> > time(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\ttime[i] = make_pair(h, i);\n\t\t}\n\t\tsort(time.begin(), time.end());\n\t\treverse(time.begin(), time.end());\n\t\t\n\t\tvector<edge> bridge(m);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tbridge[i] = edge(a,b,c);\n\t\t}\n\t\tsort(bridge.begin(), bridge.end());\n\t\t\n\t\tUnionFindTree uft(n);\n\t\tvector<bool> usable(n, false);\n\t\tint ans=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tusable[time[i].second] = true;\n\t\t\twhile(i+1<n && time[i].first==time[i+1].first){\n\t\t\t\ti++;\n\t\t\t\tusable[time[i].second] = true;\n\t\t\t}\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tedge e = bridge[j];\n\t\t\t\tif(usable[e.x] && usable[e.y] && uft.Find(e.x)!=uft.Find(e.y)){\n\t\t\t\t\tans += e.c;\n\t\t\t\t\tuft.Union(e.x, e.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint root = -1;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(usable[j]){\n\t\t\t\t\tif(root!=-1 && root!=uft.Find(j)){\n\t\t\t\t\t\tans=0;\n\t\t\t\t\t\tuft = UnionFindTree(n);\n\t\t\t\t\t}\n\t\t\t\t\tif(root==-1) root = uft.Find(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n#define Graph(type) vector< vector< Edge<type> > >\n\ntemplate <typename T>\npair<int, vector< Edge<T> > > prim(vector< vector< Edge<T> > > &G) {\n    int V = G.size(); T ans = 0;\n    vector< Edge<T> > ans_e;\n    vector<bool> used(V, false);\n    priority_queue< Edge<T>, vector< Edge<T> >, greater< Edge<T> > > q;\n    q.push(Edge<T>(-1, 0, 0));\n    while(!q.empty()) {\n        Edge<T> temp = q.top(); q.pop();\n        if(used[temp.to]) continue;\n        used[temp.to] = true;\n        ans += temp.cost; if(temp.from >= 0) ans_e.pb(temp);\n        rep(i,0,G[temp.to].size()) q.push(G[temp.to][i]);\n    }\n    rep(i,0,V) if(!used[i]) ans = numeric_limits<T>::max();\n    return pair<int, vector< Edge<T> > >(ans, ans_e);\n}\n\n// Union-Find ??¨ (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size;\n    vector<int> uf;\npublic:\n    // ????????? UnionFind uni(n) ??????????????£?¨?????????°??????\n    UnionFind(int _n) : n(_n), __size(_n), uf(_n, -1) {}\n    // find (??¨??????????±???????)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x ??¨ y ???????????????????±???????????????????\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x ????±????????????????????´???°\n    int size(int x) {return -uf[find(x)];}\n    // ???????????????????????????\n    int size()      {return __size;}\n    // x ??¨ y ????±??????????????????????\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n    }\n    // ???????????°??¨ (???????????????)\n    void debug() {for(auto e : uf) printf(\"UnionFind_debug: %lld\\n\", e);}\n};\n\nsigned main() {\n    int n, m; \n    while(cin >> n >> m) {\n        if(!n && !m) break;\n        Graph(int) G(n);\n        vector<pii> v(n);\n        rep(i,0,n) {\n            cin >> v[i].fr;\n            v[i].sc = i;\n        }\n        sort(v.begin(), v.end(), greater<pii>());\n\n        vector< Edge<int> > es;\n        int a, b, c;\n        rep(i,0,m) {\n            cin >> a >> b >> c;\n            a--; b--;\n            es.pb(Edge<int>(a, b, c));\n            es.pb(Edge<int>(b, a, c));\n        }\n        sort(es.begin(), es.end());\n        int visited[210];\n        memset(visited, -1, sizeof(visited));\n\n        int ans = 0;\n        UnionFind uf(n);\n        rep(i,0,v.size()) {\n            int g = v[i].fr; visited[v[i].sc] = 0;\n            // printf(\"visit: %lld %lld\\n\", v[i].fr, v[i].sc);\n            while(v[++i].fr == g) visited[v[i].sc] = 0;\n            i--;\n            // printf(\"end: i = %lld\\n\", i);\n\n            rep(j,0,es.size()) {\n                if(visited[es[j].from] == -1 || visited[es[j].to] == -1) continue;\n                if(uf.find(es[j].from) != uf.find(es[j].to)) {\n                    uf.unite(es[j].from, es[j].to);\n                    ans += es[j].cost;\n                }\n            }\n            // printf(\"ans: %lld\\n\", ans);\n        }\n        int par = -1;\n        rep(i,0,n) {\n            if(par == -1) par = uf.find(i);\n            else if(par != uf.find(i)) ans = 0;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n\n    /*\n    int n, m; cin >> n >> m;\n    Graph(int) G(n);\n    vector< Edge<int> > es;\n    int s, d, c;\n    rep(i,0,m) {\n        cin >> s >> d >> c; s--; d--;\n        G[s].pb(Edge<int>(s, d, c));\n        G[d].pb(Edge<int>(d, s, c));\n        es.pb(Edge<int>(d, s, c));\n        es.pb(Edge<int>(s, d, c));\n    }\n    pii ans = pii(0, 0);\n    pair< int, vector< Edge<int> > > v = prim(G);\n    sort(es.begin(), es.end());\n    int E = es.size();\n    rep(i,0,v.sc.size()) {\n        UnionFind uf(n);\n        int res = 0;\n        for(int j=0; j<E; j++) {\n            Edge<int> e = es[j];\n            if(e.to == v.sc[i].from && e.from == v.sc[i].to) continue;\n            if(e.to == v.sc[i].to && e.from == v.sc[i].from) continue;\n            if(!uf.same(e.from, e.to)) {\n                uf.unite(e.from, e.to);\n                res += e.cost;\n            }\n        }\n\n        int par = -1;\n        for(int j=0; j<n; j++) {\n            if(par == -1) par = uf.find(j);\n            else if(par != uf.find(j)) res = INT_MAX;\n        }\n\n        if(res > v.fr) {\n            ans.fr++;\n            ans.sc += v.sc[i].cost;\n        }\n    }\n    printf(\"%lld %lld\\n\", ans.fr, ans.sc);\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nint main(void){\n    int n, m;\n    while(cin >> n >> m, n){\n        vector<pii> drop(n);\n        REP(i, n){\n            cin >> drop[i].first;\n            drop[i].second = i;\n        }\n        sort(drop.rbegin(), drop.rend());\n        UnionFind uf(n);\n        vector<pipii> edge(m);\n        REP(i, m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            edge[i] = pipii(c, pii(a, b));\n        }\n        sort(edge.begin(), edge.end());\n        vi up(n, 0);\n        int ans = 0;\n        int first = drop[0].second;\n        REP(i, n){\n             int v = drop[i].second;\n             //cout << \"up : \" << v << endl;\n             up[v] = 1;\n             if(i != n - 1 && drop[i].first == drop[i+1].first) continue;\n             /*\n             REP(j, n){\n                if(up[j]) cout << j << \":\";\n             }cout << endl;\n             */\n             FOR(e, edge){\n                int a = (*e).second.first, b = (*e).second.second;\n                if(!up[a] || !up[b]) continue;\n                if(!uf.findSet(a, b)){\n                    //cout << a << \":\" << b << \":\" << (*e).first << endl;\n                    uf.unionSet(a, b);\n                    ans += (*e).first;\n                }\n             }\n             if(uf.size(first) != i + 1){\n                 uf = UnionFind(n);\n                 ans = 0;   \n             }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\n#define endl '\\n'\n#define ALL(V) V.begin(),V.end()\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\n\nstruct UnionFind {\n    ll N, max_size;\n    V<ll> rank, parent, tsize;\n\n    UnionFind(ll N) : N(N), max_size(1), rank(N, 1), tsize(N, 1) {\n        parent = V<ll>(N);\n        iota(ALL(parent), 0ll);\n    }\n\n    ~UnionFind() {}\n\n    ll find(ll x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = find(parent[x]);\n    }\n\n    void unit(ll x, ll y) {\n        ll px = find(x);\n        ll py = find(y);\n        if(px == py) return;\n        if(rank[px] < rank[py]) swap(px, py);\n\n        parent[py] = px;\n        tsize[px] += tsize[py];\n        max_size = max(max_size, tsize[px]);\n        rank[px] += rank[py];\n    }\n\n    bool same(ll x, ll y) { return find(x) == find(y); }\n};\n\nusing PLL = pair<ll, ll>;\nusing TLL = tuple<ll, ll, ll>;\n\nbool solve() {\n    ll N, M;\n    cin >> N >> M;\n    if(!(N + M)) return false;\n\n    V<ll> H(N);\n\n    for(ll &e : H) cin >> e;\n    V<TLL> edges;\n    for(ll i = 0; i < M; i++) {\n        ll a, b, c;\n        cin >> a >> b >> c;\n        edges.emplace_back(c, a - 1, b - 1);\n    }\n\n    VV<ll> h_lis;\n    {\n        map<ll, V<ll>> hmap;\n        for(ll i = 0; i < N; i++) hmap[H[i]].push_back(i);\n        while(hmap.size()) {\n            auto ite = hmap.begin();\n            h_lis.push_back(ite->second);\n            hmap.erase(ite);\n        }\n    }\n    \n    sort(ALL(edges));\n\n    ll upper = h_lis.size();\n    V<bool> used(N, true);\n    {\n        ll sum = N;\n        for(ll i = 0; i < h_lis.size(); i++) {\n            const auto &v = h_lis[i];\n            UnionFind uf(N);\n            for(const auto ele : edges) {\n                ll a, b, c;\n                tie(c, a, b) = ele;\n                if(used[a] && used[b]) uf.unit(a, b);\n            }\n            if(uf.max_size < sum) {\n                upper = i;\n                break;\n            }\n            for(ll n : v) used[n] = false;\n            sum -= v.size();\n        }\n    }\n\n    ll ans = 0;\n\n    {\n        UnionFind uf(N);\n        for(ll i = upper - 1; i >= 0; i--) {\n            for(ll ni : h_lis[i]) {\n                used[ni] = true;\n                for(const auto ele : edges) {\n                    ll a, b, c;\n                    tie(c, a, b) = ele;\n                    if(uf.same(a, b)) continue;\n                    if(!used[a] || !used[b]) continue;\n                    ans += c;\n                    uf.unit(a, b);\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n/*????????§???*/\n\nint p[502],p2[502];\nint r[502],r2[502];\n\nvoid init(int n){\n    for (int i = 0; i < n; ++i) {\n        p[i]=i;\n        r[i]=0;\n    }\n}\n\n\nint find(int x){\n\tif(x != p[x]){\n\t\tp[x] = find(p[x]);\n    }\n   \treturn p[x];\n}\n     \nvoid union_set(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x==y) return;\n\tif(r[x] < r[y]){\n\t\tp[x] = y;\t\n\t}else{\n\t\tp[y] = x;\n\t\tif(r[x] == r[y])r[x]++;\n\t}\n\treturn ;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m &&n!=0){\n\t\tll ans = 0;\n\t\tvector<int>t(n);\n\t\trep(i,n){\n\t\t\tcin >> t[i];\n\t\t}\n\t\tvector<pair<int,int> > v(n);\n\t\trep(i,n){\n\t\t\tv[i] = MP(t[i],i);\n\t\t}\n\t\tsort(v.begin(),v.end(),greater<pair<int,int> >());\n\t\tvector<set<int> >vst;\n\t\tset<int>st;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==n-1){\n\t\t\t\tst.insert(v[i].second);\n\t\t\t\tvst.PB(st);\n\t\t\t}else{\n\t\t\t\tst.insert(v[i].second);\n\t\t\t\tif(v[i].first!=v[i+1].first){\n\t\t\t\t\tvst.PB(st);\n\t\t\t\t\tst.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<pair<ll,pair<int,int > > >node;\n\t\tinit(502);\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tll c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tnode.PB(MP(c,MP(a,b)));\n\t\t}\n\t\tsort(node.begin(),node.end());\n\t\tset<int>nst;\n\t\tint cnt=0;\n\t\tint nod=0;\n\t\tfor(int i=0;i<vst.size();i++){\n\t\t\tfor(auto x:vst[i]){\n\t\t\t\tnst.insert(x);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tfor(auto x:node){\n\t\t\t\tif(nst.count(x.second.first)!=0&&nst.count(x.second.second)!=0){\n\t\t\t\t\tif(find(x.second.first)!=find(x.second.second)){\n\t\t\t\t\t\tans += x.first;\n\t\t\t\t\t\tunion_set(x.second.first,x.second.second);\n\t\t\t\t\t\tnod++;\n\t\t\t\t\t\t//cout << x.second.first << \" \" << x.second.second << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nod!=cnt-1){\n\t\t\t\tinit(502);\n\t\t\t\tans = 0;\n\t\t\t\tnod = 0;\n\t\t\t}\n\t\t}\n\t\tif(nod!=n-1){\n\t\t\tans = 0;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\n/***** Union-Find *****/\n\nconst int MAX_N = 10000;\nint Par[MAX_N];\nint Rank[MAX_N];\n\nvoid union_find_init(int n){\n\tfor(int i=0; i<n; ++i){\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(Par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)\n\t\treturn ;\n\n\tif(Rank[x] < Rank[y]){\n\t\tPar[x] = y;\n\t} else{\n\t\tPar[y] = x;\n\t\tif(Rank[x] == Rank[y]){\n\t\t\t++Rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\n/***** /Union-Find *****/\n\nstruct edge {\n\tint from,\n\t\tto,\n\t\tcost;\n    bool operator < (const edge &e) const { return cost < e.cost; }\n};\n\nvector<edge> es;\nint V, E;\n\n// time, vs\nvector<pair<int, VI>> falls;\n\nVB falled;\nVB linked;\n\n// ????????????????????¶????????????????????£????????????\nbool all_unite() {\n    int v = -1;\n    REP(i, 0, V) {\n        if (falled[i]) continue;\n\n        if (v == -1) {\n            v = i;\n        } else {\n            if (!same(v, i)) return false;\n        }\n    }\n    return true;\n}\n\n// ??¨??????????????£????????£????????¨?????????\nvoid link_new_edge() {\n    rep(i, E) {\n        edge &e = es[i];\n        if (linked[i]) continue;\n        if (falled[e.from] || falled[e.to]) continue;\n        if (!same(e.from, e.to)){\n            unite(e.from, e.to);\n            linked[i] = true;\n        }\n    }\n}\n\n// ??¨??????????????????\nvoid link_edge() {\n    rep(i, E) {\n        edge &e = es[i];\n        if (falled[e.from] || falled[e.to]) continue;\n        unite(e.from, e.to);\n    }\n}\n\n// ????¨??????????????±???????\nint sum_cost() {\n    int cost = 0;\n    rep(i, E) {\n        if (linked[i]) {\n            cost += es[i].cost;\n        }\n    }\n    return cost;\n}\n\nint solve() {\n    falled = VB(V);\n\n    sort(ALL(es));\n    sort(ALL(falls));\n\n    // ?????????????°???????????±???????\n    int end_i = 0;\n    for (; end_i < (int)falls.size(); end_i++) {\n        // ?????????\n        for (auto v : falls[end_i].snd) { falled[v] = true; }\n\n        union_find_init(V);\n        link_edge();\n\n        if (!all_unite()) { break; }\n    }\n\n    // ??¨?????¨?????§?????????\n    if (end_i == 0) return 0;\n\n    // ??´?????§????????????????????????\n    if (end_i != (int)falls.size()) {\n        for (auto v : falls[end_i].snd) { falled[v] = false; }\n    }\n\n    // ????????????????????????\n    linked = VB(E);\n    union_find_init(V);\n    for (int i = end_i - 1; i >= 0; i--) {\n        // ??????\n        for (auto v : falls[i].snd) { falled[v] = false; }\n\n        link_new_edge();\n    }\n    \n    return sum_cost();\n}\n\nint main(void) {\n    while (cin >> V >> E, V) {\n        // ??\\???\n        falls.clear();\n        falls.EB(0, VI());\n        rep(i, V) {\n            int h;\n            cin >> h;\n\n            auto it = find_if(ALL(falls), [h](const pair<int, VI> &x) {\n                    return h == x.fst; });\n            if (it == falls.end()) {\n                falls.EB(h, VI({i}));\n            } else {\n                falls[it - falls.begin()].snd.PB(i);\n            }\n        }\n\n        es.clear(); es.resize(E);\n        rep(i, E) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            --a; --b;\n            es[i].to = a;\n            es[i].from = b;\n            es[i].cost = c;\n        }\n        // ??\\??????????????§\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1){ }\n\t// ?????????????????????\n\tbool unite(int x, int y){\n\t\tx=root(x); y=root(y);\n\t\tif( x != y ) data[y] = x;\n\t\treturn x!=y;\n\t}\n\t// ??????????????????????????????\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\t// ??????????????\\???????????????\n\tint root(int x){\n\t\t// ???????????????????????????????????????????????????\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n};\n\nint N, M, a[50000], b[50000], c[50000];\nvector<P> vh, vc;\n\nint solve2(UnionFind &uf, const vector<int> &l, int z){\n\tint sum = 0;\n\tUnionFind ufl = uf;\n\tfor(auto t: l){\n\t\tufl.unite( z, t );\n\t}\n\tfor(auto c: vc){\n\t\tint i = c.second;\n\t\tif( uf.find(a[i], b[i]) ) continue;\n\t\tif( !ufl.find(z, a[i]) ) continue;\n\t\tif( !ufl.find(z, b[i]) ) continue;\n\t\tuf.unite( a[i], b[i] );\n\t\tsum += c.first;\n\t}\n\treturn sum;\n}\n\nint solve(int limit){\n\tint now = limit;\n\tint z = vh[0].second;\n\tint ans = 0;\n\tUnionFind uf(205);\n\tvector<int> l;\n\tfor(auto v: vh){\n\t\t//if( v.first < limit ) continue;\n\t\t//if( now == 0 ) now = v.first;\n\t\tif( v.first >= limit && now != v.first ){\n\t\t\tans += solve2(uf, l, z);\n\t\t\t//cout << v.first << \" \" << ans << endl;\n\t\t\tl.clear();\n\t\t}\n\t\tl.push_back( v.second );\n\t\tnow = max( v.first, limit );\n\t}\n\treturn ans;\n}\n\nint calc(){\n\tint limit = 0;\n\twhile(1){\n\t\tint nx = vh.size()-1;\n\t\tbool sink[205]={}; sink[0] = true;\n\t\twhile(limit <= vh[nx].first){\n\t\t\tsink[ vh[nx].second ] = true;\n\t\t\tnx--;\n\t\t\tif( nx <= 0 ) break;\n\t\t}\n\t\tif( nx <= 0 ) break;\n//\t\tcout << \"ok\" << nx << endl;\n\n\t\tUnionFind uf(205);\n\t\tint z = vh[0].second;\n\t\tfor(auto c: vc){\n\t\t\tint i = c.second;\n\t\t\tif( sink[ a[i] ] || sink[ b[i] ] ) continue;\n\t\t\tuf.unite( a[i], b[i] );\n\t\t}\n\t\tbool f = false;\n\t\trep(i,N+1) if( !sink[i] && !uf.find(z,i) ) f = true;\n\t\tif(f) break;\n\t\tlimit = vh[nx].first;\n\t}\n\treturn limit;\n}\n\nint main(){\n\twhile(cin >> N >> M, N|M){\n\t\tvh.clear(); vc.clear();\n\t\trep(i,N){\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\tvh.emplace_back( -h, i+1 );\n\t\t}\n\t\tvh.emplace_back(0,0);\n\t\tsort( vh.begin(), vh.end() );\n\t\trep(i,M){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tvc.emplace_back( c[i], i );\n\t\t}\n\t\tsort( vc.begin(), vc.end() );\n\t\t//cout << calc() << endl;\n\t\tcout << solve( calc() ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0;i<(int)n;i++)\n#define reep(i, s, t) for(int i=s;i<(int)t;i++)\n#define irep(i, n) for(int i=(int)n-1;i>=0;i--)\n#define ireep(i, n, s) for(int i=(int)n-1;i>=s;i--)\n#define all(v) v.begin(), v.end()\n#define vc vector\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nstruct Edge\n{\n\tint to, from;\n\tint cost;\n\n\tEdge( int to, int from, int cost ) :to(to), from(from), cost(cost)\n\t{}\n\n\tfriend bool operator < ( const Edge& e1, const Edge& e2 )\n\t{\n\t\treturn e1.cost < e2.cost;\n\t}\n};\n\nint root[200];\nint Get_root ( int x )\n{\n\tif( root[x] == x ){\n\t\treturn x;\n\t}\n\treturn root[x] = Get_root(root[x]);\n}\n\nvoid add ( int x, int y )\n{\n\tx = Get_root(x); y = Get_root(y);\n\tif( x != y ){\n\t\troot[y] = x;\n\t}\n}\n\nint kruskal ( vi node, vector<Edge> e)\n{\n\tsort(all(e));\n\n\tint ret = 0;\n\trep(i,e.size()){\n\t\tbool flag = true;\n\t\trep(j, node.size()){\n\t\t\tif( node[j] == e[i].to ){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( flag ){\n\t\t\tcontinue;\n\t\t}\n\n\t\tflag = true;\n\t\trep(j, node.size()){\n\t\t\tif( node[j] == e[i].from ){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( flag ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( Get_root(e[i].to) != Get_root(e[i].from) ){\n\t\t\tret += e[i].cost;\n\t\t\tadd(e[i].to, e[i].from);\n\t\t}\n\t}\n\trep(i, (int)node.size()-1){\n\t\tif(Get_root(node[i]) != Get_root(node[i+1])) return -(1<<30);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint N, M;\n\twhile( cin >> N >> M, N != 0 ){\n\t\tmap<int, vi> nodes;\n\t\tvector<Edge> e;\n\n\t\trep(i, N){\n\t\t\troot[i] = i;\n\t\t}\n\n\t\trep(i, N){\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\tnodes[-h].pb(i);\n\t\t}\n\n\t\trep(i, M){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\t--a; --b;\n\t\t\te.pb( Edge(a, b, c) );\n\t\t}\n\n\t\tint ans = 0;\n\t\tvi cur_node;\n\t\tmap<int, vi>::iterator itr = nodes.begin();\n\t\twhile( itr != nodes.end() ){\n\t\t\trep(i, itr->second.size()){\n\t\t\t\tcur_node.pb( itr->second[i] );\n\t\t\t}\n\t\t\tans += kruskal(cur_node, e);\n\t\t\tif(ans < 0){\n\t\t\t\tans = 0;\n\t\t\t\trep(i, N) root[i] = i;\n\t\t\t}\n\t\t\t// cout << ans << endl;\n\t\t\t++itr;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\ntypedef pair<ll, l_l> lll;\nint N, M;\nint h[200];\nint a[50000], b[50000], c[50000];\nmap<int, vector<lll>> mp;\nmap<int, int> num;\n\nvoid solve() {\n    mp.clear();\n    num.clear();\n    int Last = 0;\n    for(int i = 0; i < N; i++) {\n        cin >> h[i];\n        num[h[i]]++;\n        mp[-h[i]].push_back({-1, {i, i}});\n        if(h[i] > h[Last]) Last = i;\n    }\n    for(int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i] >> c[i];\n        a[i]--;\n        b[i]--;\n        int day = min(h[a[i]], h[b[i]]);\n        mp[-day].push_back({c[i], {a[i], b[i]}});\n    }\n    UnionFind uni(N);\n    ll ans = 0;\n    ll nownum = 0;\n    int DeadLine = 1e9;\n    for(auto tmp : mp) {\n        //cerr << \"----day: \" << -tmp.first << \"------\" << endl;\n        auto v = tmp.second;\n        //nownum += num[-tmp.first];\n        sort(v.begin(), v.end());\n        for(auto tmp2 : v) {\n            if(tmp2.first == -1) {\n                nownum++;\n                continue;\n            }\n            if(uni.merge(tmp2.second.first, tmp2.second.second)) {\n                ans += tmp2.first;\n            }\n        }\n        //cerr << uni.size(Last) << \" \" << nownum << endl;\n        if(nownum != uni.size(Last)) DeadLine = -tmp.first;\n    }\n    //cerr << DeadLine << endl;\n    ans = 0;\n    uni = UnionFind(N);\n    vector<lll> Query;\n    for(auto tmp : mp) {\n        auto v = tmp.second;\n        nownum += num[-tmp.first];\n        sort(v.begin(), v.end());\n        for(auto tmp2 : v) {\n            if(tmp2.first == -1) {\n                continue;\n            }\n            Query.push_back(tmp2);\n            continue;\n            /*\n            if(uni.merge(tmp2.second.first, tmp2.second.second)) {\n                ans += tmp2.first;\n            }\n            */\n        }\n        if(-tmp.first >= DeadLine) continue;\n        sort(Query.begin(), Query.end());\n        for(auto tmp:Query) {\n            if(uni.merge(tmp.second.first, tmp.second.second)) {\n                ans += tmp.first;\n            }\n        }\n        //cerr << uni.size(Last) << \" \" << nownum << endl;\n    }\n    if(uni.size(0) != N) ans = 0;\n    cout << ans << endl;\n}\n\nint main() {\n    while(true) {\n        cin >> N >> M;\n        if(N == 0 and M == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nstruct unionfind {\n    vector<int> data;\n    unionfind(int size) : data(size, -1) {}\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nstruct edge {\n    int u, v, cost;\n};\n\nint main(){\n    int V, E;\n    while (cin >> V >> E, V | E){\n        vector<int> h(V);\n        vector<edge> es(E);\n        set<int> hs;\n        hs.insert(0);\n        rep(i, V){\n            cin >> h[i];\n            hs.insert(h[i]);\n        }\n\n        rep(i, E){\n            int a, b, c; cin >> a >> b >> c;\n            a--; b--;\n            es[i] = { a, b, c };\n        }\n        sort(all(es), [](edge a, edge b){\n            return a.cost < b.cost;\n        });\n\n        int ans = 0;\n        unionfind uf(V);\n        for (auto it = hs.rbegin(); it != hs.rend(); ++it){\n            set<int> s;\n            rep(i, V){\n                if (*it <= h[i]){\n                    s.insert(i);\n                }\n            }\n            rep(j, E){\n                const edge& e = es[j];\n                if (!uf.same(e.u, e.v) && s.count(e.u) && s.count(e.v)){\n                    uf.unite(e.u, e.v);\n                    ans += e.cost;\n                }\n            }\n            if (s.size() != uf.size(*s.begin())){\n                ans = 0;\n                uf = unionfind(V);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nclass UF{\nprivate:\n    vector<int> par,rank,elm;\n    vector<vector<int>> elmList;\t//don't be validated\npublic:\n    int groups;\n    \n    UF(int __size):par(__size) , rank(__size,0) , elm(__size,1) , groups(__size), elmList(__size){\n        rep(i,__size)elmList[i] = vector<int>(1,i);\n        for(int i=0;i<__size;i++)par[i]=i;\n    }\n    \n    int getElements(int n){ return elm[find(n)]; }\n    vector<int> getElementsList(int n){ return elmList[find(n)]; }\n    \n    int find(int x){\n        if(par[x]==x) {\n            return x;\n        }else{\n            return par[x]=find(par[x]);\n        }\n    }\n    \n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        \n        groups--;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n            elm[y]+=elm[x];\n            for(auto &e:elmList[x])elmList[y].pb(e);\n            \n        }else{\n            par[y]=x;\n            elm[x]+=elm[y];\n            for(auto &e:elmList[y])elmList[x].pb(e);\n            if(rank[x]==rank[y])rank[x]++;\n        }\n    }\n    \n    bool isSame(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\n\n#define MAX_V 200\nstruct edge{int to,cost;};\nint v,e;\n\n\nint main(){\n    while(cin>>v>>e&&(v||e)){\n        vector<edge> G[MAX_V];\n        vector<int> h(v);\n        map<int,int> zip;\n        set<int> nums;\n        rep(i,v){\n            cin>>h[i];\n            nums.insert(h[i]);\n        }\n        \n        rep(i,e){\n            int s,t,c;\n            cin>>s>>t>>c;\n            s--,t--;\n            G[s].pb(edge{t,c});\n            G[t].pb(edge{s,c});\n        }\n        \n        int count=0;\n        for(auto e:nums){\n            zip[e] = count++;\n        }\n        rep(i,v)h[i] = zip[h[i]];\n        \n        auto connected = [&](int d){\n            UF uf(v);\n            rep(i,v){\n                for(auto u:G[i]){\n                    if( h[u.to]>=d && h[i]>=d ){\n                        uf.unite(u.to,i);\n                    }\n                }\n            }\n            int val = -1;\n            rep(i,v){\n                if(h[i]>=d){\n                    if(val==-1)val = uf.find(i);\n                    else{\n                        if(uf.find(i)!=val)return false;\n                    }\n                }\n            }\n            return true;\n        };\n        \n        int ng_point = -1;\n        for(auto d:nums){\n            if( !connected(zip[d]) ){\n                ng_point = zip[d];\n                break;\n            }\n        }\n        \n        if(ng_point==-1)ng_point = nums.size();\n        \n        \n        auto kruskal = [&](){\n            int ret=0;\n            vector<pair<int,pii>> edges;\n            \n            rep(i,MAX_V)for(auto &e:G[i])edges.pb(make_pair(e.cost,pii(i,e.to)));\n            \n            sort(all(edges));\n            \n            UF uf(v);\n            \n            for(int k=ng_point-1;k>=0;k--){\n                rep(i,edges.size()){\n                    int c,u,v;\n                    c = edges[i].first;\n                    tie(u,v) = edges[i].second;\n                    \n                    if( h[u]>=k && h[v]>=k && !uf.isSame(u,v)){\n                        //                    cout<<h[u]<<\" \"<<h[v]<<\" \"<<k<<endl;\n                        //                    cout<<\"unite \"<<u<<\" \"<<v<<endl;\n                        uf.unite(u,v);\n                        ret+=c;\n                    }\n                }\n                \n                assert(connected(k));\n            }\n            return ret;\n        };\n        \n        cout<<kruskal()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Edge{\npublic:\n    int from, to, cost;\n    Edge(int from, int to, int cost) : from(from), to(to), cost(cost){};\n    \n    bool operator < (const Edge& right)const{\n        return cost < right.cost;\n    }\n};\n\nclass UnionFind {\n    vector<int> par;\n    int cnt;\npublic:\n    UnionFind(int size_) : par(size_, -1), cnt(size_) { }\n    void unite(int x, int y){\n        if ((x = find(x)) != (y = find(y))) {\n            if (par[y] < par[x]) swap(x, y);\n            par[x] += par[y]; par[y] = x; cnt--;\n        }\n    }\n    bool same(int x, int y){ return find(x) == find(y); }\n    int find(int x){ return par[x] < 0 ? x : par[x] = find(par[x]); }\n    int size(int x){ return -par[find(x)]; }\n    int size(){ return cnt; }\n};\n\nint N, M;\n\nvoid solve(){\n    vector<pair<int, int>> islands;\n    for(int i=0; i<N; i++){\n        int h; cin >> h;\n        islands.push_back(make_pair(-h, i));\n    }\n    sort(islands.begin(), islands.end());\n    \n    vector<Edge> edges;\n    for(int i=0; i<M; i++){\n        int a, b, c;\n        cin >> a >> b >> c; a--; b--;\n        edges.push_back({a, b, c});\n    }\n    sort(edges.begin(), edges.end());\n    \n    int ans = 0;\n    auto uf = UnionFind(N);\n    set<int> exists;\n    int p = 0;\n    while(p < N){\n        int h = islands[p].first;\n        while(p < N && islands[p].first == h){\n            exists.insert(islands[p].second);\n            p++;\n        }\n        for(auto edge: edges){\n            if(exists.count(edge.from) && exists.count(edge.to) && !uf.same(edge.from, edge.to)){\n                uf.unite(edge.from, edge.to);\n                ans += edge.cost;\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin >> N >> M, N|M){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nstruct UF\n{\n    vector<ll> par; // 親\n    vector<ll> sz; // 数\n    // 初期化\n    UF(ll n):par(n),sz(n) {\n        for(ll i = 0; i < n; i++){\n            par[i] = i;sz[i] = 1;\n        }\n    }\n    // 木の根を求める\n    ll find(ll x) {\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    // xとyの属する集合を併合\n    void unite(ll x, ll y) {\n        x = find(x); y = find(y);\n        if (x == y) return;\n        par[x] = y;\n        sz[y] += sz[x];\n    }\n    // xとyが同じ集合ならtrue\n    bool same(ll x, ll y) { return find(x) == find(y); }\n    ll size(ll n){return sz[find(n)];}\n};\n \nll n,m;\nvector<pair<ll,ll>> h;\nvector<pair<ll,pair<ll,ll>>> v;\nbool sink[222];\n \nll check(ll num){\n    UF uf(n);\n    ll ret = 0;\n    REP(i,m){\n        ll A = v[i].SE.FI;\n        ll B = v[i].SE.SE;\n        ll C = v[i].FI;\n        if(sink[A] | sink[B])continue;\n        if(!uf.same(A,B)){\n            uf.unite(A,B);\n            ret += C;\n        }\n    }\n    ll cou = 0;\n    REP(i,n){\n        cou = max(cou,uf.size(i));\n    }\n    return (cou == num ? ret : -1);\n}\n \nint main(){\n    while(cin >> n >> m,n|m){\n        h.clear();\n        v.clear();\n        REP(i,222)sink[i] = false;\n         \n        REP(i,n){\n            ll tmp;\n            cin >> tmp;\n            h.PB(MP(tmp,i));\n        }\n         \n        REP(i,m){\n            ll a,b,c;\n            cin >> a >> b >> c;\n            a--;b--;\n            v.PB(MP(c,MP(a,b)));\n        }\n         \n        sort(ALL(h));\n        sort(ALL(v));\n         \n        ll prev = check(n);\n        ll sinknum;\n        if(prev == -1){\n            cout << 0 << endl;\n        }\n        else{\n            bool flag = false;\n            for(sinknum = 0;sinknum < n-1;sinknum++){\n                while(sinknum < n-1 && h[sinknum].FI == h[sinknum+1].FI){\n                    sink[h[sinknum].SE] = true;\n                    sinknum++;\n                }\n                sink[h[sinknum].SE] = true;\n                ll now = check(n-sinknum-1);\n                if(now == -1){\n                    flag = true;\n                    break;\n                }\n                prev = now;\n            }\n            sink[h[sinknum].SE] = false;\n            sinknum--;\n            DBG(cout << \"prev \" << prev << \" sinknum \" << sinknum << endl;)\n            DBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n            ll tmp = 0;\n            for(ll i = sinknum;i >= 0;i--){\n                vector<ll> li;\n                while(i > 0 && h[i].FI == h[i-1].FI){\n                    li.PB(i);\n                    i--;\n                }\n                li.PB(i);\n                DBG(cout << \"size \" << li.size() << endl;);\n                REP(j,m){\n                    ll A = v[j].SE.FI;\n                    ll B = v[j].SE.SE;\n                    ll C = v[j].FI;\n                    ll seica = -1;\n                    REP(k,li.size())if(sink[h[li[k]].SE] && (A == h[li[k]].SE || B == h[li[k]].SE))seica = li[k];\n                    if(seica != -1 && (sink[A] ^ sink[B])){\n                        tmp += C;\n                        sink[h[seica].SE] = false;\n                        j = 0;\n                    }\n                }\n                DBG(cout << \"i \" << i << endl;);\n            }\n            DBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n            cout << prev + tmp << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nusing T = tuple<int64, int64, int64>;\n\nclass UnionFind{\nprivate:\n  ::std::vector<int_fast32_t> par;\n  size_t n;\n\npublic:\n  UnionFind(){}\n  UnionFind(size_t n):n(n){\n    par.resize(n, -1);\n  }\n\n  uint_fast32_t find(uint_fast32_t x){\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  size_t size(uint_fast32_t x){\n    return -par[find(x)];\n  }\n\n  bool unite(uint_fast32_t x, uint_fast32_t y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return false;\n    if(size(x) < size(y)) std::swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool same(uint_fast32_t x, uint_fast32_t y){\n    return find(x) == find(y);\n  }\n};\n\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int64 N, M;\n  while (cin >> N >> M && N + M) {\n    vector<PLL> h(N);\n    REP(i, N) {\n      cin >> h[i].fs; h[i].fs *= -1; h[i].sc = i;\n    }\n    vector<vector<int64>> con(N);\n    vector<T> edges(M);\n    REP(i, M) {\n      int64 a, b, c;\n      cin >> a >> b >> c;\n      edges[i] = T(c, a-1, b-1);\n      con[a-1].push_back(i);\n      con[b-1].push_back(i);\n    }\n    vector<T> usable_edge;\n\n    UnionFind ok(N);\n    vector<int> canuse(N, 0);\n    sort(all(h));\n    UnionFind uf(N);\n    int64 idx = 0, res = 0, par = h[0].sc;\n    while (idx < h.size()) {\n      canuse[h[idx].sc] = 1;\n      REP(i, con[h[idx].sc].size()) {\n        usable_edge.push_back(edges[con[h[idx].sc][i]]);\n        int64 a, b, c;\n        tie(c, a, b) = edges[con[h[idx].sc][i]];\n        if (canuse[a] && canuse[b]) ok.unite(a, b);\n      }\n      if (idx < h.size()-1 && h[idx].fs == h[idx+1].fs) {\n        idx++;\n        continue;\n      }\n      if (ok.size(par) == idx+1) {\n        sort(all(usable_edge));\n        REP(i, usable_edge.size()) {\n          int64 a, b, c;\n          tie(c, a, b) = usable_edge[i];\n          if (uf.same(a, b)) {\n            continue;\n          } else if (canuse[a] && canuse[b]) {\n            uf.unite(a, b);\n            res += c;\n          }\n        }\n      } else {\n        uf = UnionFind(N);\n        res = 0;\n      }\n      idx++;\n    }\n    cout << res << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<Int, P> T;\n\nInt u[1080];\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(Int x, Int y){\n\tu[r(x)] = r(y);\n}\nvector<T> edge[1080000];\nInt h[1080];\nbool come[1080];\nint main(){\n\tInt n, m;\n\twhile(cin >> n >> m, n | m){\n\t\tInt res = 0, bridge = 0, a, b, c, cnt = 0;\n\t\tfor(Int i = 0;i < n;i++)cin >> h[i], u[i] = i, come[i] = false;\n\t\tfor(Int i = 0;i < m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tedge[min(h[a], h[b])].push_back(T(c, P(a, b)));\n\t\t}\n\t\tInt breakpoInt = 1000000;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tif(!come[from])cnt++, come[from] = true;\n\t\t\t\t\tif(!come[to])cnt++, come[to] = true;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt && cnt - 1 != bridge){\n\t\t\t\tbreakpoInt = i;\n\t\t\t}\n\t\t}                    \n\t\tbridge = 0;\n\t\tvector<T> tmp;\n\t\tfor(Int i = 0;i < n;i++)u[i] = i;\n\t\tif(breakpoInt)breakpoInt--;\n\t\tfor(Int i = 1000000;i >= breakpoInt;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\ttmp.push_back(edge[i][j]);\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor(Int i = 0;i < tmp.size();i++){\n\t\t\tInt from = tmp[i].second.first, to = tmp[i].second.second;\n\t\t\tif(r(from) != r(to)){\n\t\t\t\tbridge++;\n\t\t\t\tres += tmp[i].first;\n\t\t\t\tunite(from, to);\n\t\t\t}\n\t\t}\n\t\tfor(Int i = breakpoInt;i > 0;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tres += edge[i][j].first;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tedge[i].clear();\n\t\t}\n\t\tif(bridge + 1 != n)res = 0;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nvector<PII> g[205];\nVI t[205];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    REP(i, 205) g[i].clear(), t[i].clear();\n    uf.init(n);\n    VI h(n), hh(n);\n    REP(i, n) cin >> h[i], hh[i] = h[i];\n    VI a(m), b(m), c(m);\n    REP(i, m) {\n      cin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n      g[a[i]].PB({b[i], c[i]});\n      g[b[i]].PB({a[i], c[i]});\n    }\n\n    VI ver(n);\n    sort(ALL(hh));\n    hh.erase(unique(ALL(hh)), hh.end());\n    REP(i, n) h[i] = lower_bound(ALL(hh), h[i]) - hh.begin();\n    REP(i, n) {\n      t[h[i]].PB(i);\n      ver[i] = h[i];\n    }\n\n    int last = hh.size()-1;\n    vector<bool> exist(true, n);\n    vector<bool> used(false, n);\n\n    function<void(int)> dfs = [&](int x) {\n      used[x] = true;\n      for(auto i: g[x]) {\n        if(!used[i.first]) dfs(i.first);\n      }\n    };\n\n    REP(i, hh.size()) {\n      // 時刻iで沈む頂点を除く\n      for(int j: t[i]) exist[j] = false;\n      REP(j, n) used[j] = !exist[j];\n\n      // dfsで連結性を確かめる\n      int cnt = 0;\n      REP(j, n) {\n        if(used[j]) continue;\n        dfs(j);\n        cnt++;\n      }\n      if(cnt >= 2) {\n        last = i;\n        break;\n      }\n    }\n\n    // そもそも二つに分裂してる状態\n    // dfsで連結性を確かめる\n    used.assign(n, false);\n    int cnt = 0;\n    REP(j, n) {\n      if(used[j]) continue;\n      dfs(j);\n      cnt++;\n    }\n    if(cnt >= 2) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    VVI edge[205];\n    REP(i, m) edge[min(ver[a[i]], ver[b[i]])].PB({c[i], a[i], b[i]});\n    // REP(i, hh.size()) cout << edge[i] << \" \" << t[i] << endl;\n\n    // 時刻[last, hh.size()-1]までで沈む頂点に関する辺集合\n    VVI vec;\n    FOR(i, last, hh.size()) {\n      for(auto j: edge[i]) {\n        vec.PB(j);\n      }\n    }\n    // cout << vec << endl;\n    sort(ALL(vec));\n    int ans = 0;\n    for(auto j: vec) {\n      if(uf.same(j[1], j[2])) continue;\n      ans += j[0];\n      uf.unite(j[1], j[2]);\n    }\n    // cout << ans << endl;\n\n    for(int i=last-1; i>=0; --i) {\n      // 時間iで沈む頂点に関連する辺集合\n      sort(ALL(edge[i]));\n      for(auto j: edge[i]) {\n        if(uf.same(j[1], j[2])) continue;\n        ans += j[0];\n        uf.unite(j[1], j[2]);\n      }\n      // cout << ans << endl;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\ntypedef long long int i64;\ntypedef pair<int, int> pint;\n\nstruct UnionFind {\n    vector<int> data; int group;\n    UnionFind(int N) : data(N, -1), group(N) {}\n    void init(int N) {\n        data.assign(N, -1);\n        group = N;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            --group;\n        }\n    }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]);}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\n\nstruct Edge {\n    int from, to, cost;\n    Edge(int f, int t, int c)\n         :from(f), to(t), cost(c) {}\n    bool operator< (const Edge& E) const {\n        return cost < E.cost;\n    }\n};\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int N, M;\n    while(cin >> N >> M && N) {\n        vector<pint> h(N);\n        rep(i, N) {\n            cin >> h[i].first;\n            h[i].second = i;\n        }\n        sort(h.begin(), h.end(), greater<pint>());\n        vector<vector<int>> mat(N, vector<int>(N, 0));\n        int a, b, c;\n        rep(i, M) {\n            cin >> a >> b >> c;\n            --a; --b;\n            mat[a][b] = mat[b][a] = c;\n        }\n        UnionFind uf(N);\n        int ans = 0;\n        bool is_spt = false;\n        vector<int> notsink;\n        multiset<Edge> edges; int edgemax = 0;\n        rep(i, N) {\n            int i2 = i;\n            for(; i2 < N && h[i].first == h[i2].first; ++i2);\n            multiset<Edge> bridge;\n            REP(j, i, i2) notsink.push_back(h[j].second);\n            REP(j, i, i2) {\n                for(int k : notsink) if(mat[h[j].second][k]) {\n                    bridge.insert(Edge(h[j].second, k, mat[h[j].second][k]));\n                    edges.insert(Edge(h[j].second, k, mat[h[j].second][k]));\n                }\n            }\n            if(is_spt) {\n                for(const auto& e : bridge)\n                  if(!uf.same(e.from, e.to)) {\n                      uf.unite(e.from, e.to);\n                      ans += e.cost;\n                  }\n            }else {\n                uf.init(N); ans = 0;\n                for(const auto& e: edges) {\n                    if(!uf.same(e.from, e.to)) {\n                        uf.unite(e.from, e.to);\n                        ans += e.cost;\n                    }\n                }\n            }\n            if(uf.group == N - notsink.size() + 1) is_spt = true; else is_spt = false;\n            i = i2 - 1;\n            int k = edges.size();\n            edgemax = max(edgemax, k);\n        }\n        if(is_spt) cout << ans << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank,Size;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tSize=vi(n,1);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tint Find_Size(int x){\n\t\treturn Size[Find_Par(x)];\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]){\n\t\t\tPar[x]=y;\n\t\t\tSize[y]+=Size[x];\n\t\t}\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tSize[x]+=Size[y];\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nconst int M=1000001;\n\nint n,m;\nvvi a,g;\nvi u,v,c;\nvip e;\n\nvoid dfs(int w,vi& tmp,vi& used){\n\ttmp[w]=1;\n\tfor(int i=0;i<g[w].size();i++){\n\t\tint s=g[w][i];\n\t\tif(used[s]&&!tmp[s]) dfs(s,tmp,used);\n\t}\n}\n\nvoid DFS(int w,vi& used){\n\tused[w]=1;\n\tfor(int i=0;i<g[w].size();i++){\n\t\tint s=g[w][i];\n\t\tif(!used[s]) DFS(s,used);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(!n) break;\n\t\ta=vvi(M);\n\t\tu=v=c=vi(m);\n\t\te=vip(m);\n\t\tg=vvi(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint h;\n\t\t\tcin>>h;\n\t\t\ta[h].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>u[i]>>v[i]>>c[i];\n\t\t\tu[i]--;\n\t\t\tv[i]--;\n\t\t\te[i]={c[i],{u[i],v[i]}};\n\t\t\tg[u[i]].push_back(v[i]);\n\t\t\tg[v[i]].push_back(u[i]);\n\t\t}\n\t\tvi Vec(n);\n\t\tDFS(0,Vec);\n\t\tbool b=1;\n\t\tfor(int i=0;i<n;i++) if(!Vec[i]) b=0;\n\t\tif(!b){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tsort(e.begin(),e.end());\n\t\tll res=0,V=n;\n\t\tvi used(n,1);\n\t\tfor(int i=0;i<M;i++) if(!a[i].empty()){\n\t\t\tint S=a[i].size();\n\t\t\tV-=S;\n\t\t\tfor(int j=0;j<S;j++) used[a[i][j]]=0;\n\t\t\tvi tmp(n);\n\t\t\tfor(int j=0;j<n;j++) if(used[j]){\n\t\t\t\tdfs(j,tmp,used);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!V||used!=tmp){\n\t\t\t\tUnion_Find_Tree uft(n);\n\t\t\t\tdo{\n\t\t\t\t\tS=a[i].size();\n\t\t\t\t\tfor(int j=0;j<S;j++) used[a[i][j]]=1;\n\t\t\t\t\tif(S){\n\t\t\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\t\t\tP p=e[j].second;\n\t\t\t\t\t\t\tint s=p.first,t=p.second;\n\t\t\t\t\t\t\tif(used[s]&&used[t]&&!uft.Same(s,t)){\n\t\t\t\t\t\t\t\tres+=e[j].first;\n\t\t\t\t\t\t\t\tuft.Unite(s,t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti--;\n\t\t\t\t}while(i>=0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint n,m,h[N],a,b,c,X;\nvector<int> edge[N];\nvector<int> v;\nvector<P1> e;\nbool used[N];\nint par[N];\nset<int> s;\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x!=y)par[x]=y;\n}\n\nbool check(int A,int B){\n  bool x[N];\n  memset(x,0,sizeof(x));\n  for(int i=0;i<n;i++)par[i]=i;\n  for(int i=0;i<e.size();i++){\n    int n1=e[i].second.first;\n    int n2=e[i].second.second;\n    if(!(A<=h[n1]&&h[n1]<=B))continue;\n    if(!(A<=h[n2]&&h[n2]<=B))continue;\n    if(find(n1)!=find(n2)){\n      unite(n1,n2);\n      x[n1]=x[n2]=true;\n    }\n  }\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(!(A<=h[i]&&h[i]<=B))continue;\n    if(!x[i])res=false,cnt++;\n  }\n  if(A==B&&cnt==1)res=true;\n  return res;\n}\n\nvoid dfs(int x){\n  used[x]=true;\n  for(int i=0;i<edge[x].size();i++){\n    int nx=edge[x][i];\n    if(!used[nx])dfs(nx);\n  }\n}\n\nint kruskal(){\n  int res=0,X2=(int)v.size()-1;\n  for(int i=0;i<n;i++)par[i]=i;\n  if(X>=0){\n    for(int i=0;i<e.size();i++){\n      int n1=e[i].second.first;\n      int n2=e[i].second.second;\n      if(!(v[X]<=h[n1]&&h[n1]<=v[X2]))continue;\n      if(!(v[X]<=h[n2]&&h[n2]<=v[X2]))continue;\n      if(find(n1)!=find(n2)){\n\tunite(n1,n2);\n\tres+=e[i].first;\n      }\n    }\n  }\n  if(X==-1)X=X2+1;\n  for(int k=X-1;k>=0;k--){\n    for(int i=0;i<e.size();i++){\n      int n1=e[i].second.first;\n      int n2=e[i].second.second;\n      if(!(v[k]<=h[n1]&&h[n1]<=v[X2]))continue;\n      if(!(v[k]<=h[n2]&&h[n2]<=v[X2]))continue;\n      if(find(n1)!=find(n2)){\n\tunite(n1,n2);\n\tres+=e[i].first;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n      s.insert(h[i]);\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      edge[a-1].push_back(b-1);\n      edge[b-1].push_back(a-1);\n      e.push_back(P1(c,P(a-1,b-1)));\n    }\n    sort(e.begin(),e.end());\n    set<int>::iterator ite;\n    for(ite=s.begin();ite!=s.end();ite++)\n      v.push_back(*ite);\n    v.push_back(v[0]);\n    sort(v.begin(),v.end());\n    X=-1;\n    for(int i=0;i<v.size();i++)\n      if(!check(v[i],v[(int)v.size()-1])){\n\tX=i-1;\n\tbreak;\n      }\n    memset(used,0,sizeof(used));\n    dfs(0);\n    int f=0;\n    for(int i=0;i<n;i++)\n      if(!used[i])f=1;\n    if(f)cout<<0<<endl;\n    else cout<<kruskal()<<endl;\n    for(int i=0;i<n;i++)edge[i].clear();\n    e.clear();\n    v.clear();\n    s.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = 1'000'000'007;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nstruct Edge {\n\tint s, d; Weight w;\n\tEdge() {};\n\tEdge(int s, int d, Weight w) : s(s), d(d), w(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (sizeOf(x) < sizeOf(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint sizeOf(int x) { return -parent[root(x)]; }\n};\n\ntemplate<class T, class ...Tail>\nvoid tiedSort(vector<T> &a, vector<Tail>&... tail) {\n\tint n = a.size();\n\tusing S = tuple<T, Tail...>;\n\tvector<S> s(n);\n\tfor (int i = 0; i < n; i++)\n\t\ts[i] = make_tuple(a[i], tail[i]...);\n\tsort(s.begin(), s.end());\n\tfor (int i = 0; i < n; i++)\n\t\ttie(a[i], tail[i]...) = s[i];\n}\n\npair<Weight, Edges> kruskal(const Graph &g) {\n\tint n = g.size();\n\tUnionFind uf(n);\n\tEdges es;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto &e : g[i])\n\t\t\tes.push_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges mst;\n\tfor (auto &e : es)\n\t\tif (!uf.same(e.s, e.d)) {\n\t\t\tuf.unite(e.s, e.d);\n\t\t\tmst.push_back(e);\n\t\t\ttotal += e.w;\n\t\t}\n\treturn make_pair(total, mst);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M; cin >> N >> M && N;) {\n\t\tvector<int> h(N); rep(i, 0, N) {\n\t\t\tcin >> h[i];\n\t\t}\n\t\tvector<int> a(M), b(M), c(M); rep(i, 0, M) {\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\ta[i]--, b[i]--;\n\t\t}\n\t\ttiedSort(c, a, b);\n\n\t\tvector<int> id(N); iota(all(id), 0);\n\n\t\ttiedSort(h, id);\n\t\tdump(id);\n\n\n\t\tUnionFind uff(N);\n\t\trep(i, 0, M)\n\t\t\tuff.unite(a[i], b[i]);\n\t\tif (uff.size != 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<vector<int>> v;\n\t\tvector<int> t;\n\t\trep(i, 0, N) {\n\t\t\tif (t.size() == 0 || h[t.back()] == h[i]) {\n\t\t\t\tt.push_back(i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv.push_back(t);\n\t\t\t\tt.clear();\n\t\t\t\tt.push_back(i);\n\t\t\t}\n\t\t}\n\t\tif (t.size())v.push_back(t);\n\t\tdump(v);\n\n\t\tunordered_set<int> st;\n\t\tint x;\n\t\tfor (x = 0; x < v.size() - 1; x++) {\n\t\t\tUnionFind uf(N);\n\t\t\tfor (auto u : v[x]) {\n\t\t\t\tst.emplace(id[u]);\n\t\t\t}\n\t\t\trep(j, 0, M) {\n\t\t\t\tif (st.count(a[j]) || st.count(b[j]))\n\t\t\t\t\tcontinue;\n\t\t\t\tuf.unite(a[j], b[j]);\n\t\t\t}\n\t\t\tdump(uf.parent);\n\t\t\tif (uf.sizeOf(id[v.back().front()]) != N - st.size())\n\t\t\t\tbreak;\n\t\t}\n\t\tdump(x);\n\t\tfor (auto u : v[x])\n\t\t\tst.erase(id[u]);\n\t\tdump(st);\n\n\t\tGraph g(N);\n\t\trep(i, 0, M) {\n\t\t\tif (st.count(a[i]) || st.count(b[i]))\n\t\t\t\tcontinue;\n\t\t\taddEdge(g, a[i], b[i], c[i]);\n\t\t}\n\t\tauto res = kruskal(g);\n\t\tdump(res);\n\n\t\tUnionFind uf(N);\n\t\tfor (auto e : res.second) {\n\t\t\tuf.unite(e.d, e.s);\n\t\t}\n\n\t\tint cost = res.first;\n\t\tdump(cost);\n\n\t\trrep(y, 0, x) {\n\t\t\tfor (auto u : v[y])\n\t\t\t\tst.erase(id[u]);\n\t\t\tint add = 0;\n\t\t\trep(j, 0, M) {\n\t\t\t\tif (st.count(a[j]) || st.count(b[j]))continue;\n\t\t\t\tif (!uf.same(a[j], b[j])) {\n\t\t\t\t\tuf.unite(a[j], b[j]);\n\t\t\t\t\tadd += c[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcost += add;\n\t\t\tdump(uf.parent);\n\t\t\tdump(cost);\n\t\t}\n\n\t\tcout << cost << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvp ti(n+1,{1,-1});\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n){\n\t\t\tint a;cin>>a;\n\t\t\tti[i]={a*-1,i};\n\t\t}\n\t\tsort(all(ti));\n\t\tint t=0;\n\t\tUnionFind uf(n);\n\t\tvi used(n);\n\t\tvvi G(m,vi(3));\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tG[i]={a,b,c};\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\tint T=-1;\n\t\twhile(t!=n){\n\t\t\tused[ti[t].second]=true;\n\t\t\twhile(ti[t].second==ti[t+1].second){\n\t\t\t\tt++;\n\t\t\t\tused[ti[t].second]=true;\n\t\t\t}\n\t\t\trep(i,m)if(used[G[i][0]]&&used[G[i][1]])uf.unionSet(G[i][0],G[i][1]);\n\t\t\tt++;\n\t\t\tif(uf.size(ti[0].second)!=t)T=t;\n\t\t}\n\t\tif(uf.size(0)!=n){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tused=vi(n);\n\t\tint sum=0;\n\t\tvi d(n,inf);\n\t\td[ti[0].second]=0;\n\t\trep(j,n){\n\t\t\tint v;\n\t\t\tif(ti[T].first<ti[j].first){\n\t\t\t\tv=-1;\n\t\t\t\trep(i,n)if(used[ti[i].second]==0&&ti[i].first==ti[j].first&&(v==-1||d[v]>d[ti[i].second]))v=ti[i].second;\n\t\t\t\tv=ti[j].second;\n\t\t\t}else{\n\t\t\t\tv=-1;\n\t\t\t\trep(i,n)if(used[ti[i].second]==0&&ti[i].first<=ti[T].first&&(v==-1||d[v]>d[ti[i].second]))v=ti[i].second;\n\t\t\t}\n\t\t\tused[v]=true;\n\t\t\tsum+=d[v];\n\t\t\trep(i,n)d[i]=min(d[i],cost[v][i]);\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<Int, P> T;\n\nInt u[1080];\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(Int x, Int y){\n\tu[r(x)] = r(y);\n}\nvector<T> edge[1080000];\nInt h[1080];\nbool ok[1080];\nint main(){\n\tInt n, m;\n\twhile(cin >> n >> m, n | m){\n\t\tInt res = 0, bridge = 0, a, b, c, cnt = 0;\n\t\tfor(Int i = 0;i < n;i++){\n\t\t\tcin >> h[i], u[i] = i;\n\t\t\tedge[h[i]].push_back(T(-1, P(i, i)));\n\t\t}\n\t\tfor(Int i = 0;i < m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tedge[min(h[a], h[b])].push_back(T(c, P(a, b)));\n\t\t\tif(h[a] == h[b])unite(a, b);\n\t\t}\n\t\t\n\t\tInt breakpoInt = 1000010;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tfor(int j = 0;j < edge[i].size();j++){\n\t\t\t\ta = edge[i][j].second.first, b = edge[i][j].second.second;\n\t\t\t\tc = edge[i][j].first;\n\t\t\t\tif(c == -1)cnt++;\n\t\t\t\tif(r(a) != r(b)){\n\t\t\t\t\tunite(a, b);\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt != 1)breakpoInt = i;\n\t\t}\n\t\t//breakpoInt--;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t}                    \n\t\tbridge = 0;\n\t\tvector<T> tmp;\n\t\tfor(Int i = 0;i < n;i++)u[i] = i;\n\t\tfor(Int i = 1000000;i >= breakpoInt;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\ttmp.push_back(edge[i][j]);\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor(Int i = 0;i < tmp.size();i++){\n\t\t\tInt from = tmp[i].second.first, to = tmp[i].second.second;\n\t\t\tif(r(from) != r(to)){\n\t\t\t\tbridge++;\n\t\t\t\tres += tmp[i].first;\n\t\t\t\tunite(from, to);\n\t\t\t}\n\t\t}                          \n\t\tfor(Int i = breakpoInt;i > 0;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tres += edge[i][j].first;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tif(bridge + 1 != n)res = 0;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct edge{\n\tint a, b, c;\n\tedge(int x, int y, int z){\n\t\ta = x, b = y, c = z;\n\t}\n\tbool operator<(edge ope){\n\t\treturn c < ope.c;\n\t}\n};\n\nint N, M;\nint h[205];\nbool used[205];\nvector<edge> E, E2;\nvector<int> vec_h;\n\nint parent[205];\nvoid init(){\n\tfor(int i = 1; i <= N; i++) parent[i] = i;\n}\nint root(int i){\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\nbool same(int i, int j){\n\treturn root(i) == root(j);\n}\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nbool check(int day)\n{\n\tinit();\n\tfor(int i = 0; i < E.size(); i++){\n\t\tif(h[E[i].a] <= day || h[E[i].b] <= day) continue;\n\t\tunite(E[i].a, E[i].b);\n\t}\n\t\n\tint cnt[205], remain_cnt = 0;\n\tfor(int i = 1; i <= N; i++) cnt[i] = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(h[i] > day){\n\t\t\tcnt[root(i)]++;\n\t\t\tremain_cnt++;\n\t\t}\n\t}\n\tint comp_num = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(cnt[i]) comp_num++;\n\t}\n\tif(remain_cnt <= 1) return false;\n\tif(comp_num >= 2) return false;\n\treturn true;\n}\n\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0) break;\n\t\t\n\t\tvec_h.clear();\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tcin >> h[i];\n\t\t\tvec_h.push_back(h[i]);\n\t\t}\n\t\tvec_h.push_back(0);\n\t\tsort(vec_h.begin(), vec_h.end());\n\t\t\t\n\t\tint a, b, c;\n\t\tE.clear();\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tE.push_back( edge(a, b, c) );\n\t\t}\n\t\tsort(E.begin(), E.end());\n\t\t\n\t\tint day_i;\n\t\tfor(int i = 0; i < vec_h.size(); i++){\n\t\t\tif(!check(vec_h[i])){\n\t\t\t\tday_i = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(day_i == 0){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\tinit();\n\t\tint ans = 0;\n\t\tfor(int t = day_i; t >= 0; t--){\n\t\t\tE2.clear();\n\t\t\tfor(int i = 0; i < E.size(); i++){\n\t\t\t\tif(h[E[i].a] < vec_h[t] || h[E[i].b] < vec_h[t]){\n\t\t\t\t\tE2.push_back(E[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!same(E[i].a, E[i].b)){\n\t\t\t\t\tans += E[i].c;\n\t\t\t\t\tunite(E[i].a, E[i].b);\n\t\t\t\t}else{\n\t\t\t\t\tE2.push_back(E[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tE = E2;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// finish date: 2018/07/05\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i, n)  FOR(i,0,n)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<long double> vd;\ntypedef vector<vector<long double>> vvd;\ntypedef vector<vector<vector<long double>>> vvvd;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> pii;\nconst int bigmod = 1000000007;\nconst int INF = 1050000000;\n\n\nll prim(int N, vector<vector<pii> > edge) {\n    priority_queue<pii, vector<pii>, greater<pii> > pq;\n    vector<bool> used(N, false);\n    pq.push(pii(0, 0));\n    ll total = 0;\n    while (!pq.empty()) {\n        int dis, t;\n        tie(dis, t) = pq.top();\n        pq.pop();\n        if (used[t]) continue;\n        used[t] = true;\n        total += dis;\n        for (auto e: edge[t]) {\n            if (!used[e.second]) pq.push(e);\n        }\n    }\n    return total;\n}\n\nstruct Union_Find {\n    vi parent;\n    vi sizes;\n    int setnum = 0;\n\n    Union_Find(int n) : parent(n), sizes(n, 1) {\n        rep(i, n) parent[i] = i;\n        setnum = n;\n    }\n\n    int find(int x) {\n        if (x == parent[x]) return x;\n        return parent[x] = find(parent[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n        if (sizes[x] < sizes[y]) swap(x, y);\n\n        parent[y] = x;\n        sizes[x] += sizes[y];\n        setnum--;\n\n    }\n\n    bool isSame(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return sizes[find(x)];\n    }\n};\n\nint main() {\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 && M == 0) break;\n        vvi h(N, vi(2));\n        vvi abc(M, vi(3));\n        rep(i, N) {\n            cin >> h[i][0];\n            h[i][1] = i;\n        }\n        rep(i, M) {\n            cin >> abc[i][0] >> abc[i][1] >> abc[i][2];\n            abc[i][0]--;\n            abc[i][1]--;\n        }\n        map<int, int> numh;\n        rep(i, N) {\n            numh[h[i][0]]++;\n        }\n\n        sort(h.rbegin(), h.rend());\n        map<int, int> tr;\n        rep(i, N) {\n            tr[h[i][1]] = i;\n        }\n\n        rep(i, M) {\n            rep(j, 2) {\n                abc[i][j] = tr[abc[i][j]];\n            }\n        }\n        /*\n        rep(i,N){\n                rep(j,3){\n                        cout<<abc[i][j] << \" \";\n                }\n                cout<<endl;\n        }*/\n\n\n        vvi dist(N, vi(N, INT_MAX));\n        Union_Find uf(N);\n        rep(i, M) {\n            int a = abc[i][0];\n            int b = abc[i][1];\n            int c = abc[i][2];\n            //edge[a].push_back(make_pair(c,b));\n            //edge[b].push_back(make_pair(c,a));\n            dist[a][b] = c;\n            dist[b][a] = c;\n        }\n        //cout<<dist.size();//<<\" \"<<dist[0].size();\n        rep(i, N) dist[i][i] = 0;\n\n        vector<bool> isUF(N, false);\n\n        rep(i, N) {\n            rep(j, i) {\n                if (dist[i][j] != INT_MAX) {\n                    uf.unite(i, j);\n                }\n            }\n            if (uf.setnum == N - i) isUF[i] = true;\n        }\n        if (!isUF[N - 1]) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        int idx = 0;\n        for (int i = N - 1; i > 0; i--) {\n            if (!isUF[i]) {\n                int now = h[i][0];\n                int now_idx = i;\n                idx = i;\n                while (idx < N-1 && h[idx][0] == h[idx + 1][0]) idx++;\n                idx++;\n                while (idx < N-1 && h[idx][0] == h[idx + 1][0]) idx++;\n                idx++;\n                idx = min(idx, N);\n                break;\n            }\n        }\n        rep(i,N) cout<<h[i][0]<<endl;\n\n\n\n        ll ans = 0;\n//        idx = 9;\n        if (idx != 0) {\n            vector<vector<pii> > edge(idx);\n            rep(i, idx) {\n                rep(j, idx) {\n                    if (dist[i][j] != INT_MAX) {\n                        edge[i].push_back(make_pair(dist[i][j], j));\n                        edge[j].push_back(make_pair(dist[i][j], i));\n                    }\n                }\n            }\n            ans += prim(idx, edge);\n        }\n        if (idx == 0) idx++;\n        FOR(i, idx, N) {\n            int mi = INT_MAX;\n            rep(j, i) {\n                mi = min(mi, dist[i][j]);\n            }\n            //cout<<i<<\" \"<<mi<<endl;\n            ans += mi;\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2511&lang=jp\n// references : http://mayokoex.hatenablog.com/entry/2016/05/03/233156\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n#define MAXT 1000100\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n\tedge() {}\n\tedge(int f, int t, int c) :from(f), to(t), cost(c) {}\n\tbool operator < (const edge& o) const { return cost < o.cost; }\n};\n\nstruct UnionFind {\n\tvector<int> par;\n\tint n, cnt;\n\tUnionFind(const int& x = 0) { init(x); }\n\tvoid init(const int& x) { par.assign(cnt = n = x, -1); }\n\tinline int find(const int& x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tinline bool same(const int& x, const int& y) { return find(x) == find(y); }\n\tinline bool unite(int x, int y) {\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\t--cnt;\n\t\tif (par[x] > par[y]) swap(x, y);\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\tinline int count() const { return cnt; }\n\tinline int count(int x) { return -par[find(x)]; }\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M;\n\twhile (cin >> N >> M, N | M) {\n\t\tvector<int> h[MAXT];\n\t\tfor (int i = 0; i < N; i++) { int t; cin >> t; h[t].push_back(i); }\n\t\tvector<edge> G;\n\t\tfor (int i = 0; i < M;i++) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tG.push_back(edge(a, b, c));\n\t\t}\n\t\tsort(G.begin(), G.end());\n\t\t\n\t\tUnionFind uf(N);\n\t\tfor (auto e : G) uf.unite(e.from, e.to);\n\t\tif (uf.count() > 1) { cout << 0 << endl; continue; }\n\n\t\tvector<int> f(N, 0);\n\t\tint cnt = 1;\n\t\tint last_t = -1;\n\t\tfor (int t = 0; t < MAXT;t++) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) { f[n] = 1; cnt++; }\n\t\t\tUnionFind uf(N);\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (f[e.from] == 1 || f[e.to] == 1)continue;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\t\t\tif (uf.count() != cnt) { last_t = t; break; }\n\t\t}\n\t\tif (last_t == -1)last_t = MAXT;\n\n\t\tfill(f.begin(), f.end(), 0);\n\t\tll ans = 0;\n\t\tfor (int t = last_t; t < MAXT;t++)for (auto n : h[t]) f[n] = 1;\n\t\t/* Minimum spanning tree */\n\t\tfor (auto e : G) {\n\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t}\n\t\t/*----------------------*/\n\n\t\tfor (int t = last_t - 1; t >= 0;t--) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) f[n] = 1;\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MP make_pair\n#define MT make_tuple\n#define F first\n#define S second\n#define INF 2e9\ntypedef pair<int,int> P;\nint n, m, ans, cnt;\nint group[200];\nP h[200];\nint bridge[200][200];\nvector<tuple<int, int, int>> vec;\nvoid init(int N){\n    for(int i = 0; i < N; i++){\n        group[i] = i;\n    }\n}\nint root(int a){\n    if(group[a] == a) return a;\n    return (group[a] = root(group[a]));\n}\nbool is_same_set(int a, int b){\n    return root(a) == root(b);\n}\nvoid unite(int a, int b){\n    group[root(a)] = root(b);\n}\nint main(){\n\n    while(cin >> n >> m && n && m){\n        init(n);\n        vec.clear();\n        ans = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                bridge[i][j] = 0;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            cin >> h[i].F;\n            h[i].F *= -1;\n            h[i].S = i;\n        }\n        sort(h, h+n);\n        for(int i = 0; i < m; i++){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            bridge[a][b] = c;\n            bridge[b][a] = c;\n        }\n        for(int i = 1; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(bridge[h[i].S][h[j].S]){\n                    vec.push_back(MT(bridge[h[i].S][h[j].S], i, j));\n                }\n            }\n            if(i + 1 < n && h[i].F == h[i + 1].F){\n                continue;\n            }\n            sort(vec.begin(), vec.end());\n            for(int j = 0; j < vec.size(); j++){\n                if(!is_same_set(get<1>(vec[j]), get<2>(vec[j])) && get<1>(vec[j]) <= i && get<2>(vec[j]) <= i){\n                    unite(get<1>(vec[j]), get<2>(vec[j]));\n                    ans += get<0>(vec[j]);\n                }\n            }\n            cnt = 0;\n            for(int j = 0; j <= i; j++){\n                if(group[j] == j){\n                    cnt++;\n                }\n            }\n            if(cnt!=1){\n                init(n);\n                ans = 0;\n            }\n\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親\n\tvector<int> sz; // 数\n\t// 初期化\n\tUF(int n):par(n),sz(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\nvector<pair<ll,pair<ll,ll>>> v;\nvector<pair<ll,ll>> h;\nll n,m;\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\t//初期化\n\t\th.clear();\n\t\tv.clear();\n\t\t\n\t\t//入力\n\t\tREP(i,n){\n\t\t\tll tmp;cin >> tmp;\n\t\t\th.PB(MP(tmp,i));\n\t\t}\n\t\tREP(i,m){\n\t\t\tll a,b,c;cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv.PB(MP(c,MP(a,b)));\n\t\t}\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\t\n\t\t//沈む順番を入れておく。\n\t\tvector<int> jun(n);\n\t\tREP(i,n)jun[h[i].SE] = i;\n\n\t\t//そもそも連結であるかどうかを見る\n\t\tUF seica(n);\n\t\tREP(i,m){\n\t\t\tint A = v[i].SE.FI;\n\t\t\tint B = v[i].SE.SE;\n\t\t\tif(!seica.same(A,B)){\n\t\t\t\tseica.unite(A,B);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(seica.size(0) != n){\n\t\t\t//連結でなかったら\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\t//連結だったら\n\t\t\tvector<bool> sink(n);\n\t\t\t\n\t\t\t//順々に沈ませていってから、残った中で連結になるかどうかを見る。\n\t\t\tint cou = 0;\n\t\t\twhile(1){\n\t\t\t\tint tmp = cou;\n\t\t\t\twhile(cou < n-1 && h[cou].FI == h[cou+1].FI){\n\t\t\t\t\tcou++;\n\t\t\t\t}\n\t\t\t\tif(cou == n-1){\n\t\t\t\t\tcou = tmp - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tUF uf(n);\n\t\t\t\tREP(i,m){\n\t\t\t\t\tint A = v[i].SE.FI;\n\t\t\t\t\tint B = v[i].SE.SE;\n\t\t\t\t\tif(jun[A] > cou && jun[B] > cou && !uf.same(A,B)){\n\t\t\t\t\t\tuf.unite(A,B);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ma = 0;\n\t\t\t\tREP(i,n)ma = max(ma,uf.size(i));\n\t\t\t\tif(ma != n - cou -1){\n\t\t\t\t\tcou = tmp - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcou++;\n\t\t\t}\n\t\t\t\n\t\t\t//逆に順々に復活させて、くっつけていく。\n\t\t\tll ans = 0;\n\t\t\tUF uf(n);\n\t\t\twhile(1){\n\t\t\t\tREP(i,m){\n\t\t\t\t\tint A = v[i].SE.FI;\n\t\t\t\t\tint B = v[i].SE.SE;\n\t\t\t\t\tif(jun[A] > cou && jun[B] > cou && !uf.same(A,B)){\n\t\t\t\t\t\tuf.unite(A,B);\n\t\t\t\t\t\tans += v[i].FI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cou < 0)break;\n\t\t\t\twhile(cou > 0 && h[cou].FI == h[cou-1].FI)cou--;\n\t\t\t\tcou--;\n\t\t\t}\n\t\t\t\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\nusing namespace std;\ntypedef long long int ll;\n\n// clang-format off\n#ifdef _DEBUG_\n#define dump(...) do{ cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; PPPPP(__VA_ARGS__); cerr << endl; } while(false)\ntemplate<typename T> void PPPPP(T t) { cerr << t; }\ntemplate<typename T, typename... S> void PPPPP(T t, S... s) { cerr << t << \", \"; PPPPP(s...); }\n#else\n#define dump(...)\n#endif\ntemplate<typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\n    // clang-format on\n\n#include <tuple>\nusing Edge = tuple<ll, int, int>;\n\nclass UnionFind {\npublic:\n    vector<int> par;\n    int N;\n    UnionFind(int n) {\n        par.resize(n, -1);\n        N = n;\n    }\n    int Find(int n) {\n        return par[n] < 0 ? n : par[n] = Find(par[n]);\n    }\n    bool Union(int x, int y) {\n        x = Find(x);\n        y = Find(y);\n        if (x == y) return false;\n        if (-par[x] < -par[y]) swap(x, y);\n        par[y] += par[x];\n        par[x] = y;\n        N--;\n        return true;\n    }\n    bool Same(int x, int y) {\n        return Find(x) == Find(y);\n    }\n    int size(int x) {\n        return -par[Find(x)];\n    }\n    int size() {\n        return N;\n    }\n};\n\n#include <map>\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    while (cin >> n >> m, n + m) {\n        vector<ll> h(n);\n        REP(i, 0, n) {\n            cin >> h[i];\n        }\n        map<ll, vector<Edge>> Graph;\n        vector<Edge> All(m);\n        REP(i, 0, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--;\n            b--;\n            Graph[min(h[a], h[b])].emplace_back(c, a, b);\n            All[i] = make_tuple(c, a, b);\n        }\n        for (auto &e : Graph) {\n            sort(e.second.begin(), e.second.end());\n        }\n        sort(All.begin(), All.end());\n\n        {\n            UnionFind uf(n);\n            REP(i, 0, m) {\n                ll cost;\n                int a, b;\n                tie(cost, a, b) = All[i];\n                uf.Union(a, b);\n            }\n            if (uf.size() != 1) {\n                cout << 0 << endl;\n                continue;\n            }\n        }\n\n        ll lastT = 1LL << 60;\n        for (auto it = Graph.begin(); it != Graph.end(); it++) {\n            UnionFind uf(n);\n            vector<bool> used(n, false);\n            REP(i, 0, n) {\n                used[i] = h[i] > it->first;\n            }\n            REP(i, 0, m) {\n                int a, b;\n                tie(ignore, a, b) = All[i];\n                if (used[a] && used[b]) {\n                    uf.Union(a, b);\n                }\n            }\n            vector<bool> check(n, false);\n            REP(i, 0, n) {\n                if (used[i]) {\n                    check[uf.Find(i)] = true;\n                }\n            }\n            int sz = 0;\n            REP(i, 0, n) {\n                sz += check[i];\n            }\n            if (sz != 1) {\n                lastT = it->first;\n                break;\n            }\n        }\n        dump(lastT);\n\n        UnionFind uf(n);\n        ll ans = 0;\n        for (auto &tp : All) {\n            ll cost;\n            int a, b;\n            tie(cost, a, b) = tp;\n            if (h[a] < lastT || h[b] < lastT) continue;\n            if (uf.Union(a, b)) {\n                ans += cost;\n            }\n        }\n\n        for (auto it = Graph.rbegin(); it != Graph.rend(); it++) {\n            if (it->first < lastT) {\n                for (auto &tp : it->second) {\n                    ll cost;\n                    int a, b;\n                    tie(cost, a, b) = tp;\n                    if (uf.Union(a, b)) {\n                        ans += cost;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<cassert>\n#include<set>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 30000\nusing namespace std;\n\nclass UnionFindTree\n{\npublic:\n  int par[MAX];\n\n  void init(int N){ rep(i,N)par[i] = i; }  \n\n  int find(int x)\n  {\n    if(par[x] == x)return x;\n    return par[x] = find(par[x]);\n  }\n\n  void unit(int x,int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x != y)par[x] = y;\n  }\n\n  bool same(int x,int y){ return find(x) == find(y); }\n\n};\n\nstruct edge\n{\n  int x,y,cost;\n  edge(int x=inf,int y=inf,int cost=inf):x(x),y(y),cost(cost){}\n  bool operator < (const edge& a)const\n  {\n    return cost < a.cost;\n  }\n};\n\nint N,M;\nvector<int> h,ph;\nvector<edge> G;\n\nbool check()\n{\n  UnionFindTree UTF;\n  UTF.init(N);\n  rep(i,G.size())\n    if(!UTF.same(G[i].x,G[i].y))\n      UTF.unit(G[i].x,G[i].y);\n  rep(i,N)UTF.find(i);\n  rep(i,N)if(UTF.par[i] != UTF.par[0])return false;\n  return true;\n}\n\nvoid compute()\n{\n\n  if(!check())\n    {\n      cout << 0 << endl;\n      return;\n    }\n\n  sort(all(ph),greater<int>());\n  sort(all(G));\n\n  UnionFindTree group;\n  group.init(N);\n  int ans = 0;\n\n  rep(i,ph.size())\n    {\n      int TM = ph[i];\n      UnionFindTree UTF;\n      UTF.init(N);\n      rep(j,G.size())\n\t{\n\t  int x = G[j].x;\n\t  int y = G[j].y;\n\t  if(h[x] < TM || h[y] < TM)continue;\n\t  if(!UTF.same(x,y))\n\t    {\n\t      UTF.unit(x,y);\n\t    }\n\t}\n\n      rep(j,N)UTF.find(j);\n\n      set<int> out;\n      rep(j,N)if(h[j] >= TM && UTF.par[j] != j)out.insert(UTF.par[j]);\n      if(out.size() >= 2)\n\t{\n\t  ans = 0;\n\t  group.init(N);\n\t  continue;\n\t}\n\n\n      rep(j,G.size())\n\t{\n\t  int x = G[j].x;\n\t  int y = G[j].y;\n\t  if(h[x] < TM || h[y] < TM)continue;\n\t  if(!group.same(x,y))\n\t    {\n\t      //cout << TM << \" unit(\" << x+1 << \",\" << y+1 << \")\" << endl;\n\t      group.unit(x,y);\n\t      ans += G[j].cost;\n\t    }\n\t}\n      //cout << \"ans = \" << ans << endl;\n    }\n\n  cout << ans << endl;\n\n}\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      h.clear(),ph.clear(),G.clear();\n      h.resize(N),ph.resize(N),G.resize(M);\n      rep(i,N)cin >> h[i],ph[i] = h[i];\n      rep(i,M)cin >> G[i].x >> G[i].y >> G[i].cost,G[i].x--,G[i].y--;\n\n      compute();\n\n    }\n  return 0;\n}\n\n/*\nstruct P\n{\n  int h,identifier;\n  P(int h=inf,int identifier=inf):h(h),identifier(identifier){}\n  bool operator < (const P& a)const\n  {\n    if(h != a.h)return h > a.h;\n    return identifier < a.identifier;\n  }\n};\n\nstruct edge\n{\n  int x,y,cost;\n  edge(int x=inf,int y=inf,int cost=inf):x(x),y(y),cost(cost){}\n  bool operator < (const edge& a)const\n  {\n    return cost < a.cost;\n  }\n};\n\nint par[MAX];\nint N,M;\nvector<int> h,ph;\nvector<edge> vec;\n\nint find(int x)\n{\n  if(par[x] == x)return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x == y)return;\n  par[x] = y;\n}\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      \n      ph.clear(),h.clear(),vec.clear();\n      ph.resize(N),h.resize(N),vec.resize(M);\n      rep(i,N)par[i] = i;\n\n      rep(i,N)cin >> h[i],ph[i] = h[i];\n\t\n      rep(i,M)cin >> vec[i].x >> vec[i].y >> vec[i].cost,vec[i].x--,vec[i].y--;\n      \n      sort(ph.begin(),ph.end(),greater<int>());\n      sort(vec.begin(),vec.end());\n\n\n \n      int ans = 0;\n      rep(i,ph.size())\n\t{\n\t  int TM = ph[i];\n\t  int cost = 0;\n\t  rep(j,vec.size())\n\t    {\n\t      int x = vec[j].x;\n\t      int y = vec[j].y;\n\n\t      if(h[x] < TM || h[y] < TM)continue;\n\t      if(find(x) != find(y))\n\t\t{\n\t\t  cout << TM << \" unit(\"<<x+1 <<\",\" <<y+1 << \") : \" << vec[j].cost << endl;\n\t\t  unit(x,y);\n\t\t  cost += vec[j].cost;\n\t\t}\n\n\t    }\n\t  cout << \"ans : \" << ans << endl;\n\t}\n\n      int ch = find(0);\n      bool out = false;\n      rep(i,N)if(find(i) != ch)\n\t{\n\t  out = true;\n\t  break;\n\t}\n\n      cout << (out?0:ans) << endl;\n      \n    }\n  return 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a),b=Find(b);\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\tdata[a]+=data[b];\n\t\tdata[b]=a;\n\t\treturn true;\n\t}\n\tint Size(int i){\n\t\treturn -data[Find(i)];\n\t}\n};\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\n\nostream& operator<<(ostream& os,const Edge& e){\n\treturn os<<'('<<e.src<<','<<e.dst<<','<<e.weight<<')';\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi ts(n);\n\t\trep(i,n) cin>>ts[i];\n\t\t\n\t\tvector<Edge> es;\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w; u--,v--;\n\t\t\tes.emplace_back(u,v,w);\n\t\t}\n\t\tsort(all(es));\n\t\t\n\t\tvi ts2=ts;\n\t\tsort(all(ts2));\n\t\tts2.erase(unique(all(ts2)),end(ts2));\n\t\t\n\t\tint k;\n\t\tfor(k=0;k<ts2.size();k++){\n\t\t\tUnionFind uf(n);\n\t\t\tvi used(n);\n\t\t\tint cc=0;\n\t\t\tfor(auto e:es) if(min(ts[e.src],ts[e.dst])>=ts2[k]){\n\t\t\t\tif(!used[e.src]) used[e.src]=1,cc++;\n\t\t\t\tif(!used[e.dst]) used[e.dst]=1,cc++;\n\t\t\t\tif(uf.Unite(e.src,e.dst)) cc--;\n\t\t\t}\n\t\t\tif(cc!=1) break;\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\tint res=0;\n\t\tper(i,k){\n\t\t\tfor(auto e:es) if(min(ts[e.src],ts[e.dst])>=ts2[i])\n\t\t\t\tif(uf.Unite(e.src,e.dst))\n\t\t\t\t\tres+=e.weight;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint h[200], par[200], s[200];\nint find(int x) {\n\tif (par[x] == x)return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = find(x); y = find(y);\n\tif (x == y)return;\n\tpar[y] = x; s[x] += s[y];\n}\nstruct st { int a, b, c; };\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\tvector<P>t;\n\t\trep(i, n)scanf(\"%d\", &h[i]), t.push_back(P(h[i], i));\n\t\tsort(t.begin(), t.end(), greater<>());\n\t\tvector<st>v;\n\t\trep(i, m) {\n\t\t\tint a, b, c; scanf(\"%d%d%d\", &a, &b, &c); a--; b--;\n\t\t\tv.push_back({ a,b,c });\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\treturn min(h[a.a], h[a.b]) > min(h[b.a], h[b.b]);\n\t\t});\n\t\tint u = INT_MAX;\n\t\tint g = 0;\n\t\trep(i, n) {\n\t\t\twhile (g < v.size() && t[i].first <= min(h[v[g].a], h[v[g].b])) {\n\t\t\t\tunite(v[g].a, v[g].b); g++;\n\t\t\t}\n\t\t\tif (s[find(t[i].second)] <= i) {\n\t\t\t\tif (i + 1 == n)u = 0;\n\t\t\t\telse u = t[i + 1].first;\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\tint c = min({ u,h[a.a], h[a.b] }), d = min({ u,h[b.a], h[b.b] });\n\t\t\tif (c == d)return a.c < b.c;\n\t\t\treturn c > d;\n\t\t});\n\t\tint res = 0;\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\tfor (st p : v) {\n\t\t\tif (find(p.a) == find(p.b))continue;\n\t\t\tunite(p.a, p.b); res += p.c;\n\t\t}\n\t\tif (s[find(0)] != n)puts(\"0\");\n\t\telse printf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nvector<int> h;\nint union_tree[300];\nint union_find(int now) {\n    if (union_tree[now] == now) return now;\n    return union_tree[now] = union_find(union_tree[now]);\n}\nint union_merge(int a, int b) {\n    a = union_find(a);\n    b = union_find(b);\n    if (a == b) return 0;\n    union_tree[a] = b;\n    return 1;\n}\nvoid solve(){\n    while (true) {\n        h.clear();\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) return;\n        set<int> neko;\n        vector<int> gogo;\n        REP(i, n) {\n            int a;\n            cin >> a;\n            gogo.push_back(a);\n            h.push_back(a);\n            union_tree[i] = i;\n        }\n        sort(ALL(gogo));\n        reverse(ALL(gogo));\n        vector<tuple<int, int, int, int>> edges;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            edges.push_back(make_tuple(min(h[a], h[b]), -c, a, b));\n        }\n        sort(ALL(edges));\n        int itr = edges.size() - 1;\n        int die = -1;\n        for (auto x = gogo.begin(); x != gogo.end();++x) {\n            int tmp = (*x);\n            while (itr != -1 && get<0>(edges[itr]) == tmp) {\n                union_merge(get<2>(edges[itr]), get<3>(edges[itr]));\n                itr--;\n            }\n            int geko = -1;\n            REP(q, n) {\n                if (h[q] < tmp) continue;\n                if (geko == -1) {\n                    geko = union_find(q);\n                }\n                else {\n                    if (geko != union_find(q)) {\n                        die = x - gogo.begin();\n                    }\n                }\n            }\n        }\n        die++;\n        if (die == gogo.size()) {\n            cout << 0 << endl;\n            continue;\n        }\n        REP(i, n) {\n            union_tree[i] = i;\n        }\n        int ans = 0;\n        for (int i = die; i < gogo.size(); ++i) {\n            vector<tuple<int, int, int>> nexts;\n            REP(q, edges.size()) {\n                if (get<0>(edges[q]) >= gogo[i]) {\n                    nexts.push_back(make_tuple(-get<1>(edges[q]), get<2>(edges[q]), get<3>(edges[q])));\n                }\n            }\n            sort(ALL(nexts));\n            REP(q, nexts.size()) {\n                ans += union_merge(get<1>(nexts[q]), get<2>(nexts[q])) * get<0>(nexts[q]);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int INF = 1e9 + 7;\n\nclass edge{\n  public:\n    int f, t, c;\n    edge(){};\n    edge(int ff, int tt, int cc) { f = ff; t = tt; c = cc; }\n    bool operator < (const edge &e) const { return c < e.c; }\n};\n\nint find(int a, vector<int> &parent){\n  if(parent[a] == a) return a;\n  else return parent[a] = find(parent[a], parent);\n}\n\nvoid merge(int a, int b, vector<int> &parent, vector<int> &depth){\n  int pa = find(a, parent), pb = find(b, parent);\n  if(pa == pb) return ;\n  if(depth[pa] > depth[pb]) swap(pa, pb);\n  if(depth[pa] == depth[pb]) ++depth[pa];\n  parent[pb] = pa;\n}\n\nbool same(int a, int b, vector<int> &parent){\n  return find(a, parent) == find(b, parent);\n}\n\nint main(){\n  int N, M;\n  while(cin >>N >>M && N){\n    vector<P> H(N);\n    vector<edge> es(M);\n    REP(i, N) { cin >>H[i].first; H[i].second = i; }\n    REP(i, M) {\n      cin >>es[i].f >>es[i].t >>es[i].c;\n      --es[i].f; --es[i].t;\n    }\n    SORT(H); REVERSE(H);\n    SORT(es);\n    vector<bool> v(N, false);\n    vector<int> parent(N), depth(N, 1);\n    REP(i, N) parent[i] = i;\n    int  ans = 0, cnt = 0;\n    REP(i, N){\n      P n = H[i];\n      v[n.second] = true;\n      if(i != N - 1 && H[i].first == H[i + 1].first) continue;\n      REP(j, M){\n        edge e = es[j];\n        if(v[e.f] && v[e.t] && !same(e.f, e.t, parent)){\n          merge(e.f, e.t, parent, depth);\n          ans += e.c;\n          ++cnt;\n        }\n      }\n      if(cnt != i){\n        REP(j, N) parent[j] = j;\n        cnt = 0;\n        ans = 0;\n      }\n    }\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nstruct UnionFind\n{\n    vector<int> par, sz;\n    UnionFind(int n) : par(n), sz(n, 1) {\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n    void merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n    }\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n};\nvector<int> h;\nint beg = -1;\nint cnt = 0;\nstruct Edge{\n  int a, b, c;\n};\nvoid solve(int n, int m) {\n  h.clear();\n  h.resize(n);\n  set<int> hst;\n  for(int i=0;i<n;++i) {\n    cin >> h[i];\n    hst.insert(h[i]);\n  }\n  map<int, int> mp;\n  int idx = 0;\n  for(auto &e: hst) {\n    mp[e] = idx;\n    idx++;\n  }\n  vector<Edge> edges;\n  for(int i=0;i<m;++i) {\n    int a, b, c; cin >> a >> b >> c;\n    a--; b--;\n    edges.push_back({a, b, c});\n  }\n  cnt++;\n  sort(edges.begin(), edges.end(), [](Edge &e1, Edge &e2) {\n    int mi1 = min(h[e1.a], h[e1.b]), mi2 = min(h[e2.a], h[e2.b]);\n    if(mi1 == mi2) {\n      return e1.c < e2.c;\n    } else {\n      return mi1 > mi2;\n    }\n  });\n  beg = -1;\n  UnionFind uf(n);\n  vector<bool> sel(n, false);\n  bool ok = false;\n  for(int i=0;i<m;++i) {\n    uf.merge(edges[i].a, edges[i].b);\n    sel[edges[i].a] = true;\n    sel[edges[i].b] = true;\n    int now = min(h[edges[i].a], h[edges[i].b]);\n    int now2 = INF;\n    if(i != m-1) {\n      now2 = min(h[edges[i+1].a], h[edges[i+1].b]);\n    }\n    if(now == now2) continue;\n    set<int> st;\n    bool ok2 = true;\n    if(i != m-1 && mp[now2] - mp[now] != -1) ok2 = false;\n    for(int j=0;j<n;++j) {\n      if(!sel[j]) {\n        if(h[j] >= now) ok2 = false;\n        continue;\n      }\n      st.insert(uf.root(j));\n    }\n    if((int)(st.size()) != 1 || !ok2) {\n      ok = false;\n    } else {\n      if(!ok) beg = now;\n      ok = true;\n    }\n  }\n  for(int i=0;i<n;++i) {\n    if(!sel[i]) {\n      ok = false;\n      break;\n    }\n  }\n  if(!ok) {\n    cout << 0 << endl;\n    return;\n  }\n  sort(edges.begin(), edges.end(), [](Edge &e1, Edge &e2) {\n    int mi1 = min(h[e1.a], h[e1.b]), mi2 = min(h[e2.a], h[e2.b]);\n    if(mi1 < beg && mi2 < beg) {\n      if(mi1 == mi2) {\n        return e1.c < e2.c;\n      } else {\n        return mi1 > mi2;\n      }\n    } else if(mi1 >= beg && mi2 >= beg) {\n      return e1.c < e2.c;\n    } else if(mi1 >= beg) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n  UnionFind uf2(n);\n  int res = 0;\n  for(int i=0;i<m;++i) {\n    if(!uf2.issame(edges[i].a, edges[i].b)) {\n      uf2.merge(edges[i].a, edges[i].b);\n      res += edges[i].c;\n    }\n  }\n  cout << res << endl;\n  return;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n, m; cin >> n >> m;\n    if(n == 0) break;\n    solve(n, m);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint h[200], par[200], s[200];\nint find(int x) {\n\tif (par[x] == x)return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = find(x); y = find(y);\n\tif (x == y)return;\n\tpar[y] = x; s[x] += s[y];\n}\nstruct st { int a, b, c; };\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\tvector<int>t;\n\t\trep(i, n)scanf(\"%d\", &h[i]), t.push_back(h[i]);\n\t\tsort(t.begin(), t.end());\n\t\tvector<st>v;\n\t\trep(i, m) {\n\t\t\tint a, b, c; scanf(\"%d%d%d\", &a, &b, &c); a--; b--;\n\t\t\tv.push_back({ a,b,c });\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\treturn min(h[a.a], h[a.b]) > min(h[b.a], h[b.b]);\n\t\t});\n\t\tint u = INT_MAX;\n\t\trep(i, v.size()) {\n\t\t\tunite(v[i].a, v[i].b);\n\t\t\tint p = lower_bound(t.begin(), t.end(), min(h[v[i].a], h[v[i].b])) - t.begin();\n\t\t\tif (i + 1 == v.size() || min(h[v[i].a], h[v[i].b]) != min(h[v[i + 1].a], h[v[i + 1].b])) {\n\t\t\t\tif (n - p != s[find(v[i].a)]) {\n\t\t\t\t\tif (i + 1 == v.size())u = 0;\n\t\t\t\t\telse u = min(h[v[i + 1].a], h[v[i + 1].b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\tint c = min({ u,h[a.a], h[a.b] }), d = min({ u,h[b.a], h[b.b] });\n\t\t\tif (c == d)return a.c < b.c;\n\t\t\treturn c > d;\n\t\t});\n\t\tint res = 0;\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\tfor (st p : v) {\n\t\t\tif (find(p.a) == find(p.b))continue;\n\t\t\tunite(p.a, p.b); res += p.c;\n\t\t}\n\t\tif (s[find(0)] != n)puts(\"0\");\n\t\telse printf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nstruct UnionFind\n{\n\tvector<int> par;\n\tUnionFind(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n\tvoid init()\n\t{\n\t\tREP(i, par.size()) par[i] = -1;\n\t}\n};\n\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tvector<pii> p;\n\t\tREP(i, n)\n\t\t{\n\t\t\tint a; cin >> a;\n\t\t\tp.emplace_back(a, i);\n\t\t}\n\t\tsort(p.rbegin(), p.rend());\n\t\tEdges es;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tes.push_back(Edge{ a, b, c });\n\t\t}\n\t\tsort(ALL(es));\n\t\tUnionFind uf(n);\n\t\tset<int> st;\n\t\tEdges ans;\n\t\tREP(i, n)\n\t\t{\n\t\t\tst.insert(p[i].second);\n\t\t\twhile (i != n - 1 && p[i + 1].first == p[i].first)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tst.insert(p[i].second);\n\t\t\t}\n\t\t\tREP(i, es.size())\n\t\t\t{\n\t\t\t\tint l = es[i].from, r = es[i].to;\n\t\t\t\tif (st.count(l) && st.count(r) && !uf.same(l, r))\n\t\t\t\t{\n\t\t\t\t\tans.push_back(es[i]);\n\t\t\t\t\tuf.unite(l, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans.size() != i)\n\t\t\t{\n\t\t\t\tans.clear();\n\t\t\t\tuf.init();\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tREP(i, ans.size()) sum += ans[i].cost;\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = complex<ld>;\nusing L = pair<V, V>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = (ll)1e9 + 7LL;\nconstexpr ld PI = static_cast<ld>(3.1415926535898);\nconstexpr ld EPS = static_cast<ld>(1e-12);\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n    bool operator<(const Edge& e) const\n    {\n        return cost < e.cost;\n    }\n};\n\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) {\n            break;\n        }\n        vector<ll> h(N);\n        vector<ll> height(N);\n        for (int i = 0; i < N; i++) {\n            cin >> h[i];\n            height[i] = h[i];\n        }\n        sort(height.begin(), height.end(), greater<ll>{});\n        height.erase(unique(height.begin(), height.end()), height.end());\n        vector<int> num(height.size(), 0);\n        for (int i = 0; i < height.size(); i++) {\n            for (int j = 0; j < N; j++) {\n                if (h[j] >= height[i]) {\n                    num[i]++;\n                }\n            }\n        }\n\n        vector<Edge> edge;\n        for (int i = 0; i < M; i++) {\n            int a, b;\n            ll c;\n            cin >> a >> b >> c;\n            a--, b--;\n            edge.push_back(Edge{a, b, c});\n        }\n        sort(edge.begin(), edge.end());\n\n        DisjointSets uf(N);\n        ll sum = 0;\n        vector<bool> used(M, false);\n        int e = 0;\n        for (int j = 0; j < height.size(); j++) {\n            const ll he = height[j];\n            for (int i = 0; i < M; i++) {\n                const int from = edge[i].from;\n                const int to = edge[i].to;\n                const ll cost = edge[i].cost;\n                if (h[from] >= he and h[to] >= he and (not uf.same(from, to)) and (not used[i])) {\n                    e++;\n                    uf.unite(from, to);\n                    sum += cost;\n                    used[i] = true;\n                }\n            }\n            if (e < num[j] - 1) {\n                e = 0;\n                sum = 0;\n                uf = DisjointSets{N};\n                fill(used.begin(), used.end(), false);\n                sum = 0;\n            }\n        }\n        cout << sum << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nstruct edge{ int to,cost; };\nstruct edge_krus{ int from,to,cost; };\n\nint rnk[200],par[200];\n\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\trnk[i] = 0;\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rnk[x] < rnk[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nbool comp(const edge_krus& e1,const edge_krus& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int MAX_H = 1000000;\n\nsigned main(){\n\tint n,m;\n\twhile(scanf(\"%lld %lld\",&n,&m),n){\n\t\tint ans = 0;\n\t\tvector<edge> G[200];\n\t\tbool sank[200] = {};\n\t\tvector<int> sink[MAX_H];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint h;\n\t\t\tscanf(\"%lld\",&h);\n\t\t\tsink[h - 1].push_back(i);\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%lld %lld %lld\",&a,&b,&c); a--;b--;\n\t\t\tG[a].push_back({b,c});\n\t\t\tG[b].push_back({a,c});\n\t\t}\n\t\tinit(n);\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(edge e : G[j]){\n\t\t\t\tif(!sank[j] && !sank[e.to]) unite(j,e.to);\n\t\t\t}\n\t\t}\n\t\tint mi = INF,ma = -1;\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(sank[j]) continue;\n\t\t\tmi = min(mi,find(j));\n\t\t\tma = max(ma,find(j));\n\t\t}\n\t\tif(mi != ma){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint last = -1;\n\t\tfor(int i = 0;i < MAX_H;i++){\n\t\t\tif(!sink[i].size()) continue;\n\t\t\tfor(int v : sink[i]) sank[v] = true;\n\t\t\tinit(n);\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tfor(edge e : G[j]){\n\t\t\t\t\tif(!sank[j] && !sank[e.to]) unite(j,e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mi = INF,ma = -1;\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(sank[j]) continue;\n\t\t\t\tmi = min(mi,find(j));\n\t\t\t\tma = max(ma,find(j));\n\t\t\t}\n\t\t\tif(mi != ma){\n\t\t\t\tfor(int v : sink[i]) sank[v] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = i;\n\t\t}\n\t\tinit(n);\n\t\tvector<edge_krus> es;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(edge e : G[i]){\n\t\t\t\tif(!sank[i] && !sank[e.to]) es.push_back({i,e.to,e.cost});\n\t\t\t}\n\t\t}\n\t\tsort(es.begin(),es.end(),comp);\n\t\tfor(edge_krus e : es){\n\t\t\tif(!same(e.from,e.to)){\n\t\t\t\tunite(e.from,e.to);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\tfor(int i = last;i >= 0;i--){\n\t\t\tif(!sink[i].size()) continue;\n\t\t\tes.clear();\n\t\t\tfor(int v : sink[i]) sank[v] = false;\n\t\t\tfor(int v : sink[i]){\n\t\t\t\tfor(edge e : G[v]){\n\t\t\t\t\tif(!sank[e.to]) es.push_back({v,e.to,e.cost});\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(es.begin(),es.end(),comp);\n\t\t\tfor(edge_krus e : es){\n\t\t\t\tif(!same(e.from,e.to)){\n\t\t\t\t\tunite(e.from,e.to);\n\t\t\t\t\tans += e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint N, M, h[201];\nbool f[1000001];\n\n// Union-Find\nstruct union_find{\n\tvector<int> par, rank;\n\t\n\t// コンストラクタで初期化\n\tunion_find(int n){\n\t\tpar = vector<int>( n );\n\t\trank = vector<int>( n , 0 );\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\t// x の root を返す\n\tint find(int x){\n\t\treturn ( par[x] == x )? x : (par[x] = find(par[x]) ) ;\n\t}\n\t// x と y の属する集合を併合する\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x == y ) return;\n\t\t\n\t\tif( rank[x] < rank[y] ){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif( rank[x] == rank[y] )\n\t\t\t\trank[x]++;\n\t\t}\n\t}\n\t// x と y が同じ集合に属するかどうか\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t// 集合の数を返す\n\tint size(){\n\t\tset<int> s;\n\t\tfor(int i=0 ; i < par.size() ; i++ ){\n\t\t\ts.insert( this->find(i) );\n\t\t}\n\t\treturn s.size();\n\t}\n};\n\nstruct edge{\n\tint cost, u, v;\n\tedge(){}\n\tedge(int cost_, int u_, int v_){\n\t\tcost= cost_; u = u_; v = v_;\n\t}\n};\nbool operator<(const edge &a, const edge &b){\n\treturn a.cost < b.cost;\n}\n\nint main(){\n\twhile( cin >> N >> M , N ){\n\t\t// min_time := 一番最初に島が沈む時刻\n\t\t// max_time := 一番最後に島が沈む時刻\n\t\tint min_time = 1e+8, max_time = 0;\n\t\tfill(f, f + 1000001, false);\n\t\tvector<edge> e;\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++ ){\n\t\t\tcin >> h[i];\n\t\t\tf[h[i]] = true;\n\t\t\tmin_time = min(min_time, h[i]);\n\t\t\tmax_time = max(max_time, h[i]);\n\t\t}\n\t\tfor(int i = 0 ; i < M ; i++ ){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\te.push_back(edge(c, a, b));\n\t\t}\n\t\t\n\t\tvector<int> v;\n\t\tf[0] = true;\n\t\tfor(int t = 1000000 ; t >= 0 ; t-- ){\n\t\t\tif( f[t] ) v.push_back( t );\n\t\t}\n\t\t\n\t\t// 時刻の遅い順に連結かどうか調べる\n\t\tunion_find uf(N);\n\t\tint time = max_time;\n\t\tfor(int i = 0 ; i < v.size() ; i++ ){\n\t\t\tint t = v[i];\n\t\t\tfor(int j = 0 ; j < e.size() ; j++ ){\n\t\t\t\tint u = e[j].u, v = e[j].v;\n\t\t\t\tif( t < h[u] && t < h[v] ){\n\t\t\t\t\tuf.unite(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// V := 沈んでない頂点数\n\t\t\t// vv := 沈んでない頂点の集合\n\t\t\tint V = 0, cnt = 0;\n\t\t\tvector<int> vv;\n\t\t\tfor(int v = 0 ; v < N ; v++ ){\n\t\t\t\tif( t < h[v] ){\n\t\t\t\t\tV++;\n\t\t\t\t\tvv.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( vv.size() == 0 ) continue;\n\t\t\t\n\t\t\tfor(int j = 0 ; j < vv.size() ; j++ ){\n\t\t\t\tint v = vv[j];\n\t\t\t\tif( uf.find(v) == uf.find(vv[0]) ) cnt++;\n\t\t\t}\n\t\t\t// 時刻 t で沈んでいない頂点で全域木を構成できない(連結にできない)\t\t\t\n\t\t\tif( V != cnt ) time = t;\n\t\t}\n\t\t\n\t\t// 最初から連結にできないので解は0 \n\t\tif( time == 0 ){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tsort(e.begin(), e.end());\n\t\t// 時刻 time で残っている頂点でMSTを構成する\n\t\ttime--;\n\t\tint res = 0;\n\t\tunion_find tr(N);\n\t\tfor(int i = 0 ; i < e.size() ; i++ ){\n\t\t\tint cost = e[i].cost, u = e[i].u, v = e[i].v;\n\t\t\tif( time < h[u] && time < h[v] ){\n\t\t\t\tif( !tr.same(u, v) ){\n\t\t\t\t\tres += cost;\n\t\t\t\t\ttr.unite(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\ttime++;\n\t\tfor(int i = 0 ; i < v.size() ; i++ ){\n\t\t\tif( v[i] == time ){\n\t\t\t\tk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// 時刻 v[k] から時間の逆順に辿っていき橋をかけていく\n\t\tfor(int i = k ; i < v.size() ; i++ ){\n\t\t\tint t = v[i];\n\t\t\tfor(int j = 0 ; j < e.size() ; j++ ){\n\t\t\t\tint cost = e[j].cost, u = e[j].u, v = e[j].v;\n\t\t\t\tif( t < h[u] && t < h[v] ){\n\t\t\t\t\tif( !tr.same(u, v) ){\n\t\t\t\t\t\tres += cost;\n\t\t\t\t\t\ttr.unite(u, v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvp ti(n+1,{1,-1});\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n){\n\t\t\tint a;cin>>a;\n\t\t\tti[i]={a*-1,i};\n\t\t}\n\t\tsort(all(ti));\n\t\tint t=0;\n\t\tUnionFind uf(n);\n\t\tvi used(n);\n\t\tvvi G(m,vi(3));\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tG[i]={a,b,c};\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\tint T=-1;\n\t\twhile(t!=n){\n\t\t\tused[ti[t].second]=true;\n\t\t\twhile(ti[t].second==ti[t+1].second){\n\t\t\t\tt++;\n\t\t\t\tused[ti[t].second]=true;\n\t\t\t}\n\t\t\trep(i,m)if(used[G[i][0]]&&used[G[i][1]])uf.unionSet(G[i][0],G[i][1]);\n\t\t\tt++;\n\t\t\tif(uf.size(ti[0].second)!=t)T=t;\n\t\t}\n\t\tif(uf.size(0)!=n){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tused=vi(n);\n\t\tint sum=0;\n\t\tvi d(n,inf);\n\t\td[ti[0].second]=0;\n\t\trep(j,n){\n\t\t\tint v=-1;\n\t\t\tif(T==-1||ti[T].first<ti[j].first){\n\t\t\t\trep(i,n)if(used[ti[i].second]==0&&ti[i].first==ti[j].first&&(v==-1||d[v]>d[ti[i].second]))v=ti[i].second;\n\t\t\t}else\n\t\t\t\trep(i,n)if(used[ti[i].second]==0&&ti[i].first<=ti[T].first&&(v==-1||d[v]>d[ti[i].second]))v=ti[i].second;\n\t\t\tused[v]=true;\n\t\t\tsum+=d[v];\n\t\t\trep(i,n)d[i]=min(d[i],cost[v][i]);\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n\ntypedef long long int64;\nconst int INF = 1 << 30;\nint N, M;\n\n\nclass DisjointSet{\nprivate:\n  vector<int> rank, p;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    }else{\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n  }\n  void makeSet(int x){\n    p[x] = x, rank[x] = 0;\n  }\n  void Union(int x,int y){\n    link(findSet(x),findSet(y));\n  }\n  int findSet(int x){\n    return( x != p[x] ? p[x] = findSet(p[x]) : p[x]);\n  }\n};\n\nstruct edge{\n  int u, v, cost;\n  bool operator<(const edge& hoge)const{\n    return cost < hoge.cost;\n  }\n};\ntypedef vector< edge > Edges;\npair< bool, int > kruskal( DisjointSet& uf_tree, Edges& edges, vector< bool >& foo){\n  int ret = 0;\n  for(int i = 0; i < edges.size(); i++){\n    edge& e = edges[i];\n    if(foo[e.u] && foo[e.v] && uf_tree.findSet(e.u) != uf_tree.findSet(e.v)){\n      uf_tree.Union( e.u, e.v);\n      ret += e.cost;\n    }\n  }\n  for(int i = 0; i < N; i++){\n    if(foo[i])\n      for(int j = i + 1; j < N; j++){\n        if(foo[j] && uf_tree.findSet(i) != uf_tree.findSet(j)){\n          return make_pair( false, ret);\n        }\n      }\n  }\n  return make_pair(true,ret);\n}\n\nint main(){\n  vector< Pi > h;\n  vector< edge > edges;\n\n  while(cin >> N >> M, N){\n    h.resize(N);\n    edges.resize(M);\n    DisjointSet uf_tree(N);\n    for(int i = 0; i < N; i++){\n      uf_tree.makeSet(i);\n    }\n\n    for(int i = 0; i < N; i++){\n      cin >> h[i].first;\n      h[i].second = i;\n    }\n    sort(h.begin(), h.end());\n    for(int i = 0; i < M; i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--, b--;\n      edges.push_back((edge){ a, b, c});\n      edges.push_back((edge){ b, a, c});\n    }\n    sort( edges.begin(), edges.end());\n    int ret = 0;\n    vector< bool > foo;\n    foo.resize(N, false);\n    foo[h[N - 1].second] = true;\n    for(int i = N - 2; i >= 0; i--){\n      int time = h[i].first;\n      int j = i;\n      while(j >= 0 && time == h[j].first){\n        foo[h[j].second] = true;\n        j--;\n      }\n      while(i >= 0 && time == h[i].first){\n        Pi cost = kruskal( uf_tree, edges, foo);\n        ret += cost.second;\n        if(!cost.first){\n          uf_tree = DisjointSet(N);;\n          for(int i = 0; i < N; i++){\n            uf_tree.makeSet(i);\n          }\n          ret = 0;\n        }\n        i--;\n      }\n      i++;\n    }\n\n    \n    cout << ret << endl;\n    edges.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nclass Unionfind{\n\tpublic:\n\n\t\tvoid init(int n){\n\t\t\tparent.resize(n);\n\t\t\trank.resize(n);\n\t\t\trep(i,n) parent[i]=i,rank[i]=0;\n\t\t}\n\n\t\tint find(int x){\n\t\t\treturn (parent[x]==x) ? x : parent[x]= find(parent[x]);\n\t\t}\n\n\t\tvoid unite(int x,int y){\n\t\t\tx=find(x); y=find(y);\n\t\t\tif(x== y)return ;\n\t\n\t\t\tif(rank[x]<rank[y])\n\t\t\t\tparent[x]=y;\n\t\t\telse{\n\t\t\t\tparent[y]=x;\n\t\t\t\tif(rank[x] = rank[y])\n\t\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\n\t\tbool same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t\n\tprivate:\n\t\tvi parent;\n\t\tvi rank;\n};\n\nstruct edge{\n\tint a,b,c;\n\tbool operator<(edge tar) const{return c < tar.c;}\n};\n\nUnionfind uf,cur;\nbool used[210];\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n|m){\n\t\trep(i,210) used[i]=false;\n\t\tvector<pii> island(n);\n\t\trep(i,n) {\n\t\t\tcin >> island[i].first;\n\t\t\tisland[i].second=i+1;\n\t\t}\n\t\t\n\t\tsort(island.rbegin(),island.rend());\n\t\tvector<edge> road(m);\n\t\trep(i,m){\n\t\t\tedge in;\n\t\t\tcin >> in.a >> in.b >> in.c;\n\t\t\troad[i]=in;\n\t\t}\n\t\t\n\t\tsort(road.begin(),road.end());\n\t\t\n\t\tbool enable=true;\n\t\tint ans=0;\n\n\t\tint prev=inf,num=0;\n\t\tuf.init(n+10);\n\t\t\n\t\twhile(num<n){\n\t\t\tint cost=0;\n\t\t\tcur=uf;\n\t\t\twhile(num<n&&prev==island[num].first)\n\t\t\t\tused[island[num++].second]=true;\n\n\t\t\tprev=island[num].first;\n\t\t\trep(i,m){\n\t\t\t\tif(used[road[i].a]&&used[road[i].b]&&!cur.same(road[i].a,road[i].b)){\n\t\t\t\t\tcur.unite(road[i].a,road[i].b);\n\t\t\t\t\tcost+=road[i].c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool check=true;\n\t\t\trep(i,num){\n\t\t\t\tif(!cur.same(island[0].second,island[i].second))\n\t\t\t\t\tcheck=false;\n\t\t\t}\n\t\t\tif(check){\n\t\t\t\tuf=cur;\n\t\t\t\tans+=cost;\n\t\t\t}else{\n\t\t\t\tans=0;\n\t\t\t\tuf.init(n+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tif(!uf.same(island[0].second,island[i].second))\n\t\t\t\tenable=false;\n\t\t}\n\t\tif(enable)\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x7fffffff\n\nint n;\nint m;\nint limh;\nint as[11451419];\nint bs[11451419];\nint cs[11451419];\nint hs[11451419];\nint es[11451419];\nint vs[11451419];\n\nclass UnionFind {\npublic:\n  int size;\n  vector<int> par;\n  vector<int> height;\n\n  UnionFind(int n) {\n    par.resize(n);\n    height.resize(n);\n    for (int i=0; i<n; i++) {\n      par[i] = i;\n      height[i] = 0;\n    }\n    size = n;\n  }\n    \n  int find(int v) {\n    if (par[v] != v) return par[v] = find(par[v]);\n    return v;\n  }\n\n  bool same(int u, int v) {\n    return find(u) == find(v);\n  }\n\n  void unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return;\n  \n    size--;\n    if (height[u] > height[v]) par[v] = u;\n    else if (height[v] > height[u]) par[u] = v;\n    else {\n      par[v] = u;\n      height[v]++;\n    }\n  }\n};\n\nbool CompareVertex(int x, int y) {\n  return hs[x] > hs[y];\n}\n\nbool CompareEdge1(int x, int y) {\n  int at = min(hs[as[x]], hs[bs[x]]);\n  int bt = min(hs[as[y]], hs[bs[y]]);\n  if (at != bt) return at > bt;\n  return cs[x] < cs[y];\n}\n\nbool CompareEdge2(int x, int y) {\n  int at = min(hs[as[x]], hs[bs[x]]);\n  int bt = min(hs[as[y]], hs[bs[y]]);\n  if (min(at, bt) >= limh) return cs[x] < cs[y];\n  if (at != bt) return at > bt;\n  return cs[x] < cs[y];\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    int maxv;\n    int maxh = -1;\n    for (int i=1; i<=n; i++) {\n      scanf(\"%d\", &hs[i]);\n      if (maxh < hs[i]) {\n        maxh = hs[i];\n        maxv = i;\n      }\n      vs[i-1] = i;\n    }\n\n    for (int i=0; i<m; i++) {\n      scanf(\"%d%d%d\", &as[i], &bs[i], &cs[i]);\n      es[i] = i;\n    }\n\n    sort(vs, vs+n, CompareVertex);\n\n    limh = maxh;\n    UnionFind uf1(n+1);\n    for (int i=0; i<n; i++) {\n      int v = vs[i];\n      for (int j=0; j<m; j++) {\n        if (hs[as[j]] >= hs[v] && hs[bs[j]] >= hs[v]) {\n          uf1.unite(as[j], bs[j]);\n        }\n      }\n\n      for (int j=0; j<i; j++) {\n        int u = vs[j];\n        if (!uf1.same(u, v)) {\n          limh = hs[vs[i+1]];\n          break;\n        }\n      }\n    }\n    //cout << \"limh: \" << limh << \"\\n\";\n\n    sort(es, es+m, CompareEdge2);\n\n    int ans = 0;\n    UnionFind uf2(n+1);\n    for (int i=0; i<m; i++) {\n      int idx = es[i];\n      int u = as[idx];\n      int v = bs[idx];\n      int c = cs[idx];\n      if (uf2.same(u, v)) continue;\n      uf2.unite(u, v);\n      ans += c;\n    }\n\n    for (int i=1; i<=n; i++) {\n      if (!uf2.same(1, i)) {\n        ans = 0;\n        break;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n#define F first\n#define S second\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m;\nvector<int>s;\nvector<P>v;\nvector<P2>e;\nmap<int,int>M;\n\nsigned main(){\n  while(cin>>n>>m,n){\n    M.clear();\n    v.clear();\n    s.clear();\n    e.clear();\n    r(i,n){\n      int a;\n      cin>>a;\n      v.push_back(P(a,i));\n      s.push_back(a);\n      M[i]=a;\n    }\n    r(i,m){\n      int a,b,c;\n      cin>>a>>b>>c;a--;b--;\n      e.push_back(P2(a,P(b,c)));\n    }\n    sort(v.begin(),v.end());\n    sort(s.begin(),s.end(),greater<int>());\n    int MIN=-1;\n    r(i,s.size()){\n      vector<int>v1;\n      vector<P2>e1;\n      UnionFind U(n+7);\n      r(j,n){\n        if(M[j]>=s[i])v1.push_back(j);\n      }\n      r(j,m){\n        if(M[e[j].F]>=s[i]&&M[e[j].S.F]>=s[i])U.unite(e[j].F,e[j].S.F);\n      }\n      if(U.sum(v1[0])!=v1.size()){\n        MIN=s[i];\n      }\n    }\n    int ans=0;\n    UnionFind U(n+7);\n    vector<P2>vv;\n    if(MIN==-1)MIN=1e9;\n    r(i,s.size()){\n      if(MIN!=-1&&s[i]>=MIN)continue;\n      vv.clear();\n      r(j,m){\n        if(M[e[j].F]>=s[i]&&M[e[j].S.F]>=s[i]){\n          int A=e[j].F,B=e[j].S.F;\n          vv.push_back(P2(e[j].S.S,P(A,B)));\n        }\n      }\n      sort(vv.begin(),vv.end());\n      r(j,vv.size()){\n        int A=vv[j].S.F,B=vv[j].S.S;\n        if(!U.same(A,B)){\n          U.unite(A,B);\n          ans+=vv[j].F;\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint N,M,K,A[20],B[20],ans;\nint d[11];\n\nint main()\n{\n  scanf(\"%d%d%d\",&N,&M,&K);//社員数,隣り合ってはいけない組の数,シャッフル回数の読み込み\n  for (int i = 0; i < M; i++)\n    scanf(\"%d%d\",&A[i],&B[i]);//隣り合ってはいけない組み同士読み込み\n  for (int i = 0; i < 2000000; i++)\n    {\n      for (int j = 0; j < N; j++) \n\td[j] = j;//席の初期化\n      for (int j = 0; j < K; j++)\n\t{\n\t  int a = 0,b=0;\n\t  while (a==b)//それぞれ違う値を返すまで乱数を生成する\n\t    a=rand()%N,b=rand()%N;\n\t  swap(d[a],d[b]);//席の交換\n\t}\n      bool is = true;\n      for (int i = 0; i < N; i++)\n\t{\n\t  for (int j = 0; j < M; j++)\n\t    {\n\t      if (d[i]==A[j]&&d[(i+1)%N]==B[j]) is = false;//隣り合ってはいけない組みならばfalse\n\t      if (d[i]==B[j]&&d[(i+1)%N]==A[j]) is = false;\n\t    }\n\t}\n      if (is) ans++;//すべて成功ならans++\n    }\n  printf(\"%.8f\\n\",(double)ans/2000000.0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int from,to,cost;\n};\nconst int SIZE=1000001;\n\nclass UnionFind{\n    vector<int> par,rank;\n    public:\n    UnionFind(int n):par(n),rank(n){\n        iota(par.begin(),par.end(),0);\n    }\n    int find(int x){\n        if(par[x]==x) return x;\n        else par[x]=find(par[x]);\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    void unite(int x,int y){\n        x=find(x),y=find(y);\n        if(rank[x]<rank[y]) par[x]=y;\n        else{\n            if(rank[y]==rank[x]) rank[x]++;\n            par[y]=x;\n        }\n    }\n};\n\nusing Graph=vector<vector<Edge>>;\nint solve(int n,int m){\n    vector<int> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--,b--;\n        g[a].push_back(Edge{a,b,c});\n        g[b].push_back(Edge{b,a,c});\n    }\n    // cerr<<\"Input finished\"<<endl;\n    vector<vector<int>> sinks(SIZE);\n    for(int i=0;i<n;i++) sinks[h[i]].push_back(i);\n    UnionFind u(n);\n    vector<int> land(n,false);\n    vector<int> isok(SIZE);\n    int cnt=-1;\n    for(int t=SIZE-1;t>=0;t--){\n        cnt+=sinks[t].size();\n        for(auto &v:sinks[t]){\n            // cerr<<t<<\" \"<<v<<endl;\n            land[v]=true;\n            for(auto &e:g[v]){\n                // cerr<<\"@\"<<e.from<<\" \"<<e.to<<endl;\n                if(land[e.from] && land[e.to] && !u.same(e.from,e.to)){\n                    // cerr<<\"Hoy\"<<endl;\n                    u.unite(e.from,e.to);\n                    // cerr<<\"Hi\"<<endl;\n                    cnt--;\n                }\n                // cerr<<\"Nui\"<<endl;\n            }\n        }\n        isok[t]=cnt<=0;\n    }\n    // cerr<<\"masaka\"<<endl;\n    int beft=SIZE;\n    for(int i=0;i<SIZE;i++){\n        if(!isok[i]){\n            beft=i;\n            break;\n        }\n    }\n    // cerr<<\"Beft finished \"<<beft<<endl;\n    cnt=0;\n    int res=0;\n    u=UnionFind(n);\n    fill(land.begin(),land.end(),false);\n    vector<Edge> edges;\n    for(int t=beft;t<SIZE;t++){\n        for(auto &v:sinks[t]){\n            land[v]=true;\n            for(auto &e:g[v]){\n                if(land[e.from] && land[e.to]){\n                    edges.push_back(e);\n                }\n            }\n        }\n    }\n    for(int t=beft-1;t>=0;t--){\n        for(auto &v:sinks[t]){\n            land[v]=true;\n            for(auto &e:g[v]){\n                if(land[e.from] && land[e.to]){\n                    edges.push_back(e);\n                }\n            }\n        }\n        sort(edges.begin(),edges.end(),[](Edge lhs,Edge rhs){return lhs.cost<rhs.cost;});\n        for(auto &e:edges){\n            if(!u.same(e.from,e.to)){\n                cnt++;\n                u.unite(e.from,e.to);\n                res+=e.cost;\n            }\n        }\n        edges.clear();\n    }\n    // assert(cnt==n-1);\n    return res;\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        cout<<solve(n,m)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int INF = 1e9 + 7;\n\nclass edge{\n  public:\n    int f, t, c;\n    edge(){};\n    edge(int ff, int tt, int cc) { f = ff; t = tt; c = cc; }\n    bool operator < (const edge &e) const { return c < e.c; }\n};\n\nint find(int a, vector<int> &parent){\n  if(parent[a] == a) return a;\n  else return parent[a] = find(parent[a], parent);\n}\n\nvoid merge(int a, int b, vector<int> &parent, vector<int> &depth){\n  int pa = find(a, parent), pb = find(b, parent);\n  if(pa == pb) return ;\n\n  if(depth[pa] > depth[pb]) swap(pa, pb);\n  if(depth[pa] == depth[pb]) ++depth[pa];\n  parent[pb] = pa;\n}\n\nbool same(int a, int b, vector<int> &parent){\n  return find(a, parent) == find(b, parent);\n}\n\nbool check(int N, vector<int> &parent){\n  REP(i, N) if(!same(0, i, parent)) return false;\n  return true;\n}\n\nint main(){\n  int N, M;\n  while(cin >>N >>M && N){\n    vector<P> H(N);\n    vector<edge> es(M);\n    REP(i, N) { cin >>H[i].first; H[i].second = i; }\n    REP(i, M) {\n      cin >>es[i].f >>es[i].t >>es[i].c;\n      --es[i].f; --es[i].t;\n    }\n    SORT(H); REVERSE(H);\n    SORT(es);\n    vector<bool> v(N, false);\n    vector<int> parent(N), depth(N, 1);\n    REP(i, N) parent[i] = i;\n    int t = 0, ans = 0;\n    while(t < N){\n      //cout <<t <<\" -----------\" <<endl;\n      P n = H[t];\n      while(t < N && H[t].first == n.first) v[H[t++].second] = true;\n      //cout <<\"v = \" <<endl;\n      //REP(i, N) cout <<v[i] <<\", \"; cout <<endl;\n      REP(i, M){\n        edge e = es[i];\n        //cout <<e.f <<\", \" <<e.t <<\", \" <<e.c <<\", \" <<v[e.f] <<\", \" <<v[e.t] <<\", \" <<same(e.f, e.t, parent) <<endl;\n        if(v[e.f] && v[e.t] && !same(e.f, e.t, parent)){\n          merge(e.f, e.t, parent, depth);\n          ans += e.c;\n        }\n      }\n      //cout <<\"ans = \" <<ans <<endl;\n    }\n    if(check(N, parent)) cout <<ans <<endl;\n    else cout <<0 <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\nclass UnionFind\n{\nprivate:\n    vector<int> data;\n    int _groups;\npublic:\n    int n;\n    UnionFind(int n) : data(n, -1), _groups(n), n(n) { }\n\n    void unite(int x, int y)\n    {\n        x = root(x), y = root(y);\n        if (x != y)\n        {\n            --_groups;\n            if (data[x] > data[y])\n                swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n    int groups() const { return _groups; }\n};\nint main()\n{\n    int n, m;\n    while (cin >> n >> m, n)\n    {\n        vector<pint> land;\n        rep(i, n)\n        {\n            int h;\n            cin >> h;\n            land.pb(pint(h, i));\n        }\n        \n        int a[ten(5)], b[ten(5)], c[ten(5)];\n        vector<pint> e;\n        rep(i, m)\n        {\n            cin >> a[i] >> b[i] >> c[i];\n            --a[i], --b[i];\n            e.pb(pint(c[i], i));\n        }\n\n        sort(all(land));\n        sort(all(e));\n\n        int connect_h = -1;\n        bool down[222] = {};\n        rep(li, land.size())\n        {\n            UnionFind uf(n);\n            rep(i, m)\n                if (!down[a[i]] && !down[b[i]])\n                    uf.unite(a[i], b[i]);\n            if (uf.groups() > li + 1)\n                break;\n\n            down[land[li].second] = true;\n            connect_h = land[li].first;\n        }\n\n        UnionFind uf = UnionFind(n);        \n        bool up[222] = {};\n        int res = 0;\n        for (int li = n - 1; li >= 0; )\n        {\n            int h = land[li].first;\n            while (li >= 0 && land[li].first == h)\n                up[land[li--].second] = true;\n            \n            if (h > connect_h)\n                continue;\n            \n            foreach (it, e)\n            {\n                int i = it->second;\n                if (up[a[i]] && up[b[i]] && !uf.same(a[i], b[i]))\n                {\n                    uf.unite(a[i], b[i]);\n                    res += c[i];\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nstruct UnionFind {\n  vector<ll> par; \n  vector<ll> siz; \n\n    \n  UnionFind(ll sz_): par(sz_), siz(sz_, 1) {\n    for (ll i = 0; i < sz_; ++i) par[i] = i; \n  }\n  void init(ll sz_) {\n    par.resize(sz_);\n    siz.resize(sz_, 1);\n    for (ll i = 0; i < sz_; ++i) par[i] = i;\n  }\n\n  ll root(ll x) { \n    while (par[x] != x) {\n      x = par[x] = par[par[x]];\n    }\n    return x;\n  }\n\n  bool merge(ll x, ll y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n    if (siz[x] < siz[y]) swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool issame(ll x, ll y) {\n    return root(x) == root(y);\n  }\n\n  ll size(ll x) {\n    return siz[root(x)];\n  }\n};\n\nint n, m;\nint h[205], a[40040], b[40040], c[40040];\n\nvoid solve() {\n  vector<pair<int, int>> p(n);\n  rep(i, n) p[i] = {h[i], i};\n  sort(p.begin(), p.end());\n  vector<tuple<int, int, int>> G(m);\n  rep(i, m) G[i] = make_tuple(c[i], a[i], b[i]);\n  sort(G.begin(), G.end());\n\n  UnionFind uft(n);\n  rep(i, m) uft.merge(get<1>(G[i]), get<2>(G[i]));\n  if (uft.size(0) != n) {\n    cout << 0 << '\\n';\n    return;\n  }\n\n  vector<bool> ng(n, false);\n  int idx = n - 1;\n  rep(i, n) {\n    ng[p[i].second] = true;\n    if (i != n - 1 && p[i].first == p[i + 1].first) continue;\n    UnionFind uf(n);\n    rep(j, m) {\n      if (ng[get<1>(G[j])] || ng[get<2>(G[j])]) continue;\n      uf.merge(get<1>(G[j]), get<2>(G[j]));\n    }\n    if (uf.size(p[n - 1].second) != n - 1 - i) {\n      idx = i;\n      break;\n    }\n  }\n  //cout << idx << '\\n';\n\n  UnionFind ufa(n);\n  int ans = 0;\n  while (idx != -1) {\n    int resh = p[idx].first;\n    while (idx != -1 && p[idx].first == resh) {\n      ng[p[idx].second] = false;\n      idx--;\n    }\n    rep(i, m) {\n      if (ng[get<1>(G[i])] || ng[get<2>(G[i])]) continue;\n      if (ufa.merge(get<1>(G[i]), get<2>(G[i]))) {\n        ans += get<0>(G[i]);\n      }\n    }\n  }\n  cout << ans << '\\n';\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  while (cin >> n >> m, n && m) {\n    rep(i, n) cin >> h[i];\n    rep(i, m) {\n      cin >> a[i] >> b[i] >> c[i];\n      a[i]--, b[i]--;\n    }\n\n    solve();\n  }\n\n\n\n  \n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int to,cost;};\nstruct edge2{int from,to,cost;};\nint N,M,h[200];\nvector<edge> G[200];\nvector<int> ash,vc[200];\nint ord[200];\nbool operator<(const edge2& a,const edge2& b){\n\treturn a.cost<b.cost;\n}\nint par[200];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\treturn par[x]=find(par[x]);\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tpar[x]=y;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\trep(i,N) cin>>h[i];\n\t\trep(i,N) ash.pb(h[i]);\n\t\trep(i,N) vc[i].clear();\n\t\tsort(all(ash));\n\t\tash.erase(unique(all(ash)),ash.end());\n\t\trep(i,N){\n\t\t\tord[i]=ash.end()-lower_bound(all(ash),h[i])-1;\n\t\t\tvc[ord[i]].pb(i);\n\t\t}\n\t\trep(i,N) G[i].clear();\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--,b--;\n\t\t\tG[a].pb(edge{b,c});\n\t\t\tG[b].pb(edge{a,c});\n\t\t}\n\t\tint k=ash.size();\n\t\tinit(N);\n\t\tint last=-1;\n\t\trep(i,k){\n\t\t\tfor(int v:vc[i]){\n\t\t\t\tfor(edge e:G[v]){\n\t\t\t\t\tint u=e.to;\n\t\t\t\t\tif(ord[u]<=i) unite(u,v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x=-1;\n\t\t\tbool con=true;\n\t\t\trep(j,N){\n\t\t\t\tif(ord[j]<=i){\n\t\t\t\t\tif(x==-1){\n\t\t\t\t\t\tx=find(j);\n\t\t\t\t\t}else if(x!=find(j)){\n\t\t\t\t\t\tcon=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!con) last=i;\n\t\t}\n\t\tlong long ans=0;\n\t\tbool first=true;\n\t\tinit(N);\n\t\tfor(int i=last+1;i<k;i++){\n\t\t\tif(first){\n\t\t\t\tfirst=false;\n\t\t\t\tvector<edge2> es;\n\t\t\t\trep(j,N){\n\t\t\t\t\tif(ord[j]>i) continue;\n\t\t\t\t\tfor(edge e:G[j]){\n\t\t\t\t\t\tif(ord[e.to]>i) continue;\n\t\t\t\t\t\tedge2 e2=edge2{j,e.to,e.cost};\n\t\t\t\t\t\tes.pb(e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(all(es));\n\t\t\t\tfor(edge2 e:es){\n\t\t\t\t\tint x=e.from,y=e.to,c=e.cost;\n\t\t\t\t\tif(!same(x,y)){\n\t\t\t\t\t\tunite(x,y);\n\t\t\t\t\t\tans+=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tvector<edge2> es;\n\t\t\t\trep(j,N){\n\t\t\t\t\tif(ord[j]!=i) continue;\n\t\t\t\t\tfor(edge e:G[j]){\n\t\t\t\t\t\tif(ord[e.to]>i) continue;\n\t\t\t\t\t\tedge2 e2=edge2{j,e.to,e.cost};\n\t\t\t\t\t\tes.pb(e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(all(es));\n\t\t\t\tfor(edge2 e:es){\n\t\t\t\t\tint x=e.from,y=e.to,c=e.cost;\n\t\t\t\t\tif(!same(x,y)){\n\t\t\t\t\t\tunite(x,y);\n\t\t\t\t\t\tans+=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nclass unionfind {\n    public:\n    int n;\n    vector<int> par;\n    unionfind(int m) {\n        n = m;\n        par.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int find(int x) { return par[x] == x ? x : (par[x] = find(par[x])); }\n    int isunion(int x, int y) { return find(x) == find(y); }\n    int tounion(int x, int y) {\n        int p = find(x), q = find(y);\n        if (p == q) return 0;\n        par[q] = p;\n        return 1;\n    }\n};\n\nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n\n        vector<int> h(n);\n        map<int, int> mp;\n        for (int i = 0; i < n; ++i) {\n            cin >> h[i];\n            mp[h[i]] = 1;\n        }\n        int cc = 0;\n        for (auto& i : mp)\n            i.second = cc++;\n\n        vector<vector<int>> lis(n);\n        for (int i = 0; i < n; ++i) {\n            h[i] = mp[h[i]];\n            lis[h[i]].push_back(i);\n        }\n        vector<vector<pair<int, pair<int, int>>>> edge(n);\n        for (int i = 0; i < m; ++i) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            --a;\n            --b;\n            edge[min(h[a], h[b])].push_back(make_pair(c, make_pair(a, b)));\n        }\n        for (int i = 0; i < n; ++i)\n            sort(edge[i].begin(), edge[i].end());\n\n        int lastsep = n;\n        unionfind puf(n);\n        for (int i = n - 1; i >= 0; --i) {\n            for (auto j : edge[i])\n                puf.tounion(j.second.first, j.second.second);\n\n            for (int j = 0; j < n; ++j) {\n                if (h[j] >= i) {\n                    for (int k = 0; k < n; ++k) {\n                        if (h[k] >= i && !puf.isunion(j, k)) {\n                            lastsep = i;\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        if (lastsep == 0) {\n            cout << \"0\\n\";\n            continue;\n        }\n        vector<pair<int, pair<int, int>>> fedge;\n        for (int i = lastsep - 1; i < n; ++i)\n            for (auto j : edge[i])\n                fedge.push_back(j);\n\n        sort(fedge.begin(), fedge.end());\n        unionfind uf(n);\n        long long sum = 0;\n        for (auto i : fedge)\n            if (uf.tounion(i.second.first, i.second.second))\n                sum += i.first;\n\n        for (int i = lastsep - 2; i >= 0; --i)\n            for (auto j : edge[i])\n                if (uf.tounion(j.second.first, j.second.second))\n                    sum += j.first;\n\n        cout << sum << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,M;\nvector<P> H;\n\nstruct edge{\n  int to,from,c;\n  bool operator<(const edge& e) const{\n    return c < e.c;\n  }\n};\n\nvector<edge> E;\n\nstruct uni{\n  int d[222];\n  void init(){ memset(d,-1,sizeof(d)); }\n  int find(int a){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void marge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a]+=d[b]; d[b] = a;\n  }\n  bool same(int a,int b){ return find(a)==find(b); }\n  int size(int a){ return -d[find(a)]; }\n};\n\nuni U;\n\nbool used[333];\nint main(){\n  while( cin >> N >> M && (N||M) ){\n    U.init();\n    H.clear();\n    E.clear();\n    for(int i=0;i<N;i++) {\n      H.push_back(P(i,i));\n      cin >> H[i].first;\n    }\n    sort(H.rbegin(),H.rend());\n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      --a; --b;\n      E.push_back( (edge){a,b,c} );\n    }\n    sort(E.begin(),E.end());\n\n\n    int start = N+1;\n    for(int i=N;i>1;i--){\n      int id=H[0].second;\n      if( H[i-1].first == H[i].first && i < N ) continue;\n      memset(used,0,sizeof(used));\n      for(int j=0;j<i;j++) \n\tused[H[j].second] = true;    \n      uni up;\n      up.init();\n      for(int j=0;j<M;j++){\n\tif( used[E[j].to] && used[E[j].from] ) {\n\t  if( !up.same(E[j].to,E[j].from) ) {\n\t    up.marge(E[j].to,E[j].from);\n\t  }\n\t}\n      }  \n      if( up.size(id) == i ) start = i;\n      else break;\n    }\n\n    long long res = 0;\n    for(int i=start;i<=N;i++){\n      if( H[i-1].first == H[i].first ) \n\tcontinue;\n      for(int j=0;j<i;j++)\n\tused[H[j].second] = true;\n      \n      //      cout << id << endl;\n      for(int j=0;j<M;j++){\n\tif( used[E[j].to] && used[E[j].from] ) {\n\t  if( !U.same(E[j].to,E[j].from) ) {\n\t    //   cout << E[j].to << \" \"<< E[j].from << \" \"<< E[j].c << endl;\n\t    res+=(long long)E[j].c;\n\t    U.marge(E[j].to,E[j].from);\n\t  }\n\t}\n      }    \n    }\n    \n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m;\n\nbool is_connected(vector<vector<int>>& v, vector<int>& used, int start) {\n    int n = v.size();\n    queue<int> que;\n    que.push(start);\n\n    while (que.size()) {\n        int now = que.front();\n        que.pop();\n\n        if (used[now]) continue;\n        used[now] = true;\n\n        for (int j = 0; j < n; j++) {\n            if (v[now][j] >= 0 && !used[j]) {\n                que.push(j);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (!used[i]) return false;\n    }\n\n    return true;\n}\n\nint bfs(priority_queue<P, vector<P>, greater<P>>& que, vector<int>& used, vector<vector<int>>& v) {\n    int sum = 0;\n    while (que.size()) {\n        P p = que.top(); que.pop();\n        int now = p.second;\n        int cost = p.first;\n\n        if (used[now]) continue;\n        used[now] = true;\n        sum += cost;\n\n        for (int i = 0; i < n; i++) {\n            if (v[now][i] >= 0 && !used[i]) {\n                que.push(P(v[now][i], i));\n            }\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        map<int,vector<int>> h;\n        for (int i = 0; i < n; i++) {\n            int _h;\n            cin >> _h;\n\n            h[_h].push_back(i);\n        }\n\n        vector<vector<int>> v(n, vector<int>(n, -1));\n        for (int i = 0; i < m; i++) {\n            int x, y, c;\n            cin >> x >> y >> c;\n            --x, --y;\n            v[x][y] = v[y][x] = c;\n        }\n\n        {\n            vector<int> tmp(n, false);\n            if (!is_connected(v, tmp, 0)) {\n                cout << 0 << endl;\n                continue;\n            }\n        }\n\n        bool erased[200], merged[200];\n        memset(erased, 0, sizeof(erased));\n        memset(merged, 0, sizeof(erased));\n        int ans = 0;\n\n        for (auto l: h) {\n            auto vec = l.second;\n            bool _erased[200];\n            for (int i = 0; i < n; i++) _erased[i] = erased[i];\n            for (auto i: vec) erased[i] = true;\n\n            vector<int> used(n, false);\n            int unremoved_idx = -1;\n            for (int i = 0; i < n; i++) {\n                if (erased[i]) used[i] = true;\n                else unremoved_idx = i;\n            }\n\n            bool flag = true;\n            if (unremoved_idx >= 0 && !is_connected(v, used, unremoved_idx)) {\n                flag = false;\n            }\n\n            if (flag) {\n                for (auto i: vec) used[i] = false;\n                priority_queue<P, vector<P>, greater<P>> q;\n                for (int i = 0; i < vec.size(); i++) {\n                    for (int j = 0; j < n; j++) {\n                        if (v[vec[i]][j] >= 0 && !_erased[j] && used[j]) {\n                            q.push(P(v[vec[i]][j], vec[i]));\n                        }\n                    }\n                }\n\n                if (q.size() == 0) {\n                    for (int j = 0; j < n; j++) {\n                        if (v[vec[0]][j] >= 0 && !used[j]) q.push(P(v[vec[0]][j], j)), used[vec[0]] = true;\n                    }\n                }\n\n                ans += bfs(q, used, v);\n            } else {\n                for (int i = 0; i < n; i++) {\n                    used[i] = _erased[i];\n                }\n\n                priority_queue<P, vector<P>, greater<P>> q;\n                for (int i = 0; i < n; i++) {\n                    if (v[vec[0]][i] >= 0 && !used[i]) {\n                        q.push(P(v[vec[0]][i], i));\n                        used[vec[0]] = true;\n                    }\n                }\n\n                ans += bfs(q, used, v);\n                break;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<int,pair<int,int> >edge[60000];\nint h[210];\npair<int,int> ev[210];\nint UF[210];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;\n\tUF[a]+=UF[b];UF[b]=a;\n}\nint v[210];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d\",h+i);\n\t\tfor(int i=0;i<a;i++)ev[i]=make_pair(-h[i],i);\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)v[i]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\t\tp--;q--;\n\t\t\tedge[i]=make_pair(r,make_pair(p,q));\n\t\t}\n\t\tint ret=0;\n\t\tstd::sort(ev,ev+a);std::sort(edge,edge+b);\n\t\tint cnt=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint at=ev[i].second;\n\t\t\tv[at]=1;\n\t\t\tif(i==a-1||ev[i].first!=ev[i+1].first){\n\t\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\t\tint l=edge[j].second.first;\n\t\t\t\t\tint r=edge[j].second.second;\n\t\t\t\t\tif(v[l]&&v[r]&&FIND(l)!=FIND(r)){\n\t\t\t\t\t\tret+=edge[j].first;\n\t\t\t\t\t\tUNION(l,r);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt!=i){\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tret=0;\n\t\t\t\t\tfor(int j=0;j<a;j++)UF[j]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define fi first\n#define se second\n\nint uf[256];\nint rk[256];\n\nvoid uf_init() {\n\tfor(int i = 0; i < 256; i++) {\n\t\tuf[i] = i;\n\t\trk[i] = 0;\n\t}\n}\n\nint uf_find(int x) {\n\tif(uf[x] == x)\n\t\treturn x;\n\treturn uf[x] = uf_find(uf[x]);\n}\n\nbool uf_same(int a, int b) {\n\treturn uf_find(a) == uf_find(b);\n}\n\nvoid uf_merge(int a, int b) {\n\tint aa, bb;\n\taa = uf_find(a);\n\tbb = uf_find(b);\n\tif(aa == bb)\n\t\treturn;\n\tif(rk[aa] < rk[bb]) {\n\t\tuf[aa] = bb;\n\t}\n\telse {\n\t\tif(rk[aa] == rk[bb])\n\t\t\trk[aa]++;\n\t\tuf[bb] = aa;\n\t}\n}\n\nstruct edge {\n\tpii p; // テ」ツδ堙」ツつ「\n\tll b; // テヲツイツ暗」ツつ?ヲツ卍づゥツ鳴?\n\tll c; // テ」ツつウテ」ツつケテ」ツδ?\n};\n\nbool cost_cmp(const edge & a, const edge & b) {\n\treturn a.c < b.c;\n}\nbool time_cmp(const edge & a, const edge & b) {\n\treturn a.b < b.b;\n}\n\nint main() {\n\tint N, M;\n\twhile(cin >> N >> M, N || M) {\n\t\tvector<pii> h;\n\t\tvector<edge> eg;\n\t\th.resize(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> h[i].fi;\n\t\t\th[i].se = i;\n\t\t}\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint a, b, c;\n\t\t\tedge e;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tif(a > b) swap(a,b);\n\t\t\te.p = pii(a,b);\n\t\t\te.b = min(h[a].fi, h[b].fi);\n\t\t\te.c = c;\n\t\t\teg.push_back(e);\n\t\t}\n\t\tsort(eg.begin(), eg.end(), time_cmp);\n\t\tsort(h.begin(), h.end());\n\n\t\tint T = -1;\n\t\tfor(int i = 0; i < h.size(); i++) {\n\t\t\tuf_init();\n\t\t\tfor(int j = 0; j < eg.size(); j++) {\n\t\t\t\tif(eg[j].b < h[i].fi)\n\t\t\t\t\tcontinue;\n\t\t\t\tedge e;\n\t\t\t\te = eg[j];\n\t\t\t\tuf_merge(e.p.fi, e.p.se);\n\t\t\t}\n\t\t\tbool flg = true;\n\t\t\tint tmp = uf_find(h[i].se);\n\t\t\tfor(int j = i; j < h.size(); j++) {\n\t\t\t\tif(tmp != uf_find(h[j].se))\n\t\t\t\t\tflg = false;\n\t\t\t}\n\t\t\tif(flg == false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tT = h[i].fi;\n\t\t\twhile(i < h.size()-1 && h[i].fi == h[i+1].fi) i++;\n\t\t}\n\t\tll res = 0;\n\t\tuf_init();\n\t\twhile(T >= 0) {\n\t\t\tvector<edge> v;\n\t\t\tll nex_t = -1;\n\t\t\tfor(int i = 0; i < eg.size(); i++) {\n\t\t\t\tif(T <= eg[i].b)\n\t\t\t\t\tv.push_back(eg[i]);\n\t\t\t\telse\n\t\t\t\t\tnex_t = max(nex_t, eg[i].b);\n\t\t\t}\n\t\t\tsort(v.begin(), v.end(), cost_cmp);\n\t\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\t\tedge e = v[i];\n\t\t\t\tif(!uf_same(e.p.fi, e.p.se)) {\n\t\t\t\t\tres += e.c;\n\t\t\t\t\tuf_merge(e.p.fi, e.p.se);\n\t\t\t\t}\n\t\t\t}\n\t\t\tT = nex_t;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<Int, P> T;\n\nInt u[1080];\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(Int x, Int y){\n\tu[r(x)] = r(y);\n}\nvector<T> edge[1080000];\nInt h[1080];\nbool come[1080];\nint main(){\n\tInt n, m;\n\twhile(cin >> n >> m, n | m){\n\t\tInt res = 0, bridge = 0, a, b, c, cnt = 0;\n\t\tfor(Int i = 0;i < n;i++)cin >> h[i], u[i] = i, come[i] = false;\n\t\tfor(Int i = 0;i < m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tedge[min(h[a], h[b])].push_back(T(c, P(a, b)));\n\t\t}\n\t\tInt breakpoInt = 1000000;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tif(!come[from])cnt++, come[from] = true;\n\t\t\t\t\tif(!come[to])cnt++, come[to] = true;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt && cnt - 1 != bridge){\n\t\t\t\tbreakpoInt = i;\n\t\t\t}\n\t\t}                    \n\t\tbridge = 0;\n\t\tvector<T> tmp;\n\t\tfor(Int i = 0;i < n;i++)u[i] = i;\n\t\tif(breakpoInt)breakpoInt--;\n\t\tfor(Int i = 1000000;i >= breakpoInt;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\ttmp.push_back(edge[i][j]);\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor(Int i = 0;i < tmp.size();i++){\n\t\t\tInt from = tmp[i].second.first, to = tmp[i].second.second;\n\t\t\tif(r(from) != r(to)){\n\t\t\t\tbridge++;\n\t\t\t\tres += tmp[i].first;\n\t\t\t\tunite(from, to);\n\t\t\t}\n\t\t}\n\t\tfor(Int i = breakpoInt;i > 0;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tres += edge[i][j].first;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tedge[i].clear();\n\t\t}\n\t\tif(bridge + 1 != n)res = 0;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2511&lang=jp\n// references : http://mayokoex.hatenablog.com/entry/2016/05/03/233156\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n#define MAXT 1000100\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n\tedge() {}\n\tedge(int f, int t, int c) :from(f), to(t), cost(c) {}\n\tbool operator < (const edge& o) const { return cost < o.cost; }\n};\n\nstruct UnionFind {\n\tvector<int> par;\n\tint n, cnt;\n\tUnionFind(const int& x = 0) { init(x); }\n\tvoid init(const int& x) { par.assign(cnt = n = x, -1); }\n\tinline int find(const int& x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tinline bool same(const int& x, const int& y) { return find(x) == find(y); }\n\tinline bool unite(int x, int y) {\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\t--cnt;\n\t\tif (par[x] > par[y]) swap(x, y);\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\tinline int count() const { return cnt; }\n\tinline int count(int x) { return -par[find(x)]; }\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M;\n\twhile (cin >> N >> M, N | M) {\n\t\tvector<int> h[MAXT];\n\t\tfor (int i = 0; i < N; i++) { int t; cin >> t; h[t].push_back(i); }\n\t\tvector<edge> G;\n\t\tfor (int i = 0; i < M;i++) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tG.push_back(edge(a, b, c));\n\t\t}\n\t\tsort(G.begin(), G.end());\n\t\t\n\t\tUnionFind uf(N);\n\t\tfor (auto e : G) uf.unite(e.from, e.to);\n\t\tif (uf.count() > 1) { cout << 0 << endl; continue; }\n\n\t\tvector<int> f(N, 0);\n\t\tint cnt = 1;\n\t\tint last_t = -1;\n\t\tfor (int t = 0; t < MAXT;t++) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) { f[n] = 1; cnt++; }\n\t\t\tUnionFind uf(N);\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (f[e.from] == 1 || f[e.to] == 1)continue;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\t\t\tif (uf.count() != cnt) { last_t = t; break; }\n\t\t}\n\t\t//if (last_t == -1)last_t = MAXT;\n\n\t\tfill(f.begin(), f.end(), 0);\n\t\tll ans = 0;\n\t\tfor (int t = last_t; t < MAXT;t++)for (auto n : h[t]) f[n] = 1;\n\t\t/* Minimum spanning tree */\n\t\tfor (auto e : G) {\n\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t}\n\t\t/*----------------------*/\n\n\t\tfor (int t = last_t - 1; t >= 0;t--) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) f[n] = 1;\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,M;\nvector<P> H;\n\nstruct edge{\n  int to,from,c;\n  bool operator<(const edge& e) const{\n    return c < e.c;\n  }\n};\n\nvector<edge> E;\n\nstruct uni{\n  int d[222];\n  void init(){ memset(d,-1,sizeof(d)); }\n  int find(int a){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void marge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a]+=d[b]; d[b] = a;\n  }\n  bool same(int a,int b){ return find(a)==find(b); }\n  int size(int a){ return -d[find(a)]; }\n};\n\nuni U;\n\nbool used[333];\nint main(){\n  while( cin >> N >> M && (N||M) ){\n    U.init();\n    H.clear();\n    E.clear();\n    for(int i=0;i<N;i++) {\n      H.push_back(P(i,i));\n      cin >> H[i].first;\n    }\n    sort(H.rbegin(),H.rend());\n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      --a; --b;\n      E.push_back( (edge){a,b,c} );\n    }\n    sort(E.begin(),E.end());\n\n\n    for(int i=0;i<N;i++)used[i]=true;\n    int start = N+1;\n    for(int i=N;i>0;i--){\n      int id=0;\n      if(i<N){\n\tid=H[i].second;\n\tused[id] = false;\n\tif( H[i].first == H[i-1].first ) {\n\t  continue;\n\t}\n      }\n      uni up;\n      up.init();\n      for(int j=0;j<M;j++){\n\tif( used[E[j].to] && used[E[j].from] ) {\n\t  if( !up.same(E[j].to,E[j].from) ) {\n\t    up.marge(E[j].to,E[j].from);\n\t  }\n\t}\n      }  \n      if( up.size(id) == i ) start = i;\n      else break;\n    }\n\n    long long res = 0;\n    for(int i=start;i<=N;i++){\n      if( i < N-1 && H[i].first == H[i+1].first ) \n\tcontinue;\n      for(int j=0;j<i;j++)\n\tused[H[j].second] = true;\n      \n      //      cout << id << endl;\n      for(int j=0;j<M;j++){\n\tif( used[E[j].to] && used[E[j].from] ) {\n\t  if( !U.same(E[j].to,E[j].from) ) {\n\t    //   cout << E[j].to << \" \"<< E[j].from << \" \"<< E[j].c << endl;\n\t    res+=(long long)E[j].c;\n\t    U.marge(E[j].to,E[j].from);\n\t  }\n\t}\n      }    \n    }\n    \n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nvector<vector<pair<ll,ll>>> vv(210);\nvector<pair<ll,ll>> h;\nvector<pair<ll,pair<ll,ll>>> v;\n\nbool use[210*210];\nint uiteru[210];\nint n,m;\n\nstruct UF\n{\n\tvector<int> par; // 親\n\tvector<int> sz; // 数\n\t// 初期化\n\tUF(int n):par(n),sz(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\nll check(int num){\n\tDBG(\n\tcout << \"in check\" << endl;\n\tSHOW1d(uiteru,n);\n\t)\n\tUF uf(n);\n\tll ret = 0;\n\tREP(i,m){\n\t\tint a = v[i].SE.FI;\n\t\tint b = v[i].SE.SE;\n\t\tint c = v[i].FI;\n\t\tif(uiteru[a] + uiteru[b] != 0)continue;\n\t\tif(!uf.same(a,b)){\n\t\t\tret += c;\n\t\t\tuf.unite(a,b);\n\t\t}\n\t}\n\tDBG(cout << \"ret \" << ret << endl;)\n\tint cou = 0;\n\tREP(i,n)cou = max(cou,uf.size(i));\n\tif(cou == num){\n\t\treturn ret;\n\t}\n\telse \n\t{\n\t\treturn -1;\n\t}\n\t\t\n}\t\t\n\nint main()\n{\n\twhile(cin >> n >> m,n|m){\n\t\tint num = n;\n\t\th.clear();\n\t\tv.clear();\n\t\tREP(i,210*210)use[210*210] = false; \n\t\tREP(i,210)uiteru[i] = 0;\n\t\t\n\t\tREP(i,n){\n\t\t\tll tmp;cin >> tmp;\n\t\t\th.PB(MP(tmp,i));\n\t\t}\n\t\t\n\t\tREP(i,m){\n\t\t\tll a,b,c;cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv.PB(MP(c,MP(a,b)));\n\t\t}\n\t\t\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\t\n\t\tDBG(\n\t\tREP(i,m){\n\t\t\tcout << v[i].FI << ' ' << v[i].SE.FI << ' ' << v[i].SE.SE << endl;\n\t\t}\n\t\t)\n\t\t\n\t\tll ans = 0;\n\t\tll ret = check(n);\n\t\tll cou = 0;\n\t\tll prev = ret;\n\t\tif(ret == -1){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\twhile(1){\n\t\t\t\tint tmp = cou;\n\t\t\t\twhile(cou < n && h[cou].FI == h[cou+1].FI){\n\t\t\t\t\tuiteru[h[cou].SE] = 2;\n\t\t\t\t\tcou++;\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"cou \" << cou << endl;);\n\t\t\t\tuiteru[h[cou].SE] = 2;\n\t\t\t\tret = check(n - cou - 1);\n\t\t\t\tif(cou == n-1 || ret == -1){\n\t\t\t\t\tcout << max(0LL,prev) << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tREP(j,m){\n\t\t\t\t\t\tint kazu = 0;\n\t\t\t\t\t\tint a = v[j].SE.FI;\n\t\t\t\t\t\tint b = v[j].SE.SE;\n\t\t\t\t\t\tbool flag = false;\n\t\t\t\t\t\tint tmptmp;\n\t\t\t\t\t\tfor(int i = tmp;i <= cou;i++){\n\t\t\t\t\t\t\tif(uiteru[h[i].SE] == 2 && (a == h[i].SE || b == h[i].SE)){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\ttmptmp = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag && (uiteru[a] < 2 || uiteru[b] < 2)){\n\t\t\t\t\t\t\tuiteru[h[tmptmp].SE] = 1;\n\t\t\t\t\t\t\tans += v[j].FI;\n\t\t\t\t\t\t\tDBG(cout << \"j \" << j << \"cost \" << v[j].FI << ' ' << a << ' ' << b << endl;);\n\t\t\t\t\t\t\tkazu++;\n\t\t\t\t\t\t\tif(kazu == cou - tmp + 1)break;\n\t\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = tmp;i <= cou;i++){\n\t\t\t\t\t\tuiteru[h[i].SE] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tDBG(cout << \"ans \" << ans << endl;);\n\t\t\t\t\tprev = ans + ret;\n\t\t\t\t\tDBG(cout << \"prev \" << prev << endl;);\n\t\t\t\t}\n\t\t\t\tcou++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n\nclass UnionFindTree{\n  int m_size;\n  vector<int> parent;\n  vector<int> rank;\n  int find(int a);\npublic:\n  void init(int size);\n  void unite(int a, int b);\n  bool same(int a, int b);\n};\n\nvoid UnionFindTree::init(int size){\n  m_size = size;\n  parent.clear();\n  rank.clear();\n  for(int i = 0; i < size; i++){\n    parent.push_back(i);\n    rank.push_back(0);\n  }\n  return;\n}\n\nint UnionFindTree::find(int a){\n  if(parent[a] != a){ parent[a] = find(parent[a]); }\n  return parent[a];\n}\n\nvoid UnionFindTree::unite(int a, int b){\n  int x = find(a);\n  int y = find(b);\n  if(x == y){ return; }\n\n  if(rank[x] < rank[y]){ parent[x] = y; }\n  else{\n    parent[y] = x;\n    if(rank[x] == rank[y]){ rank[x]++; } \n  }\n  return;\n}\n\nbool UnionFindTree::same(int a, int b){\n  return find(a) == find(b);\n}\n\n// ???????????????\npair<int, int> kruskal(int v, vector<pair<pair<int, int>, pair<int, int> > > edges, vector<bool> NGedge){\n  int cost = 0, unite_count = 0;\n  UnionFindTree uf;\n  uf.init(v);\n\n  for(int i = 0; i < edges.size(); i++){\n    int nowcost = edges[i].first.second;\n    int a = edges[i].second.first;\n    int b = edges[i].second.second;\n    if(NGedge[i] || uf.same(a, b)){ continue; }\n\n    uf.unite(a, b);\n    cost += nowcost;\n    unite_count++;\n  }\n\n  return make_pair(cost, unite_count);\n}\n\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 &&  m == 0){ break; }\n\n    // ??¶??????????????±?????\\???\n    vector<int> h(n);\n    vector<pair<int, int> > sink;\n    for(int i = 0; i < n; i++){\n      cin >> h[i];\n      sink.push_back(make_pair(h[i], i));\n    }\n    sort(sink.begin(), sink.end());\n    \n    // ???????????????????????????????????±?????\\???\n    int a, b, c;\n    vector<pair<pair<int, int>, pair<int, int> > > edges;\n    for(int i = 0; i < m; i++){\n      cin >> a >> b >> c;\n      --a; --b;\n      //((-????????\\, ?????????), (from, to))\n      edges.push_back(make_pair(make_pair(-min(h[a], h[b]), c), make_pair(a, b)));\n    }\n    sort(edges.begin(), edges.end());\n\n    // ?????????????????¶????´??£????????????£???????´?????????????????¢??????????\n    int dobon;\n    vector<bool> NGedge(m, false);\n    for(dobon = 0; dobon < n - 1; dobon++){\n      pair<int, int> result = kruskal(n, edges, NGedge);\n      // ???????????????????????¶??????????????£?????????????????£??????break\n      if(result.second != n - 1 - dobon){ break; };\n      \n      // NG??????????????´??°\n      for(int j = 0; j < m; j++){\n        if(edges[j].second.first == sink[dobon].second || edges[j].second.second == sink[dobon].second){\n          NGedge[j] = true;\n        }\n      }\n    }\n    // ????????????????????£?????????????????£?????????0?????????\n    if(dobon <= 0){ cout << 0 << endl; }\n    else{\n      int bord = h[sink[dobon - 1].second];\n      // ?????????dobon????????§??£????????????????????????????????£?????????\n      // dobon????????\\????????£???????????????????????????????????????\n      for(int i = 0; i < m; i++){\n        if(bord < -edges[i].first.first){ edges[i].first.first = -bord; }\n      }\n      sort(edges.begin(), edges.end());\n      \n      pair<int, int> result = kruskal(n, edges, vector<bool>(m, false));\n      cout << result.first << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REPR(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\ntypedef long long ll;\n\n// UnionFindTree\nstruct DisjointSet {\n\nprivate:\n    struct Vertex {\n        int parent;\n        int rank;\n    };\n    int _size;\n    vector<Vertex> _vertices;\n\npublic:\n    void init(int size) {\n        _size = size;\n        _vertices.resize(_size);\n        for(int i=0; i<_size; i++) {\n            _vertices[i].parent = i;\n            _vertices[i].rank = 0;\n        }\n    }\n\n    void unite(int x, int y) {\n        link(find(x), find(y));\n    }\n\n    void link(int x, int y) {\n        if (x==y) return;\n        if (_vertices[x].rank > _vertices[y].rank) {\n            _vertices[y].parent = x;\n        } else {\n            _vertices[x].parent = y;\n            if (_vertices[x].rank == _vertices[y].rank) {\n                _vertices[y].rank++;\n            }\n        }\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int find(int index) {\n        if (_vertices[index].parent == index) {\n            return index;\n        } else {\n            return _vertices[index].parent = find(_vertices[index].parent);\n        }\n    }\n};\n\nstruct Edge {\n    int start;\n    int end;\n    ll cost;\n    int time;\n    bool used;\n};\n\nint N, M;\nint h[1000];\nvector<Edge> edges;\nDisjointSet ufSet;\n\nbool span(int time) {\n    for(auto& edge: edges) {\n        if (edge.time>=time && !ufSet.same(edge.start, edge.end)) {\n            ufSet.unite(edge.start, edge.end);\n            assert(ufSet.same(edge.start, edge.end));\n            edge.used = true;\n        }\n    }\n\n    int t = -1;\n    REP(i, N) {\n        if (h[i]>=time && t==-1) t = i;\n        if (h[i]>=time && !ufSet.same(i, t)) return false;\n    }\n    return true;\n}\n\nvoid refresh() {\n    ufSet.init(N);\n    for(auto& edge: edges) edge.used = false;\n}\n\nll solve() {\n    scanf(\"%d%d\", &N, &M);\n    if (N==0 && M==0) return -1;\n    REP(i, N) scanf(\"%d\", &h[i]);\n\n    edges = vector<Edge>();\n    REP(i, M) {\n        int a, b; ll c;\n        scanf(\"%d%d%lld\", &a, &b, &c);\n        a--; b--;\n        edges.push_back((Edge){a, b, c, min(h[a], h[b])});\n    }\n    sort(ALL(edges), [](Edge& e1, Edge& e2) {return e1.cost<e2.cost;});\n\n    int temp[1000];\n    memcpy(temp, h, sizeof(h));\n    sort(temp, temp+N);\n    int _i=0;\n    REP(i, N) {\n        refresh();\n        if (!span(temp[i])) break;\n        _i++;\n    }\n    refresh();\n    REPR(j, _i) span(temp[j]);\n\n    return [](){\n        ll ans = 0;\n        for(auto& edge: edges) {\n            if (edge.used) ans += edge.cost;\n        }\n        return ans;\n    }();\n}\n\nint main() {\n    ll ans;\n    while((ans=solve())>=0) {\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint n, m;\nint v[200];\nvector<int> h;\nint par[200];\nint d[200][200];\nvector<PIP> bridge;\n\nint find(int a) {\n    if (par[a] == a) return a;\n    return par[a] = find(par[a]);\n}\n\nvoid unite(int a, int b) {\n    int p = find(a), q = find(b);\n    if(p == q) return;\n    par[p] = q;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    while(cin >> n >> m, n | m) {\n        memset(d, 0, sizeof(d));\n        h.clear(), bridge.clear();\n\n        rep(i, n) cin >> v[i], h.pb(v[i]);\n        sort(all(h));\n        uni(h);\n\n        rep(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c; a--, b--;\n            d[a][b] = d[b][a] = c;\n            bridge.pb(PIP(c, P(a, b)));\n        }\n        sort(all(bridge));\n\n        iota(par, par + n, 0);\n\n        int tmp = h.size();\n        rep(i, h.size()) {\n            iota(par, par + n, 0);\n            int k;\n            rep(j, m) {\n                int p = bridge[j].se.fi, q = bridge[j].se.se;\n                if (v[p] > h[i] && v[q] > h[i] && find(p) != find(q)) {\n                    k = p;\n                    unite(p, q);\n                }\n            }\n\n            bool ok = true;\n            rep(j, n) if (v[j] > h[i] && find(j) != find(k)) ok = false;\n\n            if (!ok) {\n                tmp = i;\n                break;\n            }\n        }\n\n        int cost = 0;\n        iota(par, par + n, 0);\n        repr(i, tmp) {\n            rep(j, m) {\n                int p = bridge[j].se.fi, q = bridge[j].se.se;\n                if (v[p] > h[i] && v[q] > h[i] && find(p) != find(q)) {\n                    cost += bridge[j].fi;\n                    unite(p, q);\n                }\n            }\n        }\n\n        rep(j, m) {\n            int p = bridge[j].se.fi, q = bridge[j].se.se;\n            if (find(p) != find(q)) {\n                cost += bridge[j].fi;\n                unite(p, q);\n            }\n        }\n\n        rep(i, n) if (find(0) != find(i)) cost = 0;\n\n        cout << cost << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define pll     pair<long long, long long>\n#define ll      long long\n\nstruct edge {\n        int a, b, cost;\n        bool operator < (const edge &r) const { return cost > r.cost; }\n};\n\nstruct UnionFind {\n        int n;\n        vector<int> parent;\n        vector<int> rank;\n        vector<int> num;\n        int find(int x) {\n                if (parent[x] == x) return  x;\n                return parent[x] = find(parent[x]);\n        }\n        UnionFind(int n_) {\n                n = n_;\n                parent.resize(n);\n                for (int i = 0; i < n; i ++) parent[i] = i;\n                rank.assign(n, 0);\n                num.assign(n, 1);\n        }\n        void unite(int x, int y) {\n                if ((x = find(x)) != (y = find(y))) {\n                        if (rank[x] < rank[y]) {\n                                parent[x] = y;\n                                num[y] += num[x];\n                        } else {\n                                parent[y] = x;\n                                if (rank[x] == rank[y]) rank[x] ++;\n                                num[x] += num[y];\n                        }\n                        n --;\n                }\n        }\n        bool same(int x, int y) { return find(x) == find(y); }\n        int get() { return n; }\n        int get(int x) { return num[find(x)]; }\n};\nvector<edge> g[202];\nint used[202];\n\nvoid visit(int v, int t, const vector<int> &h) {\n        used[v] = true;\n        for (auto e : g[v]) if (!used[e.b]) {\n                if (h[e.b] < t) continue;\n                visit(e.b, t, h);\n        }\n}\n\nint main() {\n        int n, m;\n        while (scanf(\"%d%d\", &n, &m) && n) {\n                for (int i = 0; i < n; i ++) g[i].clear();\n                vector<int> h(n);\n                for (int i = 0; i < n; i ++) scanf(\"%d\", &h[i]);\n                vector<int> hh = h;\n                sort(all(hh));\n                map<int, int> zip;\n                int cnt = 1;\n                for (int i = 0; i < n; i ++) zip[hh[i]] = cnt ++;\n                for (int i = 0; i < n; i ++) h[i] = zip[h[i]];\n\n                //for (int i = 0; i < n; i ++) cerr << \"h = \" << h[i] << endl;\n                //priority_queue<int> es;\n                for (int i = 0; i < m; i ++) {\n                        int a, b, c;\n                        scanf(\"%d%d%d\", &a, &b, &c);\n                        a --, b --;\n                        //es.push_back((edge) { a, b, c} );\n                        g[a].push_back({a, b, c});\n                        g[b].push_back({b, a, c});\n                }\n                cnt --;\n                //cerr << cnt << endl;\n                int end_t = cnt + 1;\n                //auto get_edge = [&] (int i) {\n                //}\n                for (int t = 1; t <= cnt; t ++) {\n                        memset(used, 0, sizeof used);\n                        for (int i = 0; i < n; i ++) {\n                                if (h[i] >= t) {\n                                        visit(i, t, h);\n                                        break;\n                                }\n                        }\n                        //for (int i = 0; i < n; i ++) cerr << used[i] << endl;\n                        for (int i = 0; i < n; i ++) {\n                                if (!used[i] && h[i] >= t) {\n                                        end_t = t;\n                                        goto end;\n                                }\n                        }\n                }\n                end:;\n                long long ans = 0;\n                end_t --;\n                //cerr << \"end_t = \" << end_t << endl;\n                UnionFind uf(n);\n                priority_queue<edge> pq;\n                for (int i = 0; i < n; i ++) {\n                        if (end_t < h[i]) {\n                                for (auto e : g[i]) {\n                                        if (end_t < h[e.b]) {\n                                                pq.push(e);\n                                        }\n                                }\n                        }\n                }\n                for (int t = end_t; t >= 1; t --) {\n                        for (int i = 0; i < n; i ++) {\n                                if (t == h[i]) {\n                                        for (auto e : g[i]) {\n                                                if (t <= h[e.b]) {\n                                                        pq.push(e);\n                                                }\n                                        }\n                                }\n                        }\n                        while (!pq.empty()) {\n                                edge e = pq.top(); pq.pop();\n                                if (!uf.same(e.a, e.b)) {\n                                        uf.unite(e.a, e.b);\n                                        //cerr << \"e = \" << e.a << ' ' << e.b << ' ' << e.cost << endl;\n                                        ans += e.cost;\n                                }\n                        }\n                }\n                cout << ans << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define DEBUG(x) cout<<(#x)<<\":\"<<x<<endl\n\n// uf\nint data[252];\nvoid uf_init(int n){\n  REP(i,n)data[i]=-1;\n}\nint uf_root(int x){\n  return (data[x]<0?x:data[x]=uf_root(data[x]));\n}\nint uf_size(int x){\n  return -data[uf_root(x)];\n}\nvoid uf_unite(int a,int b){\n  a=uf_root(a);\n  b=uf_root(b);\n  if(a!=b){\n    if(-data[a]<-data[b])swap(a,b);\n    data[a]+=data[b];\n    data[b]=a;\n  }\n}\nbool uf_same(int a,int b){\n  return uf_root(a)==uf_root(b);\n}\n\nint n,m;\npii h[252];\nint mp[252][252];\nconst int INF = 830252521;\n\nvoid solve(){\n  REP(i,n){\n    int x;\n    scanf(\"%d\",&x);\n    h[i] = pii(x,i);\n  }\n  sort(h,h+n);\n  reverse(h,h+n);\n  REP(i,n)REP(j,n)mp[i][j]=INF;\n  REP(i,m){\n    int a,b,c;\n    scanf(\"%d%d%d\",&a,&b,&c);\n    --a;--b;\n    mp[a][b] = min(mp[a][b],c);\n    mp[b][a] = min(mp[b][a],c);\n  }\n  // REP(i,n){\n  //   REP(j,n)printf(\"%10d\",mp[i][j]);\n  //   putchar('\\n');\n  // }\n  uf_init(n);\n  vi isl;\n  ll ans = 0;\n  int con[252];\n  vector< pair<int,pii> > edges;\n  // first : should connect or not\n  REP(i,n){\n    con[i] = 0;\n    int x = h[i].second;\n    REP(j,i){\n      int y = h[j].second;\n      if(mp[x][y]!=INF)\n        edges.push_back(pair<int,pii>(mp[x][y],pii(x,y)));\n    }\n    if(i<n-1&&h[i].first==h[i+1].first){\n      con[i] = -1;\n      continue;\n    }\n    sort(ALL(edges));\n    REP(j,edges.size()){\n      int c = edges[j].first;\n      int s = edges[j].second.first;\n      int t = edges[j].second.second;\n      if(!uf_same(s,t)){\n        uf_unite(s,t);\n      }\n    }\n    if(uf_size(x)==i+1){\n      con[i]=1;\n    }\n    edges.clear();\n  }\n  int concon = 1;\n  REP(_i,n){\n    int i = n-1-_i;\n    if(con[i]==-1)continue;\n    if(con[i]==0)concon=0;\n    con[i] = concon;\n  }\n  // second : let's connect\n  uf_init(n);\n  edges.clear();\n  REP(i,n){\n    int x = h[i].second;\n    REP(j,i){\n      int y = h[j].second;\n      if(mp[x][y]!=INF)\n        edges.push_back(pair<int,pii>(mp[x][y],pii(x,y)));\n    }\n    if(i<n-1&&h[i].first==h[i+1].first)continue;\n    if(!con[i])continue;\n    sort(ALL(edges));\n    REP(j,edges.size()){\n      int c = edges[j].first;\n      int s = edges[j].second.first;\n      int t = edges[j].second.second;\n      if(!uf_same(s,t)){\n        ans += c;\n        uf_unite(s,t);\n      }\n    }\n    edges.clear();\n  }\n  printf(\"%lld\\n\",ans);\n}\n\nint main(){\n  while(true){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 && m==0)break;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\nconst int MAX_V=200;\nconst ll INF=LONG_MAX;\n\nll cost[MAX_V][MAX_V];\nll mincost[MAX_V];\nbool used[MAX_V];\n\nvoid init(int V){\n\tV++;\n\tREP(i,MAX_V){\n\t\tmincost[i]=INF;\n\t\tused[i]=false;\n\t}\n\tmincost[0]=0;\n}\nll prim(int V,bool do_init=true){\n\tif(do_init){\n\t\tinit(V);\n\t}\n\tV++;\n\tll res=0;\n\twhile(true){\n\t\tint v=-1;\n\t\tREP(u,V){\n\t\t\tif(!used[u]&&(v==-1||mincost[u]<mincost[v])&&mincost[u]<INF)v=u;\n\t\t}\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\tREP(u,MAX_V){\n\t\t\tmincost[u]=min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n,m;\n\tint cases=0;\n\twhile(cin>>n>>m,n|m){\n\t\tcases++;\n\t\tif(cases==72){\n\t\t\tint aaa=1;\n\t\t}\n\t\tvector<pii> h(n);\n\t\tREP(i,n){\n\t\t\tcin>>h[i].first;\n\t\t\th[i].second=i;\n\t\t}\n\t\tsort(RALL(h));\n\t\tvvi true_cost(n,vi(n,INF));\n\t\tREP(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ttrue_cost[a-1][b-1]=c;\n\t\t\ttrue_cost[b-1][a-1]=c;\n\t\t}\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tcost[i][j]=true_cost[h[i].second][h[j].second];\n\t\t\t\tcost[j][i]=true_cost[h[j].second][h[i].second];\n\t\t\t}\n\t\t}\n\t\tint max_index=-1;\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\twhile(i<n-1&&i>=0&&h[i+1].first==h[i].first){\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tprim(i);\n\t\t\tbool ok=true;\n\t\t\tREP(j,i+1){\n\t\t\t\tif(!used[j]){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok){\n\t\t\t\tmax_index=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tll ans=0;\n\t\tif(max_index<n-1){\n\t\t\tmax_index++;\n\t\t\twhile(max_index<n-1&&max_index>=0&&h[max_index+1].first==h[max_index].first){\n\t\t\t\tmax_index++;\n\t\t\t}\n\t\t\tans=prim(max_index);\n\t\t}\n\t\tfor(int i=max_index;i<n;i++){\n\t\t\twhile(i<n-1&&h[i+1].first==h[i].first){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tans+=prim(i,false);\n\t\t\t//int mmin=INF;\n\t\t\t//REP(j,i){\n\t\t\t//\tmmin=min(mmin,cost[j][i]);\n\t\t\t//}\n\t\t\t//if(mmin<INF)\n\t\t\t//ans+=mmin;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\nstruct union_find {\n\tvector<ll> v; // ??????id?????¨???????????????????????´????????¨????????????*(-1)?????¨??????\n\tunion_find(ll n) : v(n, -1) {}\n\tll find(ll x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(ll x, ll y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y];\n\t\tv[y] = x;\n\t}\n\tbool same(ll x, ll y) { return find(x) == find(y); }\n\tll size(ll x) { return -v[find(x)]; }\n};\n\nusing E = tuple<ll, ll, ll>; // = {cost, u, v}\nvector<E> kruskal(vector<E> & es, union_find & uf, ll year, const vector<ll> & h) {\n\tvector<E> res;\n\tfor (auto e : es) {\n\t\tll cost, u, v;\n\t\ttie(cost, u, v) = e;\n\t\tif (min(h[u], h[v]) < year) continue;\n\t\tif (uf.same(u, v)) continue;\n\t\tuf.unite(u, v);\n\t\tres.push_back(e);\n\t}\n\treturn res;\n}\n\n\nint main() {\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0); // cin??¨cout?????£????????????\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\twhile (true) {\n\t\tll n, m;\n\t\tcin >> n >> m;\n\t\tif (n == 0) break;\n\t\tvector<ll> h(n); REP(i, n) cin >> h[i];\n\t\t\n\t\tvector<E> es(m); REP(i, m) cin >> get<1>(es[i]) >> get<2>(es[i]) >> get<0>(es[i]);\n\t\tREP(i, m) {\n\t\t\tget<1>(es[i])--;\n\t\t\tget<2>(es[i])--;\n\t\t}\n\t\tsort(ALL(es));\n\n\t\tmap<ll, ll> years;\n\t\tREP(i, n) years[h[i]]++;\n\t\t\n\t\tunion_find uf(n);\n\t\tll cost = 0;\n\t\tll cur_n = 0;\n\t\tfor (auto it = years.rbegin(); it != years.rend(); ++it) {\n\t\t\tcur_n += it->second;\n\t\t\tauto uf_backup = uf;\n\t\t\tauto v = kruskal(es, uf, it->first, h);\n\t\t\tif (!v.empty() && uf.size(get<1>(v[0])) == cur_n) {\n\t\t\t\tfor (auto e : v) cost += get<0>(e);\n\t\t\t} else {\n\t\t\t\tuf = union_find(n);\n\t\t\t\tcost = 0;\n\t\t\t}\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\nstruct union_find{\n    vector<int> par, rank;\n    union_find(int n){\n        par = vector<int>(n);\n        rank = vector<int>(n);\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nint main(){\n    int N,M;\n    vector<P> H;\n    vector<P> G[200];//to, cost\n    bool used[200];\n    priority_queue<T,vector<T>,greater<T>> que;\n    union_find U(200),U2(200);\n\n    while(cin>>N>>M,N){\n        H.clear();\n        for(int i=0;i<N;i++){\n            int h;\n            cin>>h;\n            H.emplace_back(h,i);\n        }\n        sort(H.begin(),H.end(),greater<P>());\n        for(int i=0;i<200;i++) G[i].clear();\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--;b--;\n            G[a].emplace_back(b,c);\n            G[b].emplace_back(a,c);\n        }\n        fill(used, used+200, false);\n        U.init(200);\n        U2.init(200);\n\n        int h=-1;\n        for(int i=0;i<N;i++){\n            while(true){\n                int a = H[i].second;\n                for(auto e:G[a]){\n                    int b=e.first;\n                    if(used[b]) U2.unite(a,b); \n                }\n                used[a]=true;\n                if(i+1<N&&H[i].first==H[i+1].first){\n                    i++;\n                }else{\n                    break;\n                }\n            }\n            bool connected = true;\n            for(int j=1;j<=i;j++){\n                if(!U2.same(H[0].second,H[j].second)){\n                    connected =false;\n                    break;\n                }\n            }\n            if(connected){\n                if(h==-1) h=i;\n            }else{\n                h=-1;\n            }\n        }\n\n        fill(used,used+200,false);\n        int ans=0;\n        while(!que.empty()) que.pop();\n        for(int i=0;i<N;i++){\n            while(true){\n                int a = H[i].second;\n                for(auto e:G[a]){\n                    int b = e.first;\n                    int c = e.second;\n                    if(used[b]){\n                        que.emplace(T(c,a,b));\n                    }\n                }\n                used[a]=true;\n                if(i+1<N&&H[i].first==H[i+1].first){\n                    i++;\n                }else{\n                    break;\n                }\n            }\n            if(i<h) continue;\n            while(!que.empty()){\n                int a,b,c;\n                tie(c,a,b) = que.top(); que.pop();\n                if(!U.same(a,b)){\n                    ans+=c;\n                    U.unite(a,b);\n                }\n            }\n        }\n        for(int i=1;i<N;i++){\n            if(!U.same(0,i)){\n                ans=0;\n                break;\n            }\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n \nint p[222];\nvoid init(int n){ for(int i = 0; i <= n; i++) p[i] = i; }\nint find(int x){ return p[x] = ( (p[x] == x)?x:find(p[x])); }\nvoid merge(int x,int y){ p[find(x)] = find(y); }\nbool same(int x,int y){ return find(x) == find(y); }\n \nbool used[222];\n \nint n,m;\nint h[222];\nvector<int> s[1111111];\nint a[44444],b[44444],c[44444];\npair<int,pair<int,int> > e[44444];\nint main(void){\n \n  while(cin >> n >> m && n){\n    int ans = 0;\n    init(n);\n    memset(used,false,sizeof(used));\n \n    for(int i = 0; i < 1111111; i++) s[i].clear();\n \n    for(int i = 0; i < n; i++){\n      cin >> h[i];\n      s[ h[i] ].push_back(i+1);\n    }\n \n    for(int i = 0; i < m; i++){\n      cin >> a[i] >> b[i] >> c[i];\n      e[i] = make_pair(c[i],make_pair(a[i],b[i]));\n    }\n    sort(e,e+m);\n     \n    int c = 0;\n    int f = -1;\n    for(int t = 1000000; t > 0; t--){\n      for(int i = 0; i < (int)s[t].size(); i++){\n    used[ s[t][i] ] = true;\n    f++;\n    c++;\nflag = true;\n      }\n      if(flag && f > 0){\n    for(int i = 0; i < m; i++){\n      bool flag = false;\n      int u = e[i].second.first, v = e[i].second.second;\n      //cout << u << \" \" << v << endl;\n      if(used[u] && used[v] && !same(u,v) ){\n        merge(u,v);\n        ans += e[i].first;\n        f--;\n      }\n    }\n    if(f > 0){\n      ans = 0;\n      init(n);\n      f = c-1;\n    }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvp ti(n+1,{1,-1});\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n){\n\t\t\tint a;cin>>a;\n\t\t\tti[i]={a*-1,i};\n\t\t}\n\t\tsort(all(ti));\n\t\tint t=0;\n\t\tUnionFind uf(n);\n\t\tvi used(n);\n\t\tvvi G(m,vi(3));\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tG[i]={a,b,c};\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\tint T=-1;\n\t\twhile(t!=n){\n\t\t\tused[ti[t].second]=true;\n\t\t\twhile(ti[t].second==ti[t+1].second){\n\t\t\t\tt++;\n\t\t\t\tused[ti[t].second]=true;\n\t\t\t}\n\t\t\trep(i,m)if(used[G[i][0]]&&used[G[i][1]])uf.unionSet(G[i][0],G[i][1]);\n\t\t\tt++;\n\t\t\tif(uf.size(ti[0].second)!=t)T=t;\n\t\t}\n\t\tif(uf.size(0)!=n){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tused=vi(n);\n\t\tint sum=0;\n\t\tvi d(n,inf);\n\t\td[ti[0].second]=0;\n\t\trep(j,n){\n\t\t\tint v;\n\t\t\tif(ti[T].first<ti[j].first)v=ti[j].second;\n\t\t\telse{\n\t\t\t\tv=-1;\n\t\t\t\trep(i,n)if(used[ti[i].second]==0&&ti[i].first<=ti[T].first&&(v==-1||d[v]>d[ti[i].second]))v=ti[i].second;\n\t\t\t}\n\t\t\tused[v]=true;\n\t\t\tsum+=d[v];\n\t\t\trep(i,n)d[i]=min(d[i],cost[v][i]);\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<bitset>\n#include<map>\n#include<set>\n\nusing namespace std;\n\ntypedef bitset<400> Board;\n\nint bh,bw;\nBoard bb;\n\nstruct P{\n  int h,w;\n  vector<vector<char> > g;\n  P(){\n    cin>>h>>w;\n    g=vector<vector<char> >(h,vector<char>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tchar c;\n\tcin>>c;\n\tg[i][j]=c=='#';\n      }\n    }\n  }\n  void rot(){\n    vector<vector<char> > n(w,vector<char>(h));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tn[j][h-1-i]=g[i][j];\n      }\n    }\n    g=n;\n    swap(h,w);\n  }\n  Board to_board()const{\n    Board b;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tb[i*20+j]=g[i][j];\n      }\n    }\n    return b;\n  }\n  vector<Board> to_boards(){\n    vector<Board> v;\n    for(int i=0;i<4;i++){\n      rot();\n      for(int j=-19;j<20;j++){\n\tfor(int k=-19;k<20;k++){\n\t  Board b;\n\t  for(int l=0;l<h;l++){\n\t    for(int m=0;m<w;m++){\n\t      if(g[l][m]){\n\t\tint y=l+j;\n\t\tint x=k+m;\n\t\tif(y<0||bh<=y||x<0||bw<=x||bb[y*20+x])goto next;\n\t\tb[y*20+x]=true;\n\t      }\n\t    }\n\t  }\n\t  v.push_back(b);\n\tnext:\n\t  ;\n\t}\n      }\n    }\n    return v;\n  } \n};\n\nvector<vector<Board> > pieces;\n\nBoard mem;\n\nvoid ff(int y,int x){\n  if(y<0||bh<=y||x<0||bw<=x||mem[y*20+x])return;\n  mem[y*20+x]=true;\n  for(int i=0;i<4;i++){\n    static int d[]={0,-1,0,1,0};\n    ff(y+d[i],x+d[i+1]);\n  }\n}\n\nint nc(const Board &b){\n  mem=b;\n  int c=0;\n  for(int i=0;i<bh;i++){\n    for(int j=0;j<bw;j++){\n      if(!mem[i*20+j]){\n\tc++;\n\tff(i,j);\n      }\n    }\n  }\n  return c;\n}\n\nbool rec(const Board &b,vector<int> r);\nbool rec2(const Board &b,vector<int> r);\n\nbool rec(const Board &b,vector<int> r){\n  //  if(nc(b)>r.size())return false;\n  if(r.empty())return true;\n  int x=r.back();\n  r.pop_back();\n  for(auto &e:pieces[x]){\n    if((b&e).none()){\n      if(rec2(b|e,r))return true;\n    }\n  }\n  return false;\n}\n\nbool rec2(const Board &b,vector<int> r){\n  //  if(nc(b)>r.size())return false;\n  if(r.empty())return true;\n  for(int i=0;i<bh;i++){\n    for(int j=0;j<bw;j++){\n      if(!b[i*20+j]){\n\tfor(int k=0;k<r.size();k++){\n\t  for(auto p:pieces[r[k]]){\n\t    if(p[i*20+j]&&(b&p).none()){\n\t      vector<int> nr=r;\n\t      nr.erase(begin(nr)+k);\n\t      if(rec(b|p,nr))return true;\n\t    }\n\t  }\n\t}\n\treturn false;\n      }\n    }\n  }\n}\n\nint main(){\n  for(;;){\n    P b;\n    bh=b.h;\n    bw=b.w;\n    bb=b.to_board();\n    if(b.h==0)break;\n    int n;\n    cin>>n;\n    pieces.clear();\n    pieces.resize(n);\n    vector<int> vnb(n);\n    for(int i=0;i<n;i++){\n      P cp;\n      pieces[i]=cp.to_boards();\n      vnb[i]=cp.to_board().count();\n    }\n    int p;\n    cin>>p;\n    map<set<int>,bool> m;\n    while(p--){\n      int k;\n      cin>>k;\n      int sp=0;\n      vector<int> cp;\n      int nb=bb.count();\n      while(k--){\n\tint t;\n\tcin>>t;\n\tsp|=1<<t-1;\n\tcp.push_back(t-1);\n\tnb+=vnb[t-1];\n      }\n      set<int> s(begin(cp),end(cp));\n      sort(begin(cp),end(cp),[&](int a,int b){\n\t  return pieces[a].size()>pieces[b].size();\n\t});\n      if(!m.count(s)){\n\tm[s]=nb==bh*bw&&rec(b.to_board(),cp);\n      }\n      cout<<(m[s]?\"YES\":\"NO\")<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\nprivate:\n\tstd::vector<int> value;\npublic:\n\tUnionFind(int size): value(size, -1){}\n\tint find(int x){\n\t\treturn value[x] < 0 ? x : value[x] = find(value[x]);\n\t}\n\tint size(int x){\n\t\treturn -value[find(x)];\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\tbool unite(int x, int y){\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\tif (value[x] > value[y]) std::swap(x, y);\n\t\tvalue[x] += value[y];\n\t\tvalue[y] = x;\n\t\treturn true;\n\t}\n};\n\nstruct Edge {\n\tint s, t, cost;\n\tEdge(){}\n\tEdge(int s, int t, int cost): s(s), t(t), cost(cost){}\n};\n\nint n, m;\nint h[200];\nvector<Edge> es;\n\nint calc()\n{\n\tvector<pair<int, int>> v;\n\tfor (int i = 0; i < n; i++){\n\t\tv.push_back(make_pair(-h[i], i));\n\t}\n\tsort(v.begin(), v.end());\n\tfor (int i = 0; i < n; i++) h[i] = v[i].second;\n\tsort(es.begin(), es.end(), [](const Edge &a, const Edge &b){\n\t\treturn a.cost < b.cost;\n\t});\n\t\n\tint sum = 0;\n\tUnionFind uf(n);\n\tbool f[200] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tf[h[i]] = true;\n\t\tfor (auto &e : es){\n\t\t\tif (f[e.s] && f[e.t] && uf.unite(e.s, e.t)){\n\t\t\t\tsum += e.cost;\n\t\t\t}\n\t\t}\n\t\tif (uf.size(h[0]) != i + 1){\n\t\t\tuf = UnionFind(n);\n\t\t\tsum = 0;\n\t\t}\n\t}\n\t\n\treturn sum;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tes.clear();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", h + i);\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tes.push_back(Edge(--a, --b, c));\n\t\t}\n\t\tprintf(\"%d\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>is[1000005];\nint h[205],a[100005],b[100005],c[100005];;\nvector<P1>edge[1000005];\nint par[205],ran[205];\nvoid init(){ for(int i=0;i<205;i++) par[i] = i,ran[i] = 0; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nint p[100005];\nbool cmp(const int &a,const int &b){\n\treturn c[a] < c[b];\n}\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n) return 0;\n\t\trep(i,1000005) is[i].clear();\n\t\trep(i,1000005) edge[i].clear();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> h[i];\n\t\t\tis[h[i]].pb(i);\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\t//int a,b,c;\n\t\t\tcin >> a[i] >> b[i] >> c[i]; p[i] = i;\n\t\t\tedge[h[a[i]]].pb(mp(c[i],mp(a[i],b[i])));\n\t\t\tedge[h[b[i]]].pb(mp(c[i],mp(b[i],a[i])));\n\t\t}\n\t\tsort(p+1,p+m+1,cmp);\n\t\trep(i,1000005){\n\t\t\tSORT(edge[i]);\n\t\t}\n\t\tinit();\n\t\tint cnt = 0,ret = 0,sum = 0;\n\t\tfor(int i=1000000;i>=1;i--){\n\t\t\tfor(int k=0;k<edge[i].size();k++){\n\t\t\t\tint x = edge[i][k].sc.fi;\n\t\t\t\tif(h[edge[i][k].sc.sc] >= i && !same(edge[i][k].sc.sc,x)){\n\t\t\t\t\tunite(edge[i][k].sc.sc,x);\n\t\t\t\t\tcnt++; ret += edge[i][k].fi;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += is[i].size();\n\t\t\tif(sum && cnt != sum-1){\n\t\t\t\tcnt = 0; ret = 0; init();\n\t\t\t\tif(i!=1){\n\t\t\t\t\tfor(int x=1;x<=m;x++){\n\t\t\t\t\t\tint k = p[x];\n\t\t\t\t\t\tif(h[a[k]] >= i-1 && h[b[k]] >= i-1 && !same(a[k],b[k])){\n\t\t\t\t\t\t\tunite(a[k],b[k]);cnt++;ret+=c[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n#define repn(i,s,n) for (int i=int(s); i < int(n); i++)\n#define rep(i,n) repn(i,0,n)\n#define repd(i,n) for (int i=int(n)-1; i >= 0; i--)\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\n\nstruct UnionFind {\n  vector<int> p; \n  UnionFind(int n) : p(n, -1) { };\n  void unite(int u, int v) {\n    if ((u = find(u)) == (v = find(v))) return;\n    if (p[u] > p[v]) swap(u, v);\n    p[u] += p[v]; p[v] = u;\n  }\n  bool same(int u, int v) { return find(u) == find(v); }\n  int find(int u) { return p[u] < 0 ? u : p[u] = find(p[u]); }\n  int size(int u) { return -p[find(u)]; }\n};\n\n\n\nint n, m;\nVI h;\nconst int MAX_H = 1000010;\n\nstruct Edge\n{\n  int a, b, cost;\n\n  int getSinkTime() const {\n    return min(h[a], h[b]);\n  }\n\n  bool operator<(const Edge& o) const {\n    int sinkTime = getSinkTime();\n    int oSinkTime = o.getSinkTime();\n    if (sinkTime != oSinkTime) return sinkTime > oSinkTime;  // 最後に沈むのを先に\n    return cost < o.cost;\n  }\n};\n\nvoid solve() {\n  vector<Edge> es;\n  h = VI(n);\n  VI numSunk(MAX_H);\n  rep(i, n) {\n    cin >> h[i];\n    numSunk[h[i]]++;\n  }\n  rep(i, MAX_H-1) numSunk[i+1] += numSunk[i];\n  rep(i, m) {\n    Edge e;\n    cin >> e.a >> e.b >> e.cost;\n    e.a--;\n    e.b--;\n    es.push_back(e);\n  }\n\n  // get count\n  sort(es.begin(), es.end());\n  UnionFind uf(n);\n  int count = 1;\n  int last_unconnected_h = MAX_H-1;\n  for (int ei = 0; ei < m; ) {\n    int sinkTime = es[ei].getSinkTime();\n    int numV = n - numSunk[sinkTime];\n    if (numV > count) last_unconnected_h = sinkTime;\n    while (ei < m && es[ei].getSinkTime() == sinkTime) {\n      Edge& e = es[ei++];\n      if (!uf.same(e.a, e.b)) {\n        count++;\n        uf.unite(e.a, e.b);\n      }\n    }\n  }\n  if (count < n) {\n    cout << 0 << endl;\n    return;\n  }\n  // cout << last_unconnected_h << endl;\n\n  // 非連結になる時間に全部同時に沈むようにする\n  rep(i, n) {\n    h[i] = min(h[i], last_unconnected_h);\n  }\n\n  sort(es.begin(), es.end());\n  uf = UnionFind(n);\n  int min_cost = 0;\n\n  rep(ei, es.size()) {\n    Edge& e = es[ei];\n    if (!uf.same(e.a, e.b)) {\n      min_cost += e.cost;\n      uf.unite(e.a, e.b);\n    }\n  }\n\n  cout << min_cost << endl;\n}\n\nint main() {\n  while (cin >> n >> m, n||m) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace EGraph{\n\ttypedef int Cost;Cost CINF=1<<28;\n\tstruct Edge{\n\t\tint from,to;Cost cost;;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost){};\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n}\nusing namespace EGraph;\n\n\nstruct UnionFind{\n    vector<int> par; // 親\n    vector<int> rank; // 木の深さ\n    vector<int> ss;//xの属する集合のサイズ\n    int size;//集合の個数\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){\n            par[x] = y;ss[y]+=ss[x];\n        }else{\n            par[y] = x;ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\n\nvector<int> hs;\n\nint col(const Edge &e){\n\treturn min(hs[e.from],hs[e.to]);\n}\n\t\nclass CompTDesc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)>col(r);\n\t}\n};\n\nclass CompTAsc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)<col(r);\n\t}\n};\n\nclass CompC{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn l.cost> r.cost;\n\t}\n};\n\n\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tGraph g;\n\tvector<Edge> es;\n\tbool input(istream &cin){\n\t\tcin >> N >> M;if(N==0 && M==0)return false;\n\t\ths=vector<int>(N);\n\t\tREP(i,N){\n\t\t\tcin >> hs[i];\n\t\t}\n\t\tg=Graph(N);\n\n\t\tes=vector<Edge>();\n\t\tREP(i,M){\n\t\t\tint a,b,c;cin >> a >> b >> c;a--;b--;\n\t\t\tes.push_back(Edge(a,b,c));\n\t\t\tes.push_back(Edge(b,a,c));\n\t\t}\n\t\treturn true;\n\t}\n\tint N,M;\n\tvoid run(){\n\t\tofstream cout(\"out\");\n\t\tifstream cin(\"in\");\n\n\t\twhile(input(cin)){\n\n\t\t\t\n\t\t\tvector<int> ts;REP(i,N)ts.push_back(hs[i]);\n\t\t\tts.push_back(0);\n\t\t\tsort(ALL(ts),greater<int>());\n\n\t\t\tsort(ALL(es),CompTDesc());\n\t\t\tUnionFind uf(N);\n\n\t\t\tint endT=-INF;\n\t\t\t{\n\t\t\t\tint i=0;\n\t\t\t\tREP(ti,ts.size()){\n\t\t\t\t\twhile(i<es.size() && ts[ti]<=col(es[i])){\n\t\t\t\t\t\tuf.unite(es[i].from,es[i].to);i++;\n\t\t\t\t\t}\n\t\t\t\t\t//check\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tREP(j,N)REP(k,N)if(ts[ti]<=hs[j] && ts[ti]<=hs[k] &&  !uf.same(j,k)){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ok && endT==-INF){\n\t\t\t\t\t\tendT=ts[ti];\n\t\t\t\t\t}else if(!ok){\n\t\t\t\t\t\tendT=-INF;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tif(endT==-INF){\n\t\t\t\tcout << 0 <<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tCost res=0;\n\t\t\tUnionFind ufc(N);\n\t\t\tpriority_queue<Edge,vector<Edge>,CompC> que;\n\t\t\t\n\t\t\tint T=endT;\n\t\t\t//end\n\t\t\tint i=0;\n\t\t\tfor(;i<es.size();i++){\n\t\t\t\tif(T<=col(es[i]))que.push(es[i]);\n\t\t\t\telse break;\n\t\t\t}\n\t\t\t//cruskal\n\t\t\twhile(!que.empty()){\n\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\tres+=e.cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//reflesh\n\t\t\tfor(;i<es.size();i++){\n\t\t\t\tT=col(es[i]);\n\t\t\t\tque.push(es[i]);\n\t\t\t\ti++;\n\t\t\t\twhile(i<es.size() && T==col(es[i])){\n\t\t\t\t\tque.push(es[i]);i++;\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t\t//cruskal\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\t\tres+=e.cost;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tcout <<res<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\ntypedef long long int i64;\ntypedef pair<int, int> pint;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int N) : data(N, -1) {}\n    void init() {\n        size_t n = data.size();\n        data.assign(n, -1);\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]);}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\n\nstruct Edge {\n    int from, to, cost;\n    Edge(int f, int t, int c)\n         :from(f), to(t), cost(c) {}\n    bool operator< (const Edge& E) const {\n        return cost < E.cost;\n    }\n};\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int N, M;\n    while(cin >> N >> M && N) {\n        vector<pint> h(N);\n        rep(i, N) {\n            cin >> h[i].first;\n            h[i].second = i;\n        }\n        sort(h.begin(), h.end(), greater<pint>());\n        vector<vector<int>> mat(N, vector<int>(N, 0));\n        int a, b, c;\n        rep(i, M) {\n            cin >> a >> b >> c;\n            --a; --b;\n            mat[a][b] = mat[b][a] = c;\n        }\n        UnionFind uf(N);\n        int ans = 0;\n        bool is_spt = false;\n        vector<int> notsink;\n        set<Edge> edges;\n        rep(i, N) {\n            int i2 = i;\n            for(; i2 < N && h[i].first == h[i2].first; ++i2);\n            set<Edge> bridge;\n            REP(j, i, i2) notsink.push_back(h[j].second);\n            REP(j, i, i2) {\n                for(int k : notsink) if(mat[h[j].second][k]) {\n                    bridge.insert(Edge(h[j].second, k, mat[h[j].second][k]));\n                    edges.insert(Edge(h[j].second, k, mat[h[j].second][k]));\n                }\n            }\n            if(is_spt) {\n                for(const auto& e : bridge)\n                  if(!uf.same(e.from, e.to)) {\n                      uf.unite(e.from, e.to);\n                      ans += e.cost;\n                  }\n            }else {\n                uf.init(); ans = 0;\n                for(const auto& e: edges) {\n                    if(!uf.same(e.to, e.from)) {\n                        uf.unite(e.from, e.to);\n                        ans += e.cost;\n                    }\n                }\n            }\n            set<int> roots;\n            for(int k : notsink) roots.insert(uf.root(k));\n            if(roots.size() == 1) is_spt = true; else is_spt = false;\n            i = i2 - 1;\n        }\n        if(is_spt) cout << ans << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) begin(V), end(V)\n#define ALLR(V) rbegin(V), rend(V)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nstruct UnionFind {\n    V<ll> rank, par;\n\n    UnionFind(ll N) : rank(N, 1), par(N) {\n        iota(ALL(par), 0ll);\n    }\n\n    ll find(ll x) {\n        return par[x] == x ? x : par[x] = find(par[x]);\n    }\n\n    bool unit(ll x, ll y) {\n        ll px = find(x), py = find(y);\n        if (px == py) return false;\n        if (rank[px] < rank[py]) swap(px, py);\n        rank[px] += (rank[px] == rank[py]);\n        par[py] = par[px];\n        return true;\n    }\n\n    bool is_same(ll x, ll y) {\n        return find(x) == find(y);\n    }\n};\n\nV<ll> make_sh(V<ll> H) {\n    sort(ALL(H));\n    auto ite = unique(ALL(H));\n    H.erase(ite, H.end());\n    return H;\n}\n\nconst ll inf = 5e15;\n\nbool solve() {\n    ll N, M;\n    cin >> N >> M;\n    if (!(N + M)) return false;\n    V<ll> H(N);\n    V<TLL> edges(M);\n    for (auto &&e : H) cin >> e;\n    for (auto &&e : edges) {\n        ll a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        e = TLL(a, b, c);\n    }\n\n    auto SH = make_sh(H);\n    SH.insert(SH.begin(), 0);\n\n    ll maxh = -1;\n    for (ll bh : SH) {\n        ll cnt = 0;\n        for (ll h : H) cnt += (bh <= h);\n        UnionFind uf(N);\n        ll united = 0;\n        for (auto &&e : edges) {\n            ll a, b;\n            tie(a, b, ignore) = e;\n            if (min(H[a], H[b]) < bh) continue;\n            if (uf.unit(a, b)) united++;\n        }\n        if (united < cnt - 1) break;\n        maxh = bh;\n    }\n\n    if (maxh == -1) {\n        cout << 0 << endl;\n        return true;\n    }\n\n    /*\n    {\n        auto tmp = move(edges);\n        edges.clear();\n        for (auto &&e : tmp) {\n            ll a, b, c;\n            tie(a, b, c) = e;\n            if (maxh < max(H[a], H[b])) continue;\n            edges.emplace_back(a, b, c);\n        }\n    }\n    */\n\n    sort(ALL(edges), [&](const TLL &p, const TLL &q) {\n        ll a, b, c, d, e, f;\n        tie(a, b, c) = p;\n        tie(d, e, f) = q;\n        ll hp = var_min(H[a], H[b], maxh);\n        ll hq = var_min(H[d], H[e], maxh);\n        if (hp != hq) return hp > hq;\n        else return c < f;\n    });\n    \n    DEBUG(make_tuple(edges, maxh));\n    ll ans = 0;\n    UnionFind uf(N);\n    for (auto &&e : edges) {\n        ll a, b, c;\n        tie(a, b, c) = e;\n        if (uf.unit(a, b)) ans += c;\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2511&lang=jp\n// references : http://mayokoex.hatenablog.com/entry/2016/05/03/233156\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n#define MAXT 1000100\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n\tedge() {}\n\tedge(int f, int t, int c) :from(f), to(t), cost(c) {}\n\tbool operator < (const edge& o) const { return cost < o.cost; }\n};\n\nstruct UnionFind {\n\tvector<int> par;\n\tint n, cnt;\n\tUnionFind(const int& x = 0) { init(x); }\n\tvoid init(const int& x) { par.assign(cnt = n = x, -1); }\n\tinline int find(const int& x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tinline bool same(const int& x, const int& y) { return find(x) == find(y); }\n\tinline bool unite(int x, int y) {\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\t--cnt;\n\t\tif (par[x] > par[y]) swap(x, y);\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\tinline int count() const { return cnt; }\n\tinline int count(int x) { return -par[find(x)]; }\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M;\n\twhile (cin >> N >> M, N | M) {\n\t\tmap<int, vector<int>> h;\n\t\tfor (int i = 0; i < N; i++) { int t; cin >> t; h[t].push_back(i); }\n\t\tvector<edge> G;\n\t\tfor (int i = 0; i < M;i++) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tG.push_back(edge(a, b, c));\n\t\t}\n\t\tsort(G.begin(), G.end());\n\t\tUnionFind uf(N);\n\t\tfor (auto e : G) { uf.unite(e.from, e.to); }\n\t\tif (uf.count() > 1) { cout << 0 << endl; continue; }\n\n\t\tvector<int> f(N, 0);\n\t\tint cnt = 1;\n\t\tint last_t = -1;\n\t\tfor (int t = 0; t < MAXT;t++) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) { f[n] = 1; cnt++; }\n\t\t\tUnionFind uf(N);\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (f[e.from] == 1 || f[e.to] == 1)continue;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\t\t\tif (uf.count() != cnt) { last_t = t; break; }\n\t\t}\n\t\tif (last_t == -1)last_t = MAXT;\n\n\t\tfill(f.begin(), f.end(), 0);\n\t\tll ans = 0;\n\t\tfor (int t = last_t; t < MAXT;t++)for (auto n : h[t]) f[n] = 1;\n\t\t/* Minimum spanning tree */\n\t\tfor (auto e : G) {\n\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t}\n\t\t/*----------------------*/\n\n\t\tfor (int t = last_t - 1; t >= 0;t--) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) f[n] = 1;\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<Int, P> T;\n\nInt u[1080];\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(Int x, Int y){\n\tu[r(x)] = r(y);\n}\nvector<T> edge[1080000];\nInt h[1080];\nbool ok[1080];\nint main(){\n\tInt n, m;\n\twhile(cin >> n >> m, n | m){\n\t\tInt res = 0, bridge = 0, a, b, c, cnt = 0;\n\t\tfor(Int i = 0;i < n;i++)cin >> h[i], u[i] = i;\n\t\tfor(Int i = 0;i < m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tedge[min(h[a], h[b])].push_back(T(c, P(a, b)));\n\t\t\tif(h[a] == h[b])unite(a, b);\n\t\t}\n\t\tfor(Int i = 0;i <=1000000;i++){\n\t\t\tfor(int j = 0;j < edge[i].size();j++){\n\t\t\t\ta = edge[i][j].second.first, b = edge[i][j].second.second;\n\t\t\t\tif(h[a] == h[b])continue;\n\t\t\t\tif(h[a] > h[b])ok[r(b)] = true;\n\t\t\t}\n\t\t}\n\t\tInt breakpoInt = 1000010;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(!ok[r(i)]){\n\t\t\t\tbreakpoInt = min(breakpoInt, h[i]);\n\t\t\t}\n\t\t}\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t}                    \n\t\tbridge = 0;\n\t\tvector<T> tmp;\n\t\tfor(Int i = 0;i < n;i++)u[i] = i;\n\t\tif(breakpoInt)breakpoInt--;\n\t\tfor(Int i = 1000000;i >= breakpoInt;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\ttmp.push_back(edge[i][j]);\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor(Int i = 0;i < tmp.size();i++){\n\t\t\tInt from = tmp[i].second.first, to = tmp[i].second.second;\n\t\t\tif(r(from) != r(to)){\n\t\t\t\tbridge++;\n\t\t\t\tres += tmp[i].first;\n\t\t\t\tunite(from, to);\n\t\t\t}\n\t\t}                          \n\t\tfor(Int i = breakpoInt;i > 0;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tres += edge[i][j].first;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tif(bridge + 1 != n)res = 0;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\n/***** Union-Find *****/\n\nconst int MAX_N = 10000;\nint Par[MAX_N];\nint Rank[MAX_N];\n\nvoid union_find_init(int n){\n\tfor(int i=0; i<n; ++i){\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(Par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)\n\t\treturn ;\n\n\tif(Rank[x] < Rank[y]){\n\t\tPar[x] = y;\n\t} else{\n\t\tPar[y] = x;\n\t\tif(Rank[x] == Rank[y]){\n\t\t\t++Rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\n/***** /Union-Find *****/\n\nstruct edge {\n\tint from,\n\t\tto,\n\t\tcost;\n    bool operator < (const edge &e) const { return cost < e.cost; }\n};\n\nvector<edge> es;\nint V, E;\n\n// time, vs\nvector<pair<int, VI>> falls;\n\nVB falled;\nVB linked;\n\n// ????????????????????¶????????????????????£????????????\nbool all_unite() {\n    int v = -1;\n    REP(i, 0, V) {\n        if (falled[i]) continue;\n\n        if (v == -1) {\n            v = i;\n        } else {\n            if (!same(v, i)) return false;\n        }\n    }\n    return true;\n}\n\n// ??¨??????????????£????????£????????¨?????????\nvoid link_new_edge() {\n    rep(i, E) {\n        edge &e = es[i];\n        if (linked[i]) continue;\n        if (falled[e.from] || falled[e.to]) continue;\n        if (!same(e.from, e.to)){\n            unite(e.from, e.to);\n            linked[i] = true;\n        }\n    }\n}\n\n// ??¨??????????????????\nvoid link_edge() {\n    rep(i, E) {\n        edge &e = es[i];\n        if (falled[e.from] || falled[e.to]) continue;\n        unite(e.from, e.to);\n    }\n}\n\n// ????¨??????????????±???????\nint sum_cost() {\n    int cost = 0;\n    rep(i, E) {\n        if (linked[i]) {\n            cost += es[i].cost;\n        }\n    }\n    return cost;\n}\n\nint solve() {\n    falled = VB(V);\n\n    sort(ALL(es));\n    sort(ALL(falls));\n\n    // ?????????????°???????????±???????\n    int end_i = 0;\n    for (; end_i < (int)falls.size(); end_i++) {\n        // ?????????\n        for (auto v : falls[end_i].snd) { falled[v] = true; }\n\n        union_find_init(V);\n        link_edge();\n\n        if (!all_unite()) { break; }\n    }\n\n    // ??¨?????¨?????§?????????\n    if (end_i == 0) return 0;\n\n    // ??´?????§????????????????????????\n    if (end_i != (int)falls.size()) {\n        for (auto v : falls[end_i].snd) { falled[v] = false; }\n    }\n\n    // ????????????????????????\n    linked = VB(E);\n    union_find_init(V);\n    for (int i = end_i - 1; i >= 0; i--) {\n        // ??????\n        for (auto v : falls[i].snd) { falled[v] = false; }\n\n        link_new_edge();\n    }\n    \n    return sum_cost();\n}\n\nint main(void) {\n    while (cin >> V >> E, V) {\n        // ??\\???\n        falls.clear();\n        falls.EB(0, VI());\n        rep(i, V) {\n            int h;\n            cin >> h;\n\n            auto it = find_if(ALL(falls), [h](const pair<int, VI> &x) {\n                    return h == x.fst; });\n            if (it == falls.end()) {\n                falls.EB(h, VI({i}));\n            } else {\n                falls[it - falls.begin()].snd.PB(i);\n            }\n        }\n\n        es.clear(); es.resize(E);\n        rep(i, E) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            --a; --b;\n            es[i].to = a;\n            es[i].from = b;\n            es[i].cost = c;\n        }\n        // ??\\??????????????§\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstruct Edge{\n  int from, to, cost;\n\n  Edge(int f, int t, int c): from(f), to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\ntypedef vector< vector<Edge> > Graph;\nvoid add_edge(Graph& graph, int u, int v, int cost){\n  graph[u].push_back(Edge(u,v,cost));\n  graph[v].push_back(Edge(v,u,cost));\n}\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nint kruskal(const Graph& G){\n  int N = SZ(G);\n  UnionFind uf(N);\n  vector<pair<Edge,int>> edges;\n  REP(i,N) for(auto& e:G[i]){\n\tedges.push_back(MP(e, i));\n  }\n  sort(ALL(edges));\n\n  int res = 0, i, n;\n  for(i=0,n=1;n<N&&i<SZ(edges);++i){\n\tauto& e = edges[i].first;\n\tint v = edges[i].second;\n\tif(!uf.same(e.to,v)){\n\t  uf.unite(e.to, v);\n\t  res += e.cost;\n\t  ++n;\n\t}\n  }\n  return (n==N? res: -1);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E;\n  while(cin>>V>>E,V){\n\tvector<PII> days(V);\n\tREP(i,V){\n\t  cin >> days[i].FF;\n\t  days[i].SS = i;\n\t}\n\tSORT(days);\n\tGraph G(V);\n\tREP(i,E){\n\t  int a, b, c; cin >> a >> b >> c;\n\t  --a, --b;\n\t  add_edge(G, a, b, c);\n\t}\n\n\tUnionFind uf(V);\n\tvector<bool> use(V);\n\tpriority_queue<Edge,vector<Edge>,greater<Edge>> pq;\n\tint ans = 0;\n\tfor(int i=V-1;i>=0;){\n\t  int j;\n\t  VI buf;\n\t  for(j=i;j>=0;--j)\n\t\tif(days[j].FF == days[i].FF){\n\t\t  buf.PB(days[j].SS);\n\t\t  use[days[j].SS] = true;\n\t\t}\n\t\telse break;\n\t  i = j;\n\n\t  for(int u: buf){\n\t\tfor(auto& e: G[u]){\n\t\t  if(use[e.to])\n\t\t\tpq.push(e);\n\t\t}\n\t  }\n\n\t  auto uf_ = uf;\n\t  auto pq_ = pq;\n\t  int sum = 0;\n\t  while(!pq_.empty()){\n\t\tauto e = pq_.top(); pq_.pop();\n\t\tif(uf_.same(e.from, e.to)) continue;\n\t\telse{\n\t\t  sum += e.cost;\n\t\t  uf_.unite(e.from, e.to);\n\t\t}\n\t  }\n\n\t  int id = uf_.find(buf[0]);\n\t  bool ok = true;\n\t  REP(j,V)\n\t\tif(use[j] && uf_.find(j) != id){\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t  if(ok){\n\t\tuf = uf_;\n\t\tpq = pq_;\n\t\tans += sum;\n\t  }\n\t  else{\n\t\tans = 0;\n\t\tuf = UnionFind(V);\n\t\tpq = pq_;\n\t\tREP(u,V)\n\t\t  if(use[u])\n\t\t\tfor(auto& e: G[u])\n\t\t\t  if(use[e.to])\n\t\t\t\tpq.push(e);\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\nprivate:\n\tstd::vector<int> value;\npublic:\n\tUnionFind(int size): value(size, -1){}\n\tint find(int x){\n\t\treturn value[x] < 0 ? x : value[x] = find(value[x]);\n\t}\n\tint size(int x){\n\t\treturn -value[find(x)];\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\tbool unite(int x, int y){\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\tif (value[x] > value[y]) std::swap(x, y);\n\t\tvalue[x] += value[y];\n\t\tvalue[y] = x;\n\t\treturn true;\n\t}\n};\n\nstruct Edge {\n\tint s, t, cost;\n\tEdge(){}\n\tEdge(int s, int t, int cost): s(s), t(t), cost(cost){}\n};\n\nint n, m;\nint h[201];\nvector<Edge> es;\n\nlong long calc()\n{\n\tvector<pair<int, int>> v;\n\tfor (int i = 0; i < n; i++){\n\t\tv.push_back(make_pair(-h[i], i));\n\t}\n\tsort(v.begin(), v.end());\n\tsort(es.begin(), es.end(), [](const Edge &a, const Edge &b){\n\t\treturn a.cost < b.cost;\n\t});\n\t\n\tlong long sum = 0;\n\tUnionFind uf(n);\n\tbool f[200] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tf[v[i].second] = true;\n\t\tif (i + 1 < n && h[v[i].second] == h[v[i + 1].second]) continue;\n\t\tfor (auto &e : es){\n\t\t\tif (f[e.s] && f[e.t] && uf.unite(e.s, e.t)){\n\t\t\t\tsum += e.cost;\n\t\t\t}\n\t\t}\n\t\tif (uf.size(v[0].second) != i + 1){\n\t\t\tuf = UnionFind(n);\n\t\t\tsum = 0;\n\t\t}\n\t}\n\t\n\treturn sum;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tes.clear();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", h + i);\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tes.push_back(Edge(--a, --b, c));\n\t\t}\n\t\tprintf(\"%lld\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef pair< int, int > pii;\n\nclass UnionFind {\nprivate:\n\tvector< int > data;\n\tint g_cnt;\n\t\npublic:\n\tUnionFind(int n) : data(n, -1), g_cnt(n) {}\n\t\n\tbool unionSet(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\t\n\t\tif (x == y) return 0;\n\t\t\n\t\tif (data[y] < data[x]) swap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\t--g_cnt;\n\t\t\n\t\treturn 1;\n\t}\n\t\n\tbool sameSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\t\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\t\n\tint getGroupNum() {\n\t\treturn g_cnt;\n\t}\n};\n\nstruct Edge {\n\tint u, v, c;\n\tEdge(int _u, int _v, int _c) : u(_u), v(_v), c(_c) {}\n\tbool operator < (const Edge& e) const {\n\t\treturn c < e.c;\n\t}\n};\n\nint N, M;\nvector< pii > vh;\nbool vis[222];\nvector< Edge > edges;\n\nvoid solve() {\n\tsort(vh.begin(), vh.end(), greater< pii >());\n\tsort(edges.begin(), edges.end());\n\t\n\tint ans = 0, visc = 0;\n\tUnionFind uf(N);\n\t\n\tfor_(i,0,N) {\n\t\tvis[vh[i].second] = 1;\n\t\t++visc;\n\t\t\n\t\twhile (i < N-1 && vh[i].first == vh[i+1].first) {\n\t\t\t++i;\n\t\t\tvis[vh[i].second] = 1;\n\t\t\t++visc;\n\t\t}\n\t\t\n\t\tfor_(j,0,M) {\n\t\t\tEdge e = edges[j];\n\t\t\t\n\t\t\tif (vis[e.u] && vis[e.v] && !uf.sameSet(e.u, e.v)) {\n\t\t\t\tuf.unionSet(e.u, e.v);\n\t\t\t\tans += e.c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint g_cnt = uf.getGroupNum();\n\t\t\n\t\tif (g_cnt != N - visc + 1) {\n\t\t\tuf = UnionFind(N);\n\t\t\tans = 0;\n\t\t}\n\t\t\n\t\tif (g_cnt == 1) break;\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> M, N) {\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvh.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tint h; cin >> h;\n\t\t\tvh.push_back(pii(h, i));\n\t\t}\n\t\t\n\t\tedges.clear();\n\t\tfor_(i,0,M) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\t--a; --b;\n\t\t\tedges.push_back(Edge(a, b, c));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n  int x, hour;\n  node(){}\n  node(int x, int hour):x(x), hour(hour){}\n  bool operator < (const node& u) const {\n    return hour < u.hour;\n  }\n};\n\nstruct edge{\n  int u, v, cost;\n  edge(){}\n  edge(int u, int v, int cost):u(u), v(v), cost(cost){}\n  bool operator < (const edge& e) const {\n    return cost < e.cost;\n  }\n};\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n  int find(int k)\n  {\n    if(data[k] < 0) return k;\n    return data[k] = find(data[k]);\n  }\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y){\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n  int size(int k)\n  {\n    return -data[find(k)];\n  }\n};\n\nint main()\n{\n  int N, M;\n  while(cin >> N >> M, N || M){\n    vector<node> V;\n    vector<edge> E;\n    for(int i = 0; i < N; i++){\n      int h; cin >> h;\n      V.push_back(node(i, h));\n    }\n    for(int i = 0; i < M; i++){\n      int a, b, c; cin >> a >> b >> c; a--, b--;\n      E.push_back(edge(a, b, c));\n    }\n    sort(V.rbegin(), V.rend());\n    sort(E.begin(), E.end());\n    vector<bool> exist(N, true);\n    int dis = N;\n    for(int i = N-1; i >= 1; i--){\n      if(V[i].hour != V[i-1].hour){\n\tUnionFind msp(N);\n\tfor(int j = 0; j < M; j++){\n\t  if(exist[E[j].u] && exist[E[j].v] && !msp.same(E[j].u, E[j].v)){\n\t    msp.unite(E[j].u, E[j].v);\n\t  }\n\t}\n\tif(msp.size(V[0].x) == i+1) dis = i;\n\telse break;\n      }\n      exist[V[i].x] = false;\n    }\n    UnionFind uf(N);\n    long long ans = 0LL;\n    for(int i = dis; i < N; i++){ \n      exist[V[i].x] = true;\n      if(i < N-1 && V[i].hour == V[i+1].hour) continue;\n      for(int j = 0; j < M; j++){\n\tif(exist[E[j].u] && exist[E[j].v] && !uf.same(E[j].u, E[j].v)){\n\t  uf.unite(E[j].u, E[j].v);\n\t  ans += E[j].cost;\n\t}\n      }\n    }\t\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> node;\n    int size_;\n    UnionFind (int n) : node(n, -1), size_(n) {}\n    int find(int k) { return node[k] < 0 ? k : find(node[k]); }\n    bool same(int u, int v) { return find(u) == find(v); }\n    bool unite(int u, int v) {\n        if(same(u, v)) return false;\n        u = find(u), v = find(v);\n        size_--;\n        node[u] += node[v];\n        node[v] = u;\n        return true;\n    }\n    size_t size() { return size_; }\n    void reset() {\n        size_ = node.size();\n        fill(node.begin(), node.end(), -1);\n    }\n};\n\nconst int INF = 1 << 28;\nint solve_testcase() {\n    int N, M; cin >> N >> M;\n    if(N == 0 and M == 0) return 1;\n    \n    vector< pair<int, int> > sink;\n    for(int i=0; i<N; i++) {\n        int h; cin >> h;\n        sink.emplace_back(h, i);\n    }\n    sink.emplace_back(-INF, -1);\n\n    sort(sink.rbegin(), sink.rend());\n    vector< vector<int> > edges(N, vector<int>(N, INF));\n    for(int i=0; i<M; i++) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        edges[a][b] = c;\n        edges[b][a] = c;\n    }\n\n    UnionFind uf(N);\n    vector<int> alive(N);\n    int i = 0, ans = 0, cnt = 0;\n    for(; i<N; i++) {\n        int h = sink[i].first;\n        vector<int> is;\n        is.emplace_back(sink[i].second);\n        while(i < N and sink[i].first == sink[i+1].first) {\n            is.emplace_back(sink[++i].second);\n        }\n\n        for(auto k : is) alive[k] = true, cnt++;\n        vector< tuple<int, int, int> > cand;\n        for(int k=0; k<N; k++) {\n            for(int j=k+1; j<N; j++) {\n                if(edges[j][k] == INF or !alive[j] or !alive[k]) continue;\n                cand.emplace_back(edges[j][k], j, k);\n            }\n        }\n\n        int tmp = 0;\n        UnionFind uf_(uf);\n\n        sort(cand.begin(), cand.end());\n        for(auto e : cand) {\n            int c, u, v; tie(c, u, v) = e;\n            if(uf_.same(u, v)) continue;\n            // fprintf(stderr, \"tmp edge (h = %d): (u, v) = (%d, %d), cost = %d\\n\", h, u, v, c);\n            uf_.unite(u, v);\n            tmp += c;\n        }\n\n        if(uf_.size() == (N - cnt) + 1) {\n            for(auto e : cand) {\n                int c, u, v; tie(c, u, v) = e;\n                if(uf.same(u, v)) continue;\n                // fprintf(stderr, \"edge (h = %d): (u, v) = (%d, %d), cost = %d\\n\", h, u, v, c);\n                uf.unite(u, v);\n                ans += c;\n            }\n\n            /*\n            uf = uf_;\n            ans += tmp;\n            */\n        }\n        else {\n            uf.reset();\n            ans = 0;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int to,cost;};\nstruct edge2{int from,to,cost;};\nint N,M,h[200];\nvector<edge> G[200];\nvector<int> ash,vc[200];\nint ord[200];\nvector<edge2> es;\nbool operator<(const edge2& a,const edge2& b){\n\treturn a.cost<b.cost;\n}\nint par[200];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\treturn par[x]=find(par[x]);\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tpar[x]=y;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\trep(i,N) vc[i].clear();\n\t\tash.clear();\n\t\trep(i,N) G[i].clear();\n\t\trep(i,N) cin>>h[i];\n\t\trep(i,N) ash.pb(h[i]);\n\t\tsort(all(ash));\n\t\tash.erase(unique(all(ash)),ash.end());\n\t\trep(i,N){\n\t\t\tord[i]=ash.end()-lower_bound(all(ash),h[i])-1;\n\t\t\tvc[ord[i]].pb(i);\n\t\t}\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--,b--;\n\t\t\tG[a].pb(edge{b,c});\n\t\t\tG[b].pb(edge{a,c});\n\t\t}\n\t\tint k=ash.size();\n\t\tinit(N);\n\t\tint last=-1;\n\t\trep(i,k){\n\t\t\tfor(int v:vc[i]){\n\t\t\t\tfor(edge e:G[v]){\n\t\t\t\t\tint u=e.to;\n\t\t\t\t\tif(ord[u]<=i) unite(u,v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x=-1;\n\t\t\tbool con=true;\n\t\t\trep(j,N){\n\t\t\t\tif(ord[j]<=i){\n\t\t\t\t\tif(x==-1){\n\t\t\t\t\t\tx=find(j);\n\t\t\t\t\t}else if(x!=find(j)){\n\t\t\t\t\t\tcon=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!con) last=i;\n\t\t}\n\t\tlong long ans=0;\n\t\tbool first=true;\n\t\tinit(N);\n\t\tfor(int i=last+1;i<k;i++){\n\t\t\tif(first){\n\t\t\t\tfirst=false;\n\t\t\t\tes.clear();\n\t\t\t\trep(j,N){\n\t\t\t\t\tif(ord[j]>i) continue;\n\t\t\t\t\tfor(edge e:G[j]){\n\t\t\t\t\t\tif(ord[e.to]>i) continue;\n\t\t\t\t\t\tedge2 e2=edge2{j,e.to,e.cost};\n\t\t\t\t\t\tes.pb(e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(all(es));\n\t\t\t\tfor(edge2 e:es){\n\t\t\t\t\tint x=e.from,y=e.to,c=e.cost;\n\t\t\t\t\tif(!same(x,y)){\n\t\t\t\t\t\tunite(x,y);\n\t\t\t\t\t\tans+=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tes.clear();\n\t\t\t\trep(j,N){\n\t\t\t\t\tif(ord[j]!=i) continue;\n\t\t\t\t\tfor(edge e:G[j]){\n\t\t\t\t\t\tif(ord[e.to]>i) continue;\n\t\t\t\t\t\tedge2 e2=edge2{j,e.to,e.cost};\n\t\t\t\t\t\tes.pb(e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(all(es));\n\t\t\t\tfor(edge2 e:es){\n\t\t\t\t\tint x=e.from,y=e.to,c=e.cost;\n\t\t\t\t\tif(!same(x,y)){\n\t\t\t\t\t\tunite(x,y);\n\t\t\t\t\t\tans+=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass UnionFind {\nprivate:\n\tvector<int> parent;\n\npublic:\n\tUnionFind(int n) : parent(n) {\n\t\tfor (int i = 0; i < n; ++i) parent[i] = i;\n\t}\n\tvoid unite(int a, int b) {\n\t\tparent[root(a)] = root(b);\n\t}\n\tint root(int n) {\n\t\tif (parent[n] == n) return n;\n\t\treturn parent[n] = root(parent[n]);\n\t}\n\tbool isUnited(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n};\n\nstruct Edge {\n\tint from, to, cost;\n};\nbool operator<(const Edge& e1, const Edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nint main() {\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tmap<int, vector<int> > m;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d; cin >> d;\n\t\t\tm[-d].push_back(i);\n\t\t}\n\t\tvector<Edge> edges;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint from, to, cost; cin >> from >> to >> cost; --from, --to;\n\t\t\tedges.push_back((Edge){from, to, cost});\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\n\t\tint ans = 0;\n\t\tUnionFind uf(N);\n\t\tvector<bool> isAlive(N, false);\n\t\tfor (map<int, vector<int> >::iterator it = m.begin(); it != m.end(); ++it) {\n\t\t\tvector<int>& ids = it->second;\n\t\t\tfor (int i = 0; i < ids.size(); ++i) {\n\t\t\t\tisAlive[ids[i]] = true;\n\t\t\t}\n\t\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\t\tEdge& e = edges[i];\n\t\t\t\tif (isAlive[e.from] && isAlive[e.to] && !uf.isUnited(e.from, e.to)) {\n\t\t\t\t\tans += e.cost;\n\t\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f = true;\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (isAlive[i]) {\n\t\t\t\t\tid = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (isAlive[i] && !uf.isUnited(i, id)) {\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) {\n\t\t\t\tuf = UnionFind(N);\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Edge{\npublic:\n    int from, to, cost;\n    Edge(int from, int to, int cost) : from(from), to(to), cost(cost){};\n    \n    bool operator < (const Edge& right)const{\n        return cost < right.cost;\n    }\n};\n\nclass UnionFind {\n    vector<int> par;\n    int cnt;\npublic:\n    UnionFind(int size_) : par(size_, -1), cnt(size_) { }\n    void unite(int x, int y){\n        if ((x = find(x)) != (y = find(y))) {\n            if (par[y] < par[x]) swap(x, y);\n            par[x] += par[y]; par[y] = x; cnt--;\n        }\n    }\n    bool same(int x, int y){ return find(x) == find(y); }\n    int find(int x){ return par[x] < 0 ? x : par[x] = find(par[x]); }\n    int size(int x){ return -par[find(x)]; }\n    int size(){ return cnt; }\n};\n\nint N, M;\n\nvoid solve(){\n    vector<pair<int, int>> islands;\n    for(int i=0; i<N; i++){\n        int h; cin >> h;\n        islands.push_back(make_pair(-h, i));\n    }\n    sort(islands.begin(), islands.end());\n    \n    vector<Edge> edges;\n    for(int i=0; i<M; i++){\n        int a, b, c;\n        cin >> a >> b >> c; a--; b--;\n        edges.push_back({a, b, c});\n    }\n    sort(edges.begin(), edges.end());\n    \n    int ans = 0;\n    UnionFind uf(N);\n    set<int> exists;\n    int p = 0;\n    while(p < N){\n        int cost = 0;\n        int h = islands[p].first;\n        while(p < N && islands[p].first == h){\n            exists.insert(islands[p].second);\n            p++;\n        }\n        for(auto edge: edges){\n            if(exists.count(edge.from) && exists.count(edge.to) && !uf.same(edge.from, edge.to)){\n                uf.unite(edge.from, edge.to);\n                cost += edge.cost;\n            }\n        }\n        if(uf.size() != N-exists.size()+1){\n            ans = 0;\n            uf = UnionFind(N);\n        }else{\n            ans += cost;\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin >> N >> M, N|M){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x7fffffff\n\nint n;\nint m;\nint limh;\nint as[11451419];\nint bs[11451419];\nint cs[11451419];\nint hs[11451419];\nint es[11451419];\n\nclass UnionFind {\npublic:\n  int size;\n  vector<int> par;\n  vector<int> height;\n\n  UnionFind(int n) {\n    par.resize(n);\n    height.resize(n);\n    for (int i=0; i<n; i++) {\n      par[i] = i;\n      height[i] = 0;\n    }\n    size = n;\n  }\n    \n  int find(int v) {\n    if (par[v] != v) return par[v] = find(par[v]);\n    return v;\n  }\n\n  bool same(int u, int v) {\n    return find(u) == find(v);\n  }\n\n  void unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return;\n  \n    size--;\n    if (height[u] > height[v]) par[v] = u;\n    else if (height[v] > height[u]) par[u] = v;\n    else {\n      par[v] = u;\n      height[v]++;\n    }\n  }\n};\n\nbool CompareEdge1(int x, int y) {\n  int at = min(hs[as[x]], hs[bs[x]]);\n  int bt = min(hs[as[y]], hs[bs[y]]);\n  if (at != bt) return at > bt;\n  return cs[x] < cs[y];\n}\n\nbool CompareEdge2(int x, int y) {\n  int at = min(hs[as[x]], hs[bs[x]]);\n  int bt = min(hs[as[y]], hs[bs[y]]);\n  if (min(at, bt) >= limh) return cs[x] < cs[y];\n  if (at != bt) return at > bt;\n  return cs[x] < cs[y];\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    int maxv;\n    int maxh = -1;\n    for (int i=1; i<=n; i++) {\n      scanf(\"%d\", &hs[i]);\n      if (maxh < hs[i]) {\n        maxh = hs[i];\n        maxv = i;\n      }\n    }\n\n    for (int i=0; i<m; i++) {\n      scanf(\"%d%d%d\", &as[i], &bs[i], &cs[i]);\n      es[i] = i;\n    }\n\n    sort(es, es+m, CompareEdge1);\n\n    UnionFind uf1(n+1);\n    uf1.unite(0, 1);\n\n    limh = maxh;\n    for (int i=0; i<m; i++) {\n      int idx = es[i];\n      int u = as[idx];\n      int v = bs[idx];\n      int c = cs[idx];\n      uf1.unite(u, v);\n      int h = min(hs[u], hs[v]);\n      bool connected = true;\n      for (int j=1; j<=n; j++) {\n        if (hs[j] >= h) {\n          connected &= uf1.same(maxv, j);\n        }\n      }\n\n      if (!connected) limh = h;\n    }\n\n    sort(es, es+m, CompareEdge2);\n\n    int ans = 0;\n    UnionFind uf2(n+1);\n    for (int i=0; i<m; i++) {\n      int idx = es[i];\n      int u = as[idx];\n      int v = bs[idx];\n      int c = cs[idx];\n      if (uf2.same(u, v)) continue;\n      uf2.unite(u, v);\n      ans += c;\n    }\n\n    for (int i=1; i<=n; i++) {\n      if (!uf2.same(1, i)) {\n        ans = 0;\n        break;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\nstruct union_find{\n    vector<int> par, rank;\n    union_find(int n){\n        par = vector<int>(n);\n        rank = vector<int>(n);\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nint main(){\n    int N,M;\n    vector<P> H;\n    vector<P> G[200];//to, cost\n    bool used[200];\n    priority_queue<T,vector<T>,greater<T>> que;\n    union_find U(200),U2(200);\n\n    while(cin>>N>>M,N){\n        H.clear();\n        for(int i=0;i<N;i++){\n            int h;\n            cin>>h;\n            H.emplace_back(h,i);\n        }\n        sort(H.begin(),H.end(),greater<P>());\n        for(int i=0;i<200;i++) G[i].clear();\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--;b--;\n            G[a].emplace_back(b,c);\n            G[b].emplace_back(a,c);\n        }\n        fill(used, used+200, false);\n        U.init(200);\n        U2.init(200);\n\n        int h=-1;\n        for(int i=0;i<N;i++){\n            while(true){\n                int a = H[i].second;\n                for(auto e:G[a]){\n                    int b=e.first;\n                    if(used[b]) U2.unite(a,b); \n                }\n                used[a]=true;\n                if(i+1<N&&H[i].first==H[i+1].first){\n                    i++;\n                }else{\n                    break;\n                }\n            }\n            bool connected = true;\n            for(int j=1;j<=i;j++){\n                if(!U2.same(H[0].second,H[j].second)){\n                    connected =false;\n                    break;\n                }\n            }\n            if(connected){\n                if(h==-1) h=i;\n            }else{\n                h=-1;\n            }\n        }\n\n        fill(used,used+200,false);\n        int ans=0;\n        while(!que.empty()) que.pop();\n        for(int i=0;i<N;i++){\n            while(true){\n                int a = H[i].second;\n                for(auto e:G[a]){\n                    int b = e.first;\n                    int c = e.second;\n                    if(used[b]){\n                        que.emplace(T(c,a,b));\n                    }\n                }\n                used[a]=true;\n                if(i+1<N&&H[i].first==H[i+1].first){\n                    i++;\n                }else{\n                    break;\n                }\n            }\n            if(i<h) continue;\n            while(!que.empty()){\n                int a,b,c;\n                tie(c,a,b) = que.top(); que.pop();\n                if(!U.same(a,b)){\n                    ans+=c;\n                    U.unite(a,b);\n                }\n            }\n        }\n        for(int i=1;i<N;i++){\n            if(!U.same(0,i)){\n                ans=0;\n                break;\n            }\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    UnionFind(int n) {\n        par.resize(n);\n        sz.resize(n, 1);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n        return true;\n    }\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n};\n\nint main()\n{\n    while (true) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) {\n            break;\n        }\n        vector<int> h(n); cin >> h;\n        Edges<int> E;\n        for (int i = 0; i < m; ++i) {\n            int a, b, c; cin >> a >> b >> c; --a, --b;\n            E.emplace_back(a, b, c);\n        }\n\n        vector<vector<int>> idx;\n        {\n            map<int,vector<int>> mp;\n            for (int i = 0; i < n; ++i) {\n                mp[-h[i]].push_back(i);\n            }\n            for (auto p : mp) {\n                idx.push_back(p.sc);\n            }\n        }\n\n        int pivot = -1;\n        for (int i = idx.size()-1; i >= 0; --i) {\n            vector<bool> used(n, false);\n            for (int j = 0; j <= i; ++j) {\n                for (auto id : idx[j]) {\n                    used[id] = true;\n                }\n            }\n\n            Edges<int> es;\n            for (auto e : E) {\n                if (used[e.src] && used[e.to]) {\n                    es.push_back(e);\n                }\n            }\n\n            UnionFind uf(n);\n            for (auto e : es) {\n                if (!uf.issame(e.src, e.to)) {\n                    uf.merge(e.src, e.to);\n                }\n            }\n            map<int,bool> mp;\n            for (int i = 0; i < n; ++i) if (used[i]) {\n                mp[uf.root(i)] = true;\n            }\n\n            if (mp.size() != 1) {\n                pivot = i;\n                break;\n            }\n        }\n\n        UnionFind uf(n);\n        vector<bool> used(n, false);\n        for (int i = 0; i <= pivot; ++i) {\n            for (auto id : idx[i]) {\n                used[id] = true;\n            }\n        }\n\n        int total = 0;\n        for (int i = pivot+1; i < idx.size(); ++i) {\n            for (auto id : idx[i]) {\n                used[id] = true;\n            }\n\n            Edges<int> es;\n            for (auto e : E) {\n                if (used[e.src] && used[e.to]) {\n                    es.push_back(e);\n                }\n            }\n\n            int sz = es.size();\n            vector<int> ord(sz);\n            iota(ord.begin(), ord.end(), 0);\n            sort(ord.begin(), ord.end(), [&](int i, int j) {\n                    return es[i].cost < es[j].cost;\n                    });\n\n            int sum = 0;\n            for (auto i : ord) {\n                if (!uf.issame(es[i].src, es[i].to)) {\n                    uf.merge(es[i].src, es[i].to);\n                    sum += es[i].cost;\n                }\n            }\n            total += sum;\n        }\n\n        cout << total << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親\n\tvector<int> sz; // 数\n\t// 初期化\n\tUF(int n):par(n),sz(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\nint n,m;\nvector<pair<int,int>> h;\nvector<pair<ll,pair<ll,ll>>> v;\nbool sink[222];\n\nll check(int num){\n\tUF uf(n);\n\tll ret = 0;\n\tREP(i,m){\n\t\tll A = v[i].SE.FI;\n\t\tll B = v[i].SE.SE;\n\t\tll C = v[i].FI;\n\t\tif(sink[A] | sink[B])continue;\n\t\tif(!uf.same(A,B)){\n\t\t\tuf.unite(A,B);\n\t\t\tret += C;\n\t\t}\n\t}\n\tint cou = 0;\n\tREP(i,n){\n\t\tcou = max(cou,uf.size(i));\n\t}\n\treturn (cou == num ? ret : -1);\n}\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\th.clear();\n\t\tv.clear();\n\t\tREP(i,222)sink[i] = false;\n\t\t\n\t\tREP(i,n){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\th.PB(MP(tmp,i));\n\t\t}\n\t\t\n\t\tREP(i,m){\n\t\t\tll a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv.PB(MP(c,MP(a,b)));\n\t\t}\n\t\t\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\t\n\t\tll prev = check(n);\n\t\tint sinknum;\n\t\tif(prev == -1){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\tbool flag = false;\n\t\t\tfor(sinknum = 0;sinknum < n-1;sinknum++){\n\t\t\t\twhile(sinknum < n-1 && h[sinknum].FI == h[sinknum+1].FI){\n\t\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\t\tsinknum++;\n\t\t\t\t}\n\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\tll now = check(n-sinknum-1);\n\t\t\t\tif(now == -1){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev = now;\n\t\t\t}\n\t\t\tsink[h[sinknum].SE] = false;\n\t\t\tsinknum--;\n\t\t\tDBG(cout << \"prev \" << prev << \" sinknum \" << sinknum << endl;)\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tll tmp = 0;\n\t\t\tfor(int i = sinknum;i >= 0;i--){\n\t\t\t\tvector<int> li;\n\t\t\t\twhile(i > 0 && h[i].FI == h[i-1].FI){\n\t\t\t\t\tli.PB(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tli.PB(i);\n\t\t\t\tDBG(cout << \"size \" << li.size() << endl;);\n\t\t\t\tREP(j,m){\n\t\t\t\t\tll A = v[j].SE.FI;\n\t\t\t\t\tll B = v[j].SE.SE;\n\t\t\t\t\tll C = v[j].FI;\n\t\t\t\t\tint seica = -1;\n\t\t\t\t\tREP(k,li.size())if(sink[h[li[k]].SE] && (A == h[li[k]].SE || B == h[li[k]].SE))seica = li[k];\n\t\t\t\t\tif(seica != -1 && (sink[A] ^ sink[B])){\n\t\t\t\t\t\ttmp += C;\n\t\t\t\t\t\tsink[h[seica].SE] = false;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"i \" << i << endl;);\n\t\t\t}\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tcout << prev + tmp << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  Int num;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int n):num(n),r(n,1),p(n,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    num--;\n  }\n  Int size(Int x){\n    return r[find(x)];\n  }\n  Int count() const{\n    return num;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  while(cin>>n>>m,n){\n    vector<Int> hs(n);\n    for(Int i=0;i<n;i++) cin>>hs[i];\n    struct edge{\n      Int a,b,c,t;\n      edge(Int a,Int b,Int c,Int t):\n        a(a),b(b),c(c),t(t){}\n      bool operator<(const edge &e)const{\n        if(t!=e.t) return t>e.t;\n        return c<e.c;\n      }\n    };\n\n    vector<edge> es;\n    for(Int i=0;i<m;i++){\n      Int a,b,c;\n      cin>>a>>b>>c;\n      a--;b--;\n      Int t=min(hs[a],hs[b]);\n      es.emplace_back(a,b,c,t);\n    }\n\n    for(Int i=0;i<n;i++) es.emplace_back(i,i,0,hs[i]);\n    es.emplace_back(0,0,0,0);\n\n    sort(es.begin(),es.end());\n\n    using P = pair<Int, Int>;\n    vector<P> vp;\n    for(Int i=0;i<n;i++) vp.emplace_back(hs[i],i);\n    sort(vp.rbegin(),vp.rend());\n\n    Int time=1e9,cnt=0,num=0;\n    UnionFind uf(n);\n\n    Int pr=-1;\n    for(edge &e:es){\n      if(pr!=e.t&&num-cnt>1) time=e.t;\n      pr=e.t;\n\n      while(num<n&&e.t<=vp[num].first) num++;\n\n      if(!uf.same(e.a,e.b)) cnt++;\n      uf.unite(e.a,e.b);\n    }\n    //cout<<\"time:\"<<time<<endl;\n\n    for(edge &e:es)\n      chmin(e.t,time);\n\n    sort(es.begin(),es.end());\n    Int sum=0;\n    UnionFind uf2(n);\n    for(edge &e:es){\n      //cout<<e.a<<\" \"<<e.b<<\":\"<<e.t<<endl;\n      //if(e.t<time) continue;\n      if(uf2.same(e.a,e.b)) continue;\n      uf2.unite(e.a,e.b);\n      sum+=e.c;\n    }\n\n    if(uf.count()!=1) sum=0;\n    cout<<sum<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nstruct UnionFind {\n    vector<int> par;\n    int n, cnt;\n    UnionFind(const int& x = 0) {init(x);}\n    void init(const int& x) {par.assign(cnt=n=x, -1);}\n    inline int find(const int& x) {return par[x] < 0 ? x : par[x] = find(par[x]);}\n    inline bool same(const int& x, const int& y) {return find(x) == find(y);}\n    inline bool unite(int x, int y) {\n        if ((x = find(x)) == (y = find(y))) return false;\n        --cnt;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    inline int count() const {return cnt;}\n    inline int count(int x) {return -par[find(x)];}\n};\n\n\n\nstruct Edge\n{\t\n\tint u;\n\tint v;\n\tint cost;\n\tEdge() {}\t\n\tEdge(int u, int v, int cost) : u(u), v(v), cost(cost) {}\t\n\tbool operator<(const Edge& rhs) const {return cost < rhs.cost;}\n};\n\nconst int MAXN = 222;\nconst int MAX = 1000100;\nint N, M;\nvector<int> vanish[MAX];\nbool done[MAXN];\nvector<Edge> G;\n\nll solve() {\n\t// ??£????????????????????????????????? 1\n\t{\n\t\tUnionFind uf(N);\n\t\tfor (Edge e : G)\n\t\t\tuf.unite(e.u, e.v);\n\t\tif (uf.count() > 1) return 0;\n\t}\n\t// ????????????????????°??§??£?????§???????????????????????????\n\t// t=last ??§??£?????§??????????????´???, t=last+1 ??\\????????£??????????????????\n\t// t=last, last-1, ... ?????????????????£????????????????????°??????\n\tint last = -1;\n\tmemset(done, false, sizeof(done));\n\tfor (int t = 0; t < MAX; t++) {\n\t\tif (vanish[t].empty()) continue;\n\t\t// ????????????????¶???????\n\t\tfor (int v : vanish[t]) {\n\t\t\tdone[v] = true;\n\t\t}\n\t\t// ?????£??????????????£???????????§??????\n\t\tUnionFind uf(N);\n\t\tfor (Edge e : G) {\n\t\t\tif (done[e.u] || done[e.v]) continue;\n\t\t\tuf.unite(e.u, e.v);\n\t\t}\n\t\tint sz = 1;\n\t\tfor (int i = 0; i < N; i++) \n\t\t\tif (done[i]) sz++;\n\t\tif (uf.count() != sz) {\n\t\t\tlast = t;\n\t\t\tbreak;\n\t\t}\n\t}\n\tUnionFind uf(N);\n\tll ans = 0;\n\tmemset(done, false, sizeof(done));\n\tfor (int t = last; t < MAX; t++) {\n\t\tfor (int v : vanish[t]) {\n\t\t\tdone[v] = true;\n\t\t}\n\t}\n\tfor (Edge e : G) {\n\t\tif (!done[e.u] || !done[e.v]) continue;\n\t\tif (uf.same(e.u, e.v)) continue;\n\t\tans += e.cost;\n\t\tuf.unite(e.u, e.v);\n\t}\n\tfor (int t = last-1; t >= 0; t--) {\n\t\tif (vanish[t].empty()) continue;\n\t\tfor (int v : vanish[t]) \n\t\t\tdone[v] = true;\n\t\tfor (Edge e : G) {\n\t\t\tif (!done[e.u] || !done[e.v]) continue;\n\t\t\tif (uf.same(e.u, e.v)) continue;\n\t\t\tans += e.cost;\n\t\t\tuf.unite(e.u, e.v);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (cin >> N >> M) {\n\t\tif (N==0 && M==0) break;\n\t\tfor (int i = 0; i < MAX; i++) \n\t\t\tvanish[i].clear();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\tvanish[h].push_back(i);\n\t\t}\n\t\tG.clear();\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tG.emplace_back(a, b, c);\n\t\t}\n\t\tsort(G.begin(), G.end());\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// finish date: 2018/07/05\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <climits>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i, n)  FOR(i,0,n)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<long double> vd;\ntypedef vector<vector<long double>> vvd;\ntypedef vector<vector<vector<long double>>> vvvd;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> pii;\nconst int bigmod = 1000000007;\nconst int INF = 1050000000;\n\n\nll prim(int N, vector<vector<pii> > edge) {\n    priority_queue<pii, vector<pii>, greater<pii> > pq;\n    vector<bool> used(N, false);\n    pq.push(pii(0, 0));\n    ll total = 0;\n    while (!pq.empty()) {\n        int dis, t;\n        tie(dis, t) = pq.top();\n        pq.pop();\n        if (used[t]) continue;\n        used[t] = true;\n        total += dis;\n        for (auto e: edge[t]) {\n            if (!used[e.second]) pq.push(e);\n        }\n    }\n    return total;\n}\n\nstruct Union_Find {\n    vi parent;\n    vi sizes;\n    int setnum = 0;\n\n    Union_Find(int n) : parent(n), sizes(n, 1) {\n        rep(i, n) parent[i] = i;\n        setnum = n;\n    }\n\n    int find(int x) {\n        if (x == parent[x]) return x;\n        return parent[x] = find(parent[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n        if (sizes[x] < sizes[y]) swap(x, y);\n\n        parent[y] = x;\n        sizes[x] += sizes[y];\n        setnum--;\n\n    }\n\n    bool isSame(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return sizes[find(x)];\n    }\n};\n\nint main() {\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 && M == 0) break;\n        vvi h(N, vi(2));\n        vvi abc(M, vi(3));\n        rep(i, N) {\n            cin >> h[i][0];\n            h[i][1] = i;\n        }\n        rep(i, M) {\n            cin >> abc[i][0] >> abc[i][1] >> abc[i][2];\n            abc[i][0]--;\n            abc[i][1]--;\n        }\n        map<int, int> numh;\n        rep(i, N) {\n            numh[h[i][0]]++;\n        }\n\n        sort(h.rbegin(), h.rend());\n        map<int, int> tr;\n        rep(i, N) {\n            tr[h[i][1]] = i;\n        }\n\n        rep(i, M) {\n            rep(j, 2) {\n                abc[i][j] = tr[abc[i][j]];\n            }\n        }\n        /*\n        rep(i,N){\n                rep(j,3){\n                        cout<<abc[i][j] << \" \";\n                }\n                cout<<endl;\n        }*/\n\n\n        vvi dist(N, vi(N, INT_MAX));\n        Union_Find uf(N);\n        rep(i, M) {\n            int a = abc[i][0];\n            int b = abc[i][1];\n            int c = abc[i][2];\n            //edge[a].push_back(make_pair(c,b));\n            //edge[b].push_back(make_pair(c,a));\n            dist[a][b] = c;\n            dist[b][a] = c;\n        }\n        //cout<<dist.size();//<<\" \"<<dist[0].size();\n        rep(i, N) dist[i][i] = 0;\n\n        vector<bool> isUF(N, false);\n\n        rep(i, N) {\n            rep(j, i) {\n                if (dist[i][j] != INT_MAX) {\n                    uf.unite(i, j);\n                }\n            }\n            if (uf.setnum == N - i) isUF[i] = true;\n        }\n        if (!isUF[N - 1]) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        int idx = 0;\n        for (int i = N - 1; i > 0; i--) {\n            if (!isUF[i]) {\n                int now = h[i][0];\n                int now_idx = i;\n                idx = i;\n                while (idx < N-1 && h[idx][0] == h[idx + 1][0]) idx++;\n                idx++;\n                while (idx < N-1 && h[idx][0] == h[idx + 1][0]) idx++;\n                idx++;\n                idx = min(idx, N);\n                break;\n            }\n        }\n        rep(i,N) cout<<h[i][0]<<endl;\n\n\n\n        ll ans = 0;\n//        idx = 9;\n        if (idx != 0) {\n            vector<vector<pii> > edge(idx);\n            rep(i, idx) {\n                rep(j, idx) {\n                    if (dist[i][j] != INT_MAX) {\n                        edge[i].push_back(make_pair(dist[i][j], j));\n                        edge[j].push_back(make_pair(dist[i][j], i));\n                    }\n                }\n            }\n            ans += prim(idx, edge);\n        }\n        if (idx == 0) idx++;\n        FOR(i, idx, N) {\n            int mi = INT_MAX;\n            rep(j, i) {\n                mi = min(mi, dist[i][j]);\n            }\n            //cout<<i<<\" \"<<mi<<endl;\n            ans += mi;\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nclass UnionFind {\n\tvector<int> data;\n\tvector<int> rank;\n\tint root(int a) {\n\t\treturn data[a] < 0 ? a : data[a] = root(data[a]);\n\t}\npublic:\n\tUnionFind(int n) : data(n, -1), rank(n, 1) {}\n\tbool Find(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\tvoid Union(int a, int b) {\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b) return;\n\t\tif (rank[a] < rank[b]) {\n\t\t\tdata[a] += data[b];\n\t\t\tdata[b] = a;\n\t\t}\n\t\telse {\n\t\t\tdata[b] += data[a];\n\t\t\tdata[a] = b;\n\t\t\tif (rank[a] == rank[b]) rank[b]++;\n\t\t}\n\t}\n\tint Size(int a) {\n\t\treturn -data[root(a)];\n\t}\n\tint Rank(int a) {\n\t\treturn rank[root(a)];\n\t}\n};\n\nint main()\n{\n\tint N, M;\n\twhile (cin >> N >> M, N | M) {\n\t\tvector<int> h(N);\n\t\tvector<pair<int, int>> s(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> h[i];\n\t\t\ts[i].first = h[i];\n\t\t\ts[i].second = i;\n\t\t}\n\t\tvector<tuple<int, int, int>> abc(M);\n\t\tfor (int i = 0, a, b, c; i < M; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tabc[i] = make_tuple(c, --a, --b);\n\t\t}\n\t\tsort(s.begin(), s.end());\n\t\tsort(abc.begin(), abc.end());\n\t\tvector<int> a(M), b(M), c(M);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\ta[i] = get<1>(abc[i]);\n\t\t\tb[i] = get<2>(abc[i]);\n\t\t\tc[i] = get<0>(abc[i]);\n\t\t}\n\n\t\tvector<int> exist(N, 1);\n\t\tll tmp;\n\t\tfor (tmp = 0; tmp < N; tmp++) {\n\t\t\tUnionFind uf(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tif (exist[a[i]] && exist[b[i]]) {\n\t\t\t\t\tuf.Union(a[i], b[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint id;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (exist[i]) {\n\t\t\t\t\tid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (uf.Size(id) != N - tmp) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (tmp + 1 < N && s[tmp].first == s[tmp + 1].first) {\n\t\t\t\texist[s[tmp++].second] = 0;\n\t\t\t}\n\t\t\texist[s[tmp].second] = 0;\n\t\t}\n\t\tll res = 0;\n\t\tUnionFind uf(N);\n\t\tfor (int j = tmp - 1; j >= 0; j--) {\n\t\t\twhile (j - 1 >= 0 && s[j].first == s[j - 1].first) {\n\t\t\t\texist[s[j--].second] = 1;\n\t\t\t}\n\t\t\texist[s[j].second] = 1;\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tif (exist[a[i]] && exist[b[i]]) {\n\t\t\t\t\tif (!uf.Find(a[i], b[i])) {\n\t\t\t\t\t\tuf.Union(a[i], b[i]);\n\t\t\t\t\t\tres += c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,M;\nvector<P> H;\n\nstruct edge{\n  int to,from,c;\n  bool operator<(const edge& e) const{\n    return c < e.c;\n  }\n};\n\nvector<edge> E;\n\nstruct uni{\n  int d[222];\n  void init(){ memset(d,-1,sizeof(d)); }\n  int find(int a){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void marge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a]+=d[b]; d[b] = a;\n  }\n  bool same(int a,int b){ return find(a)==find(b); }\n  int size(int a){ return -d[find(a)]; }\n};\n\nuni U;\n\nbool used[333];\nint main(){\n  while( cin >> N >> M && (N||M) ){\n    U.init();\n    H.clear();\n    E.clear();\n    for(int i=0;i<N;i++) {\n      H.push_back(P(i,i));\n      cin >> H[i].first;\n    }\n    sort(H.rbegin(),H.rend());\n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      --a; --b;\n      E.push_back( (edge){a,b,c} );\n    }\n    sort(E.begin(),E.end());\n\n\n    int start = N+1;\n    for(int i=N;i>0;i--){\n      int id=H[0].second;\n      if( i<N && H[i].first == H[i-1].first ) {\n\tcontinue;\n      }\n      memset(used,0,sizeof(used));\n      for(int j=0;j<i;j++) used[H[j].second] = true;      \n      uni up;\n      up.init();\n      for(int j=0;j<M;j++){\n\tif( used[E[j].to] && used[E[j].from] ) {\n\t  if( !up.same(E[j].to,E[j].from) ) {\n\t    up.marge(E[j].to,E[j].from);\n\t  }\n\t}\n      }  \n      if( up.size(id) == i ) start = i;\n      else break;\n    }\n\n    long long res = 0;\n    for(int i=start;i<=N;i++){\n      if( i < N-1 && H[i].first == H[i+1].first ) \n\tcontinue;\n      for(int j=0;j<=min(N-1,i);j++)\n\tused[H[j].second] = true;\n      \n      //      cout << id << endl;\n      for(int j=0;j<M;j++){\n\tif( used[E[j].to] && used[E[j].from] ) {\n\t  if( !U.same(E[j].to,E[j].from) ) {\n\t    //   cout << E[j].to << \" \"<< E[j].from << \" \"<< E[j].c << endl;\n\t    res+=(long long)E[j].c;\n\t    U.marge(E[j].to,E[j].from);\n\t  }\n\t}\n      }    \n    }\n    \n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\n// Union-Find\nstruct UF {\n\tint c;\n\tvector<int> p;\n\tUF() = default;\n\texplicit UF(int n): c(n), p(n, -1) {}\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return false;\n\t\tif (p[x] > p[y]) swap(x, y);\n\t\tp[x] += p[y];\n\t\tp[y] = x;\n\t\tc--;\n\t\treturn true;\n\t}\n\tint find(int x) { return (p[x] < 0 ? x : p[x] = find(p[x])); }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -p[find(x)]; }\n\tint count() { return c; }\n};\n\ntemplate <typename T> map<T, int> coordinate_compression(vector<T> x) {\n    int n = x.size();\n    vector<int> y(n);\n    iota(y.begin(), y.end(), 0);\n    sort(y.begin(), y.end(), [&](int i, int j) { return x[i] < x[j]; });\n    map<T, int> res;\n    for (int i : y) if (!res.count(x[i])) {\n        int j = res.size();\n        res[x[i]] = j;\n    }\n    return res;\n}\n\nusing P = pair<int, int>;\nint N, M;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> N >> M, N) {\n        vector<int> h(N), a(M), b(M), c(M);\n        vector<vector<P>> g(N);\n        REP (i, N) cin >> h[i];\n        REP (i, M) {\n            cin >> a[i] >> b[i] >> c[i];\n            a[i]--, b[i]--;\n            g[a[i]].emplace_back(b[i], c[i]);\n            g[b[i]].emplace_back(a[i], c[i]);\n        }\n\n        auto mp = coordinate_compression<int>(h);\n        vector<vector<int>> group(mp.size());\n        REP (i, N) group[mp[h[i]]].push_back(i);\n        reverse(group.begin(), group.end());\n\n        vector<bool> used(N, false), is_connect(mp.size(), false);\n        UF uf(N);\n        int sz = 0;\n        REP (i, group.size()) {\n            for (int v : group[i]) used[v] = true, sz++;\n            for (int v : group[i]) for (P e : g[v]) if (used[e.first]) {\n                uf.unite(v, e.first);\n            }\n            is_connect[i] = (uf.size(group[i][0]) == sz);\n        }\n\n        int disconnect = -1;\n        REP(i, group.size()) if (!is_connect[i]) {\n            disconnect = i;\n        }\n        if (disconnect == group.size() - 1) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        set<int> st;\n        REP (i, disconnect + 2) for (int v : group[i]) st.insert(v);\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        used.assign(N, false);\n        que.emplace(0, group[0][0]);\n        int ans = 0;\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            if (used[p.second]) continue;\n            used[p.second] = true;\n            ans += p.first;\n            for (P& e : g[p.second]) {\n                if (st.count(e.first)) {\n                    que.emplace(e.second, e.first);\n                }\n            }\n        }\n\n        FOR (i, disconnect + 2, group.size()) {\n            for (int v : group[i]) st.insert(v);\n            REP (i, N) if (used[i]) for (P& e : g[i]) if (st.count(e.first) && !used[e.first]) {\n                que.emplace(e.second, e.first);\n            }\n            while (!que.empty()) {\n                P p = que.top();\n                que.pop();\n                if (used[p.second]) continue;\n                used[p.second] = true;\n                ans += p.first;\n                for (P& e : g[p.second]) {\n                    if (st.count(e.first) && !used[e.first]) {\n                        que.emplace(e.second, e.first);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\n//\nint par_uf[100010],rank_uf[100010];\n\nvoid init(int n){for(int i=0;i<n;i++){par_uf[i]=i;rank_uf[i]=0;}}\nint find(int x){if(par_uf[x]==x)return x;else return find(par_uf[x]);}\nvoid unite(int x,int y){x=find(x);y=find(y);if(x==y)return;if(rank_uf[x]<rank_uf[y])par_uf[x]=y;else{par_uf[y]=x;if(rank_uf[x]==rank_uf[y])rank_uf[x]++;}}\nbool same(int x,int y){return find(x)==find(y);}\n//\n\nint N,M,h[210];\npair<int,pi> e[20010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>N>>M && N){\n\t\trep(i,N)cin>>h[i];\n\t\trep(i,M){\n\t\t\tcin>>e[i].sec.fir>>e[i].sec.sec>>e[i].fir;\n\t\t\te[i].sec.fir--;e[i].sec.sec--;\n\t\t}\n\t\tsort(e,e+M);\n\t\t\n\t\tpi p[210];\n\t\trep(i,N)p[i]=mp(-h[i],i);\n\t\tsort(p,p+N);\n\t\t\n\t\tint ans=0;\n\t\tinit(N);\n\t\tint on[210]={};\n\t\tint comp=0;\n\t\trep(i,N){\n\t\t\ton[p[i].sec]=1;\n\t\t\tcomp++;\n\t\t\twhile(i+1<N && p[i+1].fir==p[i].fir){\n\t\t\t\ti++;\n\t\t\t\ton[p[i].sec]=1;\n\t\t\t\tcomp++;\n\t\t\t}\n\t\t\t\n\t\t\trep(j,M){\n\t\t\t\tif(on[e[j].sec.fir] && on[e[j].sec.sec]\n\t\t\t\t&& !same(e[j].sec.fir,e[j].sec.sec)){\n\t\t\t\t\tunite(e[j].sec.fir,e[j].sec.sec);\n\t\t\t\t\tans+=e[j].fir;\n\t\t\t\t\tcomp--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(comp!=1){\n\t\t\t\tans=0;\n\t\t\t\tinit(N);\n\t\t\t\tcomp=i+1;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<Int, P> T;\n\nInt u[1080];\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(Int x, Int y){\n\tu[r(x)] = r(y);\n}\nvector<T> edge[1080000];\nInt h[1080];\nbool ok[1080];\nint main(){\n\tInt n, m;\n\twhile(cin >> n >> m, n | m){\n\t\tInt res = 0, bridge = 0, a, b, c, cnt = 0;\n\t\tfor(Int i = 0;i < n;i++){\n\t\t\tcin >> h[i], u[i] = i;\n\t\t\tedge[h[i]].push_back(T(-1, P(i, i)));\n\t\t}\n\t\tfor(Int i = 0;i < m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tedge[min(h[a], h[b])].push_back(T(c, P(a, b)));\n\t\t\tif(h[a] == h[b])unite(a, b);\n\t\t}\n\t\t\n\t\tInt breakpoInt = 1000010;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tfor(int j = 0;j < edge[i].size();j++){\n\t\t\t\ta = edge[i][j].second.first, b = edge[i][j].second.second;\n\t\t\t\tc = edge[i][j].first;\n\t\t\t\tif(c == -1)cnt++;\n\t\t\t\tif(r(a) != r(b)){\n\t\t\t\t\tunite(a, b);\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt != 1)breakpoInt = i;\n\t\t}\n\t\tbreakpoInt--;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t}                    \n\t\tbridge = 0;\n\t\tvector<T> tmp;\n\t\tfor(Int i = 0;i < n;i++)u[i] = i;\n\t\tif(breakpoInt)breakpoInt--;\n\t\tfor(Int i = 1000000;i >= breakpoInt;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\ttmp.push_back(edge[i][j]);\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor(Int i = 0;i < tmp.size();i++){\n\t\t\tInt from = tmp[i].second.first, to = tmp[i].second.second;\n\t\t\tif(r(from) != r(to)){\n\t\t\t\tbridge++;\n\t\t\t\tres += tmp[i].first;\n\t\t\t\tunite(from, to);\n\t\t\t}\n\t\t}                          \n\t\tfor(Int i = breakpoInt;i > 0;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tres += edge[i][j].first;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tif(bridge + 1 != n)res = 0;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) : data(n, -1) { }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    void merge(int x, int y) {\n        x = root(x), y = root(y);\n        if(x != y) {\n            data[x] += data[y], data[y] = x;\n        }\n    }\n\n    int count_union() {\n        int s = 0;\n        for(int i = 0; i < (int)data.size(); i++) s += data[i] < 0;\n        return s;\n    }\n};\n\nstruct Edge {\n    int from, to, cost;\n    Edge(int f, int t, int c) : from(f), to(t), cost(c) { }\n    bool operator <(const Edge& e) const {\n        return cost < e.cost;\n    }\n};\n\n\nvector<Edge> read_edges(int M) {\n    vector<Edge> res;\n    for(int i = 0; i < M; i++) {\n        int f, t, c;\n        cin >> f >> t >> c;\n        f--, t--;\n        res.push_back(Edge(f, t, c));\n    }\n    return res;\n}\n\nvector<vector<int> > read_deadlines(int N) {\n    map<int, vector<int> > H;\n    for(int i = 0; i < N; i++) {\n        int h; cin >> h;\n        H[h].push_back(i);\n    }\n    vector<vector<int> > res;\n    for(map<int, vector<int> >::const_iterator it = H.begin(); it != H.end(); ++it) {\n        res.push_back(it->second);\n    }\n    return res;\n}\n\nint calc_deadline(int N, vector<vector<int> >& H, vector<Edge>& edges) {\n    int r = H.size();\n    UnionFind uf(N);\n    set<int> island;\n    for(int i = (int)H.size() - 1; i >= 0; i--) {\n        for(int j = 0; j < H[i].size(); j++) {\n            island.insert(H[i][j]);\n        }\n\n        for(int j = 0; j < (int)edges.size(); j++) {\n            if(island.count(edges[j].from) && island.count(edges[j].to)) {\n                uf.merge(edges[j].from, edges[j].to);\n            }\n        }\n\n        if(uf.count_union() != N - (int)island.size() + 1) {\n            r = i;\n        }\n    }\n    return r;\n}\n\nint msp(int N, vector<vector<int> >& H, vector<Edge>& edges, int deadline) {\n    int res = 0;\n    UnionFind uf(N);\n    set<int> island;\n    for(int i = H.size() - 1; i >= deadline; i--) {\n        for(int j = 0; j < H[i].size(); j++) {\n            island.insert(H[i][j]);\n        }\n    }\n    for(int i = deadline - 1; i >= 0; i--) {\n        for(int j = 0; j < H[i].size(); j++) {\n            island.insert(H[i][j]);\n        }\n\n        for(int j = 0; j < (int)edges.size(); j++) {\n            if(uf.same(edges[j].from, edges[j].to) == false && island.count(edges[j].from) && island.count(edges[j].to)) {\n                uf.merge(edges[j].from, edges[j].to);\n                res += edges[j].cost;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    for(int N, M; cin >> N >> M, N || M; ) {\n        vector<vector<int> > H = read_deadlines(N);\n        vector<Edge> edges = read_edges(M);\n        sort(edges.begin(), edges.end());\n        int dl = calc_deadline(N, H, edges);\n        cout << msp(N, H, edges, dl) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\nclass UnionFind\n{\nprivate:\n    vector<int> data;\n    int _groups;\npublic:\n    int n;\n    UnionFind(int n) : data(n, -1), _groups(n), n(n) { }\n\n    void unite(int x, int y)\n    {\n        x = root(x), y = root(y);\n        if (x != y)\n        {\n            --_groups;\n            if (data[x] > data[y])\n                swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n    int groups() const { return _groups; }\n};\nint main()\n{\n    fast_io();\n\n    int n, m;\n    while (cin >> n >> m, n)\n    {\n        vector<pint> land;\n        rep(i, n)\n        {\n            int h;\n            cin >> h;\n            land.pb(pint(h, i));\n        }\n        \n        int a[ten(5)], b[ten(5)], c[ten(5)];\n        vector<pint> e;\n        rep(i, m)\n        {\n            cin >> a[i] >> b[i] >> c[i];\n            --a[i], --b[i];\n            e.pb(pint(c[i], i));\n        }\n\n        sort(all(land));\n        sort(all(e));\n\n        int connect_h = ten(9);\n        {\n            UnionFind uf(n);\n            bool up[222] = {};\n            for (int li = n - 1; li >= 0; )\n            {\n                int h = land[li].first;\n                while (li >= 0 && land[li].first == h)\n                    up[land[li--].second] = true;\n\n                rep(i, m)\n                    if (up[a[i]] && up[b[i]])\n                        uf.unite(a[i], b[i]);\n\n                if (uf.groups() - (li + 1) > 1)\n                    connect_h = h - 1;\n            }\n        }\n\n        {\n            int res = 0;\n            UnionFind uf(n);\n            bool up[222] = {};\n            for (int li = n - 1; li >= 0; )\n            {\n                int h = land[li].first;\n                while (li >= 0 && land[li].first == h)\n                    up[land[li--].second] = true;\n\n                if (h > connect_h)\n                    continue;\n\n                foreach (it, e)\n                {\n                    int i = it->second;\n                    if (up[a[i]] && up[b[i]] && !uf.same(a[i], b[i]))\n                    {\n                        uf.unite(a[i], b[i]);\n                        res += c[i];\n                    }\n                }\n            }\n            cout << res << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2511&lang=jp\n// references:http://mayokoex.hatenablog.com/entry/2016/05/03/233156\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n#define MAXT 1000010\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n\tedge() {}\n\tedge(int f, int t, int c) :from(f), to(t), cost(c) {}\n\tbool operator < (const edge& o) const { return cost < o.cost; }\n};\n\nstruct UnionFind {\n\tvector<int> par;\n\tint n, cnt;\n\tUnionFind(const int& x = 0) { init(x); }\n\tvoid init(const int& x) { par.assign(cnt = n = x, -1); }\n\tinline int find(const int& x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tinline bool same(const int& x, const int& y) { return find(x) == find(y); }\n\tinline bool unite(int x, int y) {\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\t--cnt;\n\t\tif (par[x] > par[y]) swap(x, y);\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\tinline int count() const { return cnt; }\n\tinline int count(int x) { return -par[find(x)]; }\n};\n\nint main(void) {\n\tvector<vector<int>> v;\n\n\tv = vector<vector<int>>(100, vector<int>(100, 0));\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M;\n\twhile (cin >> N >> M, N | M) {\n\t\tvector<int> h[MAXT];\n\t\tfor (int i = 0; i < N; i++) { int t; cin >> t; h[t].push_back(i); }\n\t\tvector<edge> G(M);\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tG.push_back(edge(a, b, c));\n\t\t}\n\t\tsort(G.begin(), G.end());\n\t\t\n\t\tUnionFind uf(N);\n\t\tfor (auto e : G) uf.unite(e.from, e.to);\n\t\tif (uf.count() > 1) { cout << 0 << endl; continue; }\n\n\t\tvector<int> f(N, 0);\n\t\tint cnt = 1;\n\t\tint last_t = -1;\n\t\tfor (int t = 0; t < MAXT;t++) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) { f[n] = 1; cnt++; }\n\t\t\tUnionFind uf(N);\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (f[e.from] == 1 || f[e.to] == 1)continue;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\t\t\tif (uf.count() != cnt) { last_t = t; break; }\n\t\t}\n\t\tif (last_t == -1)last_t = MAXT;\n\n\t\tfill(f.begin(), f.end(), 0);\n\t\tll ans = 0;\n\t\tfor (int t = last_t; t < MAXT;t++)for (auto n : h[t]) f[n] = 1;\n\t\t/* Minimum spanning tree */\n\t\tfor (auto e : G) {\n\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t}\n\t\t/*----------------------*/\n\n\t\tfor (int t = last_t - 1; t >= 0;t--) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) f[n] = 1;\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親\n\tvector<int> sz; // 数\n\t// 初期化\n\tUF(int n):par(n),sz(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\nint n,m;\nvector<pair<int,int>> h;\nvector<pair<ll,pair<ll,ll>>> v;\nbool sink[222];\n\nll check(int num){\n\tUF uf(n);\n\tll ret = 0;\n\tREP(i,m){\n\t\tll A = v[i].SE.FI;\n\t\tll B = v[i].SE.SE;\n\t\tll C = v[i].FI;\n\t\tif(sink[A] | sink[B])continue;\n\t\tif(!uf.same(A,B)){\n\t\t\tuf.unite(A,B);\n\t\t\tret += C;\n\t\t}\n\t}\n\tint cou = 0;\n\tREP(i,n){\n\t\tcou = max(cou,uf.size(i));\n\t}\n\treturn (cou == num ? ret : -1);\n}\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\th.clear();\n\t\tv.clear();\n\t\tREP(i,222)sink[i] = false;\n\t\t\n\t\tREP(i,n){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\th.PB(MP(tmp,i));\n\t\t}\n\t\t\n\t\tREP(i,m){\n\t\t\tll a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv.PB(MP(c,MP(a,b)));\n\t\t}\n\t\t\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\t\n\t\tll prev = check(n);\n\t\tint sinknum;\n\t\tif(prev == -1){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\tbool flag = false;\n\t\t\tfor(sinknum = 0;sinknum < n-1;sinknum++){\n\t\t\t\twhile(sinknum < n-1 && h[sinknum].FI == h[sinknum+1].FI){\n\t\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\t\tsinknum++;\n\t\t\t\t}\n\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\tll now = check(n-sinknum-1);\n\t\t\t\tif(now == -1){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev = now;\n\t\t\t}\n\t\t\tsink[h[sinknum].SE] = false;\n\t\t\tsinknum--;\n\t\t\tDBG(cout << \"prev \" << prev << \" sinknum \" << sinknum << endl;)\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tll tmp = 0;\n\t\t\tfor(int i = sinknum;i >= 0;i--){\n\t\t\t\tvector<int> li;\n\t\t\t\twhile(i > 0 && h[i].FI == h[i-1].FI){\n\t\t\t\t\tli.PB(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tli.PB(i);\n\t\t\t\tDBG(cout << \"size \" << li.size() << endl;);\n\t\t\t\tREP(j,m){\n\t\t\t\t\tll A = v[j].SE.FI;\n\t\t\t\t\tll B = v[j].SE.SE;\n\t\t\t\t\tll C = v[j].FI;\n\t\t\t\t\tint seica = -1;\n\t\t\t\t\tREP(k,li.size())if(sink[h[li[k]].SE] && (A == h[li[k]].SE || B == h[li[k]].SE))seica = li[k];\n\t\t\t\t\tif(seica != -1 && (sink[A] ^ sink[B])){\n\t\t\t\t\t\ttmp += C;\n\t\t\t\t\t\tsink[h[seica].SE] = false;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"i \" << i << endl;);\n\t\t\t}\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tcout << prev + tmp << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nstruct union_find{\n  int N;\n  vector<int> parent;\n  vector<int> siz;\n\n  union_find(int N): parent(N), siz(N, 1){\n    for (int i  =0;i < N;i++) parent[i] = i;\n  }\n\n  int root(int x){\n    if(parent[x] == x) return x;\n    else return parent[x] = root(parent[x]);\n  }\n\n  void merge(int x, int y){\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(siz[x] < siz[y]) swap(x, y);\n    parent[y] = x;\n    siz[x] += siz[y];\n    siz[y] = 0;\n  }\n\n  bool are_same(int x, int y){\n    return root(x) == root(y);\n  }\n\n  int size(int x){\n    return siz[root(x)];\n  }\n};\n\nll n,m;\nvl h;\nvl sink;\nmap<ll,vl> hour_of_node;\nvl visit;\ngraph g;\ngraph sg;\nll ans;\n\nvoid dfs(ll x){\n  visit[x] = 1;\n  for(auto y : g[x]){\n    if(visit[y.first] == 0 && sink[y.first] == 0) dfs(y.first);\n  }\n}\n\nbool valid(){\n  for(ll i = 1;i <= n;i++){\n    if(sink[i] == visit[i]){\n      // cerr << \"!\" << i << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  while (cin >> n >> m) {\n    if(n == 0 && m == 0) return 0;\n    h = vl(n+1);\n    for(ll i = 1;i <= n;i++) cin >> h[i];\n    g = graph();\n    for(ll i = 0;i < m;i++){\n      ll a,b,c;\n      cin >> a >> b >> c;\n      g[a][b] = g[b][a] = c;\n    }\n\n    sink = vl(n+1);\n    hour_of_node = map<ll,vl>();\n    for(ll i = 1;i <= n;i++){\n      hour_of_node[h[i]].push_back(i);\n    }\n    visit = vl(n+1);\n    dfs(1);\n    if(!valid()){\n      cout << 0 << endl;\n      continue;\n    }\n    auto hour_iter = hour_of_node.begin();\n    for(;hour_iter != hour_of_node.end();hour_iter++){\n      // cerr << hour_iter->first << endl;\n      for(ll x : hour_iter->second){\n        sink[x] = 1;\n      }\n      visit = vl(n+1);\n      for(ll i = 1;i <= n;i++){\n        if(sink[i] == 0){\n          dfs(i);\n          // cerr << i << endl;\n          break;\n        }\n      }\n      if(!valid()){\n        for(ll x : hour_iter-> second){\n          sink[x] = 0;\n        }\n        break;\n      }\n    }\n    // if(hour_iter == hour_of_node.end()) // cerr << \"!!!!!!\" << endl;\n    vector<vl> edges;\n    for(ll i = 1;i <= n;i++){\n      if(sink[i] == 0){\n        for(auto y : g[i]){\n          if(sink[y.first] == 0){\n            edges.push_back(vl({y.second, i, y.first}));\n          }\n        }\n      }\n    }\n    sort(edges.begin(),edges.end());\n    union_find uf(n+1);\n    ans = 0;\n    for(ll i = 0;i < edges.size();i++){\n      ll a = edges[i][1];\n      ll b = edges[i][2];\n      ll c = edges[i][0];\n      if(!uf.are_same(a,b)){\n        uf.merge(a,b);\n        ans += c;\n      }\n    }\n    hour_iter--;\n    for(;;hour_iter--){\n      edges = vector<vl>();\n      for(ll x : hour_iter-> second){\n        sink[x] = 0;\n      }\n      for(ll x : hour_iter->second){\n        for(auto y : g[x]){\n          if(sink[y.first] == 0){\n            edges.push_back(vl({y.second, x, y.first}));\n          }\n        }\n      }\n      sort(edges.begin(),edges.end());\n\n      for(ll i = 0;i < edges.size();i++){\n        ll a = edges[i][1];\n        ll b = edges[i][2];\n        ll c = edges[i][0];\n        if(!uf.are_same(a,b)){\n          uf.merge(a,b);\n          ans += c;\n        }\n      }\n      if(hour_iter == hour_of_node.begin()) break;\n    }\n    cout << ans << endl;\n\n\n\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n  int x, hour;\n  node(){}\n  node(int x, int hour):x(x), hour(hour){}\n  bool operator < (const node& u) const {\n    return hour < u.hour;\n  }\n};\n\nstruct edge{\n  int u, v, cost;\n  edge(){}\n  edge(int u, int v, int cost):u(u), v(v), cost(cost){}\n  bool operator < (const edge& e) const {\n    return cost < e.cost;\n  }\n};\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n  int find(int k)\n  {\n    if(data[k] < 0) return k;\n    return data[k] = find(data[k]);\n  }\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y){\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n  int size(int k)\n  {\n    return -data[find(k)];\n  }\n};\n\nint main()\n{\n  int N, M;\n  while(cin >> N >> M, N || M){\n    vector<node> V;\n    vector<edge> E;\n    for(int i = 0; i < N; i++){\n      int h; cin >> h;\n      V.push_back(node(i, h));\n    }\n    for(int i = 0; i < M; i++){\n      int a, b, c; cin >> a >> b >> c; a--, b--;\n      E.push_back(edge(a, b, c));\n    }\n    sort(V.rbegin(), V.rend());\n    sort(E.begin(), E.end());\n    vector<bool> exist(N, true);\n    int dis = N;\n    for(int i = N-1; i >= 0; i--){\n      if(i < N-1 || V[i].hour != V[i+1].hour){\n\tUnionFind msp(N);\n\tfor(int j = 0; j < M; j++){\n\t  if(exist[E[j].u] && exist[E[j].v] && !msp.same(E[j].u, E[j].v)){\n\t    msp.unite(E[j].u, E[j].v);\n\t  }\n\t}\n\tif(msp.size(V[0].x) == i+1) dis = i;\n\telse break;\n      }\n      exist[V[i].x] = false;\n    }\n    UnionFind uf(N);\n    long long ans = 0LL;\n    for(int i = dis; i < N; i++){ \n      exist[V[i].x] = true;\n      if(i < N-1 && V[i].hour == V[i+1].hour) continue;\n      for(int j = 0; j < M; j++){\n\tif(exist[E[j].u] && exist[E[j].v] && !uf.same(E[j].u, E[j].v)){\n\t  uf.unite(E[j].u, E[j].v);\n\t  ans += E[j].cost;\n\t}\n      }\n    }\t\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tint t = -1;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { if (e1.t == e2.t)return e1.w < e2.w; else return e1.t < e2.t; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n};\n\n\nEdges kruskal(int N, vector<Edge> &edges) {\n\tint totalCost = 0;\n\tsort(all(edges));\n\tUnionFind dset(N);\n\tvector<Edge>mst;\n\trep(i, 0, edges.size()) {\n\t\tEdge e = edges[i];\n\t\tif (!dset.same(e.s, e.d)) {\n\t\t\tmst.push_back(e);\n\t\t\ttotalCost += e.w;\n\t\t\tdset.unite(e.s, e.d);\n\t\t}\n\t}\n\treturn mst;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N, M;\n\tint Case = 0;\n\twhile (cin >> N >> M, N&&M) {\n\t\tmap<int, vector<int>>h;\n\t\trep(i, 0, N) {\n\t\t\tint x; cin >> x;\n\t\t\th[x].eb(i);\n\t\t}\n\t\tEdges es;\n\t\tGraph g(N);\n\t\tloop(M) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--, b--;\n\t\t\tes.eb(a, b, c);\n\t\t\taddEdge(g, a, b, c);\n\t\t}\n\t\tsort(all(es));\n\t\tset<int>st;\n\t\tvector<int>used(N);\n\t\tint cnt = 0;\n\t\tUnionFind uf(N);\n\t\tint ans = 0, n = 0;\n\t\tfor (auto it = h.rbegin(); it != h.rend(); it++) {\n\t\t\tfor (auto v : it->second) {\n\t\t\t\tused[v] = 1;\n\t\t\t\tn++;\n\t\t\t}\n\t\t\tfor (auto e : es) {\n\t\t\t\tif (used[e.s] and used[e.d] and uf.unite(e.s, e.d)) {\n\t\t\t\t\tans += e.w;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt != n - 1) {\n\t\t\t\tuf = UnionFind(N);\n\t\t\t\tcnt = 0;\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t}\n\t\tdump(ans);\n\t\tcout << ans << endl;\n\t\tCase++;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<Int, P> T;\n\nInt u[1080];\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(Int x, Int y){\n\tu[r(x)] = r(y);\n}\nvector<T> edge[1080000];\nInt h[1080];\nbool ok[1080];\nint main(){\n\tInt n, m;\n\twhile(cin >> n >> m, n | m){\n\t\tInt res = 0, bridge = 0, a, b, c, cnt = 0;\n\t\tfor(Int i = 0;i < n;i++){\n\t\t\tcin >> h[i], u[i] = i;\n\t\t\tedge[h[i]].push_back(T(-1, P(i, i)));\n\t\t}\n\t\tfor(Int i = 0;i < m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tedge[min(h[a], h[b])].push_back(T(c, P(a, b)));\n\n\t\t}\n\t\t\n\t\tInt breakpoInt = 1000010;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tfor(int j = 0;j < edge[i].size();j++){\n\t\t\t\ta = edge[i][j].second.first, b = edge[i][j].second.second;\n\t\t\t\tc = edge[i][j].first;\n\t\t\t\tif(c == -1)cnt++;\n\t\t\t\tif(r(a) != r(b)){\n\t\t\t\t\tunite(a, b);\n\t\t\t\t\tbridge++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt - 1 != bridge)breakpoInt = i;\n\t\t}\n\t\tbreakpoInt--;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t}                    \n\t\tbridge = 0;\n\t\tvector<T> tmp;\n\t\tfor(Int i = 0;i < n;i++)u[i] = i;\n\t\tfor(Int i = 1000000;i >= breakpoInt;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\ttmp.push_back(edge[i][j]);\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor(Int i = 0;i < tmp.size();i++){\n\t\t\tInt from = tmp[i].second.first, to = tmp[i].second.second;\n\t\t\tif(r(from) != r(to)){\n\t\t\t\tbridge++;\n\t\t\t\tres += tmp[i].first;\n\t\t\t\tunite(from, to);\n\t\t\t}\n\t\t}                          \n\t\tfor(Int i = breakpoInt;i > 0;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tres += edge[i][j].first;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tif(bridge + 1 != n)res = 0;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v));\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\ntemplate<class T> inline T sq(T a){return a*a;}\ntemplate<class T> T gcd(T m, T n){return n?gcd(n, m%n):m;}\n\nconst int N = 210;\nint par[N];\n\nvoid init(){\n\trep(i, N) par[i] = i;\n}\n\nint find(int x){\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tpar[find(x)]=find(y);\n}\n\nstruct edge{\n\tint from, to, cost;\n\tedge(){}\n\tedge(int f, int t, int c):from(f), to(t), cost(c){}\n\tbool operator<(const edge &r) const{\n\t\treturn cost < r.cost;\n\t}\n};\n\nint h[N];\nedge E[N*N];\nbool used[N*N];\nint G[N][N];\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tinit();\n\t\trep(i, n) cin >> h[i];\n\t\tMEMSET(G, 0);\n\t\tMEMSET(used, 0);\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--, b--;\n\t\t\tE[i] = edge(a, b, c);\n\t\t\tG[a][b] = G[b][a] = 1;\n\t\t}\n\n\t\tpriority_queue<P> q;\n\t\trep(i, n) q.push(MP(h[i], i));\n\t\tbool ok[N] = {};\n\t\tint ans = 0;\n\t\tsort(E, E+m);\n\n\t\tint num = 0;\n\t\tint cnt = 1;\n\t\twhile(!q.empty()){\n\t\t\tint x = q.top().first;\n\t\t\twhile(!q.empty() && x == q.top().first){\n\t\t\t\tnum++;\n\t\t\t\tok[q.top().second] = 1;\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\trep(i, m){\n\t\t\t\tint f = E[i].from, t = E[i].to;\n\t\t\t\tif(!used[i] && ok[f] && ok[t]){\n\t\t\t\t\tif(find(f) == find(t)) continue;\n\t\t\t\t\tunite(f, t);\n\t\t\t\t\tcnt++;\n\t\t\t\t\tans += E[i].cost;\n\t\t\t\t\tused[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt != num){\n\t\t\t\tinit();\n\t\t\t\tMEMSET(used, 0);\n\t\t\t\tans = 0;\n\t\t\t\tcnt = 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// finish date: 2018/07/05\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <climits>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i, n)  FOR(i,0,n)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<long double> vd;\ntypedef vector<vector<long double>> vvd;\ntypedef vector<vector<vector<long double>>> vvvd;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> pii;\nconst int bigmod = 1000000007;\nconst int INF = 1050000000;\n\n\nll prim(int N, vector<vector<pii> > edge) {\n    priority_queue<pii, vector<pii>, greater<pii> > pq;\n    vector<bool> used(N, false);\n    pq.push(pii(0, 0));\n    ll total = 0;\n    while (!pq.empty()) {\n        int dis, t;\n        tie(dis, t) = pq.top();\n        pq.pop();\n        if (used[t]) continue;\n        used[t] = true;\n        total += dis;\n        for (auto e: edge[t]) {\n            if (!used[e.second]) pq.push(e);\n        }\n    }\n    return total;\n}\n\nstruct Union_Find {\n    vi parent;\n    vi sizes;\n    int setnum = 0;\n\n    Union_Find(int n) : parent(n), sizes(n, 1) {\n        rep(i, n) parent[i] = i;\n        setnum = n;\n    }\n\n    int find(int x) {\n        if (x == parent[x]) return x;\n        return parent[x] = find(parent[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n        if (sizes[x] < sizes[y]) swap(x, y);\n\n        parent[y] = x;\n        sizes[x] += sizes[y];\n        setnum--;\n\n    }\n\n    bool isSame(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return sizes[find(x)];\n    }\n};\n\nint main() {\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 && M == 0) break;\n        vvi h(N, vi(2));\n        vvi abc(M, vi(3));\n        rep(i, N) {\n            cin >> h[i][0];\n            h[i][1] = i;\n        }\n        rep(i, M) {\n            cin >> abc[i][0] >> abc[i][1] >> abc[i][2];\n            abc[i][0]--;\n            abc[i][1]--;\n        }\n        map<int, int> numh;\n        rep(i, N) {\n            numh[h[i][0]]++;\n        }\n\n        sort(h.rbegin(), h.rend());\n        map<int, int> tr;\n        rep(i, N) {\n            tr[h[i][1]] = i;\n        }\n\n        rep(i, M) {\n            rep(j, 2) {\n                abc[i][j] = tr[abc[i][j]];\n            }\n        }\n        /*\n        rep(i,N){\n                rep(j,3){\n                        cout<<abc[i][j] << \" \";\n                }\n                cout<<endl;\n        }*/\n\n\n        vvi dist(N, vi(N, INT_MAX));\n        Union_Find uf(N);\n        rep(i, M) {\n            int a = abc[i][0];\n            int b = abc[i][1];\n            int c = abc[i][2];\n            //edge[a].push_back(make_pair(c,b));\n            //edge[b].push_back(make_pair(c,a));\n            dist[a][b] = c;\n            dist[b][a] = c;\n        }\n        //cout<<dist.size();//<<\" \"<<dist[0].size();\n        rep(i, N) dist[i][i] = 0;\n\n        vector<bool> isUF(N, false);\n\n        rep(i, N) {\n            rep(j, i) {\n                if (dist[i][j] != INT_MAX) {\n                    uf.unite(i, j);\n                }\n            }\n            if (uf.setnum == N - i) isUF[i] = true;\n        }\n        if (!isUF[N - 1]) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        int idx = 0;\n        for (int i = N - 1; i > 0; i--) {\n            if (!isUF[i]) {\n                int now = h[i][0];\n                int now_idx = i;\n                idx = i;\n                while (idx < N-1 && h[idx][0] == h[idx + 1][0]) idx++;\n                idx++;\n                while (idx < N-1 && h[idx][0] == h[idx + 1][0]) idx++;\n                idx++;\n                idx = min(idx, N);\n                break;\n            }\n        }\n        rep(i,N) cout<<h[i][0]<<endl;\n\n\n\n        ll ans = 0;\n        idx = 9;\n        if (idx != 0) {\n            vector<vector<pii> > edge(idx);\n            rep(i, idx) {\n                rep(j, idx) {\n                    if (dist[i][j] != INT_MAX) {\n                        edge[i].push_back(make_pair(dist[i][j], j));\n                        edge[j].push_back(make_pair(dist[i][j], i));\n                    }\n                }\n            }\n            ans += prim(idx, edge);\n        }\n        if (idx == 0) idx++;\n        FOR(i, idx, N) {\n            int mi = INT_MAX;\n            rep(j, i) {\n                mi = min(mi, dist[i][j]);\n            }\n            //cout<<i<<\" \"<<mi<<endl;\n            ans += mi;\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> LP;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct UnionFind{ // gomennasai\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nint n,m;\nint d[222][222];\nint h[222];\n\nbool ok(ll x){\n  UnionFind uf(n);\n  int cnt=0;\n  rep(i,n){\n    if(h[i]>=x)cnt++;\n  }\n  rep(i,n)rep(j,n){\n    if(h[i]>=x&&h[j]>=x&&d[i][j]!=INF){\n      uf.unite(i,j);\n    }\n  }\n  rep(i,n){\n    if(h[i]>=x){\n      return uf.size(i)==cnt;\n    }\n  }\n  return false;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    rep(i,n)cin>>h[i];\n    rep(i,n)rep(j,n)d[i][j]=i==j?0:INF;\n    rep(i,m){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--; b--;\n      d[a][b]=d[b][a]=c;\n    }\n    ll lb=0, ub=10000000;\n    rep(hoge,30){\n      ll mid=(lb+ub)/2;\n      if(ok(mid))lb=mid;\n      else ub=mid;\n    }\n    if(lb==0){\n      cout<<0<<endl;\n      continue;\n    }\n    UnionFind uf(n);\n    int nh=lb;\n    int res=0;\n    while(1){\n      priority_queue<LP,vector<LP>,greater<LP> > que;\n      rep(i,n)rep(j,n){\n        if(h[i]>=nh&&h[j]>=nh&&d[i][j]!=INF&&!uf.same(i,j)){\n          que.push(LP(d[i][j],P(i,j)));\n        }\n      }\n      while(que.size()){\n        LP t = que.top(); que.pop();\n        if(!uf.same(t.se.fi,t.se.se)){\n          res+=t.fi;\n          uf.unite(t.se.fi,t.se.se);\n        }\n      }\n      if(uf.size(0)==n)break;\n      int nxt=0;\n      rep(i,n){\n        if(h[i]<nh)maxch(nxt,h[i]);\n      }\n      nh=nxt;\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint h[200], par[200], s[200];\nint find(int x) {\n\tif (par[x] == x)return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = find(x); y = find(y);\n\tpar[y] = x; s[x] += s[y];\n}\nstruct st { int a, b, c; };\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\trep(i, n)scanf(\"%d\", &h[i]);\n\t\tvector<st>v;\n\t\trep(i, m) {\n\t\t\tint a, b, c; scanf(\"%d%d%d\", &a, &b, &c); a--; b--;\n\t\t\tv.push_back({ a,b,c });\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\treturn min(h[a.a], h[a.b]) > min(h[b.a], h[b.b]);\n\t\t});\n\t\tint u = 0;\n\t\tfor (st p : v) {\n\t\t\tif (find(p.a) == find(p.b))continue;\n\t\t\tunite(p.a, p.b);\n\t\t\tif (s[find(p.a)] == n) {\n\t\t\t\tu = min(h[p.a], h[p.b]); break;\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\tint c = min({ u,h[a.a], h[a.b] }), d = min({ u,h[b.a], h[b.b] });\n\t\t\tif (c == d)return a.c < b.c;\n\t\t\treturn c > d;\n\t\t});\n\t\tint res = 0;\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\tfor (st p : v) {\n\t\t\tif (find(p.a) == find(p.b))continue;\n\t\t\tunite(p.a, p.b); res += p.c;\n\t\t}\n\t\tif (s[find(0)] != n)puts(\"0\");\n\t\telse printf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <set>\nusing namespace std;\n#define MAX_V 205\n#define INF 1<<30\nint N, M;\nint cost[MAX_V][MAX_V];\nint H[MAX_V];\n\nint mincost[MAX_V];\nbool used[MAX_V];\nbool Vused[MAX_V][MAX_V];\nint prevV[MAX_V];\n\nint prim(int t){\n\tfor(int i=0;i<N;i++){\n\t\tmincost[i]=INF;\n\t\tused[i] = false;\n\t\tprevV[i] = N;\n\t}\n\tfor(int u=0;u<N;u++){\n\t\tif(H[u]>t){\n\t\t\tmincost[u]=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u=0;u<N;u++){\n\t\t\tif(H[u]>t && !used[u] && (v==-1 || mincost[u] < mincost[v])) v=u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tVused[v][prevV[v]] = Vused[prevV[v]][v] = true;\n\t\tif(mincost[v] >= INF) return INF;\n\t\tres += mincost[v];\n\t\tfor(int u=0;u<N;u++){\n\t\t\tif(H[u] <= t) continue;\n\t\t\tif(Vused[v][u] || Vused[u][v]){\n\t\t\t\tmincost[u] = 0;\n\t\t\t\tprevV[u] = v;\n\t\t\t}\n\t\t\tif(mincost[u] > cost[v][u]){\n\t\t\t\tmincost[u] = cost[v][u];\n\t\t\t\tprevV[u] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nmain(){\n\tint i,j,k,a,b,c;\n\twhile(cin >> N >> M, N){\n\t\tvector<int> broken;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<N;j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t\tVused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tbroken.push_back(0);\n\t\tfor(i=0;i<N;i++){\n\t\t\tcin >> H[i];\n\t\t\tbroken.push_back(H[i]);\n\t\t}\n\n\t\tsort(broken.begin(), broken.end());\n\t\tbroken.erase(unique(broken.begin(), broken.end()), broken.end());\n\t\t\n\t\tfor(i=0;i<M;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a-1][b-1] = cost[b-1][a-1] = c;\n\t\t}\n\n\t\tint co = 0;\n\t\tfor(i=broken.size()-1;i>=0;i--){\n\t\t\tint ret = prim(broken[i]);\n\t\t\tif(ret >= INF){\n\t\t\t\tco = 0;\n\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\tfor(j=0;j<N;j++){\n\t\t\t\t\t\tVused[k][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else co += ret;\n\t\t\tprintf(\"%d %d\\n\", broken[i], co);\n\t\t}\n\t\tcout << co << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int from,to,cost;\n};\nconst int SIZE=1000;\n\nclass UnionFind{\n    vector<int> par,rank;\n    public:\n    UnionFind(int n):par(n),rank(n){\n        iota(par.begin(),par.end(),0);\n    }\n    int find(int x){\n        if(par[x]==x) return x;\n        else par[x]=find(par[x]);\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    void unite(int x,int y){\n        x=find(x),y=find(y);\n        if(rank[x]<rank[y]) par[x]=y;\n        else{\n            if(rank[y]==rank[x]) rank[x]++;\n            par[y]=x;\n        }\n    }\n};\n\nusing Graph=vector<vector<Edge>>;\nint solve(int n,int m){\n    vector<int> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n    {\n    set<int> x;\n    for(int i=0;i<n;i++) x.insert(h[i]);\n    int idx=1;\n    for(auto &e:x){\n        for(int i=0;i<n;i++) if(h[i]==e) h[i]=idx;\n        idx++;\n    }\n    }\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--,b--;\n        g[a].push_back(Edge{a,b,c});\n        g[b].push_back(Edge{b,a,c});\n    }\n    // cerr<<\"Input finished\"<<endl;\n    vector<vector<int>> sinks(SIZE);\n    for(int i=0;i<n;i++) sinks[h[i]].push_back(i);\n    UnionFind u(n);\n    vector<int> land(n,false);\n    vector<int> isok(SIZE);\n    int cnt=-1;\n    for(int t=SIZE-1;t>=0;t--){\n        cnt+=sinks[t].size();\n        for(auto &v:sinks[t]){\n            // cerr<<t<<\" \"<<v<<endl;\n            land[v]=true;\n            for(auto &e:g[v]){\n                // cerr<<\"@\"<<e.from<<\" \"<<e.to<<endl;\n                if(land[e.from] && land[e.to] && !u.same(e.from,e.to)){\n                    // cerr<<\"Hoy\"<<endl;\n                    u.unite(e.from,e.to);\n                    // cerr<<\"Hi\"<<endl;\n                    cnt--;\n                }\n                // cerr<<\"Nui\"<<endl;\n            }\n        }\n        isok[t]=cnt<=0;\n    }\n    // cerr<<\"masaka\"<<endl;\n    int beft=SIZE;\n    for(int i=0;i<SIZE;i++){\n        if(!isok[i]){\n            beft=i;\n            break;\n        }\n    }\n    // cerr<<\"Beft finished \"<<beft<<endl;\n    cnt=0;\n    int res=0;\n    u=UnionFind(n);\n    fill(land.begin(),land.end(),false);\n    vector<Edge> edges;\n    for(int t=beft;t<SIZE;t++){\n        for(auto &v:sinks[t]){\n            land[v]=true;\n            for(auto &e:g[v]){\n                if(land[e.from] && land[e.to]){\n                    edges.push_back(e);\n                }\n            }\n        }\n    }\n    for(int t=beft-1;t>=0;t--){\n        for(auto &v:sinks[t]){\n            land[v]=true;\n            for(auto &e:g[v]){\n                if(land[e.from] && land[e.to]){\n                    edges.push_back(e);\n                }\n            }\n        }\n        sort(edges.begin(),edges.end(),[](Edge lhs,Edge rhs){return lhs.cost<rhs.cost;});\n        for(auto &e:edges){\n            if(!u.same(e.from,e.to)){\n                cnt++;\n                u.unite(e.from,e.to);\n                res+=e.cost;\n            }\n        }\n        edges.clear();\n    }\n    // assert(cnt==n-1);\n    return res;\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        cout<<solve(n,m)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<Int, P> T;\n\nInt u[1080];\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(Int x, Int y){\n\tu[r(x)] = r(y);\n}\nvector<T> edge[1080000];\nInt h[1080];\nbool ok[1080];\nint main(){\n\tInt n, m;\n\twhile(cin >> n >> m, n | m){\n\t\tInt res = 0, bridge = 0, a, b, c, cnt = 0;\n\t\tfor(Int i = 0;i < n;i++){\n\t\t\tcin >> h[i], u[i] = i;\n\t\t\tedge[h[i]].push_back(T(-1, P(i, i)));\n\t\t}\n\t\tfor(Int i = 0;i < m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tedge[min(h[a], h[b])].push_back(T(c, P(a, b)));\n\t\t\tif(h[a] == h[b])unite(a, b);\n\t\t}\n\t\t\n\t\tInt breakpoInt = 1000010;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tfor(int j = 0;j < edge[i].size();j++){\n\t\t\t\ta = edge[i][j].second.first, b = edge[i][j].second.second;\n\t\t\t\tc = edge[i][j].first;\n\t\t\t\tif(c == -1)cnt++;\n\t\t\t\tif(r(a) != r(b)){\n\t\t\t\t\tunite(a, b);\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt != 1)breakpoInt = i;\n\t\t}\n\t\tbreakpoInt--;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t}                    \n\t\tbridge = 0;\n\t\tvector<T> tmp;\n\t\tfor(Int i = 0;i < n;i++)u[i] = i;\n\t\tfor(Int i = 1000000;i >= breakpoInt;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\ttmp.push_back(edge[i][j]);\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor(Int i = 0;i < tmp.size();i++){\n\t\t\tInt from = tmp[i].second.first, to = tmp[i].second.second;\n\t\t\tif(r(from) != r(to)){\n\t\t\t\tbridge++;\n\t\t\t\tres += tmp[i].first;\n\t\t\t\tunite(from, to);\n\t\t\t}\n\t\t}                          \n\t\tfor(Int i = breakpoInt;i > 0;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tres += edge[i][j].first;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tif(bridge + 1 != n)res = 0;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\n//init:O(n).unite,find:(Ack^-1(n,n))\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\n\nvoid solve(int n,int m){\n    static vector<int> t[1000001];\n    rep(i,0,1000001) t[i].clear();\n    rep(i,0,n){\n        int h;\n        cin >> h;\n        t[h].push_back(i);\n    }\n    vector<tuple<int,int,int>> edges;\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(make_tuple(c,a,b));\n    }\n    sort(edges.begin(),edges.end());\n\n    int ans=0;\n    union_find uf(n);\n    vector<bool> f(n);\n    for(int i=1000000; i>=1; --i){\n        if(t[i].empty()) continue;\n\n        rep(j,0,t[i].size()) f[t[i][j]]=true;\n        for(const auto &edge:edges){\n            const int a=get<1>(edge),b=get<2>(edge);\n            if(uf.is_same_group(a,b)) continue;\n            if(!f[a] or !f[b]) continue;\n            uf.unite(a,b);\n            ans+=get<0>(edge);\n        }\n        bool is_connected=true;\n        rep(j,0,n){\n            if(!f[j]) continue;\n            rep(k,j+1,n){\n                if(!f[k]) continue;\n                if(uf.is_same_group(j,k)) continue;\n                is_connected=false;\n                break;\n            }\n        }\n        if(!is_connected){\n            ans=0;\n            uf.init(n);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace EGraph{\n\ttypedef int Cost;Cost CINF=1<<28;\n\tstruct Edge{\n\t\tint from,to;Cost cost;;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost){};\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n}\nusing namespace EGraph;\n\n\nstruct UnionFind{\n    vector<int> par; // 親\n    vector<int> rank; // 木の深さ\n    vector<int> ss;//xの属する集合のサイズ\n    int size;//集合の個数\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){\n            par[x] = y;ss[y]+=ss[x];\n        }else{\n            par[y] = x;ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\n\nvector<int> hs;\nint col(const Edge &e){\n\treturn min(hs[e.from],hs[e.to]);\n}\n\t\nclass CompTDesc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)>col(r);\n\t}\n};\n\nclass CompTAsc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)<col(r);\n\t}\n};\n\nclass CompC{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn l.cost> r.cost;\n\t}\n};\n\n\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tGraph g;\n\tvector<Edge> es;\n\tbool input(){\n\t\tcin >> N >> M;if(N==0 && M==0)return false;\n\t\ths=vector<int>(N);\n\t\tREP(i,N){\n\t\t\tcin >> hs[i];\n\t\t}\n\t\tg=Graph(N);\n\n\t\tes=vector<Edge>();\n\t\tREP(i,M){\n\t\t\tint a,b,c;cin >> a >> b >> c;a--;b--;\n\t\t\tes.push_back(Edge(a,b,c));\n\t\t\tes.push_back(Edge(b,a,c));\n\t\t}\n\t\treturn true;\n\t}\n\tint N,M;\n\tvector<bool> ex;\n\tvoid run(){\n\t\twhile(input()){\n\n\t\t\tsort(ALL(es),CompTDesc());\n\t\t\tUnionFind uf(N);\n\t\t\tint endT=-INF;\n\t\t\tREP(i,2*M){\n\t\t\t\tuf.unite(es[i].from,es[i].to);int T=col(es[i]);\n\t\t\t\twhile(i+1<2*M && T==col(es[i+1])){\n\t\t\t\t\tuf.unite(es[i+1].from,es[i+1].to);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t//check\n\t\t\t\tbool ok=true;\n\t\t\t\tREP(j,N)REP(k,N)if(T<=hs[j] && T<=hs[k] &&  !uf.same(j,k)){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t\tif(ok && endT==-INF){\n\t\t\t\t\tendT=T;\n\t\t\t\t}else if(!ok && endT!=-INF){\n\t\t\t\t\tendT=-INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(endT==-INF){\n\t\t\t\tcout << 0 <<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tCost res=0;\n\t\t\tUnionFind ufc(N);\n\t\t\tpriority_queue<Edge,vector<Edge>,CompC> que;\n\t\t\tint T=endT;\n\t\t\t//end\n\t\t\tREP(i,2*M){\n\t\t\t\tif(endT<=col(es[i]))que.push(es[i]);\n\t\t\t}\n\t\t\t//cruskal\n\t\t\twhile(!que.empty()){\n\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\t//\tDUMP(e.to);DUMP(ufc.same(e.from,e.to));\n\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\tres+=e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//reflesh\n\t\t\tREP(i,2*M){\n\t\t\t\tif(col(es[i])<T){\n\t\t\t\t\tT=col(es[i]);que.push(es[i]);\n\t\t\t\t}\n\t\t\t\twhile(i+1<2*M && T==col(es[i+1])){\n\t\t\t\t\tque.push(es[i+1]);i++;\n\t\t\t\t}\n\t\t\t\t//cruskal\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\t\tres+=e.cost;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t\tcout <<res<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define s second\n#define f first\n#define INF 1e9\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> iP;\nint n,m,e[201][201],h[201],used2[201],E[201][201];\nP h2[201];\n\nint prim(int cnt,int f[201][201]){\n  int res=0,used[201]={};\n  priority_queue <iP,vector<iP>,greater<iP> > Q;\n  for(int i=0;i<n&&Q.empty();i++)if(!used2[i])Q.push(iP(0,P(i,i)));\n\n  while(!Q.empty()){\n    iP t=Q.top();Q.pop();\n    int pos=t.s.f,cost=t.f,pre=t.s.s;\n    if(used[pos]||used2[pos])continue;\n    used[pos]=1,cnt++,res+=cost;\n    if(pos!=pre) E[pos][pre]=E[pre][pos]=cost;\n    for(int i=0;i<n;i++)\n      if(f[pos][i]!=INF)Q.push(iP(f[pos][i],P(i,pos)));\n  }\n  if(cnt==n)return res+1;\n  return 0;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=E[i][j]=INF;\n    for(int i=0;i<n;i++) cin>>h2[i].f,h2[i].s=i,h[i]=h2[i].f;\n    sort(h2,h2+n);\n    for(int i=0,a,b,c;i<m;i++) cin>>a>>b>>c,e[--a][--b]=e[b][a]=c;\n\n    int res=0,ans=0;\n    memset(used2,0,sizeof(used2));\n    for(int k=0;k<n;k++){\n      res=prim(k,e);\n      for(int i=0;i<n;i++){\n\tint I=h2[i].s,mn=INF,sum=0,H,J;\n\tif(used2[I])continue;\n\tused2[I]=1;\n\tfor(int j=0;j<n;j++)\n\t  if(E[I][j]!=INF){\n\t    sum+=E[I][j];\n\t    if(mn>E[I][j]) H=h[j],J=j;\n\t    mn=min(mn,E[I][j]);\n\t  }\n\tif(prim(k+1,E))ans+=sum;\n\telse{\n\t  for(int j=0;j<n&&H==h[I];j++)e[J][j]=e[j][J]=min(e[J][j],E[I][j]);\n\t  if(!prim(k+1,e)) {\n\t    ans+=res-1,k=n;\n\t    break;\n\t  }\n\t  ans+=mn;\n\t}\n\tbreak;\n      }\n      for(int i=0;i<n;i++)for(int j=0;j<n;j++)E[i][j]=INF;\n    }\n    cout <<max(ans,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nvector<int> compress(vector<int> &a){\n    vector<int> b = a, res(a.size());\n    sort(b.begin(), b.end());\n    b.erase(unique(b.begin(), b.end()), b.end());\n    for(int i = 0; i < a.size(); i++){\n        res[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin();\n    }\n    return res;\n}\n\nstruct UF{\n    vector<int> par;\n    vector<int> sz;\n    UF(){}\n    UF(int n){\n        par.resize(n);\n        sz.resize(n, 1);\n        rep(i, 0, n) par[i] = i;\n    }\n    int find(int x){\n        if(x == par[x]) return x;\n        return par[x] = find(par[x]);\n    }\n    void unite(int x, int y){\n        x = find(x); y = find(y);\n        if(x == y) return;\n        if(sz[x] < sz[y]) swap(x, y);\n        sz[x] += sz[y];\n        par[y] = x;\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nstruct edge{\n    int u, v, c;\n    bool operator<(const edge &e)const{\n        return c < e.c;\n    }\n};\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n){\n        vector<int> hi(n);\n        rep(i, 0, n) cin >> hi[i];\n        vector<int> h = compress(hi);\n        int T = *max_element(h.begin(), h.end());\n        vector<edge> es(m);\n        rep(i, 0, m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            es[i] = {a, b, c};\n        }\n        sort(es.begin(), es.end());\n        int edt = T;\n        for(int i = 0; i <= T; i++){\n            UF uf(n);\n            rep(j, 0, es.size()){\n                int u = es[j].u;\n                int v = es[j].v;\n                if(h[u] >= i && h[v] >= i){\n                    if(!uf.same(u, v)){\n                        uf.unite(u, v);\n                    }\n                }\n            }\n            bool f = true;\n            int root = -1;\n            rep(j, 0, n){\n                if(h[j] >= i){\n                    if(root == -1) root = uf.find(j);\n                    else{\n                        if(!uf.same(root, j)) f = false;\n                    }\n                }\n            }\n            if(!f){\n                edt = i - 1; break;\n            }\n        }\n        // cout << \" \" << edt << endl;\n        int ans = 0;\n        UF uf(n);\n        bool f = true;\n        for(int i = edt; i >= 0; i--){\n            rep(j, 0, es.size()){\n                int u = es[j].u;\n                int v = es[j].v;\n                if(h[u] >= i && h[v] >= i){\n                    if(!uf.same(u, v)){\n                        uf.unite(u, v);\n                        ans += es[j].c;\n                    }\n                }\n            }\n            int root = -1;\n            rep(j, 0, n){\n                if(h[j] >= i){\n                    if(root == -1) root = uf.find(j);\n                    else{\n                        if(!uf.same(root, j)) f = false;\n                    }\n                }\n            }\n        }\n        if(!f) cout << 0 << endl;\n        else cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint h[200], par[200], s[200];\nint find(int x) {\n\tif (par[x] == x)return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = find(x); y = find(y);\n\tif (x == y)return;\n\tpar[y] = x; s[x] += s[y];\n}\nstruct st { int a, b, c; };\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\tvector<int>t;\n\t\trep(i, n)scanf(\"%d\", &h[i]), t.push_back(h[i]);\n\t\tsort(t.begin(), t.end());\n\t\tvector<st>v;\n\t\trep(i, m) {\n\t\t\tint a, b, c; scanf(\"%d%d%d\", &a, &b, &c); a--; b--;\n\t\t\tv.push_back({ a,b,c });\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\treturn min(h[a.a], h[a.b]) > min(h[b.a], h[b.b]);\n\t\t});\n\t\tint u = INT_MAX;\n\t\trep(i, v.size()) {\n\t\t\tunite(v[i].a, v[i].b);\n\t\t\tint c = min(h[v[i].a], h[v[i].b]);\n\t\t\tif (i + 1 == v.size() || c != min(h[v[i + 1].a], h[v[i + 1].b])) {\n\t\t\t\tint p = lower_bound(t.begin(), t.end(), c) - t.begin();\n\t\t\t\tif (n - p != s[find(v[i].a)]) {\n\t\t\t\t\tif (i + 1 == v.size())u = 0;\n\t\t\t\t\telse u = min(h[v[i + 1].a], h[v[i + 1].b]);\n\t\t\t\t}\n\t\t\t\tif (n - p < s[find(v[i].a)])abort();\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\tint c = min({ u,h[a.a], h[a.b] }), d = min({ u,h[b.a], h[b.b] });\n\t\t\tif (c == d)return a.c < b.c;\n\t\t\treturn c > d;\n\t\t});\n\t\tint res = 0;\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\tfor (st p : v) {\n\t\t\tif (find(p.a) == find(p.b))continue;\n\t\t\tunite(p.a, p.b); res += p.c;\n\t\t}\n\t\tif (s[find(0)] != n)puts(\"0\");\n\t\telse printf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\n\nstruct UnionFind{\n    \n    vector<int> M_par;\n    vector<int> M_rank;\n    vector<int> M_size;\n\nprivate:\n    void init(int n = 1){\n        M_par.resize(n);\n        M_rank.resize(n);\n        M_size.resize(n);\n        for(int i = 0; i < n; i++){\n            M_par[i] = i;\n            M_rank[i] = 0;\n            M_size[i] = 1;\n        }\n    }\n\npublic:\n\n    UnionFind(size_t n = 1){\n        init(n);\n    }\n\n    size_t find(size_t x){\n        if(M_par[x] == x) return x;\n        size_t r = find(M_par[x]);\n        return M_par[x] = r;\n    }\n    \n    bool same(size_t x, size_t y){\n        return find(x) == find(y);\n    }\n\n    bool unite(size_t x, size_t y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(M_rank[x] < M_rank[y]) swap(x, y);\n        if(M_rank[x] == M_rank[y]) M_rank[x]++;\n        M_par[y] = x;\n        M_size[x] = M_size[x] + M_size[y];\n        return true;\n    }\n\n    size_t size(size_t x){\n        return M_size[find(x)];\n    }\n\n};\n\nstruct edge{\n    \n    int x, y, c;\n    edge(int x, int y, int c):x(x), y(y), c(c){}\n    edge(){}\n    bool operator<(const edge &a) const{\n        return c < a.c;\n    }\n};\n\n\nsigned main(){\n\n    while(1){\n        int n, m; cin >> n >> m;\n        if(n == 0) break;\n\n        vector<pair<int, int>> time(n);\n        for(int i = 0; i < n; i++){\n            int h; cin >> h;\n            time[i] = {h, i};\n        }\n\n        sort(time.rbegin(), time.rend());\n        \n        vector<edge> bridge(m);\n        for(int i = 0; i < m; i++){\n            int a, b, c; cin >> a >> b >> c;\n            a--; b--;\n            bridge[i] = edge(a, b, c);\n        }\n        sort(bridge.begin(), bridge.end());\n\n        UnionFind uf(n);\n        vector<bool> usable(n, false);\n        int ans = 0;\n\n        for(int i = 0; i < n; i++){\n            usable[time[i].second] = true;\n            while(i + 1 < n && time[i].first == time[i + 1].first){\n                i++;\n                usable[time[i].second] = true;\n            }\n            for(int j = 0; j < m; j++){\n                edge e = bridge[j];\n                if(usable[e.x] && usable[e.y] && uf.find(e.x) != uf.find(e.y)){\n                    ans += e.c;\n                    uf.unite(e.x, e.y);\n                }\n            }\n            int root = -1;\n            for(int j = 0; j < n; j++){\n                if(usable[j]){\n                    if(root != -1 && root != uf.find(j)){\n                        ans = 0;\n                        uf = UnionFind(n);\n                    }\n                    if(root == -1) root = uf.find(j);\n                }\n            }\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <functional>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef pair<P, P> WP;\ntypedef long long ll;\n\nconst ll INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\nstruct UnionFind{\n\tvector<int> data;\n\tUnionFind(int size) :data(size, -1){}\n\n\tbool set(int x, int y){\n\t\tx = root(x), y = root(y);\n\t\tif (x != y){\n\t\t\tif (data[x] > data[y])swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x){\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x){\n\t\treturn -data[root(x)];\n\t}\n\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m && n){\n\t\tmap<int, vector<int>> hm;\n\t\thm[0].push_back(0);\n\t\tFor(i, 1, n + 1){\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\thm[h].push_back(i);\n\t\t}\n\t\tvector<T> v;\n\t\t\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv.push_back(T(c, a, b));\n\t\t}\n\t\tsort(all(v));\n\n\t\tint d[201][201];\n\t\trep(i, 201)rep(j, 201)d[i][j] = (i == j ? 1 : 0);\n\n\t\tvector<vector<int>> tv;\n\t\tfor (auto target : hm){\n\t\t\tauto t = target.second;\n\t\t\ttv.push_back(t);\n\n\t\t\tUnionFind uf(n+1);\n\t\t\trep(i, t.size()){\n\t\t\t\tFor(j, 1, n + 1){\n\t\t\t\t\td[t[i]][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f[201]; clr(f);\n\t\t\tFor(i, 1, n + 1){\n\t\t\t\tf[i] = true;\n\t\t\t\tqueue<int> q;\n\t\t\t\tq.push(i);\n\t\t\t\twhile (q.size()){\n\t\t\t\t\tint now = q.front(); q.pop();\n\t\t\t\t\tFor(j, 1, n + 1){\n\t\t\t\t\t\tif (d[now][j] && !f[j]){\n\t\t\t\t\t\t\tf[j] = true;\n\t\t\t\t\t\t\tq.push(j);\n\t\t\t\t\t\t\tuf.set(now, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,v.size()){\n\t\t\t\tT nx = v[i];\n\t\t\t\tint c = get<0>(nx), a = get<1>(nx), b = get<2>(nx);\n\t\t\t\tif (!uf.find(a, b) && d[a][a] && d[b][b]){\n\t\t\t\t\tuf.set(a, b);\n\t\t\t\t\td[a][b] = d[b][a] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ef = false;\n\t\t\tFor(j, 1, n + 1){\n\t\t\t\tif (d[j][j]){\n\t\t\t\t\tFor(i, 1, n + 1){\n\t\t\t\t\t\tif (!uf.find(j, i) && d[i][i]){\n\t\t\t\t\t\t\tef = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ef){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tUnionFind uf(n + 1);\n\t\tfor (int j = tv.size() - 1; j >= 1; j--){\n\t\t\trep(k, tv[j].size()){\n\t\t\t\td[tv[j][k]][tv[j][k]] = 1;\n\t\t\t}\n\n\t\t\trep(i, v.size()){\n\t\t\t\tT nx = v[i];\n\t\t\t\tint c = get<0>(nx), a = get<1>(nx), b = get<2>(nx);\n\t\t\t\tif (!uf.find(a, b) && d[a][a] && d[b][b]){\n\t\t\t\t\tuf.set(a, b);\n\t\t\t\t\td[a][b] = d[b][a] = 1;\n\t\t\t\t\tans += c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<int, int> P;\n\nusing Weight = int;\nstruct Edge {\n\tint src, dst; Weight weight;\n\tEdge() {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\n\nstruct UnionFind {\n\tvector<int> par;\n\tint cnt;\n\tUnionFind(int size_) : par(size_, -1), cnt(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif((x = find(x)) != (y = find(y))) {\n\t\t\tif(par[y] < par[x]) swap(x, y);\n\t\t\tpar[x] += par[y]; par[y] = x; cnt--;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tint size(int x) { return -par[find(x)]; }\n\tint size() { return cnt; }\n};\n\nbool operator < (const Edge &e, const Edge &f) { return e.weight < f.weight; }\n\nconst int MAX = (int)1e6 + 10;\nvector<int> x[MAX];\nint alive[200];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M;\n\twhile(cin >> N >> M, N) {\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tx[t].push_back(i);\n\t\t}\n\n\t\tvector<Edge> es;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--, b--;\n\t\t\tes.push_back({ a, b ,c });\n\t\t}\n\t\tsort(es.begin(), es.end());\n\n\t\t{\n\t\t\tUnionFind uf(N);\n\t\t\tfor(auto e : es) {\n\t\t\t\tuf.unite(e.src, e.dst);\n\t\t\t}\n\t\t\tif(uf.size(0) != N) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tint last = -1;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\talive[i] = 1;\n\t\t}\n\t\tfor(int t = 0; t < MAX; t++) {\n\t\t\tif(x[t].size() == 0) continue;\n\t\t\tfor(auto v : x[t]) {\n\t\t\t\talive[v] = 0;\n\t\t\t}\n\t\t\tUnionFind uf(N);\n\t\t\tfor(auto e : es) {\n\t\t\t\tif(alive[e.src] && alive[e.dst]) uf.unite(e.src, e.dst);\n\t\t\t}\n\t\t\tint sz = 1;\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(!alive[j]) sz++;\n\t\t\t}\n\t\t\tif(uf.size() != sz) {\n\t\t\t\tlast = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\talive[i] = 0;\n\t\t}\n\n\t\tUnionFind uf(N);\n\t\tint ans = 0;\n\t\tfor(int t = last; t < MAX; t++) {\n\t\t\tif(x[t].size() == 0) continue;\n\n\t\t\tfor(auto v : x[t]) {\n\t\t\t\talive[v] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(auto e : es) {\n\t\t\tif(alive[e.src] && alive[e.dst] && !uf.same(e.src, e.dst)) {\n\t\t\t\tuf.unite(e.src, e.dst);\n\t\t\t\tans += e.weight;\n\t\t\t}\n\t\t}\n\t\tfor(int t = last - 1; t >= 0; t--) {\n\t\t\tif(x[t].size() == 0) continue;\n\n\t\t\tfor(auto v : x[t]) {\n\t\t\t\talive[v] = 1;\n\t\t\t}\n\t\t\tfor(auto e : es) {\n\t\t\t\tif(alive[e.src] && alive[e.dst] && !uf.same(e.src, e.dst)) {\n\t\t\t\t\tuf.unite(e.src, e.dst);\n\t\t\t\t\tans += e.weight;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct Edge{\n    int from,to;\n    int cost;\n};\n\nbool operator>(Edge& lhs,Edge &rhs){\n    return lhs.cost>rhs.cost;\n}\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\nint solve(int n,int m,vector<int>& h,vector<int>& a,vector<int> &b,vector<int> &c){\n    vector<int> used(n,false);\n    vector<vector<Edge>> vec(1e6+1);\n    for(int i=0;i<m;i++){\n        vec[min(h[a[i]],h[b[i]])].push_back(Edge{a[i],b[i],c[i]});\n    }\n    int res=0;\n    bool start=true;\n    priority_queue<Edge,vector<Edge>,greater<>> que;\n    Graph g(n);\n    vector<int> wuse(n,false);\n    vector<int> tank;\n    for(int i=1e6;i>=0;i--){\n        if(start && vec[i].size()!=0){\n            int v=vec[i][0].from;\n            used[v]=true;\n            wuse[v]=true;\n            start=false;\n            tank.push_back(v);\n        }\n        int cnt=0;\n        for(int j=0;j<vec[i].size();j++){\n            int v0=vec[i][j].from;\n            int v1=vec[i][j].to;\n            tank.push_back(v0);\n            tank.push_back(v1);\n            if(!wuse[v0]){\n                cnt++;\n                wuse[v0]=true;\n            }\n            if(!wuse[v1]){\n                cnt++;\n                wuse[v1]=true;\n            }\n            if(used[v0] && !used[v1]){\n                que.push(Edge{v0,v1,vec[i][j].cost});\n            }\n            if(used[v1] && !used[v0]){\n                que.push(Edge{v1,v0,vec[i][j].cost});\n            }\n            g[v0].push_back(Edge{v0,v1,vec[i][j].cost});\n            g[v1].push_back(Edge{v1,v0,vec[i][j].cost});\n        }\n        while(!que.empty()){\n            Edge ret=que.top(); que.pop();\n            int v0=ret.from;\n            int v1=ret.to;\n            if(used[v0] && used[v1]) continue;\n            if(used[v1]) swap(v0,v1);\n            used[v1]=true;\n            cnt--;\n            res+=ret.cost;\n            for(int j=0;j<g[v1].size();j++){\n                que.push(g[v1][j]);\n            }\n        }\n        if(cnt>0){\n            res=0;\n            for(int j=0;j<tank.size();j++){\n                used[tank[j]]=false;\n            }\n            start=true;\n            tank.clear();\n        }\n    }\n\n    return res;\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        vector<int> h(n);\n        for(int i=0;i<n;i++){\n            cin>>h[i];\n        }\n        vector<int> a(m),b(m),c(m);\n        for(int i=0;i<m;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            a[i]--,b[i]--;\n        }\n        \n        cout<<solve(n,m,h,a,b,c)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n/*????????§???*/\n\nint p[502],p2[502];\nint r[502],r2[502];\n\nvoid init(int n){\n    for (int i = 0; i < n; ++i) {\n        p[i]=i;\n        r[i]=0;\n    }\n}\n\n\nint find(int x){\n\tif(x != p[x]){\n\t\tp[x] = find(p[x]);\n    }\n   \treturn p[x];\n}\n     \nvoid union_set(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x==y) return;\n\tif(r[x] < r[y]){\n\t\tp[x] = y;\t\n\t}else{\n\t\tp[y] = x;\n\t\tif(r[x] == r[y])r[x]++;\n\t}\n\treturn ;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m &&n!=0){\n\t\tll ans = 0;\n\t\tvector<int>t(n);\n\t\trep(i,n){\n\t\t\tcin >> t[i];\n\t\t}\n\t\tvector<pair<int,int> > v(n);\n\t\trep(i,n){\n\t\t\tv[i] = MP(t[i],i);\n\t\t}\n\t\tsort(v.begin(),v.end(),greater<pair<int,int> >());\n\t\tvector<set<int> >vst;\n\t\tset<int>st;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==n-1){\n\t\t\t\tst.insert(v[i].second);\n\t\t\t\tvst.PB(st);\n\t\t\t}else{\n\t\t\t\tst.insert(v[i].second);\n\t\t\t\tif(v[i].second!=v[i+1].second){\n\t\t\t\t\tvst.PB(st);\n\t\t\t\t\tst.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<pair<ll,pair<int,int > > >node;\n\t\tinit(502);\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tll c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tnode.PB(MP(c,MP(a,b)));\n\t\t}\n\t\tsort(node.begin(),node.end());\n\t\tset<int>nst;\n\t\tvector<bool>flag(n);\n\t\tint cnt=0;\n\t\tint nod=0;\n\t\tfor(int i=0;i<vst.size();i++){\n\t\t\tfor(auto x:vst[i]){\n\t\t\t\tnst.insert(x);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tfor(auto x:node){\n\t\t\t\tif(nst.count(x.second.first)!=0&&nst.count(x.second.second)!=0){\n\t\t\t\t\tif(find(x.second.first)!=find(x.second.second)){\n\t\t\t\t\t\tans += x.first;\n\t\t\t\t\t\tunion_set(x.second.first,x.second.second);\n\t\t\t\t\t\tnod++;\n\t\t\t\t\t\t//cout << x.second.first << \" \" << x.second.second << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nod!=n-1){\n\t\t\tans = 0;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <set>\nusing namespace std;\n#define MAX_V 205\n#define INF 1<<30\nint N, M;\nint cost[MAX_V][MAX_V];\nint H[MAX_V];\n\nint mincost[MAX_V];\nbool used[MAX_V];\nbool Vused[MAX_V][MAX_V];\nint prevV[MAX_V];\n\nint prim(int t){\n\tfor(int i=0;i<N;i++){\n\t\tmincost[i]=INF;\n\t\tused[i] = false;\n\t\tprevV[i] = N;\n\t}\n\tfor(int u=0;u<N;u++){\n\t\tif(H[u]>t){\n\t\t\tmincost[u]=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u=0;u<N;u++){\n\t\t\tif(H[u]>t && !used[u] && (v==-1 || mincost[u] < mincost[v])) v=u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tVused[v][prevV[v]] = Vused[prevV[v]][v] = true;\n\t\tif(mincost[v] >= INF) return INF;\n\t\tres += mincost[v];\n\t\tfor(int u=0;u<N;u++){\n\t\t\tif(H[u] <= t) continue;\n\t\t\tif(Vused[v][u] || Vused[u][v]){\n\t\t\t\tmincost[u] = 0;\n\t\t\t\tprevV[u] = v;\n\t\t\t}\n\t\t\tif(mincost[u] > cost[v][u]){\n\t\t\t\tmincost[u] = cost[v][u];\n\t\t\t\tprevV[u] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nmain(){\n\tint i,j,k,a,b,c;\n\twhile(cin >> N >> M, N){\n\t\tvector<int> broken;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<N;j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t\tVused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tbroken.push_back(0);\n\t\tfor(i=0;i<N;i++){\n\t\t\tcin >> H[i];\n\t\t\tbroken.push_back(H[i]);\n\t\t}\n\n\t\tsort(broken.begin(), broken.end());\n\t\tbroken.erase(unique(broken.begin(), broken.end()), broken.end());\n\t\t\n\t\tfor(i=0;i<M;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a-1][b-1] = cost[b-1][a-1] = c;\n\t\t}\n\n\t\tint co = 0;\n\t\tfor(i=broken.size()-1;i>=0;i--){\n\t\t\tint ret = prim(broken[i]);\n\t\t\tif(ret >= INF){\n\t\t\t\tco = 0;\n\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\tfor(j=0;j<N;j++){\n\t\t\t\t\t\tVused[k][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else co += ret;\n\t\t}\n\t\tcout << co << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\n\nll n, m, h, a, b, c;\nP p[200];\nQ d[40000];\nbool ok[200];\n\nclass UF {\npublic:\n  ll par[200], depth[200];\n  UF() {\n    for (ll i = 0; i < n; i++) par[i] = i, depth[i] = 0;\n  }\n  void clear() {\n    for (ll i = 0; i < n; i++) par[i] = i, depth[i] = 0;\n  }\n  ll find(ll x) { return x == par[x] ? x : par[x] = find(par[x]); }\n  void merge(ll x, ll y) {\n    x = find(x), y = find(y);\n    if (x == y) return;\n    if (depth[x] < depth[y]) par[x] = y;\n    else if (depth[x] > depth[y]) par[y] = x;\n    else par[x] = y, depth[y]++;\n  }\n  bool same(ll x, ll y) { return find(x) == find(y); }\n  void copy(const UF& uf) {\n    for (ll i = 0; i < n; i++) par[i] = uf.par[i], depth[i] = uf.depth[i];\n  }\n};\n\nint main() {\n  while (scanf(\"%lld%lld\", &n, &m), n) {\n    for (ll i = 0; i < n; i++) scanf(\"%lld\", &h), p[i] = P(h, i), ok[i] = false;\n    sort(p, p+n, greater<P>());\n    UF uf;\n    for (ll i = 0; i < m; i++) {\n      scanf(\"%lld%lld%lld\", &a, &b, &c);\n      a--; b--;\n      d[i] = Q(c, P(a, b));\n    }\n    sort(d, d+m);\n    ll ans = 0, counter = 0;\n    for (ll i = 0; i < n; i++) {\n      ll num = p[i].second;\n      ok[num] = true;\n      if (i == n-1 || p[i].first != p[i+1].first) {\n        ll tempans = 0, tempcounter = 0;\n        for (ll j = 0; j < m; j++) {\n          Q q = d[j];\n          ll from = q.second.first, to = q.second.second;\n          if (ok[from] && ok[to] && !uf.same(from, to)) {\n            uf.merge(from, to);\n            tempans += q.first;\n            tempcounter++;\n          }\n        }\n        if (counter + tempcounter == i) {\n          ans += tempans;\n          counter += tempcounter;\n        } else uf.clear(), ans = counter = 0;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint root[200];\nint size[200];\n\nint getRoot(int v){ return root[v]==-1 ? v : root[v] = getRoot(root[v]); }\n\nint main(){\n\tint N, M;\n\tint height[200];\n\twhile(cin >> N >> M && N){\n\t\tvector< vector< pair<int,int> > > g(N);\n\t\tvector< pair<int, int> > h;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> height[i];\n\t\t\th.push_back(make_pair(height[i], i));\n\t\t}\n\t\tsort(h.rbegin(), h.rend());\n\t\tint lastIdx = h[0].second;\n\t\tint sep = h[0].first+1;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\tg[a-1].push_back(make_pair(b-1,c));\n\t\t\tg[b-1].push_back(make_pair(a-1,c));\n\t\t}\n\t\tmemset(root, -1, sizeof(root));\n\t\tfor(int i=0;i<N;i++) size[i] = 1;\n\t\tfor(int i=0;i<N; ){\n\t\t\tint curTime = h[i].first;\n\t\t\twhile(i<N && h[i].first == curTime){\n\t\t\t\tint idx = h[i].second;\n\t\t\t\tfor(int j=0;j<g[idx].size();j++){\n\t\t\t\t\tif(height[g[idx][j].first] < curTime) continue;\n\t\t\t\t\tint p = getRoot(idx);\n\t\t\t\t\tint q = getRoot(g[idx][j].first);\n\t\t\t\t\tif(p!=q){\n\t\t\t\t\t\tsize[p] += size[q];\n\t\t\t\t\t\troot[q] = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(size[getRoot(lastIdx)] != i) sep = curTime;\n\t\t}\n\t\tif(sep == h.back().first){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint res = 0;\n\t\tmemset(root, -1, sizeof(root));\n\t\tfor(int i=0;i<N; ){\n\t\t\tvector< pair<int, pair<int,int> > > vp;\n\t\t\twhile(i<N && h[i].first >= sep){\n\t\t\t\tint idx = h[i].second;\n\t\t\t\tfor(int j=0;j<g[idx].size();j++)\n\t\t\t\t\tvp.push_back(make_pair(g[idx][j].second, make_pair(idx, g[idx][j].first)));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tint curTime = h[i].first;\n\t\t\twhile(i<N && h[i].first == curTime){\n\t\t\t\tint idx = h[i].second;\n\t\t\t\tfor(int j=0;j<g[idx].size();j++)\n\t\t\t\t\tvp.push_back(make_pair(g[idx][j].second, make_pair(idx, g[idx][j].first)));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tsort(vp.begin(), vp.end());\n\t\t\tfor(int j=0;j<vp.size();j++){\n\t\t\t\tif(height[vp[j].second.second] < curTime) continue;\n\t\t\t\tint p = getRoot(vp[j].second.first);\n\t\t\t\tint q = getRoot(vp[j].second.second);\n\t\t\t\tif(p != q){\n\t\t\t\t\tres += vp[j].first;\n\t\t\t\t\troot[q] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<Int, P> T;\n\nInt u[1080];\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(Int x, Int y){\n\tu[r(x)] = r(y);\n}\nvector<T> edge[1080000];\nInt h[1080];\nbool come[1080];\nint main(){\n\tInt n, m;\n\twhile(cin >> n >> m, n | m){\n\t\tInt res = 0, bridge = 0, a, b, c, cnt = 0;\n\t\tfor(Int i = 0;i < n;i++)cin >> h[i], u[i] = i, come[i] = false;\n\t\tfor(Int i = 0;i < m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tedge[min(h[a], h[b])].push_back(T(c, P(a, b)));\n\t\t}\n\t\tInt breakpoInt = 1000010;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tif(!come[from])cnt++, come[from] = true;\n\t\t\t\t\tif(!come[to])cnt++, come[to] = true;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt && cnt - 1 != bridge){\n\t\t\t\tbreakpoInt = i;\n\t\t\t}\n\t\t}                    \n\t\tbridge = 0;\n\t\tvector<T> tmp;\n\t\tfor(Int i = 0;i < n;i++)u[i] = i;\n\t\tif(breakpoInt)breakpoInt--;\n\t\tfor(Int i = 1000000;i >= breakpoInt;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\ttmp.push_back(edge[i][j]);\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor(Int i = 0;i < tmp.size();i++){\n\t\t\tInt from = tmp[i].second.first, to = tmp[i].second.second;\n\t\t\tif(r(from) != r(to)){\n\t\t\t\tbridge++;\n\t\t\t\tres += tmp[i].first;\n\t\t\t\tunite(from, to);\n\t\t\t}\n\t\t}\n\t\tfor(Int i = breakpoInt;i > 0;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tres += edge[i][j].first;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tedge[i].clear();\n\t\t}\n\t\tif(bridge + 1 != n)res = 0;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind{\n    int num;\n    vector<int> par,rank;\n    UnionFind(int n):num(n),par(n),rank(n,1){\n        iota(par.begin(),par.end(),0);\n    }\n    int root(int x){\n        return (par[x]==x?x:par[x]=root(par[x]));\n    }\n    bool merge(int x, int y){\n        x=root(x),y=root(y);\n        if (x==y) return false;\n        if (rank[x]<rank[y]) swap(x,y);\n        par[y]=x;\n        rank[x]+=rank[y];\n        --num;\n        return true;\n    }\n    bool same(int x, int y){return root(x)==root(y);}\n    int size(int x){return rank[root(x)];}\n    int count(){return num;}\n};\n\nint N,M;\n\nvoid solve(){\n    vector<pair<int,int>> H;\n    for (int i=0;i<N;++i){\n        int h; cin >> h;\n        H.emplace_back(h,i);\n    }\n    sort(H.begin(),H.end(),[](auto a,auto b){return a>b;});\n    struct edge{\n        int a,b,c;\n        edge(int a,int b,int c):a(a),b(b),c(c){}\n        const bool operator<(const edge &other) const {\n            return c<other.c;\n        }\n    };\n    vector<edge> es;\n    for (int i=0;i<M;++i){\n        int a,b,c; cin >> a >> b >> c;\n        es.emplace_back(--a,--b,c);\n    }\n    sort(es.begin(),es.end());\n    vector<int> used(M,0);\n    UnionFind uf(N);\n    set<int> alive;\n    int ans=0;\n    for (int i=0;i<N;++i){\n        while(i+1<N&&H[i+1].first==H[i].first) alive.emplace(H[i++].second);\n        alive.emplace(H[i].second);\n        UnionFind uf2(N);\n        for (int i=0;i<M;++i){\n            if (!alive.count(es[i].a)||!alive.count(es[i].b)) continue;\n            uf2.merge(es[i].a,es[i].b);\n        }\n        int p=-1,ok=1;\n        for (int v:alive){\n            if (p<0) p=uf2.root(v);\n            if (p!=uf2.root(v)) ok=0;\n        }\n        if (!ok){\n            for (int i=0;i<M;++i) used[i]=0;\n            for (int i=0;i<N;++i){\n                uf.par[i]=i; uf.rank[i]=1;\n            }\n            ans=0; continue;\n        }\n        for (int i=0;i<M;++i){\n            if (!alive.count(es[i].a)||!alive.count(es[i].b)) continue;\n            if (!used[i]&&uf.merge(es[i].a,es[i].b)){\n                used[i]=1;\n                ans+=es[i].c;\n            }\n        }\n    }\n    cout << ans << '\\n';\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M,N){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <set>\nusing namespace std;\n#define MAX_V 205\n#define INF 1<<30\nint N, M;\nint cost[MAX_V][MAX_V];\nint H[MAX_V];\n\nint mincost[MAX_V];\nbool used[MAX_V];\nbool Vused[MAX_V][MAX_V];\nint prevV[MAX_V];\n\nint prim(int t){\n\tfor(int i=0;i<N;i++){\n\t\tmincost[i]=INF;\n\t\tused[i] = false;\n\t\tprevV[i] = N;\n\t}\n\tfor(int u=0;u<N;u++){\n\t\tif(H[u]>t){\n\t\t\tmincost[u]=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u=0;u<N;u++){\n\t\t\tif(H[u]>t && !used[u] && (v==-1 || mincost[u] < mincost[v])) v=u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tVused[v][prevV[v]] = Vused[prevV[v]][v] = true;\n\t\tif(mincost[v] >= INF) return INF;\n\t\tres += mincost[v];\n\t\tfor(int u=0;u<N;u++){\n\t\t\tif(H[u] <= t) continue;\n\t\t\tif(Vused[v][u] || Vused[u][v]){\n\t\t\t\tmincost[u] = 0;\n\t\t\t\tprevV[u] = v;\n\t\t\t}\n\t\t\tif(mincost[u] > cost[v][u]){\n\t\t\t\tmincost[u] = cost[v][u];\n\t\t\t\tprevV[u] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nmain(){\n\tint i,j,k,a,b,c;\n\twhile(cin >> N >> M, N){\n\t\tvector<int> broken;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<N;j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t\tVused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tbroken.push_back(0);\n\t\tfor(i=0;i<N;i++){\n\t\t\tcin >> H[i];\n\t\t\tbroken.push_back(H[i]);\n\t\t}\n\n\t\tsort(broken.begin(), broken.end());\n\t\tbroken.erase(unique(broken.begin(), broken.end()), broken.end());\n\t\t\n\t\tfor(i=0;i<M;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a-1][b-1] = cost[b-1][a-1] = c;\n\t\t}\n\n\t\tint co = 0;\n\t\tfor(i=broken.size()-1;i>=0;i--){\n\t\t\tint ret = prim(broken[i]);\n\t\t\tif(ret >= INF){\n\t\t\t\tco = 0;\n\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\tfor(j=0;j<N;j++){\n\t\t\t\t\t\tVused[k][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else co += ret;\n\t\t}\n\t\tcout << co << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nstruct UF{\n\tint par[200];\n\tint rank[200];\n\tint si[200];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstruct edge{\n    int t;\n    int a, b, c;\n    bool operator<( const edge& right) const {\n        if(c < right.c) return true;\n        else return false;\n    }\n};\n\nUF uf;\nint n, m;\nint h[200];\nvector<int> ho;\nvector<edge> vec;\n\nvoid solve(){\n    ho.clear();\n    vec.clear();\n    rep(i,n) cin >> h[i];\n    rep(i,n) ho.push_back(h[i]);\n    sort(ho.begin(),ho.end());\n    ho.erase(unique(ho.begin(),ho.end()),ho.end());\n    sort(ho.begin(),ho.end(),greater<int>());\n    rep(i,m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        edge e;\n        e.t = min(h[a],h[b]);\n        e.a = a; e.b = b; e.c = c;\n        vec.push_back(e);\n    }\n    sort(vec.begin(),vec.end());\n    ll ans = 0;\n    int ss = 0, ee = ho.size(), mid;\n    while(ee-ss > 1){\n        mid = (ee+ss)/2;\n        uf.init(n);\n        ll preans = 0;\n        bool ok = true;\n        for(int u = mid; u < ho.size(); u++){\n            UF tmp = uf;\n            ll cnt = 0;\n            rep(i,vec.size()){\n                if(ho[u] > vec[i].t) continue;\n                if(!tmp.same(vec[i].a,vec[i].b)){\n                    tmp.unite(vec[i].a,vec[i].b);\n                    cnt += vec[i].c;\n                }\n            }\n            int huga = 0;\n            rep(i,n){\n                if(h[i] < ho[u]) continue;\n                if(i == tmp.find(i)) huga++;\n            }\n            if(huga == 1){\n                uf = tmp;\n                preans += cnt;\n            }\n            if(huga > 1){\n                ss = mid;\n                ok = false;\n                break;\n            }\n        }\n        if(ok){\n            ee = mid;\n            ans = preans;\n        }\n    }\n    {\n        int v = ss; \n        uf.init(n);\n        ll preans = 0;\n        bool ok = true;\n        for(int u = v; u < ho.size(); u++){\n            UF tmp = uf;\n            ll cnt = 0;\n            rep(i,vec.size()){\n                if(ho[u] > vec[i].t) continue;\n                if(!tmp.same(vec[i].a,vec[i].b)){\n                    tmp.unite(vec[i].a,vec[i].b);\n                    cnt += vec[i].c;\n                }\n            }\n            int huga = 0;\n            rep(i,n){\n                if(h[i] < ho[u]) continue;\n                if(i == tmp.find(i)) huga++;\n            }\n            if(huga == 1){\n                uf = tmp;\n                preans += cnt;\n            }\n            if(huga > 1){\n                ss = mid;\n                ok = false;\n                break;\n            }\n        }\n        if(ok){\n            ee = mid;\n            ans = preans;\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親\n\tvector<int> sz; // 数\n\t// 初期化\n\tUF(int n):par(n),sz(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\nvector<pair<ll,pair<ll,ll>>> v;\nvector<pair<ll,ll>> h;\nll n,m;\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\th.clear();\n\t\tv.clear();\n\t\tREP(i,n){\n\t\t\tll tmp;cin >> tmp;\n\t\t\th.PB(MP(tmp,i));\n\t\t}\n\t\tREP(i,m){\n\t\t\tll a,b,c;cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv.PB(MP(c,MP(a,b)));\n\t\t}\n\t\t\t\t\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\tvector<int> jun(n);\n\t\tREP(i,n)jun[h[i].SE] = i;\n\n\t\tUF seica(n);\n\t\tREP(i,m){\n\t\t\tint A = v[i].SE.FI;\n\t\t\tint B = v[i].SE.SE;\n\t\t\tif(!seica.same(A,B)){\n\t\t\t\tseica.unite(A,B);\n\t\t\t}\n\t\t}\n\t\tif(seica.size(0) != n){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\tvector<bool> sink(n);\n\t\t\t\n\t\t\tint cou = 0;\n\t\t\twhile(1){\n\t\t\t\tint tmp = cou;\n\t\t\t\twhile(cou < n-1 && h[cou].FI == h[cou+1].FI){\n\t\t\t\t\tcou++;\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"before cou \" << cou << endl;)\n\t\t\t\tif(cou == n-1){\n\t\t\t\t\tcou = tmp - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tUF uf(n);\n\t\t\t\tREP(i,m){\n\t\t\t\t\tint A = v[i].SE.FI;\n\t\t\t\t\tint B = v[i].SE.SE;\n\t\t\t\t\tif(jun[A] > cou && jun[B] > cou && !uf.same(A,B)){\n\t\t\t\t\t\tuf.unite(A,B);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ma = 0;\n\t\t\t\tREP(i,n)ma = max(ma,uf.size(i));\n\t\t\t\tif(ma != n - cou -1){\n\t\t\t\t\tcou = tmp - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"after cou \" << cou << endl;)\n\t\t\t\tcou++;\n\t\t\t}\n\t\t\tDBG(cout << \"OUT CHECK \" << cou << endl;);\n\t\t\tll ans = 0;\n\t\t\tUF uf(n);\n\t\t\twhile(1){\n\t\t\t\tREP(i,m){\n\t\t\t\t\tint A = v[i].SE.FI;\n\t\t\t\t\tint B = v[i].SE.SE;\n\t\t\t\t\tif(jun[A] > cou && jun[B] > cou && !uf.same(A,B)){\n\t\t\t\t\t\tuf.unite(A,B);\n\t\t\t\t\t\tans += v[i].FI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"cou \" << cou << endl;)\n\t\t\t\tif(cou < 0)break;\n\t\t\t\twhile(cou > 0 && h[cou].FI == h[cou-1].FI)cou--;\n\t\t\t\tcou--;\n\t\t\t}\n\t\t\t\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2511&lang=jp\n// references : http://mayokoex.hatenablog.com/entry/2016/05/03/233156\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n#define MAXT 1000100\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n\tedge() {}\n\tedge(int f, int t, int c) :from(f), to(t), cost(c) {}\n\tbool operator < (const edge& o) const { return cost < o.cost; }\n};\n\nstruct UnionFind {\n\tvector<int> par;\n\tint n, cnt;\n\tUnionFind(const int& x = 0) { init(x); }\n\tvoid init(const int& x) { par.assign(cnt = n = x, -1); }\n\tinline int find(const int& x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tinline bool same(const int& x, const int& y) { return find(x) == find(y); }\n\tinline bool unite(int x, int y) {\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\t--cnt;\n\t\tif (par[x] > par[y]) swap(x, y);\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\tinline int count() const { return cnt; }\n\tinline int count(int x) { return -par[find(x)]; }\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M;\n\twhile (cin >> N >> M, N | M) {\n\t\tvector<int> h[MAXT];\n\t\tfor (int i = 0; i < N; i++) { int t; cin >> t; h[t].push_back(i); }\n\t\tvector<edge> G;\n\t\tfor (int i = 0; i < M;i++) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tG.push_back(edge(a, b, c));\n\t\t}\n\t\tsort(G.begin(), G.end());\n\t\t\n\t\tUnionFind uf(N);\n\t\tfor (auto e : G) uf.unite(e.from, e.to);\n\t\tif (uf.count() > 1) { cout << 0 << endl; continue; }\n\n\t\tvector<int> f(N, 0);\n\t\tint cnt = 1;\n\t\tint last_t = -1;\n\t\tfor (int t = 0; t < MAXT;t++) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) { f[n] = 1; cnt++; }\n\t\t\tUnionFind uf(N);\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (f[e.from] == 1 || f[e.to] == 1)continue;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\t\t\tif (uf.count() != cnt) { last_t = t; break; }\n\t\t}\n\t\tif (last_t == -1)last_t = MAXT;\n\n\t\tfill(f.begin(), f.end(), 0);\n\t\tll ans = 0;\n\t\tfor (int t = last_t; t < MAXT;t++)for (auto n : h[t]) f[n] = 1;\n\t\t/* Minimum spanning tree */\n\t\tfor (auto e : G) {\n\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t}\n\t\t/*----------------------*/\n\n\t\tfor (int t = last_t - 1; t >= 0;t--) {\n\t\t\tif (h[t].size() == 0)continue;\n\t\t\tfor (auto n : h[t]) f[n] = 1;\n\t\t\tfor (auto e : G) {\n\t\t\t\tif (!(f[e.from] == 1 && f[e.to] == 1))continue;\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tans += e.cost; uf.unite(e.from, e.to);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64=int_fast64_t;\nusing pii=pair<int,int>;\n#define fir first\n#define sec second\n#define all(v) begin(v),end(v)\n\nstruct UnionFind {\n    vector<int> par,siz;\n    vector<bool> cyc;\n    int root_cnt;\n \n    UnionFind(int n) : root_cnt(n) { init(n); }\n \n    void init(int n) {\n        par.resize(n);\n        siz.assign(n,1);\n        cyc.assign(n,false);\n        for(int i = 0; i < n; ++i) par[i] = i;\n    }\n \n    int find(int x) {\n        if(par[x] == x) return x;\n        int r = find(par[x]);\n        return par[x] = r;\n    }\n \n    int size(int x) { return siz[find(x)]; }\n\n    bool is_cyclic(int x) { return cyc[find(x)]; }\n \n    bool is_same(int x, int y) { return find(x) == find(y); }\n \n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x == y) {\n            cyc[x] = true;\n            return false;\n        }\n        if(siz[x] < siz[y]) swap(x,y);\n        siz[x] += siz[y];\n        par[y] = x;\n        --root_cnt;\n        cyc[x] = cyc[x] || cyc[y];\n        return true;\n    }\n};\n\n\nint n,m;\n\nint solve() {\n    int ans=0;\n    int h[252];\n    bool exi[252]={};\n    vector<pii> g[251];\n    for(int i=0; i<n; ++i) {\n        cin>>h[i];\n    }\n    for(int i=0; i<m; ++i) {\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--,b--;\n        g[a].emplace_back(b,c);\n        g[b].emplace_back(a,c);\n    }\n\n    vector<pii> vrt;\n    for(int i=0; i<n; ++i) vrt.emplace_back(h[i],i);\n    sort(all(vrt),greater<pii>());\n\n    vector<int> clck(h,h+n);\n    clck.emplace_back(0);\n    sort(all(clck));\n\n    int las=1e7;\n    UnionFind uff(n);\n    \n    for(int i=0,j=0; i<n; i=j) {\n        while(j<n && vrt[i].fir==vrt[j].fir) {\n            int v=vrt[j].sec;\n            exi[v]=true;\n            for(auto &e:g[v]) {\n                if(exi[e.fir]) {\n                    uff.unite(v,e.fir);\n                }\n            }\n            ++j;\n        }\n        if(uff.root_cnt!=n-j+1) {\n            las=vrt[i].fir;\n        }\n    }\n    \n    vector<tuple<int,int,int>> edg;\n    UnionFind uf(n);\n    fill(all(exi),false);\n    for(int i=0, j=0; i<n; i=j) {\n        while(j<n && vrt[j].fir==vrt[i].fir) {\n            int v=vrt[j].sec;\n            exi[v]=true;\n            for(pii &e:g[v]) {\n                if(exi[e.fir]) {\n                    edg.emplace_back(e.sec,e.fir,v);\n                }\n            }\n            ++j;\n        }\n        if(las>vrt[i].fir) {\n            sort(all(edg));\n            for(auto &e:edg) {\n                int u,v,c; tie(c,u,v)=e;\n                if(uf.unite(u,v)) {\n                    ans+=c;\n                }\n            }\n            edg.clear();\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    //freopen(\"stderr.txt\",\"wt\",stderr);\n    while(cin>>n>>m,n) {\n        cout<<solve()<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nclass UnionFind{\n  int num_components;\n  std::vector<int> parent;\n  std::vector<int> weight;\n  std::vector<int> rank;\npublic:\n  UnionFind(int N) : num_components(N),\n                     parent(std::vector<int>(N)),\n                     weight(std::vector<int>(N, 1)),\n                     rank(std::vector<int>(N, 0)){\n    for(int i = 0; i < N; i++) parent[i] = i;\n  }\n  \n  int find(int x){\n    if(x == parent[x]) return x;\n    else return parent[x] = find(parent[x]);\n  }\n  \n  int size(int x){\n    return weight[find(x)];\n  }\n\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n    \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    \n    num_components--;\n    if(rank[x] < rank[y]){\n      weight[y] += weight[x];\n      parent[x] = y;\n    }else{\n      weight[x] += weight[y];\n      parent[y] = x;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\n  \n  int count(){\n    return num_components;\n  }\n};\n\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N, M;\n  while (cin >> N >> M &&N + M){\n    vector<int> H(N);\n    REP(i, N){\n      cin >> H[i];\n    }\n\n    vector<tuple<int, int, int> > es;\n    \n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c; a--, b--;\n      es.push_back(make_tuple(c, a, b));\n    }\n    sort(ALL(es));\n\n    vector<int> event_time;\n    REP(i, N){\n      event_time.push_back(H[i]);\n    }\n    sort(ALL(event_time));\n    event_time.erase(unique(ALL(event_time)), event_time.end());\n    reverse(ALL(event_time));\n      \n    ll res  = 0;\n    UnionFind uf1(N);\n    UnionFind uf2(N);\n    \n    for (int time : event_time){\n      int last = -1;\n      REP(i, M){\n        int u = get<1>(es[i]);\n        int v = get<2>(es[i]);\n        if (H[u] >= time && H[v] >= time) {\n          last = u;\n          uf1.unite(u, v);\n        }\n      }\n\n      int live = 0;\n      REP(i, N) if (H[i] >= time){\n        live++;\n      }\n\n      if (last == -1 || uf1.size(last) != live){\n        res = 0;\n        uf2 = UnionFind(N);\n        continue;\n      }\n        \n      REP(i, M){\n        int u = get<1>(es[i]);\n        int v = get<2>(es[i]);\n        int c = get<0>(es[i]);\n        if (H[u] >= time && H[v] >= time && !uf2.same(u, v)) {\n          // cout << u + 1 << \" \" << v + 1 << \" \" << c << \" \" << time << endl;\n          uf2.unite(u, v);\n          res += c;\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nvector<vector<pair<ll,ll>>> vv(210);\nvector<pair<ll,ll>> h;\nvector<pair<ll,pair<ll,ll>>> v;\n\nbool use[210*210];\nint uiteru[210];\nint n,m;\n\nstruct UF\n{\n\tvector<int> par; // 親\n\tvector<int> sz; // 数\n\t// 初期化\n\tUF(int n):par(n),sz(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\nll check(int num){\n\tDBG(\n\tcout << \"in check\" << endl;\n\tSHOW1d(uiteru,n);\n\t)\n\tUF uf(n);\n\tll ret = 0;\n\tREP(i,m){\n\t\tint a = v[i].SE.FI;\n\t\tint b = v[i].SE.SE;\n\t\tint c = v[i].FI;\n\t\tif(uiteru[a] + uiteru[b] != 0)continue;\n\t\tif(!uf.same(a,b)){\n\t\t\tret += c;\n\t\t\tuf.unite(a,b);\n\t\t}\n\t}\n\tDBG(cout << \"ret \" << ret << endl;)\n\tint cou = 0;\n\tREP(i,n)cou = max(cou,uf.size(i));\n\tif(cou == num){\n\t\treturn ret;\n\t}\n\telse \n\t{\n\t\treturn -1;\n\t}\n\t\t\n}\t\t\n\nint main()\n{\n\twhile(cin >> n >> m,n|m){\n\t\tint num = n;\n\t\th.clear();\n\t\tv.clear();\n\t\tREP(i,210*210)use[210*210] = false; \n\t\tREP(i,210)uiteru[i] = 0;\n\t\t\n\t\tREP(i,n){\n\t\t\tll tmp;cin >> tmp;\n\t\t\th.PB(MP(tmp,i));\n\t\t}\n\t\t\n\t\tREP(i,m){\n\t\t\tll a,b,c;cin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv.PB(MP(c,MP(a,b)));\n\t\t}\n\t\t\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\t\n\t\tDBG(\n\t\tREP(i,m){\n\t\t\tcout << v[i].FI << ' ' << v[i].SE.FI << ' ' << v[i].SE.SE << endl;\n\t\t}\n\t\t)\n\t\t\n\t\tll ans = 0;\n\t\tll ret = check(n);\n\t\tll cou = 0;\n\t\tll prev = ret;\n\t\tif(ret == -1){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\twhile(1){\n\t\t\t\tint tmp = cou;\n\t\t\t\twhile(cou < n && h[cou].FI == h[cou+1].FI){\n\t\t\t\t\tuiteru[h[cou].SE] = 2;\n\t\t\t\t\tcou++;\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"cou \" << cou << endl;);\n\t\t\t\tuiteru[h[cou].SE] = 2;\n\t\t\t\tret = check(n - cou - 1);\n\t\t\t\tif(cou == n-1 || ret == -1){\n\t\t\t\t\tcout << max(0LL,prev) << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tREP(j,m){\n\t\t\t\t\t\tint kazu = 0;\n\t\t\t\t\t\tint a = v[j].SE.FI;\n\t\t\t\t\t\tint b = v[j].SE.SE;\n\t\t\t\t\t\tbool flag = false;\n\t\t\t\t\t\tint tmptmp;\n\t\t\t\t\t\tfor(int i = tmp;i <= cou;i++){\n\t\t\t\t\t\t\tif(uiteru[h[i].SE] == 2 && (a == h[i].SE || b == h[i].SE)){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\ttmptmp = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag && (uiteru[a] < 2 || uiteru[b] < 2)){\n\t\t\t\t\t\t\tuiteru[h[tmptmp].SE] = 1;\n\t\t\t\t\t\t\tans += v[j].FI;\n\t\t\t\t\t\t\tDBG(cout << \"j \" << j << \"cost \" << v[j].FI << ' ' << a << ' ' << b << endl;);\n\t\t\t\t\t\t\tkazu++;\n\t\t\t\t\t\t\tif(kazu == cou - tmp + 1)break;\n\t\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = tmp;i <= cou;i++){\n\t\t\t\t\t\tuiteru[h[i].SE] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tDBG(cout << \"ans \" << ans << endl;);\n\t\t\t\t\tprev = ans + ret;\n\t\t\t\t\tDBG(cout << \"prev \" << prev << endl;);\n\t\t\t\t}\n\t\t\t\tcou++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nstruct UnionFind{\n    vector<int> data;\n\n    UnionFind(int sz){\n        data.assign(sz, -1);\n    }\n\n    bool unite(int x, int y){\n        x = find(x), y = find(y);\n        if(x == y) return(false);\n        if(data[x] > data[y]) swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n        return(true);\n    }\n\n    int find(int k){\n        if(data[k] < 0) return(k);\n        return(data[k] = find(data[k]));\n    }\n\n    int size(int k){\n        return(-data[find(k)]);\n    }\n};\nint main(){\n    int N,M;\n    while(cin>>N>>M,N)\n    {\n        vector<int>h(N);\n        vector<pair<int,int> >hh(N);\n        for(int i=0;i<N;i++)\n        {\n            cin>>h[i];\n            hh[i]=make_pair(h[i],i);\n        }\n        sort(hh.begin(),hh.end());\n        reverse(hh.begin(),hh.end());\n        vector<pair<pair<int,int>,pair<int,int> > >E;\n        for(int i=0;i<M;i++)\n        {\n            int a,b,c;cin>>a>>b>>c;\n            a--,b--;\n            E.push_back(make_pair(make_pair(min(h[a],h[b]),-c),make_pair(a,b)));\n        }\n        sort(E.begin(),E.end());\n        reverse(E.begin(),E.end());\n        UnionFind uf(N);\n        int id=0,H=0;\n        for(int i=0;i<N;i++)\n        {\n            int nowh=hh[i].first;\n            while(id<M&&E[id].first.first>=nowh)\n            {\n                uf.unite(E[id].second.first,E[id].second.second);\n                id++;\n            }\n            if(uf.size(hh[i].second)<=i)\n            {\n                H=i;\n            }\n        }\n        if(H==N-1)\n        {\n            cout<<0<<endl;\n            continue;\n        }\n        H=hh[H+1].first;\n        vector<pair<pair<int,int>,pair<int,int> > >F;\n        for(pair<pair<int,int>,pair<int,int> >p:E)\n        {\n            F.push_back(make_pair(make_pair(min(H,p.first.first),p.first.second),p.second));\n        }\n        sort(F.begin(),F.end());\n        reverse(F.begin(),F.end());\n        long long ans=0;\n        UnionFind P(N);\n        for(pair<pair<int,int>,pair<int,int> >p:F)\n        {\n            if(P.unite(p.second.first,p.second.second))\n            {\n                ans-=p.first.second;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct bridge {\n\tint from;\n\tint to;\n\tint cost;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const bridge&l, const bridge &r) {\n\t\treturn l.cost> r.cost;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<pair<int,int>>hs;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint h; cin >> h;\n\t\t\ths.emplace_back(h, i);\n\t\t}\n\t\tvector<vector<bridge>>bs(N);\n\t\tsort(hs.begin(), hs.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tbs[a].push_back(bridge{ a,b,c });\n\t\t\tbs[b].push_back(bridge{ b,a,c });\n\t\t}\n\t\tvector<vector<int>>sinks;\n\t\t{\n\t\t\tint now = hs[0].first;\n\t\t\tvector<int>vs(1, hs[0].second);\n\t\t\tfor (int i = 1; i < hs.size(); ++i) {\n\t\t\t\tif (hs[i].first == now) {\n\t\t\t\t\tvs.push_back(hs[i].second);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsinks.push_back(vs);\n\t\t\t\t\tvs.clear();\n\t\t\t\t\tvs.push_back(hs[i].second);\n\t\t\t\t\tnow = hs[i].first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsinks.push_back(vs);\n\t\t}\n\t\treverse(sinks.begin(), sinks.end());\n\t\tfor (int from = 0; from <= sinks.size(); ++from) {\n\t\t\tif (from == sinks.size()) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tint costsum = 0;\n\t\t\tvector<int>status(N);\n\n\t\t\tbool isfast = true;\n\t\t\tfor (int time = from; time < sinks.size(); ++time) {\n\t\t\t\tpriority_queue <bridge, vector<bridge>,Compare>que;\n\t\t\t\tvector<int>waits;\n\n\t\t\t\tfor (int i = 0; i <= time; ++i) {\n\t\t\t\t\tif (!isfast)i = time;\n\t\t\t\t\tfor (auto island : sinks[i]) {\n\t\t\t\t\t\twaits.push_back(island);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < waits.size(); ++i) {\n\t\t\t\t\tfor (auto b : bs[waits[i]]) {\n\t\t\t\t\t\tif(isfast){\n\t\t\t\t\t\t\tif (find(waits.begin(), waits.end(), b.to) != waits.end()) {\n\t\t\t\t\t\t\t\tque.push(b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (status[b.to]) {\n\t\t\t\t\t\t\t\tque.push(b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (que.empty()) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(isfast){\n\t\t\t\t\tbridge atop(que.top());\n\t\t\t\t\tque.pop();\n\t\t\t\t\tstatus[atop.from] = 1;\n\t\t\t\t\tstatus[atop.to] = 1;\n\t\t\t\t\twaits.erase(find(waits.begin(), waits.end(), atop.from));\n\t\t\t\t\twaits.erase(find(waits.begin(), waits.end(), atop.to));\n\t\t\t\t\tcostsum += atop.cost;\n\t\t\t\t}\n\t\t\t\twhile (!waits.empty() && !que.empty()) {\n\t\t\t\t\tbridge atop(que.top());\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (status[atop.from] == 0 && status[atop.to] == 1) {\n\t\t\t\t\t\tstatus[atop.from] = 1;\n\t\t\t\t\t\twaits.erase(find(waits.begin(), waits.end(), atop.from));\n\t\t\t\t\t\tfor (auto b : bs[atop.from]) {\n\t\t\t\t\t\t\tif (find(waits.begin(), waits.end(), b.to) != waits.end()) {\n\t\t\t\t\t\t\t\tque.push(bridge{ b.to,b.from,b.cost });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcostsum += atop.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!waits.empty()) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tisfast = false;\n\t\t\t}\n\t\t\tif (!ok)continue;\n\t\t\telse {\n\t\t\t\tcout << costsum << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\n\ntemplate <typename T>\nmap<T, int> coordinate_compression_map(vector<T> const & xs) {\n    int n = xs.size();\n    vector<int> ys(n);\n    iota(whole(ys), 0);\n    sort(whole(ys), [&](int i, int j) { return xs[i] < xs[j]; });\n    map<T,int> f;\n    for (int i : ys) {\n        if (not f.count(xs[i])) { // make unique\n            int j = f.size();\n            f[xs[i]] = j; // f[xs[i]] has a side effect, increasing the f.size()\n        }\n    }\n    return f;\n}\n\nstruct disjoint_sets {\n    vector<int> data;\n    disjoint_sets() = default;\n    explicit disjoint_sets(size_t n) : data(n, -1) {}\n    bool is_root(int i) { return data[i] < 0; }\n    int find_root(int i) { return is_root(i) ? i : (data[i] = find_root(data[i])); }\n    int set_size(int i) { return - data[find_root(i)]; }\n    int unite_sets(int i, int j) {\n        i = find_root(i); j = find_root(j);\n        if (i != j) {\n            if (set_size(i) < set_size(j)) swap(i,j);\n            data[i] += data[j];\n            data[j] = i;\n        }\n        return i;\n    }\n    bool is_same(int i, int j) { return find_root(i) == find_root(j); }\n};\n\nint main() {\n    while (true) {\n        // input\n        int n, m; scanf(\"%d%d\", &n, &m);\n        if (n == 0 and m == 0) break;\n        vector<int> h(n);\n        repeat (i, n) {\n            scanf(\"%d\", &h[i]);\n        }\n        vector<vector<tuple<int, int, int> > > edges(n);\n        repeat (i, m) {\n            int a, b, c; scanf(\"%d%d%d\", &a, &b, &c); -- a; -- b;\n            edges[a].emplace_back(c, a, b);\n            edges[b].emplace_back(c, b, a);\n        }\n        // solve\n        auto compress = coordinate_compression_map(h);\n        vector<vector<int> > groups(compress.size());\n        repeat (i, n) {\n            groups[compress[h[i]]].push_back(i);\n        }\n        int result = 0;\n        vector<bool> risen(n);\n        disjoint_sets ds(n);\n        while (not groups.empty()) {\n            auto group = groups.back();\n            groups.pop_back();\n            for (int i : group) risen[i] = true;\n            reversed_priority_queue<tuple<int, int, int> > que;\n            for (int i : group) {\n                for (auto edge : edges[i]) {\n                    int j = get<2>(edge);\n                    if (risen[j]) {\n                        que.push(edge);\n                    }\n                }\n            }\n            while (not que.empty()) {\n                int c, a, b; tie(c, a, b) = que.top();\n                que.pop();\n                if (not ds.is_same(a, b)) {\n                    ds.unite_sets(a, b);\n                    result += c;\n                }\n            }\n        }\n        // output\n        if (ds.set_size(0) != n) result = 0;\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass UnionFind {\nprivate:\n\tvector<int> parent;\n\npublic:\n\tUnionFind(int n) : parent(n) {\n\t\tfor (int i = 0; i < n; ++i) parent[i] = i;\n\t}\n\tvoid unite(int a, int b) {\n\t\tparent[root(a)] = root(b);\n\t}\n\tint root(int n) {\n\t\tif (parent[n] == n) return n;\n\t\treturn parent[n] = root(parent[n]);\n\t}\n\tbool isUnited(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n};\n\nstruct Edge {\n\tint from, to, cost;\n};\nbool operator<(const Edge& e1, const Edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nint main() {\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tmap<int, vector<int> > m;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d; cin >> d;\n\t\t\tm[-d].push_back(i);\n\t\t}\n\t\tvector<Edge> edges;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint from, to, cost; cin >> from >> to >> cost; --from, --to;\n\t\t\tedges.push_back((Edge){from, to, cost});\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\n\t\tint ans = 0;\n\t\tUnionFind uf(N);\n\t\tvector<bool> isAlive(N, false);\n\t\tfor (map<int, vector<int> >::iterator it = m.begin(); it != m.end(); ++it) {\n\t\t\tvector<int>& ids = it->second;\n\t\t\tfor (int i = 0; i < ids.size(); ++i) {\n\t\t\t\tisAlive[ids[i]] = true;\n\t\t\t}\n\t\t\tUnionFind prevUf = uf;\n\t\t\tint prevAns = ans;\n\t\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\t\tEdge& e = edges[i];\n\t\t\t\tif (isAlive[e.from] && isAlive[e.to] && !uf.isUnited(e.from, e.to)) {\n\t\t\t\t\tans += e.cost;\n\t\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f = true;\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (isAlive[i]) {\n\t\t\t\t\tid = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (isAlive[i] && !uf.isUnited(i, id)) {\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) {\n\t\t\t\tuf = prevUf;\n\t\t\t\tans = prevAns;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=int;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    Edge(int src,int dst,Weight weight):\n    src(src),dst(dst),weight(weight){}\n};\n\nauto operator < (const Edge &e,const Edge &f){\n    if(e.weight!=f.weight)return e.weight>f.weight;\n    else if(e.src!=f.src)return e.src<f.src;\n    else return e.dst<f.dst;\n}\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\ntemplate<typename T>\nstruct UnionFind{\n    vector<T>data;\n    UnionFind(T n):data(n,-1){}\n    bool unite(T x,T y){\n        x=root(x);y=root(y);\n        if(x!=y){\n            if(data[y]<data[x])swap(x,y);\n            data[x]+=data[y];data[y]=x;\n        }\n        return x!=y;\n    }\n    T root(T x){\n        return data[x]<0?x:data[x]=root(data[x]);\n    }\n    bool same(T x,T y){\n        return root(x)==root(y);\n    }\n    T size(T x){\n        return -data[root(x)];\n    }\n};\n\npair<Weight,Edges>kruskal(const Graph &g,int x,const vector<int>&h,UnionFind<int> &uf){\n    int n=g.size();\n    priority_queue<Edge>q;\n    for(int i=0;i<n;++i){\n        for(auto e:g[i]){\n            if(i<e.dst && h[e.dst] > x && h[e.src] > x)q.push(e);\n        }\n    }\n    Weight total=0;\n    Edges forest;\n    while(forest.size()<n-1 && !q.empty()){\n        Edge e=q.top();q.pop();\n        if(uf.unite(e.src,e.dst)){\n            forest.push_back(e);\n            total+=e.weight;\n        }\n    }\n    return pair<Weight, Edges>(total,forest);\n}\n\nbool isrenketu(const Graph &g,int x,const vector<int>&h){\n    int n=g.size();\n    UnionFind<int> uf(n);\n    for(int i=0;i<n;++i){\n        if(h[i]<=x)continue;\n        for(auto e:g[i]){\n            if(h[e.dst]<=x)continue;\n            uf.unite(i,e.dst);\n        }\n    }\n    int k,flag=1;\n    for(int i=0;i<n;++i){\n        if(h[i]<=x)continue;\n        if(flag){\n            k=uf.root(i);\n            flag=0;\n        }\n        if(k!=uf.root(i))return 0;\n    }\n    return 1;\n}\n\nint main(){\n    int v,e;\n    while (cin >> v >> e, v)\n    {\n        UnionFind<int> uf(v);\n        vector<int> h(v);\n        set<int> st;\n        for (int i = 0; i < v; ++i)\n        {\n            cin >> h[i];\n            st.insert(h[i]);\n        }\n        Graph g(v);\n        for (int i = 0; i < e; ++i)\n        {\n            int s, t, w;\n            cin >> s >> t >> w;\n            --s;\n            --t;\n            g[s].emplace_back(s, t, w);\n            g[t].emplace_back(t, s, w);\n        }\n        int end = 0;\n        vector<int> ve;\n        st.insert(0);\n        for (auto x : st)\n        {\n            if (!isrenketu(g, x, h))\n                break;\n            ve.push_back(x);\n        }\n        int ans = 0;\n        for (int i = ve.size() - 1; i >= 0; --i)\n        {\n            ans += kruskal(g, ve[i], h, uf).first;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nstruct UnionFind{\n    vector<int> par;\n    int count;\n    UnionFind(int n) : par(n, -1), count(0){}\n    int Find(int x){return par[x] < 0 ? x : Find(par[x]);}\n    int Size(int x){return par[x] < 0 ? -par[x] : Size(par[x]);}\n    bool Unite(int x, int y){\n        x = Find(x);\n        y = Find(y);\n        if(x == y)\n            return false;\n        if(par[x] > par[y])\n            swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return ++count;\n    }\n};\n\n\nbool solve(){\n    int n, m;\n    cin >> n >> m;\n    if(!n)\n        return false;\n    vector<int> h(n);\n    for(int i = 0; i < n; ++i)\n        cin >> h[i];\n    vector<int> a(m), b(m), c(m);\n    vector<vector<pair<int,int>>> edges(n);\n    for(int i = 0; i < m; ++i){\n        cin >> a[i] >> b[i] >> c[i];\n        --a[i], --b[i];\n        edges[a[i]].emplace_back(b[i], c[i]);\n        edges[b[i]].emplace_back(a[i], c[i]);\n    }\n    map<int, vector<int>> ts;\n    for(int i = 0; i < n; ++i)\n        ts[h[i]].push_back(i);\n\n    bitset<200> bs, fl;\n    for(int i = 0; i < n; ++i)\n        bs.set(i);\n\n    function<void(int)> f = [&](int x){\n        for(auto& ed : edges[x]){\n            if(!bs[ed.first] || fl[ed.first])\n                continue;\n            fl.set(ed.first);\n            f(ed.first);\n        }\n    };\n\n    int border = -1;\n    for(auto& elm : ts){\n        int idx = -1;\n        for(int i = 0; i < n; ++i)\n            if(bs[i]){\n                idx = i;\n                break;\n            }\n        if(idx == -1){\n            border = elm.first;\n            break;\n        }\n        fl.reset();\n        fl.set(idx);\n        f(idx);\n        if(fl != bs){\n            border = elm.first;\n            break;\n        }\n        for(auto& x : elm.second)\n            bs.reset(x);\n    }\n    fl.reset();\n    vector<pair<int, vector<int>>> v;\n    for(auto& elm : ts){\n        if(elm.first == border)\n            break;\n        v.emplace_back(elm);\n        for(auto& x : elm.second)\n            fl.set(x);\n    }\n\n    bs.reset();\n\n    for(int i = 0; i < n; ++i)\n        if(!fl[i]){\n            bs.set(i);\n        }\n    reverse(v.begin(), v.end());\n    bitset<100000> used;\n\n    UnionFind u(n);\n    int ans = 0;\n\n    if(v.empty()){\n        cout << 0 << endl;\n        return true;\n    }\n    for(auto& elm : v){\n        auto& w = elm.second;\n        for(auto& x : w)\n            bs.set(x);\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> que;\n        for(int i = 0; i < m; ++i){\n            if(bs[a[i]] && bs[b[i]] && !used[i])\n                que.emplace(c[i], i);\n        }\n        while(!que.empty()){\n            int cost, idx;\n            tie(cost, idx) = que.top();\n            que.pop();\n            if(u.Unite(a[idx], b[idx])){\n                used.set(idx);\n                ans += cost;\n                if(u.Size(a[idx]) == bs.count())\n                    break;\n            }\n        }\n    }\n\n    assert(u.count == n - 1);\n    assert(bs.count() == n);\n    assert(used.count() == n - 1);\n    cout << ans << endl;\n\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nstruct UnionFind{\n    vector<int> data;\n\n    UnionFind(int sz){\n        data.assign(sz, -1);\n    }\n\n    bool unite(int x, int y){\n        x = find(x), y = find(y);\n        if(x == y) return(false);\n        if(data[x] > data[y]) swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n        return(true);\n    }\n\n    int find(int k){\n        if(data[k] < 0) return(k);\n        return(data[k] = find(data[k]));\n    }\n\n    int size(int k){\n        return(-data[find(k)]);\n    }\n};\nint main(){\n    int N,M;\n    while(cin>>N>>M,N)\n    {\n        vector<int>h(N);\n        vector<pair<int,int> >hh(N);\n        for(int i=0;i<N;i++)\n        {\n            cin>>h[i];\n            hh[i]=make_pair(h[i],i);\n        }\n        sort(hh.begin(),hh.end());\n        reverse(hh.begin(),hh.end());\n        vector<pair<pair<int,int>,pair<int,int> > >E;\n        for(int i=0;i<M;i++)\n        {\n            int a,b,c;cin>>a>>b>>c;\n            a--,b--;\n            E.push_back(make_pair(make_pair(min(h[a],h[b]),-c),make_pair(a,b)));\n        }\n        sort(E.begin(),E.end());\n        reverse(E.begin(),E.end());\n        UnionFind uf(N);\n        int id=0,H=0;\n        for(int i=0;i<N;i++)\n        {\n            int nowh=hh[i].first;\n            while(id<M&&E[id].first.first>=nowh)\n            {\n                uf.unite(E[id].second.first,E[id].second.second);\n                id++;\n            }\n            if(uf.size(hh[i].second)<=i)\n            {\n                H=i;\n            }\n        }\n        if(H==N-1)\n        {\n            cout<<0<<endl;\n            continue;\n        }\n        H=hh[H+1].first;\n        vector<pair<pair<int,int>,pair<int,int> > >F;\n        for(pair<pair<int,int>,pair<int,int> >p:E)\n        {\n            F.push_back(make_pair(make_pair(min(H,p.first.first),p.first.second),p.second));\n        }\n        sort(F.begin(),F.end());\n        reverse(F.begin(),F.end());\n        long long ans=0;\n        UnionFind P(N);\n        for(pair<pair<int,int>,pair<int,int> >p:F)\n        {\n            if(P.unite(p.second.first,p.second.second))\n            {\n                ans-=p.first.second;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n\nusing Edge = tuple<int,int,int>; // c, a, b\nusing Graph = vector<vector<int>>;\n\nclass UnionFind {\nprivate:\n    const int n;\n    vector<int> uni;\npublic:\n    UnionFind(int _n) : n(_n), uni(_n, -1) {}\n    int root(int x) {\n        if (uni[x] < 0) return x;\n        return uni[x] = root(uni[x]);\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (uni[x] > uni[y]) swap(x, y);\n        uni[x] += uni[y];\n        uni[y] = x;\n        return true;\n    }\n    int getSize(int x) {\n        return -uni[root(x)];\n    }\n    void print() {\n        for (auto x : uni) cout << x << \" \";\n        cout << endl;\n    }\n};\n\nbool isConnected(const vector<Edge>& edges, const vector<bool>& alive) {\n    int n = alive.size();\n    UnionFind uf(n);\n    for (auto e : edges) {\n        int c, a, b;\n        tie(c, a, b) = e;\n        if (alive[a] && alive[b]) {\n            uf.unite(a, b);\n        }\n    }\n    set<int> groups;\n    rep(i, n) {\n        if (alive[i]) {\n            groups.insert(uf.root(i));\n        }\n    }\n    return groups.size() == 1;\n}\n\nint testcase = 0;\n\nbool solve() {\n    testcase++;\n\n    int n, m;\n    cin >> n >> m;\n    if (n == 0) return false;\n\n    map<int, vector<int>> day2islands;\n    rep(i, n) {\n        int h;\n        cin >> h;\n        day2islands[h].emplace_back(i);\n    }\n\n    vector<vector<int>> queries;\n    for (auto p : day2islands) {\n        queries.emplace_back(p.second);\n    }\n    int Q = queries.size();\n\n    vector<Edge> edges;\n    rep(i, m) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        edges.emplace_back(c, a, b);\n    }\n\n    sort(edges.begin(), edges.end());\n\n    Graph G(n);\n    for (auto e : edges) {\n        int c, a, b;\n        tie(c, a, b) = e;\n        G[min(a, b)].emplace_back(max(a, b));\n    }\n\n    /*\n    if (testcase == 4) {\n        cerr << n << \" \" << m << endl;\n        rep(i, Q) {\n            cerr << i << \":\";\n            for (auto v : queries[i]) {\n                cerr << \" \" << v;\n            }\n            cerr << endl;\n        }\n        for (auto e : edges) {\n            int c, a, b;\n            tie(c, a, b) = e;\n            cerr << c << \" \" << a << \" \" << b << endl;\n        }\n        rep(i, n) {\n            cerr << i << \":\";\n            for (auto v : G[i]) {\n                cerr << \" \" << v;\n            }\n            cerr << endl;\n        }\n    }\n    */\n\n    int id_first_disconnected = Q;\n    vector<bool> alive(n, true);\n    rep(i, Q) {\n        if (!isConnected(edges, alive)) {\n            id_first_disconnected = i;\n            break;\n        }\n        for (auto v : queries[i]) {\n            alive[v] = false;\n        }\n    }\n\n    id_first_disconnected--;\n    // cerr << \"id_first_disconnected = \" << id_first_disconnected << endl;\n\n    alive.clear();\n    alive.assign(n, true);\n    rep(i, id_first_disconnected) {\n        for (auto v : queries[i]) {\n            alive[v] = false;\n        }\n    }\n\n    UnionFind uf(n);\n    vector<Edge> adopted_edges;\n    for (int i = id_first_disconnected - 1; i >= -1; i--) {\n        for (auto e : edges) {\n            int c, a, b;\n            tie(c, a, b) = e;\n            if (alive[a] && alive[b] && !uf.same(a, b)) {\n                adopted_edges.push_back(e);\n                uf.unite(a, b);\n            }\n        }\n        if (i == -1) break;\n        for (auto v : queries[i]) {\n            alive[v] = true;\n        }\n    }\n\n    int sm = 0;\n    for (auto e : adopted_edges) {\n        int c, a, b;\n        tie(c, a, b) = e;\n        sm += c;\n    }\n\n    cout << sm << endl;\n\n    return true;\n}\n\nint main() {\n    while (solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\n#define endl '\\n'\n#define ALL(V) V.begin(),V.end()\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\n\nstruct UnionFind {\n    ll N, max_size;\n    V<ll> rank, parent, tsize;\n\n    UnionFind(ll N) : N(N), max_size(1), rank(N, 1), tsize(N, 1) {\n        parent = V<ll>(N);\n        iota(ALL(parent), 0ll);\n    }\n\n    ~UnionFind() {}\n\n    ll find(ll x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = find(parent[x]);\n    }\n\n    void unit(ll x, ll y) {\n        ll px = find(x);\n        ll py = find(y);\n        if(px == py) return;\n        if(rank[px] < rank[py]) swap(px, py);\n\n        parent[py] = px;\n        tsize[px] += tsize[py];\n        max_size = max(max_size, tsize[px]);\n        rank[px] += rank[py];\n    }\n\n    bool same(ll x, ll y) { return find(x) == find(y); }\n};\n\nusing PLL = pair<ll, ll>;\nusing TLL = tuple<ll, ll, ll>;\n\nbool solve() {\n    ll N, M;\n    cin >> N >> M;\n    if(!(N + M)) return false;\n\n    V<ll> H(N);\n\n    for(ll &e : H) cin >> e;\n    V<TLL> edges;\n    for(ll i = 0; i < M; i++) {\n        ll a, b, c;\n        cin >> a >> b >> c;\n        edges.emplace_back(c, a - 1, b - 1);\n    }\n\n    VV<ll> h_lis;\n    {\n        map<ll, V<ll>> hmap;\n        for(ll i = 0; i < N; i++) hmap[H[i]].push_back(i);\n        while(hmap.size()) {\n            auto ite = hmap.begin();\n            h_lis.push_back(ite->second);\n            hmap.erase(ite);\n        }\n    }\n    \n    sort(ALL(edges));\n\n    ll upper = h_lis.size();\n    V<bool> used(N, true);\n    {\n        ll sum = N;\n        for(ll i = 0; i < h_lis.size(); i++) {\n            const auto &v = h_lis[i];\n            UnionFind uf(N);\n            for(const auto ele : edges) {\n                ll a, b, c;\n                tie(c, a, b) = ele;\n                if(used[a] && used[b]) uf.unit(a, b);\n            }\n            if(uf.max_size < sum) {\n                upper = i;\n                break;\n            }\n            for(ll n : v) used[n] = false;\n            sum -= v.size();\n        }\n    }\n\n    ll ans = 0;\n\n    {\n        UnionFind uf(N);\n        for(ll i = upper - 1; i >= 0; i--) {\n            for(ll ni : h_lis[i]) used[ni] = true;\n            for(const auto ele : edges) {\n                ll a, b, c;\n                tie(c, a, b) = ele;\n                if(!used[a] || !used[b]) continue;\n                if(uf.same(a, b)) continue;\n                ans += c;\n                uf.unit(a, b);\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint n,m,h[N],a,b,c,X;\nvector<int> edge[N];\nvector<int> v;\nvector<P1> e;\nbool used[N];\nint par[N];\nset<int> s;\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x!=y)par[x]=y;\n}\n\nbool check(int A,int B){\n  bool x[N];\n  memset(x,0,sizeof(x));\n  for(int i=0;i<n;i++)par[i]=i;\n  for(int i=0;i<e.size();i++){\n    int n1=e[i].second.first;\n    int n2=e[i].second.second;\n    if(!(A<=h[n1]&&h[n1]<=B))continue;\n    if(!(A<=h[n2]&&h[n2]<=B))continue;\n    if(find(n1)!=find(n2)){\n      unite(n1,n2);\n      x[n1]=x[n2]=true;\n    }\n  }\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(!(A<=h[i]&&h[i]<=B))continue;\n    if(!x[i])res=false,cnt++;\n  }\n  if(A==B&&cnt==1)res=true;\n  return res;\n}\n\nvoid dfs(int x){\n  used[x]=true;\n  for(int i=0;i<edge[x].size();i++){\n    int nx=edge[x][i];\n    if(!used[nx])dfs(nx);\n  }\n}\n\nint kruskal(){\n  int res=0,X2=(int)v.size()-1;\n  for(int i=0;i<n;i++)par[i]=i;\n  if(X>=0){\n    for(int i=0;i<e.size();i++){\n      int n1=e[i].second.first;\n      int n2=e[i].second.second;\n      if(!(v[X]<=h[n1]&&h[n1]<=v[X2]))continue;\n      if(!(v[X]<=h[n2]&&h[n2]<=v[X2]))continue;\n      if(find(n1)!=find(n2)){\n\tunite(n1,n2);\n\tres+=e[i].first;\n      }\n    }\n  }\n  if(X==-1)X=X2;\n  for(int k=X-1;k>=0;k--){\n    for(int i=0;i<e.size();i++){\n      int n1=e[i].second.first;\n      int n2=e[i].second.second;\n      if(!(v[k]<=h[n1]&&h[n1]<=v[X2]))continue;\n      if(!(v[k]<=h[n2]&&h[n2]<=v[X2]))continue;\n      if(find(n1)!=find(n2)){\n\tunite(n1,n2);\n\tres+=e[i].first;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n      s.insert(h[i]);\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      edge[a-1].push_back(b-1);\n      edge[b-1].push_back(a-1);\n      e.push_back(P1(c,P(a-1,b-1)));\n    }\n    sort(e.begin(),e.end());\n    set<int>::iterator ite;\n    for(ite=s.begin();ite!=s.end();ite++)\n      v.push_back(*ite);\n    v.push_back(v[0]);\n    sort(v.begin(),v.end());\n    X=-1;\n    for(int i=0;i<v.size();i++)\n      if(!check(v[i],v[(int)v.size()-1])){\n\tX=i-1;\n\tbreak;\n      }\n    memset(used,0,sizeof(used));\n    dfs(0);\n    int f=0;\n    for(int i=0;i<n;i++)\n      if(!used[i])f=1;\n    if(f)cout<<0<<endl;\n    else cout<<kruskal()<<endl;\n    for(int i=0;i<n;i++)edge[i].clear();\n    e.clear();\n    v.clear();\n    s.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<ll> par; // 親\n\tvector<ll> sz; // 数\n\t// 初期化\n\tUF(ll n):par(n),sz(n) {\n\t\tfor(ll i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tll find(ll x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(ll x, ll y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(ll x, ll y) { return find(x) == find(y); }\n\tll size(ll n){return sz[find(n)];}\n};\n\nll n,m;\n\nll check(ll num,vector<pair<ll,ll>> h,vector<pair<ll,pair<ll,ll>>> v,bool sink[]){\n\tUF uf(n+10);\n\tll ret = 0;\n\tREP(i,m){\n\t\tll A = v[i].SE.FI;\n\t\tll B = v[i].SE.SE;\n\t\tll C = v[i].FI;\n\t\tDBG(if(A < 0 || A >= n || B < 0 || B >= n)cerr << \"HOGE \" << A << ' ' << B << endl;)\n\t\tif(sink[A] | sink[B])continue;\n\t\tif(!uf.same(A,B)){\n\t\t\tuf.unite(A,B);\n\t\t\tret += C;\n\t\t}\n\t}\n\tDBG(cerr << \"END UNITE\" << endl;)\n\tll cou = 0;\n\tREP(i,n){\n\t\tcou = max(cou,uf.size(i));\n\t}\n\tDBG(cerr << \"END CHECK\" << endl;)\n\treturn (cou == num ? ret : -1);\n}\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\tDBG(cerr << \"START\" << endl;)\n\t\tvector<pair<ll,ll>> h(222);\n\t\tvector<pair<ll,pair<ll,ll>>> v(222*222);\n\t\tbool sink[333];\n\t\t\n\t\tREP(i,n){\n\t\t\tll tmp;\n\t\t\tcin >> tmp;\n\t\t\th[i] = MP(tmp,i);\n\t\t}\n\t\t\n\t\tREP(i,m){\n\t\t\tll a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv[i] = MP(c,MP(a,b));\n\t\t}\n\t\tDBG(REP(i,m){cerr << v[i].SE.FI << ' ' << v[i].SE.SE << endl;if(v[i].SE.SE < 0)exit(1);})\n\t\tDBG(cerr << \"END INPIT\" << endl;);\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\t\n\t\tll prev = check(n,h,v,sink);\n\t\tll sinknum;\n\t\tif(prev == -1){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\tbool flag = false;\n\t\t\tfor(sinknum = 0;sinknum < n-1;sinknum++){\n\t\t\t\twhile(sinknum < n-1 && h[sinknum].FI == h[sinknum+1].FI){\n\t\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\t\tsinknum++;\n\t\t\t\t}\n\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\tll now = check(n-sinknum-1,h,v,sink);\n\t\t\t\tif(now == -1){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev = now;\n\t\t\t}\n\t\t\tDBG(cout << \"end sink\" << endl;);\n\t\t\tsink[h[sinknum].SE] = false;\n\t\t\tsinknum--;\n\t\t\tDBG(cout << \"prev \" << prev << \" sinknum \" << sinknum << endl;)\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tll tmp = 0;\n\t\t\tfor(ll i = sinknum;i >= 0;i--){\n\t\t\t\tvector<ll> li;\n\t\t\t\twhile(i > 0 && h[i].FI == h[i-1].FI){\n\t\t\t\t\tli.PB(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tli.PB(i);\n\t\t\t\tDBG(cout << \"size \" << li.size() << endl;);\n\t\t\t\tREP(j,m){\n\t\t\t\t\tll A = v[j].SE.FI;\n\t\t\t\t\tll B = v[j].SE.SE;\n\t\t\t\t\tll C = v[j].FI;\n\t\t\t\t\tll seica = -1;\n\t\t\t\t\tREP(k,li.size())if(sink[h[li[k]].SE] && (A == h[li[k]].SE || B == h[li[k]].SE))seica = li[k];\n\t\t\t\t\tif(seica != -1 && (sink[A] ^ sink[B])){\n\t\t\t\t\t\ttmp += C;\n\t\t\t\t\t\tsink[h[seica].SE] = false;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"i \" << i << endl;);\n\t\t\t}\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tcout << prev + tmp << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\n\ntemplate <typename T>\nmap<T, int> coordinate_compression_map(vector<T> const & xs) {\n    int n = xs.size();\n    vector<int> ys(n);\n    iota(whole(ys), 0);\n    sort(whole(ys), [&](int i, int j) { return xs[i] < xs[j]; });\n    map<T,int> f;\n    for (int i : ys) {\n        if (not f.count(xs[i])) { // make unique\n            int j = f.size();\n            f[xs[i]] = j; // f[xs[i]] has a side effect, increasing the f.size()\n        }\n    }\n    return f;\n}\n\nstruct disjoint_sets {\n    vector<int> data;\n    disjoint_sets() = default;\n    explicit disjoint_sets(size_t n) : data(n, -1) {}\n    bool is_root(int i) { return data[i] < 0; }\n    int find_root(int i) { return is_root(i) ? i : (data[i] = find_root(data[i])); }\n    int set_size(int i) { return - data[find_root(i)]; }\n    int unite_sets(int i, int j) {\n        i = find_root(i); j = find_root(j);\n        if (i != j) {\n            if (set_size(i) < set_size(j)) swap(i,j);\n            data[i] += data[j];\n            data[j] = i;\n        }\n        return i;\n    }\n    bool is_same(int i, int j) { return find_root(i) == find_root(j); }\n};\n\nint main() {\n    while (true) {\n        // input\n        int n, m; scanf(\"%d%d\", &n, &m);\n        if (n == 0 and m == 0) break;\n        vector<int> h(n);\n        repeat (i, n) {\n            scanf(\"%d\", &h[i]);\n        }\n        vector<vector<tuple<int, int, int> > > edges(n);\n        repeat (i, m) {\n            int a, b, c; scanf(\"%d%d%d\", &a, &b, &c); -- a; -- b;\n            edges[a].emplace_back(c, a, b);\n            edges[b].emplace_back(c, b, a);\n        }\n        // solve\n        auto compress = coordinate_compression_map(h);\n        vector<vector<int> > groups(compress.size());\n        repeat (i, n) {\n            groups[compress[h[i]]].push_back(i);\n        }\n        reverse(whole(groups));\n        auto rise = [&](vector<int> const & group, vector<bool> & risen, reversed_priority_queue<tuple<int, int, int> > & que) {\n            for (int i : group) {\n                risen[i] = true;\n            }\n            for (int i : group) {\n                for (auto edge : edges[i]) {\n                    int j = get<2>(edge);\n                    if (risen[j]) {\n                        que.push(edge);\n                    }\n                }\n            }\n        };\n        auto connect = [&](disjoint_sets & ds, vector<bool> const & risen, reversed_priority_queue<tuple<int, int, int> > & que) {\n            int result = 0;\n            while (not que.empty()) {\n                int c, a, b; tie(c, a, b) = que.top();\n                que.pop();\n                if (not ds.is_same(a, b)) {\n                    ds.unite_sets(a, b);\n                    result += c;\n                }\n            }\n            return result;\n        };\n        int disconnected = -1; {\n            const int root = groups[0][0];\n            int size = 0;\n            vector<bool> risen(n);\n            disjoint_sets ds(n);\n            reversed_priority_queue<tuple<int, int, int> > que;\n            repeat (t, groups.size()) {\n                auto const & group = groups[t];\n                rise(group, risen, que);\n                connect(ds, risen, que);\n                size += group.size();\n                if (ds.set_size(root) != size) {\n                    disconnected = t;\n                }\n            }\n        }\n        disconnected = min<int>(groups.size(), disconnected + 2);\n        int result = 0; {\n            vector<bool> risen(n);\n            reversed_priority_queue<tuple<int, int, int> > que;\n            repeat (t, disconnected) {\n                auto const & group = groups[t];\n                rise(group, risen, que);\n            }\n            disjoint_sets ds(n);\n            result += connect(ds, risen, que);\n            repeat_from (t, disconnected, groups.size()) {\n                auto const & group = groups[t];\n                rise(group, risen, que);\n                result += connect(ds, risen, que);\n            }\n            if (ds.set_size(0) != n) result = 0;\n        }\n        // output\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<int,pi>;\n\nconst int INF = 200000002;\n\nstruct UF{\n    int n;\n    //??£?????£????????????????????????,????????£???????????§??£?????????????????°\n    vector<int> d;\n    UF() {}\n    UF(int N):n(N), d(N,-1){}\n    int root(int v){\n        if(d[v]<0) return v;\n        return d[v]=root(d[v]);\n    }\n    bool unite(int X,int Y){\n        X=root(X); Y=root(Y);\n        if(X==Y) return false;\n        if(size(X) < size(Y)) swap(X,Y);\n        d[X]+=d[Y];\n        d[Y]=X;\n        return true;\n    }\n    int size(int v){ return -d[root(v)]; }\n    bool same(int X,int Y){ return root(X)==root(Y); }\n};\n\nint b[200][200];\n\nint solve(int n, int m)\n{\n    memset(b,-1,sizeof(b));\n\n    vector<int> h(n);\n    rep(i,n) scanf(\" %d\", &h[i]);\n\n    vector<P> e(m);\n    rep(i,m)\n    {\n        int u,v,c;\n        scanf(\" %d %d %d\", &u, &v, &c);\n        --u;\n        --v;\n        b[u][v] = b[v][u] = c;\n        e[i] = P(c,pi(u,v));\n    }\n\n    sort(all(e));\n\n    UF uf(n);\n    rep(i,m) uf.unite(e[i].se.fi, e[i].se.se);\n    if(uf.size(0) < n) return 0;\n\n    vector<int> sh(h);\n    sh.pb(0);\n    sort(all(sh));\n    sh.erase(unique(all(sh)),sh.end());\n    int SH = sh.size();\n\n    int idx = 0;\n    // ????????¶?????§????????¨?????£????????????????????¢???\n    while(idx<SH)\n    {\n        // printf(\"IDX %d  sh = %d\\n\", idx,sh[idx]);\n        uf = UF(n);\n        rep(i,m)\n        {\n            int u = e[i].se.fi, v = e[i].se.se;\n            if(h[u]>sh[idx] && h[v]>sh[idx])\n            {\n                uf.unite(u,v);\n            }\n        }\n\n        int num = 0;\n        int cand = 0;\n        rep(i,n)\n        {\n            if(h[i]>sh[idx])\n            {\n                ++num;\n                cand = i;\n            }\n        }\n        // dbg(idx);\n        // dbg(num);\n\n        if(uf.size(cand) < num) break;\n        ++idx;\n    }\n    --idx;\n    if(idx==SH-1) --idx;\n\n    int ret = 0;\n    // dbg(sh[idx]);\n\n    uf = UF(n);\n    // ??????????????¨??????????????????MST????§????\n    rep(i,m)\n    {\n        int u = e[i].se.fi, v = e[i].se.se;\n        if(h[u]>sh[idx] && h[v]>sh[idx])\n        {\n            if(!uf.same(u,v))\n            {\n                // printf(\"  MAKE %d %d\\n\", u,v);\n                uf.unite(u,v);\n                ret += e[i].fi;\n            }\n        }\n    }\n\n    // ????????¨?????????????????\\??????????????¨????????¨????????????????????\\?????????????????¨???\n    vector<int> sink[201];\n    rep(i,n)\n    {\n        int sh_idx = lower_bound(all(sh),h[i])-sh.begin();\n        sink[sh_idx].pb(i);\n    }\n\n    vector<int> con;\n    for(int i=SH-1; i>0; --i)\n    {\n        if(i<=idx)\n        {\n            vector<bool> ap(n);\n            rep(j,sink[i].size()) ap[sink[i][j]]=true;\n\n            vector<P> ee;\n            rep(j,m)\n            {\n                int u = e[j].se.fi, v = e[j].se.se;\n                if((ap[u]&&h[v]>=h[u]) || (ap[v]&&h[u]>=h[v])) ee.pb(e[j]);\n            }\n\n            int add = INF;\n            rep(j,sink[i].size())\n            {\n                int t = INF;\n                int V = -1;\n                for(const auto &x:con)\n                {\n                    if(b[sink[i][j]][x]!=-1)\n                    {\n                        t = min(t,b[sink[i][j]][x]);\n                        V = x;\n                    }\n                }\n\n                if(V==-1) continue;\n\n                UF tuf = uf;\n                tuf.unite(sink[i][j],V);\n                rep(k,ee.size())\n                {\n                    int u = ee[k].se.fi, v = ee[k].se.se;\n                    if(!tuf.same(u,v))\n                    {\n                        tuf.unite(u,v);\n                        t += ee[k].fi;\n                    }\n                }\n\n                add = min(add, t);\n            }\n            ret += add;\n        }\n\n        for(const auto &x:sink[i])\n        {\n            con.pb(x);\n            uf.unite(sink[SH-1][0],x);\n        }\n    }\n\n    return ret;\n}\n\nint main()\n{\n    int n,m;\n    while(scanf(\" %d %d\", &n, &m),n) printf(\"%d\\n\", solve(n,m));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<cassert>\n#include<set>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 3000\nusing namespace std;\n\nclass UnionFindTree\n{\npublic:\n  int par[MAX];\n\n  void init(int N){ rep(i,N)par[i] = i; }  \n\n  int find(int x)\n  {\n    if(par[x] == x)return x;\n    return par[x] = find(par[x]);\n  }\n\n  void unit(int x,int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x != y)par[x] = y;\n  }\n\n  bool same(int x,int y){ return find(x) == find(y); }\n\n};\n\nstruct edge\n{\n  int x,y,cost;\n  edge(int x=inf,int y=inf,int cost=inf):x(x),y(y),cost(cost){}\n  bool operator < (const edge& a)const\n  {\n    return cost < a.cost;\n  }\n};\n\nint N,M;\nvector<int> h,ph;\nvector<edge> G;\n\nbool check()\n{\n  UnionFindTree UTF;\n  UTF.init(N);\n  rep(i,G.size())\n    if(!UTF.same(G[i].x,G[i].y))\n      UTF.unit(G[i].x,G[i].y);\n  rep(i,N)UTF.find(i);\n  rep(i,N)if(UTF.par[i] != UTF.par[0])return false;\n  return true;\n}\n\nvoid compute()\n{\n\n  if(!check())\n    {\n      cout << 0 << endl;\n      return;\n    }\n\n  sort(all(ph),greater<int>());\n  sort(all(G));\n\n  UnionFindTree group;\n  group.init(N);\n  long long ans = 0;\n\n  rep(i,ph.size())\n    {\n      int TM = ph[i];\n      UnionFindTree UTF;\n      UTF.init(N);\n      rep(j,G.size())\n\t{\n\t  int x = G[j].x;\n\t  int y = G[j].y;\n\t  if(h[x] < TM || h[y] < TM)continue;\n\t  if(!UTF.same(x,y))\n\t    {\n\t      UTF.unit(x,y);\n\t    }\n\t}\n\n      rep(j,N)UTF.find(j);\n\n      set<int> out;\n      rep(j,N)if(h[j] >= TM && UTF.par[j] != j)out.insert(UTF.par[j]);\n      if(out.size() >= 2)\n\t{\n\t  ans = 0;\n\t  group.init(N);\n\t  continue;\n\t}\n\n\n      rep(j,G.size())\n\t{\n\t  int x = G[j].x;\n\t  int y = G[j].y;\n\t  if(h[x] < TM || h[y] < TM)continue;\n\t  if(!group.same(x,y))\n\t    {\n\t      //cout << TM << \" unit(\" << x+1 << \",\" << y+1 << \")\" << endl;\n\t      group.unit(x,y);\n\t      ans += G[j].cost;\n\t    }\n\t}\n      //cout << \"ans = \" << ans << endl;\n    }\n\n  cout << ans << endl;\n\n}\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      h.clear(),ph.clear(),G.clear();\n      h.resize(N),ph.resize(N),G.resize(M);\n      rep(i,N)cin >> h[i],ph[i] = h[i];\n      rep(i,M)cin >> G[i].x >> G[i].y >> G[i].cost,G[i].x--,G[i].y--;\n\n      compute();\n\n    }\n  return 0;\n}\n\n/*\nstruct P\n{\n  int h,identifier;\n  P(int h=inf,int identifier=inf):h(h),identifier(identifier){}\n  bool operator < (const P& a)const\n  {\n    if(h != a.h)return h > a.h;\n    return identifier < a.identifier;\n  }\n};\n\nstruct edge\n{\n  int x,y,cost;\n  edge(int x=inf,int y=inf,int cost=inf):x(x),y(y),cost(cost){}\n  bool operator < (const edge& a)const\n  {\n    return cost < a.cost;\n  }\n};\n\nint par[MAX];\nint N,M;\nvector<int> h,ph;\nvector<edge> vec;\n\nint find(int x)\n{\n  if(par[x] == x)return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x == y)return;\n  par[x] = y;\n}\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      \n      ph.clear(),h.clear(),vec.clear();\n      ph.resize(N),h.resize(N),vec.resize(M);\n      rep(i,N)par[i] = i;\n\n      rep(i,N)cin >> h[i],ph[i] = h[i];\n\t\n      rep(i,M)cin >> vec[i].x >> vec[i].y >> vec[i].cost,vec[i].x--,vec[i].y--;\n      \n      sort(ph.begin(),ph.end(),greater<int>());\n      sort(vec.begin(),vec.end());\n\n\n \n      int ans = 0;\n      rep(i,ph.size())\n\t{\n\t  int TM = ph[i];\n\t  int cost = 0;\n\t  rep(j,vec.size())\n\t    {\n\t      int x = vec[j].x;\n\t      int y = vec[j].y;\n\n\t      if(h[x] < TM || h[y] < TM)continue;\n\t      if(find(x) != find(y))\n\t\t{\n\t\t  cout << TM << \" unit(\"<<x+1 <<\",\" <<y+1 << \") : \" << vec[j].cost << endl;\n\t\t  unit(x,y);\n\t\t  cost += vec[j].cost;\n\t\t}\n\n\t    }\n\t  cout << \"ans : \" << ans << endl;\n\t}\n\n      int ch = find(0);\n      bool out = false;\n      rep(i,N)if(find(i) != ch)\n\t{\n\t  out = true;\n\t  break;\n\t}\n\n      cout << (out?0:ans) << endl;\n      \n    }\n  return 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nusing HV = tuple<int, int>;\nusing Edge = tuple<int, int, int>;\n\nconst int N = 201;\nint costs[N][N];\nvi used;\n\nvoid dfs(int v, int n){\n    used[v] = true;\n\n    rep(nv, n){\n        if(costs[v][nv] == -1 or used[nv]) continue;\n        dfs(nv, n);\n    }\n}\n\nint main(void){\n    for(int n, m; cin >> n >> m, n;){\n        rep(i, n) rep(j, n) costs[i][j] = -1;\n\n        vector<HV> hv(n);\n        vi h(n);\n        rep(i, n){\n            cin >> h[i];\n            hv[i] = HV(h[i], i);\n        }\n        sort(_all(hv));\n\n        int preh = get<0>(hv[0]);\n        vector<vi> h2vs = {{}, {get<1>(hv[0])}};\n        int hmax = 1;\n        for(auto & e : hv){\n            int h, v; tie(h, v) = e;\n            if(h != preh) h2vs.push_back(vi()), preh = h, hmax++;\n            h2vs.back().push_back(v);\n        }\n\n        rep(loop, m){\n            int a, b, c; cin >> a >> b >> c;\n            a--, b--;\n            costs[a][b] = costs[b][a] = c;\n        }\n\n        int hend = hmax + 1;\n        [&]{\n            rep(i, hmax + 1){\n                used = vi(n);\n\n                rep(j, i + 1){\n                    for(auto & v : h2vs[j]){\n                        used[v] = true;\n                    }\n                }\n\n                rep(v, n){\n                    if(used[v]) continue;\n                    dfs(v, n);\n                    break;\n                }\n                rep(v, n) if(not used[v]){\n                    hend = i;\n                    return;\n                }\n            }\n        }();\n\n        if(hend == 0){\n            cout << 0 << endl;\n            continue;\n        }\n        used = vi(n);\n        UnionFind uf(n);\n        priority_queue<Edge, vector<Edge>, greater<Edge>> q;\n        int res = 0;\n        rrep(i, hmax + 1){\n            for(auto & v : h2vs[i]){\n                rep(nv, n){\n                    if(used[nv] and costs[v][nv] != -1){\n                        q.push(Edge(costs[v][nv], v, nv));\n                    }\n                }\n                for(auto & nv : h2vs[i]){\n                    if(v >= nv) continue;\n                    if(costs[v][nv] != -1){\n                        q.push(Edge(costs[v][nv], v, nv));\n                    }\n                }\n            }\n\n            for(auto & v : h2vs[i]) used[v] = true;\n\n            if(i > hend) continue;\n\n            while(q.size()){\n                int cost, a, b; tie(cost, a, b) = q.top(); q.pop();\n                if(uf.findSet(a, b)) continue;\n\n                uf.unionSet(a, b);\n                res += cost;\n            }\n            q = priority_queue<Edge, vector<Edge>, greater<Edge>>();\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i = (bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\nstruct cww {\n\tcww() {\n\t\tios::sync_with_stdio(false);\n\t\tcin.tie(0);\n\t}\n}star;\ntemplate<typename T>\nistream & operator>> (istream &is, vector<T>&v) {\n\tfor (auto &it : v)is >> it;\n\treturn is;\n}\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\ntypedef pair<LL, LL> P;\ntypedef vector<LL> V;\nconst int INF = 1e7;\n\n\nnamespace _DSU {\n#define SZ 500000\n\tint mem[2][SZ];\n}\nclass UnionFind {\nprivate:\n\tint *par, *rank;\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\npublic:\n\tUnionFind(int n, int *par, int *rank) :par(par), rank(rank) {\n\t\tfor (int i = 0; i < n; i++)par[i] = i, rank[i] = 0;\n\t}\n\tUnionFind(int n) :UnionFind(n, _DSU::mem[0], _DSU::mem[1]) {}\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y)return false;\n\t\tif (rank[x] < rank[y])par[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y])rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\n\n\nint main() {\n\tint N,M;\n\twhile (cin >> N >> M, N + M) {\n\t\tV h(N);\n\t\tcin >> h;\n\t\tV a(M), b(M), c(M);\n\t\tvector<P> E(M);\n\t\tvector<P> I(N);\n\t\tREP(i, N)I[i] = P(h[i], i);\n\t\tREP(i, M) {\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tE[i] = P(c[i], i);\n\t\t}\n\t\tsort(ALL(E));\n\t\tsort(ALL(I));\n\n\t\tint jd = N - 1;\n\t\tLL res = 0;\n\t\t{\n\t\t\tint id = N - 1;\n\t\t\tvector<int> exist(N, 0);\n\t\t\tUnionFind uf(N);\n\t\t\twhile (id >= 0) {\n\t\t\t\tint ans = 0;\n\t\t\t\twhile (id > 0 && I[id].first == I[id - 1].first) {\n\t\t\t\t\texist[I[id--].second] = 1;\n\t\t\t\t}\n\t\t\t\texist[I[id--].second] = 1;\n\t\t\t\tREP(i, M) {\n\t\t\t\t\tint id = E[i].second;\n\t\t\t\t\tint u = a[id] - 1;\n\t\t\t\t\tint v = b[id] - 1;\n\t\t\t\t\tif (exist[u] && exist[v] && uf.unite(u, v))\n\t\t\t\t\t\tans += c[id];\n\t\t\t\t}\n\t\t\t\tint bb = -1;\n\t\t\t\tREP(i, N)if (exist[i])bb = i;\n\t\t\t\tif (bb == -1)continue;\n\t\t\t\tint flag = 1;\n\t\t\t\tREP(i, N)\n\t\t\t\t\tif (exist[i] && !uf.same(i, bb))\n\t\t\t\t\t\tflag = 0;\n\t\t\t\tif (flag == 0) jd = id;\n\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint id = N - 1;\n\t\t\tvector<int> exist(N, 0);\n\t\t\tUnionFind uf(N);\n\t\t\t\n\t\t\twhile (id >= 0) {\n\t\t\t\tif (id > jd) {\n\t\t\t\t\texist[I[id--].second] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint ans = 0;\n\t\t\t\twhile (id > 0 && I[id].first == I[id - 1].first) {\n\t\t\t\t\texist[I[id--].second] = 1;\n\t\t\t\t}\n\t\t\t\texist[I[id--].second] = 1;\n\t\t\t\tREP(i, M) {\n\t\t\t\t\tint id = E[i].second;\n\t\t\t\t\tint u = a[id] - 1;\n\t\t\t\t\tint v = b[id] - 1;\n\t\t\t\t\tif (exist[u] && exist[v] && uf.unite(u, v))\n\t\t\t\t\t\tans += c[id];\n\t\t\t\t}\n\n\t\t\t\tres += ans;\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace EGraph{\n\ttypedef int Cost;Cost CINF=1<<28;\n\tstruct Edge{\n\t\tint from,to;Cost cost;;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost){};\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n}\nusing namespace EGraph;\n\n\nstruct UnionFind{\n    vector<int> par; // 親\n    vector<int> rank; // 木の深さ\n    vector<int> ss;//xの属する集合のサイズ\n    int size;//集合の個数\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){\n            par[x] = y;ss[y]+=ss[x];\n        }else{\n            par[y] = x;ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\n\nvector<int> hs;\nint col(const Edge &e){\n\treturn min(hs[e.from],hs[e.to]);\n}\n\t\nclass CompTDesc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)>col(r);\n\t}\n};\n\nclass CompTAsc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)<col(r);\n\t}\n};\n\nclass CompC{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn l.cost> r.cost;\n\t}\n};\n\n\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tGraph g;\n\tvector<Edge> es;\n\tbool input(){\n\t\tcin >> N >> M;if(N==0 && M==0)return false;\n\t\ths=vector<int>(N);\n\t\tREP(i,N){\n\t\t\tcin >> hs[i];\n\t\t}\n\t\tg=Graph(N);\n\n\t\tes=vector<Edge>();\n\t\tREP(i,M){\n\t\t\tint a,b,c;cin >> a >> b >> c;a--;b--;\n\t\t\tes.push_back(Edge(a,b,c));\n\t\t\tes.push_back(Edge(b,a,c));\n\t\t}\n\t\treturn true;\n\t}\n\tint N,M;\n\tvector<bool> ex;\n\tvoid run(){\n\t\twhile(input()){\n\n\t\t\tsort(ALL(es),CompTDesc());\n\t\t\tUnionFind uf(N);\n\t\t\tint endT=-INF;\n\t\t\tREP(i,2*M){\n\t\t\t\tuf.unite(es[i].from,es[i].to);int T=col(es[i]);\n\t\t\t\twhile(i+1<2*M && T==col(es[i+1])){\n\t\t\t\t\tuf.unite(es[i+1].from,es[i+1].to);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t//check\n\t\t\t\tbool ok=true;\n\t\t\t\tREP(j,N)REP(k,N)if(T<=hs[j] && T<=hs[k] &&  !uf.same(j,k)){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t\tif(ok && endT==-INF){\n\t\t\t\t\tendT=T;\n\t\t\t\t}else if(!ok && endT!=-INF){\n\t\t\t\t\tendT=-INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(endT==-INF){\n\t\t\t\tcout << 0 <<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tCost res=0;\n\t\t\tUnionFind ufc(N);\n\t\t\tpriority_queue<Edge,vector<Edge>,CompC> que;\n\t\t\t\n\t\t\tint T=endT;\n\t\t\t//end\n\t\t\tREP(i,2*M)if(T<=col(es[i]))que.push(es[i]);\n\t\t\t//cruskal\n\t\t\twhile(!que.empty()){\n\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\tres+=e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//reflesh\n\t\t\tREP(i,2*M)if(col(es[i])<T){\n\t\t\t\tT=col(es[i]);que.push(es[i]);\n\t\t\t\twhile(i+1<2*M && T==col(es[i+1])){\n\t\t\t\t\tque.push(es[i+1]);i++;\n\t\t\t\t}\n\t\t\t\t//cruskal\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\t\tres+=e.cost;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tcout <<res<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pip;\n\nint N, M, H[210], V[210], A, B, C;\npii F[210];\npip E[60000];\n\nclass UnionFind {\npublic:\n  vector<int> a;\n  UnionFind(int n) { REP(i, 0, n) a.push_back(i); }\n  int find(int i) { return a[i] == i ? i : (a[i] = find(a[i])); }\n  bool unite(int i, int j) {\n    if(find(i) == find(j)) return false;\n    a[find(i)] = find(j);\n    return true;\n  }\n};\n\nint main(){\n  while(cin >> N >> M, N || M) {\n    REP(i, 0, N) cin >> H[i];\n    REP(i, 0, N) F[i] = pii(-H[i], i);\n    REP(i, 0, N) V[i] = 0;\n    REP(i, 0, M) {\n      cin >> A >> B >> C;\n      A--;\n      B--;\n      E[i] = pip(C,pii(A,B));\n    }\n    sort(F, F + N);\n    sort(E, E + M);\n\n    UnionFind uf(N);\n    int ret = 0, cnt = 0;\n    REP(i, 0, N) {\n      int v = F[i].se;\n      V[v] = 1;\n      if(i == N - 1 || F[i].fi != F[i + 1].fi) {\n        REP(j, 0, M) {\n          int a = E[j].se.fi;\n          int b = E[j].se.se;\n          if(V[a] && V[b] && uf.unite(a, b)) {\n            ret += E[j].fi;\n            cnt++;\n          }\n        }\n        if(cnt != i){\n          cnt = 0;\n          ret = 0;\n          REP(j, 0, N) uf.a[j] = j;\n        }\n      }\n    }\n    cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint h[200], par[200], s[200];\nint find(int x) {\n\tif (par[x] == x)return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = find(x); y = find(y);\n\tif (x == y)return;\n\tpar[y] = x; s[x] += s[y];\n}\nstruct st { int a, b, c; };\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\trep(i, n)scanf(\"%d\", &h[i]);\n\t\tvector<st>v;\n\t\trep(i, m) {\n\t\t\tint a, b, c; scanf(\"%d%d%d\", &a, &b, &c); a--; b--;\n\t\t\tv.push_back({ a,b,c });\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\treturn min(h[a.a], h[a.b]) > min(h[b.a], h[b.b]);\n\t\t});\n\t\tset<int>p;\n\t\tint u = INT_MAX;\n\t\trep(i, v.size()) {\n\t\t\tunite(v[i].a, v[i].b);\n\t\t\tp.insert(v[i].a); p.insert(v[i].b);\n\t\t\tif (i + 1 == v.size() || min(h[v[i].a], h[v[i].b]) != min(h[v[i + 1].a], h[v[i + 1].b])) {\n\t\t\t\tif (p.size() != s[find(v[i].a)]) {\n\t\t\t\t\tif (i + 1 == v.size())u = 0;\n\t\t\t\t\telse u = min(h[v[i + 1].a], h[v[i + 1].b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\tint c = min({ u,h[a.a], h[a.b] }), d = min({ u,h[b.a], h[b.b] });\n\t\t\tif (c == d)return a.c < b.c;\n\t\t\treturn c > d;\n\t\t});\n\t\tint res = 0;\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\tfor (st p : v) {\n\t\t\tif (find(p.a) == find(p.b))continue;\n\t\t\tunite(p.a, p.b); res += p.c;\n\t\t}\n\t\tif (s[find(0)] != n)puts(\"0\");\n\t\telse printf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\n#define endl '\\n'\n#define ALL(V) V.begin(),V.end()\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\n\nstruct UnionFind {\n    ll N, max_size;\n    V<ll> rank, parent, tsize;\n\n    UnionFind(ll N) : N(N), rank(N, 1), tsize(N, 1), max_size(1) {\n        parent = V<ll>(N);\n        iota(ALL(parent), 0ll);\n    }\n\n    ~UnionFind() {}\n\n    ll find(ll x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = find(parent[x]);\n    }\n\n    void unit(ll x, ll y) {\n        ll px = find(x);\n        ll py = find(y);\n        if(px == py) return;\n        if(rank[px] < rank[py]) swap(px, py);\n\n        parent[py] = px;\n        tsize[px] += tsize[py];\n        max_size = max(max_size, tsize[px]);\n        rank[px] += rank[py];\n    }\n\n    bool same(ll x, ll y) { return find(x) == find(y); }\n};\n\nusing PLL = pair<ll, ll>;\nusing TLL = tuple<ll, ll, ll>;\n\nbool solve() {\n    ll N, M;\n    cin >> N >> M;\n    if(!(N + M)) return false;\n\n    V<ll> H(N);\n    V<ll> node_idx(N);\n    iota(ALL(node_idx), 0ll);\n\n    for(ll &e : H) cin >> e;\n    V<TLL> edges;\n    for(ll i = 0; i < M; i++) {\n        ll a, b, c;\n        cin >> a >> b >> c;\n        edges.emplace_back(c, a - 1, b - 1);\n    }\n\n    sort(ALL(edges));\n    sort(ALL(node_idx), [&](ll i, ll j) { return H[i] > H[j]; });\n\n    UnionFind uf(N);\n    ll ans = 0;\n    V<bool> used(N, false);\n    for(ll i = 0; i < N; i++) {\n        ll ni = node_idx[i];\n        used[ni] = true;\n        for(const auto ele : edges) {\n            ll a, b, c;\n            tie(c, a, b) = ele;\n            if(uf.same(a, b)) continue;\n            if(!used[a] || !used[b]) continue;\n            ans += c;\n            uf.unit(a, b);\n        }\n        if(uf.max_size != i + 1) {\n            uf = UnionFind(N);\n            ans = 0;\n        }\n    }\n\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n#define Graph(type) vector< vector< Edge<type> > >\n\n// Union-Find ??¨ (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size;\n    vector<int> uf;\npublic:\n    // ????????? UnionFind uni(n) ??????????????£?¨?????????°??????\n    UnionFind(int _n) : n(_n), __size(_n), uf(_n, -1) {}\n    // find (??¨??????????±???????)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x ??¨ y ???????????????????±???????????????????\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x ????±????????????????????´???°\n    int size(int x) {return -uf[find(x)];}\n    // ???????????????????????????\n    int size()      {return __size;}\n    // x ??¨ y ????±??????????????????????\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n    }\n    // ???????????°??¨ (???????????????)\n    void debug() {for(auto e : uf) printf(\"UnionFind_debug: %lld\\n\", e);}\n};\n\nint N, M;\n// time, index\npii H[210];\nbool points[210];\n\nsigned main() {\n    while(cin >> N >> M, N || M) {\n        memset(points, false, sizeof(points));\n        rep(i,0,N) {\n            int p; cin >> p;\n            H[i] = pii(p, i);\n        }\n        sort(H, H+N, greater<pii>());\n\n        priority_queue< Edge<int>, vector< Edge<int> >, greater< Edge<int> > > es;\n        rep(i,0,M) {\n            int a, b, c; cin >> a >> b >> c; a--; b--;\n            es.push(Edge<int>(a, b, c));\n        }\n\n        UnionFind uf(N), uff(N);\n        int k = 0, ans = 0, MAXT = INF;\n        while(k < N) {\n            // val ??¨??????????????????????????????????????????\n            int val = H[k].first;\n            while(H[k].first == val && k < N) points[H[k++].second] = true;\n\n            priority_queue< Edge<int>, vector< Edge<int> >, greater< Edge<int> > > fs = es;\n            while(!fs.empty()) {\n                Edge<int> cur = fs.top(); fs.pop();\n                int a = cur.from, b = cur.to;\n                bool ng = false;\n                if(!points[a] || !points[b]) ng = true;\n                if(uf.same(a, b)) ng = true;\n                if(!ng) {\n                    uf.unite(a, b);\n                    // ans += cur.cost;\n                }\n            }\n            set<int> sz;\n            rep(i,0,N) if(points[i]) sz.insert(uf.find(i));\n            if(sz.size() != 1) MAXT = (k == N ? 0 : H[k].first);\n        }\n\n        // printf(\"MAXT = %lld\\n\", MAXT);\n        k = 0;\n        memset(points, false, sizeof(points));\n        bool init = true;\n        while(k < N) {\n            if(init) {\n                // MAXT ??\\?????????????????????????????????\n                init = false;\n                while(H[k].first >= MAXT && k < N) points[H[k++].second] = true;\n            }\n            else {\n                int val = H[k].first;\n                while(H[k].first == val && k < N) points[H[k++].second] = true;\n            }\n\n            priority_queue< Edge<int>, vector< Edge<int> >, greater< Edge<int> > > fs = es;\n            while(!fs.empty()) {\n                Edge<int> cur = fs.top(); fs.pop();\n                int a = cur.from, b = cur.to;\n                bool ng = false;\n                if(!points[a] || !points[b]) ng = true;\n                if(uff.same(a, b)) ng = true;\n                if(!ng) {\n                    uff.unite(a, b);\n                    ans += cur.cost;\n                }\n            }\n        }\n        cout << (uff.size() == 1 ? ans : 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a),b=Find(b);\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\tdata[a]+=data[b];\n\t\tdata[b]=a;\n\t\treturn true;\n\t}\n\tint Size(int i){\n\t\treturn -data[Find(i)];\n\t}\n};\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\n\nostream& operator<<(ostream& os,const Edge& e){\n\treturn os<<'('<<e.src<<','<<e.dst<<','<<e.weight<<')';\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi ts(n);\n\t\trep(i,n) cin>>ts[i];\n\t\t\n\t\tvector<Edge> es;\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w; u--,v--;\n\t\t\tes.emplace_back(u,v,w);\n\t\t}\n\t\tsort(all(es));\n\t\t\n\t\tvi ts2=ts;\n\t\tsort(all(ts2));\n\t\tts2.erase(unique(all(ts2)),end(ts2));\n\t\t\n\t\tint k;\n\t\tfor(k=0;k<ts2.size();k++){\n\t\t\tUnionFind uf(n);\n\t\t\tint cc=count_if(all(ts),[&](int x){return x>=ts2[k];});\n\t\t\tfor(auto e:es) if(ts[e.src]>=ts2[k] && ts[e.dst]>=ts2[k])\n\t\t\t\tcc-=uf.Unite(e.src,e.dst);\n\t\t\tif(cc>1) break;\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\tvi use(n);\n\t\tint res=0;\n\t\tper(i,k)\n\t\t\tfor(auto e:es) if(ts[e.src]>=ts2[i] && ts[e.dst]>=ts2[i])\n\t\t\t\tif(uf.Unite(e.src,e.dst))\n\t\t\t\t\tres+=e.weight;\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint n, m;\nint v[200];\nvector<int> h;\nint par[200];\nint d[200][200];\nvector<PIP> bridge;\n\nint find(int a) {\n    if (par[a] == a) return a;\n    return par[a] = find(par[a]);\n}\n\nvoid unite(int a, int b) {\n    int p = find(a), q = find(b);\n    if(p == q) return;\n    par[p] = q;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    while(cin >> n >> m, n | m) {\n        memset(d, 0, sizeof(d));\n        h.clear(), bridge.clear();\n\n        rep(i, n) cin >> v[i], h.pb(v[i]);\n        sort(all(h));\n        uni(h);\n\n        rep(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c; a--, b--;\n            d[a][b] = d[b][a] = c;\n            bridge.pb(PIP(c, P(a, b)));\n        }\n        sort(all(bridge));\n\n        iota(par, par + n, 0);\n\n        int tmp = h.size();\n        rep(i, h.size()) {\n            iota(par, par + n, 0);\n            int k;\n            rep(j, m) {\n                int p = bridge[j].se.fi, q = bridge[j].se.se;\n                if (v[p] > h[i] && v[q] > h[i] && find(p) != find(q)) {\n                    k = p;\n                    unite(p, q);\n                }\n            }\n\n            bool ok = true;\n            rep(j, n) if (v[j] > h[i] && find(j) != find(k)) ok = false;\n\n            if (!ok) {\n                tmp = i;\n                break;\n            }\n        }\n\n        int cost = 0;\n        iota(par, par + n, 0);\n        repr(i, tmp) {\n            rep(j, m) {\n                int p = bridge[j].se.fi, q = bridge[j].se.se;\n                if (v[p] > h[i] && v[q] > h[i] && find(p) != find(q)) {\n                    cost += bridge[j].fi;\n                    unite(p, q);\n                }\n            }\n        }\n\n        rep(j, m) {\n            int p = bridge[j].se.fi, q = bridge[j].se.se;\n            if (find(p) != find(q)) {\n                cost += bridge[j].fi;\n                unite(p, q);\n            }\n        }\n\n        rep(i, n) if (find(0) != find(i)) cost = 0;\n\n        cout << cost << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,a,b) for(int i=(a); i<(b); i++)\n#define FORR(i,a,b) for(int i=(b)-1; i>=(a); i--)\n\n#define ALL(v) (v).begin(), (v).end()\n#define CHMAX(a,b) a=max(a,b)\n#define CHMIN(a,b) a=min(a,b)\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n\nint n,m;\nint h[252];\npair<int,pii> es[252*252];\nint ids[252];\n\nint dat[252];\nvoid init(){\n    fill(dat,dat+252,-1);\n}\nint root(int x){\n    return dat[x]<0 ? x : dat[x]=root(dat[x]);\n}\nbool unite(int a, int b){\n    a=root(a);b=root(b);\n    if(a==b)return false;\n    dat[a] += dat[b];\n    dat[b] = a;\n    return true;\n}\n\nint main(){\n    while(true){\n        scanf(\"%d%d\",&n,&m);\n        if(n+m==0)break;\n        REP(i,n)scanf(\"%d\",h+i);\n        REP(i,m){\n            int a,b,c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            --a;--b;\n            es[i] = make_pair(c,pii(a,b));\n        }\n        REP(i,n)ids[i] = i;\n        sort(ids,ids+n,[&](int i,int j){return h[i]<h[j];});\n        int t = -1;\n        REP(i,n+1){\n            int tt = i==0 ? 0 : h[ids[i-1]];\n            int z = 0;\n            REP(i,n)if(h[i]>tt)z=i;\n            int cnt = 0;\n            REP(i,n)if(h[i]>tt)cnt++;\n            init();\n            REP(i,m){\n                int a = es[i].second.first;\n                int b = es[i].second.second;\n                if(h[a]<=tt || h[b]<=tt)continue;\n                unite(a,b);\n            }\n            if(-dat[root(z)]==cnt){\n                t = tt;\n            }else{\n                break;\n            }\n        }\n        if(t==-1){\n            puts(\"0\");\n            continue;\n        }\n        REP(i,n)if(h[i]>t)h[i]=t+1;\n        sort(es,es+m,[&](pair<int,pii> a, pair<int,pii> b){\n            int ta = min(h[a.second.first],h[a.second.second]);\n            int tb = min(h[b.second.first],h[b.second.second]);\n            if(ta != tb)return ta > tb;\n            return a.first < b.first;\n        });\n        init();\n        int ans = 0;\n        REP(i,m){\n            if(unite(es[i].second.first, es[i].second.second)){\n                ans += es[i].first;\n            }\n        }\n        if(-dat[root(0)]!=n)ans=0;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct edge{\n\tint a, b, c;\n\t\n\tbool operator< (const edge &e) const{\n\t\treturn c > e.c;\n\t}\n};\n\nstruct UF{\n\tvector<int> par;\n\n\texplicit UF(int n): par(n + 1){\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\treturn x != par[x] ? par[x] = find(par[x]) : x;\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y){ return false; }\n\t\tpar[x] = y;\n\t\treturn true;\n\t}\n\t\n\tint count(const vector<char> msk){\n\t\tint r = 0;\n\t\tfor(int i = 1; i < par.size(); ++i){\n\t\t\tif(msk[i] && find(i) == i){ ++r; }\n\t\t}\n\t\treturn r;\n\t}\n};\n\nint main(){\n\tint n, m, a, b, c;\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tvector<pii> f(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &f[i].first);\n\t\t\tf[i].second = i + 1;\n\t\t}\n\t\tsort(f.begin(), f.end());\n\n\t\tvector<vector<int> > G(n + 1, vector<int>(n + 1, -1));\n\t\tUF uf(n);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tG[a][b] = G[b][a] = c;\n\t\t\tuf.unite(a, b);\n\t\t}\n\n\t\tint ans = 0;\n\t\tvector<char> alive(n + 1, 1);\n\t\tif(uf.count(alive) < 2){\n\t\t\tint k = 0;\n\t\t\twhile(k < n){\n\t\t\t\tint ktmp = k;\n\t\t\t\tint tm = f[k].first;\n\t\t\t\twhile(k < n && f[k].first == tm){\n\t\t\t\t\tint v = f[k].second;\n\t\t\t\t\talive[v] = 0;\n\t\t\t\t\t++k;\n\t\t\t\t}\n\n\t\t\t\tUF uf1(n);\n\t\t\t\tfor(int i = 1; i <= n; ++i)\n\t\t\t\tfor(int j = 1; j < i; ++j){\n\t\t\t\t\tif(alive[i] && alive[j] && G[i][j] >= 0){\n\t\t\t\t\t\tuf1.unite(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(uf1.count(alive) > 1){\n\t\t\t\t\tk = ktmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = k; i < n; ++i){\n\t\t\t\tf[i].first = f.back().first;\n\t\t\t}\n\t\t\tfill(alive.begin(), alive.end(), 0);\n\t\t\t\t//同一時刻で沈むとみなす\n\t\t\t\n\t\t\tuf = UF(n);\n\t\t\tk = n - 1;\n\t\t\tpriority_queue<edge> pq;\n\t\t\twhile(k >= 0){\n\t\t\t\tint tm = f[k].first;\n\t\t\t\twhile(k >= 0 && f[k].first == tm){\n\t\t\t\t\tint v = f[k].second;\n\t\t\t\t\talive[v] = 1;\n\t\t\t\t\tfor(int u = 1; u <= n; ++u){\n\t\t\t\t\t\tif(alive[u] && G[v][u] >= 0){\n\t\t\t\t\t\t\tpq.push((edge){v, u, G[v][u]});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t--k;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile(!pq.empty()){\n\t\t\t\t\tedge e = pq.top();\n\t\t\t\t\tpq.pop();\n\t\t\t\t\tif(uf.unite(e.a, e.b)){\n\t\t\t\t\t\tans += e.c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nclass UnionFind{\npublic:\n  vector<int> v;\n  UnionFind(int n){\n    v.resize(n);\n    Init();\n  }\n  void Init(){\n    for(int i=0;i<(int)v.size();i++) v[i]=i;\n  }\n  int Find(int i){\n    if(v[i] == i) return i;\n    else return (v[i] = Find(v[i]));\n  }\n  bool Same(int a,int b){\n    return (Find(a) == Find(b));\n  }\n  bool Union(int a,int b){\n    int ap = Find(a);\n    int bp = Find(b);\n    if(ap == bp) return false;\n    v[ap] = bp;\n    return true;\n  }\n};\n\nstruct Edge{\n  int a,b,c;\n  Edge(int _a,int _b,int _c):a(_a),b(_b),c(_c){}\n};\n\nbool operator<(Edge e1,Edge e2){\n  return (e1.c < e2.c);\n}\n\n\nint kruskal(vector<Edge> &elist,vector<bool> &active,vector<int> &hi,int t,UnionFind &uf){\n  int ans = 0;\n  for(int i=0;i<(int)elist.size();i++){\n    if(active[elist[i].a] && active[elist[i].b] && \n       uf.Union(elist[i].a,elist[i].b)){\n      ans += elist[i].c;\n    }\n  }\n  return ans;\n}\n\nbool check(vector<Edge> &elist,vector<bool> &active){\n  UnionFind uf(active.size());\n  for(int i=0;i<(int)elist.size();i++){\n    if(active[elist[i].a]&&active[elist[i].b])\n      uf.Union(elist[i].a,elist[i].b);\n  }\n  int p = -1;\n  for(int i=0;i<(int)active.size();i++) {\n    if(p == -1 && active[i]) p = uf.Find(i);\n    if(active[i]&&p != uf.Find(i)) return false;\n  }\n  if(p == -1) return false;\n  return true;\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m,n+m){\n    vector<int> hi(n);\n    map<int,vector<int> > ivmap;\n    for(int i=0;i<n;i++){\n      cin>>hi[i];\n      ivmap[hi[i]].push_back(i);\n    }\n    vector<Edge> elist;\n    elist.reserve(m);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--;b--;\n      elist.push_back(Edge(a,b,c));\n    }\n    sort(elist.begin(),elist.end());\n    vector<bool> active(n,false);\n    int ans = 0;\n    UnionFind uf(n);\n    map<int,vector<int> >::reverse_iterator it;\n    for(it=ivmap.rbegin();it!=ivmap.rend();it++){\n      if(check(elist,active)){\n\tbreak;\n      }\n      for(int i=0;i<(int)(it->second).size();i++){\n\tactive[(it->second)[i]]=true;\n      }\n    }\n    for(;it!=ivmap.rend();it++){\n      for(int i=0;i<(int)(it->second).size();i++){\n\tactive[(it->second)[i]]=true;\n      }\n      if(!check(elist,active)) continue;\n\n      ans += kruskal(elist,active,hi,it->first,uf);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nstruct UnionFindTree{\n    vector<int> v;\n    vector<int> rank;\n    UnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        if(v[x] != x){\n            v[x] = Find(v[x]);\n        }\n        return v[x];\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nstruct edge{\n\tint x,y,c;\n\tedge(int x, int y, int c):x(x),y(y),c(c){}\n\tedge(){}\n\tbool operator < (const edge &a) const{\n\t\treturn c < a.c;\n\t}\n};\n\nbool isConnected(int n, vector<edge> &bridge, vector<bool> &canuse){\n\tUnionFindTree uft(n);\n\tfor(int i=0; i<(int)bridge.size(); i++){\n\t\tif(canuse[bridge[i].x] && canuse[bridge[i].y]){\n\t\t\tuft.Union(bridge[i].x, bridge[i].y);\n\t\t}\n\t}\n\t\n\tint root = -1;\n\tfor(int i=0; i<n; i++){\n\t\tif(canuse[i]){\n\t\t\tif(root!=-1 && root!=uft.Find(i)) return false;\n\t\t\tif(root==-1) root = uft.Find(i);\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<pair<int,int> > time(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\ttime[i] = make_pair(h, i);\n\t\t}\n\t\tsort(time.begin(), time.end());\n\t\treverse(time.begin(), time.end());\n\t\t\n\t\tvector<edge> bridge(m);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tbridge[i] = edge(a,b,c);\n\t\t}\n\t\tsort(bridge.begin(), bridge.end());\n\t\t\n\t\tvector<bool> usable(n, false);\n\t\tint lasti = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tusable[time[i].second] = true;\n\t\t\twhile(i+1<n && time[i].first==time[i+1].first){\n\t\t\t\ti++;\n\t\t\t\tusable[time[i].second] = true;\n\t\t\t}\n\t\t\tif(!isConnected(n, bridge, usable)) lasti = i+1;\n\t\t}\n\t\t\n\t\tUnionFindTree uft(n);\n\t\tfill(usable.begin(), usable.end(), false);\n\t\tint ans=0;\n\t\tfor(int i=0; i<lasti; i++){\n\t\t\tusable[time[i].second] = true;\n\t\t}\n\t\tfor(int i=lasti; i<n; i++){\n\t\t\tusable[time[i].second] = true;\n\t\t\twhile(i+1<n && time[i].first==time[i+1].first){\n\t\t\t\ti++;\n\t\t\t\tusable[time[i].second] = true;\n\t\t\t}\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tedge e = bridge[j];\n\t\t\t\tif(usable[e.x] && usable[e.y] && uft.Find(e.x)!=uft.Find(e.y)){\n\t\t\t\t\tans += e.c;\n\t\t\t\t\tuft.Union(e.x, e.y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n/*????????§???*/\n\nint p[502],p2[502];\nint r[502],r2[502];\n\nvoid init(int n){\n    for (int i = 0; i < n; ++i) {\n        p[i]=i;\n        r[i]=0;\n    }\n}\n\n\nint find(int x){\n\tif(x != p[x]){\n\t\tp[x] = find(p[x]);\n    }\n   \treturn p[x];\n}\n     \nvoid union_set(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x==y) return;\n\tif(r[x] < r[y]){\n\t\tp[x] = y;\t\n\t}else{\n\t\tp[y] = x;\n\t\tif(r[x] == r[y])r[x]++;\n\t}\n\treturn ;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m &&n!=0){\n\t\tll ans = 0;\n\t\tvector<int>t(n);\n\t\trep(i,n){\n\t\t\tcin >> t[i];\n\t\t}\n\t\tvector<pair<int,int> > v(n);\n\t\trep(i,n){\n\t\t\tv[i] = MP(t[i],i);\n\t\t}\n\t\tsort(v.begin(),v.end(),greater<pair<int,int> >());\n\t\tvector<set<int> >vst;\n\t\tset<int>st;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==n-1){\n\t\t\t\tst.insert(v[i].second);\n\t\t\t\tvst.PB(st);\n\t\t\t}else{\n\t\t\t\tst.insert(v[i].second);\n\t\t\t\tif(v[i].second!=v[i+1].second){\n\t\t\t\t\tvst.PB(st);\n\t\t\t\t\tst.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<pair<ll,pair<int,int > > >node;\n\t\tinit(502);\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tll c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tnode.PB(MP(c,MP(a,b)));\n\t\t}\n\t\tsort(node.begin(),node.end());\n\t\tset<int>nst;\n\t\tvector<bool>flag(n);\n\t\tint cnt=0;\n\t\tint nod=0;\n\t\tfor(int i=0;i<vst.size();i++){\n\t\t\tfor(auto x:vst[i]){\n\t\t\t\tnst.insert(x);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tfor(auto x:node){\n\t\t\t\tif(nst.count(x.second.first)!=0&&nst.count(x.second.second)!=0){\n\t\t\t\t\tif(find(x.second.first)!=find(x.second.second)){\n\t\t\t\t\t\tans += x.first;\n\t\t\t\t\t\tunion_set(x.second.first,x.second.second);\n\t\t\t\t\t\tnod++;\n\t\t\t\t\t\t//cout << x.second.first << \" \" << x.second.second << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nod!=n-1){\n\t\t\tans = 0;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int , int > Pi;\n\nclass DisjointSet{\nprivate:\n  vector<int> rank, p;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    }else{\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n  }\n  void makeSet(int x){\n    p[x] = x, rank[x] = 0;\n  }\n  void Union(int x,int y){\n    link(findSet(x),findSet(y));\n  }\n  int findSet(int x){\n    return( x != p[x] ? p[x] = findSet(p[x]) : p[x]);\n  }\n};\n\nstruct edge{\n  int u, v, cost;\n  bool operator<(const edge& hoge)const{\n    return cost < hoge.cost;\n  }\n};\ntypedef vector< edge > Edges;\nDisjointSet* uf_tree;\nPi kruskal(Edges& edges, vector< bool >& done){\n  int ret = 0;\n  for(int i = 0; i < edges.size(); i++){\n    edge& e = edges[i];\n    if(done[e.u] && done[e.v] && uf_tree -> findSet(e.u) != uf_tree -> findSet(e.v)){\n      uf_tree -> Union( e.u, e.v);\n      ret += e.cost;\n    }\n  }\n  for(int i = 0; i < done.size(); i++){\n    for(int j = i + 1; j < done.size(); j++){\n      if(done[i] && done[j] && uf_tree -> findSet(i) != uf_tree -> findSet(j)) return make_pair( false, ret);\n    }\n  }\n  return make_pair( true, ret);\n}\n\nint main(){\n  int N, M;\n  Pi h[200];\n  Edges edges;\n\n  while(cin >> N >> M, N){\n\n    uf_tree = new DisjointSet(N);\n    for(int i = 0; i < N; i++){\n      uf_tree -> makeSet(i);\n    }\n\n    for(int i = 0; i < N; i++){\n      cin >> h[i].first;\n      h[i].second = i;\n    }\n    sort( h, h + N);\n    for(int i = 0; i < M; i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--, b--;\n      edges.push_back((edge){ a, b, c});\n      edges.push_back((edge){ b, a, c});\n    }\n    sort( edges.begin(), edges.end());\n\n    int ret = 0;\n    vector< bool > done(N, false);\n\n    done[h[N - 1].second] = true;\n\n    for(int i = N - 2; i >= 0; ){\n      int j = i;\n      while(j >= 0 && h[i].first == h[j].first){\n        done[h[j].second] = true;\n        j--;\n      }\n      Pi p = kruskal( edges, done);\n      if(p.first){\n        ret += p.second;\n      } else {\n        ret = 0;\n        delete uf_tree;\n        uf_tree = new DisjointSet(N);\n        for(int j = 0; j < N; j++){\n          uf_tree -> makeSet(j);\n        }\n      }\n      i = j;\n    }\n    if(uf_tree != NULL) delete uf_tree;\n    cout << ret << endl;\n    edges.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace EGraph{\n\ttypedef int Cost;Cost CINF=1<<28;\n\tstruct Edge{\n\t\tint from,to;Cost cost;;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost){};\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n}\nusing namespace EGraph;\n\n\nstruct UnionFind{\n    vector<int> par; // 親\n    vector<int> rank; // 木の深さ\n    vector<int> ss;//xの属する集合のサイズ\n    int size;//集合の個数\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){\n            par[x] = y;ss[y]+=ss[x];\n        }else{\n            par[y] = x;ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\n\nvector<int> hs;\nint col(const Edge &e){\n\treturn min(hs[e.from],hs[e.to]);\n}\n\t\nclass CompTDesc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)>col(r);\n\t}\n};\n\nclass CompTAsc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)<col(r);\n\t}\n};\n\nclass CompC{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn l.cost> r.cost;\n\t}\n};\n\nclass Main{\npublic:\n\n\tGraph g;\n\tvector<Edge> es;\n\tbool input(){\n\t\tcin >> N >> M;if(N==0 && M==0)return false;\n\t\ths=vector<int>(N);\n\t\tREP(i,N){\n\t\t\tcin >> hs[i];\n\t\t}\n\t\tg=Graph(N);\n\n\t\tes=vector<Edge>();\n\t\tREP(i,M){\n\t\t\tint a,b,c;cin >> a >> b >> c;a--;b--;\n\t\t\tes.push_back(Edge(a,b,c));\n\t\t\tes.push_back(Edge(b,a,c));\n\t\t}\n\t\treturn true;\n\t}\n\tint N,M;\n\tint INF=1<<28;\n\tvector<bool> ex;\n\tvoid run(){\n\t\twhile(input()){\n\n\t\t\tsort(ALL(es),CompTDesc());\n\t\t\tUnionFind uf(N);\n\t\t\tint endT=-INF;\n\t\t\tREP(i,2*M){\n\t\t\t\tuf.unite(es[i].from,es[i].to);int T=col(es[i]);\n\t\t\t\twhile(i+1<2*M && T==col(es[i+1])){\n\t\t\t\t\tuf.unite(es[i+1].from,es[i+1].to);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t//check\n\t\t\t\tbool ok=true;\n\t\t\t\tREP(j,N)REP(k,N)if(T<=hs[j] && T<=hs[k] &&  !uf.same(j,k)){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t\tif(ok && endT==-INF){\n\t\t\t\t\tendT=T;\n\t\t\t\t}else if(!ok && endT!=-INF){\n\t\t\t\t\tendT=-INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(endT==-INF){\n\t\t\t\tcout << 0 <<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tCost res=0;\n\t\t\tUnionFind ufc(N);\n\t\t\tpriority_queue<Edge,vector<Edge>,CompC> que;\n\t\t\tint T=endT;\n\t\t\t//end\n\t\t\tREP(i,2*M){\n\t\t\t\tif(endT<=col(es[i]))que.push(es[i]);\n\t\t\t}\n\t\t\t//cruskal\n\t\t\twhile(!que.empty()){\n\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\t//\tDUMP(e.to);DUMP(ufc.same(e.from,e.to));\n\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\tres+=e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//reflesh\n\t\t\tREP(i,2*M){\n\t\t\t\tif(col(es[i])<T){\n\t\t\t\t\tT=col(es[i]);que.push(es[i]);\n\t\t\t\t}\n\t\t\t\twhile(i+1<2*M && T==col(es[i+1])){\n\t\t\t\t\tque.push(es[i+1]);i++;\n\t\t\t\t}\n\t\t\t\t//cruskal\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\t\tres+=e.cost;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t\tcout <<res<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nint n, m;\nbool exist[210], used[210];\nbool cur_used[210];\nvector<pii> disap;\nint cost[210][210];\nint prim_cost[210];\n\nint main(){\n  while(1) {\n    cin >> n >> m;\n    if (n==0) break;\n\n    disap = vector<pii>();\n    REP(i, n) {\n      exist[i] = false;\n      used[i] = false;\n    }\n\n    REP(i, n) {\n      REP(j, n) {\n        cost[i][j] = INF;\n      }\n    }\n\n    REP(i, n) {\n      int h;\n      cin >> h;\n      disap.push_back(pii(h, i));\n    }\n\n    REP(i, m) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      cost[a-1][b-1] = c;\n      cost[b-1][a-1] = c;\n    }\n\n    sort(disap.begin(), disap.end(), greater<pii>());\n\n    int output = 0;\n    REP(i, n) {\n      exist[disap[i].second] = true;\n\n      if (i==0) {\n        used[disap[0].second] = true;\n        continue;\n      }\n\n      if (i<n-1 && disap[i].first == disap[i+1].first) {\n        continue;\n      }\n\n      REP(j, n) {\n        cur_used[j] = used[j];\n        prim_cost[j] = INF;\n      }\n\n      REP(j, n) {\n        if (!exist[j]) continue;\n        REP(k, n) {\n          if (!cur_used[k]) continue;\n          prim_cost[j] = min(prim_cost[j], cost[j][k]);\n        }\n      }\n\n      int cur_cost = 0;\n      while(true) {\n        int v = -1;\n        REP(j, n) {\n          if(!cur_used[j] && prim_cost[j] < INF\n             && (v==-1 || prim_cost[j] < prim_cost[v])) v = j;\n        }\n#ifdef DEBUG\n        cout << v << \" \" << prim_cost[v] << \" \" << disap[i].second << endl;\n#endif\n\n        if (v==-1) break;\n        cur_used[v] = true;\n        cur_cost += prim_cost[v];\n\n        REP(j, n) {\n          if (exist[j]) {\n            prim_cost[j] = min(prim_cost[j], cost[v][j]);\n          }\n        }\n      }\n\n      bool update = true;\n      REP(j, n) {\n        if (cur_used[j] != exist[j]) {\n          update = false; break;\n        }\n      }\n      \n      if (!update) {\n        REP(j, n) {\n          used[j] = false;\n        }\n        used[disap[0].second] = true;\n        output = 0;\n        continue;\n      }\n\n      REP(j, n) {\n        used[j] = cur_used[j];\n      }\n      output += cur_cost;\n#ifdef DEBUG\n      cout << output << \" cost\" << endl;\n#endif\n    }\n\n    cout << output << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\nprivate:\n\tstd::vector<int> value;\npublic:\n\tUnionFind(int size): value(size, -1){}\n\tint find(int x){\n\t\treturn value[x] < 0 ? x : value[x] = find(value[x]);\n\t}\n\tint size(int x){\n\t\treturn -value[find(x)];\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\tbool unite(int x, int y){\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\tif (value[x] > value[y]) std::swap(x, y);\n\t\tvalue[x] += value[y];\n\t\tvalue[y] = x;\n\t\treturn true;\n\t}\n};\n\nstruct Edge {\n\tint s, t, cost;\n\tEdge(){}\n\tEdge(int s, int t, int cost): s(s), t(t), cost(cost){}\n};\n\nint n, m;\nint h[200];\nvector<Edge> es;\n\nlong long calc()\n{\n\tvector<pair<int, int>> v;\n\tfor (int i = 0; i < n; i++){\n\t\tv.push_back(make_pair(-h[i], i));\n\t}\n\tsort(v.begin(), v.end());\n\tfor (int i = 0; i < n; i++) h[i] = v[i].second;\n\tsort(es.begin(), es.end(), [](const Edge &a, const Edge &b){\n\t\treturn a.cost < b.cost;\n\t});\n\t\n\tlong long sum = 0;\n\tUnionFind uf(n);\n\tbool f[200] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tf[h[i]] = true;\n\t\tfor (auto &e : es){\n\t\t\tif (f[e.s] && f[e.t] && uf.unite(e.s, e.t)){\n\t\t\t\tsum += e.cost;\n\t\t\t}\n\t\t}\n\t\tif (uf.size(h[0]) != i + 1){\n\t\t\tuf = UnionFind(n);\n\t\t\tsum = 0;\n\t\t}\n\t}\n\t\n\treturn sum;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tes.clear();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", h + i);\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tes.push_back(Edge(--a, --b, c));\n\t\t}\n\t\tprintf(\"%lld\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int to,cost;};\nstruct edge2{int from,to,cost;};\nint N,M,h[200];\nvector<edge> G[200];\nvector<int> ash,vc[200];\nint ord[200];\nvector<edge2> es;\nbool operator<(const edge2& a,const edge2& b){\n\treturn a.cost<b.cost;\n}\nint par[200];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\treturn par[x]=find(par[x]);\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tpar[x]=y;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\trep(i,N) cin>>h[i];\n\t\trep(i,N) ash.pb(h[i]);\n\t\trep(i,N) vc[i].clear();\n\t\tsort(all(ash));\n\t\tash.erase(unique(all(ash)),ash.end());\n\t\trep(i,N){\n\t\t\tord[i]=ash.end()-lower_bound(all(ash),h[i])-1;\n\t\t\tvc[ord[i]].pb(i);\n\t\t}\n\t\trep(i,N) G[i].clear();\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--,b--;\n\t\t\tG[a].pb(edge{b,c});\n\t\t\tG[b].pb(edge{a,c});\n\t\t}\n\t\tint k=ash.size();\n\t\tinit(N);\n\t\tint last=-1;\n\t\trep(i,k){\n\t\t\tfor(int v:vc[i]){\n\t\t\t\tfor(edge e:G[v]){\n\t\t\t\t\tint u=e.to;\n\t\t\t\t\tif(ord[u]<=i) unite(u,v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x=-1;\n\t\t\tbool con=true;\n\t\t\trep(j,N){\n\t\t\t\tif(ord[j]<=i){\n\t\t\t\t\tif(x==-1){\n\t\t\t\t\t\tx=find(j);\n\t\t\t\t\t}else if(x!=find(j)){\n\t\t\t\t\t\tcon=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!con) last=i;\n\t\t}\n\t\tlong long ans=0;\n\t\tbool first=true;\n\t\tinit(N);\n\t\tfor(int i=last+1;i<k;i++){\n\t\t\tif(first){\n\t\t\t\tfirst=false;\n\t\t\t\tes.clear();\n\t\t\t\trep(j,N){\n\t\t\t\t\tif(ord[j]>i) continue;\n\t\t\t\t\tfor(edge e:G[j]){\n\t\t\t\t\t\tif(ord[e.to]>i) continue;\n\t\t\t\t\t\tedge2 e2=edge2{j,e.to,e.cost};\n\t\t\t\t\t\tes.pb(e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(all(es));\n\t\t\t\tfor(edge2 e:es){\n\t\t\t\t\tint x=e.from,y=e.to,c=e.cost;\n\t\t\t\t\tif(!same(x,y)){\n\t\t\t\t\t\tunite(x,y);\n\t\t\t\t\t\tans+=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tes.clear();\n\t\t\t\trep(j,N){\n\t\t\t\t\tif(ord[j]!=i) continue;\n\t\t\t\t\tfor(edge e:G[j]){\n\t\t\t\t\t\tif(ord[e.to]>i) continue;\n\t\t\t\t\t\tedge2 e2=edge2{j,e.to,e.cost};\n\t\t\t\t\t\tes.pb(e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(all(es));\n\t\t\t\tfor(edge2 e:es){\n\t\t\t\t\tint x=e.from,y=e.to,c=e.cost;\n\t\t\t\t\tif(!same(x,y)){\n\t\t\t\t\t\tunite(x,y);\n\t\t\t\t\t\tans+=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight < rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\n\n// Light version\n\nstruct UnionFind {\n  vector<int> p;\n  UnionFind (int n) { p.assign(n, -1); }\n  int root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n  void merge(int x, int y) { if (root(x) != root(y)) p[root(y)] = x; }\n};\n\n// Kruskal\n// N, operator <\nEdges kruskal(UnionFind& uf, Edges &es) {\n  Edges res;\n  REP(i, es.size()) {\n    Edge e = es[i];\n    if(uf.root(e.src) != uf.root(e.dest)) {\n      uf.merge(e.src, e.dest);\n      res.push_back(e);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n)break;\n    multimap<int,int> hm;\n    vector<int> hv;\n    REP(i,n) {\n      int h;\n      cin>>h;\n      hm.insert(make_pair(h,i));\n      hv.push_back(h);\n    }\n    Edges es;\n    REP(i,m) {\n      int a,b,c;\n      cin>>a>>b>>c;\n      --a;--b;\n      es.push_back((Edge){a,b,c});\n    }\n    sort(es.begin(), es.end());\n    int64_t csum = 0;\n    UnionFind uf(n);\n    for(int i=1000000; i>0; --i) {\n      auto p = hm.equal_range(i);\n      if (p.first == p.second) continue;\n      Edges ee;\n      for(Edge e:es) {\n        if (hv[e.src] >= i && hv[e.dest] >= i) ee.push_back(e);\n      }\n      vector<int> iss;\n      REP(j,n)\n        if (hv[j] >= i)\n          iss.push_back(j);\n      Edges brg = kruskal(uf,ee);\n      bool ok = true;\n      REP(j,iss.size()) {\n        if (uf.root(iss[j]) != uf.root(iss[0]))\n          ok = false;\n      }\n      if (!ok) {\n        csum = 0;\n        uf = UnionFind(n);\n      } else {\n        for (Edge e:brg) {\n          csum += e.weight;\n        }\n      }\n    }\n    cout << csum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nvector<PII> g[205];\nVI t[205];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    REP(i, 205) g[i].clear(), t[i].clear();\n    uf.init(n);\n    VI h(n), hh(n);\n    REP(i, n) cin >> h[i], hh[i] = h[i];\n    VI a(m), b(m), c(m);\n    REP(i, m) {\n      cin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n      g[a[i]].PB({b[i], c[i]});\n      g[b[i]].PB({a[i], c[i]});\n    }\n\n    VI ver(n);\n    sort(ALL(hh));\n    hh.erase(unique(ALL(hh)), hh.end());\n    REP(i, n) h[i] = lower_bound(ALL(hh), h[i]) - hh.begin();\n    REP(i, n) {\n      t[h[i]].PB(i);\n      ver[i] = h[i];\n    }\n\n    // cout << ver << endl;\n\n    int last = hh.size()-1;\n    VI exist(n, 1);\n    VI used(n, 0);\n\n    function<void(int)> dfs = [&](int x) {\n      used[x] = true;\n      for(auto i: g[x]) if(!used[i.first]) dfs(i.first);\n    };\n\n    REP(i, hh.size()) {\n      // cout << i << endl;\n      // 時刻iで沈む頂点を除く\n      for(int j: t[i]) exist[j] = 0;\n      REP(j, n) used[j] = !exist[j];\n\n      // dfsで連結性を確かめる\n      int cnt = 0;\n      REP(j, n) {\n        // cout << \"j:\" << j << endl;\n        if(used[j]) continue;\n        dfs(j);\n        cnt++;\n      }\n      if(cnt >= 2) {\n        last = i;\n        break;\n      }\n    }\n\n    // そもそも二つに分裂してる状態\n    // dfsで連結性を確かめる\n    used.assign(n, 0);\n    int cnt = 0;\n    REP(j, n) {\n      if(used[j]) continue;\n      dfs(j);\n      cnt++;\n    }\n    if(cnt >= 2) {\n      cout << 0 << endl;\n      continue;\n    }\n    // cout << \"a\" << endl;\n\n    VVI edge[205];\n    REP(i, m) edge[min(ver[a[i]], ver[b[i]])].PB({c[i], a[i], b[i]});\n    // REP(i, hh.size()) cout << edge[i] << \" \" << t[i] << endl;\n\n    // 時刻[last, hh.size()-1]までで沈む頂点に関する辺集合\n    VVI vec;\n    FOR(i, last, hh.size()) {\n      for(auto j: edge[i]) {\n        vec.PB(j);\n      }\n    }\n    // cout << vec << endl;\n    sort(ALL(vec));\n    int ans = 0;\n    for(auto j: vec) {\n      if(uf.same(j[1], j[2])) continue;\n      ans += j[0];\n      uf.unite(j[1], j[2]);\n    }\n    // cout << ans << endl;\n\n    for(int i=last-1; i>=0; --i) {\n      // 時間iで沈む頂点に関連する辺集合\n      sort(ALL(edge[i]));\n      for(auto j: edge[i]) {\n        if(uf.same(j[1], j[2])) continue;\n        ans += j[0];\n        uf.unite(j[1], j[2]);\n      }\n      // cout << ans << endl;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace EGraph{\n\ttypedef int Cost;Cost CINF=1<<28;\n\tstruct Edge{\n\t\tint from,to;Cost cost;;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost){};\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n}\nusing namespace EGraph;\n\n\nstruct UnionFind{\n    vector<int> par; // 親\n    vector<int> rank; // 木の深さ\n    vector<int> ss;//xの属する集合のサイズ\n    int size;//集合の個数\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){\n            par[x] = y;ss[y]+=ss[x];\n        }else{\n            par[y] = x;ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\n\nvector<int> hs;\n\nint col(const Edge &e){\n\treturn min(hs[e.from],hs[e.to]);\n}\n\t\nclass CompTDesc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)>col(r);\n\t}\n};\n\nclass CompTAsc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)<col(r);\n\t}\n};\n\nclass CompC{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn l.cost> r.cost;\n\t}\n};\n\n\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tGraph g;\n\tvector<Edge> es;\n\tbool input(istream &cin){\n\t\tcin >> N >> M;if(N==0 && M==0)return false;\n\t\ths=vector<int>(N);\n\t\tREP(i,N){\n\t\t\tcin >> hs[i];\n\t\t}\n\t\tg=Graph(N);\n\n\t\tes=vector<Edge>();\n\t\tREP(i,M){\n\t\t\tint a,b,c;cin >> a >> b >> c;a--;b--;\n\t\t\tes.push_back(Edge(a,b,c));\n\t\t\tes.push_back(Edge(b,a,c));\n\t\t}\n\t\treturn true;\n\t}\n\tint N,M;\n\tvoid run(){\n\t\tofstream cout(\"out\");\n\t\tifstream cin(\"in\");\n\n\t\twhile(input(cin)){\n\n\t\t\t\n\t\t\tvector<int> ts;REP(i,N)ts.push_back(hs[i]);\n\t\t\tts.push_back(0);\n\t\t\tsort(ALL(ts),greater<int>());\n\n\t\t\tsort(ALL(es),CompTDesc());\n\t\t\tUnionFind uf(N);\n\n\t\t\tint endT=-INF;\n\t\t\t{\n\t\t\t\tint i=0;\n\t\t\t\tREP(ti,ts.size()){\n\t\t\t\t\twhile(i<es.size() && ts[ti]<=col(es[i])){\n\t\t\t\t\t\tuf.unite(es[i].from,es[i].to);i++;\n\t\t\t\t\t}\n\t\t\t\t\t//check\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tREP(j,N)REP(k,N)if(ts[ti]<=hs[j] && ts[ti]<=hs[k] &&  !uf.same(j,k)){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ok && endT==-INF){\n\t\t\t\t\t\tendT=ts[ti];\n\t\t\t\t\t}else if(!ok){\n\t\t\t\t\t\tendT=-INF;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tif(endT==-INF){\n\t\t\t\tcout << 0 <<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tCost res=0;\n\t\t\tUnionFind ufc(N);\n\t\t\tpriority_queue<Edge,vector<Edge>,CompC> que;\n\t\t\t\n\t\t\tint T=endT;\n\t\t\t//end\n\t\t\tint i=0;\n\t\t\tfor(;i<es.size();i++){\n\t\t\t\tif(T<=col(es[i]))que.push(es[i]);\n\t\t\t\telse break;\n\t\t\t}\n\t\t\t//cruskal\n\t\t\twhile(!que.empty()){\n\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\tres+=e.cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//reflesh\n\t\t\tfor(;i<es.size();i++){\n\t\t\t\tT=col(es[i]);\n\t\t\t\tque.push(es[i]);\n\t\t\t\ti++;\n\t\t\t\twhile(i<es.size() && T==col(es[i])){\n\t\t\t\t\tque.push(es[i]);i++;\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t\t//cruskal\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\t\tres+=e.cost;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tcout <<res<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define fi first\n#define se second\n \nint uf[256];\nint rk[256];\n \nvoid uf_init() {\n    for(int i = 0; i < 256; i++) {\n        uf[i] = i;\n        rk[i] = 0;\n    }\n}\n \nint uf_find(int x) {\n    if(uf[x] == x)\n        return x;\n    return uf[x] = uf_find(uf[x]);\n}\n \nbool uf_same(int a, int b) {\n    return uf_find(a) == uf_find(b);\n}\n \nvoid uf_merge(int a, int b) {\n    int aa, bb;\n    aa = uf_find(a);\n    bb = uf_find(b);\n    if(aa == bb)\n        return;\n    if(rk[aa] < rk[bb]) {\n        uf[aa] = bb;\n    }\n    else {\n        if(rk[aa] == rk[bb])\n            rk[aa]++;\n        uf[bb] = aa;\n    }\n}\n \nstruct edge {\n    pii p; // ?????¢\n    ll b; // ????????????\n    ll c; // ?????????\n};\n \nbool cost_cmp(const edge & a, const edge & b) {\n    return a.c < b.c;\n}\nbool time_cmp(const edge & a, const edge & b) {\n    return a.b < b.b;\n}\n \nint main() {\n    int N, M;\n    while(cin >> N >> M, N || M) {\n        vector<pii> h;\n        vector<edge> eg;\n        h.resize(N);\n        for(int i = 0; i < N; i++) {\n            cin >> h[i].fi;\n            h[i].se = i;\n        }\n        for(int i = 0; i < M; i++) {\n            int a, b, c;\n            edge e;\n            cin >> a >> b >> c;\n            a--; b--;\n            if(a > b) swap(a,b);\n            e.p = pii(a,b);\n            e.b = min(h[a].fi, h[b].fi);\n            e.c = c;\n            eg.push_back(e);\n        }\n        sort(eg.begin(), eg.end(), time_cmp);\n        sort(h.begin(), h.end());\n \n        int T = -1;\n        for(int i = 0; i < h.size(); i++) {\n            uf_init();\n            for(int j = 0; j < eg.size(); j++) {\n                if(eg[j].b < h[i].fi)\n                    continue;\n                edge e;\n                e = eg[j];\n                uf_merge(e.p.fi, e.p.se);\n            }\n            bool flg = true;\n            int tmp = uf_find(h[i].se);\n            for(int j = i; j < h.size(); j++) {\n                if(tmp != uf_find(h[j].se))\n                    flg = false;\n            }\n            if(flg == false) {\n                break;\n            }\n            T = h[i].fi;\n            while(i < h.size()-1 && h[i].fi == h[i+1].fi) i++;\n        }\n        ll res = 0;\n        uf_init();\n        while(T >= 0) {\n            vector<edge> v;\n            ll nex_t = -1;\n            for(int i = 0; i < eg.size(); i++) {\n                if(T <= eg[i].b)\n                    v.push_back(eg[i]);\n                else\n                    nex_t = max(nex_t, eg[i].b);\n            }\n            sort(v.begin(), v.end(), cost_cmp);\n            for(int i = 0; i < v.size(); i++) {\n                edge e = v[i];\n                if(!uf_same(e.p.fi, e.p.se)) {\n                    res += e.c;\n                    uf_merge(e.p.fi, e.p.se);\n                }\n            }\n            T = nex_t;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace EGraph{\n\ttypedef int Cost;Cost CINF=1<<28;\n\tstruct Edge{\n\t\tint from,to;Cost cost;;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost){};\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n}\nusing namespace EGraph;\n\n\nstruct UnionFind{\n    vector<int> par; // 親\n    vector<int> rank; // 木の深さ\n    vector<int> ss;//xの属する集合のサイズ\n    int size;//集合の個数\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){\n            par[x] = y;ss[y]+=ss[x];\n        }else{\n            par[y] = x;ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\n\nvector<int> hs;\n\nint col(const Edge &e){\n\treturn min(hs[e.from],hs[e.to]);\n}\n\t\nclass CompTDesc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)>col(r);\n\t}\n};\n\nclass CompTAsc{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn col(l)<col(r);\n\t}\n};\n\nclass CompC{\npublic:\n\tbool operator () (const Edge & l,const Edge & r){\n\t\treturn l.cost> r.cost;\n\t}\n};\n\n\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tGraph g;\n\tvector<Edge> es;\n\tbool input(istream &cin){\n\t\tcin >> N >> M;if(N==0 && M==0)return false;\n\t\ths=vector<int>(N);\n\t\tREP(i,N){\n\t\t\tcin >> hs[i];\n\t\t}\n\t\tg=Graph(N);\n\n\t\tes=vector<Edge>();\n\t\tREP(i,M){\n\t\t\tint a,b,c;cin >> a >> b >> c;a--;b--;\n\t\t\tes.push_back(Edge(a,b,c));\n\t\t\tes.push_back(Edge(b,a,c));\n\t\t}\n\t\treturn true;\n\t}\n\tint N,M;\n\tvoid run(){\n\t\t// ofstream cout(\"out\");\n\t\t// ifstream cin(\"in\");\n\n\t\twhile(input(cin)){\n\n\t\t\t\n\t\t\tvector<int> ts;REP(i,N)ts.push_back(hs[i]);\n\t\t\tts.push_back(0);\n\t\t\tsort(ALL(ts),greater<int>());\n\n\t\t\tsort(ALL(es),CompTDesc());\n\t\t\tUnionFind uf(N);\n\n\t\t\tint endT=-INF;\n\t\t\t{\n\t\t\t\tint i=0;\n\t\t\t\tREP(ti,ts.size()){\n\t\t\t\t\twhile(i<es.size() && ts[ti]<=col(es[i])){\n\t\t\t\t\t\tuf.unite(es[i].from,es[i].to);i++;\n\t\t\t\t\t}\n\t\t\t\t\t//check\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tREP(j,N)REP(k,N)if(ts[ti]<=hs[j] && ts[ti]<=hs[k] &&  !uf.same(j,k)){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ok && endT==-INF){\n\t\t\t\t\t\tendT=ts[ti];\n\t\t\t\t\t}else if(!ok){\n\t\t\t\t\t\tendT=-INF;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tif(endT==-INF){\n\t\t\t\tcout << 0 <<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tCost res=0;\n\t\t\tUnionFind ufc(N);\n\t\t\tpriority_queue<Edge,vector<Edge>,CompC> que;\n\t\t\t\n\t\t\tint T=endT;\n\t\t\t//end\n\t\t\tint i=0;\n\t\t\tfor(;i<es.size();i++){\n\t\t\t\tif(T<=col(es[i]))que.push(es[i]);\n\t\t\t\telse break;\n\t\t\t}\n\t\t\t//cruskal\n\t\t\twhile(!que.empty()){\n\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\tres+=e.cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//reflesh\n\t\t\tfor(;i<es.size();i++){\n\t\t\t\tT=col(es[i]);\n\t\t\t\tque.push(es[i]);\n\t\t\t\ti++;\n\t\t\t\twhile(i<es.size() && T==col(es[i])){\n\t\t\t\t\tque.push(es[i]);i++;\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t\t//cruskal\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tEdge e=que.top();que.pop();\n\t\t\t\t\tif(!ufc.same(e.from,e.to)){\n\t\t\t\t\t\tufc.unite(e.from,e.to);\n\t\t\t\t\t\tres+=e.cost;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tcout <<res<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <functional>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef pair<P, P> WP;\ntypedef long long ll;\n\nconst ll INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\nstruct UnionFind{\n\tvector<int> data;\n\tUnionFind(int size) :data(size, -1){}\n\n\tbool set(int x, int y){\n\t\tx = root(x), y = root(y);\n\t\tif (x != y){\n\t\t\tif (data[x] > data[y])swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x){\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x){\n\t\treturn -data[root(x)];\n\t}\n\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m && n){\n\t\tmap<int, vector<int>> hm;\n\t\thm[0].push_back(0);\n\t\tFor(i, 1, n + 1){\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\thm[h].push_back(i);\n\t\t}\n\t\tvector<T> v;\n\t\t\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv.push_back(T(c, a, b));\n\t\t}\n\t\tsort(all(v));\n\n\t\tint d[201][201];\n\t\trep(i, 201)rep(j, 201)d[i][j] = (i == j ? 1 : 0);\n\n\t\tvector<vector<int>> tv;\n\t\tfor (auto target : hm){\n\t\t\tauto t = target.second;\n\t\t\ttv.push_back(t);\n\n\t\t\tUnionFind uf(n+1);\n\t\t\trep(i, t.size()){\n\t\t\t\tFor(j, 1, n + 1){\n\t\t\t\t\td[t[i]][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f[201]; clr(f);\n\t\t\tFor(i, 1, n + 1){\n\t\t\t\tf[i] = true;\n\t\t\t\tqueue<int> q;\n\t\t\t\tq.push(i);\n\t\t\t\twhile (q.size()){\n\t\t\t\t\tint now = q.front(); q.pop();\n\t\t\t\t\tFor(j, 1, n + 1){\n\t\t\t\t\t\tif (d[now][j] && !f[j]){\n\t\t\t\t\t\t\tf[j] = true;\n\t\t\t\t\t\t\tq.push(j);\n\t\t\t\t\t\t\tuf.set(now, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,v.size()){\n\t\t\t\tT nx = v[i];\n\t\t\t\tint c = get<0>(nx), a = get<1>(nx), b = get<2>(nx);\n\t\t\t\tif (!uf.find(a, b) && d[a][a] && d[b][b]){\n\t\t\t\t\tuf.set(a, b);\n\t\t\t\t\td[a][b] = d[b][a] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ef = false;\n\t\t\tFor(j, 1, n + 1){\n\t\t\t\tif (d[j][j]){\n\t\t\t\t\tFor(i, 1, n + 1){\n\t\t\t\t\t\tif (!uf.find(j, i) && d[i][i]){\n\t\t\t\t\t\t\tef = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ef){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tUnionFind uf(n + 1);\n\t\tfor (int j = tv.size() - 1; j >= 1; j--){\n\t\t\trep(k, tv[j].size()){\n\t\t\t\td[tv[j][k]][tv[j][k]] = 1;\n\t\t\t}\n\n\t\t\trep(i, v.size()){\n\t\t\t\tT nx = v[i];\n\t\t\t\tint c = get<0>(nx), a = get<1>(nx), b = get<2>(nx);\n\t\t\t\tif (!uf.find(a, b) && d[a][a] && d[b][b]){\n\t\t\t\t\tuf.set(a, b);\n\t\t\t\t\td[a][b] = d[b][a] = 1;\n\t\t\t\t\tans += c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> E;\ntypedef long long LL;\nconst int MAX = 1000000;\nvector<int> vanish[MAX + 1];\nbool done[200];\nstruct UnionFind {\n\tint *par;\n\tint *rank;\n\tint size;\n\tint cnt;\n\tUnionFind(int n) :size(n) {\n\t\tpar = new int[size];\n\t\trank = new int[size];\n\t\tcnt = size;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tcnt--;\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\tint count() {\n\t\treturn cnt;\n\t}\n};\nint main() {\n\tint N, M;\n\twhile (cin >> N >> M, N) {\n\t\tfor (int i = 0; i <= MAX; i++) vanish[i].clear();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\tvanish[h].push_back(i);\n\t\t}\n\t\tvector<E> edge;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tedge.emplace_back(c, P(a, b));\n\t\t}\n\t\tsort(edge.begin(), edge.end());\n\t\tUnionFind uf(N);\n\t\tfor (auto e : edge) uf.unite(e.second.first, e.second.second);\n\t\tif (uf.count() > 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint last = -1;\n\t\tmemset(done, 0, sizeof(done));\n\t\tfor (int t = 0; t <= MAX; t++) {\n\t\t\tif (vanish[t].empty()) continue;\n\t\t\tfor (int v : vanish[t]) done[v] = 1;\n\t\t\tUnionFind u(N);\n\t\t\tfor (auto e : edge) {\n\t\t\t\tif (done[e.second.first] || done[e.second.second]) continue;\n\t\t\t\tu.unite(e.second.first, e.second.second);\n\t\t\t}\n\t\t\tint sz = 1;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (done[i]) sz++;\n\t\t\t}\n\t\t\tif (u.count() != sz) {\n\t\t\t\tlast = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tLL ans = 0;\n\t\tUnionFind u(N);\n\t\tmemset(done, 0, sizeof(done));\n\t\tfor (int t = last; t <= MAX; t++) {\n\t\t\tif (vanish[t].empty()) continue;\n\t\t\tfor (int v : vanish[t]) done[v] = 1;\n\t\t}\n\t\tfor (auto e : edge) {\n\t\t\tif (!done[e.second.first] || !done[e.second.second]) continue;\n\t\t\tif (u.same(e.second.first, e.second.second)) continue;\n\t\t\tans += e.first;\n\t\t\tu.unite(e.second.first, e.second.second);\n\t\t}\n\t\tfor (int t = last - 1; t >= 0; t--) {\n\t\t\tif (vanish[t].empty()) continue;\n\t\t\tfor (int v : vanish[t]) done[v] = 1;\n\t\t\tfor (auto e : edge) {\n\t\t\t\tif (!done[e.second.first] || !done[e.second.second]) continue;\n\t\t\t\tif (u.same(e.second.first, e.second.second)) continue;\n\t\t\t\tans += e.first;\n\t\t\t\tu.unite(e.second.first, e.second.second);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a),b=Find(b);\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\tdata[a]+=data[b];\n\t\tdata[b]=a;\n\t\treturn true;\n\t}\n\tint Size(int i){\n\t\treturn -data[Find(i)];\n\t}\n};\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\n\nostream& operator<<(ostream& os,const Edge& e){\n\treturn os<<'('<<e.src<<','<<e.dst<<','<<e.weight<<')';\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi ts(n);\n\t\trep(i,n) cin>>ts[i];\n\t\t\n\t\tvector<Edge> es;\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w; u--,v--;\n\t\t\tes.emplace_back(u,v,w);\n\t\t}\n\t\tsort(all(es));\n\t\t\n\t\tvi ts2=ts;\n\t\tsort(all(ts2));\n\t\tts2.erase(unique(all(ts2)),end(ts2));\n\t\t\n\t\tint k;\n\t\tfor(k=0;k<ts2.size();k++){\n\t\t\tUnionFind uf(n);\n\t\t\tvi used(n);\n\t\t\tint cc=0;\n\t\t\tfor(auto e:es) if(min(ts[e.src],ts[e.dst])>=ts2[k]){\n\t\t\t\tif(!used[e.src]) used[e.src]=1,cc++;\n\t\t\t\tif(!used[e.dst]) used[e.dst]=1,cc++;\n\t\t\t\tif(uf.Unite(e.src,e.dst)) cc--;\n\t\t\t}\n\t\t\tif(cc>1) break;\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\tint res=0;\n\t\tper(i,k){\n\t\t\tfor(auto e:es) if(min(ts[e.src],ts[e.dst])>=ts2[i])\n\t\t\t\tif(uf.Unite(e.src,e.dst))\n\t\t\t\t\tres+=e.weight;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nstruct UF\n{\n    vector<ll> par; // 親\n    vector<ll> sz; // 数\n    // 初期化\n    UF(ll n):par(n),sz(n) {\n        for(ll i = 0; i < n; i++){\n            par[i] = i;sz[i] = 1;\n        }\n    }\n    // 木の根を求める\n    ll find(ll x) {\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    // xとyの属する集合を併合\n    void unite(ll x, ll y) {\n        x = find(x); y = find(y);\n        if (x == y) return;\n        par[x] = y;\n        sz[y] += sz[x];\n    }\n    // xとyが同じ集合ならtrue\n    bool same(ll x, ll y) { return find(x) == find(y); }\n    ll size(ll n){return sz[find(n)];}\n};\n \nll n,m;\nvector<pair<ll,ll>> h;\nvector<pair<ll,pair<ll,ll>>> v;\nbool sink[222];\n \nll check(ll num){\n    UF uf(n);\n    ll ret = 0;\n    REP(i,m){\n        ll A = v[i].SE.FI;\n        ll B = v[i].SE.SE;\n        ll C = v[i].FI;\n        if(sink[A] | sink[B])continue;\n        if(!uf.same(A,B)){\n            uf.unite(A,B);\n            ret += C;\n        }\n    }\n    ll cou = 0;\n    REP(i,n){\n        cou = max(cou,uf.size(i));\n    }\n    return (cou == num ? ret : -1);\n}\n \nint main(){\n    while(cin >> n >> m,n|m){\n        h.clear();\n        v.clear();\n        REP(i,222)sink[i] = false;\n         \n        REP(i,n){\n            ll tmp;\n            cin >> tmp;\n            h.PB(MP(tmp,i));\n        }\n         \n        REP(i,m){\n            ll a,b,c;\n            cin >> a >> b >> c;\n            a--;b--;\n            v.PB(MP(c,MP(a,b)));\n        }\n         \n        sort(ALL(h));\n        sort(ALL(v));\n         \n        ll prev = check(n);\n        ll sinknum;\n        if(prev == -1){\n            cout << 0 << endl;\n        }\n        else{\n            bool flag = false;\n            for(sinknum = 0;sinknum < n-1;sinknum++){\n                while(sinknum < n-1 && h[sinknum].FI == h[sinknum+1].FI){\n                    sink[h[sinknum].SE] = true;\n                    sinknum++;\n                }\n                sink[h[sinknum].SE] = true;\n                ll now = check(n-sinknum-1);\n                if(now == -1){\n                    flag = true;\n                    break;\n                }\n                prev = now;\n            }\n            sink[h[sinknum].SE] = false;\n            sinknum--;\n            DBG(cout << \"prev \" << prev << \" sinknum \" << sinknum << endl;)\n            DBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n            ll tmp = 0;\n            for(ll i = sinknum;i >= 0;i--){\n                vector<ll> li;\n                while(i > 0 && h[i].FI == h[i-1].FI){\n                    li.PB(i);\n                    i--;\n                }\n                li.PB(i);\n                DBG(cout << \"size \" << li.size() << endl;);\n                REP(j,m){\n                    ll A = v[j].SE.FI;\n                    ll B = v[j].SE.SE;\n                    ll C = v[j].FI;\n                    ll seica = -1;\n                    REP(k,li.size())if(sink[h[li[k]].SE] && (A == h[li[k]].SE || B == h[li[k]].SE))seica = li[k];\n                    if(seica != -1 && (sink[A] ^ sink[B])){\n                        tmp += C;\n                        sink[h[seica].SE] = false;\n                        j = 0;\n                    }\n                }\n                DBG(cout << \"i \" << i << endl;);\n            }\n            DBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n            cout << prev + tmp << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x,int y) {\n    x = root(x);\n    y = root(y);\n    if(x != y) {\n      if(data[y] < data[x]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n      return x != y;\n  }\n  bool findSet(int x,int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\n\nint N,M;\nint h[201];\nint ord[201];\n\nint adj[201][201];\n\nstruct Comp {\n    bool operator()(const int i, const int j) { return h[i] < h[j]; }\n};\n\nstruct Edge {\n    int src, dst, cost;\n};\nbool operator<(const Edge &e, const Edge &f) {\n    return (e.cost != f.cost) ? e.cost < f.cost : e.src < f.src;\n}\n\nint main() {\n    while(cin>>N>>M, N|M) {\n        for (int i=0; i<N; ++i) {\n            cin>>h[i];\n            ord[i] = i;\n        }\n        sort(ord, ord+N, Comp());\n        vector<Edge> e;\n        memset(adj, -1, sizeof(adj));\n        for (int i=0; i<M; ++i) {\n            int a,b,c;\n            cin>>a>>b>>c; a--, b--;\n            e.push_back((Edge){a,b,c});\n            adj[a][b] = adj[b][a] = c;\n        }\n        sort(e.begin(), e.end());\n\n        UnionFind uf(N);\n        set<int> live;\n        bool all_connect[201] = {};\n        for (int i=N-1; i>=0; --i) {\n            int now = h[ord[i]];\n            while(i >= 0 && now == h[ord[i]]) {\n                for (set<int>::iterator it = live.begin(); it != live.end(); ++it)\n                    if (adj[*it][ord[i]] != -1) uf.unionSet(ord[i], *it);\n                live.insert(ord[i]);\n                i--;\n            }\n            if (uf.size(ord[i+1]) == live.size()) all_connect[i+1] = true;\n            i++;\n        }\n\n        if (!all_connect[0]) {\n            cout<<0<<endl;\n            continue;\n        }\n\n        int last = 0, ans = 0;\n        for (; last < N && all_connect[last]; ++last); last--;\n        live.clear();\n        UnionFind uf2(N);\n        for (int i=N-1; i>=last; --i) live.insert(ord[i]);\n        for (int i=0; i<M; ++i) {\n            if (live.find(e[i].src) != live.end() &&\n                live.find(e[i].dst) != live.end()) {\n                if (uf2.findSet(e[i].src, e[i].dst)) continue;\n                ans += e[i].cost;\n                uf2.unionSet(e[i].src, e[i].dst);\n            }\n        }\n        for (int i=last-1; i>=0; --i) {\n            for (int j=0; j<M; ++j) {\n                if (e[j].src == ord[i] && live.count(e[j].dst) > 0\n                    || e[j].dst == ord[i] && live.count(e[j].src) > 0) {\n                    ans += e[j].cost;\n                    uf2.unionSet(e[j].src, e[j].dst);\n                    break;\n                }\n            }\n            live.insert(ord[i]);\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint p[222];\nvoid init(int n){ for(int i = 0; i <= n; i++) p[i] = i; }\nint find(int x){ return p[x] = ( (p[x] == x)?x:find(p[x])); }\nvoid merge(int x,int y){ p[find(x)] = find(y); }\nbool same(int x,int y){ return find(x) == find(y); }\n\nbool used[222];\n\nint n,m;\nint h[222];\nvector<int> s[1111111];\nint a[44444],b[44444],c[44444];\npair<int,pair<int,int> > e[44444];\nint main(void){\n\n  while(cin >> n >> m && n){\n    int ans = 0;\n    init(n);\n    memset(used,false,sizeof(used));\n\n    for(int i = 0; i < 1111111; i++) s[i].clear();\n\n    for(int i = 0; i < n; i++){\n      cin >> h[i];\n      s[ h[i] ].push_back(i+1);\n    }\n\n    for(int i = 0; i < m; i++){\n      cin >> a[i] >> b[i] >> c[i];\n      e[i] = make_pair(c[i],make_pair(a[i],b[i]));\n    }\n    sort(e,e+m);\n    \n    int c = 0;\n    int f = -1;\n    for(int t = 1000000; t > 0; t--){\n      for(int i = 0; i < (int)s[t].size(); i++){\n\tused[ s[t][i] ] = true;\n\tf++;\n\tc++;\n      }\n      if(f > 0){\n\tfor(int i = 0; i < m; i++){\n\t  int u = e[i].second.first, v = e[i].second.second;\n\t  //cout << u << \" \" << v << endl;\n\t  if(used[u] && used[v] && !same(u,v) ){\n\t    merge(u,v);\n\t    ans += e[i].first;\n\t    f--;\n\t  }\n\t}\n\tif(f > 0){\n\t  ans = 0;\n\t  init(n);\n\t  f = c-1;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=200,INF=1E9;\nconst int MAX_DAY=1E6;\n\nstruct edge{\n\tint to,cost;\n};\n\nint N,M;\nvector<int> q[MAX_DAY+1];\nvector<edge> G[MAX_N];\n\nbool flg[MAX_N];\t//???????????????????????°\nbool used[MAX_N]; \t//????????????????????????????????°\nint mincost[MAX_N];\n\nint last;\t//?????????????????¶\n\nvoid prim(){\n\tint ans=0;\n\tfill(flg,flg+N,false);\n\tfill(mincost,mincost+N,INF);\n\tfill(used,used+N,false);\n\tmincost[last]=0;\n\tfor (int i=MAX_DAY;i>=0;i--){\n\t\tif (q[i].empty()) continue;\n\t\tfor (int j=0;j<q[i].size();j++){\n\t\t\tused[q[i][j]]=true;\n\t\t}\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor (int j=0;j<N;j++){\n\t\t\t\tif (!flg[j] && used[j] && (v==-1 || mincost[j]<mincost[v])){\n\t\t\t\t\tv=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v==-1) break;\n\t\t\tif (mincost[v]==INF){\n\t\t\t\tfill(flg,flg+N,false);\n\t\t\t\tfill(mincost,mincost+N,INF);\n\t\t\t\tmincost[last]=0;\n\t\t\t\tans=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans+=mincost[v];\n\t\t\tflg[v]=true;\n\t\t\tfor (int j=0;j<G[v].size();j++){\n\t\t\t\tedge e=G[v][j];\n\t\t\t\tmincost[e.to]=min(mincost[e.to],e.cost);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif (N || M){\n\t\t\tint lastd=-1;\n\t\t\tlast=-1;\n\t\t\tfor (int i=0;i<=MAX_DAY;i++){\n\t\t\t\tq[i].clear();\n\t\t\t}\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tq[t].push_back(i);\n\t\t\t\tif (t>lastd){\n\t\t\t\t\tlastd=t;\n\t\t\t\t\tlast=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=0;i<M;i++){\n\t\t\t\tint a,b,c;\n\t\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\t\tG[a-1].push_back((edge){b-1,c});\n\t\t\t\tG[b-1].push_back((edge){a-1,c});\n\t\t\t}\n\t\t\tprim();\n\t\t}\n\t}while (N || M);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n\ntypedef tuple<int, int, int> T;\n\nstruct UnionFind{\n    vector<int> par;\n    vector<int> ranks;\n    vector<int> size;\n\nprivate:\n    void init(int n = 1){\n        par.resize(n);\n        ranks.resize(n);\n        size.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            ranks[i] = 0;\n            size[i] = 1;\n        }\n    }\n\npublic:\n    UnionFind(int n = 1){\n        init(n);\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return ;\n        if(ranks[x] < ranks[y]) swap(x, y);\n        if(ranks[x] == ranks[y]) ranks[x]++;\n        par[y] = x;\n        size[x] += size[y];\n        return ;\n    }\n};\n\nint main(){\n    while(1){\n        int n, m; cin>>n>>m;\n        if(n == 0) return 0;\n\n        vector<vector<int>> h(1000010);\n        int tmax = 0;\n        for(int i=0; i<n; i++){\n            int H; cin>>H;\n            tmax = max(tmax, H);\n            h[H].emplace_back(i);\n        }\n\n        vector<T> edge;\n        for(int i=0; i<m; i++){\n            int a, b, c; cin>>a>>b>>c;\n            a--, b--;\n            edge.emplace_back(c, a, b);\n        }\n        sort(edge.begin(), edge.end());\n\n        UnionFind uf_con(n);\n        for(int i=0; i<m; i++){\n            int cost, a, b;\n            tie(cost, a, b) = edge[i];\n            uf_con.unite(a, b);\n        }\n\n        set<int> ufsize;\n        for(int i=0; i<n; i++){\n            ufsize.emplace(uf_con.find(i));\n        }\n\n        if(1 < ufsize.size()){\n            cout << 0 << endl;\n            continue;\n        }\n\n        vector<bool> sinked(n, false);\n        int ltime = -1;\n        for(int i=1; i<=tmax; i++){\n            if(h[i].empty()) continue;\n\n            for(auto cv : h[i]){\n                sinked[cv] = true;\n            }\n\n            UnionFind uf(n);\n\n            for(int j=0; j<m; j++){\n                int cost, a, b;\n                tie(cost, a, b) = edge[j];\n                if(sinked[a] || sinked[b]) continue;\n                \n                uf.unite(a, b);\n            }\n\n            ufsize.clear();\n            for(int i=0; i<n; i++){\n                ufsize.emplace(uf.find(i));\n            }\n\n            int sz = 1;\n            for(int i=0; i<n; i++){\n                if(sinked[i]) sz++;\n            }\n\n            if(ufsize.size() != sz){\n                ltime = i;\n                break;\n            }\n        }\n\n        UnionFind uf(n);\n        int ans = 0;\n        for(int i=0; i<n; i++){\n            sinked[i] = false;\n        }\n\n        for(int i=ltime; i<=tmax; i++){\n            for(auto cv : h[i]){\n                sinked[cv] = true;\n            }\n        }\n\n        for(int i=0; i<m; i++){\n            int cost, a, b;\n            tie(cost, a, b) = edge[i];\n\n            if(!sinked[a] || !sinked[b]) continue;\n            if(uf.same(a, b)) continue;\n\n            ans += cost;\n            uf.unite(a, b);\n        }\n\n        for(int i=ltime-1; i>=1; i--){\n            if(h[i].empty()) continue;\n\n            for(auto cv : h[i]){\n                sinked[cv] = true;\n            }\n\n            for(int j=0; j<m; j++){\n                int cost, a, b;\n                tie(cost, a, b) = edge[j];\n\n                if(!sinked[a] || !sinked[b]) continue;\n                if(uf.same(a, b)) continue;\n\n                ans += cost;\n                uf.unite(a, b);\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N,M;\nint H[222];\nint A[111111],B[111111],C[111111];\n\n\nvoid solve(){\n    rep(i,N)cin>>H[i];\n    rep(i,M)cin>>A[i]>>B[i]>>C[i],A[i]--,B[i]--;\n\n    vint lis;\n    rep(i,N)lis.pb(H[i]);\n\n    lis.pb(0);\n\n    int latte=INT_MAX;\n    for(auto t:lis){\n        UnionFindTree uf(N);\n        int cnt=0;\n        rep(i,N)if(H[i]>t)cnt++;\n        rep(i,M){\n            if(H[A[i]]<=t||H[B[i]]<=t)continue;\n            uf.unite(A[i],B[i]);\n        }\n\n        bool ok=false;\n        rep(i,N)if(H[i]>t&&uf.size(i)==cnt)ok=true;\n        if(!ok)chmin(latte,t);\n    }\n\n    if(latte==0){\n        cout<<0<<endl;\n        return;\n    }\n\n\n    rep(i,N)chmin(H[i],latte);\n\n    vector<tuple<int,int,int>>es;\n    rep(i,M){\n        es.pb(make_tuple(-min(H[A[i]],H[B[i]]),C[i],i));\n    }\n    sort(all(es));\n    UnionFindTree uf(N);\n    int ans=0;\n    for(auto &w:es){\n        int k=get<2>(w);\n        if(uf.areSame(A[k],B[k]))continue;\n        uf.unite(A[k],B[k]);\n        ans+=C[k];\n    }\n\n    cout<<ans<<endl;\n}\nsigned main(){\n    while(cin>>N>>M,N||M)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    using namespace std;\n    size_t n, m;\n    while(cin >> n >> m && n && m){\n        vector<size_t> z(n), ih(n), v;\n        size_t sz{0};\n        {\n            vector<size_t> h(n);\n            copy_n(istream_iterator<size_t>(cin), n, h.begin());\n            iota(ih.begin(), ih.end(), 0UL);\n            stable_sort(ih.begin(), ih.end(), [&h](auto i, auto j){return h[i] < h[j];});\n            for(size_t i = 1, j = 0; i < n; ++i)z[ih[i]] = h[ih[i]] == h[ih[i - 1]] ? z[ih[i - 1]] : ++j;\n            sort(h.begin(), h.end());\n            h.erase(unique(h.begin(), h.end()), h.end());\n            sz = h.size();\n            v = vector<size_t>(sz);\n            size_t k = 0;\n            for(auto& i : v){\n                do{\n                    ++k;\n                    ++i;\n                }while(k < n && z[ih[k]] == z[ih[k - 1]]);\n            }\n        }\n        vector<vector<pair<size_t, pair<size_t, size_t>>>> edge(sz);\n        vector<pair<size_t, pair<size_t, size_t>>> ie;\n        for(size_t i = 0, a, b, c; i < m; ++i){\n            cin >> a >> b >> c;\n            if(z[--a] < z[--b])swap(a, b);\n            edge[z[b]].emplace_back(c, make_pair(a, b));\n        }\n        for(auto& i : edge)sort(i.begin(), i.end());\n        class union_find{\n            vector<long> v;\n        public:\n            union_find(size_t _n) : v(_n, -1) {}\n            size_t find(size_t i){return v[i] < 0 ? i : static_cast<size_t>(v[i] = find(v[i]));}\n            bool unite(long i, long j){\n                i = find(i);\n                j = find(j);\n                if(i == j)return false;\n                if(v[i] > v[j])swap(i, j);\n                v[i] += v[j];\n                v[j] = i;\n                return true;\n            }\n        };\n        auto tm = [&n, &z, &sz, &edge, &ih, &v]{\n            union_find uf{n};\n            size_t t{0}, ret{sz};\n            for(size_t cnt = sz; cnt--;){\n                t += v[cnt];\n                for(const auto& i : edge[cnt])if(uf.unite(i.second.first, i.second.second))--t;\n                if(t > 1)ret = cnt;\n            }\n            return ret;\n        }();\n        if(!tm){\n            puts(\"0\");\n            continue;\n        }\n        union_find uf{n};\n        size_t ans{0}, t{0};\n        priority_queue<pair<size_t, pair<size_t, size_t>>, vector<pair<size_t, pair<size_t, size_t>>>, greater<>> pq{};\n        for(size_t cnt = sz; cnt--;){\n            t += v[cnt];\n            for(const auto& i : edge[cnt])pq.push(i);\n            if(cnt < tm)while(!pq.empty() && t > 1){\n                auto i = pq.top();\n                pq.pop();\n                if(uf.unite(i.second.first, i.second.second)){\n                    ans += i.first;\n                    --t;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_V = 200;\nconst int INF = 1 << 28;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nbool used2[MAX_V];\nint V, ans;\n\nvoid prim_init(int s){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  ans = mincost[s] = 0;\n}\n\nvoid prim(int s){\n  while(1){\n    int v = -1;\n    for(int u=0;u<V;u++){\n      if(used2[u] && !used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) return;\n    if(mincost[v] >= INF){\n      prim_init(s);\n      return;\n    }\n    used[v] = true;\n    ans += mincost[v];\n    for(int u=0;u<V;u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n}\n\nvoid init(int n){\n  V = n;\n  fill(cost[0], cost[MAX_V], INF);\n  fill(used2, used2+MAX_V, false);\n}\n\nmain(){\n  int n, m;\n  while(cin >> n >> m && (n|m)){\n    vector<pair<int, int> > h(n);\n    init(n);\n    for(int i=0;i<n;i++){\n      cin >> h[i].first;\n      h[i].second = i;\n    }\n    for(int i=0;i<m;i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a; --b;\n      cost[a][b] = cost[b][a] = c;\n    }\n    sort(h.begin(), h.end());\n    reverse(h.begin(), h.end());\n    prim_init(h[0].second);\n    bool f = true;\n    for(int i=0;i<n;i++){\n      used2[h[i].second] = true;\n      int j = i + 1;\n      for(;j<n&&h[j].first==h[i].first;j++) used2[h[j].second] = true;\n      i = j - 1;\n      prim(h[i].second);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nclass Edge\n{\n\tpublic:\n\tint from,to;\n\tll cost;\n\tEdge(int f,int t,ll c)\n\t{\n\t\tfrom=f;to=t;cost=c;\n\t}\n};\n\nclass UF\n{\n\tpublic:\n\tint s;\n\tvector<int> par;\n\tvector<int> dep;\n\tvector<int> size;\n\n\tUF(int n)\n\t{\n\t\ts=n;\n\t\tpar.resize(s);\n\t\tdep.resize(s);\n\t\tsize.resize(s);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpar[i]=i;\n\t\t\tdep[i]=0;\n\t\t\tsize[i]=1;\n\t\t}\n\t}\n\tint find(int x)\n\t{\n\t\tif(par[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y)\n\t{\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y)\n\t\t\treturn;\n\t\tif(dep[x]<dep[y])\n\t\t{\n\t\t\tpar[x]=y;\n\t\t\tsize[y]+=size[x];\n\t\t}else{\n\t\t\tpar[y]=x;\n\t\t\tsize[x]+=size[y];\n\t\t\tif(dep[x]==dep[y])\n\t\t\t\tdep[x]++;\n\t\t}\n\t}\n\tbool same(int x,int y)\n\t{\n\t\treturn find(x)==find(y);\n\t}\n\tint getSize(int x)\n\t{\n\t\treturn size[find(x)];\n\t}\n};\n\nvector<int> sink[1000000];\nvector<Edge> g;\nvector<Edge> g2[200];\nUF u=UF(10);\nbool usef[200]; //使える頂点\n\nbool comp(Edge &lhs,Edge &rhs)\n{\n\treturn lhs.cost<rhs.cost;\n}\n\n//現在の頂点数における最小全域木\nll MST(int n)\n{\n\tll ret=0;\n\tUF cp=u; //あらかじめコピーを取っておく\n\tint k;//起点となる点\n\tfor(int i=0;i<200;i++)\n\t{\n\t\tif(usef[i])\n\t\t{\n\t\t\tk=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<g.size();i++)\n\t{\n\t\tEdge e=g[i];\n\t\tif(!(usef[e.from] && usef[e.to]))\n\t\t\tcontinue;\n\t\tif(!u.same(e.from,e.to))\n\t\t{\n\t\t\tu.unite(e.from,e.to);\n\t\t\tret+=e.cost;\n\t\t}\n\t\tif(u.getSize(k)==n)\n\t\t\tbreak;\n\t}\n\t//橋が建設できないならなかったことにする\n\tif(u.getSize(k)<n)\n\t{\n\t\tu=cp;\n\t\tret=0;\n\t}\n\t//cerr<<n<<\" \"<<ret<<endl;\n\treturn ret;\n}\nbool visited[200]; //下の再帰で訪れた頂点\nbool saiki(int now)\n{\n\tvisited[now]=true;\n\tfor(int i=0;i<g2[now].size();i++)\n\t{\n\t\tEdge e=g2[now][i];\n\t\tif(!visited[e.to] && usef[e.to])\n\t\t\tsaiki(e.to);\n\t}\n\tbool ret=true;\n\tfor(int i=0;i<200;i++)\n\t{\n\t\tif(usef[i]!=visited[i])\n\t\t\tret=false;\n\t}\n\treturn ret;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,m;\n\t\tll ans=0;\n\t\tcin>>n>>m;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tg.clear();\n\t\tfor(int i=0;i<1000000;i++)\n\t\t\tsink[i].clear();\n\t\tfor(int i=0;i<200;i++)\n\t\t\tg2[i].clear();\n\t\tfill(usef,usef+200,false);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint h;\n\t\t\tcin>>h;\n\t\t\tsink[h-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tg.push_back(Edge(a,b,c));\n\t\t\tg2[a].push_back(Edge(a,b,c));\n\t\t\tg2[b].push_back(Edge(b,a,c));\n\t\t}\n\t\tsort(g.begin(),g.end(),comp);\n\t\tu=UF(n);\n\t\tint now=0;\n\t\tint last=999999;\n\t\t//初めて全域木が構成できなくなる時間を求める\n\t\tfor(int i=0;i<n;i++)\n\t\t\tusef[i]=true;\n\t\tnow=n;\n\t\tfill(visited,visited+200,false);\n\t\tif(!saiki(0))\n\t\t{\n\t\t\tcout<<0<<endl;//最初から構成できない場合を除く\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<1000000;i++)\n\t\t{\n\t\t\tbool f=true;\n\t\t\tif(sink[i].size()==0)\n\t\t\t\tcontinue;\n\t\t\tfor(int j=0;j<sink[i].size();j++)\n\t\t\t\tusef[sink[i][j]]=false;\n\t\t\tnow-=sink[i].size();\n\t\t\tfor(int j=0;j<200;j++)\n\t\t\t{\n\t\t\t\tif(usef[j])\n\t\t\t\t{\n\t\t\t\t\tfill(visited,visited+200,false);\n\t\t\t\t\tf=saiki(j);\n\t\t\t\t\tif(!f)\n\t\t\t\t\t\tlast=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(int i=last;i>-1;i--)\n\t\t{\n\t\t\tif(sink[i].size()==0)\n\t\t\t\tcontinue;\n\t\t\tfor(int j=0;j<sink[i].size();j++)\n\t\t\t\tusef[sink[i][j]]=true;\n\t\t\tnow+=sink[i].size();//現在の島の数\n\t\t\tans+=MST(now);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<int, int> P;\n\nusing Weight = int;\nstruct Edge {\n\tint src, dst; Weight weight;\n\tEdge() {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\n\nstruct UnionFind {\n\tvector<int> par;\n\tint cnt;\n\tUnionFind(int size_) : par(size_, -1), cnt(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif((x = find(x)) != (y = find(y))) {\n\t\t\tif(par[y] < par[x]) swap(x, y);\n\t\t\tpar[x] += par[y]; par[y] = x; cnt--;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tint size(int x) { return -par[find(x)]; }\n\tint size() { return cnt; }\n};\n\nbool operator < (const Edge &e, const Edge &f) { return e.weight < f.weight; }\n\nconst int MAX = (int)1e6 + 10;\nvector<int> x[MAX];\nint alive[200];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M;\n\twhile(cin >> N >> M, N) {\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tx[t].push_back(i);\n\t\t}\n\n\t\tvector<Edge> es;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--, b--;\n\t\t\tes.push_back({ a, b ,c });\n\t\t}\n\t\tsort(es.begin(), es.end());\n\n\t\t{\n\t\t\tUnionFind uf(N);\n\t\t\tfor(auto e : es) {\n\t\t\t\tuf.unite(e.src, e.dst);\n\t\t\t}\n\t\t\tif(uf.size(0) != N) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tint last = -1;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\talive[i] = 1;\n\t\t}\n\t\tfor(int t = 0; t < MAX; t++) {\n\t\t\tif(x[t].size() == 0) continue;\n\t\t\tfor(auto v : x[t]) {\n\t\t\t\talive[v] = 0;\n\t\t\t}\n\t\t\tUnionFind uf(N);\n\t\t\tfor(auto e : es) {\n\t\t\t\tif(alive[e.src] && alive[e.dst]) uf.unite(e.src, e.dst);\n\t\t\t}\n\t\t\tint sz = 1;\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(!alive[j]) sz++;\n\t\t\t}\n\t\t\tif(uf.size() != sz) {\n\t\t\t\tlast = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\talive[i] = 0;\n\t\t}\n\n\t\tUnionFind uf(N);\n\t\tint ans = 0;\n\t\tfor(int t = last; t < MAX; t++) {\n\t\t\tfor(auto v : x[t]) {\n\t\t\t\talive[v] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(auto e : es) {\n\t\t\tif(alive[e.src] && alive[e.dst] && !uf.same(e.src, e.dst)) {\n\t\t\t\tuf.unite(e.src, e.dst);\n\t\t\t\tans += e.weight;\n\t\t\t}\n\t\t}\n\t\tfor(int i = last - 1; i >= 0; i--) {\n\t\t\tfor(auto v : x[i]) {\n\t\t\t\talive[v] = 1;\n\t\t\t}\n\t\t\tfor(auto e : es) {\n\t\t\t\tif(alive[e.src] && alive[e.dst] && !uf.same(e.src, e.dst)) {\n\t\t\t\t\tuf.unite(e.src, e.dst);\n\t\t\t\t\tans += e.weight;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<Int, P> T;\n\nInt u[1080];\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(Int x, Int y){\n\tu[r(x)] = r(y);\n}\nvector<T> edge[1080000];\nInt h[1080];\nbool come[1080];\nint main(){\n\tInt n, m;\n\twhile(cin >> n >> m, n | m){\n\t\tInt res = 0, bridge = 0, a, b, c, cnt = 0;\n\t\tfor(Int i = 0;i < n;i++)cin >> h[i], u[i] = i, come[i] = false;\n\t\tfor(Int i = 0;i < m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tedge[min(h[a], h[b])].push_back(T(c, P(a, b)));\n\t\t}\n\t\tInt breakpoInt = 10000000;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tif(!come[from])cnt++, come[from] = true;\n\t\t\t\t\tif(!come[to])cnt++, come[to] = true;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt && cnt - 1 != bridge){\n\t\t\t\tbreakpoInt = i;\n\t\t\t}\n\t\t}                    \n\t\tbridge = 0;\n\t\tvector<T> tmp;\n\t\tfor(Int i = 0;i < n;i++)u[i] = i;\n\t\tif(breakpoInt)breakpoInt--;\n\t\tfor(Int i = 1000000;i >= breakpoInt;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\ttmp.push_back(edge[i][j]);\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor(Int i = 0;i < tmp.size();i++){\n\t\t\tInt from = tmp[i].second.first, to = tmp[i].second.second;\n\t\t\tif(r(from) != r(to)){\n\t\t\t\tbridge++;\n\t\t\t\tres += tmp[i].first;\n\t\t\t\tunite(from, to);\n\t\t\t}\n\t\t}\n\t\tfor(Int i = breakpoInt;i > 0;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tres += edge[i][j].first;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tedge[i].clear();\n\t\t}\n\t\tif(bridge + 1 != n)res = 0;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass union_find{\n\tint n;\n\tvector<int> a;\npublic:\n\tunion_find(int N):a(N,-1),n(N){}\n\tint find(int x){\n\t\tif(a[x]<0) return x;\n\t\treturn a[x]=find(a[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x!=y){ a[x]+=a[y]; a[y]=x; n--; }\n\t}\n\tint size(){ return n; }\n};\n\nstruct edge{\n\tint u,v,cost;\n\tbool operator<(const edge &e)const{ return cost<e.cost; }\n};\n\nbool is_connected(int n,const bool *sunk,int m,edge *E){\n\tunion_find U(n);\n\trep(i,m){\n\t\tint u=E[i].u,v=E[i].v;\n\t\tif(!sunk[u] && !sunk[v]) U.unite(u,v);\n\t}\n\treturn U.size()==1+count(sunk,sunk+n,true);\n}\n\nint find_MST(int n,const bool *sunk,int m,const edge *E,union_find &U){\n\tint res=0;\n\trep(i,m){\n\t\tint u=E[i].u,v=E[i].v;\n\t\tif(!sunk[u] && !sunk[v] && U.find(u)!=U.find(v)){\n\t\t\tU.unite(u,v);\n\t\t\tres+=E[i].cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint life[200];\n\t\trep(u,n) scanf(\"%d\",life+u);\n\t\tstatic edge E[200*199/2];\n\t\trep(i,m){\n\t\t\tint u,v,c; scanf(\"%d%d%d\",&u,&v,&c); u--; v--;\n\t\t\tE[i]=(edge){u,v,c};\n\t\t}\n\t\tsort(E,E+m);\n\n\t\tint order[200];\n\t\t{\n\t\t\tpair<int,int> tmp[200];\n\t\t\trep(u,n) tmp[u]=make_pair(life[u],u);\n\t\t\tsort(tmp,tmp+n);\n\t\t\trep(i,n) order[i]=tmp[i].second;\n\t\t}\n\n\t\tbool sunk[200]={}; // sizunda islands\n\t\tif(!is_connected(n,sunk,m,E)){ puts(\"0\"); continue; }\n\n\t\tint i_end=n;\n\t\trep(i,n){\n\t\t\tsunk[order[i]]=true;\n\t\t\twhile(i<n-1 && life[order[i]]==life[order[i+1]]) sunk[order[++i]]=true;\n\n\t\t\tif(!is_connected(n,sunk,m,E)){ i_end=i; break; }\n\t\t}\n\n\t\trep(u,n) sunk[u]=false;\n\t\trep(i,i_end) sunk[order[i]]=true;\n\n\t\tunion_find U(n);\n\t\tint ans=find_MST(n,sunk,m,E,U);\n\t\tfor(int i=i_end-1;i>=0;i--){\n\t\t\tsunk[order[i]]=false;\n\t\t\twhile(i>0 && life[order[i]]==life[order[i-1]]) sunk[order[--i]]=false;\n\n\t\t\tans+=find_MST(n,sunk,m,E,U);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\nstruct union_find {\n\tvector<ll> v; // ??????id?????¨???????????????????????´????????¨????????????*(-1)?????¨??????\n\tunion_find(ll n) : v(n, -1) {}\n\tll find(ll x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(ll x, ll y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y];\n\t\tv[y] = x;\n\t}\n\tbool same(ll x, ll y) { return find(x) == find(y); }\n\tll size(ll x) { return -v[find(x)]; }\n};\n\nusing E = tuple<ll, ll, ll>; // = {cost, u, v}\nvector<E> kruskal(vector<E> & es, union_find & uf, ll year, const vector<ll> & h) {\n\tvector<E> res;\n\tfor (auto e : es) {\n\t\tll cost, u, v;\n\t\ttie(cost, u, v) = e;\n\t\tif (min(h[u], h[v]) < year) continue;\n\t\tif (uf.same(u, v)) continue;\n\t\tuf.unite(u, v);\n\t\tres.push_back(e);\n\t}\n\treturn res;\n}\n\n\nint main() {\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0); // cin??¨cout?????£????????????\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\twhile (true) {\n\t\tll n, m;\n\t\tcin >> n >> m;\n\t\tif (n == 0) break;\n\t\tvector<ll> h(n); REP(i, n) cin >> h[i];\n\t\t\n\t\tvector<E> es(m); REP(i, m) cin >> get<1>(es[i]) >> get<2>(es[i]) >> get<0>(es[i]);\n\t\tREP(i, m) {\n\t\t\tget<1>(es[i])--;\n\t\t\tget<2>(es[i])--;\n\t\t}\n\t\tsort(ALL(es));\n\n\t\tmap<ll, ll> years;\n\t\tREP(i, n) years[h[i]]++;\n\t\t\n\t\tunion_find uf(n);\n\t\tll cost = 0;\n\t\tll cur_n = 0;\n\t\tfor (auto it = years.rbegin(); it != years.rend(); ++it) {\n\t\t\tcur_n += it->second;\n\t\t\tauto v = kruskal(es, uf, it->first, h);\n\t\t\tif (!v.empty() && uf.size(get<1>(v[0])) == cur_n) {\n\t\t\t\tfor (auto e : v) cost += get<0>(e);\n\t\t\t} else {\n\t\t\t\tuf = union_find(n);\n\t\t\t\tcost = 0;\n\t\t\t}\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n#define Graph(type) vector< vector< Edge<type> > >\n\ntemplate <typename T>\npair<int, vector< Edge<T> > > prim(vector< vector< Edge<T> > > &G) {\n    int V = G.size(); T ans = 0;\n    vector< Edge<T> > ans_e;\n    vector<bool> used(V, false);\n    priority_queue< Edge<T>, vector< Edge<T> >, greater< Edge<T> > > q;\n    q.push(Edge<T>(-1, 0, 0));\n    while(!q.empty()) {\n        Edge<T> temp = q.top(); q.pop();\n        if(used[temp.to]) continue;\n        used[temp.to] = true;\n        ans += temp.cost; if(temp.from >= 0) ans_e.pb(temp);\n        rep(i,0,G[temp.to].size()) q.push(G[temp.to][i]);\n    }\n    rep(i,0,V) if(!used[i]) ans = numeric_limits<T>::max();\n    return pair<int, vector< Edge<T> > >(ans, ans_e);\n}\n\n// Union-Find ??¨ (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size;\n    vector<int> uf;\npublic:\n    // ????????? UnionFind uni(n) ??????????????£?¨?????????°??????\n    UnionFind(int _n) : n(_n), __size(_n), uf(_n, -1) {}\n    // find (??¨??????????±???????)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x ??¨ y ???????????????????±???????????????????\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x ????±????????????????????´???°\n    int size(int x) {return -uf[find(x)];}\n    // ???????????????????????????\n    int size()      {return __size;}\n    // x ??¨ y ????±??????????????????????\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n    }\n    // ???????????°??¨ (???????????????)\n    void debug() {for(auto e : uf) printf(\"UnionFind_debug: %lld\\n\", e);}\n};\n\nsigned main() {\n    int n, m; \n    while(cin >> n >> m) {\n        if(!n && !m) break;\n        Graph(int) G(n);\n        vector<pii> v(n);\n        rep(i,0,n) {\n            cin >> v[i].fr;\n            v[i].sc = i;\n        }\n        sort(v.begin(), v.end(), greater<pii>());\n\n        vector< Edge<int> > es;\n        int a, b, c;\n        rep(i,0,m) {\n            cin >> a >> b >> c;\n            a--; b--;\n            es.pb(Edge<int>(a, b, c));\n            es.pb(Edge<int>(b, a, c));\n        }\n        sort(es.begin(), es.end());\n        int visited[210];\n        memset(visited, -1, sizeof(visited));\n\n        int ans = 0;\n        UnionFind uf(n);\n        rep(i,0,v.size()) {\n            int g = v[i].fr; visited[v[i].sc] = 0;\n            // printf(\"visit: %lld %lld\\n\", v[i].fr, v[i].sc);\n            while(v[++i].fr == g) visited[v[i].sc] = 0;\n            i--;\n            // printf(\"end: i = %lld\\n\", i);\n\n            rep(j,0,es.size()) {\n                if(visited[es[j].from] == -1 || visited[es[j].to] == -1) continue;\n                if(uf.find(es[j].from) != uf.find(es[j].to)) {\n                    uf.unite(es[j].from, es[j].to);\n                    ans += es[j].cost;\n                }\n            }\n            // printf(\"ans: %lld\\n\", ans);\n        }\n        int par = -1;\n        rep(i,0,n) {\n            if(par == -1) par = uf.find(i);\n            else if(par != uf.find(i)) ans = 0;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n\n    /*\n    int n, m; cin >> n >> m;\n    Graph(int) G(n);\n    vector< Edge<int> > es;\n    int s, d, c;\n    rep(i,0,m) {\n        cin >> s >> d >> c; s--; d--;\n        G[s].pb(Edge<int>(s, d, c));\n        G[d].pb(Edge<int>(d, s, c));\n        es.pb(Edge<int>(d, s, c));\n        es.pb(Edge<int>(s, d, c));\n    }\n    pii ans = pii(0, 0);\n    pair< int, vector< Edge<int> > > v = prim(G);\n    sort(es.begin(), es.end());\n    int E = es.size();\n    rep(i,0,v.sc.size()) {\n        UnionFind uf(n);\n        int res = 0;\n        for(int j=0; j<E; j++) {\n            Edge<int> e = es[j];\n            if(e.to == v.sc[i].from && e.from == v.sc[i].to) continue;\n            if(e.to == v.sc[i].to && e.from == v.sc[i].from) continue;\n            if(!uf.same(e.from, e.to)) {\n                uf.unite(e.from, e.to);\n                res += e.cost;\n            }\n        }\n\n        int par = -1;\n        for(int j=0; j<n; j++) {\n            if(par == -1) par = uf.find(j);\n            else if(par != uf.find(j)) res = INT_MAX;\n        }\n\n        if(res > v.fr) {\n            ans.fr++;\n            ans.sc += v.sc[i].cost;\n        }\n    }\n    printf(\"%lld %lld\\n\", ans.fr, ans.sc);\n    */\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8  = int8_t;\nusing u8  = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\nusing f80 = __float80;\n// }}}\n\nconstexpr i64 INF  = INT64_C(1'010'000'000'000'000'017);\nconstexpr f64 FINF = 1e100;\n\nconstexpr i64 MOD = INT64_C(1'000'000'007);\n//constexpr i64 MOD = INT64_C(998'244'353);\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n\n#define LIFT(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\nconstexpr i64 SIZE(const C& c) noexcept { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\nconstexpr i64 SIZE(const T (&)[N]) noexcept { return static_cast<i64>(N); }\n\ntemplate<typename T, SFINAE(is_signed<T>::value)>\nconstexpr T ABS(T x) noexcept {\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr i64 CMP(T x, T y) noexcept { return (y<x) - (x<y); }\n\ntemplate<typename T>\nconstexpr i64 SGN(T x) noexcept { return CMP(x,T(0)); }\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmax(T& xmax, const U& x, Comp comp={}) noexcept {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmin(T& xmin, const U& x, Comp comp={}) noexcept {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc&& bf, UnaryFunc&& uf) {\n    return [bf=forward<BinaryFunc>(bf),uf=forward<UnaryFunc>(uf)](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F&& f) {\n    return ON(less<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto GT_ON(F&& f) {\n    return ON(greater<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto EQ_ON(F&& f) {\n    return ON(equal_to<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto NE_ON(F&& f) {\n    return ON(not_equal_to<>{}, forward<F>(f));\n}\n\n// tuple {{{\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(const tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(const tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n// }}}\n\n// container {{{\ntemplate<typename T> struct is_container : false_type {};\ntemplate<typename T, size_t N> struct is_container<array<T,N>> : true_type {};\ntemplate<typename... Args> struct is_container<vector<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<deque<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<forward_list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multimap<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multimap<Args...>> : true_type {};\n\ntemplate<typename T, typename Enable=void>\nstruct ProconHash {\n    size_t operator()(const T& x) const noexcept {\n        return hash<T>{}(x);\n    }\n};\n\ntemplate<typename T>\nsize_t procon_hash_value(const T& x) noexcept {\n    return ProconHash<T>{}(x);\n}\n\nsize_t procon_hash_combine(size_t h1, size_t h2) noexcept {\n    constexpr size_t M = UINT64_C(0xc6a4a7935bd1e995);\n    constexpr int    R = 47;\n\n    h2 *= M;\n    h2 ^= h2 >> R;\n    h2 *= M;\n\n    h1 ^= h2;\n    h1 *= M;\n\n    h1 += 0xe6546b64;\n\n    return h1;\n}\n\ntemplate<typename T1, typename T2>\nstruct ProconHash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const noexcept {\n        size_t h1 = procon_hash_value(p.first);\n        size_t h2 = procon_hash_value(p.second);\n        return procon_hash_combine(h1, h2);\n    }\n};\n\ntemplate<typename... TS>\nstruct ProconHash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const noexcept {\n        size_t h = 0;\n        tuple_enumerate(t, [&h](i64, const auto& e) {\n            h = procon_hash_combine(h, procon_hash_value(e));\n        });\n        return h;\n    }\n};\n\ntemplate<typename C>\nstruct ProconHash<C,enable_if_t<is_container<C>::value>> {\n    size_t operator()(const C& c) const noexcept {\n        size_t h = 0;\n        for(const auto& e : c)\n            h = procon_hash_combine(h, procon_hash_value(e));\n        return h;\n    }\n};\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashSet = unordered_set<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMap = unordered_map<K,V,Hash,Eq>;\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashMultiset = unordered_multiset<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMultimap = unordered_multimap<K,V,Hash,Eq>;\n\ntemplate<typename T>\nauto vec_make(i64 n, T x) {\n    return vector<T>(n, x);\n}\n\ntemplate<typename T, typename... Args, SFINAE(sizeof...(Args) >= 2)>\nauto vec_make(i64 n, Args... args) {\n    auto inner = vec_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ntemplate<typename T>\nauto vec_reserve(i64 cap) {\n    vector<T> res;\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T=i64>\nauto vec_iota(i64 n, T init={}) {\n    vector<i64> res(n);\n    ALL(iota, res, init);\n    return res;\n}\n\ntemplate<typename T, typename Comp, typename Cont=vector<T>>\nauto priority_queue_make(const Comp& comp, Cont&& cont={}) {\n    return priority_queue<T,remove_reference_t<Cont>,Comp>(comp, forward<Cont>(cont));\n}\n\ntemplate<typename T, typename Comp>\nauto priority_queue_reserve(const Comp& comp, i64 cap) {\n    return priority_queue<T,vector<T>,Comp>(comp, vec_reserve<T>(cap));\n}\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayType {\n    using type = array<typename ArrayType<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayType<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t... NS>\nusing Array = typename ArrayType<T,NS...>::type;\n\ntemplate<typename T, size_t N>\nT& array_at(Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nT& array_at(Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, size_t N>\nconst T& array_at(const Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nconst T& array_at(const Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename C, typename Comp>\nT POP(priority_queue<T,C,Comp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n// }}}\n\n// fixpoint {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nconstexpr decltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename F, size_t... NS>\nclass FixPointMemo {\npublic:\n    explicit FixPointMemo(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args... args) const {\n        using R = decltype(f_(*this,args...));\n        static Array<bool,NS...> done {};\n        static Array<R,NS...>    memo;\n\n        if(!array_at<bool,NS...>(done,args...)) {\n            array_at<R,NS...>(memo,args...) = f_(*this,args...);\n            array_at<bool,NS...>(done,args...) = true;\n        }\n        return array_at<R,NS...>(memo,args...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<size_t... NS, typename F>\ndecltype(auto) FIXMEMO(F&& f) {\n    return FixPointMemo<F,NS...>(forward<F>(f));\n}\n// }}}\n\n// math {{{\n/*constexpr*/ i64 GCD(i64 a, i64 b) noexcept {\n    /*constexpr*/ auto f_gcd = FIX([](auto&& self, i64 aa, i64 bb) {\n        if(bb == 0) return aa;\n        return self(bb, aa%bb);\n    });\n    return f_gcd(ABS(a), ABS(b));\n}\n\n/*constexpr*/ i64 LCM(i64 a, i64 b) noexcept {\n    ASSERT(a != 0 && b != 0);\n    /*constexpr*/ auto f_gcd = FIX([](auto&& self, i64 aa, i64 bb) {\n        if(bb == 0) return aa;\n        return self(bb, aa%bb);\n    });\n    a = ABS(a);\n    b = ABS(b);\n    return a / f_gcd(a,b) * b;\n}\n\n/*constexpr*/ tuple<i64,i64,i64> EXTGCD(i64 a, i64 b) noexcept {\n    /*constexpr*/ auto impl = FIX([](auto&& self, i64 aa, i64 bb) -> tuple<i64,i64,i64> {\n        if(bb == 0) return make_tuple(aa, 1, 0);\n        i64 g,x,y; tie(g,x,y) = self(bb, aa%bb);\n        return make_tuple(g, y, x-(aa/bb)*y);\n    });\n    i64 g,x,y; tie(g,x,y) = impl(ABS(a), ABS(b));\n    x *= SGN(a);\n    y *= SGN(b);\n    return make_tuple(g, x, y);\n}\n// }}}\n\n// string {{{\nauto str_reserve(i64 cap) {\n    string res;\n    res.reserve(cap);\n    return res;\n}\n// }}}\n\n// input {{{\ntemplate<typename T, typename Enable=void>\nstruct Scan {\n    static T scan(istream& in) {\n        T res;\n        in >> res;\n        return res;\n    }\n};\n\ntemplate<typename T, typename Enable=void>\nstruct Scan1;\n\ntemplate<typename T>\nstruct Scan1<T,enable_if_t<is_integral<T>::value && !is_same<T,bool>::value>> {\n    static T scan1(istream& in) {\n        return Scan<T>::scan(in) - 1;\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan<pair<T1,T2>> {\n    static pair<T1,T2> scan(istream& in) {\n        T1 x = Scan<T1>::scan(in);\n        T2 y = Scan<T2>::scan(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan1<pair<T1,T2>> {\n    static pair<T1,T2> scan1(istream& in) {\n        T1 x = Scan1<T1>::scan1(in);\n        T2 y = Scan1<T2>::scan1(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename T>\ntuple<T> tuple_scan_impl(istream& in) {\n    return make_tuple(Scan<T>::scan(in));\n}\n\ntemplate<typename T, typename... TS, SFINAE(sizeof...(TS) > 0)>\ntuple<T,TS...> tuple_scan_impl(istream& in) {\n    auto head = make_tuple(Scan<T>::scan(in));\n    return tuple_cat(head, tuple_scan_impl<TS...>(in));\n}\n\ntemplate<typename... TS>\nstruct Scan<tuple<TS...>> {\n    static tuple<TS...> scan(istream& in) {\n        return tuple_scan_impl<TS...>(in);\n    }\n};\n\ntemplate<typename T>\ntuple<T> tuple_scan1_impl(istream& in) {\n    return make_tuple(Scan1<T>::scan1(in));\n}\n\ntemplate<typename T, typename... TS, SFINAE(sizeof...(TS) > 0)>\ntuple<T,TS...> tuple_scan1_impl(istream& in) {\n    auto head = make_tuple(Scan1<T>::scan1(in));\n    return tuple_cat(head, tuple_scan1_impl<TS...>(in));\n}\n\ntemplate<typename... TS>\nstruct Scan1<tuple<TS...>> {\n    static tuple<TS...> scan1(istream& in) {\n        return tuple_scan1_impl<TS...>(in);\n    }\n};\n\ntemplate<typename T=i64>\nT RD() {\n    return Scan<T>::scan(cin);\n}\n\ntemplate<typename T=i64>\nT RD1() {\n    return Scan1<T>::scan1(cin);\n}\n\ntemplate<typename T=i64>\nauto RD_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD1<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD_VEC<T>(w));\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD1_VEC<T>(w));\n    }\n    return res;\n}\n// }}}\n\n// output {{{\ntemplate<typename T, typename Enable=void>\nstruct Fmt {\n    static void fmt(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid fmt_write(ostream& out, const T& x) {\n    Fmt<T>::fmt(out, x);\n}\n\ntemplate<typename... TS>\nstruct Fmt<tuple<TS...>> {\n    static void fmt(ostream& out, const tuple<TS...>& t) {\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << ' ';\n            fmt_write(out, e);\n        });\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Fmt<pair<T1,T2>> {\n    static void fmt(ostream& out, const pair<T1,T2>& p) {\n        return fmt_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Fmt<C,enable_if_t<is_container<C>::value>> {\n    static void fmt(ostream& out, const C& c) {\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << ' ';\n            fmt_write(out, *it);\n        }\n    }\n};\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS&... args) {\n    fmt_write(cout, x);\n    if(sizeof...(args) > 0) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS&... args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n// }}}\n\n// debug {{{\ntemplate<typename T, typename Enable=void>\nstruct Dbg {\n    static void dbg(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid dbg_write(ostream& out, const T& x) {\n    Dbg<T>::dbg(out, x);\n}\n\ntemplate<>\nstruct Dbg<i64> {\n    static void dbg(ostream& out, i64 x) {\n        if(x == INF)\n            out << \"INF\";\n        else if(x == -INF)\n            out << \"-INF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<>\nstruct Dbg<f64> {\n    static void dbg(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF)\n            out << \"FINF\";\n        else if(x == -FINF)\n            out << \"-FINF\";\n        else\n            out << x;\n#pragma GCC diagnostic pop\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct Dbg<T[N]> {\n    static void dbg(ostream& out, const T (&ary)[N]) {\n        out << \"[\";\n        REP(i, N) {\n            if(i != 0) out << \",\";\n            dbg_write(out, ary[i]);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<size_t N>\nstruct Dbg<char[N]> {\n    static void dbg(ostream& out, const char (&s)[N]) {\n        out << s;\n    }\n};\n\ntemplate<typename... TS>\nstruct Dbg<tuple<TS...>> {\n    static void dbg(ostream& out, const tuple<TS...>& t) {\n        out << \"(\";\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << \",\";\n            dbg_write(out, e);\n        });\n        out << \")\";\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Dbg<pair<T1,T2>> {\n    static void dbg(ostream& out, const pair<T1,T2>& p) {\n        return dbg_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Dbg<C,enable_if_t<is_container<C>::value>> {\n    static void dbg(ostream& out, const C& c) {\n        out << \"[\";\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << \",\";\n            dbg_write(out, *it);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<stack<T,C>> {\n    static void dbg(ostream& out, stack<T,C> stk) {\n        out << \"[\";\n        while(!stk.empty()) {\n            dbg_write(out,stk.top()); stk.pop();\n            if(!stk.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<queue<T,C>> {\n    static void dbg(ostream& out, queue<T,C> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.front()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C, typename Comp>\nstruct Dbg<priority_queue<T,C,Comp>> {\n    static void dbg(ostream& out, priority_queue<T,C,Comp> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.top()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    dbg_write(cerr, value);\n    cerr << \"\\n\";\n}\n\nvoid DBG_IMPL_HELPER() {}\n\ntemplate<typename T, typename... TS>\nvoid DBG_IMPL_HELPER(const T& x, const TS&... args) {\n    dbg_write(cerr, x);\n    if(sizeof...(args) > 0) {\n        cerr << \",\";\n        DBG_IMPL_HELPER(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid DBG_IMPL(i64 line, const char* expr, const TS&... value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = (\";\n    DBG_IMPL_HELPER(value...);\n    cerr << \")\\n\";\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value == 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>&, const array<i64,N>&) {\n    dbg_write(out, x);\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>& sizes, const array<i64,N>& offs) {\n    i64 k   = N - rank<T>::value;\n    i64 off = offs[k];\n    i64 siz = sizes[k];\n    if(siz == 0) siz = extent<T>::value - off;\n\n    out << \"[\";\n    FOR(i, off, off+siz) {\n        if(i != off) out << \",\";\n        DBG_DP_IMPL_HELPER(out, x[i], sizes, offs);\n    }\n    out << \"]\";\n}\n\ntemplate<typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL(i64 line, const char* expr, const T& dp,\n                 const array<i64,rank<T>::value>& sizes={},\n                 const array<i64,rank<T>::value>& offs={})\n{\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    DBG_DP_IMPL_HELPER<rank<T>::value>(cerr, dp, sizes, offs);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T>\nvoid DBG_GRID_IMPL(i64 line, const char* expr, const vector<T>& grid) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \":\\n\";\n    for(const auto& row : grid) {\n        dbg_write(cerr, row);\n        cerr << \"\\n\";\n    }\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_DP(args...) DBG_DP_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_GRID(args...) DBG_GRID_IMPL(__LINE__, CPP_STR_I(args), args)\n#else\n    #define DBG(args...)\n    #define DBG_DP(args...)\n    #define DBG_GRID(args...)\n#endif\n// }}}\n\n// modint {{{\ntemplate<typename Mod>\nclass ModIntT {\nprivate:\n    i64 v_;  // [0,Mod::value)\n\n    static i64 mod() { return Mod::value; }\n\n    static i64 normalize(i64 x) {\n        i64 res = x % mod();\n        if(res < 0) res += mod();\n        return res;\n    }\n\npublic:\n    ModIntT() : v_(0) {}\n    ModIntT(i64 v) : v_(normalize(v)) {}\n\n    explicit operator i64() const { return v_; }\n\n    ModIntT operator-() const { return ModIntT(-v_); }\n\n    ModIntT& operator+=(ModIntT rhs) {\n        v_ = normalize(v_ + rhs.v_);\n        return *this;\n    }\n    ModIntT& operator-=(ModIntT rhs) {\n        v_ = normalize(v_ - rhs.v_);\n        return *this;\n    }\n    ModIntT& operator*=(ModIntT rhs) {\n        v_ = normalize(v_ * rhs.v_);\n        return *this;\n    }\n\n    ModIntT& operator++() { return *this += 1; }\n    ModIntT& operator--() { return *this -= 1; }\n    ModIntT operator++(int) { return exchange(*this, *this+1); }\n    ModIntT operator--(int) { return exchange(*this, *this-1); }\n\n    ModIntT inv() const {\n        i64 g,x; tie(g,x,ignore) = EXTGCD(v_, mod());\n        ASSERT(g == 1);\n        return ModIntT(x);\n    }\n};\n\ntemplate<typename Mod>\nModIntT<Mod> operator+(ModIntT<Mod> lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(lhs) += rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator+(ModIntT<Mod> lhs, i64 rhs) { return ModIntT<Mod>(lhs) += rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator+(i64 lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(rhs) += lhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator-(ModIntT<Mod> lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(lhs) -= rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator-(ModIntT<Mod> lhs, i64 rhs) { return ModIntT<Mod>(lhs) -= rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator-(i64 lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(rhs) -= lhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator*(ModIntT<Mod> lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(lhs) *= rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator*(ModIntT<Mod> lhs, i64 rhs) { return ModIntT<Mod>(lhs) *= rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator*(i64 lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(rhs) *= lhs; }\n\ntemplate<typename Mod>\nbool operator==(ModIntT<Mod> lhs, ModIntT<Mod> rhs) { return i64(lhs) == i64(rhs); }\ntemplate<typename Mod>\nbool operator==(ModIntT<Mod> lhs, i64 rhs) { return lhs == ModIntT<Mod>(rhs); }\ntemplate<typename Mod>\nbool operator==(i64 lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(lhs) == rhs; }\ntemplate<typename Mod>\nbool operator!=(ModIntT<Mod> lhs, ModIntT<Mod> rhs) { return !(lhs == rhs); }\ntemplate<typename Mod>\nbool operator!=(ModIntT<Mod> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<typename Mod>\nbool operator!=(i64 lhs, ModIntT<Mod> rhs) { return !(lhs == rhs); }\n\ntemplate<typename Mod>\nstruct ProconHash<ModIntT<Mod>> {\n    size_t operator()(ModIntT<Mod> x) const noexcept {\n        return procon_hash_value(i64(x));\n    }\n};\n\ntemplate<typename Mod>\nstruct Scan<ModIntT<Mod>> {\n    static ModIntT<Mod> scan(istream& in) {\n        i64 v = Scan<i64>::scan(in);\n        return ModIntT<Mod>(v);\n    }\n};\n\ntemplate<typename Mod>\nstruct Fmt<ModIntT<Mod>> {\n    static void fmt(ostream& out, ModIntT<Mod> x) {\n        fmt_write(out, i64(x));\n    }\n};\n\ntemplate<typename Mod>\nstruct Dbg<ModIntT<Mod>> {\n    static void dbg(ostream& out, ModIntT<Mod> x) {\n        dbg_write(out, i64(x));\n    }\n};\n\ntemplate<i64 M>\nusing ModIntC = ModIntT<integral_constant<i64,M>>;\n\nusing ModInt = ModIntC<MOD>;\n// }}}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cin.exceptions(ios::failbit | ios::badbit);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(2);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\nstruct UnionFind {\n    vector<i64> ps_;  // 親ノード。ただし根の場合 -(集合の要素数)\n    i64 size_;\n\n    explicit UnionFind(i64 n) : ps_(n,-1), size_(n) {}\n\n    i64 size() const { return size_; }\n\n    i64 root(i64 x) {\n        i64 p = ps_[x];\n        if(p < 0) return x;\n        return ps_[x] = root(p);\n    }\n\n    i64 group_size(i64 x) {\n        return -ps_[root(x)];\n    }\n\n    void unite(i64 x, i64 y) {\n        i64 rx = root(x);\n        i64 ry = root(y);\n        if(rx == ry) return;\n\n        // 要素数が大きい方を根とする\n        i64 kx = -ps_[rx];\n        i64 ky = -ps_[ry];\n        if(kx < ky) swap(rx, ry);\n        ps_[rx] = -(kx + ky);\n        ps_[ry] = rx;\n\n        --size_;\n    }\n};\n\n//--------------------------------------------------------------------\n\nauto coord_compress(vector<i64> xs) {\n    ALL(sort, xs);\n    xs.erase(ALL(unique,xs), end(xs));\n\n    HashMap<i64,i64> comp;\n    REP(i, SIZE(xs)) {\n        comp[xs[i]] = i;\n    }\n    return comp;\n}\n\nvoid solve(i64 N, i64 M) {\n    auto H = RD_VEC(N);\n    auto hcomp = coord_compress(H);\n    vector<vector<i64>> timeline(SIZE(hcomp));\n    REP(v, N) {\n        i64 h = H[v];\n        timeline[hcomp[h]].emplace_back(v);\n    }\n    DBG(timeline);\n\n    auto es = vec_reserve<tuple<i64,i64,i64>>(M);\n    REP(_, M) {\n        i64 a = RD1();\n        i64 b = RD1();\n        i64 c = RD();\n        es.emplace_back(c, a, b);\n    }\n    ALL(sort, es);\n    DBG(es);\n\n    // 橋を全て架けたとして、*最初に*グラフが非連結になる時刻を求める\n    // (時刻が進むにつれ連結になったり非連結になったりすることに注意)\n    // 時刻の逆順に処理\n    i64 i_discon = SIZE(timeline);\n    {\n        UnionFind uf(N);\n        i64 k = 0;\n        vector<bool> exists(N, false);\n        for(i64 i = SIZE(timeline)-1; i >= 0; --i) {\n            const auto& vs = timeline[i];\n            k += SIZE(vs);\n            for(i64 v : vs)\n                exists[v] = true;\n\n            for(const auto& e : es) {\n                i64 v,w; tie(ignore,v,w) = e;\n                if(!exists[v] || !exists[w]) continue;\n                uf.unite(v, w);\n            }\n\n            if(SIZE(uf) > N-k+1)\n                i_discon = i;\n        }\n    }\n    DBG(i_discon);\n    // 最初から非連結なら何もしない\n    if(i_discon == 0) {\n        PRINTLN(0);\n        return;\n    }\n\n    // i_discon の1つ手前から逆順に見ていく\n    // 各時刻で最小全域木を構築(Kruskal)\n    vector<bool> exists(N, false);\n    for(i64 i = SIZE(timeline)-1; i >= i_discon; --i) {\n        for(i64 v : timeline[i])\n            exists[v] = true;\n    }\n    UnionFind uf(N);\n    i64 ans = 0;\n    for(i64 i = i_discon-1; i >= 0; --i) {\n        for(i64 v : timeline[i])\n            exists[v] = true;\n\n        for(const auto& e : es) {\n            i64 cost,v,w; tie(cost,v,w) = e;\n            if(!exists[v] || !exists[w]) continue;\n            if(uf.root(v) == uf.root(w)) continue;\n            uf.unite(v, w);\n            ans += cost;\n        }\n    }\n\n    PRINTLN(ans);\n}\n\nsigned main() {\n    for(;;) {\n        i64 N = RD();\n        i64 M = RD();\n        if(N == 0 && M == 0) break;\n\n        solve(N, M);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\n/***** Union-Find *****/\n\nconst int MAX_N = 10000;\nint Par[MAX_N];\nint Rank[MAX_N];\n\nvoid union_find_init(int n){\n\tfor(int i=0; i<n; ++i){\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(Par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)\n\t\treturn ;\n\n\tif(Rank[x] < Rank[y]){\n\t\tPar[x] = y;\n\t} else{\n\t\tPar[y] = x;\n\t\tif(Rank[x] == Rank[y]){\n\t\t\t++Rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\n/***** /Union-Find *****/\n\nstruct edge {\n\tint from,\n\t\tto,\n\t\tcost;\n    bool operator < (const edge &e) const { return cost < e.cost; }\n};\n\nvector<edge> es;\nint V, E;\n\n// time, vs\nvector<pair<int, VI>> falls;\n\nVB falled;\nVB linked;\n\n// ????????????????????¶????????????????????£????????????\nbool all_unite() {\n    int v = -1;\n    REP(i, 0, V) {\n        if (falled[i]) continue;\n\n        if (v == -1) {\n            v = i;\n        } else {\n            if (!same(v, i)) return false;\n        }\n    }\n    return true;\n}\n\n// ??¨??????????????£????????£????????¨?????????\nvoid link_new_edge() {\n    rep(i, E) {\n        edge &e = es[i];\n        if (linked[i]) continue;\n        if (falled[e.from] || falled[e.to]) continue;\n        if (!same(e.from, e.to)){\n            unite(e.from, e.to);\n            linked[i] = true;\n        }\n    }\n}\n\n// ??¨??????????????????\nvoid link_edge() {\n    rep(i, E) {\n        edge &e = es[i];\n        if (falled[e.from] || falled[e.to]) continue;\n        unite(e.from, e.to);\n    }\n}\n\n// ????¨??????????????±???????\nint sum_cost() {\n    int cost = 0;\n    rep(i, E) {\n        if (linked[i]) {\n            cost += es[i].cost;\n        }\n    }\n    return cost;\n}\n\nint solve() {\n    falled = VB(V);\n\n    sort(ALL(es));\n    sort(ALL(falls));\n\n    // ?????????????°???????????±???????\n    int end_i = 0;\n    for (; end_i < (int)falls.size(); end_i++) {\n        // ?????????\n        for (auto v : falls[end_i].snd) { falled[v] = true; }\n\n        union_find_init(V);\n        link_edge();\n\n        if (!all_unite()) { break; }\n    }\n\n    // ??¨?????¨?????§?????????\n    if (end_i == 0) return 0;\n\n    // ????????????????????????\n    linked = VB(E);\n    union_find_init(V);\n    for (int i = min(end_i, (int)falls.size() - 1); i >= 0; i--) {\n        // ??????\n        for (auto v : falls[i].snd) { falled[v] = false; }\n\n        link_new_edge();\n    }\n    \n    return sum_cost();\n}\n\nint main(void) {\n    while (cin >> V >> E, V) {\n        // ??\\???\n        falls.clear();\n        falls.EB(0, VI());\n        rep(i, V) {\n            int h;\n            cin >> h;\n\n            auto it = find_if(ALL(falls), [h](const pair<int, VI> &x) {\n                    return h == x.fst; });\n            if (it == falls.end()) {\n                falls.EB(h, VI({i}));\n            } else {\n                falls[it - falls.begin()].snd.PB(i);\n            }\n        }\n\n        es.clear(); es.resize(E);\n        rep(i, E) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            --a; --b;\n            es[i].to = a;\n            es[i].from = b;\n            es[i].cost = c;\n        }\n        // ??\\??????????????§\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int_fast64_t;\nusing ui64 = uint_fast64_t;\n#define REP(i, n) for (i64 (i) = 0; (i) < (n); ++(i))\n#define FOR(i, a, b) for (i64 (i) = (a); (i) < (b); ++(i))\n\nstruct UnionFind {\n    int V;\n\t// par[x] := xのroot\n\tvector<int> par;\n\t// sz[x] := xを含む集合のサイズ\n\tvector<int> sz;\n\tUnionFind(int V) :\n\t\tV(V),\n\t\tpar(vector<int>(V)),\n\t\tsz(vector<int>(V, 1))\n\t\t{\n\t\t\tfor(int i = 0; i < V; ++i) par[i] = i;\n\t\t}\n\tbool unite(int x, int y) {\n\t\tx = root(x), y = root(y);\n\t\tif(same(x, y)) return false;\n\t\tif(y < x) swap(x, y);\n\t\tpar[y] = x;\n\t\tsz[x] += sz[y];\n\t\treturn true;\n\t}\n\tint root(int x) {\n\t\tif(par[x] == x) return x;\n\t\treturn (par[x] = root(par[x]));\n\t}\n\tbool same(int x, int y) {\n\t\treturn (root(x) == root(y));\n\t}\n\tint size(int x) {\n\t\treturn sz[root(x)];\n\t}\n};\n\nint N, M;\n\nvoid solve() {\n    ui64 res = 0;\n    UnionFind uf(N);\n    map<int, vector<int>, greater<>> H;\n    REP(i, N) {\n        int h; cin >> h;\n        H[h].emplace_back(i);\n    }\n    vector<vector<pair<int, int>>> graph(N, vector<pair<int, int>>());\n    // vector<tuple<int, int, int>> edges;\n    REP(i, M) {\n        int A, B, C;\n        cin >> A >> B >> C;\n        --A, --B;\n        graph[A].emplace_back(B, C);\n        graph[B].emplace_back(A, C);\n        // edges.emplace_back(A, B, C);\n    }\n    vector<bool> connected(N, false);\n    int connected_vertex = 0;\n    for (auto& e: H) {\n        auto& vec = e.second;\n        connected_vertex += e.second.size();\n        // cerr << \"time: \" << e.first << endl;\n        // for (auto& i: vec) cerr << i + 1 << ' ';\n        // cerr << endl;\n\n        vector<bool> want(N, false);\n        vector<tuple<int, int, int>> need;\n        for (auto& g: vec) want[g] = true;\n        REP(i, N) if (want[i] or connected[i]) {\n            for (auto& edge: graph[i]) {\n                if (want[edge.first] or connected[edge.first]) {\n                    need.emplace_back(edge.second, i, edge.first);\n                }\n            }\n        }\n        sort(need.begin(), need.end());\n        for (auto& g: need) {\n            int cst, frm, dst;\n            tie(cst, frm, dst) = g;\n            if (uf.unite(frm, dst)) {\n                res += cst;\n            }\n        }\n        // cout << res << endl << endl;\n        if (uf.size(H.begin()->second[0]) != connected_vertex) {\n            // connected_vertex = 0;\n            // cout << \"sink : \" << e.second.size() << endl;\n            res = 0;\n            uf = UnionFind(N);\n\n            // vector<int> con;\n            // REP(i, N) if (connected[i] or want[i]) con.emplace_back(i);\n            // REP(i, con.size() - 1) uf.unite(con[i], con[i + 1]);\n        }\n        for (auto& g: vec) connected[g] = true;\n    }\n    // if (uf.size(0) != N) cout << 0 << endl;\n    // else cout << res << endl;\n    cout << res << endl;\n}\n\nsigned main() {\n\n    while (cin >> N >> M, N) {\n        solve();\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define all(a) (a).begin(),(a).end()\n\ntypedef pair<int,int> P;\n\n// uf\nstruct unionfind {\n  vector<int> par;\n  unionfind(int n) : par(n) { for (int i = 0; i < n; ++i) par[i] = i; }\n  \n  int find(int x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  \n  void unite(int x, int y) {\n    par[find(x)] = par[find(y)] = find(x);\n  }\n  \n  bool same(int x, int y) { return find(x) == find(y); }\n};\n\nstruct edge {\n  int u, v, cost;\n  bool operator<(const edge& other) const {\n    return cost < other.cost;\n  }\n};\n\nint N, M;\nint H[202];\nint G[202][202];\n\n// 連結でなくなる時間を求める\nint getTime() {\n  vector<P> lands;\n  rep(i,N) lands.push_back(P(H[i], i));\n  sort(all(lands));\n  vector<int> enable(N, 1);\n  rep(z,N) {\n    unionfind uf(N);\n    // enable の島だけで掛けられそうな橋をとりあえず掛ける\n    rep(i,N) {\n      if (!enable[i]) continue;\n      rep(j,N) {\n        if (!enable[j] || i == j || (G[i][j] <= 0)) continue;\n        if (!uf.same(i,j)) {\n          uf.unite(i,j);\n        }\n      }\n    }\n    // 連結であるか\n    rep(i,N) {\n      if (!enable[i] || i == lands[z].second) continue;\n      if (!uf.same(i, lands[z].second)) {\n        if (z == 0) return -1;\n        return lands[z-1].first;\n      }\n    }\n    enable[lands[z].second] = 0;    \n  }\n  return lands.back().first + 1;\n}\n\nint solve() {\n  int time = getTime(), ans = 0;\n  vector<P> lands;\n  rep(i,N) lands.push_back(P(H[i], i));\n  sort(all(lands), greater<P>());\n  // 最初から連結でない\n  if (time == -1) {\n    return 0;\n  }\n  vector<edge> es;\n  rep(i,N) rep(j,N) if (G[i][j]) es.push_back((edge){i, j, G[i][j]});\n  sort(all(es));\n  vector<int> on(N, 0);\n  // 橋を掛ける  \n  unionfind uf(N);\n  rep(z,N) {\n    on[lands[z].second] = 1;\n    const int t = lands[z].first;\n    if (t > time) continue;\n    if ((z+1 < N) && (lands[z].first == lands[z+1].first)) continue;\n    rep(i,es.size()) {\n      edge e = es[i];\n      int u = e.u, v = e.v;\n      if (on[u] && on[v]) {\n        if (G[u][v] && !uf.same(u, v)) {\n          ans += e.cost;\n          uf.unite(u, v);\n        }\n      }\n    }\n  }\n  return ans;\n}\n\nint main() {\n  while (scanf(\"%d%d\", &N, &M), N) {\n    // G[][] 初期化\n    rep(i,N) rep(j,N) G[i][j] = 0;\n    rep(i,N) G[i][i] = 0;\n    \n    rep(i,N) scanf(\"%d\", H+i);\n    rep(i,M) {\n      int a, b, c;      \n      scanf(\"%d%d%d\", &a, &b, &c);\n      --a; --b;\n      G[a][b] = G[b][a] = c;\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nclass UnionFind{\nprivate:\n    vector<int> p,s;\npublic:\n\tUnionFind(){}\n\tUnionFind(int N){\n\t\tp = s = vector<int>(N+1,0);\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tp[i] = i; s[i] = 1;\n\t\t}\n\t}\n    void init(int N){\n        for(int i=1;i<=N;i++){\n\t\t\tp[i] = i; s[i] = 1;\n\t\t}\n    }\n\tint find(int x){\n\t\tif(p[x]==x) return x;\n\t\telse return p[x] = find(p[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(s[x]>s[y]){\n\t\t\tp[y] = x;\n\t\t\ts[x] += s[y];\n\t\t}else{\n\t\t\tp[x] = y;\n\t\t\ts[y] += s[x];\n\t\t}\n\t}\n\tbool is_same_set(int x,int y) {return find(x)==find(y);}\n\tint size(int x) {return s[find(x)];}\n};\n\n\nstruct edge{\n    int to,cost;\n};\n\n\nint N,M;\nP H[210];\nvector<PP> u;\nint floating[210] = {0};\n\n\nint main(){\n    while(true){\n        cin >> N >> M;\n        if(N==0) break;\n        int h;\n        for(int i=1;i<=N;i++){\n            cin >> h;\n            H[i] = P(h,i);\n            floating[i] = false;\n        }\n        sort(H+1,H+N+1,greater<P>());\n        int a,b,c;\n        UnionFind uf(N);\n        u.clear();\n        for(int i=1;i<=M;i++){\n            cin >> a >> b >> c;\n            u.push_back(PP(c,P(a,b)));\n        }\n        int ans = 0;\n        sort(u.begin(),u.end());\n        int i = 1;\n        while(i<=N){\n            while(i<N && H[i].first==H[i+1].first){\n                floating[H[i].second] = true;\n                i++;\n            }\n            if(i<=N){\n                floating[H[i].second] = true;\n                i++;\n            }\n            for(auto x:u){\n                if(!floating[x.second.first] || !floating[x.second.second]) continue;\n                if(!uf.is_same_set(x.second.first,x.second.second)){\n                    ans += x.first;\n                    uf.unite(x.second.first,x.second.second);\n                }\n            }\n            if(uf.size(H[1].second)!=i-1){\n                ans = 0;\n                uf.init(N);\n            }\n        }\n        cout << (uf.size(1)==N? ans:0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst int inf=(int)1e9;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\n\n//union_find\n//_n mast be unsigned int\n//BEGIN CUT HERE\nclass union_find{\npublic:\n    explicit union_find(int _n):n(_n){\n        par.resize(static_cast<unsigned long>(_n));\n        rank.resize(static_cast<unsigned long>(_n));\n        sizes.resize(static_cast<unsigned long>(_n));\n        for(int i=0;i<_n;i++){\n            par[i]=i;\n            rank[i]=0;\n            sizes[i]=1;\n        }\n    }\n    \n    //親ノードを見つけます\n    int find(int a){\n        if(par[a]==a)return a;\n        return par[a]=find(par[a]);\n    }\n    \n    //aとbが同じグループかの判定\n    bool same(int a,int b){\n        return find(a)==find(b);\n    }\n    \n    //aとbを同じグループにします\n    void unite(int a,int b){\n        link(find(a),find(b));\n    }\n    \n    //aが属するグループの要素数を求めます\n    int size(int a){\n        return sizes[find(a)];\n    }\n    \n    //全体がどのグループに属しているかがわかります\n    void view(){\n        for(int i=0;i<n;i++){\n            cout<<\" par\"<<\"[\"<<i<<\"]=\"<<par[i]<<((i==n-1)?\"\\n\":\",\");\n        }\n        for(int i=0;i<n;i++){\n            cout<<\"size\"<<\"[\"<<i<<\"]=\"<<sizes[i]<<((i==n-1)?\"\\n\":\",\");\n        }\n        cout<<endl;\n    }\n\n    void init(){\n      for(int i=0;i<n;i++){\n        par[i]=i;\n        rank[i]=0;\n        sizes[i]=1;\n      }\n    }\n\nprivate:\n    void link(int a,int b){\n        if(same(a,b))return;\n        if(rank[a]>rank[b]){\n            par[b]=a;\n            sizes[a]+=sizes[b];\n            sizes[b]=0;\n        }else{\n            par[a]=b;\n            if(rank[a]==rank[b])rank[b]++;\n            sizes[b]+=sizes[a];\n            sizes[a]=0;\n        }\n    }\n    int n;\n    vector<int> par;\n    vector<int> rank;\n    vector<int> sizes;\n};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int n,m;\n  while(cin>>n>>m,n){\n    vector<pair<int,int> > h;\n    for(int i=0;i<n;i++){\n      int a;cin>>a;\n      h.push_back({a,i});\n    }\n    union_find tmp(n);\n    vector<pair<pair<int,int>,int> > v;\n    for(int i=0;i<m;i++){\n      int a,b,c;cin>>a>>b>>c;\n      a--;b--;\n      tmp.unite(a,b);\n      v.push_back(make_pair(make_pair(c,a),b));\n    }\n    if(tmp.size(0)!=n){\n      cout<<0<<endl;\n      continue;\n    }\n    sort(h.begin(),h.end());\n    reverse(h.begin(),h.end());\n    sort(v.begin(),v.end());\n    union_find uf(n);\n    ll ans=0;\n    bool ok[201];\n    int cont=0;\n    for(int i=0;i<n;i++)ok[i]=0;\n    for(int i=0;i<n;i++){\n      ok[h[i].se]=1;\n      if(i==n-1 || h[i].fi!=h[i+1].fi){\n        for(int j=0;j<m;j++){\n          int nowa=v[j].fi.se;\n          int nowb=v[j].se;\n          if(ok[nowa] && ok[nowb] && !uf.same(nowa,nowb)){\n            ans+=v[j].fi.fi;\n            cont++;\n            uf.unite(nowa,nowb);\n          }\n        }\n        if(cont!=i){\n          uf.init();\n          cont=0;\n          ans=0;\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint n,m,h[N],a,b,c,X;\nvector<int> edge[N];\nvector<int> v;\nvector<P1> e;\nbool used[N];\nint par[N];\nset<int> s;\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x!=y)par[x]=y;\n}\n\nbool check(int A,int B){\n  bool x[N];\n  memset(x,0,sizeof(x));\n  for(int i=0;i<n;i++)par[i]=i;\n  for(int i=0;i<e.size();i++){\n    int n1=e[i].second.first;\n    int n2=e[i].second.second;\n    if(!(A<=h[n1]&&h[n1]<=B))continue;\n    if(!(A<=h[n2]&&h[n2]<=B))continue;\n    if(find(n1)!=find(n2)){\n      unite(n1,n2);\n      x[n1]=x[n2]=true;\n    }\n  }\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(!(A<=h[i]&&h[i]<=B))continue;\n    if(!x[i])res=false,cnt++;\n  }\n  return res;\n}\n\nvoid dfs(int x){\n  used[x]=true;\n  for(int i=0;i<edge[x].size();i++){\n    int nx=edge[x][i];\n    if(!used[nx])dfs(nx);\n  }\n}\n\nint kruskal(){\n  int res=0,X2=(int)v.size()-1;\n  for(int i=0;i<n;i++)par[i]=i;\n  if(X>=0){\n    for(int i=0;i<e.size();i++){\n      int n1=e[i].second.first;\n      int n2=e[i].second.second;\n      if(!(v[X]<=h[n1]&&h[n1]<=v[X2]))continue;\n      if(!(v[X]<=h[n2]&&h[n2]<=v[X2]))continue;\n      if(find(n1)!=find(n2)){\n\tunite(n1,n2);\n\tres+=e[i].first;\n      }\n    }\n  }\n  if(X==-1)X=X2+1;\n  for(int k=X-1;k>=0;k--){\n    for(int i=0;i<e.size();i++){\n      int n1=e[i].second.first;\n      int n2=e[i].second.second;\n      if(!(v[k]<=h[n1]&&h[n1]<=v[X2]))continue;\n      if(!(v[k]<=h[n2]&&h[n2]<=v[X2]))continue;\n      if(find(n1)!=find(n2)){\n\tunite(n1,n2);\n\tres+=e[i].first;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n      s.insert(h[i]);\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      edge[a-1].push_back(b-1);\n      edge[b-1].push_back(a-1);\n      e.push_back(P1(c,P(a-1,b-1)));\n    }\n    sort(e.begin(),e.end());\n    set<int>::iterator ite;\n    for(ite=s.begin();ite!=s.end();ite++)\n      v.push_back(*ite);\n    v.push_back(v[0]);\n    sort(v.begin(),v.end());\n    X=-1;\n    for(int i=0;i<v.size();i++)\n      if(!check(v[i],v[(int)v.size()-1])){\n\tX=i-1;\n\tbreak;\n      }\n    memset(used,0,sizeof(used));\n    dfs(0);\n    int f=0;\n    for(int i=0;i<n;i++)\n      if(!used[i])f=1;\n    if(f)cout<<0<<endl;\n    else cout<<kruskal()<<endl;\n    for(int i=0;i<n;i++)edge[i].clear();\n    e.clear();\n    v.clear();\n    s.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nstruct UnionFindTree{\n    vector<int> v;\n    vector<int> rank;\n    UnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        if(v[x] != x){\n            v[x] = Find(v[x]);\n        }\n        return v[x];\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nstruct edge{\n\tint x,y,c;\n\tedge(int x, int y, int c):x(x),y(y),c(c){}\n\tedge(){}\n\tbool operator < (const edge &a) const{\n\t\treturn c < a.c;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<pair<int,int> > time(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\ttime[i] = make_pair(h, i);\n\t\t}\n\t\tsort(time.begin(), time.end());\n\t\treverse(time.begin(), time.end());\n\t\t\n\t\tvector<edge> bridge(m);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tbridge[i] = edge(a,b,c);\n\t\t}\n\t\tsort(bridge.begin(), bridge.end());\n\t\t\n\t\tUnionFindTree uft(n);\n\t\tvector<bool> usable(n, false), used(m, false);\n\t\tint ans = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tusable[time[i].second] = true;\n\t\t\twhile(i+1<n && time[i].first==time[i+1].first){\n\t\t\t\ti++;\n\t\t\t\tusable[time[i].second] = true;\n\t\t\t}\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tedge e = bridge[j];\n\t\t\t\tif(!used[j] && usable[e.x] && usable[e.y] && uft.Find(e.x)!=uft.Find(e.y)){\n\t\t\t\t\tans += e.c;\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tuft.Union(e.x, e.y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint root = uft.Find(0);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(uft.Find(i) != root){\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1){ }\n\t// ?????????????????????\n\tbool unite(int x, int y){\n\t\tx=root(x); y=root(y);\n\t\tif( x != y ) data[y] = x;\n\t\treturn x!=y;\n\t}\n\t// ??????????????????????????????\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\t// ??????????????\\???????????????\n\tint root(int x){\n\t\t// ???????????????????????????????????????????????????\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n};\n\nint N, M, a[1000], b[1000], c[1000];\nvector<P> vh, vc;\n\nint solve2(UnionFind &uf, const vector<int> &l, int z){\n\tint sum = 0;\n\tUnionFind ufl = uf;\n\tfor(auto t: l){\n\t\tufl.unite( z, t );\n\t}\n\tfor(auto c: vc){\n\t\tint i = c.second;\n\t\tif( uf.find(a[i], b[i]) ) continue;\n\t\tif( !ufl.find(z, a[i]) ) continue;\n\t\tif( !ufl.find(z, b[i]) ) continue;\n\t\tuf.unite( a[i], b[i] );\n\t\tsum += c.first;\n\t}\n\treturn sum;\n}\n\nint solve(int limit){\n\tint now = limit;\n\tint z = vh[0].second;\n\tint ans = 0;\n\tUnionFind uf(205);\n\tvector<int> l;\n\tfor(auto v: vh){\n\t\t//if( v.first < limit ) continue;\n\t\t//if( now == 0 ) now = v.first;\n\t\tif( v.first >= limit && now != v.first ){\n\t\t\tans += solve2(uf, l, z);\n\t\t\t//cout << v.first << \" \" << ans << endl;\n\t\t\tl.clear();\n\t\t}\n\t\tl.push_back( v.second );\n\t\tnow = max( v.first, limit );\n\t}\n\treturn ans;\n}\n\nint calc(){\n\tint limit = 0;\n\twhile(1){\n\t\tint nx = vh.size()-1;\n\t\tbool sink[205]={}; sink[0] = true;\n\t\twhile(limit <= vh[nx].first){\n\t\t\tsink[ vh[nx].second ] = true;\n\t\t\tnx--;\n\t\t\tif( nx <= 0 ) break;\n\t\t}\n\t\tif( nx <= 0 ) break;\n//\t\tcout << \"ok\" << nx << endl;\n\n\t\tUnionFind uf(205);\n\t\tint z = vh[0].second;\n\t\tfor(auto c: vc){\n\t\t\tint i = c.second;\n\t\t\tif( sink[ a[i] ] || sink[ b[i] ] ) continue;\n\t\t\tuf.unite( a[i], b[i] );\n\t\t}\n\t\tbool f = false;\n\t\trep(i,N+1) if( !sink[i] && !uf.find(z,i) ) f = true;\n\t\tif(f) break;\n\t\tlimit = vh[nx].first;\n\t}\n\treturn limit;\n}\n\nint main(){\n\twhile(cin >> N >> M, N|M){\n\t\tvh.clear(); vc.clear();\n\t\trep(i,N){\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\tvh.emplace_back( -h, i+1 );\n\t\t}\n\t\tvh.emplace_back(0,0);\n\t\tsort( vh.begin(), vh.end() );\n\t\trep(i,M){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tvc.emplace_back( c[i], i );\n\t\t}\n\t\tsort( vc.begin(), vc.end() );\n\t\t//cout << calc() << endl;\n\t\tcout << solve( calc() ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nstruct edge{ int to,cost; };\nstruct edge_krus{ int from,to,cost; };\n\nint rnk[200],par[200];\n\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\trnk[i] = 0;\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rnk[x] < rnk[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nbool comp(const edge_krus& e1,const edge_krus& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int MAX_H = 1000000;\nvector<int> sink[MAX_H];\n\nsigned main(){\n\tint n,m;\n\twhile(scanf(\"%lld %lld\",&n,&m),n){\n\t\tint ans = 0;\n\t\tvector<edge> G[200];\n\t\tbool sank[200] = {};\n\t\tfor(int i = 0;i < MAX_H;i++) sink[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint h;\n\t\t\tscanf(\"%lld\",&h);\n\t\t\tsink[h - 1].push_back(i);\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%lld %lld %lld\",&a,&b,&c); a--;b--;\n\t\t\tG[a].push_back({b,c});\n\t\t\tG[b].push_back({a,c});\n\t\t}\n\t\tinit(n);\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(edge e : G[j]){\n\t\t\t\tif(!sank[j] && !sank[e.to]) unite(j,e.to);\n\t\t\t}\n\t\t}\n\t\tint mi = INF,ma = -1;\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(sank[j]) continue;\n\t\t\tmi = min(mi,find(j));\n\t\t\tma = max(ma,find(j));\n\t\t}\n\t\tif(mi != ma){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint last = -1;\n\t\tfor(int i = 0;i < MAX_H;i++){\n\t\t\tif(!sink[i].size()) continue;\n\t\t\tfor(int v : sink[i]) sank[v] = true;\n\t\t\tinit(n);\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tfor(edge e : G[j]){\n\t\t\t\t\tif(!sank[j] && !sank[e.to]) unite(j,e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mi = INF,ma = -1;\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(sank[j]) continue;\n\t\t\t\tmi = min(mi,find(j));\n\t\t\t\tma = max(ma,find(j));\n\t\t\t}\n\t\t\tif(mi != ma){\n\t\t\t\tfor(int v : sink[i]) sank[v] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = i;\n\t\t}\n\t\tinit(n);\n\t\tvector<edge_krus> es;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(edge e : G[i]){\n\t\t\t\tif(!sank[i] && !sank[e.to]) es.push_back({i,e.to,e.cost});\n\t\t\t}\n\t\t}\n\t\tsort(es.begin(),es.end(),comp);\n\t\tfor(edge_krus e : es){\n\t\t\tif(!same(e.from,e.to)){\n\t\t\t\tunite(e.from,e.to);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\tfor(int i = last;i >= 0;i--){\n\t\t\tif(!sink[i].size()) continue;\n\t\t\tes.clear();\n\t\t\tfor(int v : sink[i]) sank[v] = false;\n\t\t\tfor(int v : sink[i]){\n\t\t\t\tfor(edge e : G[v]){\n\t\t\t\t\tif(!sank[e.to]) es.push_back({v,e.to,e.cost});\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(es.begin(),es.end(),comp);\n\t\t\tfor(edge_krus e : es){\n\t\t\t\tif(!same(e.from,e.to)){\n\t\t\t\t\tunite(e.from,e.to);\n\t\t\t\t\tans += e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m;\n\nbool is_connected(vector<vector<int>>& v, vector<int>& used, int start) {\n    int n = v.size();\n    queue<int> que;\n    que.push(start);\n\n    while (que.size()) {\n        int now = que.front();\n        que.pop();\n\n        if (used[now]) continue;\n        used[now] = true;\n\n        for (int j = 0; j < n; j++) {\n            if (v[now][j] >= 0 && !used[j]) {\n                que.push(j);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (!used[i]) return false;\n    }\n\n    return true;\n}\n\nint bfs(priority_queue<P, vector<P>, greater<P>>& que, vector<int>& used, vector<vector<int>>& v) {\n    int sum = 0;\n    while (que.size()) {\n        P p = que.top(); que.pop();\n        int now = p.second;\n        int cost = p.first;\n\n        if (used[now]) continue;\n        used[now] = true;\n        sum += cost;\n\n        for (int i = 0; i < n; i++) {\n            if (v[now][i] >= 0 && !used[i]) {\n                que.push(P(v[now][i], i));\n            }\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        map<int,vector<int>> h;\n        for (int i = 0; i < n; i++) {\n            int _h;\n            cin >> _h;\n\n            h[_h].push_back(i);\n        }\n\n        vector<vector<int>> v(n, vector<int>(n, -1));\n        for (int i = 0; i < m; i++) {\n            int x, y, c;\n            cin >> x >> y >> c;\n            --x, --y;\n            v[x][y] = v[y][x] = c;\n        }\n\n        {\n            vector<int> tmp(n, false);\n            if (!is_connected(v, tmp, 0)) {\n                cout << 0 << endl;\n                continue;\n            }\n        }\n\n        bool erased[200], merged[200];\n        memset(erased, 0, sizeof(erased));\n        memset(merged, 0, sizeof(erased));\n        int ans = 0;\n\n        for (auto l: h) {\n            auto vec = l.second;\n            bool _erased[200];\n            for (int i = 0; i < n; i++) _erased[i] = erased[i];\n            for (auto i: vec) erased[i] = true;\n\n            vector<int> used(n, false);\n            int unremoved_idx = -1;\n            for (int i = 0; i < n; i++) {\n                if (erased[i]) used[i] = true;\n                else unremoved_idx = i;\n            }\n            if (unremoved_idx < 0) {\n                break;\n            }\n            bool flag = true;\n            if (!is_connected(v, used, unremoved_idx)) {\n                flag = false;\n            }\n\n            if (flag) {\n                for (auto i: vec) used[i] = false;\n                priority_queue<P, vector<P>, greater<P>> q;\n                for (int i = 0; i < vec.size(); i++) {\n                    for (int j = 0; j < n; j++) {\n                        if (v[vec[i]][j] >= 0 && !_erased[j] && used[j]) {\n                            q.push(P(v[vec[i]][j], vec[i]));\n                        }\n                    }\n                }\n\n                ans += bfs(q, used, v);\n            } else {\n                for (int i = 0; i < n; i++) {\n                    used[i] = _erased[i];\n                }\n\n                priority_queue<P, vector<P>, greater<P>> q;\n                for (int i = 0; i < n; i++) {\n                    if (v[vec[0]][i] >= 0 && !used[i]) {\n                        q.push(P(v[vec[0]][i], i));\n                        used[vec[0]] = true;\n                    }\n                }\n\n                ans += bfs(q, used, v);\n                break;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct Edge\n{\n    int from, to, cost;\n    Edge(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\n\n// 逆順にしているので注意\nbool operator<(const Edge &e, const Edge &f)\n{\n    return e.cost > f.cost;\n}\n\nclass UnionFind\n{\n    std::vector<int> data;\n\npublic:\n    UnionFind(int size) : data(size, -1) {}\n    bool unite(int x, int y)\n    {\n        x = root(x);\n        y = root(y);\n        if (x != y)\n        {\n            if (data[y] < data[x])\n                std::swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return x != y;\n    }\n    bool find(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    int root(int x)\n    {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x)\n    {\n        return -data[root(x)];\n    }\n};\n\nvector<vector<int>> hs(1000010);\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    while (cin >> n >> m, n || m)\n    {\n        for (int i = 1; i <= 1000000; i++)\n            hs[i].clear();\n        set<int> st = {0};\n        for (int i = 0; i < n; i++)\n        {\n            int h;\n            cin >> h;\n            st.insert(h);\n            hs[h].push_back(i);\n        }\n        Edges es;\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--;\n            b--;\n            es.emplace_back(a, b, c);\n        }\n        sort(es.rbegin(), es.rend());\n        int last = -1, cnt = n;\n        vector<int> sink(n, 0);\n        for (auto h : st)\n        {\n            for (auto v : hs[h])\n            {\n                sink[v] = 1;\n                cnt--;\n            }\n            if (cnt <= 1)\n                break;\n            UnionFind uf(n);\n            int v = -1;\n            for (const auto &e : es)\n            {\n                int a = e.from, b = e.to;\n                if (!sink[a] && !sink[b])\n                {\n                    uf.unite(a, b);\n                    v = a;\n                }\n            }\n            // assert(v != -1);\n            // cout << h << \" \" << v << \" \" << uf.size(v) << \" \" << cnt << endl;\n            if (uf.size(v) == cnt)\n                last = h;\n            else\n                break;\n        }\n        if (last == -1)\n        {\n            cout << 0 << endl;\n            continue;\n        }\n        int ret = 0;\n        UnionFind uf(n);\n        for (int i = 0; i < n; i++)\n        {\n            sink[i] = 0;\n        }\n        for (auto h : st)\n        {\n            if (h <= last)\n            {\n                for (auto v : hs[h])\n                {\n                    sink[v] = 1;\n                }\n                continue;\n            }\n        }\n        for (auto e : es)\n        {\n            int a = e.from, b = e.to, c = e.cost;\n            if (sink[a] || sink[b])\n                continue;\n            if (uf.find(a, b))\n                continue;\n            uf.unite(a, b);\n            ret += c;\n        }\n        for (int i = last; i >= 1; i--)\n        {\n            for (auto v : hs[i])\n                sink[v] = 0;\n            for (auto e : es)\n            {\n                int a = e.from, b = e.to, c = e.cost;\n                if (sink[a] || sink[b])\n                    continue;\n                if (uf.find(a, b))\n                    continue;\n                uf.unite(a, b);\n                ret += c;\n            }\n        }\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nstruct edge{ int to,cost; };\nstruct edge_krus{\n\tint from,to,cost;\n\tbool operator<(const edge_krus &e) const{\n\t\treturn cost > e.cost;\n\t}\n};\n\nint rnk[200],par[200];\n\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\trnk[i] = 0;\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rnk[x] < rnk[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nconst int MAX_H = 1000000;\nvector<int> sink[MAX_H];\n\nsigned main(){\n\tint n,m;\n\twhile(scanf(\"%lld %lld\",&n,&m),n){\n\t\tint ans = 0;\n\t\tvector<edge> G[200];\n\t\tbool sank[200] = {};\n\t\tfor(int i = 0;i < MAX_H;i++) sink[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint h;\n\t\t\tscanf(\"%lld\",&h);\n\t\t\tsink[h - 1].push_back(i);\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%lld %lld %lld\",&a,&b,&c); a--;b--;\n\t\t\tG[a].push_back({b,c});\n\t\t\tG[b].push_back({a,c});\n\t\t}\n\t\tinit(n);\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(edge e : G[j]){\n\t\t\t\tif(!sank[j] && !sank[e.to]) unite(j,e.to);\n\t\t\t}\n\t\t}\n\t\tint mi = INF,ma = -1;\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(sank[j]) continue;\n\t\t\tmi = min(mi,find(j));\n\t\t\tma = max(ma,find(j));\n\t\t}\n\t\tif(mi != ma){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint last = -1;\n\t\tfor(int i = 0;i < MAX_H;i++){\n\t\t\tif(!sink[i].size()) continue;\n\t\t\tfor(int v : sink[i]) sank[v] = true;\n\t\t\tinit(n);\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tfor(edge e : G[j]){\n\t\t\t\t\tif(!sank[j] && !sank[e.to]) unite(j,e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mi = INF,ma = -1;\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(sank[j]) continue;\n\t\t\t\tmi = min(mi,find(j));\n\t\t\t\tma = max(ma,find(j));\n\t\t\t}\n\t\t\tif(mi != ma){\n\t\t\t\tfor(int v : sink[i]) sank[v] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = i;\n\t\t}\n\t\tinit(n);\n\t\tpriority_queue<edge_krus> es;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(edge e : G[i]){\n\t\t\t\tif(!sank[i] && !sank[e.to]) es.push({i,e.to,e.cost});\n\t\t\t}\n\t\t}\n\t\twhile(!es.empty()){\n\t\t\tedge_krus e = es.top();es.pop();\n\t\t\tif(!same(e.from,e.to)){\n\t\t\t\tunite(e.from,e.to);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\tfor(int i = last;i >= 0;i--){\n\t\t\tif(!sink[i].size()) continue;\n\t\t\tfor(int v : sink[i]) sank[v] = false;\n\t\t\tfor(int v : sink[i]){\n\t\t\t\tfor(edge e : G[v]){\n\t\t\t\t\tif(!sank[e.to]) es.push({v,e.to,e.cost});\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!es.empty()){\n\t\t\t\tedge_krus e = es.top();es.pop();\n\t\t\t\tif(!same(e.from,e.to)){\n\t\t\t\t\tunite(e.from,e.to);\n\t\t\t\t\tans += e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v));\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\ntemplate<class T> inline T sq(T a){return a*a;}\ntemplate<class T> T gcd(T m, T n){return n?gcd(n, m%n):m;}\n\nconst int N = 210;\nint par[N];\n\nint find(int x){\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tpar[find(x)]=find(y);\n}\n\nstruct edge{\n\tint from, to, cost;\n\tedge(){}\n\tedge(int f, int t, int c):from(f), to(t), cost(c){}\n\tbool operator<(const edge &r) const{\n\t\treturn cost < r.cost;\n\t}\n};\n\nint h[N];\nedge E[N*N];\nbool used[N*N];\n\nint ans, cnt;\n\nvoid init(){\n\trep(i, N) par[i] = i;\n\tMEMSET(used, 0);\n\tans = 0;\n\tcnt = 1;\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tinit();\n\t\trep(i, n) cin >> h[i];\n\t\tMEMSET(used, 0);\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--, b--;\n\t\t\tE[i] = edge(a, b, c);\n\t\t}\n\n\t\tpriority_queue<P> q;\n\t\trep(i, n) q.push(MP(h[i], i));\n\t\tbool ok[N] = {};\n\t\tsort(E, E+m);\n\n\t\tint num = 0;\n\t\tinit();\n\t\twhile(!q.empty()){\n\t\t\tint x = q.top().first;\n\t\t\twhile(!q.empty() && x == q.top().first){\n\t\t\t\tnum++;\n\t\t\t\tok[q.top().second] = 1;\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\trep(i, m){\n\t\t\t\tint f = E[i].from, t = E[i].to;\n\t\t\t\tif(!used[i] && ok[f] && ok[t]){\n\t\t\t\t\tif(find(f) == find(t)) continue;\n\t\t\t\t\tunite(f, t);\n\t\t\t\t\tcnt++;\n\t\t\t\t\tans += E[i].cost;\n\t\t\t\t\tused[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt != num) init();\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nstruct T {\n\tint a, b;\n\tint c;\n\tint h;\n\tbool operator<(const T &right) const {\n\t\tif (h == right.h)return c < right.c;\n\t\treturn h > right.h;\n\t}\n};\nstruct UnionFind {\n\tvector<int> sz;\n\tUnionFind(int n) {\n\t\tsz.resize(n, -1);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a != b) {\n\t\t\tif (-sz[a] < -sz[b]) {\n\t\t\t\tswap(a, b);\n\t\t\t}\n\t\t\tsz[a] += sz[b];\n\t\t\tsz[b] = a;\n\t\t}\n\t}\n\tbool find(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\tint root(int a) {\n\t\tif (sz[a] < 0)return a;\n\t\treturn sz[a] = root(sz[a]);\n\t}\n};\nsigned main() {\n\twhile (true) {\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N == 0)break;\n\t\tvector<int> h(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> h[i];\n\t\t}\n\t\tvector<T> e(M);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> e[i].a >> e[i].b >> e[i].c;\n\t\t\te[i].a--;\n\t\t\te[i].b--;\n\t\t\te[i].h = min(h[e[i].a], h[e[i].b]);\n\t\t}\n\t\tsort(e.begin(), e.end());\n\t\tUnionFind uf(N);\n\t\tint cnt = 0;\n\t\tint res = 0;\n\t\tfor (int i = 0; i < e.size(); i++) {\n\t\t\tif (!uf.find(e[i].a, e[i].b)) {\n\t\t\t\tuf.unite(e[i].a, e[i].b);\n\t\t\t\tcnt++;\n\t\t\t\tres += e[i].c;\n\t\t\t}\n\t\t}\n\t\tif (cnt != N - 1)res = 0;\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define inf (1<<29)\nusing namespace std;\n\ntypedef vector<pair<int, int> > vpii;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unite(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool isSame(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n\n};\n\n\nint main() {\n  int N, M;\n  int a, b, c;\n  while(1) {\n    cin >> N >> M;\n    if(N == 0 && M == 0)\n      break;\n    vpii hlist(N);\n    vector<pair<int, pair<int, int> > > edges(M);\n    bool used[200];\n    int h;\n    int count = 0;\n    UnionFind *uf = new UnionFind(N);\n    rep(i, N) {\n      cin >> h;\n      hlist[i] = make_pair(h, i);\n      used[i] = false;\n    }\n    sort(hlist.begin(), hlist.end());\n    reverse(hlist.begin(), hlist.end());\n    rep(i, M) {\n      cin >> a >> b >> c;\n      edges[i] = make_pair(c, make_pair(a - 1, b - 1));\n    }\n    sort(edges.begin(), edges.end());\n    rep(i, N) {\n      used[hlist[i].second] = true;\n      if(i < N - 1 && hlist[i].first == hlist[i+1].first) {\n        continue;\n      }\n      rep(j, M) {\n        a = edges[j].second.first;\n        b = edges[j].second.second;\n        if(used[a] && used[b] && !uf->isSame(a, b)) {\n            uf->unite(a, b);\n            count += edges[j].first;\n        }\n      }\n      rep(j, N) {\n        if(used[j] && uf->size(j)  != i + 1) {\n          delete uf;\n          uf = new UnionFind(N);\n          count = 0;\n          break;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct Edge\n{\n    int from, to, cost;\n    Edge(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\n\n// 逆順にしているので注意\nbool operator<(const Edge &e, const Edge &f)\n{\n    return e.cost > f.cost;\n}\n\nclass UnionFind\n{\n    std::vector<int> data;\n\npublic:\n    UnionFind(int size) : data(size, -1) {}\n    bool unite(int x, int y)\n    {\n        x = root(x);\n        y = root(y);\n        if (x != y)\n        {\n            if (data[y] < data[x])\n                std::swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return x != y;\n    }\n    bool find(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    int root(int x)\n    {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x)\n    {\n        return -data[root(x)];\n    }\n};\n\ntemplate <typename T>\nvoid coordinateCompression(std::vector<T> &a)\n{\n    int N = a.size();\n    std::vector<T> xs = a;\n    sort(xs.begin(), xs.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    for (int i = 0; i < N; i++)\n    {\n        a[i] = lower_bound(xs.begin(), xs.end(), a[i]) - xs.begin();\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    while (cin >> n >> m, n || m)\n    {\n        set<int> st = {0};\n        vector<int> h(n + 1, 0);\n        for (int i = 0; i < n; i++)\n        {\n            cin >> h[i];\n        }\n        coordinateCompression(h);\n        vector<vector<int>> hs(n + 1);\n        for (int i = 0; i < n; i++)\n        {\n            st.insert(h[i]);\n            hs[h[i]].push_back(i);\n        }\n        Edges es;\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--;\n            b--;\n            es.emplace_back(a, b, c);\n        }\n        sort(es.rbegin(), es.rend());\n        int last = -1, cnt = n;\n        vector<int> sink(n, 0);\n        for (auto h : st)\n        {\n            for (auto v : hs[h])\n            {\n                sink[v] = 1;\n                cnt--;\n            }\n            if (cnt <= 1)\n                break;\n            UnionFind uf(n);\n            int v = -1;\n            for (const auto &e : es)\n            {\n                int a = e.from, b = e.to;\n                if (!sink[a] && !sink[b])\n                {\n                    uf.unite(a, b);\n                    v = a;\n                }\n            }\n            // assert(v != -1);\n            // cout << h << \" \" << v << \" \" << uf.size(v) << \" \" << cnt << endl;\n            if (uf.size(v) == cnt)\n                last = h;\n            else\n                break;\n        }\n        if (last == -1)\n        {\n            cout << 0 << endl;\n            continue;\n        }\n        int ret = 0;\n        UnionFind uf(n);\n        for (int i = 0; i < n; i++)\n        {\n            sink[i] = 0;\n        }\n        for (auto h : st)\n        {\n            if (h <= last)\n            {\n                for (auto v : hs[h])\n                {\n                    sink[v] = 1;\n                }\n                continue;\n            }\n        }\n        for (auto e : es)\n        {\n            int a = e.from, b = e.to, c = e.cost;\n            if (sink[a] || sink[b])\n                continue;\n            if (uf.find(a, b))\n                continue;\n            uf.unite(a, b);\n            ret += c;\n        }\n        for (int i = last; i >= 1; i--)\n        {\n            for (auto v : hs[i])\n                sink[v] = 0;\n            for (auto e : es)\n            {\n                int a = e.from, b = e.to, c = e.cost;\n                if (sink[a] || sink[b])\n                    continue;\n                if (uf.find(a, b))\n                    continue;\n                uf.unite(a, b);\n                ret += c;\n            }\n        }\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct edge{\n  int to;\n  int cost;\n  edge(){}\n  edge(int t,int c){\n    to=t;\n    cost=c;\n  }\n};\n\nint N,M;\npii hs[201];\nvector<edge> G[201];\nbool noNode[201];\n\nint makeMST(int st){\n  int sumCost=0;\n  priority_queue<pii,vector<pii>,greater<pii> > pq;\n  bool used[201]={};\n  pq.push(pii(0,st));\n  while(pq.size()){\n    pii p=pq.top();pq.pop();\n    if(used[p.second])continue;\n    if(noNode[p.second])continue;\n    used[p.second]=true;\n    sumCost+=p.first;\n    for(int i=0;i<(int)G[p.second].size();i++){\n      edge &e=G[p.second][i];\n      if(used[e.to])continue;\n      if(noNode[p.second])continue;\n      pq.push(pii(e.cost,e.to));\n    }\n  }\n  for(int i=0;i<N;i++)\n    if(!used[i]&&!noNode[i])return -1;\n  return sumCost;\n}\n\nint makeMST2(int st,vector<int> &v1,vector<int> &v2){\n  int sumCost=0;\n  priority_queue<pii,vector<pii>,greater<pii> > pq;\n  bool used[201]={};\n  bool oks[201]={};\n  for(int i=0;i<(int)v2.size();i++)\n    oks[v2[i]]=true;\n  for(int i=0;i<(int)v1.size();i++){\n    used[v1[i]]=true;\n    for(int j=0;j<(int)G[v1[i]].size();j++){\n      edge &e=G[v1[i]][j];\n      int to=e.to;\n      int cost=e.cost;\n      pq.push(pii(cost,to));\n    }\n  }\n  // まだ決まっていないノードを使ってエッジを埋めていく\n  while(pq.size()){\n    pii p=pq.top();pq.pop();\n    if(used[p.second])continue;\n    if(!oks[p.second])continue;\n    used[p.second]=true;\n    sumCost+=p.first;\n    for(int i=0;i<(int)G[p.second].size();i++){\n      edge &e=G[p.second][i];\n      if(used[e.to])continue;\n      if(!oks[p.second])continue;\n      pq.push(pii(e.cost,e.to));\n    }\n  }\n  return sumCost;\n}\n\nint mst(int st){\n  int sumCost=0;\n  priority_queue<pii,vector<pii>,greater<pii> > pq;\n  bool used[201]={};\n  pq.push(pii(0,st));\n  used[st]=true;\n  for(int i=0;i<(int)G[st].size();i++){\n    edge &e=G[st][i];\n    if(used[e.to])continue;\n    pq.push(pii(e.cost,e.to));\n  }\n  while(pq.size()){\n    pii p=pq.top();pq.pop();\n    int to=p.second;\n    int cost=p.first;\n    if(used[to])continue;\n    if(noNode[to])continue;\n    used[to]=true;\n    sumCost+=cost;\n    for(int i=0;i<(int)G[to].size();i++){\n      edge &e=G[to][i];\n      if(used[e.to])continue;\n      if(noNode[e.to])continue;\n      pq.push(pii(e.cost,e.to));\n    }\n  }\n  for(int i=0;i<N;i++)\n    if(!noNode[i]&&!used[i])return -1;\n  return sumCost;\n}\n\n\nint main(){\n  while(cin>>N>>M&&(N|M)){\n    map<int,vector<int> > m;\n    for(int i=0;i<N;i++){\n      G[i].clear();\n      cin>>hs[i].first;\n      hs[i].second=i;\n      m[hs[i].first].push_back(i);\n    }\n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--;b--;\n      G[a].push_back(edge(b,c));\n      G[b].push_back(edge(a,c));\n    }\n    memset(noNode,0,sizeof(noNode));\n    vector<vector<int> > v;\n    for(map<int,vector<int> >::iterator it=m.begin();\n        it!=m.end();it++)\n      v.push_back(it->second);\n    int idx=(int)v.size();\n    // それぞれの時間単位で、だめな条件を考える\n    for(int i=0;i<(int)v.size();i++){\n      //int res=makeMST(v[i][0]);\n      int res=mst(v[i][0]);\n      if(res==-1){\n        idx=i;\n        break;\n      }\n      for(int j=0;j<(int)v[i].size();j++)\n        noNode[v[i][j]]=true;\n    }\n    if(idx==0){\n      cout<<0<<endl;\n      continue;\n    }\n    // [0,idx)なら作成が可能なので、その範囲で考えていく\n    // idxまでの時点でまずMSTを作成\n    // 次に作ったMSTにエッジを張っていく\n    memset(noNode,0,sizeof(noNode));\n    for(int i=0;i<idx-1;i++)\n      for(int j=0;j<(int)v[i].size();j++)\n        noNode[v[i][j]]=true;\n    int st=-1;\n    for(int i=0;i<N;i++)\n      if(!noNode[i])st=i;\n    int val=makeMST(st);\n    // 次に、idxから順番にedgeを張っていく\n    // vectorでまとめて私\n    // mstを行う\n    for(int i=idx-2;i>=0;i--){\n      for(int j=0;j<(int)v[i].size();j++)noNode[v[i][j]]=false;\n      int st=-1;\n      for(int j=0;j<N;j++)if(!noNode[j])st=j;\n      vector<int> a;\n      for(int j=i+1;j<(int)v.size();j++)for(int k=0;k<(int)v[j].size();k++)a.push_back(v[j][k]);\n      val+=makeMST2(st,a,v[i]);\n    }\n    cout<<val<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,m;\nP h[300];\nint a,b,c,d[300][300],dis[300];\nbool use[300],vis[300];\nconst int INF = (1<<25);\n\nint main(){\n  while(scanf(\"%d%d\",&n,&m),n||m){\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&h[i].fs);\n      h[i].sc = i;\n      for(int j=0;j<n;j++)d[i][j] = INF;\n      d[i][i] = 0;\n    }\n\n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d\",&a,&b,&c);\n      a--; b--;\n      d[a][b] = d[b][a] = c;\n    }\n\n    sort(h,h+n);\n    reverse(h,h+n);\n\n    fill(use,use+n,false);\n    fill(vis,vis+n,false);\n    fill(dis,dis+n,INF);\n    dis[h[0].sc] = 0;\n\n    long long ans = 0;\n    for(int i=0;i<n;i++){\n      use[h[i].sc] = true;\n      while(i+1<n && h[i].fs == h[i+1].fs)use[h[++i].sc] = true;\n      \n      while(1){\n\tint v = -1;\n\tfor(int u=0;u<n;u++){\n\t  if(use[u] && !vis[u] && (v<0 || dis[v]>dis[u]))v = u;\n\t}\n\n\tif(v<0)break;\n\tif(dis[v] == INF){\n\t  fill(vis,vis+n,false);\n\t  fill(dis,dis+n,INF);\n\t  ans = dis[h[0].sc] = 0;\n\t  break;\n\t}\n\n\tvis[v] = true;\n\tans += dis[v];\n\tfor(int i=0;i<n;i++)dis[i] = min(dis[i],d[v][i]);\n      } \n    }\n    printf(\"%lld\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e9;\nusing namespace std;\n\nclass UnionFind{\n\tprivate:\n\t\tvector<int> par, depth;\n\tpublic:\n\t\tUnionFind() {}\n\t\tUnionFind(int n){\n\t\t\tinit(n);\n\t\t}\n\t\tvoid init(int n){\n\t\t\tpar = vector<int>(n);\n\t\t\tdepth = vector<int>(n);\n\t\t\trep(i,n){\n\t\t\t\tpar[i] = i;\n\t\t\t\tdepth[i] = 0;\n\t\t\t}\n\t\t}\n\t\tint find(int x){\n\t\t\tif(par[x] == x){\n\t\t\t\treturn x;\n\t\t\t}else {\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\t\tvoid unite(int x, int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y) return;\n\n\t\t\tif(depth[x] < depth[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t}else{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(depth[x] == depth[y]) depth[x]++;\n\t\t\t}\n\t\t}\n\t\tbool same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n};\n\nstruct Edge{\n\tint u, v, cost, id;\n\tEdge() {}\n\tEdge(int u, int v, int cost) : u(u), v(v), cost(cost) {}\n\n\tbool operator < ( const Edge &right ) const {\n\t\treturn cost < right.cost ? 1 : (cost == right.cost ? (u < right.u ? 1 : (u == right.u ? (v == right.v) : 0)) : 0);\n\t}\n};\n\nclass Kruskal{\n\tprivate:\n\t\tstatic const int MAX_E = 50005;\n\t\tUnionFind unionFind;\n\tpublic:\n\t\tint v;\n\t\tvector<Edge> edge;\n\t\tvector<int> mst; //edge[ mst[i] ] := 最小全域木を構築するi番目の辺\n\t\tKruskal(vector<Edge>& e, int _v){\n\t\t\tv = _v;\n\t\t\tunionFind.init(v);\n\t\t\tedge = e;\n\t\t\tsort(all(edge));\n\t\t}\n\t\tvoid reset(int v){\n\t\t\tunionFind.init(v);\n\t\t}\n\t\tlong long solve(vector<bool> sinked){\n\t\t\tlong long res = 0;\n\t\t\trep(i,edge.size()){\n\t\t\t\tEdge c = edge[i];\n\t\t\t\tif(not unionFind.same(c.u, c.v) and not sinked[c.u] and not sinked[c.v]){\n\t\t\t\t\tunionFind.unite(c.u, c.v);\n\t\t\t\t\tres += c.cost;\n\t\t\t\t\tmst.emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint b = 0;\n\t\t\trep(i,v){\n\t\t\t\tif(sinked[i]) continue;\n\t\t\t\tb = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,v){\n\t\t\t\tif(not unionFind.same(b,i) and not sinked[i]){\n\t\t\t\t\treturn INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n||m){\n\t\tmap<int,vector<int>> h;\n\t\trep(i,n){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\th[a].emplace_back(i);\n\t\t}\n\n\t\tvector<Edge> e(m);\n\t\trep(i,m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\te[i] = Edge{a - 1, b - 1, c};\n\t\t}\n\n\t\tKruskal krus(e, n);\n\t\tvector<bool> sinked(n,0);\n\t\tif(krus.solve(sinked) == INF){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(auto it = h.begin(); it != h.end(); it++){\n\t\t\tkrus.reset(n);\n\t\t\tvector<bool> cp = sinked;\n\t\t\tfor(auto p : it->second) cp[p] = true;\n\t\t\t//for(auto i : cp) cout << i << ' '; cout << endl;\n\t\t\tif(krus.solve(cp) == INF){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsinked = cp;\n\t\t}\n\n\n\t\tkrus.reset(n);\n\t\t//for(auto i : sinked) cout << i << ' '; cout << endl;\n\t\tlong long ans = 0;\n\t\tfor(auto it = h.rbegin(); it != h.rend(); it++){\n\t\t\tfor(auto p : it->second) sinked[p] = false;\n\t\t//for(auto i : sinked) cout << i << ' '; cout << endl;\n\t\t\tans += krus.solve(sinked);\n\t\t\t//show(ans)\n\t\t\tassert(ans <= INF);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tfrom = to = cost = erase_day = 0;\n\t}\n\tInfo(int arg_from,int arg_to,int arg_cost,int arg_erase_day){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\terase_day = arg_erase_day;\n\t}\n\n\tbool operator<(const struct Info &arg) const{\n\t\treturn cost < arg.cost;\n\t};\n\tint from,to,cost,erase_day;\n};\n\nstruct Data{\n\tbool operator<(const struct Data &arg) const{\n\t\treturn day < arg.day;\n\t};\n\tint id,day;\n};\n\nInfo* info;\n\nint parent[200],height[200],N,M;\n\nint find(int x){\n\tif(x == parent[x])return x;\n\telse{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n\nbool isSame(int x,int y){\n\treturn find(x) == find(y);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)return;\n\n\tif(height[x] < height[y]){\n\t\tparent[x] = y;\n\t}else{\n\t\tparent[y] = x;\n\t\tif(height[x] == height[y])height[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nvoid func(){\n\n\tbool isAlive[N];\n\tfor(int i = 0; i < N; i++)isAlive[i] = true;\n\n\tData data[N+1];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&data[i].day);\n\t\tdata[i].id = i;\n\t}\n\tdata[N].day = BIG_NUM;\n\n\tfor(int i = 0; i < M;i++){\n\t\tscanf(\"%d %d %d\",&info[i].from,&info[i].to,&info[i].cost);\n\t\tinfo[i].from--;\n\t\tinfo[i].to--;\n\t\tinfo[i].erase_day = min(data[info[i].from].day,data[info[i].to].day);\n\t}\n\n\tvector<Info> V;\n\n\tsort(data,data+(N+1));\n\tsort(info,info+M);\n\n\n\tinit();\n\n\tll first = 0;\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(!isSame(info[i].from,info[i].to)){\n\t\t\tunite(info[i].from,info[i].to);\n\t\t\tV.push_back(Info(info[i].from,info[i].to,info[i].cost,0));\n\t\t\tfirst += info[i].cost;\n\t\t}\n\t}\n\n\tint num = 0;\n\tfor(int i = 0;i < N; i++){\n\t\tif(parent[i] == i)num++;\n\t}\n\n\tif(num > 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tstack<int> S;\n\n\tint tmp_day,last_day = data[0].day;\n\tint count = N;\n\n\tfor(int sche = 0; sche < N; ){\n\n\t\ttmp_day = data[sche].day;\n\t\tS.push(data[sche].id);\n\t\tsche++;\n\t\twhile(data[sche].day == tmp_day && sche < N){\n\t\t\tS.push(data[sche].id);\n\t\t\tsche++;\n\t\t}\n\n\t\twhile(!S.empty()){\n\t\t\tisAlive[S.top()] = false;\n\t\t\tcount--;\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(count <= 1)break;\n\t\tinit();\n\n\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\tif(isAlive[V[i].from] == true && isAlive[V[i].to] == true){\n\t\t\t\tunite(V[i].from,V[i].to);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(isSame(info[i].from,info[i].to) == false && isAlive[info[i].from] == true && isAlive[info[i].to] == true){\n\t\t\t\tunite(info[i].from,info[i].to);\n\t\t\t\tV.push_back(Info(info[i].from,info[i].to,info[i].cost,0));\n\t\t\t}\n\t\t}\n\n\t\tnum = 0;\n\t\tfor(int i = 0;i < N; i++){\n\t\t\tif(isAlive[i] == true && parent[i] == i)num++;\n\t\t}\n\n\t\tif(num > 1){\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_day = data[sche].day;\n\n\t}\n\n\tll ans = 0,tmp = 0;\n\n\tif(last_day == 0){\n\t\tans = first;\n\t}else{\n\n\t\tint index;\n\t\tfor(index = N-1; data[index].day > last_day; index--);\n\n\t\tinit();\n\t\tfor(;index >= 0; index--){\n\t\t\ttmp_day = data[index].day;\n\n\t\t\ttmp = 0;\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tif(isSame(info[i].from,info[i].to) == false && info[i].erase_day >= tmp_day){\n\t\t\t\t\tunite(info[i].from,info[i].to);\n\t\t\t\t\ttmp += info[i].cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans += tmp;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\tinfo = (Info*)malloc(sizeof(Info)*20000);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <set>\nusing namespace std;\n#define MAX_V 205\n#define INF 1<<30\nint N, M;\nint cost[MAX_V][MAX_V];\nint H[MAX_V];\n\nint mincost[MAX_V];\nbool used[MAX_V];\nbool Vused[MAX_V][MAX_V];\nint prevV[MAX_V];\n\nint prim(int t){\n\tfor(int i=0;i<N;i++){\n\t\tmincost[i]=INF;\n\t\tused[i] = false;\n\t\tprevV[i] = N;\n\t}\n\tfor(int u=0;u<N;u++){\n\t\tif(H[u]>t){\n\t\t\tmincost[u]=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u=0;u<N;u++){\n\t\t\tif(H[u]>t && !used[u] && (v==-1 || mincost[u] < mincost[v])) v=u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tVused[v][prevV[v]] = Vused[prevV[v]][v] = true;\n\t\tif(mincost[v] >= INF) return INF;\n\t\tres += mincost[v];\n\t\tfor(int u=0;u<N;u++){\n\t\t\tif(H[u] <= t) continue;\n\t\t\tif(Vused[v][u] || Vused[u][v]){\n\t\t\t\tmincost[u] = 0;\n\t\t\t\tprevV[u] = v;\n\t\t\t}\n\t\t\tif(mincost[u] > cost[v][u]){\n\t\t\t\tmincost[u] = cost[v][u];\n\t\t\t\tprevV[u] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nmain(){\n\tint i,j,k,a,b,c;\n\twhile(cin >> N >> M, N){\n\t\tvector<int> broken;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<N;j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t\tVused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tbroken.push_back(0);\n\t\tfor(i=0;i<N;i++){\n\t\t\tcin >> H[i];\n\t\t\tbroken.push_back(H[i]);\n\t\t}\n\n\t\tsort(broken.begin(), broken.end());\n\t\tbroken.erase(unique(broken.begin(), broken.end()), broken.end());\n\t\t\n\t\tfor(i=0;i<M;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a-1][b-1] = cost[b-1][a-1] = c;\n\t\t}\n\n\t\tint co = 0;\n\t\tfor(i=broken.size()-1;i>=0;i--){\n\t\t\tint ret = prim(broken[i]);\n\t\t\tif(ret >= INF){\n\t\t\t\tco = 0;\n\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\tfor(j=0;j<N;j++){\n\t\t\t\t\t\tVused[k][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else co += ret;\n\t\t\tprintf(\"%d %d\\n\", broken[i], co);\n\t\t}\n\t\tcout << co << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvp ti(n+1,{1,-1});\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n){\n\t\t\tint a;cin>>a;\n\t\t\tti[i]={a*-1,i};\n\t\t}\n\t\tsort(all(ti));\n\t\tint t=0;\n\t\tUnionFind uf(n);\n\t\tvi used(n);\n\t\tvvi G(m,vi(3));\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tG[i]={a,b,c};\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\tint T=-1;\n\t\twhile(t!=n){\n\t\t\tused[ti[t].second]=true;\n\t\t\twhile(ti[t].second==ti[t+1].second){\n\t\t\t\tt++;\n\t\t\t\tused[ti[t].second]=true;\n\t\t\t}\n\t\t\trep(i,m)if(used[G[i][0]]&&used[G[i][1]])uf.unionSet(G[i][0],G[i][1]);\n\t\t\tt++;\n\t\t\tif(uf.size(ti[0].second)!=t)T=t;\n\t\t}\n\t\tif(uf.size(0)!=n){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tused=vi(n);\n\t\tint sum=0;\n\t\tvi d(n,inf);\n\t\td[ti[0].second]=0;\n\t\trep(j,n){\n\t\t\tint v;\n\t\t\tif(ti[T].first<ti[j].first){\n\t\t\t\tv=-1;\n\t\t\t\trep(i,n)if(used[ti[i].second]==0&&ti[i].first==ti[j].first&&(v==-1||d[v]>d[ti[i].second]))v=ti[i].second;\n\t\t\t}else{\n\t\t\t\tv=-1;\n\t\t\t\trep(i,n)if(used[ti[i].second]==0&&ti[i].first<=ti[T].first&&(v==-1||d[v]>d[ti[i].second]))v=ti[i].second;\n\t\t\t}\n\t\t\tused[v]=true;\n\t\t\tsum+=d[v];\n\t\t\trep(i,n)d[i]=min(d[i],cost[v][i]);\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int from,to,cost;\n};\nconst int SIZE=1000;\n\nclass UnionFind{\n    vector<int> par,rank;\n    public:\n    UnionFind(int n):par(n),rank(n){\n        iota(par.begin(),par.end(),0);\n    }\n    int find(int x){\n        if(par[x]==x) return x;\n        else return par[x]=find(par[x]);\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    void unite(int x,int y){\n        x=find(x),y=find(y);\n        if(rank[x]<rank[y]) par[x]=y;\n        else{\n            if(rank[y]==rank[x]) rank[x]++;\n            par[y]=x;\n        }\n    }\n};\n\nusing Graph=vector<vector<Edge>>;\nint solve(int n,int m){\n    vector<int> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n\n    {\n        set<int> x;\n        for(int i=0;i<n;i++) x.insert(h[i]);\n        int idx=1;\n        for(auto &e:x){\n            for(int i=0;i<n;i++) if(h[i]==e) h[i]=idx;\n            idx++;\n        }\n    }\n\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--,b--;\n        g[a].push_back(Edge{a,b,c});\n        g[b].push_back(Edge{b,a,c});\n    }\n    // cerr<<\"Input finished\"<<endl;\n    vector<vector<int>> sinks(SIZE);\n    for(int i=0;i<n;i++) sinks[h[i]].push_back(i);\n    UnionFind u(n);\n    vector<int> land(n,false);\n    vector<int> isok(SIZE);\n    int cnt=-1;\n    for(int t=SIZE-1;t>=0;t--){\n        cnt+=sinks[t].size();\n        for(auto &v:sinks[t]){\n            // cerr<<t<<\" \"<<v<<endl;\n            land[v]=true;\n            for(auto &e:g[v]){\n                // cerr<<\"@\"<<e.from<<\" \"<<e.to<<endl;\n                if(land[e.from] && land[e.to] && !u.same(e.from,e.to)){\n                    // cerr<<\"Hoy\"<<endl;\n                    u.unite(e.from,e.to);\n                    // cerr<<\"Hi\"<<endl;\n                    cnt--;\n                }\n                // cerr<<\"Nui\"<<endl;\n            }\n        }\n        isok[t]=cnt<=0;\n    }\n    // cerr<<\"masaka\"<<endl;\n    int beft=SIZE;\n    for(int i=0;i<SIZE;i++){\n        if(!isok[i]){\n            beft=i;\n            break;\n        }\n    }\n    // cerr<<\"Beft finished \"<<beft<<endl;\n    cnt=0;\n    int res=0;\n    u=UnionFind(n);\n    fill(land.begin(),land.end(),false);\n    vector<Edge> edges;\n    for(int t=beft;t<SIZE;t++){\n        for(auto &v:sinks[t]){\n            land[v]=true;\n            for(auto &e:g[v]){\n                if(land[e.from] && land[e.to]){\n                    edges.push_back(e);\n                }\n            }\n        }\n    }\n    for(int t=beft-1;t>=0;t--){\n        for(auto &v:sinks[t]){\n            land[v]=true;\n            for(auto &e:g[v]){\n                if(land[e.from] && land[e.to]){\n                    edges.push_back(e);\n                }\n            }\n        }\n        sort(edges.begin(),edges.end(),[](Edge lhs,Edge rhs){return lhs.cost<rhs.cost;});\n        for(auto &e:edges){\n            if(!u.same(e.from,e.to)){\n                cnt++;\n                u.unite(e.from,e.to);\n                res+=e.cost;\n            }\n        }\n        edges.clear();\n    }\n    // assert(cnt==n-1);\n    return res;\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        cout<<solve(n,m)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct edge{\n  int u, v, c;\n  edge(int a, int b, int c) : u(a), v(b), c(c) {}\n  bool operator < (const edge& e) const {\n    return c < e.c;\n  }\n};\ntypedef vector<edge> node;\ntypedef vector<node> graph;\n\nbool used[1000];\nvoid dfs(int u, int b, graph& G, vector<int>& h){\n  used[u] = true;\n  REP(i, G[u].size()){\n    edge& e = G[u][i];\n    if(!used[e.v] && h[e.v] > b){\n      dfs(e.v, b, G, h);\n    }\n  }\n}\nstruct UF{\n  vector<int> data;\n  UF(int N) : data(N, -1) {}\n  bool uni(int x, int y){\n    x = rank(x); y = rank(y);\n    if(x == y) return false;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n  int rank(int x){\n    if(data[x] < 0) return x;\n    return data[x] = rank(data[x]);\n  }\n};\n\nint main(){\n  int N, M;\n  while(cin >> N >> M && N){\n    vector<int> h(N);\n    REP(i, N) cin >> h[i];\n    vector<int> day = h;\n    day.push_back(0);\n    sort(day.begin(), day.end());\n    day.erase(unique(day.begin(), day.end()), day.end());\n    vector<edge> es;\n    graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      es.push_back(edge(a, b, c));\n      G[a].push_back(edge(a, b, c));\n      G[b].push_back(edge(b, a, c));\n    }\n    sort(es.begin(), es.end());\n    int END = day.size();\n    for(int i = 0; i < day.size(); i++){\n      int C = 0;\n      memset(used, 0, sizeof used);\n      REP(u, N) if(!used[u] && h[u] > day[i]){\n        dfs(u, day[i], G, h);\n        C++;\n      }\n      if(C != 1){\n        END = i;\n        break;\n      }\n    }\n    int ans = 0;\n    UF uf(N);\n    for(int i = END - 1; i >= 0; i--){\n      REP(j, es.size()){\n        edge& e = es[j];\n        if(h[e.u] > day[i] && h[e.v] > day[i] && uf.uni(e.u, e.v)){\n          ans += e.c;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nstruct Edge {\n  int src, dst,cost;\n  Edge(int a, int b, int c) :src(a),dst(b),cost(c) {}\n  bool operator<(const Edge &rhs) const {\n    return cost < rhs.cost;\n  }\n};\n\nconst int H = 1000001;\nvector<int> vers[1000001];\nvector<Edge> g[201];\nint main() {\n  int n,m;\n  while(cin>>n>>m, n||m) {\n    REP(i,H) vers[i].clear();\n    REP(i,n) {\n      int h; cin >> h;\n      vers[h].push_back(i);\n      g[i].clear();\n    }\n    REP(i,m) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--;b--;\n      g[a].push_back(Edge(a,b,c));\n      g[b].push_back(Edge(b,a,c));\n    }\n    UnionFind uf(n);\n    vector<bool> ok(H);\n    set<int> st;\n    int cnt = 0;\n    int lastVer = -1;\n    for (int i=H-1; i>=0; --i) {\n      FOR(it, vers[i]) {\n        int a = *it;\n        st.insert(a);\n        FOR(e, g[a]) {\n          if (st.count(e->dst)) {\n            uf.unionSet(e->src, e->dst);\n          }\n        }\n        cnt++;\n        lastVer = a;\n      }\n      if (lastVer != -1) {\n        if (uf.size(lastVer) == cnt) {\n          ok[i] = 1;\n        }\n      }\n    }\n    int last = -1;\n    REP(i,H) {\n      if (!ok[i]) break;\n      last = i;\n    }\n    // cout << \"last = \" << last << endl;\n    if (last == -1) {\n      cout << 0 << endl;\n      continue;\n    }\n    st.clear();\n    vector<Edge> es;\n    for (int i=H-1; i>=last; --i) {\n      FOR(it, vers[i]) {\n        int a = *it;\n        st.insert(a);\n        FOR(e, g[a]) {\n          if (st.count(e->dst)) {\n            es.push_back(*e);\n          }\n        }\n      }      \n    }\n    UnionFind kr(n);\n    int ans = 0;\n    sort(ALL(es));    \n    FOR(it, es) {\n      if (kr.unionSet(it->src, it->dst)) {\n        ans += it->cost;\n      }\n    }\n    // cout << ans << endl;\n    for (int i=H-1; i>=0; --i) {\n      vector<Edge> es;\n      FOR(it, vers[i]) {\n        int a = *it;\n        st.insert(a);\n        FOR(e, g[a]) {\n          if (st.count(e->dst)) {\n            es.push_back(*e);\n          }\n        }\n      }\n      sort(ALL(es));    \n      FOR(it, es) {\n        if (kr.unionSet(it->src, it->dst)) {\n          ans += it->cost;\n        }\n      }      \n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nclass Edge{\npublic:\n    int to, cost, h;\n    Edge(int to, int cost, int h): to(to), cost(cost), h(h){};\n    \n    bool operator > (const Edge& right) const{\n        if(h == right.h)\n            return cost > right.cost;\n        else\n            return h < right.h;\n    }\n};\n\nint prim(vector<vector<Edge>>& G, int root, int rooth){\n    int V = G.size();\n    vector<bool> visited(V);\n    priority_queue<Edge, vector<Edge>, greater<Edge>> queue;\n    queue.push(Edge(root, 0, rooth));\n    \n    int res = 0;\n    int count = 0;\n    while(!queue.empty()){\n        auto edge = queue.top(); queue.pop();\n        if(visited[edge.to])\n            continue;\n        res += edge.cost;\n        count++;\n        visited[edge.to] = true;\n        for(int i=0; i<G[edge.to].size(); i++){\n            if(!visited[G[edge.to][i].to])\n                queue.push(G[edge.to][i]);\n        }\n    }\n    if(count == G.size())\n        return res;\n    else\n        return 0;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int N, M;\n    while(cin>>N>>M, N|M){\n        vector<int> hs(N);\n        for(auto &h: hs)\n            cin >> h;\n        \n        vector<vector<Edge>> G(N);\n        \n        for(int i=0; i<M; i++){\n            int a, b, c;\n            cin >> a >> b >> c; a--; b--;\n            G[a].push_back(Edge(b, c, hs[b]));\n            G[b].push_back(Edge(a, c, hs[a]));\n        }\n        \n        int m = 0, root = -1;\n        for(int i=0; i<N; i++){\n            if(m < hs[i]){\n                m = hs[i];\n                root = i;\n            }\n        }\n        cout << prim(G, root, m) << endl;\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nstruct edge{ int to,cost; };\nstruct edge_krus{\n\tint from,to,cost;\n\tbool operator<(const edge_krus &e) const{\n\t\treturn cost > e.cost;\n\t}\n};\n\nint rnk[200],par[200];\n\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\trnk[i] = 0;\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rnk[x] < rnk[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nconst int MAX_H = 1000000;\nvector<int> sink[MAX_H];\n\nsigned main(){\n\tint n,m;\n\twhile(scanf(\"%lld %lld\",&n,&m),n){\n\t\tint ans = 0;\n\t\tvector<edge> G[200];\n\t\tbool sank[200] = {};\n\t\tfor(int i = 0;i < MAX_H;i++) sink[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint h;\n\t\t\tscanf(\"%lld\",&h);\n\t\t\tsink[h - 1].push_back(i);\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%lld %lld %lld\",&a,&b,&c); a--;b--;\n\t\t\tG[a].push_back({b,c});\n\t\t\tG[b].push_back({a,c});\n\t\t}\n\t\tinit(n);\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(edge e : G[j]){\n\t\t\t\tif(!sank[j] && !sank[e.to]) unite(j,e.to);\n\t\t\t}\n\t\t}\n\t\tint mi = INF,ma = -1;\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(sank[j]) continue;\n\t\t\tmi = min(mi,find(j));\n\t\t\tma = max(ma,find(j));\n\t\t}\n\t\tif(mi != ma){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint last = -1;\n\t\tfor(int i = 0;i < MAX_H;i++){\n\t\t\tif(!sink[i].size()) continue;\n\t\t\tfor(int v : sink[i]) sank[v] = true;\n\t\t\tinit(n);\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tfor(edge e : G[j]){\n\t\t\t\t\tif(!sank[j] && !sank[e.to]) unite(j,e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mi = INF,ma = -1;\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(sank[j]) continue;\n\t\t\t\tmi = min(mi,find(j));\n\t\t\t\tma = max(ma,find(j));\n\t\t\t}\n\t\t\tif(mi != ma){\n\t\t\t\tfor(int v : sink[i]) sank[v] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = i;\n\t\t}\n\t\tinit(n);\n\t\tpriority_queue<edge_krus> es;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(edge e : G[i]){\n\t\t\t\tif(!sank[i] && !sank[e.to]) es.push({i,e.to,e.cost});\n\t\t\t}\n\t\t}\n\t\twhile(!es.empty()){\n\t\t\tedge_krus e = es.top();es.pop();\n\t\t\tif(!same(e.from,e.to)){\n\t\t\t\tunite(e.from,e.to);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\tfor(int i = last;i >= 0;i--){\n\t\t\tif(!sink[i].size()) continue;\n\t\t\tfor(int v : sink[i]) sank[v] = false;\n\t\t\tfor(int v : sink[i]){\n\t\t\t\tfor(edge e : G[v]){\n\t\t\t\t\tif(!sank[e.to]) es.push({v,e.to,e.cost});\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!es.empty()){\n\t\t\t\tedge_krus e = es.top();es.pop();\n\t\t\t\tif(!same(e.from,e.to)){\n\t\t\t\t\tunite(e.from,e.to);\n\t\t\t\t\tans += e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親\n\tvector<int> sz; // 数\n\t// 初期化\n\tUF(int n):par(n),sz(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\nint n,m;\nvector<pair<ll,ll>> h;\nvector<pair<ll,pair<ll,ll>>> v;\nbool sink[222];\n\nll check(ll num){\n\tUF uf(n);\n\tll ret = 0;\n\tREP(i,m){\n\t\tll A = v[i].SE.FI;\n\t\tll B = v[i].SE.SE;\n\t\tll C = v[i].FI;\n\t\tif(sink[A] | sink[B])continue;\n\t\tif(!uf.same(A,B)){\n\t\t\tuf.unite(A,B);\n\t\t\tret += C;\n\t\t}\n\t}\n\tll cou = 0;\n\tREP(i,n){\n\t\tcou = max(cou,uf.size(i));\n\t}\n\treturn (cou == num ? ret : -1);\n}\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\th.clear();\n\t\tv.clear();\n\t\tREP(i,222)sink[i] = false;\n\t\t\n\t\tREP(i,n){\n\t\t\tll tmp;\n\t\t\tcin >> tmp;\n\t\t\th.PB(MP(tmp,i));\n\t\t}\n\t\t\n\t\tREP(i,m){\n\t\t\tll a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv.PB(MP(c,MP(a,b)));\n\t\t}\n\t\t\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\t\n\t\tll prev = check(n);\n\t\tll sinknum;\n\t\tif(prev == -1){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\tbool flag = false;\n\t\t\tfor(sinknum = 0;sinknum < n-1;sinknum++){\n\t\t\t\twhile(sinknum < n-1 && h[sinknum].FI == h[sinknum+1].FI){\n\t\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\t\tsinknum++;\n\t\t\t\t}\n\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\tll now = check(n-sinknum-1);\n\t\t\t\tif(now == -1){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev = now;\n\t\t\t}\n\t\t\tsink[h[sinknum].SE] = false;\n\t\t\tsinknum--;\n\t\t\tDBG(cout << \"prev \" << prev << \" sinknum \" << sinknum << endl;)\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tll tmp = 0;\n\t\t\tfor(ll i = sinknum;i >= 0;i--){\n\t\t\t\tvector<ll> li;\n\t\t\t\twhile(i > 0 && h[i].FI == h[i-1].FI){\n\t\t\t\t\tli.PB(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tli.PB(i);\n\t\t\t\tDBG(cout << \"size \" << li.size() << endl;);\n\t\t\t\tREP(j,m){\n\t\t\t\t\tll A = v[j].SE.FI;\n\t\t\t\t\tll B = v[j].SE.SE;\n\t\t\t\t\tll C = v[j].FI;\n\t\t\t\t\tll seica = -1;\n\t\t\t\t\tREP(k,li.size())if(sink[h[li[k]].SE] && (A == h[li[k]].SE || B == h[li[k]].SE))seica = li[k];\n\t\t\t\t\tif(seica != -1 && (sink[A] ^ sink[B])){\n\t\t\t\t\t\ttmp += C;\n\t\t\t\t\t\tsink[h[seica].SE] = false;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"i \" << i << endl;);\n\t\t\t}\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tcout << prev + tmp << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,j) for(int i=0;i<(j);i++)\nusing namespace std;;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define X first\n#define Y second\n#define fs first\n#define sc second\n#define pb push_back\n#define em emplace_back\n\n#define rrep(X,Y) for(int (X)=(Y)-1; X >= 0; --(X))\ntypedef long long ll;\n\nstruct UF{\n  vector<int> data;\n  UF (int size) : data(size, -1){}\n  bool unite(int x,int y){\n    //cout<<\"unite\"<<x<<\",\"<<y<<endl;\n    x=root(x); y=root(y);\n    if(x!=y){\n      if(data[y]<data[x])swap(x,y);\n      data[x]+=data[y]; data[y]=x;\n    }\n    return x!=y;\n  }\n  bool same(int x,int y){\n    return root(x)==root(y);\n  }\n  int root(int x){return data[x]<0?x:data[x]=root(data[x]);}\n  int size(int x){return -data[root(x)];}\n};\n\ntypedef vector<vector<pii>> Graph;\n\ntemplate<class T> ostream & operator<< (ostream & os,const vector<T> &t){\n  os<<\"{\";for(auto a:t)os<<a<<\",\";os<<\"}\"<<endl;\n  return os;\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m&&n){\n    map<int,vi> mp;\n    vector<int> hs(n);\n    rep(i,n){\n      cin >> hs[i];\n      mp[-hs[i]].pb(i);\n    }\n    Graph g(n);\n    rep(i,m){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--;\n      b--;\n      if(hs[a]>=hs[b])\n\tg[b].emplace_back(a,c);\n      if(hs[b]>=hs[a])\n\tg[a].emplace_back(b,c);\n    }\n    UF uf(n);\n    vector<int> tree(mp.size(),1);\n    int i=0;\n    set<int> ex;\n    UF tr(n);\n    for(const auto &p:mp){\n      for(int d:p.Y){\n\tfor(pii v:g[d])\n\t  tr.unite(v.X,d);\n\tex.insert(d);\n      }\n      //if(i==1)cout<<tr.data;\n      for(int v:ex)\n\tif(!tr.same(*ex.begin(),v))tree[i]=0;\n      ++i;\n    }\n    //cout<<tree;\n    rrep(i,mp.size())if(i)\n      tree[i-1]&=tree[i];\n    priority_queue<pair<int,pii>> que;\n    ll re=0,temp;\n    i=0;\n    //cout<<tree;\n    for(const auto &p:mp){\n      for(int d:p.Y){\n\tfor(pii v:g[d])\n\t  que.emplace(-v.Y,pii(d,v.X));\n\tex.insert(d);\n      }\n      if(!tree[i++])continue;\n      //ダルダルダルメシアン\n      //cout<<p.Y<<endl;\n      while(!que.empty()){\n\tauto p=que.top(); que.pop();\n\tif(!uf.same(p.Y.X,p.Y.Y)){\n\t  re-=p.X;\n\t  uf.unite(p.Y.X,p.Y.Y);\n\t}\n      }\n    }\n    cout << re << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = ((b) - 1); i >= (int)(a); --i)\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define sz(x) ((int)x.size())\n\nconstexpr int INF = 1001001001001001001LL;\n\nusing pii = pair<int, int>;\nusing Mat = vector<vector<int>>;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) : data(n, -1) {}\n    void unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if (a == b) return;\n        if (size(a) > size(b)) swap(a, b);\n        data[b] += data[a];\n        data[a] = b;\n    }\n    int root(int x) {\n        return (data[x] < 0 ? x : (data[x] = root(data[x])));\n    }\n    int size(int x) { \n        return -data[root(x)];\n    }\n    bool same(int a, int b) {\n        return root(a) == root(b);\n    }\n};\n\n// [from, to)\nbool check_connected(Mat &adj, int from, int to) {\n    int N = adj.size();\n    UnionFind uf(N);\n    rep(i, 0, N) {\n        rep(j, 0, N) {\n            if (i == j) continue;\n            if (adj[i][j] > 0) {\n                uf.unite(i, j);\n            }\n        }\n    }\n    set<int> s;\n    rep(i, from, to) {\n        s.insert(uf.root(i));\n    }\n    return sz(s) == 1;\n}\n\nint &get_cost(Mat &adj, int i, int j) {\n    if (i > j) swap(i, j);\n    return adj[i][j];\n}\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) return false;\n\n    vector<pii> H(N);\n    rep(i, 0, N) {\n        cin >> H[i].first;\n        H[i].second = i;\n    }\n    sort(all(H));\n    vector<int> ord(N), T(N);\n    rep(i, 0, N) {\n        ord[H[i].second] = i;\n        T[i] = H[i].first;\n    }\n\n    Mat ADJ(N, vector<int>(N, -1));\n    rep(i, 0, M) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--, b--;\n        a = ord[a];\n        b = ord[b];\n        get_cost(ADJ, a, b) = c;\n    }\n\n    int X = N - 1;\n    {\n        auto adj = ADJ;\n        if (!check_connected(adj, 0, N)) {\n            cout << \"0\" << endl;\n            return true;\n        }\n        rep(i, 0, N) {\n            rep(j, 0, N) {\n                if (get_cost(adj, i, j) > 0) {\n                    get_cost(adj, i, j) = -1;\n                }\n            }\n            if (i + 1 < N && T[i] == T[i + 1]) continue;\n\n            if (!check_connected(adj, i + 1, N)) {\n                X = i;\n                break;\n            }\n        }\n        while (X > 0 && T[X - 1] == T[X]) X--;\n    }\n\n    UnionFind uf(N);\n    int ans = 0;\n    // X~N番の頂点からなる部分グラフのMSTのコストを加算\n    {\n        vector<tuple<int, int, int>> edge;\n        edge.reserve(N * N);\n        rep(i, X, N) {\n            rep(j, X, N) {\n                if (get_cost(ADJ, i, j) > 0) {\n                    edge.push_back(make_tuple(get_cost(ADJ, i, j), i, j));\n                }\n            }\n        }\n        sort(all(edge));\n        \n        rep(i, 0, sz(edge)) {\n            int c, a, b;\n            tie(c, a, b) = edge[i];\n            if (uf.same(a, b)) {\n                continue;\n            }\n            uf.unite(a, b);\n            ans += c;\n        }\n    }\n\n    // 0 ~ X-1番の頂点について、辺を張る(コストを加算)\n    {\n        vector<tuple<int, int, int>> edge;\n        rrep(i, 0, X) {\n            rep(j, i + 1, N) {\n                if (get_cost(ADJ, i, j) > 0) {\n                    edge.push_back(make_tuple(get_cost(ADJ, i, j), i, j));\n                }\n            }\n            if (i > 0 && T[i - 1] == T[i]) {\n                continue;\n            }\n            sort(all(edge));\n            rep(i, 0, sz(edge)) {\n                int c, a, b;\n                tie(c, a, b) = edge[i];\n                if (uf.same(a, b)) {\n                    continue;\n                }\n                uf.unite(a, b);\n                ans += c;\n            }\n            edge.clear();\n        }\n    }\n\n    cout << ans << endl;\n    return true;\n}\n\nsigned main() {\n    while (1) {\n        if (!solve()) break;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint n, m;\nint v[200];\nvector<int> h;\nint par[200];\nint d[200][200];\nvector<PIP> bridge;\n\nint find(int a) {\n    if (par[a] == a) return a;\n    return par[a] = find(par[a]);\n}\n\nvoid unite(int a, int b) {\n    int p = find(a), q = find(b);\n    if(p == q) return;\n    par[p] = q;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    while(cin >> n >> m, n | m) {\n        memset(d, 0, sizeof(d));\n        h.clear(), bridge.clear();\n\n        int k, maxi = 0;\n        rep(i, n) {\n            cin >> v[i], h.pb(v[i]);\n            if (maxi < v[i]) maxi = v[i], k = i;\n        }\n        sort(all(h));\n        uni(h);\n\n        rep(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c; a--, b--;\n            d[a][b] = d[b][a] = c;\n            bridge.pb(PIP(c, P(a, b)));\n        }\n        sort(all(bridge));\n\n        iota(par, par + n, 0);\n\n        int tmp = h.size() - 1;\n        rep(i, h.size() - 1) {\n            iota(par, par + n, 0);\n            rep(j, m) {\n                int p = bridge[j].se.fi, q = bridge[j].se.se;\n                if (v[p] > h[i] && v[q] > h[i] && find(p) != find(q)) {\n                    unite(p, q);\n                }\n            }\n\n            bool ok = true;\n            rep(j, n) if (v[j] > h[i] && find(j) != find(k)) ok = false;\n\n            if (!ok) {\n                tmp = i;\n                break;\n            }\n        }\n\n        int cost = 0;\n        iota(par, par + n, 0);\n        repr(i, tmp) {\n            rep(j, m) {\n                int p = bridge[j].se.fi, q = bridge[j].se.se;\n                if (v[p] > h[i] && v[q] > h[i] && find(p) != find(q)) {\n                    cost += bridge[j].fi;\n                    unite(p, q);\n                }\n            }\n        }\n\n        rep(j, m) {\n            int p = bridge[j].se.fi, q = bridge[j].se.se;\n            if (find(p) != find(q)) {\n                cost += bridge[j].fi;\n                unite(p, q);\n            }\n        }\n\n        rep(i, n) if (find(0) != find(i)) cost = 0;\n\n        cout << cost << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<ll> par; // 親\n\tvector<ll> sz; // 数\n\t// 初期化\n\tUF(ll n):par(n),sz(n) {\n\t\tfor(ll i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tll find(ll x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(ll x, ll y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(ll x, ll y) { return find(x) == find(y); }\n\tll size(ll n){return sz[find(n)];}\n};\n\nll n,m;\n\nll check(ll num,vector<pair<ll,ll>> h,vector<pair<ll,pair<ll,ll>>> v,bool sink[]){\n\tUF uf(n+10);\n\tll ret = 0;\n\tREP(i,m){\n\t\tll A = v[i].SE.FI;\n\t\tll B = v[i].SE.SE;\n\t\tll C = v[i].FI;\n\t\tDBG(if(A < 0 || A >= n || B < 0 || B >= n)cerr << \"HOGE \" << A << ' ' << B << endl;)\n\t\tif(sink[A] | sink[B])continue;\n\t\tif(!uf.same(A,B)){\n\t\t\tuf.unite(A,B);\n\t\t\tret += C;\n\t\t}\n\t}\n\tDBG(cerr << \"END UNITE\" << endl;)\n\tll cou = 0;\n\tREP(i,n){\n\t\tcou = max(cou,uf.size(i));\n\t}\n\tDBG(cerr << \"END CHECK\" << endl;)\n\treturn (cou == num ? ret : -1);\n}\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\tDBG(cerr << \"START\" << endl;)\n\t\tvector<pair<ll,ll>> h(222);\n\t\tvector<pair<ll,pair<ll,ll>>> v(222*222);\n\t\tbool sink[333];\n\t\t\n\t\tREP(i,n){\n\t\t\tll tmp;\n\t\t\tcin >> tmp;\n\t\t\th[i] = MP(tmp,i);\n\t\t}\n\t\t\n\t\tREP(i,m){\n\t\t\tll a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv[i] = MP(c,MP(a,b));\n\t\t}\n\t\tDBG(REP(i,m){cerr << v[i].SE.FI << ' ' << v[i].SE.SE << endl;if(v[i].SE.SE < 0)exit(1);})\n\t\tDBG(cerr << \"END INPIT\" << endl;);\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\t\n\t\tll prev = check(n,h,v,sink);\n\t\tll sinknum;\n\t\tif(prev == -1){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\tbool flag = false;\n\t\t\tfor(sinknum = 0;sinknum < n-1;sinknum++){\n\t\t\t\twhile(sinknum < n-1 && h[sinknum].FI == h[sinknum+1].FI){\n\t\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\t\tsinknum++;\n\t\t\t\t}\n\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\tll now = check(n-sinknum-1,h,v,sink);\n\t\t\t\tif(now == -1){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev = now;\n\t\t\t}\n\t\t\tDBG(cout << \"end sink\" << endl;);\n\t\t\tsink[h[sinknum].SE] = false;\n\t\t\tsinknum--;\n\t\t\tDBG(cout << \"prev \" << prev << \" sinknum \" << sinknum << endl;)\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tll tmp = 0;\n\t\t\tfor(ll i = sinknum;i >= 0;i--){\n\t\t\t\tvector<ll> li;\n\t\t\t\twhile(i > 0 && h[i].FI == h[i-1].FI){\n\t\t\t\t\tli.PB(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tli.PB(i);\n\t\t\t\tDBG(cout << \"size \" << li.size() << endl;);\n\t\t\t\tREP(j,m){\n\t\t\t\t\tll A = v[j].SE.FI;\n\t\t\t\t\tll B = v[j].SE.SE;\n\t\t\t\t\tll C = v[j].FI;\n\t\t\t\t\tll seica = -1;\n\t\t\t\t\tREP(k,li.size())if(sink[h[li[k]].SE] && (A == h[li[k]].SE || B == h[li[k]].SE))seica = li[k];\n\t\t\t\t\tif(seica != -1 && (sink[A] ^ sink[B])){\n\t\t\t\t\t\ttmp += C;\n\t\t\t\t\t\tsink[h[seica].SE] = false;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"i \" << i << endl;);\n\t\t\t}\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tcout << prev + tmp << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1){ }\n\t// ?????????????????????\n\tbool unite(int x, int y){\n\t\tx=root(x); y=root(y);\n\t\tif( x != y ) data[y] = x;\n\t\treturn x!=y;\n\t}\n\t// ??????????????????????????????\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\t// ??????????????\\???????????????\n\tint root(int x){\n\t\t// ???????????????????????????????????????????????????\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n};\n\nint N, M, a[50000], b[50000], c[50000];\nvector<P> vh, vc;\n\nint solve2(UnionFind &uf, const vector<int> &l, int z){\n\tint sum = 0;\n\tUnionFind ufl = uf;\n\tfor(auto t: l){\n\t\tufl.unite( z, t );\n\t}\n\tfor(auto c: vc){\n\t\tint i = c.second;\n\t\tif( uf.find(a[i], b[i]) ) continue;\n\t\tif( !ufl.find(z, a[i]) ) continue;\n\t\tif( !ufl.find(z, b[i]) ) continue;\n\t\tuf.unite( a[i], b[i] );\n\t\tsum += c.first;\n\t}\n\treturn sum;\n}\n\nint solve(int limit){\n\tint now = limit;\n\tint z = vh[0].second;\n\tint ans = 0;\n\tUnionFind uf(205);\n\tvector<int> l;\n\tvh.emplace_back(0,0);\n\tfor(auto v: vh){\n\t\tif( v.first >= limit && now != v.first ){\n\t\t\tans += solve2(uf, l, z);\n\t\t\tl.clear();\n\t\t}\n\t\tl.push_back( v.second );\n\t\tnow = max( v.first, limit );\n\t}\n\treturn ans;\n}\n\nint calc(){\n\tint limit = 0;\n\twhile(1){\n\t\tint nx = vh.size()-1;\n\t\tbool sink[205]={}; //sink[0] = true;\n\t\twhile(limit <= vh[nx].first){\n\t\t\tsink[ vh[nx].second ] = true;\n\t\t\tnx--;\n\t\t\tif( nx < 0 ) return limit;\n\t\t}\n\n\t\tUnionFind uf(205);\n\t\tint z = vh[0].second;\n\t\tfor(auto c: vc){\n\t\t\tint i = c.second;\n\t\t\tif( sink[ a[i] ] || sink[ b[i] ] ) continue;\n\t\t\tuf.unite( a[i], b[i] );\n\t\t}\n\t\trep(i,N) if( !sink[i] && !uf.find(z,i) ) return limit;\n\t\tlimit = vh[nx].first;\n\t}\n\treturn limit;\n}\n\nint main(){\n\twhile(cin >> N >> M, N|M){\n\t\tvh.clear(); vc.clear();\n\t\trep(i,N){\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\tvh.emplace_back( -h, i );\n\t\t}\n\t\tsort( vh.begin(), vh.end() );\n\t\trep(i,M){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\ta[i]--; b[i]--;\n\t\t\tvc.emplace_back( c[i], i );\n\t\t}\n\t\tsort( vc.begin(), vc.end() );\n\t\tcout << solve( calc() ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,M;\nvector<P> H;\n\nstruct edge{\n  int to,from,c;\n  bool operator<(const edge& e) const{\n    return c < e.c;\n  }\n};\n\nvector<edge> E;\n\nstruct uni{\n  int d[222];\n  void init(){ memset(d,-1,sizeof(d)); }\n  int find(int a){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void marge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a]+=d[b]; d[b] = a;\n  }\n  bool same(int a,int b){ return find(a)==find(b); }\n  int size(int a){ return -d[find(a)]; }\n};\n\nuni U;\n\nbool used[333];\nint main(){\n  while( cin >> N >> M && (N||M) ){\n    U.init();\n    H.clear();\n    E.clear();\n    for(int i=0;i<N;i++) {\n      H.push_back(P(i,i));\n      cin >> H[i].first;\n    }\n    sort(H.rbegin(),H.rend());\n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      --a; --b;\n      E.push_back( (edge){a,b,c} );\n    }\n    sort(E.begin(),E.end());\n\n\n    for(int i=0;i<N;i++)used[i]=true;\n    int start = N;\n    for(int i=N-1;i>0;i--){\n      int id=H[i].second;\n      if( i > 0 && H[i].first == H[i-1].first ) {\n\tused[id] = false;\n\tcontinue;\n      }\n      uni up;\n      up.init();\n      for(int j=0;j<M;j++){\n\tif( used[E[j].to] && used[E[j].from] ) {\n\t  if( !up.same(E[j].to,E[j].from) ) {\n\t    up.marge(E[j].to,E[j].from);\n\t  }\n\t}\n      }  \n      if( up.size(id) == i+1 ) start = i;\n      else break;\n      used[id] = false;\n    }\n\n    long long res = 0;\n    for(int i=start;i<N;i++){\n      int id=H[i].second;\n      if( i < N-1 && H[i].first == H[i+1].first ) {\n\tused[id] = true;\n\tcontinue;\n      }\n\n      //      cout << id << endl;\n      used[id] = true;\n      for(int j=0;j<M;j++){\n\tif( used[E[j].to] && used[E[j].from] ) {\n\t  if( !U.same(E[j].to,E[j].from) ) {\n\t    //   cout << E[j].to << \" \"<< E[j].from << \" \"<< E[j].c << endl;\n\t    res+=(long long)E[j].c;\n\t    U.marge(E[j].to,E[j].from);\n\t  }\n\t}\n      }    \n    }\n    \n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass UnionFind\n{\nprivate:\n  vector<int> parent, rank;\n  \npublic:\n  UnionFind(int n)\n  {\n    for (int i = 0; i < n; ++i) {\n      parent.push_back(i);\n      rank.push_back(0);\n    }\n  }\n  \n  int find(int x)\n  {\n    if (parent[x] == x)\n      return x;\n    else\n      return parent[x] = find(parent[x]);\n  }\n  \n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return;\n    \n    if (rank[x] < rank[y]) {\n      parent[x] = y;\n    } else {\n      parent[y] = x;\n      if (rank[x] == rank[y])\n        ++rank[x];\n    }\n  }\n  \n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n};\n\nclass Edge\n{\npublic:\n  int a, b, c, idx;\n  Edge() {}\n  Edge(int a_, int b_, int c_, int idx_)\n    :a(a_), b(b_), c(c_), idx(idx_) {}\n  bool operator < (const Edge& edge) const\n  {\n    return this->c > edge.c;\n  }\n};\n\nvoid dfs(int v, deque<bool>& visited, const vector<Edge>& edge, const deque<bool>& sinking)\n{\n  if (visited[v])\n    return;\n\n  visited[v] = true;\n  for (unsigned int i = 0; i < edge.size(); ++i) {\n    const Edge& e = edge[i];\n    if (e.a == v && !sinking[e.b])\n      dfs(e.b, visited, edge, sinking);\n    else if (e.b == v && !sinking[e.a])\n      dfs(e.a, visited, edge, sinking);\n  }\n}\n\nint main()\n{\n  int N, M;\n  while (cin >> N >> M) {\n    if ((N|M) == 0)\n      break;\n\n    vector<int> h(N), next;\n    next.push_back(0);\n    next.push_back(1000001);\n    for (int i = 0; i < N; ++i) {\n      cin >> h[i];\n      next.push_back(h[i]);\n    }\n    sort(next.begin(), next.end());\n    next.erase(unique(next.begin(), next.end()), next.end());\n\n    vector<Edge> edge;\n    for (int i = 0; i < M; ++i) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      edge.push_back(Edge(a-1, b-1, c, i));\n    }\n\n    unsigned int i = 0;\n    deque<bool> sinking(N, false);\n    for (; i < next.size(); ++i) {\n      int v = -1;\n      for (int j = 0; j < N; ++j) {\n        if (h[j] == next[i])\n          sinking[j] = true;\n        if (!sinking[j])\n          v = j;\n      }\n      \n      if (v == -1)\n        break;\n\n      deque<bool> visited(N, false);\n      dfs(v, visited, edge, sinking);\n\n      if (count(visited.begin(), visited.end(), true) +\n          count(sinking.begin(), sinking.end(), true) != N)\n        break;\n    }\n\n    int ans = 0;\n    UnionFind uf(N);\n    deque<bool> used(M, false);\n    for (; i > 0; --i) {\n\n      for (int j = 0; j < N; ++j) {\n        if (h[j] == next[i])\n          sinking[j] = false;\n      }\n\n      priority_queue<Edge> que;\n      for (int j = 0; j < M; ++j) {\n        if (used[j])\n          continue;\n        const Edge& e = edge[j];\n        if (sinking[e.a] || sinking[e.b])\n          continue;\n        que.push(e);\n      }\n\n      while (!que.empty()) {\n        const Edge& e = que.top();\n        if (!uf.same(e.a, e.b)) {\n          uf.unite(e.a, e.b);\n          used[e.idx] = true;\n          ans += e.c;\n        }\n        que.pop();\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x,int y) {\n        x = root(x);\n        y = root(y);\n        if(x != y) {\n            if(data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x,int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    void clear() { for (int i=0; i<data.size(); ++i) data[i] = -1; }\n};\n\n\nint N,M;\nint h[201];\nint ord[201];\n\nint adj[201][201];\n\nstruct Comp {\n    bool operator()(const int i, const int j) { return h[i] < h[j]; }\n};\n\nstruct Edge {\n    int src, dst, cost;\n};\nbool operator<(const Edge &e, const Edge &f) {\n    return (e.cost != f.cost) ? e.cost < f.cost : e.src < f.src;\n}\n\nint main() {\n    while(cin>>N>>M, N|M) {\n        vector<int> ord(N);\n        for (int i=0; i<N; ++i) {\n            cin>>h[i];\n            ord[i] = h[i];\n        }\n        sort(ord.begin(), ord.end());\n        ord.erase(unique(ord.begin(), ord.end()), ord.end());\n\n        vector<Edge> e;\n        memset(adj, -1, sizeof(adj));\n        for (int i=0; i<M; ++i) {\n            int a,b,c;\n            cin>>a>>b>>c; a--, b--;\n            adj[a][b] = adj[b][a] = c;\n            e.push_back((Edge){a,b,c});\n        }\n        sort(e.begin(), e.end());\n\n        int cnt = 0;\n        bool all_connect[201] = {};\n        UnionFind con(N);\n        for (int i=ord.size()-1; i>=0; --i) {\n            cnt = 0;\n            for (int p=0; p<N; ++p) {\n                if (ord[i] <= h[p]) cnt++;\n                for(int q=0; q<N; ++q)\n                    if (h[p] >= ord[i] && h[q] >= ord[i] && adj[p][q] >= 0)\n                        con.unionSet(p,q);\n            }\n            for (int p=0; p<N; ++p) {\n                if (ord[i] <= h[p] && con.size(p) == cnt) {\n                    all_connect[i] = true;\n                    break;\n                }\n            }\n        }\n        if (!all_connect[0]) {\n            cout<<0<<endl;\n            continue;\n        }\n\n        con.clear();\n        int last = 0, ans = 0;\n        for (; last < ord.size() && all_connect[last]; ++last);\n        last--;\n        for (; last >= 0; --last) {\n            for (int i=0; i<M; ++i) {\n                int v = e[i].src, w = e[i].dst, c = e[i].cost;\n                if (h[v] >= ord[last] && h[w] >= ord[last]) {\n                    if (con.findSet(v, w)) continue;\n                    ans += c; con.unionSet(v, w);\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef pair< int, int > pii;\n\nclass UnionFind {\nprivate:\n\tvector< int > data;\n\tint g_cnt;\n\t\npublic:\n\tUnionFind(int n) : data(n, -1), g_cnt(n) {}\n\t\n\tbool unionSet(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\t\n\t\tif (x == y) return 0;\n\t\t\n\t\tif (data[y] < data[x]) swap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\t--g_cnt;\n\t\t\n\t\treturn 1;\n\t}\n\t\n\tbool sameSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\t\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\t\n\tint getGroupNum() {\n\t\treturn g_cnt;\n\t}\n};\n\nstruct Edge {\n\tint u, v, c;\n\tEdge(int _u, int _v, int _c) : u(_u), v(_v), c(_c) {}\n\tbool operator < (const Edge& e) const {\n\t\treturn c < e.c;\n\t}\n};\n\nint N, M;\nvector< pii > vh;\nbool vis[222];\nvector< Edge > edges;\n\nvoid solve() {\n\tsort(vh.begin(), vh.end(), greater< pii >());\n\tsort(edges.begin(), edges.end());\n\t\n\tint ans = 0, visc = 0;\n\tUnionFind uf(N);\n\t\n\tfor_(i,0,N) {\n\t\tvis[vh[i].second] = 1;\n\t\t++visc;\n\t\t\n\t\twhile (i < N-1 && vh[i].first == vh[i+1].first) {\n\t\t\t++i;\n\t\t\tvis[vh[i].second] = 1;\n\t\t\t++visc;\n\t\t}\n\t\t\n\t\tfor_(j,0,M) {\n\t\t\tEdge e = edges[j];\n\t\t\t\n\t\t\tif (vis[e.u] && vis[e.v] && !uf.sameSet(e.u, e.v)) {\n\t\t\t\tuf.unionSet(e.u, e.v);\n\t\t\t\tans += e.c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint g_cnt = uf.getGroupNum();\n\t\t\n\t\tif (g_cnt != N - visc + 1) {\n\t\t\tuf = UnionFind(N);\n\t\t\tans = 0;\n\t\t}\n\t\t\n\t\tif (g_cnt == 1) break;\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> M, N) {\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvh.clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tint h; scanf(\"%d\", &h);\n\t\t\tvh.push_back(pii(h, i));\n\t\t}\n\t\t\n\t\tedges.clear();\n\t\tfor_(i,0,M) {\n\t\t\tint a, b, c; scanf(\"%d %d %d\", &a, &b, &c);\n\t\t\t--a; --b;\n\t\t\tedges.push_back(Edge(a, b, c));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nclass UnionFind{\n\nprivate:\n    vector<int> data;\n    int num;\n  public:\n      UnionFind(){};\n      UnionFind(int size){\n          data = vector<int>(size, -1);\n          num = size;\n      }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    bool unite(int x, int y){\n        if(same(x,y)) return(false);\n        x = find(x);\n        y = find(y);\n        if(data[x] > data[y]) swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n        num--;\n        return(true);\n    }\n\n    int find(int x){\n        if(data[x] < 0) return(x);\n        return(data[x] = find(data[x]));\n    }\n\n    int size(int x){\n        return(-data[find(x)]);\n    }\n\n    int count(){\n        return num;\n    }\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& e) const {\n        return cost < e.cost;\n    }\n};\n\nsigned main(void) {\n    int n,m;\n    while(cin >> n >> m, n){\n        vp h(n);\n        rep(i,n){\n            cin >> h[i].first;\n            h[i].second = i;\n        }\n        vector<vector<edge> > v(n);\n        rep(i,m){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--,b--;\n            v[a].push_back((edge){a,b,c});\n            v[b].push_back((edge){a,b,c});\n        }\n        sort(all(h));\n        reverse(all(h));\n        UnionFind uf(n);\n        vi used(n,0);\n        int tim = INF;\n        rep(i,n){\n            vector<edge> ve;\n            int nxt;\n            loop(j,i,n)if(h[i].first == h[j].first){\n                nxt = j;\n                int ind = h[j].second;\n                used[ind]++;\n                rep(k,v[ind].size())ve.push_back(v[ind][k]);\n            }\n            sort(all(ve));\n            rep(j,ve.size()){\n                int u = ve[j].from;\n                int v = ve[j].to;\n                int cost = ve[j].cost;\n                if(used[u] && used[v] && !uf.same(u,v)){\n                    uf.unite(u,v);\n                }\n            }\n            rep(j,n)if(used[j])rep(k,j)if(used[k]){\n                if(!uf.same(j,k)){\n                    tim = min(tim, h[i].first);\n                }\n            }\n            i = nxt;\n        }\n        if(h[n-1].first == tim){\n            cout << 0 << endl;\n            continue;\n        }\n        uf = UnionFind (n);\n        used = vi(n,0);\n        int ans = 0;\n        vector<edge> ve;\n        rep(i,n){\n            int nxt;\n            loop(j,i,n)if(h[i].first == h[j].first){\n                nxt = j;\n                int ind = h[j].second;\n                used[ind]++;\n                rep(k,v[ind].size())ve.push_back(v[ind][k]);\n            }\n            if(h[nxt].first < tim){\n                sort(all(ve));\n                rep(j,ve.size()){\n                    int u = ve[j].from;\n                    int v = ve[j].to;\n                    int cost = ve[j].cost;\n                    if(used[u] && used[v] && !uf.same(u,v)){\n                        uf.unite(u,v);\n                        ans += cost;\n                    }\n                }\n                ve.resize(0);\n            }\n            i = nxt;\n        }\n        //cout << tim << endl;\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct bridge {\n\tint from;\n\tint to;\n\tint cost;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const bridge&l, const bridge &r) {\n\t\treturn l.cost> r.cost;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<pair<int,int>>hs;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint h; cin >> h;\n\t\t\ths.emplace_back(h, i);\n\t\t}\n\t\tvector<vector<bridge>>bs(N);\n\t\tsort(hs.begin(), hs.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tbs[a].push_back(bridge{ a,b,c });\n\t\t\tbs[b].push_back(bridge{ b,a,c });\n\t\t}\n\t\tvector<vector<int>>sinks;\n\t\t{\n\t\t\tint now = hs[0].first;\n\t\t\tvector<int>vs(1, hs[0].second);\n\t\t\tfor (int i = 1; i < hs.size(); ++i) {\n\t\t\t\tif (hs[i].first == now) {\n\t\t\t\t\tvs.push_back(hs[i].second);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsinks.push_back(vs);\n\t\t\t\t\tvs.clear();\n\t\t\t\t\tvs.push_back(hs[i].second);\n\t\t\t\t\tnow = hs[i].first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsinks.push_back(vs);\n\t\t\t\n\t\t}\n\t\treverse(sinks.begin(), sinks.end());\n\t\tfor (int from = 0; from <= sinks.size(); ++from) {\n\t\t\tif (from == sinks.size()) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tint costsum = 0;\n\t\t\tvector<int>status(N);\n\t\t\t{\n\t\t\t\tpriority_queue <bridge, vector<bridge>,Compare>que;\n\t\t\t\tvector<int>waits;\n\n\t\t\t\tfor (int i = 0; i <= from; ++i) {\n\t\t\t\t\tfor (auto island : sinks[i]) {\n\t\t\t\t\t\twaits.push_back(island);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < waits.size(); ++i) {\n\t\t\t\t\tfor (auto b : bs[waits[i]]) {\n\t\t\t\t\t\tif (find(waits.begin(), waits.end(), b.to) != waits.end()) {\n\t\t\t\t\t\t\tque.push(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (que.empty())continue;\n\t\t\t\t{\n\t\t\t\t\tbridge atop(que.top());\n\t\t\t\t\tque.pop();\n\t\t\t\t\tstatus[atop.from] = 1;\n\t\t\t\t\tstatus[atop.to] = 1;\n\t\t\t\t\twaits.erase(find(waits.begin(), waits.end(), atop.from));\n\t\t\t\t\twaits.erase(find(waits.begin(), waits.end(), atop.to));\n\t\t\t\t\tcostsum += atop.cost;\n\t\t\t\t}\n\n\t\t\t\twhile (!waits.empty() && !que.empty()) {\n\t\t\t\t\tbridge atop(que.top());\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (status[atop.from] == 0 && status[atop.to] ==1) {\n\t\t\t\t\t\tstatus[atop.from] = 1;\n\t\t\t\t\t\twaits.erase(find(waits.begin(), waits.end(), atop.from));\n\t\t\t\t\t\tfor (auto b : bs[atop.from]) {\n\t\t\t\t\t\t\tif (find(waits.begin(), waits.end(), b.to) != waits.end()) {\n\t\t\t\t\t\t\t\tque.push(bridge{ b.to,b.from,b.cost });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcostsum += atop.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!waits.empty())continue;\n\t\t\t}\n\t\t\tfor (int time = from+1; time < sinks.size(); ++time) {\n\t\t\t\tpriority_queue <bridge, vector<bridge>,Compare>que;\n\t\t\t\tvector<int>waits;\n\n\t\t\t\t\n\t\t\t\tfor (auto island : sinks[time]) {\n\t\t\t\t\twaits.push_back(island);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < waits.size(); ++i) {\n\t\t\t\t\tfor (auto b : bs[waits[i]]) {\n\t\t\t\t\t\tif (status[b.to]) {\n\t\t\t\t\t\t\tque.push(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile (!waits.empty() && !que.empty()) {\n\t\t\t\t\tbridge atop(que.top());\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (status[atop.from] == 0 && status[atop.to] == 1) {\n\t\t\t\t\t\tstatus[atop.from] = 1;\n\t\t\t\t\t\twaits.erase(find(waits.begin(), waits.end(), atop.from));\n\t\t\t\t\t\tfor (auto b : bs[atop.from]) {\n\t\t\t\t\t\t\tif (find(waits.begin(), waits.end(), b.to) != waits.end()) {\n\t\t\t\t\t\t\t\tque.push(bridge{ b.to,b.from,b.cost });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcostsum += atop.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!waits.empty()) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok)continue;\n\t\t\telse {\n\t\t\t\tcout << costsum << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\nprivate:\n\tstd::vector<int> value;\npublic:\n\tUnionFind(int size): value(size, -1){}\n\tint find(int x){\n\t\treturn value[x] < 0 ? x : value[x] = find(value[x]);\n\t}\n\tint size(int x){\n\t\treturn -value[find(x)];\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\tbool unite(int x, int y){\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\tif (value[x] > value[y]) std::swap(x, y);\n\t\tvalue[x] += value[y];\n\t\tvalue[y] = x;\n\t\treturn true;\n\t}\n};\n\nstruct Edge {\n\tint s, t, cost;\n\tEdge(){}\n\tEdge(int s, int t, int cost): s(s), t(t), cost(cost){}\n};\n\nint n, m;\nint h[201];\nvector<Edge> es;\n\nlong long calc()\n{\n\tvector<pair<int, int>> v;\n\tfor (int i = 0; i < n; i++){\n\t\tv.push_back(make_pair(-h[i], i));\n\t}\n\tsort(v.begin(), v.end());\n\tsort(es.begin(), es.end(), [](const Edge &a, const Edge &b){\n\t\treturn a.cost < b.cost;\n\t});\n\t\n\tlong long sum = 0;\n\tUnionFind uf(n);\n\tbool f[200] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tf[v[i].second] = true;\n\t\tif (h[i] == h[i + 1]) continue;\n\t\tfor (auto &e : es){\n\t\t\tif (f[e.s] && f[e.t] && uf.unite(e.s, e.t)){\n\t\t\t\tsum += e.cost;\n\t\t\t}\n\t\t}\n\t\tif (uf.size(v[0].second) != i + 1){\n\t\t\tuf = UnionFind(n);\n\t\t\tsum = 0;\n\t\t}\n\t}\n\t\n\treturn sum;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tes.clear();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", h + i);\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tes.push_back(Edge(--a, --b, c));\n\t\t}\n\t\tprintf(\"%lld\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n\n\n#endif // 0\n\n#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nconst int MAXN = (int) 4e4 + 10;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\nint M,N;\nint p[MAXN];\nint ans;\nint arr[MAXN];\n\nstruct EDGE{\n    int u,v,w;\n    int id;\n}edges[MAXN];\n\nbool cmp(const EDGE& a,const EDGE& b){\n    return a.w<b.w;\n}\n\nint Find(int x){\n    return p[x]==x ? x : p[x]=Find(p[x]);\n}\n\nint Kruskal(int day,int& cnt){\n    int tot=0;\n    int ret=0;\n    for(int i=1;i<=N;i++)if(arr[i]>day) tot++;\n//    printf(\"%d day islands:\\n\",day);\n//    for(int i=1;i<=N;i++)if(arr[i]>day){\n//        printf(\"%d \",i);\n//    }\n//    printf(\"\\n\");\n    for(int i=0;i<M;i++){\n        int u=edges[i].u;\n        int v=edges[i].v;\n        int w=edges[i].w;\n        if(arr[u]<=day||arr[v]<=day) continue;\n        int x=Find(u);\n        int y=Find(v);\n//        printf(\"u = %d , v = %d , w = %d , x = %d , y = %d\\n\",u,v,w,x,y);\n        if(x!=y){\n            cnt++;\n            ret+=w;\n            p[x]=y;\n        }\n    }\n//    printf(\"cnt = %d , tot = %d , ret = %d\\n\",cnt,tot,ret);\n    if(cnt+1==tot) return ret;\n    return -1;\n}\n\nvoid work(){\n    while(~scanf(\"%d%d\",&N,&M)){\n        if(N==0&&M==0) break;\n        vector<int> days;\n        days.clear();\n        days.push_back(0);\n        for(int i=1;i<=N;i++){\n            int day; scanf(\"%d\",&day);\n            arr[i]=day;\n            days.push_back(day);\n        }\n        for(int i=0;i<M;i++){\n            scanf(\"%d%d%d\",&edges[i].u,&edges[i].v,&edges[i].w);\n            edges[i].id=i;\n        }\n        sort(edges,edges+M,cmp);\n        sort(days.begin(),days.end());\n        for(int i=1;i<=N;i++) p[i]=i;\n        ans=0;\n        int cnt=0;\n        for(int i=days.size()-1;i>=0;i--){\n            if(i>0&&days[i]==days[i-1]) continue;\n            int add=Kruskal(days[i],cnt);\n            if(add==-1) {\n                ans=0;\n                cnt=0;\n                for(int j=1;j<=N;j++) p[j]=j;\n            }\n            else ans+=add;\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\n\nint main(){\n    work();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvp ti(n+1,{1,-1});\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n){\n\t\t\tint a;cin>>a;\n\t\t\tti[i]={a*-1,i};\n\t\t}\n\t\tsort(all(ti));\n\t\tint t=0;\n\t\tUnionFind uf(n);\n\t\tvi used(n);\n\t\tvvi G(m,vi(3));\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tG[i]={a,b,c};\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\tint T=-1;\n\t\twhile(t!=n){\n\t\t\tused[ti[t].second]=true;\n\t\t\twhile(ti[t].second==ti[t+1].second){\n\t\t\t\tt++;\n\t\t\t\tused[ti[t].second]=true;\n\t\t\t}\n\t\t\trep(i,m)if(used[G[i][0]]&&used[G[i][1]])uf.unionSet(G[i][0],G[i][1]);\n\t\t\tif(uf.size(ti[0].second)!=t)T=t;\n\t\t\tt++;\n\t\t}\n\t\tif(uf.size(0)!=n){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tused=vi(n);\n\t\tint sum=0;\n\t\tvi d(n,inf);\n\t\td[ti[0].second]=0;\n\t\trep(j,n){\n\t\t\tint v;\n\t\t\tif(T<j)v=ti[j].second;\n\t\t\telse{\n\t\t\t\tv=-1;\n\t\t\t\trep(i,n)if(used[ti[i].second]==0&&ti[i].first<=ti[T].first&&(v==-1||d[v]>d[ti[i].second]))v=ti[i].second;\n\t\t\t}\n\t\t\tused[v]=true;\n\t\t\tsum+=d[v];\n\t\t\trep(i,n)d[i]=min(d[i],cost[v][i]);\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\nclass UnionFind\n{\nprivate:\n    vector<int> data;\n    int _groups;\npublic:\n    int n;\n    UnionFind(int n) : data(n, -1), _groups(n), n(n) { }\n\n    void unite(int x, int y)\n    {\n        x = root(x), y = root(y);\n        if (x != y)\n        {\n            --_groups;\n            if (data[x] > data[y])\n                swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n    int groups() const { return _groups; }\n};\nint main()\n{\n    int n, m;\n    while (cin >> n >> m, n)\n    {\n        vector<pint> land;\n        rep(i, n)\n        {\n            int h;\n            cin >> h;\n            land.pb(pint(h, i));\n        }\n        \n        int a[ten(5)], b[ten(5)], c[ten(5)];\n        vector<pint> e;\n        rep(i, m)\n        {\n            cin >> a[i] >> b[i] >> c[i];\n            --a[i], --b[i];\n            e.pb(pint(c[i], i));\n        }\n\n        sort(rall(land));\n        sort(all(e));\n\n        bool up[222] = {};\n        UnionFind uf(n);\n        int cost = 0;\n        for (int li = 0; li < n; )\n        {\n            int h = land[li].first;\n            up[land[li++].second] = true;\n            while (li < n && land[li].first == h)\n                up[land[li++].second] = true;\n\n            foreach (it, e)\n            {\n                int i = it->second;\n                if (up[a[i]] && up[b[i]] && !uf.same(a[i], b[i]))\n                {\n                    uf.unite(a[i], b[i]);\n                    cost += c[i];\n                }\n            }\n        }\n        if (uf.groups() > 1)\n            cost = 0;\n        cout << cost << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\tvector<P> v;\n\t\tint ans=0, sum=0, mx=0;\n\t\tbool dp[1005][1005] = {0};\n\t\tdp[0][0] = true;\n\t\trep(i,N){\n\t\t\tint r, w;\n\t\t\tcin >> r >> w;\n\t\t\tv.emplace_back(r, w);\n\t\t\tsum += r;\n\t\t\tmx = max(mx, r);\n\t\t\tans += r + w;\n\t\t}\n\t\tsort( v.begin(), v.end() );\n\t\tv.pop_back();\n\t\tif( 2*mx > sum ){\n\t\t\trep(t, v.size()) rep(k,2){\n\t\t\t\tint w = v[t].first + ( k ? 0 : v[t].second );\n\t\t\t\tfor(int j=1000; j>=0; j--){\n\t\t\t\t\tif( j+w <= 1000 ){\n\t\t\t\t\t\tdp[t+1][j+w] |= dp[t][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[t+1][j] |= dp[t][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, mx+1){\n\t\t\t\tif( dp[ v.size() ][ mx-i ] ){\n\t\t\t\t\tans += i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nstruct edge{ int to,cost; };\nstruct edge_krus{ int from,to,cost; };\n\nint rnk[200],par[200];\n\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\trnk[i] = 0;\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rnk[x] < rnk[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nbool comp(const edge_krus& e1,const edge_krus& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int MAX_H = 1000000;\nvector<int> sink[MAX_H];\n\nsigned main(){\n\tint n,m;\n\twhile(scanf(\"%lld %lld\",&n,&m),n){\n\t\tint ans = 0;\n\t\tvector<edge> G[200];\n\t\tbool sank[200] = {};\n\t\tfor(int i = 0;i < MAX_H;i++) sink[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint h;\n\t\t\tscanf(\"%lld\",&h);\n\t\t\tsink[h - 1].push_back(i);\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%lld %lld %lld\",&a,&b,&c); a--;b--;\n\t\t\tG[a].push_back({b,c});\n\t\t\tG[b].push_back({a,c});\n\t\t}\n\t\tinit(n);\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(edge e : G[j]){\n\t\t\t\tif(!sank[j] && !sank[e.to]) unite(j,e.to);\n\t\t\t}\n\t\t}\n\t\tint mi = INF,ma = -1;\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(sank[j]) continue;\n\t\t\tmi = min(mi,find(j));\n\t\t\tma = max(ma,find(j));\n\t\t}\n\t\tif(mi != ma){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint last = -1;\n\t\tfor(int i = 0;i < MAX_H;i++){\n\t\t\tif(!sink[i].size()) continue;\n\t\t\tfor(int v : sink[i]) sank[v] = true;\n\t\t\tinit(n);\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tfor(edge e : G[j]){\n\t\t\t\t\tif(!sank[j] && !sank[e.to]) unite(j,e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mi = INF,ma = -1;\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(sank[j]) continue;\n\t\t\t\tmi = min(mi,find(j));\n\t\t\t\tma = max(ma,find(j));\n\t\t\t}\n\t\t\tif(mi != ma){\n\t\t\t\tfor(int v : sink[i]) sank[v] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = i;\n\t\t}\n\t\tinit(n);\n\t\tvector<edge_krus> es;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(edge e : G[i]){\n\t\t\t\tif(!sank[i] && !sank[e.to]) es.push_back({i,e.to,e.cost});\n\t\t\t}\n\t\t}\n\t\tsort(es.begin(),es.end(),comp);\n\t\tfor(edge_krus e : es){\n\t\t\tif(!same(e.from,e.to)){\n\t\t\t\tunite(e.from,e.to);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\tfor(int i = last;i >= 0;i--){\n\t\t\tif(!sink[i].size()) continue;\n\t\t\tes.clear();\n\t\t\tfor(int v : sink[i]) sank[v] = false;\n\t\t\tfor(int v : sink[i]){\n\t\t\t\tfor(edge e : G[v]){\n\t\t\t\t\tif(!sank[e.to]) es.push_back({v,e.to,e.cost});\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(es.begin(),es.end(),comp);\n\t\t\tfor(edge_krus e : es){\n\t\t\t\tif(!same(e.from,e.to)){\n\t\t\t\t\tunite(e.from,e.to);\n\t\t\t\t\tans += e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> LP;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct UnionFind{ // paste zamurai\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){ for(int i=0;i<v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nstruct edge{\n  int a,b,c;\n};\nbool operator<(const edge& a,const edge& b){\n  return a.c<b.c;\n}\n\nint n,m;\nedge es[200*200];\nbool use[222];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    vector<P> h;\n    rep(i,n){\n      int hh;\n      cin>>hh;\n      h.pb(P(hh,i));\n    }\n    sort(all(h));\n    reverse(all(h));\n    h.pb(P(-1,-1));\n    rep(i,m){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--; b--;\n      es[i]=(edge){a,b,c};\n    }\n    sort(es,es+m);\n    UnionFind uf(n);\n    int res=0;\n    int cnt=0;\n    memset(use,0,sizeof(use));\n    rep(i,n){\n      use[h[i].se]=true;\n      while(h[i].fi==h[i+1].fi){\n        use[h[++i].se]=true;\n      }\n      rep(j,m){\n        if(use[es[j].a]&&use[es[j].b]&&!uf.same(es[j].a,es[j].b)){\n          res+=es[j].c;\n          uf.unite(es[j].a,es[j].b);\n          cnt++;\n        }\n      }\n      if(cnt!=i){\n        uf.init();\n        res=0; cnt=0;\n      }\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass union_find{\n\tint n;\n\tvector<int> a;\npublic:\n\tunion_find(int N):a(N,-1),n(N){}\n\tint find(int x){\n\t\tif(a[x]<0) return x;\n\t\treturn a[x]=find(a[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x!=y){ a[x]+=a[y]; a[y]=x; n--; }\n\t}\n\tint size(){ return n; }\n};\n\nstruct edge{\n\tint u,v,cost;\n\tbool operator<(const edge &e)const{ return cost<e.cost; }\n};\n\nbool is_connected(int n,const bool *sunk,int m,edge *E){\n\tunion_find U(n);\n\trep(i,m){\n\t\tint u=E[i].u,v=E[i].v;\n\t\tif(!sunk[u] && !sunk[v] && U.find(u)!=U.find(v)) U.unite(u,v);\n\t}\n\treturn U.size()==1+count(sunk,sunk+n,true);\n}\n\nint find_MST(const bool *sunk,int m,const edge *E,union_find &U){\n\tint res=0;\n\trep(i,m){\n\t\tint u=E[i].u,v=E[i].v;\n\t\tif(!sunk[u] && !sunk[v] && U.find(u)!=U.find(v)){\n\t\t\tU.unite(u,v);\n\t\t\tres+=E[i].cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint life[200];\n\t\trep(u,n) scanf(\"%d\",life+u);\n\t\tstatic edge E[200*199/2];\n\t\trep(i,m){\n\t\t\tint u,v,c; scanf(\"%d%d%d\",&u,&v,&c); u--; v--;\n\t\t\tE[i]=(edge){u,v,c};\n\t\t}\n\t\tsort(E,E+m);\n\n\t\tint order[200];\n\t\t{\n\t\t\tpair<int,int> tmp[200];\n\t\t\trep(u,n) tmp[u]=make_pair(life[u],u);\n\t\t\tsort(tmp,tmp+n);\n\t\t\trep(i,n) order[i]=tmp[i].second;\n\t\t}\n\n\t\tbool sunk[200]={}; // sizunda islands\n\t\tif(!is_connected(n,sunk,m,E)){ puts(\"0\"); continue; }\n\n\t\tint i_end=n;\n\t\trep(i,n){\n\t\t\tsunk[order[i]]=true;\n\t\t\twhile(i<n-1 && life[order[i]]==life[order[i+1]]) sunk[order[++i]]=true;\n\n\t\t\tif(!is_connected(n,sunk,m,E)){ i_end=i; break; }\n\t\t}\n\t\twhile(i_end>0 && life[order[i_end]]==life[order[i_end-1]]) i_end--;\n\n\t\trep(u,n) sunk[u]=false;\n\t\trep(i,i_end) sunk[order[i]]=true;\n\n\t\tunion_find U(n);\n\t\tint ans=find_MST(sunk,m,E,U);\n\t\tfor(int i=i_end-1;i>=0;i--){\n\t\t\tsunk[order[i]]=false;\n\t\t\twhile(i>0 && life[order[i]]==life[order[i-1]]) sunk[order[--i]]=false;\n\n\t\t\tans+=find_MST(sunk,m,E,U);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<cassert>\n#include<set>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 300\nusing namespace std;\n\nclass UnionFindTree\n{\npublic:\n  int par[MAX];\n\n  void init(int N){ rep(i,N)par[i] = i; }  \n\n  int find(int x)\n  {\n    if(par[x] == x)return x;\n    return par[x] = find(par[x]);\n  }\n\n  void unit(int x,int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x != y)par[x] = y;\n  }\n\n  bool same(int x,int y){ return find(x) == find(y); }\n\n};\n\nstruct edge\n{\n  int x,y,cost;\n  edge(int x=inf,int y=inf,int cost=inf):x(x),y(y),cost(cost){}\n  bool operator < (const edge& a)const\n  {\n    return cost < a.cost;\n  }\n};\n\nint N,M;\nvector<int> h,ph;\nvector<edge> G;\n\nbool check()\n{\n  UnionFindTree UTF;\n  UTF.init(N);\n  rep(i,G.size())\n    if(!UTF.same(G[i].x,G[i].y))\n      UTF.unit(G[i].x,G[i].y);\n  rep(i,N)UTF.find(i);\n  rep(i,N)if(UTF.par[i] != UTF.par[0])return false;\n  return true;\n}\n\nvoid compute()\n{\n\n  if(!check())\n    {\n      cout << 0 << endl;\n      return;\n    }\n\n  sort(all(ph),greater<int>());\n  sort(all(G));\n\n  UnionFindTree group;\n  group.init(N);\n  int ans = 0;\n\n  rep(i,ph.size())\n    {\n      int TM = ph[i];\n      UnionFindTree UTF;\n      UTF.init(N);\n      rep(j,G.size())\n\t{\n\t  int x = G[j].x;\n\t  int y = G[j].y;\n\t  if(h[x] < TM || h[y] < TM)continue;\n\t  if(!UTF.same(x,y))\n\t    {\n\t      UTF.unit(x,y);\n\t    }\n\t}\n\n      rep(j,N)UTF.find(j);\n\n      set<int> out;\n      rep(j,N)if(h[j] >= TM && UTF.par[j] != j)out.insert(UTF.par[j]);\n      if(out.size() >= 2)\n\t{\n\t  ans = 0;\n\t  group.init(N);\n\t  continue;\n\t}\n\n\n      rep(j,G.size())\n\t{\n\t  int x = G[j].x;\n\t  int y = G[j].y;\n\t  if(h[x] < TM || h[y] < TM)continue;\n\t  if(!group.same(x,y))\n\t    {\n\t      //cout << TM << \" unit(\" << x+1 << \",\" << y+1 << \")\" << endl;\n\t      group.unit(x,y);\n\t      ans += G[j].cost;\n\t    }\n\t}\n      //cout << \"ans = \" << ans << endl;\n    }\n\n  cout << ans << endl;\n\n}\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      h.clear(),ph.clear(),G.clear();\n      h.resize(N),ph.resize(N),G.resize(M);\n      rep(i,N)cin >> h[i],ph[i] = h[i];\n      rep(i,M)cin >> G[i].x >> G[i].y >> G[i].cost,G[i].x--,G[i].y--;\n\n      compute();\n\n    }\n  return 0;\n}\n\n/*\nstruct P\n{\n  int h,identifier;\n  P(int h=inf,int identifier=inf):h(h),identifier(identifier){}\n  bool operator < (const P& a)const\n  {\n    if(h != a.h)return h > a.h;\n    return identifier < a.identifier;\n  }\n};\n\nstruct edge\n{\n  int x,y,cost;\n  edge(int x=inf,int y=inf,int cost=inf):x(x),y(y),cost(cost){}\n  bool operator < (const edge& a)const\n  {\n    return cost < a.cost;\n  }\n};\n\nint par[MAX];\nint N,M;\nvector<int> h,ph;\nvector<edge> vec;\n\nint find(int x)\n{\n  if(par[x] == x)return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x == y)return;\n  par[x] = y;\n}\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      \n      ph.clear(),h.clear(),vec.clear();\n      ph.resize(N),h.resize(N),vec.resize(M);\n      rep(i,N)par[i] = i;\n\n      rep(i,N)cin >> h[i],ph[i] = h[i];\n\t\n      rep(i,M)cin >> vec[i].x >> vec[i].y >> vec[i].cost,vec[i].x--,vec[i].y--;\n      \n      sort(ph.begin(),ph.end(),greater<int>());\n      sort(vec.begin(),vec.end());\n\n\n \n      int ans = 0;\n      rep(i,ph.size())\n\t{\n\t  int TM = ph[i];\n\t  int cost = 0;\n\t  rep(j,vec.size())\n\t    {\n\t      int x = vec[j].x;\n\t      int y = vec[j].y;\n\n\t      if(h[x] < TM || h[y] < TM)continue;\n\t      if(find(x) != find(y))\n\t\t{\n\t\t  cout << TM << \" unit(\"<<x+1 <<\",\" <<y+1 << \") : \" << vec[j].cost << endl;\n\t\t  unit(x,y);\n\t\t  cost += vec[j].cost;\n\t\t}\n\n\t    }\n\t  cout << \"ans : \" << ans << endl;\n\t}\n\n      int ch = find(0);\n      bool out = false;\n      rep(i,N)if(find(i) != ch)\n\t{\n\t  out = true;\n\t  break;\n\t}\n\n      cout << (out?0:ans) << endl;\n      \n    }\n  return 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,M;\nvector<P> H;\n\nstruct edge{\n  int to,from,c;\n  bool operator<(const edge& e) const{\n    return c < e.c;\n  }\n};\n\nvector<edge> E;\n\nstruct uni{\n  int d[222];\n  void init(){ memset(d,-1,sizeof(d)); }\n  int find(int a){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void marge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a]+=d[b]; d[b] = a;\n  }\n  bool same(int a,int b){ return find(a)==find(b); }\n  int size(int a){ return -d[find(a)]; }\n};\n\nuni U;\n\nbool used[333];\nint main(){\n  while( cin >> N >> M && (N||M) ){\n    U.init();\n    H.clear();\n    E.clear();\n    for(int i=0;i<N;i++) {\n      H.push_back(P(i,i));\n      cin >> H[i].first;\n    }\n    sort(H.rbegin(),H.rend());\n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      --a; --b;\n      E.push_back( (edge){a,b,c} );\n    }\n    sort(E.begin(),E.end());\n\n\n    for(int i=0;i<N;i++)used[i]=true;\n    int start = N;\n    for(int i=N-1;i>=0;i--){\n      int id=H[i].second;\n      if( i > 0 && H[i].first == H[i-1].first ) {\n\tused[id] = false;\n\tcontinue;\n      }\n      uni up;\n      up.init();\n      for(int j=0;j<M;j++){\n\tif( used[E[j].to] && used[E[j].from] ) {\n\t  if( !up.same(E[j].to,E[j].from) ) {\n\t    up.marge(E[j].to,E[j].from);\n\t  }\n\t}\n      }  \n      if( up.size(id) == i+1 ) start = i;\n      else break;\n      used[id] = false;\n    }\n\n    long long res = 0;\n    for(int i=start;i<N;i++){\n      int id=H[i].second;\n      if( i < N-1 && H[i].first == H[i+1].first ) {\n\tused[id] = true;\n\tcontinue;\n      }\n\n      //      cout << id << endl;\n      used[id] = true;\n      for(int j=0;j<M;j++){\n\tif( used[E[j].to] && used[E[j].from] ) {\n\t  if( !U.same(E[j].to,E[j].from) ) {\n\t    //   cout << E[j].to << \" \"<< E[j].from << \" \"<< E[j].c << endl;\n\t    res+=(long long)E[j].c;\n\t    U.marge(E[j].to,E[j].from);\n\t  }\n\t}\n      }    \n    }\n    \n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nclass UnionFind\n{\nprivate:\n\tvector<int> parent;\n\tvector<int> rank;\n\npublic:\n\tUnionFind( int n ) : parent( n ), rank( n, 0 )\n\t{\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tparent[i] = i;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tint find( int x )\n\t{\n\t\tif ( parent[x] == x )\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn parent[x] = find( parent[x] );\n\t\t}\n\t}\n\n\tbool same( int x, int y )\n\t{\n\t\treturn find( x ) == find( y );\n\t}\n\n\tvoid unite( int x, int y )\n\t{\n\t\tx = find( x );\n\t\ty = find( y );\n\n\t\tif ( x == y )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif ( rank[x] < rank[y] )\n\t\t{\n\t\t\tparent[x] = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\n\t\t\tif ( rank[x] == rank[y] )\n\t\t\t{\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n};\n// UnionFind( N )\n// find( x )\n// same( x, y )\n// unite( x, y )\n\nstruct Edge\n{\n\tint u, v, c;\n\t\n\tEdge( int u, int v, int c ) : u( u ), v( v ), c( c )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const Edge &a ) const\n\t{\n\t\treturn c < a.c;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n, m; cin >> n >> m, n | m; )\n\t{\n\t\tVI hs( n );\n\t\tFOR( h, hs )\n\t\t{\n\t\t\tcin >> h;\n\t\t}\n\t\t\n\t\tVI times = hs;\n\t\tsort( ALL( times ) );\n\t\ttimes.erase( unique( ALL( times ) ), times.end() );\n\t\treverse( ALL( times ) );\n\n\t\tvector<Edge> G;\n\t\tREP( i, 0, m )\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tG.PB( Edge( a - 1, b - 1, c ) );\n\t\t}\n\t\tsort( ALL( G ) );\n\n\t\tUnionFind uf( n );\n\t\tvector<bool> exists( n, false );\n\t\tint res = 0;\n\t\tREP( i, 0, times.size() )\n\t\t{\n\t\t\tREP( j, 0, n )\n\t\t\t{\n\t\t\t\tif ( times[i] <= hs[j] )\n\t\t\t\t{\n\t\t\t\t\texists[j] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tREP( i, 0, m )\n\t\t\t{\n\t\t\t\tif ( !exists[ G[i].u ] || !exists[ G[i].v ] || uf.same( G[i].u, G[i].v ) )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tuf.unite( G[i].u, G[i].v );\n\t\t\t\tres += G[i].c;\n\t\t\t}\n\n\t\t\tconst int pos = find( ALL( exists ), true ) - exists.begin();\n\t\t\tbool connected = true;\n\t\t\tREP( i, 0, n )\n\t\t\t{\n\t\t\t\tif ( !exists[i] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconnected &= uf.same( pos, i );\n\t\t\t}\n\n\t\t\tif ( !connected )\n\t\t\t{\n\t\t\t\tres = 0;\n\t\t\t\tuf = UnionFind( n );\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>is[1000005];\nint h[205],a[100005],b[100005],c[100005];;\nvector<P1>edge[1000005];\nint par[205],ran[205];\nvoid init(){ for(int i=0;i<205;i++) par[i] = i,ran[i] = 0; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nint p[100005];\nbool cmp(const int &a,const int &b){\n\treturn c[a] < c[b];\n}\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n) return 0;\n\t\trep(i,1000005) is[i].clear();\n\t\trep(i,1000005) edge[i].clear();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> h[i];\n\t\t\tis[h[i]].pb(i);\n\t\t}\n\t\tinit();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\t//int a,b,c;\n\t\t\tcin >> a[i] >> b[i] >> c[i]; p[i] = i;\n\t\t\tedge[h[a[i]]].pb(mp(c[i],mp(a[i],b[i])));\n\t\t\tedge[h[b[i]]].pb(mp(c[i],mp(b[i],a[i])));\n\t\t\tunite(a[i],b[i]);\n\t\t}\n\t\tint C = 0;\n\t\tfor(int i=1;i<=n;i++) if(find(i)==i) C++;\n\t\tif(C>=2){\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tsort(p+1,p+m+1,cmp);\n\t\trep(i,1000005){\n\t\t\tSORT(edge[i]);\n\t\t}\n\t\tinit();\n\t\tint cnt = 0,ret = 0,sum = 0;\n\t\tfor(int i=1000000;i>=1;i--){\n\t\t\tfor(int k=0;k<edge[i].size();k++){\n\t\t\t\tint x = edge[i][k].sc.fi;\n\t\t\t\tif(h[edge[i][k].sc.sc] >= i && !same(edge[i][k].sc.sc,x)){\n\t\t\t\t\tunite(edge[i][k].sc.sc,x);\n\t\t\t\t\tcnt++; ret += edge[i][k].fi;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += is[i].size();\n\t\t\tif(sum && cnt != sum-1){\n\t\t\t\tcnt = 0; ret = 0; init();\n\t\t\t\tif(i!=1){\n\t\t\t\t\tfor(int x=1;x<=m;x++){\n\t\t\t\t\t\tint k = p[x];\n\t\t\t\t\t\tif(h[a[k]] >= i-1 && h[b[k]] >= i-1 && !same(a[k],b[k])){\n\t\t\t\t\t\t\tunite(a[k],b[k]);cnt++;ret+=c[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvp ti(n+1,{1,-1});\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n){\n\t\t\tint a;cin>>a;\n\t\t\tti[i]={a*-1,i};\n\t\t}\n\t\tsort(all(ti));\n\t\tint t=0;\n\t\tUnionFind uf(n);\n\t\tvi used(n);\n\t\tvvi G(m,vi(3));\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tG[i]={a,b,c};\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\tint T=-1;\n\t\twhile(t!=n){\n\t\t\tused[ti[t].second]=true;\n\t\t\twhile(ti[t].second==ti[t+1].second){\n\t\t\t\tt++;\n\t\t\t\tused[ti[t].second]=true;\n\t\t\t}\n\t\t\trep(i,m)if(used[G[i][0]]&&used[G[i][1]])uf.unionSet(G[i][0],G[i][1]);\n\t\t\tt++;\n\t\t\tif(uf.size(ti[0].second)!=t)T=t;\n\t\t}\n\t\tif(uf.size(0)!=n){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tused=vi(n);\n\t\tint sum=0;\n\t\tvi d(n,inf);\n\t\td[ti[0].second]=0;\n\t\trep(j,n){\n\t\t\tint v;\n\t\t\tif(ti[T].first<ti[j].first)v=ti[j].second;\n\t\t\telse{\n\t\t\t\tv=-1;\n\t\t\t\trep(i,n)if(used[ti[i].second]==0&&ti[i].first<=ti[T].first&&(v==-1||d[v]>d[ti[i].second]))v=ti[i].second;\n\t\t\t}\n\t\t\tused[v]=true;\n\t\t\tsum+=d[v];\n\t\t\trep(i,n)d[i]=min(d[i],cost[v][i]);\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint h[200], par[200], s[200];\nint find(int x) {\n\tif (par[x] == x)return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = find(x); y = find(y);\n\tpar[y] = x; s[x] += s[y];\n}\nstruct st { int a, b, c; };\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\trep(i, n)scanf(\"%d\", &h[i]);\n\t\tvector<st>v;\n\t\trep(i, m) {\n\t\t\tint a, b, c; scanf(\"%d%d%d\", &a, &b, &c); a--; b--;\n\t\t\tv.push_back({ a,b,c });\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\treturn min(h[a.a], h[a.b]) > min(h[b.a], h[b.b]);\n\t\t});\n\t\tint u = 0;\n\t\tfor (st p : v) {\n\t\t\tif (find(p.a) == find(p.b))continue;\n\t\t\tunite(p.a, p.b);\n\t\t\tif (s[find(p.a)] == n) {\n\t\t\t\tu = max(h[p.a], h[p.b]); break;\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](st a, st b) {\n\t\t\tint c = min({ u,h[a.a], h[a.b] }), d = min({ u,h[b.a], h[b.b] });\n\t\t\tif (c == d)return a.c < b.c;\n\t\t\treturn c > d;\n\t\t});\n\t\tint res = 0;\n\t\trep(i, n)par[i] = i, s[i] = 1;\n\t\tfor (st p : v) {\n\t\t\tif (find(p.a) == find(p.b))continue;\n\t\t\tunite(p.a, p.b); res += p.c;\n\t\t}\n\t\tif (s[find(0)] != n)puts(\"0\");\n\t\telse printf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\ntypedef long long ll;\n#define PB push_back\n#define mkp make_pair\n\nclass UF{\npublic:\n\tstatic const int ufmax = 410;\n\tint ufpar[ufmax],ufrank[ufmax],ufcnt[ufmax];\n\tUF() {init();}\n\tvoid init(){\n\t\trep(i,ufmax){\n\t\t\tufpar[i] = i;\n\t\t\tufrank[i] = 0;\n\t\t\tufcnt[i] = 1;\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn (ufpar[x] == x?(x):ufpar[x] = find(ufpar[x]));\n\t}\n\tint operator[](int x){\n\t\treturn find(x);\n\t}\n\tint count(int x){\n\t\treturn ufcnt[find(x)];\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(ufrank[x]<ufrank[y]) ufpar[x] = y,ufcnt[y]+=ufcnt[x];\n\t\telse{\n\t\t\tufpar[y] = x;\n\t\t\tufcnt[x] += ufcnt[y];\n\t\t\tif(ufrank[x]==ufrank[y]) ufrank[x]++;\n\t\t}\n\t}\n};\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\t// vector<pair<int,int>> v(n);\n\t\tmap<int,set<int>> ma;\n\t\trep(i,n){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tma[-t].insert(i);\n\t\t}\n\t\t// sort(v.begin(),v.end());\n\t\tvector<vector<pair<int,int>>> vv(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--,b--;\n\t\t\tvv[a].PB(mkp(b,c));\n\t\t\tvv[b].PB(mkp(a,c));\n\t\t}\n\t\tint cnt = 0;\n\t\tll ans = 0;\n\t\tvector<int> used(n,0);\n\t\tUF uf;\n\t\tfor(auto x:ma){\n\t\t\tfor(int y:x.S){\n\t\t\t\tused[y]=1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tpriority_queue<pair<int,pair<int,int>>> pq;\n\t\t\tif(ans==0) rep(i,n){\n\t\t\t\tif(!used[i]) continue;\n\t\t\t\tfor(auto y:vv[i]){\n\t\t\t\t\tif(!used[y.F]) continue;\n\t\t\t\t\tpq.push(mkp(-y.S,mkp(i,y.F)));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(pq.size()){\n\t\t\t\tauto top = pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tif(uf[top.S.F]==uf[top.S.S]) continue;\n\t\t\t\tuf.unite(top.S.F,top.S.S);\n\t\t\t\tans-=top.F;\n\t\t\t}\n\t\t\tfor(int i:x.S){\n\t\t\t\tfor(auto y:vv[i]){\n\t\t\t\t\tif(!used[y.F]) continue;\n\t\t\t\t\tpq.push(mkp(-y.S,mkp(i,y.F)));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(pq.size()){\n\t\t\t\tauto top = pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tif(uf[top.S.F]==uf[top.S.S]) continue;\n\t\t\t\tuf.unite(top.S.F,top.S.S);\n\t\t\t\tans-=top.F;\n\t\t\t}\n\t\t\trep(i,n){\n\t\t\t\tif(!used[i]) continue;\n\t\t\t\tif(uf.count(i)<cnt) ans=0;\n\t\t\t}\n\t\t\tif(ans==0) uf.init();\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (int)1e9\n#define fi first\n#define se second\nusing namespace std;\n\nstruct Unionfind {\n  // tree number\n  vector<int> par;\n  // tree rank\n  vector<int> treerank;\n  // constructor\n  Unionfind(int n = 1) { stree(n + 1); }\n  // make and initialization\n  void stree(int n = 1) {\n    par.assign(n, -1);\n    treerank.assign(n, 0);\n  }\n  // search root\n  int root(int x) {\n    if(par[x] < 0) return x;\n    return par[x] = root(par[x]);\n  }\n  // is same?\n  bool issame(int x, int y) { return root(x) == root(y); }\n\n  // add\n  // already added, return 0\n  bool uni(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if(x == y) return 0;\n    if(treerank[x] > treerank[y]) swap(x, y);\n    if(treerank[x] == treerank[y]) ++treerank[y];\n    par[y] -= size(x);\n    par[x] = y;\n    return 1;\n  }\n  int size(int x) { return -par[root(x)]; }\n};\n\nstruct edata {\n  int from, to, cost;\n};\n\nbool operator<(const edata &l, const edata &r) {\n  if(l.cost != r.cost) return l.cost > r.cost;\n  return l.from > r.from;\n}\n\nint n, m;\nvector<pair<int, int>> h;\nvector<vector<int>> edge;\nUnionfind uf;\npriority_queue<edata> pq;\n\nint solve();\nint krus(int now);\nbool ch(int now);\n\nint main() {\n  while(1) {\n    cin >> n >> m;\n    if(n + m == 0) break;\n    h.resize(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> h[i].fi;\n      h[i].se = i;\n    }\n    sort(h.begin(), h.end());\n    edge.assign(n, vector<int>(n, inf));\n    for(int i = 0; i < m; ++i) {\n      int x, y, d;\n      cin >> x >> y >> d;\n      --x, --y;\n      edge[x][y] = edge[y][x] = d;\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  int fin = n, ans = 0;\n  for(int i = 0; i < n; ++i)\n    if(!ch(i)) {\n      fin = i - 1;\n      while(fin - 1 >= 0 && h[fin].fi == h[fin - 1].fi)\n        --fin;\n      ++fin;\n      break;\n    }\n    else\n      while(i + 1 < n && h[i].fi == h[i + 1].fi) ++i;\n  uf = Unionfind(n);\n  ans += krus(fin - 1);\n  for(int i = fin - 2; i >= 0; --i) {\n    int nowr = i;\n    while(i > 0 && h[nowr].fi == h[i - 1].fi) --i;\n    ans += krus(i);\n  }\n  return ans;\n}\n\nint krus(int now) {\n  if(now == -1) return 0;\n  int ans = 0;\n  for(int i = now; i < n; ++i)\n    for(int j = i + 1; j < n; ++j)\n      if(edge[h[i].se][h[j].se] != inf)\n        pq.push({h[i].se, h[j].se, edge[h[i].se][h[j].se]});\n  while(pq.size() > 0) {\n    edata nowe = pq.top();\n    pq.pop();\n    if(!uf.issame(nowe.from, nowe.to)) {\n      ans += nowe.cost;\n      uf.uni(nowe.from, nowe.to);\n    }\n  }\n  return ans;\n}\n\nbool ch(int now) {\n  uf = Unionfind(n);\n  for(int i = now; i < n; ++i)\n    for(int j = i + 1; j < n; ++j)\n      if(edge[h[i].se][h[j].se] != inf)\n        uf.uni(h[i].se, h[j].se);\n  return uf.size(uf.root(h[now].se)) == n - now;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass UnionFindTree\n{\n    int n;\n    vector<int> parent; // 親ノード\n    vector<int> rank;   // 木の高さの上限\n    vector<int> num;    // グループの要素数\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n0){ // コンストラクタ\n        n = n0;\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n        num.assign(n, 1);\n    }\n    void unite(int x, int y){ // xとyのグループを併合\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y]){\n                parent[x] = y;\n                num[y] += num[x];\n            }else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n                num[x] += num[y];\n            }\n            -- n;\n        }\n    }\n    bool same(int x, int y){ // xとyのグループが同じかを調べる\n        return find(x) == find(y);\n    }\n    int getNum(){ // グループの数を返す\n        return n;\n    }\n    int getNum(int x){ // xのグループの要素数を返す\n        return num[find(x)];\n    }\n};\n\nclass Bridge\n{\npublic:\n    int a, b, cost;\n    bool operator<(const Bridge& x) const{\n        return cost < x.cost;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<pair<int, int> > sink(n);\n        for(int i=0; i<n; ++i){\n            cin >> sink[i].first;\n            sink[i].second = i;\n        }\n        sort(sink.rbegin(), sink.rend());\n\n        vector<Bridge> bridge(m);\n        for(int i=0; i<m; ++i){\n            cin >> bridge[i].a >> bridge[i].b >> bridge[i].cost;\n            -- bridge[i].a;\n            -- bridge[i].b;\n        }\n        sort(bridge.begin(), bridge.end());\n\n        int k = n;\n        vector<bool> isActive(n, true);\n        while(k >= 0){\n            UnionFindTree uft(n);\n            for(int i=0; i<m; ++i){\n                if(isActive[bridge[i].a] && isActive[bridge[i].b])\n                    uft.unite(bridge[i].a, bridge[i].b);\n            }\n            if(uft.getNum() != n - k + 1)\n                break;\n\n            do{\n                -- k;\n                isActive[sink[k].second] = false;\n            }while(k > 0 && sink[k].first == sink[k-1].first);\n        }\n        \n        UnionFindTree uft(n);\n        int ret = 0;\n        while(k < n){\n            do{\n                isActive[sink[k].second] = true;\n                ++ k;\n            }while(k < n && sink[k].first == sink[k-1].first);\n\n            for(int i=0; i<m; ++i){\n                if(isActive[bridge[i].a] && isActive[bridge[i].b] && !uft.same(bridge[i].a, bridge[i].b)){\n                    ret += bridge[i].cost;\n                    uft.unite(bridge[i].a, bridge[i].b);\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nclass UnionFind{\nprivate:\n  vector<int> v;\n  int cnt;\npublic:\n  UnionFind(int n){\n    v.resize(n);\n    Init();\n    cnt = n;\n  }\n  void Init(){\n    for(int i=0,size=v.size();i<size;i++) v[i]=i;\n  }\n  int Find(int n){\n    if(v[n] == n) return n;\n    else return (v[n] = Find(v[n]));\n  }\n  bool Same(int a,int b){\n    return (Find(a) == Find(b));\n  }\n  bool Union(int a,int b){\n    if(Same(a,b)) return false;\n    v[Find(a)] = Find(v[b]);\n    cnt--;\n    return true;\n  }\n  int getCnt(){ return cnt; }\n};\n\nstruct Edge{\n  int a,b,c;\n  Edge(int aa,int bb,int cc):a(aa),b(bb),c(cc){}\n};\n\nbool operator<(Edge e1,Edge e2){\n  return (e1.c < e2.c);\n}\n\nint Kruskal(vector<Edge> &Edges,vector<bool> &active,UnionFind &uf){\n  int ans = 0;\n  for(int i=0,size=Edges.size();i<size;i++){\n    if(active[Edges[i].a] && active[Edges[i].b] && uf.Union(Edges[i].a,Edges[i].b))\n      ans += Edges[i].c;\n  }\n  return ans;\n}\n\nbool check(vector<Edge> &e,vector<bool> &a){\n  UnionFind uf(a.size());\n  for(int i=0,sz=e.size();i<sz;i++){\n    if(a[e[i].a] && a[e[i].b]) uf.Union(e[i].a,e[i].b);\n  }\n  int cnt=0;\n  for(int i=0,sz=a.size();i<sz;i++) cnt += !a[i];\n  return (cnt + 1 ==  uf.getCnt());  \n} \n\nint main(){\n  int n,m;\n  while(cin>>n>>m,n+m){\n    map<int,vector<int> > ivmap;\n    for(int i=0;i<n;i++){\n      int h;\n      cin>>h;\n      ivmap[h].push_back(i);\n    }\n    vector<vector<int> > v;\n    for(map<int,vector<int> >::iterator it=ivmap.begin();it!=ivmap.end();it++){\n      v.push_back(it->second);\n    }\n    vector<Edge> Edges;\n    Edges.reserve(m);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--;\n      b--;\n      Edges.push_back(Edge(a,b,c));\n    }\n    sort(Edges.begin(),Edges.end());\n    vector<bool> active(n,true);\n    int i;\n    UnionFind uf(n);\n    if(!check(Edges,active)){\n      cout<<0<<endl;\n    }else{\n      for(i=0;i<v.size();i++){\n\tfor(int j=0,sz=v[i].size();j<sz;j++) active[v[i][j]]=false;\n\tif(!check(Edges,active)) break;\n      }\n      for(int j=0,sz=v[i].size();j<sz;j++) active[v[i][j]]=true;\n      int ans = Kruskal(Edges,active,uf);\n      for(i--;i>=0;i--){\n\tfor(int j=0;j<v[i].size();j++) active[v[i][j]]=true;\n\tans += Kruskal(Edges,active,uf);\n      }\n      cout<<ans<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<Int, P> T;\n\nInt u[1080];\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(Int x, Int y){\n\tu[r(x)] = r(y);\n}\nvector<T> edge[1080000];\nInt h[1080];\nbool come[1080];\nint main(){\n\tInt n, m;\n\twhile(cin >> n >> m, n | m){\n\t\tInt res = 0, bridge = 0, a, b, c, cnt = 0;\n\t\tfor(Int i = 0;i < n;i++)cin >> h[i], u[i] = i, come[i] = false;\n\t\tfor(Int i = 0;i < m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tedge[min(h[a], h[b])].push_back(T(c, P(a, b)));\n\t\t}\n\t\tInt breakpoInt = 1000010;\n\t\tfor(Int i = 1000000;i > 0;i--){\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\n\t\t\t\tif(!come[from])cnt++, come[from] = true;\n\t\t\t\tif(!come[to])cnt++, come[to] = true;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt && cnt - 1 != bridge){\n\t\t\t\tbreakpoInt = i;\n\t\t\t}\n\t\t}                    \n\t\tbridge = 0;\n\t\tvector<T> tmp;\n\t\tfor(Int i = 0;i < n;i++)u[i] = i;\n\t\tif(breakpoInt)breakpoInt--;\n\t\tfor(Int i = 1000000;i >= breakpoInt;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\ttmp.push_back(edge[i][j]);\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor(Int i = 0;i < tmp.size();i++){\n\t\t\tInt from = tmp[i].second.first, to = tmp[i].second.second;\n\t\t\tif(r(from) != r(to)){\n\t\t\t\tbridge++;\n\t\t\t\tres += tmp[i].first;\n\t\t\t\tunite(from, to);\n\t\t\t}\n\t\t}\n\t\tfor(Int i = breakpoInt;i > 0;i--){\n\t\t\tfor(Int j = 0;j < edge[i].size();j++){\n\t\t\t\tInt from = edge[i][j].second.first, to = edge[i][j].second.second;\n\t\t\t\tif(r(from) != r(to)){\n\t\t\t\t\tbridge++;\n\t\t\t\t\tres += edge[i][j].first;\n\t\t\t\t\tunite(from, to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tedge[i].clear();\n\t\t}\n\t\tif(bridge + 1 != n)res = 0;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<ll> par; // 親\n\tvector<ll> sz; // 数\n\t// 初期化\n\tUF(ll n):par(n),sz(n) {\n\t\tfor(ll i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tll find(ll x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(ll x, ll y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(ll x, ll y) { return find(x) == find(y); }\n\tll size(ll n){return sz[find(n)];}\n};\n\nll n,m;\nvector<pair<ll,ll>> h;\nvector<pair<ll,pair<ll,ll>>> v;\nbool sink[222];\n\nll check(ll num){\n\tUF uf(n);\n\tll ret = 0;\n\tREP(i,m){\n\t\tll A = v[i].SE.FI;\n\t\tll B = v[i].SE.SE;\n\t\tll C = v[i].FI;\n\t\tif(sink[A] | sink[B])continue;\n\t\tif(!uf.same(A,B)){\n\t\t\tuf.unite(A,B);\n\t\t\tret += C;\n\t\t}\n\t}\n\tll cou = 0;\n\tREP(i,n){\n\t\tcou = max(cou,uf.size(i));\n\t}\n\treturn (cou == num ? ret : -1);\n}\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\th.clear();\n\t\tv.clear();\n\t\tREP(i,222)sink[i] = false;\n\t\t\n\t\tREP(i,n){\n\t\t\tll tmp;\n\t\t\tcin >> tmp;\n\t\t\th.PB(MP(tmp,i));\n\t\t}\n\t\t\n\t\tREP(i,m){\n\t\t\tll a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tv.PB(MP(c,MP(a,b)));\n\t\t}\n\t\t\n\t\tsort(ALL(h));\n\t\tsort(ALL(v));\n\t\t\n\t\tll prev = check(n);\n\t\tll sinknum;\n\t\tif(prev == -1){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\tbool flag = false;\n\t\t\tfor(sinknum = 0;sinknum < n-1;sinknum++){\n\t\t\t\twhile(sinknum < n-1 && h[sinknum].FI == h[sinknum+1].FI){\n\t\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\t\tsinknum++;\n\t\t\t\t}\n\t\t\t\tsink[h[sinknum].SE] = true;\n\t\t\t\tll now = check(n-sinknum-1);\n\t\t\t\tif(now == -1){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev = now;\n\t\t\t}\n\t\t\tsink[h[sinknum].SE] = false;\n\t\t\tsinknum--;\n\t\t\tDBG(cout << \"prev \" << prev << \" sinknum \" << sinknum << endl;)\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tll tmp = 0;\n\t\t\tfor(ll i = sinknum;i >= 0;i--){\n\t\t\t\tvector<ll> li;\n\t\t\t\twhile(i > 0 && h[i].FI == h[i-1].FI){\n\t\t\t\t\tli.PB(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tli.PB(i);\n\t\t\t\tDBG(cout << \"size \" << li.size() << endl;);\n\t\t\t\tREP(j,m){\n\t\t\t\t\tll A = v[j].SE.FI;\n\t\t\t\t\tll B = v[j].SE.SE;\n\t\t\t\t\tll C = v[j].FI;\n\t\t\t\t\tll seica = -1;\n\t\t\t\t\tREP(k,li.size())if(sink[h[li[k]].SE] && (A == h[li[k]].SE || B == h[li[k]].SE))seica = li[k];\n\t\t\t\t\tif(seica != -1 && (sink[A] ^ sink[B])){\n\t\t\t\t\t\ttmp += C;\n\t\t\t\t\t\tsink[h[seica].SE] = false;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDBG(cout << \"i \" << i << endl;);\n\t\t\t}\n\t\t\tDBG(cout << \"sink\" << endl;SHOW1d(sink,n);)\n\t\t\tcout << prev + tmp << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define s second\n#define f first\n#define INF 1e9\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> iP;\nint  n,m,e[201][201],h[201],used2[201];\nP h2[201];\n\nint prim(int cnt,int f[201][201]){\n  int res=0,used[201]={};\n  priority_queue <P,vector<P>,greater<P> > Q;\n  Q.push(P(0,h2[n-1].s));\n  \n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    int cost=t.f,pos=t.s;\n    if(used[pos]||used2[pos])continue;\n    used[pos]=1,cnt++,res+=cost;\n    for(int i=0;i<n;i++)if(f[pos][i]<INF)Q.push(P(f[pos][i],i));\n  }\n  if(cnt==n)return res;\n  return 0;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=INF;\n    for(int i=0;i<n;i++) cin>>h[i],h2[i]=P(P(h[i],i));\n    sort(h2,h2+n);\n    for(int i=0,a,b,c;i<m;i++) cin>>a>>b>>c,e[--a][--b]=e[b][a]=c;\n    \n    \n    memset(used2,0,sizeof(used2));\n    int res,ans=prim(0,e),H=0,flg=ans;\n    for(int i=0;i<n&&(res=prim(i,e));i++){\n      int I=h2[i].s;\n      ans=res,H=h[I];\n      for(int j=i--;j<n&&h[h2[j].s]==H;j++) used2[h2[j].s]=1,i++;\n    }\n    for(int i=0;i<n;i++) if(h[i]==H) used2[i]=0;\n    \n    reverse(h2,h2+n);\n    for(int i=0;i<n;i++){\n      int I=h2[i].s,cnt=i;\n      if(!used2[I]) continue;\n      while(cnt+1<n&&h[I]==h[h2[cnt+1].s])cnt++;\n      while(1){\n\tint J,mn=INF;\n\tfor(int j=i;j<=cnt;j++)\n\t  for(int k=0;k<n&&used2[h2[j].s];k++)\n\t    if(!used2[k]&&mn>e[h2[j].s][k])mn=e[h2[j].s][k],J=h2[j].s;\n\tif(mn==INF)break;\n\tans+=mn;\n\tused2[J]=0;\n      }\n      i=cnt;\n    }\n    \n    if(flg) cout <<ans<<endl;\n    else cout <<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\t\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstruct edge {\n\tint u, v, cost;\n\tbool operator<(const edge &e)const {\n\t\treturn vector<int>{cost, u, v} < vector<int>{e.cost, e.u, e.v};\n\t}\n};\n\nint n, m;\n\nvoid solve() {\n\tvector<int> h(n);\n\trep(i, n)cin >> h[i];\n\tvector<P> v; rep(i, n)v.push_back({ h[i],i });\n\tsort(v.begin(), v.end());\n\tvector<edge> u;\n\trep(i, m) {\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\tu.push_back({ a,b,c });\n\t}\n\tsort(u.begin(), u.end());\n\tvector<vector<edge>> key;\n\t//key.push_back(u);\n\trep(i, n) {\n\t\tif (i > 0 && v[i].first == v[i - 1].first)continue;\n\t\t//while (i + 1 < n&&v[i].first == v[i + 1].first)i++;\n\t\tvector<bool> exi(n, true);\n\t\trep(j, i) {\n\t\t\texi[v[j].second] = false;\n\t\t}\n\t\tvector<edge> nex;\n\t\tuf t(n);\n\t\trep(j, m) {\n\t\t\tif (!exi[u[j].u] || !exi[u[j].v])continue;\n\t\t\tif (!t.same(u[j].u, u[j].v)) {\n\t\t\t\tnex.push_back(u[j]);\n\t\t\t\tt.unite(u[j].u, u[j].v);\n\t\t\t}\n\t\t}\n\t\tbool f = true;\n\t\tint root = -1;\n\t\trep(j, n) {\n\t\t\tif (!exi[j])continue;\n\t\t\tif (root < 0) {\n\t\t\t\troot = j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!t.same(root, j))f = false;\n\t\t\t}\n\t\t}\n\t\tif (!f)break;\n\t\tkey.push_back(nex);\n\t}\n\tll ans = 0;\n\tuf t(n);\n\tper(i, (int)key.size()) {\n\t\trep(j, key[i].size()) {\n\t\t\tedge &e = key[i][j];\n\t\t\tif (!t.same(e.u, e.v)) {\n\t\t\t\tans += e.cost;\n\t\t\t\tt.unite(e.u, e.v);\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"answer is \";\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile (cin >>n>>m,n) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nvector<PII> g[205];\nVI t[205];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    REP(i, 205) g[i].clear(), t[i].clear();\n    uf.init(n);\n    VI h(n), hh(n);\n    REP(i, n) cin >> h[i], hh[i] = h[i];\n    VI a(m), b(m), c(m);\n    REP(i, m) {\n      cin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n      g[a[i]].PB({b[i], c[i]});\n      g[b[i]].PB({a[i], c[i]});\n    }\n\n    VI ver(n);\n    sort(ALL(hh));\n    hh.erase(unique(ALL(hh)), hh.end());\n    REP(i, n) h[i] = lower_bound(ALL(hh), h[i]) - hh.begin();\n    REP(i, n) {\n      t[h[i]].PB(i);\n      ver[i] = h[i];\n    }\n\n    VVI edge[205];\n    REP(i, m) edge[min(ver[a[i]], ver[b[i]])].PB({c[i], a[i], b[i]});\n\n    int ans = 0;\n    for(int i=hh.size()-1; i>=0; --i) {\n      // 時間iで沈む頂点に関連する辺集合\n      sort(ALL(edge[i]));\n      for(auto j: edge[i]) {\n        if(uf.same(j[1], j[2])) continue;\n        ans += j[0];\n        uf.unite(j[1], j[2]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n = 0):uf(n, -1) {}\n\n\tint find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tbool unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn false;\n\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\n\t\tuf[y] = x;\n\t\treturn true;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstruct edge {\n\tint u, v, cost;\n\tedge(int u, int v, int c):u(u), v(v), cost(c){}\n\tbool operator<(const edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nint n, m;\nvector<pair<int, int> > hidx;\nvector<edge> es;\nbool alive[200];\nunion_find uf;\n\nbool check() {\n\tunion_find uf2(n);\n\tfor(int i = 0; i < m; ++i)\n\t\tif(alive[es[i].u] && alive[es[i].v])\n\t\t\tuf2.unite(es[i].u, es[i].v);\n\n\tfor(int i = 0; i < n; ++i)\n\t\tfor(int j = i + 1; j < n; ++j)\n\t\t\tif(alive[i] && alive[j] && !uf2.same(i, j))\n\t\t\t\treturn false;\n\n\treturn true;\n}\n\nlong long kruskal() {\n\tlong long  res = 0;\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tconst int u = es[i].u, v = es[i].v;\n\t\tif(alive[u] && alive[v] && uf.unite(u, v))\n\t\t\tres += es[i].cost;\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n >> m, n) {\n\t\thidx.clear();\n\t\thidx.reserve(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\thidx.push_back(make_pair(h, i));\n\t\t}\n\n\t\tes.clear();\n\t\tes.reserve(m);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tes.push_back(edge(a - 1, b - 1, c));\n\t\t}\n\n\t\tsort(hidx.rbegin(), hidx.rend());\n\t\tfill(alive, alive + 200, true);\n\t\tif(!check()) {\n\t\t\tcout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint end = 0;\n\t\tfor(int i = n - 1; i >= 0; --i) {\n\t\t\talive[hidx[i].second] = false;\n\t\t\twhile(i > 0 && hidx[i].first == hidx[i - 1].first) {\n\t\t\t\talive[hidx[--i].second] = false;\n\t\t\t}\n\n\t\t\tif(!check()) {\n\t\t\t\tend = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tsort(es.begin(), es.end());\n\t\tuf = union_find(n);\n\t\tmemset(alive, false, sizeof(alive));\n\t\tlong long ans = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\talive[hidx[i].second] = true;\n\t\t\twhile(i < n - 1 && hidx[i].first == hidx[i + 1].first) {\n\t\t\t\talive[hidx[++i].second] = true;\n\t\t\t}\n\n\t\t\tif(i >= end) {\n\t\t\t\tans += kruskal();\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX = 201;\n\nclass UnionFind{\nprivate:\n  int par[MAX];\n  int rank[MAX];\n\npublic:\n  UnionFind(int n){\n    for(int i=0;i<n;i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  void init(int n){\n    for(int i=0;i<n;i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n\n  bool same(int x, int y){ return find(x) == find(y);}\n};\n\nstruct edge{\n  int u,v,cost;\n  edge(int u=0, int v=0, int c=0):u(u),v(v),cost(c){}\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,m;\nP h[MAX];\nvector<edge> G;\n\nvoid solve(){\n  UnionFind uf(n), uf_cnt(n);\n  int ans = 0;\n  bool f[MAX];\n  fill(f,f+MAX,false);\n  sort(h,h+n);\n  sort(G.begin(),G.end());\n\n  f[h[0].second] = true;\n  for(int i=1;i<n;i++){\n    f[h[i].second] = true;\n    if(i < n - 1 && h[i].first == h[i+1].first) continue;\n\n    for(int j=0;j<m;j++){\n      if(f[G[j].u] && f[G[j].v]) uf_cnt.unite(G[j].u,G[j].v);\n    }\n\n    bool f2 = false;\n    for(int j=0;j<n;j++){\n      if(f[j] && !uf_cnt.same(j, h[0].second)){\n        f2 = true;\n        break;\n      }\n    }\n    if(f2){\n      ans = 0;\n      uf.init(n);\n      continue;\n    }\n\n    for(int j=0;j<m;j++){\n      if(f[G[j].u] && f[G[j].v] && !uf.same(G[j].u,G[j].v)){\n        uf.unite(G[j].u, G[j].v);\n        ans += G[j].cost;\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n >> m && (n|m)){\n    G.clear();\n    for(int i=0;i<n;i++){\n      int a;\n      cin >> a;\n      h[i] = P(-a,i);\n    }\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--;\n      b--;\n      G.push_back(edge(a,b,c));\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ta[210],to[100010],nt[100010],co[100010],f[210],c[210];\nint R=1,C=1,H[2000010],N[2000010];\n//評価関数\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]>N[H[b]]?1:0;\n}\n//挿入関数\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//取り出す関数\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint ud(int s,int t){\n  int i;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(f[to[i]]-(3-t))continue;\n    if(t==1&&c[s    ]>co[i])c[s    ]=co[i];\n    if(t==2&&c[to[i]]>co[i])c[to[i]]=co[i];\n  }\n  f[s]=t;\n}\nint main(){\n  int n,m,i,r,s,t,a,b[210],h[210];\n  while(scanf(\"%d %d\",&n,&m),n){\n    for(i=R=C=1;i<=n;i++){\n      scanf(\"%d\",&a);\n      hin(a);\n      ta[i]=-1;\n      f[i]=0;\n      c[i]=1e9;\n    }\n    for(i=0;i<n;i++)h[i]=N[b[i]=hout()];\n    h[n]=1e9;\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d\",&s,&t,&a);\n      nt[i  ]=ta[to[i+m]=s];\n      nt[i+m]=ta[to[i  ]=t];\n      co[ta[t]=i+m]=co[ta[s]=i]=a;\n    }\n    f[b[0]]=2;\n    c[b[0]]=s=0;\n    r=1;\n    while(r<n){//printf(\"!%d\\n\",r);\n      //for(i=1;i<=n;i++)printf(\"%d,%d \",f[i],c[i]);printf(\"\\n\");\n      a=h[r];\n      while(a==h[r])ud(b[r++],1);\n      while(1){\n\tt=0;\n\tfor(i=1;i<=n;i++){\n\t  if(f[i]-1||c[i]>1e9-10)continue;\n\t  if(t==0||c[t]>c[i])t=i;\n\t}//printf(\"t%d\\n\",t);\n\tif(t==0)break;\n\ts+=c[t];\n\tud(t,2);\n      }\n      //for(i=1;i<=n;i++)printf(\"!%d,%d \",f[i],c[i]);printf(\"\\n\");\n    }\n    for(i=1;i<=n;i++){//printf(\"%d %d\\n\",f[i],c[i]);\n      if(f[i]==1)s=0;\n    }//printf(\"\\n\");\n    printf(\"%d\\n\",s);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2511 Sinking islands\n// 2018.2.28 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 202\n\n/* UNION-FIND library */\nint id[MAX], size[MAX]; int cnt;\nvoid init(int n) { int i; for (i = 0; i < n; i++) id[i] = i, size[i] = 1; }\nint root(int i) { while (i != id[i]) id[i] = id[id[i]], i = id[i]; return i; }\nint connected(int p, int q) { return root(p) == root(q); }\nvoid unite(int p, int q) { int i = root(p), j = root(q); if (i == j) return;\ncnt++; if (size[i] < size[j]) id[i] = j, size[j] += size[i]; else id[j] = i, size[i] += size[j];\n}\n\nint N, M;\nint h[MAX], t[MAX];\ntypedef struct { int a, b, c; } C;\nC c[20000];\nchar mk[MAX];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint tcmp(int *a, int *b) { return *a - *b; }\nint ccmp(C *a, C *b) { return a->c - b->c; }\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint check(int tm)\n{\n\tint i, a, b, s;\n\n\ts = 0; memset(mk, 0, N);\n\tinit(N); cnt = 1;\n\tfor (i = 0; i < N; i++) if (h[i] >= tm && !mk[i]) mk[i] = 1, s++;\n\tfor (i = 0; i < M; i++) {\n\t\ta = c[i].a, b = c[i].b;\n\t\tif (h[a] >= tm && h[b] >= tm &&\t!connected(a, b)) unite(a, b);\n\t\tif (cnt == s) return 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint i, j, k, tsz, tm, ans;\n\tint a, b;\n\n\twhile (N = in()) {\n\t\tinit(N); cnt = 1;\n\n\t\tM = in();\n\t\tfor (i = 0; i < N; i++) h[i] = t[i] = in();\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tc[i].a = a = in()-1, c[i].b = b = in()-1, c[i].c = in();\n\t\t\tunite(a, b);\n\t\t}\n\t\tif (cnt < N) { puts(\"0\"); continue; }\n\n\t\tqsort(t, N, sizeof(int), tcmp);\n\t\ttsz = uniq(t, N);\n\t\tqsort(c, M, sizeof(C), ccmp);\n\n\t\tfor (i = 1; i < tsz; i++) if (check(t[i])) break;\n\t\tk = i-1, tm = t[k];\n\n\t\tans = 0;\n\t\tinit(N);\n\t\tfor (i = 0; i < M; i++) {\n\t\t\ta = c[i].a, b = c[i].b;\n\t\t\tif (h[a] >= tm && h[b] >= tm &&\t!connected(a, b))\n\t\t\t\tans += c[i].c, unite(a, b);\n\t\t}\n\t\tfor (j = k-1; j >= 0; j--) {\n\t\t\tfor (i = 0; i < M; i++) {\n\t\t\t\ta = c[i].a, b = c[i].b;\n\t\t\t\tif (h[a] >= t[j] && h[b] >= t[j] && !connected(a, b))\n\t\t\t\t\tans += c[i].c, unite(a, b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2511 Sinking islands\n// 2018.2.28 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 202\n\n/* UNION-FIND library */\nint id[MAX], size[MAX]; int cnt;\nvoid init(int n) { int i; for (i = 0; i < n; i++) id[i] = i, size[i] = 1; }\nint root(int i) { while (i != id[i]) id[i] = id[id[i]], i = id[i]; return i; }\nint connected(int p, int q) { return root(p) == root(q); }\nvoid unite(int p, int q) { int i = root(p), j = root(q); if (i == j) return;\ncnt++; if (size[i] < size[j]) id[i] = j, size[j] += size[i]; else id[j] = i, size[i] += size[j];\n}\n\nint N, M;\nint h[MAX], t[MAX], t2[MAX], s[MAX];\ntypedef struct { int a, b, c; } C;\nC c[20000];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint tcmp(int *a, int *b) { return *a - *b; }\nint ccmp(C *a, C *b) { return a->c - b->c; }\n\nint uniq(int *a, int n)\n{\n\tint i, j, k;\n\n\ts[0] = N;\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\tk = j; while (j < n && a[j] == a[i]) j++;\n\t\ts[i+1] = s[i] - (j-k+1);\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint check(int id)\n{\n\tint i, a, b, tm;\n\n\tinit(N); cnt = 1;\n\tfor (i = 0; i < M; i++) {\n\t\ta = c[i].a, b = c[i].b;\n\t\tif (h[a] >= t[id] && h[b] >= t[id] && !connected(a, b)) unite(a, b);\n\t\tif (cnt == s[id]) return 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint i, j, k, tsz, tm, ans;\n\tint a, b;\n\n\twhile (N = in()) {\n\t\tinit(N); cnt = 1;\n\n\t\tM = in();\n\t\tfor (i = 0; i < N; i++) h[i] = t[i] = in();\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tc[i].a = a = in()-1, c[i].b = b = in()-1, c[i].c = in();\n\t\t\tunite(a, b);\n\t\t}\n\t\tif (cnt < N) { puts(\"0\"); continue; }\n\n\t\tqsort(t, N, sizeof(int), tcmp);\n\t\ttsz = uniq(t, N);\n\t\tqsort(c, M, sizeof(C), ccmp);\n\n\t\tfor (i = 1; i < tsz; i++) if (check(i)) break;\n\t\tk = i-1, tm = t[k];\n\n\t\tans = 0;\n\t\tinit(N);\n\t\tfor (i = 0; i < M; i++) {\n\t\t\ta = c[i].a, b = c[i].b;\n\t\t\tif (h[a] >= tm && h[b] >= tm &&\t!connected(a, b))\n\t\t\t\tans += c[i].c, unite(a, b);\n\t\t}\n\t\tfor (j = k-1; j >= 0; j--) {\n\t\t\tfor (i = 0; i < M; i++) {\n\t\t\t\ta = c[i].a, b = c[i].b;\n\t\t\t\tif (h[a] >= t[j] && h[b] >= t[j] && !connected(a, b))\n\t\t\t\t\tans += c[i].c, unite(a, b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2511 Sinking islands\n// 2018.2.28 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 202\n\n/* UNION-FIND library */\nint id[MAX], size[MAX]; int cnt;\nvoid init(int n) { int i; for (i = 0; i < n; i++) id[i] = i, size[i] = 1; }\nint root(int i) { while (i != id[i]) id[i] = id[id[i]], i = id[i]; return i; }\nint connected(int p, int q) { return root(p) == root(q); }\nvoid unite(int p, int q) { int i = root(p), j = root(q); if (i == j) return;\ncnt++; if (size[i] < size[j]) id[i] = j, size[j] += size[i]; else id[j] = i, size[i] += size[j];\n}\n\nint N, M;\nint h[MAX], t[MAX], t2[MAX], s[MAX];\ntypedef struct { int a, b, c, t; } C;\nC c[20000], c2[20000];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint tcmp(int *a, int *b) { return *a - *b; }\nint ccmp(C *a, C *b) { return a->c - b->c; }\nint c2cmp(C *a, C *b) { if (b->t - a->t) return b->t - a->t; return a->c - b->c; }\n\nint uniq(int *a, int n)\n{\n\tint i, j, k;\n\n\ts[0] = N;\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\tk = j; while (j < n && a[j] == a[i]) j++;\n\t\ts[i+1] = s[i] - (j-k+1);\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint check(int id)\n{\n\tint i, a, b, tm;\n\n\tinit(N); cnt = 1; tm = t[id];\n\tfor (i = 0; i < M; i++) {\n\t\tif (c2[i].t < tm) break;\n\t\ta = c2[i].a, b = c2[i].b;\n\t\tif (!connected(a, b)) unite(a, b);\n\t\tif (cnt == s[id]) return 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint i, j, k, tsz, tm, ans;\n\tint a, b;\n\n\twhile (N = in()) {\n\t\tinit(N); cnt = 1;\n\n\t\tM = in();\n\t\tfor (i = 0; i < N; i++) h[i] = t[i] = in();\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tc[i].a = a = in()-1, c[i].b = b = in()-1, c[i].c = in();\n\t\t\tif (t[a] <= t[b]) c[i].t = t[a]; else c[i].t = t[b]; \n\t\t\tunite(a, b);\n\t\t}\n\t\tif (cnt < N) { puts(\"0\"); continue; }\n\n\t\tqsort(t, N, sizeof(int), tcmp);\n\t\ttsz = uniq(t, N);\n\t\tmemcpy(c2, c, sizeof(C)*M);\n\t\tqsort(c, M, sizeof(C), ccmp);\n\t\tqsort(c2, M, sizeof(C), c2cmp);\n\n\t\tfor (i = 1; i < tsz; i++) if (check(i)) break;\n\t\tk = i-1, tm = t[k];\n\n\t\tans = 0;\n\t\tinit(N);\n\t\tfor (i = 0; i < M; i++) {\n\t\t\ta = c[i].a, b = c[i].b;\n\t\t\tif (h[a] >= tm && h[b] >= tm && !connected(a, b)) ans += c[i].c, unite(a, b);\n\t\t}\n\t\tfor (j = k-1; j >= 0; j--) {\n\t\t\tfor (i = 0; i < M; i++) {\n\t\t\t\tif (c2[i].t < t[j]) break;\n\t\t\t\ta = c2[i].a, b = c2[i].b;\n\t\t\t\tif (!connected(a, b)) ans += c2[i].c, unite(a, b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ta[210],to[40010],nt[40010],co[40010],f[210],c[210];\nint R=1,C=1,H[2000010],N[2000010];\n//評価関数\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]>N[H[b]]?1:0;\n}\n//挿入関数\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//取り出す関数\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint ud(int s,int t){\n  int i;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(f[to[i]]-(3-t))continue;\n    if(t==1&&c[s    ]>co[i])c[s    ]=co[i];\n    if(t==2&&c[to[i]]>co[i])c[to[i]]=co[i];\n  }\n  f[s]=t;\n}\nint main(){\n  int n,m,i,r,s,t,a,b[210],h[210];\n  while(scanf(\"%d %d\",&n,&m),n){\n    for(i=R=C=1;i<=n;i++){\n      scanf(\"%d\",&a);\n      hin(a);\n      ta[i]=-1;\n      f[i]=0;\n      c[i]=1e9;\n    }\n    for(i=0;i<n;i++)h[i]=N[b[i]=hout()];\n    h[n]=1e9;\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d\",&s,&t,&a);\n      nt[i  ]=ta[to[i+m]=s];\n      nt[i+m]=ta[to[i  ]=t];\n      co[ta[t]=i+m]=co[ta[s]=i]=a;\n    }\n    f[b[0]]=2;\n    c[b[0]]=s=0;\n    r=1;\n    while(r<n){//printf(\"!%d\\n\",r);\n      //for(i=1;i<=n;i++)printf(\"%d,%d \",f[i],c[i]);printf(\"\\n\");\n      a=h[r];\n      while(a==h[r])ud(b[r++],1);\n      while(1){\n\tt=0;\n\tfor(i=1;i<=n;i++){\n\t  if(f[i]-1||c[i]>1e9-10)continue;\n\t  if(t==0||c[t]>c[i])t=i;\n\t}//printf(\"t%d\\n\",t);\n\tif(t==0)break;\n\ts+=c[t];\n\tud(t,2);\n      }\n      //for(i=1;i<=n;i++)printf(\"!%d,%d \",f[i],c[i]);printf(\"\\n\");\n    }\n    for(i=1;i<=n;i++){//printf(\"%d %d\\n\",f[i],c[i]);\n      if(f[i]==1)s=0;\n    }//printf(\"\\n\");\n    printf(\"%d\\n\",s);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define UNION_FIND_MAX 200\n\nint uf_table[UNION_FIND_MAX];\n\nvoid uf_init(void) {\n\tint i;\n\tfor(i=0;i<UNION_FIND_MAX;i++)uf_table[i]=0;\n}\n\nvoid uf_merge(int a,int b) {\n\tint next;\n\twhile(uf_table[a]>0) {\n\t\tnext=uf_table[a]-1;\n\t\tif(uf_table[next]>0)uf_table[a]=uf_table[next];\n\t\ta=next;\n\t}\n\twhile(uf_table[b]>0) {\n\t\tnext=uf_table[b]-1;\n\t\tif(uf_table[next]>0)uf_table[b]=uf_table[next];\n\t\tb=next;\n\t}\n\tif(a!=b)uf_table[a]=b+1;\n}\n\nint uf_issame(int a,int b) {\n\tint next;\n\twhile(uf_table[a]>0) {\n\t\tnext=uf_table[a]-1;\n\t\tif(uf_table[next]>0)uf_table[a]=uf_table[next];\n\t\ta=next;\n\t}\n\twhile(uf_table[b]>0) {\n\t\tnext=uf_table[b]-1;\n\t\tif(uf_table[next]>0)uf_table[b]=uf_table[next];\n\t\tb=next;\n\t}\n\treturn a==b;\n}\n\ntypedef struct {\n\tint id,tb_time;\n} island_t;\n\ntypedef struct {\n\tint a,b,cost;\n} bridge_t;\n\n/* desc */\nint tbt_comp(const void* x,const void* y) {\n\tint tbx=((const island_t*)x)->tb_time;\n\tint tby=((const island_t*)y)->tb_time;\n\tif(tbx<tby)return 1;\n\tif(tbx>tby)return -1;\n\treturn 0;\n}\n\n/* asc */\nint cost_comp(const void* x,const void* y) {\n\tint cx=((const bridge_t*)x)->cost;\n\tint cy=((const bridge_t*)y)->cost;\n\tif(cx>cy)return 1;\n\tif(cx<cy)return -1;\n\treturn 0;\n}\n\nint main(void) {\n\tint N,M;\n\twhile(scanf(\"%d%d\",&N,&M)==2 && (N|M)!=0) {\n\t\tstatic island_t islands[200];\n\t\tstatic int iss_taio[200];\n\t\tstatic bridge_t bridges[200*199];\n\t\tint i,j;\n\t\tint answer;\n\t\tint connect_count;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tislands[i].id=i;\n\t\t\tscanf(\"%d\",&islands[i].tb_time);\n\t\t}\n\t\tfor(i=0;i<M;i++) {\n\t\t\tscanf(\"%d%d%d\",&bridges[i].a,&bridges[i].b,&bridges[i].cost);\n\t\t\tbridges[i].a--;\n\t\t\tbridges[i].b--;\n\t\t}\n\t\tqsort(islands,N,sizeof(island_t),tbt_comp);\n\t\tqsort(bridges,M,sizeof(bridge_t),cost_comp);\n\t\tfor(i=0;i<N;i++)iss_taio[islands[i].id]=i;\n\t\tuf_init();\n\t\tanswer=0;\n\t\tconnect_count=0;\n\t\tfor(i=0;i<N;i++) {\n\t\t\twhile(i+1<N && islands[i].tb_time==islands[i+1].tb_time)i++;\n\t\t\tfor(j=0;j<M;j++) {\n\t\t\t\tif(islands[iss_taio[bridges[j].a]].tb_time>=islands[i].tb_time &&\n\t\t\t\tislands[iss_taio[bridges[j].b]].tb_time>=islands[i].tb_time) {\n\t\t\t\t\tif(!uf_issame(bridges[j].a,bridges[j].b)) {\n\t\t\t\t\t\tuf_merge(bridges[j].a,bridges[j].b);\n\t\t\t\t\t\tanswer+=bridges[j].cost;\n\t\t\t\t\t\tconnect_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(connect_count<i) {\n\t\t\t\t/* can't connect all islands */\n\t\t\t\tuf_init();\n\t\t\t\tanswer=0;\n\t\t\t\tconnect_count=0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2511 Sinking islands\n// 2018.2.28 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 202\n\n/* UNION-FIND library */\nint id[MAX], size[MAX]; int cnt;\nvoid init(int n) { int i; for (i = 0; i < n; i++) id[i] = i, size[i] = 1; }\nint root(int i) { while (i != id[i]) id[i] = id[id[i]], i = id[i]; return i; }\nint connected(int p, int q) { return root(p) == root(q); }\nvoid unite(int p, int q) { int i = root(p), j = root(q); if (i == j) return;\ncnt++; if (size[i] < size[j]) id[i] = j, size[j] += size[i]; else id[j] = i, size[i] += size[j];\n}\n\nint N, M;\nint h[MAX], t[MAX], t2[MAX], s[MAX];\ntypedef struct { int a, b, c, t; } C;\nC c[20000], c2[20000];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint tcmp(int *a, int *b) { return *a - *b; }\nint ccmp(C *a, C *b) { return a->c - b->c; }\nint c2cmp(C *a, C *b) { if (b->t - a->t) return b->t - a->t; return a->c - b->c; }\n\nint uniq(int *a, int n)\n{\n\tint i, j, k;\n\n\ts[0] = N;\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\tk = j; while (j < n && a[j] == a[i]) j++;\n\t\ts[i+1] = s[i] - (j-k+1);\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint check(int id)\n{\n\tint i, a, b, tm;\n\n\tinit(N); cnt = 1; tm = t[id];\n\tfor (i = 0; i < M; i++) {\n\t\tif (c2[i].t < tm) break;\n\t\ta = c2[i].a, b = c2[i].b;\n\t\tif (!connected(a, b)) unite(a, b);\n\t\tif (cnt == s[id]) return 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint i, j, k, tsz, tm, ans;\n\tint a, b;\n\n\twhile (N = in()) {\n\t\tinit(N); cnt = 1;\n\n\t\tM = in();\n\t\tfor (i = 0; i < N; i++) h[i] = t[i] = in();\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tc[i].a = a = in()-1, c[i].b = b = in()-1, c[i].c = in();\n\t\t\tif (t[a] <= t[b]) c[i].t = t[a]; else c[i].t = t[b]; \n\t\t\tunite(a, b);\n\t\t}\n\t\tif (cnt < N) { puts(\"0\"); continue; }\n\n\t\tqsort(t, N, sizeof(int), tcmp);\n\t\ttsz = uniq(t, N);\n\t\tmemcpy(c2, c, sizeof(C)*M);\n\t\tqsort(c, M, sizeof(C), ccmp);\n\t\tqsort(c2, M, sizeof(C), c2cmp);\n\n\t\tfor (i = 1; i < tsz; i++) if (check(i)) break;\n\t\tk = i-1, tm = t[k];\n\n\t\tans = 0;\n\t\tinit(N);\n\t\tfor (i = 0; i < M; i++) {\n\t\t\ta = c[i].a, b = c[i].b;\n\t\t\tif (h[a] >= tm && h[b] >= tm && !connected(a, b)) ans += c[i].c, unite(a, b);\n\t\t}\n\t\ti = 0; while (c2[i].t >= tm) i++;\n\t\tfor (j = k-1; j >= 0; j--) {\n\t\t\twhile (c2[i].t > t[j]) i++;\n\t\t\twhile (c2[i].t == t[j]) {\n\t\t\t\ta = c2[i].a, b = c2[i].b;\n\t\t\t\tif (!connected(a, b)) ans += c2[i].c, unite(a, b);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define UNION_FIND_MAX 200\n \nint uf_table[UNION_FIND_MAX];\n \nvoid uf_init(void) {\n    int i;\n    for(i=0;i<UNION_FIND_MAX;i++)uf_table[i]=0;\n}\n \nvoid uf_merge(int a,int b) {\n    int next;\n    while(uf_table[a]>0) {\n        next=uf_table[a]-1;\n        if(uf_table[next]>0)uf_table[a]=uf_table[next];\n        a=next;\n    }\n    while(uf_table[b]>0) {\n        next=uf_table[b]-1;\n        if(uf_table[next]>0)uf_table[b]=uf_table[next];\n        b=next;\n    }\n    if(a!=b)uf_table[a]=b+1;\n}\n \nint uf_issame(int a,int b) {\n    int next;\n    while(uf_table[a]>0) {\n        next=uf_table[a]-1;\n        if(uf_table[next]>0)uf_table[a]=uf_table[next];\n        a=next;\n    }\n    while(uf_table[b]>0) {\n        next=uf_table[b]-1;\n        if(uf_table[next]>0)uf_table[b]=uf_table[next];\n        b=next;\n    }\n    return a==b;\n}\n \ntypedef struct {\n    int id,tb_time;\n} island_t;\n \ntypedef struct {\n    int a,b,cost;\n} bridge_t;\n \n/* desc */\nint tbt_comp(const void* x,const void* y) {\n    int tbx=((const island_t*)x)->tb_time;\n    int tby=((const island_t*)y)->tb_time;\n    if(tbx<tby)return 1;\n    if(tbx>tby)return -1;\n    return 0;\n}\n \n/* asc */\nint cost_comp(const void* x,const void* y) {\n    int cx=((const bridge_t*)x)->cost;\n    int cy=((const bridge_t*)y)->cost;\n    if(cx>cy)return 1;\n    if(cx<cy)return -1;\n    return 0;\n}\n \nint main(void) {\n    int N,M;\n    while(scanf(\"%d%d\",&N,&M)==2 && (N|M)!=0) {\n        static island_t islands[200];\n        static int iss_taio[200];\n        static bridge_t bridges[200*199];\n        int i,j;\n        int answer;\n        int connect_count;\n        for(i=0;i<N;i++) {\n            islands[i].id=i;\n            scanf(\"%d\",&islands[i].tb_time);\n        }\n        for(i=0;i<M;i++) {\n            scanf(\"%d%d%d\",&bridges[i].a,&bridges[i].b,&bridges[i].cost);\n            bridges[i].a--;\n            bridges[i].b--;\n        }\n        qsort(islands,N,sizeof(island_t),tbt_comp);\n        qsort(bridges,M,sizeof(bridge_t),cost_comp);\n        for(i=0;i<N;i++)iss_taio[islands[i].id]=i;\n        uf_init();\n        answer=0;\n        connect_count=0;\n        for(i=0;i<N;i++) {\n            while(i+1<N && islands[i].tb_time==islands[i+1].tb_time)i++;\n            for(j=0;j<M;j++) {\n                if(islands[iss_taio[bridges[j].a]].tb_time>=islands[i].tb_time &&\n                islands[iss_taio[bridges[j].b]].tb_time>=islands[i].tb_time) {\n                    if(!uf_issame(bridges[j].a,bridges[j].b)) {\n                        uf_merge(bridges[j].a,bridges[j].b);\n                        answer+=bridges[j].cost;\n                        connect_count++;\n                    }\n                }\n            }\n            if(connect_count<i) {\n                /* can't connect all islands */\n                uf_init();\n                answer=0;\n                connect_count=0;\n            }\n        }\n        printf(\"%d\\n\",answer);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nclass UnionFind(val size: Int){\n    private val array = IntArray(size){-1}\n    fun find(a: Int): Int {\n        if (array[a] < 0) return a\n        array[a] = find(array[a])\n        return array[a]\n    }\n    fun isSame(a: Int, b: Int): Boolean {\n        return find(a) == find(b)\n    }\n    fun merge(a: Int, b: Int): Unit {\n        val ar = find(a)\n        val br = find(b)\n        if (ar != br) {\n            if (array[ar] < array[br]){\n                array[ar] += array[br]\n                array[br] = ar\n            }else{\n                array[br] += array[ar]\n                array[ar] = br\n            }\n        }\n    }\n}\nclass PersistentUnionFind(val size: Int) {\n    private val parentOrSize = IntArray(size){-1}\n    private val mergeTime = IntArray(size){Int.MIN_VALUE}\n    fun parentAt(a: Int, time: Int): Int {\n        var current = a\n        while(mergeTime[current] >= -time) {\n            current = parentOrSize[current]\n        }\n        return current\n    }\n    fun timeWhenMerged(a: Int, b: Int): Int? {\n        var ca = a\n        var cb = b\n        var lastTime = 0\n        while(ca != cb && (parentOrSize[ca] >= 0 || parentOrSize[cb] >= 0)) {\n            if (mergeTime[ca] > mergeTime[cb]) {\n                lastTime = mergeTime[ca]\n                ca = parentOrSize[ca]\n            }else {\n                lastTime = mergeTime[cb]\n                cb = parentOrSize[cb]\n            }\n        }\n        return if (ca != cb) null else -lastTime\n    }\n    fun currentParent(a: Int): Int {\n        return if (parentOrSize[a] < 0) a\n        else currentParent(parentOrSize[a])\n    }\n    fun mergeAt(a: Int, b: Int, time: Int): Unit {\n        val ar = currentParent(a)\n        val br = currentParent(b)\n        if (ar != br) {\n            if (parentOrSize[ar] < parentOrSize[br]) {\n                parentOrSize[ar] += parentOrSize[br]\n                parentOrSize[br] = ar\n                mergeTime[br] = -time\n            }else {\n                parentOrSize[br] += parentOrSize[ar]\n                parentOrSize[ar] = br\n                mergeTime[ar] = -time\n            }\n        }\n    }\n}\ndata class Bridge(val from: Int, val to: Int, val cost: Int)\nfun main(args: Array<String>?): Unit{\n    problem@ while(true){\n        val (n, m) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (n == 0 && m == 0) return\n        val islands = IntArray(n){readLine()!!.trim().toInt()}\n        val bridges = List(m){\n            val (a, b, c) = readLine()!!.trim().split(' ').map(String::toInt)\n            Bridge(a - 1, b - 1, c)\n        }.sortedByDescending{Math.min(islands[it.from], islands[it.to])}\n        val persistentUnionFind = PersistentUnionFind(n)\n        val lastIsland = islands.indices.maxBy(islands::get)!!\n        for ((a, b, _) in bridges) {\n            persistentUnionFind.mergeAt(a, b, islands[lastIsland] - Math.min(islands[a], islands[b]))\n        }\n        var lastTime = islands[lastIsland]\n        for (i in 1 until n) {\n            val mergeTime = persistentUnionFind.timeWhenMerged(lastIsland, (lastIsland + i) % n)\n            if (mergeTime == null) {\n                println(0)\n                continue@problem\n            }\n            if (mergeTime > islands[lastIsland] - islands[(lastIsland + i) % n] && lastTime > islands[lastIsland] - mergeTime) {\n                lastTime = islands[lastIsland] - mergeTime\n            }\n        }\n        val union = UnionFind(n)\n        var cost = 0\n        val (after, before) = bridges.partition { b -> Math.min(islands[b.from], islands[b.to]) >= lastTime  }\n        for ((a, b, c) in after.sortedBy(Bridge::cost)) {\n            if (!union.isSame(a, b)) {\n                union.merge(a, b)\n                cost += c\n                //println(\"${a + 1} ${b + 1} $c\")\n            }\n        }\n        val queue = PriorityQueue<Bridge>(compareBy(Bridge::cost))\n        var current = 0\n        while(current < before.size) {\n            queue.add(before[current])\n            while(current + 1 < before.size && Math.min(islands[before[current].from], islands[before[current].to]) == Math.min(islands[before[current + 1].from], islands[before[current + 1].to])) {\n                queue.add(before[++current])\n            }\n            while(queue.isNotEmpty()) {\n                val (a, b, c) = queue.poll()\n                if (!union.isSame(a, b)) {\n                    union.merge(a, b)\n                    cost += c\n                    //println(\"${a + 1} ${b + 1} $c\")\n                }\n            }\n            ++current\n        }\n        println(cost)\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tstatic ContestScanner in;\n\tstatic Writer out;\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\ttry {\n\t\t\tin = new ContestScanner();\n\t\t\tout = new Writer();\n\t\t\tmain.solve();\n\t\t\tout.close();\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tvoid solve() throws IOException {\n\t\twhile(true) {\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tIsl[] isl = new Isl[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tisl[i] = new Isl(i, in.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1;\n\t\t\t\tint b = in.nextInt() - 1;\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tif(isl[a].h > isl[b].h) {\n\t\t\t\t\tint tmp = a;\n\t\t\t\t\ta = b;\n\t\t\t\t\tb = tmp;\n\t\t\t\t}\n\t\t\t\tisl[a].edge.add(new Edge(a, b, c));\n\t\t\t}\n\t\t\tint ans = getAmount(n, m, isl);\n\t\t\tif(ans < 0) {\n\t\t\t\tfor(int i = 0; i <= -ans; i++) {\n\t\t\t\t\tisl[i].h = isl[-ans + 1].h;\n\t\t\t\t}\n\t\t\t\tans = getAmount(n, m, isl);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tint getAmount(int n, int m, Isl[] isl) {\n\t\tArrays.sort(isl);\n\t\tPriorityQueue<Edge> pq = new PriorityQueue<>();\n\t\tUnionFind uf = new UnionFind(n);\n\t\tint cost = 0;\n\t\tint group = 0;\n\t\tint last = -1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpq.addAll(isl[i].edge);\n\t\t\tgroup++;\n\t\t\tif(i < n - 1 && isl[i + 1].h == isl[i].h)\n\t\t\t\tcontinue;\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tEdge e = pq.poll();\n\t\t\t\tif(uf.same(e.from, e.to)) continue;\n\t\t\t\tgroup--;\n\t\t\t\tcost += e.cost;\n\t\t\t\tuf.unite(e.from, e.to);\n//\t\t\t\tout.printf(\"use: %d - %d (%d)\\n\", e.from + 1, e.to + 1, e.cost);\n\t\t\t}\n\t\t\tif(group >= 2) {\n\t\t\t\tlast = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n ; i++) {\n\t\t\tif(!uf.same(0, i)) return 0;\n\t\t}\n\t\treturn last == -1 ? cost : -last;\n\t}\n}\n\nclass Isl implements Comparable<Isl> {\n\tint id, h;\n\tList<Edge> edge;\n\tpublic Isl(int id, int h) {\n\t\tthis.id = id;\n\t\tthis.h = h;\n\t\tedge = new ArrayList<>();\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Isl o) {\n\t\treturn o.h - h;\n\t}\n}\n\nclass Edge implements Comparable<Edge> {\n\tint from, to, cost;\n\tpublic Edge(int from, int to, int cost) {\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn cost - o.cost;\n\t}\n}\n\nclass UnionFind{\n\tint[] par;\n\tint[] rank;\n\tUnionFind(int n){\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x] > rank[y]) par[x] = y;\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\tboolean same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Iku {\n    int dist;\n    int cost;\n  }\n\n  int cal(int n, List<List<Iku>> adj, List<List<Integer>> t) {\n    UnionFind uf = new UnionFind(n + 1);\n    HashSet<Integer> added = new HashSet<>(n * 2);\n    ArrayList<Integer> list = new ArrayList<>();\n    int max = -1;\n    int index = 0;\n    for (List<Integer> comer : t) {\n      list.addAll(comer);\n      added.addAll(comer);\n      for (; ; ) {\n        int a = -1;\n        int b = -1;\n        int c = INF;\n        for (Integer ite : list) {\n          for (Iku iku : adj.get(ite)) {\n            if (!added.contains(iku.dist)) {\n              continue;\n            }\n            if (uf.same(ite, iku.dist)) {\n              continue;\n            }\n            if (c > iku.cost) {\n              c = iku.cost;\n              a = ite;\n              b = iku.dist;\n            }\n          }\n        }\n        if (a == -1) {\n          break;\n        }\n        uf.union(a, b);\n      }\n      boolean flag = true;\n      for (Integer a : list) {\n        flag &= uf.same(list.get(0), a);\n      }\n      if (!flag) {\n        max = index;\n      }\n      ++index;\n    }\n    return max + 1;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      int m = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] h = new int[n];\n      TreeSet<Integer> set = new TreeSet<>();\n      for (int i = 0; i < n; ++i) {\n        h[i] = ni();\n        set.add(h[i]);\n      }\n      TreeMap<Integer, Integer> map = new TreeMap<>();\n      {\n        int index = 0;\n        for (Integer v : set.descendingSet()) {\n          map.put(v, index++);\n        }\n      }\n      List<List<Integer>> t = new ArrayList<>();\n      for (int i = 0; i < set.size(); ++i) {\n        t.add(new LinkedList<>());\n      }\n      for (int i = 0; i < n; ++i) {\n        t.get(map.get(h[i])).add(i + 1);\n      }\n      List<List<Iku>> adj = new ArrayList<>();\n      for (int i = 0; i <= n; ++i) {\n        adj.add(new LinkedList<>());\n      }\n      for (int i = 0; i < m; ++i) {\n        int a = ni();\n        int b = ni();\n        if (a > b) {\n          int tmp = a;\n          a = b;\n          b = tmp;\n        }\n        int c = ni();\n        Iku iku = new Iku();\n        iku.dist = b;\n        iku.cost = c;\n        adj.get(a).add(iku);\n      }\n      int s = cal(n, adj, t);\n      UnionFind uf = new UnionFind(n + 1);\n      HashSet<Integer> added = new HashSet<>(n * 2);\n      ArrayList<Integer> list = new ArrayList<>();\n      int sum = 0;\n      for (int i = 0; i < s; ++i) {\n        List<Integer> comer = t.get(i);\n        list.addAll(comer);\n        added.addAll(comer);\n      }\n      for (int i = s; i < t.size(); ++i) {\n        List<Integer> comer = t.get(i);\n        list.addAll(comer);\n        added.addAll(comer);\n        for (; ; ) {\n          int a = -1;\n          int b = -1;\n          int c = INF;\n          for (Integer ite : list) {\n            for (Iku iku : adj.get(ite)) {\n              if (!added.contains(iku.dist)) {\n                continue;\n              }\n              if (uf.same(ite, iku.dist)) {\n                continue;\n              }\n              if (c > iku.cost) {\n                c = iku.cost;\n                a = ite;\n                b = iku.dist;\n              }\n            }\n          }\n          if (a == -1) {\n            break;\n          }\n          uf.union(a, b);\n          sum += c;\n        }\n      }\n      System.out.println(sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(par[x]);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m) == 0) break;\n\t\t\t\n\t\t\tHashMap<Integer, ArrayList<Integer>> map = new HashMap<Integer, ArrayList<Integer>>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tif(map.containsKey(h))\n\t\t\t\t\tmap.get(h).add(i);\n\t\t\t\telse {\n\t\t\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\tlist.add(i);\n\t\t\t\t\tmap.put(h, list);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSink[] sink = new Sink[map.size()]; int p=0;\n\t\t\tfor(Map.Entry<Integer, ArrayList<Integer>> entry: map.entrySet()) {\n\t\t\t\tsink[p++] = new Sink(entry.getKey(), entry.getValue());\n\t\t\t}\n\t\t\tsort(sink);\n\t\t\t\n\t\t\tG[] g = new G[n];\n\t\t\tfor(int i=0;i<n;i++) g[i] = new G();\n\t\t\tE[] es = new E[m];\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1, b = sc.nextInt()-1, c = sc.nextInt();\n\t\t\t\tg[a].add(new E(a, b, c));\n\t\t\t\tg[b].add(new E(b, a, c));\n\t\t\t\tes[i] = new E(a, b, c);\n\t\t\t}\n\t\t\t\n\t\t\tUF uf = new UF(n);\n\t\t\tboolean[] used = new boolean[n];\n\t\t\tArrayList<Integer> l = new ArrayList<Integer>();\n\t\t\tint con = 0;\n\t\t\tfor(p=0;p<sink.length;p++) {\n\t\t\t\tfor(int v: sink[p].l) {\n\t\t\t\t\tused[v] = true;\n\t\t\t\t\tl.add(v);\n\t\t\t\t}\n\t\t\t\tfor(int v: sink[p].l) for(E e: g[v])if(used[e.f] && used[e.t]){\n\t\t\t\t\tuf.unite(e.f, e.t);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tint val = uf.find(l.get(0));\n\t\t\t\tfor(int i: l) flg &= val == uf.find(i);\n\t\t\t\tif(!flg) con = p;\n\t\t\t}\n\t\t\tfill(used, false);\n\t\t\tif(con==sink.length-1) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<con+2;i++){\n\t\t\t\tfor(int j: sink[i].l)used[j] = true;\n\t\t\t}\n\t\t\tuf = new UF(n);\n\t\t\tsort(es);\n\t\t\tint ans = 0;\n\t\t\tfor(int i=con+2;;i++) {\n\t\t\t\tfor(E e: es) if(used[e.f] && used[e.t] && !uf.same(e.f, e.t)) {\n\t\t\t\t\tuf.unite(e.f, e.t);\n\t\t\t\t\tans += e.c;\n\t\t\t\t}\n\t\t\t\tif(i>=sink.length) break;\n\t\t\t\tfor(int j: sink[i].l) used[j] = true;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tclass UF {\n\t\tint[] par, rank;\n\t\t\n\t\tpublic UF(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor(int i=0;i<n;i++) par[i] = i;\n\t\t}\n\t\t\n\t\t//代表元を求める\n\t\tint find(int x) {\n\t\t\tif( par[x] == x ) return x;\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t\t\n\t\t//要素xとyを併合する\n\t\tvoid unite(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif( x == y ) return;\n\t\t\t\n\t\t\tif( rank[x] < rank[y]  ) par[x] = y;\n\t\t\telse {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif( rank[x] == rank[y] ) rank[x]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//同一の集合に含まれるか調べる．trueならxとyは同じ集合，falseなら異なる\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\t\n\tclass G extends ArrayList<E>{}\n\t\n\tclass E implements Comparable<E>{\n\t\tint f, t, c;\n\t\tE(int f, int t, int c) {\n\t\t\tthis.f = f; this.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn c - o.c;\n\t\t}\n\t}\n\t\n\tclass Sink implements Comparable<Sink>{\n\t\tint d; ArrayList<Integer> l;\n\t\tSink(int d, ArrayList<Integer> l) {\n\t\t\tthis.d = d;\n\t\t\tthis.l = l;\n\t\t}\n\t\tpublic int compareTo(Sink o) {\n\t\t\treturn o.d - d;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int N, M;\n\tstatic int[] link, size;\n\t\n\tstatic class H implements Comparable<H>{\n\t\tint land, time;\n\t\tH(int land, int time){\n\t\t\tthis.land=land;\n\t\t\tthis.time=time;\n\t\t}\n\t\tpublic int compareTo(H s) {\n\t\t\treturn s.time-this.time;//消える時間降順\n\t\t}\n\t}\n\t\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint u, v, cost;\n\t\tEdge(int u, int v, int cost){\n\t\t\tthis.u=u;\n\t\t\tthis.v=v;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\tpublic int compareTo(Edge e){\n\t\t\treturn this.cost-e.cost;\n\t\t}//辺の重さ昇順\n\t}\n\t\n\tstatic void init() {\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tlink[i]=i;\n\t\t\tsize[i]=1;\n\t\t}\n\t}\n\tstatic int find(int x) {\n\t\twhile(x!=link[x]) x=link[x];\n\t\treturn x;\n\t}\n\tstatic boolean same(int a, int b) {\n\t\treturn find(a)==find(b);\n\t}\n\tstatic void unite(int a, int b) {\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(size[a]<size[b]) {\n\t\t\tint k=a;\n\t\t\ta=b;\n\t\t\tb=k;\n\t\t}\n\t\tsize[a]+=size[b];\n\t\tlink[b]=a;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tif(N+M==0) break;\n\t\t\t\tlink=new int[N+1];\n\t\t\t\tsize=new int[N+1];\n\t\t\t\tint[] ht=new int[N];\n\t\t\t\tH[] h=new H[N];\n\t\t\t\tEdge[] pq=new Edge[M];\n\t\t\t\tint[][] dis=new int[N+1][N+1];\n\t\t\t\tPriorityQueue<H> pq1=new PriorityQueue<>();\n\t\t\t\tfor(int i=0; i<N; i++) {\n\t\t\t\t\tint time=sc.nextInt();\n\t\t\t\t\tht[i]=time;\n\t\t\t\t\th[i]=(new H(i, time));\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<M; i++) {\n\t\t\t\t\tint a=sc.nextInt();\n\t\t\t\t\tint b=sc.nextInt();\n\t\t\t\t\tint c=sc.nextInt();\n\t\t\t\t\tpq[i]=(new Edge(a-1, b-1, c));\n\t\t\t\t}\n\t\t\t\tArrays.sort(h);\n\t\t\t\tArrays.sort(pq);\n\t\t\t\tinit();\n\t\t\t\tint ans=0, count=0;\n\t\t\t\tfor(int i=0; i<N; i++) {//時刻ごとに毎回minimum spanning tree\n\t\t\t\t\tint at=h[i].land;\n\t\t\t\t\tint now=h[i].time;\n\t\t\t\t\tif(i==N-1 || now!=h[i+1].time) {//次が同時に沈まないときそれまでのを処理しちゃう\n\t\t\t\t\t\tfor(int j=0; j<M; j++) {\n\t\t\t\t\t\t\tint l=pq[j].u;\n\t\t\t\t\t\t\tint r=pq[j].v;\n\t\t\t\t\t\t\tif(ht[l]>=now && ht[r]>=now && !same(l, r)) {\n\t\t\t\t\t\t\t\tans+=pq[j].cost;\n\t\t\t\t\t\t\t\tunite(l, r);\n\t\t\t\t\t\t\t\t//System.out.println(Arrays.toString(link));\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(count!=i) {//辺と(頂点-1)の数合わない＝やり直し\n\t\t\t\t\t\t\tcount=0;\n\t\t\t\t\t\t\tans=0;\n\t\t\t\t\t\t\tinit();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\n\t\t}\n\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Island implements Comparable<Island>{\n\t\tint island;\n\t\tint sink;\n\t\t\n\t\tpublic Island(int island, int sink) {\n\t\t\tsuper();\n\t\t\tthis.island = island;\n\t\t\tthis.sink = sink;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Island o) {\n\t\t\treturn o.sink - this.sink;\n\t\t}\n\t}\n\t\n\tpublic static int prim(boolean[] treed, boolean[] sinked, int[] costs, final int N, int[][] adj){\n\t\tint sum = 0;\n\t\t\n\t\twhile(true){\n\t\t\tArrays.fill(costs, Integer.MAX_VALUE);\n\t\t\t\n\t\t\tfor(int from = 0; from < N; from++){\n\t\t\t\tif(!treed[from]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int to = 0; to < N; to++){\n\t\t\t\t\tif(from == to){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(treed[to]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(!sinked[to]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcosts[to] = Math.min(costs[to], adj[from][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint min_pos = -1;\n\t\t\tfor(int node = 0; node < N; node++){\n\t\t\t\tif(min > costs[node]){\n\t\t\t\t\tmin = costs[node];\n\t\t\t\t\tmin_pos = node;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(min_pos == -1){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\ttreed[min_pos] = true;\n\t\t\t\tsum += min;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(treed[i] != sinked[i]){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0 && M == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Island> queue = new PriorityQueue<Main.Island>();\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tqueue.add(new Island(i, sc.nextInt()));\n\t\t\t}\n\t\t\t\n\t\t\tint[][] adj = new int[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\tadj[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tfinal int a = sc.nextInt() - 1;\n\t\t\t\tfinal int b = sc.nextInt() - 1;\n\t\t\t\tfinal int c = sc.nextInt();\n\t\t\t\t\n\t\t\t\tadj[a][b] = adj[b][a] = c;\n\t\t\t}\n\t\t\t\n\t\t\tint cost = 0;\n\t\t\tboolean[] sinked = new boolean[N];\n\t\t\tboolean[] treed  = new boolean[N];\n\t\t\tint[] costs = new int[N];\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tint prev_time = -1;\n\t\t\t\tboolean first_time = true;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\twhile(!queue.isEmpty() && (prev_time == -1 || prev_time == queue.peek().sink)){\n\t\t\t\t\tfinal Island sink = queue.poll();\n\t\t\t\t\tsinked[sink.island] = true;\n\t\t\t\t\tprev_time = sink.sink;\n\t\t\t\t\t\n\t\t\t\t\tif(cost == 0 && first_time){\n\t\t\t\t\t\tfirst_time = false;\n\t\t\t\t\t\ttreed[sink.island] = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int ret = prim(treed, sinked, costs, N, adj);\n\t\t\t\t//System.out.println(Arrays.toString(sinked) + \" \" + Arrays.toString(treed));\n\t\t\t\t\n\t\t\t\tif(ret == 0){\n\t\t\t\t\tArrays.fill(treed, false);\n\t\t\t\t\tcost = 0;\n\t\t\t\t}else{\n\t\t\t\t\tcost += ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cost);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[][] g;\n\tstatic boolean[] dead;\n\tstatic int N;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tg = new int[N][N];\n\t\t\tdead = new boolean[N];\n\t\t\tint M = sc.nextInt();\n\t\t\tSink[] sk = new Sink[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tsk[i] = new Sink(sc.nextInt(), i);\n\t\t\t}\n\t\t\tArrays.sort(sk);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tg[a][b] = g[b][a] = c;\n\t\t\t}\n\t\t\tif (!connect(N)) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint pos = 0;\n\t\t\twhile (pos < N) {\n\t\t\t\tint pp = pos;\n\t\t\t\tint t = sk[pos].t;\n\t\t\t\twhile (pos < N && sk[pos].t == t) {\n\t\t\t\t\tdead[sk[pos].i] = true;\n\t\t\t\t\t++pos;\n\t\t\t\t}\n\t\t\t\tif (!connect(N - pos)) {\n\t\t\t\t\tfor (int i = pp; i < pos; ++i) {\n\t\t\t\t\t\tdead[sk[i].i] = false;\n\t\t\t\t\t}\n\t\t\t\t\tpos = pp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrayList<Integer> from = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> to = new ArrayList<Integer>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (!dead[i]) to.add(i);\n\t\t\t}\n\t\t\tfrom.add(to.get(to.size() - 1));\n\t\t\tto.remove(to.size() - 1);\n\t\t\tint ans = mst(from, to);\n\t\t\tfrom.addAll(to);\n\t\t\twhile (pos > 0) {\n\t\t\t\tto.clear();\n\t\t\t\tint t = sk[pos - 1].t;\n\t\t\t\twhile (pos > 0 && sk[pos - 1].t == t) {\n\t\t\t\t\tdead[sk[pos - 1].i] = false;\n\t\t\t\t\tto.add(sk[pos - 1].i);\n\t\t\t\t\t--pos;\n\t\t\t\t}\n\t\t\t\tans += mst(from, to);\n\t\t\t\tfrom.addAll(to);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic boolean connect(int rest) {\n\t\tint st = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!dead[i]) {\n\t\t\t\tst = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tboolean[] used = new boolean[N];\n\t\tArrayList<Integer> pos = new ArrayList<Integer>();\n\t\tpos.add(st);\n\t\tint c = 0;\n\t\twhile (c != pos.size()) {\n\t\t\tint cur = pos.get(c);\n\t\t\t++c;\n\t\t\tused[cur] = true;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dead[i] || used[i]) continue;\n\t\t\t\tif (g[cur][i] == 0) continue;\n\t\t\t\tpos.add(i);\n\t\t\t\tused[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn c == rest;\n\t}\n\n\tstatic int mst(ArrayList<Integer> from, ArrayList<Integer> to) {\n\t\tboolean[] used = new boolean[N];\n\t\tPriorityQueue<Long> q = new PriorityQueue<Long>();\n\t\tfor (int v : from) {\n\t\t\tq.add((long) v);\n\t\t}\n\t\tint sum = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tlong cur = q.poll();\n\t\t\tint ci = (int) cur;\n\t\t\tint cc = (int) (cur >> 32);\n\t\t\tif (used[ci]) continue;\n\t\t\tsum += cc;\n\t\t\tused[ci] = true;\n\t\t\tfor (int v : to) {\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tif (g[ci][v] == 0) continue;\n\t\t\t\tq.add((((long) g[ci][v]) << 32) + v);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tstatic class Sink implements Comparable<Sink> {\n\t\tint t, i;\n\n\t\tpublic Sink(int t, int i) {\n\t\t\tthis.t = t;\n\t\t\tthis.i = i;\n\t\t}\n\n\t\tpublic int compareTo(Sink o) {\n\t\t\treturn this.t - o.t;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tstatic int N, M;\n\tstatic ArrayList<Integer[]> Sink;\n\tstatic ArrayList<Integer[]> Bridge;\n\t\n\tstatic int[] uf;\n\t\n\tstatic private void union(int a, int b)\n\t{\n\t\tif(uf[a] == uf[b]) return;\n\t\t\n\t\tif(uf[a] < uf[b])\n\t\t{\n\t\t\tint modify = uf[b];\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif(uf[i] == modify) uf[i] = uf[a];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint modify = uf[a];\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif(uf[i] == modify) uf[i] = uf[b];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic private void solve()\n\t{\n\t\tuf = new int[N+1];\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tuf[i] = i;\n\t\t}\n\t\t\n\t\tboolean init = true;\n\t\tHashSet<Integer> hs = new HashSet<Integer>();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\n\t\t\tInteger[] island = Sink.get(i);\n\t\t\ths.add(island[0]);\n\t\t\t\n\t\t\tfor (int j = i+1; j < N; j++) {\n\t\t\t\tInteger[] tmp = Sink.get(j);\n\t\t\t\tif(tmp[1].intValue() == island[1].intValue())\n\t\t\t\t{\n\t\t\t\t\ths.add(tmp[0]);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(init)\n\t\t\t{\n\t\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\t\tuf[j] = j;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (Integer[] b : Bridge) {\n\t\t\t\t\tb[3] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (Integer[] b : Bridge) {\n\t\t\t\tif(b[3].intValue() == 1) continue;\n\t\t\t\tif(!hs.contains(b[0]) || !hs.contains(b[1])) continue;\n\t\t\t\tif(uf[b[0]] == uf[b[1]]) continue;\n\t\t\t\t\n\t\t\t\tb[3] = 1;\n\t\t\t\tunion(b[0], b[1]);\n\t\t\t}\n\t\t\t\n\t\t\tint index = -1;\n\t\t\tboolean preinit = false;\n\t\t\tfor (Integer tmp : hs) {\n\t\t\t\tif(index < 0)\n\t\t\t\t{\n\t\t\t\t\tindex = uf[tmp];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(index != uf[tmp]) preinit = true;\n\t\t\t}\n\t\t\tinit = preinit;\n\t\t\t\n\t\t\t//System.err.println(\"break\");\n\t\t}\n\t\t\n\t\tint index = uf[1];\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tif(uf[i] != index)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cost = 0;\n\t\tfor (Integer[] i : Bridge) {\n\t\t\tif(i[3] == 1) cost += i[2];\n\t\t}\n\t\t\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tstatic public void main(String[] args)\n\t{\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\t\n\t\t\tN = sca.nextInt();\n\t\t\tM = sca.nextInt();\n\t\t\tif(N == 0) break;\n\t\t\t\n\t\t\tSink = new ArrayList<Integer[]>();\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tSink.add(new Integer[]{i+1, sca.nextInt()});\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(Sink, new Comparator<Integer[]>() {\n\t\t\t\tpublic int compare(Integer[] a, Integer[] b) {\n\t\t\t\t\tint t = a[1] - b[1];\n\t\t\t\t\tif(t > 0) return -1;\n\t\t\t\t\telse if(t == 0) return 0;\n\t\t\t\t\telse return 1;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tBridge = new ArrayList<Integer[]>();\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tBridge.add(new Integer[]{sca.nextInt(), sca.nextInt(), sca.nextInt(), 0});\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(Bridge, new Comparator<Integer[]>() {\n\t\t\t\tpublic int compare(Integer[] a, Integer[] b) {\n\t\t\t\t\tint t = a[2] - b[2];\n\t\t\t\t\tif(t > 0) return 1;\n\t\t\t\t\telse if(t == 0) return 0;\n\t\t\t\t\telse return -1;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tsolve();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tstatic ContestScanner in;\n\tstatic Writer out;\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\ttry {\n\t\t\tin = new ContestScanner();\n\t\t\tout = new Writer();\n\t\t\tmain.solve();\n\t\t\tout.close();\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tvoid solve() throws IOException {\n\t\twhile(true) {\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tIsl[] isl = new Isl[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tisl[i] = new Isl(i, in.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1;\n\t\t\t\tint b = in.nextInt() - 1;\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tif(isl[a].h > isl[b].h) {\n\t\t\t\t\tint tmp = a;\n\t\t\t\t\ta = b;\n\t\t\t\t\tb = tmp;\n\t\t\t\t}\n\t\t\t\tisl[a].edge.add(new Edge(a, b, c));\n\t\t\t}\n\t\t\tint ans = getAmount(n, m, isl);\n\t\t\tif(ans < 0) {\n\t\t\t\tfor(int i = 0; i <= -ans + 1; i++) {\n\t\t\t\t\tisl[i].h = 1000001;\n\t\t\t\t}\n\t\t\t\tans = getAmount(n, m, isl);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tint getAmount(int n, int m, Isl[] isl) {\n\t\tArrays.sort(isl);\n\t\tPriorityQueue<Edge> pq = new PriorityQueue<>();\n\t\tUnionFind uf = new UnionFind(n);\n\t\tint cost = 0;\n\t\tint group = 0;\n\t\tint last = -1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpq.addAll(isl[i].edge);\n\t\t\tgroup++;\n\t\t\tif(i < n - 1 && isl[i + 1].h == isl[i].h)\n\t\t\t\tcontinue;\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tEdge e = pq.poll();\n\t\t\t\tif(uf.same(e.from, e.to)) continue;\n\t\t\t\tgroup--;\n\t\t\t\tcost += e.cost;\n\t\t\t\tuf.unite(e.from, e.to);\n//\t\t\t\tout.printf(\"use: %d - %d (%d)\\n\", e.from + 1, e.to + 1, e.cost);\n\t\t\t}\n\t\t\tif(group >= 2) {\n\t\t\t\tlast = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n ; i++) {\n\t\t\tif(!uf.same(0, i)) return 0;\n\t\t}\n\t\treturn last == -1 ? cost : -last;\n\t}\n}\n\nclass Isl implements Comparable<Isl> {\n\tint id, h;\n\tList<Edge> edge;\n\tpublic Isl(int id, int h) {\n\t\tthis.id = id;\n\t\tthis.h = h;\n\t\tedge = new ArrayList<>();\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Isl o) {\n\t\treturn o.h - h;\n\t}\n}\n\nclass Edge implements Comparable<Edge> {\n\tint from, to, cost;\n\tpublic Edge(int from, int to, int cost) {\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn cost - o.cost;\n\t}\n}\n\nclass UnionFind{\n\tint[] par;\n\tint[] rank;\n\tUnionFind(int n){\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x] > rank[y]) par[x] = y;\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\tboolean same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int N;\n\tstatic int M;\n\tstatic int[][] h;\n\tstatic int[] h2;\n\tstatic ArrayList<Edge>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tM = sc.nextInt();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\th = new int[N][2];\n\t\t\th2 = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\th[i] = new int[] { i, sc.nextInt() };\n\t\t\t\th2[i] = h[i][1];\n\t\t\t}\n\t\t\tArrays.sort(h, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tArrayList<Edge> elis = new ArrayList<>();\n\t\t\tg = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tg[a].add(new Edge(a, b, c));\n\t\t\t\tg[b].add(new Edge(b, a, c));\n\t\t\t\telis.add(new Edge(a, b, c));\n\t\t\t\telis.add(new Edge(b, a, c));\n\t\t\t}\n\n\t\t\tCollections.sort(elis);\n\t\t\tDJSet ds = new DJSet(N);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\twhile (i + 1 < N && h[i][1] == h[i + 1][1])\n\t\t\t\t\t++i;\n\t\t\t\tint t = h[i][1];\n\t\t\t\tint v = h[i][0];\n\t\t\t\tfor (Edge e : elis) {\n\t\t\t\t\tif (h2[e.src] >= t && h2[e.dst] >= t && !ds.equiv(e.src, e.dst)) {\n\t\t\t\t\t\tds.setUnion(e.src, e.dst);\n\t\t\t\t\t\tans += e.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ds.size(v) != i + 1) {\n\t\t\t\t\tds.clear();\n\t\t\t\t\tans = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint src;\n\t\tint dst;\n\t\tint cost;\n\n\t\tpublic Edge(int src, int dst, int cost) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn Integer.compare(cost, o.cost);\n\t\t}\n\t}\n\n\tstatic class DJSet {\n\t\tint n;\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[y] += upper[x];\n\t\t\t\tupper[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tvoid clear() {\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\n\tint N, M;\n\tint[][] edge;\n\t\n\tint INF = 100000000;\n\t\n\tclass Island implements Comparable<Island> {\n\t\tint sink, id;\n\t\tIsland(int id, int sink) {\n\t\t\tthis.id = id;\n\t\t\tthis.sink = sink;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Island island) {\n\t\t\tint c1 = sink, c2 = island.sink;\n\t\t\treturn c2 - c1;\n\t\t}\n\t}\n\t\n\tclass Edge implements Comparable<Edge> {\n\t\tint x, y;\n\t\tEdge(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Edge e) {\n\t\t\tint c1 = edge[x][y], c2 = edge[e.x][e.y];\n\t\t\treturn c1 - c2;\n\t\t}\n\t}\n\t\n\tUnionFindTree uft;\n\tArrayList<Integer> iList = new ArrayList<Integer>();\n\tlong res = 0;\n\t\n\tvoid prim() {\n\t\tPriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\t\tfor (int i = 0; i < iList.size(); i++) {\n\t\t\tfor (int j = i+1; j < iList.size(); j++) {\n\t\t\t\tint x = iList.get(i), y = iList.get(j);\n\t\t\t\tpq.add(new Edge(x, y));\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tEdge e = pq.poll();\n\t\t\tif (edge[e.x][e.y] != INF && !uft.same(e.x, e.y)) {\n\t\t\t\tuft.unite(e.x, e.y);\n\t\t\t\tres += edge[e.x][e.y];\n\t\t\t}\n\t\t}\n\t}\n\n\tclass UnionFindTree {\n\t\tint[] parent;\n\t\t\n\t\tpublic UnionFindTree(int n) {\n\t\t\tparent = new int[n];\n\t\t\tinit();\n\t\t}\n\t\t\n\t\tvoid init() {\n\t\t\tfor (int i = 0; i < parent.length; i++)\n\t\t\t\tparent[i] = i;\t\n\t\t}\n\t\t\n\t\tpublic int find(int x) {\n\t\t\tif (parent[x] == x) return x;\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x, int y) {\n\t\t\tint xx = find(x), yy = find(y);\n\t\t\tif (xx == yy) return;\n\t\t\tparent[xx] = yy;\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tiList.clear();\n\t\t\tN = in.nextInt(); M = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tIsland[] islands = new Island[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint sink = in.nextInt();\n\t\t\t\tislands[i] = new Island(i, sink);\n\t\t\t}\n\t\t\t\n\t\t\tedge = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++) Arrays.fill(edge[i], INF);\n\t\t\t\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n\t\t\t\tedge[a][b] = edge[b][a] = c;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(islands);\n\t\t\t\n\t\t\tint idx = 0, sink = -1;\n\t\t\tres = 0;\n\t\t\tuft = new UnionFindTree(N);\n\t\t\t\n\t\t\twhile (idx < N) {\n\t\t\t\tIsland il = islands[idx++];\n\t\t\t\tif (sink != -1 && sink != il.sink) {\n\t\t\t\t\tprim();\n\t\t\t\t\tfor (int i = 1; i < iList.size(); i++) {\n\t\t\t\t\t\tint z = iList.get(0);\n\t\t\t\t\t\tif (!uft.same(z, iList.get(i))) {\n\t\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\t\tuft.init();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsink = il.sink; iList.add(il.id);\n\t\t\t}\n\t\t\tprim();\n\t\t\tfor (int i = 1; i < iList.size(); i++) {\n\t\t\t\tint z = iList.get(0);\n\t\t\t\tif (!uft.same(z, iList.get(i))) {\n\t\t\t\t\tres = 0;\n\t\t\t\t\tuft.init();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(int cnt=0;;cnt++) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m) == 0) break;\n\t\t\t\n\t\t\tHashMap<Integer, ArrayList<Integer>> map = new HashMap<Integer, ArrayList<Integer>>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tif(map.containsKey(h))\n\t\t\t\t\tmap.get(h).add(i);\n\t\t\t\telse {\n\t\t\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\tlist.add(i);\n\t\t\t\t\tmap.put(h, list);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSink[] sink = new Sink[map.size()]; int p=0;\n\t\t\tfor(Map.Entry<Integer, ArrayList<Integer>> entry: map.entrySet()) {\n\t\t\t\tsink[p++] = new Sink(entry.getKey(), entry.getValue());\n\t\t\t}\n\t\t\tsort(sink);\n\t\t\t\n\t\t\tG[] g = new G[n];\n\t\t\tfor(int i=0;i<n;i++) g[i] = new G();\n\t\t\tE[] es = new E[m];\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1, b = sc.nextInt()-1, c = sc.nextInt();\n\t\t\t\tg[a].add(new E(a, b, c));\n\t\t\t\tg[b].add(new E(b, a, c));\n\t\t\t\tes[i] = new E(a, b, c);\n\t\t\t}\n\t\t\t\n\t\t\tUF uf = new UF(n);\n\t\t\tboolean[] used = new boolean[n];\n\t\t\tArrayList<Integer> l = new ArrayList<Integer>();\n\t\t\tint con = -1;\n\t\t\tfor(p=0;p<sink.length;p++) {\n\t\t\t\tfor(int v: sink[p].l) {\n\t\t\t\t\tused[v] = true;\n\t\t\t\t\tl.add(v);\n\t\t\t\t}\n\t\t\t\tfor(int v: sink[p].l) for(E e: g[v])if(used[e.f] && used[e.t]){\n\t\t\t\t\tuf.unite(e.f, e.t);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tint val = uf.find(l.get(0));\n\t\t\t\tfor(int i: l) flg &= val == uf.find(i);\n\t\t\t\tif(!flg) con = p;\n\t\t\t}\n\t\t\tfill(used, false);\n\t\t\tif(con==sink.length-1) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<con+2;i++){\n\t\t\t\tfor(int j: sink[i].l)used[j] = true;\n\t\t\t}\n\t\t\tuf = new UF(n);\n\t\t\tsort(es);\n\t\t\tint ans = 0;\n\t\t\tfor(int i=con+2;;i++) {\n\t\t\t\tfor(E e: es) if(used[e.f] && used[e.t] && !uf.same(e.f, e.t)) {\n\t\t\t\t\tuf.unite(e.f, e.t);\n\t\t\t\t\tans += e.c;\n\t\t\t\t}\n\t\t\t\tif(i>=sink.length) break;\n\t\t\t\tfor(int j: sink[i].l) used[j] = true;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tclass UF {\n\t\tint[] par, rank;\n\t\t\n\t\tpublic UF(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor(int i=0;i<n;i++) par[i] = i;\n\t\t}\n\t\t\n\t\t//代表元を求める\n\t\tint find(int x) {\n\t\t\tif( par[x] == x ) return x;\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t\t\n\t\t//要素xとyを併合する\n\t\tvoid unite(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif( x == y ) return;\n\t\t\t\n\t\t\tif( rank[x] < rank[y]  ) par[x] = y;\n\t\t\telse {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif( rank[x] == rank[y] ) rank[x]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//同一の集合に含まれるか調べる．trueならxとyは同じ集合，falseなら異なる\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\t\n\tclass G extends ArrayList<E>{}\n\t\n\tclass E implements Comparable<E>{\n\t\tint f, t, c;\n\t\tE(int f, int t, int c) {\n\t\t\tthis.f = f; this.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn c - o.c;\n\t\t}\n\t}\n\t\n\tclass Sink implements Comparable<Sink>{\n\t\tint d; ArrayList<Integer> l;\n\t\tSink(int d, ArrayList<Integer> l) {\n\t\t\tthis.d = d;\n\t\t\tthis.l = l;\n\t\t}\n\t\tpublic int compareTo(Sink o) {\n\t\t\treturn o.d - d;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solver\n{\n\n    void Solve()\n    {\n        while (true)\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            if ((n | m) == 0)\n                return;\n            var H = sc.IntArray(n);\n            var I = Enumerable.Range(0, n).ToArray();\n            Array.Sort(H, I);\n            var G = new long[n][];\n            for (int i = 0; i < n; i++)\n                G[i] = new long[n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if(i!=j) G[i][j] = 1L << 60;\n            for (int i = 0; i < m; i++)\n            {\n                var f = sc.Integer() - 1;\n                var t = sc.Integer() - 1;\n                var c = sc.Integer();\n                G[f][t] = c;\n                G[t][f] = c;\n            }\n\n            Func<long> Prim = () =>\n                {\n                    long ret = 0;\n                    var cost = Enumerable.Repeat(1L << 60, n).ToArray();\n                    var enable = new bool[n];\n                    var visited = new bool[n];\n                    cost[I[n - 1]] = 0;\n                    for (int i = n - 1; i >= 0; i--)\n                    {\n                        for (int j = i; j >= 0; j--)\n                        {\n                            if (H[j] == H[i])\n                            {\n                                enable[I[j]] = true;\n                                continue;\n                            }\n                            break;\n                        }\n                        while (true)\n                        {\n                            var v = -1;\n                            for (int u = 0; u < n; u++)\n                                if (enable[u] && !visited[u] && (v == -1 || cost[u] < cost[v]))\n                                    v = u;\n                            if (v == -1)\n                                break;\n                            if (cost[v] == 1L << 60)\n                            {\n                                for (int k = 0; k < n; k++)\n                                {\n                                    visited[k] = false;\n                                    cost[k] = 1L << 60;\n                                }\n                                cost[v] = 0;\n                                ret = 0;\n                                break;\n                            }\n                            visited[v] = true;\n                            ret += cost[v];\n                            for (int u = 0; u < n; u++)\n                                if (u != v && cost[u] > G[v][u])\n                                    cost[u] = G[v][u];\n                        }\n                    }\n                    return ret;\n                };\n            Printer.PrintLine(Prim());\n\n\n        }\n    }\n\n    static void Main()\n    {\n#if DEBUG\n        var ostream = new System.IO.FileStream(\"debug.txt\", System.IO.FileMode.Create, System.IO.FileAccess.Write);\n        var iStream = new System.IO.FileStream(\"input.txt\", System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.ReadWrite);\n        Console.SetIn(new System.IO.StreamReader(iStream));\n        System.Diagnostics.Debug.AutoFlush = true;\n        System.Diagnostics.Debug.Listeners.Add(new System.Diagnostics.TextWriterTraceListener(new System.IO.StreamWriter(ostream, System.Text.Encoding.UTF8)));\n        try\n        {\n#endif\n            var solver = new Solver();\n            solver.Solve();\n#if DEBUG\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(ex.Message);\n            Console.WriteLine(ex.StackTrace);\n        }\n        Console.ReadKey(true);\n#endif\n    }\n    _Scanner sc = new _Scanner();\n\n}\n\nstatic public class Printer\n{\n    static readonly private System.IO.TextWriter writer;\n    static readonly private System.Globalization.CultureInfo info;\n    static string Separator { get; set; }\n    static Printer()\n    {\n        writer = Console.Out;\n        info = System.Globalization.CultureInfo.InvariantCulture;\n        Separator = \" \";\n    }\n\n    static public void Print(int num) { writer.Write(num.ToString(info)); }\n    static public void Print(int num, string format) { writer.Write(num.ToString(format, info)); }\n    static public void Print(long num) { writer.Write(num.ToString(info)); }\n    static public void Print(long num, string format) { writer.Write(num.ToString(format, info)); }\n    static public void Print(double num) { writer.Write(num.ToString(info)); }\n    static public void Print(double num, string format) { writer.Write(num.ToString(format, info)); }\n    static public void Print(string str) { writer.Write(str); }\n    static public void Print(string format, params object[] arg) { writer.Write(format, arg); }\n    static public void Print(IEnumerable<char> sources) { writer.Write(sources.AsString()); }\n    static public void Print(params object[] arg)\n    {\n        var res = new System.Text.StringBuilder();\n        foreach (var x in arg)\n        {\n            res.AppendFormat(info, \"{0}\", x);\n            if (!string.IsNullOrEmpty(Separator))\n                res.Append(Separator);\n        }\n        writer.Write(res.ToString(0, res.Length - Separator.Length));\n    }\n    static public void Print<T>(IEnumerable<T> sources)\n    {\n        var res = new System.Text.StringBuilder();\n        foreach (var x in sources)\n        {\n            res.AppendFormat(info, \"{0}\", x);\n            if (string.IsNullOrEmpty(Separator))\n                res.Append(Separator);\n        }\n        writer.Write(res.ToString(0, res.Length - Separator.Length));\n    }\n    static public void PrintLine(int num) { writer.WriteLine(num.ToString(info)); }\n    static public void PrintLine(int num, string format) { writer.WriteLine(num.ToString(format, info)); }\n    static public void PrintLine(long num) { writer.WriteLine(num.ToString(info)); }\n    static public void PrintLine(long num, string format) { writer.WriteLine(num.ToString(format, info)); }\n    static public void PrintLine(double num) { writer.WriteLine(num.ToString(info)); }\n    static public void PrintLine(double num, string format) { writer.WriteLine(num.ToString(format, info)); }\n    static public void PrintLine(string str) { writer.WriteLine(str); }\n    static public void PrintLine(string format, params object[] arg) { writer.WriteLine(format, arg); }\n    static public void PrintLine(IEnumerable<char> sources) { writer.WriteLine(sources.AsString()); }\n    static public void PrintLine(params object[] arg)\n    {\n        var res = new System.Text.StringBuilder();\n        foreach (var x in arg)\n        {\n            res.AppendFormat(info, \"{0}\", x);\n            if (!string.IsNullOrEmpty(Separator))\n                res.Append(Separator);\n        }\n        writer.WriteLine(res.ToString(0, res.Length - Separator.Length));\n    }\n    static public void PrintLine<T>(IEnumerable<T> sources)\n    {\n        var res = new System.Text.StringBuilder();\n        foreach (var x in sources)\n        {\n            res.AppendFormat(info, \"{0}\", x);\n            if (!string.IsNullOrEmpty(Separator))\n                res.Append(Separator);\n        }\n        writer.WriteLine(res.ToString(0, res.Length - Separator.Length));\n    }\n    static public void PrintLine(System.Linq.Expressions.Expression<Func<string, object>> ex)\n    {\n        var res = ex.Parameters[0];\n        writer.WriteLine(res.Name);\n    }\n}\npublic class _Scanner\n{\n    readonly private System.Globalization.CultureInfo info;\n    readonly System.IO.TextReader reader;\n    string[] buffer = new string[0];\n    int position;\n\n    public char[] Separator { get; set; }\n    public _Scanner(System.IO.TextReader reader = null, string separator = null, System.Globalization.CultureInfo info = null)\n    {\n\n        this.reader = reader ?? Console.In;\n        if (string.IsNullOrEmpty(separator))\n            separator = \" \";\n        this.Separator = separator.ToCharArray();\n        this.info = info ?? System.Globalization.CultureInfo.InvariantCulture;\n    }\n    public string Scan()\n    {\n        if (this.position < this.buffer.Length)\n            return this.buffer[this.position++];\n        this.buffer = this.reader.ReadLine().Split(this.Separator, StringSplitOptions.RemoveEmptyEntries);\n        this.position = 0;\n        return this.buffer[this.position++];\n    }\n\n    public string[] ScanToEndLine()\n    {\n        if (this.position >= this.buffer.Length)\n            return this.reader.ReadLine().Split(this.Separator, StringSplitOptions.RemoveEmptyEntries);\n        var size = this.buffer.Length - this.position;\n        var ar = new string[size];\n        Array.Copy(this.buffer, position, ar, 0, size);\n        return ar;\n\n    }\n\n    public string ScanLine()\n    {\n        if (this.position >= this.buffer.Length)\n            return this.reader.ReadLine();\n        else\n        {\n            var sb = new System.Text.StringBuilder();\n            for (; this.position < buffer.Length; this.position++)\n            {\n                sb.Append(this.buffer[this.position]);\n                sb.Append(' ');\n            }\n            return sb.ToString();\n        }\n    }\n    public string[] ScanArray(int length)\n    {\n        var ar = new string[length];\n        for (int i = 0; i < length; i++)\n        {\n            ar[i] = this.Scan();\n        }\n        return ar;\n    }\n\n    public int Integer()\n    {\n        return int.Parse(this.Scan(), info);\n    }\n    public long Long()\n    {\n        return long.Parse(this.Scan(), info);\n    }\n    public double Double()\n    {\n        return double.Parse(this.Scan(), info);\n    }\n    public double Double(string str)\n    {\n        return double.Parse(str, info);\n    }\n\n    public int[] IntArray(int length)\n    {\n        var a = new int[length];\n        for (int i = 0; i < length; i++)\n            a[i] = this.Integer();\n        return a;\n    }\n    public long[] LongArray(int length)\n    {\n        var a = new long[length];\n        for (int i = 0; i < length; i++)\n            a[i] = this.Long();\n        return a;\n    }\n    public double[] DoubleArray(int length)\n    {\n        var a = new double[length];\n        for (int i = 0; i < length; i++)\n            a[i] = this.Double();\n        return a;\n    }\n\n}\nstatic public partial class EnumerableEx\n{\n    static public string AsString(this IEnumerable<char> source)\n    {\n        return new string(source.ToArray());\n    }\n    static public IEnumerable<T> Enumerate<T>(this int count, Func<int, T> selector)\n    {\n        return Enumerable.Range(0, count).Select(x => selector(x));\n    }\n}\n//*/\n"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/10.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction UF(n) {//union find\n  var i,\n      par = [];\n  for (i = 0; i < n; i++) {\n    par[i] = -1;\n  }\n  function union(x, y) {\n    x = find(x);\n    y = find(y);\n    if (x !== y) {\n      if (par[x] < par[y]) {\n        par[x] += par[y];\n        par[y] = x;\n      } else {\n        par[y] += par[x];\n        par[x] = y;\n      }\n    }\n    return x !== y;\n  }\n\n  function find(x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  function count(using) {\n    var c = 0;\n    for (i = 0; i < n; i++) {\n      if (using[i] && par[i] < 0) {\n        c++\n      }\n    }\n    return c;\n  }\n  function same(x, y){\n    return find(x) === find(y);\n  }\n  return {\n    union: union,\n    find: find,\n    count: count,\n    same: same\n  };\n}\nfunction main() {\n  var temp, n, m,\n      i, j, k,\n      h,\n      g,\n      edges, e,\n      uf,\n      res,\n      use;\n  while (true) {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n\n    if (n === 0 && m === 0) {\n      break;\n    }\n    h = [];\n    use = [];\n    for (i = 0; i < n; i++) {\n//      h[i] = [+input.shift() , i];\n      h[i] = {\n        node: i,\n        days: +input.shift()\n      };\n      use[i] = false;\n    }\n    edges = [];\n//    g = [];\n//    for (i = 0; i < n; i++) {\n//      g[i] = [];\n//      for (j = 0; j < n; j++) {\n//        g[i][j] = i == j ? 0 : Infinity;\n//      }\n//    }\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      edges[i] = [temp[0] - 1, temp[1] - 1, temp[2] - 0];\n//      g[edges[i][0]][edges[i][1]] = g[edges[i][1]][edges[i][0]] = edges[i][2];\n    }\n//    console.log(g)\n\n    h.sort(function (a, b) {\n      return a.days - b.days;\n    });\n\n//    uf = UF(n);\n//    for (j = 0; j < n; j++) {\n//      for (k = 0; k < n; k++) {\n//        if (j !== k && g[j][k] !== Infinity) {\n//          uf.union(j, k);\n//        }\n//      }\n//    }\n//    if (uf.count(use) > 1) {\n//      console.log(0);\n//      continue;\n//    }\n    //\n    edges.sort(function (e1, e2) {\n      return e1[2] - e2[2];\n    });\n    uf = UF(n);\n    res = 0;\n    for (i = n - 1; i >= 0; i--) {\n      use[h[i].node] = true;\n      while (i > 0 && h[i].days === h[i - 1].days) {\n        i--;\n        use[h[i].node] = true;\n      }\n      for (j = 0; j < m; j++) {\n        e = edges[j];\n        if (use[e[0]] && use[e[1]]) {\n          if (!uf.same(e[0],e[1])) {\n            uf.union(e[0], e[1]);\n            res += e[2];\n          }\n        }\n      }\n      if (uf.count(use) > 1) {\n        res = 0;\n        uf = UF(n);\n//        break;\n      }\n    }\n\n    console.log(res);\n\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/10.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction UF(n) {//union find\n  var i,\n      par = [];\n  for (i = 0; i < n; i++) {\n    par[i] = -1;\n  }\n  function union(x, y) {\n    x = find(x);\n    y = find(y);\n    if (x !== y) {\n      if (par[x] < par[y]) {\n        par[x] += par[y];\n        par[y] = x;\n      } else {\n        par[y] += par[x];\n        par[x] = y;\n      }\n    }\n    return x !== y;\n  }\n\n  function find(x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  function count(using) {\n    var c = 0;\n    for (i = 0; i < n; i++) {\n      if (using[i] && par[i] < 0) {\n        c++\n      }\n    }\n    return c;\n  }\n\n  function same(x, y) {\n    return find(x) === find(y);\n  }\n\n  return {\n    union: union,\n    find: find,\n    count: count,\n    same: same\n  };\n}\nfunction main() {\n  var temp, n, m,\n      i, j, k,\n      h,\n      edges, e,\n      uf,\n      res,\n      use;\n  while (true) {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n\n    if (!m) {\n      break;\n    }\n    h = [];\n    use = [];\n    for (i = 0; i < n; i++) {\n      h[i] = {\n        node: i,\n        days: +input.shift()\n      };\n      use[i] = false;\n    }\n    edges = [];\n\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      edges[i] = [temp[0] - 1, temp[1] - 1, temp[2] - 0];\n    }\n    h.sort(function (a, b) {\n      return a.days - b.days;\n    });\n    edges.sort(function (e1, e2) {\n      return e1[2] - e2[2];\n    });\n    uf = UF(n);\n    res = 0;\n    for (i = n - 1; i >= 0; i--) {\n      use[h[i].node] = true;\n      while (i > 0 && h[i].days === h[i - 1].days) {\n        i--;\n        use[h[i].node] = true;\n      }\n      //kruskal\n      for (j = 0; j < m; j++) {\n        e = edges[j];\n        if (use[e[0]] && use[e[1]] && !uf.same(e[0], e[1])) {\n          uf.union(e[0], e[1]);\n          res += e[2];\n        }\n      }\n      if (uf.count(use) > 1) {\n        res = 0;\n        uf = UF(n);\n      }\n    }\n    console.log(res);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/10.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction UF(n) {//union find\n  var i,\n      par = [];\n  for (i = 0; i < n; i++) {\n    par[i] = -1;\n  }\n  function union(x, y) {\n    x = find(x);\n    y = find(y);\n    if (x !== y) {\n      if (par[x] < par[y]) {\n        par[x] += par[y];\n        par[y] = x;\n      } else {\n        par[y] += par[x];\n        par[x] = y;\n      }\n    }\n    return x !== y;\n  }\n\n  function find(x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  function count(using) {\n    var c = 0;\n    for (i = 0; i < n; i++) {\n      if (using[i] && par[i] < 0) {\n        c++\n      }\n    }\n    return c;\n  }\n\n  function same(x, y) {\n    return find(x) === find(y);\n  }\n\n  return {\n    union: union,\n    find: find,\n    count: count,\n    same: same\n  };\n}\nfunction main() {\n  var temp, n, m,\n      i, j, k,\n      h,\n      edges, e,\n      uf,\n      res,\n      use;\n  while (true) {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n\n    if (n === 0) {\n      break;\n    }\n    h = [];\n    use = [];\n    for (i = 0; i < n; i++) {\n      h[i] = {\n        node: i,\n        days: +input.shift()\n      };\n      use[i] = false;\n    }\n    edges = [];\n\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      edges[i] = [temp[0] - 1, temp[1] - 1, temp[2] - 0];\n    }\n    h.sort(function (a, b) {\n      return a.days - b.days;\n    });\n    edges.sort(function (e1, e2) {\n      return e1[2] - e2[2];\n    });\n    uf = UF(n);\n    res = 0;\n//    for (i = n - 1; i >= 0; i--) {\n//      use[h[i].node] = true;\n//      while (i > 0 && h[i].days === h[i - 1].days) {\n//        i--;\n//        use[h[i].node] = true;\n//      }\n//      //kruskal\n//      for (j = 0; j < m; j++) {\n//        e = edges[j];\n//        if (use[e[0]] && use[e[1]] && !uf.same(e[0], e[1])) {\n//          uf.union(e[0], e[1]);\n//          res += e[2];\n//        }\n//      }\n//      if (uf.count(use) > 1) {\n//        res = 0;\n//        uf = UF(n);\n//      }\n//    }\n    console.log(res);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/10.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction UF(n) {//union find\n  var i,\n      par = [];\n  for (i = 0; i < n; i++) {\n    par[i] = -1;\n  }\n  function union(x, y) {\n    x = find(x);\n    y = find(y);\n    if (x !== y) {\n      if (par[x] < par[y]) {\n        par[x] += par[y];\n        par[y] = x;\n      } else {\n        par[y] += par[x];\n        par[x] = y;\n      }\n    }\n    return x !== y;\n  }\n\n  function find(x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  function count(using) {\n    var c = 0;\n    for (i = 0; i < n; i++) {\n      if (using[i] && par[i] < 0) {\n        c++\n      }\n    }\n    return c;\n  }\n\n  function same(x, y) {\n    return find(x) === find(y);\n  }\n\n  return {\n    union: union,\n    find: find,\n    count: count,\n    same: same\n  };\n}\nfunction main() {\n  var temp, n, m,\n      i, j, k,\n      h,\n      edges, e,\n      uf,\n      res,\n      use;\n  while (input[0]!=='0 0') {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n\n    if (m === 0) {\n      break;\n    }\n    h = [];\n    use = [];\n    for (i = 0; i < n; i++) {\n      h[i] = {\n        node: i,\n        days: +input.shift()\n      };\n      use[i] = false;\n    }\n    edges = [];\n\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      edges[i] = [temp[0] - 1, temp[1] - 1, temp[2] - 0];\n    }\n    h.sort(function (a, b) {\n      return a.days - b.days;\n    });\n    edges.sort(function (e1, e2) {\n      return e1[2] - e2[2];\n    });\n    uf = UF(n);\n    res = 0;\n    for (i = n - 1; i >= 0; i--) {\n      use[h[i].node] = true;\n      while (i > 0 && h[i].days === h[i - 1].days) {\n        i--;\n        use[h[i].node] = true;\n      }\n      //kruskal\n      for (j = 0; j < m; j++) {\n        e = edges[j];\n        if (use[e[0]] && use[e[1]] && !uf.same(e[0], e[1])) {\n          uf.union(e[0], e[1]);\n          res += e[2];\n        }\n      }\n      if (uf.count(use) > 1) {\n        res = 0;\n        uf = UF(n);\n      }\n    }\n    console.log(res);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/10.\n */\n//var fs = require('fs'),\n//    length = fs.fstatSync(process.stdin.fd).size,\n//    buffer = new Buffer(length),\n//    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n//    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\n\nvar input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});\nfunction UF(n) {//union find\n  var i,\n      par = [];\n  for (i = 0; i < n; i++) {\n    par[i] = -1;\n  }\n  function union(x, y) {\n    x = find(x);\n    y = find(y);\n    if (x !== y) {\n      if (par[x] < par[y]) {\n        par[x] += par[y];\n        par[y] = x;\n      } else {\n        par[y] += par[x];\n        par[x] = y;\n      }\n    }\n    return x !== y;\n  }\n\n  function find(x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  function count(using) {\n    var c = 0;\n    for (i = 0; i < n; i++) {\n      if (using[i] && par[i] < 0) {\n        c++\n      }\n    }\n    return c;\n  }\n\n  function same(x, y) {\n    return find(x) === find(y);\n  }\n\n  return {\n    union: union,\n    find: find,\n    count: count,\n    same: same\n  };\n}\nfunction main() {\n  var temp, n, m,\n      i, j, k,\n      h,\n      edges, e,\n      uf,\n      res,\n      use;\n  while (true) {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n\n    if (m === 0) {\n      break;\n    }\n    h = [];\n    use = [];\n    for (i = 0; i < n; i++) {\n      h[i] = {\n        node: i,\n        days: +input.shift()\n      };\n      use[i] = false;\n    }\n    edges = [];\n\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      edges[i] = [temp[0] - 1, temp[1] - 1, temp[2] - 0];\n    }\n    h.sort(function (a, b) {\n      return a.days - b.days;\n    });\n    edges.sort(function (e1, e2) {\n      return e1[2] - e2[2];\n    });\n    uf = UF(n);\n    res = 0;\n    for (i = n - 1; i >= 0; i--) {\n      use[h[i].node] = true;\n      while (i > 0 && h[i].days === h[i - 1].days) {\n        i--;\n        use[h[i].node] = true;\n      }\n      //kruskal\n      for (j = 0; j < m; j++) {\n        e = edges[j];\n        if (use[e[0]] && use[e[1]] && !uf.same(e[0], e[1])) {\n          uf.union(e[0], e[1]);\n          res += e[2];\n        }\n      }\n      if (uf.count(use) > 1) {\n        res = 0;\n        uf = UF(n);\n      }\n    }\n    console.log(res);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/10.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction matrix(n, m, init) {\n  var arr = [], i, j;\n  for (i = 0; i < n; i++) {\n    arr[i] = [];\n    for (j = 0; j < m; j++) {\n      arr[i][j] = init;\n    }\n  }\n  return arr;\n}\nfunction UF(n) {//union find\n  var i,\n      par = [];\n  for (i = 0; i < n; i++) {\n    par[i] = -1;\n  }\n  function union(x, y) {\n    x = find(x);\n    y = find(y);\n    if (x !== y) {\n      if (par[x] < par[y]) {\n        par[x] += par[y];\n        par[y] = x;\n      } else {\n        par[y] += par[x];\n        par[x] = y;\n      }\n    }\n    return x !== y;\n  }\n\n  function find(x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  function count(using) {\n    var c = 0;\n    for (i = 0; i < n; i++) {\n      if (using[i] && par[i] < 0) {\n        c++\n      }\n    }\n    return c;\n  }\n\n  return {\n    union: union,\n    find: find,\n    count: count\n  };\n}\nfunction main() {\n  var temp, n, m,\n      i, j, k,\n      h,\n      g,\n      edges, e,\n      uf,\n      res,\n      use;\n  while (true) {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n\n    if (n === 0 && m === 0) {\n      break;\n    }\n    h = [];\n    use = [];\n    for (i = 0; i < n; i++) {\n//      h[i] = [+input.shift() , i];\n      h[i] = {\n        node: i,\n        days: +input.shift()\n      };\n      use[i] = true;\n    }\n    edges = [];\n    g = [];\n    for (i = 0; i < n; i++) {\n      g[i] = [];\n      for (j = 0; j < n; j++) {\n        g[i][j] = i == j ? 0 : Infinity;\n      }\n    }\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      edges[i] = [temp[0] - 1, temp[1] - 1, temp[2] - 0];\n      g[edges[i][0]][edges[i][1]] = g[edges[i][1]][edges[i][0]] = edges[i][2];\n    }\n//    console.log(g)\n\n//    h.sort(function (a, b) {\n//      return a[0] - b[0];\n//    });\n    h.sort(function (a, b) {\n      return a.days - b.days;\n    });\n    uf = UF(n);\n    for (j = 0; j < n; j++) {\n      for (k = 0; k < n; k++) {\n        if (j !== k && g[j][k] !== Infinity) {\n          uf.union(j, k);\n        }\n      }\n    }\n    if (uf.count(use) > 1) {\n      console.log(0);\n      continue;\n    }\n    for (i = 0; i < n; i++) {\n      use[h[i].node] = false;\n\n//      while (i < n - 1 && h[i][0] === h[i + 1][0]) {\n      while (i < n - 1 && h[i].days === h[i + 1].days) {\n        i++;\n\n        use[h[i].node] = false;\n      }\n      uf = UF(n);\n      for (j = 0; j < n; j++) {\n        for (k = 0; k < n; k++) {\n          if (use[k] && use[j] && k !== j && g[j][k] !== Infinity) {\n            uf.union(j, k);\n          }\n        }\n      }\n//      console.log('uf',uf.count(use));\n\n      if (uf.count(use) > 1) {\n//        console.log('days', h)\n        use[h[i].node] = true;\n        while (i > 0 && h[i].days === h[i - 1].days) {\n          i--;\n          use[h[i].node] = true;\n        }\n        break;\n      }\n    }\n    //kruskal\n    res = 0;\n    uf = UF(n);\n    edges.sort(function (e1, e2) {\n      return e1[2] - e2[2];\n    });\n    for (j = 0; j < m; j++) {\n      e = edges[j];\n      if (use[e[0]] && use[e[1]]) {\n        if (uf.find(e[0]) !== uf.find(e[1])) {\n          uf.union(e[0], e[1]);\n          res += e[2];\n        }\n      }\n    }\n\n    var stack, d, node;\n\n    for (k = i - 1; k >= 0; k--) {\n//      stack = [];\n//      stack.push(h[k].node);\n      use[h[k].node] = true;\n      while (k > 0 && h[k].days === h[k - 1].days) {\n        k--;\n//        stack.push(h[k].node);\n        use[h[k].node] = true;\n      }\n      for (j = 0; j < m; j++) {\n        e = edges[j];\n        if (use[e[0]] && use[e[1]]) {\n          if (uf.find(e[0]) !== uf.find(e[1])) {\n            uf.union(e[0], e[1]);\n            res += e[2];\n          }\n        }\n      }\n//      while (stack.length > 0) {\n//        node = stack.pop();\n//        d = Infinity;\n//      }\n    }\n    console.log(res);\n\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/10.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction matrix(n, m, init) {\n  var arr = [], i, j;\n  for (i = 0; i < n; i++) {\n    arr[i] = [];\n    for (j = 0; j < m; j++) {\n      arr[i][j] = init;\n    }\n  }\n  return arr;\n}\nfunction UF(n) {//union find\n  var i,\n      par = [];\n  for (i = 0; i < n; i++) {\n    par[i] = -1;\n  }\n  function union(x, y) {\n    x = find(x);\n    y = find(y);\n    if (x !== y) {\n      if (par[x] < par[y]) {\n        par[x] += par[y];\n        par[y] = x;\n      } else {\n        par[y] += par[x];\n        par[x] = y;\n      }\n    }\n    return x !== y;\n  }\n\n  function find(x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  function count(using) {\n    var c = 0;\n    for (i = 0; i < n; i++) {\n      if (using[i] && par[i] < 0) {\n        c++\n      }\n    }\n    return c;\n  }\n\n  return {\n    union: union,\n    find: find,\n    count: count\n  };\n}\nfunction main() {\n  var temp, n, m,\n      i, j, k,\n      h,\n      g,\n      edges, e,\n      uf,\n      res,\n      use;\n  while (true) {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n\n    if (n === 0 && m === 0) {\n      break;\n    }\n    h = [];\n    use = [];\n    for (i = 0; i < n; i++) {\n//      h[i] = [+input.shift() , i];\n      h[i] = {\n        node: i,\n        days: +input.shift()\n      };\n      use[i] = true;\n    }\n    edges = [];\n    g = [];\n    for (i = 0; i < n; i++) {\n      g[i] = [];\n      for (j = 0; j < n; j++) {\n        g[i][j] = i == j ? 0 : Infinity;\n      }\n    }\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      edges[i] = [temp[0] - 1, temp[1] - 1, temp[2] - 0];\n      g[edges[i][0]][edges[i][1]] = g[edges[i][1]][edges[i][0]] = edges[i][2];\n    }\n//    console.log(g)\n\n//    h.sort(function (a, b) {\n//      return a[0] - b[0];\n//    });\n    h.sort(function (a, b) {\n      return a.days - b.days;\n    });\n    uf = UF(n);\n    for (j = 0; j < n; j++) {\n      for (k = 0; k < n; k++) {\n        if (j !== k && g[j][k] !== Infinity) {\n          uf.union(j, k);\n        }\n      }\n    }\n    if (uf.count(use) > 1) {\n      console.log(0);\n      continue;\n    }\n    for (i = 0; i < n; i++) {\n      use[h[i].node] = false;\n\n//      while (i < n - 1 && h[i][0] === h[i + 1][0]) {\n      while (i < n - 1 && h[i].days === h[i + 1].days) {\n        i++;\n\n        use[h[i].node] = false;\n      }\n      uf = UF(n);\n      for (j = 0; j < n; j++) {\n        for (k = 0; k < n; k++) {\n          if (use[k] && use[j] && k !== j && g[j][k] !== Infinity) {\n            uf.union(j, k);\n          }\n        }\n      }\n//      console.log('uf',uf.count(use));\n\n      if (uf.count(use) > 1) {\n//        console.log('days', h)\n        use[h[i].node] = true;\n        while (i > 0 && h[i].days === h[i - 1].days) {\n          i--;\n          use[h[i].node] = true;\n        }\n        break;\n      }\n    }\n    //kruskal\n    res = 0;\n    uf = UF(n);\n    edges.sort(function (e1, e2) {\n      return e1[2] - e2[2];\n    });\n    for (j = 0; j < m; j++) {\n      e = edges[j];\n      if (use[e[0]] && use[e[1]]) {\n        if (uf.find(e[0]) !== uf.find(e[1])) {\n          uf.union(e[0], e[1]);\n          res += e[2];\n        }\n      }\n    }\n\n//    console.log(res)\n//    console.log('uf',uf.count(use));\n//    console.log(use)\n    var stack, d, node;\n\n    for (k = i - 1; k >= 0; k--) {\n//      console.log('k',k)\n      stack = [];\n      stack.push(h[k].node);\n      use[h[k].node] = true;\n      while (k > 0 && h[k].days === h[k - 1].days) {\n        k--;\n        stack.push(h[k].node);\n        use[h[k].node] = true;\n      }\n//      queue.sort(function (n1, n2) {\n//\n//        return e1[2] - e2[2];\n//      });\n      while (stack.length > 0) {\n        node = stack.pop();\n        d = Infinity;\n        for (j = 0; j < m; j++) {\n          e = edges[j];\n          if (use[e[0]] && use[e[1]]) {\n            if (uf.find(e[0]) !== uf.find(e[1])) {\n              uf.union(e[0], e[1]);\n              res += e[2];\n            }\n          }\n//          }\n        }\n//        for (j = 0; j < n; j++) {\n//          if (use[j] && j !== node) {\n//            d = d > g[node][j] ? g[node][j] : d;\n//          }\n//        }\n//        console.log('d', d, 'node', node);\n//        if (d !== Infinity) {\n//          res += d;\n//        }\n\n      }\n    }\n    console.log(res);\n\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/10.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction UF(n) {//union find\n  var i,\n      par = [];\n  for (i = 0; i < n; i++) {\n    par[i] = -1;\n  }\n  function union(x, y) {\n    x = find(x);\n    y = find(y);\n    if (x !== y) {\n      if (par[x] < par[y]) {\n        par[x] += par[y];\n        par[y] = x;\n      } else {\n        par[y] += par[x];\n        par[x] = y;\n      }\n    }\n    return x !== y;\n  }\n\n  function find(x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  function count(using) {\n    var c = 0;\n    for (i = 0; i < n; i++) {\n      if (using[i] && par[i] < 0) {\n        c++\n      }\n    }\n    return c;\n  }\n\n  function same(x, y) {\n    return find(x) === find(y);\n  }\n\n  return {\n    union: union,\n    find: find,\n    count: count,\n    same: same\n  };\n}\nfunction main() {\n  var temp, n, m,\n      i, j, k,\n      h,\n      edges, e,\n      uf,\n      res,\n      use;\n  while (true) {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n\n    if (n === 0 && m === 0) {\n      break;\n    }\n    h = [];\n    use = [];\n    for (i = 0; i < n; i++) {\n      h[i] = {\n        node: i,\n        days: +input.shift()\n      };\n      use[i] = false;\n    }\n    edges = [];\n\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      edges[i] = [temp[0] - 1, temp[1] - 1, temp[2] - 0];\n    }\n    h.sort(function (a, b) {\n      return a.days - b.days;\n    });\n    edges.sort(function (e1, e2) {\n      return e1[2] - e2[2];\n    });\n    uf = UF(n);\n    res = 0;\n    for (i = n - 1; i >= 0; i--) {\n      use[h[i].node] = true;\n      while (i > 0 && h[i].days === h[i - 1].days) {\n        i--;\n        use[h[i].node] = true;\n      }\n      for (j = 0; j < m; j++) {\n        e = edges[j];\n        if (use[e[0]] && use[e[1]] && !uf.same(e[0], e[1])) {\n          uf.union(e[0], e[1]);\n          res += e[2];\n\n        }\n      }\n      if (uf.count(use) > 1) {\n        res = 0;\n        uf = UF(n);\n//        break;\n      }\n    }\n    console.log(res);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/10.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction UF(n) {//union find\n  var i,\n      par = [];\n  for (i = 0; i < n; i++) {\n    par[i] = -1;\n  }\n  function union(x, y) {\n    x = find(x);\n    y = find(y);\n    if (x !== y) {\n      if (par[x] < par[y]) {\n        par[x] += par[y];\n        par[y] = x;\n      } else {\n        par[y] += par[x];\n        par[x] = y;\n      }\n    }\n    return x !== y;\n  }\n\n  function find(x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  function count(using) {\n    var c = 0;\n    for (i = 0; i < n; i++) {\n      if (using[i] && par[i] < 0) {\n        c++\n      }\n    }\n    return c;\n  }\n\n  function same(x, y) {\n    return find(x) === find(y);\n  }\n\n  return {\n    union: union,\n    find: find,\n    count: count,\n    same: same\n  };\n}\nfunction main() {\n  var temp, n, m,\n      i, j, k,\n      h,\n      edges, e,\n      uf,\n      res,\n      use;\n  while (input.length < 2) {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n\n    if (m === 0) {\n      break;\n    }\n    h = [];\n    use = [];\n    for (i = 0; i < n; i++) {\n      h[i] = {\n        node: i,\n        days: +input.shift()\n      };\n      use[i] = false;\n    }\n    edges = [];\n\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      edges[i] = [temp[0] - 1, temp[1] - 1, temp[2] - 0];\n    }\n    h.sort(function (a, b) {\n      return a.days - b.days;\n    });\n    edges.sort(function (e1, e2) {\n      return e1[2] - e2[2];\n    });\n    uf = UF(n);\n    res = 0;\n    for (i = n - 1; i >= 0; i--) {\n      use[h[i].node] = true;\n      while (i > 0 && h[i].days === h[i - 1].days) {\n        i--;\n        use[h[i].node] = true;\n      }\n      //kruskal\n      for (j = 0; j < m; j++) {\n        e = edges[j];\n        if (use[e[0]] && use[e[1]] && !uf.same(e[0], e[1])) {\n          uf.union(e[0], e[1]);\n          res += e[2];\n        }\n      }\n      if (uf.count(use) > 1) {\n        res = 0;\n        uf = UF(n);\n      }\n    }\n    console.log(res);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/10.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction UF(n) {//union find\n  var i,\n      par = [];\n  for (i = 0; i < n; i++) {\n    par[i] = -1;\n  }\n  function union(x, y) {\n    x = find(x);\n    y = find(y);\n    if (x !== y) {\n      if (par[x] < par[y]) {\n        par[x] += par[y];\n        par[y] = x;\n      } else {\n        par[y] += par[x];\n        par[x] = y;\n      }\n    }\n    return x !== y;\n  }\n\n  function find(x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  function count(using) {\n    var c = 0;\n    for (i = 0; i < n; i++) {\n      if (using[i] && par[i] < 0) {\n        c++\n      }\n    }\n    return c;\n  }\n\n  function same(x, y) {\n    return find(x) === find(y);\n  }\n\n  return {\n    union: union,\n    find: find,\n    count: count,\n    same: same\n  };\n}\nfunction main() {\n  var temp, n, m,\n      i, j, k,\n      h,\n      edges, e,\n      uf,\n      res,\n      use;\n  while (true) {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n\n    if (n === 0) {\n      break;\n    }\n    h = [];\n    use = [];\n    for (i = 0; i < n; i++) {\n      h[i] = {\n        node: i,\n        days: +input.shift()\n      };\n      use[i] = false;\n    }\n    edges = [];\n\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      edges[i] = [temp[0] - 1, temp[1] - 1, temp[2] - 0];\n    }\n    h.sort(function (a, b) {\n      return a.days - b.days;\n    });\n    edges.sort(function (e1, e2) {\n      return e1[2] - e2[2];\n    });\n    uf = UF(n);\n    res = 0;\n    for (i = n - 1; i >= 0; i--) {\n      use[h[i].node] = true;\n      while (i > 0 && h[i].days === h[i - 1].days) {\n        i--;\n        use[h[i].node] = true;\n      }\n      //kruskal\n      for (j = 0; j < m; j++) {\n        e = edges[j];\n        if (use[e[0]] && use[e[1]] && !uf.same(e[0], e[1])) {\n          uf.union(e[0], e[1]);\n          res += e[2];\n        }\n      }\n      if (uf.count(use) > 1) {\n        res = 0;\n        uf = UF(n);\n      }\n    }\n    console.log(res);\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "sleep 200"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.rank += 1\n\t\t\tv.size += u.size\n\t\tend\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\nend\n\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\t\n\tnodes = [nil] + (1..n).map{|i| [i, gets.to_i]}\n\n\tavailable = {}\n\t(1..m).each{\n\t\ti, j, c = gets.split.map &:to_i\n\t\tu = nodes[i]\n\t\tv = nodes[j]\n\t\tr = (u[1] < v[1] ? u : v)\n\t\tavailable[r] ||= []\n\t\tavailable[r] << [u, v, c]\n\t}\n\n\tnodes.shift\n\tnodes.sort_by!(&:last)\n\n\ttree_size = 0\n\tnode_num = 0\n\tuf = UnionFind.new\n\tseparator = Float::INFINITY\n\tdisconnected = false\n\n\ti = nodes.size-1\n\tuntil i < 0 \n\t\tmax = nodes[i][1]\n\t\twhile i >= 0 && nodes[i][1] == max\n\t\t\tv = nodes[i]\n\t\t\tnode_num += 1\n\t\t\tedges = (available[v] || [])\n\t\t\t\n\t\t\tedges.sort_by!(&:last)\n\t\t\tedges.each{|u, v, c|\n\t\t\t\tif !uf.same?(u, v)\t\n\t\t\t\t\tuf.union(u, v)\n\t\t\t\t\ttree_size += 1\n\t\t\t\tend\n\t\t\t}\n\t\t\ti -= 1\n\t\tend\n\n\t\tif tree_size == node_num - 1\n\t\t\tif disconnected\n\t\t\t\tseparator = v[1]\n\t\t\tend\n\t\t\tdisconnected = false\n\t\telse\n\t\t\tdisconnected = true\t\n\t\tend\n\tend\t\n\tedges = []\n\n\tsum = 0\n\ttree_size = 0\n\tnode_num = 0\n\tuf = UnionFind.new\n\n\tuntil nodes.empty? || nodes[-1][1] <= separator \n\t\tv = nodes.pop\n\t\tnode_num += 1\n\t\tedges += (available[v] || [])\n\tend\n\n\tuntil nodes.empty?\n\t\tmax = nodes[-1][1]\n\t\twhile !nodes.empty? && nodes[-1][1] == max\n\t\t\tv = nodes.pop\n\t\t\tnode_num += 1\n\t\t\tedges += (available[v] || [])\n\t\tend\n\t\t\t\n\t\tedges.sort_by!(&:last)\n\t\tedges.each{|u, v, c|\n\t\t\tif !uf.same?(u, v)\t\n\t\t\t\tuf.union(u, v)\n\t\t\t\tsum += c\n\t\t\t\ttree_size += 1\n\t\t\tend\n\t\t}\n\t\tedges = []\n\tend\n\tp tree_size == n - 1 ? sum : 0\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events;\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        foreach (int i, t; events) {\n            if (aliveIslands(t).connected(t)) {\n                lastTimeIndex = i;\n            } else {\n                break;\n            }\n        }\n\n        int ans = 0;\n        auto uftree = new UFTree(islands.length);\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            Bridge[] possibleBridges;\n            foreach (island; alived) {\n                foreach (bridge; island.bridges) {\n                    if (bridge.to.isAlive(t)) {\n                        possibleBridges ~= bridge;\n                    }\n                }\n            }\n            possibleBridges.sort;\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; possibleBridges) {\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n                bridge.cost = int.max;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[Island] used;\n    foreach (island; islands) used[island] = false;\n    void dfs(Island c) {\n        used[c] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (readf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events;\n        foreach (i; 0 .. N) {\n            int h; readf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; readf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            Bridge[] bs = [new Bridge(islands[a], islands[b], c), \n                           new Bridge(islands[b], islands[a], c)];\n            islands[a].bridges ~= bs[0];\n            islands[b].bridges ~= bs[1];\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        foreach (int i, t; events) {\n            if (aliveIslands(t).connected(t)) {\n                lastTimeIndex = i;\n            } else {\n                break;\n            }\n        }\n\n        int ans = 0;\n        auto uftree = new UFTree(islands.length);\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            Bridge[] possibleBridges;\n            foreach (island; alived) {\n                foreach (bridge; island.bridges) {\n                    if (bridge.to.isAlive(t)) {\n                        possibleBridges ~= bridge;\n                    }\n                }\n            }\n            possibleBridges.sort;\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; possibleBridges) {\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n                bridge.cost = 0;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    ulong cost;\n    this(Island from, Island to, ulong cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    override string toString() {\n        return \"Island \" ~ index.to!string;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) \n        if (island.isAlive(t)) \n            used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (! (bridge.from.isAlive(t) && bridge.to.isAlive(t)) ) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    foreach (island; islands) {\n        if (island.isAlive(t)) {\n            dfs(island);\n            break;\n        }\n    }\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events = [0];\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events = events.sort.uniq.array;\n        //events.writeln;\n        foreach (i; 0 .. M) {\n            int a, b; ulong c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        int lastTimeIndex = 0;\n        while (lastTimeIndex < events.length && islands.connected(events[lastTimeIndex])) {\n            lastTimeIndex++;\n        }\n\n        ulong ans = 0;\n        auto uftree = new UFTree(islands.length);\n        Bridge[] bridges;\n        foreach (island; islands) {\n            bridges ~= island.bridges;\n        }\n        bridges.sort!((a, b) => a.cost < b.cost);\n        //bridges.map!(a => a.cost).writeln;;\n        foreach (t; events[0 .. lastTimeIndex].reverse) {\n            foreach (bridge; bridges) {\n                if (! (bridge.to.isAlive(t) && bridge.from.isAlive(t)) ) continue;\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events = [0];\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        int lb = 0, ub = cast(int)events.length;\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            int t = events[mid];\n            if (aliveIslands(t).connected(t)) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        lastTimeIndex = lb;\n\n        int ans = 0;\n        auto uftree = new UFTree(islands.length);\n        Bridge[] bridges;\n        foreach (island; islands) {\n            bridges ~= island.bridges;\n        }\n        bridges.sort;\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; bridges) {\n                if (bridge.cost == 0) continue;\n                if (! (bridge.to.isAlive(t) && bridge.from.isAlive(t)) ) continue;\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n                bridge.cost = 0;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events;\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        foreach (int i, t; events) {\n            if (aliveIslands(t).connected(t)) {\n                lastTimeIndex = i;\n            } else {\n                break;\n            }\n        }\n\n        int ans = 0;\n        auto uftree = new UFTree(islands.length);\n        bool[Bridge] bridgeUsed;\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            Bridge[] possibleBridges;\n            foreach (island; alived) {\n                foreach (bridge; island.bridges) {\n                    if (bridge.to.isAlive(t) && !bridgeUsed.get(bridge, false)) {\n                        possibleBridges ~= bridge;\n                    }\n                }\n            }\n            possibleBridges.sort;\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; possibleBridges) {\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n                bridge.cost = 0;\n                bridgeUsed[bridge] = true;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events;\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        foreach (int i, t; events) {\n            if (aliveIslands(t).connected(t)) {\n                lastTimeIndex = i;\n            } else {\n                break;\n            }\n        }\n\n        int ans = 0;\n        auto uftree = new UFTree(islands.length);\n        bool[Bridge] bridgeUsed;\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            Bridge[] possibleBridges;\n            foreach (island; alived) {\n                foreach (bridge; island.bridges) {\n                    if (bridge.to.isAlive(t) && !bridgeUsed.get(bridge, false)) {\n                        possibleBridges ~= bridge;\n                        bridgeUsed[bridge] = true;\n                    }\n                }\n            }\n            possibleBridges.sort;\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; possibleBridges) {\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n                bridge.cost = int.max;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree(T) {\n    T[T] parent;\n    this(T[] set) {\n        foreach (elem; set) {\n            parent[elem] = null;\n        }\n    }\n    T root(T k) {\n        if (parent[k]) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(T x, T y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(T x, T y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[Island] used;\n    foreach (island; islands) used[island] = false;\n    void dfs(Island c) {\n        used[c] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (readf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events;\n        foreach (i; 0 .. N) {\n            int h; readf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; readf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            Bridge[] bs = [new Bridge(islands[a], islands[b], c), \n                           new Bridge(islands[b], islands[a], c)];\n            islands[a].bridges ~= bs[0];\n            islands[b].bridges ~= bs[1];\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            return islands.filter!(a => a.isAlive(t)).array;\n        }\n\n        int lastTimeIndex = 0;\n        foreach (int i, t; events) {\n            if (aliveIslands(t).connected(t)) {\n                lastTimeIndex = i;\n            } else {\n                break;\n            }\n        }\n\n        int ans = 0;\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            auto uftree = new UFTree!Island(alived);\n            Bridge[] possibleBridges;\n            foreach (island; alived) {\n                possibleBridges ~= island.bridges.filter!(b => b.to.isAlive(t)).array;\n            }\n            possibleBridges.sort;\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; possibleBridges) {\n                if (uftree.equivalent(bridge.to, bridge.from)) continue;\n                uftree.unite(bridge.to, bridge.from);\n                ans += bridge.cost;\n                bridge.cost = 0;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events = [0];\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        foreach (int i, t; events) {\n            if (aliveIslands(t).connected(t)) {\n                lastTimeIndex = i;\n            } else {\n                break;\n            }\n        }\n\n        int ans = 0;\n        auto uftree = new UFTree(islands.length);\n        bool[Bridge] bridgeUsed;\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            Bridge[] possibleBridges;\n            foreach (island; alived) {\n                foreach (bridge; island.bridges) {\n                    if (bridge.to.isAlive(t) && !bridgeUsed.get(bridge, false)) {\n                        possibleBridges ~= bridge;\n                    }\n                }\n            }\n            possibleBridges.sort;\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; possibleBridges) {\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) {\n                    bridgeUsed[bridge] = true;\n                    continue;\n                }\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n                bridge.cost = int.max;\n                bridgeUsed[bridge] = true;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree(T) {\n    T[T] parent;\n    this(T[] set) {\n        foreach (elem; set) {\n            parent[elem] = null;\n        }\n    }\n    T root(T k) {\n        if (parent[k]) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(T x, T y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(T x, T y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[Island] used;\n    foreach (island; islands) used[island] = false;\n    void dfs(Island c) {\n        used[c] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (readf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events;\n        foreach (i; 0 .. N) {\n            int h; readf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; readf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            Bridge[] bs = [new Bridge(islands[a], islands[b], c), \n                           new Bridge(islands[b], islands[a], c)];\n            islands[a].bridges ~= bs[0];\n            islands[b].bridges ~= bs[1];\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            return islands.filter!(a => a.isAlive(t)).array;\n        }\n\n        int lastTimeIndex = 0;\n        foreach (int i, t; events) {\n            if (aliveIslands(t).connected(t)) {\n                lastTimeIndex = i;\n            } else {\n                break;\n            }\n        }\n\n        int ans = 0;\n        auto uftree = new UFTree!Island(islands);\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            Bridge[] possibleBridges;\n            foreach (island; alived) {\n                foreach (bridge; island.bridges) {\n                    if (bridge.to.isAlive(t)) {\n                        possibleBridges ~= bridge;\n                    }\n                }\n            }\n            possibleBridges.sort;\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; possibleBridges) {\n                if (uftree.equivalent(bridge.to, bridge.from)) continue;\n                uftree.unite(bridge.to, bridge.from);\n                ans += bridge.cost;\n                bridge.cost = 0;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events;\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        foreach (int i, t; events) {\n            if (aliveIslands(t).connected(t)) {\n                lastTimeIndex = i;\n            } else {\n                break;\n            }\n        }\n\n        int ans = 0;\n        auto uftree = new UFTree(islands.length);\n        bool[Bridge] bridgeUsed;\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            Bridge[] possibleBridges;\n            foreach (island; alived) {\n                foreach (bridge; island.bridges) {\n                    if (bridge.to.isAlive(t) && !bridgeUsed.get(bridge, false)) {\n                        possibleBridges ~= bridge;\n                    }\n                }\n            }\n            possibleBridges.sort;\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; possibleBridges) {\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) {\n                    bridgeUsed[bridge] = true;\n                    continue;\n                }\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n                bridge.cost = int.max;\n                bridgeUsed[bridge] = true;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events;\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        foreach (int i, t; events) {\n            if (aliveIslands(t).connected(t)) {\n                lastTimeIndex = i;\n            } else {\n                break;\n            }\n        }\n\n        int ans = 0;\n        auto uftree = new UFTree(islands.length);\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            Bridge[] possibleBridges;\n            foreach (island; alived) {\n                foreach (bridge; island.bridges) {\n                    if (bridge.to.isAlive(t)) {\n                        possibleBridges ~= bridge;\n                    }\n                }\n            }\n            possibleBridges.sort;\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; possibleBridges) {\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n                bridge.cost = 0;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    ulong cost;\n    this(Island from, Island to, ulong cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events = [0];\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b; ulong c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        int lb = 0, ub = cast(int)events.length;\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            int t = events[mid];\n            if (aliveIslands(t).connected(t)) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        lastTimeIndex = ub;\n\n        ulong ans = 0;\n        auto uftree = new UFTree(islands.length);\n        Bridge[] bridges;\n        foreach (island; islands) {\n            bridges ~= island.bridges;\n        }\n        bridges.sort!((a, b) => a.cost < b.cost);\n        //bridges.map!(a => a.cost).writeln;;\n        foreach (t; events[0 .. lastTimeIndex].reverse) {\n            foreach (bridge; bridges) {\n                if (! (bridge.to.isAlive(t) && bridge.from.isAlive(t)) ) continue;\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree(T) {\n    T[T] parent;\n    this(T[] set) {\n        foreach (elem; set) {\n            parent[elem] = null;\n        }\n    }\n    T root(T k) {\n        if (parent[k]) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(T x, T y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(T x, T y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    int cost;\n    this(Island from, Island to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[Island] used;\n    foreach (island; islands) used[island] = false;\n    void dfs(Island c) {\n        used[c] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (readf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events;\n        foreach (i; 0 .. N) {\n            int h; readf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b, c; readf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            Bridge[] bs = [new Bridge(islands[a], islands[b], c), \n                           new Bridge(islands[b], islands[a], c)];\n            islands[a].bridges ~= bs[0];\n            islands[b].bridges ~= bs[1];\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            return islands.filter!(a => a.isAlive(t)).array;\n        }\n\n        int lastTimeIndex = 0;\n        foreach (int i, t; events) {\n            if (aliveIslands(t).connected(t)) {\n                lastTimeIndex = i;\n            } else {\n                break;\n            }\n        }\n\n        int ans = 0;\n        auto uftree = new UFTree!Island(islands);\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            Island[] alived = aliveIslands(t);\n            Bridge[] possibleBridges;\n            foreach (island; alived) {\n                possibleBridges ~= island.bridges.filter!(b => b.to.isAlive(t)).array;\n            }\n            possibleBridges.sort;\n            //possibleBridges.map!(a => [a.from.index, a.to.index, a.cost]).writeln;\n            foreach (bridge; possibleBridges) {\n                if (uftree.equivalent(bridge.to, bridge.from)) continue;\n                uftree.unite(bridge.to, bridge.from);\n                ans += bridge.cost;\n                bridge.cost = 0;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport core.thread;\n\nvoid main() {\n    Thread.sleep(dur!\"seconds\"(15));\n    writeln(\"hello, world\");\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    ulong cost;\n    this(Island from, Island to, ulong cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    override string toString() {\n        return \"Island \" ~ index.to!string;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events = [0];\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events = events.sort.uniq.array;\n        //events.writeln;\n        foreach (i; 0 .. M) {\n            int a, b; ulong c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        int lb = 0, ub = cast(int)events.length;\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            int t = events[mid];\n            if (aliveIslands(t).connected(t)) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        lastTimeIndex = ub;\n\n        ulong ans = 0;\n        auto uftree = new UFTree(islands.length);\n        Bridge[] bridges;\n        foreach (island; islands) {\n            bridges ~= island.bridges;\n        }\n        bridges.sort!((a, b) => a.cost < b.cost);\n        //bridges.map!(a => a.cost).writeln;;\n        foreach (t; events[0 .. lastTimeIndex].reverse) {\n            //writeln(aliveIslands(t));\n            foreach (bridge; bridges) {\n                if (! (bridge.to.isAlive(t) && bridge.from.isAlive(t)) ) continue;\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    ulong cost;\n    this(Island from, Island to, ulong cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    override int opCmp(Object o) {\n        return cost > (cast(Bridge)o).cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    override int opCmp(Object o) {\n        return sinkTime < (cast(Island)o).sinkTime;\n    }\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events = [0];\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort;\n        foreach (i; 0 .. M) {\n            int a, b; ulong c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        int lb = 0, ub = cast(int)events.length;\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            int t = events[mid];\n            if (aliveIslands(t).connected(t)) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        lastTimeIndex = lb;\n\n        ulong ans = 0;\n        auto uftree = new UFTree(islands.length);\n        Bridge[] bridges;\n        foreach (island; islands) {\n            bridges ~= island.bridges;\n        }\n        bridges.sort;\n        foreach (t; events[0 .. lastTimeIndex + 1].reverse) {\n            foreach (bridge; bridges) {\n                if (bridge.cost == 0) continue;\n                if (! (bridge.to.isAlive(t) && bridge.from.isAlive(t)) ) continue;\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.array;\nimport std.algorithm;\nimport std.range;\nimport std.functional;\n\nclass UFTree {\n    int[] parent;\n    this(ulong size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int k) {\n        if (parent[k] >= 0) {\n            return parent[k] = root(parent[k]);\n        } else {\n            return k;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        parent[x] = y;\n    }\n    bool equivalent(int x, int y) {\n        return root(x) == root(y);\n    }\n}\n\nclass Bridge {\n    Island from;\n    Island to;\n    ulong cost;\n    this(Island from, Island to, ulong cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n}\n\nclass Island {\n    int index;\n    int sinkTime;\n    Bridge[] bridges;\n    this(int index, int sinkTime) {\n        this.index = index;\n        this.sinkTime = sinkTime;\n    }\n    bool isAlive(int t) {\n        return t <= sinkTime;\n    }\n}\n\nbool connected(Island[] islands, int t = 0) {\n    if (islands.empty) return false;\n    bool[int] used;\n    foreach (island; islands) used[island.index] = false;\n    void dfs(Island c) {\n        used[c.index] = true;\n        foreach (bridge; c.bridges) {\n            if (!bridge.to.isAlive(t)) continue;\n            if (used[bridge.to.index]) continue;\n            dfs(bridge.to);\n        }\n    }\n    dfs(islands[0]);\n    foreach (k, v; used) {\n        if (!v) return false;\n    }\n    return true;\n}\n\nvoid main() {\n    int N, M;\n    while (scanf(\"%d %d\\n\", &N, &M), N || M) {\n        Island[] islands;\n        int[] events = [0];\n        foreach (i; 0 .. N) {\n            int h; scanf(\"%d\\n\", &h);\n            islands ~= new Island(i, h);\n            events ~= h;\n        }\n        events.sort.uniq.array;\n        foreach (i; 0 .. M) {\n            int a, b; ulong c; scanf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            islands[a].bridges ~= new Bridge(islands[a], islands[b], c); \n            islands[b].bridges ~= new Bridge(islands[b], islands[a], c);\n        }\n\n        if (!islands.connected) {\n            writeln(0);\n            continue;\n        }\n\n        Island[] aliveIslands(int t) {\n            Island[] alive;\n            foreach (island; islands) {\n                if (island.isAlive(t)) {\n                    alive ~= island;\n                }\n            }\n            return alive;\n        }\n\n        int lastTimeIndex = 0;\n        int lb = 0, ub = cast(int)events.length;\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            int t = events[mid];\n            if (aliveIslands(t).connected(t)) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        lastTimeIndex = ub;\n\n        ulong ans = 0;\n        auto uftree = new UFTree(islands.length);\n        Bridge[] bridges;\n        foreach (island; islands) {\n            bridges ~= island.bridges;\n        }\n        bridges.sort!((a, b) => a.cost < b.cost);\n        //bridges.map!(a => a.cost).writeln;;\n        foreach (t; events[0 .. lastTimeIndex].reverse) {\n            foreach (bridge; bridges) {\n                if (! (bridge.to.isAlive(t) && bridge.from.isAlive(t)) ) continue;\n                if (uftree.equivalent(bridge.to.index, bridge.from.index)) continue;\n                uftree.unite(bridge.to.index, bridge.from.index);\n                ans += bridge.cost;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [-1] * size\n    \n    def find(self, x):\n        while self.table[x] >= 0:\n            x = self.table[x]\n        return x\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            if self.table[x_root] < self.table[y_root]:\n                self.table[x_root] += self.table[y_root]\n                self.table[y_root] = x_root\n            else:\n                self.table[y_root] += self.table[x_root]\n                self.table[x_root] = y_root\n    \n    def isDisjoint(self, x, y):\n        return self.find(x) != self.find(y)\n\n\ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    from bisect import bisect_left\n    \n    while True:\n        N, M = map(int, input_lines[0].split())\n        if N == 0 and M == 0:\n            break\n        \n        h = map(int, input_lines[1:1+N])\n        h = list(zip(h, range(1, 1 + N)))\n        h.sort()\n        rm_days, islands = zip(*h)\n        \n        bridges = [tuple(map(int, l.split())) for l in input_lines[1+N:1+N+M]]\n        bridges.sort(key=lambda x: x[2])\n        \n        S = UnionFind(N + 1)\n        cost = 0\n        i = N\n        mst_flag = True\n        while i > 0:\n            j = i\n            i -= 1\n            i = bisect_left(rm_days, rm_days[i])\n            unsunk_islands = islands[i:]\n            \n            f = lambda x: x[0] in unsunk_islands and x[1] in unsunk_islands\n            target_bridges = filter(f, bridges)\n            \n            # Number of required bridges\n            if mst_flag:\n                bridge_num = len(unsunk_islands) - 1\n            else:\n                bridge_num = j - i\n            cnt = 0\n            # Kruskal's algorithm\n            for bridge in target_bridges:\n                a, b, c = bridge\n                if S.isDisjoint(a, b):\n                    S.union(a, b)\n                    cost += c\n                    cnt += 1\n                    if cnt == bridge_num:\n                        mst_flag = False\n                        break\n            else:\n                mst_flag = True\n                S = UnionFind(N + 1)\n                cost = 0\n        \n        if -N in S.table:\n            print(cost)\n        else:\n            print(0)\n            \n        del input_lines[:N+1+M]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] <= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n            return True\n        return False\n\n    def subsetall(self):\n        a = []\n        for i in range(len(self.table)):\n            if self.table[i] < 0:\n                a.append((i, -self.table[i]))\n        return a\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        h = [I() for _ in range(n)]\n        e = collections.defaultdict(list)\n        for _ in range(m):\n            a,b,c = LI_()\n            c += 1\n            e[a].append((b,c))\n            e[b].append((a,c))\n        hd = collections.defaultdict(list)\n        for i in range(n):\n            hd[h[i]].append(i)\n\n        us = set()\n        uf = UnionFind(n)\n        uc = 1\n        ek = inf\n        for k in sorted(hd.keys(), reverse=True):\n            us |= set(hd[k])\n            for i in hd[k]:\n                for b,c in e[i]:\n                    if b not in us:\n                        continue\n                    if uf.union(i,b):\n                        uc += 1\n            if uc != len(us):\n                ek = k\n\n        mi = min(h)\n        if ek == mi:\n            return 0\n        mk = max(c for c in h if c < ek)\n\n        r = 0\n        uf = UnionFind(n)\n        us = set([i for i in range(n) if h[i] >= mk])\n        el = []\n        for i in us:\n            for b,c in e[i]:\n                if b not in us:\n                    continue\n                el.append((c,i,b))\n        el.sort()\n        for c,a,b in el:\n            if uf.union(a,b):\n                r += c\n        for k in sorted([k for k in hd.keys() if k < mk], reverse=True):\n            us |= set(hd[k])\n            el = []\n            for i in hd[k]:\n                for b,c in e[i]:\n                    if b not in us:\n                        continue\n                    el.append((c,i,b))\n            el.sort()\n            for c,a,b in el:\n                if uf.union(a,b):\n                    r += c\n        return r\n\n    while 1:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [-1] * size\n    \n    def find(self, x):\n        while self.table[x] >= 0:\n            x = self.table[x]\n        return x\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            if self.table[x_root] < self.table[y_root]:\n                self.table[x_root] += self.table[y_root]\n                self.table[y_root] = x_root\n            else:\n                self.table[y_root] += self.table[x_root]\n                self.table[x_root] = y_root\n    \n    def isDisjoint(self, x, y):\n        return self.find(x) != self.find(y)\n\n\ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    \n    while True:\n        N, M = map(int, input_lines[0].split())\n        if N == 0 and M == 0:\n            break\n        \n        h = map(int, input_lines[1:1+N])\n        h = list(zip(h, range(1, 1 + N)))\n        h.sort()\n        rm_days, islands = zip(*h)\n        \n        bridges = [tuple(map(int, l.split())) for l in input_lines[1+N:1+N+M]]\n        bridges.sort(key=lambda x: x[2])\n        \n        from bisect import bisect_left\n        S = UnionFind(N + 1)\n        cost = 0\n        i = N\n        while i > 0:\n            i -= 1\n            i = bisect_left(rm_days, rm_days[i])\n            unsunk_islands = islands[i:]\n            \n            # Kruskal's algorithm\n            for bridge in bridges:\n                a, b, c = bridge\n                if a in unsunk_islands and b in unsunk_islands:\n                    if S.isDisjoint(a, b):\n                        S.union(a, b)\n                        cost += c\n            \n            if -len(unsunk_islands) not in S.table:\n                S = UnionFind(N + 1)\n                cost = 0\n        \n        if -N in S.table:\n            print(cost)\n        else:\n            print(0)\n            \n        del input_lines[:N+1+M]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom heapq import heappush, heappop, heapify\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    INF = 10**9\n    N, M = map(int, readline().split())\n    if N == M == 0:\n        return False\n    H = [int(readline()) for i in range(N)]\n    E = []\n    G = [[] for i in range(N)]\n    for i in range(M):\n        a, b, c = map(int, readline().split())\n        E.append((c, a-1, b-1))\n        G[a-1].append((b-1, c))\n        G[b-1].append((a-1, c))\n    E.sort()\n\n    mp = defaultdict(list)\n    for i in range(N):\n        mp[H[i]].append(i)\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n    def unite(x, y):\n        px = root(x); py = root(y)\n        if px == py:\n            return False\n        if sz[px] > sz[py]:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n        return True\n\n    *prt, = range(N)\n    sz = [1]*N\n\n    *hs, = mp.keys()\n    hs.sort(reverse=1)\n    U = [0]*N\n    c = 0\n    h0 = -1\n    k = -1\n    for i, h in enumerate(hs):\n        vs = mp[h]\n        for v in vs:\n            for w, _ in G[v]:\n                if not U[w]:\n                    continue\n                unite(v, w)\n            U[v] = 1\n            c += 1\n        v0 = root(vs[0])\n        if sz[v0] != c:\n            h0 = h\n            k = i\n\n    if k == len(hs)-1:\n        write(\"0\\n\")\n        return True\n\n    ans = 0\n\n    h = hs[k+1]\n    *prt, = range(N); sz = [1]*N\n    for c, a, b in E:\n        if H[a] >= h and H[b] >= h:\n            if unite(a, b):\n                ans += c\n\n    mc = [INF]*N\n    U = [0]*N\n    for v in range(N):\n        if H[v] < h:\n            continue\n        U[v] = 1\n        for w, d in G[v]:\n            if H[w] < h:\n                mc[w] = min(mc[w], d)\n\n    que = []\n    for v in range(N):\n        if H[v] >= h:\n            continue\n        que.append((-H[v], mc[v], v))\n    heapify(que)\n    while que:\n        _, cost, v = heappop(que)\n        if U[v]:\n            continue\n        U[v] = 1\n        h = H[v]\n        ans += cost\n        for w, d in G[v]:\n            if not U[w] and H[w] <= h and d < mc[w]:\n                mc[w] = d\n                heappush(que, (-H[w], d, w))\n    write(\"%d\\n\" % ans)\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [-1] * size\n    \n    def find(self, x):\n        while self.table[x] >= 0:\n            x = self.table[x]\n        return x\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            if self.table[x_root] < self.table[y_root]:\n                self.table[x_root] += self.table[y_root]\n                self.table[y_root] = x_root\n            else:\n                self.table[y_root] += self.table[x_root]\n                self.table[x_root] = y_root\n    \n    def isDisjoint(self, x, y):\n        return self.find(x) != self.find(y)\n\n\ndef solve():\n    import sys\n    file_input = sys.stdin\n    from bisect import bisect_left\n    \n    while True:\n        N, M = map(int, file_input.readline().split())\n        if N == 0:\n            break\n        \n        h = [int(file_input.readline()) for i in range(N)]\n        \n        # h_n's element: (remaining days, island number)\n        h_n = list(zip(h, range(N)))\n        h_n.sort()\n        days, islands = zip(*h_n)\n        \n        bridges = []\n        for i in range(M):\n            a, b, c = map(int, file_input.readline().split())\n            # change island numbering to 0-based\n            a -= 1\n            b -= 1\n            d = min(h[a], h[b])\n            bridges.append((a, b, c, d))\n        bridges.sort(key=lambda x: x[3], reverse=True)\n        \n        i = N\n        i_bridges = iter(bridges)\n        a, b, c, d = next(i_bridges)\n        S = UnionFind(N)\n        limit_day = None\n        while i > 0:\n            i -= 1\n            day = days[i]\n            i = bisect_left(days, day)\n            if day <= d:\n                S.union(a, b)\n                for a, b, c, d in i_bridges:\n                    if day > d:\n                        break\n                    S.union(a, b)\n            if i - N  in S.table:   # if islands are connected\n                if limit_day == None:\n                    limit_day = day\n            else:\n                limit_day = None\n        \n        if limit_day == None:\n            print(0)\n            continue\n        \n        bridges.sort(key=lambda x:(min(x[3], limit_day), -x[2]), reverse=True)\n        \n        S = UnionFind(N)\n        cost = 0\n        for a, b, c, d in bridges:\n            if S.isDisjoint(a, b):\n                S.union(a, b)\n                cost += c\n        \n        print(cost)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [-1] * size\n    \n    def find(self, x):\n        while self.table[x] >= 0:\n            x = self.table[x]\n        return x\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            if self.table[x_root] < self.table[y_root]:\n                self.table[x_root] += self.table[y_root]\n                self.table[y_root] = x_root\n            else:\n                self.table[y_root] += self.table[x_root]\n                self.table[x_root] = y_root\n    \n    def isDisjoint(self, x, y):\n        return self.find(x) != self.find(y)\n\n\ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    from bisect import bisect_left\n    \n    while True:\n        N, M = map(int, input_lines[0].split())\n        if N == 0 and M == 0:\n            break\n        \n        h = map(int, input_lines[1:1+N])\n        h = list(zip(h, range(1, 1 + N)))\n        h.sort()\n        rm_days, islands = zip(*h)\n        \n        bridges = [tuple(map(int, l.split())) for l in input_lines[1+N:1+N+M]]\n        bridges.sort(key=lambda x: x[2])\n        \n        S = UnionFind(N + 1)\n        cost = 0\n        i = N\n        while i > 0:\n            i -= 1\n            i = bisect_left(rm_days, rm_days[i])\n            unsunk_islands = islands[i:]\n            \n            # Kruskal's algorithm\n            for bridge in bridges:\n                a, b, c = bridge\n                if a in unsunk_islands and b in unsunk_islands:\n                    if S.isDisjoint(a, b):\n                        S.union(a, b)\n                        cost += c\n            \n            if -len(unsunk_islands) not in S.table:\n                S = UnionFind(N + 1)\n                cost = 0\n        \n        if -N in S.table:\n            print(cost)\n        else:\n            print(0)\n            \n        del input_lines[:N+1+M]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [-1] * size\n    \n    def find(self, x):\n        while self.table[x] >= 0:\n            x = self.table[x]\n        return x\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            if self.table[x_root] < self.table[y_root]:\n                self.table[x_root] += self.table[y_root]\n                self.table[y_root] = x_root\n            else:\n                self.table[y_root] += self.table[x_root]\n                self.table[x_root] = y_root\n    \n    def isDisjoint(self, x, y):\n        return self.find(x) != self.find(y)\n\n\ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    from bisect import bisect_left\n    from itertools import filterfalse\n    \n    while True:\n        N, M = map(int, input_lines[0].split())\n        if N == 0 and M == 0:\n            break\n        \n        h = map(int, input_lines[1:1+N])\n        h = list(zip(h, range(1, 1 + N)))\n        h.sort()\n        rm_days, islands = zip(*h)\n        \n        bridges = [tuple(map(int, l.split())) for l in input_lines[1+N:1+N+M]]\n        bridges.sort(key=lambda x: x[2])\n        \n        S = UnionFind(N + 1)\n        cost = 0\n        i = N\n        mst_flag = True\n        target_bridges = bridges.copy()\n        while i > 0:\n            if mst_flag:\n                i -= 1\n                i = bisect_left(rm_days, rm_days[i])\n                unsunk_islands = islands[i:]\n                \n                f = lambda x: x[0] in unsunk_islands and x[1] in unsunk_islands\n                target_bridges = filter(f, bridges)\n                \n                # Number of required bridges\n                bridge_num = len(unsunk_islands) - 1\n                cnt = 0\n                # Kruskal's algorithm\n                for bridge in target_bridges:\n                    a, b, c = bridge\n                    if S.isDisjoint(a, b):\n                        S.union(a, b)\n                        cost += c\n                        cnt += 1\n                        if cnt == bridge_num:\n                            mst_flag = False\n                            break\n                else:\n                    mst_flag = True\n                    S = UnionFind(N + 1)\n                    cost = 0\n            else:\n                j = i\n                i -= 1\n                i = bisect_left(rm_days, rm_days[i])\n                present_islands = islands[i:]\n                unsunk_islands = islands[j:]\n                \n                f = lambda x: x[0] in present_islands and x[1] in present_islands\n                target_bridges = filter(f, bridges)\n                f = lambda x: x[0] in unsunk_islands and x[1] in unsunk_islands\n                target_bridges = filterfalse(f, target_bridges)\n                \n                # Number of required bridges\n                bridge_num = j - i\n                cnt = 0\n                # Kruskal's algorithm\n                for bridge in target_bridges:\n                    a, b, c = bridge\n                    if S.isDisjoint(a, b):\n                        S.union(a, b)\n                        cost += c\n                        cnt += 1\n                        if cnt == bridge_num:\n                            break\n                else:\n                    mst_flag = True\n                    S = UnionFind(N + 1)\n                    cost = 0\n        \n        if -N in S.table:\n            print(cost)\n        else:\n            print(0)\n            \n        del input_lines[:N+1+M]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [-1] * size\n    \n    def find(self, x):\n        while self.table[x] >= 0:\n            x = self.table[x]\n        return x\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            if self.table[x_root] < self.table[y_root]:\n                self.table[x_root] += self.table[y_root]\n                self.table[y_root] = x_root\n            else:\n                self.table[y_root] += self.table[x_root]\n                self.table[x_root] = y_root\n    \n    def isDisjoint(self, x, y):\n        return self.find(x) != self.find(y)\n\n\ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    from bisect import bisect_left\n    \n    while True:\n        N, M = map(int, input_lines[0].split())\n        if N != 0 and M != 0:\n            print(0)\n            break\n        \n        h = map(int, input_lines[1:1+N])\n        h = list(zip(h, range(1, 1 + N)))\n        h.sort()\n        rm_days, islands = zip(*h)\n        \n        bridges = [tuple(map(int, l.split())) for l in input_lines[1+N:1+N+M]]\n        bridges.sort(key=lambda x: x[2])\n        \n        S = UnionFind(N + 1)\n        cost = 0\n        i = N\n        while i > 0:\n            i -= 1\n            i = bisect_left(rm_days, rm_days[i])\n            unsunk_islands = islands[i:]\n            \n            # Kruskal's algorithm\n            for bridge in bridges:\n                a, b, c = bridge\n                if a in unsunk_islands and b in unsunk_islands:\n                    if S.isDisjoint(a, b):\n                        S.union(a, b)\n                        cost += c\n            \n            if -len(unsunk_islands) not in S.table:\n                S = UnionFind(N + 1)\n                cost = 0\n        \n        if -N in S.table:\n            print(cost)\n        else:\n            print(0)\n            \n        del input_lines[:N+1+M]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [-1] * size\n    \n    def find(self, x):\n        while self.table[x] >= 0:\n            x = self.table[x]\n        return x\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            if self.table[x_root] < self.table[y_root]:\n                self.table[x_root] += self.table[y_root]\n                self.table[y_root] = x_root\n            else:\n                self.table[y_root] += self.table[x_root]\n                self.table[x_root] = y_root\n    \n    def isDisjoint(self, x, y):\n        return self.find(x) != self.find(y)\n\n\ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    \n    while True:\n        N, M = map(int, input_lines[0].split())\n        if N == 0 and M == 0:\n            break\n        \n        h = map(int, input_lines[1:1+N])\n        h = list(zip(h, range(1, 1 + N)))\n        h.sort()\n        rm_days, islands = zip(*h)\n        \n        bridges = [tuple(map(int, l.split())) for l in input_lines[1+N:1+N+M]]\n        bridges.sort(key=lambda x: x[2])\n        \n        from bisect import bisect_left\n        S = UnionFind(N + 1)\n        cost = 0\n        i = N\n        while i > 0:\n            i -= 1\n            i = bisect_left(rm_days, rm_days[i])\n            unsunk_islands = islands[i:]\n            \n            # Kruskal's algorithm\n            for bridge in bridges:\n                a, b, c = bridge\n                if a in unsunk_islands and b in unsunk_islands:\n                    if S.isDisjoint(a, b):\n                        S.union(a, b)\n                        cost += c\n            \n            if -len(unsunk_islands) not in S.table:\n                S = UnionFind(N + 1)\n                cost = 0\n        \n        if -N in S.table:\n            print(cost)\n        else:\n            print(0)\n            \n        del input_lines[:N+1+M]\n\nsolve()\n"
  }
]