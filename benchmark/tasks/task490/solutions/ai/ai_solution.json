[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_H 20\n#define MAX_W 20\n\nint h, w;\nchar board[MAX_H][MAX_W];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid mark_walls(int x, int y) {\n    board[x][y] = 'W';\n    for (int d = 0; d < 4; d++) {\n        int nx = x + dx[d], ny = y + dy[d];\n        while (nx >= 0 && nx < h && ny >= 0 && ny < w && \n               board[nx][ny] != 'W') {\n            board[nx][ny] = 'W';\n            nx += dx[d];\n            ny += dy[d];\n        }\n    }\n}\n\nbool is_valid_move(int x, int y) {\n    return x >= 0 && x < h && y >= 0 && y < w && board[x][y] == '.';\n}\n\nbool can_move(char board_copy[MAX_H][MAX_W]) {\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (board_copy[i][j] == '.') return true;\n        }\n    }\n    return false;\n}\n\nbool minimax(char board_copy[MAX_H][MAX_W], bool is_first_player, int depth) {\n    if (!can_move(board_copy)) {\n        return !is_first_player;\n    }\n\n    if (depth == 0) return false;\n\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (is_valid_move(i, j)) {\n                char temp_board[MAX_H][MAX_W];\n                memcpy(temp_board, board_copy, sizeof(temp_board));\n                mark_walls(i, j);\n\n                if (!minimax(temp_board, !is_first_player, depth - 1)) {\n                    return true;\n                }\n\n                memcpy(board_copy, temp_board, sizeof(temp_board));\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &h, &w);\n    \n    for (int i = 0; i < h; i++) {\n        scanf(\"%s\", board[i]);\n    }\n\n    bool first_player_wins = minimax(board, true, h * w);\n    printf(\"%s\\n\", first_player_wins ? \"First\" : \"Second\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_HW 20\n\ntypedef struct {\n    char board[MAX_HW][MAX_HW];\n    int H, W;\n} GameState;\n\nint memo[1 << (2 * MAX_HW)];\n\nint get_key(GameState *gs) {\n    int key = 0;\n    for (int i = 0; i < gs->H; i++) {\n        for (int j = 0; j < gs->W; j++) {\n            key <<= 1;\n            if (gs->board[i][j] == 'E') key |= 1;\n            key <<= 1;\n            if (gs->board[i][j] == 'M') key |= 1;\n        }\n    }\n    return key;\n}\n\nvoid mark(GameState *gs, int r, int c, int dr, int dc) {\n    while (r >= 0 && r < gs->H && c >= 0 && c < gs->W && gs->board[r][c] != 'W') {\n        if (gs->board[r][c] == 'E') gs->board[r][c] = 'M';\n        r += dr;\n        c += dc;\n    }\n}\n\nint grundy(GameState *gs) {\n    int key = get_key(gs);\n    if (memo[key] != -1) return memo[key];\n\n    int mex[MAX_HW * MAX_HW + 2] = {0};\n    for (int i = 0; i < gs->H; i++) {\n        for (int j = 0; j < gs->W; j++) {\n            if (gs->board[i][j] == 'E') {\n                GameState next = *gs;\n                next.board[i][j] = 'W';\n                mark(&next, i+1, j, 1, 0);\n                mark(&next, i-1, j, -1, 0);\n                mark(&next, i, j+1, 0, 1);\n                mark(&next, i, j-1, 0, -1);\n                int g = grundy(&next);\n                if (g <= MAX_HW * MAX_HW) mex[g] = 1;\n            }\n        }\n    }\n\n    int g = 0;\n    while (mex[g]) g++;\n    memo[key] = g;\n    return g;\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    GameState gs;\n    gs.H = H;\n    gs.W = W;\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", gs.board[i]);\n    }\n\n    memset(memo, -1, sizeof(memo));\n    int result = grundy(&gs);\n    printf(\"%s\\n\", result != 0 ? \"First\" : \"Second\");\n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nunordered_map<string, int> memo;\n\nint grundy(int h, int w) {\n    if (h == 0 || w == 0) return 0;\n    string key = to_string(h) + \",\" + to_string(w);\n    if (memo.find(key) != memo.end()) return memo[key];\n    \n    vector<bool> mex(h * w + 1, false);\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            int g = grundy(i, j) ^ grundy(i, w - j - 1) ^ grundy(h - i - 1, j) ^ grundy(h - i - 1, w - j - 1);\n            mex[g] = true;\n        }\n    }\n    \n    int res = 0;\n    while (mex[res]) ++res;\n    memo[key] = res;\n    return res;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> board(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> board[i];\n    }\n    \n    int total = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (board[i][j] == '.') {\n                int h = 1, w = 1;\n                while (i + h < H && board[i + h][j] == '.') ++h;\n                while (j + w < W && board[i][j + w] == '.') ++w;\n                total ^= grundy(h, w);\n                for (int di = 0; di < h; ++di) {\n                    for (int dj = 0; dj < w; ++dj) {\n                        board[i + di][j + dj] = 'x';\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << (total != 0 ? \"First\" : \"Second\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:54:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WallMakingGame {\n    private Map<String, Boolean> memo = new HashMap<>();\n\n    public char whoWins(String[] board) {\n        int h = board.length;\n        int w = board[0].length();\n        char[][] grid = new char[h][w];\n        for (int i = 0; i < h; i++) {\n            grid[i] = board[i].toCharArray();\n        }\n        return canWin(grid) ? 'Y' : 'N';\n    }\n\n    private boolean canWin(char[][] grid) {\n        String key = serialize(grid);\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] == '.') {\n                    char[][] newGrid = copyGrid(grid);\n                    mark(newGrid, i, j);\n                    if (!canWin(newGrid)) {\n                        memo.put(key, true);\n                        return true;\n                    }\n                }\n            }\n        }\n\n        memo.put(key, false);\n        return false;\n    }\n\n    private void mark(char[][] grid, int i, int j) {\n        int h = grid.length;\n        int w = grid[0].length;\n        grid[i][j] = '#';\n\n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n\n        for (int d = 0; d < 4; d++) {\n            int x = i + dx[d];\n            int y = j + dy[d];\n            while (x >= 0 && x < h && y >= 0 && y < w && grid[x][y] != '#') {\n                grid[x][y] = '#';\n                x += dx[d];\n                y += dy[d];\n            }\n        }\n    }\n\n    private char[][] copyGrid(char[][] grid) {\n        char[][] newGrid = new char[grid.length][grid[0].length];\n        for (int i = 0; i < grid.length; i++) {\n            System.arraycopy(grid[i], 0, newGrid[i], 0, grid[i].length);\n        }\n        return newGrid;\n    }\n\n    private String serialize(char[][] grid) {\n        StringBuilder sb = new StringBuilder();\n        for (char[] row : grid) {\n            sb.append(row);\n        }\n        return sb.toString();\n    }\n}",
    "timestamp": "2025-08-05 21:54:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WallMakingGame {\n    private int H, W;\n    private char[][] board;\n    private int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    public String determineWinner(char[][] board) {\n        this.board = board;\n        this.H = board.length;\n        this.W = board[0].length;\n        \n        return minimax(0, true) ? \"First\" : \"Second\";\n    }\n    \n    private boolean minimax(int depth, boolean isFirstPlayer) {\n        List<int[]> validMoves = findValidMoves();\n        \n        if (validMoves.isEmpty()) {\n            return !isFirstPlayer;\n        }\n        \n        if (isFirstPlayer) {\n            for (int[] move : validMoves) {\n                makeMove(move[0], move[1]);\n                boolean result = minimax(depth + 1, false);\n                undoMove(move[0], move[1]);\n                \n                if (result) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            for (int[] move : validMoves) {\n                makeMove(move[0], move[1]);\n                boolean result = minimax(depth + 1, true);\n                undoMove(move[0], move[1]);\n                \n                if (!result) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    \n    private List<int[]> findValidMoves() {\n        List<int[]> moves = new ArrayList<>();\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (board[i][j] == '.') {\n                    moves.add(new int[]{i, j});\n                }\n            }\n        }\n        \n        return moves;\n    }\n    \n    private void makeMove(int row, int col) {\n        board[row][col] = 'W';\n        \n        for (int[] dir : directions) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n            \n            while (isValidCell(newRow, newCol) && board[newRow][newCol] != 'W') {\n                board[newRow][newCol] = 'W';\n                newRow += dir[0];\n                newCol += dir[1];\n            }\n        }\n    }\n    \n    private void undoMove(int row, int col) {\n        board[row][col] = '.';\n        \n        for (int[] dir : directions) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n            \n            while (isValidCell(newRow, newCol) && board[newRow][newCol] == 'W') {\n                board[newRow][newCol] = '.';\n                newRow += dir[0];\n                newCol += dir[1];\n            }\n        }\n    }\n    \n    private boolean isValidCell(int row, int col) {\n        return row >= 0 && row < H && col >= 0 && col < W;\n    }\n}",
    "timestamp": "2025-08-05 21:54:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nclass WallMakingGame {\nprivate:\n    int H, W;\n    std::vector<std::vector<char>> board;\n    std::vector<std::vector<int>> memo;\n\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n\n    bool isValidCell(int x, int y) {\n        return x >= 0 && x < H && y >= 0 && y < W;\n    }\n\n    int countWalls(int x, int y) {\n        int walls = 0;\n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            while (isValidCell(nx, ny) && board[nx][ny] != 'W') {\n                if (board[nx][ny] == '.') walls++;\n                nx += dx[k];\n                ny += dy[k];\n            }\n        }\n        return walls;\n    }\n\n    int minimax(int player) {\n        int bestScore = (player == 1) ? INT_MIN : INT_MAX;\n        bool movePossible = false;\n\n        for (int x = 0; x < H; x++) {\n            for (int y = 0; y < W; y++) {\n                if (board[x][y] == '.') {\n                    movePossible = true;\n                    int wallCount = countWalls(x, y);\n                    \n                    // Make move\n                    board[x][y] = 'W';\n                    for (int k = 0; k < 4; k++) {\n                        int nx = x + dx[k], ny = y + dy[k];\n                        while (isValidCell(nx, ny) && board[nx][ny] != 'W') {\n                            if (board[nx][ny] == '.') board[nx][ny] = 'W';\n                            nx += dx[k];\n                            ny += dy[k];\n                        }\n                    }\n\n                    int score;\n                    if (wallCount == 0) {\n                        score = (player == 1) ? INT_MIN : INT_MAX;\n                    } else {\n                        score = minimax(3 - player);\n                    }\n\n                    // Undo move\n                    board[x][y] = '.';\n                    for (int k = 0; k < 4; k++) {\n                        int nx = x + dx[k], ny = y + dy[k];\n                        while (isValidCell(nx, ny) && board[nx][ny] == 'W') {\n                            if (board[nx][ny] == 'W') board[nx][ny] = '.';\n                            nx += dx[k];\n                            ny += dy[k];\n                        }\n                    }\n\n                    if (player == 1) {\n                        bestScore = std::max(bestScore, score);\n                    } else {\n                        bestScore = std::min(bestScore, score);\n                    }\n                }\n            }\n        }\n\n        if (!movePossible) {\n            return (player == 1) ? INT_MIN : INT_MAX;\n        }\n\n        return bestScore;\n    }\n\npublic:\n    int determineWinner(std::vector<std::string>& boardInput) {\n        H = boardInput.size();\n        W = boardInput[0].length();\n        board.resize(H, std::vector<char>(W));\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                board[i][j] = boardInput[i][j];\n            }\n        }\n\n        int result = minimax(1);\n        return (result > 0) ? 1 : 2;\n    }\n};",
    "timestamp": "2025-08-05 21:55:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_win(board, h, w):\n    def mex(s):\n        s_sorted = sorted(s)\n        for i, num in enumerate(s_sorted):\n            if i != num:\n                return i\n        return len(s)\n\n    def calculate_grundy(x, y):\n        if memo[x][y] != -1:\n            return memo[x][y]\n        \n        if board[x][y] == '#':\n            memo[x][y] = 0\n            return 0\n\n        reached_states = set()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            sequence = []\n\n            while 0 <= nx < h and 0 <= ny < w and board[nx][ny] != '#':\n                sequence.append((nx, ny))\n                nx += dx\n                ny += dy\n\n            new_grundy = 0\n            for (nx, ny) in sequence:\n                board[nx][ny] = '#'\n            \n            for nx, ny in sequence:\n                new_grundy ^= calculate_grundy(nx, ny)\n            \n            reached_states.add(new_grundy)\n\n            for (nx, ny) in sequence:\n                board[nx][ny] = '.'\n        \n        memo[x][y] = mex(reached_states)\n        return memo[x][y]\n\n    memo = [[-1] * w for _ in range(h)]\n    total_grundy = 0\n\n    for i in range(h):\n        for j in range(w):\n            if board[i][j] == '.':\n                total_grundy ^= calculate_grundy(i, j)\n\n    return total_grundy != 0\n\ndef determine_winner(board):\n    if can_win(board, len(board), len(board[0])):\n        return \"First\"\n    else:\n        return \"Second\"\n\nh, w = map(int, input().split())\nboard = [list(input().strip()) for _ in range(h)]\nprint(determine_winner(board))",
    "timestamp": "2025-08-13 07:59:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class WallMakingGame {\n    static int H, W;\n    static char[][] board;\n    static int[][] memo;\n    static int[] dr = {0, 0, 1, -1}; // Right, Left, Down, Up\n    static int[] dc = {1, -1, 0, 0};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        H = scanner.nextInt();\n        W = scanner.nextInt();\n        board = new char[H][W];\n        memo = new int[H][W];\n\n        for (int i = 0; i < H; i++) {\n            String line = scanner.next();\n            for (int j = 0; j < W; j++) {\n                board[i][j] = line.charAt(j);\n                memo[i][j] = -1;\n            }\n        }\n\n        scanner.close();\n\n        // Determine winner\n        int result = canWin();\n        if (result == 1) {\n            System.out.println(\"First\");\n        } else {\n            System.out.println(\"Second\");\n        }\n    }\n\n    private static int canWin() {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (board[i][j] == '.') {\n                    if (dfs(i, j) == 1) {\n                        return 1;\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n\n    private static int dfs(int row, int col) {\n        if (memo[row][col] != -1) return memo[row][col];\n\n        // Check all cells\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (board[i][j] == '.') {\n                    char[][] newBoard = makeMove(i, j);\n\n                    int isWinning = 0;\n                    // Check if the next player loses.\n                    outerLoop:\n                    for (int ni = 0; ni < H; ni++) {\n                        for (int nj = 0; nj < W; nj++) {\n                            if (newBoard[ni][nj] == '.' && dfsUtility(newBoard, ni, nj) == 1) {\n                                isWinning = 1;\n                                break outerLoop;\n                            }\n                        }\n                    }\n\n                    if (isWinning == 0) {\n                        memo[row][col] = 1;\n                        return 1;\n                    }\n\n                    board = cloneBoard(newBoard); // Restore board to current state\n                }\n            }\n        }\n        memo[row][col] = 0;\n        return 0;\n    }\n\n    private static char[][] makeMove(int row, int col) {\n        char[][] newBoard = cloneBoard(board);\n        setWall(newBoard, row, col);\n        return newBoard;\n    }\n\n    private static void setWall(char[][] newBoard, int row, int col) {\n        newBoard[row][col] = '#';\n        for (int i = 0; i < 4; i++) {\n            int nr = row;\n            int nc = col;\n            while (true) {\n                nr += dr[i];\n                nc += dc[i];\n                if (nr < 0 || nr >= H || nc < 0 || nc >= W || newBoard[nr][nc] == '#') break;\n                newBoard[nr][nc] = '#';\n            }\n        }\n    }\n\n    private static int dfsUtility(char[][] newBoard, int row, int col) {\n        if (memo[row][col] != -1) return memo[row][col];\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (newBoard[i][j] == '.') {\n                    char[][] trialBoard = cloneBoard(newBoard);\n                    setWall(trialBoard, i, j);\n\n                    int canOpponentWin = 0;\n                    outerLoop:\n                    for (int ni = 0; ni < H; ni++) {\n                        for (int nj = 0; nj < W; nj++) {\n                            if (trialBoard[ni][nj] == '.' && dfs(ni, nj) == 1) {\n                                canOpponentWin = 1;\n                                break outerLoop;\n                            }\n                        }\n                    }\n\n                    if (canOpponentWin == 0) {\n                        memo[row][col] = 1;\n                        return 1;\n                    }\n\n                    // Restore the board to prior state.\n                    newBoard = cloneBoard(trialBoard);\n                }\n            }\n        }\n        memo[row][col] = 0;\n        return 0;\n    }\n\n    private static char[][] cloneBoard(char[][] board) {\n        char[][] newBoard = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            System.arraycopy(board[i], 0, newBoard[i], 0, W);\n        }\n        return newBoard;\n    }\n}",
    "timestamp": "2025-08-13 07:59:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX 100\n\nint H, W;\nchar board[MAX][MAX];\n\nint dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\n\n// Check if the current board state is losing for the current player\nint isLosingConfiguration() {\n    int losing = 0;\n\n    // Try every empty cell and simulate making it a wall\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (board[i][j] == ' ') {\n                // Mark the current cell and adjacent cells as walls\n                board[i][j] = '#';\n                for (int d = 0; d < 4; ++d) {\n                    int x = i + dx[d], y = j + dy[d];\n                    while (x >= 0 && x < H && y >= 0 && y < W && board[x][y] != '#') {\n                        board[x][y] = '#';\n                        x += dx[d];\n                        y += dy[d];\n                    }\n                }\n\n                // Recurse to check if opponent is in a losing position\n                int opponentLoses = !isLosingConfiguration();\n\n                // Restore the board\n                board[i][j] = ' ';\n                for (int d = 0; d < 4; ++d) {\n                    int x = i + dx[d], y = j + dy[d];\n                    while (x >= 0 && x < H && y >= 0 && y < W && board[x][y] == '#') {\n                        board[x][y] = ' ';\n                        x += dx[d];\n                        y += dy[d];\n                    }\n                }\n\n                // If the opponent loses, the current player wins\n                if (opponentLoses) {\n                    return 1;\n                }\n\n                losing = 1; // If there's any move possible, it's not an immediate loss\n            }\n        }\n    }\n    \n    // If no moves are possible, return that the current configuration is losing\n    return losing == 0;\n}\n\nint main() {\n    // Input reading\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            scanf(\" %c\", &board[i][j]);\n        }\n    }\n\n    // Determine and print the winner\n    if (isLosingConfiguration()) {\n        printf(\"Player 2 wins\\n\");\n    } else {\n        printf(\"Player 1 wins\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 07:59:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_wall_making_game(board):\n    H, W = len(board), len(board[0])\n    \n    def is_valid_move(r, c):\n        return 0 <= r < H and 0 <= c < W and board[r][c] == '.'\n    \n    def make_walls(r, c):\n        directions = [(0,1), (0,-1), (1,0), (-1,0)]\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            while 0 <= nr < H and 0 <= nc < W and board[nr][nc] != 'W':\n                board[nr][nc] = 'W'\n                nr += dr\n                nc += dc\n    \n    def minimax(is_max_player):\n        possible_moves = [\n            (r, c) for r in range(H) for c in range(W) \n            if is_valid_move(r, c)\n        ]\n        \n        if not possible_moves:\n            return not is_max_player\n        \n        if is_max_player:\n            best_score = float('-inf')\n            for r, c in possible_moves:\n                board_copy = [row[:] for row in board]\n                board[r][c] = 'W'\n                make_walls(r, c)\n                score = minimax(False)\n                board[:] = board_copy\n                best_score = max(best_score, score)\n            return best_score\n        else:\n            best_score = float('inf')\n            for r, c in possible_moves:\n                board_copy = [row[:] for row in board]\n                board[r][c] = 'W'\n                make_walls(r, c)\n                score = minimax(True)\n                board[:] = board_copy\n                best_score = min(best_score, score)\n            return best_score\n    \n    result = minimax(True)\n    return \"First\" if result > 0 else \"Second\"\n\ndef main():\n    H, W = map(int, input().split())\n    board = [list(input().strip()) for _ in range(H)]\n    print(solve_wall_making_game(board))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 07:59:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(H)]\n    \n    memo = {}\n    \n    def grundy(x, y, size_x, size_y):\n        key = (x, y, size_x, size_y)\n        if key in memo:\n            return memo[key]\n        \n        used = set()\n        for i in range(x, x + size_x):\n            for j in range(y, y + size_y):\n                if grid[i][j] == '.':\n                    # Simulate choosing this cell\n                    # Find boundaries\n                    left = i\n                    while left >= x and grid[left][j] != '#':\n                        left -= 1\n                    left += 1\n                    right = i\n                    while right < x + size_x and grid[right][j] != '#':\n                        right += 1\n                    right -= 1\n                    top = j\n                    while top >= y and grid[i][top] != '#':\n                        top -= 1\n                    top += 1\n                    bottom = j\n                    while bottom < y + size_y and grid[i][bottom] != '#':\n                        bottom += 1\n                    bottom -= 1\n                    \n                    # Split into 4 regions\n                    g = 0\n                    # Left region\n                    g ^= grundy(x, y, i - x, size_y)\n                    # Right region\n                    g ^= grundy(i + 1, y, x + size_x - (i + 1), size_y)\n                    # Top region\n                    g ^= grundy(left, y, right - left + 1, j - y)\n                    # Bottom region\n                    g ^= grundy(left, j + 1, right - left + 1, y + size_y - (j + 1))\n                    used.add(g)\n        \n        mex = 0\n        while mex in used:\n            mex += 1\n        memo[key] = mex\n        return mex\n    \n    total_grundy = grundy(0, 0, H, W)\n    print(\"First\" if total_grundy != 0 else \"Second\")\n\nsolve()",
    "timestamp": "2025-08-13 08:00:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool canWin(vector<vector<char>>& board, int turn, int h, int w) {\n    // Base case: If the board is completely walled, player can't make a move\n    bool isMovePossible = false;\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (board[i][j] == '.') {\n                isMovePossible = true;\n                // Simulate making a move at (i, j)\n                vector<vector<char>> newBoard = board;\n                // Turn current cell to wall\n                newBoard[i][j] = '#';\n                // Turn adjacent cells to wall\n                int dx[4] = {-1, 0, 1, 0};\n                int dy[4] = {0, 1, 0, -1};\n                for (int dir = 0; dir < 4; ++dir) {\n                    int x = i, y = j;\n                    while (true) {\n                        x += dx[dir];\n                        y += dy[dir];\n                        if (x < 0 || x >= h || y < 0 || y >= w || newBoard[x][y] == '#') break;\n                        newBoard[x][y] = '#';\n                    }\n                }\n                if (!canWin(newBoard, 1 - turn, h, w)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return !isMovePossible;\n}\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    vector<vector<char>> board(h, vector<char>(w));\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            cin >> board[i][j];\n        }\n    }\n    cout << (canWin(board, 0, h, w) ? \"Player1\" : \"Player2\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:42:21"
  }
]