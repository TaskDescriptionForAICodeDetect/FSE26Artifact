[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  import scala.io.StdIn._\n  val Array(h, w) = readLine.trim.split(' ').map(_.toInt)\n  val state = new State(Array.tabulate(h){_ ⇒ readLine.trim})\n  println(\n    if (state.grundyNumberAt(0, w - 1, 0, h - 1) == 0) \"Second\"\n    else \"First\"\n  )\n  class State(state: Array[String]) {\n    private val memo: Array[Array[Array[Array[Option[Int]]]]] = Array.tabulate(state.head.length){_ ⇒ Array.tabulate(state.head.length){_ ⇒ Array.tabulate(state.length){_ ⇒ Array.tabulate(state.length){_ ⇒ None: Option[Int]}}}}\n    private val isMarked: Array[Array[Boolean]] = state.map(str ⇒ str.map(_ == 'X').toArray)\n    def grundyNumberAt(left: Int, right: Int, top: Int, bottom: Int): Int = {\n      if (left > right || top > bottom) 0\n      else memo(left)(right)(top)(bottom) match {\n        case Some(r) ⇒ r\n        case None if left == right || top == bottom ⇒\n          if ((left to right).forall(x ⇒ (top to bottom).forall(y ⇒ isMarked(y)(x)))) {\n            memo(left)(right)(top)(bottom) = Some(0)\n            0\n          }\n          else {\n            memo(left)(right)(top)(bottom) = Some(1)\n            1\n          }\n\n        case None ⇒\n          val next = (left to right).flatMap(x ⇒\n            (top to bottom).withFilter(y ⇒ !isMarked(y)(x)).map(y ⇒\n              grundyNumberAt(left, x - 1, top, y - 1) ^\n                grundyNumberAt(x + 1, right, top, y - 1) ^\n                grundyNumberAt(left, x - 1, y + 1, bottom) ^\n              grundyNumberAt(x + 1, right, y + 1, bottom)\n            )).distinct.toSet\n          val g = (0 to 1000).find(i ⇒ !next.contains(i)).get\n          memo(left)(right)(top)(bottom) = Some(g)\n          g\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nint h,w;\nstring mark;\nmap<string, bool> memo;\n\nbool solve(string &state){\n    if(memo.count(state) != 0){\n        return !memo[state];\n    }\n    bool res = false;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            if(state[i*w +j] == 'X' || mark[i*w +j] == 'X') continue;\n            string next = state;\n            next[i*w +j] = 'X';\n            for(int d=0; d<4; d++){\n                int y = i+dy[d];\n                int x = j+dx[d];\n                while(0<=y && y<h && 0<=x && x<w && next[y*w +x]=='.'){\n                    next[y*w +x] = 'X';\n                    y += dy[d];\n                    x += dx[d];\n                }\n            }\n            if(solve(next)){\n                res = true;\n                i=h;\n                break;\n            }\n        }\n    }\n    memo[state] = res;\n    return !res;\n}\n\nint main(){\n    cin >> h >> w;\n    for(int i=0; i<h; i++){\n        string s;\n        cin >> s;\n        mark += s;\n    }\n    string init(h*w, '.');\n    bool res = solve(init);\n    if(!res){\n        cout << \"First\" << endl;\n    }else{\n        cout << \"Second\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 21\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nint H, W;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint memo[MAX][MAX][MAX][MAX];\n\nint grundy(int x1, int y1, int x2, int y2, Mat &f)\n{\n    if (x1 > x2 || y1 > y2) {\n        return 0;\n    }\n\n    if (memo[y1][x1][y2][x2] != -1) {\n        return memo[y1][x1][y2][x2];\n    }\n        \n    unordered_set<int> st;\n    for (int i = y1; i <= y2; i++) {\n        for (int j = x1; j <= x2; j++) {\n            if (f[i][j] == 0) {\n                st.insert(grundy(x1, y1, j-1, i-1, f) ^\n                          grundy(j+1, y1, x2, i-1, f) ^\n                          grundy(x1, i+1, j-1, y2, f) ^\n                          grundy(j+1, i+1, x2, y2, f));\n            }\n        }\n    }   \n    \n    int res = 0;\n    while (st.count(res)) res++;\n    return (memo[y1][x1][y2][x2] = res);\n}\n\nint main()\n{    \n    cin >> H >> W;\n    Mat f(H);\n    for (int i = 0; i < H; i++) {\n        f[i].resize(W);\n        for (int j = 0; j < W; j++) {\n            char ch;\n            cin >> ch;\n            f[i][j] = (ch == 'X');\n        }\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (grundy(0, 0, W-1, H-1, f) != 0 ? \"First\" : \"Second\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-5;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nint mex(vector<int> &v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()),v.end());\n\trep(i, v.size()) {\n\t\tif (i != v[i])return i;\n\t}\n\treturn v.size();\n}\n\nbool used[20][20][20][20];\nint win[20][20][20][20];\nchar mp[20][20];\n\nint dfs(int lx, int ly, int rx, int ry) {\n\tif (lx > rx || ly > ry)return 0;\n\tif (used[lx][ly][rx][ry])return win[lx][ly][rx][ry];\n\tused[lx][ly][rx][ry] = true;\n\tvector<int> v;\n\tRep1(i, lx, rx) {\n\t\tRep1(j, ly, ry) {\n\t\t\tif (mp[i][j] == 'X')continue;\n\t\t\tint x = 0;\n\t\t\tx ^= dfs(lx, ly, i - 1, j - 1);\n\t\t\tx ^= dfs(lx, j + 1, i - 1, ry);\n\t\t\tx ^= dfs(i + 1, ly, rx, j - 1);\n\t\t\tx ^= dfs(i + 1, j + 1, rx, ry);\n\t\t\tv.push_back(x);\n\t\t}\n\t}\n\treturn win[lx][ly][rx][ry] = mex(v);\n}\nint h, w;\nvoid solve() {\n\tcin >> h >> w;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\tint u = dfs(0, 0, h - 1, w - 1);\n\tif (u == 0) {\n\t\tcout << \"Second\" << endl;\n\t}\n\telse {\n\t\tcout << \"First\" << endl;\n\t}\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 21\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nint H, W;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nbool inField(int x, int y)\n{\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid put(int x, int y, Mat &f)\n{\n    f[y][x] = -1;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        while (inField(nx, ny) && f[ny][nx] != -1) {\n            f[ny][nx] = -1;\n            nx += dx[i]; ny += dy[i];\n        }\n    }\n}\n\nint memo[MAX][MAX][MAX][MAX];\n\nint grundy(int x1, int y1, int x2, int y2, Mat &f)\n{\n    if (x1 > x2 || y1 > y2) {\n        return 0;\n    }\n\n    if (memo[y1][x1][y2][x2] != -1) {\n        return memo[y1][x1][y2][x2];\n    }\n        \n    set<int> st;\n    for (int i = y1; i <= y2; i++) {\n        for (int j = x1; j <= x2; j++) {\n            if (f[i][j] == 0) {\n                Mat nf = f;\n                put(j, i, nf);\n                st.insert(grundy(x1, y1, j-1, i-1, nf) ^\n                          grundy(j+1, y1, x2, i-1, nf) ^\n                          grundy(x1, i+1, j-1, y2, nf) ^\n                          grundy(j+1, i+1, x2, y2, nf));\n            }\n        }\n    }   \n    \n    int res = 0;\n    while (st.count(res)) res++;\n    return (memo[y1][x1][y2][x2] = res);\n}\n\nint main()\n{    \n    cin >> H >> W;\n    Mat f(H);\n    for (int i = 0; i < H; i++) {\n        f[i].resize(W);\n        for (int j = 0; j < W; j++) {\n            char ch;\n            cin >> ch;\n            f[i][j] = (ch == 'X');\n        }\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (grundy(0, 0, W-1, H-1, f) != 0 ? \"First\" : \"Second\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint h,w;\nstring s[22];\nint dp[22][22][22][22];\n\nint dfs(int i1,int j1,int i2,int j2){\n  if(i1>=i2||j1>=j2)return 0;\n  if(dp[i1][j1][i2][j2]!=-1)return dp[i1][j1][i2][j2];\n  set<int> st;\n  rep(i,h)rep(j,w)st.insert(i*w+j);\n  repl(i,i1,i2)repl(j,j1,j2){\n    if(s[i][j]=='X')continue;\n    int sum=0;\n    sum^=dfs(i1,j1,i,j);\n    sum^=dfs(i+1,j1,i2,j);\n    sum^=dfs(i1,j+1,i,j2);\n    sum^=dfs(i+1,j+1,i2,j2);\n    st.erase(sum);\n  }\n  return dp[i1][j1][i2][j2]=*st.begin();\n}\n\nint main(){\n  cin>>h>>w;\n  rep(i,h)cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  int res=dfs(0,0,h,w);\n  if(res==0)cout<<\"Second\"<<endl;\n  else cout<<\"First\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[30][30][30][30];\nchar str[30][30];\nint calc(int a,int b,int c,int d){\n    if(a>=b||c>=d)return 0;\n    if(dp[a][b][c][d]!=-1)return dp[a][b][c][d];\n    int val[64];\n    for(int i=0;i<64;i++)val[i]=0;\n    for(int i=a;i<b;i++)for(int j=c;j<d;j++){\n        if(str[i][j]=='X')continue;\n        int tmp=0;\n        tmp^=calc(a,i,c,j);\n        tmp^=calc(i+1,b,c,j);\n        tmp^=calc(a,i,j+1,d);\n        tmp^=calc(i+1,b,j+1,d);\n        val[tmp]=1;\n    }\n    for(int i=0;i<64;i++)if(!val[i])return dp[a][b][c][d]=i;\n}\nint main(){\n    int a,b;scanf(\"%d%d\",&a,&b);\n    for(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n    for(int i=0;i<30;i++)for(int j=0;j<30;j++)for(int k=0;k<30;k++)for(int l=0;l<30;l++)\n        dp[i][j][k][l]=-1;\n    int ret=calc(0,a,0,b);\n    if(ret)printf(\"First\\n\");\n    else printf(\"Second\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 22\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nint h,w;\nint mem[MAX][MAX][MAX][MAX];\nstring grid[MAX];\n\nint rec(int a,int b,int c,int d){\n  if(mem[a][b][c][d]!=-1)return mem[a][b][c][d];\n\n  set<int> s;\n  FOR(i,a,c){\n    FOR(j,b,d){\n      if(grid[i][j]=='X')continue;\n      int g=0;\n      if(i!=a && j!=b)g^=rec(a,b,i,j);\n      if(i!=a && j!=d-1)g^=rec(a,j+1,i,d);\n      if(i!=c-1 && j!=b)g^=rec(i+1,b,c,j);\n      if(i!=c-1 && j!=d-1)g^=rec(i+1,j+1,c,d);\n      s.insert(g);\n    }\n  }\n  int res=0;\n  while(s.count(res))res++;\n  mem[a][b][c][d]=res;\n  return res;\n}\n\nint main()\n{\n  cin>>h>>w;\n  FOR(i,0,h)cin>>grid[i];\n  memset(mem,-1,sizeof(mem));\n  if(rec(0,0,h,w)!=0)cout<<\"First\"<<endl;\n  else cout<<\"Second\"<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Turn{\n\tSente,\n\tGote,\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tchar map[20][21];\n\tvector<Data> V;\n};\n\nint H,W;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_SenteWin(Info info,Turn turn){\n\n\tif(turn == Sente){\n\n\t\tfor(int i = 0; i < info.V.size(); i++){\n\n\t\t\tInfo next_info;\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tnext_info.map[row][col] = info.map[row][col];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext_info.map[info.V[i].row][info.V[i].col] = '#';\n\n\t\t\tfor(int col = info.V[i].col-1; rangeCheck(info.V[i].row,col) == true && next_info.map[info.V[i].row][col] != '#'; col--){\n\t\t\t\tnext_info.map[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int col = info.V[i].col+1; rangeCheck(info.V[i].row,col) == true && next_info.map[info.V[i].row][col] != '#'; col++){\n\t\t\t\tnext_info.map[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row-1; rangeCheck(row,info.V[i].col) == true && next_info.map[row][info.V[i].col] != '#'; row--){\n\t\t\t\tnext_info.map[row][info.V[i].col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row+1; rangeCheck(row,info.V[i].col) == true && next_info.map[row][info.V[i].col] != '#'; row++){\n\t\t\t\tnext_info.map[row][info.V[i].col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_info.map[row][col] == '.'){\n\t\t\t\t\t\tnext_info.V.push_back(Data(row,col));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next_info.V.size() == 0)return true;\n\n\t\t\tif(is_SenteWin(next_info,Gote))return true;\n\t\t}\n\n\t\treturn false;\n\n\t}else{\n\n\t\tfor(int i = 0; i < info.V.size(); i++){\n\n\t\t\tInfo next_info;\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tnext_info.map[row][col] = info.map[row][col];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext_info.map[info.V[i].row][info.V[i].col] = '#';\n\n\t\t\tfor(int col = info.V[i].col-1; rangeCheck(info.V[i].row,col) == true && next_info.map[info.V[i].row][col] != '#'; col--){\n\t\t\t\tnext_info.map[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int col = info.V[i].col+1; rangeCheck(info.V[i].row,col) == true && next_info.map[info.V[i].row][col] != '#'; col++){\n\t\t\t\tnext_info.map[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row-1; rangeCheck(row,info.V[i].col) == true && next_info.map[row][info.V[i].col] != '#'; row--){\n\t\t\t\tnext_info.map[row][info.V[i].col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row+1; rangeCheck(row,info.V[i].col) == true && next_info.map[row][info.V[i].col] != '#'; row++){\n\t\t\t\tnext_info.map[row][info.V[i].col] = '#';\n\t\t\t}\n\n\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_info.map[row][col] == '.'){\n\t\t\t\t\t\tnext_info.V.push_back(Data(row,col));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next_info.V.size() == 0)return false;\n\n\t\t\tif(!is_SenteWin(next_info,Sente))return false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tInfo first;\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",first.map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first.map[row][col] == '.'){\n\t\t\t\tfirst.V.push_back(Data(row,col));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_SenteWin(first,Sente)){\n\t\tprintf(\"First\\n\");\n\t}else{\n\t\tprintf(\"Second\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W;\nchar S[25][25];\n\nint dp[25][25][25][25];\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret > -1 ) return ret;\n\n  set<int> g;\n  for(int x=x1;x<=x2;x++){\n    for(int y=y1;y<=y2;y++){\n      if( S[x][y] == 'X' ) continue;\n      g.insert( solve(x1,y1,x-1,y-1) ^ solve(x+1,y1,x2,y-1) ^\n                solve(x1,y+1,x-1,y2) ^ solve(x+1,y+1,x2,y2) );\n    }\n  }\n  \n  ret = 0;\n  while( g.find( ret ) != g.end() ) ret++;\n  return ret;\n}\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  cin >> H >> W;\n  for(int i=1;i<=H;i++)\n    for(int j=1;j<=W;j++)\n      cin >> S[j][i];\n  if( solve(1,1,W,H) ) cout << \"First\" << endl;\n  else cout << \"Second\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint memo[20][20][20][20];\n\n\nint getnum(const vector<vector<int>>&field,const int l,const int r,const int u,const int d) {\n\tif (memo[l][r][u][d] != -1)return memo[l][r][u][d];\n\tif (l == r)return 0;\n\telse if (u == d)return 0;\n\telse {\n\t\tassert(l < r);\n\t\tassert(u < d);\n\t\tset<int>nums;\n\t\tfor (int x = l; x < r; ++x) {\n\t\t\tfor (int y = u; y < d; ++y) {\n\t\t\t\tif (field[y][x])continue;\n\t\t\t\telse {\n\t\t\t\t\tint anum = 0;\n\t\t\t\t\tanum ^= getnum(field, l, x, u, y);\n\t\t\t\t\tanum ^= getnum(field, x + 1, r, u, y);\n\t\t\t\t\tanum ^= getnum(field, l, x, y + 1, d);\n\t\t\t\t\tanum ^= getnum(field, x + 1, r, y + 1, d);\n\t\t\t\t\tnums.emplace(anum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tauto it = nums.begin();\n\t\twhile (it != nums.end()) {\n\t\t\tif (ans == *it) {\n\t\t\t\tans++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn memo[l][r][u][d]=ans;\n\t}\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tfor (int i = 0; i < 20; ++i) {\n\t\tfor (size_t j = 0; j < 20; j++)\n\t\t{\n\t\t\tfor (size_t k = 0; k < 20; k++)\n\t\t\t{\n\t\t\t\tfor (size_t l = 0; l < 20; l++)\n\t\t\t\t{\n\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>>field(H, vector<int>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '.') {\n\t\t\t\tfield[i][j] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = getnum(field,0, W, 0, H);\n\tif (ans) {\n\t\tcout << \"First\" << endl;\n\t}\n\telse {\n\t\tcout << \"Second\" << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint h,w;\nstring s[22];\nint dp[22][22][22][22];\n\nint dfs(int i1,int j1,int i2,int j2){\n  if(i1>=i2||j1>=j2)return 0;\n  if(dp[i1][j1][i2][j2]!=-1)return dp[i1][j1][i2][j2];\n  set<int> st;\n  rep(i,20)rep(j,20)st.insert(i*w+j);\n  repl(i,i1,i2)repl(j,j1,j2){\n    if(s[i][j]=='X')continue;\n    int sum=0;\n    sum^=dfs(i1,j1,i,j);\n    sum^=dfs(i+1,j1,i2,j);\n    sum^=dfs(i1,j+1,i,j2);\n    sum^=dfs(i+1,j+1,i2,j2);\n    st.erase(sum);\n  }\n  return dp[i1][j1][i2][j2]=*st.begin();\n}\n\nint main(){\n  cin>>h>>w;\n  rep(i,h)cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  int res=dfs(0,0,h,w);\n  if(res==0)cout<<\"Second\"<<endl;\n  else cout<<\"First\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nstring S[20];\nint dp[20][20][21][21];\n\nint rec(int sx, int sy, int gx, int gy)\n{\n  if(sx >= gx || sy >= gy) return (0);\n  if(~dp[sx][sy][gx][gy]) return (dp[sx][sy][gx][gy]);\n  unordered_set< int > grundy;\n  for(int mx = sx; mx < gx; mx++) {\n    for(int my = sy; my < gy; my++) {\n      if(S[my][mx] == 'X') continue;\n      grundy.insert(rec(sx, sy, mx, my) ^\n                    rec(mx + 1, sy, gx, my) ^\n                    rec(sx, my + 1, mx, gy) ^\n                    rec(mx + 1, my + 1, gx, gy));\n    }\n  }\n  int ret = 0;\n  while(grundy.count(ret)) ++ret;\n  return (dp[sx][sy][gx][gy] = ret);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  if(rec(0, 0, W, H)) cout << \"First\" << endl;\n  else cout << \"Second\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing T = tuple<int, int, int, int>;\n\nmap<T, int> dp;\nchar is[20][20];\nint H, W;\n\nint find(int I, int J, int K, int L) {\n\tif (I == J || K == L) {\n\t\treturn 0;\n\t}\n\tif (dp[make_tuple(I, J, K, L)]) {\n\t\treturn dp[make_tuple(I, J, K, L)] - 1;\n\t}\n\tvector<int> ko;\n\tfor (int i = I; i < J; i++) {\n\t\tfor (int j = K; j < L; j++) {\n\t\t\tif (is[i][j] == '.') {\n\t\t\t\tko.push_back(find(I, i, K, j) ^ find(i + 1, J, K, j) ^ find(I, i, j + 1, L) ^ find(i + 1, J, j + 1, L));\n\t\t\t}\n\t\t}\n\t}\n\tsort(ko.begin(), ko.end());\n\tko.erase(unique(ko.begin(), ko.end()), ko.end());\n\tint res = 0;\n\twhile (res < (int)ko.size() && ko[res] == res) {\n\t\tres++;\n\t}\n\tdp[make_tuple(I, J, K, L)] = res + 1;\n\treturn res;\n}\n\nint main()\n{\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> is[i][j];\n\t\t}\n\t}\n\tcout << (find(0, H, 0, W) ? \"First\" : \"Second\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\n#define MAX_H 22\n#define MAX_W 22\nint grundy[MAX_H][MAX_W][MAX_H][MAX_W]; // ????????????[u,d)&[l,r)\n\nint H, W;\nchar board[MAX_H][MAX_W];\n\nint calcGrundy(int u, int l, int d, int r)\n{\n  int& g = grundy[u][l][d][r];\n  if(~g) return g;\n  if(u >= d || l >= r) return g = 0;\n  set<int> V;\n  for(int i = u; i < d; i++) {\n    for(int j = l; j < r; j++) {\n      if(board[i][j] != 'X') {\n\tV.insert(calcGrundy(u, l, i, j) ^ calcGrundy(u, j+1, i, r)\n\t\t ^ calcGrundy(i+1, l, d, j) ^ calcGrundy(i+1, j+1, d, r));\n      }\n    }\n  }\n  g = 0;\n  while(V.count(g)) g++;\n  return g;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  cin >> H >> W;\n  rep(i, H) rep(j, W) cin >> board[i][j];\n  memset(grundy, -1, sizeof(grundy));\n  cout << calcGrundy(0, 0, H, W) << endl;\n  cout << (calcGrundy(0, 0, H, W) ? \"First\" : \"Second\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\nint dp[21][21][21][21];\nint H, W, x[20][20];\nint solve(int a1, int b1, int a2, int b2) {\n\tif (a1 > a2 || b1 > b2)return 0;\n\tif (dp[a1][b1][a2][b2] >= 0)return dp[a1][b1][a2][b2];\n\tset<int>S;\n\tfor (int i = a1; i <= a2; i++) {\n\t\tfor (int j = b1; j <= b2; j++) {\n\t\t\tint V1 = solve(a1, b1, i - 1, j - 1);\n\t\t\tint V2 = solve(a1, j + 1, i - 1, b2);\n\t\t\tint V3 = solve(i + 1, b1, a2, j - 1);\n\t\t\tint V4 = solve(i + 1, j + 1, a2, b2);\n\t\t\tint V5 = V1 ^ V2 ^ V3 ^ V4;\n\t\t\tS.insert(V5);\n\t\t}\n\t}\n\tfor (int i = 0; i < 400; i++) {\n\t\tif (S.count(i) == 0) { dp[a1][b1][a2][b2] = i; break; }\n\t}\n\treturn dp[a1][b1][a2][b2];\n}\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < 441; i++) {\n\t\tfor (int j = 0; j < 441; j++)dp[i / 21][i % 21][j / 21][j % 21] = -1;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'X')x[i][j] = 1;\n\t\t}\n\t}\n\tint res = solve(0, 0, H - 1, W - 1);\n\tif (res == 0)cout << \"Second\" << endl;\n\telse { cout << \"First\" << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nint dp[22][22][22][22];\n\nstring s[22];\nint rec(int x1,int y1,int x2,int y2){\n    if(x1>x2||y1>y2)return 0;\n    if(dp[x1][y1][x2][y2]!=-1)return dp[x1][y1][x2][y2];\n    vector<int> g;\n    REP(i,x1,x2+1)REP(j,y1,y2+1){\n        if(s[i][j]=='X')continue;\n        int ret=0;\n        ret^=rec(x1,y1,i-1,j-1);\n        ret^=rec(x1,j+1,i-1,y2);\n        ret^=rec(i+1,y1,x2,j-1);\n        ret^=rec(i+1,j+1,x2,y2);\n        g.push_back(ret);\n    }\n    sort(g.begin(),g.end());\n    g.erase(unique(g.begin(),g.end()),g.end());\n    g.push_back(inf);\n    rep(i,g.size()){\n        if(g[i]!=i){\n            return dp[x1][y1][x2][y2]=i;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    int h,w;\n    cin>>h>>w;\n    rep(i,h)cin>>s[i];\n    rep(i,h)rep(j,w)rep(k,h)rep(l,w)dp[i][j][k][l]=-1;\n    int ans = rec(0,0,h-1,w-1);\n    cout<<(ans?\"First\" : \"Second\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=21;\nint h,w;\nvs a;\nint dp[M][M][M][M];\n\nint Rec(int lx,int rx,int ly,int ry){\n\tif(lx==rx||ly==ry) return 0;\n\tif(dp[lx][rx][ly][ry]>=0) return dp[lx][rx][ly][ry];\n\tset<int> st;\n\tfor(int i=lx;i<rx;i++) for(int j=ly;j<ry;j++) if(a[i][j]=='.'){\n\t\tst.insert(Rec(lx,i,ly,j)^Rec(lx,i,j+1,ry)^Rec(i+1,rx,ly,j)^Rec(i+1,rx,j+1,ry));\n\t}\n\tfor(int i=0;;i++) if(st.find(i)==st.end()){\n\t\tdp[lx][rx][ly][ry]=i;\n\t\tbreak;\n\t}\n\treturn dp[lx][rx][ly][ry];\n}\n\nint main(){\n\tfor(int i=0;i<M;i++) for(int j=0;j<M;j++) for(int k=0;k<M;k++) fill(dp[i][j][k],dp[i][j][k]+M,-1);\n\tcin>>h>>w;\n\ta=vs(h);\n\tfor(int i=0;i<h;i++) cin>>a[i];\n\tcout<<(Rec(0,h,0,w)?\"First\":\"Second\")<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint w, h;\nvs fld;\nint dp[22][22][22][22];\n\nint grundy(int top, int left, int bottom, int right)\n{\n\tif (dp[top][left][bottom][right] >=0) return dp[top][left][bottom][right];\n\tset<int> st;\n\tFOR(i, top, bottom)FOR(j, left, right) \n\t{\n\t\tif (fld[i][j] == 'X') continue;\n\t\tst.insert(grundy(top, left, i, j) ^ grundy(i + 1, left, bottom, j) ^ grundy(top, j + 1, i, right) ^ grundy(i + 1, j + 1, bottom, right));\n\t}\n\tint res = 0;\n\twhile (st.count(res)) res++;\n\treturn dp[top][left][bottom][right] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tMS(dp, -1);\n\tcin >> h >> w;\n\tfld.resize(h);\n\tREP(i, h) cin >> fld[i];\n\tif (grundy(0, 0, h, w)) puts(\"First\");\n\telse puts(\"Second\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint mem[20][20][21][21];\nint H,W;\nchar t[20][20];\n\nint solve(int ay,int ax,int by,int bx){\n  if(mem[ay][ax][by][bx]!=-1)return mem[ay][ax][by][bx];\n  \n  for(int i=ay;i<by;i++){\n    for(int j=ax;j<bx;j++){\n      if(t[i][j]=='X')continue;\n      int lu=solve(ay,ax,i,j);\n      int ld=solve(i+1,ax,by,j);\n      int ru=solve(ay,j+1,i,bx);\n      int rd=solve(i+1,j+1,by,bx);\n      int flg=lu^ld^ru^rd;\n      if(!flg)return mem[ay][ax][by][bx]=1;\n    }\n  }\n  return mem[ay][ax][by][bx]=0;\n}\n\nint main(){\n  memset(mem,-1,sizeof(mem));\n  cin>>H>>W;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  cout<<(solve(0,0,H,W)?\"First\":\"Second\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[30][30][30][30];\nchar str[30][30];\nint calc(int a,int b,int c,int d){\n    if(a>=b||c>=d)return 0;\n    if(dp[a][b][c][d]!=-1)return dp[a][b][c][d];\n    int val[64];\n    for(int i=0;i<64;i++)val[i]=0;\n    for(int i=a;i<b;i++)for(int j=c;j<d;j++){\n        if(str[i][j]=='X')continue;\n        int tmp=0;\n        tmp^=calc(a,i,c,j);\n        tmp^=calc(i+1,b,c,j);\n        tmp^=calc(a,i,j+1,d);\n        tmp^=calc(i+1,b,j+1,d);\n        val[tmp]=1;\n    }\n    for(int i=0;i<64;i++)if(!val[i])return dp[a][b][c][d]=i;\n}\nint main(){\n    int a,b;scanf(\"%d%d\",&a,&b);\n    for(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n    for(int i=0;i<30;i++)for(int j=0;j<30;j++)for(int k=0;k<30;k++)for(int l=0;l<30;l++)\n        dp[i][j][k][l]=-1;\n    int ret=calc(0,a,0,b);\n    if(ret)printf(\"First\\n\");\n    else printf(\"Second\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int S = 22;\nint dp[S][S][S][S];\nchar m[S][S];\n\nbool used[S*S];\nint mex(const vector<int> &vec)\n{\n    for(auto x: vec)\n        used[x] = true;\n    int ans;\n    for(int i = 0; ; i++)\n        if(!used[i])\n        {\n            ans = i;\n            break;\n        }\n    for(auto x: vec)\n        used[x] = false;\n    return ans;\n}\n\nint main()\n{\n    int h, w;\n    scanf(\"%d %d\", &h, &w);\n    for(int i = 1; i <= h; i++)\n        scanf(\"%s\", m[i] + 1);\n    for(int i = 0; i < h; i++)\n        for(int j = 0; j < w; j++)\n            for(int x0 = 1; x0 + i <= h; x0++)\n                for(int y0 = 1; y0 + j <= w; y0++)\n                {\n                    int x1 = x0 + i, y1 = y0 + j;\n                    vector<int> vec;\n                    for(int x = x0; x <= x1; x++)\n                        for(int y = y0; y <= y1; y++)\n                            if(m[x][y] == '.')\n                                vec.push_back(dp[x0][x-1][y0][y-1]\n                                            ^ dp[x+1][x1][y0][y-1]\n                                            ^ dp[x0][x-1][y+1][y1]\n                                            ^ dp[x+1][x1][y+1][y1]);\n                    dp[x0][x1][y0][y1] = mex(vec);\n                }\n    puts(dp[1][h][1][w] ? \"First\" : \"Second\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\nusing namespace std;\nint memo[21][21][21][21];\nint H, W;\nstring C[20];\n\nint grundy(int b, int l, int t, int r){\n  if(memo[b][l][t][r] >= 0) return memo[b][l][t][r];\n  set<int> S;\n  for(int i = b; i < t; ++i){\n    for(int j = l; j < r; ++j){\n      if(C[i][j] == 'X') continue;\n      int x = grundy(b,l,i,j), y = grundy(b,j+1,i,r), z = grundy(i+1,l,t,j), w = grundy(i+1,j+1,t,r);\n      S.insert(x^y^z^w);\n    }\n  }\n  for(int i = 0; i <= H*W; ++i){\n    if(not S.count(i)){\n      memo[b][l][t][r] = i;\n      return i;\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin >> H >> W;\n  for(int i = 0; i <= H; ++i)\n    for(int j = 0; j <= W; ++j)\n      for(int k = 0; k <= H; ++k)\n        fill(memo[i][j][k],memo[i][j][k]+21,-1);\n\n  for(int i = 0; i < H; ++i) cin >> C[i];\n  int ans = grundy(0,0,H,W);\n  if(not ans) cout << \"Second\" << endl;\n  else cout << \"First\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cassert>\nusing namespace std;\n\nstring field[22];\n\nbool dfs(int si, int sj, int ei, int ej)\n{\n\tfor(int i=si;i<ei;i++)\n\t{\n\t\tfor(int j=sj;j<ej;j++)\n\t\t{\n\t\t\tif (field[i][j] == 'X') continue;\n\t\t\tbool res = true;\n\t\t\tif (i + 1 < ei && j + 1 < ej) res ^= dfs(i + 1, j + 1, ei, ej);\n\t\t\tif (i + 1 < ei && j - 1 >= sj) res ^= dfs(i + 1, j - 1, ei, j);\n\t\t\tif (i - 1 >= si && j + 1 < ej) res ^= dfs(i - 1, j + 1, i, ej);\n\t\t\tif (i - 1 >= si && j - 1 >= sj) res ^= dfs(i - 1, j - 1, i, j);\n\t\t\tif (res) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tcin >> field[i];\n\t}\n\n\tif (dfs(0, 0, H, W)) cout << \"First\" << endl;\n\telse cout << \"Second\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\nint h,w;\nint memo[21][21][21][21];//semiopen\nbool mark[20][20];\nvoid init(){\n    REP(ys,21) REP(yt,21) REP(xs,21) REP(xt,21){\n        if(ys>yt || xs>xt) memo[ys][yt][xs][xt] = 0;\n        else memo[ys][yt][xs][xt] = -1;\n    }\n    memset(mark, 0, sizeof(mark));\n}\n\nint grundy(int ys, int yt, int xs, int xt){\n    if(memo[ys][yt][xs][xt] != -1){\n        return memo[ys][yt][xs][xt];\n    }\n    vector<int> trans;\n    for(int i=ys; i<yt; i++){\n        for(int j=xs; j<xt; j++){\n            if(mark[i][j]) continue;\n            int gn = 0;\n            gn ^= grundy(ys, i, xs, j);\n            gn ^= grundy(i+1, yt, xs, j);\n            gn ^= grundy(ys, i, j+1, xt);\n            gn ^= grundy(i+1, yt, j+1, xt);\n            trans.push_back(gn);\n        }\n    }\n    sort(trans.begin(), trans.end());\n    trans.erase(unique(trans.begin(), trans.end()), trans.end());\n    int res = 0;\n    for(int i=0; i<(int)trans.size(); i++){\n        if(trans[i] != i) break;\n        res++;\n    }\n    memo[ys][yt][xs][xt] = res;\n    return res;\n}\n\nint main(){\n    init();\n    cin >> h >> w;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            char c;\n            cin >> c;\n            if(c == 'X') mark[i][j] = true;\n        }\n    }\n    if(grundy(0, h, 0, w) != 0){\n        cout << \"First\" << endl;\n    }else{\n        cout << \"Second\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint h,w;\nstring s[30];\nint dp[30][30][30][30];\nint grundy(int sy,int sx,int ty,int tx){\n  if(~dp[sy][sx][ty][tx]) return dp[sy][sx][ty][tx];\n  set<int> g;\n  for(int i=sy;i<ty;i++){\n    for(int j=sx;j<tx;j++){\n      if(s[i][j]=='X') continue;\n      int k=0;\n      k^=grundy(sy,sx,i,j);\n      k^=grundy(i+1,j+1,ty,tx);\n      k^=grundy(sy,j+1,i,tx);\n      k^=grundy(i+1,sx,ty,j);\n      g.insert(k);\n    }\n  }\n  int r=0;\n  while(g.count(r)) r++;\n  return dp[sy][sx][ty][tx]=r;\n}\nsigned main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  cout<<(grundy(0,0,h,w)?\"First\":\"Second\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,a,n) for(int i=a;i<n;i++)\nusing namespace std;\nint h,w,dp[22][22][22][22];\nstring s[55];\nint dfs(int ul,int ur,int dl,int dr){\n  if(ul>dl||ur>dr)return 0;\n  if(dp[ul][ur][dl][dr]!=-1)return dp[ul][ur][dl][dr];\n  set<int>st;\n  r(i,ul,dl+1){\n    r(j,ur,dr+1){\n      if(s[i][j]=='X')continue;\n      int a,b,c,d;\n      a=dfs(ul,ur,i-1,j-1);\n      b=dfs(ul,j+1,i-1,dr);\n      c=dfs(i+1,ur,dl,j-1);\n      d=dfs(i+1,j+1,dl,dr);\n      st.insert(a^b^c^d);\n    }\n  }\n  int res=0;\n  while(st.count(res))res++;\n  return dp[ul][ur][dl][dr]=res;\n}\nint main(){\n  memset(dp,-1,sizeof(dp));\n  cin>>h>>w;\n  r(i,0,h)cin>>s[i];\n  cout<<(dfs(0,0,h-1,w-1)?\"First\":\"Second\")<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint mem[25][25][25][25];\nint H,W;\nchar t[20][20];\n\nint solve(int ay,int ax,int by,int bx){\n  if(mem[ay][ax][by][bx]!=-1)return mem[ay][ax][by][bx];\n  \n  for(int i=ay;i<by;i++){\n    for(int j=ax;j<bx;j++){\n      if(t[i][j]=='X')continue;\n      int lu=solve(ay,ax,i,j);\n      int ld=solve(i+1,ax,by,j);\n      int ru=solve(ay,j+1,i,bx);\n      int rd=solve(i+1,j+1,by,bx);\n      int flg=lu^ld^ru^rd;\n      if(!flg)return mem[ay][ax][by][bx]=1;\n    }\n  }\n  return mem[ay][ax][by][bx]=0;\n}\n\nint main(){\n  memset(mem,-1,sizeof(mem));\n  cin>>H>>W;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  cout<<(solve(0,0,H,W)?\"First\":\"Second\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint mem[25][25][25][25];\nint H,W;\nchar t[20][20];\n\nint solve(int ay,int ax,int by,int bx){\n  if(mem[ay][ax][by][bx]!=-1)return mem[ay][ax][by][bx];\n  set<int> s;\n  for(int i=ay;i<by;i++){\n    for(int j=ax;j<bx;j++){\n      if(t[i][j]=='X')continue;\n      int lu=solve(ay,ax,i,j);\n      int ld=solve(i+1,ax,by,j);\n      int ru=solve(ay,j+1,i,bx);\n      int rd=solve(i+1,j+1,by,bx);\n      s.insert(lu^ld^ru^rd);\n    }\n  }\n  int res;\n  for(int i=0;;i++){\n    if(s.count(i)==0){\n      res=i;\n      break;\n    }\n  }\n  return mem[ay][ax][by][bx]=res;\n}\n\nint main(){\n  memset(mem,-1,sizeof(mem));\n  cin>>H>>W;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  cout<<(solve(0,0,H,W)?\"First\":\"Second\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define y1 Gacho\n#define N 20\nusing namespace std;\n\nstring s[N];\nint h, w, X[N][N];\nint grundy[N][N][N][N];\n\nint dfs(int y1, int y2, int x1, int x2){\n  \n  if(y2-y1<0||x2-x1<0) return 0;\n  \n  int &g=grundy[y1][y2][x1][x2];\n  \n  if(g!=-1) return g;\n    \n  set<int> S;\n  \n  for(int i=y1;i<=y2;i++)\n    for(int j=x1;j<=x2;j++){\n      if(X[i][j]) continue;\n      int a=dfs(y1,i-1,x1,j-1);\n      int b=dfs(y1,i-1,j+1,x2);\n      int c=dfs(i+1,y2,x1,j-1);\n      int d=dfs(i+1,y2,j+1,x2);\n      S.insert(a^b^c^d);\n    }\n  \n  int cnt=0;\n  \n  while(S.count(cnt)) cnt++;\n  \n  return g=cnt;\n}\n\nvoid solve(){\n\n  memset(grundy,-1,sizeof(grundy));\n  \n  cout<<(dfs(0, h-1, 0, w-1)?\"First\":\"Second\")<<endl;\n  \n}\n\nint main(){\n\n  cin>>h>>w;\n\n  for(int i=0;i<h;i++){\n    cin>>s[i];\n    for(int j=0;j<w;j++)\n      if(s[i][j]=='X') X[i][j]=1;\n  }\n\n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 21\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nint H, W;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint memo[MAX][MAX][MAX][MAX];\n\nint grundy(int x1, int y1, int x2, int y2, Mat &f)\n{\n    if (x1 > x2 || y1 > y2) {\n        return 0;\n    }\n\n    if (memo[y1][x1][y2][x2] != -1) {\n        return memo[y1][x1][y2][x2];\n    }\n        \n    unordered_set<int> st;\n    for (int i = y1; i <= y2; i++) {\n        for (int j = x1; j <= x2; j++) {\n            if (f[i][j] == 0) {\n                st.insert(grundy(x1, y1, j-1, i-1, f) ^\n                          grundy(j+1, y1, x2, i-1, f) ^\n                          grundy(x1, i+1, j-1, y2, f) ^\n                          grundy(j+1, i+1, x2, y2, f));\n            }\n        }\n    }   \n    \n    int res = 0;\n    while (st.count(res)) res++;\n    return (memo[y1][x1][y2][x2] = res);\n}\n\nint main()\n{    \n    cin >> H >> W;\n    Mat f(H);\n    for (int i = 0; i < H; i++) {\n        f[i].resize(W);\n        for (int j = 0; j < W; j++) {\n            char ch;\n            cin >> ch;\n            f[i][j] = (ch == 'X');\n        }\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (grundy(0, 0, W-1, H-1, f) != 0 ? \"First\" : \"Second\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint memo[22][22][22][22];\n\n\nint getnum(const vector<vector<int>>&field,const int l,const int r,const int u,const int d) {\n\tif (memo[l][r][u][d] != -1)return memo[l][r][u][d];\n\tif (l == r)return 0;\n\telse if (u == d)return 0;\n\telse {\n\t\tassert(l < r);\n\t\tassert(u < d);\n\t\tset<int>nums;\n\t\tfor (int x = l; x < r; ++x) {\n\t\t\tfor (int y = u; y < d; ++y) {\n\t\t\t\tif (field[y][x])continue;\n\t\t\t\telse {\n\t\t\t\t\tint anum = 0;\n\t\t\t\t\tanum ^= getnum(field, l, x, u, y);\n\t\t\t\t\tanum ^= getnum(field, x + 1, r, u, y);\n\t\t\t\t\tanum ^= getnum(field, l, x, y + 1, d);\n\t\t\t\t\tanum ^= getnum(field, x + 1, r, y + 1, d);\n\t\t\t\t\tnums.emplace(anum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tauto it = nums.begin();\n\t\twhile (it != nums.end()) {\n\t\t\tif (ans == *it) {\n\t\t\t\tans++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn memo[l][r][u][d]=ans;\n\t}\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tfor (int i = 0; i < 22; ++i) {\n\t\tfor (size_t j = 0; j < 22; j++)\n\t\t{\n\t\t\tfor (size_t k = 0; k < 22; k++)\n\t\t\t{\n\t\t\t\tfor (size_t l = 0; l < 22; l++)\n\t\t\t\t{\n\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>>field(H, vector<int>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '.') {\n\t\t\t\tfield[i][j] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = getnum(field,0, W, 0, H);\n\tif (ans) {\n\t\tcout << \"First\" << endl;\n\t}\n\telse {\n\t\tcout << \"Second\" << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 21\nusing namespace std;\nint h,w;\nstring mp[N];\n\nint used[N][N][N][N],mem[N][N][N][N];\nint dfs(int y,int x,int Y,int X){\n  int &res=mem[y][x][Y][X];\n  if(y>Y||x>X) return 0;\n  if(used[y][x][Y][X]++) return res;\n   \n  set<int> S;\n  for(int i=y;i<=Y;i++)\n    for(int j=x;j<=X;j++){\n      if(mp[i][j]=='X')continue;\n      int a=dfs(y,x,i-1,j-1);\n      int b=dfs(y,j+1,i-1,X);\n      int c=dfs(i+1,x,Y,j-1);\n      int d=dfs(i+1,j+1,Y,X);\n      int r=a^b^c^d;\n      S.insert(r);\n    }\n  while(S.count(res))res++;\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cout <<(dfs(0,0,h-1,w-1)!=0? \"First\":\"Second\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nint h,w;\nstring mark;\nmap<string, bool> memo;\n\n\nbool solve(string &state){\n    if(memo.count(state) != 0){\n        return !memo[state];\n    }\n    bool res = false;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            if(state[i*h +j] == 'X' || mark[i*h +j] == 'X') continue;\n            string next = state;\n            next[i*h +j] = 'X';\n            for(int d=0; d<4; d++){\n                int x = j+dx[d];\n                int y = i+dy[d];\n                while(0<=y && y<h && 0<=x && x<w && next[y*h +x]=='.'){\n                    next[y*h +x] = 'X';\n                    x+=dx[d];\n                    y+=dy[d];\n                }\n            }\n            bool ret = solve(next);\n            if(ret){\n                res = true;\n                i=h;\n                break;\n            }\n        }\n    }\n    memo[state] = res;\n    return !res;\n}\n\nint main(){\n    cin >> h >> w;\n    for(int i=0; i<h; i++){\n        string s;\n        cin >> s;\n        mark += s;\n    }\n    string init(h*w, '.');\n    bool res = solve(init);\n    if(!res){\n        cout << \"First\" << endl;\n    }else{\n        cout << \"Second\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W;\nchar S[22][22];\n\nint dp[22][22][22][22];\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret > -1 ) return ret;\n\n  set<int> g;\n  for(int x=x1;x<=x2;x++){\n    for(int y=y1;y<=y2;y++){\n      if( S[x][y] == 'X' ) continue;\n      g.insert( solve(x1,y1,x-1,y-1) ^ solve(x+1,y1,x2,y-1) ^\n                solve(x1,y+1,x-1,y2) ^ solve(x+1,y+1,x2,y2) );\n    }\n  }\n  \n  ret = 0;\n  while( g.find( ret ) != g.end() ) ret++;\n  return ret;\n}\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  cin >> H >> W;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin >> S[j][i];\n  if( solve(0,0,W-1,H-1) ) cout << \"First\" << endl;\n  else cout << \"Second\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint getnum(const vector<vector<int>>&field,const int l,const int r,const int u,const int d) {\n\tif (l == r)return 0;\n\telse if (u == d)return 0;\n\telse {\n\t\tassert(l < r);\n\t\tassert(u < d);\n\t\tset<int>nums;\n\t\tfor (int x = l; x < r; ++x) {\n\t\t\tfor (int y = u; y < d; ++y) {\n\t\t\t\tif (field[y][x])continue;\n\t\t\t\telse {\n\t\t\t\t\tint anum = 0;\n\t\t\t\t\tanum ^= getnum(field, l, x, u, y);\n\t\t\t\t\tanum ^= getnum(field, x + 1, r, u, y);\n\t\t\t\t\tanum ^= getnum(field, l, x, y + 1, d);\n\t\t\t\t\tanum ^= getnum(field, x + 1, r, y + 1, d);\n\t\t\t\t\tnums.emplace(anum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tauto it = nums.begin();\n\t\twhile (it != nums.end()) {\n\t\t\tif (ans == *it) {\n\t\t\t\tans++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint H, W; cin >> H >> W;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '.') {\n\t\t\t\t\tfield[i][j] = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = getnum(field,0, W, 0, H);\n\t\tif (ans) {\n\t\t\tcout << \"First\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Second\" << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Turn{\n\tSente,\n\tGote,\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tchar table[20][21];\n\tvector<Data> V;\n};\n\nint H,W;\n\nmap<string,bool> MAP;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_SenteWin(Info info,Turn turn){\n\n\tif(turn == Sente){\n\n\t\tfor(int i = 0; i < info.V.size(); i++){\n\n\t\t\tInfo next_info;\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tnext_info.table[row][col] = info.table[row][col];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext_info.table[info.V[i].row][info.V[i].col] = '#';\n\n\t\t\tfor(int col = info.V[i].col-1; rangeCheck(info.V[i].row,col) == true && next_info.table[info.V[i].row][col] != '#'; col--){\n\t\t\t\tnext_info.table[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int col = info.V[i].col+1; rangeCheck(info.V[i].row,col) == true && next_info.table[info.V[i].row][col] != '#'; col++){\n\t\t\t\tnext_info.table[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row-1; rangeCheck(row,info.V[i].col) == true && next_info.table[row][info.V[i].col] != '#'; row--){\n\t\t\t\tnext_info.table[row][info.V[i].col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row+1; rangeCheck(row,info.V[i].col) == true && next_info.table[row][info.V[i].col] != '#'; row++){\n\t\t\t\tnext_info.table[row][info.V[i].col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_info.table[row][col] == '.'){\n\t\t\t\t\t\tnext_info.V.push_back(Data(row,col));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next_info.V.size() == 0)return true;\n\n\t\t\t//??¢????????£?????????????????????\n\t\t\tstring tmp;\n\n\t\t\tfor(int i = 0; i < next_info.V.size();i++){\n\t\t\t\ttmp.append(to_string(next_info.V[i].row));\n\t\t\t\ttmp.append(to_string(next_info.V[i].col));\n\t\t\t}\n\n\t\t\tauto at = MAP.find(tmp);\n\t\t\tif(at != MAP.end()) {\n\t\t\t\tif(MAP[tmp] == true){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif((MAP[tmp] = is_SenteWin(next_info,Gote)))return true;\n\t\t}\n\n\t\treturn false;\n\n\t}else{\n\n\t\tfor(int i = 0; i < info.V.size(); i++){\n\n\t\t\tInfo next_info;\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tnext_info.table[row][col] = info.table[row][col];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext_info.table[info.V[i].row][info.V[i].col] = '#';\n\n\t\t\tfor(int col = info.V[i].col-1; rangeCheck(info.V[i].row,col) == true && next_info.table[info.V[i].row][col] != '#'; col--){\n\t\t\t\tnext_info.table[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int col = info.V[i].col+1; rangeCheck(info.V[i].row,col) == true && next_info.table[info.V[i].row][col] != '#'; col++){\n\t\t\t\tnext_info.table[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row-1; rangeCheck(row,info.V[i].col) == true && next_info.table[row][info.V[i].col] != '#'; row--){\n\t\t\t\tnext_info.table[row][info.V[i].col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row+1; rangeCheck(row,info.V[i].col) == true && next_info.table[row][info.V[i].col] != '#'; row++){\n\t\t\t\tnext_info.table[row][info.V[i].col] = '#';\n\t\t\t}\n\n\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_info.table[row][col] == '.'){\n\t\t\t\t\t\tnext_info.V.push_back(Data(row,col));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next_info.V.size() == 0)return false;\n\n\t\t\t//??¢????????£?????????????????????\n\t\t\tstring tmp;\n\n\t\t\tfor(int i = 0; i < next_info.V.size();i++){\n\t\t\t\ttmp.append(to_string(next_info.V[i].row));\n\t\t\t\ttmp.append(to_string(next_info.V[i].col));\n\t\t\t}\n\n\n\t\t\tauto at = MAP.find(tmp);\n\t\t\tif(at != MAP.end()) {\n\t\t\t\tif(MAP[tmp] == false){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!(MAP[tmp] = is_SenteWin(next_info,Sente)))return false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tInfo first;\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",first.table[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first.table[row][col] == '.'){\n\t\t\t\tfirst.V.push_back(Data(row,col));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_SenteWin(first,Sente)){\n\t\tprintf(\"First\\n\");\n\t}else{\n\t\tprintf(\"Second\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint h,w;\nstring s[22];\nint dp[22][22][22][22];\n\nint dfs(int i1,int j1,int i2,int j2){\n  if(i1>=i2||j1>=j2)return 0;\n  if(dp[i1][j1][i2][j2]!=-1)return dp[i1][j1][i2][j2];\n  int res=0;\n  repl(i,i1,i2)repl(j,j1,j2){\n    if(s[i][j]=='X')continue;\n    int sum=0;\n    sum^=dfs(i1,j1,i,j);\n    sum^=dfs(i+1,j1,i2,j);\n    sum^=dfs(i1,j+1,i,j2);\n    sum^=dfs(i+1,j+1,i2,j2);\n    if(sum==0)res=1;\n  }\n  return dp[i1][j1][i2][j2]=res;\n}\n\nint main(){\n  cin>>h>>w;\n  rep(i,h)cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  int res=dfs(0,0,h,w);\n  if(res==0)cout<<\"Second\"<<endl;\n  else cout<<\"First\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 22\n\nint n,m;\nchar _map[nn][nn];\nint dp[nn][nn][nn][nn];\n\n\nint dfs(int x1,int y1,int x2,int y2){\n\tif(x1>x2 or y1>y2) return 0;\n\tif(dp[x1][y1][x2][y2]>-1) return dp[x1][y1][x2][y2];\n\tset<int> all;\n\tfor(int i=x1;i<=x2;i++) {\n\t\tfor(int j=y1;j<=y2;j++) if(_map[i][j]=='.'){\n\t\t\tint w=dfs(x1,y1,i-1,j-1)^dfs(x1,j+1,i-1,y2)^dfs(i+1,y1,x2,j-1)^dfs(i+1,j+1,x2,y2);\n\t\t\tall.insert(w);\n\t\t}\n\t}\n\tint res=0;\n\twhile(all.count(res))res++;\n\n\treturn dp[x1][y1][x2][y2]=res;\n}\n\nint main(){\n\tmemset(dp,-1,sizeof dp);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%s\",_map[i]+1);\n\t\n\tif(dfs(1,1,n,m)) puts(\"First\");else puts(\"Second\");\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <string>\n#include <iostream>\nusing namespace std;\nint H, W, vis[22][22][22][22], dp[22][22][22][22]; string s[22];\nint rec(int x1, int y1, int x2, int y2) {\n\tif (x1 == x2 || y1 == y2) return 0;\n\tif (vis[x1][y1][x2][y2]) return dp[x1][y1][x2][y2];\n\tset<int> s_;\n\tfor (int i = y1; i < y2; i++) {\n\t\tfor (int j = x1; j < x2; j++) {\n\t\t\tif (s[i][j] == 'X') continue;\n\t\t\tint res1 = rec(x1, y1, j, i);\n\t\t\tint res2 = rec(x1, i + 1, j, y2);\n\t\t\tint res3 = rec(j + 1, y1, x2, i);\n\t\t\tint res4 = rec(j + 1, i + 1, x2, y2);\n\t\t\tint res5 = res1 ^ res2 ^ res3 ^ res4;\n\t\t\ts_.insert(res5);\n\t\t}\n\t}\n\tvis[x1][y1][x2][y2] = true;\n\tint ret = 0;\n\twhile (s_.count(ret)) ret++;\n\treturn dp[x1][y1][x2][y2] = ret;\n}\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) cin >> s[i];\n\tint ret = rec(0, 0, W, H);\n\tif (ret > 0) cout << \"First\" << endl;\n\telse cout << \"Second\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h,w;\nstring field[25];\nint memo[25][25][25][25];\n\nint calc(int x1,int x2,int y1,int y2){\n\tif(x1 == x2 || y1 == y2) return 0;\n\tif(memo[x1][x2][y1][y2] != -1) return memo[x1][x2][y1][y2];\n\tset<int> st;\n\tfor(int i = x1;i < x2;i++){\n\t\tfor(int j = y1;j < y2;j++){\n\t\t\tif(field[i][j] == 'X') continue;\n\t\t\tint g = calc(x1,i,y1,j) ^ calc(i+1,x2,y1,j) ^ calc(x1,i,j+1,y2) ^ calc(i+1,x2,j+1,y2);\n\t\t\tst.insert(g);\n\t\t}\n\t}\n\tfor(int i = 0;;i++){\n\t\tif(!st.count(i)) return memo[x1][x2][y1][y2] = i;\n\t}\n}\n\nsigned main(){\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++) cin >> field[i];\n\tfor(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= h;j++){\n\t\t\tfor(int k = 0;k <= w;k++){\n\t\t\t\tfor(int l = 0;l <= w;l++) memo[i][j][k][l] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif(calc(0,h,0,w)) cout << \"First\" << endl;\n\telse cout << \"Second\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <functional>\n#include <set>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nvoid solve() {\n    int h, w;\n    std::cin >> h >> w;\n\n    std::vector<std::string> ss(h);\n    for (auto& s : ss) std::cin >> s;\n\n    auto dp = vec(h, vec(h, vec(w, vec(w, -1))));\n\n    std::function<int(int, int, int, int)>\n        dfs = [&](int lx, int rx, int ly, int ry) {\n            if (rx < lx || ry < ly) return 0;\n\n            auto& ret = dp[lx][rx][ly][ry];\n            if (ret != -1) return ret;\n\n            std::set<int> gs;\n            for (int x = lx; x <= rx; ++x) {\n                for (int y = ly; y <= ry; ++y) {\n                    if (ss[x][y] == 'X') continue;\n\n                    int g = dfs(lx, x - 1, ly, y - 1) ^\n                            dfs(x + 1, rx, ly, y - 1) ^\n                            dfs(lx, x - 1, y + 1, ry) ^\n                            dfs(x + 1, rx, y + 1, ry);\n                    gs.insert(g);\n                }\n            }\n\n            for (int i = 0;; ++i) {\n                if (!gs.count(i)) {\n                    ret = i;\n                    break;\n                }\n            }\n            return ret;\n        };\n\n    int g = dfs(0, h - 1, 0, w - 1);\n    std::cout << (g == 0 ? \"Second\" : \"First\") << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 21\nusing namespace std;\nint h,w;\nstring mp[N];\n\nint used[N][N][N][N],mem[N][N][N][N];\nint dfs(int y,int x,int Y,int X){\n  int &res=mem[y][x][Y][X];\n  if(y>Y||x>X) return 0;\n  if(used[y][x][Y][X]++) return res;\n  res=0;\n  for(int i=y;i<=Y;i++)\n    for(int j=x;j<=X;j++){\n      if(mp[i][j]=='X')continue;\n      int a=dfs(y,x,i-1,j-1);\n      int b=dfs(y,j+1,i-1,X);\n      int c=dfs(i+1,x,Y,j-1);\n      int d=dfs(i+1,j+1,Y,X);\n      res|=(a+b+c+d+1)%2;\n    }\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cout <<(dfs(0,0,h-1,w-1)? \"First\":\"Second\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W;\nchar table[20][21];\n\nint dp[20][20][20][20];\n\nint grundy(int row1,int col1,int row2,int col2){\n\n\tif(row1 > row2 || col1 > col2)return 0;\n\n    if(dp[row1][col1][row2][col2] != -1)return dp[row1][col1][row2][col2];\n\n    set<int> S;\n\n    for(int row = row1; row <= row2; row++){\n    \tfor(int col = col1; col <= col2; col++){\n    \t\t if(table[row][col]=='X')continue;\n\n    \t\t int x = 0;\n    \t\t x ^= grundy(row1,col1,row-1,col-1);\n    \t\t x ^= grundy(row1,col+1,row-1,col2);\n    \t\t x ^= grundy(row+1,col1,row2,col-1);\n    \t\t x ^= grundy(row+1,col+1,row2,col2);\n    \t\t S.insert(x);\n    \t}\n    }\n\n    int g = 0;\n    while(S.count(g) != 0)g++;\n\n    return dp[row1][col1][row2][col2] = g;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",table[row]);\n\t}\n\n    for(int a = 0; a < H; a++){\n    \tfor(int b = 0; b < W; b++){\n    \t\tfor(int c = 0; c < H; c++){\n    \t\t\tfor(int d = 0; d < W; d++){\n    \t\t\t\tdp[a][b][c][d] = -1;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n\n\tif(grundy(0,0,H-1,W-1) != 0){\n\t\tprintf(\"First\\n\");\n\t}else{\n    \tprintf(\"Second\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 21\nusing namespace std;\nint h,w;\nstring mp[N];\n\nint used[N][N][N][N],mem[N][N][N][N];\nint dfs(int y,int x,int Y,int X){\n  int &res=mem[y][x][Y][X];\n  if(y>Y||x>X) return 0;\n  if(used[y][x][Y][X]++) return res;\n   \n  set<int> S;\n  for(int i=y;i<=Y;i++)\n    for(int j=x;j<=X;j++){\n      if(mp[i][j]=='X')continue;\n      int a=dfs(y,x,i-1,j-1);\n      int b=dfs(y,j+1,i-1,X);\n      int c=dfs(i+1,x,Y,j-1);\n      int d=dfs(i+1,j+1,Y,X);\n      S.insert(a^b^c^d);\n    }\n  while(S.count(res))res++;\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cout <<(dfs(0,0,h-1,w-1)!=0? \"First\":\"Second\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint memo[22][22][22][22];\nint H, W;\nstring G[22];\n\nint solve(int sy, int sx, int gy, int gx) {\n\n  if(sy == gy || sx == gx) return 0;\n\n  int& ret = memo[sy][sx][gy][gx];\n  if(ret + 1) return ret;\n\n  set<int> s;\n  REP(i, sy, gy) REP(j, sx, gx) {\n    if(G[i][j] == 'X') continue;\n    int a = solve(sy, sx, i, j);\n    int b = solve(sy, j + 1, i, gx);\n    int c = solve(i + 1, sx, gy, j);\n    int d = solve(i + 1, j + 1, gy, gx);\n    s.insert(a ^ b ^ c ^ d);\n  }\n\n  int r = 0;\n  while(s.count(r)) r++;\n\n  return ret = r;\n}\n\nint main() {\n\n  minus(memo);\n\n  cin >> H >> W;\n  rep(i, H) cin >> G[i];\n  cout << (solve(0, 0, H, W) > 0 ? \"First\" : \"Second\") << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef tuple<int,int,int,int> T;\nmap<T, int> memo;\nint grundy(vector<vector<char>>& m, T t){\n\tif(memo.count(t)) return memo[t];\n\n\tint lx, ly, rx, ry;\n\ttie(lx, ly, rx, ry) = t;\n\n\tset<int> s;\n\trange(i,ly,ry){\n\t\trange(j,lx,rx){\n\t\t\tif(m[i][j] == 'X') continue;\n\t\t\tvector<T> a(4);\n\t\t\ta[0] = T(lx, ly, j, i);\n\t\t\ta[1] = T(j + 1, ly, rx, i);\n\t\t\ta[2] = T(lx, i + 1, j, ry);\n\t\t\ta[3] = T(j + 1, i + 1, rx, ry);\n\n\t\t\tint x = 0;\n\t\t\t//rep(k,4){\n\t\t\t//\t\tint q,w,e,r;\n\t\t\t//\t\ttie(q,w,e,r) = a[k];\n\t\t\t//\t\tcout << q << w << e << r << endl;\n\t\t\t//}\n\t\t\t//\t\tcout << endl;\n\t\t\trep(k,4){\n\t\t\t\tif(get<2>(a[k]) > get<0>(a[k]) and get<3>(a[k]) > get<1>(a[k])){\n\t\t\t\t\tx ^= grundy(m, a[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.emplace(x);\n\t\t}\n\t}\n\n\tint k = 0;\n\twhile(s.count(k)) k++;\n\treturn memo[t] = k;\n}\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<vector<char>> m(h, vector<char>(w));\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tcin >> m[i][j];\n\t\t}\n\t}\n\n\tcout << (grundy(m, T(0, 0, w, h)) != 0 ? \"First\" : \"Second\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint getnum(const vector<vector<int>>&field,const int l,const int r,const int u,const int d) {\n\tif (l == r)return 0;\n\telse if (u == d)return 0;\n\telse {\n\t\tassert(l < r);\n\t\tassert(u < d);\n\t\tset<int>nums;\n\t\tfor (int x = l; x < r; ++x) {\n\t\t\tfor (int y = u; y < d; ++y) {\n\t\t\t\tif (field[y][x])continue;\n\t\t\t\telse {\n\t\t\t\t\tint anum = 0;\n\t\t\t\t\tanum ^= getnum(field, l, x, u, y);\n\t\t\t\t\tanum ^= getnum(field, x + 1, r, u, y);\n\t\t\t\t\tanum ^= getnum(field, l, x, y + 1, d);\n\t\t\t\t\tanum ^= getnum(field, x + 1, r, y + 1, d);\n\t\t\t\t\tnums.emplace(anum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tauto it = nums.begin();\n\t\twhile (it != nums.end()) {\n\t\t\tif (ans == *it) {\n\t\t\t\tans++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint H, W; cin >> H >> W;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '.') {\n\t\t\t\t\tfield[i][j] = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = getnum(field,0, W, 0, H);\n\t\tif (ans) {\n\t\t\tcout << \"First\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Second\" << endl;\n\t\t}\n\t\treturn 0;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint h, w;\nvector<string> f;\n\nconst int N = 21;\nint memo[N][N][N][N];\n\nint rec(int x1, int y1, int x2, int y2){\n    int& cur = memo[y1][x1][y2][x2];\n    if(cur != -1) return cur;\n\n    if(x1 == x2 or y1 == y2){\n        return cur = 0;\n    }\n\n    set<int> s;\n    rep(y, y1, y2){\n        rep(x, x1, x2){\n            if(f[y][x] == 'X') continue;\n            int g = 0;\n            g ^= rec(x1, y1, x, y);\n            g ^= rec(x1, y+1, x, y2);\n            g ^= rec(x+1, y1, x2, y);\n            g ^= rec(x+1, y+1, x2, y2);\n            s.insert(g);\n        }\n    }\n    cur = 0;\n    for(auto& e : s){\n        if(cur != e) break;\n        cur++;\n    }\n\n    return cur;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> h >> w;\n    f = vector<string>(h); for(auto& e : f) cin >> e;\n\n    rep(y, h+1) rep(x, w+1) rep(yy, h+1) rep(xx, w+1) memo[y][x][yy][xx] = -1;\n\n    cout << (rec(0, 0, w, h) == 0 ? \"Second\":\"First\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Turn{\n\tSente,\n\tGote,\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tchar table[20][21];\n\tvector<Data> V;\n};\n\nint H,W;\n\nmap<string,bool> MAP;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_SenteWin(Info info,Turn turn){\n\n\tif(turn == Sente){\n\n\t\tfor(int i = 0; i < info.V.size(); i++){\n\n\t\t\tInfo next_info;\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tnext_info.table[row][col] = info.table[row][col];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext_info.table[info.V[i].row][info.V[i].col] = '#';\n\n\t\t\tfor(int col = info.V[i].col-1; rangeCheck(info.V[i].row,col) == true && next_info.table[info.V[i].row][col] != '#'; col--){\n\t\t\t\tnext_info.table[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int col = info.V[i].col+1; rangeCheck(info.V[i].row,col) == true && next_info.table[info.V[i].row][col] != '#'; col++){\n\t\t\t\tnext_info.table[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row-1; rangeCheck(row,info.V[i].col) == true && next_info.table[row][info.V[i].col] != '#'; row--){\n\t\t\t\tnext_info.table[row][info.V[i].col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row+1; rangeCheck(row,info.V[i].col) == true && next_info.table[row][info.V[i].col] != '#'; row++){\n\t\t\t\tnext_info.table[row][info.V[i].col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_info.table[row][col] == '.'){\n\t\t\t\t\t\tnext_info.V.push_back(Data(row,col));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next_info.V.size() == 0)return true;\n\n\t\t\t//??¢????????£?????????????????????\n\t\t\tstring tmp;\n\n\t\t\tfor(int i = 0; i < next_info.V.size();i++){\n\t\t\t\ttmp.append(to_string(next_info.V[i].row));\n\t\t\t\ttmp.append(to_string(next_info.V[i].col));\n\t\t\t}\n\n\t\t\tauto at = MAP.find(tmp);\n\t\t\tif(at != MAP.end()) {\n\t\t\t\tif(MAP[tmp] == true){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif((MAP[tmp] = is_SenteWin(next_info,Gote)))return true;\n\t\t}\n\n\t\treturn false;\n\n\t}else{\n\n\t\tfor(int i = 0; i < info.V.size(); i++){\n\n\t\t\tInfo next_info;\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tnext_info.table[row][col] = info.table[row][col];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext_info.table[info.V[i].row][info.V[i].col] = '#';\n\n\t\t\tfor(int col = info.V[i].col-1; rangeCheck(info.V[i].row,col) == true && next_info.table[info.V[i].row][col] != '#'; col--){\n\t\t\t\tnext_info.table[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int col = info.V[i].col+1; rangeCheck(info.V[i].row,col) == true && next_info.table[info.V[i].row][col] != '#'; col++){\n\t\t\t\tnext_info.table[info.V[i].row][col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row-1; rangeCheck(row,info.V[i].col) == true && next_info.table[row][info.V[i].col] != '#'; row--){\n\t\t\t\tnext_info.table[row][info.V[i].col] = '#';\n\t\t\t}\n\n\t\t\tfor(int row = info.V[i].row+1; rangeCheck(row,info.V[i].col) == true && next_info.table[row][info.V[i].col] != '#'; row++){\n\t\t\t\tnext_info.table[row][info.V[i].col] = '#';\n\t\t\t}\n\n\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_info.table[row][col] == '.'){\n\t\t\t\t\t\tnext_info.V.push_back(Data(row,col));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next_info.V.size() == 0)return false;\n\n\t\t\t//??¢????????£?????????????????????\n\t\t\tstring tmp;\n\n\t\t\tfor(int i = 0; i < next_info.V.size();i++){\n\t\t\t\ttmp.append(to_string(next_info.V[i].row));\n\t\t\t\ttmp.append(to_string(next_info.V[i].col));\n\t\t\t}\n\n\n\t\t\tauto at = MAP.find(tmp);\n\t\t\tif(at != MAP.end()) {\n\t\t\t\tif(MAP[tmp] == false){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!(MAP[tmp] = is_SenteWin(next_info,Sente)))return false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tInfo first;\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",first.table[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first.table[row][col] == '.'){\n\t\t\t\tfirst.V.push_back(Data(row,col));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_SenteWin(first,Sente)){\n\t\tprintf(\"First\\n\");\n\t}else{\n\t\tprintf(\"Second\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define y1 Gacho\n#define N 20\nusing namespace std;\n\nstring s[N];\nint h, w, X[N][N];\nint grundy[N][N][N][N];\n\nint dfs(int y1, int y2, int x1, int x2){\n  \n  int &g=grundy[y1][y2][x1][x2];\n  \n  if(g!=-1) return g;\n  if(y2-y1<0||x2-x1<0) return g=0;\n  \n  set<int> S;\n  \n  for(int i=y1;i<=y2;i++)\n    for(int j=x1;j<=x2;j++){\n      if(X[i][j]) continue;\n      int a=dfs(y1,i-1,x1,j-1);\n      int b=dfs(y1,i-1,j+1,x2);\n      int c=dfs(i+1,y2,x1,j-1);\n      int d=dfs(i+1,y2,j+1,x2);\n      S.insert(a^b^c^d);\n    }\n  \n  int cnt=0;\n  \n  while(S.count(cnt)) cnt++;\n  \n  return g=cnt;\n}\n\nvoid solve(){\n\n  memset(grundy,-1,sizeof(grundy));\n  \n  cout<<(dfs(0, h-1, 0, w-1)?\"First\":\"Second\")<<endl;\n  \n}\n\nint main(){\n\n  cin>>h>>w;\n\n  for(int i=0;i<h;i++){\n    cin>>s[i];\n    for(int j=0;j<w;j++)\n      if(s[i][j]=='X') X[i][j]=1;\n  }\n\n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<set>\n#include<climits>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define FIR 1\n#define SEC 0\n\nshort h,w,memo[22][22][22][22];\nstring s[21];\n\nshort dfs(int xL,int yL,int xR,int yR,int phase) {\n  if( !( xL < xR && yL < yR ) ) {\n    return 0;\n  }\n  short &grundy = memo[xL][yL][xR][yR];\n  if( grundy != -1 ) return grundy;\n  set<int> S;\n  REP(y,yL,yR) {\n    REP(x,xL,xR) {\n      if( s[y][x] == 'X') continue;\n      int v = 0;\n      v ^= dfs(xL,yL,x,y,(phase+1)&1);\n      v ^= dfs(x+1,yL,xR,y,(phase+1)&1);\n      v ^= dfs(xL,y+1,x,yR,(phase+1)&1);\n      v ^= dfs(x+1,y+1,xR,yR,(phase+1)&1);\n      S.insert(v);\n    }\n  }\n  rep(i,1000) if( !S.count(i) ) {\n    grundy = i;\n    break;\n  }\n  return grundy;\n}\n\nvoid compute() {\n  memset(memo,-1,sizeof memo);\n  puts(dfs(0,0,w,h,FIR)?\"First\":\"Second\");\n}\n\nint main() {\n  if( 0 ) {\n    srand((unsigned int)time(NULL));\n    h = 4, w = 4;\n    cout << h << \" \" << w << endl;\n    rep(i,h) {\n      rep(j,w) {\n\tcout << ((rand()%2)?'X':'.');\n      }puts(\"\");\n    }\n    return 0;\n  }\n  cin >> h >> w;\n  rep(i,h) cin >> s[i];\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define y1 Gacho\n#define N 20\nusing namespace std;\n\nstring s[N];\nint h, w, X[N][N];\nint grundy[N][N][N][N];\n\nint dfs(int y1, int y2, int x1, int x2){\n  int &g=grundy[y1][y2][x1][x2];\n  if(g!=-1) return g;\n  if(y2-y1<0||x2-x1<0) return g=0;\n  \n  set<int> S;\n  \n  for(int i=y1;i<=y2;i++)\n    for(int j=x1;j<=x2;j++){\n      if(X[i][j]) continue;\n      int a=dfs(y1,i-1,x1,j-1);\n      int b=dfs(y1,i-1,j+1,x2);\n      int c=dfs(i+1,y2,x1,j-1);\n      int d=dfs(i+1,y2,j+1,x2);\n      S.insert(a^b^c^d);\n    }\n  \n  int cnt=0;\n  while(S.count(cnt)) cnt++;\n  \n  return g=cnt;\n}\n\nvoid solve(){\n\n  memset(grundy,-1,sizeof(grundy));\n    \n  cout<<(dfs(0, h-1, 0, w-1)?\"First\":\"Second\")<<endl;\n  \n}\n\nint main(){\n\n  cin>>h>>w;\n\n  for(int i=0;i<h;i++){\n    cin>>s[i];\n    for(int j=0;j<w;j++)\n      if(s[i][j]=='X'){\n\tX[i][j]=1;\n\ts[i][j]='.';\n      }\n  }\n\n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\nint dp[21][21][21][21];\nint H, W, x[20][20];\nint solve(int a1, int b1, int a2, int b2) {\n\tif (a1 > a2 || b1 > b2)return 0;\n\tif (dp[a1][b1][a2][b2] >= 0)return dp[a1][b1][a2][b2];\n\tset<int>S;\n\tfor (int i = a1; i <= a2; i++) {\n\t\tfor (int j = b1; j <= b2; j++) {\n\t\t\tif (x[i][j] == 1)continue;\n\t\t\tint V1 = solve(a1, b1, i - 1, j - 1);\n\t\t\tint V2 = solve(a1, j + 1, i - 1, b2);\n\t\t\tint V3 = solve(i + 1, b1, a2, j - 1);\n\t\t\tint V4 = solve(i + 1, j + 1, a2, b2);\n\t\t\tint V5 = V1 ^ V2 ^ V3 ^ V4;\n\t\t\tS.insert(V5);\n\t\t}\n\t}\n\tfor (int i = 0; i < 400; i++) {\n\t\tif (S.count(i) == 0) { dp[a1][b1][a2][b2] = i; break; }\n\t}\n\treturn dp[a1][b1][a2][b2];\n}\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < 441; i++) {\n\t\tfor (int j = 0; j < 441; j++)dp[i / 21][i % 21][j / 21][j % 21] = -1;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'X')x[i][j] = 1;\n\t\t}\n\t}\n\tint res = solve(0, 0, H - 1, W - 1);\n\tif (res == 0)cout << \"Second\" << endl;\n\telse { cout << \"First\" << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<set>\n#include<climits>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define FIR 1\n#define SEC 0\n\nshort h,w,memo[22][22][22][22][2];\nstring s[21];\n\nbool dfs(int xL,int yL,int xR,int yR,int phase) {\n  if( !( xL < xR && yL < yR ) ) {\n    return ( phase == FIR ) ? false : true;\n  }\n  short &res = memo[xL][yL][xR][yR][phase];\n  if( res != -1 ) return res;\n  res = ( phase == FIR ) ? false : true;\n  REP(y,yL,yR) {\n    REP(x,xL,xR) {\n      if( s[y][x] == 'X' ) continue;\n      int cnt = 0;\n      cnt += dfs(xL,yL,x,y,(phase+1)&1);\n      cnt += dfs(x+1,yL,xR,y,(phase+1)&1);\n      cnt += dfs(xL,y+1,x,yR,(phase+1)&1);\n      cnt += dfs(x+1,y+1,xR,yR,(phase+1)&1);\n      if( phase == FIR ) {\n\tcnt = 4 - cnt;\n\tif( !( cnt & 1 ) ) {\n\t  res = true;\n\t  goto Found;\n\t}\n      } else {\n\tif( !( cnt & 1 ) ) {\n\t  res = false;\n\t  goto Found;\n\t}\n      }\n    }\n  }\n Found:\n  return res;\n}\n\nvoid compute() {\n  memset(memo,-1,sizeof memo);\n  puts(dfs(0,0,w,h,FIR)?\"First\":\"Second\");\n}\n\nint main() {\n  cin >> h >> w;\n  rep(i,h) cin >> s[i];\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0}, vx[] = {0, 0, -1, 1};\n\nint H, W;\nstring S[20];\nint dp[20][20][21][21];\n\nint rec(int sx, int sy, int gx, int gy)\n{\n  if(sx >= gx || sy >= gy) return (0);\n  if(~dp[sx][sy][gx][gy]) return (dp[sx][sy][gx][gy]);\n  set< int > grundy;\n  for(int mx = sx; mx < gx; mx++) {\n    for(int my = sy; my < gy; my++) {\n      if(S[my][mx] == 'X') continue;\n      grundy.insert(rec(sx, sy, mx, my) ^\n                    rec(mx + 1, sy, gx, my) ^\n                    rec(sx, my + 1, mx, gy) ^\n                    rec(mx + 1, my + 1, gx, gy));\n    }\n  }\n  int ret = 0;\n  while(grundy.count(ret)) ++ret;\n  return (dp[sx][sy][gx][gy] = ret);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  if(rec(0, 0, W, H)) cout << \"First\" << endl;\n  else cout << \"Second\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\n#define MAX_H 22\n#define MAX_W 22\nint grundy[MAX_H][MAX_W][MAX_H][MAX_W]; // ????????????[u,d)&[l,r)\n\nint H, W;\nchar board[MAX_H][MAX_W];\n\nint calcGrundy(int u, int l, int d, int r)\n{\n  int& g = grundy[u][l][d][r];\n  if(~g) return g;\n  if(u >= d || l >= r) return g = 0;\n  set<int> V;\n  for(int i = u; i < d; i++) {\n    for(int j = l; j < r; j++) {\n      if(board[i][j] != 'X') {\n\tV.insert(calcGrundy(u, l, i, j) ^ calcGrundy(u, j+1, i, r)\n\t\t ^ calcGrundy(i+1, l, d, j) ^ calcGrundy(i+1, j+1, d, r));\n      }\n    }\n  }\n  g = 0;\n  while(V.count(g)) g++;\n  return g;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  cin >> H >> W;\n  rep(i, H) rep(j, W) cin >> board[i][j];\n  memset(grundy, -1, sizeof(grundy));\n  cout << (calcGrundy(0, 0, H, W) ? \"First\" : \"Second\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint w, h;\nvs fld;\nint dp[22][22][22][22];\n\nint grundy(int top, int left, int bottom, int right)\n{\n\tif (dp[top][left][bottom][right] >=0) return dp[top][left][bottom][right];\n\tset<int> st;\n\tFOR(i, top, bottom)FOR(j, left, right) \n\t{\n\t\tif (fld[i][j] == 'X') continue;\n\t\tst.insert(grundy(top, left, i, j) ^ grundy(i + 1, left, bottom, j) ^ grundy(top, j + 1, i, right) ^ grundy(i + 1, j + 1, bottom, right));\n\t}\n\tint res = 0;\n\twhile (st.count(res)) res++;\n\treturn dp[top][left][bottom][right] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tMS(dp, -1);\n\tcin >> h >> w;\n\tfld.resize(h);\n\tREP(i, h) cin >> fld[i];\n\tif (grundy(0, 0, h, w)) puts(\"First\");\n\telse puts(\"Second\");\n\tquick_exit(EXIT_SUCCESS);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint H, W;\nvector<string> s(20);\nint dp[20][20][20][20];\n\nint grundy(int sx, int sy, int gx, int gy)\n{\n    if (gx < sx || gy < sy)\n        return 0;\n    if (dp[sx][sy][gx][gy] >= 0)\n        return dp[sx][sy][gx][gy];\n\n    set<int> st;\n    for (int i = sx; i <= gx; i++)\n    {\n        for (int j = sy; j <= gy; j++)\n        {\n            if (s[i][j] == '.')\n            {\n                st.insert(grundy(sx, sy, i - 1, j - 1) ^ grundy(i + 1, sy, gx, j - 1) ^ grundy(sx, j + 1, i - 1, gy) ^ grundy(i + 1, j + 1, gx, gy));\n            }\n        }\n    }\n    int res = 0;\n    while (st.find(res) != st.end())\n        res++;\n    return dp[sx][sy][gx][gy] = res;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> H >> W;\n    memset(dp, -1, sizeof(dp));\n    for (int i = 0; i < H; i++)\n        cin >> s[i];\n    cout << (grundy(0, 0, H - 1, W - 1) ? \"First\" : \"Second\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool G[21][21];\nint dp[21][21][21][21];\n\nint h, w;\n\nint grundy(int si, int sj, int gi, int gj){\n    int &res = dp[si][sj][gi][gj];\n    if(res != -1) return res;\n\n    res = 0;\n    if(si > gi || sj > gj) return res;\n\n    vector<int> result;\n\n    for(int i = si; i < gi; i++){\n        for(int j = sj; j < gj; j++){\n            if(G[i][j]) continue;\n            int g = 0;\n            g ^= grundy(si, sj, i, j);\n            g ^= grundy(si, j + 1, i, gj);\n            g ^= grundy(i + 1, sj, gi, j);\n            g ^= grundy(i + 1, j + 1, gi, gj);\n            result.push_back(g);\n        }\n    }\n\n    /*sif(si == 0 && sj == 0 && gi == h && gj == w){\n        cout << \"hoge~~~~\" << endl;\n        for(int i = 0; i < (int)result.size(); i++){\n            cout << result[i] << \" \";\n        }\n        cout << endl;\n    }*/\n    sort(result.begin(), result.end());\n    result.erase(unique(result.begin(), result.end()), result.end());\n    \n\n    for(int i = 0; i < (int)result.size(); i++){\n        if(result[i] != i) break;\n        res++;\n    }\n\n    //cout << \"[\" << si << \"][\" << sj << \"][\" << gi << \"][\" << gj << \"] = \" << res << endl;\n    return res;\n}\n\nint main(){\n\n    memset(dp, -1, sizeof(dp));\n    cin >> h >> w;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            char in; cin >> in;\n            G[i][j] = (in == 'X');\n        }\n    }\n\n    if(grundy(0, 0, h, w) == 0) cout << \"Second\" << endl;\n    else cout << \"First\" << endl;\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<set>\n#include<climits>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define FIR 1\n#define SEC 0\n\nshort h,w,memo[22][22][22][22][2];\nstring s[21];\n\nbool dfs(int xL,int yL,int xR,int yR,int phase) {\n  if( !( xL < xR && yL < yR ) ) {\n    return ( phase == FIR ) ? false : true;\n  }\n  short &res = memo[xL][yL][xR][yR][phase];\n  if( res != -1 ) return res;\n  res = ( phase == FIR ) ? false : true;\n  REP(y,yL,yR) {\n    REP(x,xL,xR) {\n      if( s[y][x] == 'X' ) continue;\n      int cnt = 0;\n      cnt += dfs(xL,yL,x,y,(phase+1)&1);\n      cnt += dfs(x+1,yL,xR,y,(phase+1)&1);\n      cnt += dfs(xL,y+1,x,yR,(phase+1)&1);\n      cnt += dfs(x+1,y+1,xR,yR,(phase+1)&1);\n      if( !( cnt & 1 ) ) {\n\tres = ( phase == FIR ) ? true : false;\n\tgoto Found;\n      } \n    }\n  }\n Found:\n  return res;\n}\n\nvoid compute() {\n  memset(memo,-1,sizeof memo);\n  puts(dfs(0,0,w,h,FIR)?\"First\":\"Second\");\n}\n\nint main() {\n  cin >> h >> w;\n  rep(i,h) cin >> s[i];\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 22;\n\nint h,w;\nstring f[N];\n\nint dp[N][N][N][N];\nint Grundy(int ly, int lx, int ry, int rx){\n    if(ry<ly || rx<lx) return 0;\n    if(dp[ly][lx][ry][rx]>=0) return dp[ly][lx][ry][rx];\n\n    set<int> s;\n    for(int i=ly; i<=ry; ++i)for(int j=lx; j<=rx; ++j){\n        if(f[i][j]=='.'){\n            int g = Grundy(ly,lx,i-1,j-1)^Grundy(ly,j+1,i-1,rx)^Grundy(i+1,lx,ry,j-1)^Grundy(i+1,j+1,ry,rx);\n            s.insert(g);\n        }\n    }\n\n    int ret = 0;\n    while(s.count(ret)) ++ret;\n\n    return dp[ly][lx][ry][rx] = ret;\n}\n\nint main(){\n    cin >>h >>w;\n    rep(i,h) cin >>f[i];\n\n    memset(dp,-1,sizeof(dp));\n    int g = Grundy(0,0,h-1,w-1);\n    cout << (g==0?\"Second\":\"First\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <bitset>\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\n// constexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\ntemplate <typename F>\nclass fix_point: F {\npublic:\n  explicit constexpr fix_point(F&& f) noexcept: F(std::forward<F>(f)) {}\n\n  template <typename... Args>\n  constexpr decltype(auto) operator ()(Args&&... args) const {\n    return F::operator ()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <typename F>\nstatic inline constexpr decltype(auto) make_fix_point(F&& f) noexcept {\n  return fix_point<F>{std::forward<F>(f)};\n}\n\nint main() {\n  size_t h, w;\n  scanf(\"%zu %zu\", &h, &w);\n\n  std::vector<std::string> s(h);\n  for (auto& si: s) {\n    char buf[32];\n    scanf(\"%s\", buf);\n    si = buf;\n  }\n\n  std::vector<int> memo(21_zu*21*21*21, -1);\n\n  auto enc = [&](size_t u, size_t b, size_t l, size_t r) {\n    return u + 21 * (b + 21 * (l + 21 * r));\n  };\n\n  auto grundy = make_fix_point([&](auto dfs, size_t u, size_t b, size_t l, size_t r) -> int {\n      if (u >= b || l >= r) return 0;\n\n      int& res = memo[enc(u, b, l, r)];\n      if (res != -1) return res;\n\n      std::bitset<21*21*21*21> bs;\n      bs.flip();\n      for (size_t i = u; i < b; ++i)\n        for (size_t j = l; j < r; ++j) {\n          if (s[i][j] != '.') continue;\n          int cur = 0;\n          cur ^= dfs(u, i, l, j);\n          cur ^= dfs(i+1, b, l, j);\n          cur ^= dfs(u, i, j+1, r);\n          cur ^= dfs(i+1, b, j+1, r);\n          bs.reset(cur);\n        }\n\n      res = bs._Find_first();\n      return res;\n  })(0_zu, h, 0_zu, w);\n\n  puts((grundy > 0)? \"First\": \"Second\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint grundy[21][21][21][21];\n\nint calc_grundy(int y1, int x1, int y2, int x2, vector<string> const& v) {\n    if(y2 <= y1 || x2 <= x1) {\n        return grundy[y1][x1][y2][x2] = 0;\n    }\n    int& r = grundy[y1][x1][y2][x2];\n    if(r != -1) {\n        return r;\n    }\n    set<int> s;\n    for(int i=y1; i<y2; ++i) {\n        for(int j=x1; j<x2; ++j) {\n            if(v[i][j] == 'X') {\n                continue;\n            }\n            int g = 0;\n            g ^= calc_grundy(y1, x1, i, j, v);\n            g ^= calc_grundy(i+1, x1, y2, j, v);\n            g ^= calc_grundy(y1, j+1, i, x2, v);\n            g ^= calc_grundy(i+1, j+1, y2, x2, v);\n            s.insert(g);\n        }\n    }\n    r = 0;\n    while(s.count(r) == 1) {\n        r++;\n    }\n    return r;\n}\n\nstring solve(vector<string> const& v) {\n    const int H = v.size();\n    const int W = v[0].size();\n    return calc_grundy(0, 0, H, W, v) == 0 ? \"Second\" : \"First\";\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    for(int i=0; i<21; ++i) {\n        for(int j=0; j<21; ++j) {\n            for(int k=0; k<21; ++k) {\n                for(int l=0; l<21; ++l) {\n                    grundy[i][j][k][l] = -1;\n                }\n            }\n        }\n    }\n    vector<string> v(H);\n    for(int i=0; i<H; ++i) {\n        cin >> v[i];\n    }\n    cout << solve(v) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[30][30][30][30];\nchar str[30][30];\nint calc(int a,int b,int c,int d){\n\tif(a>=b||c>=d)return 0;\n\tif(dp[a][b][c][d]!=-1)return dp[a][b][c][d];\n\tint val[64];\n\tfor(int i=0;i<64;i++)val[i]=0;\n\tfor(int i=a;i<b;i++)for(int j=c;j<d;j++){\n\t\tif(str[i][j]=='X')continue;\n\t\tint tmp=0;\n\t\ttmp^=calc(a,i,c,j);\n\t\ttmp^=calc(i+1,b,c,j);\n\t\ttmp^=calc(a,i,j+1,d);\n\t\ttmp^=calc(i+1,b,j+1,d);\n\t\tval[tmp]=1;\n\t}\n\tfor(int i=0;i<64;i++)if(!val[i])return dp[a][b][c][d]=i;\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<30;i++)for(int j=0;j<30;j++)for(int k=0;k<30;k++)for(int l=0;l<30;l++)\n\t\tdp[i][j][k][l]=-1;\n\tint ret=calc(0,a,0,b);\n\tif(ret)printf(\"First\\n\");\n\telse printf(\"Second\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 21\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nint H, W;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint memo[MAX][MAX][MAX][MAX];\n\nint grundy(int x1, int y1, int x2, int y2, Mat &f)\n{\n    if (x1 > x2 || y1 > y2) {\n        return 0;\n    }\n\n    if (memo[y1][x1][y2][x2] != -1) {\n        return memo[y1][x1][y2][x2];\n    }\n        \n    set<int> st;\n    for (int i = y1; i <= y2; i++) {\n        for (int j = x1; j <= x2; j++) {\n            if (f[i][j] == 0) {\n                st.insert(grundy(x1, y1, j-1, i-1, f) ^\n                          grundy(j+1, y1, x2, i-1, f) ^\n                          grundy(x1, i+1, j-1, y2, f) ^\n                          grundy(j+1, i+1, x2, y2, f));\n            }\n        }\n    }   \n    \n    int res = 0;\n    while (st.count(res)) res++;\n    return (memo[y1][x1][y2][x2] = res);\n}\n\nint main()\n{    \n    cin >> H >> W;\n    Mat f(H);\n    for (int i = 0; i < H; i++) {\n        f[i].resize(W);\n        for (int j = 0; j < W; j++) {\n            char ch;\n            cin >> ch;\n            f[i][j] = (ch == 'X');\n        }\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (grundy(0, 0, W-1, H-1, f) != 0 ? \"First\" : \"Second\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int S = 22;\nint dp[S][S][S][S];\nchar m[S][S];\n\nbool used[S*S];\nint mex(const vector<int> &vec)\n{\n    for(auto x: vec)\n        used[x] = true;\n    int ans;\n    for(int i = 0; ; i++)\n        if(!used[i])\n        {\n            ans = i;\n            break;\n        }\n    for(auto x: vec)\n        used[x] = false;\n    return ans;\n}\n\nint main()\n{\n    int h, w;\n    scanf(\"%d %d\", &h, &w);\n    for(int i = 1; i <= h; i++)\n        scanf(\"%s\", m[i] + 1);\n    for(int i = 0; i < h; i++)\n        for(int j = 0; j < w; j++)\n            for(int x0 = 1; x0 + i <= h; x0++)\n                for(int y0 = 1; y0 + j <= w; y0++)\n                {\n                    int x1 = x0 + i, y1 = y0 + j;\n                    vector<int> vec;\n                    for(int x = x0; x <= x1; x++)\n                        for(int y = y0; y <= y1; y++)\n                            if(m[x][y] == '.')\n                                vec.push_back(dp[x0][x-1][y0][y-1]\n                                            ^ dp[x+1][x1][y0][y-1]\n                                            ^ dp[x0][x-1][y+1][y1]\n                                            ^ dp[x+1][x1][y+1][y1]);\n                    dp[x0][x1][y0][y1] = mex(vec);\n                }\n    puts(dp[1][h][1][w] ? \"First\" : \"Second\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<set>\n#include<climits>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define FIR 1\n#define SEC 0\n\nshort h,w,memo[22][22][22][22][2];\nstring s[21];\n\nbool dfs(int xL,int yL,int xR,int yR,int phase) {\n  if( !( xL < xR && yL < yR ) ) {\n    return ( phase == FIR ) ? false : true;\n  }\n  short &res = memo[xL][yL][xR][yR][phase];\n  if( res != -1 ) return res;\n  res = ( phase == FIR ) ? false : true;\n  REP(y,yL,yR) {\n    REP(x,xL,xR) {\n      if( s[y][x] == 'X' ) continue;\n      int cnt = 0;\n      cnt += dfs(xL,yL,x,y,(phase+1)&1);\n      cnt += dfs(x+1,yL,xR,y,(phase+1)&1);\n      cnt += dfs(xL,y+1,x,yR,(phase+1)&1);\n      cnt += dfs(x+1,y+1,xR,yR,(phase+1)&1);\n      if( phase == SEC ) cnt = 4 - cnt;\n      if( !( cnt & 1 ) ) {\n\tres = ( phase == FIR ) ? true : false;\n\tgoto Found;\n      } \n    }\n  }\n Found:\n  return res;\n}\n\nvoid compute() {\n  memset(memo,-1,sizeof memo);\n  puts(dfs(0,0,w,h,FIR)?\"First\":\"Second\");\n}\n\nint main() {\n  cin >> h >> w;\n  rep(i,h) cin >> s[i];\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint H, W;\nchar map[25][25];\nint memo[25][25][25][25];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(sx > tx || sy > ty) return 0;\n\tif(memo[sx][sy][tx][ty] != -1) return memo[sx][sy][tx][ty];\n\t\n\tint g;\n\tset<int> s;\n\tfor(int x = sx; x <= tx; x++){\n\t\tfor(int y = sy; y <= ty; y++){\n\t\t\tif(map[x][y] == 'X') continue;\n\t\t\tg = 0;\n\t\t\tg ^= calc(sx, sy, x-1, y-1);\n\t\t\tg ^= calc(x+1, sy, tx, y-1);\n\t\t\tg ^= calc(sx, y+1, x-1, ty);\n\t\t\tg ^= calc(x+1, y+1, tx, ty);\n\t\t\ts.insert(g);\n\t\t}\n\t}\n\tint ret = 0;\n\twhile(s.count(ret)) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\tcin >> H >> W;\n\tfor(int y = 0; y < H; y++){\n\t\tfor(int x = 0; x < W; x++){\n\t\t\tcin >> map[x][y];\n\t\t}\n\t}\n\t\n\tfor(int sx = 0; sx < W; sx++){\n\t\tfor(int sy = 0; sy < H; sy++){\n\t\t\tfor(int tx = 0; tx < W; tx++){\n\t\t\t\tfor(int ty = 0; ty < H; ty++){\n\t\t\t\t\tmemo[sx][sy][tx][ty] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(calc(0, 0, W-1, H-1)) cout << \"First\" << endl;\n\telse cout << \"Second\" << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    H, W = map(int, readline().split())\n    f = \".X\".index\n    S = [list(map(f, readline().strip())) for i in range(H)]\n    memo = {}\n    def dfs(px, py, qx, qy):\n        key = (px, py, qx, qy)\n        if key in memo:\n            return memo[key]\n        res = set()\n        for y in range(py, qy):\n            for x in range(px, qx):\n                if S[y][x]:\n                    continue\n                r1 = dfs(px, py, x, y)\n                r2 = dfs(x+1, py, qx, y)\n                r3 = dfs(px, y+1, x, qy)\n                r4 = dfs(x+1, y+1, qx, qy)\n                res.add(r1 ^ r2 ^ r3 ^ r4)\n        k = 0\n        while k in res:\n            k += 1\n        memo[key] = k\n        return k\n    if dfs(0, 0, W, H):\n        write(\"First\\n\")\n    else:\n        write(\"Second\\n\")\nsolve()\n"
  }
]