[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.io.StdIn._\nobject Main extends App {\n\n  loop\n  @tailrec\n  def loop: Unit = {\n    val max = readInt\n    if (max == 0) return\n    val n = readInt\n    val cell = 0 +: Array.tabulate(n){i ⇒\n      val d = readInt\n      if (d + i + 1 > n + 1) n + 1\n      else if (d + i + 1 < 0) 0\n      else d + i + 1\n    } :+ n + 1\n    val canReachFrom = Array.tabulate(n + 2){_ ⇒ Nil: List[Int]}\n    val canStop = Array.tabulate(n + 2){_ ⇒ false}\n    canStop(0) = true\n    val queue = mutable.Queue[Int](0)\n    while(queue.nonEmpty){\n      val current = queue.dequeue()\n      for (i ← current + 1 to math.min(n + 1, current + max)){\n        canReachFrom(cell(i)) ::= current\n        if (!canStop(cell(i))) {\n          canStop(cell(i)) = true\n          queue.enqueue(cell(i))\n        }\n      }\n    }\n    for (i ← canStop.indices) canStop(i) = false\n    canStop(n + 1) = true\n    queue.enqueue(n + 1)\n    while (queue.nonEmpty){\n      val current = queue.dequeue()\n      for (i ← canReachFrom(current) if !canStop(i)) {\n        canStop(i) = true\n        queue.enqueue(i)\n      }\n    }\n    println(\n      if (canStop.indices.forall(i ⇒ canStop(i) || canReachFrom(i).isEmpty)) \"OK\" else \"NG\"\n    )\n    loop\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\nint come[300];\nbool dfs(const int now,const vector<vector<int>>&edges, const int goal) {\n\tassert(come[now] == false);\n\tcome[now] = true;\n\tif (now == goal)return true;\n\telse {\n\t\tif (edges[now].empty())return false;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (e == now)assert(false);\n\t\t\tif (!dfs(e, edges, goal))return false;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tmemset(come, false, sizeof(come));\n\t\tint amax;\n\t\tcin >> amax;\n\t\tif (!amax)break;\n\t\tint N; cin >> N;\n\t\tconst int goal = N + 1;\n\t\tconst int start = 0;\n\t\tvector<int>ds(goal+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tvector<vector<int>>edges(N + 2);\n\t\tfor (int i = 0; i < N + 1; ++i) {\n\t\t\tfor (int j = 1; j <= amax; ++j) {\n\t\t\t\tint next;\n\t\t\t\tif (i + j >= goal) {\n\t\t\t\t\tnext = goal;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i + j + ds[i + j] >= goal) {\n\t\t\t\t\t\tnext = goal;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i + j + ds[i+j]<0) {\n\t\t\t\t\t\tnext = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnext = i + j + ds[i + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (find(edges[i].begin(), edges[i].end(), next) == edges[i].end()) {\n\t\t\t\t\tedges[i].push_back(next);\n\t\t\t\t}\n\t\t\t\tsort(edges[i].begin(), edges[i].end());\n\t\t\t}\n\t\t}\n\t\tauto p=dscc.get(edges);\n\t\tint newstart=-1;\n\t\tint newgoal=-1;\n\t\tfor (int i = 0; i < p.first.size();++i) {\n\t\t\tauto b = p.first[i];\n\t\t\tif (find(b.begin(), b.end(), 0)!=b.end()) {\n\t\t\t\tnewstart = i;\n\t\t\t}\n\t\t\tif (find(b.begin(), b.end(), goal) != b.end()) {\n\t\t\t\tnewgoal= i;\n\t\t\t}\n\t\t}\n\t\tif (newstart == -1 || newgoal == -1)cout << \"ff\";\n\t\tauto newedges = p.second;\n\t\t\n\t\tbool ans = dfs(newstart, newedges, newgoal);\n\t\tif (ans) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nint ma;\nint n;\nint a[252];\nint d[252];\nbool f[252];\n\nbool search(int x, int cnt)\n{\n\tif (x == n + 1) return true;\n\tif (d[x] < cnt) return false;\n\tif (cnt > 5000) return false;\n\t//printf(\"_ %d\\n\", x);\n\td[x] = cnt;\n\tfor (int i = 1; i <= ma; i++){\n\t\tint to = min(x + i, n + 1);\n\t\tto += a[to];\n\t\tto = max(to, 0);\n\t\tto = min(to, n + 1);\n\t\tif (search(to, cnt + 1)) return true;\n\t}\n\treturn false;\n}\n\nvoid solve()\n{\n\tbool res = true;\n\tfill(f, f + 252, false);\n\tfill(d, d + 252, INF);\n\tsearch(0, 0);\n\tfor (int i = 0; i <= n; i++){\n\t\tf[i] = (d[i] != INF);\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tif (f[i]){\n\t\t\tfill(d, d + 252, INF);\n\t\t\tres &= search(i, 0);\n\t\t}\n\t}\n\tputs(res ? \"OK\" : \"NG\");\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &ma), ma){\n\t\tfill(a, a + 252, 0);\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint m, n, d[559], e[559]; bool canvis[559], vis[559];\nint main() {\n\twhile (cin >> m, m) {\n\t\tcin >> n;\n\t\tfill(d, d + 555, 0);\n\t\tfor (int i = 1; i <= n; i++) cin >> d[i];\n\t\tfor (int i = 0; i < 555; i++) {\n\t\t\tint p = i + d[i];\n\t\t\tp = min(p, n + 1);\n\t\t\tp = max(p, 0);\n\t\t\te[i] = p;\n\t\t}\n\t\tqueue<int> que1; que1.push(0);\n\t\tfill(canvis, canvis + 555, false); canvis[0] = true;\n\t\twhile (!que1.empty()) {\n\t\t\tint u = que1.front(); que1.pop();\n\t\t\tfor (int i = 1; i <= m; i++) {\n\t\t\t\tint t = e[u + i];\n\t\t\t\tif (!canvis[t]) {\n\t\t\t\t\tcanvis[t] = true;\n\t\t\t\t\tque1.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ret = true;\n\t\tfor (int i = 0; i <= n + 1; i++) {\n\t\t\tif (!canvis[i]) continue;\n\t\t\tfill(vis, vis + 555, false); vis[i] = true;\n\t\t\tqueue<int> que2; que2.push(i);\n\t\t\twhile (!que2.empty()) {\n\t\t\t\tint u = que2.front(); que2.pop();\n\t\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\t\tint t = e[u + j];\n\t\t\t\t\tif (!vis[t]) {\n\t\t\t\t\t\tvis[t] = true;\n\t\t\t\t\t\tque2.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[n + 1]) ret = false;\n\t\t}\n\t\tcout << (ret ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint n,m;\nint start,end;\nvector<int> v,p;\nvector<bool> flag;\nbool ans;\n\nvoid init(int now)\n{\n\trep(i,end+1)\n\t{\n\t\tint next = i + v[i];\n\t\tif(now == next || (now == end && now < next))\n\t\t{\n\t\t\tREP(j,1,m+1)\n\t\t\t{\n\t\t\t\tif(0 <= i-j && !flag[i-j])\n\t\t\t\t{\n\t\t\t\t\tflag[i-j] = true;\n\t\t\t\t\tinit(i-j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(vector<bool> used,int now)\n{\n\tif(!flag[now]) \n\t{\n\t\tans = false;\n\t}\n\n\tREP(j,1,m+1)\n\t{\n\t\tif(now + j <= end)\n\t\t{\n\t\t\tint next = now + j + v[now + j];\n\t\t\tif(next < 0) next = 0;\n\t\t\tif(next > end) next = end;\n\n\t\t\tif(used[next]) continue;\n\t\t\tused[next] = true;\n\t\t\tdfs(used,next);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin >> m && m)\n\t{\n\t\tp.clear();\n\t\tp.resize(m);\n\t\trep(i,m) p[i] = i+1;\n\n\t\tcin >> n;\n\n\t\tv.clear();\n\t\tv.resize(n+2);\n\t\t\n\t\tv[0] = 0;\n\t\tstart = 0;\n\n\t\tREP(i,1,n+1) cin >> v[i];\n\n\t\tv[n+1] = 0;\n\t\tend = n+1;\n\t\n\t\tans = true;\n\t\tvector<bool> used(n+2);\n\t\trep(i,n+2) used[i] = false;\n\t\tused[0] = true;\n\n\t\tflag.clear();\n\t\tflag.resize(n+2);\n\t\trep(i,n+2) flag[i] = false;\n\n\t\tflag[n+1] = true;\n\t\tinit(n+1);\n\t\tdfs(used,0);\n\n\t\tif(ans) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint n, a[300], m; bool u1[300], u2[300];\nint main() {\n\twhile (true) {\n\t\tcin >> m; if (m == 0)break; cin >> n;\n\t\tfor (int i = 0; i < 300; i++)a[i] = 0;\n\t\tfor (int i = 1; i <= n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < 300; i++)u1[i] = false; u1[0] = true;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tif (u1[j] == false)continue;\n\t\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\t\tint G = j + k; if (G > n)G = n + 1;\n\t\t\t\t\tG += a[G]; if (G < 0)G = 0; if (G > n)G = n + 1; u1[G] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tif (u1[i] == false)continue;\n\t\t\tfor (int j = 0; j < 300; j++)u2[j] = false; u2[i] = true;\n\t\t\tqueue<int>Q; Q.push(i);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\t\tint G = a1 + j; if (G > n)G = n + 1;\n\t\t\t\t\tG += a[G]; if (G < 0)G = 0; if (G > n)G = n + 1;\n\t\t\t\t\tif (u2[G] == false) { u2[G] = true; Q.push(G); }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (u2[n + 1] == false) { cout << \"NG\" << endl; flag = true; break; }\n\t\t}\n\t\tif (flag == false)cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define repi(i,a,b) for( int i = (a); i != (b); ++i )\n\nint ma;\nint n;\nint d[252];\nstd::vector<int> G[252], rG[252];\nbool reach[252], rev[252];\n\nvoid dfs( int v )\n{\n\trev[v] = true;\n\n\trep( i, rG[v].size() )\n\t\tif( !rev[rG[v][i]] )\n\t\t\tdfs( rG[v][i] );\n\n\treturn;\n}\n\nvoid dfs2( int v )\n{\n\treach[v] = true;\n\n\trep( i, G[v].size() )\n\t\tif( !reach[G[v][i]] )\n\t\t\tdfs2( G[v][i] );\n\n\treturn;\n}\n\nint main()\n{\n\twhile( scanf( \"%d\", &ma ), ma )\n\t{\n\t\trep( i, 252 )\n\t\t\tG[i].clear(), rG[i].clear();\n\n\t\tscanf( \"%d\", &n );\n\n\t\trepi( i, 1, n+1 )\n\t\t\tscanf( \"%d\", d+i );\n\n\t\trep( i, n+1 )\n\t\t{\n\t\t\trep( j, ma )\n\t\t\t{\n\t\t\t\tif( i+j+1 >= n+2 )\n\t\t\t\t\tbreak;\n\n\t\t\t\tint to = std::max( 0, std::min( i+j+1+d[i+j+1], n+1 ) );\n\t\t\t\tG[i].push_back( to );\n\t\t\t\trG[to].push_back( i );\n\t\t\t}\n\t\t}\n\n\t\tmemset( reach, false, sizeof( reach ) );\n\t\tmemset( rev, false, sizeof( rev ) );\n\t\tdfs( n+1 );\n\t\tdfs2( 0 );\n\n\t\tbool fl = true;\n\t\trep( i, n+2 )\n\t\t\tif( reach[i] && !rev[i] )\n\t\t\t\tfl = false;\n\n\t\tputs( fl ? \"OK\" : \"NG\" );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_N = 300;\nint maxi,n,d[MAX_N];\nbool reach[MAX_N][MAX_N];\n\nint main(){\n  while( cin >> maxi, maxi ){\n    cin >> n;\n    REP(i,1,n+1) cin >> d[i];\n    n += 2;\n    rep(i,n) rep(j,n) reach[i][j] = false;\n    rep(i,n) reach[i][i] = true;\n    rep(i,n-1) {\n      REP(j,1,maxi+1){\n        int next = i + j;\n        next = min(next,n-1);\n        next += d[next];\n        next = min(next,n-1);\n        next = max(next,0);\n        reach[i][next] = true;\n      }\n    }\n    rep(k,n) rep(i,n) rep(j,n) if( reach[i][k] && reach[k][j] )reach[i][j] = true;\n    bool success = true;\n    rep(i,n) if( reach[0][i] && !reach[i][n-1] ) { success = false; break; }\n    puts(success?\"OK\":\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint main(){\tfor(int m,n,i,j,k,a;a=1,scanf(\"%d\",&m),m;puts(a?\"OK\":\"NG\")){int d[300]={0},g[300][300]={0};scanf(\"%d\",&n);for(i=1;i<=n;)scanf(\"%d\",d+i++);for(i=0;i<=n;i++)for(j=1;j<=m;j++)k=i+j+d[i+j],(k=k<0?0:n+1<k?n+1:k),g[i][k]=1;for(k=0;k<n+2;k++)for(i=0;i<n+2;i++)for(j=0;j<n+2;j++)if(g[i][k]&&g[k][j])g[i][j]=1;for(i=0;i<=n;i++)if(g[0][i]&&!g[i][n+1])a=0;}}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nint a[1000], used[1000], b[300][300], used2[1000];\nvector<int> G[300];\nvoid dfs(int u){\n\tif(used[u])return;\n\tused[u] = 1;\n\trep(i,G[u].size()){\n\t\tdfs(G[u][i]);\n\t}\n}\n\nvoid dfs2(int u, int R, int t){\n\tif(used2[u])return;\n\tused2[u] = 1;\n\tint i = u;\n\trrep(j,R){\n\t\tif(i+j >= t){b[i][t] = 1;dfs2(t, R, t);continue;}\n\t\tif(i+j+a[i+j] < 0){b[i][0] = 1;dfs2(0, R, t);continue;}\n\t\tif(i+j+a[i+j] >= t){b[i][t] = 1;dfs2(t, R, t);continue;}\n\t\tb[i][i+j+a[i+j]] = 1;dfs2(i+j+a[i+j], R, t);\n\t}\n}\n\nvoid init(){\n\trep(i,300)rep(j,300)b[i][j] = 0;\n\tfill(used2, used2+1000, 0);\n\tfill(used, used+1000, 0);\n\trep(i,300)G[i].clear();\n}\n\nsigned main(){\n\twhile(1){\n\t\tint R, n;\n\t\tscanf(\"%lld\", &R);\n\t\tif(R == 0)break;\n\t\tscanf(\"%lld\", &n);\n\t\trrep(i,n)scanf(\"%lld\", &a[i]);\n\t\tint s = 0, t = n+1;\n\t\tinit();\n\t\tdfs2(0, R, t);\n\t\trep(i,t+1)rep(j,t+1){if(b[j][i])G[i].pb(j);}\n\t\tdfs(t);\n\t\t\n\t\tint ans = 1;\n\t\trep(i,t+1)if(used[i] != used2[i])ans = 0;\n\t\t/*rep(i,t+1)printf(\"%lld \", used2[i]);printf(\"\\n\");\n\t\trep(i,t+1)printf(\"%lld \", used[i]);printf(\"\\n\");\n\t\trep(i,t+1)printf(\"%lld \", (int)(G[i].size()));printf(\"\\n\");*/\n\t\t/*rep(i,t+1){\n\t\t\trep(j,t+1)printf(\"%lld \", b[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%s\\n\", ans ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int me;scanf(\"%d\",&me),me;){\n\t\tint n; scanf(\"%d\",&n);\n\t\tint a[252]={};\n\t\trep(i,n) scanf(\"%d\",a+i+1);\n\t\tn+=2;\n\n\t\tbool vis[252]={true};\n\t\tint Q[252],head=0,tail=0;\n\t\tQ[tail++]=0;\n\t\twhile(head<tail){\n\t\t\tint x=Q[head++];\n\n\t\t\tif(a[x]==0){\n\t\t\t\tfor(int a=1;a<=me;a++){\n\t\t\t\t\tint xx=min(x+a,n-1);\n\t\t\t\t\tif(!vis[xx]){\n\t\t\t\t\t\tvis[xx]=true;\n\t\t\t\t\t\tQ[tail++]=xx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint xx=max(min(x+a[x],n-1),0);\n\t\t\t\tif(!vis[xx]){\n\t\t\t\t\tvis[xx]=true;\n\t\t\t\t\tQ[tail++]=xx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tputs(vis[n-1]?\"OK\":\"NG\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint m,n;\nint a[300];\nbool used[300];\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> m;\n\t\tif(m==0)break;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++)cin >> a[i];\n\t\tbool flag=true;\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tbool p=true;\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tint k=((i+j>=n+1)?n+1:i+j+a[i+j]);\n\t\t\t\tif(k>i)\n\t\t\t\t{\n\t\t\t\t\tp=false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p)\n\t\t\t{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tend:;\n\t\t}\n\t\tcout << \"OK\" << endl;\n\t\tnext:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nint x[1000], n, maxn, k[1000], t[1000];\nqueue<int>Q;\n\nvoid bfs(int s,int p) {\n\tQ.push(s);\n\twhile (!Q.empty()) {\n\t\tfor (int i = 1; i <= p; i++) {\n\t\t\tt[Q.front() + i] = 1;\n\t\t\tQ.push(x[Q.front() + i]);\n\t\t}\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(k, 0, sizeof(k));\n\t\tcin >> maxn;\n\t\tif (maxn == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> x[i];\n\t\t\tx[i] += i;\n\t\t\tif (x[i] < 0) { x[i] = 0; }\n\t\t\tif (x[i] > n) { x[i] = n; }\n\t\t}\n\t\tbfs(0, maxn);\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tk[i] = t[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmemset(t, 0, sizeof(t));\n\t\t\tif (k[i] == 1) {\n\t\t\t\tbfs(i, maxn);\n\t\t\t\tif (t[n + 1] == 0) { cout << \"NG\" << endl; goto owata; }\n\t\t\t}\n\t\t}\n\t\tcout << \"OK\" << endl;\n\towata:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nint ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\tif (ka[y][x] == 1)break;\n\t\t\t\tka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\tfor (int j = 0; j<300; j++)\n\t\t\t{\n\t\t\t\tka[i][j] = 0;\n\t\t\t}\n\t\t}\n//\t\tmemset(go, 0, sizeof(go));\n//\t\tmemset(ba, 0, sizeof(ba));\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nint mx;\nint d[3000];\nint n;\nint done[3000] = {};\nint ok[3000] = {};\nint can(int x){\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\tif( x == n - 1 ) return 1;\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tt = min(t,n-1);\n\t\tif( can(t) ) return 1;\n\t}\n\treturn 0;\n}\nint dfs(int x){\n\tif( !ok[x] ) return 1;\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\t\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tt = min(t,n-1);\n\t\tif( dfs(t) ) return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> mx && mx){\n\t\tfor(int i = 0 ; i < 300 ; i++) d[i] = 0;\n\t\tcin >> n;\n\t\tn += 2;\n\t\tfor(int i = 1 ; i < n - 1 ; i++)\n\t\t\tcin >> d[i];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\t\tok[i] = can(i);\n\t\t}\n\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\tcout << (dfs(0)?\"NG\":\"OK\") << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define N 250\n#define CLAMP(X,A,B) \\\n  max ( 0, min ( (X), (B) ) )\n\nstatic int d[ N + 2 ];\nstatic int n;\nstatic int m;\n\nstatic int\ndp (\n  int *r,\n  int  b\n  )\n{\n  queue<int> lis;\n  int i;\n\n  fill ( r, r + n + 2, 0 );\n  lis.push ( b );\n  while ( !lis.empty ( ) )\n  {\n    const int t = lis.front ( );\n    lis.pop ( );\n\n    if ( r[ t ] ) continue ;\n    r[ t ] = 1;\n\n    for ( i = 1; i <= m; ++i )\n      lis.push ( CLAMP( d[ CLAMP( t + i, 0, n + 1 ) ], 0, n + 1 ) );\n  }\n\n  return ( r[ n + 1 ] );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int v[ N + 2 ];\n\n    scanf ( \"%d\", &m );\n    if ( m == 0 ) break ;\n    scanf ( \"%d\", &n );\n    for ( i = 1; i <= n; ++i )\n      scanf ( \"%d\", &d[ i ] );\n    d[ 0 ] = d[ n + 1 ] = 0;\n    for ( i = 1; i <= n + 1; ++i )\n      d[ i ] = i + d[ i ];\n\n    dp ( v, 0 );\n    for ( i = 0; i <= n + 1; ++i )\n    {\n      int t[ N + 2 ];\n\n      if ( !v[ i ] ) continue ;\n      if ( !dp ( t, i ) ) break ;\n    }\n    if ( i > n + 1 )\n      puts ( \"OK\" );\n    else\n      puts ( \"NG\" );\n  }\n\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dice;\nint n;\nvector<int> a;\nvector<bool> memo;\n\nbool solve(int curr)\n{\n    if(curr == n-1)\n        return true;\n\n    if(memo[curr])\n        return false;\n    memo[curr] = true;\n\n    for(int i=1; i<=dice; ++i){\n        int next = min(n-1, curr + i);\n        next = max(0, min(n-1, next + a[next]));\n        if(solve(next))\n            return true;\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        cin >> dice >> n;\n        if(dice == 0)\n            return 0;\n\n        a.assign(n+2, 0);\n        for(int i=1; i<=n; ++i)\n            cin >> a[i];\n        n += 2;\n\n        vector<bool> access(n, false);\n        access[0] = true;\n        queue<int> q;\n        q.push(0);\n        while(!q.empty()){\n            int curr = q.front();\n            q.pop();\n            for(int i=1; i<=dice; ++i){\n                int next = min(n-1, curr + i);\n                next = max(0, min(n-1, next + a[next]));\n                if(!access[next]){\n                    access[next] = true;\n                    q.push(next);\n                }\n            }\n        }\n\n        bool ok = true;\n        for(int i=0; i<n; ++i){\n            memo.assign(n, false);\n            if(access[i] && !solve(i))\n                ok = false;\n        }\n\n        if(ok)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 300\n\nint main()\n{\n    int mx, n;\n    while (cin >> mx, mx) {\n        cin >> n;\n        vector<int> v(n+2, 0);\n        for (int i = 1; i <= n; i++) {\n            cin >> v[i];\n        }\n        bool visited[MAX] = {0};\n        visited[0] = 1;\n        queue<int> Q;\n        Q.push(0);\n\n        while (!Q.empty()) {\n            int now = Q.front(); Q.pop();\n            if (now == n+1) {\n                continue;\n            }\n\n            for (int i = 1; i <= mx; i++) {\n                int next = min(n+1, now+i);\n                next += v[next];\n                if (next < 0) {\n                    next = 0;\n                } else if (next > n+1) {\n                    next = n+1;\n                }\n                if (!visited[next]) {\n                    visited[next] = 1;\n                    Q.push(next);\n                }\n            }\n        }\n        bool reachable = 1;\n        for (int i = 0; i <= n; i++) {\n            if (!visited[i]) {              \n                continue;\n            }\n            bool ng = 1, visited2[MAX] = {0};\n            queue<int> Q2; Q2.push(i);\n            visited2[i] = 1;\n            while (!Q2.empty()) {\n                int now = Q2.front(); Q2.pop();\n                if (now == n+1) {\n                    ng = 0;\n                    break;\n                }\n                for (int i = 1; i <= mx; i++) {\n                    int next = min(n+1, now+i);\n                    next += v[next];\n                    if (next < 0) {\n                        next = 0;\n                    } else if (next > n+1) {\n                        next = n+1;\n                    }\n                    if (!visited2[next]) {\n                        visited2[next] = 1;\n                        Q2.push(next);\n                    }\n                }\n            }\n            if (ng) {\n                reachable = 0;\n                break;\n            }\n        }\n        cout << (reachable && visited[n+1] ? \"OK\" : \"NG\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <functional>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set>\n\nint rmax, n;\nint d[260];\nstd::vector<std::set<int> > edges, edges2;\n\n/*\n0: テゥツ卍催」ツつ甘・ツ?コテ」ツ??\n1~n: テ」ツδ榲」ツつケ\nn + 1: テ、ツクツ甘」ツ?古」ツつ?\n*/\n\nint check(int idx) {\n    idx += d[idx];\n    if(idx <= 0) {\n        return 0;\n    }\n\n    if(idx >= n + 1) {\n        return n + 1;\n    }\n\n    return idx;\n}\n\nint main() {\n    while(std::cin >> rmax, rmax) {\n        std::cin >> n;\n\n        edges.clear();\n        edges.resize(n + 2);\n        edges2.clear();\n        edges2.resize(n + 2);\n\n        for(int i = 1; i <= n; ++i) {\n            std::cin >> d[i];\n        }\n        for(int i = 0; i <= n; ++i) {\n            for(int j = 1; j <= rmax; ++j) {\n                int to = check(i + j);\n\n                if(i == to) {\n                    continue;\n                }\n                edges[to].insert(i);\n                edges2[i].insert(to);\n            }\n        }\n\n        /*for(int i = 0; i < edges.size(); ++i) {\n            for(std::set<int>::iterator it = edges[i].begin(); it != edges[i].end(); ++it) {\n                std::cout << i << \" \" <<  *it << std::endl;\n            }\n        }*/\n\n        bool used[260] = {}, used2[260] = {};\n        std::queue<int> que;\n        {\n            que.push(n + 1);\n            used[n + 1] = true;\n            while(!que.empty()) {\n                int p = que.front(); que.pop();\n\n                for(std::set<int>::iterator it = edges[p].begin(); it != edges[p].end(); ++it) {\n                    if(!used[*it]) {\n                        que.push(*it);\n                        used[*it] = true;\n                    }\n                }\n            }\n        }\n\n        {\n            que.push(0);\n            used2[0] = true;\n            while(!que.empty()) {\n                int p = que.front(); que.pop();\n\n                for(std::set<int>::iterator it = edges2[p].begin(); it != edges2[p].end(); ++it) {\n                    if(!used2[*it]) {\n                        que.push(*it);\n                        used2[*it] = true;\n                    }\n                }\n            }\n        }\n\n        bool ok = true;\n        for(int i = 0; i <= n + 1; ++i) {\n            //std::cout << i << \" \" << used2[i] << \" \" << used[i] << std::endl;\n            if(used2[i] && !used[i]) {\n                ok = false;\n                break;\n            }\n        }\n\n        std::cout << (ok ? \"OK\" : \"NG\") << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint m,n;\nint mass[252]={};\nbool DP[252]={};\nint seach(vector<int> walked,int now){\n\t\n\tnow=max(0,min(now,n+1));\n\tif(DP[now])\n\treturn DP[now];\n\tif(now>n){\n\t\tDP[now]=1;\n\t\treturn 1;\n\t}\n\tfor(int i=0;i<walked.size();i++){\n\t\tif(now==walked[i])\n\t\treturn -i-1;\n\t}\n\twalked.push_back(now);\n\tint maxer=-9999;\n\tfor(int i=1;i<=m;i++){\n\t\tint first=now+i;\n\t\tint second=first+mass[first];\n\t\tmaxer=max(maxer,seach(walked,second));\n\t}\n\tif(walked.size()==-maxer){\n\tDP[now]=2;\t\n\tmaxer=2;\n\t}\n\treturn maxer;\n\t\n}\n\nint main() {\n\t// your code goes here\n\tvector<int> a;\n\twhile(cin >> m){\n\tif(m==0)\n\t\tbreak;\n\tcin >> n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> mass[i];\n\t}\n\tfor(int i=0;i<252;i++)\n\tDP[i]=0;\n\tif(seach(a,0)==1)\n\t\tcout << \"OK\" << endl;\n\telse\n\t\tcout << \"NG\" << endl;\n\t\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint n,m;\nint start,end;\nvector<int> v,p;\nvector<bool> flag,used;\nbool ans;\n\nvoid init(int now)\n{\n\trep(i,end+1)\n\t{\n\t\tint next = i + v[i];\n\t\tif(now == next || (now == end && now < next))\n\t\t{\n\t\t\tREP(j,1,m+1)\n\t\t\t{\n\t\t\t\tif(0 <= i-j && !flag[i-j])\n\t\t\t\t{\n\t\t\t\t\tflag[i-j] = true;\n\t\t\t\t\tinit(i-j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\nvoid dfs(int now)\n{\n\tif(!flag[now]) \n\t{\n\t\tans = false;\n\t}\n\n\tREP(j,1,m+1)\n\t{\n\t\tif(now + j <= end)\n\t\t{\n\t\t\tint next = now + j + v[now + j];\n\t\t\tif(next < 0) next = 0;\n\t\t\tif(next > end) next = end;\n\n\t\t\tif(used[next]) continue;\n\t\t\tused[next] = true;\n\t\t\tdfs(next);\n\t\t}\n\t}\n\n\treturn;\n}\n\nint main()\n{\n\twhile(cin >> m && m)\n\t{\n\t\tp.clear();\n\t\tp.resize(m);\n\t\trep(i,m) p[i] = i+1;\n\n\t\tcin >> n;\n\n\t\tv.clear();\n\t\tv.resize(n+2);\n\t\t\n\t\tv[0] = 0;\n\t\tstart = 0;\n\n\t\tREP(i,1,n+1) cin >> v[i];\n\n\t\tv[n+1] = 0;\n\t\tend = n+1;\n\t\n\t\tans = true;\n\n\t\tused.clear();\n\t\tused.resize(n+2);\n\t\trep(i,n+2) used[i] = false;\n\t\tused[0] = true;\n\n\t\tflag.clear();\n\t\tflag.resize(n+2);\n\t\trep(i,n+2) flag[i] = false;\n\n\t\tflag[end] = true;\n\t\tinit(end);\n\t\tdfs(0);\n\n\t\tif(ans) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\nint m,n;\nint d[500];\nint dp[500][500];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&m);\n\t\tif(m==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d\",&d[i]);\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(d[i+j]==0)dp[i][i+j]=1;\n\t\t\t\tif(d[i+j]>=1)dp[i][min(i+j+d[i+j],n+1)]=1;\n\t\t\t\tif(d[i+j]<=-1)dp[i][max(0,i+j+d[i+j])]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<=n+1;k++){\n\t\t\tfor(int i=0;i<=n+1;i++){\n\t\t\t\tfor(int j=0;j<=n+1;j++){\n\t\t\t\t\tif(dp[i][k]==1 && dp[k][j]==1)dp[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=true;\n\t\t/*\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tfor(int j=0;j<=n+1;j++)printf(\"%d%c\",dp[i][j],j==n+1?'\\n':' ');\n\t\t}\n\t\t*/\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(dp[0][i]==1 && dp[i][n+1]==0)f=false;\n\t\t}\n\t\tif(f)puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint n,dmax;\nint m[300];\nbool visited[300], isVisit[300], goal[300], isGoal;\nbool dfs(int p){\n  if(visited[p])return goal[p];\n  visited[p] = true;\n  if(p == n+1){\n    return true;\n  }\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;  \n    goal[p] = (dfs(np)||goal[p]);\n  }\n  return goal[p];\n}\nvoid solve(){\n  memset(visited, 0, sizeof(visited));\n  memset(goal, 0, sizeof(goal));\n  for(int i = 0 ; i <= n; i++){\n    if(visited[i])continue;\n    goal[i] = dfs(i);\n    if(!goal[i]){\n      cout << \"NG\" << endl;\n      return ;\n    }\n  }\n  cout << \"OK\" << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    m[0] = 0;\n    int i;\n    for(i = 1 ; i < n+1 ;i++){\n      cin >> m[i];\n    }\n    m[i] = 0;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MN = 400;\n\nint main() {\n    while(1) {\n        int m, n;\n        int d[MN] = {};\n        bool used[MN][2] = {};\n        vector<int> rd[MN];\n\n        cin >> m;\n        if (!m) break;\n        cin >> n; n += 2;\n        for (int i = 1; i < n-1; i++) {\n            cin >> d[i];\n            d[i] += i;\n            d[i] = max(d[i], 0);\n            d[i] = min(d[i], n-1);\n            rd[d[i]].push_back(i);\n        }\n        rd[0].push_back(0);\n        d[n-1] = n-1;\n        rd[n-1].push_back(n-1);\n        queue<P> q;\n        q.push(P(n-1, 0));\n        q.push(P(n-1, 1));\n        while (!q.empty()) {\n            P p = q.front(); q.pop();\n            int u, f;\n            tie(u, f) = p;\n            if (used[u][f]) continue;\n            //cout << u << endl;\n            used[u][f] = true;\n            if (!f) {\n                for (int i = max(0, u-m); i < u; i++) {\n                    q.push(P(i, 1));\n                }                \n            } else {\n                for (int i: rd[u]) {\n                    q.push(P(i, 0));\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            //printf(\"%d %d %d\\n\", i, used[i][0], used[i][1]);\n        }\n        bool f = true;\n        for (int i = 1; i <= min(n-1, m); i++) {\n            if (!used[i][0]) {\n                //cout << i << endl;\n                f = false;\n            }\n        }\n        if (f) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 650\n\nvoid calc(int m){\n  int n;\n  int d[SIZE];\n  \n  scanf(\"%d\",&n);\n\n  d[0] = 0;\n  d[n+1] = 0;\n  for(int i=1;i<=n;i++){\n    scanf(\"%d\",d+i);\n  }\n\n  queue<int> q;\n  q.push(0);\n  bool can_visit[SIZE] = {};\n  can_visit[0] = true;\n\n  \n  while(q.size()){\n    bool flag = false;\n    int st = q.front();\n    int visited[SIZE] = {};\n    q.pop();\n    \n    queue<int> q2;\n    q2.push(st);\n\n    while(q2.size()){\n      int now = q2.front();\n      q2.pop();\n\n      if(visited[now]) continue;\n\n      if(now == n+1){\n        flag = true;\n        break;\n      }\n\n      visited[now] = true;\n\n      if(can_visit[now] == false){\n        can_visit[now] = true;\n        q.push(now);\n      }\n\n      for(int i=1;i<=m;i++){\n        int next = min(n+1,now+i);\n\n        if(d[next] < 0){\n          next = max(0,next + d[next]);\n        }else{\n          next = min(n+1,next + d[next]);\n        }\n        \n        q2.push(next);\n      }\n    }\n\n    if(flag == false){\n      puts(\"NG\");\n      return;\n    }\n  }\n\n  puts(\"OK\");\n}\n  \n\nint main(){\n  int m;\n\n  while(scanf(\"%d\",&m)!=EOF){\n    if(m==0) break;\n    calc(m);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int> >G(252),R(252);\nint n,m;\nint d[252];\nbool u[252];\nvoid f(int v)\n{\n\tu[v]=1;\n\tfor(int i=0;i<R[v].size();i++)\n\t{\n\t\tif(!u[R[v][i]])f(R[v][i]);\n\t}\n}\nbool vi[252];\nvoid ok(int v)\n{\n    vi[v]=1;\n    for(int i=0;i<G[v].size();i++)\n    {\n        if(!vi[G[v][i]])ok(G[v][i]);\n    }\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<=n+1;i++)G[i].clear(),R[i].clear(),vi[i]=u[i]=0;\n\t\tfor(int i=1;i<=n;i++)cin>>d[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m&&i+j<=n+1;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+d[i+j];\n\t\t\t\tif(k>n+1)k=n+1;\n\t\t\t\tif(k<0)k=0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n+1);ok(0);\n\t\tbool flag=1;\n\t\tfor(int i=0;i<=n+1;i++)if(vi[i]&&!u[i])flag=0;\n\t\tcout<<(flag?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint t[255],f[255],g[255],n,m;\nint hantei(int x,int d) {\n\tint i,j,c,a;\n\tfor (i=0;i<=n+1;i++) f[i]=0; f[x]=1; c=1;\n\twhile(c==1) {\n\tc=0;\t\n\tfor (i=0;i<=n && c<2;i++) {\n\t\tif (f[i]==1) {\n\t\t\tfor (j=i+1;j<=i+m;j++) {\n\t\t\t\ta=j+t[j];\n\t\t\t\tif (a<0) a=0; if (a>n+1) a=n+1;\n\t\t\t\tif (d==1 && a==n+1) return 2;\n\t\t\t\tif (f[a]==0) { f[a]=1; c=1;}\n\t\t\t}\n\t\t\tf[i]=2;\n\t\t}\n\t  }\n  }\n  return 0;\t\n  }\nint main() {\nint i,c;\n while(cin >> m && m!=0) {\n\t cin >> n;\n\t for (i=1;i<=n;i++) cin >> t[i];\n\t c=hantei(0,0); c=0;\n\t for (i=0;i<=n;i++)  if (f[i]>0) {c=hantei(i,1); if (c==2) break;}\n\t if (c==0) cout << \"NG\"; else cout << \"OK\";\n\t cout << endl;\n\t} \t\t\t   \n return 0;\n } \n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint rlet;\nint n;\nint d[255];\nvector<int> vec[255],rvec[255];\nbool vis[255],rvis[255];\n\nvoid dfs(int now){\n  vis[now]=true;\n  for(int i=0;i<vec[now].size();i++){\n    if(!vis[vec[now][i]])dfs(vec[now][i]);\n  }\n}  \nvoid rdfs(int now){\n  rvis[now]=true;\n  for(int i=0;i<rvec[now].size();i++){\n    if(!rvis[rvec[now][i]])rdfs(rvec[now][i]);\n  }\n}\n\nint main(){\n\n  while(1){\n    memset(vis,false,sizeof(vis));\n    memset(rvis,false,sizeof(rvis));\n    cin>>rlet;\n    if(!rlet)break;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n      cin>>d[i];\n    }\n    \n    for(int i=0;i<=n+1;i++){\n       vec[i].clear();\n       rvec[i].clear();\n    }\n    /*グラフ化*/\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=rlet;j++){\n\tvec[i].push_back(min(max(i+j+d[i+j],0),n+1));\n\trvec[min(max(i+j+d[i+j],0),n+1)].push_back(i);\n      }\n    }\n    \n    dfs(0);\n    rdfs(n+1);\n \n    bool ok=true;\n    for(int i=0;i<=n;i++){\n      if(vis[i]&&!rvis[i])ok=false;\n    }\n\n    if(ok)cout<<\"OK\"<<\"\\n\";\n    else cout<<\"NG\"<<\"\\n\";\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\nint ma;\nint n;\nint d[250];\n\nint main()\n{\n\twhile( scanf( \"%d\", &ma ), ma )\n\t{\n\t\tscanf( \"%d\", &n );\n\n\t\tstd::vector<int> v;\n\t\tv.push_back( 0 );\n\t\trep( i, n )\n\t\t{\n\t\t\tscanf( \"%d\", d+i );\n\t\t\tif( i && i != n-1 && !d[i] )\n\t\t\t\tv.push_back( i );\n\t\t}\n\n\t\tbool f = false;\n\t\trep( i, v.size() )\n\t\t{\n\t\t\tbool fl = true;\n\t\t\tfor( int j = 0; j < ma && v[i]+j+1 < n; ++j )\n\t\t\t\tfl &= v[i] ? -d[v[i]+j+1] == j+1 : -d[v[i]+j+1] >= j+1;\n\n\t\t\tif( fl )\n\t\t\t{\n\t\t\t\tputs(\"NG\");\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( f )\n\t\t\tcontinue;\n\n\t\tputs(\"OK\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, M;\nint D[300];\nint dist[300];\nvector<int> G[300], R[300];\nvector<int> G2[300];\nbool used[300];\nint ord[300];\n\nvector<int> vs;\nvoid dfs(int x) {\n  if (used[x]) return;\n  used[x] = true;\n  for (int t : G[x]) dfs(t);\n  vs.pb(x);\n}\nvoid rdfs(int x, int k) {\n  if (used[x]) return;\n  used[x] = true;\n  ord[x] = k;\n  for (int t : R[x]) rdfs(t, k);\n}\n\nint scc() {\n  vs.clear();\n  rep(i, N) used[i] = false;\n  rep(i, N) dfs(i);\n  rep(i, N) used[i] = false;\n  int k = 0;\n  for (int i=vs.size()-1; i>=0; i--) {\n    if (!used[vs[i]]) rdfs(vs[i], k++);\n  }\n  return k;\n}\nvoid dfs2(int x) {\n  if (used[x]) return;\n  used[x] = true;\n  for (int t : G2[x]) dfs2(t);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> M) {\n    if (M == 0) break;\n    cin >> N;\n    N+=2;\n    D[0] = 0;\n    rep(i, N-2) cin >> D[i+1];\n    D[N-1] = 0;\n    bool ng = false;\n    rep(i, N) G[i].clear(), R[i].clear();\n    rep(i, N-1) {\n      for (int k=1; k<=M; k++) {\n        int t = i+k;\n        if (t > N) t = N;\n        if (t < 0) t = 0;\n        t += D[t];\n        if (t > N) t = N;\n        if (t < 0) t = 0;\n        if (i == t) continue;\n        G[i].pb(t);\n        R[t].pb(i);\n      }\n    }\n    int K = scc();\n    rep(i, K) G2[i].clear();\n    rep(i, N) {\n      for (int t : G[i]) {\n        if (ord[i] == ord[t]) continue;\n        G2[ord[i]].pb(ord[t]);\n      }\n    }\n    rep(i, K) {\n      sort(all(G2[i])); uniq(G2[i]);\n    }\n    rep(i, N) used[i] = false;\n    dfs2(ord[0]);\n    rep(i, K) {\n      if (i == ord[N-1]) continue;\n      if (used[i] && G2[i].empty()) ng = true;\n    }\n    if (!ng) cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int max,n,data[255];\n  bool MAS[255][255];\n  while(1){\n    memset(MAS,false,sizeof(MAS));\n    cin >> max;\n    if(max==0)break;\n    cin >> n;\n    for(int i=1;i<=n;i++) cin >> data[i];\n    for(int j=0;j<=n;j++){\n      for(int i=1;i<=max && j+i<n+2;i++){\n\tj+i+data[i]>n+1 ? MAS[j][n+1]=true : MAS[j][j+i+data[i+j]]=true;\n      }\n    }\n\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n\tfor(int k=0;k<n+2;k++){\n\t  if(MAS[j][i]&&MAS[i][k]){\n\t    MAS[j][k]=true;\n\t  }\n\t}\n      }\n    }\n    bool flg=false;\n    for(int i=0;i<=n;i++){\n      if(MAS[0][i]&&(!MAS[i][n+1])){\n\tflg=true;\n\tbreak;\n      }\n    }\n    cout << (flg?\"NG\":\"OK\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int> >G(252),R(252);\nint n,m;\nint d[552];\nbool u[252];\nvoid f(int v)\n{\n\tu[v]=1;\n\tfor(int i=0;i<R[v].size();i++)\n\t{\n\t\tif(!u[R[v][i]])f(R[v][i]);\n\t}\n}\nbool vi[252];\nbool ok(int v)\n{\n    bool ans=u[v];\n    vi[v]=1;\n    for(int i=0;i<G[v].size();i++)\n    {\n        if(!vi[G[v][i]])ans&=ok(G[v][i]);\n    }\n    return ans;\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<=n+1;i++)G[i].clear(),R[i].clear(),d[i]=vi[i]=u[i]=0;\n\t\tfor(int i=1;i<=n;i++)cin>>d[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m&&i+j<=n+1;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+d[i+j];\n\t\t\t\tif(k>n+1)k=n+1;\n\t\t\t\tif(k<0)k=0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n+1);\n\t\tcout<<(ok(0)?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint t[255],f[255],g[255],n,m;\nint hantei(int x,int d) {\n\tint i,j,c,a;\n\tfor (i=0;i<=n+1;i++) f[i]=0; f[x]=1; c=1;\n\twhile(c==1) {\n\tc=0;\t\n\tfor (i=0;i<=n;i++) {\n\t\tif (f[i]==1) {\n\t\t\tfor (j=i+1;j<=i+m;j++) {\n\t\t\t\ta=j+t[j];\n\t\t\t\tif (a<0) a=0; if (a>n+1) a=n+1;\n\t\t\t\tif (d==1 && a==n+1) return 2;\n\t\t\t\tif (f[a]==0) { f[a]=1; c=1;}\n\t\t\t}\n\t\t\tf[i]=2;\n\t\t}\n\t  }\n  }\n  return 0;\t\n  }\nint main() {\nint i,c;\n while(cin >> m && m!=0) {\n\t cin >> n;\n\t for (i=1;i<=n;i++) cin >> t[i];\n\t c=hantei(0,0);\n\t for (i=0;i<=n;i++) g[i]=f[i];\n\t for (i=0;i<=n;i++) if (g[i]>0) {c=hantei(i,1); if (c==0) break;}\n\t if (c==0) cout << \"NG\"; else cout << \"OK\";\n\t cout << endl;\n\t} \t\t\t   \n return 0;\n } "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint M, n, d[252];\nint visited[252];\n\nbool rec(int start) {\n    bool ok = false;\n    if(start<0) return false;\n    if(n+1<=start) return true;\n    if(visited[start]) return visited[start]>1;\n    visited[start] = 1;\n    for(int i=1; i<=M; i++) {\n        ok |= rec(start + i + d[start+i]);\n    }\n    if(ok) visited[start]++;\n    return ok;\n}\n\nint main()\n{\n    while(cin>>M, M) {\n        cin>>n;\n        visited[0] = 0;\n        for(int i=1; i<=n; i++) {\n            cin>>d[i];\n            visited[i] = 0;\n        }\n        rec(0);\n        bool ok = true;\n        for(int i=0; i<=n; i++) {\n            if(!visited[i]) continue;\n            if(visited[i]==1) ok = false;\n        }\n        if(ok) cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\n\nint main(){\n\tint m,n,d[511];\n\tbool b[255];\n\tfor(;;){\n\t\tscanf(\"%d\",&m);\n\t\tif(!m)break;\n\t\tscanf(\"%d\",&n);\n\t\trep(i,511)d[i]=0;\n\t\trep(i,255)b[i]=0;\n\t\trep(i,n)scanf(\"%d\",d+i+1);\n\t\tint f=1;\n\t\twhile(f){\n\t\t\tf=0;\n\t\t\tfor(int i=n;i>=0;i--){\n\t\t\t\treps(j,1,m){\n\t\t\t\t\tint c=d[i+j]+i+j;\n\t\t\t\t\tif(!b[i])if(c>n || (in(c,0,n) && b[c])){\n\t\t\t\t\t\tb[i]=1;\n\t\t\t\t\t\tf=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf=1;\n\t\trep(i,n+1)if(f &&(i==0 || b[i]))reps(j,1,m){\n\t\t\tint c=d[i+j]+i+j;\n\t\t\tif(c<=n && in(c,0,n) && !b[c]){\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tputs(f?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q1,q2;\n    q1.push(0);\n    bool c=true;\n    while(!q1.empty()){\n      b=q1.front();q1.pop();\n      if(r[b]) continue;\n      r[b]=true;\n      q2.push(b);\n      fill(used,used+300,false);\n      while(!q2.empty()){\n\tp=q2.front();q2.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(used[p]) continue;\n\tused[p]=true;\n\tq1.push(p);\n\tfor(i=1;i<=m;i++){\n\t  if(p+i+d[p+i]>n+1){\n\t    used[n+1]=true;\n\t    break;\n\t  }else q2.push(p+i+d[p+i]);\n\t}\n      }\n      if(!used[n+1]){\n\tc=false;\n\tbreak;\n      }\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <vector>\nint main(){\n  int m,n;\n  while(true){\n    cin >> m;\n    if(m == 0)break;\n    cin >> n;\n    vector<int> d(n*2);\n    vector<vector<int> >p(n*3,vector<int>(n*3,0));\n    for(int i = 0; i < 2*n; i++)d[i] = 0;\n    for(int i = 1; i <= n; i++)cin >> d[i];\n    \n    for(int i = 0; i <= n; i++){\n      for(int j = 1; j <= m; j++){\n\tint pp= i+j+d[i+j];\n\tif(pp < 0)pp = 0;\n\tif(pp > n+1)pp = n+1;\n\tp[i][pp] = 1;\n      }\n    }\n    \n \n    for(int j = 0; j <= n+1; j++){\n      for(int i = 0; i <= n+1; i++){\n\tfor(int k = 0; k <= n+1; k++){\n\t  if(p[j][i]&&p[i][k]) p[j][k] = 1;\n\t}\n      }\n    }\n\n      \n    int ans = true;\n    for(int i = 0;i < n+1; i++){\n      if(p[0][i]==1&&p[i][n+1] == 0)ans = false;\n    }\n    if(ans)cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define repi(i,a,b) for( int i = (a); i != (b); ++i )\n\nint ma, n;\nint d[260];\nbool dp[260][260];\n\nint main()\n{\n\twhile( scanf( \"%d\", &ma ), ma )\n\t{\n\t\tscanf( \"%d\", &n );\n\t\tmemset( dp, false, sizeof( dp ) );\n\t\trepi( i, 1, n+1 )\n\t\t\tscanf( \"%d\", d+i );\n\t\td[0] = d[n+1] = 0;\n\n\t\trep( i, n+1 )\n\t\t{\n\t\t\trepi( j, 1, ma+1 )\n\t\t\t{\n\t\t\t\tif( i+j > n+1 )\n\t\t\t\t\tbreak;\n\t\t\t\tdp[i][std::max( std::min( i+j+d[i+j], n+1 ), 0 )] = true;\n\t\t\t}\n\t\t}\n\n\t\trep( k, n+2 )\n\t\t\trep( i, n+2 )\n\t\t\t\trep( j, n+2 )\n\t\t\t\t\tif( dp[i][k] && dp[k][j] )\n\t\t\t\t\t\tdp[i][j] = true;\n\n\t\tbool fl = true;\n\t\trep( i, n+1 )\n\t\t\tif( dp[0][i] && !dp[i][n+1] )\n\t\t\t\tfl = false;\n\t\t\n\t\tputs( fl ? \"OK\" : \"NG\" );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int mx; cin >> mx && mx;) {\n\t\tint n;\n\t\tcin >> n;\n\t\t++n;\n\n\t\tvector<int> d(n);\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tcin >> d[i];\n\t\t}\n\n\t\tqueue<int> que;\n\t\tvector<bool> visited(n, false);\n\n\t\tque.push(0);\n\t\tvisited[0] = true;\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int pos = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor(int i = 1; i <= mx; ++i) {\n\t\t\t\tif(pos + i >= n) break;\n\t\t\t\tconst int to = pos + i + d[pos + i];\n\t\t\t\tif(to <= 0) continue;\n\t\t\t\tif(!visited[to]) {\n\t\t\t\t\tvisited[to] = true;\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = true;\n\t\tfor(int pos = 0; pos < n; ++pos) {\n\t\t\tif(!visited[pos]) continue;\n\n\t\t\tfor(int i = 1; i <= mx; ++i) {\n\t\t\t\tif(pos + i >= n) goto next;\n\t\t\t\tconst int to = pos + i + d[pos + i];\n\t\t\t\tif(to > pos) goto next;\n\t\t\t}\n\n\t\t\tok = false;\n\t\t\tbreak;\n\n\t\tnext:;\n\t\t}\n\n\t\tcout << (ok ? \"OK\" : \"NG\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nint ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\tif (ka[y][x] == 1)break;\n\t\t\t\tka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\tfor (int j = 0; j<300; j++)\n\t\t\t{\n\t\t\t\tka[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n/*\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\t*/\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint M, N, D[255];\nvector < int > G[255];\nbool visited[255];\nbool vim[255];\n\nvoid visit(int v)\n{\n    if ( !visited[v] ) {\n        visited[v] = true;\n        for ( auto &x : G[v] ) {\n            visit(x);\n        }\n    }\n}\n\n\nbool dfs(int v)\n{\n    bool ret = false;\n    if ( !vim[v] ) {\n        vim[v] = true;\n        if ( v == N + 1 ) return ( true );\n        for ( auto &x : G[v] ) {\n            ret |= dfs(x);\n        }\n    }\n    return (ret);\n}\n\nint main()\n{\n\n    while ( cin >> M, M ) {\n        cin >> N;\n        fill_n(visited, 255, false);\n        for ( int i = 0; i < 255; i++ ) {\n            while ( !G[i].empty() ) {\n                G[i].pop_back();\n            }\n        }\n\n        for ( int i = 1; i <= N; i++ ) {\n            cin >> D[i];\n        }\n        D[0] = 0, D[N + 1] = 0;\n\n        for ( int i = 0; i <= N + 1; i++ ) {\n            for ( int j = 1; j <= M; j++ ) {\n                if ( i + j >= N + 1 ) {\n                    G[i].push_back(N + 1);\n                } else {\n                    G[i].push_back(max(0, i + j + D[i + j]));\n                }\n            }\n        }\n\n        visit(0);\n\n        bool possible = true;\n        for ( int i = 0; i <= N + 1; i++ ) {\n            if ( visited[i] ) {\n                fill_n(vim, 255, false);\n                possible &= dfs(i);\n            }\n        }\n\n        if ( possible ) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NG\" << endl;\n        }\n    }\n\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nint mx;\nint d[3000];\nint n;\nint done[3000] = {};\nint ok[3000] = {};\nint can(int x){\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\tif( x == n - 1 ) return 1;\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( can(t) ) return 1;\n\t}\n\treturn 0;\n}\nint dfs(int x){\n\tif( !ok[x] ) return 1;\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\t\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( dfs(t) ) return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> mx && mx){\n\t\tfor(int i = 0 ; i < 300 ; i++) d[i] = 0;\n\t\tfor(int i = 0 ; i < 300 ; i++) ok[i] = 0;\n\t\tcin >> n;\n\t\tn += 2;\n\t\tok[n-1] = 1;\n\t\tok[0] = 1;\n\t\tfor(int i = 1 ; i < n - 1 ; i++)\n\t\t\tcin >> d[i];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\t\tok[i] = can(i);\n\t\t}\n\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\tcout << (dfs(0)?\"NG\":\"OK\") << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n;\nvector<int> G[252];\nbool used[252],flag = true;\n\nbool dfs(int v){\n\tif(v == n + 1) return true;\n\tif(used[v]) return false;\n\tbool f = false;\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tif(dfs(G[v][i])) f = true;\n\t}\n\tif(!f) flag = false;\n\tused[v] = false;\n\treturn f;\n}\n\nint main(){\n\tint ma;\n\twhile(cin >> ma,ma){\n\t\tflag = true;\n\t\tfor(int i = 0;i < 252;i++) {\n\t\t\tG[i].clear();\n\t\t\tused[i] = false;\n\t\t}\n\t\tint d[252] = {};\n\t\tcin >> n;\n\t\tfor(int i = 0;i < n;i++) cin >> d[i + 1];\n\t\tfor(int i = 0;i < n + 1;i++){\n\t\t\tfor(int j = 1;j <= ma;j++){\n\t\t\t\tif(i + j >= n + 2) break;\n\t\t\t\tG[i].push_back(min(n + 1,max(0,i + j + d[i + j])));\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tif(flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nint main(){\n\n  int n, m, d[255];\n  bool dp[255];\n  while(cin >> m, m){\n    cin >> n;\n    d[0] = 0;\n    for(int i = 1; i <= n; i++)\n      cin >> d[i];\n    \n    memset(dp, false, sizeof(dp));\n    dp[0] = true;\n    for(int i = 0; i < n; i++){\n      for(int j = 1; j <= m; j++){\n        if(dp[i]){\n          dp[max(min(i + j + d[max(min(i + j, n), 0)], n), 0)] = true;\n        }\n      }\n    }\n    \n    cout << (dp[n] ? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n;\nvector<int> G[252];\nbool used[252],flag = true;\n\nbool dfs(int v){\n\tif(v == n + 1) return true;\n\tif(used[v]) return false;\n\tbool f = false;\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tif(dfs(G[v][i])) f = true;\n\t}\n\tif(!f) flag = false;\n\tused[v] = false;\n\treturn f;\n}\n\nint main(){\n\tint ma;\n\twhile(cin >> ma,ma){\n\t\tfor(int i = 0;i < 252;i++) G[i].clear();\n\t\tint d[252] = {};\n\t\tcin >> n;\n\t\tfor(int i = 0;i < n;i++) cin >> d[i + 1];\n\t\tfor(int i = 0;i < n + 1;i++){\n\t\t\tfor(int j = 1;j <= ma;j++){\n\t\t\t\tif(i + j >= n + 2) break;\n\t\t\t\tG[i].push_back(min(n + 1,max(0,i + j + d[i + j])));\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tif(flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 260;\nbool come[MAX],goal[MAX];\nint M,n,d[MAX];\n\nvoid print(){\n\n  for(int i = 0; i <= n; i++) cout << come[i] << \" \";\n  cout << endl;\n  for(int i = 0; i <= n; i++) cout << goal[i] << \" \";\n  cout << endl;\n}\n\nvoid init(){\n  fill(come,come+MAX,false);\n  fill(goal,goal+MAX,false);\n  fill(d,d+MAX,0);\n}\n\nint move(int now, int num){\n  int nex = now+num;\n  if(nex > n) return -1;\n  nex += d[nex];\n  if(nex > n) return -1;\n  if(nex < 0) return 0;\n  return nex;\n}\n\nvoid make_come(){\n  come[0] = true;\n  priority_queue<int,vector<int>,greater<int> > Q;\n  Q.push(0);\n  while(!Q.empty()){\n    int now = Q.top();\n    Q.pop();\n\n    for(int i = 1; i <= M; i++){\n      int nex = move(now,i);\n      if(nex == -1) goal[now] = true;\n      else if(!come[nex] && nex <= n){\n        come[nex] = true;\n        Q.push(nex);\n      }\n    }\n  }\n}\n\nvoid make_goal(){\n  for(int i = n; i >= 0; i--){\n    if(!come[i] || goal[i]) continue;\n\n    for(int j = 1; j <= M; j++){\n      if(goal[move(i,j)]) goal[i] = true;\n    }\n  }\n}\n\n\nbool solve(){\n\n  make_come();\n  make_goal();\n\n  for(int i = 0; i <= n; i++)\n    if(come[i] && !goal[i]) return false; \n  return true;\n}\n\nint main(){\n\n  while(cin >> M && M){\n    init();\n    cin >> n;\n    for(int i = 1; i <= n; i++) cin >> d[i];\n    if(solve()) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    //print();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nint mx;\nint d[300];\nint n;\nint done[300] = {};\nint ok[300] = {};\nint can(int x){\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\tif( x == n - 1 ) return 1;\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( can(t) ) return 1;\n\t}\n\treturn 0;\n}\nint dfs(int x){\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\tif( !ok[x] ) return 1;\n\t\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( dfs(t) ) return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> mx && mx){\n\t\tfor(int i = 0 ; i < 300 ; i++) done[i] = 0;\n\t\tfor(int i = 0 ; i < 300 ; i++) d[i] = 0;\n\t\tcin >> n;\n\t\tn += 2;\n\t\tfor(int i = 1 ; i < n - 1 ; i++)\n\t\t\tcin >> d[i];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\t\tok[i] = can(i);\n\t\t}\n\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\tcout << (dfs(0)?\"NG\":\"OK\") << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define MAX_N 300\nint m,n;\nint arr[MAX_N];\nint visited[MAX_N];\nint visited2[MAX_N];\nint flag[MAX_N];\n\nvoid init();\nvoid rec(int);\nint solve(int);\n\nint main(){\n  int i,j,a,b;\n  while(1){\n    init();\n    scanf(\"%d\",&m);\n    if(m==0)break;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n      scanf(\"%d\",&a);\n      b=i+a;\n      if(b<0)b=0;\n      if(b>n+1)b=n+1;\n      arr[i]=b;\n    }\n    for(i=0;i<=n+1;i++){\n      if(arr[i]==n+1)rec(i);\n    }\n    /*\n    for(i=0;i<=n+1;i++){\n      printf(\"%d \",visited[i]);\n    }\n    printf(\"\\n\");\n    */\n    flag[n+1]=1;\n    if(solve(0))printf(\"NG\\n\");\n    else printf(\"OK\\n\");\n  }\n  return 0;\n}\n\nint solve(int pos){\n  if(visited2[pos])return 0;\n  visited2[pos]=1;\n  if(!flag[pos])return 1;\n  int i,a;\n  for(i=1;i<=m;i++){\n    a=pos+i;\n    if(a>n+1)break;\n    a=arr[a];\n    if( solve(a) )return 1;\n  }\n  return 0;\n}\n\nvoid rec(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  int i,j,a;\n  for(i=1;i<=m;i++){\n    a=pos-i;\n    if(a<0)break;\n    flag[a]=1;\n    for(j=0;j<=n+1;j++){\n      if(arr[j]==a)rec(j);\n    }\n  }\n}\n\nvoid init(){\n  int i,j;\n  for(i=0;i<MAX_N;i++){\n    arr[i]=i;\n    visited[i]=0;\n    visited2[i]=0;\n    flag[i]=0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\nint maxCount, n;\nvector<int> kouka;\nint memo[252];//251があがり0がふりだし\nint passed[252];\n\nconst int AGARI = 100000;\n\nbool dfs(int index)\n{\n\tif(passed[index]) return false;\n\tpassed[index] = true;\n\n\tindex = min(n + 1, max(0 ,kouka[index] + index));\n\tif(kouka[index] == AGARI) return true;\n\tfor (int i = 1; i <= maxCount; i++)\n\t{\n\t\tint next = index + i;\n\t\tif(memo[next])\n\t\t\tif(memo[next] = dfs(next))\n\t\t\t\treturn true;\n\t}\n\n\tpassed[index] = false;\n\treturn false;\n}\n\nbool solve()\n{\n\tfor (int i = 1; i <= maxCount; i++)\n\t{\n\t\tif(dfs(i)) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> maxCount && maxCount)\n\t{\n\t\tcin >> n;\n\t\tkouka.resize(n + 2);\n\t\tkouka[0] = -1;//ふりだし\n\t\tfor (int i = 1; i < n + 1; i++)\n\t\t{\n\t\t\tcin >> kouka[i];\n\t\t}\n\t\tkouka[n + 1] = AGARI;//あがり\n\t\tmemset(memo, true, sizeof(memo));\n\t\tmemset(passed, false, sizeof(memo));\n\t\tcout << (solve()? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\n\nint main(){\n\tint m,n,d[1024],*p;\n\tbool b[255];\n\tfor(;;){\n\t\tscanf(\"%d\",&m);\n\t\tif(!m)break;\n\t\tscanf(\"%d\",&n);\n\t\trep(i,1024)d[i]=0;\n\t\trep(i,255)b[i]=0;\n\t\tp=d+256;\n\t\trep(i,n)scanf(\"%d\",p+i+1);\n\t\tint f=1;\n\t\twhile(f){\n\t\t\tf=0;\n\t\t\tfor(int i=n;i>=0;i--){\n\t\t\t\treps(j,1,m){\n\t\t\t\t\tint c=p[i+j]+i+j;\n\t\t\t\t\tif(!b[i])if(c>n || (in(c,0,n) && b[c])){\n\t\t\t\t\t\tb[i]=1;\n\t\t\t\t\t\tf=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf=1;\n\t\trep(i,n+1)if(f &&(i==0 || p[i]))reps(j,1,m){\n\t\t\tint c=p[i+j]+i+j;\n\t\t\tif(c<=n && in(c,0,n) && !b[c]){\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tputs(f?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint m,n,d[255];\nvector<int>g[255];\nbool vis[255];\nvoid dfs(int v){\n    vis[v]=true;\n    for(int i=0;i<g[v].size();i++)if(!vis[g[v][i]])dfs(g[v][i]);\n}\nint main(void){\n    while(1){\n        cin>>m>>n;\n        if(m==0)return 0;\n        for(int i=1;i<=n;i++){\n            cin>>d[i];\n        }\n        for(int i=0;i<=n+1;i++){\n            g[i].clear();\n            vis[i]=false;\n        }\n        for(int i=0;i<=n;i++)for(int j=1;j<=m&&i+j<=n+1;j++)g[i].push_back(min(max(i+j+d[i+j],0),n+1));\n        dfs(0);\n        if(vis[n+1])cout<<\"OK\\n\";\n        else cout<<\"NG\\n\";\n        \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mas[300];\nint memo[300];\nint isGorl[300];\n\nint Max;\nint n;\n\nvoid dfs(int i){\n  if(i < 0) i = 0;\n  if(i >= n) i = n-1;\n  if(memo[i] != 0) return;\n  memo[i] = 1;\n  for(int j = 1;j <= Max;j++){\n    int tmp = i+j;\n    if(i+j < n) tmp += mas[i+j];\n    dfs(tmp);\n  }\n\n  return;\n}\n\nbool flag;\n\nvoid gorldfs(int i){\n  if(i < 0) i = 0;\n  if(i >= n) i = n-1;\n  if(memo[i] != 0) return;\n  if(isGorl[i] == 0){\n    flag = true;\n  }\n  memo[i] = 1;\n  for(int j = 1;j <= Max;j++){\n    int tmp = i+j;\n    if(tmp < n) tmp += mas[tmp];\n    gorldfs(tmp);\n  }\n\n  return;\n}\n\nint main(){\n  while(1){\n    flag = false;\n\n    cin >> Max;\n    if(Max == 0) break;\n    cin >> n;\n    for(int i = 0;i < n;i++) scanf(\"%d\",&mas[i+1]);\n    n += 2;\n\n    int i;\n    for(i = n-1;i >= 0;i--){\n      for(int x = 0;x < 300;x++) memo[x] = 0;\n      dfs(i);\n      if(memo[n-1] == 1){\n        isGorl[i] = 1;\n      }else{\n        isGorl[i] = 0;\n      }\n    }\n\n    for(int x = 0;x < 300;x++) memo[x] = 0;\n    gorldfs(0);\n    if(flag) cout << \"NG\" << endl; else cout << \"OK\" << endl;\n  }\n\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int M, N;\n    int D[255];\n\n    while ( cin >> M, M ) {\n        int memo[255][555];\n\n        cin >> N;\n        for ( int i = 1; i <= N; i++ ) {\n            cin >> D[i];\n        }\n        D[0] = 0, D[N + 1] = 0;\n\n        memset ( memo, -1, sizeof( memo ) );\n\n        function < int(int, int) > dfs = [&]( int v , int num )\n        {\n            int ret = 0;\n            if ( num > 520 ) return ( 0 );\n            if ( memo[v][num] != -1 ) return ( 0 );\n            if ( v == N + 1 ) return ( 1 );\n\n            for ( int i = 1; i <= M && v + i <= N + 1; i++ ) {\n                int place = min( N + 1, max ( v + i + D[v + i], 0 ) ) ;\n                ret |= dfs ( place , num + 1);\n            }\n            return ( memo[v][num] = ret );\n        };\n\n        dfs ( 0 , 0 );\n\n        bool flag = true;\n        for ( int i = 0; i <= N; i++ ) {\n            bool g = false, f = false;\n            for ( int j = 0; j < 520; j++ ) {\n                if ( memo[i][j] != -1 ) f = true;\n                if ( memo[i][j] == 1 ) {\n                    g = true;\n                }\n            }\n            if ( f && !g ) flag = false;\n        }\n        cout << ( flag ? \"OK\" : \"NG\" ) << endl;\n\n    }\n\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\n\n#define pb push_back\n\nint main(){\n\twhile(1){\n\t\tint max;\n\t\tint n,d[252];\n\t\tint dp[255] = {};\n\t\tscanf(\"%d\",&max); if(max == 0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i = 1 ; i <= n ; i ++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tbool t = true;\n\t\tfor(int s = 0 ; s < n+1 ; s ++){\n\t\t\tfor(int i = 0 ; i < 255 ; i ++)dp[i] = 0;\n\t\t\tdp[s] = 1;\n\t\t\tfor(int i = s ; i < n+1 ; i ++){\n\t\t\t\tif(dp[i] == 0)continue;\n\t\t\t\tfor(int j = 1 ; j <= max ; j ++){\n\t\t\t\t\tif(i+j >= n+1)dp[n+1] = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(i+j+d[i+j] >= n+1)dp[n+1] = 1;\n\t\t\t\t\t\telse if(i+j+d[i+1] >= 0)dp[i+j+d[i+j]] = 1;\n\t\t\t\t\t\telse dp[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt &= (dp[n+1] != 0);\n\t\t}\n\t\tif(t)puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint m,n;\nint a[300];\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> m;\n\t\tif(m==0)break;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++)cin >> a[i];\n\t\tbool flag=true;\n\t\tfor(int i=0;i<=n-m;i++)\n\t\t{\n\t\t\tbool p=true;\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+a[i+j];\n\t\t\t\tif(k>i)\n\t\t\t\t{\n\t\t\t\t\tp=false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p)\n\t\t\t{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tend:;\n\t\t}\n\t\tcout << \"OK\" << endl;\n\t\tnext:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <iterator>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct input {\n\tint operator()() { return *istream_iterator<int>(cin); }\n};\nint main(void){\n\tint max;\n\twhile(cin >> max && max) {\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<int> d(n);\n\t\tgenerate(d.begin(), d.end(), input());\n\n\t\tint right = max;\n\t\tfor(int left = 0; left < right && !(n < right); ++left)\tif(right < left + d[left] + max) right = left + d[left] + max;\n\t\tcout << (n < right ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main (){\n\tint max,n,i,i2,d[250],a;\n\tscanf(\"%d\",&max);\n\twhile(max!=0){\n\t\tscanf(\"%d\",&n);\n\t\ta=0;\n\t\tfor(i=0;i!=n;i++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t\tif(d[i]<0){\n\t\t\t\td[i]+=2*(d[i]*-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\td[i]+=2*(d[i]*-1);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i!=n-max+2;i++){\n\t\t\tfor(i2=1+i;i2<=max+i;i2++){\n\t\t\t\tif(d[i2]>0&&d[i2]<=max){\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(a>=max){\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\tscanf(\"%d\",&max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int M, N;\n    int D[255];\n\n    while ( cin >> M, M ) {\n        int memo[255][1555];\n\n        cin >> N;\n        for ( int i = 1; i <= N; i++ ) {\n            cin >> D[i];\n        }\n        D[0] = 0, D[N + 1] = 0;\n\n        memset ( memo, -1, sizeof( memo ) );\n\n        function < int(int, int) > dfs = [&]( int v , int num )\n        {\n            int ret = 0;\n            if ( num > 1520 ) return ( 0 );\n            if ( memo[v][num] != -1 ) return ( 0 );\n            if ( v == N + 1 ) return ( 1 );\n\n            for ( int i = 1; i <= M && v + i <= N + 1; i++ ) {\n                int place = min( N + 1, max ( v + i + D[v + i], 0 ) ) ;\n                ret |= dfs ( place , num + 1);\n            }\n            return ( memo[v][num] = ret );\n        };\n\n        dfs ( 0 , 0 );\n\n        bool flag = true;\n        for ( int i = 0; i <= N; i++ ) {\n            bool g = false, f = false;\n            for ( int j = 0; j <= 1520; j++ ) {\n                if ( memo[i][j] != -1 ) f = true;\n                if ( memo[i][j] == 1 ) {\n                    g = true;\n                }\n            }\n            if ( f && !g ) flag = false;\n        }\n        cout << ( flag ? \"OK\" : \"NG\" ) << endl;\n\n    }\n\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint m,n;\nint mass[260]={};\nbool DP[260]={};\nint seach(vector<int> walked,int now){\n\tnow=max(0,min(now,n+1));\n\tif(DP[now]!=0)\n\treturn DP[now];\n\tif(now>n){\n\t\tDP[now]=1;\n\t\treturn 1;\n\t}\n\tfor(int i=0;i<walked.size();i++){\n\t\tif(now==walked[i]){\n\t\t//DP[now]=-1;\n\t\treturn -i-1;\n\t\t}\n\t}\n\twalked.push_back(now);\n\tint maxer=-9999;\n\tfor(int i=1;i<=m;i++){\n\t\tint first=min(n+1,now+i);\n\t\tint second=first+mass[first];\n\t\tmaxer=max(maxer,seach(walked,second));\n\t}\n\tif(walked.size()==-maxer){\n\tDP[now]=2;\t\n\tmaxer=2;\n\t}\n\tif(DP[now]>0)\n\tDP[now]=maxer;\n\telse if(DP[now]<0)\n\tDP[now]=-1;\n\treturn maxer;\n\t\n}\n\nint main() {\n\t// your code goes here\n\tvector<int> a;\n\twhile(true){\n\t\tcin >> m;\n\tif(m==0)\n\t\tbreak;\n\tcin >> n;\n\t\n\tfor(int i=0;i<260;i++)\n\t\tmass[i]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> mass[i];\n\t}\n\tfor(int i=0;i<260;i++)\n\tDP[i]=0;\n\tif(seach(a,0)==1)\n\t\tcout << \"OK\" << endl;\n\telse\n\t\tcout << \"NG\" << endl;\n\t\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[N],used[N],ans;\n\nbool dfs(int x,int prev){\n  int f=0;\n  if(!prev&&d[x]){\n    int t=x+d[x];\n    if(t<0)t=0;\n    if(n+1<t)t=n+1;\n    x=t;\n    f=1;\n  }\n  if(used[x])return memo[x];\n  used[x]=true;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[x]|=dfs(nx,f);\n  }\n  if(!memo[x])ans=false;\n  return memo[x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    memset(d,0,sizeof(d));\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    used[n+1]=memo[n+1]=true;\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/07/26 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(true){\n\t\tint m;\n\t\tcin >> m;\n\n\t\tif(m==0)\n\t\t\tbreak;\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tint d[250];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> d[i];\n\t\t}\n\n\t\tbool flg = true;\n\n\t\tfor(int i=n-m; i>=-1; i--){\n\t\t\tflg = false;\n\n\t\t\tfor(int j=1; j<=m; j++){\n\t\t\t\tint k = i+j;\n\n\t\t\t\tif(k>=n){\n\t\t\t\t\tflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint l = k+d[k];\n\n\t\t\t\tif(l>i){\n\t\t\t\t\tflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!flg)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(flg){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m;\nint d[555];\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++)cin>>d[i];\n\t\tbool f=1;\n\t\tfor(int i=n-1;i>=-1;i--)\n\t\t{\n\t\t\tbool ok=0;\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tok|=i+j+d[i+j]>i;\n\t\t\t}\n\t\t\tf&=ok;\n\t\t}\n\t\tcout<<(f?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint m,n,d[255];\nvector<int>g[255];\nbool vis[255];\nvoid dfs(int v){\n    vis[v]=true;\n    for(int i=0;i<g[v].size();i++)if(!g[v][i])dfs(g[v][i]);\n}\nint main(void){\n    while(1){\n        cin>>m>>n;\n        if(m==0)return 0;\n        for(int i=1;i<=n;i++){\n            cin>>d[i];\n        }\n        for(int i=0;i<=n+1;i++){\n            g[i].clear();\n            vis[i]=false;\n        }\n        for(int i=0;i<=n;i++)for(int j=1;j<=m&&i+j<=n+1;j++)g[i].push_back(min(max(i+j+d[i+j],0),n+1));\n        dfs(0);\n        if(vis[n+1])cout<<\"OK\\n\";\n        else cout<<\"NG\\n\";\n        \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ma;\nint n;\n\nvector<int> graph2[300];\nvector<int> graph1[300];\nvector<int> graph3[300];\n\nvector<int> vs;\nbool used[300];\nint cmp[300];\n\nvoid dfs(int v){\n    used[v] = true;\n\n    for(int i = 0;i < graph1[v].size();i++){\n        if(!used[graph1[v][i]]) dfs(graph1[v][i]);\n    }\n\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n    used[v] = true;\n    cmp[v] = k;\n    for(int i = 0;i < graph2[v].size();i++){\n        if(!used[graph2[v][i]]) rdfs(graph2[v][i], k);\n    }\n}\n\nint memo[300];\n\nbool dfs3(int idx){\n    if(idx == cmp[n-1]){\n        return true;\n    }\n\n    if(graph3[idx].size() == 0){\n        return false;\n    }\n\n    if(memo[idx] != -1){\n        return memo[idx];\n    }\n\n    bool ans = true;\n    for(int i = 0;i < graph3[idx].size();i++){\n        ans = (ans && dfs3(graph3[idx][i]));\n    }\n\n    return memo[idx] = ans;\n}\n\n\nint scc(){\n    memset(used, 0, sizeof(used));\n    memset(cmp, 0, sizeof(cmp));\n    vs.clear();\n\n    for(int i = 0;i < n;i++){\n        if(!used[i]) dfs(i);\n    }\n\n    memset(used, 0, sizeof(used));\n\n    int k = 0;\n    for(int i = vs.size()-1;i >= 0;i--){\n        if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n\n    return k;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin >> ma, ma != 0){\n        cin >> n;\n\n        int a[310] = {};\n\n        for(int i = 0;i < n;i++){\n            cin >> a[i+1];\n        }\n        n+=2;\n        for(int i = 0;i < n;i++){\n            graph1[i].clear();\n            graph2[i].clear();\n            graph3[i].clear();\n        }\n\n        for(int i = 0;i < n;i++){\n            for(int j = i+1;j < min(i+ma+1, n);j++){\n                int tmp = min(n-1, max(j+a[j], 0));\n                graph1[i].push_back(tmp);\n                graph2[tmp].push_back(i);\n            }\n        }\n\n        scc();\n        for(int i = 0;i < n;i++){\n            for(int j = i+1;j < min(i+ma+1, n);j++){\n                int tmp = min(n-1, max(j+a[j], 0));\n                if(cmp[i] != cmp[tmp]){\n                    graph3[cmp[i]].push_back(cmp[tmp]);\n                }\n            }\n        }\n\n\n        memset(memo, -1, sizeof(memo));\n\n        if(dfs3(cmp[0])){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\nint m;\nint n;\nint INF=10000;\nint lo[1000];\nint lo2[1000];\nbool dp[1000][2];\nbool dp2[1000][2];\nbool ch,ch2;\nbool ch3;\n\nvoid role(int x,int kz,int z){\n\tif(x>=n+2)ch=true;\n\telse{\n\t\tif(lo[x]!=0 && z==0){\n\t\t\tif(x+lo[x]>=0 && dp[x+lo[x]][1]==false){\n\t\t\t\tdp[x+lo[x]][1]=true;\n\t\t\t\trole(x+lo[x],kz,1);\n\t\t\t}\n\t\t}\n\t\tif(lo[x]==0)for(int i=1;i<=m;i++){\n\t\t\tif(dp[x+i][0]==false){\n\t\t\t\tdp[x+i][0]=true;\n\t\t\t\trole(x+i,kz+1,0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid role2(int x,int kz,int z){\n\tif(x<0)ch2=true;\n\telse{\n\t\tif(lo[x]!=0 && z==0){\n\t\t\tif(x-lo[x]>=0 && dp2[x-lo[x]][1]==false){\n\t\t\t\tdp2[x-lo[x]][1]=true;\n\t\t\t\trole2(x-lo[x],kz,1);\n\t\t\t}\n\t\t}\n\t\tif(lo[x]==0)for(int i=1;i<=m;i++){\n\t\t\tif(dp2[x-i][0]==false){\n\t\t\t\tdp2[x-i][0]=true;\n\t\t\t\trole2(x-i,kz+1,0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tch=false;\n\t\tch2=false;\n\t\tch3=true;\n\t\tscanf(\"%d\",&m);\n\t\tif(m==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tmemset(lo,0,sizeof(lo));\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d\",&lo[i]);\n\t\t//for(int i=1;i<=n;i++)lo2[i]=-lo[i];\n\t\tfor(int i=0;i<1000;i++)dp[i][0]=dp[i][1]=false;\n\t\tfor(int i=0;i<1000;i++)dp2[i][0]=dp2[i][1]=false;\n\t\trole(0,0,0);\n\t\trole2(n+1,0,0);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(dp[i][0]==true || dp[i][1]==true){\n\t\t\t\tif(dp2[i][0]==false && dp2[i][1]==false)ch3=false;\n\t\t\t}\n\t\t\tif(dp2[i][0]==true || dp2[i][1]==true){\n\t\t\t\tif(dp[i][0]==false && dp[i][1]==false)ch3=false;\n\t\t\t}\n\t\t}\n\t\tif(ch && ch2 && ch3)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\nint d[252];\nint dp[252][252];\nint Max;\nint n;\nint main() {\n\twhile(scanf(\"%d\",&Max),Max) {\n\t\tscanf(\"%d\",&n);\n\t\td[0]=d[n+1]=0;\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=0;i<n+2;i++) {\n\t\t\tfor(int j=1;j<=Max;j++) {\n\t\t\t\tint p;\n\t\t\t\tp=min(i+j,n+1);\n\t\t\t\tp+=d[p];\n\t\t\t\tp=min(max(p,0),n+1);\n\t\t\t\tdp[i][p]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n+2;k++) {\n\t\t\tfor(int i=0;i<n+2;i++) {\n\t\t\t\tfor(int j=0;j<n+2;j++) {\n\t\t\t\t\tif(dp[i][k]&&dp[k][j]) dp[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool OK=1;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tif(dp[0][i]&&!dp[i][n+1]) {OK=0;break;}\n\t\t}\n\t\tif(OK) printf(\"OK\\n\"); else printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    fill(d,d+300,0);\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q1,q2;\n    q1.push(0);\n    bool c=true;\n    while(!q1.empty()){\n      b=q1.front();q1.pop();\n      if(r[b]) continue;\n      r[b]=true;\n      q2.push(b);\n      //cout << b << endl;\n      fill(used,used+300,false);\n      while(!q2.empty()){\n\tp=q2.front();q2.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(p>=n+1){\n\t  used[n+1]=true;\n\t  break;\n\t}\n\tif(used[p]) continue;\n\tused[p]=true;\n\tq1.push(p);\n\tfor(i=1;i<=m;i++){\n\t  //cout <<p<<\":\"<< i <<\":\"<<p+i+d[p+i]<< endl;\n\t  q2.push(p+i+d[p+i]);\n\t}\n      }\n      if(!used[n+1]){\n\tc=false;\n\tbreak;\n      }\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool used[300];\nint N,M;\nint d[300];\n\nint next(int t,int i){\n    return min(N+1,max(0,min(N+1,t+i)+d[t]));\n}\n\nvoid latte(int t=0){\n    if(used[t])return;\n    used[t]=true;\n\n    for(int i=1;i<=M;i++){\n        latte(next(t,i));\n    }\n}\n\nbool used2[300];\nbool dfs(int t){\n    if(used2[t])return false;\n    used2[t]=true;\n\n    if(t==N+1)return true;\n\n    bool ret=false;\n\n    for(int i=1;i<=M;i++)ret|=dfs(next(t,i));\n\n    return ret;\n}\n\nint main(){\n    while(cin>>M,M){\n        cin>>N;\n        for(int i=0;i<N;i++)cin>>d[i+1];\n        d[0]=d[N+1]=0;\n        fill_n(used,300,false);\n        latte();\n\n\n        bool flag=true;\n        for(int i=0;i<=N;i++)if(used[i]){\n            fill_n(used2,300,false);\n            if(!dfs(i))flag=false;\n        }\n\n        cout<<(flag?\"OK\":\"NG\")<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\n\n#define pb push_back\n\nint main(){\n\twhile(1){\n\t\tint max;\n\t\tint n,d[252];\n\t\tint dp[255] = {};\n\t\tscanf(\"%d\",&max); if(max == 0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i = 1 ; i <= n ; i ++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tbool t = true;\n\t\tfor(int s = 0 ; s < n+1 ; s ++){\n\t\t\tfor(int i = 0 ; i < 255 ; i ++)dp[i] = 0;\n\t\t\tdp[s] = 1;\n\t\t\tfor(int i = s ; i < n+1 ; i ++){\n\t\t\t\tif(dp[i] == 0)continue;\n\t\t\t\tfor(int j = 1 ; j <= max ; j ++){\n\t\t\t\t\tif(i+j >= n+1)dp[n+1] = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(i+j+d[i+j] >= n+1)dp[n+1] = 1;\n\t\t\t\t\t\telse if(i+j+d[i+j] >= 0)dp[i+j+d[i+j]] = 1;\n\t\t\t\t\t\telse dp[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt &= (dp[n+1] != 0);\n\t\t}\n\t\tif(t)puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\n\n#define pb push_back\n\nint main(){\n\twhile(1){\n\t\tint max;\n\t\tint n,d[252];\n\t\tint dp[255] = {};\n\t\tint dp_[255] = {};\n\t\tdp_[0] = 1;\n\t\tscanf(\"%d\",&max); if(max == 0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i = 1 ; i <= n ; i ++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tbool t = true;\n\t\tfor(int s = 0 ; s < n+1 ; s ++){\n\t\t\tif(dp_[s] == 0)continue;\n\t\t\tfor(int i = 0 ; i < 255 ; i ++)dp[i] = 0;\n\t\t\tdp[s] = 1;\n\t\t\tfor(int i = s ; i < n+1 ; i ++){\n\t\t\t\tif(dp[i] == 0)continue;\n\t\t\t\tdp_[i] = 1;\n\t\t\t\tfor(int j = 1 ; j <= max ; j ++){\n\t\t\t\t\tif(i+j >= n+1)dp[n+1] = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(i+j+d[i+j] >= n+1)dp[n+1] = 1;\n\t\t\t\t\t\telse if(i+j+d[i+j] >= 0)dp[i+j+d[i+j]] = 1;\n\t\t\t\t\t\telse dp[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt &= (dp[n+1] == 1);\n\t\t}\n\t\tif(t)puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q1,q2;\n    q1.push(0);\n    while(!q1.empty()){\n      b=q1.front();q1.pop();\n      if(r[b]) continue;\n      r[b]=true;\n      q2.push(b);\n      fill(used,used+300,false);\n      while(!q2.empty()){\n\tp=q2.front();q2.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(used[p]) continue;\n\tused[p]=true;\n\tq1.push(p);\n\tfor(i=1;i<=m;i++){\n\t  if(p+i+d[p+i]>n+1){\n\t    used[n+1]=true;\n\t    break;\n\t  }else q2.push(p+i+d[p+i]);\n\t}\n      }\n      g[b]=used[n+1];\n    }\n    bool c=true;\n    for(i=0;i<=n;i++){\n      if(r[i]&&!g[i]) c=false;\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint mx;\nint n;\nint d[251];\nbool flg[251];\n\n\nbool Solve(int x){\n\n  if(x>=n+1)return true;\n\n  ////////////////x<n kakutei ///////////////////////\n\n  if(d[x]!=0){\n  \n    if(x+d[x]>=n)return true;\n    if(Solve(x+d[x])==true)return true;\n  }\n  else{\n    \n    if(x+mx>=n+1)return true;\n    if(flg[x]==true)return false;  \n    \n    flg[x]=true;\n\n    for(int i=1; i<=mx; i++){\n     if(Solve(x+i)==true)return true;\n    }   \n    \n  }\n  \n  flg[x]=false;\n  \n  return false;\n}\n\n\nint main(){\n  \n  while(cin>>mx , mx){\n    cin >> n;\n    d[0]=0;\n    for(int i=1; i<=n; i++){\n      cin>>d[i];\n      flg[i]=false;\n    }\n\n    if(Solve(0)==true)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dice;\nint n;\nvector<int> a;\nvector<bool> memo;\n\nbool solve(int curr)\n{\n    if(curr == n-1)\n        return true;\n\n    if(memo[curr])\n        return false;\n    memo[curr] = true;\n\n    bool ret = false;\n    for(int i=1; i<=dice; ++i){\n        int next = min(n-1, curr + i);\n        next = max(0, min(n-1, next + a[next]));\n        if(solve(next))\n            ret = true;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        cin >> dice >> n;\n        if(dice == 0)\n            return 0;\n\n        a.assign(n+2, 0);\n        for(int i=1; i<=n; ++i)\n            cin >> a[i];\n\n        memo.assign(n+2, false);\n        solve(0);\n        vector<bool> access = memo;\n\n        bool ok = true;\n        for(int i=0; i<n; ++i){\n            memo.assign(n+2, false);\n            if(access[i] && !solve(i))\n                ok = false;\n        }\n\n        if(ok)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nint m, n;\nvi d;\nvector<int> memo;\n\nint f(int p)\n{\n    p = max(0, p);\n    if(p >= n-1) return 1;\n    if(memo[p]) return memo[p];\n    \n    memo[p] = 2;\n    rep(i, m){\n        int v = f(p+i+1 + d[p+i+1]);\n        if(v != 2){\n            return memo[p] = v;\n        }\n    }\n    \n    return memo[p] = 3;\n}\n\nint main()\n{\n    while(cin >> m, m){\n        cin >> n;\n        n += 2;\n        d.assign(n, 0);\n        memo.assign(n, 0);\n        rep(i, n-2) cin >> d[i+1];\n        cout << (f(0) == 1 ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint N;\nint a;\nvector<int>ds;\nvector<int>used;\nbool dfs(const int now) {\n\tif (now + N >= a + 1) {\n\t\tused[now] = 1;\n\t\treturn true;\n\t}\n\tset<int>nexts;\n\tfor (int i = 1; i <= N; ++i) {\n\t\t int next = now + i + ds[now + i];\n\t\tif (next >= a + 1) {\n\t\t\tused[now] = 1;\n\t\t\treturn true;\n\t\t}\n\t\telse if (next <= -1) {\n\t\t\tnext = 0;\n\t\t}\n\t\tif (used[next] == 1) {\n\t\t\tused[now] = 1;\n\t\t\treturn true;\n\t\t}\n\t\telse if (used[next] == -1) {\n\n\t\t}\n\t\telse {\n\t\t\tnexts.emplace(next);\n\t\t}\n\t}\n\tused[now] = -1;\n\tfor (auto n : nexts) {\n\t\tbool ok = dfs(n);\n\t\tif (ok) {\n\t\t\tused[now] = true;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false; \n}\n\nint main() {\n\twhile (1) { cin >> N;\n\t\tif (!N)break; cin >> a;\n\t\tds.clear();\n\t\tused.clear();\n\t\tds.resize(a+2);\n\t\tused.resize(a + 2);\n\t\tfor (int i = 0; i < a; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tused[0] = -1;\n\t\tbool ok=dfs(0);\n\t\tif (ok)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> a;\nint n,m;\nvector<bool> d(300);\n\nbool saiki(int p1,vector<bool> u){\n    int p = p1;\n    if(a[p] == 300) return true;\n    if(u[p]) return false;\n    u[p] = true;\n    if(d[p]) return true;\n    bool ans = false;\n    vector<bool> t = u;\n    for(int i = 1;i<=m;i++){\n\tu = t;\n\tp = p1;\n\tp += i;\n\tp += a[p];\n\tp = max(p,0);\n\tif(p >= 300) return d[p1] = true;\n\twhile(a[p] != 0){\n\t    if(u[p]) break;\n\t    u[p] = true;\n\t    p += a[p];\n\t    p = max(p,0);\n\t    if(p >= 300) return d[p1] = true;\n\t}\n\tans = ans | saiki(p,u);\n    }\n    return d[p] = ans;\n}\n\nint main(){\n    while(true){\n\tfill(ALL(d),false);\n\ta = vector<int>(0);\n\tcin >> m;\n\tif(m == 0) break;\n\tcin >> n;\n\ta.PB(-300);\n\tREP(i,n){\n\t    int temp;\n\t    cin >> temp;\n\t    a.PB(temp);\n\t}\n\ta.PB(300);\n\tif(saiki(0,vector<bool>(n+2,false))) cout << \"OK\" << endl;\n\telse cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nint M;\nint N;\nint D[259];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&M);\n\t\tif(M==0)break;\n\t\tscanf(\"%d\",&N);\n\t\tfor(int i=1;i<=N;i++)scanf(\"%d\",&D[i]);\n\t\tvector<int> G[259];\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(i+D[i]<0)G[i].pb(0);\n\t\t\telse if(i+D[i]>N+1)G[i].pb(N+1);\n\t\t\telse G[i].pb(i+D[i]);\n\t\t\tfor(int j=1;j<=M;j++){\n\t\t\t\tif(i+j<=N+1)G[i].pb(i+j);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=M;j++){\n\t\t\tif(j<=N+1)G[0].pb(j);\n\t\t}\n\t\tbool F[259];\n\t\tfor(int i=0;i<=N+1;i++)F[i]=false;\n\t\tvector<int>S;S.pb(0);\n\t\tint l=0;\n\t\twhile(l<(int)S.size()){\n\t\t\tint v=S[l];\n\t\t\tif(F[v])continue;\n\t\t\tF[v]=true;\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tif(!F[G[v][i]]){\n\t\t\t\t\tS.pb(G[v][i]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\t\tbool ans=true;\n\t\tbool F1[259];\n\t\tfor(int i=0;i<=N+1;i++){\n\t\t\tif(!F[i])continue;\n\t\t\tfor(int j=0;j<=N+1;j++){\n\t\t\t\tF1[i]=false;\n\t\t\t}\n\t\t\tS.clear();\n\t\t\tS.pb(i);\n\t\t\tl=0;\n\t\t\twhile(l<(int)S.size()&&!F1[N+1]){\n\t\t\t\tint v=S[l];\n\t\t\t\tif(F1[v])continue;\n\t\t\t\tF1[v]=true;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tif(!F1[G[v][i]]){\n\t\t\t\t\t\tS.pb(G[v][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(!F1[N+1])ans=false;\n\t\t}\n\t\tif(ans)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint m,n;\nint mass[252]={};\nbool DP[252]={};\nint seach(vector<int> walked,int now){\n\tif(now>n)\n\t\treturn 1;\n\tnow=max(0,now);\n\tfor(int i=0;i<walked.size();i++){\n\t\tif(now==walked[i])\n\t\treturn -i-1;\n\t}\n\twalked.push_back(now);\n\tint maxer=-9999;\n\tfor(int i=1;i<=m;i++){\n\t\tint first=now+i;\n\t\tint second=first+mass[first];\n\t\tmaxer=max(maxer,seach(walked,second));\n\t}\n\tif(walked.size()==-maxer)\n\tmaxer=2;\n\treturn maxer;\n\t\n}\n\nint main() {\n\t// your code goes here\n\tvector<int> a;\n\twhile(cin >> m){\n\tcin >> n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> mass[i];\n\t}\n\tif(seach(a,0)==1)\n\t\tcout << \"OK\" << endl;\n\telse\n\t\tcout << \"NG\" << endl;\n\t\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "// すごろくを作る.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <queue>\nusing namespace std;\nqueue<int> que;\n\n\nint main(void)\n{\n\tint result[100];\n\tint suffix = 0;\n\n\twhile (1) {\n\t\tbool sugoroku[502] = { false };\n\t\tint roulette_max, nglid, value[252] = { 0 };\n\n\t\tscanf(\"%d\", &roulette_max);\n\t\tif (roulette_max == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &nglid);\n\t\tfor (int i = 1; i <= nglid; i++) {\n\t\t\tscanf(\"%d\", &value[i]);\n\t\t}\n\n\t\twhile (que.empty() == false) {\n\t\t\tque.pop();\n\t\t}\n\n\t\tque.push(0);\n\t\tsugoroku[0] = true;\n\n\t\tint success;\n\t\twhile (que.empty() == false) {\n\t\t\tint size = que.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tint front = que.front();\n\t\t\t\tsuccess = 0;\n\t\t\t\tfor (int j = 1; j <= roulette_max; j++) {\n\t\t\t\t\tif (sugoroku[front + j] == false) {\n\t\t\t\t\t\tsugoroku[front + j] = true;\n\t\t\t\t\t\tif (front + j + value[front + j] > 0) {\n\t\t\t\t\t\t\tif (front + j + value[front + j] > nglid) {\n\t\t\t\t\t\t\t\tif (success != 2) {\n\t\t\t\t\t\t\t\t\tsuccess = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tque.push(front + j + value[front + j]);\n\t\t\t\t\t\t\t\tsuccess = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tif (success == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (success == 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (success == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (success == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tresult[suffix++] = success;\n\t}\n\n\tfor (int i = 0; i < suffix; i++) {\n\t\tif (result[i] == 1) {\n\t\t\tputs(\"OK\");\n\t\t}\n\t\telse {\n\t\t\tputs(\"NG\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\n//int ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\t//if (ka[y][x] == 1)continue;\n\t\t\t\t//ka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\t//for (int j = 0; j<300; j++)\n\t\t\t//{\n\t\t\t//\tka[i][j] = 0;\n\t\t\t//}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\t/*\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\t*/\n\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint m,n,d[255];\nvector<int>g[255];\nbool vis[255];\nvoid dfs(int v){\n    vis[v]=true;\n    for(int i=0;i<g[v].size();i++)if(!vis[g[v][i]])dfs(g[v][i]);\n}\nint main(void){\n    while(1){\n        cin>>m>>n;\n        if(m==0)return 0;\n        for(int i=1;i<=n;i++){\n            cin>>d[i];\n        }\n        d[n+1]=0;\n        for(int i=0;i<=n+1;i++){\n            g[i].clear();\n            vis[i]=false;\n        }\n        for(int i=0;i<=n;i++)for(int j=1;j<=m&&i+j<=n+1;j++)g[i].push_back(min(max(i+j+d[i+j],0),n+1));\n        dfs(0);\n        if(vis[n+1])cout<<\"OK\\n\";\n        else cout<<\"NG\\n\";\n        \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int INF = 1 << 22;\nint main()\n{\n    int Max,n;\n    while(cin >> Max, Max){\n        int map[252] = {};\n        int dist[252][252];\n        cin >> n;\n        for(int i = 1; i <= n; ++i){\n            cin >> map[i];   \n        }\n        fill((int*)dist,(int*)(dist + n + 2),INF);\n        queue<int> q;\n        q.push(0);\n        while(!q.empty()){\n            int x = q.front(); q.pop();\n            for(int i = 1; i <= Max; ++i){\n                int nx = x + i;\n                if(nx >= n + 1){\n                    dist[x][nx] = 1;\n                } else {\n                    int t = nx;\n                    nx += map[t];\n                    if(nx >= n + 1){\n                        dist[x][n + 1] = 1;\n                    } else if(nx <= 0){\n                        dist[x][0] = 1;\n                    } else if(dist[x][nx] == INF){\n                        dist[x][nx] = 1;\n                        q.push(nx);\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < n + 2; ++i){\n            dist[i][i] = 0;\n        }\n        for(int k = 0; k < n + 2; ++k){\n            for(int i = 0; i < n + 2; ++i){\n                for(int j = 0; j < n + 2; ++j){\n                    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        \n        bool f = false;\n        for(int i = 0; i < n + 1; ++i){\n            if(dist[0][i] != INF && dist[i][n + 1] == INF){\n                cout << \"NG\" << endl;\n                f = true;\n                break;\n            }\n        }\n        if(!f){\n            cout << \"OK\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 999999\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<k;i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n    int ma;\n    while(scanf(\"%d\",&ma),ma){\n        int n;\n        scanf(\"%d\",&n);\n        int stage[256]={0};\n        bool D[300][300]={{0}};\n        reps(i,1,n+1)scanf(\"%d\",&stage[i]);\n        rep(i,n+1){\n            reps(j,1,ma+1){\n                /*行先i+j*/\n                if(stage[i+j]==0)D[i][i+j]=1;\n                else if(stage[i+j]>=1)D[i][min(i+j+stage[i+j],n+1)]=1;\n                else if(stage[i+j]<=-1)D[i][max(0,i+j+stage[i+j])]=1;\n            }\n        }\n        /*WarshallFloyd*/\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    if(D[i][k] && D[k][j]) D[i][j] = 1;\n                }\n            }\n        }\n        bool f = true;\n\n        rep(i,n+1)if(D[0][i] && !D[i][n+1])f =false;\n        printf(\"%s\\n\",(f) ? \"OK\" : \"NG\");\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n\nusing namespace std;\nint maxCount, n;\nvector<int> kouka;\nint memo[252];//251があがり0がふりだし\nint passed[252];\n\nconst int AGARI = 100000;\n\nbool dfs(int index)\n{\n\tif(passed[index]) return false;\n\tpassed[index] = true;\n\n\tindex = min(n + 1, max(0 ,kouka[index] + index));\n\tif(kouka[index] == AGARI) return true;\n\tfor (int i = 1; i <= maxCount; i++)\n\t{\n\t\tint next = index + i;\n\t\tif(memo[next])\n\t\t\tif(memo[next] = dfs(next))\n\t\t\t\treturn true;\n\t}\n\n\tpassed[index] = false;\n\treturn false;\n}\n\nbool solve()\n{\n\tfor (int i = 1; i <= maxCount; i++)\n\t{\n\t\tif(dfs(i)) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> maxCount && maxCount)\n\t{\n\t\tcin >> n;\n\t\tkouka.resize(n + 2);\n\t\tkouka[0] = -1;//ふりだし\n\t\tfor (int i = 1; i < n + 1; i++)\n\t\t{\n\t\t\tcin >> kouka[i];\n\t\t}\n\t\tkouka[n + 1] = AGARI;//あがり\n\t\tmemset(memo, true, sizeof(memo));\n\t\tmemset(passed, false, sizeof(memo));\n\t\tcout << (solve()? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(void)\n{\n\tint max,n,d[251];\n\tint i,j,flg,a[251];\n\t\n\twhile(1){\n\t\n\t\tcin>>max;\n\t\tif(max==0) break;\n\t\t\n\t\tcin>>n;\n\t\t\n\t\tfor(i=1;i<=n;i++) cin>>d[i];\n\t\t\n\t\tfor(i=1;i<=max;i++) a[i]=0;\n\t\t\n\t\tfor(i=1;i<=max;i++){\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tif(d[j]<0){\n\t\t\t\t\tif(d[j]*-1>=i) a[i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tflg=0;\n\t\tfor(i=1;i<=max;i++){\n\t\t\tif(a[i]==0){\n\t\t\t\tprintf(\"OK\\n\");\n\t\t\t\tflg=1;\n\t\t\t}\n\t\t}\n\t\tif(flg==0) printf(\"NG\\n\");\n\t\t\n\t}\t\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint m,n;\nint d[300];\nbool used[300];\nint dp[300];\nbool found=false;\nbool dfs(int pos)\n{\n\tif(dp[pos]!=-2)return dp[pos];\n\tif(pos==n+1)return true;\n\tbool none=true;\n\tbool res=true;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint npos=pos+i;\n\t\tif(npos>0&&npos<=n)npos+=d[npos];\n\t\tnpos=min(npos,n+1);\n\t\tnpos=max(npos,0);\n\t\tif(used[npos])continue;\n\t\tnone=false;\n\t\tused[npos]=true;\n\t\tif(!dfs(npos))res=false;\n\t\tused[npos]=false;\n\t\tif(!res)return dp[pos]=false;\n\t}\n\tif(none)return dp[pos]=false;\n\treturn dp[pos]=true;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tfor(int i=0;i<300;i++)dp[i]=-2;\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(used,false,sizeof(used));\n\t\tcin >> m;\n\t\tif(m==0)break;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++)cin >> d[i];\n\t\tused[0]=true;\n\t\tif(dfs(0))cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int> >G(252),R(252);\nint n,m;\nint d[252];\nbool u[252];\nvoid f(int v)\n{\n\tu[v]=1;\n\tfor(int i=0;i<R[v].size();i++)\n\t{\n\t\tif(!u[R[v][i]])f(R[v][i]);\n\t}\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<=n+1;i++)G[i].clear(),R[i].clear(),u[i]=0;\n\t\tfor(int i=1;i<=n;i++)cin>>d[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m&&i+j<=n+1;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+d[i+j];\n\t\t\t\tif(k>n+1)k=n+1;\n\t\t\t\tif(k<0)k=0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n+1);\n\t\tbool ok=1;\n\t\tfor(int i=0;i<G[0].size();i++)ok&=u[G[0][i]];\n\t\tcout<<(ok?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nint ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\tif (ka[y][x] == 1)break;\n\t\t\t\tka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\tfor (int j = 0; j<300; j++)\n\t\t\t{\n\t\t\t\tka[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\t/*\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\t*/\n\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\n\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-10;\n\nint M, N;\nint d[260];\nint dp[260]; // -1: ?????¢?´¢, 0:??¢?´¢???, 1:??????, 2: ?????????\n\nint dfs(int p) {\n\tif (p >= N + 1) return 1;\n\tif (p < 0) p = 0;\n\t\n\tif (dp[p] == 0 || dp[p] == 2) return dp[p] = 2;\n\tif (dp[p] == 1) return dp[p] = 1;\n\t\n\tbool ok = false;\n\t\n\tdp[p] = 0;\n\t\n\tif (d[p - 1] == 0) {\n\t\tFOR(i, 1, M + 1) {\n\t\t\t\n\t\t\tif (dfs(p + i) == 1) ok = true;\n\t\t}\n\t}\n\telse {\n\t\tif (dfs(p + d[p - 1]) == 1) ok = true;\n\t}\n\t\n\treturn dp[p] = ok ? 1 : 2;\n}\n\nint main() {\n\twhile (cin >> M, M) {\n\t\tcin >> N;\n\t\tREP(i, N) scanf(\"%d\", d + i);\n\t\t\n\t\tfill(dp, dp + N + 2, -1);\n\t\t\n\t\tputs(dfs(0) == 1 ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nbool bfs(int, int, int*, int *);\n\nint main()\n{\n\tint max, n, *nl, *c, f1;\n\n\twhile(cin >> max && max > 0)\n\t{\n\t\tcin >> n;\n\t\tnl = new int [n + 2];\n\t\tc = new int [n + 2];\n\n\t\tfor(f1 = 0; f1 < n + 2; f1++)\n\t\t{\n\t\t\tif(f1 == 0 || f1 == n + 1)\n\t\t\t\tnl[f1] = 0;\n\t\t\telse\n\t\t\t\tcin >> nl[f1];\n\n\t\t\tc[f1] = 0;\n\t\t}\n\n\t\tif(bfs(n+1, max, nl, c))\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\n\treturn 0;\n}\nbool bfs(int n, int max, int *nl, int *c)\n{\n\tint f1, t, p, ps = 0;\n\tbool j = true, k;\n\n\tqueue<int> P;\n\tP.push(ps);\n\n\twhile(!P.empty() && j)\n\t{\n\t\tps = P.front(); P.pop();\n\t\tk = false;\n\t\tfor(f1 = 1; f1 <= max; f1++)\n\t\t{\n\t\t\tt = ps + f1;\n\t\t\tif(t > n)\n\t\t\t\tt = n;\n\n\t\t\tp = t + nl[t];\n\n\t\t\tif(p > n)\n\t\t\t\tp = n;\n\t\t\telse if(p < 0)\n\t\t\t\tp = 0;\n\n\t\t\tif(p != ps)\n\t\t\t\tk = true;\n\n\t\t\tif(k && p != n && c[p] == 0)\n\t\t\t{\n\t\t\t\tP.push(p);\n\t\t\t\tc[p] = 1;\n\t\t\t}\n\t\t}\n\n\t\tif(!k)\n\t\t\tj = false;\n\t}\n\n\treturn j;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n\nbool check(char data[4]){\n  for(int i = 1 ; i < 4 ; i++){\n    if(data[0] != data[i])return false;\n  }\n  return true;\n}\n\nint toInt(char data[4]){\n  int ret = 0;\n  for(int i = 0 ; i < 4 ; i++){\n    ret += (data[i]-'0');\n    ret *= 10;\n  }  \n  return ret/10;\n}\n\nvoid getNext(int a,char data[4]){\n  for(int i = 0 ; i < 4 ; i++){\n    data[3 - i] = a%10 + '0';\n    a /= 10;\n  }\n}\n\nvoid solve(char data[4]){\n\n  if(check(data)){\n    cout << \"NA\" << endl;\n    return;\n  }\n\n  if(toInt(data) == 6174){\n    cout << 0 << endl;\n    return;\n  }\n\n  int res;\n  for(res = 1 ; ; res++){\n    int L,S;\n    sort(data,data + 4);\n    S = toInt(data);\n    reverse(data,data + 4);\n    L = toInt(data);\n    if(L - S == 6174)break;\n    getNext(L - S,data);\n  }\n  cout << res << endl;\n}\n\nint main(){\n\n  char data[4];\n  while(1){\n    bool f = true;\n    for(int i = 0 ; i < 4 ; i++){\n      cin >> data[i];\n      if(data[i] != '0')f = false;\n    }\n    if(f)break;\n    solve(data);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define NMAX 260\nint n,dmax;\nint m[NMAX];\nbool visited[NMAX], isVisit[NMAX], goal[NMAX], isGoal;\nbool dfs(int p){\n  //cout << \"    @\" << p << endl;\n  if(visited[p])return goal[p];\n  visited[p] = true;\n  if(p == n+1){\n    //cout << \"    goal\" << endl;\n    return true;\n  }\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    //cout << \"        \" << p << \"->\" << np << endl;\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;  \n    goal[p] = (dfs(np)||goal[p]);\n  }\n  return goal[p];\n}\nvoid solve(){\n  memset(visited, 0, sizeof(visited));\n  memset(goal, 0, sizeof(goal));\n  goal[0] = dfs(0);\n  if(!goal[0]){\n    cout << \"NG\" << endl;\n    return ;\n  }\n  for(int i = 1 ; i <= n; i++){\n    if(!visited[i])continue;\n    //cout << \":\" << i << endl;\n    goal[i] = dfs(i);\n    if(!goal[i]){\n      cout << \"NG\" << endl;\n      return ;\n    }\n  }\n  cout << \"OK\" << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    m[0] = 0;\n    int i;\n    for(i = 1 ; i < n+1 ;i++){\n      cin >> m[i];\n    }\n    m[i] = 0;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX = 260;\nbool come[MAX],goal[MAX];\nint M,n,d[MAX];\nvector<int> V;\n\nvoid print(){\n\n  for(int i = 0; i <= n; i++) cout << come[i] << \" \";\n  cout << endl;\n  for(int i = 0; i <= n; i++) cout << goal[i] << \" \";\n  cout << endl;\n}\n\nvoid init(){\n  fill(come,come+MAX,false);\n  fill(goal,goal+MAX,false);\n  fill(d,d+MAX,0);\n}\n\nint move(int now, int num){\n  int nex = now+num;\n  nex += d[nex];\n  if(nex > n) return -1;\n  if(nex < 0) return 0;\n  return nex;\n}\n\nvoid make_come(){\n  come[0] = true;\n  priority_queue<int> Q;\n  Q.push(0);\n  while(!Q.empty()){\n    int now = Q.top();\n    Q.pop();\n    for(int i = 1; i <= M; i++){\n      int nex = move(now,i);\n      if(nex == -1) goal[nex] = true;\n      else if(come[nex] == false && nex <= n){\n        come[nex] = true;\n        Q.push(nex);\n      }\n    }\n  }\n}\n\nvoid make_goal(){\n  for(int i = n; i >= 0; i--){\n    if(!come[i] || goal[i]) continue;\n\n    for(int j = 1; j <= M; j++){\n      if(goal[move(i,j)]) goal[i] = true;\n    }\n  }\n}\n\n\nbool solve(){\n\n  make_come();\n  make_goal();\n\n  for(int i = 0; i <= n; i++)\n    if(come[i] && !goal[i]) return false; \n  return true;\n}\n\nint main(){\n\n  while(cin >> M && M){\n    init();\n    cin >> n;\n    for(int i = 1; i <= n; i++) cin >> d[i];\n    if(solve()) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    // print();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint d[300];\nbool ok[300];\nbool prob[300];\n\nint main() {\n  int ma;\n  while(cin>>ma,ma) {\n    int n;\n    cin >> n;\n    REP(i,n) {\n      cin >> d[i+1];\n    }\n    n++;\n    memset(ok,0,sizeof(ok));\n    memset(prob,0,sizeof(prob));\n    prob[0] = 1;\n    REP(k,n+1) {\n      REP(i,n) {\n        for (int x=1; x<=ma; ++x) {\n          if (i+x>=n) ok[i] = 1;\n          else {\n            int D = d[i+x];\n            int nxt = i+x;\n            if (D > 0) {\n              nxt += D;\n            } else if (D < 0) {\n              nxt += D;\n            }\n            if (nxt >= n) ok[i] = 1;\n            else if (nxt < 0) ok[i] |= ok[0];\n            else {\n              // cout << i << \" : \" << nxt << endl;\n              ok[i] |= ok[nxt];\n              prob[nxt] |= prob[i];\n            }\n          }\n        }\n      }\n    }\n    // REP(i,n) cout << prob[i] << \" \" << ok[i] << endl;\n    bool f = 0;\n    REP(i,n) if (prob[i] && !ok[i]) {\n      f = 1;\n    }\n    cout << (f?\"NG\":\"OK\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q1,q2;\n    q1.push(0);\n    while(!q1.empty()){\n      b=q1.front();q1.pop();\n      if(r[b]) continue;\n      r[b]=true;\n      q2.push(b);\n      fill(used,used+300,false);\n      while(!q2.empty()){\n\tp=q2.front();q2.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(used[p]) continue;\n\tused[p]=true;\n\tq1.push(p);\n\tfor(i=1;i<=m;i++){\n\t  if(p+i+d[p+i]>=n+1){\n\t    used[n+1]=true;\n\t    break;\n\t  }else q2.push(p+i+d[p+i]);\n\t}\n      }\n      g[b]=used[n+1];\n    }\n    bool c=true;\n    for(i=0;i<=n;i++){\n      if(r[i]&&!g[i]) c=false;\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    int Max,n;\n    while(cin >> Max, Max){\n        int map[252] = {};\n        bool dist[252][252];\n        cin >> n;\n        for(int i = 1; i <= n; ++i){\n            cin >> map[i];   \n        }\n        fill((bool*)dist,(bool*)(dist + n + 2),false);\n        queue<int> q;\n        q.push(0);\n        while(!q.empty()){\n            int x = q.front(); q.pop();\n            for(int i = 1; i <= Max; ++i){\n                int nx = x + i;\n                if(nx >= n + 1){\n                    dist[x][n + 1] = true;\n                } else {\n                    nx += map[nx];\n                    if(nx >= n + 1){\n                        dist[x][n + 1] = true;\n                    } else if(nx <= 0){\n                        dist[x][0] = true;\n                    } else if(dist[x][nx] == false){\n                        dist[x][nx] = true;\n                        q.push(nx);\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < n + 2; ++i){\n            dist[i][i] = true;\n        }\n        for(int k = 0; k < n + 2; ++k){\n            for(int i = 0; i < n + 2; ++i){\n                for(int j = 0; j < n + 2; ++j){\n                    if(dist[i][k] && dist[k][j]) dist[i][j] = true;\n                }\n            }\n        }\n        \n        bool f = false;\n        for(int i = 0; i < n + 1; ++i){\n            if(dist[0][i] && !dist[i][n + 1]){\n                f = true;\n                break;\n            }\n        }\n        cout << (f?\"NG\":\"OK\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nint MAX, N;\n\nvoid valid_check(vector<bool> &isValid, vector< vector<int> > &g){\n  isValid[0] = true;\n  REP(now, N + 1){\n    if(!isValid[now]) continue;\n    REP(i, g[now].size()) isValid[g[now][i]] = true;\n  }\n}\n\nint main() {\n  while(cin >>MAX && MAX){\n    cin >>N;\n    vector<int> v(N + 2, 0); FOR(i, 1, N + 1) cin >>v[i];\n\n    vector< vector<int> > g(N + 2, vector<int>());\n    REP(i, N + 1){\n      if(v[i] == 0){\n        FOR(j, i + 1, min(N + 1, i + MAX) + 1) g[i].push_back(j);\n      } else if(v[i] < 0){\n        int next = max(0, i + v[i]);\n        g[i].push_back(next);\n      } else {\n        int next = min(N + 1, i + v[i]);\n        g[i].push_back(next);\n      }\n    }\n    vector<bool> isValid(N + 2, false);\n    valid_check(isValid, g);\n\n    //debug\n    //REP(i, v.size()) cout <<v[i] <<\" \"; cout <<endl;\n    bool final_isOK = true;\n    REP(i, N + 1){\n      //if(!closed[i]) continue;\n      if(!isValid[i]) continue;\n      queue<int> open;\n      open.push(i);\n      bool isOK = false;\n      vector<bool> closed(N + 1, false);\n      closed[i] = true;\n      //cout <<i <<\" ---------\" <<endl;\n      while(!open.empty()){\n        int now = open.front(); open.pop();\n        //cout <<now <<\", \" <<v[now] <<endl;\n        if(now == N + 1){\n          isOK = true;\n          break;\n        }\n        //if(closed[now]) continue;\n\n        if(v[now] == 0){\n          FOR(i, now + 1, min(N + 1, now + MAX) + 1){\n            if(!closed[i]){\n              //cout <<\"    push \" <<i <<endl;\n              open.push(i);\n              closed[i] = true;\n            }\n          }\n        } else if(v[now] < 0){\n          int next = max(0, now + v[now]);\n          //cout <<\"    push \" <<next <<endl;\n          if(!closed[next]){\n            open.push(next);\n            closed[next] = true;\n          }\n        } else if(v[now] > 0){\n          int next = min(N + 1, now + v[now]);\n          if(!closed[next]){\n            open.push(next);\n            closed[next] = true;\n          }\n        }\n      }\n      if(!isOK){\n        final_isOK = false;\n        break;\n      }\n    }\n    cout <<(final_isOK ? \"OK\" : \"NG\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nbool dfs(int now, vector<bool> &visited, vector< vector<int> > &g, vector<int> &v){\n  //cout <<\"now = \" <<v[now] <<endl;\n  if(v[now] == 0) return true;\n  if(visited[now]) return false;\n  int next = g[now][0];\n  visited[next] = true;\n  return dfs(next, visited, g, v);\n}\n\nint main() {\n  int MAX;\n  while(cin >>MAX && MAX){\n    int N; cin >>N;\n    vector<int> v(N + 2, 0); FOR(i, 1, N + 1) cin >>v[i];\n    vector< vector<int> > g(N + 2, vector<int>());\n    REP(i, N + 1){\n      if(v[i] == 0){\n        FOR(j, i + 1, min(N + 1, i + MAX) + 1) g[i].push_back(j);\n      } else if(v[i] < 0){\n        int next = max(0, i + v[i]);\n        g[i].push_back(next);\n      } else {\n        int next = min(N + 1, i + v[i]);\n        g[i].push_back(next);\n      }\n    }\n    //REP(i, g.size()){\n    //  cout <<i <<\": \";\n    //  REP(j, g[i].size()) cout <<g[i][j] <<\" \";\n    //  cout <<endl;\n    //}\n    bool isOK = true;\n    REP(i, N + 1){\n      if(v[i] == 0){\n        bool f = false;\n        REP(j, g[i].size()){\n          vector<bool> visited(N + 2, false);\n          dfs(g[i][j], visited, g, v);\n          if(!visited[i]) f = true;\n        }\n        if(!f) isOK = false;\n      } else{\n        vector<bool> visited(N + 2, false);\n        bool tmp = dfs(i, visited, g, v);\n        if(!tmp) isOK = false;\n      }\n      //REP(i, visited.size()) cout <<visited[i] <<\" \"; cout <<endl;\n      //cout <<i <<\" (\" <<v[i] <<\") : \";\n    }\n    cout <<(isOK ? \"OK\" : \"NG\") <<endl;\n  } return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nqueue<int> q;\n\nbool t[252];\nint d[252];\n\nint maxw;\n\nint n;\n\nvoid tw(int a)\n{\n\tif(a < 0)\n\t{\n\t\tif(!t[0])\n\t\t{\n\t\t\tt[0] = true;\n\t\t\tq.push(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!t[a])\n\t\t{\n\t\t\tt[a] = true;\n\t\t\tq.push(a);\n\t\t}\n\t}\n}\n\nvoid tou(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttw(a - i);\n\t}\n}\n\nvoid syo(int a)\n{\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(i + d[i] == a)\n\t\t{\n\t\t\ttou(a);\n\t\t}\n\t}\n}\n\nvoid init()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt[i] = false;\n\t}\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\tif(n + 1 - i >= 0)\n\t\t{\n\t\t\tt[n + 1 - i] = true;\n\t\t\tq.push(n + 1 - i);\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(d[i] + i >= n + 1)\n\t\t{\n\t\t\ttou(i);\n\t\t}\n\t}\n}\n\nvoid modo()\n{\n\tinit();\n\twhile(!q.empty())\n\t{\n\t\tint w = q.front();\n\t\tq.pop();\n\t\tsyo(w);\n\t}\n}\n\nqueue<int> q2;\n\nbool t2[252];\n\nvoid tw2(int a)\n{\n\tif(a < n + 1)\n\t{\n\t\tif(!t2[a])\n\t\t{\n\t\t\tt2[a] = true;\n\t\t\tq2.push(a);\n\t\t}\n\t}\n}\n\nvoid tou2(int a)\n{\n\tif(a > n + 1)\n\t{\n\t\tt2[n + 1] = true;\n\t}\n\telse\n\t{\n\t\ttw2(a + d[a]);\n\t}\n}\n\nvoid syo2(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttou2(a + i);\n\t}\n}\n\nvoid init2()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt2[i] = false;\n\t}\n\tq2.push(0);\n\tt2[0] = true;\n}\n\nvoid modo2()\n{\n\tinit2();\n\twhile(!q2.empty())\n\t{\n\t\tint w = q2.front();\n\t\tq2.pop();\n\t\tsyo2(w);\n\t}\n}\n\nbool can()\n{\n\tif(!t2[n + 1])\n\t{\n\t\treturn false;\n\t}\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tif(t2[i])\n\t\t{\n\t\t\tif(!t[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&maxw);\n\t\tif(maxw == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\td[0] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\",d + i);\n\t\t}\n\t\td[n + 1] = 0;\n\t\tmodo();\n\t\tmodo2();\n\t\tif(can())\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool used[N],ans;\n\nvoid dfs(int x){\n  x+=d[x];\n  if(x<0)x=0;\n  if(n+1<x)x=n+1;\n  if(used[x])return;\n  used[x]=true;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    dfs(nx);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    memset(d,0,sizeof(d));\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(used,0,sizeof(used));\n    dfs(0);\n    ans=true;\n    for(int i=0;i<=n;i++){\n      if(!used[i])continue;\n      int f=0;\n      for(int j=1;j<=m;j++){\n\tint ni=min(n+1,i+j);\n\tni+=d[ni];\n\tif(ni<0)ni=0;\n\tif(n+1<ni)ni=n+1;\n\tif(ni!=i)f=1;\n      }\n      if(!f)ans=false;\n    }\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nnamespace MGraph{\n\ttypedef int Cost;Cost CINF=1<<28;\n\ttypedef  vector<vector<Cost> > Mat;\n}\nnamespace ShortestPath{\n    using namespace MGraph;\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\n\nCost INF=1<<28;\n\nclass Main{\npublic:\n\n\tvoid run(){\n\t\twhile(true){\n\t\t\tint M;cin >> M;if(M==0)break;\n\t\t\tint n;cin >> n;\n\t\t\tvector<int> ds(n+2);REP(i,n) cin >> ds[i+1];\n\t\t\t\n\t\t\tMat g(n+2,vector<Cost>(n+2,INF));\n\t\t\tREP(i,n+2){\n\t\t\t\tfor(int r=1;r<=M;r++){\n\t\t\t\t\tint npos=min(i+r,n+1);\n\t\t\t\t\tnpos+=ds[npos];npos=max(npos,0);npos=min(npos,n+1);\n\t\t\t\t\tg[i][npos]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twarshall_floyd(g);\n\t\t\tbool ok=true;\n\t\t\tREP(i,n+2){\n\t\t\t\tif(g[0][i]<INF && g[i][n+1]>=INF)ok=false;\n\t\t\t}\n\t\t\tcout << (ok?\"OK\":\"NG\")<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cmath>\n\ntypedef long long ll;\n#define fi first\n#define se second\n\nconst ll mod = 1000000007;\n//\t\t\t\t123456789\n\n\nusing namespace std;\n\nint n;\nint ans = 1;\nint MAX;\n\nint d[260];\nbool flag[260];\nint idx;\nint ch;\nqueue< int >q;\n\nint main(){\n  \n  int i;\n  int j;\n  \n  while( cin>>MAX,MAX ){\n  \tcin>>n;\n  \t//cout<<MAX<<endl;\n  \t//cout<<n<<endl;\n  \t\n  \tans = 1;\n  \t\n  \tfill( flag, flag+260, 1);\n  \t\n  \tfor( i = 0; i < n; i++ ){\n  \t\tscanf(\"%d\", d+i+1);\n  \t}\n  \t\n  \tq.push(0);\n  \tflag[0] = 0;\n  \t\n  \twhile( !q.empty() ){\n  \t\t\n  \t\tidx = q.front();\n  \t\n  \t\t//cout<<idx<<endl;\n  \t\t\n  \t\tint cnt = 0;\n  \t\t\n  \t\tfor( i = 1; i <= MAX; i++ ){\n  \t\t\t\n  \t\t\tch = idx+i;\n  \t\t\t//cout<<\"cccc\"<<ch<<endl;\n  \t\t\t//cout<<\"ccc\"<<d[ch]<<endl;\n  \t\t\tch += d[ch];\n  \t\t\t//cout<<\"cc\"<<ch<<endl;\n  \t\t\tif( ch < 0 ) ch = 0;\n  \t\t\t//cout<<idx<<\" \"<<ch<<endl;\n  \t\t\tif( ch > n ){\n  \t\t\t\tcnt++;\n  \t\t\t}\n  \t\t\tif( flag[ch] && ch <= n ){\n  \t\t\t\tcnt++;\n  \t\t\t\tq.push(ch);\n  \t\t\t\tflag[ch] = 0;\n  \t\t\t}\n  \t\t}\n  \t\t\n  \t\tif( cnt == 0 ){\n  \t\t\t//cout<<\"---\"<<idx<<endl;\n  \t\t\tans = 0;\n  \t\t\tbreak;\n  \t\t}\n  \t\t\n  \t\tq.pop();\n  \t}\n  \t\n  \twhile( !q.empty() ) q.pop();\n  \t\n  \t\n  \t\n  \t\n  \tif( ans ) puts(\"OK\");\n  \telse{     puts(\"NG\");}\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 252\nusing namespace std;\n\nint m,n,d[N],ans;\nbool dp[N];\n\nbool OK(int x){\n  bool r=false;\n  int c=x;\n  x+=d[x];\n  if(x<0&&dp[0]) r=true;\n  if(x>=n+1) r=true;\n  if(dp[x]) r=true;\n  if(r) dp[c]=true;\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m) break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    for(int i=0;i<=n;i++) dp[i]=false;\n    dp[n+1]=true;\n    while(1){\n      int f=0;\n      for(int i=n;i>=0;i--){\n\tfor(int j=1;j<=m;j++){\n\t  if(i+j>=n+1||OK(i+j)){\n\t    if(!dp[i]) f=1;\n\t    dp[i]=true;\n\t  }\n\t}\n      }\n      if(!f) break;\n    }\n    ans=0;\n    for(int i=0;i<=n;i++)\n      if(!dp[i]) ans=1;\n    if(ans) cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int> >G(252),R(252);\nint n,m;\nint d[552];\nbool u[252];\nvoid f(int v)\n{\n\tu[v]=1;\n\tfor(int i=0;i<R[v].size();i++)\n\t{\n\t\tif(!u[R[v][i]])f(R[v][i]);\n\t}\n}\nbool vi[252];\nbool ok(int v)\n{\n    bool ans=u[v];\n    vi[v]=1;\n    for(int i=0;i<G[v].size();i++)\n    {\n        if(!vi[G[v][i]])ans&=ok(G[v][i]);\n    }\n    return ans;\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<=n+1;i++)G[i].clear(),R[i].clear(),d[i]=vi[i]=u[i]=0;\n\t\tfor(int i=1;i<=n;i++)cin>>d[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m&&i+j<=n+1;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+d[i+j];\n\t\t\t\tif(k>n+1)k=n+1;\n\t\t\t\tif(k<0)k=0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n+1);u[0]=1;\n\t\tcout<<(ok(0)?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int max,n;\n  bool MAS[255][255];\n  while(1){\n    memset(MAS,false,sizeof(MAS));\n    cin >> max;\n    if(max==0)break;\n    cin >> n;\n    for(int j=1;j<=max;j++) MAS[0][j] = true;\n    for(int i=1,a;i<=n;i++){\n      cin >> a;\n      (i+a>n+1)? MAS[i][n+1] = true : MAS[i][i+a] = true;\n      for(int j=i+a;j<=max+i+a && n+1>=j;j++){\n\tMAS[i][j] = true;\n      }\n    }\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n\tfor(int k=0;k<n+2;k++){\n\t  if(MAS[j][i]&&MAS[i][k]){\n\t    MAS[j][k]=true;\n\t  }\n\t}\n      }\n    }\n    bool flg=false;\n    for(int i=0;i<=n;i++){\n      if(MAS[0][i]&&(!MAS[i][n+1])){\n\tcout << \"NG\" <<endl;\n\tflg=true;\n\tbreak;\n      }\n    }\n    if(!flg)cout << \"OK\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 256;\n\nint maxi;\nint n;\nint d[MAXN];\nint canGoal[MAXN];\n\nint nextPos(int pos, int m) {\n  int npos = min(pos + m, n-1);\n  npos += d[npos];\n  npos = min(npos, n-1);\n  npos = max(npos, 0);\n  return npos;\n}\n\nint rec(int pos) {\n  int &res = canGoal[pos];\n  if(res != -1) return res;\n  res = 0;\n  for(int m = 1; m <= maxi; ++m) {\n    if(rec(nextPos(pos, m))) {\n      return res = 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> maxi && maxi) {\n    cin >> n;\n    for(int i = 0; i < n; ++i) cin >> d[i+1];\n    n += 2;\n    d[0] = d[n-1] = 0;\n    fill(canGoal, canGoal+n, -1);\n    canGoal[n-1] = 1;\n    rec(0);\n    bool res = true;\n    for(int i = 0; i < n; ++i) {\n      if(canGoal[i] == 0) {\n\tres = false;\n\tbreak;\n      }\n    }\n    if(res) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,dmax;\nint m[300];\nbool visited[300], isVisit[300], isGoal;\nvoid dfs(int p){\n  if(visited[p])return ;\n  visited[p] = true;\n  isVisit[p] = true;\n  if(p == n+1){\n    isGoal = true;\n    return;\n  }\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;  \n    dfs(np);\n  }\n}\nvoid solve(){\n  fill(isVisit, isVisit+(n+2), false);\n  isVisit[0] = true;\n  for(int i = 0 ; i <= n; i++){\n    if(!isVisit[i])continue;\n    isGoal = false;\n    fill(visited, visited+(n+2), false);\n    dfs(i);\n    if(!isGoal)break;    \n  }\n  cout << (isGoal?\"OK\":\"NG\") << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    fill(m, m+(n+2), 0);\n    for(int i = 0 ; i < n ;i++){\n      cin >> m[i+1];\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int M;\n    while(cin >> M, M){\n        int n;\n        cin >> n;\n        vector<int> v(n);\n        for (auto &&i : v) scanf(\"%d\", &i);\n        vector<int> to(n+2);\n        to.back() = n+1;\n        for (int i = 0; i < n; ++i) {\n            if(v[i] < 0) to[i+1] = max(0, i+1+v[i]);\n            else to[i+1] = min(n+1, i+1+v[i]);\n        }\n        vector<vector<int>> dp(n+2, vector<int>(n+2, INF<int>));\n        for (int i = 0; i <= n; ++i) {\n            for (int j = 1; j <= M; ++j) {\n                int t = to[min(n+1, i+j)];\n                dp[i][t] = 1;\n            }\n        }\n        for (int k = 0; k <= n+1; ++k) {\n            for (int i = 0; i <= n+1; ++i) {\n                for (int j = 0; j <= n+1; ++j) {\n                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n                }\n            }\n        }\n        int ok = 1;\n        for (int i = 0; i <= n; ++i) {\n            if(dp[0][i] != INF<int> && dp[i][n+1] == INF<int>){\n                ok = 0;\n            }\n        }\n        puts(ok ? \"OK\" : \"NG\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nbool solve(int mx, int n, int order[])\n{\n\tqueue<int> search;\n\tqueue<int> back[252];\n\n\tint start[252];\n\tfor (int i = 0; i <= n + 1; i++) start[i] = false;\n\tstart[0] = true;\n\tsearch.push(0);\n\twhile (!search.empty()){\n\t\tint now = search.front();\n\t\tsearch.pop();\n\t\tfor (int i = 1; i <= mx; i++){\n\t\t\tint next;\n\t\t\tif (now + i <= 0) continue;\n\t\t\telse if (now + i > n + 1) next = n + 1;\n\t\t\telse if (now + i + order[now + i] <= 0) continue;\n\t\t\telse if (now + i + order[now + i] > n + 1) next = n + 1;\n\t\t\telse next = now + i + order[now + i];\n\t\t\tback[next].push(now);\n\t\t\tif (start[next]) continue;\n\t\t\tstart[next] = true;\n\t\t\tsearch.push(next);\t\t\t\n\t\t}\n\t}\n\tif (!start[n + 1]) return false;\n\t\n\tint goal[252];\n\tfor (int i = 0; i <= n + 1; i++) goal[i] = false;\n\tgoal[n + 1] = true;\t\n\tsearch.push(n + 1);\n\twhile (!search.empty()){\n\t\tint now = search.front();\n\t\tsearch.pop();\n\t\twhile (!back[now].empty()){\n\t\t\tint from = back[now].front();\n\t\t\tback[now].pop();\n\t\t\tif (goal[from]) continue;\n\t\t\tgoal[from] = true;\n\t\t\tsearch.push(from);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n + 1; i++){\n\t\tif (start[i] && !goal[i]) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile (true){\n\t\tint mx;\n\t\tcin >> mx;\n\t\tif (!mx) break;\n\t\tint n, order[252];\n\t\tcin >> n;\n\t\torder[0] = order[n + 1] = 0;\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tcin >> order[i];\n\t\t}\n\t\tif (solve(mx, n, order)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 252\nusing namespace std;\n\nint m,n,d[N],ans;\nbool dp[N],o[N];\n\nbool OK(int x){\n  bool r=false;\n  x+=d[x];\n  if(x<0&&dp[0]) r=true;\n  if(x>=n+1) r=true;\n  if(dp[x]) r=true;\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m) break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    for(int i=0;i<=n;i++) dp[i]=false;\n    dp[n+1]=true;\n    o[0]=true;\n    while(1){\n      int f=0;\n      for(int i=0;i<=n;i++){\n\tif(!o[i]) continue;\n\tfor(int j=1;j<=m;j++){\n\t  int nx=i+j;\n\t  if(nx>=n+1) continue;\n\t  nx=nx+d[nx];\n\t  if(nx>=n+1||nx<0) continue;\n\t  if(!o[nx]) f=1;\n\t  o[nx]=true;\n\t}\n      }\n      if(!f) break;\n    }\n    while(1){\n      int f=0;\n      for(int i=n;i>=0;i--){\n\tif(dp[i]||!o[i]) continue;\n\tfor(int j=1;j<=m;j++){\n\t  if(i+j>=n+1||OK(i+j)){\n\t    dp[i]=true;\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n      if(!f) break;\n    }\n    for(int i=0;i<=n;i++)\n      if(!o[i]) dp[i]=true;\n    ans=0;\n    for(int i=0;i<=n;i++)\n      if(!dp[i]) ans=1;\n    if(ans) cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll m,n;\n  while(cin >> m &&m){\n    cin >> n;\n    vary(ll,v,n,0);\n    rep(i,n){\n      cin >> v[i];\n    }\n    bool ans = true;\n    rep(x,n){\n      vary(bool,dp,n+m+1,false);\n      dp[0] = true;\n      int s = x+1;\n      if(s < 0) s = 0;\n      if(s > n) dp[s] = true;\n      if(s > 0 && s <= n){\n        s += v[s-1];\n      }\n      if(s < 0) s = 0;\n      dp[s] = true;\n      if(s)\n        dp[0] = false;\n      rep(y,255){\n        rep(i,n+1){\n          rep(j,m){\n            int s = j+1 + i;\n            if(s < 0) s = 0;\n            if(s > n) dp[s] = dp[s] | dp[i];\n            if(s > 0 && s <= n){\n              s += v[s-1];\n            }\n            if(s < 0) s = 0;\n//             cout << i << ',' << s << endl;\n            dp[s] = dp[i] | dp[s];\n          }\n        }\n      }\n      bool f = false;\n      REP(i,n,n+m+1){\n        f |= dp[i];\n      }\n      ans = ans & f;\n    }\n    if(ans){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint M, n, d[252];\nbool visited[252];\n\nbool rec(int start) {\n    bool ok = false;\n    if(start<0) return false;\n    if(n+1<start) return true;\n    if(visited[start]) return false;\n\n    visited[start] = true;\n    for(int i=1; i<=M; i++) {\n        ok |= rec(start + i + d[start+i]);\n    }\n    return ok;\n}\n\nint main()\n{\n    while(cin>>M, M) {\n        int ok = 0;\n        cin>>n;\n        for(int i=1; i<=n; i++) {\n            cin>>d[i];\n            visited[i] = false;\n        }\n        if(rec(0)) cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint m, n, d[509], e[259]; bool canvis[259], vis[259];\nint main() {\n\twhile (cin >> m, m) {\n\t\tcin >> n;\n\t\tfill(d, d + 505, 0);\n\t\tfor (int i = 1; i <= n; i++) cin >> d[i];\n\t\tfor (int i = 0; i < 505; i++) {\n\t\t\tint p = i + d[i];\n\t\t\tp = min(p, n + 1);\n\t\t\tp = max(p, 0);\n\t\t\te[i] = p;\n\t\t}\n\t\tqueue<int> que1; que1.push(0);\n\t\tfill(canvis, canvis + 505, false); canvis[0] = true;\n\t\twhile (!que1.empty()) {\n\t\t\tint u = que1.front(); que1.pop();\n\t\t\tfor (int i = 1; i <= m; i++) {\n\t\t\t\tint t = e[u + i];\n\t\t\t\tif (!canvis[t]) {\n\t\t\t\t\tcanvis[t] = true;\n\t\t\t\t\tque1.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ret = true;\n\t\tfor (int i = 0; i <= n + 1; i++) {\n\t\t\tif (!canvis[i]) continue;\n\t\t\tfill(vis, vis + 505, false); vis[i] = true;\n\t\t\tqueue<int> que2; que2.push(i);\n\t\t\twhile (!que2.empty()) {\n\t\t\t\tint u = que2.front(); que2.pop();\n\t\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\t\tint t = e[u + j];\n\t\t\t\t\tif (!vis[t]) {\n\t\t\t\t\t\tvis[t] = true;\n\t\t\t\t\t\tque2.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[n + 1]) ret = false;\n\t\t}\n\t\tcout << (ret ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n#define ALL(co) co.begin(), co.end()\n#define tpl(...) make_tuple(__VA_ARGS__)\n\ntypedef long long LL;\ntypedef pair<int, int> P; typedef pair<int, P> IP; typedef pair<P, P> PP;\ntypedef vector<int> Array; typedef vector<vector<int> > Array2;\ntypedef vector<LL> LArray; typedef vector<P> PArray; typedef vector<string> SArray;\n\nconst int INF = 1 << 29;\nconst LL LINF = 1LL << 60;\n\ninline int getInt() { int itiv; return (cin >> itiv, itiv); }\ntemplate <typename T> void readAll(vector<T>& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i]; }\ntemplate <typename T, typename U> void readAll(vector<pair<T, U> >& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i].first >> vec[i].second; }\ntemplate < typename T > inline string toString( const T &a ){ ostringstream oss; oss << a; return oss.str(); };\ninline bool between(int min, int max, int n) { return min <= n && n <= max; }\ninline bool inRange(int begin, int end, int n) { return begin <= n && n < end; }\ninline bool inRange(int size, int n) { return 0 <= n && n < size; }\n\nint dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\nint dr[] = { 0, -1, 0, 1 }, dc[] = { -1, 0, 1, 0 };\n\n\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\tint n, mx;\n\twhile(cin >> mx && mx)\n\t{\n\t\tcin >> n;\n\t\tArray arr(n + mx + 1);\n\t\tArray2 graph(n + mx + 1, Array());\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tarr[i + 1] = getInt();\n\t\t}\n\n\t\tfor (int i = 0; i < n + 2; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= mx; j++)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(max(i + j + arr[i + j], 0));\n\t\t\t}\n\t\t}\n\n\t\tvector<bool> visited(n + mx + 1);\n\t\tfunction<bool(int)> dfs = [&](int x){\n\t\t\tif(x >= n + 2) return true;\n\t\t\t\n\t\t\tvisited[x] = true;\n\t\t\tfor(auto nx : graph[x])\n\t\t\t{\n\t\t\t\tif(visited[nx]) continue;\n\t\t\t\tif(dfs(nx)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tcout << (dfs(0) ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={},o[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    /*\n    for(i=1;i<=n;i++){\n      p=i;\n      bool vi[300]={};\n      bool f=false;\n      while(d[p]!=0){\n\tp+=d[p];\n\tif(vi[p]){\n\t  f=true;\n\t  break;\n\t}\n\tif(p<0) p=0;\n\tif(p>n+1) p=n+1;\n\tvi[p]=true;\n      }\n      if(f) o[i]=-1;\n      else o[i]=p;\n    }\n    */\n    o[n+1]=n+1;\n    fill(used,used+300,false);\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q;\n    for(int k=0;k<=n;k++){\n      q.push(k);\n      fill(used,used+300,false);\n      while(!q.empty()){\n\tp=q.front();q.pop();\n\t//cout << p << endl;\n\t//p=o[p];\n\tif(used[p]) continue;\n\tused[p]=true;\n\tr[p]=true;\n\tfor(i=1;i<=m;i++){\n\t  if(p+i+d[p+i]>n+1){\n\t    used[n+1]=true;\n\t    break;\n\t  }else q.push(p+i+d[p+i]);\n\t}\n      }\n      g[k]=used[n+1];\n    }\n    bool c=true;\n    for(i=0;i<=n;i++){\n      if(r[i]&&!g[i]) c=false;\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\nint d[252];\nint dp[252][252];\nint Max;\nint n;\nint main() {\n\twhile(scanf(\"%d\",&Max),Max) {\n\t\tscanf(\"%d\",&n);\n\t\td[0]=d[n+1]=0;\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=0;i<n+2;i++) {\n\t\t\tfor(int j=1;j<=Max;j++) {\n\t\t\t\tint p;\n\t\t\t\tp=min(i+j,n+1);\n\t\t\t\tp+=d[p];\n\t\t\t\tp=min(max(p,0),n+1);\n\t\t\t\tdp[i][p]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n+2;k++) {\n\t\t\tfor(int i=0;i<n+2;i++) {\n\t\t\t\tfor(int j=0;j<n+2;j++) {\n\t\t\t\t\tif(dp[i][k]&&dp[k][j]) dp[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool OK=1;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tfor(int j=0;j<=n;j++) {\n\t\t\t\tif(dp[i][j]&&!dp[j][n+1]) {\n\t\t\t\t\tOK=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!OK) break;\n\t\t}\n\t\tif(OK) printf(\"OK\\n\"); else printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m;\nint d[555];\nbool u[555];\nbool f(int v)\n{\n\tif(v>=n)return true;\n\telse if(v>=0&&!u[v])return 0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(v+i+d[v+i]>=n)continue;\n\t\tif(!u[v+i+d[v+i]]||!f(v+i+d[v+i]))\n\t\t{\n\t\t\tif(v>=0)u[v]=0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(v>=0)u[v]=1;\n\treturn u[v]=1;\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<555;i++)u[i]=1,d[i]=0;\n\t\tfor(int i=0;i<n;i++)cin>>d[i];\n\t\tbool flag=0;\n\t\tfor(int i=n-1;i>=-1;i--)\n\t\t{\n\t\t\tbool ok=0;\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tok|=i+j+d[i+j]>i;\n\t\t\t}\n\t\t\tif(i>=0)u[i]=ok;\n\t\t\telse flag=ok;\n\t\t\tif(ok)\n\t\t\t{\n\t\t\t\tbool ng=0;\n\t\t\t\tfor(int j=1;j<=m;j++)if(i+j+d[i+j]>i)ng|=!u[i+j+d[i+j]];\n\t\t\t\tif(i>=0)u[i]=!ng;\n\t\t\t\telse flag=!ng;\n\t\t\t}\n\t\t}\n\t\tcout<<(flag?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Max, N, d[252];\nbool graph[252][252], rgraph[252];\n\n\nmain()\n{\n\n  while(cin >> Max, Max) {\n    fill_n(d, 252, 0);\n    fill_n(*graph, 252 * 252, false);\n\n    cin >> N;\n    for(int i = 1; i <= N; i++) {\n      cin >> d[i];\n    }\n    for(int i = 0; i <= N; i++) {\n      for(int j = 1; j <= Max; j++) {\n        int next = max(0, min(N + 1, i + j + d[min(N + 1, i + j)]));\n        graph[i][next] = true;\n      }\n    }\n    for(int i = 0; i <= N + 1; i++) {\n      for(int j = 0; j <= N + 1; j++) {\n        for(int k = 0; k <= N + 1; k++) {\n          graph[j][k] |= graph[j][i] & graph[i][k];\n        }\n      }\n    }\n    bool flag = true;\n    for(int i = 0; i < N + 1; i++) {\n      if(graph[0][i] && !graph[i][N + 1]) flag = false;\n    } \n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint maxi, n;\nint d[256];\nbool mas[256];\n\nvector< vector<int> > G(256);\n\nvoid dfs1(int x)\n{\n  if(mas[x]) return;\n  mas[x] = true;\n  for(int i = 1; i <= maxi; i++){\n    dfs1(max(0, min(x + i + d[max(0, min(x + i, n+1))], n+1)));\n    G[max(0, min(x + i + d[max(0, min(x + i, n+1))], n+1))].push_back(x);\n  }\n}\n\nvoid dfs2(int x)\n{\n  if(!mas[x]) return;\n  mas[x] = false;\n  //if(d[x] != 0) return;\n  for(int i = 0; i < G[x].size(); i++){\n    dfs2(G[x][i]);\n  }\n}\n\nbool check()\n{\n  for(int i = 1; i <= n; i++){\n    if(mas[i]) return false;\n  }\n  return true;\n}\n\nint main()\n{\n  while(cin >> maxi, maxi){ \n    cin >> n;\n    G.clear(); G.resize(n + 2);\n    memset(mas, false, sizeof(mas));\n    memset(d, 0, sizeof(d));\n    for(int i = 1; i <= n; i++) cin >> d[i];\n    dfs1(0);\n    if(check() || !mas[n+1]) cout << \"NG\" << endl;\n    else {\n      dfs2(n+1);\n      cout << (check() ? \"OK\" : \"NG\") << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<bitset>\n#include<vector>\nusing namespace std;\n\n\n\nint main()\n{\nint n,mex;\n  while(cin >> mex,mex)\n    {\n      cin >> n;\n      vector<int> G(n);\n      int out[n];\n      for(int i=0;i<n;i++)\n\t{\n\t  cin >> G[i];\n\t  out[i] = 0;\n\t}\n\n\n      for(int i=0;i<n;i++)\n\tif(G[i] < 0)\n\t  for(int j=i;j>i-mex && j >= 0;j--)\n\t    {\n\t      out[j]++;\n\t    }\n\n      for(int i=0;i<n;i++)\n\t{\n\t  if(out[i] >= mex)\n\t    {\n\t      cout << \"NG\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"OK\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint main(){\n\t#define MAX_N 250\n\tint m, n, d[MAX_N + 2];\n\tbool reach;\n\t\n\twhile(1){\n\t\tfill(d, d + MAX_N + 2, 0);\n\t\tscanf(\"%d\", &m);\n\t\tif(m == 0) return 0;\n\t\tscanf(\"%d\", &n);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", d + i);\n\t\t}\n\t\t\n\t\treach = true;\n\t\tfor(int i = 0; i <= n - m + 1; i++){\n\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\tif(d[i + j] > -j) break;\n\t\t\t\tif(j == m) reach = false;\n\t\t\t}\n\t\t\tif(!reach){\n\t\t\t\tprintf(\"NG\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(reach) printf(\"OK\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mas[300];\nint memo[300];\nint memomemo[300];\n\nint Max;\nint n;\n\nvoid dfs(int i){\n  if(i < 0) i = 0;\n  if(i >= n) i = n-1;\n  if(memo[i] != 0) return;\n  memo[i] = 1;\n  for(int j = 1;j <= Max;j++){\n    int tmp = i+j;\n    if(i+j < n) tmp += mas[i+j];\n    dfs(tmp);\n  }\n\n  return;\n}\n\nint main(){\n  while(1){\n    cin >> Max;\n    if(Max == 0) break;\n    cin >> n;\n    for(int i = 0;i < n;i++) scanf(\"%d\",&mas[i+1]);\n    n += 2;\n\n    memomemo[0] = 1;\n    int i;\n    for(i = 0;i < n;i++){\n      if(memomemo[i] == 1){\n        for(int x = 0;x < 300;x++) memo[x] = 0;\n        dfs(i);\n        if(memo[n-1] == 0){\n          break;\n        }\n        for(int x = i;x < 300;x++) memomemo[x] |= memo[x];\n      }\n    }\n    if(i < n) cout << \"NG\" << endl; else cout << \"OK\" << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nqueue<int> q;\n\nbool t[252];\nint d[252];\n\nint maxw;\n\nint n;\n\nvoid tw(int a)\n{\n\tif(a < 0)\n\t{\n\t\tif(!t[0])\n\t\t{\n\t\t\tt[0] = true;\n\t\t\tq.push(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!t[a])\n\t\t{\n\t\t\tt[a] = true;\n\t\t\tq.push(a);\n\t\t}\n\t}\n}\n\nvoid tou(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttw(a - i);\n\t}\n}\n\nvoid syo(int a)\n{\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(i + d[i] == a)\n\t\t{\n\t\t\ttou(a);\n\t\t}\n\t}\n}\n\nvoid init()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt[i] = false;\n\t}\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\tif(n + 1 - i >= 0)\n\t\t{\n\t\t\tt[n + 1 - i] = true;\n\t\t\tq.push(n + 1 - i);\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(d[i] + i >= n + 1)\n\t\t{\n\t\t\ttou(i);\n\t\t}\n\t}\n}\n\nvoid modo()\n{\n\tinit();\n\twhile(!q.empty())\n\t{\n\t\tint w = q.front();\n\t\tq.pop();\n\t\tsyo(w);\n\t}\n}\n\nqueue<int> q2;\n\nbool t2[252];\n\nvoid tw2(int a)\n{\n\tif(a > n + 1)\n\t{\n\t\tif(!t2[n + 1])\n\t\t{\n\t\t\tt2[n + 1] = true;\n\t\t\tq2.push(n + 1);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!t2[a])\n\t\t{\n\t\t\tt2[a] = true;\n\t\t\tq2.push(a);\n\t\t}\n\t}\n}\n\nvoid tou2(int a)\n{\n\ttw2(a + d[a]);\n}\n\nvoid syo2(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttou2(a + 1);\n\t}\n}\n\nvoid init2()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt2[i] = false;\n\t}\n\tq.push(0);\n\tt2[0] = true;\n}\n\nvoid modo2()\n{\n\tinit2();\n\twhile(!q2.empty())\n\t{\n\t\tint w = q2.front();\n\t\tq2.pop();\n\t\tsyo2(w);\n\t}\n}\n\nbool can()\n{\n\tif(!t2[n + 1])\n\t{\n\t\treturn false;\n\t}\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tif(t2[i])\n\t\t{\n\t\t\tif(!t[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&maxw);\n\t\tif(maxw == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\td[0] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\",d + i);\n\t\t}\n\t\td[n + 1] = 0;\n\t\tmodo();\n\t\tmodo2();\n\t\tif(can())\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mas[300];\nint memo[300];\n\nint Max;\nint n;\n\nvoid dfs(int i){\n  if(i < 0) i = 0;\n  if(i >= n) i = n-1;\n  if(memo[i] != 0) return;\n  memo[i] = 1;\n  for(int j = 1;j <= Max;j++){\n    int tmp = i+j;\n    if(i+j < n) tmp += mas[i+j];\n    dfs(tmp);\n  }\n\n  return;\n}\n\nint main(){\n  while(1){\n    cin >> Max;\n    if(Max == 0) break;\n    cin >> n;\n    for(int i = 0;i < n;i++) scanf(\"%d\",&mas[i+1]);\n    n += 2;\n\n    for(int i = 0;i < n;i++){\n      for(int x = 0;x < 300;x++) memo[x] = 0;\n      dfs(i);\n      if(memo[n-1] == 0){\n        cout << \"NG\" << endl;\n        break;\n      }\n      if(i == n-1) cout << \"OK\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nint main(){\n  while(true){\n    int mx,n;\n    cin>>mx;\n    if(!mx)break;\n    cin>>n;\n    vi d(n+2);\n    d[0] = 0;\n    d[n+1] = 0;\n    REP(i,n) cin>>d[i+1];\n    vi edges[n+2];\n    vi revedges[n+2];\n    // 0: begin\n    // 1~n: land\n    // n+1: end\n    vector<bool> used(n+2,false);\n    queue<int> Q;\n    Q.push(0);\n    used[0] = true;\n    while(Q.size()){\n      ll t = Q.front(); Q.pop();\n      FOR(to,t+1,min<ll>(t+mx,n+1)+1){\n        // to position to\n        ll nxt = to + d[to];\n        nxt = max<ll>(0,min<ll>(n+1,nxt));\n        if(t == nxt)continue;\n        edges[t].push_back(nxt);\n        revedges[nxt].push_back(t);\n        if(used[nxt])continue;\n        if(nxt == n+1)continue;\n        used[nxt] = true;\n        Q.push(nxt);\n      }\n    }\n    set<int> jun,gyaku;\n    Q.push(0);\n    jun.insert(0);\n    while(Q.size()){\n      int t = Q.front(); Q.pop();\n      REP(i,edges[t].size()){\n        int nxt = edges[t][i];\n        if(jun.count(nxt))continue;\n        jun.insert(nxt);\n        Q.push(nxt);\n      }\n    }\n    Q.push(n+1);\n    gyaku.insert(n+1);\n    while(Q.size()){\n      int t = Q.front(); Q.pop();\n      REP(i,revedges[t].size()){\n        int nxt = revedges[t][i];\n        if(gyaku.count(nxt))continue;\n        gyaku.insert(nxt);\n        Q.push(nxt);\n      }\n    }\n    if(jun == gyaku){\n      cout<<\"OK\"<<endl;\n    }else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mas[300];\nint memo[300];\nint isGorl[300];\n\nint Max;\nint n;\n\nvoid dfs(int i){\n  if(i < 0) i = 0;\n  if(i >= n) i = n-1;\n  if(memo[i] != 0) return;\n  memo[i] = 1;\n  for(int j = 1;j <= Max;j++){\n    int tmp = i+j;\n    if(i+j < n) tmp += mas[i+j];\n    dfs(tmp);\n  }\n\n  return;\n}\n\nbool flag;\n\nvoid gorldfs(int i){\n  if(i < 0) i = 0;\n  if(i >= n) i = n-1;\n  if(memo[i] != 0) return;\n  if(isGorl[i] == 0){\n    flag = true;\n  }\n  memo[i] = 1;\n  for(int j = 1;j <= Max;j++){\n    int tmp = i+j;\n    if(tmp < n) tmp += mas[tmp];\n    gorldfs(tmp);\n  }\n\n  return;\n}\n\nint main(){\n  while(1){\n    flag = false;\n\n    cin >> Max;\n    if(Max == 0) break;\n    cin >> n;\n    for(int i = 0;i < n;i++) scanf(\"%d\",&mas[i+1]);\n    n += 2;\n\n    int i;\n    for(i = n-1;i >= 0;i--){\n      for(int x = 0;x < 300;x++) memo[x] = 0;\n      dfs(i);\n      if(memo[n-1] == 1){\n        isGorl[i] = 1;\n      }else{\n        isGorl[i] = 0;\n      }\n    }\n\n    for(int x = 0;x < 300;x++) memo[x] = 0;\n    gorldfs(0);\n    if(flag) cout << \"NG\" << endl; else cout << \"OK\" << endl;\n  }\n\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \nconst INF = 1 << 22;\nint main()\n{\n    int Max,n;\n    while(cin >> Max, Max){\n        int map[252] = {};\n        int dist[252][252];\n        cin >> n;\n        for(int i = 1; i <= n; ++i){\n            cin >> map[i];   \n        }\n        fill((int*)dist,(int*)(dist + n + 2),INF);\n        queue<int> q;\n        q.push(0);\n        while(!q.empty()){\n            int x = q.front(); q.pop();\n            for(int i = 1; i <= Max; ++i){\n                int nx = x + i;\n                if(nx >= n + 1){\n                    dist[x][nx] = 1;\n                } else {\n                    int t = nx;\n                    nx += map[t];\n                    if(nx >= n + 1){\n                        dist[x][n + 1] = 1;\n                    } else if(nx <= 0){\n                        dist[x][0] = 1;\n                    } else if(dist[x][nx] == INF){\n                        dist[x][nx] = 1;\n                        q.push(nx);\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < n + 2; ++i){\n            dist[i][i] = 0;\n        }\n        for(int k = 0; k < n + 2; ++k){\n            for(int i = 0; i < n + 2; ++i){\n                for(int j = 0; j < n + 2; ++j){\n                    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        \n        bool f = false;\n        for(int i = 0; i < n + 1; ++i){\n            if(dist[0][i] != INF && dist[i][n + 1] == INF){\n                cout << \"NG\" << endl;\n                f = true;\n                break;\n            }\n        }\n        if(!f){\n            cout << \"OK\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mass[252];\n\nint m,n;\n\nint table[252][252];\n\nint main() {\n\n    while(1){\n\n        cin >> m;\n\n        if(m==0) break;\n\n        cin >> n;\n\n        mass[0] = 0;\n        mass[n+1] = 500;\n\n        for(int i=1;i<=n;i++){\n            cin >> mass[i];\n        }\n\n        for(int i=0;i<=n+1;i++){\n            for(int j=0;j<=n+1;j++){\n                table[i][j] = -1;\n            }\n        }\n\n        for(int i=0;i<n+1;i++){\n            for(int j=1;j<=m;j++){\n                int next = i+j+mass[i+j];\n                if(next<0) next = 0;\n                if(next>n+1) next = n+1;\n                table[i][next] = 1;\n                //vec[i].push_back(next);\n            }\n        }\n\n        for(int k=0;k<n+2;k++){\n            for(int i=0;i<n+2;i++){\n                for(int j=0;j<n+2;j++){\n                    if(table[i][k] != -1 && table[k][j] != -1)\n                    table[i][j] = 1;\n                }\n            }\n        }\n\n        bool flag = true;\n\n        for(int i=0;i<=n;i++){\n            if(table[0][i]!=-1 && table[i][n+1] == -1){\n                flag = false;\n                break;\n            }\n        }\n\n        if(flag){\n            cout << \"OK\" << endl;\n        }\n        else{\n            cout << \"NG\" << endl;\n        }\n\n\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\n//再帰flag変数\nbool flag_sugoroku[251] = {false};\n\n//入力配列\nint h_input[251] = {0};\n\n//入力変数\nint n = 0;\n//マスの数\nint masu = 0;\n\t\n\n//-- flag初期化関数 --//\n\nvoid f_syokika();\n\n\n//-- 再起関数 --//\n\nbool f_saiki(int , int);\n\n\n\nint main(void)\n{\n\twhile (cin >> n && n != 0)\n\t{\n\t\tcin >> masu;\n\t\t//成功flag\n\t\tbool ok = false;\n\n\t\tfor (int i = 0; i < masu; i++)\n\t\t{\n\t\t\tcin >> h_input[i];\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\t//必ず初期化が必要\n\t\t\tf_syokika();\n\t\t\tif (f_saiki(i , h_input[i]) == true)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\t\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n\n//*****----- flag初期化関数 -----*****//\n\nvoid f_syokika()\n{\n\tfor (int i = 0; i < 251; i++)\n\t{\n\t\tflag_sugoroku[i] = false;\n\t}\n}\n\n\n//*****----- 再起関数 -----*****//\n\nbool f_saiki(int index , int genzaiti)\n{\n\tif (index >= masu)\n\t{\n\t\treturn false;\n\t}\n\n\t//振り出しはいらない\n\tif (genzaiti < 0)\t{\treturn false;\t}\n\n\t//マスを超えていたらOK\n\tif (genzaiti >= masu)\t{\treturn true;\t}\n\n\t//既にきているなら駄目\n\tif (flag_sugoroku[genzaiti] == true)\n\t{\n\t\treturn true;\n\t}\n\n\t//現在地に到達\n\tflag_sugoroku[genzaiti] = true;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tf_saiki(index + 1 , genzaiti + h_input[i]);\n\t}\n\n\t//来てないことにする\n\tflag_sugoroku[genzaiti] = false;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nusing int64 = long long;\n\ntemplate<typename T>\nusing p_que = priority_queue<T>;\ntemplate<typename T>\nusing rp_que = priority_queue<T, vector<T>, greater<T>>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr int64 INF64 = (1ll << 60) - 1;\n\n#define rep(i, N) for(int i=0;i<(int)(N);++i)\n#define fs first\n#define sc second\n#define e_b emplace_back\n#define m_p make_pair\n#define all(x) x.begin(),x.end()\n#define rall(x) x.rbegin(),x.rend()\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\treturn os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos << \"[\";\n\tfor (auto& e : v) os << e << \", \";\n\treturn os << \"]\";\n}\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& m) {\n\tos << \"{\" << endl;\n\tfor (auto& e : m) os << \"(\" << e.first << \", \" << e.second << \")\" << endl;\n\treturn os << \"}\";\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const set<T>& s) {\n\tos << \"{\" << endl;\n\tfor (auto& e : s) os << \", \" << e << endl;\n\treturn os << \"}\";\n}\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nint64 gcd(int64 x, int64 y) {\n\tif (x == 0 || y == 0) return 0;\n\tint64 r;\n\twhile ((r = y % x) != 0) {\n\t\ty = x;\n\t\tx = r;\n\t}\n\treturn x;\n}\nint64 lcm(int64 x, int64 y) {\n\tif (x == 0 || y == 0) return 0;\n\treturn x / gcd(x, y) * y;\n}\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nvoid Main();\nsigned main() {\n\tcin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(30);\n\tMain();\n}\n\n/*----------------------------Insert from here!----------------------------*/\n\ntemplate <int mod>\nstruct ModInt {\n\tint x;\n\n\tModInt() : x(0) {}\n\n\tModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n\tModInt& operator+=(const ModInt& p) {\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt& operator-=(const ModInt& p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt& operator*=(const ModInt& p) {\n\t\tx = (int)(1LL * x * p.x % mod);\n\t\treturn *this;\n\t}\n\n\tModInt& operator/=(const ModInt& p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\n\tModInt operator-() const { return ModInt(-x); }\n\n\tModInt operator+(const ModInt& p) const { return ModInt(*this) += p; }\n\n\tModInt operator-(const ModInt& p) const { return ModInt(*this) -= p; }\n\n\tModInt operator*(const ModInt& p) const { return ModInt(*this) *= p; }\n\n\tModInt operator/(const ModInt& p) const { return ModInt(*this) /= p; }\n\n\tbool operator==(const ModInt& p) const { return x == p.x; }\n\n\tbool operator!=(const ModInt& p) const { return x != p.x; }\n\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\n\tModInt pow(int64_t n) const {\n\t\tModInt ret(1), mul(x);\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) ret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const ModInt& p) {\n\t\treturn os << p.x;\n\t}\n\n\tfriend istream& operator>>(istream& is, ModInt& a) {\n\t\tint64_t t;\n\t\tis >> t;\n\t\ta = ModInt< mod >(t);\n\t\treturn (is);\n\t}\n\n\tstatic int get_mod() { return mod; }\n};\n\ntemplate <typename T>\nstruct Edge {\n\tint from, to;\n\tT cost;\n\n\tEdge() : from(0), to(0), cost(0) {}\n\tEdge(int to, T cost) : from(-1), to(to), cost(cost) {}\n\tEdge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\tEdge& operator=(const int& x) {\n\t\tto = x;\n\t\treturn *this;\n\t}\n};\n\ntemplate <typename T>\nusing Edges = vector<Edge<T>>;\ntemplate <typename T>\nusing wGraph = vector<Edges<T>>;\n\n/* Function from here! */\n\ntemplate <typename T>\nvector<T> dijkstra(wGraph<T>& g, int s) {\n\tconst auto INF = numeric_limits<T>::max();\n\tvector<T> dist(g.size(), INF);\n\n\tusing P = pair<T, int>;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tdist[s] = 0;\n\tque.emplace(dist[s], s);\n\twhile (!que.empty()) {\n\t\tT cost;\n\t\tint idx;\n\t\ttie(cost, idx) = que.top();\n\t\tque.pop();\n\t\tif (dist[idx] < cost) continue;\n\t\tfor (auto& e : g[idx]) {\n\t\t\tT next_cost = cost + e.cost;\n\t\t\tif (dist[e.to] <= next_cost) continue;\n\t\t\tdist[e.to] = next_cost;\n\t\t\tque.emplace(dist[e.to], e.to);\n\t\t}\n\t}\n\n\treturn dist;\n}\n\n/*----------------------------Insert above here----------------------------*/\n\nvoid Main() {\n\tint max, n;\n\twhile (true) {\n\t\tcin >> max;\n\t\tif (max == 0) break;\n\t\tcin >> n;\n\n\t\tvector<int> d(n + 2);\n\t\tfor (int i = 1; i <= n; ++i) cin >> d[i];\n\n\t\twGraph<int> G(n + 2);\n\t\tvector<int> used(n + 2);\n\t\tstack<int> stk;\n\t\tstk.emplace(0);\n\t\twhile (!stk.empty()) {\n\t\t\tint idx = stk.top(); stk.pop();\n\t\t\tif (used[idx]) continue;\n\t\t\tused[idx] = 1;\n\t\t\tfor (int i = 1; i <= max; ++i) {\n\t\t\t\tint next = idx + i;\n\t\t\t\tif (next >= n + 2) break;\n\t\t\t\tnext += d[next];\n\t\t\t\tif (next >= n + 2) next = n + 1;\n\t\t\t\telse if (next < 0) next = 0;\n\t\t\t\tG[idx].emplace_back(next, 1);\n\n\t\t\t\tif (used[next]) continue;\n\t\t\t\tstk.emplace(next);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i=0; i<n+1; ++i) {\n\t\t\tcout << i << \" \";\n\t\t\tfor (auto& k : G[i]) cout << k.to << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t\tfor (int i = 0; i < n + 1; ++i) {\n\t\t\tif (!used[i]) continue;\n\t\t\tauto d = dijkstra(G, i);\n\t\t\tif (d[n + 1] == numeric_limits<int>::max()) {\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t\tgoto LABEL;\n\t\t\t}\n\t\t}\n\t\tcout << \"OK\" << endl;\n\tLABEL:\n\t\t;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint main(void){\n  int roulette;\n  while(cin >> roulette, roulette){\n    int n;\n    cin >> n;\n    vector<signed int> d(n+2);\n    REP(i,n){\n      cin >> d[i+1];\n    }\n\n    vector<bool>loop(n+2, false);\n\n    loop[0] = true;\n\n    REP(asdf, 3){\n      for(int pos = 0; pos < n+2; pos++){\n        if(loop[pos] == false) continue;\n        for(int r = 1; r <= roulette; r++){\n          int npos = pos + r + d[pos+r];\n          npos = max(0, min(n+2-1, npos));\n          loop[npos] = true;\n        }\n      }\n    }\n\n    bool flg;\n    REP(i,n+2){\n      if(loop[i] == false) continue;\n      flg = false;\n      REP(j, roulette){\n        int delta = j+1;\n        if(!(d[i+delta] <= -delta)) flg = true;\n      }\n      if(flg == false){\n        break;\n      }\n    }\n    if(flg) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int mx; cin >> mx && mx;) {\n\t\tint n;\n\t\tcin >> n;\n\t\t++n;\n\n\t\tvector<int> d(n);\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tcin >> d[i];\n\t\t}\n\n\t\tqueue<int> que;\n\t\tvector<bool> visited(n, false);\n\n\t\tque.push(0);\n\t\tvisited[0] = true;\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int pos = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor(int i = 1; i <= mx; ++i) {\n\t\t\t\tif(pos + i >= n) break;\n\t\t\t\tconst int to = pos + i + d[pos + i];\n\t\t\t\tif(to <= 0) continue;\n\t\t\t\tif(!visited[to]) {\n\t\t\t\t\tvisited[to] = true;\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = true;\n\t\tfor(int pos = 0; pos < n; ++pos) {\n\t\t\tfor(int i = 1; i <= mx; ++i) {\n\t\t\t\tif(pos + i >= n) goto next;\n\t\t\t\tconst int to = pos + i + d[pos + i];\n\t\t\t\tif(to > pos) goto next;\n\t\t\t}\n\n\t\t\tok = false;\n\t\t\tbreak;\n\n\t\tnext:;\n\t\t}\n\n\t\tcout << (ok ? \"OK\" : \"NG\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nint M, N;\nint D[510];\n\nint memo[510];\n\nint calc(int n){\n\tif(memo[n] != -1) return memo[n];\n\tmemo[n] = 0;\n\tfor(int i = 1; i<= M; i++){\n\t\tif(n +i > N || n + i + D[n+i] > N) memo[n] = 1;\n\t\tmemo[n] = max(memo[n], calc(max(n+i+D[n+i], 0)));\n\t}\n\treturn memo[n];\n}\n\nint main(){\n\twhile(cin>>M && M > 0) {\n\t\tcin>>N;\n\t\trep(i, 510) memo[i] = -1, D[i] = 0;\n\t\trep(i, N) cin>>D[i+1];\n\t\t//rep(i, M) calc(i+1);\n\t\tcalc(0);\n\t\tbool f = true;\n\t\trep(i, N+1) if(memo[i] == 0) f = false;\n\t\tcout<<(f?\"OK\":\"NG\")<<endl;\n\t\t// rep(i, N+1) printf(\"%3d\", memo[i]);\n\t\t// printf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nint ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\tif (ka[y][x] == 1)break;\n\t\t\t\tka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\tfor (int j = 0; j<300; j++)\n\t\t\t{\n\t\t\t\tka[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\t\n\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint me,n,a[252];\n\nvoid bfs(int s,bool *vis){\n\trep(x,n) vis[x]=(x==s);\n\n\tint Q[252],head=0,tail=0;\n\tQ[tail++]=s;\n\twhile(head<tail){\n\t\tint x=Q[head++];\n\t\tfor(int d=1;d<=me;d++){\n\t\t\tint xx=min(x+d,n-1);\n\t\t\txx=max(min(xx+a[xx],n-1),0);\n\t\t\tif(!vis[xx]){\n\t\t\t\tvis[xx]=true;\n\t\t\t\tQ[tail++]=xx;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d\",&me),me){\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n) scanf(\"%d\",a+i+1);\n\t\tn+=2;\n\t\ta[0]=a[n-1]=0;\n\n\t\tbool vis[252];\n\t\tbfs(0,vis);\n\n\t\tif(!vis[n-1]){ puts(\"NG\"); continue; }\n\n\t\tbool ok=true;\n\t\trep(s,n) if(vis[s]) {\n\t\t\tbool vis2[252];\n\t\t\tbfs(s,vis2);\n\t\t\tif(!vis2[n-1]){ ok=false; break; }\n\t\t}\n\t\tputs(ok?\"OK\":\"NG\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(x==n+1)return true;\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]=dfs(1,nx);\n    if(!memo[prev][x])ans=false;\n    return memo[prev][x];\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nint n, m, d[255];\nbool used[255];\n\nbool bfs(){\n  \n  queue <int> que;\n  que.push(0);\n  while(!que.empty()){\n    int now = que.front(); que.pop();\n    if(used[now]) continue;\n    if(now == n + 1) return true;\n    for(int i = 1; i <= m; i++){\n      que.push(max(min(now + i + d[max(min(now + i, n), 0)], n + 1), 0));\n      used[now] = true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  \n  while(cin >> m, m){\n    cin >> n;\n    d[0] = 0;\n    for(int i = 1; i <= n; i++)\n      cin >> d[i];\n    \n    memset(used, false, sizeof(used));\n    cout << (bfs() ? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\n//再帰flag変数\nbool flag_sugoroku[251] = {false};\n\n//入力配列\nint h_input[251] = {0};\n\n//入力変数\nint n = 0;\n//マスの数\nint masu = 0;\n\t\n\n//-- flag初期化関数 --//\n\nvoid f_syokika();\n\n\n//-- 再起関数 --//\n\nbool f_saiki(int , int);\n\n\n\nint main(void)\n{\n\twhile (cin >> n && n != 0)\n\t{\n\t\tcin >> masu;\n\t\t//成功flag\n\t\tbool ok = false;\n\n\t\tfor (int i = 0; i < masu; i++)\n\t\t{\n\t\t\tcin >> h_input[i];\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\t//必ず初期化が必要\n\t\t\tf_syokika();\n\t\t\tif (f_saiki(i , h_input[i]) == true)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\t\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n\n//*****----- flag初期化関数 -----*****//\n\nvoid f_syokika()\n{\n\tfor (int i = 0; i < 251; i++)\n\t{\n\t\tflag_sugoroku[i] = false;\n\t}\n}\n\n\n//*****----- 再起関数 -----*****//\n\nbool f_saiki(int index , int genzaiti)\n{\n\tif (index >= masu)\n\t{\n\t\treturn false;\n\t}\n\n\t//振り出しはいらない\n\tif (genzaiti < 0)\t{\treturn false;\t}\n\n\t//マスを超えていたらOK\n\tif (genzaiti >= masu)\t{\treturn true;\t}\n\n\t//既にきているなら駄目\n\tif (flag_sugoroku[genzaiti] == true)\n\t{\n\t\treturn false;\n\t}\n\n\t//現在地に到達\n\tflag_sugoroku[genzaiti] = true;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tf_saiki(index + 1 , genzaiti + h_input[i]);\n\t}\n\n\t//来てないことにする\n\tflag_sugoroku[genzaiti] = false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n,dmax;\nint m[300];\n\nbool visited[300];\nbool isVisit[300];\nbool isGoal;\nvoid dfs(int p){\n  if(visited[p])return ;\n  visited[p] = true;\n  isVisit[p] = true;\n  if(p == n+1){\n    isGoal = true;\n    return;\n  }\n  for(int i = 1; i <= dmax; i++){\n    int np = p+i;\n    if(np > n + 1)np = n + 1;\n    if(np < 0)np = 0;\n    while(m[np] != 0){\n      if(visited[np])return;\n      visited[np] = true;\n      np = np + m[np];\n      if(np > n + 1)np = n + 1;\n      if(np < 0) np = 0;\n    }\n    dfs(np);\n  }\n}\nvoid solve(){\n  fill(isVisit, isVisit+300, false);\n  isVisit[0] = true;\n  for(int i = 0 ; i <= n; i++){\n    if(!isVisit[i])continue;\n    isGoal = false;\n    fill(visited, visited+300, false);\n    dfs(i);\n    if(!isGoal){\n      break;\n    }\n  }\n  cout << (isGoal?\"OK\":\"NG\") << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    fill(m, m+300, 0);\n    for(int i = 0 ; i < n ;i++){\n      cin >> m[i+1];\n    }\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 252\nusing namespace std;\n\nint m,n,d[N],ans;\nbool dp[N],o[N];\n\nbool OK(int x){\n  bool r=false;\n  x+=d[x];\n  if(x<0&&dp[0]) r=true;\n  if(x>=n+1) r=true;\n  if(dp[x]) r=true;\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m) break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    for(int i=0;i<=n;i++) dp[i]=false;\n    dp[n+1]=true;\n    o[0]=true;\n    while(1){\n      int f=0;\n      for(int i=0;i<=n;i++){\n\tif(!o[i]) continue;\n\tfor(int j=1;j<=m;j++){\n\t  int nx=i+j;\n\t  if(nx>=n+1) continue;\n\t  nx=nx+d[nx];\n\t  if(nx>=n+1||nx<0) continue;\n\t  if(!o[nx]) f=1;\n\t  o[nx]=true;\n\t}\n      }\n      if(!f) break;\n    }\n    while(1){\n      int f=0;\n      for(int i=n;i>=0;i--){\n\tif(dp[i]||!o[i]) continue;\n\tfor(int j=1;j<=m;j++){\n\t  if(i+j>=n+1||OK(i+j)){\n\t    dp[i]=true;\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n      for(int i=0;i<=n;i++){\n\tif(!o[i]&&!dp[i]){\n\t  if(i+d[i]>=n+1) f=1,dp[i]=true;\n\t  else if(i+d[i]<0&&dp[i]) f=1,dp[i]=true;\n\t  else if(dp[i+d[i]]) f=1,dp[i]=true;\n\t}\n      }\n      if(!f) break;\n    }\n    ans=0;\n    for(int i=0;i<=n;i++)\n      if(o[i]&&!dp[i]) ans=1;\n    if(ans) cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string.h>\n#include <queue>\n#define in insert\nusing namespace std;\ntypedef pair<int,int>P;\n\nbool g[252],b[252];\nset<int> go[252],back[252];\n\nvoid fr(int pos){\n\tif(g[pos])return;\n\tg[pos]=1;\n\tfor(set<int>::iterator i=go[pos].begin();i!=go[pos].end();i++)fr(*i);\n}\n\nvoid ag(int pos){\n\tif(b[pos])return;\n\tb[pos]=1;\n\tfor(set<int>::iterator i=back[pos].begin();i!=back[pos].end();i++)ag(*i);\n}\n\nint main(){\n\t\n\tfor(int mx,n;cin>>mx,mx;){\n\t\tcin>>n;\n\t\tmemset(g,0,sizeof(g));\n\t\tmemset(b,0,sizeof(b));\n\t\tfor(int i=0;i<252;i++)go[i].clear(),back[i].clear();\n\t\tvector<int>mass(n+2,0);\n\t\tfor(int i=1;i<=n;i++)cin>>mass[i];\n\t\tfor(int i=0;i<mass.size();i++){\n\t\t\tfor(int j=1;j<=mx;j++){\n\t\t\t\tint nx=min(n+1,max(0,i+j+mass[i+j]));\n\t\t\t\tif(i==nx)continue;\n\t\t\t\tgo[i].in(nx);\n\t\t\t\tback[nx].in(i);\n\t\t\t}\n\t\t}\n\t\tfr(0);\n\t\tag(n+1);\n\t\tbool flag=1;\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tif(g[i]&&!b[i])flag=0;\n\t\t}\n\t\t\n\t\tif(flag)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\nvoid D(int n,vector<int>*v,int*b){\n\tb[n]=1;\n\tfor(int i=0;i<v[n].size();i++)if(!b[v[n][i]])D(v[n][i],v,b);\n}\nmain(){\n\tint m,n,i,j,next,d[259];\n\tfor(;scanf(\"%d%d\",&m,&n)>1;puts(i<=n+1?\"NG\":\"OK\")){\n\t\td[0]=d[n+1]=0;\n\t\tfor(i=1;i<=n;i++)scanf(\"%d\",d+i);\n\t\tvector<int>vf[259],vr[259];\n\t\tfor(i=0;i<=n;i++)for(j=1;j<=m;j++){\n\t\t\tnext=i+j;\n\t\t\tif(next>n+1)next=n+1;\n\t\t\tnext+=d[next];\n\t\t\tif(next>n+1)next=n+1;\n\t\t\tif(next<0)next=0;\n\t\t\tvf[i].push_back(next),vr[next].push_back(i);\n\t\t}\n\t\tint bf[259],br[259];\n\t\tD(0,vf,bf),D(n+1,vr,br);\n\t\tfor(i=0;i<=n+1;i++)if(bf[i]&&!br[i])break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[N],used[N],ans;\n\nbool dfs(int x){\n  if(d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    x=nx;\n  }\n  if(used[x])return memo[x];\n  used[x]=true;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[x]|=dfs(nx);\n  }\n  if(!memo[x])ans=false;\n  return memo[x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    memset(d,0,sizeof(d));\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    used[n+1]=memo[n+1]=true;\n    ans=true;\n    dfs(0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\n\nint main(){\n  int maxx,n;\n  int data[260];\n  bool d[260][260];\n  while(cin >> maxx,maxx){\n    cin >> n;\n    int N = n + 2;\n    memset(d,false,sizeof(d));\n    memset(data,0,sizeof(data));\n    for(int i=0;i<n;i++){\n      cin >> data[i+1];\n    }\n    for(int i=0;i<N;i++){\n      for(int j=1;j<=maxx && i+j<N;j++){\n\tif(j+i == n+1) d[i][n+1] = true;\n\telse {\n\t  if(j+i+data[j+i] >= n+1) d[i][n+1] = true;\n\t  else if(j+i+data[j+i] < 0) d[i][0] = true;\n\t  else d[i][i+j+data[j+i]] = true;\n\t}\n      }\n    }\n    for(int k=0;k < N;k++){\n      for(int i=0;i < N;i++){\n\tif(d[i][k] == false) continue;\n\tfor(int j=0;j < N;j++){\n\t  if(d[k][j] == false) continue;\n\t  d[i][j] = true;\n\t}\n      }\n    }\n    bool flag = false;\n    for(int i=0;i<=n;i++){\n      if(d[0][i] && (!d[i][n+1])){\n\tflag = true;\n\tcout << \"NG\" << endl;\n\tbreak;\n      }\n    }\n    if(!flag) cout << \"OK\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_N = 300;\nint maxi,n,d[MAX_N];\nbool reach[MAX_N][MAX_N];\n\nint main(){\n  while( cin >> maxi, maxi ){\n    cin >> n;\n    rep(i,n+10) d[i] = 0;\n    REP(i,1,n+1) cin >> d[i];\n    n += 2;\n    rep(i,n) rep(j,n) reach[i][j] = false;\n    rep(i,n) reach[i][i] = true;\n    rep(i,n-1) {\n      REP(j,1,maxi+1){\n        int next = i + j;\n        next = min(next,n-1);\n        next += d[next];\n        next = min(next,n-1);\n        next = max(next,0);\n        reach[i][next] = true;\n      }\n    }\n    rep(k,n) rep(i,n) rep(j,n) if( reach[i][k] && reach[k][j] )reach[i][j] = true;\n    bool success = true;\n    rep(i,n) if( reach[0][i] && !reach[i][n-1] ) { success = false; break; }\n    puts(success?\"OK\":\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint m, n, d[559], e[559]; bool canvis[559], vis[559];\nint main() {\n\twhile (cin >> m, m) {\n\t\tcin >> n;\n\t\tfill(d, d + 555, 0);\n\t\tfor (int i = 1; i <= n; i++) cin >> d[i];\n\t\tfor (int i = 0; i < 555; i++) {\n\t\t\tint p = i + d[i];\n\t\t\tp = min(p, n + 1);\n\t\t\tp = max(p, 0);\n\t\t\te[i] = p;\n\t\t}\n\t\tqueue<int> que1; que1.push(0);\n\t\tfill(canvis, canvis + 555, false); canvis[0] = true;\n\t\twhile (!que1.empty()) {\n\t\t\tint u = que1.front(); que1.pop();\n\t\t\tfor (int i = 1; i <= m; i++) {\n\t\t\t\tint t = e[u + i];\n\t\t\t\tif (!canvis[t]) {\n\t\t\t\t\tcanvis[t] = true;\n\t\t\t\t\tque1.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ret = true;\n\t\tfor (int i = 0; i <= n + 1; i++) {\n\t\t\tif (!canvis[i]) continue;\n\t\t\tfill(vis, vis + 555, false); vis[i] = true;\n\t\t\tqueue<int> que2; que2.push(i);\n\t\t\twhile (!que2.empty()) {\n\t\t\t\tint u = que2.front(); que2.pop();\n\t\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\t\tint t = e[u + j];\n\t\t\t\t\tif (!vis[t]) {\n\t\t\t\t\t\tvis[t] = true;\n\t\t\t\t\t\tque2.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[n + 1]) ret = false;\n\t\t}\n\t\tcout << (ret ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint mx, n, d[300], g[300][300];\n\nint dfs(int k){\n\tif( d[k] == 0 ) return k;\n\t\n\tif( n+1 <= k + d[k] ) return n + 1;\n\tif( k + d[k] <= 0 ) return 0;\n\t\n\treturn dfs(k + d[k]);\n}\n\nvoid add_edge(int u, int v){\n\tg[u][v] = 1;\n}\n\nint main(){\n\twhile( cin >> mx, mx ){\n\t\tfill(d, d + 300, 0);\n\t\tfor(int i = 0; i < 300; i++) fill(g[i], g[i] + 300, 0);\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; i++) cin >> d[i];\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif( d[i] == 0 ){\n\t\t\t\tint u = i;\n\t\t\t\tfor(int j = 1; j <= mx; j++){\n\t\t\t\t\tint v = dfs(i + j);\n\t\t\t\t\tadd_edge(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k <= n+1; k++){\n\t\t\tfor(int i = 0; i <= n+1; i++){\n\t\t\t\tfor(int j = 0; j <= n+1; j++){\n\t\t\t\t\tif( g[i][k] && g[k][j] ) g[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tfor(int u = 0; u <= n; u++){\n\t\t\tif( g[0][u] && !g[u][n+1] ) ans = false;\n\t\t}\n\t\tcout << (ans? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[N],used[N],ans;\n\nbool dfs(int x){\n  x+=d[x];\n  if(x<0)x=0;\n  if(n+1<x)x=n+1;\n  if(used[x])return memo[x];\n  used[x]=true;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[x]|=dfs(nx);\n  }\n  if(!memo[x])ans=false;\n  return memo[x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    memset(d,0,sizeof(d));\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    used[n+1]=memo[n+1]=true;\n    ans=true;\n    dfs(0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(void)\n{\n\tint max,n,d[251];\n\tint i,j,flg,a[251];\n\t\n\twhile(1){\n\t\n\t\tcin>>max;\n\t\tif(max==0) break;\n\t\t\n\t\tcin>>n;\n\t\t\n\t\tfor(i=1;i<=n;i++) cin>>d[i];\n\t\t\n\t\tfor(i=1;i<=max;i++) a[i]=0;\n\t\t\n\t\tfor(i=1;i<=max;i++){\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tif(d[j]<0){\n\t\t\t\t\tif(d[j]*-1>=i) a[i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tflg=0;\n\t\tfor(i=1;i<=max;i++){\n\t\t\tif(a[i]==0) {flg=1;}\n\t\t\telse flg==0;\n\t\t}\n\t\t\n\t\tif(flg==1) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t\n\t}\t\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nint mx;\nint d[300];\nint n;\nint done[300] = {};\nint ok[300] = {};\nint can(int x){\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\tif( x == n - 1 ) return 1;\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( can(t) ) return 1;\n\t}\n\treturn 0;\n}\nint dfs(int x){\n\tif( !ok[x] ) return 1;\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\t\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( dfs(t) ) return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> mx && mx){\n\t\tfor(int i = 0 ; i < 300 ; i++) d[i] = 0;\n\t\tcin >> n;\n\t\tn += 2;\n\t\tfor(int i = 1 ; i < n - 1 ; i++)\n\t\t\tcin >> d[i];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\t\tok[i] = can(i);\n\t\t}\n\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\tcout << (dfs(0)?\"NG\":\"OK\") << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint m,n;\nint mass[260]={};\nbool DP[260]={};\nint seach(vector<int> walked,int now){\n\tnow=max(0,min(now,n+1));\n\tif(DP[now]!=0)\n\treturn DP[now];\n\tif(now>n){\n\t\tDP[now]=1;\n\t\treturn 1;\n\t}\n\tfor(int i=0;i<walked.size();i++){\n\t\tif(now==walked[i]){\n\t\t//DP[now]=-9999;\n\t\treturn -i-1;\n\t\t}\n\t}\n\twalked.push_back(now);\n\tint maxer=-9999;\n\tfor(int i=1;i<=m;i++){\n\t\tint first=min(n+1,now+i);\n\t\tint second=first+mass[first];\n\t\tmaxer=max(maxer,seach(walked,second));\n\t}\n\tif(walked.size()==-maxer){\n\tDP[now]=2;\t\n\tmaxer=2;\n\t}\n\tif(DP[now]>0)\n\tDP[now]=maxer;\n\t//else if(DP[now]<0)\n\t//DP[now]=-9999;\n\treturn maxer;\n\t\n}\n\nint main() {\n\t// your code goes here\n\tvector<int> a;\n\twhile(true){\n\t\tcin >> m;\n\tif(m==0)\n\t\tbreak;\n\t\t\n\tcin >> n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> mass[i];\n\t}\n\tfor(int i=0;i<252;i++)\n\tDP[i]=0;\n\tif(seach(a,0)==1)\n\t\tcout << \"OK\" << endl;\n\telse\n\t\tcout << \"NG\" << endl;\n\t\n\t}\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000\n\nint main()\n{\n    int mx, n;\n    while (cin >> mx, mx) {\n        cin >> n;\n        vector<int> v(n+2, 0);\n        for (int i = 1; i <= n; i++) {\n            cin >> v[i];\n        }\n        bool visited[MAX] = {0};\n        visited[0] = 1;\n        queue<int> Q;\n        Q.push(0);\n\n        while (!Q.empty()) {\n            int now = Q.front(); Q.pop();\n            for (int i = 1; i <= mx; i++) {\n                int next = min(n+1, now+i);\n                next += v[next];\n                if (next < 0) {\n                    next = 0;\n                } else if (next > n+1) {\n                    next = n+1;\n                }\n                if (!visited[next]) {\n                    visited[next] = 1;\n                    Q.push(next);\n                }\n            }\n        }\n        bool reachable = 1;\n        for (int i = 0; i <= n; i++) {\n            if (!visited[i]) {\n                continue;\n            }\n            bool ng = 1;\n            for (int j = 1; j <= mx; j++) {\n                int k = min(n+1, i+j);\n                k += v[k];\n                if (k < 0) {\n                    k = 0;\n                } else if (k > n+1) {\n                    k = n+1;\n                }\n                if (k != i) {\n                    ng = 0;\n                    break;\n                }\n            }\n            if (ng) {\n                reachable = 0;\n                break;\n            }\n        }\n        cout << (reachable ? \"OK\" : \"NG\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\n\nint main(){\n\tint m,n,d[1024],*p;\n\tbool b[255];\n\tfor(;;){\n\t\tscanf(\"%d\",&m);\n\t\tif(!m)break;\n\t\tscanf(\"%d\",&n);\n\t\trep(i,1024)d[i]=0;\n\t\trep(i,255)b[i]=0;\n\t\tp=d+256;\n\t\trep(i,n)scanf(\"%d\",p+i+1);\n\t\tfor(int i=n;i>=0;i--){\n\t\t\treps(j,1,m){\n\t\t\t\tint c=p[i+j]+i+j;\n\t\t\t\tif(c>n || (in(c,0,n) && b[c])){\n\t\t\t\t\tb[i]=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint f=1;\n\t\trep(i,n+1)if(f &&(i==0 || p[i]))reps(j,1,m){\n\t\t\tint c=p[i+j]+i+j;\n\t\t\tif(c<=n && in(c,0,n) && !b[c]){\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tputs(f?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nbool solve(int mx, int n, int order[])\n{\n\tqueue<int> search;\n\tqueue<int> back[252];\n\n\tbool start[252];\n\tfor (int i = 0; i <= n + 1; i++) start[i] = false;\n\tstart[0] = true;\n\tsearch.push(0);\n\twhile (!search.empty()){\n\t\tint now = search.front();\n\t\tsearch.pop();\n\t\tfor (int i = 1; i <= mx; i++){\n\t\t\tint next;\n\t\t\tif (now + i <= 0) continue;\n\t\t\telse if (now + i > n + 1) next = n + 1;\n\t\t\telse if (now + i + order[now + i] <= 0) continue;\n\t\t\telse if (now + i + order[now + i] > n + 1) next = n + 1;\n\t\t\telse next = now + i + order[now + i];\n\t\t\tback[next].push(now);\n\t\t\tif (start[next]) continue;\n\t\t\tstart[next] = true;\n\t\t\tsearch.push(next);\t\t\t\n\t\t}\n\t}\n\tif (!start[n + 1]) return false;\n\t\n\tint goal[252];\n\tfor (int i = 0; i <= n + 1; i++) goal[i] = false;\n\tgoal[n + 1] = true;\t\n\tsearch.push(n + 1);\n\twhile (!search.empty()){\n\t\tint now = search.front();\n\t\tsearch.pop();\n\t\twhile (!back[now].empty()){\n\t\t\tint from = back[now].front();\n\t\t\tback[now].pop();\n\t\t\tif (goal[from]) continue;\n\t\t\tgoal[from] = true;\n\t\t\tsearch.push(from);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n + 1; i++){\n\t\tif (start[i] && !goal[i]) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile (true){\n\t\tint mx;\n\t\tcin >> mx;\n\t\tif (!mx) break;\n\t\tint n, order[252];\n\t\tcin >> n;\n\t\torder[0] = order[n + 1] = 0;\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tcin >> order[i];\n\t\t}\n\t\tif (solve(mx, n, order)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int m;cin>>m,m;){\n\t\tint n; cin>>n;\n\t\tvi d(n+2); rep(i,n) cin>>d[i+1];\n\t\t\n\t\tvvi dp(n+2,vi(n+2)); // 0:ふりだし,m+1:あがり\n\t\trep(i,n+2) dp[i][i]=1;\n\t\trep(i,n+2) repi(j,1,m+1) if(i+j<=n+1)\n\t\t\tdp[i][min(max(i+j+d[i+j],0),n+1)]=1;\n\t\t\n\t\trep(k,n+2) rep(i,n+2) rep(j,n+2)\n\t\t\tdp[i][j]|=dp[i][k]&dp[k][j];\n\t\t\n\t\tbool res=true;\n\t\trep(i,n+2) if(dp[0][i] && !dp[i][n+1]) res=false;\n\t\tcout<<(res?\"OK\":\"NG\")<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std ;\n\n\nbool sg[ 260 ][ 260 ] ;\n\n\nint maxy ;\nint n ;\n\n\nint map[ 260 ] ;\n\nvoid yuki(int now)\n{\n\tint i,x;\n\n\tfor(i=1;i<=maxy;i++)\n\t{\n\t\tx=now+i;\n\t\tx=x+map[x];\n\n\t\t\t\tif(x<=0) x=0;\n\n\t\t\t\tif(x>=n+1) x=n+1;\n\t\tif(sg[now][x])continue;\n\t\tsg[now][x]=true;\n\n\t\tif(x==0) continue ;\n\t\tif(x>=n+1) continue ;  // owari\n\t\tyuki(x);\n\n\t}\n\n\treturn ;\n}\n\nvoid kaeri( int end )\n{\n\tint i;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tif(sg[i][end])\n\t\t{\n\t\t\tsg[i][end] = false;\n\t\t\tkaeri( i );\n\t\t}\n\t}\n\treturn ;\n\n}\n\nint main()\n{\n\tint i,j;\n\t\n\twhile( 1 )\n\t{\n\t\tint flag = 0 ;\n\n\t\tcin >> maxy ;\n\n\t\tif( maxy == 0 )\n\t\t{\n\t\t\treturn 0 ;\n\t\t}\n\n\n\t\tcin >> n ;\n\n\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tcin >> map[i];\n\t\t}\n\n\t\tyuki(0);\n\t\t/*for(i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n+1;j++)\n\t\t\t{\n\t\t\t\tcout << sg[ i ][ j ] << \" \" ;\n\t\t\t}\t\n\t\t\tcout << endl ;\n\t\t}*/\n                \n\t\tkaeri(n+1);\n/*\ncout << endl ;\n\n\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n+1;j++)\n\t\t\t{\n\t\t\t\tcout << sg[ i ][ j ] << \" \" ;\n\t\t\t}\t\n\t\t\tcout << endl ;\n\t\t}*/\n\n\n\n\n\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n+1;j++)\n\t\t\t{\n\t\t\t\tif(sg[i][j])\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\" ;\n\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(sg[i][j])\n\t\t\t{\n\t\t\t\t++flag ;\n\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t}\n\n\t\tif( flag == 0 )\n\t\t{\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\n\t\tmemset( map ,0 ,sizeof map ) ;\n\t\tmemset( sg ,false ,sizeof sg ) ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 256;\n\nint maxi;\nint n;\nint d[MAXN];\nint canGoal[MAXN];\nbool vis[MAXN];\n\nint nextPos(int pos, int m) {\n  int npos = min(pos + m, n-1);\n  npos += d[npos];\n  npos = min(npos, n-1);\n  npos = max(npos, 0);\n  return npos;\n}\n\nvoid rec(int pos) {\n  vis[pos] = true;\n  for(int m = 1; m <= maxi; ++m) {\n    int npos = nextPos(pos, m);\n    if(vis[npos]) continue;\n    rec(npos);\n  }\n}\n\nint rec2(int pos) {\n  int &res = canGoal[pos];\n  if(res != -1) return res;\n  res = 0;\n  for(int m = 1; m <= maxi; ++m) {\n    if(rec2(nextPos(pos, m))) {\n      return res = 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> maxi && maxi) {\n    cin >> n;\n    for(int i = 0; i < n; ++i) cin >> d[i+1];\n    n += 2;\n    d[0] = d[n-1] = 0;\n    fill(vis, vis+n, false);\n    rec(0);\n    fill(canGoal, canGoal+n, -1);\n    canGoal[n-1] = 1;\n    bool res = true;\n    for(int i = 0; i < n; ++i) {\n      if(vis[i] && !rec2(i)) {\n\tres = false;\n\tbreak;\n      }\n    }\n    if(res) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tbool r[255][255]={};\n\t\tint num[255]={};\n\t\tint maxv,n;\n\t\tvector<int>edge[255];\n\t\tfor(int i=0;i<255;i++) edge[i].clear();\n\t\tbool used[255][255]={};\n\t\t\n\t\tcin >> maxv;\n\t\tif(maxv == 0) return 0;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++) cin >> num[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=maxv;j++)\n\t\t\t{\n\t\t\t\tint d = i+j;\n\t\t\t\tif(d > n) r[i][n+1] = true;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\td += num[d];\n\t\t\t\t\td = max(d,0);\n\t\t\t\t\td = min(d,n+1);\n\t\t\t\t\tr[i][d] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=n;i++) for(int j=0;j<=n+1;j++) if(r[i][j]) edge[i].pb(j);\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\t//used[i][i] = true;\n\t\t\tqueue<int>que; que.push(i);\n\t\t\twhile(!que.empty())\n\t\t\t{\n\t\t\t\tint q = que.front(); que.pop();\n\t\t\t\tif(used[i][q]) continue;\n\t\t\t\tused[i][q] = true;\n\t\t\t\tfor(int j=0;j<edge[q].size();j++)\n\t\t\t\t{\n\t\t\t\t\tif(!used[i][edge[q][j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(edge[q][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tif(used[0][i] && !used[i][n+1])\n\t\t\t{\n\t\t\t\tputs(\"NG\"); goto nxt;\n\t\t\t}\n\t\t}\n\t\tputs(\"OK\"); nxt:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int> >G(252),R(252);\nint n,m;\nint d[252];\nbool u[252];\nvoid f(int v)\n{\n\tu[v]=1;\n\tfor(int i=0;i<R[v].size();i++)\n\t{\n\t\tif(!u[R[v][i]])f(R[v][i]);\n\t}\n}\nbool vi[252];\nbool ok(int v)\n{\n    bool ans=1;\n    vi[v]=1;\n    for(int i=0;i<G[v].size();i++)\n    {\n        if(!vi[G[v][i]])ans&=ok(G[v][i]);\n    }\n    return ans;\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<=n+1;i++)G[i].clear(),R[i].clear(),vi[i]=u[i]=0;\n\t\tfor(int i=1;i<=n;i++)cin>>d[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m&&i+j<=n+1;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+d[i+j];\n\t\t\t\tif(k>n+1)k=n+1;\n\t\t\t\tif(k<0)k=0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n+1);\n\t\tcout<<(ok(0)?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int m;\n    while(cin >> m && m){\n\n        int n;\n        cin >> n;\n\n        int d[300];\n        for(int i = 1; i <= n; ++i){\n            cin >> d[i];\n        }\n\n        bool g[300][300];\n        for(int i = 0; i <= n + 1; ++i){\n            for(int j = 0; j <= n + 1; ++j){\n                g[i][j] = false;\n            }\n        }\n\n        for(int i = 0; i < n + 1; ++i){\n            for(int j = 1; j <= m; ++j){\n                if(i + j >= n + 1){\n                    g[i][n + 1] = true;\n                }\n                else {\n                    g[i][max(0, min(n + 1, i + j + d[i + j]))] = true;\n                }\n            }\n        }\n\n        for(int k = 0; k <= n + 1; ++k){\n            for(int i = 0; i <= n + 1; ++i){\n                for(int j = 0; j <= n + 1; ++j){\n                    if(g[i][k] && g[k][j]){\n                        g[i][j] = true;\n                    }\n                }\n            }\n        }\n\n        bool check = g[0][n + 1];\n        for(int i = 1; i <= n; ++i){\n            //cout << g[0][i] << \" \" << g[i][n + 1] << endl;\n            if(g[0][i] && !g[i][n + 1]){\n                check = false;\n            }\n        }\n\n        cout << (check ? \"OK\" : \"NG\") << endl;\n    }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dice;\nint n;\nvector<int> a;\nvector<bool> memo;\n\nbool solve(int curr)\n{\n    if(curr == n+1)\n        return true;\n\n    if(memo[curr])\n        return false;\n    memo[curr] = true;\n\n    for(int i=1; i<=dice; ++i){\n        int next = min(n+1, curr + i);\n        next = max(0, min(n+1, next + a[next]));\n        if(solve(next))\n            return true;\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        cin >> dice >> n;\n        if(dice == 0)\n            return 0;\n\n        a.assign(n+2, 0);\n        for(int i=1; i<=n; ++i)\n            cin >> a[i];\n\n        vector<bool> access(n+2, false);\n        access[0] = true;\n        queue<int> q;\n        q.push(0);\n        while(!q.empty()){\n            int curr = q.front();\n            q.pop();\n            for(int i=1; i<=dice; ++i){\n                int next = min(n-1, curr + i);\n                next = max(0, min(n-1, next + a[next]));\n                if(!access[next]){\n                    access[next] = true;\n                    q.push(next);\n                }\n            }\n        }\n\n        bool ok = true;\n        for(int i=0; i<n+2; ++i){\n            memo.assign(n+2, false);\n            if(access[i] && !solve(i))\n                ok = false;\n        }\n\n        if(ok)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint mx, n, d[300], g[300][300];\nint memo[300];\n\nint dfs(int k){\n\tif( d[k] == 0 ) return k;\n\t\n\tif( n+1 <= k + d[k] ) return n + 1;\n\tif( k + d[k] <= 0 ) return 0;\n\t\n\tif( memo[k] != -1 ) return memo[k];\n\treturn 0;\n\treturn memo[k] = dfs(k + d[k]);\n}\n\nvoid add_edge(int u, int v){\n\tg[u][v] = 1;\n}\n\nint main(){\n\twhile( cin >> mx, mx ){\n\t\tfill(d, d + 300, 0);\n\t\tfill(memo, memo + 300, -1);\n\t\tfor(int i = 0; i < 300; i++) fill(g[i], g[i] + 300, 0);\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; i++) cin >> d[i];\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif( d[i] == 0 ){\n\t\t\t\tint u = i;\n\t\t\t\tfor(int j = 1; j <= mx; j++){\n\t\t\t\t\tint v = dfs(i + j);\n\t\t\t\t\tadd_edge(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k <= n+1; k++){\n\t\t\tfor(int i = 0; i <= n+1; i++){\n\t\t\t\tfor(int j = 0; j <= n+1; j++){\n\t\t\t\t\tif( g[i][k] && g[k][j] ) g[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tfor(int u = 0; u <= n; u++){\n\t\t\tif( g[0][u] && !g[u][n+1] ) ans = false;\n\t\t}\n\t\tcout << (ans? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, M;\nint D[300];\nint dist[300];\nvector<int> G[300], R[300];\nvector<int> G2[300];\nbool used[300];\nint ord[300];\n\nvector<int> vs;\nvoid dfs(int x) {\n  if (used[x]) return;\n  used[x] = true;\n  for (int t : G[x]) dfs(t);\n  vs.pb(x);\n}\nvoid rdfs(int x, int k) {\n  if (used[x]) return;\n  used[x] = true;\n  ord[x] = k;\n  for (int t : R[x]) rdfs(t, k);\n}\n\nint scc() {\n  vs.clear();\n  rep(i, N) used[i] = false;\n  rep(i, N) dfs(i);\n  rep(i, N) used[i] = false;\n  int k = 0;\n  for (int i=vs.size()-1; i>=0; i--) {\n    if (!used[vs[i]]) rdfs(vs[i], k++);\n  }\n  return k;\n}\nvoid dfs2(int x) {\n  if (used[x]) return;\n  used[x] = true;\n  for (int t : G2[x]) dfs2(t);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> M) {\n    if (M == 0) break;\n    cin >> N;\n    N+=2;\n    D[0] = 0;\n    rep(i, N-2) cin >> D[i+1];\n    D[N-1] = 0;\n    rep(i, N) G[i].clear(), R[i].clear();\n    rep(i, N-1) {\n      rep(k, M) {\n        int t = i+k;\n        if (t > N) t = N;\n        if (t < 0) t = 0;\n        t += D[t];\n        if (t > N) t = N;\n        if (t < 0) t = 0;\n        G[i].pb(t);\n        R[t].pb(i);\n      }\n    }\n    int K = scc();\n    rep(i, K) G2[i].clear();\n    rep(i, N) {\n      for (int t : G[i]) {\n        G2[ord[i]].pb(ord[t]);\n      }\n    }\n    rep(i, K) {\n      sort(all(G2[i])); uniq(G2[i]);\n    }\n    rep(i, N) used[i] = false;\n    dfs2(ord[0]);\n    bool ok = false;\n    rep(i, K) {\n      if (used[i] && G2[i].empty()) ok = true;\n    }\n    if (ok) cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dice;\nint n;\nvector<int> a;\nvector<bool> memo;\n\nbool solve(int curr)\n{\n    if(curr == n-1)\n        return true;\n\n    if(memo[curr])\n        return false;\n    memo[curr] = true;\n\n    for(int i=1; i<=dice; ++i){\n        int next = min(n-1, curr + i);\n        next = max(0, min(n-1, next + a[next]));\n        if(solve(next))\n            return true;\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        cin >> dice >> n;\n        if(dice == 0)\n            return 0;\n\n        a.assign(n+2, 0);\n        for(int i=1; i<=n; ++i)\n            cin >> a[i];\n\n        vector<bool> access(n+2, false);\n        access[0] = true;\n        queue<int> q;\n        q.push(0);\n        while(!q.empty()){\n            int curr = q.front();\n            q.pop();\n            for(int i=1; i<=dice; ++i){\n                int next = min(n-1, curr + i);\n                next = max(0, min(n-1, next + a[next]));\n                if(!access[next]){\n                    access[next] = true;\n                    q.push(next);\n                }\n            }\n        }\n\n        bool ok = true;\n        for(int i=0; i<n; ++i){\n            memo.assign(n+2, false);\n            if(access[i] && !solve(i))\n                ok = false;\n        }\n\n        if(ok)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> a;\nint n,m;\nvector<bool> d(300);\n\nbool saiki(int p1,int pre,vector<int> u){\n    int p = p1;\n  //  if(u[p] > 2) return true;\n    u[p]++;\n    bool ans = false;\n\n    bool flg = false;\n    for(int i=1;i<=m;i++){\n\tif(u[min(p+i,n+1)] == 0) flg = true;\n    }\n    if(!flg) return true;\n    for(int i=1;i<=m;i++){\n\tp = p1;\n\tp += i;\n\tp = min(p,n+1);\n\tu[p]++;\n\tif(a[p] == 300) return d[p1] = false;\n\tp += a[p];\n\tp = min(p,n+1);\n\tp = max(p,0);\n\tif(u[p] < 50)\n\t    ans = ans | saiki(p,p1,u);\n    }\n    return d[p] = ans;\n}\n\nint main(){\n    while(true){\n\tfill(ALL(d),true);\n\ta = vector<int>(0);\n\tcin >> m;\n\tif(m == 0) break;\n\tcin >> n;\n\ta.PB(-300);\n\tREP(i,n){\n\t    int temp;\n\t    cin >> temp;\n\t    a.PB(temp);\n\t}\n\ta.PB(300);\n\tif(!saiki(0,0,vector<int>(n+2,0))) cout << \"OK\" << endl;\n\telse cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nint main() {\n  int MAX;\n  while(cin >>MAX && MAX){\n    int N; cin >>N;\n    vector<int> v(N + 2, 0); FOR(i, 1, N + 1) cin >>v[i];\n    //debug\n    //REP(i, v.size()) cout <<v[i] <<\" \"; cout <<endl;\n    bool final_isOK = true;\n    REP(i, N + 1){\n      queue<int> open;\n      open.push(i);\n      vector<bool> closed(N + 1, false);\n      bool isOK = false;\n      while(!open.empty()){\n        int now = open.front(); open.pop();\n        //cout <<now <<\", \" <<v[now] <<endl;\n        if(now == N + 1){\n          isOK = true;\n          break;\n        }\n        if(closed[now]) continue;\n        closed[now] = true;\n\n        if(v[now] == 0){\n          FOR(i, now + 1, min(N + 1, now + MAX) + 1){\n            if(!closed[i]){\n              //cout <<\"    push \" <<i <<endl;\n              open.push(i);\n            }\n          }\n        } else if(v[now] < 0){\n          int next = max(0, now + v[now]);\n          //cout <<\"    push \" <<next <<endl;\n          if(!closed[next]) open.push(next);\n        } else if(v[now] > 0){\n          int next = min(N + 1, now + v[now]);\n          if(!closed[next]) open.push(next);\n        }\n      }\n      if(!isOK){\n        final_isOK = false;\n        break;\n      }\n    }\n    cout <<(final_isOK ? \"OK\" : \"NG\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q1,q2;\n    q1.push(0);\n    bool c=true;\n    while(!q1.empty()){\n      b=q1.front();q1.pop();\n      if(r[b]) continue;\n      r[b]=true;\n      q2.push(b);\n      //cout << b << endl;\n      fill(used,used+300,false);\n      while(!q2.empty()){\n\tp=q2.front();q2.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(p>=n+1){\n\t  used[n+1]=true;\n\t  break;\n\t}\n\tif(used[p]) continue;\n\tused[p]=true;\n\tq1.push(p);\n\tfor(i=1;i<=m;i++){\n\t  //cout <<p<<\":\"<< i <<\":\"<<p+i+d[p+i]<< endl;\n\t  q2.push(p+i+d[p+i]);\n\t}\n      }\n      if(!used[n+1]){\n\tc=false;\n\tbreak;\n      }\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint m, n;\nint main() {\n\twhile (cin >> m, m) {\n\t\tcin >> n;\n\t\tvector<vector<int> > G(n + 2);\n\t\tvector<int> a(n + 2, -1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> a[i];\n\t\t\tif (a[i] == 0) a[i] = -1;\n\t\t\telse {\n\t\t\t\ta[i] += i;\n\t\t\t\ta[i] = min(max(a[i], 0), n + 1);\n\t\t\t\tG[i].push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tfor (int j = 1; j <= m && i + j < n + 2; j++) {\n\t\t\t\tG[i].push_back((a[j] == -1 ? j : a[j]));\n\t\t\t}\n\t\t}\n\t\tvector<bool> vis(n + 2, false); vis[0] = true;\n\t\tqueue<int> que; que.push(0);\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tfor (int e : G[u]) {\n\t\t\t\tif (!vis[e]) {\n\t\t\t\t\tvis[e] = true;\n\t\t\t\t\tque.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = vis[n + 1];\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (!vis[i]) continue;\n\t\t\tvector<bool> vis2(n + 2, false); vis2[i] = true;\n\t\t\tqueue<int> que2; que2.push(i);\n\t\t\twhile (!que2.empty()) {\n\t\t\t\tint u = que2.front(); que2.pop();\n\t\t\t\tfor (int e : G[u]) {\n\t\t\t\t\tif (!vis2[e]) {\n\t\t\t\t\t\tvis2[e] = true;\n\t\t\t\t\t\tque2.push(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis2[n + 1]) flag = false;\n\t\t}\n\t\tcout << (flag ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint m,n,d[300];\nint reach[300];\nbool vis[300];\n\nbool rec(int p){\n  if(p == n+1)return true;\n  if(reach[p])return (reach[p]==1);\n  if(vis[p])return false;\n  vis[p] = true;\n\n  bool res = false;\n  for(int i=1;i<=m;i++){\n    int nxt = min(n+1,p+i);\n    nxt = max(0,min(n+1,nxt + d[nxt]));\n    res |= rec(nxt);\n  }\n\n  reach[p] = res?1:-1;\n  return res;\n}\n\nint main(){\n  while(cin >> m,m){\n    cin >> n;\n    for(int i=1;i<=n;i++){cin >> d[i]; reach[i] = vis[i] = 0;}\n    d[0] = d[n+1] = reach[0] = reach[n-1] = vis[0] = vis[n-1] = 0;\n    rec(0);\n    bool res = true;\n    for(int i=0;i<=n+1;i++)if(reach[i]<0)res = false;\n    cout << (res?\"OK\":\"NG\") << endl;\n  }\n}\n      "
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\n//int ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\t//if (ka[y][x] == 1)continue;\n\t\t\t\t//ka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\t//for (int j = 0; j<300; j++)\n\t\t\t//{\n\t\t\t//\tka[i][j] = 0;\n\t\t\t//}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\t/*\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\t*/\n\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\ntypedef long long ll;\n\n#define pb push_back\n\nint main(){\n\twhile(1){\n\t\tint max;\n\t\tint n,d[252];\n\t\tscanf(\"%d\",&max); if(max == 0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i = 1 ; i <= n ; i ++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tvector<int> G[252];\n\t\tvector<int> rG[252];\n\t\tfor(int i = 0 ; i < n+1 ; i ++){\n\t\t\tfor(int j = 1 ; j <= max ; j ++){\n\t\t\t\tif(i+j >= n+1 || i+j+d[i+j] >= n+1){\n\t\t\t\t\tG[i].pb(n+1);\n\t\t\t\t\trG[n+1].pb(i);\n\t\t\t\t}\n\t\t\t\telse if(i+j+d[i+j] >= 0){\n\t\t\t\t\tG[i].pb(i+j+d[i+j]);\n\t\t\t\t\trG[i+j+d[i+j]].pb(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tG[i].pb(0);\n\t\t\t\t\trG[0].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool used[252];\n\t\tqueue<int> que;\n\t\tfor(int i = 0 ; i < 252 ; i ++){\n\t\t\tused[i] = false;\n\t\t\tque.push(0);\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint p = que.front(); que.pop();\n\t\t\tif(used[p])continue;\n\t\t\tused[p] = true;\n\t\t\tfor(int i = 0 ; i < G[p].size() ; i ++){\n\t\t\t\tque.push(G[p][i]);\n\t\t\t}\n\t\t}\n\t\tbool used_[252];\n\t\tqueue<int> que_;\n\t\tfor(int i = 0 ; i < 252 ; i ++){\n\t\t\tused_[i] = false;\n\t\t\tque_.push(n+1);\n\t\t}\n\t\twhile(!que_.empty()){\n\t\t\tint p = que_.front(); que_.pop();\n\t\t\tif(used_[p])continue;\n\t\t\tused_[p] = true;\n\t\t\tfor(int i = 0 ; i < rG[p].size() ; i ++){\n\t\t\t\tque_.push(rG[p][i]);\n\t\t\t}\n\t\t}\n\t\tbool t = true;\n\t\tfor(int i = 0 ; i < 252 ; i ++){\n\t\t\tif(used[i] && !used_[i])t = false;\n\t\t}\n\t\tif(t)puts(\"OK\");\n\t\telse puts(\"NG\");\n\t\t/*for(int i = 0 ; i <= n+1 ; i ++){\n\t\t\tprintf(\"G[%d]:\",i);\n\t\t\tfor(int j = 0 ; j < G[i].size() ; j ++){\n\t\t\t\tprintf(\"%d \",G[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t\tprintf(\"rG[%d]:\",i);\n\t\t\tfor(int j = 0 ; j < rG[i].size() ; j ++){\n\t\t\t\tprintf(\"%d \",rG[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint m,n;\nint mass[260]={};\nbool DP[260]={};\nint seach(vector<int> walked,int now){\n\tnow=max(0,min(now,n+1));\n\tif(DP[now]!=0)\n\treturn DP[now];\n\tif(now>n){\n\t\tDP[now]=1;\n\t\treturn 1;\n\t}\n\tfor(int i=0;i<walked.size();i++){\n\t\tif(now==walked[i]){\n\t\tDP[now]=-9999;\n\t\treturn -i-1;\n\t\t}\n\t}\n\twalked.push_back(now);\n\tint maxer=-9999;\n\tfor(int i=1;i<=m;i++){\n\t\tint first=min(n+1,now+i);\n\t\tint second=first+mass[first];\n\t\tmaxer=max(maxer,seach(walked,second));\n\t}\n\tif(walked.size()==-maxer){\n\tDP[now]=2;\t\n\tmaxer=2;\n\t}\n\tif(DP[now]>0)\n\tDP[now]=maxer;\n\telse if(DP[now]<0)\n\tDP[now]=-9999;\n\treturn maxer;\n\t\n}\n\nint main() {\n\t// your code goes here\n\tvector<int> a;\n\twhile(true){\n\t\tcin >> m;\n\tif(m==0)\n\t\tbreak;\n\t\t\n\tcin >> n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> mass[i];\n\t}\n\tfor(int i=0;i<252;i++)\n\tDP[i]=0;\n\tif(seach(a,0)==1)\n\t\tcout << \"OK\" << endl;\n\telse\n\t\tcout << \"NG\" << endl;\n\t\n\t}\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint n, a[300], m; bool u1[300], u2[300];\nint main() {\n\twhile (true) {\n\t\tcin >> m; if (m == 0)break; cin >> n;\n\t\tfor (int i = 1; i <= n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < 300; i++)u1[i] = false; u1[0] = true;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tif (u1[j] == false)continue;\n\t\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\t\tint G = j + k; if (G > n)G = n + 1;\n\t\t\t\t\tG += a[G]; if (G < 0)G = 0; if (G > n)G = n + 1; u1[G] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tif (u1[i] == false)continue;\n\t\t\tfor (int j = 0; j < 300; j++)u2[j] = false; u2[i] = true;\n\t\t\tqueue<int>Q; Q.push(i);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\t\tint G = a1 + j; if (G > n)G = n + 1;\n\t\t\t\t\tG += a[G]; if (G < 0)G = 0; if (G > n)G = n + 1;\n\t\t\t\t\tif (u2[G] == false) { u2[G] = true; Q.push(G); }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (u2[n + 1] == false) { cout << \"NG\" << endl; flag = true; break; }\n\t\t}\n\t\tif (flag == false)cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int N = 250;\n\nint m, n;\nint val[N+2];\nbool vis[N+2];\nbool G[N+2][N+2];\n\nvoid makeG(){\n  fill(G[0], G[n+2], false);\n  for(int i=0;i<n+2;i++){\n    for(int j=1;j<=m;j++){\n      int next = i + j;\n      if(next > n + 1) next = n + 1;\n      next += val[next];\n      if(next > n + 1) next = n + 1;\n      if(next < 0) next = 0;\n      if(next == i) continue;\n      G[i][next] = true;\n    }\n  }\n  for(int k=0;k<n+2;k++){\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n        if(G[i][k] && G[k][j]) G[i][j] = true;\n      }\n    }\n  }\n}\n\nbool solve(){\n  makeG();\n  bool f = false;\n  for(int i=0;i<n+2;i++) if(G[0][i]) f = true;\n  if(!f) return false;\n  for(int i=1;i<n+1;i++){\n    if(G[0][i] && !G[i][n+1]) return false;\n  }\n  return true;\n}\n\nmain(){\n  while(cin >> m && m){\n    cin >> n;\n    val[0] = val[n+1] = 0;\n    for(int i=1;i<=n;i++) cin >> val[i];\n    cout << (solve() ? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nint main(){\n\tint max,n;\n\tint e[10000];\n\tbool tizu[256][256];bool flag = false;\n\twhile(cin >> max,max){\n\tmemset(tizu,false,sizeof(tizu));\n\tflag = false;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> e[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=1;j<=max;j++){\n\t\t\tif(i+j+e[i+j]>=n+1) tizu[i][n+1] = true;\n\t\t\telse if(i+j+e[i+j]<=0) tizu[i][0] = true;\n\t\t\telse tizu[i][i+j+e[i+j]] = true;\n\t\t}\n\t}\n\tfor(int k=0;k<n+1;k++){\n\t\tfor(int i=0;k<n+1;k++){\n\t\t\tfor(int j=0;j<n+1;j++){\n\t\t\t\tif(tizu[i][k] && tizu[k][j]) tizu[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=max;i++){\n\t\tif(tizu[0][i] && !tizu[i][n+1]) flag = true;\n\t}\n\t(flag ? cout << \"NG\" : cout << \"OK\");\n\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nint ma;\nint n;\nint a[252];\nint d[252];\n\nbool search(int x, int cnt)\n{\n\tif (x == n + 1) return true;\n\tif (d[x] < cnt) return false;\n\tif (cnt > 5000) return false;\n\t//printf(\"_ %d\\n\", x);\n\td[x] = cnt;\n\tfor (int i = 1; i <= ma; i++){\n\t\tint to = min(x + i, n + 1);\n\t\tto += a[to];\n\t\tto = max(to, 0);\n\t\tto = min(to, n + 1);\n\t\tif (search(to, cnt + 1)) return true;\n\t}\n\treturn false;\n}\n\nvoid solve()\n{\n\tbool res = true;\n\tfor (int i = 0; i <= n; i++){\n\t\tfill(d, d + 252, INF);\n\t\tres &= search(i, 0);\n\t}\n\tputs(res ? \"OK\" : \"NG\");\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &ma), ma){\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MN = 400;\n\nint main() {\n    while(1) {\n        int m, n;\n        int d[MN] = {};\n        bool used[MN][2] = {};\n        vector<int> rd[MN];\n\n        cin >> m;\n        if (!m) break;\n        cin >> n; n += 2;\n        for (int i = 1; i < n-1; i++) {\n            cin >> d[i];\n            d[i] += i;\n            d[i] = max(d[i], 0);\n            d[i] = min(d[i], n-1);\n            rd[d[i]].push_back(i);\n        }\n        d[n-1] = n-1;\n        rd[n-1].push_back(n-1);\n        queue<P> q;\n        q.push(P(n-1, 0));\n        q.push(P(n-1, 1));\n        while (!q.empty()) {\n            P p = q.front(); q.pop();\n            int u, f;\n            tie(u, f) = p;\n            if (used[u][f]) continue;\n            //cout << u << endl;\n            used[u][f] = true;\n            if (!f) {\n                for (int i = max(0, u-m); i < u; i++) {\n                    q.push(P(i, 1));\n                }                \n            } else {\n                for (int i: rd[u]) {\n                    q.push(P(i, 0));\n                }\n            }\n        }\n        bool f = true;\n        for (int i = 1; i <= m; i++) {\n            if (!used[i][0]) {\n                //cout << i << endl;\n                f = false;\n            }\n        }\n        if (f) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define NMAX 260\nint n,dmax;\nint m[NMAX];\nbool visited[NMAX], isVisit[NMAX], goal[NMAX], isGoal;\nbool dfs(int p){\n  if(visited[p])return goal[p];\n  visited[p] = true;\n  if(p == n+1) return true;\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;  \n    goal[p] = (dfs(np)||goal[p]);\n  }\n  return goal[p];\n}\nvoid solve(){\n  memset(visited, 0, sizeof(visited));\n  memset(goal, 0, sizeof(goal));\n  goal[0] = dfs(0);\n  if(!goal[0]){\n    cout << \"NG\" << endl;\n    return ;\n  }\n  for(int i = 1 ; i <= n; i++){\n    if(!visited[i])continue;\n    goal[i] = dfs(i);\n    if(!goal[i]){\n      cout << \"NG\" << endl;\n      return ;\n    }\n  }\n  cout << \"OK\" << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    m[0] = 0;\n    int i;\n    for(i = 1 ; i < n+1 ;i++){\n      cin >> m[i];\n    }\n    m[i] = 0;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint main(void){\n  int roulette;\n  while(cin >> roulette, roulette){\n    int n;\n    cin >> n;\n    vector<signed int> d(n+2);\n    REP(i,n){\n      cin >> d[i+1];\n    }\n\n    /*\n    vector<bool>loop(n+2, false);\n\n    loop[0] = true;\n\n    REP(asdf, 3){\n      for(int pos = 0; pos < n+2; pos++){\n        if(loop[pos] == false) continue;\n        for(int r = 1; r <= roulette; r++){\n          int npos = pos + r + d[pos+r];\n          npos = max(0, min(n+2-1, npos));\n          loop[npos] = true;\n        }\n      }\n    }\n    */\n\n    bool flg;\n    REP(i,n+2){\n      //if(loop[i] == false) continue;\n      flg = false;\n      REP(j, roulette){\n        int delta = j+1;\n        if(!(d[i+delta] <= -delta)) flg = true;\n      }\n      if(flg == false){\n        break;\n      }\n    }\n    if(flg) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nbool solve(int mx, int n, int order[])\n{\n\tqueue<int> search;\n\tqueue<int> back[252];\n\n\tbool start[252];\n\tfor (int i = 0; i <= n + 1; i++) start[i] = false;\n\tstart[0] = true;\n\tsearch.push(0);\n\twhile (!search.empty()){\n\t\tint now = search.front();\n\t\tsearch.pop();\n\t\tfor (int i = 1; i <= mx; i++){\n\t\t\tint next;\n\t\t\tif (now + i <= 0) continue;\n\t\t\telse if (now + i > n + 1) next = n + 1;\n\t\t\telse if (now + i + order[now + i] <= 0) continue;\n\t\t\telse if (now + i + order[now + i] > n + 1) next = n + 1;\n\t\t\telse next = now + i + order[now + i];\n\t\t\tback[next].push(now);\n\t\t\tif (start[next]) continue;\n\t\t\tstart[next] = true;\n\t\t\tsearch.push(next);\t\t\t\n\t\t}\n\t}\n\tif (!start[n + 1]) return false;\n\t\n\tint goal[252];\n\tfor (int i = 0; i <= n + 1; i++) goal[i] = false;\n\tgoal[n + 1] = true;\t\n\tsearch.push(n + 1);\n\twhile (!search.empty()){\n\t\tint now = search.front();\n\t\tsearch.pop();\n\t\twhile (!back[now].empty()){\n\t\t\tint from = back[now].front();\n\t\t\tback[now].pop();\n\t\t\tif (goal[from]) continue;\n\t\t\tgoal[from] = true;\n\t\t\tsearch.push(from);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n + 1; i++){\n\t\tif (start[i] && !goal[i]) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile (true){\n\t\tint mx;\n\t\tcin >> mx;\n\t\tif (!mx) break;\n\t\tint n, order[252];\n\t\tcin >> n;\n\t\torder[0] = order[n + 1] = 0;\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tcin >> order[i];\n\t\t}\n\t\tif (solve(mx, n, order)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\nint Max;\nint N;\nint D[1000];\nvector<int>G[300];\nbool S[300];\nbool T[300];\nint main()\n{\n\twhile (true){\n\t\tbool F = true;\n\t\tfor (int i = 0; i < 300; i++)G[i].clear();\n\t\tfor (int i = 0; i < 300; i++)S[i] = false;\n\t\tscanf(\"%d\", &Max);\n\t\tif (Max == 0)break;\n\t\tscanf(\"%d\", &N);\n\t\t//graph\n\t\tfor (int i = 1; i <= N; i++){\n\t\t\tscanf(\"%d\", &D[i]);\n\t\t}\n\t\tfor (int i = 0; i <= N; i++){\n\t\t\tfor (int j = 1; j <= Max; j++){\n\t\t\t\tif (i + j >= N + 1){\n\t\t\t\t\tG[i].push_back(N + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (i + j + D[i + j] < 0)G[i].push_back(0);\n\t\t\t\t\telse if (i + j + D[i + j] >= N + 1)G[i].push_back(N + 1);\n\t\t\t\t\telse G[i].push_back(i + j + D[i + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tS[0] = true;\n\t\t/*for (int i = 0; i <= N + 1; i++){\n\t\t\tprintf(\"%d:\", i);\n\t\t\tfor (int j = 0; j < G[i].size(); j++){\n\t\t\t\tprintf(\"%d \", G[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tpriority_queue<int>que;\n\t\tque.push(0);\n\t\twhile (!que.empty()){\n\t\t\tint e = que.top(); que.pop();\n\t\t\tfor (int i = 0; i < G[e].size(); i++){\n\t\t\t\tif (S[G[e][i]])continue;\n\t\t\t\tS[G[e][i]] = true;\n\t\t\t\tque.push(G[e][i]);\n\t\t\t}\n\t\t}\n\t\tfor (int s = 0; s <= N; s++){\n\t\t\tif (!S[s])continue;\n\t\t\tfor (int i = 0; i <= N + 1; i++)T[i] = false;\n\t\t\tT[s] = true;\n\t\t\tpriority_queue<int>que1;\n\t\t\tque1.push(s);\n\t\t\twhile (!que1.empty()){\n\t\t\t\tint e = que1.top(); que1.pop();\n\t\t\t\tfor (int i = 0; i < G[e].size(); i++){\n\t\t\t\t\tif (T[G[e][i]])continue;\n\t\t\t\t\tT[G[e][i]] = true;\n\t\t\t\t\tque1.push(G[e][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!T[N + 1])F = false;\n\t\t}\n\t\tif (F)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n//scanf_S"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 252\nusing namespace std;\n\nint m,n,d[N],ans;\nbool dp[N];\n\nbool OK(int x){\n  bool r=false;\n  int c=x;\n  x+=d[x];\n  if(x<0&&dp[0]) r=true;\n  if(x>=n+1) r=true;\n  if(dp[x]) r=true;\n  if(r) dp[c]=true;\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m) break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    for(int i=0;i<=n;i++) dp[i]=false;\n    dp[n+1]=true;\n    while(1){\n      int f=0;\n      for(int i=n;i>=0;i--){\n\tfor(int j=1;j<=m;j++){\n\t  if(i+j>=n+1||OK(i+j)){\n\t    if(!dp[i]) f=1;\n\t    dp[i]=true;\n\t    break;\n\t  }\n\t}\n      }\n      if(!f) break;\n    }\n    ans=0;\n    for(int i=0;i<=n;i++)\n      if(!dp[i]) ans=1;\n    if(ans) cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nint M, N;\nint D[510];\n\nint memo[510];\n\nint calc(int n){\n\tif(memo[n] != -1) return memo[n];\n\tmemo[n] = 0;\n\tfor(int i = 1; i<= M; i++){\n\t\tif(n +i > N || n + i + D[n+i] > N) memo[n] = 1;\n\t\tmemo[n] = max(memo[n], calc(max(n+i+D[n+i], 0)));\n\t}\n\treturn memo[n];\n}\n\nint main(){\n\twhile(cin>>M && M > 0) {\n\t\tcin>>N;\n\t\trep(i, 510) memo[i] = -1, D[i] = 0;\n\t\trep(i, N) cin>>D[i+1];\n\t\trep(i, M) calc(i+1);\n\t\tbool f = true;\n\t\trep(i, N+1) if(memo[i] == 0) f = false;\n\t\tcout<<(f?\"OK\":\"NG\")<<endl;\n\t\t// rep(i, N) printf(\"%3d\", memo[i]);\n\t\t// printf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint ma, n;\n\t\n\twhile (scanf(\"%d\", &ma) && ma){\n\t\tbool state[256][256] = {{0}};\n\t\tint a[256] = {0};\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n\n\t\tn += 2;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 1; j <= ma && i + j < n; j++){\n\t\t\t\tstate[i][min(n - 1, max(0, i + j + a[i + j]))] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (state[i][k] && state[k][j]) state[i][j] = true;\n\t\t\n\t\tbool ng = false;\n\t\tfor (int i = 0; i < n - 1; i++) if (state[0][i] && !state[i][n - 1]) ng = true;\n\t\tprintf(\"%s\\n\", ng ? \"NG\" : \"OK\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint mx, n;\n\twhile(cin >> mx, mx){\n\t\tcin >> n;\n\t\tvi d(n + 2), v(n + 2);\n\t\tbool ans = 1;\n\t\trep(i, n) cin >> d[i + 1];\n\t\tfunction<void(int, vi&)> rec = [&](int c, vi &v){\n\t\t\tv[c] = 1;\n\t\t\tif(c == n + 1) return;\n\t\t\tfor(int i = 1; i <= mx && c + i < n + 2; i++){\n\t\t\t\tint to = c + i + d[c + i];\n\t\t\t\tif(!v[to]) rec(to, v);\n\t\t\t}\n\t\t};\n\t\trec(0, v);\n\t\t\n\t\trep(i, n + 1) if(v[i]){\n\t\t\tvi vv(n + 2);\n\t\t\trec(i, vv);\n\t\t\tif(!vv[n + 1]){ ans = 0; break; }\n\t\t}\n\t\tcout << (ans ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define NMAX 260\nint n,dmax;\nint m[NMAX];\nbool visited[NMAX], isVisit[NMAX], goal[NMAX], isGoal;\nbool dfs(int p){\n    if(visited[p])return goal[p];\n    visited[p] = true;\n  if(p == n+1){\n    return true;\n  }\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;  \n    goal[p] = (dfs(np)||goal[p]);\n  }\n  \n  return goal[p];\n}\nvoid solve(){\n  memset(visited, 0, sizeof(visited));\n  memset(goal, 0, sizeof(goal));\n  goal[0] = dfs(0);\n  if(!goal[0]){\n    cout << \"NG\" << endl;\n    return ;\n  }\n  for(int i = 1 ; i <= n; i++){\n    if(m[i]!=0 || !visited[i])continue;\n    goal[i] = dfs(i);\n    if(!goal[i]){\n      cout << \"NG\" << endl;\n      return ;\n    }\n  }\n  cout << \"OK\" << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    m[0] = 0;\n    int i;\n    for(i = 1 ; i < n+1 ;i++){\n      cin >> m[i];\n    }\n    m[i] = 0;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nint n, m, d[255];\nbool used[255];\n\nbool bfs(){\n  \n  queue <int> que;\n  que.push(0);\n  while(!que.empty()){\n    int now = que.front(); que.pop();\n    if(used[now]) continue;\n    if(now == n) return true;\n    for(int i = 1; i < m; i++){\n      que.push(max(min(now + i + d[i + now], n), 0));\n      used[now] = true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  \n  while(cin >> m, m){\n    cin >> n;\n    d[0] = 0;\n    for(int i = 1; i <= n; i++)\n      cin >> d[i];\n    \n    memset(used, false, sizeof(used));\n    cout << (bfs() ? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nint ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\tif (ka[y][x] == 1)continue;\n\t\t\t\tka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\tfor (int j = 0; j<300; j++)\n\t\t\t{\n\t\t\t\tka[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\t/*\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\t*/\n\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\nusing namespace std;\n#include<queue>\nint main(void)\n{\n\tfor(;;){\n\t\tqueue<int> q;\n\t\tint max,n,d[252],i,j,k,p=0,e;\n\t\tscanf(\"%d %d\",&max,&n);\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tq.push(0);\n\t\twhile(p==0){\n\t\t\tk=0;\n\t\t\te=q.front();\n\t\t\tfor(i=1;i<=max;i++){\n\t\t\t\tif(e!=e+i+d[i]){\n\t\t\t\t\tk=1;\n\t\t\t\t\tq.push(e+i+d[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(k==0){\n\t\t\t\tprintf(\"NG\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(e==n+1){\n\t\t\t\tprintf(\"OK\\n\");\n\t\t\t\tp=1;\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    fill(used,used+300,false);\n    queue<int> q;\n    q.push(0);\n    int p,b;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      //cout << p << endl;\n      while(d[p]!=0){\n\tp+=d[p];\n\tif(p<0) p=0;\n\tif(p>n+1) p=n+1;\n      }\n      if(used[p]) continue;\n      used[p]=true;\n      if(used[n+1]) break;\n      for(i=1;i<=m;i++){\n\tif(p+i>n+1) q.push(n+1);\n\telse q.push(p+i);\n      }\n    }\n    if(used[n+1]) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint m,n,d[255];\nvector<int>g[255];\nbool vis[255];\nvoid dfs(int v){\n    vis[v]=true;\n    for(int i=0;i<n;i++)if(!g[v][i])dfs(g[v][i]);\n}\nint main(void){\n    while(1){\n        cin>>m>>n;\n        if(m==0)return 0;\n        for(int i=1;i<=n;i++){\n            cout<<i<<endl;\n            cin>>d[i];\n        }\n        for(int i=0;i<=n+1;i++){\n            g[i].clear();\n            vis[i]=false;\n        }\n        for(int i=0;i<=n;i++)for(int j=1;j<=m&&i+j<=n+1;j++)g[i].push_back(min(max(i+j+d[i+j],0),n+1));\n        dfs(0);\n        if(vis[n+1])cout<<\"OK\\n\";\n        else cout<<\"NG\\n\";\n        \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]=dfs(1,nx);\n    if(!memo[prev][x])ans=false;\n    return memo[prev][x];\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint n,m;\nint start,end;\nvector<int> v,p;\nbool flag;\nbool ans;\n\nvoid dfs(vector<bool> used,int now)\n{\n\tif(now == end)\n\t{\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\tif(used[now]) return;\n\tused[now] = true;\n\n\tREP(j,1,m+1)\n\t{\n\t\tif(now + j <= end)\n\t\t{\n\t\t\tif(now == now + j + v[now + j])\n\t\t\t{\n\t\t\t\tans = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(0 <= now + j + v[now + j] && now != now + j + v[now + j]) \n\t\t\t{\n\t\t\t\tdfs(used,now + j + v[now + j]);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main()\n{\n\twhile(cin >> m && m)\n\t{\n\t\tp.clear();\n\t\tp.resize(m);\n\t\trep(i,m) p[i] = i+1;\n\n\t\tcin >> n;\n\n\t\tv.clear();\n\t\tv.resize(n+2);\n\t\t\n\t\tv[0] = 0;\n\t\tstart = 0;\n\n\t\tREP(i,1,n+1) cin >> v[i];\n\n\t\tv[n+1] = 0;\n\t\tend = n+1;\n\t\n\t\tflag = false;\n\t\tans = false;\n\t\tvector<bool> used(n+2);\n\t\trep(i,n+2) used[i] = false;\n\n\t\tdfs(used,0);\n\n\t\tif(!ans) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\n//再帰flag変数\nbool flag_sugoroku[251] = {false};\n\n//入力配列\nint h_input[251] = {0};\n\n//入力変数\nint n = 0;\n//マスの数\nint masu = 0;\n\t\n\n//-- flag初期化関数 --//\n\nvoid f_syokika();\n\n\n//-- 再起関数 --//\n\nbool f_saiki(int , int);\n\n\n\nint main(void)\n{\n\twhile (cin >> n && n != 0)\n\t{\n\t\tcin >> masu;\n\t\t//成功flag\n\t\tbool ok = false;\n\n\t\tfor (int i = 0; i < masu; i++)\n\t\t{\n\t\t\tcin >> h_input[i];\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\t//必ず初期化が必要\n\t\t\tf_syokika();\n\t\t\tif (f_saiki(i , h_input[i]) == true)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\t\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n\n//*****----- flag初期化関数 -----*****//\n\nvoid f_syokika()\n{\n\tfor (int i = 0; i < 251; i++)\n\t{\n\t\tflag_sugoroku[i] = false;\n\t}\n}\n\n\n//*****----- 再起関数 -----*****//\n\nbool f_saiki(int index , int genzaiti)\n{\n\tif (index >= masu)\n\t{\n\t\treturn false;\n\t}\n\n\t//振り出しはいらない\n\tif (genzaiti < 0)\t{\treturn false;\t}\n\n\t//マスを超えていたらOK\n\tif (genzaiti >= masu)\t{\treturn true;\t}\n\n\t//既にきているなら駄目\n\tif (flag_sugoroku[genzaiti] == true)\n\t{\n\t\treturn false;\n\t}\n\n\t//現在地に到達\n\tflag_sugoroku[genzaiti] = true;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tf_saiki(index + 1 , genzaiti + h_input[i]);\n\t}\n\n\t//来てないことにする\n\tflag_sugoroku[genzaiti] = false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint limit,V,d[300],n;\n\nint main(){\n  while( cin >> limit, limit ){\n    cin >> n;\n    V = n + 2;\n    d[0] = d[V-1] = 0;\n    rep(i,n) cin >> d[i+1];\n    vector<vector<int> > G(V);\n    rep(i,V-1) {\n      if( d[i] == 0 ) {\n        REP(j,1,limit+1) {\n          int next = i + j;\n          if( next >= V ) break;\n          if( i != next ) G[i].push_back(next);\n        }\n      } else {\n        int next = i + d[i];\n        if( next <  0 ) next = 0;\n        if( next >= V ) next = V-1;\n        if( i != next ) G[i].push_back(next);\n      }\n    }\n    vector<bool> used(V,false);\n    used[0] = true;\n    deque<int> deq;\n    deq.push_back(0);\n    while( !deq.empty() ){\n      int cur = deq.front(); deq.pop_front();\n      rep(i,G[cur].size()){\n        int next = G[cur][i];\n        if( !used[next] ) {\n          used[next] = true;\n          deq.push_back(next);\n        }\n      }\n    }\n    puts(used[V-1]?\"OK\":\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool g[251][251];\n\nint main(){\n\n  while(1){\n\n    int max;\n\n    cin >> max;\n\n    if(max == 0){\n      break;\n    }\n\n    int n;\n\n    cin >> n;\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n        g[i][j] = false;\n      }\n    }\n\n    int mass[n+2];\n\n    mass[0] = 0;\n    mass[n+1] = 0;\n\n    for(int i=1;i<n+1;i++){\n      cin >> mass[i];\n    }\n\n    for(int i=0;i<n+1;i++){\n      for(int j=1;j<=max;j++){\n        int next;\n        if(i+j>=n+2){\n          next = n+1;\n        }\n        else{\n          next = i+j+mass[i+j];\n        }\n\n        if(next<0) next = 0;\n        if(next>n+2) next=n+1;\n        g[i][next] = true;\n      }\n    }\n\n    for(int k=0;k<n+2;k++){\n      for(int i=0;i<n+2;i++){\n        for(int j=0;j<n+2;j++){\n          if(g[i][k] && g[k][j]){\n            g[i][j] = true;\n          }\n        }\n      }\n    }\n\n    bool flag = true;\n\n    for(int i=0;i<n+1;i++){\n      if(g[0][i] && !g[i][n+1]){\n        flag = false;\n        break;\n      }\n    }\n\n    if(flag){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nint ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\t//if (ka[y][x] == 1)break;\n\t\t\t\t//ka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\tfor (int j = 0; j<300; j++)\n\t\t\t{\n\t\t\t\tka[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\t/*\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\t*/\n\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint main(){\n    int ma;\n    while(scanf(\"%d\",&ma),ma){\n        int n;\n        int stage[256]={0};\n        int D[256][256]={{0}};\n        scanf(\"%d\",&n);\n        reps(i,1,n+1){\n            scanf(\"%d\",&stage[i]);\n        }\n        rep(i,n+1){\n            reps(j,1,ma+1){\n                int tmp = i+j;\n                if(stage[tmp]==0)D[i][tmp] = 1;\n                else if(stage[tmp]>0){\n                    if(tmp+stage[tmp]>n+1)tmp = n+1;\n                    else tmp += stage[tmp];\n                    D[i][tmp] = 1;\n                }\n                else{\n                    if(tmp+stage[tmp]<0)tmp = 0;\n                    else tmp += stage[tmp];\n                    D[i][tmp] =  1;\n                }\n            }\n        }\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    if(D[i][k] && D[k][j]){\n                        D[i][j] = 1;\n                    }\n                }\n            }\n        }\n        /*\n        puts(\"--------------------------\");\n        rep(i,n+2){\n            rep(j,n+2){\n                printf(\"%d \",D[i][j]);\n            }\n            puts(\"\");\n        }\n        puts(\"--------------------------\");\n        */\n        bool flg = true;\n        rep(i,n+1){\n            if(D[0][i] && !D[i][n+1]){\n                flg = false;\n                break;\n            }\n        }\n        flg ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nbool dfs(int now, vector<bool> &visited, vector< vector<int> > &g, vector<int> &v){\n  //cout <<\"now = \" <<v[now] <<endl;\n  if(v[now] == 0) return true;\n  if(visited[now]) return false;\n  int next = g[now][0];\n  visited[next] = true;\n  return dfs(next, visited, g, v);\n}\n\nint main() {\n  int MAX;\n  while(cin >>MAX && MAX){\n    int N; cin >>N;\n    vector<int> v(N + 2, 0); FOR(i, 1, N + 1) cin >>v[i];\n    vector< vector<int> > g(N + 2, vector<int>());\n    REP(i, N + 1){\n      if(v[i] == 0){\n        FOR(j, i + 1, min(N + 1, i + MAX) + 1) g[i].push_back(j);\n      } else if(v[i] < 0){\n        int next = max(0, i + v[i]);\n        g[i].push_back(next);\n      } else {\n        int next = min(N + 1, i + v[i]);\n        g[i].push_back(next);\n      }\n    }\n    //REP(i, g.size()){\n    //  cout <<i <<\": \";\n    //  REP(j, g[i].size()) cout <<g[i][j] <<\" \";\n    //  cout <<endl;\n    //}\n    bool isOK = true;\n    REP(i, N + 1){\n      if(v[i] == 0){\n        bool f = false;\n        REP(j, g[i].size()){\n          vector<bool> visited(N + 2, false);\n          dfs(g[i][j], visited, g, v);\n          if(!visited[0]) f = true;\n        }\n        if(!f) isOK = false;\n      } else{\n        vector<bool> visited(N + 2, false);\n        bool tmp = dfs(i, visited, g, v);\n        if(!tmp) isOK = false;\n      }\n      //REP(i, visited.size()) cout <<visited[i] <<\" \"; cout <<endl;\n      //cout <<i <<\" (\" <<v[i] <<\") : \";\n    }\n    cout <<(isOK ? \"OK\" : \"NG\") <<endl;\n  } return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(1,nx);\n    if(!memo[prev][x])ans=false;\n    return memo[prev][x];\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll m,n;\n  while(cin >> m &&m){\n    cin >> n;\n    vary(ll,v,n,0);\n    rep(i,n){\n      cin >> v[i];\n    }\n    bool ans = true;\n    rep(x,n){\n      vary(bool,dp,2 * n+1,false);\n      dp[0] = true;\n      int s = x+1;\n      if(s < 0) s = 0;\n      if(s > n) dp[s] = true;\n      if(s > 0 && s <= n){\n        s += v[s-1];\n      }\n      if(s < 0) s = 0;\n      dp[s] = true;\n      if(s)\n        dp[0] = false;\n      rep(y,255){\n        rep(i,n+1){\n          rep(j,m){\n            int s = j+1 + i;\n            if(s < 0) s = 0;\n            if(s > n) dp[s] = dp[s] | dp[i];\n            if(s > 0 && s <= n){\n              s += v[s-1];\n            }\n            if(s < 0) s = 0;\n            dp[s] = dp[i] | dp[s];\n          }\n        }\n      }\n      bool f = false;\n      REP(i,n+1,2 * n+1){\n        f |= dp[i];\n      }\n      ans = ans & f;\n    }\n    if(ans){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> a;\nint n,m;\nvector<bool> d(300);\n\nbool saiki(int p1,int pre,vector<int> u){\n    int p = p1;\n  //  if(u[p] > 2) return true;\n    //if(!d[p]) return false;\n    u[p]++;\n    bool ans = false;\n\n    bool flg = false;\n    for(int i=1;i<=m;i++){\n\tif(u[min(p+i,n+1)] == 0) flg = true;\n    }\n    if(!flg) return true;\n    for(int i=1;i<=m;i++){\n\tp = p1;\n\tp += i;\n\tp = min(p,n+1);\n\tu[p]++;\n\t//printf(\"m = %d i = %d p = %d a[p] = %d\\n\",m,i,p,a[p]);\n\tif(a[p] == 300) return d[p1] = false;\n\tp += a[p];\n\tp = min(p,n+1);\n\tp = max(p,0);\n\tif(u[p] < 100)\n\t    ans = ans | saiki(p,p1,u);\n    }\n    return d[p] = ans;\n}\n\nint main(){\n    while(true){\n\tfill(ALL(d),true);\n\ta = vector<int>(0);\n\tcin >> m;\n\tif(m == 0) break;\n\tcin >> n;\n\ta.PB(-300);\n\tREP(i,n){\n\t    int temp;\n\t    cin >> temp;\n\t    a.PB(temp);\n\t}\n\ta.PB(300);\n\tif(!saiki(0,0,vector<int>(n+2,0))) cout << \"OK\" << endl;\n\telse cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]=dfs(1,nx);\n    //    if(!memo[prev][x])ans=false;\n    return memo[prev][x];\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define MN 252\n\nint next(int n);\n\nvector<int> G[MN];\n\nint max_, n_, D[MN];\nbool init() {\n    cin >> max_; \n    if (max_ == 0) return false;\n    cin >> n_;\n    D[0] = D[n_+1] = 0;\n    for (int i = 1; i <= n_; i++) cin >> D[i];\n    for (int i = 0; i <= n_+1; i++) {\n        for (int j = 1; j <= max_; j++) {\n            if (i == next(i+j)) continue;\n            G[i].push_back(next(i+j));\n        }\n    }\n    return true;\n}\n\nint next(int n) {\n    n = max(0, min(n_+1, n));\n    return max(0, min(n_+1, n + D[n]));\n}\n\nbool visit[MN];\nbool dfs(int n) {\n    if (visit[n]) return false;\n    visit[n] = true;\n    for (int i = 0; i < G[n].size(); i++) {\n        if (!dfs(G[n][i])) { \n            return false;\n        }\n    }\n    visit[n] = false;\n    return true;\n}\nbool loop() {\n    memset(visit, 0, sizeof(visit));\n    return dfs(0);\n}\n\nbool reach() {\n    queue<int> Q;\n    bool v[MN]; for (int i = 0; i < MN; i++) v[i] = false;\n    Q.push(0); v[0] = true;\n    while (!Q.empty()) {\n        int n = Q.front(); Q.pop();\n        for (int i = 1; i <= max_; i++) {\n            int nxt = next(n+i);\n            if (!v[nxt]) {\n                v[nxt] = true;\n                Q.push(nxt);\n            }\n        }\n    }\n    return v[n_+1];\n}\n\nint main() {\n    while (init()) {\n        cout << (loop() && reach() ? \"OK\" : \"NG\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_count,int arg_loc){\n\t\tcount = arg_count;\n\t\tloc = arg_loc;\n\t}\n\tint count,loc;\n};\n\nvoid func(int MAX,int N){\n\n\tint min_Count_Base[N+2];\n\tint min_Count_Work[N+2];\n\tint instruction[N+2];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&instruction[i]);\n\t\tmin_Count_Base[i] = BIG_NUM;\n\t}\n\n\tmin_Count_Base[0] = 0;\n\tmin_Count_Base[N+1] = BIG_NUM;\n\n\tinstruction[0] = 0;\n\tinstruction[N+1] = 0;\n\n\tint next_loc;\n\n\tqueue<Info> Q;\n\tQ.push(Info(0,0));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().loc == N+1){\n\t\t\tQ.pop();\n\t\t}else if(Q.front().count > min_Count_Base[Q.front().loc]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= MAX; i++){\n\t\t\t\tnext_loc = Q.front().loc+i;\n\n\t\t\t\tif(next_loc > N+1){\n\t\t\t\t\tnext_loc = N+1;\n\t\t\t\t}else if(next_loc < 0){\n\t\t\t\t\tnext_loc = 0;\n\t\t\t\t}\n\n\t\t\t\tnext_loc += instruction[next_loc];\n\n\t\t\t\tif(next_loc > N+1){\n\t\t\t\t\tnext_loc = N+1;\n\t\t\t\t}else if(next_loc < 0){\n\t\t\t\t\tnext_loc = 0;\n\t\t\t\t}\n\n\t\t\t\tif(min_Count_Base[next_loc] > Q.front().count+1){\n\t\t\t\t\tmin_Count_Base[next_loc] = Q.front().count+1;\n\t\t\t\t\tQ.push(Info(Q.front().count+1,next_loc));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(min_Count_Base[N+1] == BIG_NUM){\n\t\tprintf(\"NG\\n\");\n\t\treturn;\n\t}\n\n\tbool FLG = true;\n\n\tfor(int start = 1; start <= N; start++){\n\t\tif(min_Count_Base[start] != BIG_NUM){\n\n\t\t\tfor(int i = 0; i <= N+1; i++){\n\t\t\t\tmin_Count_Work[i] = BIG_NUM;\n\t\t\t}\n\n\t\t\tmin_Count_Work[0] = 0;\n\n\t\t\tQ.push(Info(0,start));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tif(Q.front().loc == N+1){\n\t\t\t\t\tQ.pop();\n\t\t\t\t}else if(Q.front().count > min_Count_Work[Q.front().loc]){\n\t\t\t\t\tQ.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\tfor(int i = 1; i <= MAX; i++){\n\t\t\t\t\t\tnext_loc = Q.front().loc+i;\n\n\t\t\t\t\t\tif(next_loc > N+1){\n\t\t\t\t\t\t\tnext_loc = N+1;\n\t\t\t\t\t\t}else if(next_loc < 0){\n\t\t\t\t\t\t\tnext_loc = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext_loc += instruction[next_loc];\n\n\t\t\t\t\t\tif(next_loc > N+1){\n\t\t\t\t\t\t\tnext_loc = N+1;\n\t\t\t\t\t\t}else if(next_loc < 0){\n\t\t\t\t\t\t\tnext_loc = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(min_Count_Work[next_loc] > Q.front().count+1){\n\t\t\t\t\t\t\tmin_Count_Work[next_loc] = Q.front().count+1;\n\t\t\t\t\t\t\tQ.push(Info(Q.front().count+1,next_loc));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tQ.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(min_Count_Work[N+1] == BIG_NUM){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(!FLG){\n\t\tprintf(\"NG\\n\");\n\t}else{\n\t\tprintf(\"OK\\n\");\n\t}\n}\n\nint main(){\n\n\tint MAX,N;\n\twhile(true){\n\t\tscanf(\"%d\",&MAX);\n\t\tif(MAX == 0)break;\n\n\t\tscanf(\"%d\",&N);\n\t\tfunc(MAX,N);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 10;\nint m,n;\nint x[300];\nint hoge[300];\nint used[300];\nint f(int num){\n    int ans = 0;\n    if(x[num]!=INF){\n        return x[num];\n    }else if(used[num] && x[num] == INF){\n        cout << num;\n        return 0;\n    }\n    if(num >= n){\n        return 1;\n    }\n    used[num] = 1;\n    ans = min(f(num + hoge[num]),INF);\n    return ans;\n}\n\nsigned main(){\n    while(1){\n        cin >> m;\n        if(m == 0)break;\n        cin >> n;\n        fill(x,x+300,INF);\n        fill(used,used+300,0);\n        for(int i = 1; i <= n; i++){\n            cin >> hoge[i];\n        }\n        bool ans = true;\n        for(int i = 1; i <= n; i++){\n            if(hoge[i] < 0){\n                int k = 1;\n                for(int j = 1; j <= (m -1) && (j + i) <= n; j++){\n                    if(hoge[i + j] < -j){\n                        //cout << (i + j) << \"hoge\" << endl;\n                        k++;\n                    }\n                }\n                if(k == m){\n                    ans = false;\n                }\n            }\n        }\n        if(ans){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define MAX_N 300\nint m,n;\nint arr[MAX_N];\nint visited[MAX_N];\nint visited2[MAX_N];\n\nvoid init();\nvoid rec(int);\nint solve(int);\n\nint main(){\n  int i,j,a,b;\n  while(1){\n    init();\n    scanf(\"%d\",&m);\n    if(m==0)break;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n      scanf(\"%d\",&a);\n      b=i+a;\n      if(b<0)b=0;\n      if(b>n+1)b=n+1;\n      arr[i]=b;\n    }\n    for(i=0;i<=n+1;i++){\n      if(arr[i]==n+1)rec(i);\n    }\n    /*\n    for(i=0;i<=n+1;i++){\n      printf(\"%d \",visited[i]);\n    }\n    printf(\"\\n\");\n    */\n    if(solve(0))printf(\"NG\\n\");\n    else printf(\"OK\\n\");\n  }\n  return 0;\n}\n\nint solve(int pos){\n  if(visited2[pos])return 0;\n  visited2[pos]=1;\n  if(!visited[pos])return 1;\n  int i,a;\n  for(i=1;i<=m;i++){\n    a=pos+i;\n    if(a>n+1)break;\n    a=arr[a];\n    if( solve(a) )return 1;\n  }\n  return 0;\n}\n\nvoid rec(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  int i,j,a;\n  for(i=1;i<=m;i++){\n    a=pos-i;\n    if(a<0)break;\n    for(j=0;j<=n+1;j++){\n      if(arr[j]==a)rec(j);\n    }\n  }\n}\n\nvoid init(){\n  int i,j;\n  for(i=0;i<MAX_N;i++){\n    arr[i]=i;\n    visited[i]=0;\n    visited2[i]=0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<bitset>\n#include<vector>\nusing namespace std;\n\n\n\nint main()\n{\nint n,mex;\n  while(cin >> mex,mex)\n    {\n      cin >> n;\n      vector<int> G(n+1);\n      int out[n+1];\n\n      for(int i=1;i<=n;i++)\n\t{\n\t  cin >> G[i];\n\t  out[i] = 0;\n\t}\n      out[0] = 0;\n\n      for(int i=1;i<=n;i++)\n\tif(G[i] < 0)\n\t  for(int j=i-1;j>=i+G[i] && j >= 0;j--)\n\t    out[j]++;\t    \n\n      for(int i=0;i<n;i++)\n\t{\n\t  if(out[i] >= mex && (G[i] >= 0 && out[i] >= G[i]))\n\t    {\n\t      cout << \"NG\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"OK\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1001001001;\n\nint MAX, N, dist[260][260], D[260];\nbool can[260];\n\nvoid dfs(int u){\n\tFOR(v,1,N+3){\n\t\tif(dist[u][v] != INF && !can[v]){\n\t\t\tcan[v] = true;\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\n\nint main(){\n  while(scanf(\"%d %d\", &MAX, &N), MAX){\n    std::fill(D, D+260, 0);\n    std::fill(can, can+260, false);\n\n    FOR(i,2,N+2){\n      scanf(\"%d\", D+i);\n      // printf(\"%d: %d\\n\", i, D[i]);\n    }\n\n    FOR(i,1,N+3){FOR(j,1,N+3){if(i==j){dist[i][j]=0;}else{dist[i][j]=INF;}}}\n\n    FOR(i,1,N+3){\n      for(int j=1;j<=MAX&&i+j<=N+2;j++){\n        int k = i+j+D[i+j];\n        if(k < 0){k = 0;}\n        if(k > N+2){k = N+2;}\n        if(i == k){continue;}\n        // printf(\"%d, %d, %d, %d\\n\", i, j, D[i+j], k);\n        dist[i][k] = 1;\n      }\n    }\n    \n    can[1] = true;\n    dfs(1);\n\n    FOR(k,1,N+3){\n      FOR(i,1,N+3){\n        FOR(j,1,N+3){\n          if(dist[i][j] > dist[i][k] + dist[k][j]){dist[i][j] = dist[i][k] + dist[k][j];}\n        }\n      }\n    }\n\n    bool f = true;\n    FOR(i,1,N+3){\n      if(!can[i]){continue;}\n      // printf(\"%d->N+2: %d\\n\", i, dist[i][N+2]);\n      if(dist[i][N+2] == INF){f = false;}\n    }\n\n    if(f){puts(\"OK\");}\n    else{puts(\"NG\");}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(1,nx);\n    //    if(!memo[prev][x])ans=false;\n    return memo[prev][x];\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nqueue<int> q;\n\nbool t[252];\nint d[252];\n\nint maxw;\n\nint n;\n\nvoid tw(int a)\n{\n\tif(a < 0)\n\t{\n\t\tif(!t[0])\n\t\t{\n\t\t\tt[0] = true;\n\t\t\tq.push(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!t[a])\n\t\t{\n\t\t\tt[a] = true;\n\t\t\tq.push(a);\n\t\t}\n\t}\n}\n\nvoid tou(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttw(a - i);\n\t}\n}\n\nvoid syo(int a)\n{\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(i + d[i] == a)\n\t\t{\n\t\t\ttou(a);\n\t\t}\n\t}\n}\n\nvoid init()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt[i] = false;\n\t}\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\tif(n + 1 - i >= 0)\n\t\t{\n\t\t\tt[n + 1 - i] = true;\n\t\t\tq.push(n + 1 - i);\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(d[i] + i >= n + 1)\n\t\t{\n\t\t\ttou(i);\n\t\t}\n\t}\n}\n\nvoid modo()\n{\n\tinit();\n\twhile(!q.empty())\n\t{\n\t\tint w = q.front();\n\t\tq.pop();\n\t\tsyo(w);\n\t}\n}\n\nqueue<int> q2;\n\nbool t2[252];\n\nvoid tw2(int a)\n{\n\tif(a < n + 1)\n\t{\n\t\tif(!t2[a])\n\t\t{\n\t\t\tt2[a] = true;\n\t\t\tq2.push(a);\n\t\t}\n\t}\n\telse\n\t{\n\t\tt2[n + 1] = true;\n\t}\n}\n\nvoid tou2(int a)\n{\n\tif(a >= n + 1)\n\t{\n\t\tt2[n + 1] = true;\n\t}\n\telse\n\t{\n\t\ttw2(a + d[a]);\n\t}\n}\n\nvoid syo2(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttou2(a + i);\n\t}\n}\n\nvoid init2()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt2[i] = false;\n\t}\n\tq2.push(0);\n\tt2[0] = true;\n}\n\nvoid modo2()\n{\n\tinit2();\n\twhile(!q2.empty())\n\t{\n\t\tint w = q2.front();\n\t\tq2.pop();\n\t\tsyo2(w);\n\t}\n}\n\nbool can()\n{\n\tif(!t2[n + 1])\n\t{\n\t\treturn false;\n\t}\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tif(t2[i])\n\t\t{\n\t\t\tif(!t[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&maxw);\n\t\tif(maxw == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\td[0] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\",d + i);\n\t\t}\n\t\td[n + 1] = 0;\n\t\tmodo();\n\t\tmodo2();\n\t\tif(can())\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvector<char> bfs(const vector<vector<int> > &G, int start){\n\tint v = G.size();\n\tvector<char> visit(v);\n\n\tqueue<int> q;\n\tq.push(start);\n\tvisit[start] = 1;\n\n\twhile(!q.empty()){\n\t\tfor(int i = 0; i < G[q.front()].size(); ++i){\n\t\t\tint t = G[q.front()][i];\n\t\t\tif(!visit[t]){\n\t\t\t\tvisit[t] = 1;\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n\n\treturn visit;\n}\n\nbool solve(int m, int n){\n\tvector<int> d(n + 2);\n\tfor(int i = 1; i <= n; ++i){\n\t\tscanf(\"%d\", &d[i]);\n\t}\n\n\tvector<vector<int> > G(n + 2), rG(n + 2);\n\tfor(int i = 0; i <= n; ++i){\n\t\tfor(int j = 1; j <= m; ++j){\n\t\t\tint t = i + j;\n\t\t\tif(t > n + 1) break;\n\t\t\tt += d[t];\n\n\t\t\tif(t < 0){ t = 0; }\n\t\t\telse if(t > n + 1){ t = n + 1; }\n\n\t\t\tG[i].push_back(t);\n\t\t\trG[t].push_back(i);\n\t\t}\n\t}\n\n\tvector<char> reach = bfs(G, 0), goal = bfs(rG, n + 1);\n\tfor(int i = 0; i < n + 2; ++i){\n\t\tif(reach[i] && !goal[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n, m;\n\twhile(scanf(\"%d%d\", &m, &n) == 2){\n\t\tputs(solve(m, n) ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n#define ALL(co) co.begin(), co.end()\n#define tpl(...) make_tuple(__VA_ARGS__)\n\ntypedef long long LL;\ntypedef pair<int, int> P; typedef pair<int, P> IP; typedef pair<P, P> PP;\ntypedef vector<int> Array; typedef vector<vector<int> > Array2;\ntypedef vector<LL> LArray; typedef vector<P> PArray; typedef vector<string> SArray;\n\nconst int INF = 1 << 29;\nconst LL LINF = 1LL << 60;\n\ninline int getInt() { int itiv; return (cin >> itiv, itiv); }\ntemplate <typename T> void readAll(vector<T>& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i]; }\ntemplate <typename T, typename U> void readAll(vector<pair<T, U> >& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i].first >> vec[i].second; }\ntemplate < typename T > inline string toString( const T &a ){ ostringstream oss; oss << a; return oss.str(); };\ninline bool between(int min, int max, int n) { return min <= n && n <= max; }\ninline bool inRange(int begin, int end, int n) { return begin <= n && n < end; }\ninline bool inRange(int size, int n) { return 0 <= n && n < size; }\n\nint dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\nint dr[] = { 0, -1, 0, 1 }, dc[] = { -1, 0, 1, 0 };\n\n\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\tint n, mx;\n\twhile(cin >> mx && mx)\n\t{\n\t\tcin >> n;\n\t\tArray arr(n + mx + 2);\n\t\tArray2 graph(n + mx + 1, Array());\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tarr[i + 1] = getInt();\n\t\t}\n\n\t\tfor (int i = 0; i < n + 2; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= mx; j++)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(max(i + j + arr[i + j], 0));\n\t\t\t}\n\t\t}\n\n\t\tvector<bool> visited(n + mx + 1);\n\t\tfunction<bool(int)> dfs = [&](int x){\n\t\t\tif(x >= n + 2) return true;\n\t\t\t\n\t\t\tvisited[x] = true;\n\t\t\tfor(auto nx : graph[x])\n\t\t\t{\n\t\t\t\tif(visited[nx]) continue;\n\t\t\t\tif(dfs(nx)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tbool ans = true;\n\t\tfor (int i = 0; i < graph[0].size(); i++)\n\t\t{\n\t\t\tans = ans && dfs(graph[0][i]);\n\t\t}\n\t\tcout << (ans ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int> >G(252),R(252);\nint n,m;\nint d[252];\nbool u[252];\nvoid f(int v)\n{\n\tu[v]=1;\n\tfor(int i=0;i<R[v].size();i++)\n\t{\n\t\tif(!u[R[v][i]])f(R[v][i]);\n\t}\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<=n+1;i++)G[i].clear(),R[i].clear(),u[i]=0;\n\t\tfor(int i=1;i<=n;i++)cin>>d[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m&&i+j<=n+1;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+d[i+j];\n\t\t\t\tif(k>n+1)k=n+1;\n\t\t\t\tif(k<0)k=0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n+1);\n\t\tbool ok=1;\n\t\tfor(int i=1;i<=m;i++)ok&=u[i];\n\t\tcout<<(ok?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint Max, n, d[251];\nbool dfs(int x){\n    if(x >= 0){\n        if(x >= n + 1)  return 1;\n        for(int i = 1; i < Max; i++){\n            x += i;\n            if(x >= n + 1)  return 1;\n            x += d[x];\n            dfs(x);\n        }\n    }\n    return 0;\n}\n\nint main(void){\n    while(1){\n        cin >> Max;\n        if(Max == 0)    break;\n        cin >> n;\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        if(dfs(0))   cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint MAX,N;\nint d[300];\n\n\nbool a[300],b[300];\nvector<int>ga[300],gb[300];\n\nvoid f(int x){\n    if(a[x])return;\n    a[x]=true;\n    for(int i=0;i<ga[x].size();i++)f(ga[x][i]);\n}\n\nvoid g(int x){\n    if(b[x])return;\n    b[x]=true;\n    for(int i=0;i<gb[x].size();i++)g(gb[x][i]);\n}\n\nvoid solve(){\n    for(int i=0;i<=N+1;i++){\n        a[i]=b[i]=false;\n        ga[i]=gb[i]=vector<int>();\n    }\n\n    for(int i=0;i<=N;i++){\n        for(int j=1;j<=MAX;j++){\n            int to=max(min((min(i+j,N+1)+d[min(i+j,N+1)]),N+1),0);\n            ga[i].push_back(to);\n            gb[to].push_back(i);\n        }\n    }\n\n    f(0);g(N+1);\n\n    for(int i=0;i<=N;i++){\n        if(a[i]&&(!b[i])){\n            cout<<\"NG\"<<endl;\n            return;\n        }\n    }\n\n    cout<<\"OK\"<<endl;\n\n}\n\nbool input(){\n    cin>>MAX;\n    if(!MAX)return false;\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>d[i+1];\n    d[N+1]=0;\n    return true;\n}\n\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define N 250\n#define CLAMP(X,A,B) \\\n  max ( 0, min ( (X), (B) ) )\n\nstatic int d[ N + 2 ];\nstatic int n;\nstatic int m;\n\nstatic int\ndp (\n  int *r,\n  int  b\n  )\n{\n  queue<int> lis;\n  int i;\n\n  fill ( r, r + n + 2, 0 );\n  lis.push ( b );\n  while ( !lis.empty ( ) )\n  {\n    const int t = lis.front ( );\n    lis.pop ( );\n\n    if ( r[ t ] ) continue ;\n    r[ t ] = 1;\n\n    for ( i = 1; i <= m; ++i )\n      lis.push ( CLAMP( d[ CLAMP( t + i, 0, n + 1 ) ], 0, n + 1 ) );\n  }\n\n  return ( r[ n + 1 ] );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int v[ N + 2 ];\n\n    scanf ( \"%d\", &m );\n    if ( m == 0 ) break ;\n    scanf ( \"%d\", &n );\n    for ( i = 1; i <= n; ++i )\n      scanf ( \"%d\", &d[ i ] );\n    d[ 0 ] = d[ n + 1 ] = 0;\n    for ( i = 1; i <= n + 1; ++i )\n      d[ i ] = i + d[ i ];\n\n    if ( !dp ( v, 0 ) )\n    {\n      puts ( \"NG\" );\n      continue ;\n    }\n    for ( i = 0; i <= n + 1; ++i )\n    {\n      int t[ N + 2 ];\n\n      if ( v[ i ] ) continue ;\n      if ( !dp ( t, i ) ) break ;\n    }\n    if ( i > n + 1 )\n      puts ( \"OK\" );\n    else\n      puts ( \"NG\" );\n  }\n\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint Step, N;\nint NodeInfo[252];\nbool Result[252][252];\n\n\nbool solve() {\n\n\tfor (int k = 0; k <= N + 1; ++k) {\n\t\tfor (int i = 0; i <= N + 1; ++i) {\n\t\t\tfor (int j = 0; j <= N + 1; ++j) {\n\t\t\t\tif (Result[i][k] && Result[k][j]) {\n\t\t\t\t\tResult[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= N; ++i) {\n\t\tif (Result[0][i] && (!Result[i][N + 1])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid createMapData() {\n\tint currentNode;\n\n\tfor (int i = 0; i <= N; ++i) {\n\t\tfor (int j = 1; j <= Step; ++j) {\n\t\t\tcurrentNode = i + j;\n\t\t\tif (currentNode > N) {\n\t\t\t\tResult[i][N + 1] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcurrentNode = max(0, currentNode += NodeInfo[currentNode]);\n\t\t\tif (currentNode >= N) {\n\t\t\t\tResult[i][N + 1] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tResult[i][currentNode] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\n\twhile (cin >> Step, Step) {\n\t\tmemset(NodeInfo, 0, sizeof(NodeInfo));\n\t\tmemset(Result, false, sizeof(Result));\n\t\tcin >> N;\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tcin >> NodeInfo[i];\n\t\t}\n\n\t\tcreateMapData();\n\t\tif (solve()) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nint n, m, d[255];\nbool used[255];\n\nbool bfs(){\n  \n  queue <int> que;\n  que.push(0);\n  while(!que.empty()){\n    int now = que.front(); que.pop();\n    if(used[now]) continue;\n    if(now == n) return true;\n    for(int i = 1; i <= m; i++){\n      que.push(max(min(now + i + d[i + now], n), 0));\n      used[now] = true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  \n  while(cin >> m, m){\n    cin >> n;\n    d[0] = 0;\n    for(int i = 1; i <= n; i++)\n      cin >> d[i];\n    \n    memset(used, false, sizeof(used));\n    cout << (bfs() ? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main(){\t\n\tfor(int m,n,i,j,k,a;a=1,scanf(\"%d\",&m),m;puts(a?\"OK\":\"NG\")){\n\t\tint d[300]={0},g[300][300]={0};\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;)scanf(\"%d\",d+i++);\n\t\tfor(i=0;i<=n;i++)\n\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\tk=i+j+d[i+j],(k=k<0?0:n+1<k?n+1:k),g[i][k]=1;\n\t\tfor(k=0;k<n+2;k++)\n\t\t\tfor(i=0;i<n+2;i++)\n\t\t\t\tfor(j=0;j<n+2;j++)\n\t\t\t\t\tif(g[i][k]&&g[k][j])g[i][j]=1;\n\t\tfor(i=0;i<=n;i++)\n\t\t\tif(g[0][i]&&!g[i][n+1])a=0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={},o[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    for(i=1;i<=n;i++){\n      p=i;\n      while(d[p]!=0){\n\tp+=d[p];\n\tif(p<0) p=0;\n\tif(p>n+1) p=n+1;\n      }\n      o[i]=p;\n    }\n    o[n+1]=n+1;\n    fill(used,used+300,false);\n    \n    queue<int> q;\n    q.push(0);\n    while(!q.empty()){\n      p=q.front();q.pop();\n      //cout << p << endl;\n      p=o[p];\n      if(used[p]) continue;\n      used[p]=true;\n      if(used[n+1]) break;\n      for(i=1;i<=m;i++){\n\tif(p+i>n+1) q.push(n+1);\n\telse q.push(p+i);\n      }\n    }\n    if(used[n+1]) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int> >G(252),R(252);\nint n,m;\nint d[552];\nbool u[252];\nvoid f(int v)\n{\n\tu[v]=1;\n\tfor(int i=0;i<R[v].size();i++)\n\t{\n\t\tif(!u[R[v][i]])f(R[v][i]);\n\t}\n}\nbool vi[252];\nvoid ok(int v)\n{\n    vi[v]=1;\n    for(int i=0;i<G[v].size();i++)\n    {\n        if(!vi[G[v][i]])ok(G[v][i]);\n    }\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<=n+1;i++)G[i].clear(),R[i].clear(),d[i]=vi[i]=u[i]=0;\n\t\tfor(int i=1;i<=n;i++)cin>>d[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m&&i+j<=n+1;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+d[i+j];\n\t\t\t\tif(k>n+1)k=n+1;\n\t\t\t\tif(k<0)k=0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n+1);ok(0);\n\t\tbool flag=1;\n\t\tfor(int i=0;i<=n+1;i++)if(vi[i]&&!u[i])flag=0;\n\t\tcout<<(flag?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint main(void){\n  int roulette;\n  while(cin >> roulette, roulette){\n    int n;\n    cin >> n;\n    vector<signed int> d(n+2);\n    REP(i,n){\n      cin >> d[i+1];\n    }\n\n    vector<bool>loop(n+2, false);\n\n    loop[0] = true;\n\n    REP(asdf, 3){\n      for(int pos = 0; pos < n+2; pos++){\n        if(loop[pos] == false) continue;\n        for(int r = 1; r <= roulette; r++){\n          int npos = pos + r + d[pos+r];\n          npos = max(0, min(n+2-1, npos));\n          loop[npos] = true;\n        }\n      }\n    }\n\n    bool flg;\n    REP(i,n+2){\n      if(loop[i] == false) continue;\n      flg = false;\n      REP(j, roulette){\n        int delta = j+1;\n        if(!(d[i+delta] <= -delta)) flg = true;\n      }\n      if(flg == false){\n        break;\n      }\n    }\n    if(flg) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int max,n,data[255];\n  bool MAS[255][255];\n  while(1){\n    memset(MAS,false,sizeof(MAS));\n    memset(data,false,sizeof(data));\n    cin >> max;\n    if(max==0)break;\n    cin >> n;\n    for(int i=1;i<=n;i++) cin >> data[i];\n    for(int j=0;j<=n;j++){\n      for(int i=1;i<=max && j+i<n+2;i++){\n\tif(j+i==n+1)MAS[j][n+1]=true;\n\telse j+i+data[j+i]>=n+1 ? MAS[j][n+1]=true : MAS[j][j+i+data[i+j]]=true;\n      }\n    }\n\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n\tfor(int k=0;k<n+2;k++){\n\t  if(MAS[j][i]&&MAS[i][k]){\n\t    MAS[j][k]=true;\n\t  }\n\t}\n      }\n    }\n    bool flg=false;\n    for(int i=0;i<=n;i++){\n      if(MAS[0][i]&&(!MAS[i][n+1])){\n\tflg=true;\n\tbreak;\n      }\n    }\n    cout << (flg?\"NG\":\"OK\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nqueue<int> q;\n\nbool t[252];\nint d[252];\n\nint maxw;\n\nint n;\n\nvoid tw(int a)\n{\n\tif(a <= 0)\n\t{\n\t\tif(!t[0])\n\t\t{\n\t\t\tt[0] = true;\n\t\t\tq.push(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!t[a])\n\t\t{\n\t\t\tt[a] = true;\n\t\t\tq.push(a);\n\t\t}\n\t}\n}\n\nvoid tou(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttw(a - i);\n\t}\n}\n\nvoid syo(int a)\n{\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(i + d[i] == a)\n\t\t{\n\t\t\ttou(i);\n\t\t}\n\t}\n}\n\nvoid init()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt[i] = false;\n\t}\n\tt[n + 1] = true;\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\tif(n + 1 - i >= 0)\n\t\t{\n\t\t\tt[n + 1 - i] = true;\n\t\t\tq.push(n + 1 - i);\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(d[i] + i >= n + 1)\n\t\t{\n\t\t\ttou(i);\n\t\t}\n\t}\n}\n\nvoid modo()\n{\n\tinit();\n\twhile(!q.empty())\n\t{\n\t\tint w = q.front();\n\t\tq.pop();\n\t\tsyo(w);\n\t}\n}\n\nqueue<int> q2;\n\nbool t2[252];\n\nvoid tw2(int a)\n{\n\tif(a < n + 1)\n\t{\n\t\tif(!t2[a])\n\t\t{\n\t\t\tt2[a] = true;\n\t\t\tq2.push(a);\n\t\t}\n\t}\n\telse\n\t{\n\t\tt2[n + 1] = true;\n\t}\n}\n\nvoid tou2(int a)\n{\n\tif(a >= n + 1)\n\t{\n\t\tt2[n + 1] = true;\n\t}\n\telse\n\t{\n\t\ttw2(a + d[a]);\n\t}\n}\n\nvoid syo2(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttou2(a + i);\n\t}\n}\n\nvoid init2()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt2[i] = false;\n\t}\n\tq2.push(0);\n\tt2[0] = true;\n}\n\nvoid modo2()\n{\n\tinit2();\n\twhile(!q2.empty())\n\t{\n\t\tint w = q2.front();\n\t\tq2.pop();\n\t\tsyo2(w);\n\t}\n}\n\nbool can()\n{\n\tif(!t2[n + 1])\n\t{\n\t\treturn false;\n\t}\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tif(t2[i])\n\t\t{\n\t\t\tif(!t[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&maxw);\n\t\tif(maxw == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\td[0] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\",d + i);\n\t\t}\n\t\td[n + 1] = 0;\n\t\tmodo();\n\t\tmodo2();\n\t\tif(can())\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint mx, n, d[300], g[300][300];\nint memo[300] = {0};\n\nint dfs(int k){\n\tif( d[k] == 0 ) return k;\n\t\n\tif( n+1 <= k + d[k] ) return n + 1;\n\tif( k + d[k] <= 0 ) return 0;\n\t\n\tif( memo[k] != -1 ) return memo[k];\n\tif( 0 <= k && k < 300 )\n\t\treturn memo[k] = dfs(k + d[k]);\n\treturn 0;\n}\n\nvoid add_edge(int u, int v){\n\tg[u][v] = 1;\n}\n\nint main(){\n\twhile( cin >> mx, mx ){\n\t\tfill(d, d + 300, 0);\n\t\tfill(memo, memo + 300, -1);\n\t\tfor(int i = 0; i < 300; i++) fill(g[i], g[i] + 300, 0);\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; i++) cin >> d[i];\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif( d[i] == 0 ){\n\t\t\t\tint u = i;\n\t\t\t\tfor(int j = 1; j <= mx; j++){\n\t\t\t\t\tint v = dfs(i + j);\n\t\t\t\t\tadd_edge(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k <= n+1; k++){\n\t\t\tfor(int i = 0; i <= n+1; i++){\n\t\t\t\tfor(int j = 0; j <= n+1; j++){\n\t\t\t\t\tif( g[i][k] && g[k][j] ) g[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tfor(int u = 0; u <= n; u++){\n\t\t\tif( g[0][u] && !g[u][n+1] ) ans = false;\n\t\t}\n\t\tcout << (ans? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define LOOP -2\n\nint m, n;\nint d[300];\nint to[300]; //テ」ツ?ゥテ」ツ?ョテ」ツδ榲」ツつケテ」ツ?クテ」ツ?淌」ツ?ゥテ」ツつ甘ァツ敖?」ツ?湘」ツ??\nbool used[300];\n\nint dfs(int id){\n  if(id <= 0) return 0;\n  if(id >= n + 1) return n + 1;\n  if(d[id] == 0) return to[id] = id;\n  if(used[id]) return LOOP;\n  used[id] = true;\n  return to[id] = dfs(id + d[id]);\n}\n\nvoid solve(){\n  memset(to, -1, sizeof(to));\n  to[0] = 0;\n  to[n + 1] = n + 1;\n  for(int i = 1; i <= n; i++){\n    if(to[i] != -1) continue;\n    memset(used, 0, sizeof(used));\n    dfs(i);\n  }\n\n  /*\n  for(int i = 0; i < n + 2; i++){\n    printf(\"%3d\", d[i]);\n  }\n  cout<<endl;\n\n  for(int i = 0; i < n + 2; i++){\n    printf(\"%3d\", to[i]);\n  }\n  cout<<endl;\n  */\n\n  queue<int> open;\n  open.push(0);\n  memset(used, 0, sizeof(used));\n\n  while(!open.empty()){\n    int id = open.front();\n    open.pop();\n\n    if(id == n + 1){\n      cout << \"OK\" << endl;\n      return;\n    }\n    if(used[id]) continue;\n    used[id] = true;\n\n    for(int i = 1; i <= m; i++){\n      if(n + 1 < id + i) break;\n      int next = to[id + i];\n      if(next == LOOP) continue;\n      open.push(next);\n    }\n  }\n  cout << \"NG\" << endl;\n}\n\nint main(){\n  while(cin >> m >> n, m){\n    d[0] = d[n + 1] = 0;\n    for(int i = 0; i < n; i++){\n      cin >> d[i + 1];\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n;\nvector<int> G[252];\nbool used[252],flag = true;\n\nbool dfs(int v){\n\tif(v == n + 1) return true;\n\tif(used[v]) return false;\n\tbool f = false;\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tif(dfs(G[v][i])) f = true;\n\t}\n\tif(!f) flag = false;\n\tused[v] = false;\n\treturn f;\n}\n\nint main(){\n\tint ma;\n\twhile(cin >> ma,ma){\n\t\tflag = true;\n\t\tfor(int i = 0;i < 252;i++) {\n\t\t\tG[i].clear();\n\t\t\tused[i] = false;\n\t\t}\n\t\tint d[252] = {};\n\t\tcin >> n;\n\t\tfor(int i = 0;i < n;i++) cin >> d[i + 1];\n\t\tfor(int i = 0;i < n + 1;i++){\n\t\t\tfor(int j = 1;j <= ma;j++){\n\t\t\t\tif(i + j >= n + 2) break;\n\t\t\t\tG[i].push_back(min(n + 1,max(0,i + j + d[i + j])));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n + 1;i++){\n\t\t\tsort(G[i].begin(),G[i].end());\n\t\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\t\t}\n\t\tdfs(0);\n\t\tif(flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint m, n;\nint main() {\n\twhile (cin >> m, m) {\n\t\tcin >> n;\n\t\tvector<vector<int> > G(n + 2);\n\t\tvector<int> a(n + 2, -1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> a[i];\n\t\t\tif (a[i] == 0) a[i] = -1;\n\t\t\telse {\n\t\t\t\ta[i] += i;\n\t\t\t\ta[i] = min(max(a[i], 0), n + 1);\n\t\t\t\tG[i].push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tfor (int j = i + 1; j <= i + m && j < n + 2; j++) {\n\t\t\t\tG[i].push_back((a[j] == -1 ? j : a[j]));\n\t\t\t}\n\t\t}\n\t\tvector<bool> vis(n + 2, false); vis[0] = true;\n\t\tqueue<int> que; que.push(0);\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tfor (int e : G[u]) {\n\t\t\t\tif (!vis[e]) {\n\t\t\t\t\tvis[e] = true;\n\t\t\t\t\tque.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = vis[n + 1];\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (!vis[i]) continue;\n\t\t\tvector<bool> vis2(n + 2, false); vis2[i] = true;\n\t\t\tqueue<int> que2; que2.push(i);\n\t\t\twhile (!que2.empty()) {\n\t\t\t\tint u = que2.front(); que2.pop();\n\t\t\t\tfor (int e : G[u]) {\n\t\t\t\t\tif (!vis2[e]) {\n\t\t\t\t\t\tvis2[e] = true;\n\t\t\t\t\t\tque2.push(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis2[n + 1]) flag = false;\n\t\t}\n\t\tcout << (flag ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nint d[256][256];\n\nint main(){\n  while(scanf(\"%d\", &M) && M){\n    scanf(\"%d\", &N);\n    //  rep(i, N+2) rep(j, N+2) d[i][j] = INF;\n    memset(d, 0, sizeof(d));\n\n    rep(i, M+1) d[0][min(i, N+1)] = 1;\n\n    REP(i, 1, N+1){\n      int in;\n      scanf(\"%d\", &in);\n      if(in){\n\tint next = i + in;\n\tnext = max(0, min(N+1, next));\n\td[i][next] = 1;\n      }else{\n\trep(j, M+1){\n\t  int next = i+j;\n\t  next = min(next, N+1);\n\t  d[i][next] = 1;\n\t}\n      }\n    }\n\n    rep(k, N+2) rep(i, N+2) rep(j, N+2){\n      if(d[i][k] && d[k][j]) d[i][j] = 1;\n    }\n\n    /*    rep(i, N+2){\n      rep(j, N+2) printf(\"%d \", d[i][j]); puts(\"\");\n      }*/\n\n    int p;\n    for(p = 0; p < N+1; p++) if(d[p][N+1] == 0){ puts(\"NG\"); break;}\n    if(p == N+1) puts(\"OK\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q1,q2;\n    q1.push(0);\n    bool c=true;\n    while(!q1.empty()){\n      b=q1.front();q1.pop();\n      if(r[b]) continue;\n      r[b]=true;\n      q2.push(b);\n      fill(used,used+300,false);\n      while(!q2.empty()){\n\tp=q2.front();q2.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(p>=n+1){\n\t  used[n+1]=true;\n\t  break;\n\t}\n\tif(used[p]) continue;\n\tused[p]=true;\n\tq1.push(p);\n\tfor(i=1;i<=m;i++){\n\t  q2.push(p+i+d[p+i]);\n\t}\n      }\n      if(!used[n+1]){\n\tc=false;\n\tbreak;\n      }\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> a;\nint n,m;\nvector<bool> d(300);\n\nbool saiki(int p1,int pre,vector<int> u){\n    int p = p1;\n  //  if(u[p] > 2) return true;\n    u[p]++;\n    bool ans = false;\n\n    bool flg = false;\n    for(int i=1;i<=m;i++){\n\tif(u[min(p+i,n+1)] == 0) flg = true;\n    }\n    if(!flg) return true;\n    for(int i=1;i<=m;i++){\n\tp = p1;\n\tp += i;\n\tp = min(p,n+1);\n\tu[p]++;\n\tif(a[p] == 300) return d[p1] = false;\n\tp += a[p];\n\tp = min(p,n+1);\n\tp = max(p,0);\n\tif(u[p] < 10)\n\t    ans = ans | saiki(p,p1,u);\n    }\n    return d[p] = ans;\n}\n\nint main(){\n    while(true){\n\tfill(ALL(d),true);\n\ta = vector<int>(0);\n\tcin >> m;\n\tif(m == 0) break;\n\tcin >> n;\n\ta.PB(-300);\n\tREP(i,n){\n\t    int temp;\n\t    cin >> temp;\n\t    a.PB(temp);\n\t}\n\ta.PB(300);\n\tif(!saiki(0,0,vector<int>(n+2,0))) cout << \"OK\" << endl;\n\telse cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nqueue<int> q;\n\nbool t[252];\nint d[252];\n\nint maxw;\n\nint n;\n\nvoid tw(int a)\n{\n\tif(a <= 0)\n\t{\n\t\tif(!t[0])\n\t\t{\n\t\t\tt[0] = true;\n\t\t\tq.push(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!t[a])\n\t\t{\n\t\t\tt[a] = true;\n\t\t\tq.push(a);\n\t\t}\n\t}\n}\n\nvoid tou(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttw(a - i);\n\t}\n}\n\nvoid syo(int a)\n{\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(i + d[i] == a)\n\t\t{\n\t\t\ttou(i);\n\t\t}\n\t}\n}\n\nvoid init()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt[i] = false;\n\t}\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\tif(n + 1 - i >= 0)\n\t\t{\n\t\t\tt[n + 1 - i] = true;\n\t\t\tq.push(n + 1 - i);\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(d[i] + i >= n + 1)\n\t\t{\n\t\t\ttou(i);\n\t\t}\n\t}\n}\n\nvoid modo()\n{\n\tinit();\n\twhile(!q.empty())\n\t{\n\t\tint w = q.front();\n\t\tq.pop();\n\t\tsyo(w);\n\t}\n}\n\nqueue<int> q2;\n\nbool t2[252];\n\nvoid tw2(int a)\n{\n\tif(a < n + 1)\n\t{\n\t\tif(!t2[a])\n\t\t{\n\t\t\tt2[a] = true;\n\t\t\tq2.push(a);\n\t\t}\n\t}\n\telse\n\t{\n\t\tt2[n + 1] = true;\n\t}\n}\n\nvoid tou2(int a)\n{\n\tif(a >= n + 1)\n\t{\n\t\tt2[n + 1] = true;\n\t}\n\telse\n\t{\n\t\ttw2(a + d[a]);\n\t}\n}\n\nvoid syo2(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttou2(a + i);\n\t}\n}\n\nvoid init2()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt2[i] = false;\n\t}\n\tq2.push(0);\n\tt2[0] = true;\n}\n\nvoid modo2()\n{\n\tinit2();\n\twhile(!q2.empty())\n\t{\n\t\tint w = q2.front();\n\t\tq2.pop();\n\t\tsyo2(w);\n\t}\n}\n\nbool can()\n{\n\tif(!t2[n + 1])\n\t{\n\t\treturn false;\n\t}\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tif(t2[i])\n\t\t{\n\t\t\tif(!t[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&maxw);\n\t\tif(maxw == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\td[0] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\",d + i);\n\t\t}\n\t\td[n + 1] = 0;\n\t\tmodo();\n\t\tmodo2();\n\t\tif(can())\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/07/26 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(true){\n\t\tint m;\n\t\tcin >> m;\n\n\t\tif(m==0)\n\t\t\tbreak;\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tint d[252] = {0};\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tcin >> d[i];\n\t\t}\n/*\n\t\tfor(int i=0; i<n+2; i++){\n\t\t\tcout << d[i] << ' ';\n\t\t}\n\t\tcout << endl;\n*/\n\t\tbool G[252][252];\n\t\tfor(int i=0; i<n+2; i++){\n\t\t\tfor(int j=0; j<n+2; j++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tG[i][j] = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tG[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tfor(int j=1; j<=m; j++){\n\t\t\t\tint k = i+j;\n\n\t\t\t\tif(k>=n+1){\n\t\t\t\t\tG[i][n+1] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint l = k+d[k];\n\n\t\t\t\tG[i][l] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=0; k<n+2; k++){\n\t\t\tfor(int i=0; i<n+2; i++){\n\t\t\t\tfor(int j=0; j<n+2; j++){\n\t\t\t\t\tif(G[i][k] && G[k][j]){\n\t\t\t\t\t\tG[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flg = true;\n\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tif(G[0][i] && !G[i][n+1]){\n\t\t\t\tflg = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(flg){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nint ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\tif (ka[y][x] == 1)break;\n\t\t\t\tka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\tfor (int j = 0; j<300; j++)\n\t\t\t{\n\t\t\t\tka[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nint main() {\n  int MAX;\n  while(cin >>MAX && MAX){\n    int N; cin >>N;\n    vector<int> v(N + 2, 0); FOR(i, 1, N + 1) cin >>v[i];\n    //debug\n    //REP(i, v.size()) cout <<v[i] <<\" \"; cout <<endl;\n    queue<int> open;\n    open.push(0);\n    vector<bool> closed(N + 1, false);\n    bool isOK = false;\n    while(!open.empty()){\n      int now = open.front(); open.pop();\n      //cout <<now <<\", \" <<v[now] <<endl;\n      if(now == N + 1){\n        isOK = true;\n        break;\n      }\n      if(closed[now]) continue;\n      closed[now] = true;\n\n      if(v[now] == 0){\n        FOR(i, now + 1, min(N + 1, now + MAX) + 1){\n          if(!closed[i]){\n            //cout <<\"    push \" <<i <<endl;\n            open.push(i);\n          }\n        }\n      } else if(v[now] < 0){\n        int next = max(0, now + v[now]);\n        if(!closed[next]) open.push(next);\n      } else if(v[now] > 0){\n        int next = min(N + 1, now + v[now]);\n        if(!closed[next]) open.push(next);\n      }\n    }\n    cout <<(isOK ? \"OK\" : \"NG\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nvector<int> g[300];\nbool go[300], ba[300];\n\nvoid iki(int x)\n{\n\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n + 1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif(y<0) y==0;\n\t\t\t//if (y>=0)\n\t\t\t//{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t//}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\nusing namespace std;\n#include<queue>\nint main(void)\n{\n\tfor(;;){\n\t\tqueue<int> q;\n\t\tint max,n,d[252],i,j,k,p=0,e;\n\t\tscanf(\"%d %d\",&max,&n);\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tq.push(0);\n\t\twhile(p==0){\n\t\t\tk=0;\n\t\t\te=q.front();\n\t\t\tfor(i=1;i<=max;i++){\n\t\t\t\tif(e!=e+i+d[i]){\n\t\t\t\t\tk=1;\n\t\t\t\t\tq.push(e+i+d[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(k==0){\n\t\t\t\tprintf(\"NG\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(e==n+1){\n\t\t\t\tprintf(\"OK\\n\");\n\t\t\t\tp=1;\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nconst int INF = 100000;\n\nint main(){\n    while(true){\n        int maxi;cin >> maxi;\n        if(maxi == 0) break;\n        int n;cin >> n;\n        n+=2;\n        vector<int> d(n);\n        for(int i=1;i<=n-2;i++){\n            cin >> d[i];\n        }\n        vector<vector<int>> graph(n,vector<int>(n,INF));\n        for(int i=0;i<n;i++){\n            for(int s=1;s<=maxi;s++){\n                int g = i+s;\n                g = min(g,n-1);\n                g = max(g,0);\n                g += d[g];\n                g = min(g,n-1);\n                g = max(g,0);\n                graph[i][g] = 1;\n            }\n        }\n        // read graph.\n        for(int i=0;i<n;i++){\n            graph[i][i] = 0;\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    graph[i][j] = min(graph[i][j],graph[i][k]+graph[k][j]);\n                }\n            }\n        }\n        bool ret = true;\n        for(int t=0;t<n;t++){\n            if(graph[0][t] < INF and graph[t][n-1] >= INF){\n                ret = false;\n            }\n        }\n        cout << (ret?\"OK\":\"NG\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint maxv;\nint N;\nint d[303];\nbool used[304];\nint main(){\n\n  while(cin>>maxv&&maxv){\n    memset(used,0,sizeof(used));\n    memset(d,0,sizeof(d));\n    cin>>N;\n    for(int i=1;i<=N;i++)cin>>d[i];\n    N+=2;\n    queue<int> q;\n    q.push(0);\n    used[0]=true;\n    while(q.size()){\n      int now=q.front();q.pop();\n      for(int i=1;i<=maxv;i++){\n        int to=min(N-1,now+i);\n        if(used[to])continue;\n        if(d[to]>0){\n          to=min(N-1,to+d[to]);\n          if(!used[to]){\n            q.push(to);\n            used[to]=true;\n          }\n        }\n        else if(d[to]<0){\n          to=max(0,to+d[to]);\n          if(!used[to]){\n            q.push(to);\n            used[to]=true;\n          }\n        }\n        else{\n          used[to]=true;\n          q.push(to);\n        }\n      }\n    }\n    vector<int> cand;\n    for(int i=0;i<N-1;i++)if(used[i])cand.push_back(i);\n    for(int ite=0;ite<(int)cand.size();ite++){\n      memset(used,0,sizeof(used));\n      queue<int> q;\n      q.push(cand[ite]);\n      used[cand[ite]]=true;\n      while(q.size()){\n        int now=q.front();q.pop();\n        for(int i=1;i<=maxv;i++){\n          int to=min(N-1,now+i);\n          if(d[to]>0){\n            to=min(N-1,to+d[to]);\n            if(!used[to]){\n              q.push(to);\n              used[to]=true;\n            }\n          }\n          else if(d[to]<0){\n            to=max(0,to+d[to]);\n            if(!used[to]){\n              q.push(to);\n              used[to]=true;\n            }\n          }\n          else{\n            if(used[to])continue;\n            used[to]=true;\n            q.push(to);\n          }\n        }\n      }\n      // テ」ツつエテ」ツδシテ」ツδォテ」ツ?クテ・ツ按ーテゥツ?氾」ツ?ァテ」ツ?催」ツ?ェテ」ツ??」ツδ妥」ツつソテ」ツδシテ」ツδウテ」ツ?古・ツュツ佚・ツ慊ィ\n      if(!used[N-1]){\n        cout<<\"NG\"<<endl;\n        break;\n      }\n    }\n    if(used[N-1])cout<<\"OK\"<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nint mx;\nint d[3000];\nint n;\nint done[3000] = {};\nint ok[3000] = {};\nint can(int x){\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\tif( x == n - 1 ) return 1;\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( can(t) ) return 1;\n\t}\n\treturn 0;\n}\nint dfs(int x){\n\tif( !ok[x] ) return 1;\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\t\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( dfs(t) ) return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> mx && mx){\n\t\tfor(int i = 0 ; i < 300 ; i++) d[i] = 0;\n\t\tfor(int i = 0 ; i < 300 ; i++) ok[i] = 0;\n\t\tcin >> n;\n\t\tn += 2;\n\t\tfor(int i = 1 ; i < n - 1 ; i++)\n\t\t\tcin >> d[i];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\t\tok[i] = can(i);\n\t\t}\n\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\tcout << (dfs(0)?\"NG\":\"OK\") << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[300];\nint n,m;\nint g[300][300];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tscanf(\"%d\",&n);\n\t\tm=a;\n\t\tfor(int i=0;i<n;i++)scanf(\"%d\",b+i+1);\n\t\tb[0]=b[n+1]=0;\n\t\tfor(int i=0;i<n+2;i++)for(int j=0;j<n+2;j++)g[i][j]=0;\n\t\tfor(int i=0;i<n+1;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tint to=i+j;\n\t\t\t\tif(to>n+1)to=n+1;\n\t\t\t\tto+=b[to];\n\t\t\t\tif(to>n+1)to=n+1;\n\t\t\t\tif(to<0)to=0;\n\t\t\t\tg[i][to]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n+2;i++)g[i][i]=1;\n\t\tfor(int k=0;k<n+2;k++)for(int i=0;i<n+2;i++)for(int j=0;j<n+2;j++)\n\t\t\tg[i][j]|=(g[i][k]&g[k][j]);\n\t\tbool ok=true;\n\t\tfor(int i=0;i<n+1;i++)if(g[0][i]&&!g[i][n+1])ok=false;\n\t\tif(ok)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n\nvoid dfs(int u);\nvoid rdfs(int u);\nbool vis[256],rvis[256];\nvector<int>start[256];  \nvector<int>goal[256];\n\nint main(){\n  int m,n,d[256];\n\n  while(1){\n\n    fill(vis,vis+256,false);\n    fill(rvis,rvis+256,false);\n    fill(d,d+256,0);\n    scanf(\"%d\",&m);\n    if(m==0) break;\n    scanf(\"%d\",&n);\n    for(int i=0;i<=n+1;i++){\n      start[i].clear(),goal[i].clear();\n    }\n    for(int i=1;i<=n;i++){\n      scanf(\"%d\",&d[i]);\n    }\n\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n\tint next=i+j+d[i+j];\n\tnext=min(max(next,0),n+1);\n\tstart[i].push_back(next);\n\tgoal[next].push_back(i);\n      }\n    }\n\n    dfs(0);\n    rdfs(n+1);\n\n    bool judge=true;\n    for(int i=0;i<=n;i++){\n      if(vis[i]&&!rvis[i]) judge=false;\n    } \n    \n    if(judge) printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n  }\n\n  return 0;\n}\n\nvoid dfs(int u){\n  vis[u]=true;\n\n  for(int i=0;i<start[u].size();i++){\n    if(!vis[start[u][i]]) dfs(start[u][i]);\n  }\n}\n\nvoid rdfs(int u){\n  rvis[u]=true;\n\n  for(int i=0;i<goal[u].size();i++){\n    if(!rvis[goal[u][i]]) rdfs(goal[u][i]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define N 333\nint max_masu,n;\nint d[N],flag[N];\nusing namespace std;\nint solve(int i){\n  int ret = 0;\n  if(i>=n)return 0;\n  i=i+d[i];\n  if(i<0)i=0;\n  // printf(\"%d %d\\n\",i,flag[i]);\n  if(flag[i] == 1)return 1;\n  for(int j=1;j<=max_masu;j++){\n    flag[i] = 1;\n    ret += solve(i+j);\n    flag[i] = 0;\n  }\n  return ret;\n}\nint main(){\n  while(1){\n    cin >> max_masu;\n    if(!max_masu)break;\n    cin >> n;\n    memset( d, 0 , sizeof(d));\n    memset( flag , 0 , sizeof(flag) );\n    for(int i=0;i<n;i++){\n      cin >> d[i];\n    }\n    int ret = 0;\n    for(int i=0;i<n;i++){\n      ret += solve( i );\n     //cout << ret << endl;\n    }\n    printf(\"%s\\n\",(ret == 0)? \"OK\" : \"NG\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N];\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<=nx)nx=n+1;\n    return memo[prev][x]|=dfs(1,nx);\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<=nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    dfs(0,0);\n    bool ans=true;\n    for(int i=0;i<=n+1;i++)\n      if(!memo[0][i]&&!memo[1][i])ans=false;\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 252\nusing namespace std;\n\nint m,n,d[N],ans;\nbool dp[N];\n\nbool OK(int x){\n  bool r=false;\n  x+=d[x];\n  if(x<0&&dp[0]) r=true;\n  if(x>=n+1) r=true;\n  if(dp[x]) r=true;\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m) break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    for(int i=0;i<=n;i++) dp[i]=false;\n    dp[n+1]=true;\n    while(1){\n      int f=0;\n      for(int i=n;i>=0;i--){\n\tfor(int j=1;j<=m;j++){\n\t  if(i+j>=n+1||OK(i+j)){\n\t    if(!dp[i]) f=1;\n\t    dp[i]=true;\n\t  }\n\t}\n      }\n      if(!f) break;\n    }\n    ans=0;\n    for(int i=0;i<=n;i++)\n      if(!dp[i]) ans=1;\n    if(ans) cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint main(){\n    int ma;\n    while(scanf(\"%d\",&ma),ma){\n        int n;\n        int stage[256];\n        int D[256][256]={{0}};\n        scanf(\"%d\",&n);\n        rep(i,n+2){\n            rep(j,n+2){\n                if(i == j)D[i][j] = 0;\n                else D[i][j] = INF;\n            }\n        }\n        reps(i,1,n+1){\n            scanf(\"%d\",&stage[i]);\n        }\n        rep(i,n+1){\n            if(stage[i]){\n                int tmp = i+stage[i];\n                if(tmp < 0)tmp = 0;\n                if(tmp > n+1)tmp = n+1;\n                D[i][tmp] = 1;\n            }\n            else{\n                rep(j,ma+1){\n                    int tmp = i+j;\n                    if(tmp > n+1)tmp = n+1;\n                    D[i][tmp] = 1;\n                }\n            }\n        }\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    D[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n                }\n            }\n        }\n        /*puts(\"--------------------------\");\n        rep(i,n+2){\n            rep(j,n+2){\n                if(D[i][j] >= INF)printf(\"M \");\n                else printf(\"%d \",D[i][j]);\n            }\n            puts(\"\");\n        }\n        puts(\"--------------------------\");*/\n        bool flg = true;\n        rep(i,n+2){\n            flg &=(D[0][i]>=INF || D[i][n+1]<INF);\n        }\n        flg ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int max,n,data[255];\n  bool MAS[255][255];\n  while(1){\n    memset(MAS,false,sizeof(MAS));\n    cin >> max;\n    if(max==0)break;\n    cin >> n;\n    for(int i=1,a;i<=n;i++) cin >> data[i];\n    for(int j=0;j<=n;j++){\n      for(int i=1;i<=max && j+i<n+2;i++){ \n        j+i+data[i]>n+1 ? MAS[j][n+1]=true : MAS[j][j+i+data[i]]=true;\n      }\n    }\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n\tfor(int k=0;k<n+2;k++){\n\t  if(MAS[j][i]&&MAS[i][k]){\n\t    MAS[j][k]=true;\n\t  }\n\t}\n      }\n    }\n    bool flg=false;\n    for(int i=0;i<=n;i++){\n      if(MAS[0][i]&&(!MAS[i][n+1])){\n\tflg=true;\n\tbreak;\n      }\n    }\n    cout << (flg?\"NG\":\"OK\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nint M, N;\nint D[5100];\n\nint memo[5100];\n\nint calc(int n){\n\tif(memo[n] != -1) return memo[n];\n\tmemo[n] = 0;\n\tfor(int i = 1; i<= M; i++){\n\t\tif(n +i > N || n + i + D[n+i] > N) memo[n] = 1;\n\t\tmemo[n] = max(memo[n], calc(max(n+i+D[n+i], 0)));\n\t}\n\treturn memo[n];\n}\n\nint main(){\n\twhile(cin>>M && M > 0) {\n\t\tcin>>N;\n\t\trep(i, 5100) memo[i] = -1, D[i] = 0;\n\t\trep(i, N) cin>>D[i+1];\n\t\t//rep(i, M) calc(i+1);\n\t\tcalc(0);\n\t\tbool f = true;\n\t\trep(i, N+1) if(memo[i] == 0) f = false;\n\t\tcout<<(f?\"OK\":\"NG\")<<endl;\n\t\t// rep(i, N+1) printf(\"%3d\", memo[i]);\n\t\t// printf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define MAX_N 300\nint m,n;\nint arr[MAX_N];\nint visited[MAX_N];\nint visited2[MAX_N];\nint flag[MAX_N];\n\nvoid init();\nvoid rec(int);\nint solve(int);\n\nint main(){\n  int i,j,a,b;\n  while(1){\n    init();\n    scanf(\"%d\",&m);\n    if(m==0)break;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n      scanf(\"%d\",&a);\n      b=i+a;\n      if(b<0)b=0;\n      if(b>n+1)b=n+1;\n      arr[i]=b;\n    }\n    for(i=0;i<=n+1;i++){\n      if(arr[i]==n+1)rec(i);\n    }\n    /*\n    for(i=0;i<=n+1;i++){\n      printf(\"%d \",visited[i]);\n    }\n    printf(\"\\n\");\n    */\n    if(solve(0))printf(\"NG\\n\");\n    else printf(\"OK\\n\");\n  }\n  return 0;\n}\n\nint solve(int pos){\n  if(visited2[pos])return 0;\n  visited2[pos]=1;\n  if(!flag[pos])return 1;\n  int i,a;\n  for(i=1;i<=m;i++){\n    a=pos+i;\n    if(a>=n+1)break;\n    a=arr[a];\n    if( solve(a) )return 1;\n  }\n  return 0;\n}\n\nvoid rec(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  int i,j,a;\n  for(i=1;i<=m;i++){\n    a=pos-i;\n    if(a<0)break;\n    flag[a]=1;\n    for(j=0;j<=n+1;j++){\n      if(arr[j]==a)rec(j);\n    }\n  }\n}\n\nvoid init(){\n  int i,j;\n  for(i=0;i<MAX_N;i++){\n    arr[i]=i;\n    visited[i]=0;\n    visited2[i]=0;\n    flag[i]=0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    fill(used,used+300,false);\n    queue<int> q;\n    q.push(0);\n    int p,b;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      //cout << p << endl;\n      while(d[p]!=0){\n\tp+=d[p];\n\tif(p<0) p=0;\n\tif(p>n+1) p=n+1;\n      }\n      if(used[p]) continue;\n      used[p]=true;\n      for(i=1;i<=m;i++){\n\tif(p+i>n+1) q.push(n+1);\n\telse q.push(p+i);\n      }\n    }\n    if(used[n+1]) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\twhile(true){\n\t\tint ma,n,d[255];\n\t\tscanf(\"%d\",&ma);\n\t\tif(ma==0)return 0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tbool F=true;\n\t\tfor(int i=0;i<=n-ma;i++){\n\t\t\tbool f1=false;\n\t\t\tfor(int j=1;j<=ma;j++){\n\t\t\t\tif(i+j+d[i+j]>i)f1=true;\n\t\t\t}\n\t\t\tif(!f1)F=false;\n\t\t}\n\t\tif(F)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1001001001;\n\nint MAX, N, dist[260][260], D[260];\n\nint main(){\n  while(scanf(\"%d %d\", &MAX, &N), MAX){\n    std::fill(D, D+260, 0);\n\n    FOR(i,2,N+2){\n      scanf(\"%d\", D+i);\n      // printf(\"%d: %d\\n\", i, D[i]);\n    }\n\n    FOR(i,1,N+3){FOR(j,1,N+3){if(i==j){dist[i][j]=0;}else{dist[i][j]=INF;}}}\n\n    FOR(i,1,N+3){\n      for(int j=1;j<=MAX&&i+j<=N+2;j++){\n        int k = i+j+D[i+j];\n        if(k < 0){k = 0;}\n        if(k > N+2){k = N+2;}\n        if(i == k){continue;}\n        // printf(\"%d, %d, %d, %d\\n\", i, j, D[i+j], k);\n        dist[i][k] = 1;\n      }\n    }\n\n\n    for(int i=1;i<=MAX&&N+2-i>=1;i++){\n      dist[N+2-i][N+2] = 1;\n    }\n\n\n    FOR(k,1,N+3){\n      FOR(i,1,N+3){\n        FOR(j,1,N+3){\n          if(dist[i][j] > dist[i][k] + dist[k][j]){dist[i][j] = dist[i][k] + dist[k][j];}\n        }\n      }\n    }\n\n    bool f = true;\n    FOR(i,1,N+3){\n      if(dist[i][N+2] == INF){f = false;}\n    }\n\n    if(f){puts(\"OK\");}\n    else{puts(\"NG\");}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n#define ALL(co) co.begin(), co.end()\n#define tpl(...) make_tuple(__VA_ARGS__)\n\ntypedef long long LL;\ntypedef pair<int, int> P; typedef pair<int, P> IP; typedef pair<P, P> PP;\ntypedef vector<int> Array; typedef vector<vector<int> > Array2;\ntypedef vector<LL> LArray; typedef vector<P> PArray; typedef vector<string> SArray;\n\nconst int INF = 1 << 29;\nconst LL LINF = 1LL << 60;\n\ninline int getInt() { int itiv; return (cin >> itiv, itiv); }\ntemplate <typename T> void readAll(vector<T>& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i]; }\ntemplate <typename T, typename U> void readAll(vector<pair<T, U> >& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i].first >> vec[i].second; }\ntemplate < typename T > inline string toString( const T &a ){ ostringstream oss; oss << a; return oss.str(); };\ninline bool between(int min, int max, int n) { return min <= n && n <= max; }\ninline bool inRange(int begin, int end, int n) { return begin <= n && n < end; }\ninline bool inRange(int size, int n) { return 0 <= n && n < size; }\n\nint dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\nint dr[] = { 0, -1, 0, 1 }, dc[] = { -1, 0, 1, 0 };\n\n\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\tint n, mx;\n\twhile(cin >> mx && mx)\n\t{\n\t\tcin >> n;\n\t\tArray arr(n + mx + 1);\n\t\tArray2 graph(n + mx + 1, Array());\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tarr[i + 1] = getInt();\n\t\t}\n\n\t\tfor (int i = 0; i < n + 2; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= mx; j++)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(max(i + j + arr[i + j], 0));\n\t\t\t}\n\t\t}\n\n\t\tvector<bool> visited(n + mx + 1);\n\t\tfunction<bool(int)> dfs = [&](int x){\n\t\t\tif(x >= n + 2) return true;\n\t\t\t\n\t\t\tvisited[x] = true;\n\t\t\tfor(auto nx : graph[x])\n\t\t\t{\n\t\t\t\tif(visited[nx]) continue;\n\t\t\t\tif(dfs(nx)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tcout << (dfs(0) ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int> >G(252),R(252);\nint n,m;\nint d[552];\nbool u[252];\nvoid f(int v)\n{\n\tu[v]=1;\n\tfor(int i=0;i<R[v].size();i++)\n\t{\n\t\tif(!u[R[v][i]])f(R[v][i]);\n\t}\n}\nbool vi[252];\nvoid ok(int v)\n{\n    vi[v]=1;\n    for(int i=0;i<G[v].size();i++)\n    {\n        if(!vi[G[v][i]])ok(G[v][i]);\n    }\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<=n+1;i++)G[i].clear(),R[i].clear(),vi[i]=u[i]=0;\n\t\tfor(int i=1;i<=n;i++)cin>>d[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m&&i+j<=n+1;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+d[i+j];\n\t\t\t\tif(k>n+1)k=n+1;\n\t\t\t\tif(k<0)k=0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n+1);ok(0);\n\t\tbool flag=1;\n\t\tfor(int i=0;i<=n+1;i++)if(vi[i]&&!u[i])flag=0;\n\t\tcout<<(flag?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int max,n,data[255];\n  bool MAS[255][255];\n  while(1){\n    memset(MAS,false,sizeof(MAS));\n    cin >> max;\n    if(max==0)break;\n    cin >> n;\n    for(int i=1,a;i<=n;i++) cin >> data[i];\n    for(int j=0;j<=n;j++){\n      for(int i=1;i<=max;i++){ \n      MAS[j][j+i+data[i]]=true;\n      }\n    }\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n\tfor(int k=0;k<n+2;k++){\n\t  if(MAS[j][i]&&MAS[i][k]){\n\t    MAS[j][k]=true;\n\t  }\n\t}\n      }\n    }\n    bool flg=false;\n    for(int i=0;i<=n;i++){\n      if(MAS[0][i]&&(!MAS[i][n+1])){\n\tflg=true;\n\tbreak;\n      }\n    }\n    cout << (flg?\"NG\":\"OK\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n#define ALL(co) co.begin(), co.end()\n#define tpl(...) make_tuple(__VA_ARGS__)\n\ntypedef long long LL;\ntypedef pair<int, int> P; typedef pair<int, P> IP; typedef pair<P, P> PP;\ntypedef vector<int> Array; typedef vector<vector<int> > Array2;\ntypedef vector<LL> LArray; typedef vector<P> PArray; typedef vector<string> SArray;\n\nconst int INF = 1 << 29;\nconst LL LINF = 1LL << 60;\n\ninline int getInt() { int itiv; return (cin >> itiv, itiv); }\ntemplate <typename T> void readAll(vector<T>& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i]; }\ntemplate <typename T, typename U> void readAll(vector<pair<T, U> >& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i].first >> vec[i].second; }\ntemplate < typename T > inline string toString( const T &a ){ ostringstream oss; oss << a; return oss.str(); };\ninline bool between(int min, int max, int n) { return min <= n && n <= max; }\ninline bool inRange(int begin, int end, int n) { return begin <= n && n < end; }\ninline bool inRange(int size, int n) { return 0 <= n && n < size; }\n\nint dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\nint dr[] = { 0, -1, 0, 1 }, dc[] = { -1, 0, 1, 0 };\n\n\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\tint n, mx;\n\twhile(cin >> mx && mx)\n\t{\n\t\tcin >> n;\n\t\tArray arr(n + mx + 2);\n\t\tArray2 graph(n + mx + 1, Array());\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tarr[i + 1] = getInt();\n\t\t}\n\n\t\tfor (int i = 0; i < n + 2; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= mx; j++)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(max(i + j + arr[i + j], 0));\n\t\t\t}\n\t\t}\n\n\t\tvector<bool> visited(n + mx + 1);\n\t\tfunction<bool(int)> dfs = [&](int x){\n\t\t\tif(x >= n + 2) return true;\n\t\t\t\n\t\t\tvisited[x] = true;\n\t\t\tfor(auto nx : graph[x])\n\t\t\t{\n\t\t\t\tif(visited[nx]) continue;\n\t\t\t\tif(dfs(nx)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tbool ans = true;\n\t\tfor (int i = 0; i < graph[0].size(); i++)\n\t\t{\n\t\t\tfill(ALL(visited), false);\n\t\t\tans = ans && dfs(graph[0][i]);\n\t\t}\n\t\tcout << (ans ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define MAX_N 300\nint m,n;\nint arr[MAX_N];\nint visited[MAX_N];\nint visited2[MAX_N];\n\nvoid init();\nvoid rec(int);\nint solve(int);\n\nint main(){\n  int i,j,a,b;\n  while(1){\n    init();\n    scanf(\"%d\",&m);\n    if(m==0)break;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n      scanf(\"%d\",&a);\n      b=i+a;\n      if(b<0)b=0;\n      if(b>n+1)b=n+1;\n      arr[i]=b;\n    }\n    rec(n+1);\n    for(i=1;i<=n;i++){\n      if(arr[i]==n+1)rec(i);\n    }\n    /*\n    for(i=0;i<=n+1;i++){\n      printf(\"%d \",visited[i]);\n    }\n    printf(\"\\n\");\n    */\n    if(solve(0))printf(\"NG\\n\");\n    else printf(\"OK\\n\");\n  }\n  return 0;\n}\n\nint solve(int pos){\n  if(visited2[pos])return 0;\n  visited2[pos]=1;\n  if(!visited[pos])return 1;\n  int i,a;\n  for(i=1;i<=m;i++){\n    a=pos+i;\n    if(a>n+1)break;\n    a=arr[a];\n    if( solve(a) )return 1;\n  }\n  return 0;\n}\n\nvoid rec(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  int i,j,a;\n  for(i=1;i<=m;i++){\n    a=pos-i;\n    if(a<0)break;\n    for(j=0;j<=n;j++){\n      if(arr[j]==a)rec(j);\n    }\n  }\n}\n\nvoid init(){\n  int i,j;\n  for(i=0;i<MAX_N;i++){\n    arr[i]=i;\n    visited[i]=0;\n    visited2[i]=0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint table[252][252];\n\nint mass[252];\n\nint main() {\n\n    int rmax,n;\n\n    while(1){\n\n        scanf(\" %d\",&rmax);\n\n        if(rmax == 0){\n            break;\n        }\n\n        scanf(\" %d\",&n);\n\n        for(int i=0;i<=n+1;i++){\n            for(int j=0;j<=n+1;j++){\n                table[i][j] = 0;\n            }\n        }\n\n        mass[0] = 0;\n        mass[n+1] = 0;\n\n\n        for(int i=1;i<=n;i++){\n            int d;\n            scanf(\" %d\",&d);\n            mass[i] = d;\n        }\n\n        for(int i=0;i<=n;i++){\n            for(int j=1;j<=rmax;j++){\n                if(i+j+mass[i+j]>n+1){\n                    table[i][n+1] = 1;\n                }\n                else if(i+j+mass[i+j] < 0){\n                    table[i][0] = 1;\n                }\n                else{\n                    table[i][i+j+mass[i+j]] = 1;\n                }\n            }\n        }\n\n        /*for(int i=0;i<=n+1;i++){\n            for(int j=0;j<=n+1;j++){\n                cout << table[i][j] << \" \";\n            }\n            cout << endl;\n        }cout << endl;*/\n\n        for(int k=0;k<=n+1;k++){\n            for(int i=0;i<=n+1;i++){\n                for(int j=0;j<=n+1;j++){\n                    if(table[k][j] == 1 && table[i][k] == 1) {\n                        table[i][j] = 1;\n                    }\n                }\n            }\n        }\n\n        /*for(int i=0;i<=n+1;i++){\n            for(int j=0;j<=n+1;j++){\n                cout << table[i][j] << \" \";\n            }\n            cout << endl;\n        }cout << endl;*/\n\n        bool check = true;\n\n        for(int i=0;i<=n;i++){\n            if(table[0][i] == 1 && table[i][n+1] == 0){\n                check = false;\n                printf(\"NG\\n\");\n                break;\n            }\n        }\n\n        if(check){\n            printf(\"OK\\n\");\n        }\n\n        /*for(int i=0;i<=n+1;i++){\n            for(int j=0;j<=n+1;j++){\n                cout << table[i][j] << \" \";\n            }\n            cout << endl;\n        }*/\n\n\n\n    }\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int M, N;\n    int D[255];\n\n    while ( cin >> M, M ) {\n        int memo[255][555];\n\n        cin >> N;\n        for ( int i = 1; i <= N; i++ ) {\n            cin >> D[i];\n        }\n        D[0] = 0, D[N + 1] = 0;\n\n        memset ( memo, -1, sizeof( memo ) );\n\n        function < int(int, int) > dfs = [&]( int v , int num )\n        {\n            int ret = 0;\n            if ( num > 520 ) return ( 0 );\n            if ( memo[v][num] != -1 ) return ( 0 );\n            if ( v == N + 1 ) return ( 1 );\n\n            for ( int i = 1; i <= M && v + i <= N + 1; i++ ) {\n                int place = min( N + 1, max ( v + i + D[v + i], 0 ) ) ;\n                ret |= dfs ( place , num + 1);\n            }\n            return ( memo[v][num] = ret );\n        };\n\n        dfs ( 0 , 0 );\n\n        bool flag = true;\n        for ( int i = 0; i <= N; i++ ) {\n            bool g = false, f = false;\n            for ( int j = 0; j < 520; j++ ) {\n                if ( memo[i][j] != -1 ) f = true;\n                if ( memo[i][j] == 1 ) {\n                    g = true;\n                }\n            }\n            if ( f && !g ) flag = false;\n        }\n        cout << ( flag ? \"OK\" : \"NG\" ) << endl;\n\n    }\n\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int max,n,data[255];\n  bool MAS[255][255];\n  while(1){\n    memset(MAS,false,sizeof(MAS));\n    memset(data,false,sizeof(data));\n    cin >> max;\n    if(max==0)break;\n    cin >> n;\n    for(int i=1;i<=n;i++) cin >> data[i];\n    for(int j=0;j<n+2;j++){\n      for(int i=1;i<=max && j+i<n+2;i++){\n\tif(j+i==n+1)MAS[j][n+1]=true;\n\telse j+i+data[j+i]>=n+1 ? MAS[j][n+1]=true : MAS[j][j+i+data[i+j]]=true;\n      }\n    }\n\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n\tfor(int k=0;k<n+2;k++){\n\t  if(MAS[j][i]&&MAS[i][k]){\n\t    MAS[j][k]=true;\n\t  }\n\t}\n      }\n    }\n    bool flg=false;\n    for(int i=0;i<=n;i++){\n      if(MAS[0][i]&&(!MAS[i][n+1])){\n\tflg=true;\n\tbreak;\n      }\n    }\n    cout << (flg?\"NG\":\"OK\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool jd[300];\nint maxnum;\nint n;\nint d[300];\n\nbool ans(int pos){\n\tbool res=false;\n\tif(pos>n){\n\t\treturn 1;\n\t}\n\tif(jd[pos]!=1){\n\t\tjd[pos]=1;\n\t\tfor(int i=1;i<maxnum+1;i++){\n\t\t\tif(pos+i>n){\n\t\t\t\tres =true;\n\t\t\t}else if(ans(pos+i+d[pos+i])){\n\t\t\t\tres =true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\n\nint main(){\n\twhile(cin>>maxnum,maxnum){\n\t\tcin>>n;\n\t\td[0]=0;\n\t\tfor(int i=1;i<n+1;i++){\n\t\t\tcin>>d[i];\n\t\t\tjd[i]=0;\n\t\t}\n\t\t\n\t\tif(ans(0)){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint M;\nint N;\nint D[252];\n\nbool used[252][252];\n\nint memo[252];\n\nbool rec(int pos)\n{\n    if (pos > N) return true;\n\n    if (~memo[pos]) return memo[pos];\n\n    pos += D[pos];\n\n    if (pos < 0) pos = 0;\n\n    bool res = true;\n\n    bool f = false;\n\n    for (int i = 1; i <= M; ++i) {\n        if (used[pos][i]) continue;\n        f = true;\n        used[pos][i] = true;\n        res &= rec(pos + i);\n        used[pos][i] = false;\n    }\n\n    if (!f) res = false;\n\n    return memo[pos] = res;\n}\n\nsigned main()\n{\n    while (cin >> M, M) {\n        cin >> N;\n        rep1(i, N) cin >> D[i];\n\n        memset(used, false, sizeof(used));\n        memset(memo, -1, sizeof(memo));\n\n        cout << (rec(0) ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int> >G(252),R(252);\nint n,m;\nint d[252];\nbool u[252];\nvoid f(int v)\n{\n\tu[v]=1;\n\tfor(int i=0;i<R[v].size();i++)\n\t{\n\t\tif(!u[R[v][i]])f(R[v][i]);\n\t}\n}\nbool vi[252];\nbool ok(int v)\n{\n    bool ans=u[v];\n    vi[v]=1;\n    for(int i=0;i<G[v].size();i++)\n    {\n        if(!vi[G[v][i]])ans&=ok(G[v][i]);\n    }\n    return ans;\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<=n+1;i++)G[i].clear(),R[i].clear(),vi[i]=u[i]=0;\n\t\tfor(int i=1;i<=n;i++)cin>>d[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m&&i+j<=n+1;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+d[i+j];\n\t\t\t\tif(k>n+1)k=n+1;\n\t\t\t\tif(k<0)k=0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n+1);u[0]=1;\n\t\tcout<<(ok(0)?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint t[255],f[255],g[255],n,m;\nint hantei(int x,int d) {\n\tint i,j,c,a;\n\tfor (i=0;i<=n+1;i++) f[i]=0; f[x]=1; c=1;\n\twhile(c==1) {\n\tc=0;\t\n\tfor (i=0;i<=n && c<2;i++) {\n\t\tif (f[i]==1) {\n\t\t\tfor (j=i+1;j<=i+m;j++) {\n\t\t\t\ta=j+t[j];\n\t\t\t\tif (a<0) a=0; if (a>n+1) a=n+1;\n\t\t\t\tif (d==1 && a==n+1) return 2;\n\t\t\t\tif (f[a]==0) { f[a]=1; c=1;}\n\t\t\t}\n\t\t\tf[i]=2;\n\t\t}\n\t  }\n  }\n  return 0;\t\n  }\nint main() {\nint i,c;\n while(cin >> m && m!=0) {\n\t cin >> n;\n\t for (i=1;i<=n;i++) cin >> t[i];\n\t c=hantei(0,0); c=0;\n\t for (i=0;i<=n;i++) g[i]=f[i];\n\t for (i=0;i<=n;i++)  if (g[i]>0) {c=hantei(i,1); if (c==2) break;}\n\t if (c==0) cout << \"NG\"; else cout << \"OK\";\n\t cout << endl;\n\t} \t\t\t   \n return 0;\n } "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define GET_MACRO5(ARG__1, ARG__2, ARG__3, ARG__4, ARG__5, NAME, ...) NAME\n#define GET_MACRO9(ARG__1, ARG__2, ARG__3, ARG__4, ARG__5, ARG__6, ARG__7, ARG__8, ARG__9, NAME, ...) NAME\n\n// Input ///////////////////////////////////////////////////////////////////////\n#define R1(a)                     cin>>a\n#define R2(a,b)                   cin>>a>>b\n#define R3(a,b,c)                 cin>>a>>b>>c\n#define R4(a,b,c,d)               cin>>a>>b>>c>>d\n#define R5(a,b,c,d,e)             cin>>a>>b>>c>>d>>e\n#define R6(a,b,c,d,e,f)           cin>>a>>b>>c>>d>>e>>f\n#define R7(a,b,c,d,e,f,g)         cin>>a>>b>>c>>d>>e>>f>>g\n#define R8(a,b,c,d,e,f,g,h)       cin>>a>>b>>c>>d>>e>>f>>g>>h\n#define R9(a,b,c,d,e,f,g,h,i)     cin>>a>>b>>c>>d>>e>>f>>g>>h>>i\n#define R(...) GET_MACRO9(__VA_ARGS__, R9, R8, R7, R6, R5, R4, R3, R2, R1)(__VA_ARGS__)\n\n#define I(...) int __VA_ARGS__; R(__VA_ARGS__)\n#define L(...) ll __VA_ARGS__; R(__VA_ARGS__)\n#define S(...) char __VA_ARGS__; R(__VA_ARGS__)\n\n#define TO_ARR1(n, a)             a[n]\n#define TO_ARR2(n, a, b)          a[n], b[n]\n#define TO_ARR3(n, a, b, c)       a[n], b[n], c[n]\n#define TO_ARR4(n, a, b, c, d)    a[n], b[n], c[n], d[n]\n#define TO_ARR5(n, a, b, c, d, e) a[n], b[n], c[n], d[n], e[n]\n#define TO_ARR(n, ...) \\\n\t\tGET_MACRO5(__VA_ARGS__, TO_ARR5, TO_ARR4, TO_ARR3, TO_ARR2, TO_ARR1)(n, __VA_ARGS__)\n\n#define ARR_CONCAT(type, n, ...) type TO_ARR(n, __VA_ARGS__); REP(i,n) R(TO_ARR(i, __VA_ARGS__));\n#define IARR(n, ...) ARR_CONCAT(int, n, __VA_ARGS__)\n#define LARR(n, ...) ARR_CONCAT(long long, n, __VA_ARGS__)\n\n#define input(t,v) t v;cin>>v;\n#define input2(t,v1,v2) t v1,v2;cin>>v1>>v2;\n#define input3(t,v1,v2,v3) t v1,v2,v3;cin>>v1>>v2>>v3;\n\ntemplate<class T=int> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\n// Types ///////////////////////////////////////////////////////////////////////\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef set<int> si;\ntypedef set<ll, ll> sll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef list<int> li;\ntypedef list<ll> lll;\ntypedef map<int, int> mii;\ntypedef map<int, ll> mil;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\n\n// Loop & Iteration ////////////////////////////////////////////////////////////\n#define FOR(i, a, b) for(int i = (a), loop_end_##i=(b); i < (loop_end_##i); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define rep(v,n) for(int (v)=0;(v)<(n);(v)++)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define PB push_back\n\n// Debug ///////////////////////////////////////////////////////////////////////\n#define dump(x)  cout << #x << \" = \" << (x) << endl\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\n\ntemplate<class T=int> void dump_table(int a, int b, T **x){\n\tint w = b, h = a;\n\tREP(j, w){\n\t\tprintf(\"\\t%d\", j);\n\t}\n\tprintf(\"\\n\");\n\tREP(i, h){\n\t\tprintf(\"%d\", i);\n\t\tREP(j, w){\n\t\t\tprintf(\"\\t%d\", x[i][j]);\n\t\t}\n\t}\n}\n////////////////////////////////////////////////////////////////////////////////\n\n#define constrain(a, b, c) std::max(std::min((a), (c)), (b))\n\nint main(){\n\tint max;\n\twhile(max=read<int>()){\n\t\tI(n);\n\t\tint d[n+2];\n\t\td[0]=d[n+1]=0;\n\t\tREP(i,n) d[i+1]=read<int>();\n\t\tset<int> cango[n+2];\n// \t\tREP(i, n+2) EACH(it, cango[i]) cout << *it;\n\t\tREP(i, n+1){\n\t\t\tREP(j, max){\n\t\t\t\tint x = constrain(i+j+1, 0, n+1);\n\t\t\t\tx = constrain(x + d[x], 0, n+1);\n\t\t\t\t// cout << x << endl;\n\t\t\t\tcango[x].insert(i);\n\t\t\t}\n\t\t}\n\t\tlist<int> cand;\n\t\tcand.PB(n+1);\n\t\tset<int> finish;\n\t\tint aaa = 0;\n\t\twhile(cand.size()){\n\t\t\tli::iterator it = cand.begin();\n\t\t\tint a = *it;\n\t\t\tcand.remove(a);\n\t\t\t// cout << a << endl;\n\t\t\tif(EXIST(finish, a)) continue;\n\t\t\tfor(set<int>::iterator it2=cango[a].begin(); it2!=cango[a].end(); it2++)\n\t\t\t\tcand.PB(*it2);\n\t\t\tfinish.insert(a);\n\t\t\taaa++;\n\t\t\tif(a>100){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tREP(i,n+1){\n\t\t\tif(!EXIST(finish, i)){\n\t\t\t\tok = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(ok) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int M, N;\n    int D[255];\n\n    while ( cin >> M, M ) {\n        int memo[255][1555];\n\n        cin >> N;\n        for ( int i = 1; i <= N; i++ ) {\n            cin >> D[i];\n        }\n        D[0] = 0, D[N + 1] = 0;\n\n        memset ( memo, -1, sizeof( memo ) );\n\n        function < int(int, int) > dfs = [&]( int v , int num )\n        {\n            int ret = 0;\n            if ( num > 1520 ) return ( 0 );\n            if ( memo[v][num] != -1 ) return ( 0 );\n            if ( v == N + 1 ) return ( 1 );\n\n            for ( int i = 1; i <= M && v + i <= N + 1; i++ ) {\n                int place = min( N + 1, max ( v + i + D[v + i], 0 ) ) ;\n                ret |= dfs ( place , num + 1);\n            }\n            return ( memo[v][num] = ret );\n        };\n\n        dfs ( 0 , 0 );\n\n        bool flag = true;\n        for ( int i = 0; i <= N; i++ ) {\n            bool g = false, f = false;\n            for ( int j = 0; j <= 1520; j++ ) {\n                if ( memo[i][j] != -1 ) f = true;\n                if ( memo[i][j] == 1 ) {\n                    g = true;\n                }\n            }\n            if ( f && !g ) flag = false;\n        }\n        cout << ( flag ? \"OK\" : \"NG\" ) << endl;\n\n    }\n\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nint ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\tif (ka[y][x] == 1)break;\n\t\t\t\tka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\tfor (int j = 0; j<300; j++)\n\t\t\t{\n\t\t\t\tka[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\t/*\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\t*/\n\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,dmax;\nint m[300];\nbool visited[300], isVisit[300], isGoal;\nvoid dfs(int p){\n  if(visited[p])return ;\n  visited[p] = true;\n  isVisit[p] = true;\n  if(p == n+1){\n    isGoal = true;\n    return;\n  }\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;  \n    dfs(np);\n  }\n}\nvoid solve(){\n  fill(isVisit, isVisit+(n+2), false);\n  isVisit[0] = true;\n  for(int i = 0 ; i <= n; i++){\n    if(!isVisit[i])continue;\n    isGoal = false;\n    fill(visited, visited+(n+2), false);\n    dfs(i);\n    if(!isGoal)break;    \n  }\n  cout << (isGoal?\"OK\":\"NG\") << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    fill(m, m+(n+2), 0);\n    for(int i = 0 ; i < n ;i++){\n      cin >> m[i+1];\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int> >G(252),R(252);\nint n,m;\nint d[252];\nbool u[252];\nvoid f(int v)\n{\n\tu[v]=1;\n\tfor(int i=0;i<R[v].size();i++)\n\t{\n\t\tif(!u[R[v][i]])f(R[v][i]);\n\t}\n}\nbool vi[252];\nbool ok(int v)\n{\n    bool ans=u[v];\n    vi[v]=1;\n    for(int i=0;i<G[v].size();i++)\n    {\n        if(!vi[G[v][i]])ans&=ok(G[v][i]);\n    }\n    return ans;\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<=n+1;i++)G[i].clear(),R[i].clear(),vi[i]=u[i]=0;\n\t\tfor(int i=1;i<=n;i++)cin>>d[i];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m&&i+j<=n+1;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+d[i+j];\n\t\t\t\tif(k>n+1)k=n+1;\n\t\t\t\tif(k<0)k=0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n+1);\n\t\tcout<<(ok(0)?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nint ma;\nint n;\nint a[252];\nint d[252];\nbool f[252];\n\nbool search(int x, int cnt)\n{\n\tif (x == n + 1) return true;\n\tif (d[x] < cnt) return false;\n\tif (cnt > 5000) return false;\n\t//printf(\"_ %d\\n\", x);\n\td[x] = cnt;\n\tfor (int i = 1; i <= ma; i++){\n\t\tint to = min(x + i, n + 1);\n\t\tto += a[to];\n\t\tto = max(to, 0);\n\t\tto = min(to, n + 1);\n\t\tif (search(to, cnt + 1)) return true;\n\t}\n\treturn false;\n}\n\nvoid solve()\n{\n\tbool res = true;\n\tfill(f, f + 252, false);\n\tfill(d, d + 252, INF);\n\tsearch(0, 0);\n\tfor (int i = 0; i <= 250; i++){\n\t\tf[i] = (d[i] != INF);\n\t}\n\tfor (int i = 0; i <= 250; i++){\n\t\tif (f[i]){\n\t\t\tfill(d, d + 252, INF);\n\t\t\tres &= search(i, 0);\n\t\t}\n\t}\n\tputs(res ? \"OK\" : \"NG\");\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &ma), ma){\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint M;\nint N;\nint D[252];\n\nbool used[252][252];\n\nbool rec(int pos)\n{\n    if (pos > N) return true;\n\n    pos += D[pos];\n\n    if (pos < 0) pos = 0;\n\n    bool res = true;\n\n    bool f = false;\n\n    for (int i = 1; i <= M; ++i) {\n        if (used[pos][i]) continue;\n        f = true;\n        used[pos][i] = true;\n        res &= rec(pos + i);\n        used[pos][i] = false;\n    }\n\n    if (!f) return false;\n\n    return res;\n}\n\nsigned main()\n{\n    while (cin >> M, M) {\n        cin >> N;\n        rep1(i, N) cin >> D[i];\n\n        memset(used, false, sizeof(used));\n\n        cout << (rec(0) ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){ \n  int d[251];\n  int dp[501];\n  int m,n;\n \n  while(1){\n    cin>>m;\n    if(m==0)break;\n    /* for(int i=0;i<=501;i++){\n       dp[i]=0;\n       }\n       for(int i=0;i<=251;i++){\n       d[i]=-1;\n       }*/\n    cin>>n;\n    d[0]=0;\n    for(int i=1;i<=n;i++)cin>>d[i];\n   \n    bool flag=0;\n    // cout<<m<<endl;\n    for(int x=0;x<=n;x++){\n      for(int i=1;i<=m;i++){\n\tif(dp[i+d[i+x]]==0) dp[i+d[i+x]]=1;\n\tif(i+d[i+x]>=n)flag=1; \n      }\n      if(flag==1)break;\n    }\n    if(flag==1)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nbool reach_fm_goal[512];\nbool reach_fm_start[512];\n\nint main() {\n\tint mx;\n\twhile(cin >> mx, mx) {\n\t\tint n;\n\t\tvector<int> d;\n\t\tfor(int i = 0; i < 512; i++)\n\t\t\treach_fm_goal[i] = reach_fm_start[i] = false;\n\t\tcin >> n;\n\t\td.resize(n+2);\n\t\td[0] = d[n+1] = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcin >> d[i+1];\n\n\t\tvector<vector<int> > edge, rev_edge;\n\t\tedge.resize((n+2)*2);\n\t\trev_edge.resize((n+2)*2);\n\t\tfor(int i = 0; i < n+2; i++) {\n\t\t\tfor(int j = 0; j < min(mx, n+1 - i); j++) {\n\t\t\t\tedge[n+2 + i].push_back(i + j+1);\n\t\t\t\trev_edge[i + j+1].push_back(n+2 + i);\n\t\t\t}\n\t\t\tif(d[i] > 0) {\n\t\t\t\tedge[i].push_back(n+2 + min(i+d[i], n+1));\n\t\t\t\trev_edge[n+2 + min(i+d[i], n+1)].push_back(i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tedge[i].push_back(n+2 + max(i+d[i], 0));\n\t\t\t\trev_edge[n+2 + max(i+d[i], 0)].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < rev_edge.size(); i++) {\n\t\t\tfor(int j = 0; j < rev_edge[i].size(); j++) {\n\t\t\t\tcout << rev_edge[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tqueue<int> q;\n\t\tq.push(0);\n\t\treach_fm_start[0] = true;\n\t\twhile(!q.empty()) {\n\t\t\tint cur = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i = 0; i < edge[cur].size(); i++) {\n\t\t\t\tif(!reach_fm_start[edge[cur][i]]) {\n\t\t\t\t\treach_fm_start[edge[cur][i]] = true;\n\t\t\t\t\tq.push(edge[cur][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.push((n+2)*2 - 1);\n\t\treach_fm_goal[(n+2)*2 - 1] = true;\n\t\twhile(!q.empty()) {\n\t\t\tint cur = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i = 0; i < rev_edge[cur].size(); i++) {\n\t\t\t\tif(!reach_fm_goal[rev_edge[cur][i]]) {\n\t\t\t\t\treach_fm_goal[rev_edge[cur][i]] = true;\n\t\t\t\t\tq.push(rev_edge[cur][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flg = true;\n\t\tfor(int i = 0; i < 512; i++) {\n\t\t\tif(reach_fm_start[i] && !reach_fm_goal[i])\n\t\t\t\tflg = false;\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < 20; i++) {\n\t\t\tcout << reach_fm_start[i] << \" \" << reach_fm_goal[i] << endl;\n\t\t}\n\t\t// */\n\t\t\n\t\tcout << (flg ? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nclass State {\npublic:\n  int x;\n  int cost;\n  State(int x,int cost)\n    : x(x), cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int max_roulette_num;\n  while(~scanf(\"%d\",&max_roulette_num)){\n    if(max_roulette_num == 0) break;\n\n    int stage[320] = {};\n    int total_cells;\n    scanf(\"%d\",&total_cells);\n    for(int i = 0; i < total_cells; i++){\n      int cell;\n      scanf(\"%d\",&cell);\n      stage[i+1] = cell;\n    }\n    stage[0] = 0;\n    stage[total_cells + 1] = 0;\n    \n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(0,0));\n    int dp[320];\n    memset(dp,0x3f,sizeof(dp));\n    dp[0] = 0;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int i = 1; i <= max_roulette_num; i++){\n        int next = s.x + i;\n        if(next > total_cells + 1) continue;\n        next += stage[next];\n        if(dp[next] <= s.cost + 1) continue;\n        dp[next] = s.cost + 1;\n        que.push(State(next,s.cost + 1));\n      }\n    }\n    vector<int> starts;\n    for(int i = 1; i <= total_cells + 1; i++){\n      if(dp[i] < INF) starts.push_back(i);\n    }\n\n    bool has_unable = false;\n    for(int start_i = 0; start_i < starts.size(); start_i++){\n      int start = starts[start_i];\n      memset(dp,0x3f,sizeof(dp));\n\n      que.push(State(start,0));\n      while(!que.empty()){\n        State s = que.top();\n        que.pop();\n        for(int i = 1; i <= max_roulette_num; i++){\n          int next = s.x + i;\n          if(next > total_cells + 1) continue;\n          next += stage[next];\n          if(dp[next] <= s.cost + 1) continue;\n          dp[next] = s.cost + 1;\n          que.push(State(next,s.cost + 1));\n        }\n      }\n\n      if(dp[total_cells + 1] >= INF){\n        has_unable = true;\n        break;\n      }\n    }\n    \n    printf(\"%s\\n\", has_unable ? \"NG\" : \"OK\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int M, N;\n    int D[255];\n\n    while ( cin >> M, M ) {\n        int memo[255][555];\n\n        cin >> N;\n        for ( int i = 1; i <= N; i++ ) {\n            cin >> D[i];\n        }\n        D[0] = 0, D[N + 1] = 0;\n\n        memset ( memo, -1, sizeof( memo ) );\n\n        function < int(int, int) > dfs = [&]( int v , int num )\n        {\n            int ret = 0;\n            if ( num > 520 ) return ( 0 );\n            if ( memo[v][num] != -1 ) return ( 0 );\n            if ( v == N + 1 ) return ( 1 );\n\n            for ( int i = 1; i <= M && v + i <= N + 1; i++ ) {\n                int place = min( N + 1, max ( v + i + D[v + i], 0 ) ) ;\n                ret |= dfs ( place , num + 1);\n            }\n            return ( memo[v][num] = ret );\n        };\n\n        dfs ( 0 , 0 );\n\n        bool flag = true;\n        for ( int i = 0; i < N; i++ ) {\n            bool g = false, f = false;\n            for ( int j = 0; j < 520; j++ ) {\n                if ( memo[i][j] != -1 ) f = true;\n                if ( memo[i][j] == 1 ) {\n                    g = true;\n                }\n            }\n            if ( f && !g ) flag = false;\n        }\n        cout << ( flag ? \"OK\" : \"NG\" ) << endl;\n\n    }\n\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nint n, m;\nint d[251];\nvec G[252];\nvec rG[252];\nbool can_goal[252];\nbool visited[252];\n\nvoid dfs(int v){\n    can_goal[v] = true;\n    for(int i=0;i<rG[v].size();i++){\n        if(!can_goal[rG[v][i]]) dfs(rG[v][i]);\n    }\n}\n\nbool dfs2(int v){\n    visited[v] = true;\n    if(!can_goal[v]) return false;\n    for(int i=0;i<G[v].size();i++){\n        if(!visited[G[v][i]]&&!dfs2(G[v][i])){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid add_edge(int f,int t){\n    G[f].push_back(t);\n    rG[t].push_back(f);\n}\n\nint main(){\n    while(cin >> m, m){\n        cin >> n;\n\n        for(int i=0;i<n+2;i++){\n            G[i].clear();\n            rG[i].clear();\n        }\n        d[0] = 0;\n        for(int i=1;i<=n;i++){\n            scanf(\"%d\", &d[i]);\n        }\n        for(int i=0;i<n+1;i++){\n            for(int j=1;j<=m;j++){\n                if(i+j >= n+1 || i+j+d[i+j] >= n+1){\n                    add_edge(i, n+1);\n                }else{\n                    add_edge(i, max(0, i+j+d[i+j]));\n                }\n            }\n        }\n\n        memset(can_goal, 0, sizeof(can_goal));\n        dfs(n+1);\n        memset(visited, 0, sizeof(visited));\n        if(dfs2(0))cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define repi(i,a,b) for( int i = (a); i != (b); ++i )\n\nint ma;\nint n;\nint d[252];\nstd::vector<int> G[252], rG[252];\nbool reach[252], rev[252];\n\nvoid dfs( int v )\n{\n\trev[v] = true;\n\n\trep( i, rG[v].size() )\n\t\tif( !rev[rG[v][i]] )\n\t\t\tdfs( rG[v][i] );\n\n\treturn;\n}\n\nvoid dfs2( int v )\n{\n\treach[v] = true;\n\n\trep( i, G[v].size() )\n\t\tif( !reach[G[v][i]] )\n\t\t\tdfs2( G[v][i] );\n\n\treturn;\n}\n\nint main()\n{\n\twhile( scanf( \"%d\", &ma ), ma )\n\t{\n\t\trep( i, 252 )\n\t\t\tG[i].clear(), rG[i].clear();\n\n\t\tscanf( \"%d\", &n );\n\n\t\trepi( i, 1, n+1 )\n\t\t\tscanf( \"%d\", d+i );\n\n\t\trep( i, n+1 )\n\t\t{\n\t\t\trep( j, ma )\n\t\t\t{\n\t\t\t\tint t = std::min( i+j+1, n+1 );\n\t\t\t\tint to = std::max( 0, std::min( t+d[t], n+1 ) );\n\t\t\t\tG[i].push_back( to );\n\t\t\t\trG[to].push_back( i );\n\t\t\t}\n\t\t}\n\n\t\tmemset( reach, false, sizeof( reach ) );\n\t\tmemset( rev, false, sizeof( rev ) );\n\t\tdfs( n+1 );\n\t\tdfs2( 0 );\n\n\t\tbool fl = true;\n\t\trep( i, n+2 )\n\t\t\tif( reach[i] && !rev[i] )\n\t\t\t\tfl = false;\n\n\t\tputs( fl ? \"OK\" : \"NG\" );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint m,n;\nint d[251];\n\nbool dfs(int x,bool *p){\n  x=max(0,x);\n  if(x>n)return true;\n  if(p[x]++)return false;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(nx>n||dfs(nx+d[nx],p))return true;\n  }\n  return false;\n}\n\nvoid reach(int x,bool *p){\n  x=max(0,x);\n  if(x>n)return;\n  if(p[x]++)return;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(nx<=n){\n      dfs(nx+d[nx],p);\n    }\n  }\n}\n\nint main(){\n  while(cin>>m>>n,m){\n    bool r[251]={};\n    for(int i=1;i<=n;i++){\n      cin>>d[i];\n    }\n    reach(0,r);\n    bool f=false;\n    for(int i=0;i<=n;i++){\n      bool p[251]={};\n      f|=r[i]&&!dfs(i,p);\n    }\n    cout<<(!f?\"OK\":\"NG\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,flag[252];\nvector<int> G[252];\nbool used[252];\n\nbool dfs(int v){\n\tif(flag[v] != -1) return flag[v];\n\tif(v == n + 1) return flag[v] = true;\n\tif(used[v]) return flag[v] = false;\n\tbool f = false;\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tif(dfs(G[v][i])) f = true;\n\t}\n\tused[v] = false;\n\treturn flag[v] = f;\n}\n\nint main(){\n\tint ma;\n\twhile(cin >> ma,ma){\n\t\tfor(int i = 0;i < 252;i++) {\n\t\t\tG[i].clear();\n\t\t\tused[i] = false;\n\t\t\tflag[i] = -1;\n\t\t}\n\t\tint d[252] = {};\n\t\tcin >> n;\n\t\tfor(int i = 0;i < n;i++) cin >> d[i + 1];\n\t\tfor(int i = 0;i < n + 1;i++){\n\t\t\tfor(int j = 1;j <= ma;j++){\n\t\t\t\tif(i + j >= n + 2) break;\n\t\t\t\tG[i].push_back(min(n + 1,max(0,i + j + d[i + j])));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n + 1;i++){\n\t\t\tsort(G[i].begin(),G[i].end());\n\t\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\t\t}\n\t\tdfs(0);\n\t\tbool ff = true;\n\t\tfor(int i = 0;i < n + 1;i++) if(!flag[i]) ff = false;\n\t\tif(ff) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]=dfs(1,nx);\n    //if(!memo[prev][x])ans=false;\n    return memo[prev][x];\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint M, n, d[252];\nint visited[252];\n\nbool rec(int start) {\n    bool ok = false;\n    if(start<0) return false;\n    if(n+1<start) return true;\n    if(visited[start]) return visited[start]>1;\n    visited[start] = 1;\n    for(int i=1; i<=M; i++) {\n        ok |= rec(start + i + d[start+i]);\n    }\n    if(ok) visited[start]++;\n    return ok;\n}\n\nint main()\n{\n    while(cin>>M, M) {\n        cin>>n;\n        visited[0] = 0;\n        for(int i=1; i<=n; i++) {\n            cin>>d[i];\n            visited[i] = 0;\n        }\n        rec(0);\n        bool ok = true;\n        for(int i=0; i<=n; i++) {\n            if(!visited[i]) continue;\n            if(visited[i]==1) ok = false;\n        }\n        if(ok) cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define MN 252\n\nvector<int> G[MN];\n\nint max_, n_, D[MN];\nbool init() {\n    cin >> max_; \n    if (max_ == 0) return false;\n    cin >> n_;\n    D[0] = D[n_+1] = 0;\n    for (int i = 1; i <= n_; i++) cin >> D[i];\n    return true;\n}\n\nbool v[MN];\nint next(int n) {\n    n = max(0, min(n_+1, n));\n    if (v[n]) {\n        return -1;\n    }\n    v[n] = true;\n    if (D[n] == 0) return n;\n    return next(n + D[n]);\n}\n\nvoid solve() {\n    queue<int> Q;\n    Q.push(0);\n    bool reach_goal = false;\n    bool v1[MN]; for (int i = 0; i < MN; i++) v1[i] = false;\n    while (!Q.empty()) {\n        int n = Q.front(); Q.pop();\n        if (n == n_+1) reach_goal = true;\n        for (int i = 1; i <= max_; i++) {\n            memset(v, 0, sizeof(v));\n            int nxt = next(n+i);\n            if (nxt < 0) {\n                cout << \"NG\" << endl;\n                return;\n            }\n            if (!v1[nxt]) {\n                Q.push(nxt);\n                v1[nxt] = true;\n            }\n        }\n    }\n    cout << (reach_goal ? \"OK\" : \"NG\") << endl;\n}\n\nint main() {\n    while (init()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\nint come[300];\nbool dfs(const int now,const vector<vector<int>>&edges, const int goal) {\n\tif (come[now])return true;\n\tcome[now] = true;\n\tif (now == goal)return true;\n\telse {\n\t\tif (edges[now].empty())return false;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (e == now)assert(false);\n\t\t\tif (!dfs(e, edges, goal))return false;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tmemset(come, false, sizeof(come));\n\t\tint amax;\n\t\tcin >> amax;\n\t\tif (!amax)break;\n\t\tint N; cin >> N;\n\t\tconst int goal = N + 1;\n\t\tconst int start = 0;\n\t\tvector<int>ds(goal+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tvector<vector<int>>edges(N + 2);\n\t\tfor (int i = 0; i < N + 1; ++i) {\n\t\t\tfor (int j = 1; j <= amax; ++j) {\n\t\t\t\tint next;\n\t\t\t\tif (i + j >= goal) {\n\t\t\t\t\tnext = goal;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i + j + ds[i + j] >= goal) {\n\t\t\t\t\t\tnext = goal;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i + j + ds[i+j]<0) {\n\t\t\t\t\t\tnext = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnext = i + j + ds[i + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (find(edges[i].begin(), edges[i].end(), next) == edges[i].end()) {\n\t\t\t\t\tedges[i].push_back(next);\n\t\t\t\t}\n\t\t\t\tsort(edges[i].begin(), edges[i].end());\n\t\t\t}\n\t\t}\n\t\tauto p=dscc.get(edges);\n\t\tint newstart=-1;\n\t\tint newgoal=-1;\n\t\tfor (int i = 0; i < p.first.size();++i) {\n\t\t\tauto b = p.first[i];\n\t\t\tif (find(b.begin(), b.end(), 0)!=b.end()) {\n\t\t\t\tnewstart = i;\n\t\t\t}\n\t\t\tif (find(b.begin(), b.end(), goal) != b.end()) {\n\t\t\t\tnewgoal= i;\n\t\t\t}\n\t\t}\n\t\tif (newstart == -1 || newgoal == -1)cout << \"ff\";\n\t\tauto newedges = p.second;\n\t\t\n\t\tbool ans = dfs(newstart, newedges, newgoal);\n\t\tif (ans) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<bitset>\n#include<vector>\nusing namespace std;\n\n\n\nint main()\n{\nint n,mex;\n  while(cin >> mex,mex)\n    {\n      cin >> n;\n      vector<int> G(n+1);\n      int out[n+1];\n\n      for(int i=1;i<=n;i++)\n\t{\n\t  cin >> G[i];\n\t  out[i] = 0;\n\t}\n      out[0] = 0;\n\n      for(int i=1;i<=n;i++)\n\tif(G[i] < 0)\n\t  for(int j=i-1;j>=i-mex && j >= 0;j--)\n\t    out[j]++;\n\t    \n\n      for(int i=0;i<n;i++)\n\t{\n\t  if(out[i] >= mex)\n\t    {\n\t      cout << \"NG\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"OK\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 252\nusing namespace std;\n \nint m,n,d[N],ans;\nbool dp[N];\n \nbool OK(int x){\n  bool r=false;\n  x+=d[x];\n  if(x<0&&dp[0]) r=true;\n  if(x>=n+1) r=true;\n  if(dp[x]) r=true;\n  return r;\n}\n \nint main(){\n  while(1){\n    cin>>m;\n    if(!m) break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    for(int i=0;i<=n;i++) dp[i]=false;\n    dp[n+1]=true;\n    while(1){\n      int f=0;\n      for(int i=n;i>=0;i--){\n\tif(dp[i]) continue;\n\tfor(int j=1;j<=m;j++){\n\t  if(i+j>=n+1||OK(i+j)){\n\t    dp[i]=true;\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n      if(!f) break;\n    }\n    while(1){\n      int f=0;\n      for(int i=0;i<=n;i++){\n\tif(dp[i]) continue;\n\tif(i+d[i]>=n+1||i+d[i]<0) continue;\n\tif(dp[i+d[i]]){\n\t  dp[i]=true;\n\t  f=1;\n\t}\n      }\n      if(!f) break;\n    }\n    ans=0;\n    for(int i=0;i<=n;i++)\n      if(!dp[i]) ans=1;\n    if(ans) cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n\nusing namespace std;\nint maxCount, n;\nvector<int> kouka;\nint memo[252];//251があがり0がふりだし\nint passed[252];\n\nconst int AGARI = 100000;\n\nbool dfs(int index)\n{\n\tif(passed[index]) return false;\n\tpassed[index] = true;\n\n\tindex = min(n + 1, max(0 ,kouka[index] + index));\n\tif(kouka[index] == AGARI) return true;\n\tfor (int i = 1; i <= maxCount; i++)\n\t{\n\t\tint next = index + i;\n\t\tif(memo[next])\n\t\t\tif(memo[next] = dfs(next))\n\t\t\t\treturn true;\n\t}\n\n\tpassed[index] = false;\n\treturn false;\n}\n\nbool solve()\n{\n\tfor (int i = 1; i <= maxCount; i++)\n\t{\n\t\tif(dfs(i)) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> maxCount && maxCount)\n\t{\n\t\tcin >> n;\n\t\tkouka.resize(n + 2);\n\t\tkouka[0] = -1;//ふりだし\n\t\tfor (int i = 1; i < n + 1; i++)\n\t\t{\n\t\t\tcin >> kouka[i];\n\t\t}\n\t\tkouka[n + 1] = AGARI;//あがり\n\t\tmemset(memo, true, sizeof(memo));\n\t\tmemset(passed, false, sizeof(memo));\n\t\tcout << (solve()? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool jd[600];\nbool td[600];\nint maxnum;\nint n;\nint d[600];\nbool ans(int pos){\n\tif(td[pos]==1){\n\t\treturn true;\n\t}\n\ttd[pos]=1;\n\tif(pos<0)pos=0;\n\tbool res=true;\n\tif(pos>n){\n\t\treturn true;\n\t}else if(jd[pos]==0){\n\t\treturn false;\n\t}else{\n\t\tfor(int i=1;i<maxnum+1;i++){\n\t\t\tif(ans(pos+i+d[pos+i])==false){\n\t\t\t\tres=false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid set(){\n\tfor(int i=n;i>-1;i--){\n\t\tfor(int j=1;j<maxnum+1 && jd[i]==0;j++){\n\t\t\tif(i+j>n){\n\t\t\t\tjd[i]=1;\n\t\t\t}else if(jd[i+j+d[i+j]]==1){\n\t\t\t\tjd[i]=1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\twhile(cin>>maxnum,maxnum){\n\t\tcin>>n;\n\t\td[0]=0;\n\t\tjd[0]=1;\n\t\tfor(int i=0;i<600;i++){\n\t\t\td[i]=jd[i]=td[i]=0;\n\t\t}\n\t\tfor(int i=1;i<n+1;i++){\n\t\t\tcin>>d[i];\n\t\t}\n\t\tset();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcout<<jd[i+1];\n\t\t}cout<<endl;\n\t\tif(ans(0)){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nbool dfs(const int now,const vector<vector<int>>&edges, const int goal) {\n\tif (now == goal)return true;\n\telse {\n\t\tif (edges[now].empty())return false;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!dfs(e, edges, goal))return false;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint amax;\n\t\tcin >> amax;\n\t\tif (!amax)break;\n\t\tint N; cin >> N;\n\t\tconst int goal = N + 1;\n\t\tconst int start = 0;\n\t\tvector<int>ds(goal+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tvector<vector<int>>edges(N + 2);\n\t\tfor (int i = 0; i < N + 1; ++i) {\n\t\t\tfor (int j = 1; j <= amax; ++j) {\n\t\t\t\tint next;\n\t\t\t\tif (i + j >= goal) {\n\t\t\t\t\tnext = goal;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i + j + ds[i + j] >= goal) {\n\t\t\t\t\t\tnext = goal;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i + j + ds[i+j]<0) {\n\t\t\t\t\t\tnext = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnext = i + j + ds[i + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (find(edges[i].begin(), edges[i].end(), next) == edges[i].end()) {\n\n\t\t\t\t\tedges[i].push_back(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=dscc.get(edges);\n\t\tint newstart;\n\t\tint newgoal;\n\t\tfor (int i = 0; i < p.first.size();++i) {\n\t\t\tauto b = p.first[i];\n\t\t\tif (find(b.begin(), b.end(), 0)!=b.end()) {\n\t\t\t\tnewstart = i;\n\t\t\t}\n\t\t\tif (find(b.begin(), b.end(), goal) != b.end()) {\n\t\t\t\tnewgoal= i;\n\t\t\t}\n\t\t}\n\t\tauto newedges = p.second;\n\t\t\n\t\tbool ans = dfs(newstart, newedges, newgoal);\n\t\tif (ans) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma GCC optimize(\"Ofast\")\n\n// Begin Header {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, b, e) for (intmax_t i = (b), i##_limit = (e); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T, class Compare = less<>>\nusing MaxHeap = priority_queue<T, vector<T>, Compare>;\ntemplate <class T, class Compare = greater<>>\nusing MinHeap = priority_queue<T, vector<T>, Compare>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline istream& operator>>(istream &is, vector<T> &vec) {\n    for (auto &e: vec) {\n        is >> e;\n    }\n    return is;\n}\n\ninline void output() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void output(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) {\n        cout << \" \";\n    }\n    output(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &os, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        os << e << delim[&e == &vec.back()];\n    }\n    return os;\n}\n\ntemplate <class T>\ninline vector<T> makeVector(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto makeVector(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(makeVector<T>(initValue, args...))>(sz, makeVector<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class Container>\nstruct reverse_t {\n    Container &c;\n    reverse_t(Container &c) : c(c) {}\n    auto begin() { return c.rbegin(); }\n    auto end() { return c.rend(); }\n};\n\ntemplate <class Container>\nauto reversed(Container &c) {\n    return reverse_t<Container>(c);\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// End Header }}}\n\n// Edge {{{\ntemplate <class Weight>\nstruct Edge {\n    size_t from, to;\n    Weight weight;\n\n    Edge() {}\n    Edge(size_t from, size_t to, Weight weight = 1) :\n        from(from), to(to), weight(weight)\n    {}\n\n    bool operator<(const Edge &rhs) const {\n        return weight < rhs.weight;\n    }\n\n    bool operator>(const Edge &rhs) const {\n        return weight > rhs.weight;\n    }\n\n    operator size_t() const {\n        return to;\n    }\n};\n// }}}\n\n// Graph {{{\ntemplate <class Weight>\nclass Graph : public vector<vector<Edge<Weight>>> {\n    using graph = vector<vector<Edge<Weight>>>;\n\npublic:\n    Graph() {}\n    Graph(const size_t V) : graph(V) {}\n\n    void connect(size_t from, size_t to, Weight weight = 1) {\n        (*this)[from].emplace_back(from, to, weight);\n    }\n\n    friend ostream& operator<<(ostream &strm, const Graph &G) {\n        for (size_t v = 0; v < G.size(); ++v) {\n            strm << '[' << setw(2) << v << ']';\n            for (const auto &e: G[v]) {\n                strm << ' ' << setw(2) << e.to;\n            }\n            strm << '\\n';\n        }\n        return strm;\n    }\n};\n// }}}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(ios_base::fixed);\n    cout.precision(20);\n\n    intmax_t M;\n    while (cin >> M, M) {\n        var(intmax_t, N);\n        vector<intmax_t> d(N + 2);\n        reps(i, 1, N) input(d[i]);\n\n        const auto clamp = [&](intmax_t v) -> intmax_t {\n            if (v < 0) {\n                return 0;\n            } else if (N + 1 < v) {\n                return N + 1;\n            } else {\n                return v;\n            }\n        };\n\n        vector<bool> seen(N + 2, false);\n        const auto dfs = makeFixPoint([&](auto dfs, size_t cur) -> bool {\n            seen[cur] = true;\n            if (cur == N + 1) return true;\n            bool ret = false;\n            reps(k, 1, M) {\n                const intmax_t v = clamp(cur + k);\n                const intmax_t nxt = clamp(v + d[v]);\n                if (!seen[nxt]) ret |= dfs(nxt);\n            }\n            return ret;\n        });\n\n        dfs(0);\n\n        auto can_reach = seen;\n\n        bool valid = true;\n        reps(i, 0, N) {\n            seen.assign(N + 2, false);\n            if (can_reach[i] && !dfs(i)) {\n                valid = false;\n                break;\n            }\n        }\n\n        output((valid) ? \"OK\" : \"NG\");\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\nint n;\nint MAP[256][256];\t//????????????,???????????????\nint main()\n{\n\tint max_m;\n\tint d[256]={0};\n\tint Flag,Flag2;\n\t\n\twhile (1) {\n\t\tFlag2 = 0;\n\t\tcin >> max_m;\n\t\tif (max_m == 0) break;\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> d[i];\n\t\t}\n\t\tmemset(MAP, 0, sizeof(MAP));\n\t\t\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j = i+1; j <= max_m+i; j++){\n\t\t\t\tif(j+d[j]<0)\n\t\t\t\t\tMAP[i][0] = 1;\n\t\t\t\telse if(j+d[j] > n + 2)\n\t\t\t\t\tMAP[i][n+1] = 1;\n\t\t\t\telse\n\t\t\t\t\tMAP[i][j+d[j]] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tFlag = 0;\n\t\t\tfor(int j=0;j<=n+1;j++){\n\t\t\t\tif(MAP[i][j] == 1 && i == j)\n\t\t\t\t\tFlag = 1;\n\t\t\t\telse if(MAP[i][j] == 1)\n\t\t\t\t\tFlag = 0;\n\t\t\t}\n\t\t\tif(Flag == 1)\n\t\t\t\tFlag2 = 1;\n\t\t}\n\t\tif(Flag2 == 1)\n\t\t\tcout << \"NG\" << endl;\n\t\telse\n\t\t\tcout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int M, N;\n    int D[255];\n\n    while ( cin >> M, M ) {\n        int memo[255][555];\n\n        cin >> N;\n        for ( int i = 1; i <= N; i++ ) {\n            cin >> D[i];\n        }\n        D[0] = 0, D[N + 1] = 0;\n\n        memset ( memo, -1, sizeof( memo ) );\n\n        function < int(int, int) > dfs = [&]( int v , int num )\n        {\n            int ret = 0;\n            if ( num > 520 ) return ( 0 );\n            if ( memo[v][num] != -1 ) return ( 0 );\n            if ( v == N + 1 ) return ( 1 );\n\n            for ( int i = 1; i <= M && v + i <= N + 1; i++ ) {\n                int place = min( N + 1, max ( v + i + D[v + i], 0 ) ) ;\n                ret |= dfs ( place , num + 1);\n            }\n            return ( memo[v][num] = ret );\n        };\n\n        dfs ( 0 , 0 );\n\n        bool flag = true;\n        for ( int i = 0; i < N; i++ ) {\n            bool g = false, f = false;\n            for ( int j = 0; j < 520; j++ ) {\n                if ( memo[i][j] != -1 ) f = true;\n                if ( memo[i][j] == 1 ) {\n                    g = true;\n                }\n            }\n            if ( f && !g ) flag = false;\n        }\n        cout << ( flag ? \"OK\" : \"NG\" ) << endl;\n\n    }\n\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nint m, n;\nvi d;\nvector<int> memo;\n\nint f(int p)\n{\n    p = max(0, p);\n    if(p >= n-1) return 1;\n    if(memo[p]) return memo[p];\n    \n    memo[p] = 2;\n    rep(i, m){\n        int v = f(p+i+1 + d[p+i+1]);\n        if(v == 1) memo[p] = 1;\n        if(v == 3) return memo[p] = 3;\n    }\n    \n    if(memo[p] == 2) memo[p] = 3;\n    return memo[p];\n}\n\nint main()\n{\n    while(cin >> m, m){\n        cin >> n;\n        n += 2;\n        d.assign(n, 0);\n        memo.assign(n, 0);\n        rep(i, n-2) cin >> d[i+1];\n        cout << (f(0) == 1 ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_N = 300;\nint maxi,n,d[MAX_N];\nvector<int> G[MAX_N], rG[MAX_N];\nbool reach[MAX_N];\n\nvoid dfs(int cur){\n  rep(i,(int)rG[cur].size()) {\n    int next = rG[cur][i];\n    if( !reach[next] ) { reach[next] = true; dfs(next); }\n  }\n}\n\nint main(){\n  while( cin >> maxi, maxi ){\n    cin >> n;\n    rep(i,n+5) { G[i].clear(); rG[i].clear(); reach[i] = false; d[i] = 0; }\n    REP(i,1,n+1) cin >> d[i];\n    n += 2;\n    rep(i,n-1) {\n      REP(j,1,maxi+1){\n        int next = i + j;\n        if( next >= n ) {\n          G[i].push_back(n-1);\n          rG[n-1].push_back(i);\n          break;\n        }\n        next += d[next];\n        if( next < 0 ) next = 0;\n        if( next >= n ) next = n-1;\n        G[i].push_back(next);\n        rG[next].push_back(i);\n      }\n    }\n    reach[n-1] = true;\n    dfs(n-1);\n    bool success = true;\n    rep(i,(int)G[0].size()) if( !reach[G[0][i]] ) { success = false; break; }\n    puts(success?\"OK\":\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nbool dfs(const int now,const vector<vector<int>>&edges, const int goal) {\n\tif (now == goal)return true;\n\telse {\n\t\tif (edges[now].empty())return false;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!dfs(e, edges, goal))return false;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint amax;\n\t\tcin >> amax;\n\t\tif (!amax)break;\n\t\tint N; cin >> N;\n\t\tconst int goal = N + 1;\n\t\tconst int start = 0;\n\t\tvector<int>ds(goal+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tvector<vector<int>>edges(N + 2);\n\t\tfor (int i = 0; i < N + 1; ++i) {\n\t\t\tfor (int j = 1; j <= amax; ++j) {\n\t\t\t\tint next;\n\t\t\t\tif (i + j >= goal) {\n\t\t\t\t\tnext = goal;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i + j + ds[i + j] >= goal) {\n\t\t\t\t\t\tnext = goal;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i + j + ds[i+j]<0) {\n\t\t\t\t\t\tnext = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnext = i + j + ds[i + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (find(edges[i].begin(), edges[i].end(), next) == edges.end()) {\n\n\t\t\t\t\tedges[i].push_back(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=dscc.get(edges);\n\t\tint newstart;\n\t\tint newgoal;\n\t\tfor (int i = 0; i < p.first.size();++i) {\n\t\t\tauto b = p.first[i];\n\t\t\tif (find(b.begin(), b.end(), 0)!=b.end()) {\n\t\t\t\tnewstart = i;\n\t\t\t}\n\t\t\tif (find(b.begin(), b.end(), goal) != b.end()) {\n\t\t\t\tnewgoal= i;\n\t\t\t}\n\t\t}\n\t\tauto newedges = p.second;\n\t\t\n\t\tbool ans = dfs(newstart, newedges, newgoal);\n\t\tif (ans) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nint M;\nint N;\nint D[259];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&M);\n\t\tif(M==0)break;\n\t\tscanf(\"%d\",&N);\n\t\tfor(int i=1;i<=N;i++)scanf(\"%d\",&D[i]);\n\t\tvector<int> G[259];\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(i+D[i]<0)G[i].pb(0);\n\t\t\telse if(i+D[i]>N+1)G[i].pb(N+1);\n\t\t\telse G[i].pb(i+D[i]);\n\t\t\tfor(int j=1;j<=M;j++){\n\t\t\t\tif(i+j<=N+1)G[i].pb(i+j);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=M;j++){\n\t\t\tif(j<=N+1)G[0].pb(j);\n\t\t}\n\t\tbool F[259];\n\t\tfor(int i=0;i<=N+1;i++)F[i]=false;\n\t\tvector<int>S;S.pb(0);\n\t\tint l=0;\n\t\twhile(l<(int)S.size()){\n\t\t\tint v=S[l];\n\t\t\tif(F[v]){\n\t\t\t\tl++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF[v]=true;\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tif(!F[G[v][i]]){\n\t\t\t\t\tS.pb(G[v][i]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\t\tbool ans=true;\n\t\tbool F1[259];\n\t\tfor(int i=0;i<=N+1;i++){\n\t\t\tif(!F[i])continue;\n\t\t\tfor(int j=0;j<=N+1;j++){\n\t\t\t\tF1[i]=false;\n\t\t\t}\n\t\t\tS.clear();\n\t\t\tS.pb(i);\n\t\t\tl=0;\n\t\t\twhile(l<(int)S.size()&&!F1[N+1]){\n\t\t\t\tint v=S[l];\n\t\t\t\tif(F1[v]){\n\t\t\t\t\tl++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tF1[v]=true;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tif(!F1[G[v][i]]){\n\t\t\t\t\t\tS.pb(G[v][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(!F1[N+1])ans=false;\n\t\t}\n\t\tif(ans)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint main(){\n  int m[260],h,a,b,i,j,hh;\n  while(1){\n    scanf(\"%d %d\",&a,&b);\n    if(a==0)break;\n    for(i=0;i<260;i++)m[i]=0;\n    for(i=1;i<=b;i++){\n      scanf(\"%d\",&m[i]);\n    }\n    hh=0;\n    for(i=0;i<=b;i++){\n      h=0;\n      for(j=1;j<=a;j++){\n\tif(m[i+j]+j+i>i)h++;\n      }\n      if(h==0){\n\thh++;\n\tbreak;\n      }\n    }\n    if(hh>0)printf(\"NG\\n\");\n    else printf(\"OK\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define all(s) (s).begin(), (s).end()\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint m, n;\nvi ok;\nvi d;\n\nbool isok(int num){\n\tif(ok[num] != -1) return ok[num];\n\tfor(int i = m; i >= 1; i--){\n\t\tint next = num+i;\n\t\tif(next < 0) next = 0;\n\t\tif(next > n) return ok[num] = true;\n\t\tnext += d[next];\n\t\tif(next < 0) next = 0;\n\t\tif(next == num) continue;\n\t\tif(next > n) return ok[num] = true;\n\t\tif(isok(next)) return ok[num] = true;\n\t}\n\n\treturn false;\n}\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\twhile(cin >> m, m){\n\t\tcin >> n;\n\t\td.resize(n+1);\n\t\tfill(all(d), 0);\n\t\trep(i, n) cin >> d[i+1];\n\t\tok.resize(n+1);\n\t\tfill(all(ok), -1);\n\n\t\tbool ans = true;\n\t\trep(i, n) ans &= isok(i);\n\t\t\n\t\tcout << (ans?\"OK\":\"NG\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Making Sugoroku\n\n// wrong answer\n// 3/6\n\n#include<iostream>\nusing namespace std;\n\nint M, n, d[252];\nint visited[252], visited2[252];\n\nvoid rec(int start) {\n    if(start < 0) return;\n    if(n+1 <= start) return;\n    if(visited[start]) return;\n    visited[start] = 1;\n    for(int i=1; i<=M; i++) {\n        rec(start + i + d[start+i]);\n    }\n    return;\n}\n\nbool rec2(int start) {\n    bool ok = false;\n    if(start < 0) return false;\n    if(n+1 <= start) return true;\n    if(visited2[start]) return false;\n    visited2[start] = 1;\n    for(int i=1; i<=M; i++) {\n        ok |= rec2(start + i + d[start+i]);\n    }\n    return ok;\n}\n\nint main()\n{\n    while(cin>>M, M) {\n        cin>>n;\n        visited[0] = 0;\n        for(int i=1; i<=n; i++) {\n            cin>>d[i];\n            visited[i] = 0;\n        }\n        d[0] = 0;\n        d[n+1] = 0;\n        rec(0);\n        bool ok = true;\n        for(int i=0; i<=n; i++) {\n            if(!visited[i]) continue;\n            for(int j=0; j<=n; j++) visited2[j] = false;\n            if(!rec2(i)) ok=false;\n        }\n        if(ok) cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nint main(){\n      int m,n;\n      while(scanf(\"%d\",&m)&&m){\n            scanf(\"%d\",&n);\n            int d[252];\n            bool f[252][252];\n            memset(f,false,sizeof(f));\n            REP(i,n){\n                  int a;\n                  scanf(\"%d\",&a);\n                  int now=i+a+1;\n                  now=max(0,min(n+1,now));\n                  d[i+1]=now;\n            }\n            d[n+1]=n+1;\n            REP(i,n+1){\n                  REP(j,m+1){\n                        int now=i+j;\n                        now=max(0,min(n+1,now));\n                        f[i][d[now]]=true;\n                  }\n            }\n            REP(k,n+2)\n                  REP(i,n+2)\n                        REP(j,n+2)\n                              if(f[i][k]&&f[k][j])f[i][j]=true;\n            bool ans=true;\n            REP(i,n+1)if(f[0][i]&&!f[i][n+1]){\n                  ans=false;\n            }\n            if(ans)cout<<\"OK\"<<endl;\n            else cout<<\"NG\"<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Max, N, d[252];\nbool graph[252], rgraph[252];\n\n\nmain()\n{\n\n  while(cin >> Max, Max) {\n    fill_n(d, 252, 0);\n    fill_n(graph, 252, false);\n    fill_n(rgraph, 252, false);\n\n    cin >> N;\n    for(int i = 1; i <= N; i++) {\n      cin >> d[i];\n    }\n\n    queue< int > que;\n    que.push(0);\n    graph[0] = true;\n    while(!que.empty()) {\n      int i = que.front(); que.pop();\n      for(int j = 1; j <= Max; j++) {\n        int next = max(0, min(N + 1, i + j + d[min(N + 1, i + j)]));\n        if(graph[next]++) continue;\n        que.push(next);\n      }\n    }\n\n    que.push(N + 1);\n    rgraph[N + 1] = true;\n    while(!que.empty()) {\n      int i = que.front(); que.pop();\n      for(int j = 1; j <= Max; j++) {\n        int prev = max(0, min(N + 1, i - j - d[max(0, i - j)]));\n        if(rgraph[prev]++) continue;\n        que.push(prev);\n      }\n    }\n    bool flag = true;\n    for(int i = 0; i <= N + 1; i++) {\n      if(graph[i] && !rgraph[i]) flag = false;\n    } \n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool g[251][251];\n\nint main(){\n\n  while(1){\n\n    int max;\n\n    cin >> max;\n\n    if(max == 0){\n      break;\n    }\n\n    int n;\n\n    cin >> n;\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n        g[i][j] = false;\n      }\n    }\n\n    int mass[n+2];\n\n    mass[0] = 0;\n    mass[n+1] = 0;\n\n    for(int i=1;i<n+1;i++){\n      cin >> mass[i];\n    }\n\n    for(int i=0;i<n+1;i++){\n      for(int j=1;i+j<n+2 && j<=max;j++){\n        int next = i+j+mass[i+j];\n        if(next<0) next = 0;\n        if(next>n+2) next=n+1;\n        g[i][next] = true;\n      }\n    }\n\n    for(int k=0;k<n+2;k++){\n      for(int i=0;i<n+2;i++){\n        for(int j=0;j<n+2;j++){\n          if(g[i][k] && g[k][j]){\n            g[i][j] = true;\n          }\n        }\n      }\n    }\n\n    bool flag = true;\n\n    for(int i=0;i<n+1;i++){\n      if(g[0][i] && !g[i][n+1]){\n        flag = false;\n        break;\n      }\n    }\n\n    if(flag){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[N],used[N],ans;\n\nvoid dfs(int x){\n  int px=x;\n  if(used[x])return;\n  used[x]=true;\n  x+=d[x];\n  if(x<0)x=0;\n  if(n+1<x)x=n+1;\n  if(d[px]<0&&used[x])return;\n  for(int i=1;i<=m;i++){\n    int nx=min(n+1,x+i);\n    dfs(nx);\n    memo[x]|=memo[nx];\n  }\n  if(!memo[x])ans=false;\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(used,0,sizeof(used));\n    memset(memo,0,sizeof(memo));\n    memo[n+1]=true;\n    ans=true;\n    dfs(0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nqueue<int> q;\n\nbool t[252];\nint d[252];\n\nint maxw;\n\nint n;\n\nvoid tw(int a)\n{\n\tif(a < 0)\n\t{\n\t\tif(!t[0])\n\t\t{\n\t\t\tt[0] = true;\n\t\t\tq.push(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!t[a])\n\t\t{\n\t\t\tt[a] = true;\n\t\t\tq.push(a);\n\t\t}\n\t}\n}\n\nvoid tou(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttw(a - i);\n\t}\n}\n\nvoid syo(int a)\n{\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(i + d[i] == a)\n\t\t{\n\t\t\ttou(a);\n\t\t}\n\t}\n}\n\nvoid init()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt[i] = false;\n\t}\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\tt[n + 1 - i] = true;\n\t\tq.push(n + 1 - i);\n\t\ttou(n + 1 - i);\n\t}\n}\n\nvoid modo()\n{\n\tinit();\n\twhile(!q.empty())\n\t{\n\t\tint w = q.front();\n\t\tq.pop();\n\t\tsyo(w);\n\t}\n}\n\nqueue<int> q2;\n\nbool t2[252];\n\nvoid tw2(int a)\n{\n\tif(a >= n + 2)\n\t{\n\t\tif(!t2[0])\n\t\t{\n\t\t\tt2[0] = true;\n\t\t\tq2.push(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!t2[a])\n\t\t{\n\t\t\tt2[a] = true;\n\t\t\tq2.push(a);\n\t\t}\n\t}\n}\n\nvoid tou2(int a)\n{\n\ttw2(a + d[a]);\n}\n\nvoid syo2(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttou2(a + 1);\n\t}\n}\n\nvoid init2()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt2[i] = false;\n\t}\n\tq.push(0);\n\tt2[0] = true;\n}\n\nvoid modo2()\n{\n\tinit2();\n\twhile(!q2.empty())\n\t{\n\t\tint w = q2.front();\n\t\tq2.pop();\n\t\tsyo2(w);\n\t}\n}\n\nbool can()\n{\n\tif(!t2[n + 1])\n\t{\n\t\treturn false;\n\t}\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tif(t2[i])\n\t\t{\n\t\t\tif(!t[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&maxw);\n\t\tif(maxw == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\td[0] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\",d + i);\n\t\t}\n\t\tmodo();\n\t\tmodo2();\n\t\tif(can())\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint dice,n,t[252],flg[252],v[252];\nvector<int> node[252];\nvoid bfs(int x){\n  v[x]=1;\n  \n  for(int i=1;i<=dice;i++){\n    if(x-i<0)break;\n    if(flg[x-i]==0){\n      flg[x-i]=1;\n      for(int j=0;j<(int)node[x-i].size();j++)if(v[node[x-i][j]]==0)bfs(node[x-i][j]);\n    }\n  }\n}\nint main(){\n  bool clearflg;\n  while(cin>>dice&&dice){\n    for(int i=0;i<252;i++){\n      t[i]=i;\n      node[i].clear();\n    }\n    cin>>n;\n    for(int i=1;i<=n;i++){\n      cin>>t[i];\n      t[i]=i+t[i];\n      if(t[i]<0)t[i]=0;\n      if(t[i]>n+1)t[i]=n+1;\n      node[t[i]].push_back(i);\n    }\n    for(int i=0;i<252;i++)flg[i]=v[i]=0;\n    bfs(n+1);\n\n    //for(int i=0;i<=n+1;i++)cout<<flg[i];\n    //cout<<endl;\n    clearflg=true;\n    for(int i=1;i<=dice;i++){\n      if(flg[t[i]]==0)clearflg=false;\n    }\n    if(clearflg){\n      cout<<\"OK\"<<endl;\n    }else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\nint come[300];\nbool dfs(const int now,const vector<vector<int>>&edges, const int goal) {\n\tassert(come[now] == false);\n\tcome[now] = true;\n\tif (now == goal)return true;\n\telse {\n\t\tif (edges[now].empty())return false;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (e == now)assert(false);\n\t\t\tif (!dfs(e, edges, goal))return false;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tmemset(come, false, sizeof(come));\n\t\tint amax;\n\t\tcin >> amax;\n\t\tif (!amax)break;\n\t\tint N; cin >> N;\n\t\tconst int goal = N + 1;\n\t\tconst int start = 0;\n\t\tvector<int>ds(goal+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tvector<vector<int>>edges(N + 2);\n\t\tfor (int i = 0; i < N + 1; ++i) {\n\t\t\tfor (int j = 1; j <= amax; ++j) {\n\t\t\t\tint next;\n\t\t\t\tif (i + j >= goal) {\n\t\t\t\t\tnext = goal;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i + j + ds[i + j] >= goal) {\n\t\t\t\t\t\tnext = goal;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i + j + ds[i+j]<0) {\n\t\t\t\t\t\tnext = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnext = i + j + ds[i + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (find(edges[i].begin(), edges[i].end(), next) == edges[i].end()) {\n\t\t\t\t\tedges[i].push_back(next);\n\t\t\t\t}\n\t\t\t\tsort(edges[i].begin(), edges[i].end());\n\t\t\t}\n\t\t}\n\t\tauto p=dscc.get(edges);\n\t\tint newstart;\n\t\tint newgoal;\n\t\tfor (int i = 0; i < p.first.size();++i) {\n\t\t\tauto b = p.first[i];\n\t\t\tif (find(b.begin(), b.end(), 0)!=b.end()) {\n\t\t\t\tnewstart = i;\n\t\t\t}\n\t\t\tif (find(b.begin(), b.end(), goal) != b.end()) {\n\t\t\t\tnewgoal= i;\n\t\t\t}\n\t\t}\n\t\tauto newedges = p.second;\n\t\t\n\t\tbool ans = dfs(newstart, newedges, newgoal);\n\t\tif (ans) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nint d[256][256];\nint op[256];\n\nint main(){\n  while(scanf(\"%d\", &M) && M){\n    scanf(\"%d\", &N);\n    memset(d, 0, sizeof(d));\n    memset(op, 0, sizeof(op));\n    REP(i, 1, N+1) scanf(\"%d\", op+i);\n\n    rep(i, N+1) REP(j, 1, M+1){\n      int next = i + j;\n      if(op[next] == 0){\n\td[i][next] = 1;\n      }else{\n\td[i][max(0, min(N+1, next+op[next]))] = 1;\n      }\n    }\n\n    rep(k, N+2) rep(i, N+2) rep(j, N+2){\n      if(d[i][k] && d[k][j]) d[i][j] = 1;\n    }\n\n    /*    rep(i, N+2){\n      rep(j, N+2) printf(\"%d \", d[i][j]); puts(\"\");\n      }*/\n\n    int p;\n    for(p = 0; p < N+1; p++) if(d[0][p] && !d[p][N+1]){ puts(\"NG\"); break;}\n    if(p == N+1) puts(\"OK\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\twhile(true){\n\t\tint ma,n,d[255];\n\t\tscanf(\"%d\",&ma);\n\t\tif(ma==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d\",&d[i]);\n\t\tvector<int>G[255];\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=1;j<=ma;j++){\n\t\t\t\tint x=i+j+d[i+j];\n\t\t\t\tif(x<0)x=0;\n\t\t\t\tif(x>n)x=n+1;\n\t\t\t\tG[i].push_back(x);\n\t\t\t}\n\t\t}\n\t\tbool f[255];\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tf[i]=false;\n\t\t}\n\t\tvector<int>vertex1;\n\t\tvertex1.push_back(0);int l=0;\n\t\twhile(l<(int)vertex1.size()){\n\t\t\tint v=vertex1[l];l++;if(f[v])continue;\n\t\t\tf[v]=true;\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tif(!f[G[v][i]])vertex1.push_back(G[v][i]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tbool ans=true;\n\t\tif(!f[n+1]){\n\t\t\tprintf(\"NG\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int s=1;s<=n+1;s++){\n\t\t\tif(f[s]){\n\t\t\t\tbool f1[255];\n\t\t\t\tfor(int i=0;i<=n+1;i++)f1[i]=false;\n\t\t\t\tvertex1.clear();\n\t\t\t\tvertex1.push_back(s);l=0;\n\t\t\t\twhile(l<(int)vertex1.size()){\n\t\t\t\t\tint v=vertex1[l];l++;if(f1[v])continue;\n\t\t\t\t\tf1[v]=true;\n\t\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\t\tif(!f1[G[v][i]])vertex1.push_back(G[v][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f1[n+1]){\n\t\t\t\t\tans=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[N],used[N],ans;\n\nbool dfs(int x){\n  if(d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    x=nx;\n  }\n  if(used[x])return memo[x];\n  used[x]=true;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[x]|=dfs(nx);\n  }\n  if(!memo[x])ans=false;\n  return memo[x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    memset(d,0,sizeof(d));\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[n+1]=true;\n    ans=true;\n    dfs(0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll m,n;\n  while(cin >> m &&m){\n    cin >> n;\n    vary(ll,v,n,0);\n    rep(i,n){\n      cin >> v[i];\n    }\n    bool ans = true;\n    rep(x,n){\n      vary(bool,dp,n+m+1,false);\n      dp[0] = true;\n      int s = x+1;\n      if(s < 0) s = 0;\n      if(s > n) dp[s] = true;\n      if(s > 0 && s <= n){\n        s += v[s-1];\n      }\n      if(s < 0) s = 0;\n      dp[s] = true;\n      if(s)\n        dp[0] = false;\n      rep(y,255){\n        rep(i,n+1){\n          rep(j,m){\n            int s = j+1 + i;\n            if(s < 0) s = 0;\n            if(s > n) dp[s] = dp[s] | dp[i];\n            if(s > 0 && s <= n){\n              s += v[s-1];\n            }\n            if(s < 0) s = 0;\n//             cout << i << ',' << s << endl;\n            dp[s] = dp[i] | dp[s];\n          }\n        }\n      }\n      bool f = false;\n      REP(i,n+1,n+m+1){\n        f |= dp[i];\n      }\n      ans = ans & f;\n    }\n    if(ans){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 252\nusing namespace std;\n\nint m,n,d[N],ans;\nbool dp[N],o[N];\n\nbool OK(int x){\n  bool r=false;\n  x+=d[x];\n  o[x]=true;\n  if(x<0&&dp[0]) r=true;\n  if(x>=n+1) r=true;\n  if(dp[x]) r=true;\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m) break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    for(int i=0;i<=n;i++) dp[i]=false,o[i]=false;\n    dp[n+1]=true;\n    while(1){\n      int f=0;\n      for(int i=n;i>=0;i--){\n\tif(dp[i]) continue;\n\tfor(int j=1;j<=m;j++){\n\t  if(i+j>=n+1||OK(i+j)){\n\t    dp[i]=true;\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n      if(!f) break;\n    }\n    for(int i=0;i<=n;i++)\n      if(!o[i]&&!dp[i]) dp[i]=true;\n    ans=0;\n    for(int i=0;i<=n;i++)\n      if(o[i]&&!dp[i]) ans=1;\n    if(ans) cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nint main(){\n\tint max,n;\n\tint e[10000];\n\tbool tizu[256][256];bool flag = false;\n\twhile(cin >> max,max){\n\tmemset(tizu,false,sizeof(tizu));\n\tflag = false;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> e[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=1;j<=max;j++){\n\t\t\tif(i+j+e[i+j]>=n+1) tizu[i][n+1] = true;\n\t\t\telse if(i+j+e[i+j]<=0) tizu[i][0] = true;\n\t\t\telse tizu[i][i+j+e[i+j]] = true;\n\t\t}\n\t}\n\tfor(int k=0;k<n+1;k++){\n\t\tfor(int i=0;k<n+1;k++){\n\t\t\tfor(int j=0;j<n+1;j++){\n\t\t\t\tif(tizu[i][k] && tizu[k][j]) tizu[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=max;i++){\n\t\tif(tizu[0][i] && !tizu[i][n+1]) flag = true;\n\t\telse if(!tizu[0][i] && !tizu[i][n+1]) flag = true;\n\t}\n\t(flag ? cout << \"NG\" : cout << \"OK\");\n\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\n//再帰flag変数\nbool flag_sugoroku[251] = {false};\n\n//入力配列\nint h_input[251] = {0};\n\n//入力変数\nint n = 0;\n//マスの数\nint masu = 0;\n\t\n\n//-- flag初期化関数 --//\n\nvoid f_syokika();\n\n\n//-- 再起関数 --//\n\nbool f_saiki(int , int);\n\n\n\nint main(void)\n{\n\twhile (cin >> n && n != 0)\n\t{\n\t\tcin >> masu;\n\t\t//成功flag\n\t\tbool ok = false;\n\n\t\tfor (int i = 0; i < masu; i++)\n\t\t{\n\t\t\tcin >> h_input[i];\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\t//必ず初期化が必要\n\t\t\tf_syokika();\n\t\t\tif (f_saiki(i , h_input[i]) == true)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\t\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n\n//*****----- flag初期化関数 -----*****//\n\nvoid f_syokika()\n{\n\tfor (int i = 0; i < 251; i++)\n\t{\n\t\tflag_sugoroku[i] = false;\n\t}\n}\n\n\n//*****----- 再起関数 -----*****//\n\nbool f_saiki(int index , int genzaiti)\n{\n\tif (index >= masu)\n\t{\n\t\treturn false;\n\t}\n\n\t//振り出しはいらない\n\tif (genzaiti < 0)\t{\treturn false;\t}\n\n\t//マスを超えていたらOK\n\tif (genzaiti >= masu)\t{\treturn true;\t}\n\n\t//既にきているなら駄目\n\tif (flag_sugoroku[genzaiti] == true)\n\t{\n\t\treturn true;\n\t}\n\n\t//現在地に到達\n\tflag_sugoroku[genzaiti] = true;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tf_saiki(index + 1 , genzaiti + h_input[i]);\n\t}\n\n\t//来てないことにする\n\tflag_sugoroku[genzaiti] = false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nconst int MAXN = 256;\n \nint maxi;\nint n;\nint d[MAXN];\nbool vis[MAXN], vis2[MAXN];\n \nint nextPos(int pos, int m) {\n  int npos = min(pos + m, n-1);\n  npos += d[npos];\n  npos = min(npos, n-1);\n  npos = max(npos, 0);\n  return npos;\n}\n \nvoid rec(int pos) {\n  vis[pos] = true;\n  for(int m = 1; m <= maxi; ++m) {\n    int npos = nextPos(pos, m);\n    if(vis[npos]) continue;\n    rec(npos);\n  }\n}\n \nbool rec2(int pos) {\n  vis2[pos] = true;\n  if(pos == n-1) return true;\n  for(int m = 1; m <= maxi; ++m) {\n    int npos = nextPos(pos, m);\n    if(vis2[npos]) continue;\n    if(rec2(npos)) return true;\n  }\n  return false;\n}\n \nint main() {\n  while(cin >> maxi && maxi) {\n    cin >> n;\n    for(int i = 0; i < n; ++i) cin >> d[i+1];\n    n += 2;\n    d[0] = d[n-1] = 0;\n    fill(vis, vis+n, false);\n    rec(0);\n    bool res = true;\n    for(int i = 0; i < n; ++i) {\n      if(vis[i]) {\n    fill(vis2, vis2+n, false);\n    if(!rec2(i)) {\n      res = false;\n      break;\n    }\n      }\n    }\n    if(res) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n\nint M, N, D[256];\nbool G[256][256];\n\n\nint main()\n{\n\tfor(; cin >> M && M; ) {\n\t\tmemset(G, false, sizeof G);\n\t\t\n\t\tcin >> N;\n\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tcin >> D[i];\n\t\t}\n\n\t\tfor(int i = 0; i <= N; i++) {\n\t\t\tfor(int j = 1; j <= M; j++) {\n\t\t\t\tif(i+j >= N+1) G[i][N+1] = true;\n\t\t\t\telse G[i][max(0, min(i+j+D[i+j], N+1))] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i <= N+1; i++) {\n\t\t\tfor(int j = 0; j <= N+1; j++) {\n\t\t\t\tfor(int k = 0; k <= N+1; k++) {\n\t\t\t\t\tG[i][j] |= (G[i][k] && G[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool res = G[0][N+1];\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tres &= (G[0][i] ? G[i][N+1] : true);\n\t\t}\n\t\t\n\t\tcout << (res ? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_N = 300;\nint maxi,n,d[MAX_N];\nvector<int> G[MAX_N], rG[MAX_N];\nbool reach[MAX_N];\n\nvoid dfs(int cur){\n  rep(i,(int)rG[cur].size()) {\n    int next = rG[cur][i];\n    if( !reach[next] ) { reach[next] = true; dfs(next); }\n  }\n}\n\nint main(){\n  while( cin >> maxi, maxi ){\n    cin >> n;\n    rep(i,n+5) { G[i].clear(); rG[i].clear(); reach[i] = false; d[i] = 0; }\n    REP(i,1,n+1) cin >> d[i];\n    n += 2;\n    rep(i,n-1) {\n      REP(j,1,maxi+1){\n        int next = i + j;\n        if( next >= n ) {\n          G[i].push_back(n-1);\n          rG[n-1].push_back(i);\n          break;\n        }\n        next += d[next];\n        if( next < 0 ) next = 0;\n        if( next >= n ) next = n-1;\n        G[i].push_back(next);\n        rG[next].push_back(i);\n      }\n    }\n    reach[n-1] = true;\n    dfs(n-1);\n    bool success = reach[0];\n    rep(i,(int)G[0].size()) if( !reach[G[0][i]] ) { success = false; break; }\n    puts(success?\"OK\":\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]=dfs(1,nx);\n    if(!memo[prev][x])ans=false;\n    return memo[prev][x];\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint m,n;\nint d[251];\n\nbool dfs(int x,bool *p){\n  x=max(0,x);\n  if(x>n)return true;\n  if(p[x]++)return false;\n  bool f=false;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    f|=nx>n||dfs(nx+d[nx],p);\n  }\n  return f;\n}\n\nint main(){\n  while(cin>>m>>n,m){\n    bool r[251]={};\n    for(int i=1;i<=n;i++){\n      cin>>d[i];\n    }\n    dfs(0,r);\n    bool f=false;\n    for(int i=0;i<=n;i++){\n      bool p[251]={};\n      f|=r[i]&&!dfs(i,p);\n    }\n    cout<<(!f?\"OK\":\"NG\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 256;\n\nint maxi;\nint n;\nint d[MAXN];\nint canGoal[MAXN];\n\nint nextPos(int pos, int m) {\n  int npos = min(pos + m, n-1);\n  npos += d[npos];\n  npos = min(npos, n-1);\n  npos = max(npos, 0);\n  return npos;\n}\n\nint rec(int pos) {\n  int &res = canGoal[pos];\n  if(res != -1) return res;\n  res = 0;\n  for(int m = 1; m <= maxi; ++m) {\n    if(rec(nextPos(pos, m))) {\n      res = 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> maxi && maxi) {\n    cin >> n;\n    for(int i = 0; i < n; ++i) cin >> d[i+1];\n    n += 2;\n    d[0] = d[n-1] = 0;\n    fill(canGoal, canGoal+n, -1);\n    canGoal[n-1] = 1;\n    rec(0);\n    bool res = true;\n    for(int i = 0; i < n; ++i) {\n      if(canGoal[i] == 0) {\n\tres = false;\n\tbreak;\n      }\n    }\n    if(res) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nint main(){\n\tint max,n;\n\tint e[10000];\n\tbool tizu[256][256];bool flag = false;\n\twhile(cin >> max,max){\n\tmemset(tizu,false,sizeof(tizu));\n\tflag = false;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> e[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=1;j<=max;j++){\n\t\t\tif(i+j+e[i+j]>=n+1) tizu[i][n+1] = true;\n\t\t\telse if(i+j+e[i+j]<=0) tizu[i][0] = true;\n\t\t\telse tizu[i][i+j+e[i+j]] = true;\n\t\t}\n\t}\n\tfor(int k=0;k<n+1;k++){\n\t\tfor(int i=0;k<n+1;k++){\n\t\t\tfor(int j=0;j<n+1;j++){\n\t\t\t\tif(tizu[i][k] && tizu[k][j]) tizu[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tif(tizu[0][i] && !tizu[i][n+1]) flag = true;\n\t}\n\t(flag ? cout << \"NG\" : cout << \"OK\");\n\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 650\n\nvoid calc(int m){\n  int n;\n  int d[SIZE];\n  \n  scanf(\"%d\",&n);\n\n  d[0] = 0;\n  d[n+1] = 0;\n  for(int i=1;i<=n;i++){\n    scanf(\"%d\",d+i);\n  }\n\n  queue<int> q;\n  q.push(0);\n  bool can_visit[SIZE] = {};\n  can_visit[0] = true;\n\n  \n  while(q.size()){\n    bool flag = false;\n    int st = q.front();\n    int visited[SIZE] = {};\n    q.pop();\n    \n    queue<int> q2;\n    q2.push(st);\n\n    while(q2.size()){\n      int now = q2.front();\n      q2.pop();\n\n      if(visited[now]) continue;\n\n      if(now == n+1){\n        flag = true;\n      }\n\n      visited[now] = true;\n\n      if(can_visit[now] == false){\n        can_visit[now] = true;\n        q.push(now);\n      }\n\n      for(int i=1;i<=m;i++){\n        int next = min(n+1,now+i);\n\n        if(d[next] < 0){\n          next = max(0,next + d[next]);\n        }else{\n          next = min(n+1,next + d[next]);\n        }\n        \n        q2.push(next);\n      }\n    }\n\n    if(flag == false){\n      puts(\"NG\");\n      return;\n    }\n  }\n\n  puts(\"OK\");\n}\n  \n\nint main(){\n  int m;\n\n  while(scanf(\"%d\",&m)!=EOF){\n    if(m==0) break;\n    calc(m);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\n\nvector<bool> cnt(vvi G, int start)\n{\n    vector<bool> visited(G.size(), false);\n    queue<int> Q;\n    Q.push(start);\n    \n    while(!Q.empty()){\n        int p = Q.front();\n        Q.pop();\n        if(visited[p]) continue;\n        visited[p] = true;\n        for(int e : G[p]){\n            Q.push(e);\n        }\n    }\n    \n    return visited;\n}\n\n\nint func(int m)\n{\n    int n;\n    cin >> n;\n    \n    vvi G1(n+2), G2(n+2);\n    vi d(n+m);\n    rep(i, n){\n        cin >> d[i];\n    }\n    \n    rep(i, n+1){\n        rep(j, m){\n            int v = i + j + 1 + d[i+j];\n            if(0 <= v && v < n+2){\n                G1[i].push_back(v);\n                G2[v].push_back(i);\n            }\n        }\n    }\n    \n    vector<bool> a = cnt(G1, 0), b = cnt(G2, n+1);\n    rep(i, n+2){\n        if(a[i] && !b[i]) return false;\n    }\n    return true;\n}\n\nint main()\n{\n    int m;\n    while(cin >> m, m){\n        cout << (func(m) ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MN = 400;\n\nint main() {\n    while(1) {\n        int m, n;\n        int d[MN] = {};\n        bool used[MN][2] = {};\n        vector<int> rd[MN];\n\n        cin >> m;\n        if (!m) break;\n        cin >> n; n++;\n        for (int i = 1; i < n; i++) {\n            cin >> d[i];\n            d[i] += i;\n            d[i] = max(d[i], 0);\n            d[i] = min(d[i], n);\n            rd[d[i]].push_back(i);\n        }\n        rd[0].push_back(0);\n        d[n] = n;\n        rd[n].push_back(n);\n        queue<P> q;\n        q.push(P(n, 0));\n        q.push(P(n, 1));\n        while (!q.empty()) {\n            P p = q.front(); q.pop();\n            int u, f;\n            tie(u, f) = p;\n            if (used[u][f]) continue;\n            //cout << u << endl;\n            used[u][f] = true;\n            if (!f) {\n                for (int i = max(0, u-m); i < u; i++) {\n                    q.push(P(i, 1));\n                }                \n            } else {\n                for (int i: rd[u]) {\n                    q.push(P(i, 0));\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            //printf(\"%d %d %d\\n\", i, used[i][0], used[i][1]);\n        }\n        bool f = true;\n        for (int i = 1; i <= min(n, m); i++) {\n            if (!used[i][0]) {\n                //cout << i << endl;\n                f = false;\n            }\n        }\n        if (f) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 10;\nint m,n;\nint x[300];\nint hoge[300];\nint used[300];\nint f(int num){\n    int ans = 0;\n    if(x[num]!=INF){\n        return x[num];\n    }else if(used[num] && x[num] == INF){\n        cout << num;\n        return 0;\n    }\n    if(num >= n){\n        return 1;\n    }\n    used[num] = 1;\n    ans = min(f(num + hoge[num]),INF);\n    return ans;\n}\n\nsigned main(){\n    while(1){\n        cin >> m;\n        if(m == 0)break;\n        cin >> n;\n        fill(x,x+300,INF);\n        fill(used,used+300,0);\n        for(int i = 1; i <= n; i++){\n            cin >> hoge[i];\n        }\n        hoge[0] = 0;\n        int o = 0,u,k;\n        bool ans = true;\n        for(int i = 0; i <= n; i++){\n            k = i + hoge[i];\n            o = 0;\n            for(int j = 1; j <= m; j++){\n                u = k + j;\n                if(hoge[u] <= -j){\n                    o++;\n                }else{\n                    break;\n                }\n            }\n            if(o == m){\n                ans = false;\n                break;\n            }\n        }\n        if(ans){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define double long double\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\ntypedef vector<pii> VP;\ntypedef vector<string> VS;\ntypedef priority_queue<int> PQ;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n#define eps 1e-12 \n//priority_queue<int,vector<int>, greater<int> > q2;\nint N;\nint G[300][300];\n\nvoid warshall() {\n\tREP(i, N + 2) {\n\t\tREP(j, N + 2) {\n\t\t\tREP(k, N + 2) {\n\t\t\t\tG[j][k] = min(G[j][k], G[j][i] + G[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstring solve(int M) {\n\tcin >> N;\n\n\tVI D(N);\n\tREP(i, N)cin >> D[i];\n\tqueue<int>Q;\n\tvector<bool>F(N + 1, false);\n\tF[0] = 1;\n\tQ.push(0);\n\twhile (!Q.empty()) {\n\t\tint from = Q.front(); Q.pop();\n\t\teFOR(i, 1, M) {\n\t\t\tint to = from + i;\n\t\t\tif (to > N + 1)break;\n\t\t\tif (to == N + 1) {\n\t\t\t\t//G[from].push_back(to);\n\t\t\t\tG[from][to] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto += D[to - 1];\n\t\t\t\tif (to < 0)to = 0;\n\t\t\t\tif (to > N + 1)to = N + 1;\n\t\t\t\t//if (from != to) {\n\t\t\t\t\t//G[from].push_back(to);\n\t\t\t\t\t//cout << from << \" \" << to << endl;\n\t\t\t\t\tG[from][to] = 1;\n\t\t\t\t\tif (!F[to]) {\n\t\t\t\t\t\tF[to] = 1;\n\t\t\t\t\t\tQ.push(to);\n\t\t\t\t\t}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\twarshall();\n\teREP(i, N) {\n\t\t//cout << i + 1 << \" \" << G[0][i + 1] << \" \" << G[i + 1][N + 1] << endl;\n\t\tif (G[0][i] != INF && G[i][N + 1] == INF) {\n\t\t\t//cout << i + 1 << endl;\n\t\t\treturn \"NG\";\n\t\t}\n\t}\n\treturn \"OK\";\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tint M = 1;\n\twhile (M) {\n\t\tREP(i, 300)REP(j, 300)G[i][j] = INF;\n\t\tcin >> M;\n\t\tif (!M)return 0;\n\t\tcout << solve(M) << '\\n';\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nint mx;\nint d[3000];\nint n;\nint done[3000] = {};\nint ok[3000] = {};\nint can(int x){\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\tif( x == n - 1 ) return 1;\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( can(t) ) return 1;\n\t}\n\treturn 0;\n}\nint dfs(int x){\n\tif( !ok[x] ) return 1;\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\t\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( dfs(t) ) return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> mx && mx){\n\t\tfor(int i = 0 ; i < 300 ; i++) d[i] = 0;\n\t\tfor(int i = 0 ; i < 300 ; i++) ok[i] = 1;\n\t\tcin >> n;\n\t\tn += 2;\n\t\tfor(int i = 1 ; i < n - 1 ; i++)\n\t\t\tcin >> d[i];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\t\tok[i] = can(i);\n\t\t}\n\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\tcout << (dfs(0)?\"NG\":\"OK\") << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> a;\nint n,m;\nvector<bool> d(300);\n\nvoid saiki(vector<int> a,vector<bool> &u,int p){\n    if(u[p]) return ;\n    u[p] = true;\n    for(int i=1;i<=m;i++){\n\tint temp = min(n+1,p+i);\n\ttemp = max(min(temp+a[temp],n+1),0);\n\tsaiki(a,u,temp);\n    }\n}\n\nint main(){\n    while(true){\n\tfill(ALL(d),true);\n\ta = vector<int>(0);\n\tcin >> m;\n\tif(m == 0) break;\n\tcin >> n;\n\ta.PB(-300);\n\tREP(i,n){\n\t    int temp;\n\t    cin >> temp;\n\t    a.PB(temp);\n\t}\n\ta.PB(300);\n\tvector<bool> u(a.size(),false);\n\tsaiki(a,u,0);\n\tbool ans = true;\n\tif(!u[u.size()-1]) cout << \"NG\"<< endl;\n\telse{\n\t    u[u.size()-1] = false;\n\t    RREP(i,n+2){\n\t\tif(u[i]){\n\t\t    vector<bool> used(u.size(),false);\n\t\t    queue<int> q;\n\t\t    q.push(i);\n\t\t    while(!q.empty()){\n\t\t\tint x = q.front();\n\t\t\tq.pop();\n\t\t\tif(x == a.size()-1) {\n\t\t\t    u[x] = true;\n\t\t\t    break;\n\t\t\t}\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t    int nx = x + i;\n\t\t\t    if(a.size()<=nx) nx = a.size()-1;\n\t\t\t    nx = min((int)(a.size()-1),a[nx] + nx);\n\t\t\t    nx = max(nx,0);\n\t\t\t    if(!used[nx]){\n\t\t\t\tused[nx] = true;\n\t\t\t\tq.push(nx);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if(!used.back()){\n\t\t\tans = false;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if(ans) cout << \"OK\"<<endl;\n\t    else cout << \"NG\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q;\n    for(int k=0;k<=n;k++){\n      q.push(k);\n      fill(used,used+300,false);\n      while(!q.empty()){\n\tp=q.front();q.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(used[p]) continue;\n\tused[p]=true;\n\tr[p]=true;\n\tfor(i=1;i<=m;i++){\n\t  if(p+i+d[p+i]>n+1){\n\t    used[n+1]=true;\n\t    break;\n\t  }else q.push(p+i+d[p+i]);\n\t}\n      }\n      g[k]=used[n+1];\n    }\n    bool c=true;\n    for(i=0;i<=n;i++){\n      if(r[i]&&!g[i]) c=false;\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> T round_up(T a, T b) { return (a + b - 1) / b; }\n\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\nint m, n, d[333];\nvector<bool> bfs(int start)\n{\n    queue<int> q;\n    vector<bool> visit(n + 2, false);\n    visit[start] = true;\n    q.push(start);\n    while (!q.empty())\n    {\n        int p = q.front();\n        q.pop();\n\n        for (int i = 1; i <= m; ++i)\n        {\n            int to = min(p + i, n + 1);\n            to = to + d[to];\n            chmin(to, n + 1);\n            chmax(to, 0);\n            if (!visit[to])\n            {\n                visit[to] = true;\n                q.push(to);\n            }\n        }\n    }\n    return visit;\n}\nint main()\n{\n    while (cin >> m, m)\n    {\n        CL(d, 0);\n        cin >> n;\n        input(d + 1, n);\n\n        vector<bool> reach = bfs(0);\n        bool f = true;\n        for (int s = 0; s <= n; ++s)\n            if (reach[s] && !bfs(s)[n + 1])\n                f = false;\n        cout << (f ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "     if(Solve(x+i)==true)return true;\n    }   \n    \n  }\n  \n  flg[x]=false;\n  \n  return false;\n}\n\n\nint main(){\n  \n  while(cin>>mx , mx){\n    cin >> n;\n    d[0]=0;\n    for(int i=1; i<=n; i++){\n      cin>>d[i];\n      flg[i]=false;\n    }\n\n    if(Solve(0)==true)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<climits>\n#include <utility>\nusing namespace std;\n\nint n;\nint ma;\nvector<int>vec;\nvector<bool>ok;\n\nbool solve(int cur){\n    for(int i=0;i<vec.size();i++){\n        if(cur+vec[i]>=0&&cur+vec[i]<ok.size()&&!ok[cur+vec[i]]){\n            if(cur+vec[i]==ok.size()-1){\n                return true;\n            }\n            ok[cur+vec[i]]=true;\n            if(solve(cur+vec[i])){\n                return true;\n            };\n        }\n    }\n    return false;\n}\n\nint main(){\n    while(cin>>ma,ma){\n        ok.push_back(true);\n        cin>>n;\n        for(int i=0;i<n;i++){\n            int j;\n            cin>>j;\n            vec.push_back(j);\n            ok.push_back(false);\n        }\n        ok.push_back(false);\n        if(solve(0)){\n            cout<<\"OK\"<<endl;\n        } else {\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint m,n;\nint a[300];\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> m;\n\t\tif(m==0)break;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++)cin >> a[i];\n\t\tbool flag=true;\n\t\tfor(int i=0;i<=n-m;i++)\n\t\t{\n\t\t\tbool p=true;\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tint k=i+j+a[i+j];\n\t\t\t\tif(k>i)\n\t\t\t\t{\n\t\t\t\t\tp=false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p)\n\t\t\t{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tend:;\n\t\t}\n\t\tcout << \"OK\" << endl;\n\t\tnext:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 260;\nbool come[MAX],goal[MAX];\nint M,n,d[MAX];\n\nvoid print(){\n\n  for(int i = 0; i <= n; i++) cout << come[i] << \" \";\n  cout << endl;\n  for(int i = 0; i <= n; i++) cout << goal[i] << \" \";\n  cout << endl;\n}\n\nvoid init(){\n  fill(come,come+MAX,false);\n  fill(goal,goal+MAX,false);\n  fill(d,d+MAX,0);\n}\n\nint move(int now, int num){\n  int nex = now+num;\n  if(nex > n) return -1;\n  nex += d[nex];\n  if(nex > n) return -1;\n  if(nex < 0) return 0;\n  return nex;\n}\n\nvoid make_come(){\n  come[0] = true;\n  priority_queue<int,vector<int>,greater<int> > Q;\n  Q.push(0);\n  while(!Q.empty()){\n    int now = Q.top();\n    Q.pop();\n\n    for(int i = 1; i <= M; i++){\n      int nex = move(now,i);\n      if(nex == -1) goal[now] = true;\n      else if(!come[nex] && nex <= n){\n        come[nex] = true;\n        Q.push(nex);\n      }\n    }\n  }\n}\n\nvoid make_goal(){\n\n  while(1){\n    bool update = false;\n\n    for(int i = n; i >= 0; i--){\n      if(!come[i] || goal[i]) continue;\n      \n      for(int j = 1; j <= M; j++){\n        int nex = move(i,j);\n        if(nex == -1){\n          goal[i] = true;\n          update = true;\n        }else if(goal[nex]){\n          goal[i] = true;\n          update = true;\n        } \n      }\n    }\n    if(!update) break;\n  }\n}\n\n\nbool solve(){\n\n  make_come();\n  make_goal();\n\n  for(int i = 0; i <= n; i++)\n    if(come[i] && !goal[i]) return false; \n  return true;\n}\n\nint main(){\n\n  while(cin >> M && M){\n    init();\n    cin >> n;\n    for(int i = 1; i <= n; i++) cin >> d[i];\n    if(solve()) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    //print();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool used[N],ans;\n\nvoid dfs(int x){\n  x+=d[x];\n  if(x<0)x=0;\n  if(n+1<x)x=n+1;\n  if(used[x])return;\n  used[x]=true;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    dfs(nx);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    memset(d,0,sizeof(d));\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(used,0,sizeof(used));\n    dfs(0);\n    ans=true;\n    for(int i=0;i<=n;i++){\n      if(!used[i])continue;\n      for(int j=1;j<=m;j++){\n\tint ni=min(n+1,i+j);\n\tif(ni+d[ni]==i)ans=false;\n      }\n    }\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\nint n;\nint MAP[252][252];\t//????????????,???????????????\nint main()\n{\n\tint max_m;\n\tint d[252]={0};\n\tint Flag,Flag2;\n\t\n\twhile (1) {\n\t\tFlag2 = 0;\n\t\tcin >> max_m;\n\t\tif (max_m == 0) break;\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> d[i];\n\t\t}\n\t\tmemset(MAP, 0, sizeof(MAP));\n\t\t\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j = i+1; j <= max_m+i; j++){\n\t\t\t\tif(j+d[j]<0)\n\t\t\t\t\tMAP[i][0] = 1;\n\t\t\t\telse if(j+d[j] > n + 2)\n\t\t\t\t\tMAP[i][n+1] = 1;\n\t\t\t\telse\n\t\t\t\t\tMAP[i][j+d[j]] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tFlag = 0;\n\t\t\tfor(int j=0;j<=n+1;j++){\n\t\t\t\tif(MAP[i][j] == 1 && i == j)\n\t\t\t\t\tFlag = 1;\n\t\t\t\telse if(MAP[i][j] == 1)\n\t\t\t\t\tFlag = 0;\n\t\t\t}\n\t\t\tif(Flag == 1)\n\t\t\t\tFlag2 = 1;\n\t\t}\n\t\tif(Flag2 == 1)\n\t\t\tcout << \"NG\" << endl;\n\t\telse\n\t\t\tcout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint Max, n, d[251];\nbool dfs(int x){\n    if(x >= 0){\n        if(x >= n + 1)  return 1;\n        for(int i = 1; i < Max; i++){\n            x += i;\n            if(x >= n + 1)  return 1;\n            x += d[x];\n            dfs(x);\n        }\n    }\n    return 0;\n}\n\nint main(void){\n    while(1){\n        int sum = 0;\n        cin >> Max;\n        if(Max == 0)    break;\n        cin >> n;\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        sum += dfs(0);\n        if(sum > 0)   cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nint x[1000], n, maxn, k[1000], t[1000];\nqueue<int>Q;\n\nvoid bfs(int s,int p) {\n\tQ.push(s);\n\tt[s] = 1;\n\twhile (!Q.empty()) {\n\t\tfor (int i = 1; i <= p; i++) {\n\t\t\tif (t[Q.front() + i] == 0 && Q.front() + i < n + 2) {\n\t\t\t\tt[Q.front() + i] = 1;\n\t\t\t\tQ.push(x[Q.front() + i]);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(k, 0, sizeof(k));\n\t\tmemset(t, 0, sizeof(t));\n\t\tcin >> maxn;\n\t\tif (maxn == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> x[i];\n\t\t\tx[i] += i;\n\t\t\tif (x[i] < 0) { x[i] = 0; }\n\t\t\tif (x[i] > n) { x[i] = n + 1; }\n\t\t}\n\t\tbfs(0, maxn);\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tk[i] = t[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmemset(t, 0, sizeof(t));\n\t\t\tif (k[i] == 1) {\n\t\t\t\tbfs(i, maxn);\n\t\t\t\tif (t[n + 1] == 0) { cout << \"NG\" << endl; goto owata; }\n\t\t\t}\n\t\t}\n\t\tcout << \"OK\" << endl;\n\towata:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define MN 252\n\nint next(int n);\n\nvector<int> G[MN];\n\nint max_, n_, D[MN];\nbool init() {\n    cin >> max_; \n    if (max_ == 0) return false;\n    cin >> n_;\n    D[0] = D[n_+1] = 0;\n    for (int i = 1; i <= n_; i++) cin >> D[i];\n    for (int i = 0; i <= n_+1; i++) {\n        for (int j = 1; j <= max_; j++) {\n            int n = next(i+j);\n            if (i != n) {\n                G[i].push_back(n);\n            }\n        }\n        G[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());\n    }\n//    for (int i = 0; i <= n_+1; i++) {\n//        cout << i << \": \";\n//        for (int j = 0; j < G[i].size(); j++) {\n//            cout << G[i][j] << \" \";\n//        }\n//        cout << endl;\n//    }\n    return true;\n}\n\nint next(int n) {\n    n = max(0, min(n_+1, n));\n    return max(0, min(n_+1, n + D[n]));\n}\n\nbool visit[MN];\nbool dfs(int n) {\n    if (visit[n]) return false;\n    visit[n] = true;\n    for (int i = 0; i < G[n].size(); i++) {\n        if (!dfs(G[n][i])) { \n            return false;\n        }\n    }\n    visit[n] = false;\n    return true;\n}\nbool loop() {\n    memset(visit, 0, sizeof(visit));\n    return dfs(0);\n}\n\nbool reach() {\n    queue<int> Q;\n    bool v[MN]; for (int i = 0; i < MN; i++) v[i] = false;\n    Q.push(0); v[0] = true;\n    while (!Q.empty()) {\n        int n = Q.front(); Q.pop();\n        for (int i = 1; i <= max_; i++) {\n            int nxt = next(n+i);\n            if (!v[nxt]) {\n                v[nxt] = true;\n                Q.push(nxt);\n            }\n        }\n    }\n    return v[n_+1];\n}\n\nint main() {\n    while (init()) {\n        cout << (loop() && reach() ? \"OK\" : \"NG\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define GET_MACRO5(ARG__1, ARG__2, ARG__3, ARG__4, ARG__5, NAME, ...) NAME\n#define GET_MACRO9(ARG__1, ARG__2, ARG__3, ARG__4, ARG__5, ARG__6, ARG__7, ARG__8, ARG__9, NAME, ...) NAME\n\n// Input ///////////////////////////////////////////////////////////////////////\n#define R1(a)                     cin>>a\n#define R2(a,b)                   cin>>a>>b\n#define R3(a,b,c)                 cin>>a>>b>>c\n#define R4(a,b,c,d)               cin>>a>>b>>c>>d\n#define R5(a,b,c,d,e)             cin>>a>>b>>c>>d>>e\n#define R6(a,b,c,d,e,f)           cin>>a>>b>>c>>d>>e>>f\n#define R7(a,b,c,d,e,f,g)         cin>>a>>b>>c>>d>>e>>f>>g\n#define R8(a,b,c,d,e,f,g,h)       cin>>a>>b>>c>>d>>e>>f>>g>>h\n#define R9(a,b,c,d,e,f,g,h,i)     cin>>a>>b>>c>>d>>e>>f>>g>>h>>i\n#define R(...) GET_MACRO9(__VA_ARGS__, R9, R8, R7, R6, R5, R4, R3, R2, R1)(__VA_ARGS__)\n\n#define I(...) int __VA_ARGS__; R(__VA_ARGS__)\n#define L(...) ll __VA_ARGS__; R(__VA_ARGS__)\n#define S(...) char __VA_ARGS__; R(__VA_ARGS__)\n\n#define TO_ARR1(n, a)             a[n]\n#define TO_ARR2(n, a, b)          a[n], b[n]\n#define TO_ARR3(n, a, b, c)       a[n], b[n], c[n]\n#define TO_ARR4(n, a, b, c, d)    a[n], b[n], c[n], d[n]\n#define TO_ARR5(n, a, b, c, d, e) a[n], b[n], c[n], d[n], e[n]\n#define TO_ARR(n, ...) \\\n\t\tGET_MACRO5(__VA_ARGS__, TO_ARR5, TO_ARR4, TO_ARR3, TO_ARR2, TO_ARR1)(n, __VA_ARGS__)\n\n#define ARR_CONCAT(type, n, ...) type TO_ARR(n, __VA_ARGS__); REP(i,n) R(TO_ARR(i, __VA_ARGS__));\n#define IARR(n, ...) ARR_CONCAT(int, n, __VA_ARGS__)\n#define LARR(n, ...) ARR_CONCAT(long long, n, __VA_ARGS__)\n\n#define input(t,v) t v;cin>>v;\n#define input2(t,v1,v2) t v1,v2;cin>>v1>>v2;\n#define input3(t,v1,v2,v3) t v1,v2,v3;cin>>v1>>v2>>v3;\n\ntemplate<class T=int> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\n// Types ///////////////////////////////////////////////////////////////////////\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef set<int> si;\ntypedef set<ll, ll> sll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef list<int> li;\ntypedef list<ll> lll;\ntypedef map<int, int> mii;\ntypedef map<int, ll> mil;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\n\n// Loop & Iteration ////////////////////////////////////////////////////////////\n#define FOR(i, a, b) for(int i = (a), loop_end_##i=(b); i < (loop_end_##i); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define rep(v,n) for(int (v)=0;(v)<(n);(v)++)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define PB push_back\n\n// Debug ///////////////////////////////////////////////////////////////////////\n#define dump(x)  cout << #x << \" = \" << (x) << endl\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\n\ntemplate<class T=int> void dump_table(int a, int b, T **x){\n\tint w = b, h = a;\n\tREP(j, w){\n\t\tprintf(\"\\t%d\", j);\n\t}\n\tprintf(\"\\n\");\n\tREP(i, h){\n\t\tprintf(\"%d\", i);\n\t\tREP(j, w){\n\t\t\tprintf(\"\\t%d\", x[i][j]);\n\t\t}\n\t}\n}\n////////////////////////////////////////////////////////////////////////////////\n\n#define constrain(a, b, c) std::max(std::min((a), (c)), (b))\n\nint main(){\n\tint max;\n\twhile(max=read<int>()){\n\t\tI(n);\n\t\tint d[n+2];\n\t\td[0]=d[n+1]=0;\n\t\tREP(i,n) d[i+1]=read<int>();\n\t\tset<int> cango[n+2];\n\t\tREP(i, n+1){\n\t\t\tREP(j, max){\n\t\t\t\tint x = constrain(i+j+1, 0, n+1);\n\t\t\t\tx = x + d[x];\n\t\t\t\tcango[x].insert(i);\n\t\t\t}\n\t\t}\n\t\tlist<int> cand;\n\t\tcand.PB(n+1);\n\t\tset<int> finish;\n\t\tint aaa = 0;\n\t\twhile(cand.size()){\n\t\t\tli::iterator it = cand.begin();\n\t\t\tint a = *it;\n\t\t\tcand.remove(a);\n\t\t\t// cout << a << endl;\n\t\t\tif(EXIST(finish, a)) continue;\n\t\t\tEACH(it, cango[a]) cand.PB(*it);\n\t\t\tfinish.insert(a);\n\t\t\taaa++;\n\t\t\tif(a>100){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tREP(i,n+1){\n\t\t\tif(!EXIST(finish, i)){\n\t\t\t\tok = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(ok) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int M, N;\n  while(cin>>M>>N){\n    vector<int> d(N + 2); //0 - start, N + 1 - goal\n    REP(i, N) cin>>d[i + 1];\n    vector<bool> is_ok(N + 2);\n    queue<int> que;\n    is_ok[N + 1] = true;\n    que.push(N + 1);\n    while(!que.empty()){\n      int u = que.front(); que.pop();\n      REP(v, N + 2)if(v + d[v] == u || (u == N + 1 && v + d[v] >= u)){\n        for(int c = 1; c <= M && v - c >= 0; c++) if(!is_ok[v - c]){\n          que.push(v - c);\n          is_ok[v - c] = true;\n        }\n      }\n    }\n    bool ans = true;\n    vector<bool> used(N + 2);\n    que.push(0);\n    used[0] = true;\n    while(!que.empty()){\n      int u = que.front(); que.pop();\n      if(!is_ok[u]) ans = false;\n      for(int c = 1; c <= M && u + c < N + 2; c++){\n        int v = u + c;\n        int to = v + d[v];\n        if(to < 0) to = 0;\n        if(to > N + 1) to = N + 1;\n        if(used[to]) continue;\n        que.push(to);\n        used[to] = true;\n      }\n    }\n    if(ans) cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nint ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\tif (ka[y][x] == 1)continue;\n\t\t\t\tka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\tfor (int j = 0; j<300; j++)\n\t\t\t{\n\t\t\t\tka[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\t/*\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\t*/\n\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){ \n  int d[251];\n  int dp[501];\n  int m,n;\n \n  while(1){\n    cin>>m;\n    if(m==0)break;\n    /* for(int i=0;i<=501;i++){\n       dp[i]=0;\n       }\n       for(int i=0;i<=251;i++){\n       d[i]=-1;\n       }*/\n    cin>>n;\n    d[0]=0;\n    for(int i=1;i<=n;i++)cin>>d[i];\n   \n    bool flag=0;\n    // cout<<m<<endl;\n    for(int x=0;x<=n;x++){\n      for(int i=1;i<=m;i++){\n\tif(dp[i+d[i+x]]==0) dp[i+d[i+x]]=1;\n\tif(i+d[i+x]>=n)flag=1; \n      }\n      if(flag==1)break;\n    }\n    if(flag==1)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\n\n#define pb push_back\n\nint main(){\n\twhile(1){\n\t\tint max;\n\t\tint n,d[252];\n\t\tint dp[255] = {};\n\t\tscanf(\"%d\",&max); if(max == 0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i = 1 ; i <= n ; i ++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tbool t = true;\n\t\tfor(int s = 0 ; s < n+1 ; s ++){\n\t\t\tfor(int i = 0 ; i < 255 ; i ++)dp[i] = 0;\n\t\t\tdp[s] = 1;\n\t\t\tfor(int i = s ; i < n+1 ; i ++){\n\t\t\t\tif(dp[i] == 0)continue;\n\t\t\t\tfor(int j = 1 ; j <= max ; j ++){\n\t\t\t\t\tif(i+j >= n+1)dp[n+1] = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i+j+d[i+j]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt &= (dp[n+1] != 0);\n\t\t}\n\t\tif(t)puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 260\nint main() {\n\tint mx, n;\n\twhile (cin >> mx, mx) {\n\t\tcin >> n;\n\t\tvector<int> v(n + 2, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> v[i];\n\t\t}\n\t\tbool vs[MAX] = { 0 };\n\t\tvs[0] = 1;\n\t\tqueue<int> Q;\n\t\tQ.push(0);\n\n\t\twhile (!Q.empty()) {\n\t\t\tint now = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (now == n + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= mx; i++) {\n\t\t\t\tint next = min(n + 1, now + i);\n\t\t\t\tnext += v[next];\n\t\t\t\tif (next < 0) {\n\t\t\t\t\tnext = 0;\n\t\t\t\t} else if (next > n + 1) {\n\t\t\t\t\tnext = n + 1;\n\t\t\t\t}\n\t\t\t\tif (!vs[next]) {\n\t\t\t\t\tvs[next] = 1;\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flg = 1;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tif (!vs[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool ng = 1, vs2[MAX] = { 0 };\n\t\t\tqueue<int> Q2;\n\t\t\tQ2.push(i);\n\t\t\tvs2[i] = 1;\n\t\t\twhile (!Q2.empty()) {\n\t\t\t\tint now = Q2.front();\n\t\t\t\tQ2.pop();\n\t\t\t\tif (now == n + 1) {\n\t\t\t\t\tng = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= mx; i++) {\n\t\t\t\t\tint next = min(n + 1, now + i);\n\t\t\t\t\tnext += v[next];\n\t\t\t\t\tif (next < 0) {\n\t\t\t\t\t\tnext = 0;\n\t\t\t\t\t} else if (next > n + 1) {\n\t\t\t\t\t\tnext = n + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!vs2[next]) {\n\t\t\t\t\t\tvs2[next] = 1;\n\t\t\t\t\t\tQ2.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ng) {\n\t\t\t\tflg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (flg && vs[n + 1] ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 252\nusing namespace std;\n\nint m,n,d[N],ans;\nbool dp[N],o[N];\n\nbool OK(int x){\n  bool r=false;\n  x+=d[x];\n  if(x<0&&dp[0]) r=true;\n  if(x>=n+1) r=true;\n  if(dp[x]) r=true;\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m) break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    for(int i=0;i<=n;i++) dp[i]=false;\n    dp[n+1]=true;\n    o[0]=true;\n    while(1){\n      int f=0;\n      for(int i=0;i<=n;i++){\n\tif(!o[i]) continue;\n\tfor(int j=1;j<=m;j++){\n\t  int nx=i+j;\n\t  if(nx>=n+1) continue;\n\t  nx=nx+d[nx];\n\t  if(nx>=n+1||nx<0) continue;\n\t  if(!o[nx]) f=1;\n\t  o[nx]=true;\n\t}\n      }\n      if(!f) break;\n    }\n    for(int i=0;i<=n;i++)\n      if(!o[i]) dp[i]=true;\n    while(1){\n      int f=0;\n      for(int i=n;i>=0;i--){\n\tif(dp[i]||!o[i]) continue;\n\tfor(int j=1;j<=m;j++){\n\t  if(i+j>=n+1||OK(i+j)){\n\t    dp[i]=true;\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n      if(!f) break;\n    }\n    ans=0;\n    for(int i=0;i<=n;i++)\n      if(!dp[i]) ans=1;\n    if(ans) cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 260;\nbool come[MAX],goal[MAX];\nint M,n,d[MAX];\n\nvoid print(){\n\n  for(int i = 0; i <= n; i++) cout << come[i] << \" \";\n  cout << endl;\n  for(int i = 0; i <= n; i++) cout << goal[i] << \" \";\n  cout << endl;\n}\n\nvoid init(){\n  fill(come,come+MAX,false);\n  fill(goal,goal+MAX,false);\n  fill(d,d+MAX,0);\n}\n\nint move(int now, int num){\n  int nex = now+num;\n  if(nex > n) return -1;\n  nex += d[nex];\n  if(nex > n) return -1;\n  if(nex < 0) return 0;\n  return nex;\n}\n\nvoid make_come(){\n  come[0] = true;\n  priority_queue<int,vector<int>,greater<int> > Q;\n  Q.push(0);\n  while(!Q.empty()){\n    int now = Q.top();\n    Q.pop();\n    if(goal[now]) continue;\n\n    for(int i = 1; i <= M; i++){\n      int nex = move(now,i);\n      if(nex == -1) goal[nex] = true;\n      else if(come[nex] == false && nex <= n){\n        come[nex] = true;\n        Q.push(nex);\n      }\n    }\n  }\n}\n\nvoid make_goal(){\n  for(int i = n; i >= 0; i--){\n    if(!come[i] || goal[i]) continue;\n\n    for(int j = 1; j <= M; j++){\n      if(goal[move(i,j)]) goal[i] = true;\n    }\n  }\n}\n\n\nbool solve(){\n\n  make_come();\n  make_goal();\n\n  for(int i = 0; i <= n; i++)\n    if(come[i] && !goal[i]) return false; \n  return true;\n}\n\nint main(){\n\n  while(cin >> M && M){\n    init();\n    cin >> n;\n    for(int i = 1; i <= n; i++) cin >> d[i];\n    if(solve()) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    //print();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint mx, n;\n\twhile(cin >> mx, mx){\n\t\tcin >> n;\n\t\tvi d(n + 2), v(n + 2);\n\t\tbool ans = 1;\n\t\trep(i, n) cin >> d[i + 1];\n\t\tfunction<void(int, vi&)> rec = [&](int c, vi &v){\n\t\t\tv[c] = 1;\n\t\t\tif(c == n + 1) return;\n\t\t\tfor(int i = 1; i <= mx && c + i < n + 2; i++){\n\t\t\t\tint to = c + i + d[c + i];\n\t\t\t\tif(!v[to]) rec(to, v);\n\t\t\t}\n\t\t};\n\t\trec(0, v);\n\t\t\n\t\trep(i, n + 1) if(v[i]){\n\t\t\tvi vv(n + 2);\n\t\t\trec(i, vv);\n\t\t\tif(!vv[n + 1]){ ans = 0; break; }\n\t\t}\n\t\tcout << (ans ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nbool dfs(const int now,const vector<vector<int>>&edges, const int goal) {\n\tif (now == goal)return true;\n\telse {\n\t\tif (edges[now].empty())return false;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (e == now)assert(false);\n\t\t\tif (!dfs(e, edges, goal))return false;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint amax;\n\t\tcin >> amax;\n\t\tif (!amax)break;\n\t\tint N; cin >> N;\n\t\tconst int goal = N + 1;\n\t\tconst int start = 0;\n\t\tvector<int>ds(goal+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tvector<vector<int>>edges(N + 2);\n\t\tfor (int i = 0; i < N + 1; ++i) {\n\t\t\tfor (int j = 1; j <= amax; ++j) {\n\t\t\t\tint next;\n\t\t\t\tif (i + j >= goal) {\n\t\t\t\t\tnext = goal;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i + j + ds[i + j] >= goal) {\n\t\t\t\t\t\tnext = goal;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i + j + ds[i+j]<0) {\n\t\t\t\t\t\tnext = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnext = i + j + ds[i + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (find(edges[i].begin(), edges[i].end(), next) == edges[i].end()) {\n\t\t\t\t\tedges[i].push_back(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=dscc.get(edges);\n\t\tint newstart;\n\t\tint newgoal;\n\t\tfor (int i = 0; i < p.first.size();++i) {\n\t\t\tauto b = p.first[i];\n\t\t\tif (find(b.begin(), b.end(), 0)!=b.end()) {\n\t\t\t\tnewstart = i;\n\t\t\t}\n\t\t\tif (find(b.begin(), b.end(), goal) != b.end()) {\n\t\t\t\tnewgoal= i;\n\t\t\t}\n\t\t}\n\t\tauto newedges = p.second;\n\t\t\n\t\tbool ans = dfs(newstart, newedges, newgoal);\n\t\tif (ans) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define repi(i,a,b) for( int i = (a); i != (b); ++i )\n\nint ma;\nint n;\nint d[252];\nstd::vector<int> G[252], rG[252];\nbool reach[252], rev[252];\n\nvoid dfs( int v )\n{\n\trev[v] = true;\n\n\trep( i, rG[v].size() )\n\t\tif( !rev[rG[v][i]] )\n\t\t\tdfs( rG[v][i] );\n\n\treturn;\n}\n\nvoid dfs2( int v )\n{\n\treach[v] = true;\n\n\trep( i, G[v].size() )\n\t\tif( !reach[G[v][i]] )\n\t\t\tdfs2( G[v][i] );\n\n\treturn;\n}\n\nint main()\n{\n\twhile( scanf( \"%d\", &ma ), ma )\n\t{\n\t\trep( i, 252 )\n\t\t\tG[i].clear(), rG[i].clear();\n\n\t\tscanf( \"%d\", &n );\n\n\t\trepi( i, 1, n+1 )\n\t\t\tscanf( \"%d\", d+i );\n\t\td[0] = d[n+1] = 0;\n\n\t\trep( i, n+1 )\n\t\t{\n\t\t\trep( j, ma )\n\t\t\t{\n\t\t\t\tint t = std::min( i+j+1, n+1 );\n\t\t\t\tint to = std::max( 0, std::min( t+d[t], n+1 ) );\n\t\t\t\tG[i].push_back( to );\n\t\t\t\trG[to].push_back( i );\n\t\t\t}\n\t\t}\n\n\t\tmemset( reach, false, sizeof( reach ) );\n\t\tmemset( rev, false, sizeof( rev ) );\n\t\tdfs( n+1 );\n\t\tdfs2( 0 );\n\n\t\tbool fl = true;\n\t\trep( i, n+2 )\n\t\t\tif( reach[i] && !rev[i] )\n\t\t\t\tfl = false;\n\n\t\tputs( fl ? \"OK\" : \"NG\" );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint limit,V,d[300],n;\n\nint main(){\n  while( cin >> limit, limit ){\n    cin >> n;\n    V = n + 2;\n    d[0] = d[V-1] = 0;\n    rep(i,n) cin >> d[i+1];\n    vector<vector<int> > G(V);\n    rep(i,V-1) {\n      if( d[i] == 0 ) {\n        REP(j,1,limit+1) {\n          int next = i + j;\n          if( next >= V ) break;\n          if( i != next ) G[next].push_back(i);\n        }\n      } else {\n        int next = i + d[i];\n        if( next <  0 ) next = 0;\n        if( next >= V ) next = V-1;\n        if( i != next ) G[next].push_back(i);\n      }\n    }\n    vector<bool> used(V,false);\n    used[V-1] = true;\n    deque<int> deq;\n    deq.push_back(V-1);\n    while( !deq.empty() ){\n      int cur = deq.front(); deq.pop_front();\n      rep(i,G[cur].size()){\n        int next = G[cur][i];\n        if( !used[next] ) {\n          used[next] = true;\n          deq.push_back(next);\n        }\n      }\n    }\n    bool ok = true;\n    rep(i,V) if( !used[i] ) { ok = false; break; }\n    puts(ok?\"OK\":\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 260;\nbool come[MAX],goal[MAX];\nint M,n,d[MAX];\n\nvoid print(){\n\n  for(int i = 0; i <= n; i++) cout << come[i] << \" \";\n  cout << endl;\n  for(int i = 0; i <= n; i++) cout << goal[i] << \" \";\n  cout << endl;\n}\n\nvoid init(){\n  fill(come,come+MAX,false);\n  fill(goal,goal+MAX,false);\n  fill(d,d+MAX,0);\n}\n\nint move(int now, int num){\n  int nex = now+num;\n  if(nex > n) return -1;\n  nex += d[nex];\n  if(nex > n) return -1;\n  if(nex < 0) return 0;\n  return nex;\n}\n\nvoid make_come(){\n  come[0] = true;\n  priority_queue<int> Q;\n  Q.push(0);\n  while(!Q.empty()){\n    int now = Q.top();\n    Q.pop();\n    if(goal[now]) continue;\n\n    for(int i = 1; i <= M; i++){\n      int nex = move(now,i);\n      if(nex == -1) goal[nex] = true;\n      else if(come[nex] == false && nex <= n){\n        come[nex] = true;\n        Q.push(nex);\n      }\n    }\n  }\n}\n\nvoid make_goal(){\n  for(int i = n; i >= 0; i--){\n    if(!come[i] || goal[i]) continue;\n\n    for(int j = 1; j <= M; j++){\n      if(goal[move(i,j)]) goal[i] = true;\n    }\n  }\n}\n\n\nbool solve(){\n\n  make_come();\n  make_goal();\n\n  for(int i = 0; i <= n; i++)\n    if(come[i] && !goal[i]) return false; \n  return true;\n}\n\nint main(){\n\n  while(cin >> M && M){\n    init();\n    cin >> n;\n    for(int i = 1; i <= n; i++) cin >> d[i];\n    if(solve()) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    // print();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nint a[1000], used[1000], b[300][300], used2[1000];\nvector<int> G[300];\nvoid dfs(int u){\n\tif(used[u])return;\n\tused[u] = 1;\n\trep(i,G[u].size()){\n\t\tdfs(G[u][i]);\n\t}\n}\n\nvoid dfs2(int u, int R, int t){\n\tif(used2[u])return;\n\tused2[u] = 1;\n\tint i = u;\n\trrep(j,R){\n\t\tif(i+j >= t){b[i][t] = 1;dfs2(t, R, t);continue;}\n\t\tif(i+j+a[i+j] < 0){b[i][0] = 1;dfs2(0, R, t);continue;}\n\t\tif(i+j+a[i+j] >= t){b[i][t] = 1;dfs2(t, R, t);continue;}\n\t\tb[i][i+j+a[i+j]] = 1;dfs2(i+j+a[i+j], R, t);\n\t}\n}\n\nvoid init(){\n\trep(i,300)rep(j,300)b[i][j] = 0;\n\tfill(used2, used2+1000, 0);\n\tfill(used, used+1000, 0);\n\trep(i,300)G[i].clear();\n}\n\nsigned main(){\n\twhile(1){\n\t\tint R, n;\n\t\tscanf(\"%lld\", &R);\n\t\tif(R == 0)break;\n\t\tscanf(\"%lld\", &n);\n\t\trrep(i,n)scanf(\"%lld\", &a[i]);\n\t\tint s = 0, t = n+1;\n\t\tinit();\n\t\tdfs2(0, R, t);\n\t\trep(i,t+1)rep(j,t+1){if(b[j][i])G[i].pb(j);}\n\t\tdfs(t);\n\t\t\n\t\tint ans = 1;\n\t\trep(i,t+1)if(used[i] != used2[i])ans = 0;\n\t\tprintf(\"%s\\n\", ans ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nvector<int> g[300];\nbool go[300], ba[300];\n\nvoid iki(int x)\n{\n\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n + 1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nint x[1000], n, maxn, k[1000], t[1000];\nqueue<int>Q;\n\nvoid bfs(int s,int p) {\n\tQ.push(s);\n\tt[s] = 1;\n\twhile (!Q.empty()) {\n\t\tfor (int i = 1; i <= p; i++) {\n\t\t\tif (t[Q.front() + i] == 0) {\n\t\t\t\tt[Q.front() + i] = 1;\n\t\t\t\tQ.push(x[Q.front() + i]);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(k, 0, sizeof(k));\n\t\tcin >> maxn;\n\t\tif (maxn == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> x[i];\n\t\t\tx[i] += i;\n\t\t\tif (x[i] < 0) { x[i] = 0; }\n\t\t\tif (x[i] > n) { x[i] = n + 1; }\n\t\t}\n\t\tbfs(0, maxn);\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tk[i] = t[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmemset(t, 0, sizeof(t));\n\t\t\tif (k[i] == 1) {\n\t\t\t\tbfs(i, maxn);\n\t\t\t\tif (t[n + 1] == 0) { cout << \"NG\" << endl; goto owata; }\n\t\t\t}\n\t\t}\n\t\tcout << \"OK\" << endl;\n\towata:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\twhile(true){\n\t\tint ma,n,d[255];\n\t\tscanf(\"%d\",&ma);\n\t\tif(ma==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tbool F=true;\n\t\tfor(int i=0;i<=n-ma;i++){\n\t\t\tbool f1=false;\n\t\t\tfor(int j=1;j<=ma;j++){\n\t\t\t\tif(i+j+d[i+j]>i)f1=true;\n\t\t\t}\n\t\t\tif(!f1)F=false;\n\t\t}\n\t\tif(F)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n,dmax;\nint m[300];\n\nbool visited[300];\nbool isVisit[300];\nbool isGoal;\nvoid dfs(int p){\n  if(visited[p])return ;\n  visited[p] = true;\n  isVisit[p] = true;\n  if(p == n+1){\n    isGoal = true;\n    return;\n  }\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    if(np > n + 1)np = n + 1;\n    if(np < 0)np = 0;\n\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;\n  \n    dfs(np);\n  }\n}\nvoid solve(){\n  fill(isVisit, isVisit+300, false);\n  isVisit[0] = true;\n  for(int i = 0 ; i <= n; i++){\n    if(!isVisit[i])continue;\n    isGoal = false;\n    fill(visited, visited+300, false);\n    dfs(i);\n    if(!isGoal){\n      break;\n    }\n  }\n  cout << (isGoal?\"OK\":\"NG\") << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    fill(m, m+300, 0);\n    for(int i = 0 ; i < n ;i++){\n      cin >> m[i+1];\n    }\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool used[300];\nint N,M;\nint d[300];\n\nint next(int t,int i){\n    return min(N+1,max(0,min(N+1,t+i)+d[t]));\n}\n\nvoid latte(int t=0){\n    if(used[t])return;\n    used[t]=true;\n\n    for(int i=1;i<=M;i++){\n        latte(next(t,i));\n    }\n}\n\nbool used2[300];\nbool dfs(int t){\n    if(used2[t])return false;\n    used2[t]=true;\n\n    if(t==N+1)return true;\n\n    bool ret=false;\n\n    for(int i=1;i<=M;i++)ret|=dfs(next(t,i));\n\n    return ret;\n}\n\nint main(){\n    while(cin>>M,M){\n        cin>>N;\n        for(int i=0;i<N;i++)cin>>d[i+1];\n        d[0]=d[N+1]=0;\n        fill_n(used,300,false);\n        latte();\n\n\n        bool flag=true;\n        for(int i=0;i<=N;i++)if(used[i]){\n            for(int j=1;j<=M;j++){\n                fill_n(used2,300,false);\n                if(!dfs(next(i,j)))flag=false;\n\n            }\n        }\n\n        cout<<(flag?\"OK\":\"NG\")<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nint x[1000], n, maxn, k[1000], t[1000];\nqueue<int>Q;\n\nvoid bfs(int s,int p) {\n\tQ.push(s);\n\tt[s] = 1;\n\twhile (!Q.empty()) {\n\t\tfor (int i = 1; i <= p; i++) {\n\t\t\tif (t[Q.front() + i] == 0 && Q.front() + i < n + 2) {\n\t\t\t\tt[Q.front() + i] = 1;\n\t\t\t\tQ.push(x[Q.front() + i]);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(k, 0, sizeof(k));\n\t\tcin >> maxn;\n\t\tif (maxn == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> x[i];\n\t\t\tx[i] += i;\n\t\t\tif (x[i] < 0) { x[i] = 0; }\n\t\t\tif (x[i] > n) { x[i] = n + 1; }\n\t\t}\n\t\tbfs(0, maxn);\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tk[i] = t[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmemset(t, 0, sizeof(t));\n\t\t\tif (k[i] == 1) {\n\t\t\t\tbfs(i, maxn);\n\t\t\t\tif (t[n + 1] == 0) { cout << \"NG\" << endl; goto owata; }\n\t\t\t}\n\t\t}\n\t\tcout << \"OK\" << endl;\n\towata:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define all(s) (s).begin(), (s).end()\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint m, n;\nvi ok;\nvi d;\n\nbool isok(int num){\n\tif(ok[num] != -1) return ok[num];\n\tbool res = false;\n\tfor(int i = m; i >= 1; i--){\n\t\tint next = num+i;\n\t\tif(next < 0) next = 0;\n\t\tif(next > n) return ok[num] = true;\n\t\tnext += d[next];\n\t\tif(next < 0) next = 0;\n\t\tif(next == num) continue;\n\t\tif(next > n) return ok[num] = true;\n\t\tres |= isok(next);\n\t}\n\n\treturn ok[num] = res;\n}\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\twhile(cin >> m, m){\n\t\tcin >> n;\n\t\td.resize(n+1);\n\t\tfill(all(d), 0);\n\t\trep(i, n) cin >> d[i+1];\n\t\tok.resize(n+1);\n\t\tfill(all(ok), -1);\n\n\t\tbool ans = true;\n\t\trep(i, n) ans &= isok(i);\n\t\t\n\t\tcout << (ans?\"OK\":\"NG\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool used[N],ans;\n\nvoid dfs(int x){\n  x+=d[x];\n  if(x<0)x=0;\n  if(n+1<x)x=n+1;\n  if(used[x])return;\n  used[x]=true;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    dfs(nx);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    memset(d,0,sizeof(d));\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(used,0,sizeof(used));\n    dfs(0);\n    ans=true;\n    for(int i=0;i<=n;i++){\n      if(!used[i])continue;\n      int f=0;\n      for(int j=1;j<=m;j++){\n\tint ni=min(n+1,i+j);\n\tni+=d[ni];\n\tif(ni<0)ni=0;\n\tif(n+1<ni)ni=n+1;\n\tif(ni+d[ni]!=i)f=1;\n      }\n      if(!f)ans=false;\n    }\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, n) for(int i = (a); i < (n); i++)\n#define MP make_pair\n#define all(s) (s).begin(), (s).end()\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint m, n;\nvi ok;\nint dist[300][300];\n\nint main(){\n\tfreopen(\"test.txt\", \"r\", stdin);\n\twhile(cin >> m, m){\n\t\tcin >> n;\n\t\tvi d(n+2, 0);\n\t\tFOR(i, 1, n+1) cin >> d[i];\n\t\trep(i, n+2){\n\t\t\td[i] += i;\n\t\t\tif(d[i] < 0) d[i] = 0;\n\t\t\tif(d[i] > n) d[i] = n+1;\n\t\t}\n\n\t\tconst int INF = 10000;\n\t\trep(i, n+2)rep(j, n+2) dist[i][j] = INF;\n\t\tdist[0][0] = 0;\n\n\t\trep(i, n+2){\n\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\tint dest = i+j;\n\t\t\t\tif(dest > n) dest = n+1;\n\t\t\t\tdist[i][d[dest]] = min(dist[i][d[dest]], 1);\n\t\t\t}\n\t\t}\n\t\trep(i, n+2)rep(j, n+2)rep(k, n+2) dist[j][k] = min(dist[j][k], dist[j][i]+dist[i][k]);\n\n\t\tbool ok = true;\n\t\trep(i, n+2){\n\t\t\tok &= (dist[0][i] == INF || dist[i][n+1] != INF);\n\t\t}\n\t\tcout << (ok?\"OK\":\"NG\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nint main(){\n      int m,n;\n      while(scanf(\"%d\",&m)&&m){\n            scanf(\"%d\",&n);\n            int d[500];\n            bool f[500][500];\n            memset(f,false,sizeof(f));\n            REP(i,n){\n                  int a;\n                  scanf(\"%d\",&a);\n                  int now=i+a+1;\n                  now=max(0,min(n+1,now));\n                  d[i+1]=now;\n            }\n            d[n+1]=n+1;\n            REP(i,n+1){\n                  REP(j,m+1){\n                        int now=i+j;\n                        now=max(0,min(n+1,now));\n                        f[i][d[now]]=true;\n                  }\n            }\n            REP(k,n+2)\n                  REP(i,n+2)\n                        REP(j,n+2)\n                              if(f[i][k]&&f[k][j])f[i][j]=true;\n            bool ans=true;\n            REP(i,n+1)if(f[0][i]&&!f[i][n+1]){\n                  ans=false;\n            }\n            if(ans)cout<<\"OK\"<<endl;\n            else cout<<\"NG\"<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 252\nusing namespace std;\n\nint m,n,d[N],ans;\nbool dp[N],o[N];\n\nbool OK(int x){\n  bool r=false;\n  x+=d[x];\n  o[x]=true;\n  if(x<0&&dp[0]) r=true;\n  if(x>=n+1) r=true;\n  if(dp[x]) r=true;\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m) break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    for(int i=0;i<=n;i++) dp[i]=false,o[i]=false;\n    dp[n+1]=true;\n    while(1){\n      int f=0;\n      for(int i=n;i>=0;i--){\n\tif(dp[i]) continue;\n\tfor(int j=1;j<=m;j++){\n\t  if(i+j>=n+1||OK(i+j)){\n\t    dp[i]=true;\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n      if(!f) break;\n    }\n    for(int i=0;i<=n;i++)\n      if(!o[i]&&!dp[i]) dp[i]=true;\n    ans=0;\n    for(int i=0;i<=n;i++)\n      if(!dp[i]) ans=1;\n    if(ans) cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,dmax;\nint m[300];\nbool visited[300], isVisit[300], isGoal;\nvoid dfs(int p){\n  if(visited[p])return ;\n  visited[p] = true;\n  isVisit[p] = true;\n  if(p == n+1){\n    isGoal = true;\n    return;\n  }\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;  \n    dfs(np);\n  }\n}\nvoid solve(){\n  fill(isVisit, isVisit+(n+2), false);\n  isVisit[0] = true;\n  fill(visited, visited+(n+2), false);\n  for(int i = 0 ; i <= n; i++){\n    if(!isVisit[i])continue;\n    isGoal = false;\n    dfs(i);\n    if(!isGoal)break;    \n  }\n  cout << (isGoal?\"OK\":\"NG\") << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    fill(m, m+(n+2), 0);\n    for(int i = 0 ; i < n ;i++){\n      cin >> m[i+1];\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint main(){\n    int ma;\n    while(scanf(\"%d\",&ma),ma){\n        int n;\n        int stage[256]={0};\n        int D[256][256]={{0}};\n        scanf(\"%d\",&n);\n        reps(i,1,n+1){\n            scanf(\"%d\",&stage[i]);\n        }\n        rep(i,n+1){\n            reps(j,1,ma+1){\n                int tmp = i+j;\n                if(stage[tmp]==0)D[i][tmp] = 1;\n                else if(stage[tmp]>0){\n                    if(tmp+stage[tmp]>n+1)tmp = n+1;\n                    else tmp += stage[tmp];\n                    D[i][tmp] = 1;\n                }\n                else{\n                    if(tmp+stage[tmp]<0)tmp = 0;\n                    else tmp += stage[tmp];\n                    D[i][tmp] =  1;\n                }\n            }\n        }\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    if(D[i][k] && D[k][j]){\n                        D[i][j] = 1;\n                    }\n                }\n            }\n        }\n        /*\n        puts(\"--------------------------\");\n        rep(i,n+2){\n            rep(j,n+2){\n                printf(\"%d \",D[i][j]);\n            }\n            puts(\"\");\n        }\n        puts(\"--------------------------\");\n        */\n        bool flg = true;\n        rep(i,n+1){\n            if(D[0][i] && !D[i][n+1]){\n                flg = false;\n                break;\n            }\n        }\n        flg ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool used[2][N],ans;\n \nvoid dfs(int x,int idx){\n  if(used[idx][x])return;\n  used[idx][x]=true;\n  x+=d[x];\n  if(x<0)x=0;\n  if(n+1<x)x=n+1;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    dfs(nx,idx);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(used,0,sizeof(used));\n    ans=true;\n    dfs(0,0);\n    if(!used[0][n+1])ans=false;\n    for(int i=1;i<n+1;i++){\n      if(!used[0][i])continue;\n      for(int j=0;j<=n+1;j++)\n\tused[1][j]=false;\n      dfs(i,1);\n      if(!used[1][n+1])ans=false;\n    }\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={},o[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    for(i=1;i<=n;i++){\n      p=i;\n      bool vi[300]={};\n      bool f=false;\n      while(d[p]!=0){\n\tp+=d[p];\n\tif(vi[p]){\n\t  f=true;\n\t  break;\n\t}\n\tif(p<0) p=0;\n\tif(p>n+1) p=n+1;\n\tvi[p]=true;\n      }\n      if(f) o[i]=-1;\n      else o[i]=p;\n    }\n    o[n+1]=n+1;\n    fill(used,used+300,false);\n    \n    queue<int> q;\n    q.push(0);\n    while(!q.empty()){\n      p=q.front();q.pop();\n      //cout << p << endl;\n      p=o[p];\n      if(p==-1) continue;\n      if(used[p]) continue;\n      used[p]=true;\n      for(i=1;i<=m;i++){\n\tif(p+i>n+1){\n\t  used[n+1]=true;\n\t  break;\n\t}else q.push(p+i);\n      }\n    }\n    if(used[n+1]) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint G[252][252], M, N, masu[251];\n\nint main() {\n\twhile(cin >> M && M){\n\t\tcin >> N;\n\t\tfor(int i = 1; i <= N; ++i)\n\t\t\tcin >> masu[i];\n\t\t\t\n\t\tfor(int i = 0; i < 252; ++i)\n\t\t\tfor(int j = 0; j < 252; ++j)\n\t\t\t\tG[i][j] = 0;\n\t\t\n\t\tfor(int i = 0; i < N + 1; ++i){\n\t\t\tfor(int j = 1; j <= M; ++j){\n\t\t\t\tif(i + j >= N + 1){\n\t\t\t\t\tG[i][N + 1] = 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint v = i + j + masu[i + j];\n\t\t\t\t\tif(v < 0)\n\t\t\t\t\t\tv = 0;\n\t\t\t\t\telse if(v > N + 1)\n\t\t\t\t\t\tv = N + 1;\n\t\t\t\t\tG[i][v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N + 2; ++k){\n\t\t\tfor(int i = 0; i < N + 2; ++i){\n\t\t\t\tfor(int j = 0; j < N + 2; ++j){\n\t\t\t\t\tif(G[i][k] && G[k][j])\n\t\t\t\t\t\tG[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool ok = G[0][N + 1];\n\t\tfor(int i = 1; i < N + 1; ++i){\n\t\t\tif(G[0][i] && G[i][N + 1] == 0){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"OK\" : \"NG\") << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nvector<int> v[252], rev[252];\nvector<bool> goal(252), way(252);\n\nvoid abletogoal(int i){\n    goal[i] = true;\n    for(int next : rev[i]){\n        if(!goal[next]) abletogoal(next);\n    }\n}\n\nbool f(int i){\n    bool ret = true;\n    way[i] = true;\n    ret &= goal[i];\n    for(int next : v[i]){\n        if(way[next])   continue;\n        ret &= f(next);\n    }\n    return ret;\n}\n\nint main(){\n    int m;\n    while(cin >> m, m){\n        for(int i = 0; i < 252; i++){\n            v[i].clear(), rev[i].clear();\n            goal[i] = way[i] = false;\n        }\n\n        int n;\n        cin >> n;\n        vector<int> d(n+2);\n        for(int i = 1; i <= n; i++) cin >> d[i];\n        for(int i = 0; i <= n; i++){\n            for(int j = 1; j <= m; j++){\n                int ni = i+j;\n                if(ni > n+1)    ni = n+1;\n                else            ni += d[ni];\n                if(ni > n+1)    ni = n+1;\n                if(ni < 0)  ni = 0;\n                v[i].push_back(ni);\n                rev[ni].push_back(i);\n            }\n        }\n        abletogoal(n+1);\n        cout << (f(0) ? \"OK\" : \"NG\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint mx;\nint n;\nint d[251];\nbool flg[251];\n\n\nbool Solve(int x){\n\n  if(x>=n+1)return true;\n  if(flg[x]==true)return false;\n  flg[x]=true;\n    \n  if(d[x]!=0){\n  \n    if(x+d[x]>=n+1)return true;\n    if(Solve(x+d[x])==true)return true;\n  }\n  else{\n    \n    if(x+mx>=n+1)return true;  \n   \n    for(int i=1; i<=mx; i++){\n     if(Solve(x+i)==true)return true;\n    }   \n    \n  }\n  \n  flg[x]=false;\n  \n  return false;\n}\n\n\nint main(){\n  \n  while(cin>>mx , mx){\n    cin >> n;\n    d[0]=0;\n    for(int i=1; i<=n; i++){\n      cin>>d[i];\n      flg[i]=false;\n    }\n\n    if(Solve(0)==true)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool used[2][N];\n\nvoid bfs(int s,int idx){\n  queue<int> q;\n  q.push(s);\n  while(!q.empty()){\n    int x=q.front(); q.pop();\n    x+=d[x];\n    if(x<0)x=0;\n    if(n+1<x)x=n+1;\n    if(used[idx][x])continue;\n    used[idx][x]=true;\n    for(int i=1;i<=m;i++){\n      int nx=x+i;\n      if(n+1<nx)nx=n+1;\n      q.push(nx);\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(used,0,sizeof(used));\n    bfs(0,0);\n    bool ans=true;\n    for(int i=0;i<=n;i++){\n      if(!used[0][i])continue;\n      for(int j=0;j<=n+1;j++)used[1][j]=false;\n      bfs(i,1);\n      if(!used[1][n+1])ans=false;\n    }\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint m,n;\nint mass[260]={};\nbool DP[260]={};\nint seach(vector<int> walked,int now){\n\tnow=max(0,min(now,n+1));\n\tif(DP[now]!=0)\n\treturn DP[now];\n\tif(now>n){\n\t\tDP[now]=1;\n\t\treturn 1;\n\t}\n\tfor(int i=0;i<walked.size();i++){\n\t\tif(now==walked[i]){\n\t\tDP[now]=-9999;\n\t\treturn -i-1;\n\t\t}\n\t}\n\twalked.push_back(now);\n\tint maxer=-9999;\n\tfor(int i=1;i<=m;i++){\n\t\tint first=max(n+1,now+i);\n\t\tint second=first+mass[first];\n\t\tmaxer=max(maxer,seach(walked,second));\n\t}\n\tif(walked.size()==-maxer){\n\tDP[now]=2;\t\n\tmaxer=2;\n\t}\n\tif(DP[now]>0)\n\tDP[now]=maxer;\n\telse if(DP[now]<0)\n\tDP[now]=-9999;\n\treturn maxer;\n\t\n}\n\nint main() {\n\t// your code goes here\n\tvector<int> a;\n\twhile(true){\n\t\tcin >> m;\n\tif(m==0)\n\t\tbreak;\n\t\t\n\tcin >> n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> mass[i];\n\t}\n\tfor(int i=0;i<252;i++)\n\tDP[i]=0;\n\tif(seach(a,0)==1)\n\t\tcout << \"OK\" << endl;\n\telse\n\t\tcout << \"NG\" << endl;\n\t\n\t}\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nint d[256][256];\nint op[256];\n\nint main(){\n  while(scanf(\"%d\", &M) && M){\n    scanf(\"%d\", &N);\n    memset(d, 0, sizeof(d));\n    memset(op, 0, sizeof(op));\n    REP(i, 1, N+1) scanf(\"%d\", op+i);\n\n    rep(i, N+1) REP(j, 1, M+1){\n      int next = i + j;\n      if(op[next] == 0){\n\td[i][next] = 1;\n      }else{\n\td[i][max(0, min(N+1, next+op[next]))] = 1;\n      }\n    }\n\n    rep(k, N+2) rep(i, N+2) rep(j, N+2){\n      if(d[i][k] && d[k][j]) d[i][j] = 1;\n    }\n\n    /*    rep(i, N+2){\n      rep(j, N+2) printf(\"%d \", d[i][j]); puts(\"\");\n      }*/\n\n    int p;\n    for(p = 0; p < N+1; p++) if(d[p][N+1] == 0){ puts(\"NG\"); break;}\n    if(p == N+1) puts(\"OK\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define repp(i,k,n) for(int i=k;i<(int)n;i++)\n#define rei(n) for(int i=0;i<(int)n;i++)\n#define rel(n) for(int l=0;l<(int)n;l++)\n#define al(s) s.begin(),s.end()\n#define INT_MAX 2147483647\n#define debug(x) cout<<#x<<\": \"<<x<<endl;\n#define PI 2*acos(0,0)\n#define pb push_back\n#define inin(x) int x; cin>>x;\nstruct Calendar\n{\n\tlong long year;\n\tlong long month;\n\tlong long day;\n\tlong long dat[2][13];\n\tCalendar(long long y, long long m, long long d)\n\t{\n\t\tyear = y;\n\t\tmonth = m;\n\t\tday = d;\n\t\tdat[0][0] = dat[1][0] = 0;\n\t\tdat[0][1] = dat[1][1] = 31;\n\t\tdat[0][2] = dat[1][2] = 28;\n\t\tdat[0][3] = dat[1][3] = 31;\n\t\tdat[0][4] = dat[1][4] = 30;\n\t\tdat[0][5] = dat[1][5] = 31;\n\t\tdat[0][6] = dat[1][6] = 30;\n\t\tdat[0][7] = dat[1][7] = 31;\n\t\tdat[0][8] = dat[1][8] = 31;\n\t\tdat[0][9] = dat[1][9] = 30;\n\t\tdat[0][10] = dat[1][10] = 31;\n\t\tdat[0][11] = dat[1][11] = 30;\n\t\tdat[0][12] = dat[1][12] = 31;\n\t\tdat[1][2] = 29;\n\t}\n\tint uruu()\n\t{\n\t\tif (year % 4 == 0)\n\t\t{\n\t\t\tif (year % 400 != 0 && year % 100 == 0)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint uruu(long long y)\n\t{\n\t\tif (y % 4 == 0)\n\t\t{\n\t\t\tif (y % 400 != 0 && y % 100 == 0)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tlong long pday(long long d)\n\t{\n\t\tday += d;\n\t\tfor (;; month++)\n\t\t{\n\t\t\tif (month >= 13)\n\t\t\t{\n\t\t\t\tyear++;\n\t\t\t\tmonth = 1;\n\t\t\t}\n\n\t\t\tif (dat[uruu()][month] < day)\n\t\t\t{\n\t\t\t\tday -= dat[uruu()][month];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpmonth(0);\n\t\treturn d;\n\t}\n\tlong long pmonth(long long m)\n\t{\n\t\tmonth += m;\n\t\tfor (;; year++)\n\t\t{\n\t\t\tif (month > 12)\n\t\t\t{\n\t\t\t\tmonth -= 12;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tlong long pyear(long long y)\n\t{\n\t\tyear += y;\n\t\treturn y;\n\t}\n\tlong long dif(Calendar c)\n\t{\n\t\tlong long ans = 0;\n\t\tCalendar a(year, month, day);\n\t\tans -= a.day;\n\t\tans += c.day;\n\t\ta.day = 0;\n\t\tc.day = 0;\n\t\tfor (; a.month >= 1; a.month--)\n\t\t{\n\t\t\tans -= dat[a.uruu()][a.month-1];\n\t\t}\n\t\tfor (; c.month >= 1; c.month--)\n\t\t{\n\t\t\tans += dat[c.uruu()][c.month-1];\n\t\t}\n\t\tfor (; a.year != c.year; a.year++)\n\t\t{\n\t\t\tans += 365;\n\t\t\tif (a.uruu())ans++;\n\t\t}\n\t\treturn ans;\n\t}\n\n\n};\n\n\n\nint main()\n{\n\tint m;\n\twhile (cin >> m&&m)\n\t{\n\t\tbool ans = true;\n\t\tinin(n);\n\t\tint sugoroku[256] = {};\n\t\tint cost[256][256];\n\t\trei(256)rel(256)cost[i][l] = INT_MAX;\n\t\trei(n)\n\t\t{\n\t\t\tcin >> sugoroku[i+1];\n\t\t}\n\n\t\tfor (int i = 0;i<=n+1; i++)\n\t\t{\n\t\t\tcost[i][i] = 1;\n\t\t\tfor (int l = 1; l <= m; l++)\n\t\t\t{\n\t\t\t\tcost[max(0, min(n + 1, i + l + sugoroku[min(n+1,i + l)]))][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k <= n + 1; k++)\n\t\t{\n\t\t\tfor (int i = 0; i <= n + 1; i++) \n\t\t\t{\n\t\t\t\tfor (int l = 0; l <= n + 1; l++)\n\t\t\t\t{\n\t\t\t\t\tif (cost[i][k] + cost[k][l] == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcost[i][l] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (cost[i][0] == 1 && cost[n + 1][i] != 1)\n\t\t\t{\n\t\t\t\tans = false;\n\t\t\t}\n\t\t}\n\t\tcout << ((ans) ? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint main(){\n    int ma;\n    while(scanf(\"%d\",&ma),ma){\n        int n;\n        int stage[256];\n        int D[256][256]={{0}};\n        scanf(\"%d\",&n);\n        rep(i,n+2){\n            rep(j,n+2){\n                if(i == j)D[i][j] = 0;\n                else D[i][j] = INF;\n            }\n        }\n        reps(i,1,n+1){\n            scanf(\"%d\",&stage[i]);\n        }\n        rep(i,n+1){\n            if(stage[i]){\n                int tmp = i+stage[i];\n                if(tmp < 0)tmp = 0;\n                if(tmp > n+1)tmp = n+1;\n                D[i][tmp] = 1;\n            }\n            else{\n                rep(j,ma+1){\n                    int tmp = i+j;\n                    if(tmp > n+1)tmp = n+1;\n                    D[i][tmp] = 1;\n                }\n            }\n        }\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    if(D[i][k]==1 && D[k][j] == 1){\n                        D[i][j] = 1;\n                    }\n                }\n            }\n        }\n        /*puts(\"--------------------------\");\n        rep(i,n+2){\n            rep(j,n+2){\n                if(D[i][j] >= INF)printf(\"M \");\n                else printf(\"%d \",D[i][j]);\n            }\n            puts(\"\");\n        }\n        puts(\"--------------------------\");*/\n        bool flg = true;\n        rep(i,n+2){\n            flg &=(D[0][i]>=INF || D[i][n+1]<INF);\n        }\n        flg ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 999999\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<k;i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n    int ma;\n    while(scanf(\"%d\",&ma),ma){\n        int n;\n        scanf(\"%d\",&n);\n        int stage[256]={0};\n        int D[300][300]={{0}};\n        reps(i,1,n+1)scanf(\"%d\",&stage[i]);\n        rep(i,n+1){\n            reps(j,1,ma+1){\n                if(stage[i+j]==0)D[i][i+j]=1;\n                else if(stage[i+j]>=1)D[i][min(i+j+stage[i+j],n+1)];\n                else if(stage[i+j]<=-1)D[i][max(0,i+j+stage[i+j])]=1;\n            }\n        }\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    if(D[i][k] && D[k][j]) D[i][j] = 1;\n                }\n            }\n        }\n        bool f = true;\n\n        rep(i,n+1)if(D[0][i] && D[i][n+1])f =false;\n        printf(\"%s\\n\",(!f) ? \"OK\" : \"NG\");\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<bitset>\n#include<vector>\n#define M 256\nusing namespace std;\n\nstruct P\n{\n  bitset<M> visited;\n  int now;\n  P(bitset<M> visited,int now):visited(visited),now(now){}\n};\n\nint main()\n{\n  int mex;\n  while(cin >> mex,mex)\n    {\n      int n;\n      cin >> n;\n      vector<int> G(n);\n      for(int i=0;i<n;i++)\n\tcin >> G[i];\n\n      deque<P> deq;\n      bitset<M> fir;\n      fir[0] = true;\n      deq.push_back(P(fir,0));\n      \n      while(!deq.empty())\n\t{\n\t  P p = deq.front(); deq.pop_front();\n\t  if(p.now >= n+1)\n\t    continue;\n\t    \n\t  for(int i=1;i<=mex;i++)\n\t    {\n\t      int next = p.now + i;\n\t      next += G[next];\n\t      if(next < 0)next = 0;\n\t      else if(next >= n+1)next = n+1;\n\t      if(p.visited[next])\n\t\t{\n\t\t  cout << \"NG\" << endl;\n\t\t  goto F;\n\t\t}\n\t      bitset<M> visited = p.visited;\n\t      visited[next] = 1;\n\t      deq.push_back(P(visited,next));\n\t    }\n\t}\n      cout << \"OK\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m;\nint d[555];\nbool u[555];\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++)cin>>d[i];\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tbool ok=0;\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tok|=i+j+d[i+j]>i;\n\t\t\t}\n\t\t\tu[i]=ok;\n\t\t}\n\t\tbool f=1;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(!(i>=n||u[i-1]))f=0;\n\t\t}\n\t\tcout<<(f?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[N],used[N],ans;\n\nbool dfs(int x){\n  if(used[x])return memo[x];\n  used[x]=true;\n  if(d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    x=nx;\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[x]|=dfs(nx);\n  }\n  if(!memo[x])ans=false;\n  return memo[x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    memset(d,0,sizeof(d));\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[n+1]=true;\n    ans=true;\n    dfs(0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\n\nint main(){\n\tint m,n,d[511];\n\tbool b[255],e[255];\n\tqueue<int> q;\n\tfor(;;){\n\t\tscanf(\"%d\",&m);\n\t\tif(!m)break;\n\t\tscanf(\"%d\",&n);\n\t\trep(i,511)d[i]=0;\n\t\trep(i,255)b[i]=e[i]=0;\n\t\trep(i,n)scanf(\"%d\",d+i+1);\n\t\tint f=1;\n\t\twhile(f){\n\t\t\tf=0;\n\t\t\tfor(int i=n;i>=0;i--){\n\t\t\t\treps(j,1,m){\n\t\t\t\t\tint c=d[i+j]+i+j;\n\t\t\t\t\tif(!b[i])if(c>n || (in(c,0,n) && b[c])){\n\t\t\t\t\t\tb[i]=1;\n\t\t\t\t\t\tf=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf=b[0];\n\t\te[0]=1;\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint p=q.front();\n\t\t\tq.pop();\n\t\t\treps(i,1,m){\n\t\t\t\tint c=d[p+i]+i+p;\n\t\t\t\tif(in(c,0,n) && !e[c]){\n\t\t\t\t\tif(b[c]){\n\t\t\t\t\t\te[c]=1;\n\t\t\t\t\t\tq.push(c);\n\t\t\t\t\t}\n\t\t\t\t\telse f=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f)while(!q.empty())q.pop();\n\t\t}\n\t\tputs(f?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint main(){for(int m,n,i,j,k,a;a=1,scanf(\"%d\",&m),m;puts(a?\"OK\":\"NG\")){int d[300]={0},g[300][300]={0};scanf(\"%d\",&n);for(i=1;i<=n;)scanf(\"%d\",d+i++);for(i=0;i<=n;i++)for(j=1;j<=m;j++)k=i+j+d[i+j],(k=k<0?0:n+1<k?n+1:k),g[i][k]=1;for(k=0;k<n+2;k++)for(i=0;i<n+2;i++)for(j=0;j<n+2;j++)if(g[i][k]&&g[k][j])g[i][j]=1;for(i=0;i<=n;i++)if(g[0][i]&&!g[i][n+1])a=0;}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint mx, n;\n\nint main(){\t\n\twhile( cin >> mx, mx ){\n\t\tint d[300] = {0}, g[300][300] = {0};\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; i++) cin >> d[i];\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tfor(int j = 1; j <= mx; j++){\n\t\t\t\tint v = i + j + d[i + j];\n\t\t\t\tif( v < 0 ) v = 0;\n\t\t\t\tif( n+1 < v ) v = n+1;\n\t\t\t\tg[i][v] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n + 2; k++){\n\t\t\tfor(int i = 0; i < n + 2; i++){\n\t\t\t\tfor(int j = 0; j < n + 2; j++){\n\t\t\t\t\tif( g[i][k] && g[k][j] ) g[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tfor(int i = 0; i <= n ; i++){\n\t\t\tif( g[0][i] && !g[i][n+1] ){\n\t\t\t\tans = false;\n\t\t\t}\n\t\t}\n\t\tcout << (ans?\"OK\":\"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nint main(){\n      int m,n;\n      while(scanf(\"%d\",&m)&&m){\n            scanf(\"%d\",&n);\n            int d[252];\n            bool G[252][252];\n            REP(i,n){\n                  cin>>d[i+1];\n                  d[i+1]=max(0,min(n+1,d[i+1]+i+1));\n            }\n            memset(G,false,sizeof(G));\n            REP(i,n+1){\n                  REP(j,m){\n                        int now=min(n+1,i+j+1);\n                        if(now>=n+1)G[i][n+1]=true;\n                        else G[i][d[now]]=true;\n                  }\n            }\n            //REP(i,n+2)REP(j,n+2)printf(\"%d%c\",G[i][j]?1:0,j==n+1?'\\n':' ');\n            REP(k,n+2)REP(i,n+2)REP(j,n+2)if(G[i][k]&&G[k][j])G[i][j]=true;\n            bool ans=true;\n            REP(i,n+1){\n                  if(G[0][i]&&!G[i][n+1])ans=false;\n            }\n            if(ans)cout<<\"OK\"<<endl;\n            else cout<<\"NG\"<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 260;\nconst int INF = 1e9;\n\nint main(){\n  int M, N, D[MAX_N], G[MAX_N][MAX_N];\n  while(cin >>M && M){\n    memset(D, 0, sizeof(D));\n    memset(G, 0, sizeof(G));\n    cin >>N;\n    FOR(i, 1, N + 1) cin >>D[i];\n    REP(i, N + 2){\n      FOR(j, i + 1, min(N + 2, i + M + 1)){\n        int next = min(N + 1, max(0, j + D[j]));\n        G[i][next] = 1;\n      }\n    }\n    REP(k, N + 2) REP(i, N + 2) REP(j, N + 2) if(G[i][k] && G[k][j]) G[i][j] = true;\n    bool f = true;\n    REP(i, N + 1) if(G[0][i] && !G[i][N + 1]) f = false;\n    cout <<(f ? \"OK\" : \"NG\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 650\n\nvoid calc(int m){\n  int n;\n  int d[SIZE];\n  \n  scanf(\"%d\",&n);\n\n  d[0] = 0;\n  d[n+1] = 0;\n  for(int i=1;i<=n;i++){\n    scanf(\"%d\",d+i);\n  }\n\n  queue<int> q;\n  q.push(0);\n  bool can_visit[SIZE] = {};\n  can_visit[0] = true;\n\n  \n  while(q.size()){\n    bool flag = false;\n    int st = q.front();\n    int visited[SIZE] = {};\n    q.pop();\n    \n    queue<int> q2;\n    q2.push(st);\n\n    while(q2.size()){\n      int now = q2.front();\n      q2.pop();\n\n      if(visited[now]) continue;\n\n      if(now == n+1){\n        flag = true;\n        break;\n      }\n\n      visited[now] = true;\n\n      if(can_visit[now] == false){\n        can_visit[now] = true;\n        q.push(now);\n      }\n\n      if(d[now]!=0){\n        if(d[now] < 0){\n          q2.push(max(0,now + d[now]));\n        }else{\n          q2.push(min(n+1,now + d[now]));\n        }\n      }else{\n\n        for(int i=1;i<=m;i++){\n          q2.push(min(n+1,now + i));\n        }\n        \n      }\n    }\n\n    if(flag == false){\n      puts(\"NG\");\n      return;\n    }\n  }\n\n  puts(\"OK\");\n}\n  \n\nint main(){\n  int m;\n\n  while(scanf(\"%d\",&m)!=EOF){\n    if(m==0) break;\n    calc(m);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, n) for(int i = (a); i < (n); i++)\n#define MP make_pair\n#define all(s) (s).begin(), (s).end()\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint m, n;\nvi ok;\nint dist[300][300];\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\twhile(cin >> m, m){\n\t\tcin >> n;\n\t\tvi d(n+2, 0);\n\t\tFOR(i, 1, n+1) cin >> d[i];\n\t\trep(i, n+2){\n\t\t\td[i] += i;\n\t\t\tif(d[i] < 0) d[i] = 0;\n\t\t\tif(d[i] > n) d[i] = n+1;\n\t\t}\n\n\t\tconst int INF = 10000;\n\t\trep(i, n+2)rep(j, n+2) dist[i][j] = 9;\n\t\tdist[0][0] = 0;\n\n\t\trep(i, n+2){\n\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\tint dest = i+j;\n\t\t\t\tif(dest > n) dest = n+1;\n\t\t\t\tdist[i][d[dest]] = min(dist[i][d[dest]], 1);\n\t\t\t}\n\t\t}\n\t\trep(i, n+2)rep(j, n+2)rep(k, n+2) dist[j][k] = min(dist[j][k], dist[j][i]+dist[i][k]);\n\n\t\tbool ok = true;\n\t\trep(i, n+2){\n\t\t\tok &= (dist[0][i] == INF || dist[i][n+1]);\n\t\t}\n\t\tcout << (ok?\"OK\":\"NG\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint ma, n;\n\t\n\twhile (scanf(\"%d\", &ma) && ma){\n\t\tbool state[256][256] = {{0}};\n\t\tint a[256] = {0};\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n\n\t\tn += 2;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 1; j <= ma && i + j < n; j++){\n\t\t\t\tstate[i][min(n - 1, max(0, i + j + a[i + j]))] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (state[i][k] && state[k][j]) state[i][j] = true;\n\t\t\n\t\tbool ng = false, ok = false;\n\t\tfor (int i = 1; i < n - 1; i++) if (state[0][i] && !state[i][n - 1]) ng = true;\n\t\tfor (int i = 1; i < n - 1; i++) if (state[0][i] && state[i][n - 1]) ok = true;\n\t\tprintf(\"%s\\n\", ng || !ok ? \"NG\" : \"OK\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int max,n,data[255];\n  bool MAS[255][255];\n  while(1){\n    memset(MAS,false,sizeof(MAS));\n    memset(data,false,sizeof(data));\n    cin >> max;\n    if(max==0)break;\n    cin >> n;\n    for(int i=1;i<=n;i++) cin >> data[i];\n    for(int j=0;j<n+2;j++){\n      for(int i=1;i<=max && j+i<n+2;i++){\n\tif(j+i==n+1)MAS[j][n+1]=true;\n\telse j+i+data[j+i]>=n+1 ? MAS[j][n+1]=true :\n\t       (j+i+data[j+i]<0?MAS[j][0]=true:MAS[j][j+i+data[i+j]]=true);\n      }\n    }\n\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n\tfor(int k=0;k<n+2;k++){\n\t  if(MAS[j][i]&&MAS[i][k]){\n\t    MAS[j][k]=true;\n\t  }\n\t}\n      }\n    }\n    bool flg=false;\n    for(int i=0;i<=n;i++){\n      if(MAS[0][i]&&(!MAS[i][n+1])){\n\tflg=true;\n\tbreak;\n      }\n    }\n    cout << (flg?\"NG\":\"OK\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,dmax;\nint m[300];\nbool visited[300], isVisit[300], isGoal;\nvoid dfs(int p){\n  if(visited[p])return ;\n  visited[p] = true;\n  isVisit[p] = true;\n  if(p == n+1){\n    isGoal = true;\n    return;\n  }\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;  \n    dfs(np);\n  }\n}\nvoid solve(){\n  fill(isVisit, isVisit+(n+2), false);\n  isVisit[0] = true;\n  for(int i = 0 ; i <= n; i++){\n    if(!isVisit[i])continue;\n    isGoal = false;\n    dfs(i);\n    if(!isGoal)break;    \n  }\n  cout << (isGoal?\"OK\":\"NG\") << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    fill(m, m+(n+2), 0);\n    for(int i = 0 ; i < n ;i++){\n      cin >> m[i+1];\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 256;\n\nint maxi;\nint n;\nint d[MAXN];\nbool vis[MAXN], vis2[MAXN];\n\nint nextPos(int pos, int m) {\n  int npos = min(pos + m, n-1);\n  npos += d[npos];\n  npos = min(npos, n-1);\n  npos = max(npos, 0);\n  return npos;\n}\n\nvoid rec(int pos) {\n  vis[pos] = true;\n  for(int m = 1; m <= maxi; ++m) {\n    int npos = nextPos(pos, m);\n    if(vis[npos]) continue;\n    rec(npos);\n  }\n}\n\nbool rec2(int pos) {\n  vis2[pos] = true;\n  if(pos == n-1) return true;\n  for(int m = 1; m <= maxi; ++m) {\n    int npos = nextPos(pos, m);\n    if(vis2[npos]) continue;\n    if(rec2(npos)) return true;\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> maxi && maxi) {\n    cin >> n;\n    for(int i = 0; i < n; ++i) cin >> d[i+1];\n    n += 2;\n    d[0] = d[n-1] = 0;\n    fill(vis, vis+n, false);\n    rec(0);\n    bool res = true;\n    for(int i = 0; i < n; ++i) {\n      if(vis[i]) {\n\tfill(vis2, vis2+n, false);\n\tif(!rec2(i)) {\n\t  res = false;\n\t  break;\n\t}\n      }\n    }\n    if(res) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint main(){\n    int ma;\n    while(scanf(\"%d\",&ma),ma){\n        int n;\n        int stage[256]={0};\n        int D[256][256]={{0}};\n        scanf(\"%d\",&n);\n        reps(i,1,n+1){\n            scanf(\"%d\",&stage[i]);\n        }\n        rep(i,n+1){\n            if(stage[i]){\n                int tmp = i+stage[i];\n                if(tmp < 0)tmp = 0;\n                if(tmp > n+1)tmp = n+1;\n                D[i][tmp] = 1;\n            }\n            else{\n                reps(j,1,ma+1){\n                    int tmp = i+j;\n                    if(tmp > n+1)tmp = n+1;\n                    D[i][tmp] = 1;\n                }\n            }\n        }\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    if(D[i][k] && D[k][j]){\n                        D[i][j] = 1;\n                    }\n                }\n            }\n        }\n        /*\n        puts(\"--------------------------\");\n        rep(i,n+2){\n            rep(j,n+2){\n                printf(\"%d \",D[i][j]);\n            }\n            puts(\"\");\n        }\n        puts(\"--------------------------\");\n        */\n        bool flg = false;\n        rep(i,n+2){\n            if(D[0][i] && D[i][n+1]){\n                flg = true;\n                break;\n            }\n        }\n        flg ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q1,q2;\n    q1.push(0);\n    bool c=true;\n    while(!q1.empty()){\n      b=q1.front();q1.pop();\n      if(r[b]) continue;\n      r[b]=true;\n      q2.push(b);\n      //cout << b << endl;\n      fill(used,used+300,false);\n      while(!q2.empty()){\n\tp=q2.front();q2.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(p>n+1){\n\t  used[n+1]=true;\n\t  break;\n\t}\n\tif(used[p]) continue;\n\tused[p]=true;\n\tq1.push(p);\n\tfor(i=1;i<=m;i++){\n\t  //cout <<p<<\":\"<< i <<\":\"<<p+i+d[p+i]<< endl;\n\t  q2.push(p+i+d[p+i]);\n\t}\n      }\n      if(!used[n+1]){\n\tc=false;\n\tbreak;\n      }\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define GET_MACRO5(ARG__1, ARG__2, ARG__3, ARG__4, ARG__5, NAME, ...) NAME\n#define GET_MACRO9(ARG__1, ARG__2, ARG__3, ARG__4, ARG__5, ARG__6, ARG__7, ARG__8, ARG__9, NAME, ...) NAME\n\n// Input ///////////////////////////////////////////////////////////////////////\n#define R1(a)                     cin>>a\n#define R2(a,b)                   cin>>a>>b\n#define R3(a,b,c)                 cin>>a>>b>>c\n#define R4(a,b,c,d)               cin>>a>>b>>c>>d\n#define R5(a,b,c,d,e)             cin>>a>>b>>c>>d>>e\n#define R6(a,b,c,d,e,f)           cin>>a>>b>>c>>d>>e>>f\n#define R7(a,b,c,d,e,f,g)         cin>>a>>b>>c>>d>>e>>f>>g\n#define R8(a,b,c,d,e,f,g,h)       cin>>a>>b>>c>>d>>e>>f>>g>>h\n#define R9(a,b,c,d,e,f,g,h,i)     cin>>a>>b>>c>>d>>e>>f>>g>>h>>i\n#define R(...) GET_MACRO9(__VA_ARGS__, R9, R8, R7, R6, R5, R4, R3, R2, R1)(__VA_ARGS__)\n\n#define I(...) int __VA_ARGS__; R(__VA_ARGS__)\n#define L(...) ll __VA_ARGS__; R(__VA_ARGS__)\n#define S(...) char __VA_ARGS__; R(__VA_ARGS__)\n\n#define TO_ARR1(n, a)             a[n]\n#define TO_ARR2(n, a, b)          a[n], b[n]\n#define TO_ARR3(n, a, b, c)       a[n], b[n], c[n]\n#define TO_ARR4(n, a, b, c, d)    a[n], b[n], c[n], d[n]\n#define TO_ARR5(n, a, b, c, d, e) a[n], b[n], c[n], d[n], e[n]\n#define TO_ARR(n, ...) \\\n\t\tGET_MACRO5(__VA_ARGS__, TO_ARR5, TO_ARR4, TO_ARR3, TO_ARR2, TO_ARR1)(n, __VA_ARGS__)\n\n#define ARR_CONCAT(type, n, ...) type TO_ARR(n, __VA_ARGS__); REP(i,n) R(TO_ARR(i, __VA_ARGS__));\n#define IARR(n, ...) ARR_CONCAT(int, n, __VA_ARGS__)\n#define LARR(n, ...) ARR_CONCAT(long long, n, __VA_ARGS__)\n\n#define input(t,v) t v;cin>>v;\n#define input2(t,v1,v2) t v1,v2;cin>>v1>>v2;\n#define input3(t,v1,v2,v3) t v1,v2,v3;cin>>v1>>v2>>v3;\n\ntemplate<class T=int> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\n// Types ///////////////////////////////////////////////////////////////////////\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef set<int> si;\ntypedef set<ll, ll> sll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef list<int> li;\ntypedef list<ll> lll;\ntypedef map<int, int> mii;\ntypedef map<int, ll> mil;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\n\n// Loop & Iteration ////////////////////////////////////////////////////////////\n#define FOR(i, a, b) for(int i = (a), loop_end_##i=(b); i < (loop_end_##i); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define rep(v,n) for(int (v)=0;(v)<(n);(v)++)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define PB push_back\n\n// Debug ///////////////////////////////////////////////////////////////////////\n#define dump(x)  cout << #x << \" = \" << (x) << endl\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\n\ntemplate<class T=int> void dump_table(int a, int b, T **x){\n\tint w = b, h = a;\n\tREP(j, w){\n\t\tprintf(\"\\t%d\", j);\n\t}\n\tprintf(\"\\n\");\n\tREP(i, h){\n\t\tprintf(\"%d\", i);\n\t\tREP(j, w){\n\t\t\tprintf(\"\\t%d\", x[i][j]);\n\t\t}\n\t}\n}\n////////////////////////////////////////////////////////////////////////////////\n\n#define constrain(a, b, c) std::max(std::min((a), (c)), (b))\n\nint main(){\n\tint max;\n\twhile(max=read<int>()){\n\t\tI(n);\n\t\tint d[n+2];\n\t\td[0]=d[n+1]=0;\n\t\tREP(i,n) d[i+1]=read<int>();\n\t\tset<int> cango[n+2];\n\t\tREP(i, n+1){\n\t\t\tREP(j, max){\n\t\t\t\tint x = constrain(i+j+1, 0, n+1);\n\t\t\t\tx = x + d[x];\n\t\t\t\tcango[x].insert(i);\n\t\t\t}\n\t\t}\n\t\tlist<int> cand;\n\t\tcand.PB(n+1);\n\t\tset<int> finish;\n\t\tint aaa = 0;\n\t\twhile(cand.size()){\n\t\t\tli::iterator it = cand.begin();\n\t\t\tint a = *it;\n\t\t\tcand.remove(a);\n\t\t\t// cout << a << endl;\n\t\t\tif(EXIST(finish, a)) continue;\n\t\t\tfor(set<int>::iterator it2=cango[a].begin(); it2!=cango[a].end(); it2++)\n\t\t\t\tcand.PB(*it2);\n\t\t\tfinish.insert(a);\n\t\t\taaa++;\n\t\t\tif(a>100){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tREP(i,n+1){\n\t\t\tif(!EXIST(finish, i)){\n\t\t\t\tok = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(ok) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint N;\nint a;\nvector<int>ds;\nvector<int>used;\nbool dfs(const int now) {\n\tif (now + N >= a + 1) {\n\t\tused[now] = 1;\n\t\treturn true;\n\t}\n\tset<int>nexts;\n\tfor (int i = 1; i <= N; ++i) {\n\t\t int next = now + i + ds[now + i];\n\t\tif (next >= a + 1) {\n\t\t\tused[now] = 1;\n\t\t\treturn true;\n\t\t}\n\t\telse if (next <= -1) {\n\t\t\tnext = 0;\n\t\t}\n\t\tif (used[next] == 1) {\n\t\t\tused[now] = 1;\n\t\t\treturn true;\n\t\t}\n\t\telse if (used[next] == -1) {\n\n\t\t}\n\t\telse {\n\t\t\tnexts.emplace(next);\n\t\t}\n\t}\n\tused[now] = -1;\n\tfor (auto n : nexts) {\n\t\tbool ok = dfs(n);\n\t\tif (ok) {\n\t\t\tused[now] = true;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (1) { cin >> N;\n\t\tif (!N)break; cin >> a;\n\t\tds.clear();\n\t\tused.clear();\n\t\tds.resize(a+2);\n\t\tused.resize(a + 2);\n\t\tfor (int i = 0; i < a; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tused[0] = -1;\n\t\tbool ok=dfs(0);\n\t\tif (ok)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, n) for(int i = (a); i < (n); i++)\n#define MP make_pair\n#define all(s) (s).begin(), (s).end()\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint m, n;\nvi ok;\nint dist[300][300];\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\twhile(cin >> m, m){\n\t\tcin >> n;\n\t\tvi d(n+2, 0);\n\t\tFOR(i, 1, n+1) cin >> d[i];\n\t\trep(i, n+2){\n\t\t\td[i] += i;\n\t\t\tif(d[i] < 0) d[i] = 0;\n\t\t\tif(d[i] > n) d[i] = n+1;\n\t\t}\n\n\t\tconst int INF = 10000;\n\t\trep(i, n+2)rep(j, n+2) dist[i][j] = INF;\n\t\tdist[0][0] = 0;\n\n\t\trep(i, n+2){\n\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\tint dest = i+j;\n\t\t\t\tif(dest > n) dest = n+1;\n\t\t\t\tdist[i][d[dest]] = min(dist[i][d[dest]], 1);\n\t\t\t}\n\t\t}\n\t\trep(i, n+2)rep(j, n+2)rep(k, n+2) dist[j][k] = min(dist[j][k], dist[j][i]+dist[i][k]);\n\n\t\tbool ok = true;\n\t\trep(i, n+2){\n\t\t\tok &= (dist[0][i] == INF || dist[i][n+1] != INF);\n\t\t}\n\t\tcout << (ok?\"OK\":\"NG\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\n\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-10;\n\nint M, N;\nint d[260];\nbool done[260], visited[260];\nvector<int> g[260];\n\nint dfs(int p) {\n\tif (visited[p]) return 0;\n\tif (p == N + 1) return 1;\n\t\n\tvisited[p] = true;\n\t\n\tREP(i, g[p].size()) if (dfs(g[p][i])) return 1;\n\treturn 0;\n}\n\nint main() {\n\twhile (cin >> M, M) {\n\t\tcin >> N;\n\t\t\n\t\tmemset(d, 0, sizeof(d));\n\t\tREP(i, N) scanf(\"%d\", d + i + 1);\n\t\t\n\t\tREP(i, 260) g[i].clear();\n\t\t\n\t\tREP(i, N + 1) {\n\t\t\tmemset(done, 0, sizeof(done));\n\t\t\tFOR(j, 1, M + 1) {\n\t\t\t\tint p = min(i + j, N + 1);\n\t\t\t\tp = max(0, min(p + d[p], N + 1));\n\t\t\t\tdone[p] = true;\n\t\t\t}\n\t\t\t\n\t\t\tREP(j, N + 2) if (done[j]) g[i].push_back(j);\n\t\t}\n\t\t\n\t\tbool ans = true;\n\t\t\n\t\tmemset(done, 0, sizeof(done));\n\t\t\n\t\tqueue<int> que;\n\t\tque.push(0);\n\t\tdone[0] = true;\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tint p = que.front(); que.pop();\n\t\t\t\n\t\t\tmemset(visited, 0, sizeof(visited));\n\t\t\tif (!dfs(p)) ans = false;\n\t\t\t\n\t\t\tREP(i, g[p].size()) if (!done[g[p][i]]) {\n\t\t\t\tdone[g[p][i]] = true;\n\t\t\t\tque.push(g[p][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tputs(ans ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n\nint M, N, D[256];\nbool G[256][256];\n\n\nint main()\n{\n\tfor(; cin >> M && M; ) {\n\t\tmemset(G, false, sizeof G);\n\n\t\tcin >> N;\n\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tcin >> D[i];\n\t\t}\n\n\t\tfor(int i = 0; i <= N; i++) {\n\t\t\tfor(int j = 1; j <= M; j++) {\n\t\t\t\tif(i+j >= N+1) G[i][N+1] = true;\n\t\t\t\telse G[i][max(0, min(i+j+D[i+j], N+1))] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i <= N+1; i++) {\n\t\t\tfor(int j = 0; j <= N+1; j++) {\n\t\t\t\tfor(int k = 0; k <= N+1; k++) {\n\t\t\t\t\tG[i][j] |= (G[i][k] && G[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool res = G[0][N+1];\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tres &= (G[0][i] ? G[i][N+1] : true);\n\t\t}\n\t\t\n\t\tcout << (res ? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint maxi, n;\nint d[256];\nbool mas[256];\n\nvector< vector<int> > G(256);\n\nvoid dfs1(int x)\n{\n  if(mas[x]) return;\n  mas[x] = true;\n  for(int i = 1; i <= maxi; i++){\n    dfs1(max(0, min(x + i + d[max(0, min(x + i, n+1))], n+1)));\n    G[max(0, min(x + i + d[max(0, min(x + i, n+1))], n+1))].push_back(x);\n  }\n}\n\nvoid dfs2(int x)\n{\n  if(!mas[x]) return;\n  mas[x] = false;\n  //if(d[x] != 0) return;\n  for(int i = 0; i < G[x].size(); i++){\n    dfs2(G[x][i]);\n  }\n}\n\nbool check()\n{\n  for(int i = 1; i <= n; i++){\n    if(mas[i]) return false;\n  }\n  return true;\n}\n\nint main()\n{\n  while(cin >> maxi, maxi){ \n    cin >> n;\n    G.clear(); G.resize(n + 2);\n    memset(mas, false, sizeof(mas));\n    memset(d, 0, sizeof(d));\n    for(int i = 1; i <= n; i++) cin >> d[i];\n    dfs1(0);\n    if(check() && !mas[n+1]) cout << \"NG\" << endl;\n    else {\n      dfs2(n+1);\n      cout << (check() ? \"OK\" : \"NG\") << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0262>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint M;\nstring solve(){\n    int n; cin >> n;\n    vector<int> d(n+2);\n    for(int i = 1; i <= n;i++) cin >> d[i];\n//    vector<vector<int>> canvisit(n+2,vector<int>(n+2,0));\n//    for(int i = 0; i < n+2;i++) canvisit[i][i] = 1;\n//    for(int i = 0; i < n+2;i++){\n//        queue<int> q; q.push(i);\n//        while(q.size()){\n//            int now = q.front(); q.pop();\n//            if(canvisit[i][now]) continue;\n//            canvisit[i][now] = true;\n//            for(int dice = 1; dice <= M && dice+now<=n+1;i++){\n//\n//            }\n//        }\n//    }\n    vector<int> canvisit(n+2),checked(n+2); canvisit[0] = true;\n\n    while(true){\n        int target = -1;\n        for(int i = 0; i <= n;i++){\n            if(canvisit[i]){\n                if(checked[i]) continue;\n                target = i;\n                break;\n            }\n        }\n        if(target == -1) break;\n        checked[target] = true;\n\n        vector<int> visited(n+2);\n        queue<int> q; q.push(target);\n        while(q.size()){\n            int now = q.front(); q.pop();\n            if(visited[now]) continue;\n            visited[now] = true;\n            for(int dice = 1; dice <= M;dice++){\n                if(now + dice >= n+2)break;\n                int next = max(0,min(n+1,dice+now));\n                q.push(max(0,min(n+1,next+d[next])));\n            }\n        }\n        if(visited[n+1] == false) return \"NG\";\n        if(target == 0){\n            for(int i = 0; i <= n;i++){\n                canvisit[i] |= visited[i];\n            }\n        }\n    }\n    return \"OK\";\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> M,M){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <functional>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set>\n\nint rmax, n;\nint d[260];\nstd::vector<std::set<int> > edges, edges2;\n\n/*\n0: ????????????\n1~n: ??????\nn + 1: ?????????\n*/\n\nint check(int idx) {\n    idx += d[idx];\n    if(idx <= 0) {\n        return 0;\n    }\n\n    if(idx >= n + 1) {\n        return n + 1;\n    }\n\n    return idx;\n}\n\nint main() {\n    while(std::cin >> rmax, rmax) {\n        std::cin >> n;\n\n        edges.clear();\n        edges.resize(n + 2);\n        edges2.clear();\n        edges2.resize(n + 2);\n\n        for(int i = 1; i <= n; ++i) {\n            std::cin >> d[i];\n        }\n        for(int i = 0; i <= n; ++i) {\n            for(int j = 1; j <= rmax; ++j) {\n                int to = check(i + j);\n\n                if(i == to) {\n                    continue;\n                }\n                edges[to].insert(i);\n                edges2[i].insert(to);\n            }\n        }\n\n        /*for(int i = 0; i < edges.size(); ++i) {\n            for(std::set<int>::iterator it = edges[i].begin(); it != edges[i].end(); ++it) {\n                std::cout << i << \" \" <<  *it << std::endl;\n            }\n        }*/\n\n        bool used[260] = {}, used2[260] = {};\n        std::queue<int> que;\n        {\n            que.push(n + 1);\n            used[n + 1] = true;\n            while(!que.empty()) {\n                int p = que.front(); que.pop();\n\n                for(std::set<int>::iterator it = edges[p].begin(); it != edges[p].end(); ++it) {\n                    if(!used[*it]) {\n                        que.push(*it);\n                        used[*it] = true;\n                    }\n                }\n            }\n        }\n\n        {\n            que.push(0);\n            used2[0] = true;\n            while(!que.empty()) {\n                int p = que.front(); que.pop();\n\n                for(std::set<int>::iterator it = edges2[p].begin(); it != edges2[p].end(); ++it) {\n                    if(!used2[*it]) {\n                        que.push(*it);\n                        used2[*it] = true;\n                    }\n                }\n            }\n        }\n\n        bool ok = true;\n        for(int i = 0; i <= n + 1; ++i) {\n            //std::cout << i << \" \" << used2[i] << \" \" << used[i] << std::endl;\n            if(used2[i] && !used[i]) {\n                ok = false;\n                break;\n            }\n        }\n\n        std::cout << (ok ? \"OK\" : \"NG\") << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(1,nx);\n    //if(!memo[prev][x])ans=false;\n    return memo[prev][x];\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint mx, n, d[300], g[300][300];\nint memo[300];\n\nint dfs(int k){\n\tif( d[k] == 0 ) return k;\n\t\n\tif( n+1 <= k + d[k] ) return n + 1;\n\tif( k + d[k] <= 0 ) return 0;\n\tif( memo[k] != -1 ) return memo[k];\n\t\n\treturn memo[k] = dfs(k + d[k]);\n}\n\nvoid add_edge(int u, int v){\n\tg[u][v] = 1;\n}\n\nint main(){\n\twhile( cin >> mx, mx ){\n\t\tfill(d, d + 300, 0);\n\t\tfill(memo, memo + 300, -1);\n\t\tfor(int i = 0; i < 300; i++) fill(g[i], g[i] + 300, 0);\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; i++) cin >> d[i];\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif( d[i] == 0 ){\n\t\t\t\tint u = i;\n\t\t\t\tfor(int j = 1; j <= mx; j++){\n\t\t\t\t\tint v = dfs(i + j);\n\t\t\t\t\tadd_edge(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k <= n+1; k++){\n\t\t\tfor(int i = 0; i <= n+1; i++){\n\t\t\t\tfor(int j = 0; j <= n+1; j++){\n\t\t\t\t\tif( g[i][k] && g[k][j] ) g[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tfor(int u = 0; u <= n; u++){\n\t\t\tif( g[0][u] && !g[u][n+1] ) ans = false;\n\t\t}\n\t\tcout << (ans? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n,m,d[300],u[300];\n  while(cin >> m && m) {\n    cin >> n;\n    memset(d,0,sizeof(d));\n    memset(u,0,sizeof(u));\n    for(int i=1; i<=n; i++) cin >> d[i];\n    queue<int> que;\n    que.push(0);\n    u[0]=1;\n    while(!que.empty()) {\n      int x=que.front();que.pop();\n      for(int i=1; i<=m; i++) {\n        int y=i+x;\n        if(y<0) y=0;\n        else if(y>=n+2) y=n+1;\n        y+=d[y];\n        if(y<0) y=0;\n        else if(y>=n+2) y=n+1;\n        if(u[y]) continue;\n        u[y]=1;\n        que.push(y);\n      }\n    }\n    bool f=1;\n    for(int j=0; j<n+2; j++) {\n      if(!u[j]) continue;\n      memset(u,0,sizeof(u));\n      u[j]=1;\n      que.push(j);\n      u[j]=1;\n      while(!que.empty()) {\n        int x=que.front();que.pop();\n        for(int i=1; i<=m; i++) {\n          int y=i+x;\n          if(y<0) y=0;\n          else if(y>=n+2) y=n+1;\n          y+=d[y];\n          if(y<0) y=0;\n          else if(y>=n+2) y=n+1;\n          if(u[y]) continue;\n          u[y]=1;\n          que.push(y);\n        }\n      }\n      if(!u[n+1]) f=0;\n    }\n    if(f) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint main(){\n\t#define MAX_N 250\n\tint m, n, d[MAX_N + 2];\n\tbool reach;\n\t\n\twhile(1){\n\t\tfill(d, d + MAX_N + 2, 0);\n\t\tscanf(\"%d\", &m);\n\t\tif(m == 0) return 0;\n\t\tscanf(\"%d\", &n);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", d + i);\n\t\t}\n\t\t\n\t\treach = true;\n\t\tfor(int i = 0; i < n - m + 1; i++){\n\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\tif(d[i + j] > -j) break;\n\t\t\t\tif(j == m) reach = false;\n\t\t\t}\n\t\t\tif(!reach){\n\t\t\t\tprintf(\"NG\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(reach) printf(\"OK\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m;\nint d[555];\nbool u[555];\nbool f(int v)\n{\n\tif(v>=n)return true;\n\telse if(v>=0&&!u[v])return 0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(v+i+d[v+i]>=n)continue;\n\t\tif(!u[v+i+d[v+i]]||!f(v+i+d[v+i]))\n\t\t{\n\t\t\tif(v>=0)u[v]=0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(v>=0)u[v]=1;\n\treturn u[v]=1;\n}\nmain()\n{\n\twhile(cin>>m,m)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=0;i<555;i++)u[i]=1,d[i]=0;\n\t\tfor(int i=0;i<n;i++)cin>>d[i];\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tbool ok=0;\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tok|=i+j+d[i+j]>i;\n\t\t\t}\n\t\t\tu[i]=ok;\n\t\t\tif(ok)\n\t\t\t{\n\t\t\t\tbool ng=0;\n\t\t\t\tfor(int j=1;j<=m;j++)if(i+j+d[i+j])ng|=!u[i+j+d[i+j]];\n\t\t\t\tu[i]=!ng;\n\t\t\t}\n\t\t}\n\t\tbool flag=1;\n\t\tfor(int i=0;i<m;i++)if(i+d[i]>=0)flag&=u[i+d[i]];\n\t\tcout<<(flag?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint maxi, n;\nint d[256];\nbool mas[256];\n\nvector< vector<int> > G(256);\n\nvoid dfs1(int x)\n{\n  if(mas[x]) return;\n  mas[x] = true;\n  for(int i = 1; i <= maxi; i++){\n    dfs1(max(0, min(x + i + d[max(0, min(x + i, n+1))], n+1)));\n    G[max(0, min(x + i + d[max(0, min(x + i, n+1))], n+1))].push_back(x);\n  }\n}\n\nvoid dfs2(int x)\n{\n  if(!mas[x]) return;\n  mas[x] = false;\n  //if(d[x] != 0) return;\n  for(int i = 0; i < G[x].size(); i++){\n    dfs2(G[x][i]);\n  }\n}\n\nbool check()\n{\n  for(int i = 1; i <= n; i++){\n    if(mas[i]) return false;\n  }\n  return true;\n}\n\nint main()\n{\n  while(cin >> maxi, maxi){ \n    cin >> n;\n    G.clear(); G.resize(n + 2);\n    memset(mas, false, sizeof(mas));\n    memset(d, 0, sizeof(d));\n    for(int i = 1; i <= n; i++) cin >> d[i];\n    dfs1(0);\n    if(check()) cout << \"NG\" << endl;\n    else {\n      dfs2(n+1);\n      cout << (check() ? \"OK\" : \"NG\") << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nint mx;\nint d[300];\nint n;\nint done[300] = {};\nint ok[300] = {};\nint can(int x){\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\tif( x == n - 1 ) return 1;\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( can(t) ) return 1;\n\t}\n\treturn 0;\n}\nint dfs(int x){\n\tif( !ok[x] ) return 1;\n\tif( done[x] ) return 0;\n\tdone[x] = 1;\n\t\n\tfor(int i = 1 ; i <= mx ; i++){\n\t\tint t = min(n-1,x+i);\n\t\tt += d[t];\n\t\tt = max(0,t);\n\t\tif( dfs(t) ) return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin >> mx && mx){\n\t\tfor(int i = 0 ; i < 300 ; i++) d[i] = 0;\n\t\tfor(int i = 0 ; i < 300 ; i++) ok[i] = 0;\n\t\tcin >> n;\n\t\tn += 2;\n\t\tfor(int i = 1 ; i < n - 1 ; i++)\n\t\t\tcin >> d[i];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\t\tok[i] = can(i);\n\t\t}\n\t\tfor(int j = 0 ; j < 300 ; j++) done[j] = 0;\n\t\tcout << (dfs(0)?\"NG\":\"OK\") << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint mx, n, d[300], g[300][300];\nint memo[300];\n\nint dfs(int k){\n\tif( d[k] == 0 ) return k;\n\t\n\tif( n+1 <= k + d[k] ) return n + 1;\n\tif( k + d[k] <= 0 ) return 0;\n\t\n\tif( memo[k] != -1 ) return memo[k];\n\treturn memo[k] = dfs(k + d[k]);\n}\n\nvoid add_edge(int u, int v){\n\tg[u][v] = 1;\n}\n\nint main(){\n\twhile( cin >> mx, mx ){\n\t\tfill(d, d + 300, 0);\n\t\tfill(memo, memo + 300, -1);\n\t\tfor(int i = 0; i < 300; i++) fill(g[i], g[i] + 300, 0);\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; i++) cin >> d[i];\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif( d[i] == 0 ){\n\t\t\t\tint u = i;\n\t\t\t\tfor(int j = 1; j <= mx; j++){\n\t\t\t\t\tint v = dfs(i + j);\n\t\t\t\t\tadd_edge(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k <= n+1; k++){\n\t\t\tfor(int i = 0; i <= n+1; i++){\n\t\t\t\tfor(int j = 0; j <= n+1; j++){\n\t\t\t\t\tif( g[i][k] && g[k][j] ) g[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tfor(int u = 0; u <= n; u++){\n\t\t\tif( g[0][u] && !g[u][n+1] ) ans = false;\n\t\t}\n\t\tcout << (ans? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define MAX 250\n#define rep(i, n) for ( int i = 0; i < n; i++ )\nint G[MAX+2][MAX+2], D[MAX+2];\n\nmain(){\n  int m, n; \n  int tcase = 0;\n  while(cin >> m){\n    if ( m == 0 ) break;\n    cin >> n;\n    tcase++;\n    rep(i, n+2) rep(j, n+2) G[i][j] = 0;\n    D[0] = D[n+1] = 0;\n    for ( int i = 1; i <= n; i++ ) cin >> D[i];\n    for ( int i = 0; i <= n; i++ ){\n      assert( -n <= D[i] && D[i] <= n );\n      for ( int k = 1; k <= m; k++ ){\n\tint t = min(i+k, n+1);\n\tif ( D[t] > 0 ) t = min(n+1, t + D[t]);\n\telse if ( D[t] < 0 ) t = max(0, t + D[t]);\n\tG[i][t] = 1;\n      }\n    }\n    rep(k, n+2) rep(i, n+2) rep(j, n+2){\n      if ( G[i][k] && G[k][j] ) G[i][j] = 1;\n    }\n    bool valid = true;\n    for ( int i = 0; i <= n; i++ ){\n      if ( G[0][i] && !G[i][n+1]) valid = false;\n    }\n    cout << (valid?\"OK\":\"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\nint come[300];\nbool dfs(const int now,const vector<vector<int>>&edges, const int goal) {\n\tassert(come[now] == false);\n\tcome[now] = true;\n\tif (now == goal)return true;\n\telse {\n\t\tif (edges[now].empty())return false;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (e == now)assert(false);\n\t\t\tif (!dfs(e, edges, goal))return false;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tmemset(come, false, sizeof(come));\n\t\tint amax;\n\t\tcin >> amax;\n\t\tif (!amax)break;\n\t\tint N; cin >> N;\n\t\tconst int goal = N + 1;\n\t\tconst int start = 0;\n\t\tvector<int>ds(goal+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tvector<vector<int>>edges(N + 2);\n\t\tfor (int i = 0; i < N + 1; ++i) {\n\t\t\tfor (int j = 1; j <= amax; ++j) {\n\t\t\t\tint next;\n\t\t\t\tif (i + j >= goal) {\n\t\t\t\t\tnext = goal;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i + j + ds[i + j] >= goal) {\n\t\t\t\t\t\tnext = goal;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i + j + ds[i+j]<0) {\n\t\t\t\t\t\tnext = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnext = i + j + ds[i + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (find(edges[i].begin(), edges[i].end(), next) == edges[i].end()) {\n\t\t\t\t\tedges[i].push_back(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=dscc.get(edges);\n\t\tint newstart;\n\t\tint newgoal;\n\t\tfor (int i = 0; i < p.first.size();++i) {\n\t\t\tauto b = p.first[i];\n\t\t\tif (find(b.begin(), b.end(), 0)!=b.end()) {\n\t\t\t\tnewstart = i;\n\t\t\t}\n\t\t\tif (find(b.begin(), b.end(), goal) != b.end()) {\n\t\t\t\tnewgoal= i;\n\t\t\t}\n\t\t}\n\t\tauto newedges = p.second;\n\t\t\n\t\tbool ans = dfs(newstart, newedges, newgoal);\n\t\tif (ans) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int> > G, R;\nbool u[255], vi[255];\n\nvoid f(int v) {\n\tu[v] = true;\n\tfor (int a : R[v])\n\t\tif (!u[a]) f(a);\n}\n\nbool ok(int v) {\n\tbool ans = u[v];\n\tvi[v] = true;\n\tfor (int a : G[v])\n\t\tif (!vi[a] && ans) ans = ok(a);\n\treturn ans;\n}\n\nint main() {\n    int m;\n\twhile (cin >> m, m) {\n\t    int n; cin >> n;\n\t\tvector<int> d(n + 2);\n\t\tG.assign(n + 2, vector<int>()), R.assign(n + 2, vector<int>());\n\t\tfor (int i = 0; i <= n + 1; ++i) G[i].clear(), R[i].clear(), vi[i] = u[i] = false;\n\t\tfor (int i = 1; i <= n; ++i) cin >> d[i];\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tfor (int j = 1; j <= m && i + j <= n + 1; ++j) {\n\t\t\t\tint k = i + j + d[i + j];\n\t\t\t\tif (k > n + 1) k = n + 1;\n\t\t\t\tif (k < 0) k = 0;\n\t\t\t\tG[i].push_back(k);\n\t\t\t\tR[k].push_back(i);\n\t\t\t}\n\t\t}\n\t\tf(n + 1);\n\t\tcout << (ok(0) ? \"OK\" : \"NG\") << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint mx, n, d[300], g[300][300];\nint memo[300];\n\nint dfs(int k){\n\tif( d[k] == 0 ) return k;\n\t\n\tif( n+1 <= k + d[k] ) return n + 1;\n\tif( k + d[k] <= 0 ) return 0;\n\t\n\tif( memo[k] != -1 ) return memo[k];\n\treturn 0;\n\t//return memo[k] = dfs(k + d[k]);\n}\n\nvoid add_edge(int u, int v){\n\tg[u][v] = 1;\n}\n\nint main(){\n\twhile( cin >> mx, mx ){\n\t\tfill(d, d + 300, 0);\n\t\tfill(memo, memo + 300, -1);\n\t\tfor(int i = 0; i < 300; i++) fill(g[i], g[i] + 300, 0);\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; i++) cin >> d[i];\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif( d[i] == 0 ){\n\t\t\t\tint u = i;\n\t\t\t\tfor(int j = 1; j <= mx; j++){\n\t\t\t\t\tint v = dfs(i + j);\n\t\t\t\t\tadd_edge(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k <= n+1; k++){\n\t\t\tfor(int i = 0; i <= n+1; i++){\n\t\t\t\tfor(int j = 0; j <= n+1; j++){\n\t\t\t\t\tif( g[i][k] && g[k][j] ) g[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tfor(int u = 0; u <= n; u++){\n\t\t\tif( g[0][u] && !g[u][n+1] ) ans = false;\n\t\t}\n\t\tcout << (ans? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint mx;\nint n;\nint d[251];\nbool flg[251];\n\n\nbool Solve(int x){\n\n  if(x>=n+1)return true;\n  if(flg[x]==true)return false;\n  flg[x]=true;\n    \n  if(d[x]!=0){\n  \n    if(x+d[x]>=n+1)return true;\n    if(Solve(x+d[x])==true)return true;\n  }\n  else{\n    \n    if(x+mx>=n+1)return true;  \n   \n    for(int i=1; i<mx; i++){\n     if(Solve(x+i)==true)return true;\n    }   \n    \n  }\n  \n  flg[x]=false;\n  \n  return false;\n}\n\n\nint main(){\n  \n  while(cin>>mx , mx){\n    cin >> n;\n    d[0]=0;\n    for(int i=1; i<=n; i++){\n      cin>>d[i];\n      flg[i]=false;\n    }\n\n    if(Solve(0)==true)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q1,q2;\n    q1.push(0);\n    bool c=true;\n    while(!q1.empty()){\n      b=q1.front();q1.pop();\n      if(r[b]) continue;\n      r[b]=true;\n      q2.push(b);\n      fill(used,used+300,false);\n      while(!q2.empty()){\n\tp=q2.front();q2.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(used[p]) continue;\n\tused[p]=true;\n\tq1.push(p);\n\tfor(i=1;i<=m;i++){\n\t  if(p+i+d[p+i]>n+1){\n\t    used[n+1]=true;\n\t    break;\n\t  }else q2.push(p+i+d[p+i]);\n\t}\n      }\n      if(!used[n+1]){\n\tc=false;\n\tbreak;\n      }\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n \nusing namespace std;\n \nconst int MAX = 260;\nbool come[MAX],goal[MAX];\nint M,n,d[MAX];\n \nvoid print(){\n \n  for(int i = 0; i <= n; i++) cout << come[i] << \" \";\n  cout << endl;\n  for(int i = 0; i <= n; i++) cout << goal[i] << \" \";\n  cout << endl;\n}\n \nvoid init(){\n  fill(come,come+MAX,false);\n  fill(goal,goal+MAX,false);\n  fill(d,d+MAX,0);\n}\n \nint move(int now, int num){\n  int nex = now+num;\n  if(nex > n) return -1;\n  nex += d[nex];\n  if(nex > n) return -1;\n  if(nex < 0) return 0;\n  return nex;\n}\n \nvoid make_come(){\n  come[0] = true;\n  priority_queue<int,vector<int>,greater<int> > Q;\n  Q.push(0);\n  while(!Q.empty()){\n    int now = Q.top();\n    Q.pop();\n \n    for(int i = 1; i <= M; i++){\n      int nex = move(now,i);\n      if(nex == -1) goal[now] = true;\n      else if(!come[nex] && nex <= n){\n        come[nex] = true;\n        Q.push(nex);\n      }\n    }\n  }\n}\n \nvoid make_goal(){\n \n  while(1){\n    bool update = false;\n \n    for(int i = n; i >= 0; i--){\n      if(!come[i] || goal[i]) continue;\n       \n      for(int j = 1; j <= M; j++){\n        int nex = move(i,j);\n        if(nex == -1){\n          goal[i] = true;\n          update = true;\n        }else if(goal[nex]){\n          goal[i] = true;\n          update = true;\n        } \n      }\n    }\n    if(!update) break;\n  }\n}\n \n \nbool solve(){\n \n  make_come();\n  make_goal();\n \n  for(int i = 0; i <= n; i++)\n    if(come[i] && !goal[i]) return false; \n  return true;\n}\n \nint main(){\n \n  while(cin >> M && M){\n    init();\n    cin >> n;\n    for(int i = 1; i <= n; i++) cin >> d[i];\n    if(solve()) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    //print();\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<bitset>\n#include<vector>\nusing namespace std;\n\n\n\nint main()\n{\nint n,mex;\n  while(cin >> mex,mex)\n    {\n      cin >> n;\n      vector<int> G(n+1);\n      int out[n+1];\n\n      for(int i=1;i<=n;i++)\n\t{\n\t  cin >> G[i];\n\t  out[i] = 0;\n\t}\n      out[0] = 0;\n\n      for(int i=1;i<=n;i++)\n\tif(G[i] < 0)\n\t  for(int j=i-1;j>=i-mex && j >= 0;j--)\n\t    out[j]++;\n\t    \n      for(int i=0;i<n;i++)\n\t{\n\t  if(out[i] >= mex && (G[i] >= 0 && out[i] >= G[i]))\n\t    {\n\t      cout << \"NG\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"OK\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define repi(i,a,b) for( int i = (a); i != (b); ++i )\n\nint ma;\nint n;\nint d[252];\nstd::vector<int> G[252], rG[252];\nbool reach[252], rev[252];\n\nvoid dfs( int v )\n{\n\trev[v] = true;\n\n\trep( i, rG[v].size() )\n\t\tif( !rev[rG[v][i]] )\n\t\t\tdfs( rG[v][i] );\n\n\treturn;\n}\n\nvoid dfs2( int v )\n{\n\treach[v] = true;\n\n\trep( i, G[v].size() )\n\t\tif( !reach[G[v][i]] )\n\t\t\tdfs2( G[v][i] );\n\n\treturn;\n}\n\nint main()\n{\n\twhile( scanf( \"%d\", &ma ), ma )\n\t{\n\t\trep( i, 252 )\n\t\t\tG[i].clear(), rG[i].clear();\n\n\t\tscanf( \"%d\", &n );\n\n\t\trepi( i, 1, n+1 )\n\t\t\tscanf( \"%d\", d+i );\n\n\t\trep( i, n+1 )\n\t\t{\n\t\t\trep( j, ma )\n\t\t\t{\n\t\t\t\tif( i+j+1 >= n+2 )\n\t\t\t\t\tbreak;\n\n\t\t\t\tint to = std::max( 0, std::min( i+j+1+d[i+j+1], n+1 ) );\n\t\t\t\tG[i].push_back( to );\n\t\t\t\trG[to].push_back( i );\n\t\t\t}\n\t\t}\n\n\t\tmemset( reach, false, sizeof( reach ) );\n\t\tmemset( rev, false, sizeof( rev ) );\n\t\tdfs( n+1 );\n\t\tdfs2( 0 );\n\n\t\tbool fl = true;\n\t\trep( i, n+2 )\n\t\t\tif( reach[i] && !rev[i] )\n\t\t\t\tfl = false;\n\n\t\tputs( fl ? \"OK\" : \"NG\" );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nint M;\nint N;\nint D[259];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&M);\n\t\tif(M==0)break;\n\t\tscanf(\"%d\",&N);\n\t\tfor(int i=1;i<=N;i++)scanf(\"%d\",&D[i]);\n\t\tvector<int> G[259];\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(i+D[i]<0)G[i].pb(0);\n\t\t\telse if(i+D[i]>N+1)G[i].pb(N+1);\n\t\t\telse G[i].pb(i+D[i]);\n\t\t\tfor(int j=1;j<=M;j++){\n\t\t\t\tif(i+j<=N+1)G[i].pb(i+j);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=M;j++){\n\t\t\tif(j<=N+1)G[0].pb(j);\n\t\t}\n\t\tbool F[259];\n\t\tfor(int i=0;i<=N+1;i++)F[i]=false;\n\t\tvector<int>S;S.pb(0);\n\t\tint l=0;\n\t\twhile(l<(int)S.size()){\n\t\t\tint v=S[l];\n\t\t\tif(F[v])continue;\n\t\t\tF[v]=true;\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tif(!F[G[v][i]]){\n\t\t\t\t\tS.pb(G[v][i]);\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\t\tbool ans=true;\n\t\tbool F1[259];\n\t\tfor(int i=0;i<=N+1;i++){\n\t\t\tif(!F[i])continue;\n\t\t\tfor(int j=0;j<=N+1;j++){\n\t\t\t\tF1[i]=false;\n\t\t\t}\n\t\t\tS.clear();\n\t\t\tS.pb(i);\n\t\t\tl=0;\n\t\t\twhile(l<(int)S.size()&&!F1[N+1]){\n\t\t\t\tint v=S[l];\n\t\t\t\tif(F1[v])continue;\n\t\t\t\tF1[v]=true;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tif(!F1[G[v][i]]){\n\t\t\t\t\t\tS.pb(G1[v][i]);\n\t\t\t\t\t\tr++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(!F1[N+1])ans=false;\n\t\t}\n\t\tif(ans)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint n,m;\nint start,end;\nvector<int> v,p;\nbool flag;\n\nvoid dfs(vector<bool> used,int now)\n{\n\tif(now == end)\n\t{\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\tif(used[now]) return;\n\tused[now] = true;\n\n\trep(j,m)\n\t{\n\t\tif(now + j <= end)\n\t\t{\n\t\t\tif(0 <= now + j + v[now + j] && now != now + j + v[now + j]) \n\t\t\t{\n\t\t\t\tdfs(used,now + j + v[now + j]);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main()\n{\n\twhile(cin >> m && m)\n\t{\n\t\tp.clear();\n\t\tp.resize(m);\n\t\trep(i,m) p[i] = i+1;\n\n\t\tcin >> n;\n\n\t\tv.clear();\n\t\tv.resize(n+2);\n\t\t\n\t\tv[0] = 0;\n\t\tstart = 0;\n\n\t\tREP(i,1,n+1) cin >> v[i];\n\n\t\tv[n+1] = 0;\n\t\tend = n+1;\n\t\n\t\tflag = false;\n\t\tvector<bool> used(n+2);\n\t\trep(i,n+2) used[i] = false;\n\n\t\tdfs(used,0);\n\n\t\tif(flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Max, N, d[252];\nbool graph[252], rgraph[252];\n\n\nmain()\n{\n\n  while(cin >> Max, Max) {\n    fill_n(d, 252, 0);\n    fill_n(graph, 252, false);\n    fill_n(rgraph, 252, false);\n\n    cin >> N;\n    for(int i = 1; i <= N; i++) {\n      cin >> d[i];\n    }\n\n    graph[0] = true;\n    for(int i = 0; i <= N; i++) {\n      if(!graph[i]) continue;\n      for(int j = 1; j <= Max; j++) {\n        graph[max(0, min(N + 1, i + j + d[min(N + 1, i + j)]))] = true;\n      }\n    }\n    rgraph[N + 1] = true;\n    for(int i = N + 1; i > 0; i--) {\n      if(!rgraph[i]) continue;\n      for(int j = 1; j <= Max; j++) {\n        rgraph[max(0, min(N + 1, i - j - d[max(0, i - j)]))] = true;\n      }\n    }\n    bool flag = true;\n    for(int i = 0; i <= N + 1; i++) {\n      if(graph[i] && !rgraph[i]) flag = false;\n    } \n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint M, n, d[252];\nbool visited[252];\n\nbool rec(int start) {\n    bool ok = false;\n    if(start<0) return false;\n    if(n+1<start) return true;\n    if(visited[start]) return false;\n\n    visited[start] = true;\n    for(int i=1; i<=M; i++) {\n        ok |= rec(start + i + d[start+i]);\n    }\n    return ok;\n}\n\nint main()\n{\n    while(cin>>M, M) {\n        cin>>n;\n        visited[0] = false;\n        for(int i=1; i<=n; i++) {\n            cin>>d[i];\n            visited[i] = false;\n        }\n        if(rec(0)) cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    return memo[prev][x]|=dfs(1,nx);\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    ans=true;\n    dfs(0,0);    \n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> a;\nint n,m;\nvector<bool> d(300);\n\nbool saiki(int p1,int pre,vector<int> u){\n    int p = p1;\n  //  if(u[p] > 2) return true;\n    if(!d[p]) return false;\n    u[p]++;\n    bool ans = false;\n\n    bool flg = false;\n    for(int i=1;i<=m;i++){\n\tif(u[min(p+i,n+1)] == 0) flg = true;\n    }\n    if(!flg) return true;\n    for(int i=1;i<=m;i++){\n\tp = p1;\n\tp += i;\n\tp = min(p,n+1);\n\tu[p]++;\n\tif(a[p] == 300) return d[p1] = false;\n\tp += a[p];\n\tp = min(p,n+1);\n\tp = max(p,0);\n\tif(u[p] < 50)\n\t    ans = ans | saiki(p,p1,u);\n    }\n    return d[p] = ans;\n}\n\nint main(){\n    while(true){\n\tfill(ALL(d),true);\n\ta = vector<int>(0);\n\tcin >> m;\n\tif(m == 0) break;\n\tcin >> n;\n\ta.PB(-300);\n\tREP(i,n){\n\t    int temp;\n\t    cin >> temp;\n\t    a.PB(temp);\n\t}\n\ta.PB(300);\n\tif(!saiki(0,0,vector<int>(n+2,0))) cout << \"OK\" << endl;\n\telse cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint m,n,order[252];\nbool g[255][255]={};//g[a][b]:=a->b\nint main()\n{\n\twhile(cin>>m&&m){\n\t\tfill(g[0], g[255], false);\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin>>order[i];\n\t\t\tg[i][i]=true;\n\t\t}\n\t\tg[0][0]=g[n+1][n+1]=true;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tint tmp=i+j+order[i+j];\n\t\t\t\tif(tmp<0)tmp=0;\n\t\t\t\telse if(tmp>n+1)tmp=n+1;\n\t\t\t\tg[i][tmp]=true;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<=n+1;k++)\n\t\t\tfor(int i=0;i<=n+1;i++)\n\t\t\t\tfor(int j=0;j<=n+1;j++)\n\t\t\t\t\tif(g[i][k]&&g[k][j])g[i][j]=true;\n\t\tbool flg=true;\n\t\tfor(int i=0;i<=n;i++)if(g[0][i]&&!g[i][n+1])flg=false;\n\t\tif(flg)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint main(){\n    int ma;\n    while(scanf(\"%d\",&ma),ma){\n        int n;\n        int stage[256]={0};\n        int D[256][256]={{0}};\n        scanf(\"%d\",&n);\n        reps(i,1,n+1){\n            scanf(\"%d\",&stage[i]);\n        }\n        rep(i,n+1){\n            if(stage[i]){\n                int tmp = i+stage[i];\n                if(tmp < 0)tmp = 0;\n                if(tmp > n+1)tmp = n+1;\n                D[i][tmp] = 1;\n            }\n            else{\n                reps(j,1,ma+1){\n                    int tmp = i+j;\n                    if(tmp > n+1)tmp = n+1;\n                    D[i][tmp] = 1;\n                }\n            }\n        }\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    if(D[i][k] && D[k][j]){\n                        D[i][j] = 1;\n                    }\n                }\n            }\n        }\n        /*\n        puts(\"--------------------------\");\n        rep(i,n+2){\n            rep(j,n+2){\n                printf(\"%d \",D[i][j]);\n            }\n            puts(\"\");\n        }\n        puts(\"--------------------------\");\n        */\n        bool flg = true;\n        rep(i,n+1){\n            if(D[0][i] && !D[i][n+1]){\n                flg = false;\n                break;\n            }\n        }\n        flg ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint m,n;\nint mass[260]={};\nbool DP[260]={};\nint seach(vector<int> walked,int now){\n\tnow=max(0,min(now,n+1));\n\tif(DP[now]!=0)\n\treturn DP[now];\n\tif(now>n){\n\t\tDP[now]=1;\n\t\treturn 1;\n\t}\n\tfor(int i=0;i<walked.size();i++){\n\t\tif(now==walked[i]){\n\t\t//DP[now]=-9999;\n\t\treturn -i-1;\n\t\t}\n\t}\n\twalked.push_back(now);\n\tint maxer=-9999;\n\tfor(int i=1;i<=m;i++){\n\t\tint first=min(n+1,now+i);\n\t\tint second=first+mass[first];\n\t\tmaxer=max(maxer,seach(walked,second));\n\t}\n\tif(walked.size()==-maxer){\n\tDP[now]=2;\t\n\tmaxer=2;\n\t}\n\tif(DP[now]>0)\n\tDP[now]=maxer;\n\t//else if(DP[now]<0)\n\t//DP[now]=-9999;\n\treturn maxer;\n\t\n}\n\nint main() {\n\t// your code goes here\n\tvector<int> a;\n\twhile(true){\n\t\tcin >> m;\n\tif(m==0)\n\t\tbreak;\n\tcin >> n;\n\t\n\tfor(int i=0;i<260;i++)\n\t\tmass[i]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> mass[i];\n\t}\n\tfor(int i=0;i<260;i++)\n\tDP[i]=0;\n\tif(seach(a,0)==1)\n\t\tcout << \"OK\" << endl;\n\telse\n\t\tcout << \"NG\" << endl;\n\t\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int M, N;\n    int D[255];\n\n    while ( cin >> M, M ) {\n        int memo[255][555];\n\n        cin >> N;\n        for ( int i = 1; i <= N; i++ ) {\n            cin >> D[i];\n        }\n        D[0] = 0, D[N + 1] = 0;\n\n        memset ( memo, -1, sizeof( memo ) );\n\n        function < int(int, int) > dfs = [&]( int v , int num )\n        {\n            int ret = 0;\n            if ( num > 520 ) return ( 0 );\n            if ( memo[v][num] != -1 ) return ( 0 );\n            if ( v == N + 1 ) return ( 1 );\n\n            for ( int i = 1; i <= M && v + i <= N + 1; i++ ) {\n                int place = min( N + 1, max ( v + i + D[v + i], 0 ) ) ;\n                ret |= dfs ( place , num + 1);\n            }\n            return ( memo[v][num] = ret );\n        };\n\n        dfs ( 0 , 0 );\n\n        bool flag = true;\n        for ( int i = 0; i <= N + 1; i++ ) {\n            bool g = false, f = false;\n            for ( int j = 0; j < 520; j++ ) {\n                if ( memo[i][j] != -1 ) f = true;\n                if ( memo[i][j] == 1 ) {\n                    g = true;\n                }\n            }\n            if ( f && !g ) flag = false;\n        }\n        cout << ( flag ? \"OK\" : \"NG\" ) << endl;\n\n    }\n\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool used[2][N],ans;\n \nvoid dfs(int x,int idx){\n  if(used[idx][x])return;\n  used[idx][x]=true;\n  x+=d[x];\n  if(x<0)x=0;\n  if(n+1<x)x=n+1;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    dfs(nx,idx);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(used,0,sizeof(used));\n    ans=true;\n    dfs(0,0);\n    if(!used[0][n+1])ans=false;\n    for(int i=1;i<n+1;i++){\n      if(!used[0][i])continue;\n      for(int j=0;j<=n+1;j++)\n\tused[1][j]=false;\n      dfs(i,1);\n      if(!used[1][n+1])ans=false;\n    }\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <queue>\n\ntypedef long long ll;\n\n#define FOR(i,a,b)   for(ll i = (a); i < (b); i++ )\n#define REP(i, n)    FOR(i,0,n)\n#define fi first\n#define se second\nconst ll mod = 1000000007;\n//              123456789\n\nusing namespace std;\n \n\n///////////////////////////////////////////////\n//\n//\n///////////////////////////////////////////////\n\n////////////////////////////////////////////////\n////////////////////////////////////////////////\n\nint MAX;\nint N;\n\nint d[260];\nbool flag[260];\nbool ans[260];\nvector< int >r[260];\nint idx;\nint ch;\nint jdg;\nqueue< int >q;\n\n\nint main(){\n\t\n\twhile( cin>>MAX, MAX ){\n\t\tcin>>N;\n\t\t\n\t\tjdg = 1;\n\t\tfill( ans, ans+260, 1 );\n\t\tfill( d, d+260, 0 );\n\t\tfill( flag, flag+260, 1 );\n\t\tREP(i, 260) r[i].clear();\n\t\t\n\t\tREP(i, N) scanf(\"%d\", d+i+1);\n\t\tq.push(0);\n\t\tflag[0] = 0;\n\t\tflag[N+1] = 0;\t\n\t\t\n\t\twhile( !q.empty() ){\n\t\t\tidx = q.front();\n\t\t\tq.pop();\n\t\t\tFOR(i, 1, MAX+1){\n\t\t\t\tch = idx+i;\n\t\t\t\tif( ch > N ) ch = N+1;\n\t\t\t\tch += d[ch];\n\t\t\t\tif( ch > N ) ch = N+1;\n\t\t\t\tif( ch < 0 ) ch = 0;\n\t\t\t\tr[ch].push_back(idx);\n\t\t\t\tif( flag[ch] ){\n\t\t\t\t\tq.push(ch);\n\t\t\t\t\tflag[ch] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tq.push(N+1);\n\t\tans[N+1] = 0;\n\t\twhile( !q.empty() ){\n\t\t\tch = q.front();\n\t\t\tq.pop();\n\t\t\tREP(i, r[ch].size() ){\n\t\t\t\tidx = r[ch][i];\n\t\t\t\tif( ans[idx] ){\n\t\t\t\t\tans[idx] = 0;\n\t\t\t\t\tq.push(idx);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP( i, N+2 ){\n\t\t\tif( ans[i] && !flag[i] ) jdg = 0;\n\t\t\t//printf(\"%d-%d \", ans[i], flag[i]);\n\t\t}\n\t\t\n\t\tif( jdg ) puts(\"OK\");\n\t\telse{     puts(\"NG\");}\n\t\t\n\t}\n\t\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int max,n,data[255];\n  bool MAS[255][255];\n  while(1){\n    memset(MAS,false,sizeof(MAS));\n    cin >> max;\n    if(max==0)break;\n    cin >> n;\n    for(int i=1;i<=n;i++) cin >> data[i];\n    for(int j=0;j<=n;j++){\n      for(int i=1;i<=max && j+i<n+2;i++){\n\tj+i+data[i+j]>n+1 ? MAS[j][n+1]=true : MAS[j][j+i+data[i+j]]=true;\n      }\n    }\n\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n\tfor(int k=0;k<n+2;k++){\n\t  if(MAS[j][i]&&MAS[i][k]){\n\t    MAS[j][k]=true;\n\t  }\n\t}\n      }\n    }\n    bool flg=false;\n    for(int i=0;i<=n;i++){\n      if(MAS[0][i]&&(!MAS[i][n+1])){\n\tflg=true;\n\tbreak;\n      }\n    }\n    cout << (flg?\"NG\":\"OK\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nint m, n;\nint arr[300];\nint dist[300][300];\nbool ok[300];\n\nvoid dfs(int v)\n{\n\tok[v] = true;\n\tfor (int i = 1; i <= m; i++){\n\t\tint to = max(0, min(v + i, n + 1));\n\t\tto += arr[to];\n\t\tif (!ok[to]) dfs(to);\n\t}\n}\n\nstring solve()\n{\n\tfor (int i = 0; i <= n; i++){\n\t\tif (!ok[i]) continue;\n\t\tif (dist[i][n + 1] == INF) return \"NG\";\n\t}\n\treturn \"OK\";\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &m), m){\n\t\tfill_n(arr, 300, 0);\n\t\tfill_n(*dist, 300 * 300, INF);\n\t\tfill_n(ok, 300, false);\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &arr[i]);\n\t\t}\n\t\t\n\t\tdfs(0);\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 1; j <= m; j++){\n\t\t\t\tint to = max(0, min(i + j, n + 1));\n\t\t\t\tto += arr[to];\n\t\t\t\tdist[i][to] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k = 0; k <= n + 1; k++){\n\t\t\tfor (int i = 0; i <= n + 1; i++){\n\t\t\t\tfor (int j = 0; j <= n + 1; j++){\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint n,dmax;\nint m[300];\nbool visited[300], isVisit[300], isGoal;\nvoid dfs(int p){\n  if(visited[p])return ;\n  visited[p] = true;\n  isVisit[p] = true;\n  if(p == n+1){\n    isGoal = true;\n    return;\n  }\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;  \n    dfs(np);\n  }\n}\nvoid solve(){\n  memset(isVisit, 0, sizeof(isVisit));\n  isVisit[0] = true;\n  for(int i = 0 ; i <= n; i++){\n    if(!isVisit[i])continue;\n    isGoal = false;\n    memset(visited, 0, sizeof(visited));\n    dfs(i);\n    if(!isGoal)break;    \n  }\n  cout << (isGoal?\"OK\":\"NG\") << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    m[0] = 0;\n    int i;\n    for(i = 1 ; i < n+1 ;i++){\n      cin >> m[i];\n    }\n    m[i] = 0;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nbool solve(int mx, int n, int order[])\n{\n\tqueue<int> search;\n\tqueue<int> back[252];\n\n\tbool start[252];\n\tfor (int i = 0; i <= n + 1; i++) start[i] = false;\n\tstart[0] = true;\n\tsearch.push(0);\n\twhile (!search.empty()){\n\t\tint now = search.front();\n\t\tsearch.pop();\n\t\tfor (int i = 1; i <= mx; i++){\n\t\t\tint next;\n\t\t\tif (now + i <= 0) continue;\n\t\t\telse if (now + i > n + 1) next = n + 1;\n\t\t\telse if (now + i + order[now + i] <= 0) continue;\n\t\t\telse if (now + i + order[now + i] > n + 1) next = n + 1;\n\t\t\telse next = now + i + order[now + i];\n\t\t\tback[next].push(now);\n\t\t\tif (start[next]) continue;\n\t\t\tstart[next] = true;\n\t\t\tsearch.push(next);\t\t\t\n\t\t}\n\t}\n\tif (!start[n + 1]) return false;\n\t\n\tbool goal[252];\n\tfor (int i = 0; i <= n + 1; i++) goal[i] = false;\n\tgoal[n + 1] = true;\t\n\tsearch.push(n + 1);\n\twhile (!search.empty()){\n\t\tint now = search.front();\n\t\tsearch.pop();\n\t\twhile (!back[now].empty()){\n\t\t\tint from = back[now].front();\n\t\t\tback[now].pop();\n\t\t\tif (goal[from]) continue;\n\t\t\tgoal[from] = true;\n\t\t\tsearch.push(from);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n + 1; i++){\n\t\tif (start[i] && !goal[i]) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile (true){\n\t\tint mx;\n\t\tcin >> mx;\n\t\tif (!mx) break;\n\t\tint n, order[252];\n\t\tcin >> n;\n\t\torder[0] = order[n + 1] = 0;\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tcin >> order[i];\n\t\t}\n\t\tif (solve(mx, n, order)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q1,q2;\n    q1.push(0);\n    bool c=true;\n    while(!q1.empty()){\n      b=q1.front();q1.pop();\n      if(r[b]) continue;\n      r[b]=true;\n      q2.push(b);\n      //cout << b << endl;\n      fill(used,used+300,false);\n      while(!q2.empty()){\n\tp=q2.front();q2.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(p>n+1){\n\t  used[n+1]=true;\n\t  break;\n\t}\n\tif(used[p]) continue;\n\tused[p]=true;\n\tq1.push(p);\n\tfor(i=1;i<=m;i++){\n\t  //cout <<p<<\":\"<< i <<\":\"<<p+i+d[p+i]<< endl;\n\t  if(p+i+d[p+i]>n+1){\n\t    used[n+1]=true;\n\t    break;\n\t  }else q2.push(p+i+d[p+i]);\n\t}\n      }\n      if(!used[n+1]){\n\tc=false;\n\tbreak;\n      }\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define N 333\nint max_masu,n;\nint d[N],flag[N];\nusing namespace std;\nint solve(int i){\n  int ret = 0;\n  if(i>n)return 0;\n  if(i<0)i=0;\n  //printf(\"%d %d\\n\",i,flag[i]);\n  if(flag[i] == 1)return 1;\n  for(int j=1;j<=max_masu;j++){\n    flag[i] = 1;\n    ret += solve(i+j+d[i+j]);\n    flag[i] = 0;\n  }\n  return ret;\n}\nint main(){\n  while(1){\n    cin >> max_masu;\n    if(!max_masu)break;\n    cin >> n;\n    memset( d, 0 , sizeof(d));\n    memset( flag , 0 , sizeof(flag) );\n    for(int i=0;i<n;i++){\n      cin >> d[i];\n    }\n    int ret = 0;\n    for(int i=0;i<n;i++){\n      ret += solve( i );\n     //cout << ret << endl;\n    }\n    printf(\"%s\\n\",(ret == 0)? \"OK\" : \"NG\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nvector<int> g[300];\nbool go[300], ba[300];\n\nvoid iki(int x)\n{\n\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n + 1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif(y<0) y==0;\n\t\t\tif (y>=0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool jd[600];\nbool td[600];\nint maxnum;\nint n;\nint d[600];\nbool ans(int pos){\n\tif(td[pos]==1){\n\t\treturn true;\n\t}\n\ttd[pos]=1;\n\tif(pos<0)pos=0;\n\tbool res=true;\n\tif(pos>n){\n\t\treturn true;\n\t}else if(jd[pos]==0){\n\t\treturn false;\n\t}else{\n\t\tfor(int i=1;i<maxnum+1;i++){\n\t\t\tif(ans(pos+i+d[pos+i])==false){\n\t\t\t\tres=false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid set(){\n\tfor(int i=n;i>-1;i--){\n\t\tfor(int j=1;j<maxnum+1 && jd[i]==0;j++){\n\t\t\tif(i+j>n){\n\t\t\t\tjd[i]=1;\n\t\t\t}else if(jd[i+j+d[i+j]]==1){\n\t\t\t\tjd[i]=1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\twhile(cin>>maxnum,maxnum){\n\t\tcin>>n;\n\t\td[0]=0;\n\t\tjd[0]=1;\n\t\tfor(int i=0;i<600;i++){\n\t\t\td[i]=jd[i]=td[i]=0;\n\t\t}\n\t\tfor(int i=1;i<n+1;i++){\n\t\t\tcin>>d[i];\n\t\t}\n\t\tset();\n\t\tif(ans(0)){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 260;\nconst int INF = 1e9;\n\n\nbool G[MAX_N][MAX_N];\nint M, N;\n\nvoid dfs(int n, vector<bool> &visited){\n  visited[n] = true;\n  REP(i, N + 2){\n    if(!G[n][i] || visited[i]) continue;\n    dfs(i, visited);\n  }\n}\n\nint main(){\n  while(cin >>M && M){\n    memset(G, 0, sizeof(G));\n    cin >>N;\n    FOR(i, 1, M + 1) G[0][min(N + 1, i)] = true;\n    FOR(i, 1, N + 1){\n      int d; cin >>d;\n      if(d != 0) G[i][min(N + 1, max(0, i + d))] = true;\n      else FOR(j, 1, M + 1) G[i][min(N + 1, i + j)] = true;\n    }\n    bool f = true;\n    REP(i, N + 1){\n      vector<bool> visited(N + 2, false);\n      dfs(i, visited);\n      if(!visited[N + 1]) f = false;\n    }\n    cout <<(f ? \"OK\" : \"NG\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int M, N;\n    int D[255];\n\n    while ( cin >> M, M ) {\n        bool road[255];\n        bool flag[255] = {};\n\n        cin >> N;\n        for ( int i = 1; i <= N; i++ ) {\n            cin >> D[i];\n        }\n        D[0] = 0, D[N + 1] = 0;\n\n        function < bool(int) > dfs = [&]( int v )\n        {\n            bool ret = 0;\n            if ( flag[v] ) return ( false );\n            flag[v] = true;\n            if ( v == N + 1 ) return ( true );\n\n            for ( int i = 1; i <= M && v + i <= N + 1; i++ ) {\n                int place = min( N + 1, max ( v + i + D[v + i], 0 ) ) ;\n                ret |= dfs ( place );\n            }\n            return ( ret );\n        };\n\n        dfs ( 0 );\n        for ( int i = 0; i <= N + 1; i++ ) {\n            road[i] = flag[i];\n        }\n\n        bool is_agari = true;\n        for ( int i = 0; i <= N; i++ ) {\n            fill_n ( flag, 255, false );\n            if ( road[i] && !dfs(i) ) {\n                is_agari = false;\n            }\n        }\n\n        cout << (is_agari ? \"OK\" : \"NG\") << endl;\n\n    }\n\n    return ( 0 );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int max,n,data[255];\n  bool MAS[255][255];\n  while(1){\n    memset(MAS,false,sizeof(MAS));\n    cin >> max;\n    if(max==0)break;\n    cin >> n;\n    for(int i=1,a;i<=n;i++) cin >> data[i];\n    for(int j=0;j<=n;j++){\n      for(int i=1;i<=max && j+i<n+2;i++){ \n        j+i+data[i]>n+1 ? MAS[j][n+1] : MAS[j][j+i+data[i]]=true;\n      }\n    }\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n\tfor(int k=0;k<n+2;k++){\n\t  if(MAS[j][i]&&MAS[i][k]){\n\t    MAS[j][k]=true;\n\t  }\n\t}\n      }\n    }\n    bool flg=false;\n    for(int i=0;i<=n;i++){\n      if(MAS[0][i]&&(!MAS[i][n+1])){\n\tflg=true;\n\tbreak;\n      }\n    }\n    cout << (flg?\"NG\":\"OK\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_N = 300;\nint maxi,n,d[MAX_N];\nint state[MAX_N];\n\nint main(){\n  while( cin >> maxi, maxi ){\n    cin >> n;\n    REP(i,1,n+1) cin >> d[i];\n    n += 2;\n    rep(i,n) state[i] = -1;\n    state[n-1] = 1;\n    bool update = true;\n    while( update ){\n      update = false;\n      rep(cur,n-1) if( state[cur] == -1 ) {\n        bool success = true;\n        int cnt = 0;\n        REP(i,1,maxi+1){\n          int next = min( cur + i, n - 1 );\n          next += d[next];\n          next = min(next,n-1);\n          next = max(next,0);\n          if( next == cur ) continue;\n          if( state[next] == -1 ) { success = false; break; }\n          ++cnt;\n        }\n        if( cnt && success ) {\n          state[cur] = 1;\n          update = true;\n          break;\n        }\n      }\n    }\n    //REP(i,1,maxi+1) cout << state[i] << \" \"; cout << endl;\n    puts((state[0]==1)?\"OK\":\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define MAX_N 300\nint m,n;\nint arr[MAX_N];\nint visited[MAX_N];\nint visited2[MAX_N];\n\nvoid init();\nvoid rec(int);\nint solve(int);\n\nint main(){\n  int i,j,a,b;\n  while(1){\n    init();\n    scanf(\"%d\",&m);\n    if(m==0)break;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n      scanf(\"%d\",&a);\n      b=i+a;\n      if(b<0)b=0;\n      if(b>n+1)b=n+1;\n      arr[i]=b;\n    }\n    for(i=0;i<=n+1;i++){\n      if(arr[i]==n+1)rec(i);\n    }\n    /*\n    for(i=0;i<=n+1;i++){\n      printf(\"%d \",visited[i]);\n    }\n    printf(\"\\n\");\n    */\n    if(solve(0))printf(\"NG\\n\");\n    else printf(\"OK\\n\");\n  }\n  return 0;\n}\n\nint solve(int pos){\n  if(visited2[pos])return 0;\n  visited2[pos]=1;\n  if(!visited[pos])return 1;\n  int i,a;\n  for(i=1;i<=m;i++){\n    a=pos+i;\n    if(a>=n+1)break;\n    a=arr[a];\n    if( solve(a) )return 1;\n  }\n  return 0;\n}\n\nvoid rec(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  int i,j,a;\n  for(i=1;i<=m;i++){\n    a=pos-i;\n    if(a<0)break;\n    for(j=0;j<=n+1;j++){\n      if(arr[j]==a)rec(j);\n    }\n  }\n}\n\nvoid init(){\n  int i,j;\n  for(i=0;i<MAX_N;i++){\n    arr[i]=i;\n    visited[i]=0;\n    visited2[i]=0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint limit,V,d[300],n;\n\nint main(){\n  while( cin >> limit, limit ){\n    cin >> n;\n    V = n + 2;\n    d[0] = d[V-1] = 0;\n    rep(i,n) cin >> d[i+1];\n    vector<vector<int> > G(V);\n    rep(i,V-1) {\n      if( d[i] == 0 ) {\n        REP(j,1,limit+1) {\n          int next = i + j;\n          if( next >= V ) break;\n          if( i != next ) G[i].push_back(next);\n        }\n      } else {\n        int next = i + d[i];\n        if( next <  0 ) next = 0;\n        if( next >= V ) next = V-1;\n        if( i != next ) G[i].push_back(next);\n      }\n    }\n    vector<bool> used(V,false);\n    used[0] = true;\n    deque<int> deq;\n    deq.push_back(0);\n    while( !deq.empty() ){\n      int cur = deq.front(); deq.pop_front();\n      rep(i,G[cur].size()){\n        int next = G[cur][i];\n        if( !used[next] ) {\n          used[next] = true;\n          deq.push_back(next);\n        }\n      }\n    }\n    bool ok = true;\n    rep(i,V) if( !used[i] ) { ok = false; break; }\n    puts(ok?\"OK\":\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\n\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-10;\n\nll n;\nll h[112];\n\nint main() {\n\t\n\twhile (cin >> n, n) {\n\t\tREP(i, n + 1) scanf(\"%lld\", h + i);\n\t\t\n\t\tll A, D;\n\t\tREP(i, 5) {\n\t\t\tvector<ll> v;\n\t\t\tREP(j, 5) if (i != j) v.push_back(h[j]);\n\t\t\tif (v[1] - v[0] == v[2] - v[1] && v[2] - v[1] == v[3] - v[2]) D = v[1] - v[0];\n\t\t}\n\t\t\n\t\tREP(i, 5) {\n\t\t\tvector<ll> v;\n\t\t\tREP(j, 5) if (i != j) v.push_back(h[j]);\n\t\t\tif (v[0] + D == v[1] && v[0] + 2 * D == v[2] && v[0] + 3 * D == v[3]) A = v[0];\n\t\t}\n\t\t\n\t\tll SUM = (ll)n * (A + A + D * (n - 1)) / 2;\n\t\tll sum = 0;\n\t\tREP(i, n + 1) sum += h[i];\n\t\t\n\t\tcout << sum - SUM << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\nint m,n;\nint d[500];\nint dp[500][500];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&m);\n\t\tif(m==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d\",&d[i]);\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(d[i+j]==0)dp[i][i+j]=1;\n\t\t\t\tif(d[i+j]>=1)dp[i][min(i+j+d[i+j],n+1)]=1;\n\t\t\t\tif(d[i+j]<=-1)dp[i][max(0,i+j+d[i+j])]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<=n+1;k++){\n\t\t\tfor(int i=0;i<=n+1;i++){\n\t\t\t\tfor(int j=0;j<=n+1;j++){\n\t\t\t\t\tif(dp[i][k]==1 && dp[k][j]==1)dp[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=true,f2=false;\n\t\t/*\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tfor(int j=0;j<=n+1;j++)printf(\"%d%c\",dp[j][i],j==n+1?'\\n':' ');\n\t\t}\n\t\t*/\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(dp[0][i]==1 && dp[i][n+1]==0)f=false;\n\t\t\tif(dp[0][i]==1 && dp[i][n+1]==1)f2=true;\n\t\t}\n\t\tif(f && f2)puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n\nusing namespace std;\nint maxCount, n;\nvector<int> kouka;\nint memo[252];//251があがり0がふりだし\nint passed[252];\n\nconst int AGARI = 100000;\n\nbool dfs(int index)\n{\n\tif(passed[index]) return false;\n\tpassed[index] = true;\n\n\tindex = min(n + 1, max(0 ,kouka[index] + index));\n\tif(kouka[index] == AGARI) return true;\n\tfor (int i = 1; i <= maxCount; i++)\n\t{\n\t\tint next = index + i;\n\t\tif(memo[next])\n\t\t\tif(memo[next] = dfs(next))\n\t\t\t\treturn true;\n\t}\n\n\tpassed[index] = false;\n\treturn false;\n}\n\nbool solve()\n{\n\tfor (int i = 1; i <= maxCount; i++)\n\t{\n\t\tif(dfs(i)) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> maxCount && maxCount)\n\t{\n\t\tcin >> n;\n\t\tkouka.resize(n + 2);\n\t\tkouka[0] = -1;//ふりだし\n\t\tfor (int i = 1; i < n + 1; i++)\n\t\t{\n\t\t\tcin >> kouka[i];\n\t\t}\n\t\tkouka[n + 1] = AGARI;//あがり\n\t\tmemset(memo, true, sizeof(memo));\n\t\tmemset(passed, false, sizeof(memo));\n\t\tcout << (solve()? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nclass State {\npublic:\n  int x;\n  int cost;\n  State(int x,int cost)\n    : x(x), cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int max_roulette_num;\n  while(~scanf(\"%d\",&max_roulette_num)){\n    if(max_roulette_num == 0) break;\n\n    int stage[320] = {};\n    int total_cells;\n    scanf(\"%d\",&total_cells);\n    for(int i = 0; i < total_cells; i++){\n      int cell;\n      scanf(\"%d\",&cell);\n      stage[i+1] = cell;\n    }\n    stage[0] = 0;\n    stage[total_cells + 1] = 0;\n    \n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(0,0));\n    int dp[320];\n    memset(dp,0x3f,sizeof(dp));\n    dp[0] = 0;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int i = 1; i <= max_roulette_num; i++){\n        int next = s.x + i;\n        if(next > total_cells + 1) continue;\n        next += stage[next];\n        if(dp[next] <= s.cost + 1) continue;\n        dp[next] = s.cost + 1;\n        que.push(State(next,s.cost + 1));\n      }\n    }\n    vector<int> starts;\n    for(int i = 0; i <= total_cells + 1; i++){\n      if(dp[i] < INF) starts.push_back(i);\n    }\n\n    bool has_unable = false;\n    for(int start_i = 0; start_i < starts.size(); start_i++){\n      int start = starts[start_i];\n      memset(dp,0x3f,sizeof(dp));\n\n      que.push(State(start,0));\n      dp[start] = 0;\n      while(!que.empty()){\n        State s = que.top();\n        que.pop();\n        for(int i = 1; i <= max_roulette_num; i++){\n          int next = s.x + i;\n          if(next > total_cells + 1) continue;\n          next += stage[next];\n          if(dp[next] <= s.cost + 1) continue;\n          dp[next] = s.cost + 1;\n          que.push(State(next,s.cost + 1));\n        }\n      }\n\n      if(dp[total_cells + 1] >= INF){\n        has_unable = true;\n        break;\n      }\n    }\n    \n    printf(\"%s\\n\", has_unable ? \"NG\" : \"OK\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 300\n\nint main()\n{\n    int mx, n;\n    while (cin >> mx, mx) {\n        cin >> n;\n        vector<int> v(n+2, 0);\n        for (int i = 1; i <= n; i++) {\n            cin >> v[i];\n        }\n        bool visited[MAX] = {0};\n        visited[0] = 1;\n        queue<int> Q;\n        Q.push(0);\n\n        while (!Q.empty()) {\n            int now = Q.front(); Q.pop();\n            if (now == n+1) {\n                continue;\n            }\n\n            for (int i = 1; i <= mx; i++) {\n                int next = min(n+1, now+i);\n                next += v[next];\n                if (next < 0) {\n                    next = 0;\n                } else if (next > n+1) {\n                    next = n+1;\n                }\n                if (!visited[next]) {\n                    visited[next] = 1;\n                    Q.push(next);\n                }\n            }\n        }\n        bool reachable = 1;\n        for (int i = 0; i <= n; i++) {\n            if (!visited[i]) {              \n                continue;\n            }\n            bool ng = 1, visited2[MAX] = {0};\n            queue<int> Q2; Q2.push(i);\n            visited2[i] = 1;\n            while (!Q2.empty()) {\n                int now = Q2.front(); Q2.pop();\n                if (now == n+1) {\n                    ng = 0;\n                    break;\n                }\n                for (int i = 1; i <= mx; i++) {\n                    int next = min(n+1, now+i);\n                    next += v[next];\n                    if (next < 0) {\n                        next = 0;\n                    } else if (next > n+1) {\n                        next = n+1;\n                    }\n                    if (!visited2[next]) {\n                        visited2[next] = 1;\n                        Q2.push(next);\n                    }\n                }\n            }\n            if (ng) {\n                reachable = 0;\n                break;\n            }\n        }\n        cout << (reachable && visited[n+1] ? \"OK\" : \"NG\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 300\n\nint main()\n{\n    int mx, n;\n    while (cin >> mx, mx) {\n        cin >> n;\n        vector<int> v(n+2, 0);\n        for (int i = 1; i <= n; i++) {\n            cin >> v[i];\n        }\n        bool visited[MAX] = {0};\n        visited[0] = 1;\n        queue<int> Q;\n        Q.push(0);\n\n        while (!Q.empty()) {\n            int now = Q.front(); Q.pop();\n            if (now == n+1) {\n                continue;\n            }\n            for (int i = 1; i <= mx; i++) {\n                int next = min(n+1, now+i);\n                next += v[next];\n                if (next < 0) {\n                    next = 0;\n                } else if (next > n+1) {\n                    next = n+1;\n                }\n                if (!visited[next]) {\n                    visited[next] = 1;\n                    Q.push(next);\n                }\n            }\n        }\n        bool reachable = 1;\n        for (int i = 0; i <= n; i++) {\n            if (!visited[i]) {\n                continue;\n            }\n            bool ng = 1;\n            for (int j = 1; j <= mx; j++) {\n                int k = min(n+1, i+j);\n                k += v[k];\n                if (k < 0) {\n                    k = 0;\n                } else if (k > n+1) {\n                    k = n+1;\n                }\n                if (k > i) {\n                    ng = 0;\n                    break;\n                }\n            }\n            if (ng) {\n                reachable = 0;\n                break;\n            }\n        }\n        cout << (reachable && visited[n+1] ? \"OK\" : \"NG\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint main(){\n    int ma;\n    while(scanf(\"%d\",&ma),ma){\n        int n;\n        int stage[256];\n        int D[256][256]={{0}};\n        scanf(\"%d\",&n);\n        rep(i,n+2){\n            rep(j,n+2){\n                if(i == j)D[i][j] = 0;\n                else D[i][j] = INF;\n            }\n        }\n        reps(i,1,n+1){\n            scanf(\"%d\",&stage[i]);\n        }\n        rep(i,n+1){\n            if(stage[i]){\n                int tmp = i+stage[i];\n                if(tmp < 0)tmp = 0;\n                if(tmp > n+1)tmp = n+1;\n                D[i][tmp] = 1;\n            }\n            else{\n                rep(j,ma+1){\n                    int tmp = i+j;\n                    if(tmp > n+1)tmp = n+1;\n                    D[i][tmp] = 1;\n                }\n            }\n        }\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    D[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n                }\n            }\n        }\n        /*puts(\"--------------------------\");\n        rep(i,n+2){\n            rep(j,n+2){\n                if(D[i][j] >= INF)printf(\"M \");\n                else printf(\"%d \",D[i][j]);\n            }\n            puts(\"\");\n        }\n        puts(\"--------------------------\");*/\n        bool flg = !(D[0][n+1]>=INF);\n        flg ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * src.cpp\n *\n *  Created on: 2016/08/09\n *      Author: joi\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_N=250,MAX_MAX=250;\n\nint MAX,N,D[MAX_N+MAX_MAX+8];\n\nbool flg[2][MAX_N+2];\n\nvector<int> G[2][MAX_N+2];\n\nvoid bfs(){\n\tREP(r,2){\n\t\tREP(i,N+2){\n\t\t\tflg[r][i]=false;\n\t\t}\n\t\tint s= !r ? 0 : N+1;\n\t\tflg[r][s]=true;\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\twhile (!q.empty()){\n\t\t\tint v=q.front();\n\t\t\tq.pop();\n\t\t\tREP(i,(int)G[r][v].size()){\n\t\t\t\tint to=G[r][v][i];\n\t\t\t\tif (!flg[r][to]){\n\t\t\t\t\tflg[r][to]=true;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tdo{\n\t\tcin>>MAX;\n\t\tif (MAX){\n\t\t\tcin>>N;\n\t\t\tmemset(D,0,sizeof(D));\n\t\t\tFOR(i,1,N+1){\n\t\t\t\tcin>>D[i];\n\t\t\t}\n\t\t\tREP(i,2) REP(j,N+2) G[i][j].clear();\n\t\t\tREP(i,N+1){\n\t\t\t\tFOR(j,1,MAX+1){\n\t\t\t\t\tint to=i+j+D[i+j];\n\t\t\t\t\tto=max(to,0);\n\t\t\t\t\tto=min(to,N+1);\n\t\t\t\t\tG[0][i].push_back(to);\n\t\t\t\t\tG[1][to].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbfs();\n\t\t\tbool f=true;\n\t\t\tREP(i,N+2){\n\t\t\t\tif (flg[0][i] && !flg[1][i]){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}while(MAX);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nnamespace MGraph{\n\ttypedef int Cost;Cost CINF=1<<28;\n\ttypedef  vector<vector<Cost> > Mat;\n}\nnamespace ShortestPath{\n    using namespace MGraph;\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\n\nCost INF=1<<28;\n\nclass Main{\npublic:\n\n\tvoid run(){\n\t\twhile(true){\n\t\t\tint M;cin >> M;if(M==0)break;\n\t\t\tint n;cin >> n;\n\t\t\tvector<int> ds(n+2);REP(i,n) cin >> ds[i+1];\n\t\t\t\n\t\t\tMat g(n+2,vector<Cost>(n+2,INF));\n\t\t\tREP(i,n+2){\n\t\t\t\tfor(int r=1;r<=M;r++){\n\t\t\t\t\tint npos=min(i+r,n+1);\n\t\t\t\t\tnpos+=ds[npos];npos=max(npos,0);npos=min(npos,n+1);\n\t\t\t\t\tg[i][npos]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twarshall_floyd(g);\n\t\t\tbool ok=true;\n\t\t\tREP(i,n+2)if(g[i][n+1]>=INF)ok=false;\n\t\t\tcout << (ok?\"OK\":\"NG\")<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint m,n;\nint mass[252]={};\nbool DP[252]={};\nint seach(vector<int> walked,int now){\n\tif(now>n)\n\t\treturn 1;\n\tnow=max(0,now);\n\tfor(int i=0;i<walked.size();i++){\n\t\tif(now==walked[i])\n\t\treturn -i-1;\n\t}\n\twalked.push_back(now);\n\tint maxer=-9999;\n\tfor(int i=1;i<=m;i++){\n\t\tint first=now+i;\n\t\tint second=first+mass[first];\n\t\tmaxer=max(maxer,seach(walked,second));\n\t}\n\tif(walked.size()==-maxer)\n\tmaxer=2;\n\treturn maxer;\n\t\n}\n\nint main() {\n\t// your code goes here\n\tvector<int> a;\n\twhile(cin >> m){\n\tif(m==0)\n\t\tbreak;\n\tcin >> n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> mass[i];\n\t}\n\tif(seach(a,0)==1)\n\t\tcout << \"OK\" << endl;\n\telse\n\t\tcout << \"NG\" << endl;\n\t\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define MN 252\n\nvector<int> G[MN];\n\nint max_, n_, D[MN];\nbool init() {\n    cin >> max_; \n    if (max_ == 0) return false;\n    cin >> n_;\n    D[0] = D[n_+1] = 0;\n    for (int i = 1; i <= n_; i++) cin >> D[i];\n    return true;\n}\n\nbool v[MN];\nint next(int n) {\n    n = max(0, min(n_+1, n));\n    if (v[n]) return -1;\n    v[n] = true;\n    if (D[n] == 0) return n;\n    return next(n + D[n]);\n}\n\nvoid solve() {\n    queue<int> Q;\n    Q.push(0);\n    bool v1[MN]; for (int i = 0; i < MN; i++) v1[i] = false;\n    while (!Q.empty()) {\n        int n = Q.front(); Q.pop();\n        v1[n] = true;\n        for (int i = 1; i <= max_; i++) {\n            memset(v, 0, sizeof(v));\n            int nxt = next(n+i);\n            if (nxt < 0) {\n                cout << \"NG\" << endl;\n                return;\n            }\n            if (!v1[nxt]) {\n                Q.push(nxt);\n            }\n        }\n    }\n    cout << (v1[n_+1] ? \"OK\" : \"NG\") << endl;\n}\n\nint main() {\n    while (init()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint t[252],f[252],g[252],n,m;\nint hantei(int x) {\n\tint i,j,c=1,a;\n\tfor (i=0;i<=n+1;i++) f[i]=0; f[x]=1; c=1;\n\twhile(c==1) {\n\tc=0;\t\n\tfor (i=0;i<=n && c<2;i++) {\n\t\tif (f[i]==1) {\n\t\t\tfor (j=i+1;j<=i+m;j++) {\n\t\t\t\ta=j+t[j];\n\t\t\t\tif (a<0) a=0; if (a>=n+1) { c=2; break;}\n\t\t\t\tif (f[a]==0) { f[a]=1; c=1;}\n\t\t\t}\n\t\t\tf[i]=2;\n\t\t}\n\t  }\n  }\n  return c;\t\n  }\nint main() {\nint i,c;\n while(cin >> m && m!=0) {\n\t cin >> n;\n\t for (i=1;i<=n;i++) cin >> t[i];\n\t c=hantei(0);\n\t if (c==0) { cout << \"NG\" << endl; continue;}\n\t for (i=1;i<=n;i++) g[i]=f[i];\n\t for (i=1,c=2;i<=n;i++) if (g[i]>0) { c=hantei(i);\t if (c==0) break;}\n\t if (c==0) cout << \"NG\"; else cout << \"OK\";\n\t cout << endl;\n\t} \t\t\t   \n return 0;\n } "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\n//再帰flag変数\nbool flag_sugoroku[251] = {false};\n\n//入力配列\nint h_input[251] = {0};\n\n//入力変数\nint n = 0;\n//マスの数\nint masu = 0;\n\t\n\n//-- flag初期化関数 --//\n\nvoid f_syokika();\n\n\n//-- 再起関数 --//\n\nbool f_saiki(int , int);\n\n\n\nint main(void)\n{\n\twhile (cin >> n && n != 0)\n\t{\n\t\tcin >> masu;\n\t\t//成功flag\n\t\tbool ok = false;\n\n\t\tfor (int i = 0; i < masu; i++)\n\t\t{\n\t\t\tcin >> h_input[i];\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\t//必ず初期化が必要\n\t\t\tf_syokika();\n\t\t\tif (f_saiki(i , h_input[i]) == true)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\t\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n\n//*****----- flag初期化関数 -----*****//\n\nvoid f_syokika()\n{\n\tfor (int i = 0; i < 251; i++)\n\t{\n\t\tflag_sugoroku[i] = false;\n\t}\n}\n\n\n//*****----- 再起関数 -----*****//\n\nbool f_saiki(int index , int genzaiti)\n{\n\tif (index >= masu)\n\t{\n\t\treturn false;\n\t}\n\n\t//振り出しはいらない\n\tif (genzaiti < 0)\t{\treturn false;\t}\n\n\t//マスを超えていたらOK\n\tif (genzaiti >= masu)\t{\treturn true;\t}\n\n\t//既にきているなら駄目\n\tif (flag_sugoroku[genzaiti] == true)\n\t{\n\t\t//return false;\n\t}\n\n\t//現在地に到達\n\tflag_sugoroku[genzaiti] = true;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tf_saiki(index + 1 , genzaiti + h_input[i]);\n\t}\n\n\t//来てないことにする\n\tflag_sugoroku[genzaiti] = false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nint main(){\n\tint max,n;\n\tint e[10000];\n\tbool tizu[100][100];bool flag = false;\n\twhile(cin >> max,max){\n\tmemset(tizu,false,sizeof(tizu));\n\tflag = false;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> e[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=1;j<=max;j++){\n\t\t\tif(i+j+e[i+j]>=n+1) tizu[i][n+1] = true;\n\t\t\telse if(i+j+e[i+j]<=0) tizu[i][0] = true;\n\t\t\telse tizu[i][i+j+e[i+j]] = true;\n\t\t}\n\t}\n\tfor(int k=0;k<n+1;k++){\n\t\tfor(int i=0;k<n+1;k++){\n\t\t\tfor(int j=0;j<n+1;j++){\n\t\t\t\tif(tizu[i][k] && tizu[k][j]) tizu[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=max;i++){\n\t\tif(tizu[0][i] && !tizu[i][n+1]) flag = true;\n\t}\n\t(flag ? cout << \"NG\" : cout << \"OK\");\n\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define MAX_N 300\nint m,n;\nint arr[MAX_N];\nint visited[MAX_N];\nint visited2[MAX_N];\nint flag[MAX_N];\n\nvoid init();\nvoid rec(int);\nint solve(int);\n\nint main(){\n  int i,j,a,b;\n  while(1){\n    init();\n    scanf(\"%d\",&m);\n    if(m==0)break;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n      scanf(\"%d\",&a);\n      b=i+a;\n      if(b<0)b=0;\n      if(b>n+1)b=n+1;\n      arr[i]=b;\n    }\n    for(i=0;i<=n+1;i++){\n      if(arr[i]==n+1)rec(i);\n    }\n\n    if(solve(0))printf(\"NG\\n\");\n    else printf(\"OK\\n\");\n  }\n  return 0;\n}\n\nint solve(int pos){\n  if(visited2[pos])return 0;\n  visited2[pos]=1;\n  if(!flag[pos])return 1;\n  int i,a;\n  for(i=1;i<=m;i++){\n    a=pos+i;\n    if(a>=n+1)break;\n    a=arr[a];\n    if( solve(a) )return 1;\n  }\n  return 0;\n}\n\nvoid rec(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  int i,j,a;\n  for(i=1;i<=m;i++){\n    a=pos-i;\n    if(a<0)break;\n    flag[a]=1;\n    for(j=0;j<=n+1;j++){\n      if(arr[j]==a)rec(j);\n    }\n  }\n}\n\nvoid init(){\n  int i,j;\n  for(i=0;i<MAX_N;i++){\n    arr[i]=i;\n    visited[i]=0;\n    visited2[i]=0;\n    flag[i]=0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint maxi, n;\nint d[256];\nbool mas[256];\n\nvoid dfs1(int x)\n{\n  if(mas[x]) return;\n  mas[x] = true;\n  for(int i = 1; i <= maxi; i++){\n    dfs1(max(0, min(x + i + d[max(0, min(x + i, n+1))], n+1)));\n  }\n}\n\nvoid dfs2(int x)\n{\n  if(!mas[x]) return;\n  mas[x] = false;\n  if(d[x] != 0) return;\n  for(int i = 1; i <= maxi; i++){\n    dfs2(max(0, min(x - i, n+1)));\n  }\n}\n\nbool check()\n{\n  for(int i = 1; i <= n; i++){\n    if(mas[i]) return false;\n  }\n  return true;\n}\n\nint main()\n{\n  while(cin >> maxi, maxi){ \n    cin >> n;\n    memset(mas, false, sizeof(mas));\n    memset(d, 0, sizeof(d));\n    for(int i = 1; i <= n; i++) cin >> d[i];\n    dfs1(0);\n    if(check()) cout << \"NG\" << endl;\n    else {\n      dfs2(n+1);\n      cout << (check() ? \"OK\" : \"NG\") << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//同じマスにつくなら早いほうが良い。という考えでいく。ゴールにつく前に更新が終わってしまえば、そこからはゴールにたどり着けない(と思う…)\n\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nint MAX,N,masu[252];\t//0:ふりだし,N+1:あがり\nint cango[2][252];\t\t\t//0スタートで行けるマス(この中で無限ループするものがあるのかを考える)\nint totatu[2][252];\t\t//到達したかのフラグ(一回調べたマスはもう調べなくて良い。結果は同じだから).0:ルーレット回す前に到達,1:ルーレット回した後到達\n\nchar *ans[100],cor = 0;\n\nbool Dijkstra(int left){\n\tqueue<int> que;\n\tint now;\n\tque.push(left);\n\twhile(!que.empty()){\n\t\tnow = que.front();\n\t\tque.pop();\n\t\tif(totatu[0][N+1] > 0 || totatu[1][N+1] > 0)\n\t\t\tbreak;\n\t\tif(totatu[0][now] >= 2 && totatu[1][now] >= 2)\n\t\t\tcontinue;\n\t\tif(totatu[1][now] == 1){\n\t\t\tint go = now+masu[now];\n\t\t\tif(go < 0)go = 0;\n\t\t\tif(go > MAX+1)go = MAX+1;\n\t\t\tif(go != now && totatu[0][go] == 0){\n\t\t\t\tque.push(go);\n\t\t\t\ttotatu[0][go] = 1;\n\t\t\t}\n\t\t\ttotatu[1][now]++;\n\t\t}\n\t\tif(totatu[0][now] == 1){\n\t\t\tfor(int i = now+1;i <= now+MAX && i <= N+1;i++){\n\t\t\t\tif(totatu[1][i] == 0){\n\t\t\t\t\ttotatu[1][i] = 1; \n\t\t\t\t\tque.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttotatu[0][now]++;\n\t\t}\n\t}\n\tif(totatu[0][N+1] > 0 || totatu[1][N+1] > 0)\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\tint i;\n\twhile(cin >> MAX){\n\t\tif(MAX == 0)break;\n\t\tcin >> N;\n\t\tfor(i = 1;i <= N;i++){\n\t\t\tcin >> masu[i];\n\t\t}\n\t\tmasu[N+1] = 0;\n\t\tfor(i = 0;i <= N+1;i++){\n\t\t\ttotatu[0][i] = 0;\n\t\t\ttotatu[1][i] = 0;\n\t\t\tcango[0][i] = 0;\n\t\t\tcango[1][i] = 0;\n\t\t}\n\t\t//幅優先探索\n\t\tbool flag;\n\t\ttotatu[0][0] = 1;\n\t\tflag = Dijkstra(0);\t//マス0からのスタートで行けるマスとか…到達できるかとか…\n\t\tif(flag == false){\n\t\t\tans[cor] = \"NG\";\n\t\t\tcor++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 1;i <= N;i++){\n\t\t\tif(totatu[0][i])\n\t\t\t\tcango[0][i] = 1;\n\t\t\t//if(totatu[1][i])\n\t\t\t//\tcango[1][i] = 1;\n\t\t}\n\t\tfor(i = 1;i <= N;i++){\n\t\t\tif(cango[0][i] == 1){\n\t\t\t\tfor(int j = 0;j <= N+1;j++){\n\t\t\t\t\ttotatu[0][j] = 0;\n\t\t\t\t\ttotatu[1][j] = 0;\n\t\t\t\t}\n\t\t\t\ttotatu[0][i] = 1;\n\t\t\t\tflag = Dijkstra(i);\n\t\t\t\tif(flag == false){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if(cango[1][i] == 1){\n\t\t\t\tfor(int j = 0;j <= N+1;j++){\n\t\t\t\t\ttotatu[0][j] = 0;\n\t\t\t\t\ttotatu[1][j] = 0;\n\t\t\t\t}\n\t\t\t\ttotatu[1][i] = 1;\n\t\t\t\tflag = Dijkstra(i);\n\t\t\t\tif(flag == false){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\t\tif(i == N+1)\n\t\t\tans[cor] = \"OK\";\n\t\telse\n\t\t\tans[cor] = \"NG\";\n\t\tcor++;\n\t}\n\tfor(i = 0;i < cor;i++)\n\t\tcout << ans[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint m,n,d[300];\nvector<int> g[300],rg[300];\nbool vis[300],rvis[300];\n\nvoid dfs(int p){\n  if(vis[p])return;\n  vis[p] = true;\n  for(int i=0;i<g[p].size();i++)\n    if(!vis[g[p][i]])dfs(g[p][i]);\n}\n\nvoid rdfs(int p){\n  if(rvis[p])return;\n  rvis[p] = true;\n  for(int i=0;i<rg[p].size();i++)\n    if(!rvis[rg[p][i]])rdfs(rg[p][i]);\n}\n\nint main(){\n  while(cin >> m,m){\n    cin >> n;\n    for(int i=1;i<=n;i++)cin >> d[i]; d[0] = d[n+1] = 0;\n    for(int i=0;i<=n+1;i++){g[i].clear(); rg[i].clear();}\n\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n\tint nxt = min(n+1,i+j);\n\tnxt = max(0,min(n+1,nxt + d[nxt]));\n\n\tg[i].push_back(nxt); rg[nxt].push_back(i);\n      }\n    }\n\n    for(int i=0;i<=n+1;i++)vis[i] = rvis[i] = false;\n    dfs(0); rdfs(n+1);\n\n    bool res = true;\n    for(int i=0;i<=n+1;i++){\n      if(vis[i] && !rvis[i])res = false;\n    }\n    cout << (res?\"OK\":\"NG\") << endl;\n  }\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint mx, n;\n\twhile(cin >> mx, mx){\n\t\tcin >> n;\n\t\tvi d(n + 2), v(n + 2);\n\t\tbool ans = 1;\n\t\trep(i, n) cin >> d[i + 1];\n\t\tfunction<void(int, vi&)> rec = [&](int c, vi &v){\n\t\t\tv[c] = 1;\n\t\t\tif(c == n + 1) return;\n\t\t\tfor(int i = 1; i <= mx && c + i < n + 2; i++){\n\t\t\t\tint to = c + i + d[c + i];\n\t\t\t\tto = max(0, min(to, n + 1));\n\t\t\t\tif(!v[to]) rec(to, v);\n\t\t\t}\n\t\t};\n\t\trec(0, v);\n\t\t\n\t\trep(i, n + 1) if(v[i]){\n\t\t\tvi vv(n + 2);\n\t\t\trec(i, vv);\n\t\t\tif(!vv[n + 1]){ ans = 0; break; }\n\t\t}\n\t\tcout << (ans ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nqueue<int> q;\n\nbool t[252];\nint d[252];\n\nint maxw;\n\nint n;\n\nvoid tw(int a)\n{\n\tif(a < 0)\n\t{\n\t\tif(!t[0])\n\t\t{\n\t\t\tt[0] = true;\n\t\t\tq.push(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!t[a])\n\t\t{\n\t\t\tt[a] = true;\n\t\t\tq.push(a);\n\t\t}\n\t}\n}\n\nvoid tou(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttw(a - i);\n\t}\n}\n\nvoid syo(int a)\n{\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(i + d[i] == a)\n\t\t{\n\t\t\ttou(a);\n\t\t}\n\t}\n}\n\nvoid init()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt[i] = false;\n\t}\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\tif(n + 1 - i >= 0)\n\t\t{\n\t\t\tt[n + 1 - i] = true;\n\t\t\tq.push(n + 1 - i);\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(d[i] + i >= n + 1)\n\t\t{\n\t\t\ttou(i);\n\t\t}\n\t}\n}\n\nvoid modo()\n{\n\tinit();\n\twhile(!q.empty())\n\t{\n\t\tint w = q.front();\n\t\tq.pop();\n\t\tsyo(w);\n\t}\n}\n\nqueue<int> q2;\n\nbool t2[252];\n\nvoid tw2(int a)\n{\n\tif(a > n + 1)\n\t{\n\t\tif(!t2[n + 1])\n\t\t{\n\t\t\tt2[n + 1] = true;\n\t\t\tq2.push(n + 1);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!t2[a])\n\t\t{\n\t\t\tt2[a] = true;\n\t\t\tq2.push(a);\n\t\t}\n\t}\n}\n\nvoid tou2(int a)\n{\n\ttw2(a + d[a]);\n}\n\nvoid syo2(int a)\n{\n\tfor(int i = 1; i <= maxw; i++)\n\t{\n\t\ttou2(a + 1);\n\t}\n}\n\nvoid init2()\n{\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tt2[i] = false;\n\t}\n\tq2.push(0);\n\tt2[0] = true;\n}\n\nvoid modo2()\n{\n\tinit2();\n\twhile(!q2.empty())\n\t{\n\t\tint w = q2.front();\n\t\tq2.pop();\n\t\tsyo2(w);\n\t}\n}\n\nbool can()\n{\n\tif(!t2[n + 1])\n\t{\n\t\treturn false;\n\t}\n\tfor(int i = 0; i <= n + 1; i++)\n\t{\n\t\tif(t2[i])\n\t\t{\n\t\t\tif(!t[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&maxw);\n\t\tif(maxw == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\td[0] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\",d + i);\n\t\t}\n\t\td[n + 1] = 0;\n\t\tmodo();\n\t\tmodo2();\n\t\tif(can())\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// Custom Header {{{\n#define ALL(x) x.begin(), x.end()\n#define endl '\\n'\nusing namespace std;\nusing i64 = long long;\nusing pii = pair<i64, i64>;\ntemplate<class A, class B>inline bool chmax(A &a, const B &b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, const B &b){return b<a ? a=b,1 : 0;}\nconstexpr int INF  = 0x3f3f3f3f;\nconstexpr i64 LINF = 0x3f3f3f3f3f3f3f3fLL;\n// }}}\n\nint K, N;\nint d[300];\nint START = 0, GOAL;\nbool reach[300];\nbool visited[300];\nvector<vector<int>> G;\n\nvoid addEdge(int s)\n{\n    for (int j = 1; j <= K; ++j) {\n        int t = min(GOAL, s + j);\n        G[s].push_back(max(0, min(GOAL, t + d[t])));\n    }\n}\n\nvoid dfs(int u)\n{\n    if (!visited[u]) {\n        visited[u] = true;\n        for (int v : G[u]) dfs(v);\n    }\n}\n\nbool canGoal(int u)\n{\n    if (u == GOAL) return true;\n\n    if (visited[u]) return false;\n    visited[u] = true;\n\n    bool ret = false;\n    for (int v : G[u]) {\n        ret |= canGoal(v);\n    }\n    return ret;\n}\n\nsigned main()\n{\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n\n\n    while(cin >> K, K) {\n        cin >> N;\n        memset(d, 0, sizeof(d));\n        for (int i = 1; i <= N; ++i) cin >> d[i];\n        GOAL = N+1;\n\n        G = vector<vector<int>>(N+2);\n        for (int i = 0; i <= N; ++i) {\n            addEdge(i);\n        }\n\n        /*\n        cout << \"-------------------------------------\" << endl;\n        cout << ++__  << ' ' << N << ' ' << K << endl;\n        for (int i = 1; i <= N; ++i) cout << d[i] << ' ';\n        cout << endl;\n\n        for (int i = 0; i <= GOAL; ++i) {\n            printf(\"[%d] \", i);\n            for (int u : G[i]) {\n                printf(\" %d\", u);\n            }\n            printf(\"\\n\");\n        }\n        */\n\n        memset(visited, false, sizeof(visited));\n        dfs(0);\n\n        int reachCount = 0;\n        int canGoalCount = 0;\n\n        memcpy(reach, visited, sizeof(reach));\n        for (int i = 1; i <= GOAL; ++i) {\n            if (reach[i]) {\n                //printf(\"reach : %d\\n\", i);\n                ++reachCount;\n                memset(visited, false, sizeof(visited));\n                if (canGoal(i)) {\n                    ++canGoalCount;\n                }\n            }\n        }\n\n        cout << (canGoalCount > 0 && reachCount == canGoalCount ? \"OK\" : \"NG\") << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nnamespace MGraph{\n\ttypedef int Cost;Cost CINF=1<<28;\n\ttypedef  vector<vector<Cost> > Mat;\n}\nnamespace ShortestPath{\n    using namespace MGraph;\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\n\nCost INF=1<<28;\n\nclass Main{\npublic:\n\n\tvoid run(){\n\t\twhile(true){\n\t\t\tint M;cin >> M;if(M==0)break;\n\t\t\tint n;cin >> n;\n\t\t\tvector<int> ds(n+2);REP(i,n) cin >> ds[i+1];\n\t\t\t\n\t\t\tMat g(n+2,vector<Cost>(n+2,INF));\n\t\t\tREP(i,n+2)g[i][i]=0;\n\t\t\tREP(i,n+2){\n\t\t\t\tfor(int r=1;r<=M;r++){\n\t\t\t\t\tint npos=min(i+r,n+1);\n\t\t\t\t\tnpos+=ds[npos];npos=max(npos,0);npos=min(npos,n+1);\n\t\t\t\t\tg[i][npos]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twarshall_floyd(g);\n\t\t\tbool ok=true;\n\t\t\tREP(i,n+2)if(g[i][n+1]>=INF)ok=false;\n\t\t\tcout << (ok?\"OK\":\"NG\")<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(1,nx);\n    if(!memo[prev][x])ans=false;\n    return memo[prev][x];\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    memset(d,0,sizeof(d));\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint maxv;\nint N;\nint d[303];\nbool used[304];\nint main(){\n\n  while(cin>>maxv&&maxv){\n    memset(used,0,sizeof(used));\n    memset(d,0,sizeof(d));\n    cin>>N;\n    for(int i=1;i<=N;i++)cin>>d[i];\n    N+=2;\n    queue<int> q;\n    q.push(0);\n    used[0]=true;\n    while(q.size()){\n      int now=q.front();q.pop();\n      for(int i=1;i<=maxv;i++){\n        int to=min(N-1,now+i);\n        if(used[to])continue;\n        // used[to]=true;\n        if(d[to]>0){\n          to=min(N-1,to+d[to]);\n          if(!used[to]){\n            q.push(to);\n            used[to]=true;\n          }\n        }\n        else if(d[to]<0){\n          to=max(0,to+d[to]);\n          if(!used[to]){\n            q.push(to);\n            used[to]=true;\n          }\n        }\n        else{\n          used[to]=true;\n          q.push(to);\n        }\n      }\n    }\n    vector<int> cand;\n    for(int i=0;i<N-1;i++)\n      if(used[i])cand.push_back(i);\n    // for(int i=0;i<(int)cand.size();i++){\n    //   cout<<cand[i]<<\" \";\n    // }\n    // cout<<endl;\n    \n    for(int ite=0;ite<(int)cand.size();ite++){\n      memset(used,0,sizeof(used));\n      queue<int> q;\n      q.push(cand[ite]);\n      used[cand[ite]]=true;\n      while(q.size()){\n        int now=q.front();q.pop();\n        for(int i=1;i<=maxv;i++){\n          int to=min(N-1,now+i);\n          if(used[to])continue;\n          // used[to]=true;\n          if(d[to]>0){\n            to=min(N-1,to+d[to]);\n            if(!used[to]){\n              q.push(to);\n              used[to]=true;\n            }\n          }\n          else if(d[to]<0){\n            to=max(0,to+d[to]);\n            if(!used[to]){\n              q.push(to);\n              used[to]=true;\n            }\n          }\n          else{\n            used[to]=true;\n            q.push(to);\n          }\n        }\n      }\n      if(!used[N-1]){\n        cout<<\"NG\"<<endl;\n        break;\n      }\n    }\n    if(used[N-1])cout<<\"OK\"<<endl;\n  }\n  \n  return 0;\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\nvoid D(int n,vector<int>*v,int*b){\n\tb[n]=1;\n\tfor(int i=0;i<v[n].size();i++)if(!b[v[n][i]])D(v[n][i],v,b);\n}\nmain(){\n\tint m,n,i,j,next,d[259];\n\tfor(;scanf(\"%d%d\",&m,&n)>1;puts(i<=n+1?\"NG\":\"OK\")){\n\t\td[0]=d[n+1]=0;\n\t\tfor(i=1;i<=n;i++)scanf(\"%d\",d+i);\n\t\tvector<int>vf[259],vr[259];\n\t\tfor(i=0;i<=n;i++)for(j=1;j<=m;j++){\n\t\t\tnext=i+j;\n\t\t\tif(next>n+1)next=n+1;\n\t\t\tnext+=d[next];\n\t\t\tif(next>n+1)next=n+1;\n\t\t\tif(next<0)next=0;\n\t\t\tvf[i].push_back(next),vr[next].push_back(i);\n\t\t}\n\t\tint bf[259]={0},br[259]={0};\n\t\tD(0,vf,bf),D(n+1,vr,br);\n\t\tfor(i=0;i<=n+1;i++)if(bf[i]&&!br[i])break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint mx, n, d[300], g[300][300];\nint memo[300];\n\nint dfs(int k){\n\tif( d[k] == 0 ) return k;\n\t\n\tif( n+1 <= k + d[k] ) return n + 1;\n\tif( k + d[k] <= 0 ) return 0;\n\t\n\tif( memo[k] != -1 ) return memo[k];\n\tif( 0 <= k && k < 300 )\n\t\treturn memo[k] = dfs(k + d[k]);\n\treturn 0;\n}\n\nvoid add_edge(int u, int v){\n\tg[u][v] = 1;\n}\n\nint main(){\n\twhile( cin >> mx, mx ){\n\t\tfill(d, d + 300, 0);\n\t\tfill(memo, memo + 300, -1);\n\t\tfor(int i = 0; i < 300; i++) fill(g[i], g[i] + 300, 0);\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; i++) cin >> d[i];\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif( d[i] == 0 ){\n\t\t\t\tint u = i;\n\t\t\t\tfor(int j = 1; j <= mx; j++){\n\t\t\t\t\tint v = dfs(i + j);\n\t\t\t\t\tadd_edge(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k <= n+1; k++){\n\t\t\tfor(int i = 0; i <= n+1; i++){\n\t\t\t\tfor(int j = 0; j <= n+1; j++){\n\t\t\t\t\tif( g[i][k] && g[k][j] ) g[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tfor(int u = 0; u <= n; u++){\n\t\t\tif( g[0][u] && !g[u][n+1] ) ans = false;\n\t\t}\n\t\tcout << (ans? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nint MAX, N;\n\nvoid valid_check(vector<bool> &isValid, vector< vector<int> > &g){\n  isValid[0] = true;\n  REP(now, N + 1){\n    if(!isValid[now]) continue;\n    REP(i, g[now].size()) isValid[g[now][i]] = true;\n  }\n}\n\nbool dfs(int now, vector<bool> &visited, vector< vector<int> > &g, vector<int> &v){\n  //cout <<\"now = \" <<v[now] <<endl;\n  if(v[now] == 0) return true;\n  if(visited[now]) return false;\n  int next = g[now][0];\n  visited[next] = true;\n  return dfs(next, visited, g, v);\n}\n\nint main() {\n  while(cin >>MAX && MAX){\n    cin >>N;\n    vector<int> v(N + 2, 0); FOR(i, 1, N + 1) cin >>v[i];\n    vector< vector<int> > g(N + 2, vector<int>());\n    REP(i, N + 1){\n      if(v[i] == 0){\n        FOR(j, i + 1, min(N + 1, i + MAX) + 1) g[i].push_back(j);\n      } else if(v[i] < 0){\n        int next = max(0, i + v[i]);\n        g[i].push_back(next);\n      } else {\n        int next = min(N + 1, i + v[i]);\n        g[i].push_back(next);\n      }\n    }\n    //REP(i, g.size()){\n    //  cout <<i <<\": \";\n    //  REP(j, g[i].size()) cout <<g[i][j] <<\" \";\n    //  cout <<endl;\n    //}\n    vector<bool> isValid(N + 2, false);\n    valid_check(isValid, g);\n\n    bool isOK = true;\n    REP(i, N + 1){\n      if(!isValid[i]) continue;\n      if(v[i] == 0){\n        bool f = false;\n        REP(j, g[i].size()){\n          vector<bool> visited(N + 2, false);\n          dfs(g[i][j], visited, g, v);\n          if(!visited[i]) f = true;\n        }\n        if(!f) isOK = false;\n      } else{\n        vector<bool> visited(N + 2, false);\n        bool tmp = dfs(i, visited, g, v);\n        if(!tmp) isOK = false;\n      }\n      //REP(i, visited.size()) cout <<visited[i] <<\" \"; cout <<endl;\n      //cout <<i <<\" (\" <<v[i] <<\") : \";\n    }\n    cout <<(isOK ? \"OK\" : \"NG\") <<endl;\n  } return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint m, n;\n\nbool solve(const vector<int>& data){\n  if(m > n) return true;\n  vector<bool> is(data.size(), false);\n  for(int i=0; i<=m; ++i) is[i]=true;\n  for(int i=m+1; i<data.size(); ++i){\n    bool is_=false;\n    for(int j=1; j<=m; ++j){\n      int k=i-j-data[i-j];\n      if(k < i && (k<0 || is[k])){\n\tis[i]=true; is_=true; break;\n      }else if(k > i){\n\tis_=true;\n      }\n    }\n    if(!is_) return false;\n  }\n  return is[is.size()-1];\n}\n\nint main(){\n  while(1){\n    cin >> m;\n    if(!m) break;\n    cin >> n;\n    vector<int> data(n+2, 0);\n    for(int i=0; i<n; ++i) cin >> data[i+1];\n    reverse(data.begin(), data.end());\n    if(solve(data)) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool g[252][252];\n\nint main(){\n\n  while(1){\n\n    int max;\n\n    cin >> max;\n\n    if(max == 0){\n      break;\n    }\n\n    int n;\n\n    cin >> n;\n\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n        g[i][j] = false;\n      }\n    }\n\n    int mass[n+2];\n\n    mass[0] = 0;\n    mass[n+1] = 0;\n\n    for(int i=1;i<n+1;i++){\n      cin >> mass[i];\n    }\n\n    for(int i=0;i<n+1;i++){\n      for(int j=1;j<=max;j++){\n        int next;\n        if(i+j>=n+2){\n          next = n+1;\n        }\n        else{\n          next = i+j+mass[i+j];\n        }\n\n        if(next<0) next = 0;\n        if(next>n+2) next=n+1;\n        g[i][next] = true;\n      }\n    }\n\n    for(int k=0;k<n+2;k++){\n      for(int i=0;i<n+2;i++){\n        for(int j=0;j<n+2;j++){\n          if(g[i][k] && g[k][j]){\n            g[i][j] = true;\n          }\n        }\n      }\n    }\n\n    bool flag = true;\n\n    for(int i=0;i<n+1;i++){\n      if(g[0][i] && !g[i][n+1]){\n        flag = false;\n        break;\n      }\n    }\n\n    if(flag){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define N 333\nint max_masu,n;\nint d[N],flag[N];\nusing namespace std;\nint solve(int i){\n  int ret = 0;\n  if(i>=n)return 0;\n  if(i<0)i=0;\n  //printf(\"%d %d\\n\",i,flag[i]);\n  if(flag[i] == 1)return 1;\n  for(int j=1;j<=max_masu;j++){\n    flag[i] = 1;\n    ret += solve(i+j+d[i+j]);\n    flag[i] = 0;\n  }\n  return ret;\n}\nint main(){\n  while(1){\n    cin >> max_masu;\n    if(!max_masu)break;\n    cin >> n;\n    memset( d, 0 , sizeof(d));\n    memset( flag , 0 , sizeof(flag) );\n    for(int i=0;i<n;i++){\n      cin >> d[i];\n    }\n    int ret = 0;\n    for(int i=0;i<n;i++){\n      ret += solve( i );\n     //cout << ret << endl;\n    }\n    printf(\"%s\\n\",(ret == 0)? \"OK\" : \"NG\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,dmax;\nint m[300];\nbool visited[300];\nbool isVisit[300];\nbool isGoal;\nvoid dfs(int p){\n  if(visited[p])return ;\n  visited[p] = true;\n  isVisit[p] = true;\n  if(p == n+1){\n    isGoal = true;\n    return;\n  }\n  for(int i = 1; i <= dmax && p+i <= n+1; i++){\n    int np = p+i;\n    np = np + m[np];\n    if(np > n + 1)np = n + 1;\n    if(np < 0) np = 0;  \n    dfs(np);\n  }\n}\nvoid solve(){\n  fill(isVisit, isVisit+300, false);\n  isVisit[0] = true;\n  for(int i = 0 ; i <= n; i++){\n    if(!isVisit[i])continue;\n    isGoal = false;\n    fill(visited, visited+300, false);\n    dfs(i);\n    if(!isGoal)break;    \n  }\n  cout << (isGoal?\"OK\":\"NG\") << endl;\n}\nint main(){\n  while( cin >> dmax, dmax ){\n    cin >> n;\n    fill(m, m+300, 0);\n    for(int i = 0 ; i < n ;i++){\n      cin >> m[i+1];\n    }\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m,n;\n  while(cin>>m,m){\n    cin >> n;\n    int d[300]={};\n    int i;\n    int p,b;\n    fill(d,d+300,0);\n    for(i=1;i<=n;i++) cin >> d[i];\n    int used[300];\n    bool r[300]={};\n    bool g[300]={};\n    queue<int> q1,q2;\n    q1.push(0);\n    bool c=true;\n    while(!q1.empty()){\n      b=q1.front();q1.pop();\n      if(r[b]) continue;\n      r[b]=true;\n      q2.push(b);\n      //cout << b << endl;\n      fill(used,used+300,false);\n      while(!q2.empty()){\n\tp=q2.front();q2.pop();\n\t//cout << p << endl;\n\tif(p<0) p=0;\n\tif(p>n+1) p=n+1;\n\tif(used[p]) continue;\n\tused[p]=true;\n\tq1.push(p);\n\tfor(i=1;i<=m;i++){\n\t  //cout <<p<<\":\"<< i <<\":\"<<p+i+d[p+i]<< endl;\n\t  q2.push(p+i+d[p+i]);\n\t}\n      }\n      if(!used[n+1]){\n\tc=false;\n\tbreak;\n      }\n    }\n    if(c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dice;\nint n;\nvector<int> a;\nvector<bool> memo;\n\nbool solve(int curr)\n{\n    if(curr == n-1)\n        return true;\n\n    if(memo[curr])\n        return false;\n    memo[curr] = true;\n\n    for(int i=1; i<=dice; ++i){\n        int next = min(n-1, curr + i);\n        next = max(0, min(n-1, next + a[next]));\n        if(solve(next))\n            return true;\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        cin >> dice >> n;\n        if(dice == 0)\n            return 0;\n\n        a.assign(n+2, 0);\n        for(int i=1; i<=n; ++i)\n            cin >> a[i];\n\n        bool ok = true;\n        for(int i=0; i<=n; ++i){\n            memo.assign(n+2, false);\n            if(!solve(i))\n                ok = false;\n        }\n\n        if(ok)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint N;\nint a;\nvector<int>ds;\nvector<int>used;\nbool dfs(const int now) {\n\tif (now + N >= a + 1) {\n\t\tused[now] = 1;\n\t\treturn true;\n\t}\n\tset<int>nexts;\n\tfor (int i = 1; i <= N; ++i) {\n\t\t int next = now + i + ds[now + i];\n\t\tif (next >= a + 1) {\n\t\t\tused[now] = 1;\n\t\t\treturn true;\n\t\t}\n\t\telse if (next <= -1) {\n\t\t\tnext = 0;\n\t\t}\n\t\tif (used[next] == 1) {\n\t\t\tused[now] = 1;\n\t\t\treturn true;\n\t\t}\n\t\telse if (used[next] == -1) {\n\n\t\t}\n\t\telse {\n\t\t\tnexts.emplace(next);\n\t\t}\n\t}\n\tused[now] = -1;\n\tfor (auto n : nexts) {\n\t\tbool ok = dfs(n);\n\t\tif (ok) {\n\t\t\tused[now] = true;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (1) { cin >> N;\n\t\tif (!N)break; cin >> a;\n\t\tds.clear();\n\t\tused.clear();\n\t\tds.resize(a+2);\n\t\tused.resize(a + 2);\n\t\tfor (int i = 0; i < a; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tused[0] = -1;\n\t\tbool ok=dfs(0);\n\t\tif (ok)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint mx, n, d[300], g[300][300];\nint memo[300];\n\nint dfs(int k){\n\tif( d[k] == 0 ) return k;\n\t\n\tif( n+1 <= k + d[k] ) return n + 1;\n\tif( k + d[k] <= 0 ) return 0;\n\t\n\tif( memo[k] != -1 ) return memo[k];\n\t\n\treturn memo[k] = dfs(k + d[k]);\n}\n\nvoid add_edge(int u, int v){\n\tg[u][v] = 1;\n}\n\nint main(){\n\twhile( cin >> mx, mx ){\n\t\tfill(d, d + 300, 0);\n\t\tfill(memo, memo + 300, -1);\n\t\tfor(int i = 0; i < 300; i++) fill(g[i], g[i] + 300, 0);\n\t\t\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; i++) cin >> d[i];\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif( d[i] == 0 ){\n\t\t\t\tint u = i;\n\t\t\t\tfor(int j = 1; j <= mx; j++){\n\t\t\t\t\t//int v = dfs(i + j);\n\t\t\t\t\t//add_edge(u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k <= n+1; k++){\n\t\t\tfor(int i = 0; i <= n+1; i++){\n\t\t\t\tfor(int j = 0; j <= n+1; j++){\n\t\t\t\t\tif( g[i][k] && g[k][j] ) g[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tfor(int u = 0; u <= n; u++){\n\t\t\tif( g[0][u] && !g[u][n+1] ) ans = false;\n\t\t}\n\t\tcout << (ans? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool used[2][N],ans;\n \nvoid dfs(int x,int idx){\n  if(used[idx][x])return;\n  x+=d[x];\n  if(x<0)x=0;\n  if(n+1<x)x=n+1;\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    dfs(nx,idx);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(used,0,sizeof(used));\n    ans=true;\n    dfs(0,0);\n    if(!used[0][n+1])ans=false;\n    for(int i=1;i<n+1;i++){\n      if(!used[0][i])continue;\n      for(int j=0;j<=n+1;j++)used[1][j]=false;\n      dfs(i,1);\n      if(!used[1][n+1])ans=false;\n    }\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint rlet;\nint n;\nint d[255];\nvector<int> vec[255],rvec[255];\nbool vis[255],rvis[255];\n\nvoid dfs(int now){\n  vis[now]=true;\n  for(int i=0;i<vec[now].size();i++){\n    if(!vis[vec[now][i]])dfs(vec[now][i]);\n  }\n}\nvoid rdfs(int now){\n  rvis[now]=true;\n  for(int i=0;i<rvec[now].size();i++){\n    if(!rvis[rvec[now][i]])rdfs(rvec[now][i]);\n  }\n}\n\nint main(){\n\n  while(1){\n    memset(vis,false,sizeof(vis));\n    memset(rvis,false,sizeof(rvis));\n    cin>>rlet;\n    if(!rlet)break;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n      cin>>d[i];\n    }\n\n    for(int i=0;i<=n+1;i++){\n       vec[i].clear();\n       rvec[i].clear();\n    }\n    /*グラフ化*/\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=rlet;j++){\n        vec[i].push_back(min(max(i+j+d[i+j],0),n+1));\n        rvec[min(max(i+j+d[i+j],0),n+1)].push_back(i);\n      }\n    }\n\n    dfs(0);\n    rdfs(n+1);\n\n    bool ok=true;\n    for(int i=0;i<=n;i++){\n      if(vis[i]&&!rvis[i])ok=false;\n    }\n\n    if(ok)cout<<\"OK\"<<\"\\n\";\n    else cout<<\"NG\"<<\"\\n\";\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> a;\nint n,m;\nbool d[300];\n\nbool saiki(int p1,vector<bool> u){\n    int p = p1;\n    if(a[p] == 300) return true;\n    if(u[p]) return false;\n    u[p] = true;\n    if(d[p]) return true;\n    bool ans = false;\n    vector<bool> t = u;\n    for(int i = 1;i<=m;i++){\n\tu = t;\n\tp = p1;\n\tp += i;\n\tp += a[p];\n\tp = max(p,0);\n\tif(p >= 300) return d[p1] = true;\n\twhile(a[p] != 0){\n\t    if(u[p]) break;\n\t    u[p] = true;\n\t    p += a[p];\n\t    p = max(p,0);\n\t    if(p >= 300) return d[p1] = true;\n\t}\n\tans = ans | saiki(p,u);\n    }\n    return d[p] = ans;\n}\n\nint main(){\n    while(true){\n\tmemset(d,false,sizeof(d));\n\ta = vector<int>(0);\n\tcin >> m;\n\tif(m == 0) break;\n\tcin >> n;\n\ta.PB(-300);\n\tREP(i,n){\n\t    int temp;\n\t    cin >> temp;\n\t    a.PB(temp);\n\t}\n\ta.PB(300);\n\tif(saiki(0,vector<bool>(n+2,false))) cout << \"OK\" << endl;\n\telse cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\nint d[252];\nint dp[252][252];\nint Max;\nint n;\nint main() {\n\twhile(scanf(\"%d\",&Max),Max) {\n\t\tscanf(\"%d\",&n);\n\t\td[0]=d[n+1]=0;\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=0;i<n+2;i++) {\n\t\t\tfor(int j=1;j<=Max;j++) {\n\t\t\t\tint p;\n\t\t\t\tp=min(i+j,n+2);\n\t\t\t\tp+=d[p];\n\t\t\t\tp=min(max(p,0),n+2);\n\t\t\t\tdp[i][p]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n+2;k++) {\n\t\t\tfor(int i=0;i<n+2;i++) {\n\t\t\t\tfor(int j=0;j<n+2;j++) {\n\t\t\t\t\tif(dp[i][k]&&dp[k][j]) dp[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool OK=1;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tfor(int j=0;j<=n;j++) {\n\t\t\t\tif(dp[i][j]&&!dp[j][n+1]) {\n\t\t\t\t\tOK=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!OK) break;\n\t\t}\n\t\tif(OK) printf(\"OK\\n\"); else printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint main(){\n    int ma;\n    while(scanf(\"%d\",&ma),ma){\n        int n;\n        int stage[256];\n        int D[256][256]={{0}};\n        scanf(\"%d\",&n);\n        reps(i,1,n+1){\n            scanf(\"%d\",&stage[i]);\n        }\n        rep(i,n+1){\n            if(stage[i]){\n                int tmp = i+stage[i];\n                if(tmp < 0)tmp = 0;\n                if(tmp > n+1)tmp = n+1;\n                D[i][tmp] = 1;\n            }\n            else{\n                reps(j,1,ma+1){\n                    int tmp = i+j;\n                    if(tmp > n+1)tmp = n+1;\n                    D[i][tmp] = 1;\n                }\n            }\n        }\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    if(D[i][k] && D[k][j]){\n                        D[i][j] = 1;\n                    }\n                }\n            }\n        }\n        /*puts(\"--------------------------\");\n        rep(i,n+2){\n            rep(j,n+2){\n                if(D[i][j] >= INF)printf(\"M \");\n                else printf(\"%d \",D[i][j]);\n            }\n            puts(\"\");\n        }\n        puts(\"--------------------------\");*/\n        bool flg = false;\n        rep(i,n+2){\n            if(D[0][i] && D[i][n+1]){\n                flg = true;\n                break;\n            }\n        }\n        flg ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> a;\nint n,m;\nvector<bool> d(300);\n\nbool saiki(int p1,int pre,vector<int> u){\n    int p = p1;\n  //  if(u[p] > 2) return true;\n    //if(!d[p]) return false;\n    u[p]++;\n    bool ans = false;\n\n    bool flg = false;\n    for(int i=1;i<=m;i++){\n\tif(u[min(p+i,n+1)] == 0) flg = true;\n    }\n    if(!flg) return true;\n    for(int i=1;i<=m;i++){\n\tp = p1;\n\tp += i;\n\tp = min(p,n+1);\n\tu[p]++;\n\t//printf(\"m = %d i = %d p = %d a[p] = %d\\n\",m,i,p,a[p]);\n\tif(a[p] == 300) return d[p1] = false;\n\tp += a[p];\n\tp = min(p,n+1);\n\tp = max(p,0);\n\tif(u[p] < 10)\n\t    ans = ans | saiki(p,p1,u);\n    }\n    return d[p] = ans;\n}\n\nint main(){\n    while(true){\n\tfill(ALL(d),true);\n\ta = vector<int>(0);\n\tcin >> m;\n\tif(m == 0) break;\n\tcin >> n;\n\ta.PB(-300);\n\tREP(i,n){\n\t    int temp;\n\t    cin >> temp;\n\t    a.PB(temp);\n\t}\n\ta.PB(300);\n\tif(!saiki(0,0,vector<int>(n+2,0))) cout << \"OK\" << endl;\n\telse cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nint m, n;\nvi d;\nvector<int> memo;\n\nint f(int p)\n{\n    p = max(0, p);\n    if(memo[p]) return memo[p];\n    if(p >= n-1) return 1;\n    \n    memo[p] = 2;\n    rep(i, m){\n        int v = f(p+i+1 + d[p+i+1]);\n        if(v != 2){\n            return memo[p] = v;\n        }\n    }\n    \n    return memo[p] = 3;\n}\n\nint main()\n{\n    while(cin >> m, m){\n        cin >> n;\n        n += 2;\n        d.assign(n, 0);\n        memo.assign(n, 0);\n        rep(i, n-2) cin >> d[i+1];\n        cout << (f(0) == 1 ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<int>;\nusing VL = vector<ll>;\n#define FOR(i,a,n) for(int (i)=(a);(i)<(n);(i)++)\n#define eFOR(i,a,n) for(int (i)=(a);(i)<=(n);(i)++)\n#define rFOR(i,a,n) for(int (i)=(n)-1;(i)>=(a);(i)--)\n#define erFOR(i,a,n) for(int (i)=(n);(i)>=(a);(i)--)\n#define SORT(i) sort((i).begin(),(i).end())\n#define rSORT(i,a) sort((i).begin(),(i).end(),(a))\n#define all(i) (i).begin(),(i).end()\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; }return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; }return 0; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T> inline istream& operator>>(istream& input, vector<T>& v) { for (auto& elemnt : v)input >> elemnt; return input; }\n\nint main() {\n    init();\n\n    while (1) {\n        int dice;\n        cin >> dice;\n        if (dice == 0)break;\n\n        int n;\n        cin >> n;\n        n += 2;\n        VI d(n, 0);\n        FOR(i, 1, n - 1)cin >> d[i];\n\n        vector<vector<bool>> g(n, vector<bool>(n, false));\n        FOR(i, 0, n)g[i][i] = true;\n        FOR(i, 0, n) {\n            eFOR(j, 1, dice) {\n                int next = i + j + d[min(i + j, n - 1) ];\n                chmax(next, 0), chmin(next, n - 1);\n                g[i][next] = true;\n            }\n        }\n        FOR(k, 0, n)FOR(i, 0, n)FOR(j, 0, n) {\n            if (g[i][k] && g[k][j])g[i][j] = true;\n        }\n        string ans = \"OK\\n\";\n        FOR(i, 0, n)if (g[0][i]) {\n            if (!g[i][n - 1])ans = \"NG\\n\";\n        }\n        cout << ans;\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 255\nusing namespace std;\nint m,n,d[N];\nbool memo[2][N],used[2][N],ans;\n\nbool dfs(int prev,int x){\n  if(used[prev][x])return memo[prev][x];\n  used[prev][x]=true;\n  if(!prev&&d[x]){\n    int nx=x+d[x];\n    if(nx<0)nx=0;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]=dfs(1,nx);\n    //    if(!memo[prev][x])ans=false;\n    return memo[prev][x];\n  }\n  for(int i=1;i<=m;i++){\n    int nx=x+i;\n    if(n+1<nx)nx=n+1;\n    memo[prev][x]|=dfs(0,nx);\n  }\n  if(!memo[prev][x])ans=false;\n  return memo[prev][x];\n}\n\nint main(){\n  while(1){\n    cin>>m;\n    if(!m)break;\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>d[i];\n    memset(memo,0,sizeof(memo));\n    memset(used,0,sizeof(used));\n    memo[0][n+1]=memo[1][n+1]=true;\n    ans=true;\n    dfs(0,0);\n    if(ans)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,flag[252];\nvector<int> G[252];\nbool used[252];\n\nbool dfs(int v){\n\tif(flag[v] != -1) return flag[v];\n\tif(v == n + 1) return true;\n\tif(used[v]) return false;\n\tbool f = false;\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tif(dfs(G[v][i])) f = true;\n\t}\n\tused[v] = false;\n\treturn flag[v] = f;\n}\n\nint main(){\n\tint ma;\n\twhile(cin >> ma,ma){\n\t\tfor(int i = 0;i < 252;i++) {\n\t\t\tG[i].clear();\n\t\t\tused[i] = false;\n\t\t\tflag[i] = -1;\n\t\t}\n\t\tint d[252] = {};\n\t\tcin >> n;\n\t\tfor(int i = 0;i < n;i++) cin >> d[i + 1];\n\t\tfor(int i = 0;i < n + 1;i++){\n\t\t\tfor(int j = 1;j <= ma;j++){\n\t\t\t\tif(i + j >= n + 2) break;\n\t\t\t\tG[i].push_back(min(n + 1,max(0,i + j + d[i + j])));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n + 1;i++){\n\t\t\tsort(G[i].begin(),G[i].end());\n\t\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\t\t}\n\t\tdfs(0);\n\t\tbool ff = true;\n\t\tfor(int i = 0;i < n + 1;i++) if(!flag[i]) ff = false;\n\t\tif(ff) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nbool dfs(const int now,const vector<vector<int>>&edges, const int goal) {\n\tif (now == goal)return true;\n\telse {\n\t\tif (edges[now].empty())return false;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!dfs(e, edges, goal))return false;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint amax;\n\t\tcin >> amax;\n\t\tif (!amax)break;\n\t\tint N; cin >> N;\n\t\tconst int goal = N + 1;\n\t\tconst int start = 0;\n\t\tvector<int>ds(goal+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> ds[i+1];\n\t\t}\n\t\tvector<vector<int>>edges(N + 2);\n\t\tfor (int i = 0; i < N + 1; ++i) {\n\t\t\tfor (int j = 1; j <= amax; ++j) {\n\t\t\t\tif (i + j >= goal) {\n\t\t\t\t\tedges[i].push_back(goal);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i + j + ds[i + j] >= goal) {\n\t\t\t\t\t\tedges[i].push_back(goal);\n\t\t\t\t\t}\n\t\t\t\t\telse if (i + j + ds[i+j]<0) {\n\t\t\t\t\t\tedges[i].push_back(0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tedges[i].push_back(i + j + ds[i + j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=dscc.get(edges);\n\t\tint newstart;\n\t\tint newgoal;\n\t\tfor (int i = 0; i < p.first.size();++i) {\n\t\t\tauto b = p.first[i];\n\t\t\tif (find(b.begin(), b.end(), 0)!=b.end()) {\n\t\t\t\tnewstart = i;\n\t\t\t}\n\t\t\tif (find(b.begin(), b.end(), goal) != b.end()) {\n\t\t\t\tnewgoal= i;\n\t\t\t}\n\t\t}\n\t\tauto newedges = p.second;\n\t\tvector<vector<int>>revedges(newedges.size());\n\t\tfor (int i = 0; i < newedges.size(); ++i) {\n\t\t\tfor (int j = 0; j < newedges[i].size(); ++j) {\n\t\t\t\trevedges[newedges[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t\tbool ans = dfs(newstart, newedges, newgoal);\n\t\tif (ans) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<climits>\n#include <utility>\nusing namespace std;\n\nint n;\nint ma;\nvector<int>vec;\nvector<bool>ok;\n\nbool solve(int cur){\n    for(int i=0;i<vec.size();i++){\n        if(cur+vec[i]>=0&&cur+vec[i]<ok.size()&&!ok[cur+vec[i]]){\n            if(cur+vec[i]==ok.size()-1){\n                return true;\n            }\n            ok[cur+vec[i]]=true;\n            if(solve(cur+vec[i])){\n                return true;\n            };\n        }\n    }\n    return false;\n}\n\nint main(){\n    while(cin>>ma,ma){\n        ok.clear();\n        vec.clear();\n        ok.push_back(true);\n        cin>>n;\n        for(int i=0;i<n;i++){\n            int j;\n            cin>>j;\n            vec.push_back(j);\n            ok.push_back(false);\n        }\n        ok.push_back(false);\n        if(solve(0)){\n            cout<<\"OK\"<<endl;\n        } else {\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n#define ALL(co) co.begin(), co.end()\n#define tpl(...) make_tuple(__VA_ARGS__)\n\ntypedef long long LL;\ntypedef pair<int, int> P; typedef pair<int, P> IP; typedef pair<P, P> PP;\ntypedef vector<int> Array; typedef vector<vector<int> > Array2;\ntypedef vector<LL> LArray; typedef vector<P> PArray; typedef vector<string> SArray;\n\nconst int INF = 1 << 29;\nconst LL LINF = 1LL << 60;\n\ninline int getInt() { int itiv; return (cin >> itiv, itiv); }\ntemplate <typename T> void readAll(vector<T>& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i]; }\ntemplate <typename T, typename U> void readAll(vector<pair<T, U> >& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i].first >> vec[i].second; }\ntemplate < typename T > inline string toString( const T &a ){ ostringstream oss; oss << a; return oss.str(); };\ninline bool between(int min, int max, int n) { return min <= n && n <= max; }\ninline bool inRange(int begin, int end, int n) { return begin <= n && n < end; }\ninline bool inRange(int size, int n) { return 0 <= n && n < size; }\n\nint dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\nint dr[] = { 0, -1, 0, 1 }, dc[] = { -1, 0, 1, 0 };\n\n\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\tint n, mx;\n\twhile(cin >> mx && mx)\n\t{\n\t\tcin >> n;\n\t\tArray arr(n + mx + 1);\n\t\tArray2 graph(n + mx + 1, Array());\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tarr[i + 1] = getInt();\n\t\t}\n\n\t\tfor (int i = 0; i < n + 1; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= mx; j++)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(max(i + j + arr[i + j], 0));\n\t\t\t}\n\t\t}\n\n\t\tvector<bool> visited(n + mx + 1);\n\t\tfunction<bool(int)> dfs = [&](int x){\n\t\t\tif(x >= n + 2) return true;\n\t\t\t\n\t\t\tvisited[x] = true;\n\t\t\tfor(auto nx : graph[x])\n\t\t\t{\n\t\t\t\tif(visited[nx]) continue;\n\t\t\t\tif(dfs(nx)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tcout << (dfs(0) ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define outl(x) cout<< (x) << '\\n'\n#define fi first\n#define se second\nusing pii = pair<int,int>;\nusing ll = long long;\n#define LIM 256\n\nvector<int> G[LIM], R[LIM];\nint N, M;\nint d[LIM];\nbool used[LIM];\nbool vi[LIM];\n\nvoid f(int v)\n{\n    used[v] = true;\n    for (const int nxt : R[v]) {\n        if (!used[nxt]) f(nxt);\n    }\n}\n\nbool ok(int v)\n{\n    bool rec = used[v];\n    vi[v] = true;\n    for (const int nxt : G[v]) {\n        if (!vi[nxt]) rec &= ok(nxt);\n    }\n    return rec;\n}\n\nint main()\n{\n    cin.tie(0), ios::sync_with_stdio(false);\n\n    while (cin >> M, M) {\n        cin >> N;\n        for (int i=0; i<=N+1; ++i)  G[i].clear(), R[i].clear();\n        memset(d, 0, sizeof(d));\n        memset(used, 0, sizeof(used));\n        memset(vi, 0, sizeof(vi));\n\n        for (int i=1; i<=N; ++i) cin >> d[i];\n\n        for (int s=0; s<=N; ++s) {\n            for (int j=1; j<=M;++j) {\n                int t = s+j + d[s+j];\n                t = min(max(t, 0), N+1);\n                G[s].push_back(t);\n                R[t].push_back(s);\n            }\n        }\n        f(N+1);\n        outl(ok(0)? \"OK\" : \"NG\");\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nmemo\n????????°??????\n\n*/\n\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint m, n;\nint ma[300];\nint ka[300][300];\nvector<int> g[300];\nbool go[300], ba[300];\nvoid iki(int x)\n{\n\t//????????§????????¨????????????????????????\n\n\t//????????????????????´??????????????????????????°?????¨??????\n\t//????????´??????????????°???????????????\n\t//???????????????????????§??????????????¶???????????????????????????????????£???\n\t//??????????????°????????????????????°????????????????????°?????¨???????????????????????????\n\t//?????????????????????????????°?????¨??°?????°????????´???????¨???????????????????\n\t//????????????????????´???????????£???????????´???????????????????????????????????????\n\t//??´?????????????????????????????´??????????§???????????????????????????????????????´????????????????????¨??????????????°????????????????????????????????????\n\n\tint i;\n\n\tif (go[x]) return;\n\tgo[x] = true;\t\t\t\t//????????°??????\n\tif (x == n + 1) return;\n\tfor (i = 1; i <= m; i++)\n\t{\n\t\tint y = x + i;\n\t\tif (y <= n+1)\n\t\t{\n\t\t\ty = y + ma[y];\n\t\t\tif (y>0)\n\t\t\t{\n\t\t\t\tif (y > n + 1) y = n + 1;\n\t\t\t\t//if (ka[y][x] == 1)break;\n\t\t\t\t//ka[y][x] = 1;\n\n\t\t\t\tg[y].push_back(x);\n\t\t\t\tiki(y);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn;\n}\n\nvoid kae(int x)\n{\n\t//????????§?????°?????¨????????´???????????????????????????????????¨???????????????????????????\n\n\t//????????????????????´?????????????§??????¨??????????????????????????°????????????????????§???????????´?????????????????????\n\t//??????????????§?????£?????´??????????????¨?????????????????°???????????????\n\n\n\tint i;\n\tif (ba[x]) return;\n\tba[x] = true;\n\tif (x == 0) return;\n\tfor (i = 0; i<g[x].size(); i++)\n\t{\n\t\tkae(g[x][i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> m, m)\n\t{\n\t\tcin >> n;\n\n\t\t//---------------?????????--------------------//\n\t\tfor (i = 0; i<300; i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tma[i] = 0;\n\t\t\t//for (int j = 0; j<300; j++)\n\t\t\t//{\n\t\t\t//\tka[i][j] = 0;\n\t\t\t//}\n\t\t}\n\t\tmemset(go, 0, sizeof(go));\n\t\tmemset(ba, 0, sizeof(ba));\n\n\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> ma[i];\n\t\t}\n\t\tma[0] = ma[n + 1] = 0;\n\n\t\tiki(0);\n\t\tkae(n + 1);\n\n\n\t\t/*\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << go[i] << \"  \" ;\n\t\t}\n\t\tcout << endl;\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tcout << \"  \" << ba[i] << \"  \";\n\t\t}\n\t\t*/\n\n\n\n\t\tfor (i = 0; i <= n + 1; i++)\n\t\t{\n\t\t\tif (go[i])\n\t\t\t{\n\t\t\t\tif (ba[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NG\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n + 1) cout << \"OK\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n\tint a[251],i,n,best;\n\twhile(scanf(\"%d\",&best),best!=0){\n\t\tint z=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\t\tfor(i=best;;i--){\n\t\t\tif(z+i+a[z+i]>z){\n\t\t\t\tz+=i;\n\t\t\t\ti=best+1;\n\t\t\t}\n\t\t\tif(z>=n || i==0)break;\n\t\t}\n\t\tif(i==0)printf(\"NG\\n\");\n\t\telse printf(\"OK\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint r_max,n;\nint order[252];\nchar visited[252];\nchar start_visit[252];\n\nvoid can_arrive_pre(int now) {\n\tint i;\n\tif(start_visit[now])return;\n\tstart_visit[now]=1;\n\tfor(i=1;i<=r_max && now+i<=n+1;i++) {\n\t\tcan_arrive_pre(now+i+order[now+i]>=0?now+i+order[now+i]:0);\n\t}\n}\n\nint can_arrive(int now) {\n\tint i;\n\tif(visited[now])return 0;\n\tvisited[now]=1;\n\tif(now+r_max>=n+1)return 1;\n\tfor(i=1;i<=r_max;i++) {\n\t\tif(can_arrive(now+i+order[now+i]>=0?now+i+order[now+i]:0))return 1;\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tint i,ok;\n\twhile(scanf(\"%d\",&r_max)==1 && r_max>0) {\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;i++)scanf(\"%d\",&order[i]);\n\t\torder[0]=order[n+1]=0;\n\t\tmemset(start_visit,0,sizeof(start_visit));\n\t\tcan_arrive_pre(0);\n\t\tif(!start_visit[n+1])puts(\"NG\");\n\t\telse {\n\t\t\tok=1;\n\t\t\tfor(i=1;i<n+1;i++) {\n\t\t\t\tmemset(visited,0,sizeof(visited));\n\t\t\t\tif(!can_arrive(i)) {\n\t\t\t\t\tputs(\"NG\");\n\t\t\t\t\tok=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)puts(\"OK\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint max;\n\tint n;\n\tint d[251];\n\tint i,j;\n\twhile(1){\n\t\tscanf(\"%d\",&max);\n\t\tif(max==0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\ti=0;\n\t\twhile(i<n){\n\t\t\twhile(d[i]>=0){\n\t\t\t\ti++;\n\t\t\t\tif(i>n){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>n){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(j=0;j<max;j++){\n\t\t\t\t//printf(\"%d %d\\n\",d[i+j],-j-1);\n\t\t\t\tif(d[i+j]>-j-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j==max){\n\t\t\t\ti=n-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif(i>=n){\n\t\t\tprintf(\"OK\\n\");\n\t\t}else{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(m,n,i,j,k,a){for(;a=1,scanf(\"%d\",&m),m;puts(a?\"OK\":\"NG\")){int d[300],g[300][300]={0};scanf(\"%d\",&n);for(i=1;i<=n;)scanf(\"%d\",d+i++);for(i=0;i<=n;i++)for(j=1;j<=m;j++)k=i+j+d[i+j],(k=k<0?0:n+1<k?n+1:k),g[i][k]=1;for(k=0;k<n+2;k++)for(i=0;i<n+2;i++)for(j=0;j<n+2;j++)if(g[i][k]&&g[k][j])g[i][j]=1;for(i=0;i<=n;i++)if(g[0][i]&&!g[i][n+1])a=0;}return 0;}"
  },
  {
    "language": "C",
    "code": "// Aizu 0262: Making Sugoroku\n// 2017.9.9 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint d[252], m, n;\nchar f[252];\n\nint main()\n{\n\tint i, k, g;\n\n\twhile (scanf(\"%d\", &m) && m) {\n\t\tscanf(\"%d\", &n); n++;\n\t\tfor (i = 1; i < n; i++) scanf(\"%d\", d+i);\n\t\tif (m >= n) { puts(\"OK\"); continue; }\n\t\tmemset(f, 0, n);\n\t\tfor (i = n-1; i >= 1; i--) {\n\t\t\tk = i + d[i];\n\t\t\tif (k >= n - m || f[k]) f[i] = 1;\n\t\t\telse if (k <= 0) f[i] = 2;\n\t\t}\n\t\tfor (g = 1, i = 1; i <= m; i++) if (f[i] == 0) break; else if (f[i] == 1) g = 0;\n\t\tputs(i > m && !g ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0262\n  Title:Making Sugoroku\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint d[252];\nint goal[252];\nint reach[252];\nchar connect[252][252];\nint max_r;\nint n;\nint result;\n\nmake_graph()\n{\n  int i,j,next;\n\n  for(i=0;i<=n;i++)\n    for(j=1;j<=max_r;j++)\n      {\n\tnext=i+j;\n\tnext = ((next>n+1)?(n+1):(next<0?0:next));\n\tnext += d[next];\n\tnext = ((next>n+1)?(n+1):(next<0?0:next));\n\tconnect[i][next]=1;\n\t//printf(\"ijn=%d %d |\",i,j);\n      }\n  //printf(\"\\n\");\n}\n\ncan_goal(int aim)\n{\n  int i;\n  goal[n+1]=1;\n  for(i=0;i<=n;i++)\n    if(connect[i][aim] && goal[i]==0)\n      {\n\tgoal[i]=1;\n\tcan_goal(i);\n      }\n}\n\nvoid solve(int start)\n{\n  int i,next;\n\n  //printf(\"st=%d|\",start);\n\n  for(i=1;i<=max_r;i++)\n    {\n      next=start+i;\n      next = ((next>n+1)?(n+1):(next<0?0:next));\n      next += d[next];\n      next = ((next>n+1)?(n+1):(next<0?0:next));\n\n      if(goal[next]==0)\n\t{\n\t  //printf(\"not reach=%d\\n\",next);\n\t  result=0;\n\t  return;\n\t}\n      if(reach[next]==0)\n\t{\n\t  reach[next]=1;\n\t  solve(next);\n\t}\n    }\n}\nvoid show_graph()\n{\n  int i,j;\n  for(i=0;i<=n+1;i++)\n    {\n      printf(\"%d|\",i);\n      for(j=0;j<=n+1;j++)\n\tif(connect[i][j])\n\t  printf(\"%02d|\",j);\n      printf(\"\\n\");\n    }\n}\n\n\nvoid show_goal()\n{\n  int i;\n  for(i=0;i<=n;i++)\n    printf(\"%02d|\",i);\n  printf(\" G|\\n\");\n  for(i=0;i<=n+1;i++)\n    printf(\"%2d|\",goal[i]);\n  printf(\"\\n\");\n}\n\nmain()\n{\n  int i;\n  \n  while(scanf(\"%d\",&max_r)  && (max_r))\n    {\n      memset(connect,0,sizeof(connect));\n      memset(goal    ,0,sizeof(goal)   );\n      memset(reach  ,0,sizeof(reach)  );\n      scanf(\"%d\",&n);\n      for(i=1;i<=n;i++)\n\tscanf(\"%d\",&d[i]);\n\n      make_graph();\n      //show_graph();\n      can_goal(n+1);\n      //show_goal();\n      result=1;\n      solve(0);\n      \n      printf(\"%s\\n\",result?\"OK\":\"NG\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint max;\n\tint n;\n\tint d[251];\n\tint i,j;\n\twhile(1){\n\t\tscanf(\"%d\",&max);\n\t\tif(max==0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\ti=0;\n\t\twhile(i<n){\n\t\t\twhile(d[i]>=0){\n\t\t\t\ti++;\n\t\t\t\tif(i>n){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>n){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(j=0;j<max;j++){\n\t\t\t\t//printf(\"%d %d\\n\",d[i+j],-j-1);\n\t\t\t\tif(d[i+j]>=-j-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j==max){\n\t\t\t\ti=n+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\t\n\t\t}\n\t\tif(i>n){\n\t\t\tprintf(\"OK\\n\");\n\t\t}else{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n,m;\nint d[256];\nint func(int cid,int f[]){\n\tint i,j,id,ff;\n\t//printf(\"%d %d\\n\",cid,f[cid]);\n\tif(cid==n+1)return 1;\n\tff=0;\n\tfor(i=1;i<=m;i++){\n\t\tid=cid+i+d[cid+i];\n\t\tif(id<0)id=0;\n\t\tif(id>n+1)id=n+1;\n\t\t\n\t\tif(f[id]==1)continue;\n\n\t\tf[id]=1;\n\t\tif(func(id,f)==0)return 0;\n\t\telse ff=1;\n\t\tf[id]=0;\n\t}\n\treturn ff;\n}\nint main(){\n\tint i,j,f[256];\n\twhile(1){\n\t\tscanf(\"%d\",&m);\n\t\tif(m==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;i++)scanf(\"%d\",&d[i]);\n\t\t\n\t\tmemset(f,0,sizeof(f));\n\t\tf[0]=1;\n\t\tif(func(0,f)==1)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "void main(m,n,i,j,k,a){for(;a=1,scanf(\"%d\",&m),m;puts(a?\"OK\":\"NG\")){int d[300],g[300][300]={0};scanf(\"%d\",&n);for(i=1;i<=n;)scanf(\"%d\",d+i++);for(i=0;i<=n;i++)for(j=1;j<=m;j++)k=i+j+d[i+j],(k=k<0?0:n+1<k?n+1:k),g[i][k]=1;for(k=0;k<n+2;k++)for(i=0;i<n+2;i++)for(j=0;j<n+2;j++)g[i][k]&&g[k][j]?g[i][j]=1:0;for(i=0;i<=n;i++)g[0][i]&&!g[i][n+1]?a=0:0;}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint max;\n\tint n;\n\tint d[251];\n\tint i,j;\n\twhile(1){\n\t\tscanf(\"%d\",&max);\n\t\tif(max==0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\ti=0;\n\t\twhile(i<n){\n\t\t\twhile(d[i]>=0){\n\t\t\t\ti++;\n\t\t\t\tif(i>n){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>n){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(j=0;j<max;j++){\n\t\t\t\t//printf(\"%d %d\\n\",d[i+j],-j-1);\n\t\t\t\tif(d[i+j]>-j-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j==max){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(d[i-j]>j+max){\n\t\t\t\t\t\tj=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j!=-1){\n\t\t\t\t\ti=n-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif(i>=n){\n\t\t\tprintf(\"OK\\n\");\n\t\t}else{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0262: Making Sugoroku\n// 2017.10.26 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar g[255][255];\nint d[255];\n\nint main()\n{\n\tint m, n, i, j, k, ans;\n\n\twhile (scanf(\"%d\", &m) && m > 0) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tscanf(\"%d\", &n);\n\t\tfor (i = 1; i <= n; i++) scanf(\"%d\", d+i);\n\t\tfor (i = 0; i <= n; i++) for (j = 1; j <= m; j++) {\n\t\t\tk = i + j + d[i+j];\n\t\t\tif (k < 0) k = 0;\n\t\t\telse if (k > n+1) k = n+1;\n\t\t\tg[i][k] = 1;\n\t\t}\n\n\t\tfor (k = 0; k <= n+1; k++)\n\t\t\tfor (i = 0; i <= n+1; i++) for (j = 0; j <= n+1; j++)\n\t\t\t\tif (g[i][k] && g[k][j]) g[i][j] = 1;\n\n\t\tans = 1;\n\t\tfor (i = 0; i <= n; i++) {\n\t\t\tif (g[0][i] && !g[i][n+1]) { ans = 0; break; }\n\t\t}\n\t\tputs(ans ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N_MAX 250\nshort m,n,d[N_MAX + 2],flag[N_MAX + 1],route[N_MAX],j;\nshort solve(short x){\n\tshort i,k,y,conf = 1;\n\troute[j++] = x;\n\tfor(i=1; i<=m; i++){\n\t\tshort contf;\n\t\tcont:\n\t\ty = x + i;\n\t\tif(y > n){\n\t\t\tconf = 0;\n\t\t\tbreak;\n\t\t}\n\t\ty += d[y];\n\t\tif(y < 0)y = 0;\n\t\tcontf = 0;\n\t\tfor(k=0;k<j;k++)if(route[k]==y)contf=1;\n\t\tif(contf)continue;/* confinement */\n\t\tif(y > n || flag[y] || solve(y)){\n\t\t\tconf = 0;continue;\n\t\t\t/* is can goal */\n\t\t}\n\t\t/* impossible: */\n\t\t--j;\n\t\treturn 0;\n\t}\n\t--j;\n\tif(conf){\n\t\treturn 0;\n\t}else{\n\t\tflag[x] = 1;\n\t\treturn 1;\n\t}\n}\n\nint main(void){\n\tshort i;\n\twhile(scanf(\"%hd\",&m),m){\n\t\tscanf(\"%hd\",&n);\n\t\td[0] = d[n + 1] = 0;\n\t\tflag[0] = 0;\n\t\tfor(i=1;i<=n;i++)flag[i]=0,scanf(\"%hd\",d+i);\n\t\tputs(solve(0)?\"OK\":\"NG\");\n\t\tj = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0262: Making Sugoroku\n// 2017.9.9 bal4u@uu\n\n#include <stdio.h>\n\nint d[252], m, n;\n\nint check(int k)\n{\n\tint i, s;\n\n\tif (m >= k) return 1;\n\tif ((s = k - m) < 0) s = 0;\n\tfor (i = k-1; i >= s; i--) {\n\t\tif (i+d[i] >= k-m ) { if (check(i+d[i])) return 1; }\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i;\n\n\twhile (scanf(\"%d\", &m) && m) {\n\t\tscanf(\"%d\", &n); n++;\n\t\tfor (i = 1; i < n; i++) scanf(\"%d\", d+i);\n\t\tif (m >= n) { puts(\"OK\"); continue; }\n\t\tputs(check(n) ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint max;\n\tint n;\n\tint d[251];\n\tint i,j;\n\twhile(1){\n\t\tscanf(\"%d\",&max);\n\t\tif(max==0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\ti=0;\n\t\twhile(i<n){\n\t\t\twhile(d[i]>=0){\n\t\t\t\ti++;\n\t\t\t\tif(i>n){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>n){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(j=0;j<max;j++){\n\t\t\t\tprintf(\"%d %d\\n\",d[i+j],-j-1);\n\t\t\t\tif(d[i+j]>=-j-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j==max){\n\t\t\t\ti=n+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\t\n\t\t}\n\t\tif(i>n){\n\t\t\tprintf(\"OK\\n\");\n\t\t}else{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(m,n,i,j,k,a){for(;a=1,scanf(\"%d\",&m),m;puts(a?\"OK\":\"NG\")){int d[300],g[300][300]={0};scanf(\"%d\",&n);for(i=1;i<=n;)scanf(\"%d\",d+i++);for(i=0;i<=n;i++)for(j=1;j<=m;j++)k=i+j+d[i+j],(k=k<0?0:n+1<k?n+1:k),g[i][k]=1;for(k=0;k<n+2;k++)for(i=0;i<n+2;i++)for(j=0;j<n+2;j++)g[i][k]&&g[k][j]?g[i][j]=1:0;for(i=0;i<=n;i++)g[0][i]&&!g[i][n+1]?a=0:0;}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint r_max,n;\nint order[252];\nchar visited[252];\nchar start_visit[252];\n\nvoid can_arrive_pre(int now) {\n\tint i;\n\tif(now>n+1 || start_visit[now])return;\n\tstart_visit[now]=1;\n\tfor(i=1;i<=r_max && now+i<=n+1;i++) {\n\t\tcan_arrive_pre(now+i+order[now+i]>=0?now+i+order[now+i]:0);\n\t}\n}\n\nint can_arrive(int now) {\n\tint i;\n\tif(now+r_max>=n+1)return 1;\n\tif(visited[now])return 0;\n\tvisited[now]=1;\n\tfor(i=1;i<=r_max;i++) {\n\t\tif(can_arrive(now+i+order[now+i]>=0?now+i+order[now+i]:0))return 1;\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tint i,ok;\n\twhile(scanf(\"%d\",&r_max)==1 && r_max>0) {\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;i++)scanf(\"%d\",&order[i]);\n\t\torder[0]=order[n+1]=0;\n\t\tmemset(start_visit,0,sizeof(start_visit));\n\t\tcan_arrive_pre(0);\n\t\tif(!start_visit[n+1])puts(\"NG\");\n\t\telse {\n\t\t\tok=1;\n\t\t\tfor(i=1;i<n+1;i++) {\n\t\t\t\tif(start_visit[i]) {\n\t\t\t\t\tmemset(visited,0,sizeof(visited));\n\t\t\t\t\tif(!can_arrive(i)) {\n\t\t\t\t\t\tputs(\"NG\");\n\t\t\t\t\t\tok=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)puts(\"OK\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint max;\n\tint n;\n\tint d[251];\n\tint i,j;\n\twhile(1){\n\t\tscanf(\"%d\",&max);\n\t\tif(max==0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&d[i]);\n\t\t}\n\t\ti=0;\n\t\twhile(i<n){\n\t\t\twhile(d[i]>=0){\n\t\t\t\ti++;\n\t\t\t\tif(i>n){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>n){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(j=0;j<max;j++){\n\t\t\t\t//printf(\"%d %d\\n\",d[i+j],-j-1);\n\t\t\t\tif(d[i+j]>-j-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j==max){\n\t\t\t\ti=n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif(i>n){\n\t\t\tprintf(\"OK\\n\");\n\t\t}else{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(m,n,i,j,k,a){for(;a=1,scanf(\"%d\",&m),m;puts(a?\"OK\":\"NG\")){int d[300],g[300][300]={0};scanf(\"%d\",&n);for(i=1;i<=n;)scanf(\"%d\",d+i++);for(i=0;i<=n;i++)for(j=1;j<=m;j++)k=i+j+d[i+j],(k=k<0?0:n+1<k?n+1:k),g[i][k]=1;for(k=0;k<n+2;k++)for(i=0;i<n+2;i++)for(j=0;j<n+2;j++)g[i][k]&&g[k][j]?g[i][j]=1:0;for(i=0;i<=n;i++)g[0][i]&&!g[i][n+1]?a=0:0;}return 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N_MAX 250\nshort m,n,f[N_MAX+2],d[N_MAX],ij[N_MAX + 2][N_MAX + 2],used[N_MAX + 2],s[N_MAX + 2][N_MAX + 2];\n\nshort min(short i,short j){return(i<j)?i:j;}\n\nvoid dijkstra(short x){\n    short u,v;\n    for(u=0;u<n+2;u++)used[u]=0,s[x][u]=1;\n    s[x][x] = 0;\n    for(;;){\n        v = -1;\n        for(u=0;u<n+2;u++)if(!used[u] && (v < 0 || s[x][u] < s[x][v]))v = u;\n        if(v < 0)break;\n        used[v] = 1;\n        for(u=0;u<n+2;u++)s[x][u]=min(s[x][u],s[x][v]+1-ij[v][u]);\n    }\n    return;\n}\n\nshort solve(short x){\n    short i;\n    dijkstra(x);\n    if(s[x][n+1])return 0;\n    f[x] = 1;\n    for(i=0;i<=n;i++){\n        if(!f[i] && !s[x][i] && !solve(i))\n        return 0;\n    }\n    return 1;\n}\n\nvoid graph(void){\n    short i,j,k;\n    for(i=0;i < n + 2;i++){\n        for(j=0;j < n + 2;j++)ij[i][j]=0;\n        for(j=1;j<=m;j++){\n            k = i + j;\n            if(k > n)\n                k = n + 1;\n            else{\n                k += d[k - 1];\n                if(k < 0)k = 0;\n            }\n            ij[i][k] = 1;\n        }\n    }\n    return;\n}\n\nint main(void){\n    short i;\n    while(scanf(\"%hd\",&m),m){\n        scanf(\"%hd\",&n);\n        for(i=0;i<n;i++)d[i]=0,scanf(\"%hd\",d+i);\n        for(i=0;i<n+2;i++)f[i]=0;\n        graph();\n        puts(solve(0)?\"OK\":\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m,n;\nint arr[251];\nint tab[251][251];\nint visited[251];\nint visited2[251];\nvoid init();\nvoid rec(int);\nint solve(int);\n\nint main(){\n  int i,j,a,b;\n  while(1){\n    init();\n    scanf(\"%d\",&m);\n    if(m==0)break;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n      scanf(\"%d\",&a);\n      b=i+a;\n      if(b<0)b=0;\n      if(b>n+1)b=n+1;\n      arr[i]=b;\n      tab[i][b]=1;\n    }\n    rec(n+1);\n    /*\n    for(i=0;i<=n+1;i++){\n      printf(\"%d \",visited[i]);\n    }\n    printf(\"\\n\");\n    */\n    if(solve(0))printf(\"NG\\n\");\n    else printf(\"OK\\n\");\n  }\n  return 0;\n}\n\nint solve(int pos){\n  if(visited2[pos])return 0;\n  visited2[pos]=1;\n  if(!visited[pos])return 1;\n  int i,a;\n  for(i=1;i<=m;i++){\n    a=pos+i;\n    if(a>n+1)break;\n    a=arr[a];\n    if( solve(a) )return 1;\n  }\n  return 0;\n}\n\nvoid rec(int pos){\n  if(visited[pos])return;\n  visited[pos]=1;\n  int i,j,a,b;\n  for(i=0;i<=m;i++){\n    a=pos-i;\n    if(a<0)break;\n    for(j=0;j<=n;j++){\n      if(tab[j][a])rec(j);\n    }\n  }\n}\n\nvoid init(){\n  int i,j;\n  for(i=0;i<251;i++){\n    visited[i]=0;\n    visited2[i]=0;\n    for(j=0;j<251;j++){\n      tab[i][j]=0;\n    }\n  }\n  tab[0][0]=1;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc;\n\t\n\tint max;\n\tint n;\n\tint[] d;\n\tboolean[] done;\n\tvoid dfs(int depth) {\n\t\tif( depth >= n + 1 ) {\n\t\t\treturn;\n\t\t}\n\t\tif( done[depth] ) {\n\t\t\treturn;\n\t\t}\n\t\tdone[depth] = true;\n\t\t\n\t\tfor( int i = 1; i <= max; ++i ) {\n\t\t\tint ni = Math.min(depth + i, n + 1);\n\t\t\tni = Math.max(Math.min(ni + d[ni], n + 1), 0);\n\t\t\t\n\t\t\tdfs(ni);\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\tint cnt;\n\tint num;\n\tvoid search(int depth) {\n\t\tif( depth >= n + 1 ) {\n\t\t\treturn;\n\t\t}\n\t\tif( done[depth] ) {\n\t\t\t++cnt;\n\t\t\treturn;\n\t\t}\n\t\tdone[depth] = true;\n\t\t\n\t\tfor( int i = 1; i <= max; ++i ) {\n\t\t\tint ni = Math.min(depth + i, n + 1);\n\t\t\tni = Math.max(Math.min(ni + d[ni], n + 1), 0);\n\t\t\t\n\t\t\t++num;\n\t\t\tsearch(ni);\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile(true) {\n\t\t\tmax = sc.nextInt();\n\t\t\t\n\t\t\tif( max == 0 ) break;\n\t\t\t\n\t\t\tn = sc.nextInt();\n\t\t\td = new int[n + 2];\n\t\t\t\n\t\t\td[0] = 0;\n\t\t\tfor( int i = 1; i <= n; ++i ) {\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\td[n+1] = 0;\n\t\t\t\n\t\t\tdone = new boolean[n + 2];\n\t\t\tdfs(0);\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor( int i = 0; i <= n; ++i ) {\n\t\t\t\tif(done[i]) list.add(i);\n\t\t\t}\n\t\t\t\n\t\t\tboolean ans = false;\n\t\t\tfor( int i : list ) {\n\t\t\t\tcnt = 0;\n\t\t\t\tnum = 0;\n\t\t\t\tdone = new boolean[n + 2];\n\t\t\t\tsearch(i);\n\t\t\t\t\n\t\t\t\tans |= cnt==num;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans ? \"NG\" : \"OK\");\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.out.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n//\t\tnew AOJ0260().doIt();\n\t\tnew AOJ0262().doit();\n\t}\n\t\n\t\n\t\n\tclass AOJ0262{\n\t\tboolean flg;\n\t\tint get_index(int index,boolean[] a){\n\t\t\tif(index<=0)return 0;\n\t\t\tif(index>n||masu[index]==0)return index;\n\t\t\tif(a[index]==true){\n\t\t\t\tflg = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[index] = true;\n\t\t\treturn get_index(index+masu[index], a);\n\t\t}\n\t\t\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tflg = false;\n\t\t\tindex = get_index(index, new boolean[n+505]);\n\t\t\tif(flg)return false;\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tif(index>n)return true;\n\t\t\tif(index<=0)return false;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index]=cost;\n\t\t\tfor(int i=1;i<=m;i++)if(dfs(index+i,cost+1))return true;\n\t\t\treturn false;\n\t\t}\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+505];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+505];\n\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(sw)break;\n\t\t\t\t}\n\t\t\t\tif(sw)System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n//\t\tnew AOJ0260().doIt();\n\t\tnew AOJ0262().doit();\n\t}\n\t\n\t\n\t\n\tclass AOJ0262{\n\t\tboolean flg;\n\t\tint get_index(int index,boolean[] a){\n\t\t\tif(index<=0)return 0;\n\t\t\tif(index>n||masu[index]==0)return index;\n\t\t\tif(a[index]==true){\n\t\t\t\tflg = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[index] = true;\n\t\t\treturn get_index(index+masu[index], a);\n\t\t}\n\t\t\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tflg = false;\n\t\t\tindex = get_index(index, new boolean[n+300]);\n\t\t\tif(flg)return false;\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tif(index>n)return true;\n\t\t\tif(index<=0)return false;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index]=cost;\n\t\t\tfor(int i=1;i<=m;i++)if(dfs(index+i,cost+1))return true;\n\t\t\treturn false;\n\t\t}\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+300];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+300];\n\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(sw)break;\n\t\t\t\t}\n\t\t\t\tif(sw)System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n//\t\tnew AOJ0260().doIt();\n\t\tnew AOJ0262().doit();\n\t}\n\t\n\t\n\t\n\tclass AOJ0262{\n\t\t\n\t\tint get_index(int index,boolean[] a){\n\t\t\tif(index<=0||index>n||masu[index]==0)return index;\n\t\t\tif(a[index]==true)return 0;\n\t\t\ta[index] = true;\n\t\t\treturn get_index(index+masu[index], a);\n\t\t}\n\t\t\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tindex = get_index(index, new boolean[n+60]);\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tif(index>n)return true;\n\t\t\tif(index<=0)return false;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index]=cost;\n\t\t\tfor(int i=1;i<=m;i++)if(dfs(index+i,cost+1))return true;\n\t\t\treturn false;\n\t\t}\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+60];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+60];\n\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(sw)break;\n\t\t\t\t}\n\t\t\t\tif(sw)System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tclass AOJ0260{\n\t\tint dfs(int[] pype,int[] joynt){\n\t\t\tint result = 0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tif(n==0)break;\n\t\t\t\tint pype[] = new int[n];\n\t\t\t\tint joynt[] = new int[n-1];\n\t\t\t\tfor(int i=0;i<n;i++)pype[i] = in.nextInt();\n\t\t\t\tfor(int i=0;i<n-1;i++)joynt[i] = in.nextInt();\n\t\t\t\tArrays.sort(pype);\n\t\t\t\tArrays.sort(joynt);\n\t\t\t\tint result = dfs(pype,joynt);\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew AOJ0262().doIt();\n\t}\n\n\tclass AOJ0262{\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tboolean went_0;\n\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tindex = index+masu[index];\n\t\t\tif(index<0)index = 0;\n\t\t\tif(index==0)went_0=true;\n\t\t\tif(index>n)return true;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index] = cost;\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tif(dfs(index+i, cost+1))return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+505];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+505];\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\t\twent_0 = false;\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(went_0==true)continue;\n\t\t\t\t\tif(sw==false&&went_0==false)break;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sw? \"OK\":\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n  static Scanner sc = new Scanner(System.in);\n  static int max;\n  static int [] block;\n  static boolean [] block_visited;\n\n\tpublic static void main(String [] args){\n    while(readLine()){\n      if(solve())System.out.println(\"OK\");\n      else System.out.println(\"NG\");\n    }\n\t}\n\n  static boolean solve(){\n    int current_block, moved_block;\n    Deque <Integer> stack = new ArrayDeque <Integer>();\n    stack.push(0);\n    while(!stack.isEmpty()){\n      current_block = stack.pop();\n      for(int i = 1; i < max; i++){\n        moved_block = current_block + i;\n        if(moved_block >= block.length) return true;\n        else if(moved_block <= 0) moved_block = 0;\n        System.out.println(moved_block);\n        if(block_visited[moved_block]) continue;\n        else{\n          block_visited[moved_block] = true;\n          if(block[moved_block] == 0 ){\n            stack.push(moved_block);\n          }else{\n            stack.push(moved_block + block[moved_block]);\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  static boolean readLine(){\n    max = sc.nextInt();\n    if(max == 0)return false;\n    block = new int[sc.nextInt()];\n    block_visited = new boolean [block.length];\n    Arrays.fill(block_visited, false);\n    for(int i = 0; i < block.length; i++){\n      block[i]  = sc.nextInt();\n    }\n    return true;\n  }\n  \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc;\n\t\n\tint max;\n\tint n;\n\tint[] d;\n\tboolean[] done;\n\tboolean[] memo;\n\tboolean dfs(int depth) {\n\t\tif( depth >= n + 1 ) {\n\t\t\treturn true;\n\t\t}\n\t\tif( done[depth] ) {\n\t\t\treturn memo[depth];\n\t\t}\n\t\tdone[depth] = true;\n\t\tmemo[depth] = false;\n\t\t\n\t\tboolean flag = false;\n\t\tfor( int i = 1; i <= max; ++i ) {\n\t\t\tint ni = Math.min(depth + i, n + 1);\n\t\t\tni = Math.max(Math.min(ni + d[ni], n + 1), 0);\n\t\t\t\n\t\t\tflag |= dfs(ni);\n\t\t}\n\t\t\n\t\tmemo[depth] = flag;\n\t\treturn memo[depth];\n\t}\n\t\n\tvoid solve() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile(true) {\n\t\t\tmax = sc.nextInt();\n\t\t\t\n\t\t\tif( max == 0 ) break;\n\t\t\t\n\t\t\tn = sc.nextInt();\n\t\t\td = new int[n + 2];\n\t\t\t\n\t\t\td[0] = 0;\n\t\t\tfor( int i = 1; i <= n; ++i ) {\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\td[n+1] = 0;\n\t\t\t\n\t\t\tdone = new boolean[n + 2];\n\t\t\tmemo = new boolean[n + 2];\n\t\t\t\n\t\t\tboolean ans = dfs(0);\n\t\t\tfor( int i = 1; i <= n; ++i ) {\n\t\t\t\tif(done[i]) {\n\t\t\t\t\tans &= memo[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"OK\" : \"NG\");\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.out.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n\tstatic int max;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif(max == 0) break;\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] d = new int[n+2];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\td[i+1] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] list = new Node[n+2];\n\t\t\tfor(int i = 0; i < n+2; i++) {\n\t\t\t\tlist[i] = new Node(i);\n\t\t\t}\n\t\t\tdfs(0,list,d);\n\t\t\tboolean[] ok = new boolean[n+2];\n\t\t\tdfs(n+1,list,ok);\n\t\t\tboolean ans = dfs2(0,list,ok,new boolean[n+2]);\n\t\t\tSystem.out.println((ans)?\"OK\":\"NG\");\n\t\t}\n\t\t\n\t}\n\tstatic class Node {\n\t\tArrayList<Node> to = new ArrayList<Node>();\n\t\tArrayList<Node> dst = new ArrayList<Node>();\n\t\tint id;\n\t\tNode(int a) {\n\t\t\tid = a;\n\t\t}\n\t}\n\tstatic boolean dfs2(int a,Node[] b, boolean[] c, boolean[] d) {\n\t\tif(!c[a]) return false;\n\t\tif(d[a]) return true;\n\t\td[a] = true;\n\t\tboolean ret = true;\n\t\tfor(int i = 0; i < b[a].to.size(); i++) {\n\t\t\tret &= dfs2(b[a].to.get(i).id,b,c,d);\n\t\t}\n\t\treturn ret;\t\n\t}\n\t\n\t\n\t\n\tstatic void dfs(int a, Node[] b, boolean[] c) {\n\t\tif(c[a]) return;\n\t\tc[a] = true;\n\t\tfor(int i = 0; i < b[a].dst.size(); i++) {\n\t\t\tdfs(b[a].dst.get(i).id,b,c);\n\t\t}\t\n\t}\n\t\n\tstatic void dfs(int a, Node[] b, int[] c) {\n\t\tfor(int i = 1; i <= max; i++) {\n\t\t\tint to = a + i;\n\t\t\tif(to >= b.length) to = b.length-1;\n\t\t\tto += c[to];\n\t\t\tif(to >= b.length) to = b.length-1;\n\t\t\tif(to < 0) to = 0;\n\t\t\tif(b[a].to.contains(b[to])) return;\n\t\t\tb[a].to.add(b[to]);\n\t\t\tif(b[to].dst.contains(b[a])) return;\n\t\t\tb[to].dst.add(b[a]);\n\t\t\t\n\t\t\tdfs(to,b,c);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int max =sc.nextInt();\n\t\t\t\n\t\t\tif(max == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int size = n + 2;\n\t\t\t\n\t\t\tint[] map = new int[size];\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tmap[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t//int[][] adj = new int[size][max];\n\t\t\tboolean[][] adj = new boolean[size][size];\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tfor(int j = 0; j < max; j++){\n\t\t\t\t\tif(i == size - 1){\n\t\t\t\t\t\tadj[i][i] = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfinal int num = j + 1;\n\t\t\t\t\tfinal int to = Math.min(size - 1, Math.max(0, i + num));\n\t\t\t\t\tfinal int dist = Math.min(size - 1, Math.max(0, to + map[to]));\n\t\t\t\t\t\n\t\t\t\t\tadj[i][dist] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\t\tadj[i][j] = adj[i][j] || (adj[i][k] && adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean flag = true;\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t//System.out.print(i + \" \");\n\t\t\t\t//System.out.print(adj[0][i] + \" \");\n\t\t\t\t//System.out.println(adj[i][size-1]);\n\t\t\t\t\n\t\t\t\tif(adj[0][i] && !adj[i][size-1]){\n\t\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n\tstatic int max;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif(max == 0) break;\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] d = new int[n+2];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\td[i+1] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] list = new Node[n+2];\n\t\t\tfor(int i = 0; i < n+2; i++) {\n\t\t\t\tlist[i] = new Node(i);\n\t\t\t}\n\t\t\tdfs(0,list,d);\n\t\t\tboolean[] ok = new boolean[n+2];\n\t\t\tdfs(n+1,list,ok);\n\t\t\tboolean ans = dfs2(0,list,ok,new boolean[n+2]);\n\t\t\tSystem.out.println((ans)?\"OK\":\"NG\");\n\t\t}\n\t\t\n\t}\n\tstatic class Node {\n\t\tArrayList<Node> to = new ArrayList<Node>();\n\t\tArrayList<Node> dst = new ArrayList<Node>();\n\t\tint id;\n\t\tNode(int a) {\n\t\t\tid = a;\n\t\t}\n\t}\n\tstatic boolean dfs2(int a,Node[] b, boolean[] c, boolean[] d) {\n\t\tif(!c[a]) return false;\n\t\tif(d[a]) return true;\n\t\td[a] = true;\n\t\tboolean ret = true;\n\t\tfor(int i = 0; i < b[a].to.size(); i++) {\n\t\t\tret &= dfs2(b[a].to.get(i).id,b,c,d);\n\t\t}\n\t\treturn ret;\t\n\t}\n\t\n\t\n\t\n\tstatic void dfs(int a, Node[] b, boolean[] c) {\n\t\tif(c[a]) return;\n\t\tc[a] = true;\n\t\tfor(int i = 0; i < b[a].dst.size(); i++) {\n\t\t\tdfs(b[a].dst.get(i).id,b,c);\n\t\t}\t\n\t}\n\t\n\tstatic void dfs(int a, Node[] b, int[] c) {\n\t\tfor(int i = 1; i <= max; i++) {\n\t\t\tint to = a + i;\n\t\t\tif(to >= b.length) to = b.length-1;\n\t\t\tto += c[to];\n\t\t\tif(to >= b.length) to = b.length-1;\n\t\t\tif(to < 0) to = 0;\n\t\t\t//if(b[a].to.contains(b[to])) return;\n\t\t\tb[a].to.add(b[to]);\n\t\t\tif(b[to].dst.contains(b[a])) return;\n\t\t\tb[to].dst.add(b[a]);\n\t\t\t\n\t\t\tdfs(to,b,c);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int max =sc.nextInt();\n\t\t\t\n\t\t\tif(max == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int size = n + 2;\n\t\t\t\n\t\t\tint[] map = new int[size];\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tmap[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t//int[][] adj = new int[size][max];\n\t\t\tboolean[][] adj = new boolean[size][size];\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tfor(int j = 0; j < max; j++){\n\t\t\t\t\tif(i == size - 1){\n\t\t\t\t\t\tadj[i][i] = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfinal int num = j + 1;\n\t\t\t\t\tfinal int to = Math.min(size - 1, Math.max(0, i + num));\n\t\t\t\t\tfinal int dist = Math.min(size - 1, Math.max(0, to + map[to]));\n\t\t\t\t\t\n\t\t\t\t\tadj[i][dist] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\t\tadj[i][j] = adj[i][j] || (adj[i][k] && adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean flag = true;\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t//System.out.print(i + \" \");\n\t\t\t\t//System.out.print(adj[0][i] + \" \");\n\t\t\t\t//System.out.println(adj[i][size-1]);\n\t\t\t\t\n\t\t\t\tif(adj[0][i] && !adj[i][size-1]){\n\t\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew AOJ0262().doIt();\n\t}\n\n\tclass AOJ0262{\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tboolean went_0;\n\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tindex = index+masu[index];\n\t\t\tif(index<0)index = 0;\n\t\t\tif(index==0)went_0=true;\n\t\t\tif(index>n)return true;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index] = cost;\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tif(dfs(index+i, cost+1))return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+505];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+505];\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\t\twent_0 = false;\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(sw==false&&went_0==false)break;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sw? \"OK\":\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int max;\n\tstatic int n;\n\tstatic int a[];\n\tstatic int edge[][];\n\tstatic int dp[];\n\n\tpublic static boolean dp(int k, int depth) {\n\t\tif (dp[k] == 1 || k == n + 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (n + 2 <= depth) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tboolean f = false;\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tif (!dp(i, depth + 1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[k] = 1;\n\t\treturn f;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tL: while (true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif (max == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tedge = new int[n + 2][n + 2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tdp = new int[n + 2];\n\n\t\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\t\tfor (int j = 1; j <= max; j++) {\n\t\t\t\t\tint next = i + j;\n\t\t\t\t\tif (next < n + 2) {\n\t\t\t\t\t\tnext += a[next];\n\t\t\t\t\t}\n\t\t\t\t\tnext = Math.min(next, n + 1);\n\t\t\t\t\tnext = Math.max(next, 0);\n\t\t\t\t\tedge[i][next] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (dp(0, 0)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport javax.naming.spi.DirStateFactory.Result;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n//\t\tnew AOJ0260().doIt();\n\t\tnew AOJ0262().doit();\n\t}\n\t\n\t\n\t\n\tclass AOJ0262{\n\t\tboolean flg;\n\t\tint get_index(int index,boolean[] a){\n\t\t\tif(index<=0)return 0;\n\t\t\tif(index>n||masu[index]==0)return index;\n\t\t\tif(a[index]==true){\n\t\t\t\tflg = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[index] = true;\n\t\t\treturn get_index(index+masu[index], a);\n\t\t}\n\t\t\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tflg = false;\n\t\t\tindex = get_index(index, new boolean[n+505]);\n\t\t\tif(flg)return false;\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tif(index>n)return true;\n\t\t\tif(index<0)index = 0;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index]=cost;\n\t\t\tfor(int i=1;i<=m;i++)if(dfs(index+i,cost+1))return true;\n\t\t\treturn false;\n\t\t}\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+505];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+505];\n\t\t\t\tboolean[] result = new boolean[n+1];\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(!sw)break;\n\t\t\t\t}\n\t\t\t\tif(sw)System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Making Sugoroku\npublic class Main{\n\t\n\tboolean[] e = new boolean[250], reach = new boolean[250];\n\t@SuppressWarnings(\"unchecked\")\n\tSet<Integer>[] next = new Set[250], rv = new Set[250];\n\tint max, n;\n\t\n\tvoid f(int v){\n\t\tif(e[v])return;\n\t\te[v] = true;\n\t\tfor(int x:rv[v])f(x);\n\t}\n\t\n\tvoid g(int v){\n\t\tif(reach[v])return;\n\t\treach[v] = true;\n\t\tfor(int x:next[v])g(x);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(int i=0;i<250;i++){\n\t\t\tnext[i] = new HashSet<Integer>();\n\t\t\trv[i] = new HashSet<Integer>();\n\t\t}\n\t\tfor(;;){\n\t\t\tmax = sc.nextInt();\n\t\t\tif(max==0)break;\n\t\t\tn = sc.nextInt();\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i=0;i<n;i++)d[i]=sc.nextInt();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tnext[i].clear();\n\t\t\t\trv[i].clear();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)for(int m=1;m<=max;m++){\n\t\t\t\tint nx = Math.min(i+m, n-1);\n\t\t\t\tnx = Math.max(0, Math.min(nx+d[nx], n-1));\n\t\t\t\tnext[i].add(nx);\n\t\t\t\trv[nx].add(i);\n\t\t\t}\n\t\t\tArrays.fill(e, false);\n\t\t\tArrays.fill(reach, false);\n\t\t\tf(n-1);\n\t\t\tg(0);\n\t\t\tboolean OK = true;\n\t\t\tfor(int i=0;i<n;i++)if(reach[i] && !e[i])OK = false;\n\t\t\tSystem.out.println(OK?\"OK\":\"NG\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport javax.naming.spi.DirStateFactory.Result;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\t//\t\tnew AOJ0260().doIt();\n\t\tnew AOJ0262().doit();\n\t}\n\n\n\n\tclass AOJ0262{\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tindex = index+masu[index];\n\t\t\tif(index<0)index = 0;\n\t\t\tif(index>n)return true;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index] = cost;\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tif(dfs(index+i, cost+1))return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+505];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tmap = new int[n+505];\n\t\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(sw==false)break;\n\t\t\t\t}\n\t\t\t\tif(sw)System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int max;\n\tstatic int n;\n\tstatic int a[];\n\tstatic int b[];\n\tstatic int edge[][];\n\tstatic int dp[];\n\n\tpublic static boolean dp(int k, int depth) {\n\t\tif (dp[k] == 1 || k == n + 1) {\n\t\t\treturn true;\n\t\t} else if (depth == n + 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean f = false;\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tf = true;\n\t\t\t\tif (!dp(i, depth + 1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (f) {\n\t\t\tdp[k] = 1;\n\t\t}\n\t\treturn  f;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif (max == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tb = new int[n + 2];\n\t\t\tedge = new int[n + 2][n + 2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tdp = new int[n + 2];\n\n\t\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\t\tfor (int j = 1; j <= max; j++) {\n\t\t\t\t\tint next = i + j;\n\t\t\t\t\tif (next < n + 2) {\n\t\t\t\t\t\tnext += a[next];\n\t\t\t\t\t}\n\t\t\t\t\tnext = Math.min(next, n + 1);\n\t\t\t\t\tnext = Math.max(next, 0);\n\t\t\t\t\tedge[i][next] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp(0, 0)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n\tstatic int max;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] d = new int[n+2];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\td[i+1] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] list = new Node[n+2];\n\t\t\tfor(int i = 0; i < n+2; i++) {\n\t\t\t\tlist[i] = new Node(i);\n\t\t\t}\n\t\t\tdfs(0,list,d);\n\t\t\tboolean[] ok = new boolean[n+2];\n\t\t\tdfs(n+1,list,ok);\n\t\t\tboolean ans = dfs2(0,list,ok,new boolean[n+2]);\n\t\t\tSystem.out.println((ans)?\"OK\":\"NG\");\n\t\t}\n\t\t\n\t}\n\tstatic class Node {\n\t\tArrayList<Node> to = new ArrayList<Node>();\n\t\tArrayList<Node> dst = new ArrayList<Node>();\n\t\tint id;\n\t\tNode(int a) {\n\t\t\tid = a;\n\t\t}\n\t}\n\tstatic boolean dfs2(int a,Node[] b, boolean[] c, boolean[] d) {\n\t\tif(!c[a]) return false;\n\t\tif(d[a]) return true;\n\t\td[a] = true;\n\t\tboolean ret = true;\n\t\tfor(int i = 0; i < b[a].to.size(); i++) {\n\t\t\tret &= dfs2(b[a].to.get(i).id,b,c,d);\n\t\t}\n\t\treturn ret;\t\n\t}\n\t\n\t\n\t\n\tstatic void dfs(int a, Node[] b, boolean[] c) {\n\t\tif(c[a]) return;\n\t\tc[a] = true;\n\t\tfor(int i = 0; i < b[a].dst.size(); i++) {\n\t\t\tdfs(b[a].dst.get(i).id,b,c);\n\t\t}\t\n\t}\n\t\n\tstatic void dfs(int a, Node[] b, int[] c) {\n\t\tfor(int i = 1; i <= max; i++) {\n\t\t\tint to = a + i;\n\t\t\tif(to >= b.length) to = b.length-1;\n\t\t\tto += c[to];\n\t\t\tif(to >= b.length) to = b.length-1;\n\t\t\tif(to < 0) to = 0;\n\t\t\tif(b[a].to.contains(b[to])) return;\n\t\t\tb[a].to.add(b[to]);\n\t\t\tif(b[to].dst.contains(b[a])) return;\n\t\t\tb[to].dst.add(b[a]);\n\t\t\t\n\t\t\tdfs(to,b,c);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int max;\n\tstatic int n;\n\tstatic int a[];\n\tstatic int b[];\n\tstatic int edge[][];\n\tstatic int dp[];\n\n\tpublic static boolean dp(int k, int depth) {\n\t\tif (dp[k] == 1 || k == n + 1) {\n\t\t\treturn true;\n\t\t} else if (depth == n + 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean f = false;\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tf = true;\n\t\t\t\tif (!dp(i, depth + 1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdp[k] = 1;\n\t\treturn  f;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif (max == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tb = new int[n + 2];\n\t\t\tedge = new int[n + 2][n + 2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tdp = new int[n + 2];\n\n\t\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\t\tfor (int j = 1; j <= max; j++) {\n\t\t\t\t\tint next = i + j;\n\t\t\t\t\tif (next < n + 2) {\n\t\t\t\t\t\tnext += a[next];\n\t\t\t\t\t}\n\t\t\t\t\tnext = Math.min(next, n + 1);\n\t\t\t\t\tnext = Math.max(next, 0);\n\t\t\t\t\tedge[i][next] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp(0, 0)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n//\t\tnew AOJ0260().doIt();\n\t\tnew AOJ0262().doit();\n\t}\n\t\n\t\n\t\n\tclass AOJ0262{\n\t\t\n\t\tint get_index(int index,boolean[] a){\n\t\t\tif(index<=0)return 0;\n\t\t\tif(index>n||masu[index]==0)return index;\n\t\t\tif(a[index]==true)return 0;\n\t\t\ta[index] = true;\n\t\t\treturn get_index(index+masu[index], a);\n\t\t}\n\t\t\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tindex = get_index(index, new boolean[n+60]);\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tif(index>n)return true;\n\t\t\tif(index<=0)return false;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index]=cost;\n\t\t\tfor(int i=1;i<=m;i++)if(dfs(index+i,cost+1))return true;\n\t\t\treturn false;\n\t\t}\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+300];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+300];\n\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(sw)break;\n\t\t\t\t}\n\t\t\t\tif(sw)System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tclass AOJ0260{\n\t\tint dfs(int[] pype,int[] joynt){\n\t\t\tint result = 0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tif(n==0)break;\n\t\t\t\tint pype[] = new int[n];\n\t\t\t\tint joynt[] = new int[n-1];\n\t\t\t\tfor(int i=0;i<n;i++)pype[i] = in.nextInt();\n\t\t\t\tfor(int i=0;i<n-1;i++)joynt[i] = in.nextInt();\n\t\t\t\tArrays.sort(pype);\n\t\t\t\tArrays.sort(joynt);\n\t\t\t\tint result = dfs(pype,joynt);\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tme = scanner.nextInt();\n\t\t\tif (me == 0)\n\t\t\t\tbreak;\n\t\t\tn = scanner.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = scanner.nextInt();\n\t\t\tn += 2;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tbfs(0, vis);\n\t\t\tif (!vis[n - 1]) {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean ok = true;\n\t\t\tfor (int s = 1; s < n - 1; s++) {\n\t\t\t\tif (vis[s]) {\n\t\t\t\t\tboolean[] vis2 = new boolean[n];\n\t\t\t\t\tbfs(s, vis2);\n\t\t\t\t\tif (!vis2[n - 1]) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"OK\" : \"NG\");\n\t\t}\n\t}\n\n\tprivate void bfs(int s, boolean[] vis) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tvis[i] = (i == s);\n\t\tDeque<Integer> deque = new ArrayDeque<Integer>();\n\t\tdeque.push(s);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tint x = deque.poll();\n\t\t\tfor (int d = 1; d <= me; d++) {\n\t\t\t\tint xx = Math.min(x + d, n - 1);\n\t\t\t\txx = Math.max(Math.min(xx + a[xx], n - 1), 0);\n\t\t\t\tif (!vis[xx]) {\n\t\t\t\t\tvis[xx] = true;\n\t\t\t\t\tdeque.push(xx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint n, me;\n\tint[] a;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n  static Scanner sc = new Scanner(System.in);\n  static int max;\n  static int [] block;\n  static boolean [] block_visited;\n\n\tpublic static void main(String [] args){\n    while(readLine()){\n      if(solve())System.out.println(\"OK\");\n      else System.out.println(\"NG\");\n    }\n\t}\n\n  static boolean solve(){\n    int current_block, moved_block;\n    Deque <Integer> stack = new ArrayDeque <Integer>();\n    stack.push(0);\n    while(!stack.isEmpty()){\n      current_block = stack.pop();\n      for(int i = 1; i < max; i++){\n        moved_block = current_block + i;\n        if(moved_block >= block.length) return true;\n        else if(moved_block <= 0) moved_block = 0;\n        if(block_visited[moved_block]) continue;\n        else{\n          block_visited[moved_block] = true;\n          if(block[moved_block] == 0 ){\n            stack.push(moved_block);\n          }else{\n            stack.push(moved_block + block[moved_block]);\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  static boolean readLine(){\n    max = sc.nextInt();\n    if(max == 0)return false;\n    block = new int[sc.nextInt()];\n    block_visited = new boolean [block.length];\n    Arrays.fill(block_visited, false);\n    for(int i = 0; i < block.length; i++){\n      block[i]  = sc.nextInt();\n    }\n    return true;\n  }\n  \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport javax.naming.spi.DirStateFactory.Result;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n//\t\tnew AOJ0260().doIt();\n\t\tnew AOJ0262().doit();\n\t}\n\t\n\t\n\t\n\tclass AOJ0262{\n\t\tboolean flg;\n\t\tint get_index(int index,boolean[] a){\n\t\t\tif(index<=0)return 0;\n\t\t\tif(index>n||masu[index]==0)return index;\n\t\t\tif(a[index]==true){\n\t\t\t\tflg = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[index] = true;\n\t\t\treturn get_index(index+masu[index], a);\n\t\t}\n\t\t\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tflg = false;\n\t\t\tindex = get_index(index, new boolean[n+505]);\n\t\t\tif(flg)return false;\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tif(index>n)return true;\n\t\t\tif(index<0)index = 0;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index]=cost;\n\t\t\tfor(int i=1;i<=m;i++)if(dfs(index+i,cost+1))return true;\n\t\t\treturn false;\n\t\t}\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+505];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+505];\n\t\t\t\tboolean[] result = new boolean[n+1];\n\t\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(!sw)break;\n\t\t\t\t}\n\t\t\t\tif(sw)System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int max;\n\tstatic int n;\n\tstatic int a[];\n\tstatic int b[];\n\tstatic int edge[][];\n\tstatic int dp[];\n\n\tpublic static int  dp(int k, int depth) {\n\t\tif (dp[k] == 1 || k == n + 1) {\n\t\t\treturn 1;\n\t\t} else if (depth == n * n) {\n\t\t\treturn -1;\n\t\t} else if (b[k] == 1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tb[k] = 1;\n\t\tboolean f = false;\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tf = true;\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tif (dp(i, depth + 1) == -1) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[k] = 1;\n\t\treturn  1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif (max == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tb = new int[n + 2];\n\t\t\tedge = new int[n + 2][n + 2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tdp = new int[n + 2];\n\n\t\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\t\tfor (int j = 1; j <= max; j++) {\n\t\t\t\t\tint next = i + j;\n\t\t\t\t\tif (next < n + 2) {\n\t\t\t\t\t\tnext += a[next];\n\t\t\t\t\t}\n\t\t\t\t\tnext = Math.min(next, n + 1);\n\t\t\t\t\tnext = Math.max(next, 0);\n\t\t\t\t\tedge[i][next] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp(0, 0) == 1) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n    Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        new Main();\n    }\n \n    public Main() {\n        new AOJ0262().doIt();\n    }\n \n    class AOJ0262{\n        int n,m;\n        int[] masu;\n        boolean visit[],visit2[],visit3[];\n        int s,g;\n        \n        boolean dfs(int index){//スタート地点から行けるかどうか。\n        \tvisit2[index] = true;\n        \tif(index==g)return true;\n        \tfor(int i=1;i<=m;i++){\n        \t\tint next = i+index;\n        \t\tif(next<s)next = s;\n        \t\tif(next>g)next = g;\n        \t\tnext+=masu[next];\n        \t\tif(next<s)next = s;\n        \t\tif(next>g)next = g;\n        \t\tif(visit2[next])continue;\n        \t\tif(dfs(next))return true;\n        \t}\n        \treturn false;\n        }\n        \n        void start(int index){//スタートする場所\n//        \tSystem.out.println(index);\n        \tvisit[index] = true;\n    \t\tvisit2 = new boolean[n+2];\n        \tvisit3[index] = dfs(index);\n        \tfor(int i=1;i<=m;i++){\n        \t\tint next = i+index;\n        \t\tif(next<s)next = s;\n        \t\tif(next>g)next = g;\n        \t\tnext+=masu[next];\n        \t\tif(next<s)next = s;\n        \t\tif(next>g)next = g;\n        \t\tif(visit[next])continue;\n        \t\tstart(next);\n        \t}\n        }\n\n        boolean solve(){\n        \tvisit = new boolean[n+2];\n        \tvisit3 = new boolean[n+2];\n        \tstart(0);\n        \tfor(int i=0;i<=n;i++)if(visit[i]&&!visit3[i])return false;//そのマスからstartしていてゴールしていない\n        \treturn true;\n        }\n        \n        \n        \n        void doIt(){\n            while(true){\n                m = in.nextInt();\n                if(m==0)break;\n                n = in.nextInt();\n                masu = new int[n+2];\n                for(int i=1;i<=n;i++)masu[i] = in.nextInt();\n                s=0;g=n+1;\n                System.out.println(solve()? \"OK\":\"NG\");\n            }\n        }\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tme = scanner.nextInt();\n\t\t\tif (me == 0)\n\t\t\t\tbreak;\n\t\t\tn = scanner.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = scanner.nextInt();\n\t\t\tn += 2;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tbfs(0, vis);\n\t\t\tif (!vis[n - 1]) {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean ok = true;\n\t\t\tfor (int s = 1; s < n - 1; s++) {\n\t\t\t\tif (vis[s]) {\n\t\t\t\t\tboolean[] vis2 = new boolean[n];\n\t\t\t\t\tbfs(s, vis2);\n\t\t\t\t\tif (!vis2[n - 1]) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"OK\" : \"NG\");\n\t\t}\n\t}\n\n\tprivate void bfs(int s, boolean[] vis) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tvis[i] = (i == s);\n\t\tint[] Q = new int[n];\n\t\tint head = 0;\n\t\tint tail = 0;\n\t\tQ[tail++] = s;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[head++];\n\t\t\tfor (int d = 1; d <= me; d++) {\n\t\t\t\tint xx = Math.min(x + d, n - 1);\n\t\t\t\txx = Math.max(Math.min(xx + a[xx], n - 1), 0);\n\t\t\t\tif (!vis[xx]) {\n\t\t\t\t\tvis[xx] = true;\n\t\t\t\t\tQ[tail++] = xx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint n, me;\n\tint[] a;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc;\n\t\n\tint max;\n\tint n;\n\tint[] d;\n\tboolean[] done;\n\tvoid dfs(int depth) {\n\t\tif( depth >= n + 1 ) {\n\t\t\treturn;\n\t\t}\n\t\tif( done[depth] ) {\n\t\t\treturn;\n\t\t}\n\t\tdone[depth] = true;\n\t\t\n\t\tfor( int i = 1; i <= max; ++i ) {\n\t\t\tint ni = Math.min(depth + i, n + 1);\n\t\t\tni = Math.max(Math.min(ni + d[ni], n + 1), 0);\n\t\t\t\n\t\t\tdfs(ni);\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\tboolean res;\n\tvoid search(int depth) {\n\t\tif( depth >= n + 1 ) {\n\t\t\tres = false;\n\t\t\treturn;\n\t\t}\n\t\tif( done[depth] ) {\n\t\t\treturn;\n\t\t}\n\t\tdone[depth] = true;\n\t\t\n\t\tfor( int i = 1; i <= max; ++i ) {\n\t\t\tint ni = Math.min(depth + i, n + 1);\n\t\t\tni = Math.max(Math.min(ni + d[ni], n + 1), 0);\n\t\t\t\n\t\t\tsearch(ni);\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile(true) {\n\t\t\tmax = sc.nextInt();\n\t\t\t\n\t\t\tif( max == 0 ) break;\n\t\t\t\n\t\t\tn = sc.nextInt();\n\t\t\td = new int[n + 2];\n\t\t\t\n\t\t\td[0] = 0;\n\t\t\tfor( int i = 1; i <= n; ++i ) {\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\td[n+1] = 0;\n\t\t\t\n\t\t\tdone = new boolean[n + 2];\n\t\t\tdfs(0);\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor( int i = 0; i <= n; ++i ) {\n\t\t\t\tif(done[i]) list.add(i);\n\t\t\t}\n\t\t\t\n\t\t\tboolean ans = false;\n\t\t\tfor( int i : list ) {\n\t\t\t\tres = true;\n\t\t\t\tdone = new boolean[n + 2];\n\t\t\t\tsearch(i);\n\t\t\t\t\n\t\t\t\tans |= res;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans ? \"NG\" : \"OK\");\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.out.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n//\t\tnew AOJ0260().doIt();\n\t\tnew AOJ0262().doit();\n\t}\n\t\n\tclass AOJ0262{\n\t\tboolean dfs(int index,int cost){\n\t\t\tindex = masu[index]+index;\n\t\t\tif(index>n)return true;\n\t\t\tif(index<=0)return false;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index]=cost;\n\t\t\tfor(int i=1;i<m;i++)if(dfs(index+i, cost+1))return true;\n\t\t\treturn false;\n\t\t}\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+60];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+1];\n\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\tfor(int i=1;i<=m;i++)sw = dfs(i,0);\n\t\t\t\tif(sw)System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tclass AOJ0260{\n\t\tint dfs(int[] pype,int[] joynt){\n\t\t\tint result = 0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tif(n==0)break;\n\t\t\t\tint pype[] = new int[n];\n\t\t\t\tint joynt[] = new int[n-1];\n\t\t\t\tfor(int i=0;i<n;i++)pype[i] = in.nextInt();\n\t\t\t\tfor(int i=0;i<n-1;i++)joynt[i] = in.nextInt();\n\t\t\t\tArrays.sort(pype);\n\t\t\t\tArrays.sort(joynt);\n\t\t\t\tint result = dfs(pype,joynt);\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int max,n,now,goal,me;\n\tstatic int[] field;\n\tstatic int[][] dp;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tmax=cin.nextInt();\n\t\t\tif(max==0)break;\n\t\t\tn=cin.nextInt();\n\t\t\tnow=0;\n\t\t\tgoal=n+1;\n\t\t\tfield=new int[n+2];\n\t\t\tdp=new int[n+2][max+1];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfield[i]=cin.nextInt();\n\t\t\t}\n\t\t\tboolean ans=false;\n\t\t\tfor(me=2;me<=max;me++){\n\t\t\t\tif(bt(0)){\n\t\t\t\t\tans=true;\n//\t\t\t\t\tSystem.out.println(me+\" \"+true);\n\t\t\t\t}\n\t\t\t\telse{\n//\t\t\t\t\tSystem.out.println(me+\" \"+false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans){\n\t\t\t\tSystem.out.println(\"OK\");\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\tstatic boolean bt(int now){\n//\t\tSystem.out.println(now);\n\t\tif(dp[now][me]==1)return false;\n\t\tdp[now][me]=1;\n\t\tif(now==goal)return true;\n\t\tfor(int i=1;i<me;i++){\n\t\t\tif(bt(decide(now,i))){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic int  decide(int now,int me){\n\t\tnow+=me;\n\t\tif(now>goal){\n\t\t\tnow=goal;\n\t\t}\n\t\tnow += field[now];\n\t\tif(now>goal){\n\t\t\tnow=goal;\n\t\t}\n\t\tif(now<0){\n\t\t\tnow=0;\n\t\t}\n\t\treturn now;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n//\t\tnew AOJ0260().doIt();\n\t\tnew AOJ0262().doit();\n\t}\n\t\n\tclass AOJ0262{\n\t\tboolean dfs(int index,int cost){\n\t\t\tindex = masu[index]+index;\n\t\t\tif(index>n)return true;\n\t\t\tif(index<=0)return false;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index]=cost;\n\t\t\tfor(int i=1;i<m;i++)if(dfs(index+i, cost+1))return true;\n\t\t\treturn false;\n\t\t}\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+60];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+60];\n\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(sw)break;\n\t\t\t\t}\n\t\t\t\tif(sw)System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tclass AOJ0260{\n\t\tint dfs(int[] pype,int[] joynt){\n\t\t\tint result = 0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tif(n==0)break;\n\t\t\t\tint pype[] = new int[n];\n\t\t\t\tint joynt[] = new int[n-1];\n\t\t\t\tfor(int i=0;i<n;i++)pype[i] = in.nextInt();\n\t\t\t\tfor(int i=0;i<n-1;i++)joynt[i] = in.nextInt();\n\t\t\t\tArrays.sort(pype);\n\t\t\t\tArrays.sort(joynt);\n\t\t\t\tint result = dfs(pype,joynt);\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int max;\n\tstatic int n;\n\tstatic int a[];\n\tstatic int b[];\n\tstatic int edge[][];\n\tstatic int dp[];\n\n\tpublic static boolean dp(int k, int depth) {\n\t\tif (dp[k] == 1 || k == n + 1) {\n\t\t\treturn true;\n\t\t} else if (depth == n + 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean f = false;\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tf = true;\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tif (!dp(i, depth + 1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[k] = 1;\n\t\treturn  true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif (max == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tb = new int[n + 2];\n\t\t\tedge = new int[n + 2][n + 2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tdp = new int[n + 2];\n\n\t\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\t\tfor (int j = 1; j <= max; j++) {\n\t\t\t\t\tint next = i + j;\n\t\t\t\t\tif (next < n + 2) {\n\t\t\t\t\t\tnext += a[next];\n\t\t\t\t\t}\n\t\t\t\t\tnext = Math.min(next, n + 1);\n\t\t\t\t\tnext = Math.max(next, 0);\n\t\t\t\t\tedge[i][next] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp(0, 0)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;                                                                 \npublic class Main{                                                               \n  static Scanner sc = new Scanner(System.in);                                       \n  static int max;                                                                   \n  static int [] block;                                                              \n  static boolean [] block_visited;                                                  \n\n  public static void main(String [] args){                                          \n    while(readLine()){                                                              \n      if(solve())System.out.println(\"OK\");                                          \n      else System.out.println(\"NG\");                                                \n    }                                                                               \n  }                                                                                 \n\n  static boolean solve(){                                                           \n    int current_block, moved_block;                                                 \n    Deque <Integer> stack = new ArrayDeque <Integer>();\n    stack.push(0);\n    while(!stack.isEmpty()){\n      current_block = stack.pop();\n      for(int i = 1; i < max; i++){\n        moved_block = current_block + i;\n        if(moved_block >= block.length) return true;\n        else if(moved_block <= 0) moved_block = 0;\n        System.out.println(moved_block);\n        if(block_visited[moved_block]) continue;\n        else{\n          block_visited[moved_block] = true;\n          if(block[moved_block] == 0 ){\n            stack.push(moved_block);\n          }else{\n            stack.push(moved_block + block[moved_block]);\n          }\n        }\n      }\n    }\n    return false;\n  }\n static boolean readLine(){\n    max = sc.nextInt();\n    if(max == 0)return false;\n    block = new int[sc.nextInt()];\n    block_visited = new boolean [block.length];\n    Arrays.fill(block_visited, false);\n    for(int i = 0; i < block.length; i++){\n      block[i]  = sc.nextInt();\n    }\n    return true;\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew AOJ0262().doIt();\n\t}\n\n\tclass AOJ0262{\n\t\tint max,n;\n\t\tint[] masu;\n\t\tboolean search[];\n\t\t\n\t\tvoid dfs(int index){\n\t\t\tif(index<=0)index = 0;\n\t\t\tif(index>n)index = n+1;\n\t\t\tif(search[index])return;\n\t\t\tsearch[index] = true;\n\t\t\tfor(int i=1;i<=max;i++){\n\t\t\t\tdfs(i+index+masu[i+index]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tmax = in.nextInt();\n\t\t\t\tif(max==0)break;\n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+300];\n\t\t\t\tboolean sw[] = new boolean[max];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tfor(int i=1;i<=max;i++){\n\t\t\t\t\tsearch = new boolean[n+2];\n\t\t\t\t\tdfs(i+masu[i]);\n\t\t\t\t\tif(search[n+1])sw[i-1] = true;\n\t\t\t\t\telse if(!search[0]&&!search[n+1])sw[i-1] = false;//スタートにも行けてなくてゴールにも行けてない。\n\t\t\t\t}\n\t\t\t\tboolean a = true;\n//\t\t\t\tfor(int i=0;i<max;i++)System.out.println(sw[i]);\n\t\t\t\tfor(int i=0;i<max;i++)if(sw[i]==false)a = false;\n\t\t\t\tSystem.out.println(a? \"OK\":\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tme = scanner.nextInt();\n\t\t\tif (me == 0)\n\t\t\t\tbreak;\n\t\t\tn = scanner.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = scanner.nextInt();\n\t\t\tn += 2;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tbfs(0, vis);\n\t\t\tif (!vis[n - 1]) {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean ok = true;\n\t\t\tfor (int s = 1; s < n - 1; s++) {\n\t\t\t\tif (vis[s]) {\n\t\t\t\t\tboolean[] vis2 = new boolean[n];\n\t\t\t\t\tvis2[s] = true;\n\t\t\t\t\tbfs(s, vis2);\n\t\t\t\t\tif (!vis2[n - 1]) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"OK\" : \"NG\");\n\t\t}\n\t}\n\n\tprivate void bfs(int s, boolean[] vis) {\n\t\tDeque<Integer> deque = new ArrayDeque<Integer>();\n\t\tdeque.push(s);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tint x = deque.poll();\n\t\t\tfor (int d = 1; d <= me; d++) {\n\t\t\t\tint xx = Math.min(x + d, n - 1);\n\t\t\t\txx = Math.max(Math.min(xx + a[xx], n - 1), 0);\n\t\t\t\tif (!vis[xx]) {\n\t\t\t\t\tvis[xx] = true;\n\t\t\t\t\tdeque.push(xx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint n, me;\n\tint[] a;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n\tpublic static final int BIG_NUM = 2000000000;\n\tpublic static final int MOD = 1000000007;\n\tpublic static final long HUGE_NUM = 99999999999999999L;\n\tpublic static final double EPS = 0.000000001;\n\n\tpublic static final int OK = 0;\n\tpublic static final int NOT = 1;\n\tpublic static final int UNDEFINED = 2;\n\tpublic static final int SIZE = 255;\n\tpublic static int table[];\n\tpublic static int min_dist1[],min_dist2[];\n\tpublic static int MAX;\n\tpublic static int N;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\n\t\t//BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\ttable = new int[SIZE];\n\t\tmin_dist1 = new int[SIZE];\n\t\tmin_dist2 = new int[SIZE];\n\n\t\tStringBuilder ans = new StringBuilder();\n\n\t\twhile(true){\n\n\t\t\tMAX = scanner.nextInt();\n\t\t\tif(MAX == 0)break;\n\n\t\t\tN = scanner.nextInt();\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\n\t\t\t\ttable[i] = scanner.nextInt();\n\t\t\t}\n\n\t\t\tmin_dist1[0] = 0;\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\n\t\t\t\tmin_dist1[i] = BIG_NUM;\n\t\t\t}\n\n\t\t\tPriorityQueue<Info> Q = new PriorityQueue<Info>();\n\n\t\t\t//startから行けるセルを調べる\n\n\t\t\tfor(int i = 1; i <= MAX; i++){\n\n\t\t\t\tint loc = i;\n\t\t\t\tif(loc >= N+1){\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tloc += table[i];\n\t\t\t\tif(loc >= N+1){\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(loc <= 0){\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmin_dist1[loc] = 1;\n\t\t\t\tQ.add(new Info(loc,1));\n\t\t\t}\n\n\t\t\twhile(!Q.isEmpty()){\n\n\t\t\t\tif(Q.peek().sum_dist > min_dist1[Q.peek().node_id]){\n\n\t\t\t\t\tQ.poll();\n\n\t\t\t\t}else{\n\n\t\t\t\t\tfor(int k = 1; k <= MAX; k++){\n\n\t\t\t\t\t\tint loc = Q.peek().node_id+k;\n\t\t\t\t\t\tif(loc >= N+1)continue;\n\n\t\t\t\t\t\tloc += table[loc];\n\n\t\t\t\t\t\tif(loc >= N+1 || loc <= 0)continue;\n\n\t\t\t\t\t\tif(min_dist1[loc] > Q.peek().sum_dist+1){\n\t\t\t\t\t\t\tmin_dist1[loc] = Q.peek().sum_dist+1;\n\t\t\t\t\t\t\tQ.add(new Info(loc,min_dist1[loc]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tQ.poll();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean FLG = true;\n\n\t\t\tfor(int i = 0; i <= N; i++){\n\t\t\t\tif(min_dist1[i] == BIG_NUM)continue;\n\n\t\t\t\tfor(int k = 0; k <= N+1; k++){\n\n\t\t\t\t\tmin_dist2[k] = BIG_NUM;\n\t\t\t\t}\n\n\t\t\t\tmin_dist2[i] = 0;\n\t\t\t\tQ.add(new Info(i,0));\n\n\t\t\t\twhile(!Q.isEmpty()){\n\n\t\t\t\t\tif(Q.peek().sum_dist > min_dist2[Q.peek().node_id]){\n\n\t\t\t\t\t\tQ.poll();\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tfor(int k = 1; k <= MAX; k++){\n\n\t\t\t\t\t\t\tint loc = Q.peek().node_id+k;\n\t\t\t\t\t\t\tif(loc >= N+1){\n\n\t\t\t\t\t\t\t\tmin_dist2[N+1] = Q.peek().node_id+1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tloc += table[loc];\n\n\t\t\t\t\t\t\tif(loc >= N+1){\n\n\t\t\t\t\t\t\t\tmin_dist2[N+1] = Q.peek().node_id+1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(loc <= 0){\n\n\t\t\t\t\t\t\t\tloc = 0;\n\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\tif(min_dist2[loc] > Q.peek().sum_dist+1){\n\t\t\t\t\t\t\t\tmin_dist2[loc] = Q.peek().sum_dist+1;\n\t\t\t\t\t\t\t\tQ.add(new Info(loc,min_dist2[loc]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(min_dist2[N+1] != BIG_NUM){\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tQ.poll();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile(!Q.isEmpty())Q.poll();\n\n\t\t\t\tif(min_dist2[N+1] == BIG_NUM){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG){\n\n\t\t\t\tans.append(\"OK\\n\");\n\t\t\t}else{\n\n\t\t\t\tans.append(\"NG\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(ans.toString());\n\t}\n}\n\nclass Info implements Comparable<Info>{\n\tpublic int node_id;\n\tpublic int sum_dist;\n\n\tInfo(int arg_node_id,int arg_sum_dist){\n\t\tthis.node_id = arg_node_id;\n\t\tthis.sum_dist = arg_sum_dist;\n\t}\n\n\tpublic int compareTo(Info arg){\n\t\tif(this.sum_dist < arg.sum_dist)return -1;\n\t\tif(this.sum_dist > arg.sum_dist)return 1;\n\t\treturn 0;\n\t}\n}\n\nclass UTIL{\n\n\t//最大公約数\n\tpublic static long gcd(long x,long y){\n\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\n\t\tif(x < y){\n\n\t\t\tlong tmp = y;\n\t\t\ty = x;\n\t\t\tx = tmp;\n\t\t}\n\n\t\tif(y == 0){\n\n\t\t\treturn x;\n\t\t}else{\n\n\t\t\treturn gcd(y,x%y);\n\t\t}\n\t}\n\n\t//最小公倍数\n\tpublic static long lcm(long x,long y){\n\n\t\treturn (x*y)/gcd(x,y);\n\t}\n\n\t//String→intへ変換\n    public static int getNUM(String tmp_str){\n\n        return Integer.parseInt(tmp_str);\n    }\n\n    //文字が半角数字か判定する関数\n    public static boolean isNumber(String tmp_str){\n\n        if(tmp_str == null || tmp_str.length() == 0){\n\n            return false;\n        }\n\n        Pattern pattern = Pattern.compile(\"\\\\A[0-9]+\\\\z\");\n        Matcher matcher = pattern.matcher(tmp_str);\n        return matcher.matches();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew AOJ0262().doIt();\n\t}\n\n\tclass AOJ0262{\n\t\tint max,n;\n\t\tint[] masu;\n\t\tboolean search[];\n\t\t\n\t\tvoid dfs(int index){\n\t\t\tif(index<=0)index = 0;\n\t\t\tif(index>n)index = n+1;\n\t\t\tif(search[index])return;\n\t\t\tsearch[index] = true;\n\t\t\tfor(int i=1;i<=max;i++){\n\t\t\t\tdfs(i+index+masu[i+index]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tmax = in.nextInt();\n\t\t\t\tif(max==0)break;\n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+300];\n\t\t\t\tboolean sw[] = new boolean[max];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tfor(int i=1;i<=max;i++){\n\t\t\t\t\tsearch = new boolean[n+2];\n\t\t\t\t\tdfs(i+masu[i]);\n\t\t\t\t\tsw[i-1] = search[n+1];\n\t\t\t\t}\n\t\t\t\tboolean a = true;\n\t\t\t\tfor(int i=0;i<max;i++)if(sw[i]==false)a = false;\n\t\t\t\tSystem.out.println(a? \"OK\":\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew AOJ0262().doIt();\n\t}\n\n\tclass AOJ0262{\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tboolean went_0;\n\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tindex = index+masu[index];\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tif(index<0)index = 0;\n\t\t\tif(index==0)went_0=true;\n\t\t\tif(index>n)return true;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index] = cost;\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tif(dfs(index+i, cost+1))return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+505];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+505];\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\t\twent_0 = false;\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(went_0==true)continue;\n\t\t\t\t\tif(sw==false)break;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sw? \"OK\":\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t\n\tclass C{\n\t\tint pos, step, start;\n\t\tpublic C(int pos, int step, int start) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.step = step;\n\t\t\tthis.start = start;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tint max = sc.nextInt();\n\t\t\tif(max == 0) break;\n\t\t\tint n = sc.nextInt();\n\t\t\tint [] data  = new int[n + 2];\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t}\n\t\t\tn += 2;\n\t\t\tLinkedList<C> open = new LinkedList<Main.C>();\n\t\t\topen.add(new C(0, 0, 0));\n\t\t\tboolean [][] close = new boolean[n][n];\n\t\t\tclose[0][0] = true;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\tif(now.pos == n-1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i = 1; i <= max; i++){\n\t\t\t\t\tint npos = now.pos + i;\n\t\t\t\t\tif(n <= npos){\n\t\t\t\t\t\tnpos = n-1;\n\t\t\t\t\t}\n\t\t\t\t\tif(data[npos] != 0){\n\t\t\t\t\t\tnpos = npos + data[npos];\n\t\t\t\t\t\tif(0 > npos){\n\t\t\t\t\t\t\tnpos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(npos >= n){\n\t\t\t\t\t\t\tnpos = n-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(! close[now.start][npos]){\n\t\t\t\t\t\tclose[now.start][npos] = true;\n\t\t\t\t\t\topen.add(new C(npos, now.step + 1, now.start));\n\t\t\t\t\t}\n\t\t\t\t\tif(! close[npos][npos]){\n\t\t\t\t\t\tclose[npos][npos] = true;\n\t\t\t\t\t\topen.add(new C(npos, 0, npos));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans = true;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(close[i][n-1] == false && close[i][i]){\n\t\t\t\t\tans = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"OK\" : \"NG\");\n\t\t}\n\t}\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n\tstatic int max;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif(max == 0) break;\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] d = new int[n+2];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\td[i+1] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] list = new Node[n+2];\n\t\t\tfor(int i = 0; i < n+2; i++) {\n\t\t\t\tlist[i] = new Node(i);\n\t\t\t}\n\t\t\tdfs(0,list,d);\n\t\t\tboolean[] ok = new boolean[n+2];\n\t\t\tdfs(n+1,list,ok);\n\t\t\tboolean ans = dfs2(0,list,ok,new boolean[n+2]);\n\t\t\tSystem.out.println((ans)?\"OK\":\"NG\");\n\t\t}\n\t\t\n\t}\n\tstatic class Node {\n\t\tArrayList<Node> to = new ArrayList<Node>();\n\t\tArrayList<Node> dst = new ArrayList<Node>();\n\t\tint id;\n\t\tNode(int a) {\n\t\t\tid = a;\n\t\t}\n\t}\n\tstatic boolean dfs2(int a,Node[] b, boolean[] c, boolean[] d) {\n\t\tif(!c[a]) return false;\n\t\tif(d[a]) return true;\n\t\td[a] = true;\n\t\tboolean ret = true;\n\t\tif(b[a].to.size() == 0) ret = false;\n\t\tfor(int i = 0; i < b[a].to.size(); i++) {\n\t\t\tret &= dfs2(b[a].to.get(i).id,b,c,d);\n\t\t}\n\t\treturn ret;\t\n\t}\n\t\n\t\n\t\n\tstatic void dfs(int a, Node[] b, boolean[] c) {\n\t\tif(c[a]) return;\n\t\tc[a] = true;\n\t\tfor(int i = 0; i < b[a].dst.size(); i++) {\n\t\t\tdfs(b[a].dst.get(i).id,b,c);\n\t\t}\t\n\t}\n\t\n\tstatic void dfs(int a, Node[] b, int[] c) {\n\t\tfor(int i = 1; i <= max; i++) {\n\t\t\tint to = a + i;\n\t\t\tif(to >= b.length) to = b.length-1;\n\t\t\tto += c[to];\n\t\t\tif(to >= b.length) to = b.length-1;\n\t\t\tif(to < 0) to = 0;\n\t\t\tif(b[a].to.contains(b[to])) return;\n\t\t\tb[a].to.add(b[to]);\n\t\t\tif(b[to].dst.contains(b[a])) return;\n\t\t\tb[to].dst.add(b[a]);\n\t\t\t\n\t\t\tdfs(to,b,c);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tmax = scanner.nextInt();\n\t\t\tif (max == 0)\n\t\t\t\tbreak;\n\t\t\tn = scanner.nextInt();\n\t\t\tmap = new int[n + 2];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tmap[i] = scanner.nextInt();\n\t\t\tn += 2;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tvis[0] = true;\n\t\t\tdfs(0, vis);\n\t\t\tif (!vis[n - 1]) {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean flag = true;\n\t\t\tfor (int s = 1; s < n - 1; s++) {\n\t\t\t\tif (!vis[s])\n\t\t\t\t\tcontinue;\n\t\t\t\tboolean[] vis2 = new boolean[n];\n\t\t\t\tvis2[s] = true;\n\t\t\t\tdfs(s, vis2);\n\t\t\t\tif (!vis2[n - 1]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"OK\" : \"NG\");\n\n\t\t}\n\t}\n\n\tprivate void dfs(int s, boolean[] vis) {\n\t\tDeque<Integer> deque = new ArrayDeque<Integer>();\n\t\tdeque.push(s);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tint x = deque.poll();\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tint nx = Math.min(x + i, n - 1);\n\t\t\t\tnx = Math.max(Math.min(nx + map[nx], n - 1), 0);\n\t\t\t\tif (!vis[nx]) {\n\t\t\t\t\tvis[nx] = true;\n\t\t\t\t\tdeque.push(nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint max, n;\n\tint[] map;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n//\t\tnew AOJ0260().doIt();\n\t\tnew AOJ0262().doit();\n\t}\n\t\n\t\n\t\n\tclass AOJ0262{\n\t\tboolean sw;\n\t\tint get_index(int index,boolean[] a){\n\t\t\tif(index<=0)return 0;\n\t\t\tif(index>n||masu[index]==0)return index;\n\t\t\tif(a[index]==true){\n\t\t\t\tsw = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[index] = true;\n\t\t\treturn get_index(index+masu[index], a);\n\t\t}\n\t\t\n\t\tboolean dfs(int index,int cost){\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tsw = false;\n\t\t\tindex = get_index(index, new boolean[n+60]);\n\t\t\tif(sw)return false;\n//\t\t\tSystem.out.println(index+\" \"+cost);\n\t\t\tif(index>n)return true;\n\t\t\tif(index<=0)return false;\n\t\t\tif(map[index]<cost)return false;\n\t\t\tmap[index]=cost;\n\t\t\tfor(int i=1;i<=m;i++)if(dfs(index+i,cost+1))return true;\n\t\t\treturn false;\n\t\t}\n\t\tint n,m;\n\t\tint[] masu;\n\t\tint[] map;\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tm = in.nextInt();\n\t\t\t\tif(m==0)break; \n\t\t\t\tn = in.nextInt();\n\t\t\t\tmasu = new int[n+300];\n\t\t\t\tfor(int i=1;i<=n;i++)masu[i] = in.nextInt();\n\t\t\t\tboolean sw = false;\n\t\t\t\tmap = new int[n+300];\n\t\t\t\tArrays.fill(map, Integer.MAX_VALUE);\n\t\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\t\tsw = dfs(i,0);\n\t\t\t\t\tif(sw)break;\n\t\t\t\t}\n\t\t\t\tif(sw)System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tclass AOJ0260{\n\t\tint dfs(int[] pype,int[] joynt){\n\t\t\tint result = 0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tif(n==0)break;\n\t\t\t\tint pype[] = new int[n];\n\t\t\t\tint joynt[] = new int[n-1];\n\t\t\t\tfor(int i=0;i<n;i++)pype[i] = in.nextInt();\n\t\t\t\tfor(int i=0;i<n-1;i++)joynt[i] = in.nextInt();\n\t\t\t\tArrays.sort(pype);\n\t\t\t\tArrays.sort(joynt);\n\t\t\t\tint result = dfs(pype,joynt);\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int max;\n\tstatic int n;\n\tstatic int a[];\n\tstatic int b[];\n\tstatic int edge[][];\n\tstatic int dp[];\n\n\tpublic static boolean dp(int k, int depth) {\n\t\tif (dp[k] == 1 || k == n + 1) {\n\t\t\treturn true;\n\t\t} else if (depth == 5 * n) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean f = false;\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tf = true;\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tif (!dp(i, depth + 1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[k] = 1;\n\t\treturn  true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif (max == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tb = new int[n + 2];\n\t\t\tedge = new int[n + 2][n + 2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tdp = new int[n + 2];\n\n\t\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\t\tfor (int j = 1; j <= max; j++) {\n\t\t\t\t\tint next = i + j;\n\t\t\t\t\tif (next < n + 2) {\n\t\t\t\t\t\tnext += a[next];\n\t\t\t\t\t}\n\t\t\t\t\tnext = Math.min(next, n + 1);\n\t\t\t\t\tnext = Math.max(next, 0);\n\t\t\t\t\tedge[i][next] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp(0, 0)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n\tstatic int max;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif(max == 0) break;\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] d = new int[n+2];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\td[i+1] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] list = new Node[n+2];\n\t\t\tfor(int i = 0; i < n+2; i++) {\n\t\t\t\tlist[i] = new Node(i);\n\t\t\t}\n\t\t\tdfs(0,list,d);\n\t\t\tboolean[] ok = new boolean[n+2];\n\t\t\tdfs(n+1,list,ok);\n\t\t\tboolean ans = dfs2(0,list,ok,new boolean[n+2]);\n\t\t\tSystem.out.println((ans)?\"OK\":\"NG\");\n\t\t}\n\t\t\n\t}\n\tstatic class Node {\n\t\tArrayList<Node> to = new ArrayList<Node>();\n\t\tArrayList<Node> dst = new ArrayList<Node>();\n\t\tint id;\n\t\tNode(int a) {\n\t\t\tid = a;\n\t\t}\n\t}\n\tstatic boolean dfs2(int a,Node[] b, boolean[] c, boolean[] d) {\n\t\tif(!c[a]) return false;\n\t\tif(d[a]) return true;\n\t\td[a] = true;\n\t\tboolean ret = true;\n\t\tfor(int i = 0; i < b[a].to.size(); i++) {\n\t\t\tret &= dfs2(b[a].to.get(i).id,b,c,d);\n\t\t}\n\t\treturn ret;\t\n\t}\n\t\n\t\n\t\n\tstatic void dfs(int a, Node[] b, boolean[] c) {\n\t\tif(c[a]) return;\n\t\tc[a] = true;\n\t\tfor(int i = 0; i < b[a].dst.size(); i++) {\n\t\t\tdfs(b[a].dst.get(i).id,b,c);\n\t\t}\t\n\t}\n\t\n\tstatic void dfs(int a, Node[] b, int[] c) {\n\t\tfor(int i = 1; i <= max; i++) {\n\t\t\tint to = a + i;\n\t\t\tif(to >= b.length) to = b.length-1;\n\t\t\tto += c[to];\n\t\t\tif(to >= b.length) to = b.length-1;\n\t\t\tif(to < 0) to = 0;\n\t\t\tif(b[a].to.contains(b[to])) continue;\n\t\t\tb[a].to.add(b[to]);\n\t\t\tif(b[to].dst.contains(b[a])) continue;\n\t\t\tb[to].dst.add(b[a]);\n\t\t\t\n\t\t\tdfs(to,b,c);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Making Sugoroku\npublic class Main{\n\t\n\tboolean[] e = new boolean[252], reach = new boolean[252];\n\t@SuppressWarnings(\"unchecked\")\n\tSet<Integer>[] next = new Set[252], rv = new Set[252];\n\tint max, n;\n\t\n\tvoid f(int v){\n\t\tif(e[v])return;\n\t\te[v] = true;\n\t\tfor(int x:rv[v])f(x);\n\t}\n\t\n\tvoid g(int v){\n\t\tif(reach[v])return;\n\t\treach[v] = true;\n\t\tfor(int x:next[v])g(x);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(int i=0;i<252;i++){\n\t\t\tnext[i] = new HashSet<Integer>();\n\t\t\trv[i] = new HashSet<Integer>();\n\t\t}\n\t\tfor(;;){\n\t\t\tmax = sc.nextInt();\n\t\t\tif(max==0)break;\n\t\t\tn = sc.nextInt();\n\t\t\tint[] d = new int[n+2];\n\t\t\tfor(int i=1;i<=n;i++)d[i]=sc.nextInt();\n\t\t\tfor(int i=0;i<n+2;i++){\n\t\t\t\tnext[i].clear();\n\t\t\t\trv[i].clear();\n\t\t\t}\n\t\t\tfor(int i=0;i<n+1;i++)for(int m=1;m<=max;m++){\n\t\t\t\tint nx = Math.min(i+m, n+1);\n\t\t\t\tnx = Math.max(0, Math.min(nx+d[nx], n+1));\n\t\t\t\tnext[i].add(nx);\n\t\t\t\trv[nx].add(i);\n\t\t\t}\n\t\t\tArrays.fill(e, false);\n\t\t\tArrays.fill(reach, false);\n\t\t\tf(n+1);\n\t\t\tg(0);\n\t\t\tboolean OK = true;\n\t\t\tfor(int i=0;i<n+2;i++)if(reach[i] && !e[i])OK = false;\n\t\t\tSystem.out.println(OK?\"OK\":\"NG\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int max;\n\tstatic int n;\n\tstatic int a[];\n\tstatic int b[];\n\tstatic int edge[][];\n\tstatic int dp[];\n\n\tpublic static boolean dp(int k, int depth) {\n\t\tif (dp[k] == 1 || k == n + 1) {\n\t\t\treturn true;\n\t\t} else if (depth == 5 * n) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean f = false;\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tf = true;\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tedge[k][i] = 0;\n\t\t\t\tif (!dp(i, depth + 1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[k] = 1;\n\t\treturn  true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif (max == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tb = new int[n + 2];\n\t\t\tedge = new int[n + 2][n + 2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tdp = new int[n + 2];\n\n\t\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\t\tfor (int j = 1; j <= max; j++) {\n\t\t\t\t\tint next = i + j;\n\t\t\t\t\tif (next < n + 2) {\n\t\t\t\t\t\tnext += a[next];\n\t\t\t\t\t}\n\t\t\t\t\tnext = Math.min(next, n + 1);\n\t\t\t\t\tnext = Math.max(next, 0);\n\t\t\t\t\tedge[i][next] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp(0, 0)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int max;\n\tstatic int n;\n\tstatic int a[];\n\tstatic int edge[][];\n\tstatic int dp[];\n\n\tpublic static boolean dp(int k) {\n\t\tif (dp[k] == 1 || k == n + 1) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tboolean f = false;\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tif (i != k && edge[k][i] == 1) {\n\t\t\t\tif (!dp(i)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[k] = 1;\n\t\treturn f;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tL: while (true) {\n\t\t\tmax = sc.nextInt();\n\t\t\tif (max == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\ta = new int[n + 2];\n\t\t\tedge = new int[n + 2][n + 2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tdp = new int[n + 2];\n\n\t\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\t\tfor (int j = 1; j <= max; j++) {\n\t\t\t\t\tint next = i + j;\n\t\t\t\t\tif (next < n + 2) {\n\t\t\t\t\t\tnext += a[next];\n\t\t\t\t\t}\n\t\t\t\t\tnext = Math.min(next, n + 1);\n\t\t\t\t\tnext = Math.max(next, 0);\n\t\t\t\t\tedge[i][next] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (dp(0)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tvar max = int.Parse(Console.ReadLine().Trim());\n\t\t\tif (max == 0) break;\n\t\t\tvar n = int.Parse(Console.ReadLine().Trim());\n\t\t\tvar s = new int[n + 2];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ts[i + 1] = int.Parse(Console.ReadLine().Trim());\n\t\t\tvar aa = setEdge(s, max, n);\n\t\t\tvar dp = setDp(aa);\n\t\t\tgoWarshall(dp);\n\t\t\tConsole.WriteLine(getAns(dp)? \"OK\":\"NG\");\n\t\t}\n\t}\n\tstatic bool getAns (int[,] dp)\n\t{\n\t\tvar a = dp.GetLength(0);\n\t\tfor (int i = 0; i < a; i++)\n\t\t\tif (dp[i, a - 1] == 9999999) return false;\n\t\treturn true;\n\t}\n\tstatic int[,] setDp(List<int>[] aa)\n\t{\n\t\tvar n = aa.Length;\n\t\tvar dp = new int[n+1, n+1];\n\t\tfor (int i = 0; i < n+1; i++)\n\t\t\tfor (int j = 0; j < n+1; j++) dp[i, j] = 9999999;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tforeach (var x in aa[i])\n\t\t\t\tdp[i, x] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n+1; i++) dp[i, i] = 0;\n\t\treturn dp;\n\t}\n\tstatic List<int>[] setEdge(int[] s, int max, int n)\n\t{\n\t\tvar aa = new List<int>[n + 1];\n\t\tfor (int i = 0; i < n + 1; i++) aa[i] = new List<int>();\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = 1; j <= max; j++)\n\t\t\t{\n\t\t\t\tif (i + j <= n + 1)\n\t\t\t\t{\n\t\t\t\t\tvar cmd = s[i + j];\n\t\t\t\t\tvar np = i + j + cmd;\n\t\t\t\t\tif (np > n + 1) np = n + 1;\n\t\t\t\t\tif (np < 0) np = 0;\n\t\t\t\t\tif (!aa[i].Contains(np)   ) aa[i].Add(np);\n\t\t\t\t}\n\t\t\t}\n\t\treturn aa;\n\t}\n\tpublic static void goWarshall(int[,] dp)\n\t{\n\t\tvar n = dp.GetLength(0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\tdp[j, k] = Math.Min(dp[j, k], dp[j, i] + dp[i, k]);\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0262\n{\n    class Program\n    {\n        static Dictionary<int, HashSet<int>> adj;\n        static int max, n;\n        static int[] direction;\n        static bool[] sVisited, gVisited;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                max = RInt();\n                if (max == 0) break;\n                Init();\n                GotoGoal();\n                if (!adj.ContainsKey(n + 1))\n                {\n                    Console.WriteLine(\"NG\");\n                }\n                else\n                {\n                    GotoStart();\n                    bool flg = true;\n                    for (int i = 1; i < sVisited.Length; i++)\n                    {\n                        if (sVisited[i] && !gVisited[i])\n                        {\n                            flg = false;\n                            break;\n                        }\n                    }\n                    Console.WriteLine(flg ? \"OK\" : \"NG\");\n                }\n            }\n        }\n\n        private static void Init()\n        {\n            n = RInt();\n            direction = new int[n + 1];\n            for (int i = 1; i <= n; i++) direction[i] = RInt();\n            adj = new Dictionary<int, HashSet<int>>();\n            sVisited = new bool[n + 2];\n            gVisited = new bool[n + 2];\n        }\n\n        private static void GotoGoal()\n        {\n            Queue<int> q = new Queue<int>();\n            q.Enqueue(0);\n\n            while (q.Count > 0)\n            {\n                int cur = q.Dequeue();\n                if (sVisited[cur]) continue;\n                sVisited[cur] = true;\n\n                for (int i = 1; i <= max; i++)\n                {\n                    if (cur + i >= n + 1)\n                    {\n                        if (!adj.ContainsKey(n + 1)) adj.Add(n + 1, new HashSet<int>());\n                        adj[n + 1].Add(cur);\n                    }\n                    else\n                    {\n                        int next = cur + i + direction[cur + i];\n                        if (next >= n + 1)\n                        {\n                            if (!adj.ContainsKey(n + 1)) adj.Add(n + 1, new HashSet<int>());\n                            adj[n + 1].Add(cur);\n                        }\n                        else if (next < 0)\n                        {\n                            if (!adj.ContainsKey(0)) adj.Add(0, new HashSet<int>());\n                            adj[0].Add(cur);\n                        }\n                        else\n                        {\n                            if (!adj.ContainsKey(next)) adj.Add(next, new HashSet<int>());\n                            adj[next].Add(cur);\n                            q.Enqueue(next);\n                        }\n                    }\n                }\n            }\n        }\n\n        private static void GotoStart()\n        {\n            Queue<int> q = new Queue<int>();\n            q.Enqueue(n + 1);\n\n            while (q.Count > 0)\n            {\n                int cur = q.Dequeue();\n                if (gVisited[cur] || cur == 0) continue;\n                gVisited[cur] = true;\n\n                foreach (var next in adj[cur])\n                {\n                    q.Enqueue(next);\n                }\n            }\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tvar max = int.Parse(Console.ReadLine().Trim());\n\t\t\tif (max == 0) break;\n\t\t\tvar n = int.Parse(Console.ReadLine().Trim());\n\t\t\tvar s = new int[n + 2];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ts[i + 1] = int.Parse(Console.ReadLine().Trim());\n\t\t\tvar aa = setEdge(s, max, n);\n\t\t\tvar dp = setDp(aa);\n\t\t\tgoWarshall(dp);\n\t\t\tConsole.WriteLine(getAns(dp) ? \"OK\" : \"NG\");\n\t\t}\n\t}\n\tstatic bool getAns(bool[,] dp)\n\t{\n\t\tvar a = dp.GetLength(0);\n\t\tif (!dp[0, a - 1] ) return false;\n\t\tfor (int i = 1; i < a - 1; i++)\n\t\t\tif (dp[0, i]  && !dp[i, a - 1] ) return false;\n\t\treturn true;\n\t}\n\tstatic bool[,] setDp(List<int>[] aa)\n\t{\n\t\tvar n = aa.Length;\n\t\tvar dp = new bool[n + 1, n + 1];\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tforeach (var x in aa[i])\n\t\t\t\tdp[i, x] = true;\n\t\t}\n\t\tfor (int i = 0; i < n + 1; i++) dp[i, i] = true;\n\t\treturn dp;\n\t}\n\tstatic List<int>[] setEdge(int[] s, int max, int n)\n\t{\n\t\tvar aa = new List<int>[n + 1];\n\t\tfor (int i = 0; i < n + 1; i++) aa[i] = new List<int>();\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = 1; j <= max; j++)\n\t\t\t{\n\t\t\t\tif (i + j <= n + 1)\n\t\t\t\t{\n\t\t\t\t\tvar cmd = s[i + j];\n\t\t\t\t\tvar np = i + j + cmd;\n\t\t\t\t\tif (np > n + 1) np = n + 1;\n\t\t\t\t\tif (np < 0) np = 0;\n\t\t\t\t\tif (!aa[i].Contains(np)) aa[i].Add(np);\n\t\t\t\t}\n\t\t\t}\n\t\treturn aa;\n\t}\n\tpublic static void goWarshall(bool[,] dp)\n\t{\n\t\tvar n = dp.GetLength(0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\tif (dp[j, i] && dp[i, k]) dp[j, k] = true;\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tvar max = int.Parse(Console.ReadLine().Trim());\n\t\t\tif (max == 0) break;\n\t\t\tvar n = int.Parse(Console.ReadLine().Trim());\n\t\t\tvar s = new int[n + 2];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ts[i + 1] = int.Parse(Console.ReadLine().Trim());\n\t\t\tvar aa = setEdge(s, max, n);\n\t\t\tvar dp = setDp(aa);\n\t\t\tgoWarshall(dp);\n\t\t\tConsole.WriteLine(getAns(dp) ? \"OK\" : \"NG\");\n\t\t}\n\t}\n\tstatic bool getAns(int[,] dp)\n\t{\n\t\tvar a = dp.GetLength(0);\n\t\tif (dp[0, a - 1] == 9999999) return false;\n\t\tfor (int i = 1; i < a - 1; i++)\n\t\t\tif (dp[0, i] != 9999999 && dp[i, a - 1] == 9999999) return false;\n\t\treturn true;\n\t}\n\tstatic int[,] setDp(List<int>[] aa)\n\t{\n\t\tvar n = aa.Length;\n\t\tvar dp = new int[n + 1, n + 1];\n\t\tfor (int i = 0; i < n + 1; i++)\n\t\t\tfor (int j = 0; j < n + 1; j++) dp[i, j] = 9999999;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tforeach (var x in aa[i])\n\t\t\t\tdp[i, x] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n + 1; i++) dp[i, i] = 0;\n\t\treturn dp;\n\t}\n\tstatic List<int>[] setEdge(int[] s, int max, int n)\n\t{\n\t\tvar aa = new List<int>[n + 1];\n\t\tfor (int i = 0; i < n + 1; i++) aa[i] = new List<int>();\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = 1; j <= max; j++)\n\t\t\t{\n\t\t\t\tif (i + j <= n + 1)\n\t\t\t\t{\n\t\t\t\t\tvar cmd = s[i + j];\n\t\t\t\t\tvar np = i + j + cmd;\n\t\t\t\t\tif (np > n + 1) np = n + 1;\n\t\t\t\t\tif (np < 0) np = 0;\n\t\t\t\t\tif (!aa[i].Contains(np)) aa[i].Add(np);\n\t\t\t\t}\n\t\t\t}\n\t\treturn aa;\n\t}\n\tpublic static void goWarshall(int[,] dp)\n\t{\n\t\tvar n = dp.GetLength(0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\tdp[j, k] = Math.Min(dp[j, k], dp[j, i] + dp[i, k]);\n\t}\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n})\nprocess.stdin.on('end', function() {\n  main(input.split('\\n'));\n});\n\nfunction main (input) {\n\n  var max, n;\n  var i;\n  while ((max = input.shift() - 0) !== 0) {\n    var d = [];\n    n = input.shift() - 0;\n    d[0] = 0;\n    d[n + 1] = 0;\n    for (i = 1; i <= n; i++) {\n        d[i] = input.shift() - 0;\n    }\n    console.log(solve(max, n, d) ? 'OK' : 'NG');\n  }\n}\n\nfunction makeGraph(n){\n  var i, j, g;\n  g = [];\n  for (i = 0; i < n; i++) {\n    g[i] = [];\n    for (j = 0; j < n; j++) {\n      g[i][j] = i === j ? 0 : Infinity;\n    }\n  }\n  return g;\n}\n\nfunction warshall_floyd(d) {\n  var i, j, k,n= d.length;\n  for (k = 0; k < n; k++) {\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        d[i][j] = d[i][j] > d[i][k] + d[k][j] ? d[i][k] + d[k][j] : d[i][j];\n      }\n    }\n  }\n  return d;\n}\n\n\nfunction solve(max, n, d) {\n    var g = makeGraph(n + 2);\n    var i, j;\n    var pos;\n    for (i = 0; i <= n; i++) {\n        for (var j = max; j--; ) {\n            pos = i + j + (i + j < n + 1 ? d[i + j] : 0);\n            pos = Math.min(Math.max(pos, 0), n + 1);\n            if(pos !== i) {\n                g[i][pos] = 1;\n            }\n        }       \n    }\n\n    warshall_floyd(g);\n\n    for (i = 0; i <= n; i++) {\n      if(g[0][i] < Infinity && g[i][n+1] === Infinity) {\n        return false;\n      }\n    }\n    return true;\n    \n}"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\n\nvar max, n;\nvar i;\nfunction makeGraph(n){\n  var i, j, g;\n  g = [];\n  for (i = 0; i < n; i++) {\n    g[i] = [];\n    for (j = 0; j < n; j++) {\n      g[i][j] = i === j ? 0 : Infinity;\n    }\n  }\n  return g;\n}\n\nfunction warshall_floyd(d) {\n  var i, j, k,n= d.length;\n  for (k = 0; k < n; k++) {\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        d[i][j] = d[i][j] > d[i][k] + d[k][j] ? d[i][k] + d[k][j] : d[i][j];\n      }\n    }\n  }\n  return d;\n}\n\n\nfunction solve(max, n, d) {\n    var g = makeGraph(n + 2);\n    var i, j;\n    var pos;\n    for (i = 0; i <= n; i++) {\n        for (var j = max; j--; ) {\n            pos = i + j + (i + j < n + 1 ? d[i + j] : 0);\n            pos = Math.min(Math.max(pos, 0), n + 1);\n            if(pos !== i) {\n                g[i][pos] = 1;\n            }\n        }       \n    }\n\n    warshall_floyd(g);\n\n    for (i = 0; i <= n; i++) {\n      if(g[0][i] < Infinity && g[i][n+1] === Infinity) {\n        return false;\n      }\n    }\n    return true;\n    \n}\nwhile ((max = input.shift() - 0) !== 0) {\n    var d = [];\n    n = input.shift() - 0;\n    d[0] = 0;\n    d[n + 1] = 0;\n    for (i = 1; i <= n; i++) {\n        d[i] = input.shift() - 0;\n    }\n    console.log(solve(max, n, d) ? 'OK' : 'NG');\n}"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\n\nvar max, n;\nvar i;\nfunction matrix(n, m, init) {\n  var arr = [], i, j;\n  for (i = 0; i < n; i++) {\n    arr[i] = [];\n    for (j = 0; j < m; j++) {\n      arr[i][j] = init;\n    }\n  }\n  return arr;\n}\n\nfunction dijkstra(g, s) {\n  var d = [],\n      use = [],\n      i,\n      n = g.length,\n      v, u;\n  for (u = 0; u < n; u++) {\n    d[u] = Infinity;\n    use[u] = false;\n  }\n  d[s] = 0;\n  while (true) {\n    v = -1;\n    for (u = 0; u < n; u++) {\n      if (!use[u] && (v === -1 || d[v] > d[u])) {\n        v = u;\n      }\n    }\n    if (v === -1) {\n      break;\n    }\n    use[v] = true;\n    for (u = 0; u < n; u++) {\n      d[u] = d[u] < d[v] + g[v][u] ? d[u] : d[v] + g[v][u];\n    }\n  }\n  return d;\n}\n\nfunction solve(max, n, d) {\n    var g = matrix(n + 2, n + 2, Infinity);\n    var i, j;\n    var pos;\n    for (i = 0; i <= n; i++) {\n        for (var j = max; j--; ) {\n            pos = i + j + d[i + j];\n            pos = Math.min(Math.max(pos, 0), n + 1);\n            if(pos !== i) {\n                g[i][pos] = 1;\n            }\n        }       \n    }\n    var reachable = dijkstra(g, 0);\n    if (reachable[n+1] === Infinity) {\n        return false;\n    }\n    var d;\n    for (i = 1; i <= n; i++) {\n        if(reachable[i] < Infinity) {\n            d = dijkstra(g, i);\n            if(d[n+1] === Infinity) {\n                return false\n            }\n        }\n    }\n    return true;\n    \n}\nwhile ((max = input.shift() - 0) !== 0) {\n    var d = [];\n    n = input.shift() - 0;\n    d[0] = 0;\n    d[n + 1] = 0;\n    for (i = 1; i <= n; i++) {\n        d[i] = input.shift() - 0;\n    }\n    console.log(solve(max, n, d) ? 'OK' : 'NG');\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n})\nprocess.stdin.on('end', function() {\n  main(input.split('\\n'));\n});\n\nfunction main (input) {\n\n  var max, n;\n  var i;\n  while ((max = input.shift() - 0) !== 0) {\n    var d = [];\n    n = input.shift() - 0;\n    d[0] = 0;\n    d[n + 1] = 0;\n    for (i = 1; i <= n; i++) {\n        d[i] = input.shift() - 0;\n    }\n    console.log(solve(max, n, d) ? 'OK' : 'NG');\n  }\n}\n\nfunction makeGraph(n){\n  var i, j, g;\n  g = [];\n  for (i = 0; i < n; i++) {\n    g[i] = [];\n    for (j = 0; j < n; j++) {\n      g[i][j] = i === j ? 0 : Infinity;\n    }\n  }\n  return g;\n}\n\nfunction warshall_floyd(d) {\n  var i, j, k,n= d.length;\n  for (k = 0; k < n; k++) {\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        d[i][j] = d[i][j] > d[i][k] + d[k][j] ? d[i][k] + d[k][j] : d[i][j];\n      }\n    }\n  }\n  return d;\n}\n\n\nfunction solve(max, n, d) {\n    var g = makeGraph(n + 2);\n    var i, j;\n    var pos;\n    for (i = 0; i <= n; i++) {\n        for (j = 1; j <=max; j++) {\n            pos = i + j + (i + j < n + 1 ? d[i + j] : 0);\n            pos = Math.min(Math.max(pos, 0), n + 1);\n            if(pos !== i) {\n                g[i][pos] = 1;\n            }\n        }       \n    }\n\n    warshall_floyd(g);\n\n    for (i = 0; i <= n; i++) {\n      if(g[0][i] < Infinity && g[i][n+1] === Infinity) {\n        return false;\n      }\n    }\n    return true;\n    \n}"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\n\nvar max, n;\nvar i;\nfunction matrix(n, m, init) {\n  var arr = [], i, j;\n  for (i = 0; i < n; i++) {\n    arr[i] = [];\n    for (j = 0; j < m; j++) {\n      arr[i][j] = init;\n    }\n  }\n  return arr;\n}\n\nfunction dijkstra(g, s) {\n  var d = [],\n      use = [],\n      i,\n      n = g.length,\n      v, u;\n  for (u = 0; u < n; u++) {\n    d[u] = Infinity;\n    use[u] = false;\n  }\n  d[s] = 0;\n  while (true) {\n    v = -1;\n    for (u = 0; u < n; u++) {\n      if (!use[u] && (v === -1 || d[v] > d[u])) {\n        v = u;\n      }\n    }\n    if (v === -1) {\n      break;\n    }\n    use[v] = true;\n    for (u = 0; u < n; u++) {\n      d[u] = d[u] < d[v] + g[v][u] ? d[u] : d[v] + g[v][u];\n    }\n  }\n  return d;\n}\n\nfunction solve(max, n, d) {\n    var g = matrix(n + 2, n + 2, Infinity);\n    var i, j;\n    var pos;\n    for (i = 0; i <= n; i++) {\n        for (var j = max; j--; ) {\n            pos = i + j + (i + j < n + 1 ? d[i + j] : 0);\n            pos = Math.min(Math.max(pos, 0), n + 1);\n            if(pos !== i) {\n                g[i][pos] = 1;\n            }\n        }       \n    }\n    var reachable = dijkstra(g, 0);\n    if (reachable[n+1] === Infinity) {\n        return false;\n    }\n    var d;\n    for (i = 1; i <= n; i++) {\n        if(reachable[i] < Infinity) {\n            d = dijkstra(g, i);\n            if(d[n+1] === Infinity) {\n                return false\n            }\n        }\n    }\n    return true;\n    \n}\nwhile ((max = input.shift() - 0) !== 0) {\n    var d = [];\n    n = input.shift() - 0;\n    d[0] = 0;\n    d[n + 1] = 0;\n    for (i = 1; i <= n; i++) {\n        d[i] = input.shift() - 0;\n    }\n    console.log(solve(max, n, d) ? 'OK' : 'NG');\n}"
  },
  {
    "language": "Ruby",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int M, N;\n  while(cin>>M>>N){\n    vector<int> d(N + 2); //0 - start, N + 1 - goal\n    REP(i, N) cin>>d[i + 1];\n    vector<bool> is_ok(N + 2);\n    queue<int> que;\n    is_ok[N + 1] = true;\n    que.push(N + 1);\n    while(!que.empty()){\n      int u = que.front(); que.pop();\n      REP(v, N + 2)if(v + d[v] == u || (u == N + 1 && v + d[v] >= u)){\n        for(int c = 1; c <= M && v - c >= 0; c++) if(!is_ok[v - c]){\n          que.push(v - c);\n          is_ok[v - c] = true;\n        }\n      }\n    }\n    bool ans = true;\n    vector<bool> used(N + 2);\n    que.push(0);\n    used[0] = true;\n    while(!que.empty()){\n      int u = que.front(); que.pop();\n      if(!is_ok[u]) ans = false;\n      for(int c = 1; c <= M && u + c < N + 2; c++){\n        int v = u + c;\n        int to = v + d[v];\n        if(to < 0) to = 0;\n        if(to > N + 1) to = N + 1;\n        if(used[to]) continue;\n        que.push(to);\n        used[to] = true;\n      }\n    }\n    if(ans) cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef backtrace(max, n, edges, start)\n  visited = (n + 2).times.map{false}\n\n  q = [start]\n  visited[start] = true\n\n  while ! q.empty?\n    pos = q.shift\n    next if pos == 0\n\n    for pos0 in (0..n)\n      if edges[pos0][pos] && ! visited[pos0]\n        visited[pos0] = true\n        q << pos0\n      end\n    end\n  end\n\n  visited\nend\n\n### main\n\nwhile true\n  max = gets.strip.to_i\n  break if max == 0\n\n  n = gets.strip.to_i\n\n  masu = [0] + n.times.map{gets.strip.to_i}\n\n  edges = (n + 2).times.map{(n + 2).times.map{false}}\n\n  for pos in (0..n)\n    for k in (1..max)\n      pos0 = pos + k\n      pos0 += masu[pos0] if pos0 <= n\n      pos0 = 0 if pos0 < 0\n      pos0 = n + 1 if pos0 > n\n\n      edges[pos][pos0] = true\n    end\n  end\n\n  visited = backtrace(max, n, edges, n + 1)\n\n  if ! visited[0]\n    puts 'NG'\n    next\n  end\n\n  ans = 'OK'\n  for i in (1..n)\n    if ! visited[i]\n      visited0 = backtrace(max, n, edges, i)\n      if visited0[0]\n        ans = 'NG'\n        break\n      end\n    end\n  end\n\n  puts ans\nend"
  },
  {
    "language": "OCaml",
    "code": "open Printf\nopen Scanf\n\nlet id x = x\n\nlet solve m n sg =\n  let am = Array.make_matrix (n + 2) (n + 2) false in\n  let que = Queue.create () in\n  let ars = Array.make (n + 2) false in\n  let arg = Array.make (n + 2) false in\n  for i = 0 to n do\n    for j = 1 to m do\n      let k = if i + j >= n + 1 then n + 1 else i + j + sg.(i + j) in\n      am.(i).(min (max 0 k) (n + 1)) <- true\n    done\n  done;\n  Queue.push 0 que;\n  ars.(0) <- true;\n  while (not (Queue.is_empty que)) do\n    let i = Queue.pop que in\n    for j = 0 to n + 1 do\n      if am.(i).(j) then\n        begin\n          if ars.(j) then ()\n          else begin\n              ars.(j) <- true;\n              Queue.push j que\n            end\n        end\n      else ()\n    done\n  done;\n  Queue.push (n + 1) que;\n  arg.(n + 1) <- true;\n  while (not (Queue.is_empty que)) do\n    let i = Queue.pop que in\n    for j = 0 to n + 1 do\n      if am.(j).(i) then\n        begin\n          if arg.(j) then ()\n          else begin\n              arg.(j) <- true;\n              Queue.push j que\n            end\n        end\n      else ()\n    done\n  done;\n  let rec iter i =\n    if i = n + 2 then printf \"OK\\n\"\n    else if ars.(i) && not arg.(i) then\n      printf \"NG\\n\"\n    else iter (i + 1) in\n  iter 0\n    \nlet () = \n  let rec loop () = \n    let m = scanf \"%d \" id in\n    if m = 0 then ()\n    else\n      begin\n        let n = scanf \"%d \" id in\n        let sg = Array.make (n + 2) 0 in\n        for i = 1 to n do\n          let d = scanf \"%d \" id in\n          sg.(i) <- d\n        done;\n        solve m n sg;\n        loop ()\n      end\n  in loop ()\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    while(true) {\n        int M = readln.chomp.to!int;\n        if (M==0) break;\n        int n = readln.chomp.to!int;\n        int[] d = new int[n+2];\n        foreach(i; 0..n) d[i+1] = readln.chomp.to!int;\n        bool[][] edges = new bool[][](d.length, d.length);\n        bool[][] edges_reverse = new bool[][](d.length, d.length);\n        foreach(i; 0..d.length) {\n            foreach(j; 1..M+1) {\n                int k = min(d.length-1, i+j).to!int;\n                k += d[k];\n                k = max(0, min(d.length-1, k));\n                edges[i][k] = true;\n                edges_reverse[k][i] = true;\n            }\n        }\n\n        bool[] flg1 = new bool[d.length];\n        flg1[0] = true;\n        auto list = DList!(int)(0);\n        while(!list.empty) {\n            int id = list.front;\n            id.writeln;\n            list.removeFront;\n            foreach(i, e; edges[id]) {\n                if (e && !flg1[i]) {\n                    flg1[i] = true;\n                    list.insertBack(i.to!int);\n                }\n            }\n        }\n        bool[] flg2 = new bool[d.length];\n        flg2[$-1] = true;\n        list.insertBack(d.length.to!int-1);\n        while(!list.empty) {\n            int id = list.front;\n            list.removeFront;\n            foreach(i, e; edges_reverse[id]) {\n                if (e && !flg2[i]) {\n                    flg2[i] = true;\n                    list.insertBack(i.to!int);\n                }\n            }\n        }\n\n        foreach(i; 0..d.length) {\n            if (flg1[i] && !flg2[i]) {\n                writeln(\"NG\");\n                break;\n            }\n            if (i == d.length-1) {\n                writeln(\"OK\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    while(true) {\n        int M = readln.chomp.to!int;\n        if (M==0) break;\n        int n = readln.chomp.to!int;\n        int[] d = new int[n+2];\n        foreach(i; 0..n) d[i+1] = readln.chomp.to!int;\n        bool[][] edges = new bool[][](d.length, d.length);\n        bool[][] edges_reverse = new bool[][](d.length, d.length);\n        foreach(i; 0..d.length) {\n            foreach(j; 1..M+1) {\n                int k = min(d.length-1, i+j).to!int;\n                k += d[k];\n                k = max(0, min(d.length-1, k));\n                edges[i][k] = true;\n                edges_reverse[k][i] = true;\n            }\n        }\n\n        bool[] flg1 = new bool[d.length];\n        flg1[0] = true;\n        auto list = DList!(int)(0);\n        while(!list.empty) {\n            int id = list.front;\n            id.writeln;\n            list.removeFront;\n            foreach(i, e; edges[id]) {\n                if (e && !flg1[i]) {\n                    flg1[i] = true;\n                    list.insertBack(i.to!int);\n                }\n            }\n        }\n        bool[] flg2 = new bool[d.length];\n        flg2[$-1] = true;\n        list.insertBack(d.length-1);\n        while(!list.empty) {\n            int id = list.front;\n            list.removeFront;\n            foreach(i, e; edges_reverse[id]) {\n                if (e && !flg2[i]) {\n                    flg2[i] = true;\n                    list.insertBack(i);\n                }\n            }\n        }\n\n        foreach(i; 0..d.length) {\n            if (flg1[i] && !flg2[i]) {\n                writeln(\"NG\");\n                break;\n            }\n            if (i == d.length-1) {\n                writeln(\"OK\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    while(true) {\n        int M = readln.chomp.to!int;\n        if (M==0) break;\n        int n = readln.chomp.to!int;\n        int[] d = new int[n+2];\n        foreach(i; 0..n) d[i+1] = readln.chomp.to!int;\n        bool[][] edges = new bool[][](d.length, d.length);\n        bool[][] edges_reverse = new bool[][](d.length, d.length);\n        foreach(i; 0..d.length) {\n            foreach(j; 1..M+1) {\n                int k = min(d.length-1, i+j).to!int;\n                k += d[k];\n                k = max(0, min(d.length-1, k));\n                edges[i][k] = true;\n                edges_reverse[k][i] = true;\n            }\n        }\n\n        bool[] flg1 = new bool[d.length];\n        flg1[0] = true;\n        auto list = DList!(int)(0);\n        while(!list.empty) {\n            int id = list.front;\n            id.writeln;\n            list.removeFront;\n            foreach(i, e; edges[id]) {\n                if (e && !flg1[i]) {\n                    flg1[i] = true;\n                    list.insertBack(i.to!int);\n                }\n            }\n        }\n        bool[] flg2 = new bool[d.length];\n        flg2[$-1] = true;\n        list.insertBack(d.length.to!int-1);\n        while(!list.empty) {\n            int id = list.front;\n            list.removeFront;\n            foreach(i, e; edges_reverse[id]) {\n                if (e && !flg2[i]) {\n                    flg2[i] = true;\n                    list.insertBack(i);\n                }\n            }\n        }\n\n        foreach(i; 0..d.length) {\n            if (flg1[i] && !flg2[i]) {\n                writeln(\"NG\");\n                break;\n            }\n            if (i == d.length-1) {\n                writeln(\"OK\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.algorithm;\nimport std.array;\n\nvoid main() {\n    int roulette; \ntest:\n    while (scanf(\"%d\", &roulette), roulette) {\n        int n; scanf(\"%d\", &n);\n        int[] d = new int[n + 2];\n        foreach (i; 1 .. n + 1) scanf(\"%d\", &d[i]);\n        int next(int x) {\n            int ans = x + d[x];\n            if (ans < 0) ans = 0;\n            if (ans > n + 1) ans = n + 1;\n            return ans;\n        }\n        int[][] graph = new int[][n + 2];\n        bool[] used = new bool[n + 2];\n        void make(int cur) {\n            used[cur] = true;\n            foreach (i; 1 .. roulette + 1) {\n                if (cur + i > n + 1) {\n                    graph[cur] ~= n + 1;\n                    break;\n                }\n                int x = next(cur + i);\n                graph[cur] ~= x;\n                if (!used[x]) make(x);\n            }\n        }\n        make(0);\n        foreach (ref g; graph) {\n            g = g.sort.uniq.array;\n        }\n        used[] = false;\n\n        bool cangoal(int cur) {\n            if (cur == n + 1) return true;\n            used[cur] = true;\n            foreach (x; graph[cur]) {\n                if (used[x]) continue;\n                if (cangoal(x)) return true;\n            }\n            return false;\n        }\n\n        //graph.writeln;\n\n        foreach (int i, ref g; graph) {\n            if (g.empty) continue;\n            used[] = false;\n            if (cangoal(i)) continue;\n            writeln(\"NG\");\n            continue test;\n        }\n        writeln(\"OK\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.algorithm;\nimport std.array;\n\nvoid main() {\n    int roulette; \ntest:\n    while (scanf(\"%d\", &roulette), roulette) {\n        int n; scanf(\"%d\", &n);\n        int[] d = new int[n + 2];\n        foreach (i; 1 .. n + 1) scanf(\"%d\", &d[i]);\n        int next(int x) {\n            int ans = x + d[x];\n            if (ans < 0) ans = 0;\n            if (ans > n + 1) ans = n + 1;\n            return ans;\n        }\n        int[][] graph = new int[][n + 2];\n        bool[] used = new bool[n + 2];\n        void make(int cur) {\n            used[cur] = true;\n            foreach (i; 1 .. roulette + 1) {\n                if (cur + i > n + 1) break;\n                int x = next(cur + i);\n                graph[cur] ~= x;\n                if (!used[x]) make(x);\n            }\n        }\n        make(0);\n        foreach (ref g; graph) {\n            g = g.sort.uniq.array;\n        }\n        used[] = false;\n\n        bool cangoal(int cur) {\n            if (cur == n + 1) return true;\n            used[cur] = true;\n            foreach (x; graph[cur]) {\n                if (used[x]) continue;\n                if (cangoal(x)) return true;\n            }\n            return false;\n        }\n\n        foreach (int i, ref g; graph) {\n            if (g.empty) continue;\n            if (cangoal(i)) continue;\n            writeln(\"NG\");\n            continue test;\n        }\n        writeln(\"OK\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    while(true) {\n        int M = readln.chomp.to!int;\n        if (M==0) break;\n        int n = readln.chomp.to!int;\n        int[] d = new int[n+2];\n        foreach(i; 0..n) d[i+1] = readln.chomp.to!int;\n        bool[][] edges = new bool[][](d.length, d.length);\n        bool[][] edges_reverse = new bool[][](d.length, d.length);\n        foreach(i; 0..d.length) {\n            foreach(j; 1..M+1) {\n                int k = min(d.length-1, i+j);\n                k += d[k];\n                k = max(0, min(d.length-1, k));\n                edges[i][k] = true;\n                edges_reverse[k][i] = true;\n            }\n        }\n        \n        bool[] flg1 = new bool[d.length];\n        flg1[0] = true;\n        auto list = DList!(int)(0);\n        while(!list.empty) {\n            int id = list.front;\n            id.writeln;\n            list.removeFront;\n            foreach(i, e; edges[id]) {\n                if (e && !flg1[i]) {\n                    flg1[i] = true;\n                    list.insertBack(i);\n                }\n            }\n        }\n        bool[] flg2 = new bool[d.length];\n        flg2[$-1] = true;\n        list.insertBack(d.length-1);\n        while(!list.empty) {\n            int id = list.front;\n            list.removeFront;\n            foreach(i, e; edges_reverse[id]) {\n                if (e && !flg2[i]) {\n                    flg2[i] = true;\n                    list.insertBack(i);\n                }\n            }\n        }\n\n        foreach(i; 0..d.length) {\n            if (flg1[i] && !flg2[i]) {\n                writeln(\"NG\");\n                break;\n            }\n            if (i == d.length-1) {\n                writeln(\"OK\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\n\nvoid main(){\n  int rmax,n;\n  while(rmax=to!int(chomp(readln())),rmax){\n    n=to!int(chomp(readln()));\n    auto d=new int[n];\n    for(int i=0,a,b;i<n;++i){\n      a=to!int(chomp(readln()));\n      b=(a!=0)?i+a:i;\n      d[i]=(b<-1)?-1:((b>n)?n:b);\n    }\n    writeln((reduce!(max)(d[0..n])+rmax<=n)?\"NG\":\"OK\");\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    while(true) {\n        int M = readln.chomp.to!int;\n        if (M==0) break;\n        int n = readln.chomp.to!int;\n        int[] d = new int[n+2];\n        foreach(i; 0..n) d[i+1] = readln.chomp.to!int;\n        bool[][] edges = new bool[][](d.length, d.length);\n        bool[][] edges_reverse = new bool[][](d.length, d.length);\n        foreach(i; 0..d.length) {\n            foreach(j; 1..M+1) {\n                int k = min(d.length-1, i+j).to!int;\n                k += d[k];\n                k = max(0, min(d.length-1, k));\n                edges[i][k] = true;\n                edges_reverse[k][i] = true;\n            }\n        }\n\n        bool[] flg1 = new bool[d.length];\n        flg1[0] = true;\n        auto list = DList!(int)(0);\n        while(!list.empty) {\n            int id = list.front;\n            id.writeln;\n            list.removeFront;\n            foreach(i, e; edges[id]) {\n                if (e && !flg1[i]) {\n                    flg1[i] = true;\n                    list.insertBack(i);\n                }\n            }\n        }\n        bool[] flg2 = new bool[d.length];\n        flg2[$-1] = true;\n        list.insertBack(d.length-1);\n        while(!list.empty) {\n            int id = list.front;\n            list.removeFront;\n            foreach(i, e; edges_reverse[id]) {\n                if (e && !flg2[i]) {\n                    flg2[i] = true;\n                    list.insertBack(i);\n                }\n            }\n        }\n\n        foreach(i; 0..d.length) {\n            if (flg1[i] && !flg2[i]) {\n                writeln(\"NG\");\n                break;\n            }\n            if (i == d.length-1) {\n                writeln(\"OK\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    while(true) {\n        int M = readln.chomp.to!int;\n        if (M==0) break;\n        int n = readln.chomp.to!int;\n        int[] d = new int[n+2];\n        foreach(i; 0..n) d[i+1] = readln.chomp.to!int;\n        bool[][] edges = new bool[][](d.length, d.length);\n        bool[][] edges_reverse = new bool[][](d.length, d.length);\n        foreach(i; 0..d.length) {\n            foreach(j; 1..M+1) {\n                int k = min(d.length-1, i+j).to!int;\n                k += d[k];\n                k = max(0, min(d.length-1, k));\n                edges[i][k] = true;\n                edges_reverse[k][i] = true;\n            }\n        }\n\n        bool[] flg1 = new bool[d.length];\n        flg1[0] = true;\n        auto list = DList!(int)(0);\n        while(!list.empty) {\n            int id = list.front;\n            list.removeFront;\n            foreach(i, e; edges[id]) {\n                if (e && !flg1[i]) {\n                    flg1[i] = true;\n                    list.insertBack(i.to!int);\n                }\n            }\n        }\n        bool[] flg2 = new bool[d.length];\n        flg2[$-1] = true;\n        list.insertBack(d.length.to!int-1);\n        while(!list.empty) {\n            int id = list.front;\n            list.removeFront;\n            foreach(i, e; edges_reverse[id]) {\n                if (e && !flg2[i]) {\n                    flg2[i] = true;\n                    list.insertBack(i.to!int);\n                }\n            }\n        }\n\n        foreach(i; 0..d.length) {\n            if (flg1[i] && !flg2[i]) {\n                writeln(\"NG\");\n                break;\n            }\n            if (i == d.length-1) {\n                writeln(\"OK\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.algorithm;\nimport std.array;\n\nvoid main() {\n    int roulette; \ntest:\n    while (scanf(\"%d\", &roulette), roulette) {\n        int n; scanf(\"%d\", &n);\n        int[] d = new int[n + 2];\n        foreach (i; 1 .. n + 1) scanf(\"%d\", &d[i]);\n        int next(int x) {\n            int ans = x + d[x];\n            if (ans < 0) ans = 0;\n            if (ans > n + 1) ans = n + 1;\n            return ans;\n        }\n        int[][] graph = new int[][n + 2];\n        bool[] used = new bool[n + 2];\n        void make(int cur) {\n            used[cur] = true;\n            foreach (i; 1 .. roulette + 1) {\n                if (cur + i > n + 1) {\n                    graph[cur] ~= n + 1;\n                    break;\n                }\n                int x = next(cur + i);\n                graph[cur] ~= x;\n                if (!used[x]) make(x);\n            }\n        }\n        make(0);\n        foreach (ref g; graph) {\n            g = g.sort.uniq.array;\n        }\n        used[] = false;\n\n        bool cangoal(int cur) {\n            if (cur == n + 1) return true;\n            used[cur] = true;\n            foreach (x; graph[cur]) {\n                if (used[x]) continue;\n                if (cangoal(x)) return true;\n            }\n            return false;\n        }\n\n        //graph.writeln;\n\n        foreach (int i, ref g; graph) {\n            if (g.empty) continue;\n            if (cangoal(i)) continue;\n            writeln(\"NG\");\n            continue test;\n        }\n        writeln(\"OK\");\n    }\n}"
  },
  {
    "language": "Python",
    "code": "inf = 1000000\n\ndef graph_set(g, i, j, v):\n    g[i][j >> 5] |= v << (j & 31)\n\ndef graph_set1(g, i, j):\n    graph_set(g, i, j, 1)\n\ndef graph_get(g, i, j):\n    return (g[i][j >> 5] >> (j & 31)) & 1\n\ndef solve(dmax, arr):\n    arr.insert(0, 0)\n    arr.append(0)\n    n = len(arr)\n    g = [[0 for _ in range(int((n + 31) / 32))] for _ in range(n)]\n    \n    for i in range(n):\n        graph_set1(g, i, i)\n\n    for s in range(n):\n        for d in range(1, dmax + 1):\n            next = min(max(0, s + d), n - 1)\n            next += arr[next]\n            next = min(max(0, next), n - 1)\n            graph_set1(g, s, next)\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                graph_set(g, i, j, \n                          graph_get(g, i, j) | graph_get(g, i, k) & graph_get(g, k, j))\n                    \n    for i in range(0, n - 1):\n        if graph_get(g, 0, i) and (not graph_get(g, i, n - 1)):\n            print(\"NG\")\n            return\n    print(\"OK\")\n\ndef main():\n    while True:\n        dmax = int(input())\n        if dmax == 0:\n            return\n        n = int(input())\n        arr = [int(input()) for _ in range(n)]\n        solve(dmax, arr)\n        \n\nmain()"
  },
  {
    "language": "Python",
    "code": "def reachable(graph, init):\n    if init not in graph or graph[init] is None:\n        return set()\n    \n    tmp,  graph[init] = graph[init], None\n\n    return tmp.union(* [reachable(graph, i) for i in tmp])\n\ndef sugoroku(m, d):\n    d = [0] + d + [0]\n    start, goal = 0, len(d) - 1\n\n    graph_to = {goal:{goal}}\n    graph_from = {start:{start}}\n    \n    for init in range(len(d) - 1):\n        for xi in range(1, 1 + m):\n            pos = min(init + xi, goal)\n            to = max(start, min(pos + d[pos],goal))\n            try:\n                graph_to[to].add(init)\n            except KeyError:\n                graph_to[to] = {init}\n            try:\n                graph_from[init].add(to)\n            except KeyError:\n                graph_from[init] = {to}\n    \n    unreachable_node = reachable(graph_from, start).difference(reachable(graph_to, goal))\n    \n    return 0 == len(unreachable_node)\n\nimport sys\nf = sys.stdin\n\nwhile True:\n    m = int(f.readline())\n    if m == 0:\n        break\n    d = [int(f.readline()) for _ in range(int(f.readline()))]\n    print('OK' if sugoroku(m, d) else 'NG')"
  },
  {
    "language": "Python",
    "code": "inf = 1000000\n\ndef graph_set(g, i, j, v):\n    g[i][j >> 5] |= v << (j & 31)\n\ndef graph_set1(g, i, j):\n    graph_set(g, i, j, 1)\n\ndef graph_get(g, i, j):\n    return (g[i][j >> 5] >> (j & 31)) & 1\n\ndef solve(dmax, arr):\n    arr.insert(0, 0)\n    arr.append(0)\n    n = len(arr)\n    g = [[False for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        g[i][i] = True\n\n    for s in range(n):\n        for d in range(1, dmax + 1):\n            next = min(max(0, s + d), n - 1)\n            next += arr[next]\n            next = min(max(0, next), n - 1)\n            g[s][next] = True\n\n    visited = [[False for _ in range(n)] for _ in range(n)]\n    memo = [[None for _ in range(n)] for _ in range(n)]\n\n    def dfs(s, i, t):\n        if i == t:\n            return True\n        if visited[i][t]:\n            return False\n        if memo[i][t] != None:\n            return memo[i][t]\n        visited[i][t] = True\n        memo[s][i] = True\n\n        for j in range(n):\n            if g[i][j] and not visited[j][t] and dfs(i, j, t):\n                g[i][t] = True\n                g[s][t] = True\n                memo[s][t] = True\n                return True\n        memo[i][t] = False\n        g[i][t] = False\n        return False\n                    \n    for i in range(n):\n        for j in range(n):\n            if dfs(i, i, j):\n                g[i][j] = True\n        \n    for i in range(0, n - 1):\n        if g[0][i] and (not g[i][n - 1]):\n            print(\"NG\")\n            return\n    print(\"OK\")\n\ndef main():\n    while True:\n        dmax = int(input())\n        if dmax == 0:\n            return\n        n = int(input())\n        arr = [int(input()) for _ in range(n)]\n        solve(dmax, arr)\n        \n\nmain()"
  },
  {
    "language": "Python",
    "code": "inf = 1000000\n\ndef solve(dmax, arr):\n    arr.insert(0, 0)\n    arr.append(0)\n    n = len(arr)\n    graph = [[inf for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        graph[i][i] = 0\n\n    for s in range(n):\n        for d in range(1, dmax + 1):\n            next = min(max(0, s + d), n - 1)\n            next += arr[next]\n            next = min(max(0, next), n - 1)\n            graph[s][next] = 1\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if graph[i][k] < inf and graph[k][j] < inf:\n                    graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\n\n    for i in range(0, n - 1):\n        if graph[0][i] < inf and graph[i][n - 1] == inf:\n            print(\"NG\")\n            return\n    print(\"OK\")\n\ndef main():\n    while True:\n        dmax = int(input())\n        if dmax == 0:\n            return\n        n = int(input())\n        arr = [int(input()) for _ in range(n)]\n        solve(dmax, arr)\n        \n\nmain()"
  },
  {
    "language": "Python",
    "code": "inf = 1000000\n\ndef graph_set(g, i, j, v):\n    g[i][j >> 5] |= v << (j & 31)\n\ndef graph_set1(g, i, j):\n    graph_set(g, i, j, 1)\n\ndef graph_get(g, i, j):\n    return (g[i][j >> 5] >> (j & 31)) & 1\n\ndef solve(dmax, arr):\n    arr.insert(0, 0)\n    arr.append(0)\n    n = len(arr)\n    g = [[False for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        g[i][i] = True\n\n    for s in range(n):\n        for d in range(1, dmax + 1):\n            next = min(max(0, s + d), n - 1)\n            next += arr[next]\n            next = min(max(0, next), n - 1)\n            g[s][next] = True\n\n    visited = [[False for _ in range(n)] for _ in range(n)]\n    memo = [[None for _ in range(n)] for _ in range(n)]\n\n    def dfs(s, i, t):\n        if i == t:\n            return True\n        if visited[i][t]:\n            return False\n        if memo[i][t] != None:\n            return memo[i][t]\n        visited[i][t] = True\n        memo[s][i] = True\n\n        for j in range(n):\n            if g[i][j] and not visited[j][t] and dfs(s, j, t):\n                g[i][t] = True\n                return True\n        memo[i][t] = False\n        g[i][t] = False\n        return False\n                    \n    for i in range(n):\n        for j in range(n):\n            if dfs(i, i, j):\n                g[i][j] = True\n        \n    for i in range(0, n - 1):\n        if g[0][i] and (not g[i][n - 1]):\n            print(\"NG\")\n            return\n    print(\"OK\")\n\ndef main():\n    while True:\n        dmax = int(input())\n        if dmax == 0:\n            return\n        n = int(input())\n        arr = [int(input()) for _ in range(n)]\n        solve(dmax, arr)\n        \n\nmain()"
  },
  {
    "language": "Python",
    "code": "def sugoroku(m, d):\n    d = [0] + d + [0]\n    start, goal = 0, len(d) - 1\n\n    g = [[0 for j in range(len(d))] for i in range(len(d))]\n    for i in range(len(d) - 1):\n        for mi in range(m + 1):\n            pos = min(goal, i + mi)\n            pos = max(start, pos + d[pos])\n            g[i][pos] = 1\n\n    for i in range(len(d)):\n        for j in range(len(d)):\n            for k in range(len(d)):\n                if g[i][j] and g[j][k]:\n                    g[i][k]\n    \n    for i in range(len(d)):\n        if g[start][i] and not g[i][goal]:\n            return False\n    return True\n\nimport sys\nf = sys.stdin\n\nwhile True:\n    m = int(f.readline())\n    if m == 0:\n        break\n    d = [int(f.readline()) for _ in range(int(f.readline()))]\n    print('OK' if sugoroku(m, d) else 'NG')"
  },
  {
    "language": "Python",
    "code": "def sugoroku(m, d):\n    d = [0] + d + [0]\n    start, goal = 0, len(d) - 1\n\n    g = [[0 for j in range(len(d))] for i in range(len(d))]\n    for i in range(len(d) - 1):\n        for mi in range(1, m + 1):\n            pos = min(goal, i + mi)\n            pos = max(start, pos + d[pos])\n            g[i][pos] = 1\n\n    for k in range(len(d)):\n        for i in range(len(d)):\n            for j in range(len(d)):\n                if g[i][k] and g[k][j]:\n                    g[i][j] = 1\n    \n    for i in range(len(d) - 1):\n        if g[start][i] and not g[i][goal]:\n            return False\n    return True\n\nimport sys\nf = sys.stdin\n\n\nwhile True:\n    m = int(f.readline())\n    if m == 0:\n        break\n    d = [int(f.readline()) for _ in range(int(f.readline()))]\n    print('OK' if sugoroku(m, d) else 'NG')"
  },
  {
    "language": "Python",
    "code": "while 1:\n    m = int(input())\n    if m == 0:break\n    n = int(input())\n    d = [int(input()) for _ in range(n)]\n    if n < m:print(\"OK\")\n    for i in range(m):\n        if d[- i - 1] > - m + i:break\n    else:\n        print(\"NG\")\n        continue\n    print(\"OK\")\n"
  },
  {
    "language": "Python",
    "code": "def reachable(graph, init):\n    if init not in graph or graph[init] is None:\n        return set()\n    \n    tmp,  graph[init] = graph[init], None\n\n    return tmp.union(* [reachable(graph, i) for i in tmp])\n\ndef sugoroku(m, d):\n    d = [0] + d + [0]\n    start, goal = 0, len(d) - 1\n\n    graph_to = {goal:{goal}}\n    graph_from = {start:{start}}\n    \n    for init in range(len(d) - 1):\n        for xi in range(1, 1 + m):\n            pos = min(init + xi, goal)\n            to = max(start, pos + d[pos])\n            try:\n                graph_to[to].add(init)\n            except KeyError:\n                graph_to[to] = {init}\n            try:\n                graph_from[init].add(to)\n            except KeyError:\n                graph_from[init] = {to}                \n    \n    unreachable_node = reachable(graph_from, start).difference(reachable(graph_to, goal))\n    \n    return 0 == len(unreachable_node)\n\nimport sys\nf = sys.stdin\n\nwhile True:\n    m = int(f.readline())\n    if m == 0:\n        break\n    d = [int(f.readline()) for _ in range(int(f.readline()))]\n    print('OK' if sugoroku(m, d) else 'NG')"
  },
  {
    "language": "Python",
    "code": "inf = 1000000\n\ndef graph_set(g, i, j, v):\n    g[i][j >> 5] |= v << (j & 31)\n\ndef graph_set1(g, i, j):\n    graph_set(g, i, j, 1)\n\ndef graph_get(g, i, j):\n    return (g[i][j >> 5] >> (j & 31)) & 1\n\ndef solve(dmax, arr):\n    arr.insert(0, 0)\n    arr.append(0)\n    n = len(arr)\n    g = [[False for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        g[i][i] = True\n\n    for s in range(n):\n        for d in range(1, dmax + 1):\n            next = min(max(0, s + d), n - 1)\n            next += arr[next]\n            next = min(max(0, next), n - 1)\n            g[s][next] = True\n\n    visited = [[False for _ in range(n)] for _ in range(n)]\n    def dfs(i, t):\n        if i == t:\n            return True\n        elif visited[i][t]:\n            return g[i][t]\n        visited[i][t] = True\n        for j in range(n):\n            if g[i][j] and dfs(j, t):\n                g[i][t] = True\n                return True\n        return False\n                    \n    for i in range(n):\n        for j in range(n):\n            dfs(i, j)\n\n\n    for i in range(0, n - 1):\n        if g[0][i] and (not g[i][n - 1]):\n            print(\"NG\")\n            return\n    print(\"OK\")\n\ndef main():\n    while True:\n        dmax = int(input())\n        if dmax == 0:\n            return\n        n = int(input())\n        arr = [int(input()) for _ in range(n)]\n        solve(dmax, arr)\n        \n\nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile 1:\n    M = int(input())\n    if M == 0:\n        break\n    N = int(input())\n    D = [0] + [int(input()) for i in range(N)] + [0]\n    G = [[] for i in range(N+2)]\n\n    u = [0]*(N+2)\n    que = deque([0])\n    u[0] = 1\n    while que:\n        v = que.popleft()\n        for j in range(1, M+1):\n            if D[min(v+j, N+1)] != 0:\n                to = max(min(v+j+D[v+j], N+1), 0)\n            else:\n                to = min(v+j, N+1)\n            if not u[to]:\n                que.append(to)\n                u[to] = 1\n            G[to].append(v)\n\n    z = [0]*(N+2)\n    que = deque([N+1])\n    z[N+1] = 1\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if z[w]:\n                continue\n            z[w] = 1\n            que.append(w)\n    print(\"OK\" if u == z else \"NG\")\n\n"
  },
  {
    "language": "Python",
    "code": "def search(x, visited, edges):\n  if visited[x]:\n    return\n\n  visited[x] = True\n  for to in edges[x]:\n    search(to, visited, edges)\n\ndef main():\n  while True:\n    m = int(input())\n    if m == 0:\n      break\n    n = int(input())\n    mp = [0] + [int(input()) for _ in range(n)] + [0]\n    visited = [False] * (n + 2)\n    rev_visited = [False] * (n + 2)\n    edges = [[] for _ in range(n + 2)]\n    rev_edges = [[] for _ in range(n + 2)]\n    for i in range(n + 2):\n      for j in range(1, m + 1):\n        nex = i + j\n        nex = min(nex, n + 1)\n        nex += mp[nex]\n        nex = min(nex, n + 1)\n        nex = max(nex, 0)\n        edges[i].append(nex)\n        rev_edges[nex].append(i)\n  \n    search(0, visited, edges)\n    search(n + 1, rev_visited, rev_edges)\n    for node in range(n + 1):\n      if visited[node] and not rev_visited[node]:\n        print(\"NG\")\n        break\n    else:\n      print(\"OK\")\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\nwhile True:\n    m = int(input())\n    if m == 0:\n        break\n    n = int(input())\n    d = [0]*(n+2)\n    for i in range(1,n+1):\n        d[i] = int(input())\n    visited = [False]*(n+2)\n    visited[0] = True\n    ok = [False]*(n+2)\n    ok[n+1] = True\n    rev = [[] for _ in range(n+2)]\n    \n    que = queue.LifoQueue()\n    que.put(0)\n    while not que.empty():\n        i = que.get()\n        for j in range(1,m+1):\n            if i+j > n+1:\n                break\n            k = min(max(i+j+d[i+j], 0), n+1)\n            rev[k].append(i)\n            if not visited[k]:\n                que.put(k)\n                visited[k] = True\n\n    que.put(n+1)\n    while not que.empty():\n        i = que.get()\n        for j in rev[i]:\n            if not ok[j]:\n                ok[j] = True\n                que.put(j)\n\n    ans = 'OK'\n    if not visited[n+1]:\n        ans = 'NG'\n    for i in range(n+1):\n        if visited[i] and (not ok[i]):\n            ans = 'NG'\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "inf = 1000000\n\ndef solve(dmax, arr):\n    arr.insert(0, 0)\n    arr.append(0)\n    n = len(arr)\n    graph = [[False for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        graph[i][i] = True\n\n    for s in range(n):\n        for d in range(1, dmax + 1):\n            next = min(max(0, s + d), n - 1)\n            next += arr[next]\n            next = min(max(0, next), n - 1)\n            graph[s][next] = True\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if graph[i][k] < inf and graph[k][j] < inf:\n                    graph[i][j] |= graph[i][k] and graph[k][j]\n                    \n    for i in range(0, n - 1):\n        if graph[0][i] and (not graph[i][n - 1]):\n            print(\"NG\")\n            return\n    print(\"OK\")\n\ndef main():\n    while True:\n        dmax = int(input())\n        if dmax == 0:\n            return\n        n = int(input())\n        arr = [int(input()) for _ in range(n)]\n        solve(dmax, arr)\n        \n\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\ndef bfs(adj_list, s):\n    q = deque([s])\n    visited = [False]*(n+2)\n    visited[s] = True\n    \n    while q:\n        v = q.popleft()\n        \n        for nv in adj_list[v]:\n            if not visited[nv]:\n                visited[nv] = True\n                q.append(nv)\n\n    return visited\n\nwhile True:\n    m = int(input())\n    \n    if m==0:\n        break\n    \n    n = int(input())\n    d = [int(input()) for _ in range(n)]\n    adj_list = [[] for _ in range(n+2)]\n    rev_adj_list = [[] for _ in range(n+2)]\n    \n    for i in range(n+1):\n        for j in range(1, m+1):\n            if i+j>n:\n                adj_list[i].append(n+1)\n                rev_adj_list[n+1].append(i)\n            else:\n                t = min(n+1, max(i+j+d[i+j-1], 0))\n                adj_list[i].append(t)\n                rev_adj_list[t].append(i)\n    \n    visited_1 = bfs(adj_list, 0)\n    visited_2 = bfs(rev_adj_list, n+1)\n    \n    for i in range(n+2):\n        if visited_1[i] and not visited_2[i]:\n            print('NG')\n            break\n    else:\n        print('OK')\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    m = int(input())\n    if not m:\n        break\n    n = int(input())\n    ds = [0] + [int(input()) for _ in range(n)] + [0]\n\n    g = [[] for _ in range(n+2)]\n    rg = [[] for _ in range(n+2)]\n    for i in range(n+2):\n        for j in range(min(n+1,i+1),min(n+1,i+m)+1):\n            j = max(0,min(n+1,j+ds[j]))\n            g[i].append(j)\n            rg[j].append(i)\n    \n    def go(g,bs,i):\n        bs[i] = True\n        for j in g[i]:\n            if not bs[j]:\n                go(g,bs,j)\n    \n    bs = [False]*(n+2)\n    rbs = [False]*(n+2)\n    go(g,bs,0)\n    go(rg,rbs,n+1)\n\n    if any((b and (not rb)) for b,rb in zip(bs,rbs)):\n        print('NG')\n    else:\n        print('OK')"
  },
  {
    "language": "Python",
    "code": "inf = 1000000\n\ndef graph_set(g, i, j, v):\n    g[i][j >> 5] |= v << (j & 31)\n\ndef graph_set1(g, i, j):\n    graph_set(g, i, j, 1)\n\ndef graph_get(g, i, j):\n    return (g[i][j >> 5] >> (j & 31)) & 1\n\ndef solve(dmax, arr):\n    arr.insert(0, 0)\n    arr.append(0)\n    n = len(arr)\n    g = [[False for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        g[i][i] = True\n\n    for s in range(n):\n        for d in range(1, dmax + 1):\n            next = min(max(0, s + d), n - 1)\n            next += arr[next]\n            next = min(max(0, next), n - 1)\n            g[s][next] = True\n\n    visited = [[False for _ in range(n)] for _ in range(n)]\n    def dfs(i, t):\n        if i == t:\n            return True\n        elif visited[i][t]:\n            return g[i][t]\n        visited[i][t] = True\n        for j in range(n):\n            if g[i][j] and not visited[j][t] and dfs(j, t):\n                g[i][t] = True\n                return True\n        return False\n                    \n    for i in range(n):\n        for j in range(n):\n            dfs(i, j)\n\n    for i in range(0, n - 1):\n        if g[0][i] and (not g[i][n - 1]):\n            print(\"NG\")\n            return\n    print(\"OK\")\n\ndef main():\n    while True:\n        dmax = int(input())\n        if dmax == 0:\n            return\n        n = int(input())\n        arr = [int(input()) for _ in range(n)]\n        solve(dmax, arr)\n        \n\nmain()"
  }
]