[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_POSITIONS 1000\n\ntypedef struct {\n    int pos;\n    char command[20];\n} Cell;\n\nbool canReachEnd(int N, int M, Cell cells[]) {\n    bool visited[MAX_POSITIONS] = {false};\n    int queue[MAX_POSITIONS];\n    int front = 0, rear = 0;\n    queue[rear++] = 1;\n    visited[1] = true;\n\n    while (front < rear) {\n        int current = queue[front++];\n        if (current == N) {\n            return true;\n        }\n\n        for (int spin = 1; spin <= M; spin++) {\n            int next = current + spin;\n            if (next > N) {\n                next = N;\n            }\n\n            if (cells[next].command[0] != '\\0') {\n                char cmd[20];\n                strcpy(cmd, cells[next].command);\n                int move;\n                sscanf(cmd + 10, \"%d\", &move);\n                if (strstr(cmd, \"forward\")) {\n                    next += move;\n                } else if (strstr(cmd, \"back\")) {\n                    next -= move;\n                }\n                if (next > N) {\n                    next = N;\n                }\n                if (next < 1) {\n                    next = 1;\n                }\n            }\n\n            if (!visited[next]) {\n                visited[next] = true;\n                queue[rear++] = next;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int N, M, K;\n    while (scanf(\"%d %d %d\", &N, &M, &K) == 3 && (N != 0 || M != 0 || K != 0)) {\n        Cell cells[MAX_POSITIONS] = {0};\n        for (int i = 0; i < K; i++) {\n            int pos;\n            char command[20];\n            scanf(\"%d %s\", &pos, command);\n            strcpy(cells[pos].command, command);\n        }\n        if (canReachEnd(N, M, cells)) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:38:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Sugoroku {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int N = scanner.nextInt(); // Number of special positions\n            int M = scanner.nextInt(); // Maximum roulette value\n            int L = scanner.nextInt(); // Game board length\n            \n            if (N == 0 && M == 0 && L == 0) break;\n            \n            Map<Integer, Integer> specialPositions = new HashMap<>();\n            for (int i = 0; i < N; i++) {\n                int pos = scanner.nextInt();\n                int move = scanner.nextInt();\n                specialPositions.put(pos, move);\n            }\n            \n            boolean[] visited = new boolean[L + 1];\n            Queue<Integer> queue = new LinkedList<>();\n            queue.offer(1);\n            visited[1] = true;\n            \n            boolean canReachEnd = false;\n            \n            while (!queue.isEmpty()) {\n                int current = queue.poll();\n                \n                if (current == L) {\n                    canReachEnd = true;\n                    break;\n                }\n                \n                for (int roll = 1; roll <= M; roll++) {\n                    int next = current + roll;\n                    \n                    if (next > L) next = L;\n                    \n                    if (specialPositions.containsKey(next)) {\n                        next += specialPositions.get(next);\n                        \n                        if (next < 1) next = 1;\n                        if (next > L) next = L;\n                    }\n                    \n                    if (!visited[next]) {\n                        queue.offer(next);\n                        visited[next] = true;\n                    }\n                }\n            }\n            \n            System.out.println(canReachEnd ? \"OK\" : \"NG\");\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:38:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nstruct State {\n    int pos;\n    int spin;\n};\n\nbool canReachEnd(int N, int M, const vector<pair<char, int>>& commands) {\n    queue<State> q;\n    set<pair<int, int>> visited;\n    q.push({0, 0});\n    visited.insert({0, 0});\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.pos == N) {\n            return true;\n        }\n\n        for (int s = 1; s <= M; ++s) {\n            int newPos = current.pos + s;\n            if (newPos > N) {\n                newPos = N;\n            }\n\n            if (newPos >= 0 && newPos < commands.size()) {\n                char cmd = commands[newPos].first;\n                int val = commands[newPos].second;\n                if (cmd == '+') {\n                    newPos += val;\n                } else if (cmd == '-') {\n                    newPos -= val;\n                }\n                if (newPos > N) {\n                    newPos = N;\n                }\n                if (newPos < 0) {\n                    newPos = 0;\n                }\n            }\n\n            if (visited.find({newPos, s}) == visited.end()) {\n                visited.insert({newPos, s});\n                q.push({newPos, s});\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 && M == 0) break;\n\n        vector<pair<char, int>> commands(N);\n        for (int i = 0; i < N; ++i) {\n            string cmd;\n            cin >> cmd;\n            if (cmd[0] == '+' || cmd[0] == '-') {\n                int val = stoi(cmd.substr(1));\n                commands[i] = {cmd[0], val};\n            } else {\n                commands[i] = {' ', 0};\n            }\n        }\n\n        if (canReachEnd(N, M, commands)) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NG\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:39:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_POSITIONS 100\n\ntypedef struct {\n    int value;\n    bool special;\n} Position;\n\nbool canReachEnd(Position* board, int boardLength, int maxRoulette, int startPos, int endPos) {\n    bool* visited = calloc(boardLength, sizeof(bool));\n    bool* reachable = calloc(boardLength, sizeof(bool));\n    \n    reachable[startPos] = true;\n    \n    for (int turn = 0; turn < boardLength; turn++) {\n        bool changed = false;\n        \n        for (int pos = 0; pos < boardLength; pos++) {\n            if (!reachable[pos]) continue;\n            \n            for (int roll = 1; roll <= maxRoulette; roll++) {\n                int nextPos = pos + roll;\n                \n                if (nextPos >= endPos) {\n                    free(visited);\n                    free(reachable);\n                    return true;\n                }\n                \n                if (nextPos < boardLength) {\n                    if (board[nextPos].special) {\n                        nextPos += board[nextPos].value;\n                        \n                        if (nextPos >= endPos) {\n                            free(visited);\n                            free(reachable);\n                            return true;\n                        }\n                        \n                        if (nextPos < 0) nextPos = 0;\n                    }\n                    \n                    if (nextPos < boardLength && !visited[nextPos]) {\n                        reachable[nextPos] = true;\n                        changed = true;\n                    }\n                }\n            }\n            \n            for (int roll = 1; roll <= maxRoulette; roll++) {\n                int nextPos = pos - roll;\n                \n                if (nextPos < 0) nextPos = 0;\n                \n                if (board[nextPos].special) {\n                    nextPos += board[nextPos].value;\n                    \n                    if (nextPos >= endPos) {\n                        free(visited);\n                        free(reachable);\n                        return true;\n                    }\n                    \n                    if (nextPos < 0) nextPos = 0;\n                }\n                \n                if (nextPos < boardLength && !visited[nextPos]) {\n                    reachable[nextPos] = true;\n                    changed = true;\n                }\n            }\n            \n            visited[pos] = true;\n        }\n        \n        if (!changed) break;\n    }\n    \n    free(visited);\n    free(reachable);\n    return false;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    for (int dataset = 0; dataset < datasets; dataset++) {\n        int boardLength, maxRoulette;\n        scanf(\"%d %d\", &boardLength, &maxRoulette);\n        \n        Position* board = malloc(boardLength * sizeof(Position));\n        for (int i = 0; i < boardLength; i++) {\n            board[i].special = false;\n            board[i].value = 0;\n        }\n        \n        int specialPositions;\n        scanf(\"%d\", &specialPositions);\n        \n        for (int i = 0; i < specialPositions; i++) {\n            int pos, value;\n            scanf(\"%d %d\", &pos, &value);\n            board[pos].special = true;\n            board[pos].value = value;\n        }\n        \n        int result = canReachEnd(board, boardLength, maxRoulette, 0, boardLength - 1);\n        printf(\"%s\\n\", result ? \"OK\" : \"NG\");\n        \n        free(board);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:39:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\nusing namespace std;\n\nbool canReachEnd(int board_length, vector<int>& board_moves, int max_roulette) {\n    vector<bool> visited(board_length + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        if (current == board_length) return true;\n\n        for (int roll = 1; roll <= max_roulette; ++roll) {\n            int next = current + roll;\n\n            if (next > board_length) next = board_length;\n\n            if (board_moves[next] != 0) {\n                next += board_moves[next];\n            }\n\n            if (next < 1) next = 1;\n            if (next > board_length) next = board_length;\n\n            if (!visited[next]) {\n                visited[next] = true;\n                q.push(next);\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int T;\n    cin >> T;\n\n    while (T--) {\n        int board_length, max_roulette;\n        cin >> board_length >> max_roulette;\n\n        vector<int> board_moves(board_length + 1, 0);\n        for (int i = 2; i <= board_length; ++i) {\n            cin >> board_moves[i];\n        }\n\n        cout << (canReachEnd(board_length, board_moves, max_roulette) ? \"OK\" : \"NG\") << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:39:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Sugoroku {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int N = scanner.nextInt();\n            int M = scanner.nextInt();\n            if (N == 0 && M == 0) break;\n            \n            int[] board = new int[N + 1];\n            for (int i = 1; i <= N; i++) {\n                board[i] = scanner.nextInt();\n            }\n            \n            int[] roulette = new int[M];\n            for (int i = 0; i < M; i++) {\n                roulette[i] = scanner.nextInt();\n            }\n            \n            boolean possible = false;\n            int currentPos = 1;\n            int turn = 0;\n            \n            while (turn < M) {\n                int move = roulette[turn];\n                currentPos += move;\n                if (currentPos >= N) {\n                    possible = true;\n                    break;\n                }\n                if (currentPos < 1) {\n                    currentPos = 1;\n                }\n                int command = board[currentPos];\n                currentPos += command;\n                if (currentPos >= N) {\n                    possible = true;\n                    break;\n                }\n                if (currentPos < 1) {\n                    currentPos = 1;\n                }\n                turn++;\n            }\n            \n            System.out.println(possible ? \"OK\" : \"NG\");\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:40:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_reach_end(board, max_roulette):\n    visited = [False] * len(board)\n    queue = [0]\n    visited[0] = True\n\n    while queue:\n        pos = queue.pop(0)\n        \n        if pos == len(board) - 1:\n            return 'OK'\n        \n        for roll in range(1, max_roulette + 1):\n            new_pos = min(pos + roll, len(board) - 1)\n            # Calculate real position after obeying board instruction\n            if board[new_pos].startswith('move forward'):\n                step = int(board[new_pos].split()[-1])\n                new_pos = min(new_pos + step, len(board) - 1)\n            elif board[new_pos].startswith('move back'):\n                step = int(board[new_pos].split()[-1])\n                new_pos = max(new_pos - step, 0)\n            \n            if not visited[new_pos]:\n                visited[new_pos] = True\n                queue.append(new_pos)\n\n    return 'NG'\n\ndef sugoroku(datasets):\n    results = []\n    for board, max_roulette in datasets:\n        results.append(can_reach_end(board, max_roulette))\n    return results\n\n# Example usage with multiple datasets\ndatasets = [\n    (['', 'move forward 2', '', 'move back 1', '', '', 'move forward 1'], 3),\n    (['', '', 'move back 2', '', 'move forward 3', '', ''], 2)\n]\nprint(sugoroku(datasets))",
    "timestamp": "2025-08-13 00:23:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class Sugoroku {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numDatasets = scanner.nextInt();\n\n        for (int i = 0; i < numDatasets; i++) {\n            int boardSize = scanner.nextInt();\n            int maxRoulette = scanner.nextInt();\n            int numInstructions = scanner.nextInt();\n\n            String[] instructions = new String[boardSize];\n            for (int j = 0; j < numInstructions; j++) {\n                int position = scanner.nextInt();\n                instructions[position] = scanner.next();\n            }\n\n            if (canReachEnd(boardSize, maxRoulette, instructions)) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NG\");\n            }\n        }\n\n        scanner.close();\n    }\n\n    private static boolean canReachEnd(int boardSize, int maxRoulette, String[] instructions) {\n        boolean[] reachable = new boolean[boardSize];\n        reachable[0] = true;\n\n        for (int position = 0; position < boardSize; position++) {\n            if (!reachable[position]) {\n                continue;\n            }\n\n            for (int dice = 1; dice <= maxRoulette; dice++) {\n                int newPosition = position + dice;\n                if (newPosition >= boardSize) {\n                    return true;\n                }\n                reachable[newPosition] = true;\n\n                if (instructions[newPosition] != null) {\n                    newPosition = applyInstruction(newPosition, boardSize, instructions[newPosition]);\n                    if (newPosition >= boardSize) {\n                        return true;\n                    }\n                    reachable[newPosition] = true;\n                }\n            }\n        }\n        return reachable[boardSize - 1];\n    }\n\n    private static int applyInstruction(int position, int boardSize, String instruction) {\n        String[] parts = instruction.split(\" \");\n        int move = Integer.parseInt(parts[2]);\n\n        if (parts[1].equals(\"forward\")) {\n            position = Math.min(position + move, boardSize - 1);\n        } else if (parts[1].equals(\"back\")) {\n            position = Math.max(position - move, 0);\n        }\n        return position;\n    }\n}",
    "timestamp": "2025-08-13 00:23:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_POSITIONS 1000\n\ntypedef struct {\n    int forward;\n    int backward;\n} Movement;\n\nbool canReachEnd(int n, int maxRoulette, Movement board[]) {\n    int position = 0;\n    bool visited[MAX_POSITIONS] = {false};\n\n    while (true) {\n        if (position >= n - 1) {\n            return true;\n        }\n        if (visited[position]) {\n            return false;\n        }\n\n        visited[position] = true;\n        if (board[position].forward > 0) {\n            position += board[position].forward;\n            if (position >= n - 1) {\n                return true;\n            }\n        } else if (board[position].backward > 0) {\n            position -= board[position].backward;\n            if (position < 0) {\n                position = 0;\n            }\n        } else {\n            position += maxRoulette;\n            if (position >= n - 1) {\n                return true;\n            }\n        }\n    }\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    for (int i = 0; i < datasets; i++) {\n        int n, maxRoulette;\n        scanf(\"%d %d\", &n, &maxRoulette);\n\n        Movement board[MAX_POSITIONS] = {0};\n        for (int j = 0; j < n; j++) {\n            char instruction[20];\n            scanf(\"%s\", instruction);\n\n            if (strncmp(instruction, \"move\", 4) == 0) {\n                char direction[10];\n                int steps;\n                sscanf(instruction + 5, \"%s %d\", direction, &steps);\n\n                if (strcmp(direction, \"forward\") == 0) {\n                    board[j].forward = steps;\n                } else if (strcmp(direction, \"backward\") == 0) {\n                    board[j].backward = steps;\n                }\n            }\n        }\n\n        if (canReachEnd(n, maxRoulette, board)) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:23:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_sugoroku(board_length, commands, roulette_max):\n    def can_reach_end(start_pos=0):\n        visited = set()\n        \n        def dfs(current_pos):\n            if current_pos >= board_length:\n                return True\n            \n            if current_pos in visited:\n                return False\n            \n            visited.add(current_pos)\n            \n            for roll in range(1, roulette_max + 1):\n                new_pos = current_pos + roll\n                \n                if new_pos >= board_length:\n                    return True\n                \n                if new_pos in commands:\n                    new_pos += commands[new_pos]\n                \n                if new_pos < 0:\n                    new_pos = 0\n                \n                if new_pos >= board_length:\n                    return True\n                \n                if dfs(new_pos):\n                    return True\n            \n            return False\n        \n        return dfs(start_pos)\n    \n    return \"OK\" if can_reach_end() else \"NG\"\n\n# Input parsing and main execution\ndef main():\n    T = int(input())\n    \n    for _ in range(T):\n        board_length, num_commands, roulette_max = map(int, input().split())\n        \n        commands = {}\n        for _ in range(num_commands):\n            pos, move = map(int, input().split())\n            commands[pos - 1] = move\n        \n        print(solve_sugoroku(board_length, commands, roulette_max))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:23:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        N = int(input[ptr])\n        M = int(input[ptr+1])\n        ptr +=2\n        if N == 0 and M == 0:\n            break\n        commands = []\n        for _ in range(N):\n            cmd = input[ptr]\n            if cmd == 'F':\n                x = int(input[ptr+1])\n                commands.append(('F', x))\n                ptr +=2\n            elif cmd == 'B':\n                x = int(input[ptr+1])\n                commands.append(('B', x))\n                ptr +=2\n        # BFS setup\n        from collections import deque\n        visited = set()\n        q = deque()\n        q.append(1)\n        visited.add(1)\n        possible = False\n        while q:\n            pos = q.popleft()\n            if pos == M:\n                possible = True\n                break\n            for spin in range(1, M+1):\n                new_pos = pos + spin\n                if new_pos > M:\n                    new_pos = M\n                # Apply commands in order\n                for cmd in commands:\n                    if cmd[0] == 'F':\n                        new_pos += cmd[1]\n                        if new_pos > M:\n                            new_pos = M\n                    elif cmd[0] == 'B':\n                        new_pos -= cmd[1]\n                        if new_pos < 1:\n                            new_pos = 1\n                if new_pos not in visited:\n                    visited.add(new_pos)\n                    q.append(new_pos)\n        print(\"OK\" if possible else \"NG\")\n\nsolve()",
    "timestamp": "2025-08-13 00:24:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nbool canReachEnd(int n, int maxRoulette, const vector<string>& board) {\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(0);\n    visited[0] = true;\n\n    while (!q.empty()) {\n        int pos = q.front();\n        q.pop();\n\n        for (int move = 1; move <= maxRoulette; move++) {\n            int nextPos = pos + move;\n            if (nextPos >= n) nextPos = n - 1;\n\n            while (true) {\n                if (visited[nextPos]) break;\n\n                visited[nextPos] = true;\n                const string& action = board[nextPos];\n                \n                if (action.find(\"forward\") != string::npos) {\n                    int steps = stoi(action.substr(action.find(' ') + 1));\n                    nextPos += steps;\n                    if (nextPos >= n) {\n                        nextPos = n - 1;\n                        break;\n                    }\n                } else if (action.find(\"back\") != string::npos) {\n                    int steps = stoi(action.substr(action.find(' ') + 1));\n                    nextPos -= steps;\n                    if (nextPos < 0) {\n                        nextPos = 0;\n                        break;\n                    }\n                } else break;\n            }\n\n            if (nextPos == n - 1) return true;\n            if (!visited[nextPos]) q.push(nextPos);\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n\n    while (datasets--) {\n        int n, maxRoulette;\n        cin >> n >> maxRoulette;\n        cin.ignore();\n\n        vector<string> board(n);\n        for (int i = 0; i < n; ++i) {\n            getline(cin, board[i]);\n        }\n\n        cout << (canReachEnd(n, maxRoulette, board) ? \"OK\" : \"NG\") << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:53:52"
  }
]