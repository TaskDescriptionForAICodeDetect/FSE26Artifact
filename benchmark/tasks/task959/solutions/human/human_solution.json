[
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(ll (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 40010\nll n, a, b, c;\n\nll inv[N], fact[N], ifact[N], be[N];\n \nll comb(ll a, ll b){\n\treturn fact[a+b]*ifact[a]%mod*ifact[b]%mod;\n}\n \nll comb_nk(ll n, ll k){\n\treturn comb(n-k, k);\n}\n \nll pow_mod(ll a, ll r, ll m){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n \nvoid init_fact(ll n = N){\n    inv[1] = 1;\n    for(int i = 2; i < n; i++) inv[i] = inv[mod%i] * (mod - mod/i) % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\t\tifact[i]=(ifact[i-1]*inv[i])%mod;\n\t}\n}\n\nint main(){\n\tinit_fact();\n\tcin>>n>>a>>b>>c;\n\tif(b%2){\n\t\tcout<<0<<endl;\n\t\twhile(true);\n\t\treturn 0;\n\t}\n\tif(b==0) return -1;\n\tb /= 2;\n\tll res = 0;\n\trep(y, a+1){\n\t\tll z = a-y;\n\t\tfor(ll x = 0; x <= (c-y)/3; x++){\n\t\t\tll w = c-y-3*x;\n\t\t\tif(b==0 && w>0) continue;\n\t\t\t(res+=fact[x+y+z+b]*ifact[x]%mod*ifact[y]%mod*ifact[z]%mod*ifact[b]%mod*comb_nk(w+b-1, w))%=mod;\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr lint MOD = 1000000007;\nvector<lint> fac, facInv, inv;\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\nlint nPr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return fac[n] * facInv[n-r] % MOD;\n}\nlint power(lint x, lint n, lint mod=MOD)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= mod;\n        (x *= x) %= mod;\n       n >>= 1;\n    }\n   return ans;\n}\n\n\nint main()\n{\n    int N, A, B, C;\n    cin >> N >> A >> B >> C;\n    facInit(N * 2);\n    if (B % 2)\n    {\n        puts(\"0\");\n        return 0;\n    }\n    lint ret = 0;\n    lint c = nCr(A + B / 2, A);\n\n    REP(i, A + 1) // 1をつつむ3の数\n    {\n        int j = C - i; // 残った3の数\n        if (j < 0) continue;\n        REP(k, j / 3 + 1) // 3のみの塊の数\n        {\n            int l = j - 3 * k; // 2に関与できる3の数\n            if (B) ret += c * nCr(A, i) % MOD * nCr(l + B / 2 - 1, l) % MOD * nCr(A + B / 2 + k, k) % MOD;\n            else if (l == 0) ret += c * nCr(A, i) % MOD * nCr(A + B / 2 + k, k) % MOD;\n        }\n    }\n    cout << ret % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint N, A, B, C;\nint main() {\n\tcin >> N >> A >> B >> C;\n\tif (B % 2 == 0) {\n\t\tMInt sum;\n\t\tREP(x, 0, N) {\n\t\t\tREP(y, 0, 2 * N) {\n\t\t\t\tif ((C - x - y) % 3 != 0) continue;\n\t\t\t\tint p = A - x;\n\t\t\t\tint q = x;\n\t\t\t\tint r = (C - x - y) / 3;\n\t\t\t\tint s = B / 2;\n\t\t\t\tif (p < 0) continue;\n\t\t\t\tif (q < 0) continue;\n\t\t\t\tif (r < 0) continue;\n\t\t\t\tsum += MInt::fact(p + q + r + s) * MInt::homcombi(s, y) / (\n\t\t\t\t\t\tMInt::fact(p) *\n\t\t\t\t\t\tMInt::fact(q) *\n\t\t\t\t\t\tMInt::fact(r) *\n\t\t\t\t\t\tMInt::fact(s)\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t} else {\n\t\tcout << 0 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int MOD = (int) 1e9 + 7;\nvoid sadd(int &a, int b)\n{\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n}\nint add(int a, int b)\n{\n\tsadd(a, b);\n\treturn a;\n}\nint mul(int a, int b)\n{\n\treturn (a * 1LL * b) % MOD;\n}\nvoid smul(int &a, int b)\n{\n\ta = mul(a, b);\n}\n\nconst int N = 5005;\nint C[N][N];\n\nint getC(int a, int b)\n{\n\tif (a < 0 || b < 0 || b > a) return 0;\n\treturn C[a][b];\n}\n\nvoid init()\n{\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tC[i][j] = add(C[i - 1][j - 1], C[i - 1][j] );\n\t}\n}\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tinit();\n\n\tint n, a, b, c;\n\tscanf(\"%d%d%d%d\", &n, &a, &b, &c);\n\n\tif (b % 2 != 0)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\tint blocks = b / 2;\n\tfor (int c3b = 0; c3b <= c; c3b++)\n\t{\n\t\tint cur = getC(blocks + c3b - 1,c3b);\n\t\tfor (int c1 = 0; c1 <= a; c1++)\n\t\t{\n\t\t\tint c31 = a - c1;\n\t\t\tint c333 = (c - c31 - c3b) / 3;\n\t\t\tif (c31 < 0 || c333 < 0) continue;\n\t\t\tif (c31 + c3b + 3 * c333 != c) continue;\n\t\t\tint loc = cur;\n\t\t\tsmul(loc, getC(blocks + c31, c31) );\n\t\t\tsmul(loc, getC(blocks + c31 + c333, c333) );\n\t\t\tsmul(loc, getC(blocks + c31 + c333 + c1, c1) );\n\t\t\tsadd(ans, loc);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nconst int maxn = (int) 1e4 + 10;\nint fact[maxn], ifact[maxn];\n\nvoid precalc() {\n  fact[0] = ifact[0] = 1;\n  for (int i = 1; i < maxn; ++i) {\n    fact[i] = mult(fact[i - 1], i);\n    ifact[i] = mult(ifact[i - 1], myPower(i, mod - 2));\n  }\n}\n\nint n, a, b, c;\n\nint read() {\n  if (scanf(\"%d%d%d%d\", &n, &a, &b, &c) < 4) {\n    return 0;\n  }\n  return 1;\n}\n\nvoid solve() {\n  if (b & 1) {\n    printf(\"0\\n\");\n    return;\n  }\n  int b2 = b / 2;\n\n  int res = 0;\n  for (int x = 0; x <= a; ++x) {\n    for (int y = 0;; ++y) {\n      int left = c - (3 * y + a - x);\n      if (left < 0) {\n        break;\n      }\n      int cur = 1;\n      cur = mult(cur, fact[a + y + b2]);\n      cur = mult(cur, ifact[x]);\n      cur = mult(cur, ifact[a - x]);\n      cur = mult(cur, ifact[y]);\n      cur = mult(cur, ifact[b2]);\n      if (b2 == 0) {\n        if (left != 0) {\n          cur = 0;\n        }\n      } else {\n        cur = mult(cur, fact[left + b2 - 1]);\n        cur = mult(cur, ifact[b2 - 1]);\n        cur = mult(cur, ifact[left]);\n      }\n      add(res, cur);\n    }\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n\tll call_invp(int i) {\n\t\treturn invp[i];\n\t}\n};\nperm p(1 << 20);\n\n\nvoid solve() {\n\tint n, a, b, c; cin >> n >> a >> b >> c;\n\tif (b % 2) {\n\t\tcout << 0 << endl; return;\n\t}\n\tll ans = 0;\n\trep(x, a + 1) {\n\t\trep(y, b / 2 + 1) {\n\t\t\tvector<int> v = { x,y };\n\t\t\tv.push_back(a - x);\n\t\t\tv.push_back(b / 2 - y);\n\t\t\tint z = c - x + y - b / 2;\n\t\t\tif (z % 3||z<0)continue;\n\t\t\tv.push_back(z / 3);\n\t\t\tint sum = 0;\n\t\t\trep(k, 5) {\n\t\t\t\tsum += v[k];\n\t\t\t}\n\t\t\tll csum = p.combP(sum, sum);\n\t\t\trep(i, 5) {\n\t\t\t\tcsum = csum * p.call_invp(v[i]) % mod;\n\t\t\t}\n\t\t\tans += csum;\n\t\t\tif (ans >= mod)ans -= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 100000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nint main()\n{\n\tinvinit();\n\tint n, a, b, c;\n\tscanf(\"%d%d%d%d\", &n, &a, &b, &c);\n\tif (b % 2 != 0)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i <= c / 3; i++)\n\t{\n\t\tfor (int j = 0; j <= min(a, c - i * 3); j++)\n\t\t{\n\t\t\tll t = com(a + b / 2 + i, i)*com(a + b / 2, a) % mod*com(a, j) % mod;\n\t\t\tt *= com(c - i * 3 - j + b / 2 - 1, b / 2 - 1);\n\t\t\tans = (ans + t) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=10000+10,mod=1e9+7;\nint ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint fac[maxn],ifac[maxn];\ninline void init(int n){\n\tfac[0]=1;\n\tREP(i,1,n) fac[i]=(ll)i*fac[i-1]%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tDREP(i,n,1) ifac[i-1]=(ll)i*ifac[i]%mod;\n}\ninline int calc(int n,int m){\n\tif(n<0 || m<0 || m>n) return 1;\n\treturn (ll)fac[n]*ifac[n-m]%mod*ifac[m]%mod;\n}\nint main(){\n\tinit(maxn-10);\n\tint n=read(),A=read(),B=read(),C=read(),ans=0;\n\tREP(x1,0,A) REP(x3,0,C/3){\n\t\tint x2=A-x1,x4=B/2,S=C-x3*3-x2;\n\t\tif(S<0) continue;\n\t\tans=(ans+(ll)fac[x1+x2+x3+x4]*ifac[x1]%mod*ifac[x2]%mod*ifac[x3]%mod*ifac[x4]%mod*calc(x4+S-1,x4-1))%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst ll Mod = 1000000007LL;\nconst int Maxn = 1e4 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nll mul(ll a, ll b){\n\treturn (a * b) % Mod;\n}\nll bin_pow(ll b, ll p){\n\tll res = 1;\n\tfor(ll j = 1, pw = b; j <= p; j <<= 1, pw = mul(pw, pw))\n\t\tif(p & j)\n\t\t\tres = mul(res, pw);\n\treturn res;\n}\nll inv(ll x){\n\treturn bin_pow(x, Mod - 2);\n}\nll f[Maxn], iv[Maxn];\nll nCr(ll n, ll r){\n\tif((n < r) || (r < 0)) return 0;\n\treturn mul(f[n], mul(iv[r], iv[n - r]));\n}\n\n\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tf[0] = 1;\n\tfor(int i = 1; i < Maxn; i++) f[i] = mul(f[i - 1], i);\n\tfor(int i = 0; i < Maxn; i++) iv[i] = inv(f[i]);\n\t\n\tll n, a, b, c;\n\tcin >> n >> a >> b >> c;\n\tif(b & 1) return cout << 0, 0;\n\tb /= 2;\n\t\n\tll ans = 0;\n\tfor(int i = 0; i <= a; i++){\n\t\tfor(int j = 0; 3*j + i <= c; j++){\n\t\t\tans += mul( mul( mul(nCr(a + j + b, i), nCr(a + j + b - i, a - i)), nCr(j + b, j) ), nCr(c - 3*j - i + b - 1, b - 1));\n\t\t}\n\t}\n\tcout << ans % Mod << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long N, A, B, C, sum1[5009], sum2[5009][5009], ans, mod = 1000000007;\nlong long fact[5009], inv[5009], factinv[5009];\n\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= 5000; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tinv[1] = 1; for (int i = 2; i <= 5000; i++)inv[i] = (mod - (1LL * (mod / i)*inv[mod%i]) % mod) % mod;\n\tfactinv[0] = 1; for (int i = 1; i <= 5000; i++)factinv[i] = (factinv[i - 1] * inv[i]) % mod;\n}\nlong long ncr(long long n, long long r) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn (((fact[n] * factinv[n - r]) % mod)*factinv[r]) % mod;\n}\n\nint main() {\n\tinit();\n\tcin >> N >> A >> B >> C; if (B % 2 == 1) { cout << \"0\" << endl; return 0; }\n\n\tfor (int i = 0; i <= B / 2; i++) {\n\t\tfor (int j = 0; j <= C; j++) {\n\t\t\tlong long ret = factinv[i] * factinv[B / 2 - i];\n\t\t\tret *= ncr(j + (i - 1), (i - 1)); ret %= mod;\n\t\t\tsum1[j] += ret; sum1[j] %= mod;\n\t\t}\n\t}\n\tfor (int i = 0; i <= C; i++) {\n\t\tfor (int j = 0; j <= C; j += 3) {\n\t\t\tif (i + j > C || i > A) continue;\n\t\t\tlong long P1 = A - i, P2 = i, P3 = j / 3;\n\t\t\tlong long ret = factinv[P1] * factinv[P2]; ret %= mod;\n\t\t\tret *= factinv[P3]; ret %= mod;\n\t\t\tsum2[P1 + P2 + P3][i + j] += ret; sum2[P1 + P2 + P3][j] %= mod;\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= C; i++) { \n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tans += ((sum1[i] * sum2[j + A + i][C - i]) % mod)*fact[j]; ans %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\n#define LL long long\nusing namespace std;\nconst int mo=1e9+7;\nint n,a,b,c; LL fc[N],xf[N],ans;\nLL fpm(LL x,LL y){ LL s=1; while(y){ if(y&1) s=(s*x)%mo; y>>=1,x=(x*x)%mo;} return s;}\nLL C(int n,int m){ return fc[n]*xf[m]%mo*xf[n-m]%mo;} \nint main()\n{\n\tint i,j,p,q,r,s,v;\n\tcin>>n>>a>>b>>c;\n\tif(b&1){ printf(\"0\"); return 0;}\n\tfc[0]=xf[0]=1;\n\tfor(i=1;i<N;i++){\n\t\tfc[i]=(fc[i-1]*i)%mo;\n\t\txf[i]=fpm(fc[i],mo-2);\n\t  }\n\tfor(i=0;i<=a&&i<=c;i++)\n\t\tfor(j=0;i+3*j<=c;j++){\n\t\t\tp=a-i,q=i,r=j,s=b/2,v=c-i-3*j;\n\t\t\tans=(ans+1LL*fc[p+q+r+s]*xf[p]%mo*xf[q]%mo*xf[r]%mo*xf[s]%mo*C(v+s-1,s-1))%mo;\n\t\t  }\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst ll MOD = 1e9 + 7;\nconst int MX = 11000;\n\nll ans = 0;\nll fc[MX];\nll bfc[MX];\nint n, a, b, c;\n\nll pw(ll a, ll b) {\n\tll ans = 1;\n\twhile (b) {\n\t\twhile (!(b & 1))\n\t\t\tb >>= 1, a = (a * a) % MOD;\n\t\t--b;\n\t\tans = (ans * a) % MOD;\n\t}\n\treturn ans;\n}\n\nvoid init() {\n\tfc[0] = bfc[0] = 1;\n\tfor (int i = 1; i < MX; ++i)\n\t\tfc[i] = (fc[i - 1] * i) % MOD, bfc[i] = pw(fc[i], MOD - 2);\n}\n\nint main() {\n\tcin >> n >> a >> b >> c;\n\tinit();\n\tif (b % 2 != 0) {\n\t\tcout << 0 << \"\\n\";\n\t\treturn 0;\n\t}\n\tint y = b / 2;\n\tfor (int x = 0; x <= a; ++x) {\n\t\tfor (int w = 0; w * 3 <= c; ++w) {\n\t\t\tint z = a - x;\n\t\t\tif (z + 3 * w > c)\n\t\t\t\tcontinue;\n\t\t\tint lst = c - 3 * w - z;\n\t\t\tif (lst != 0 && y == 0)\n\t\t\t\tcontinue;\n\t\t\tll now = fc[x + y + z + w];\n\t\t\tnow = now * bfc[x] % MOD * bfc[y] % MOD * bfc[z] % MOD * bfc[w] % MOD;\n\t\t\tif (y != 0)\n\t\t\t\tnow = now * fc[y + lst - 1] % MOD * bfc[lst] % MOD * bfc[y - 1] % MOD;\n\t\t\tans = (now + ans) % MOD;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nll MOD = 1E9 + 7;\n\nll F[20000], I[20000];\n\nll power(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b % 2) {\n            res *= a;\n            res %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid init() {\n    F[0] = 1;\n    for (ll i = 1;i < 20000;i++) {\n        F[i] = F[i - 1] * i;\n        F[i] %= MOD;\n    }\n    I[19999] = power(F[19999], MOD - 2);\n    for (ll i = 19998;i >= 0;i--) {\n        I[i] = I[i + 1] * (i + 1);\n        I[i] %= MOD;\n    }\n    return;\n}\n\nll nchoosek(int a, int b) {\n    ll ans = F[a] * I[b];\n    ans %= MOD;\n    ans *= I[a - b];\n    ans %= MOD;\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N, A, B, C;\n    init();\n    cin >> N >> A >> B >> C;\n    if (B % 2) {\n        cout << 0 << endl;\n        return 0;\n    }\n    ll res = 0;\n    for (int x = 0;x <= A;x++) {\n        int y = A - x;\n        int rem_c = C - y;\n        for (int c = 0;c * 3 <= rem_c;c++) {\n            ll crt = 1;\n            int all = x + y + c + B/2;\n            crt *= nchoosek(all, x);\n            crt *= nchoosek(all - x, y);\n            crt %= MOD;\n            crt *= nchoosek(all - x - y, c);\n            crt %= MOD;\n            if (B > 0) crt *= nchoosek(rem_c - c * 3 + B/2 - 1, B/2 - 1);\n            else if (rem_c - c != 0) crt = 0;\n            crt %= MOD;\n            res += crt;\n            res %= MOD;\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    return fact[n]*inv[n-k]%mod;\n}\n\nsigned main(){\n    int N,A,B,C;\n    cin>>N>>A>>B>>C;\n\n    if(B%2){\n        cout<<0<<endl;\n        return 0;\n    }\n    \n    int ans=0;\n    for(int i=0;i<=A;i++){\n        for(int l=0;l*3<=C;l++){\n            int j=B/2;\n            int k=A-i;\n\n            int x=C-k-3*l;\n            if(x<0)continue;\n            if(j==0&&x>0)continue;\n            int tmp=fact[i+j+k+l]*inv[i]%mod*inv[j]%mod*inv[k]%mod*inv[l]%mod;\n            tmp=tmp*nCk(x+j-1,j-1)%mod;\n            add(ans,tmp);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\n#define LL long long\nusing namespace std;\nconst int mo=1e9+7;\nint n,a,b,c; LL fc[N],xf[N],ans;\nLL fpm(LL x,LL y){ LL s=1; while(y){ if(y&1) s=(s*x)%mo; y>>=1,x=(x*x)%mo;} return s;}\nLL C(int n,int m){ return fc[n]*xf[m]%mo*xf[n-m]%mo;}\nLL f(int n,int m)\n{\n\tif(!n) return (m==0);\n\telse return xf[n]*C(m+n-1,n-1)%mo;\n}\nint main()\n{\n\tint i,j,p,q,r,s,v;\n\tcin>>n>>a>>b>>c;\n\tif(b&1){ printf(\"0\"); return 0;}\n\tfc[0]=xf[0]=1;\n\tfor(i=1;i<N;i++){\n\t\tfc[i]=(fc[i-1]*i)%mo;\n\t\txf[i]=fpm(fc[i],mo-2);\n\t  }\n\tfor(i=0;i<=a&&i<=c;i++)\n\t\tfor(j=0;i+3*j<=c;j++){\n\t\t\tp=a-i,q=i,r=j,s=b/2,v=c-i-3*j;\n\t\t\tans=(ans+fc[p+q+r+s]*xf[p]%mo*xf[q]%mo*xf[r]%mo*f(s,v))%mo;\n\t\t  }\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define DN(en, ka) (F[en] * pot(F[ka] * F[en - ka] % Q, -1) % Q)\nusing namespace std;\ntypedef long long int ll;\nconst ll N = 1 << 16, Q = 1000000007;\nll n, a, b, c, res, F[N] = {1};\nint pot(ll a, ll b){\n  a %= Q;\n  if(b < 0)\n    return pot(pot(a, -b), Q - 2);\n  if(b == 0)\n    return 1;\n  if(b % 2 == 1)\n    return ((ll)pot(a, b - 1) * a) % Q;\n  ll t = pot(a, b / 2);\n  return (t * t) % Q;\n}\nint solve(int x, int y){\n  if(b % 2 == 1 || c < y * 3 + a - x || (b == 0 && (c - a + x) % 3 != 0))\n    return 0;\n  ll t = c - a + x - 3 * y,\n    l = F[a + y + b / 2],\n    m = F[x] * F[y] % Q * F[a - x] % Q * F[b / 2] % Q,\n    k = b ? DN(b / 2 + t - 1, t) : 1;\n  return l * pot(m, -1) % Q * k % Q;\n}  \nint main(){\n  for(int i = 1;i < N;i++)\n    F[i] = (F[i - 1] * i) % Q;\n  cin >> n >> a >> b >> c;\n  for(int i = 0;i <= a;i++)\n    for(int j = 0;j <= c / 3;j++){\n      res += solve(i, j);\n    }\n  cout << res % Q << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(ll (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 5010\nll n, a, b, c;\n\nll inv[N], fact[N], ifact[N], be[N];\n \nll comb(ll a, ll b){\n\treturn fact[a+b]*ifact[a]%mod*ifact[b]%mod;\n}\n \nll comb_nk(ll n, ll k){\n\treturn comb(n-k, k);\n}\n \nll pow_mod(ll a, ll r, ll m){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n \nvoid init_fact(ll n = N){\n    inv[1] = 1;\n    for(int i = 2; i < n; i++) inv[i] = inv[mod%i] * (mod - mod/i) % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\t\tifact[i]=(ifact[i-1]*inv[i])%mod;\n\t}\n}\n\nint main(){\n\tinit_fact();\n\tcin>>n>>a>>b>>c;\n\tif(b%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tb /= 2;\n\tll res = 0;\n\trep(y, a+1){\n\t\tll z = a-y;\n\t\tfor(ll x = 0; x <= (c-y)/3; x++){\n\t\t\tll w = c-y-3*x;\n\t\t\tif(b==0 && w>0) continue;\n\t\t\t(res+=fact[x+y+z+b]*ifact[x]%mod*ifact[y]%mod*ifact[z]%mod*ifact[b]%mod*comb_nk(w+b-1, w))%=mod;\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nint a, b, c;\n\nlong long mod=1000000007;\nlong long sil[100007];\nlong long osil[100007];\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n\tlong long wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t{\n\t\t\ta*=b;\n\t\t\ta%=mod;\n\t\t}\n\t\tb*=b;\n\t\tb%=mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nlong long komb(int a, int b)\n{\n\tif (b<0 || b>a)\n\t\treturn 0;\n\treturn (sil[a]*((osil[b]*osil[a-b])%mod))%mod;\n}\n\nlong long komz(int a, int b)\n{\n\tif (!a && !b)\n\t\treturn 1;\n\treturn komb(a+b-1, b);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%d%d%d\", &a, &b, &c);\n\tsil[0]=1;\n\tosil[0]=1;\n\tfor (int i=1; i<=2*n; i++)\n\t{\n\t\tsil[i]=(sil[i-1]*i)%mod;\n\t\tosil[i]=dziel(1, sil[i]);\n\t}\n\tif (b&1)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tb/=2;\n\tfor (int i=0; i<=c; i++)\n\t{\n\t\tfor (int j=0; j+i<=c; j++)\n\t\t{\n\t\t\tint r=c-j-i;\n\t\t\tif (r%3)\n\t\t\t\tcontinue;\n\t\t\tr/=3;\n\t\t\tlong long dod=1;\n\t\t\t\n\t\t\tdod*=komz(b, i);\n\t\t\tdod%=mod;\n\t\t\t\n\t\t\tdod*=komb(a, j);\n\t\t\tdod%=mod;\n\t\t\t\n\t\t\tdod*=komb(a+b+r, r);\n\t\t\tdod%=mod;\n\t\t\t\n\t\t\twyn+=dod;\n\t\t\twyn%=mod;\n\t\t}\n\t}\n\t\n\t\n\twyn*=komb(a+b, a);\n\twyn%=mod;\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst ll Mod = 1000000007LL;\nconst int Maxn = 1e5 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nll mul(ll a, ll b){\n\treturn (a * b) % Mod;\n}\nll bin_pow(ll b, ll p){\n\tll res = 1;\n\tfor(ll j = 1, pw = b; j <= p; j <<= 1, pw = mul(pw, pw))\n\t\tif(p & j)\n\t\t\tres = mul(res, pw);\n\treturn res;\n}\nll inv(ll x){\n\treturn bin_pow(x, Mod - 2);\n}\nll f[Maxn], iv[Maxn];\nll nCr(ll n, ll r){\n\tif((n < r) || (r < 0)) return 0;\n\treturn mul(f[n], mul(iv[r], iv[n - r]));\n}\n\n\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tf[0] = 1;\n\tfor(int i = 1; i < Maxn; i++) f[i] = mul(f[i - 1], i);\n\tfor(int i = 0; i < Maxn; i++) iv[i] = inv(f[i]);\n\t\n\tll n, a, b, c;\n\tcin >> n >> a >> b >> c;\n\tif(b & 1) return cout << 0, 0;\n\tb /= 2;\n\t\n\tll ans = 0;\n\tfor(int i = 0; i <= a; i++){\n\t\tfor(int j = 0; 3*j + (a - i) <= c; j++){\n\t\t\tans += mul( mul( mul(nCr(a + j + b, i), nCr(a + j + b - i, a - i)), nCr(j + b, j) ), nCr(c - 3*j - (a - i) + b - 1, b - 1));\n\t\t}\n\t}\n\tcout << ans % Mod << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    return fact[n]*inv[n-k]%mod;\n}\n\nsigned main(){\n    int N,A,B,C;\n    cin>>N>>A>>B>>C;\n\n    int ans=0;\n    for(int i=0;i<=A;i++){\n        for(int l=0;l*3<=C;l++){\n            int j=B/2;\n            int k=A-i;\n\n            int x=C-k-3*l;\n            if(x<0)continue;\n            if(j==0&&x>0)continue;\n            int tmp=fact[i+j+k+l]*inv[i]%mod*inv[j]%mod*inv[k]%mod*inv[l]%mod;\n            tmp=tmp*nCk(x+j-1,j-1)%mod;\n            add(ans,tmp);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 100005\n#define M 200005\n#define seed 23333\n#define Mo 1000000007\n\nusing namespace std;\nint i,j,m,n,p,k,a,b,c,ans,fac[N],inv[N];\nint C(int x,int y)\n{\n\t\tif (y==0) return 1; \n\t\tif (x<y) return 0;\n\t\treturn 1ll*fac[x]*inv[y]%Mo*inv[x-y]%Mo;\n}\nint power(int x,int y)\n{\n\t\tint s=1;\n\t\tfor (;y;y>>=1)\n\t\t{\n\t\t\t\tif (y&1) s=1ll*s*x%Mo;\n\t\t\t\tx=1ll*x*x%Mo;\n\t\t}\n\t\treturn s;\n}\nvoid jia(int &x,int y)\n{\n\t\tx+=y; if (x>=Mo) x-=Mo;\n}\nint main()\n{\n\tscanf(\"%d%d%d%d\",&n,&a,&b,&c);\n\tfac[0]=inv[0]=1;\n\tfor (i=1;i<N;++i) fac[i]=1ll*fac[i-1]*i%Mo,inv[i]=power(fac[i],Mo-2);\n\tif (b&1) puts(\"0\");\n\telse \n\t{\n\t\t  b/=2;\n\t\t  for (i=0;i<=a;++i)\n\t\t  \tfor (j=0;i+j<=c;++j)\n\t\t  \t\tif ((c-i-j)%3==0)\n\t\t  \t\t{\n\t\t  \t\t\t\tjia(ans,1ll*C(a+b,a)*C(a,i)%Mo*C(b+j-1,j)%Mo*C(a+b+1+(c-i-j)/3-1,(c-i-j)/3)%Mo); \n\t\t  \t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace io {\n    // TYPE ID (StackOverflow)\n    \n    template<class T> struct like_array : is_array<T>{};\n    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};\n    template<class T> struct like_array<vector<T>> : true_type{};\n    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }\n\n    // I/O \n    \n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n    \n    // INPUT \n    \n    template<class T> void re(T& x) { cin >> x; }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest);\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    \n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    \n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n    \n    // OUTPUT \n    \n    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {\n        os << '{' << a.f << \", \" << a.s << '}'; return os;\n    }\n    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {\n        os << '{';\n        F0R(i,SZ) {\n            if (i) {\n                os << \", \";\n                if (is_like_array(a[i])) cout << \"\\n\";\n            }\n            os << a[i];\n        }\n        os << '}';\n        return os;\n    }\n    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {\n        return printArray(os,a,SZ);\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {\n        return printArray(os,a,sz(a));\n    }\n    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {\n        os << vector<T>(all(a)); return os;\n    }\n    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {\n        os << vector<pair<T1,T2>>(all(a)); return os;\n    }\n    \n    template<class T> void pr(const T& x) { cout << x << '\\n'; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        cout << first << ' '; pr(rest...); \n    }\n}\n\nusing namespace io;\n\nnamespace modOp {\n    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }\n    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }\n    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }\n    \n    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }\n    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }\n    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }\n    \n    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }\n    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }\n    \n    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1\n        if (a == 0) return b == 1 ? 0 : -1;\n        int x = invGeneral(b%a,a); \n        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n    }\n}\n\nusing namespace modOp;\n\ntemplate<int SZ> struct combo {\n    int fac[SZ+1], ifac[SZ+1];\n    vpl factors;\n    vi cnt[SZ+1];\n    \n    void init(ll _MOD) {\n        factors = {{MOD,1}}; // factors = factor(MOD);\n        cnt[0].resize(sz(factors));\n        \n        fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ+1) {\n            cnt[i] = cnt[i-1];\n            \n            int I = i;\n            F0R(j,sz(factors)) \n                while (I % factors[j].f == 0) \n                    I /= factors[j].f, cnt[i][j] ++;\n                \n            fac[i] = mul(I,fac[i-1],MOD), ifac[i] = invGeneral(fac[i],MOD);\n        }\n    }\n    \n    ll comb(ll a, ll b) {\n        if (a == b) return 1;\n        if (a < b || b < 0) return 0;\n        ll tmp = mul(mul(fac[a],ifac[b],MOD),ifac[a-b],MOD);\n        F0R(i,sz(factors)) {\n            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];\n            tmp = mul(tmp,po(factors[i].f,t),MOD);\n        }\n        return tmp;\n    }\n};\n\ncombo<5001> Z;\nint N,A,B,C,ans;\n\nint multi(vi v) {\n    int prod = 1, sum = 0;\n    trav(x,v) {\n        sum += x;\n        MUL(prod,Z.ifac[x]);\n    }\n    MUL(prod,Z.fac[sum]);\n\n    return prod;\n}\n\nint main() {\n    // you should actually read the stuff at the bottom\n    Z.init(MOD);\n    setIO(); re(N,A,B,C); \n    if (B % 2 != 0) {\n        cout << 0;\n        exit(0);\n    }\n    for (int i = 0; i <= min(A,C); ++i) for (int j = 0; i+3*j <= C; ++j) {\n        int two = A-i, four = i, six = j, special = B/2;\n        AD(ans,mul(multi({two,four,six,special}),Z.comb(C-i-3*j+special-1,special-1)));\n        // C-i-3*j extras\n    }\n    pr(ans);\n    \n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD=1000000007;\nint fact[10001];\nint ifact[10001];\n\nint powmod(int a, int b)\n{\n    int ret=1;\n    for(; b>0; b/=2)\n    {\n        if(b&1)\n            ret=1LL*ret*a%MOD;\n        a=1LL*a*a%MOD;\n    }\n    return ret;\n}\n\nint C(int n, int k)\n{\n    return 1LL*fact[n]*ifact[k]%MOD*ifact[n-k]%MOD;\n}\n\nint solve(int a, int b, int c, int d, int f)\n{\n    if(c==0)\n    {\n        if(d==0)\n            return 1LL*C(a+b+f, a+b)*C(a+b, a)%MOD;\n        return 0;\n    }\n    int e=C(d+c-1, d);\n    return 1LL*e*C(a+b+c+f, a+b+c)%MOD*C(a+b+c, a+b)%MOD*C(a+b, a)%MOD;\n}\n\nint main()\n{\n    fact[0]=1;\n    ifact[0]=1;\n    for(int i=1; i<=10000; i++)\n    {\n        fact[i]=1LL*fact[i-1]*i%MOD;\n        ifact[i]=powmod(fact[i], MOD-2);\n    }\n    int N, A, B, C;\n    scanf(\"%d%d%d%d\", &N, &A, &B, &C);\n    if(B%2==1)\n        return printf(\"0\\n\"), 0;\n    int ans=0;\n    for(int c=0; c<=C; c+=3)\n        for(int i=0; i<=min(A, C-c); i++)\n            ans=(ans+solve(i, A-i, B/2, C-c-i, c/3))%MOD;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong long fact[12100];\nlong long inv[12100];\nlong long finv[12100];\nlong long C(int a,int b){\n\tif(a<b)return 0;\n\treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nint main(){\n\tfact[0]=finv[0]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<12100;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<12100;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n\tint n,a,b,c;\n\tscanf(\"%d%d%d%d\",&n,&a,&b,&c);\n\tif(b%2){\n\t\tprintf(\"0\\n\");return 0;\n\t}\n\tlong long ks=C(a+b/2,a);\n\tlong long ret=0;\n\tif(b==0){\n\t\tfor(int i=0;i<=c/3;i++){\n\t\t\tret=(ret+C(a,c-i*3)*C(a+c/3,a))%mod;\t\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<=c/3;i++){\n\t\t\tlong long ks2=C(a+b/2+i,i);\n\t\t\tfor(int j=0;j<=min(a,c-i*3);j++){\n\t\t\t\tlong long tmp=C(a,j);\n\t\t\t\tint rem=c-i*3-j;\n\t\t\t\tret=(ret+tmp*C(rem+b/2-1,rem)%mod*ks2)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tret=ret*ks%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(ll (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 40010\nll n, a, b, c;\n\nll inv[N], fact[N], ifact[N], be[N];\n \nll comb(ll a, ll b){\n\treturn fact[a+b]*ifact[a]%mod*ifact[b]%mod;\n}\n \nll comb_nk(ll n, ll k){\n\tif(n<0) return 1;\n\treturn comb(n-k, k);\n}\n \nll pow_mod(ll a, ll r, ll m){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n \nvoid init_fact(ll n = N){\n    inv[1] = 1;\n    for(int i = 2; i < n; i++) inv[i] = inv[mod%i] * (mod - mod/i) % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\t\tifact[i]=(ifact[i-1]*inv[i])%mod;\n\t}\n}\n\nint main(){\n\tinit_fact();\n\tcin>>n>>a>>b>>c;\n\tif(b%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tb /= 2;\n\tll res = 0;\n\trep(y, a+1){\n\t\tll z = a-y;\n\t\tfor(ll x = 0; x <= (c-y)/3; x++){\n\t\t\tll w = c-y-3*x;\n\t\t\tif(w<0) continue;\n\t\t\tif(b==0 && w>0) continue;\n\t\t\t(res+=fact[x+y+z+b]*ifact[x]%mod*ifact[y]%mod*ifact[z]%mod*ifact[b]%mod*comb_nk(w+b-1, w))%=mod;\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n\nvector<pair<ll, ll> > vv;\nconst ll INF = 1e18;\n\nint n;\nll dp[2][5100];\nll dp2[2][5100];\n\nvoid out(ll a) {\n\tvector<int> o;\n\twhile (a != 0)\n\t\to.push_back(a % 10), a /= 10;\n\treverse(o.begin(), o.end());\n\tfor (int i: o)\n\t\tcout << i;\n}\n\n\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tvv.push_back(make_pair(l + r, l));\n\t}\n\tsort(vv.begin(), vv.end());\n\treverse(vv.begin(), vv.end());\n\tfor (int i = 0; i <= n; ++i)\n\t\tdp[0][i] = dp[1][i] = INF;\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < (int)vv.size(); ++i) {\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tdp2[0][j] = dp2[1][j] = INF;\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tdp2[0][j + 1] = min(dp2[0][j + 1], dp[0][j] + vv[i].first * j + (vv[i].first - vv[i].second));\n\t\t\tdp2[0][j] = min(dp2[0][j], dp[0][j] + vv[i].first * (i - j) + (vv[i].second));\n\t\t}\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\t\tdp[0][j] = dp2[0][j], dp[1][j] = dp2[1][j];\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tdp2[1][j + 1] = min(dp2[1][j + 1], dp[1][j] + vv[i].first * j + (vv[i].first - vv[i].second));\n\t\t\tdp2[1][j] = min(dp2[1][j], dp[1][j] + vv[i].first * (i - j) + (vv[i].second));\n\t\t\tdp2[1][j] = min(dp2[1][j], dp[0][j] + ((n - 1) / 2) * vv[i].first);\n\t\t}\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tdp[0][j] = dp2[0][j], dp[1][j] = dp2[1][j];\n\t\t}\n\t}\n\tif (n % 2 == 0) {\n\t\tout(dp[0][n / 2]);\n\t}\n\telse {\n\t\tout(dp[1][n / 2]);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(ll (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 40010\nll n, a, b, c;\n\nll inv[N], fact[N], ifact[N], be[N];\n \nll comb(ll a, ll b){\n\treturn fact[a+b]*ifact[a]%mod*ifact[b]%mod;\n}\n \nll comb_nk(ll n, ll k){\n\tif(n<0) return 1;\n\treturn comb(n-k, k);\n}\n \nll pow_mod(ll a, ll r, ll m){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n \nvoid init_fact(ll n = N){\n    inv[1] = 1;\n    for(int i = 2; i < n; i++) inv[i] = inv[mod%i] * (mod - mod/i) % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\t\tifact[i]=(ifact[i-1]*inv[i])%mod;\n\t}\n}\n\nint main(){\n\tinit_fact();\n\tcin>>n>>a>>b>>c;\n\tif(b%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tb /= 2;\n\tll res = 0;\n\trep(y, a+1){\n\t\tll z = a-y;\n\t\tfor(ll x = 0; x <= (c-y)/3; x++){\n\t\t\tll w = c-y-3*x;\n\t\t\tif(b==0 && w>0) continue;\n\t\t\t(res+=fact[x+y+z+b]*ifact[x]%mod*ifact[y]%mod*ifact[z]%mod*ifact[b]%mod*comb_nk(w+b-1, w))%=mod;\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define N 10003\n#define IL inline\n#define REP(a,b,c) for(a=b;a<=c;a++)\n#define PER(a,b,c) for(a=b;a>=c;a--)\nusing namespace std;\ntypedef long long lol;\nconst lol mod=1e9+7;\nint n,a,b,c;lol fac[N],inv[N];\nIL lol C(int n,int m){return fac[n]*inv[m]%mod*inv[n-m]%mod;}\nIL lol qpow(lol a,int b){lol res=1;while(b){if(b&1)res=res*a%mod;a=a*a%mod,b>>=1;}return res;}\nIL lol f(int n,int m){\n\tif(!n)return m==0;\n\treturn C(n+m-1,m)*inv[n]%mod;\n}\nint main(){\n  scanf(\"%d%d%d%d\",&n,&a,&b,&c);fac[0]=1;int x1,x2,x3,x4,S,up=n<<1,ans=0;\n\tREP(x1,1,up)fac[x1]=fac[x1-1]*x1%mod;inv[up]=qpow(fac[up],mod-2);\n  PER(x1,up,1)inv[x1-1]=inv[x1]*x1%mod;\n\tfor(x2=0;x2<=a&&x2<=c;x2++)\n\t\tfor(x1=a-x2,S=c-x2,x3=0;S>=0;x3++,S-=3)\n\tans=(ans+fac[x1+x2+x3+x4]*inv[x1]%mod*inv[x2]%mod*inv[x3]%mod*f(x4,S))%mod;\n\tprintf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=10005;\nint fac[N],ifac[N];\nvoid init(int n=1e4){\n\tfac[0]=ifac[0]=1;fp(i,1,n)fac[i]=mul(fac[i-1],i);\n\tifac[n]=ksm(fac[n],P-2);fd(i,n-1,1)ifac[i]=mul(ifac[i+1],i+1);\n}\ninline int C(R int n,R int m){return m<0||m>n?0:1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\ninline int ch(R int n,R int m){return n==0&&m==0?1:C(n+m-1,m-1);}\nint n,a,b,c,res;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d%d%d\",&n,&a,&b,&c),res=0;\n\tinit();\n\tif(b&1)return puts(\"0\"),0;\n\tfp(i,0,a)fp(j,0,(c-i)/3){\n\t\tR int n1=i,n2=a-i,n3=j,n4=b>>1,k=c-i-j*3;\n\t\tif (n1<0||n2<0||n3<0||n4<0||k<0)continue;\n\t\tR int now=mul(fac[n1+n2+n3+n4],ch(k,n4));\n\t\tnow=1ll*now*ifac[n1]%P*ifac[n2]%P*ifac[n3]%P*ifac[n4]%P;\n\t\tupd(res,now);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = (ll)(1e9+7);\n\nll memo[5050][5050];\nbool done[5050][5050];\n\nll comb(int n, int k){\n\tif(n < k){\n\t\treturn 0ll;\n\t}\n\tif(done[n][k]){\n\t\treturn memo[n][k];\n\t}\n\tdone[n][k] = true;\n\tif(k==0 || k==n){\n\t\treturn memo[n][k] = 1ll;\n\t}\n\tmemo[n][k] = (comb(n-1,k-1)+comb(n-1,k))%MOD;\n\treturn memo[n][k];\n}\n\nint main(void){\n\tint N,A,B,C,b,x,y,z,m;\n\tll ans=0ll,tmp;\n\tcin >> N >> A >> B >> C;\n\tif(B&1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tb = B>>1;\n\tfor(x=0; x*3<=C; ++x){\n\t\tm = min(A,C-x*3);\n\t\tfor(y=0; y<=m; ++y){\n\t\t\tz = C - x*3 - y;\n\t\t\ttmp = comb(A+b+x,x);\n\t\t\ttmp *= comb(A+b,b); tmp %= MOD;\n\t\t\ttmp *= comb(A,y); tmp %= MOD;\n\t\t\tif(b){\n\t\t\t\ttmp *= comb(z+b-1,z); tmp %= MOD;\n\t\t\t}else if(z){\n\t\t\t\ttmp = 0ll;\n\t\t\t}\n\t\t\tans += tmp; ans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define r(b) for(int b=1;b<=1235231;b++)\nusing namespace std;\nint a[123538647];\nint main()\n{\n\tr(b) r(c) r(d) r(e) r(f) r(g) r(h);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint A, B, C;\nlong long Mod = 1000000007, F[5010], InvF[5010], Res;\nlong long Pow(long long a, int b){\n    long long r = 1;\n    while(b){\n        if(b&1)r=r*a%Mod;\n        a=a*a%Mod;b>>=1;\n    }\n    return r;\n}\nlong long H(int a, int b){\n    if(!a&&!b)return 1;\n    return F[a+b-1] * InvF[b] % Mod * InvF[a-1] % Mod;\n}\nint main(){\n    int n;\n    scanf(\"%d%d%d%d\",&n,&A,&B,&C);\n    int i, j;\n    F[0]=InvF[0]=1;\n    for(i=1;i<=5000;i++){\n        F[i]=F[i-1]*i%Mod;\n        InvF[i]=Pow(F[i],Mod-2);\n    }\n    if(B%2){\n        printf(\"0\\n\");\n        return 0;\n    }\n    for(i=0;i<=A;i++){\n        for(j=0;A-i+3*j<=C;j++){\n            int s = C - (A-i+3*j);\n            Res = (Res +F[A+j+B/2] * InvF[i] % Mod * InvF[j] % Mod * InvF[A-i] % Mod * InvF[B/2] % Mod * H(B/2,s))%Mod;\n        }\n    }\n    printf(\"%lld\\n\",Res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long N, A, B, C, dp[5009][5009], fact[5009], factinv[5009], mod = 1000000007;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 30; i++) {\n\t\tif ((b / (1 << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\nlong long Div(long long a, long long b, long long m) {\n\treturn (a*modpow(b, m - 2, m)) % m;\n}\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= 5000; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tfor (int i = 0; i <= 5000; i++) factinv[i] = Div(1, fact[i], mod);\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = 0; j <= 5000; j++) dp[i][j] += dp[i - 1][j];\n\t\tfor (int j = 1; j <= 5000; j++) { dp[i][j] += dp[i][j - 1]; dp[i][j] %= mod; }\n\t}\n}\n\nint main() {\n\tinit();\n\tcin >> N >> A >> B >> C;\n\tif (B % 2 == 1) { cout << \"0\" << endl; return 0; }\n\tlong long sum = 0;\n\tfor (int i = 0; i <= A; i++) {\n\t\tfor (int j = 0; j <= C; j++) {\n\t\t\tlong long a = i, b = (A - i), c = j, d = B / 2, n = (C - b - 3 * c);\n\t\t\tif (a < 0 || b < 0 || c < 0 || d < 0 || n < 0) continue;\n\t\t\tlong long X = fact[a + b + c + d];\n\t\t\tX *= factinv[a]; X %= mod;\n\t\t\tX *= factinv[b]; X %= mod;\n\t\t\tX *= factinv[c]; X %= mod;\n\t\t\tX *= factinv[d]; X %= mod;\n\t\t\tX *= dp[d][n]; X %= mod;\n\t\t\tsum += X; sum %= mod;\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int N=10010;\nconst LL MOD=1e9+7;\n\nLL inv[N],fac[N],ifac[N];\nvoid predo() {\n    inv[1]=1;\n    REP1(i,2,N-1) inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    fac[0]=1;\n    REP1(i,1,N-1) fac[i]=fac[i-1]*i%MOD;\n    ifac[0]=1;\n    REP1(i,1,N-1) ifac[i]=ifac[i-1]*inv[i]%MOD;\n}\n\nLL C( int n, int m ) {\n    return fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;\n}\n\nLL H( int n, int m ) {\n    if ( n==0 && m==0 ) return 1;\n    return C(n-1+m,m);\n}\n\nint n,a,b,c;\n\nint solve() {\n    if ( b%2!=0 ) return 0;\n    b/=2;\n    LL ans=0;\n    REP1(i,0,c) {\n        REP1(j,0,min(a,c-i)) {\n            int k=c-i-j;\n            if ( k%3!=0 ) continue;\n            k/=3;\n            LL now=H(b,i);\n            now=now*H(b+1,k)%MOD;\n            now=now*H(b+1+k,j)%MOD;\n            now=now*H(b+1+k+j,a-j)%MOD;\n            dump(i,j,k,now);\n            ans+=now;\n        }\n    }\n    ans%=MOD;\n    return ans;\n}\n\nbool vis[N];\nint slow_ans;\nvoid dfs( int x, int t[3] ) {\n    if ( t[0]>a || t[1]>b || t[2]>c ) return;\n    // dump(x,t[0],t[1],t[2],x+2,vis[3],n);\n    if ( x==n ) {\n        if ( t[0]==a && t[1]==b && t[2]==c ) slow_ans++;\n        return;\n    }\n    if ( vis[x] ) {\n        dfs(x+1,t);\n        return;\n    }\n    REP1(i,1,3) if ( x+i<n && !vis[x+i] ) {\n        vis[x+i]=1;\n        t[i-1]++;\n        dfs(x+1,t);\n        t[i-1]--;\n        vis[x+i]=0;\n    }\n}\n\nint main() {\n    predo();\n    R(n,a,b,c);\n    n=2*(a+b+c);\n    // int t[3]={};\n    // dfs(0,t);\n    // dump(slow_ans);\n    int ans=solve();\n    W(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nll readLL(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<>\nvoid add(int& a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<>\nvoid sub(int& a,int b){\n\ta-=b;\n\tif(a<0)a+=mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nint main(){\n\tvector<ll> fact({1});\n\tFOR(i,1,114514)\n\t\tfact.PB(fact.back()*i%mod);\n\tauto comb=[&](int a,int b){\n\t\tif(b==0)\n\t\t\treturn 1LL;\n\t\telse if(b<0||a-b<0)\n\t\t\treturn 0LL;\n\t\telse\n\t\t\treturn fact[a]*modInv(fact[b])%mod*modInv(fact[a-b])%mod;\n\t};\n\tint ans=0;\n\tint n=read(),a=read(),b=read(),c=read();\n\tif(b%2!=0){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tREP(p,min(a,c)+1){\n\t\tfor(int k=0;k*3<=c-p;k++){\n\t\t\tint w=comb(b/2-1+(c-p-3*k),(c-p-3*k));\n\t\t\tmult(w,fact[p+k+b/2+a-p]);\n\t\t\tmult(w,modInv(fact[p]));\n\t\t\tmult(w,modInv(fact[k]));\n\t\t\tmult(w,modInv(fact[b/2]));\n\t\t\tmult(w,modInv(fact[a-p]));\n\t\t\tadd(ans,w);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nconst ll MOD=1000000007LL;\nvector<ll> f,fi;\nll mpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1){\n\t\t\tres*=x;\n\t\t\tres%=MOD;\n\t\t}\n\t\tx=x*x%MOD;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n){\n\tf.resize(n+1);\n\tfi.resize(n+1);\n\tf[0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tf[i]=f[i-1]*i;\n\t\tf[i]%=MOD;\n\t}\n\tfi[n]=mpow(f[n],MOD-2);\n\tfor(ll i=n-1;i>=0;i--){\n\t\tfi[i]=fi[i+1]*(i+1LL);\n\t\tfi[i]%=MOD;\n\t}\n}\nll ncr(ll n,ll r){\n\tif(n<r){\n\t\treturn 0;\n\t}\n\tif(r==0){\n\t\treturn 1;\n\t}\n\treturn f[n]*fi[r]%MOD*fi[n-r]%MOD;\n}\nint main(){\n\tll n,A,B,C;cin>>n>>A>>B>>C;\n\tif(B%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tinit(3*n+10);\n\tll ans=0;\n\tfor(ll b=0;b<=n/2;b++){\n\t\tfor(ll d=0;d<=n/3;d++){\n\t\t\tll c=B/2;\n\t\t\tll a=A-b;\n\t\t\tll x=C-b-3*d;\n\t\t\tif(x<0||a<0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t//\tcout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<\" \"<<x<<endl;\n\t\t\tll sum=a+b+c+d;\n\t\t\tll s=ncr(sum,a)*ncr(sum-a,b)%MOD*ncr(sum-a-b,c)%MOD;\n\t\t\tif(c>0){\n\t\t\t\ts*=ncr(x+c-1,x);\n\t\t\t\ts%=MOD;\n\t\t\t}else if(x>0){\n\t\t\t\ts=0;\n\t\t\t}\n\t\t\tans+=s;\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\tcout<<ans<<endl;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint N, A, B, C;\nint main() {\n\tcin >> N >> A >> B >> C;\n\tif (B % 2 == 0) {\n\t\tMInt sum;\n\t\tREP(x, 0, N + 1) {\n\t\t\tREP(y, 0, 2 * N + 1) {\n\t\t\t\tif (B == 0 && y != 0) continue;\n\t\t\t\tif ((C - x - y) % 3 != 0) continue;\n\t\t\t\tint p = A - x;\n\t\t\t\tint q = x;\n\t\t\t\tint r = (C - x - y) / 3;\n\t\t\t\tint s = B / 2;\n\t\t\t\tif (p < 0) continue;\n\t\t\t\tif (q < 0) continue;\n\t\t\t\tif (r < 0) continue;\n\t\t\t\tsum += MInt::fact(p + q + r + s) * MInt::homcombi(s, y) / (\n\t\t\t\t\t\tMInt::fact(p) *\n\t\t\t\t\t\tMInt::fact(q) *\n\t\t\t\t\t\tMInt::fact(r) *\n\t\t\t\t\t\tMInt::fact(s)\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t} else {\n\t\tcout << 0 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define N 10003\n#define IL inline\n#define REP(a,b,c) for(a=b;a<=c;a++)\n#define PER(a,b,c) for(a=b;a>=c;a--)\nusing namespace std;\ntypedef long long lol;\nconst lol mod=1e9+7;\nint n,a,b,c;lol fac[N],inv[N];\nIL lol C(int n,int m){return fac[n]*inv[m]%mod*inv[n-m]%mod;}\nIL lol qpow(lol a,int b){lol res=1;while(b){if(b&1)res=res*a%mod;a=a*a%mod,b>>=1;}return res;}\nIL lol f(int n,int m){\n\tif(!n)return m==0;\n\treturn C(n+m-1,m)*inv[n]%mod;\n}\nint main(){\n  scanf(\"%d%d%d%d\",&n,&a,&b,&c);fac[0]=1;int x1,x2,x3,x4,S,up=n<<1,ans=0;\n\tif(b&1){printf(\"0\");return 0;}\n\tREP(x1,1,up)fac[x1]=fac[x1-1]*x1%mod;inv[up]=qpow(fac[up],mod-2);\n  PER(x1,up,1)inv[x1-1]=inv[x1]*x1%mod;\n\tx4=b>>1;\n\tfor(x2=0;x2<=a&&x2<=c;x2++)\n\t\tfor(x1=a-x2,S=c-x2,x3=0;S>=0;x3++,S-=3)\n\t\t\tans=(ans+fac[x1+x2+x3+x4]*inv[x1]%mod*inv[x2]%mod*inv[x3]%mod*f(x4,S))%mod;\n\tprintf(\"%d\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#define mk make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define REP(i, x, y) for(int i = (int)x; i <= (int)y; i ++)\n#define FOR(i, x, y) for(int i = (int)x; i <  (int)y; i ++)\n#define PER(i, x, y) for(int i = (int)x; i >= (int)y; i --)\n#define trace(x) cerr << #x << \" \" << x << endl;\n#define dprintf(...) fprintf(stderr, __VA__ARGS__)\n#define dln()        fprintf(stderr, \"\\n\")\nusing namespace std;\ntypedef long long LL;\ntypedef long double db;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VPI;\nconst\tint N = 100005;\nconst\tint P = 1e9 + 7;\nconst\tint inf = 1e9;\nconst\tLL Inf = 1e15;\n\ninline int IN(){\n\tchar ch = getchar(); int x = 0, f = 0;\n\twhile(ch < '0' || ch > '9') ch = getchar(), f = (ch == '-');\n\twhile(ch >= '0' && ch <= '9'){\n\t\tx = (x << 1) + (x << 3) + ch - 48;\n\t\tch = getchar();\n\t}\n\treturn f ? (-x) : x;\n}\n\ninline int Pow(int x, int y, int p){\n\tint an = 1;\n\tfor(; y; y >>= 1, x = (LL)x * x % p) if(y & 1) an = (LL)an * x % p;\n\treturn an;\n}\n\ntemplate<typename T> inline void chkmin(T &a, const T &b) {if(a > b) a = b;}\ntemplate<typename T> inline void chkmax(T &a, const T &b) {if(a < b) a = b;}\n\nint n, A, B, C;\nint fac[10005], ifac[10005];\n\nint Comb(int x, int y){\n\tif(y < 0 || x < y) return 0;\n\treturn (LL)fac[x] * ifac[y] % P * ifac[x - y] % P;\n}\n\nint AA = 0;\nint ask(int w){\n\t//\\sum{a[i]} = B / 2\n\t//\\sum{i * a[i]} = w\n\t//sum of \\prod{a[i]!}\n\tif(B == 0) return w == 0;\n\treturn (LL)AA * Comb(B / 2 + w - 1, B / 2 - 1) % P;\t\n}\n\nint main(){\n\tcin >> n >> A >> B >> C;\n\tif(B & 1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tifac[0] = 1;\n\tREP(i, 1, 10000) ifac[i] = (LL)ifac[i - 1] * Pow(i, P - 2, P) % P;\n\tREP(i, 0, 10000) fac[i] = Pow(ifac[i], P - 2, P);\n\tAA = ifac[B / 2];\n\tint ans = 0;\n\tREP(a, 0, A) for(int b = 0; 3 * b <= C; b ++){\n\t\tint ww = C - A + a - 3 * b;\n\t\tif(ww < 0) continue;\n\t\tint cf = (LL)fac[A + b + B / 2] * ifac[a] % P * ifac[A - a] % P * ifac[b] % P;\n\t\tcf = (LL)cf * ask(ww) % P;\n\t\tans = (ans + cf) % P;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long LL;\nconst int N=10005,md=1e9+7;\nint n,a,b,c,fac[N],iv[N],_[N],ans;\ninline int pow(int a,int b){\n\tint ret=1;\n\tfor(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;\n\treturn ret;\n}\ninline int C(int n,int m){return n>=m?(LL)fac[n]*iv[m]%md*iv[n-m]%md:0;}\nint main(){\n\tscanf(\"%d%d%d%d\",&n,&a,&b,&c);\n\tif(b&1){puts(\"0\");return 0;}b>>=1;\n\tfor(int i=*fac=1;i<=n*2;++i)fac[i]=(LL)fac[i-1]*i%md;\n\tiv[n*2]=pow(fac[n*2],md-2);\n\tfor(int i=n*2-1;~i;--i)iv[i]=(i+1LL)*iv[i+1]%md;\n\tfor(int i=*_=1;i<=c;++i)_[i]=C(i+b-1,i);\n\tfor(int i=0;3*i<=c;++i){\n\t\tfor(int x=c-3*i;~x;--x)if(c-3*i-x<=a){\n\t\t\tint _31=c-3*i-x,_1=a-_31;\n\t\t\tans=(ans+(LL)fac[b+i+a]*iv[b]%md*iv[i]%md*iv[_31]%md*iv[_1]%md*_[x])%md;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nconst ll MOD=1000000007LL;\nvector<ll> f,fi;\nll mpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1){\n\t\t\tres*=x;\n\t\t\tres%=MOD;\n\t\t}\n\t\tx=x*x%MOD;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n){\n\tf.resize(n+1);\n\tfi.resize(n+1);\n\tf[0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tf[i]=f[i-1]*i;\n\t\tf[i]%=MOD;\n\t}\n\tfi[n]=mpow(f[n],MOD-2);\n\tfor(ll i=n-1;i>=0;i--){\n\t\tfi[i]=fi[i+1]*(i+1LL);\n\t\tfi[i]%=MOD;\n\t}\n}\nll ncr(ll n,ll r){\n\tif(n<r){\n\t\treturn 0;\n\t}\n\tif(r==0){\n\t\treturn 1;\n\t}\n\treturn f[n]*fi[r]%MOD*fi[n-r]%MOD;\n}\nint main(){\n\tll n,A,B,C;cin>>n>>A>>B>>C;\n\tif(B%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tinit(3*n+10);\n\tll ans=0;\n\tfor(ll b=0;b<=n/2;b++){\n\t\tfor(ll d=0;d<=n/3;d++){\n\t\t\tll c=B/2;\n\t\t\tll a=A-b;\n\t\t\tll x=C-b-3*d;\n\t\t\tif(x<0||a<0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<\" \"<<x<<endl;\n\t\t\tll sum=a+b+c+d;\n\t\t\tll s=ncr(sum,a)*ncr(sum-a,b)%MOD*ncr(sum-a-b,c)%MOD;\n\t\t\tif(c>0){\n\t\t\t\ts*=ncr(x+c-1,x);\n\t\t\t\ts%=MOD;\n\t\t\t}\n\t\t\tans+=s;\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\tcout<<ans<<endl;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n#include <vector>\n\n\n\n#include <assert.h>\n#include <type_traits>\n\n\n\n\n\ntemplate <typename T, typename = std::true_type>\nstruct IdentityHelper;\n\ntemplate <typename T>\nstruct IdentityHelper<T, typename std::is_arithmetic<T>::type> {\n\tstatic T identity() {\n\t\treturn 1;\n\t}\n};\n\ntemplate <typename T>\nT identity() {\n\treturn IdentityHelper<T>::identity();\n}\n\n\n\n/**\n* ax + by = result\n*/\ntemplate <typename T>\nT extendedGcd(T a, T b, T& x, T& y) {\n\tif (a == 0) {\n\t\tx = 0;\n\t\ty = 1;\n\t\treturn b;\n\t}\n\tT d = extendedGcd(b % a, a, y, x);\n\tx -= (b / a) * y;\n\treturn d;\n}\n\ntemplate <typename T>\nclass Zn {\npublic:\n\tZn(): value(0) {\n\t}\n\n\t/**\n\t* Instead of ctor, to allow not to normalize in ctor\n\t*/\n\tstatic Zn valueOf(int value) {\n\t\tint x = value % mod();\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\tstatic Zn valueOf(long long value) {\n\t\tint x = static_cast<int>(value % mod());\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\tstatic Zn rawValueOf(int value) {\n\t\tSPCPPL_ASSERT(value >= 0 && value < mod());\n\t\treturn Zn(value);\n\t}\n\n\tZn& operator=(int rhs) {\n\t\treturn *this = Zn::valueOf(rhs);\n\t}\n\n\tZn& operator=(long long rhs) {\n\t\treturn *this = Zn::valueOf(rhs);\n\t}\n\n\tZn& operator+=(const Zn& rhs) {\n\t\tvalue += rhs.value;\n\t\tif (value >= mod()) {\n\t\t\tvalue -= mod();\n\t\t}\n\t\treturn *this;\n\t}\n\n\tZn& operator+=(int rhs) {\n\t\treturn *this += Zn::valueOf(rhs);\n\t}\n\n\tZn& operator+=(long long rhs) {\n\t\treturn *this += Zn::valueOf(rhs);\n\t}\n\n\tZn& operator-=(const Zn& rhs) {\n\t\tvalue -= rhs.value;\n\t\tif (value < 0) {\n\t\t\tvalue += mod();\n\t\t}\n\t\treturn *this;\n\t}\n\n\tZn& operator-=(int rhs) {\n\t\treturn *this -= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator-=(long long rhs) {\n\t\treturn *this -= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator*=(const Zn& rhs) {\n\t\tlong long result = static_cast<long long>(value) * static_cast<long long>(rhs.value);\n\t\tvalue = static_cast<int>(result % mod());\n\t\treturn *this;\n\t}\n\n\tZn& operator*=(int rhs) {\n\t\treturn *this *= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator*=(long long rhs) {\n\t\treturn *this *= Zn::valueOf(rhs);\n\t}\n\n\tZn operator-() const {\n\t\tif (value == 0) {\n\t\t\treturn *this;\n\t\t}\n\t\telse {\n\t\t\treturn Zn(mod() - value);\n\t\t}\n\t}\n\n\tZn& operator/=(const Zn& rhs) {\n\t\treturn *this *= rhs.inversed();\n\t}\n\n\tZn& operator/=(int rhs) {\n\t\treturn *this /= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator/=(long long rhs) {\n\t\treturn *this /= Zn::valueOf(rhs);\n\t}\n\n\tbool operator==(const Zn& rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tZn inversed() const {\n\t\tSPCPPL_ASSERT(value != 0);\n\n\t\tint x, y;\n\t\tint gcd = extendedGcd(value, mod(), x, y);\n\t\t(void) gcd;\n\t\tSPCPPL_ASSERT(gcd == 1);\n\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\ttemplate <typename U>\n\tfriend std::ostream& operator<<(std::ostream&, const Zn<U>& zn);\n\n\ttemplate <typename U>\n\tfriend std::istream& operator>>(std::istream&, Zn<U>& zn);\n\n\tint intValue() const {\n\t\treturn value;\n\t}\n\nprivate:\n\t/**\n\t* No normalization performed\n\t*/\n\texplicit Zn(int value): value(value) {\n\t}\n\n\tint value;\n\n\tconstexpr static int mod() {\n\t\treturn T::value;\n\t}\n\n\ttemplate <int N = T::value>\n\tstatic constexpr bool positive_or_runtime(int) {\n\t\treturn N > 0;\n\t}\n\tstatic constexpr bool positive_or_runtime(...) {\n\t\treturn true;\n\t}\n\tstatic_assert(\n\t\t\tstd::is_same<typename std::decay<decltype(T::value)>::type, int>::value,\n\t\t\t\"T::value must be int\"\n\t);\n\tstatic_assert(positive_or_runtime(0), \"Mod has to be positive integer\");\n};\n\ntemplate <typename T>\nbool operator==(const Zn<T>& lhs, int rhs) {\n\treturn lhs == Zn<T>::valueOf(rhs);\n}\n\ntemplate <typename T>\nbool operator==(int lhs, const Zn<T>& rhs) {\n\treturn rhs == lhs;\n}\ntemplate <typename T>\nbool operator==(const Zn<T>& lhs, long long rhs) {\n\treturn lhs == Zn<T>::valueOf(rhs);\n}\n\ntemplate <typename T>\nbool operator==(long long lhs, Zn<T>& rhs) {\n\treturn rhs == lhs;\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, const Zn<T>& rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, int rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(int lhs, const Zn<T>& rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, long long rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(long long rhs, const Zn<T>& lhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(int lhs, const Zn<T>& rhs) {\n\treturn rhs + lhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(long long lhs, const Zn<T>& rhs) {\n\treturn rhs + lhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(int lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) - rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(long lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) - rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(int lhs, const Zn<T>& rhs) {\n\treturn rhs * lhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(long long lhs, const Zn<T>& rhs) {\n\treturn rhs * lhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(int lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) / rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(long long lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) / rhs;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Zn<T>& zn) {\n\treturn stream << zn.value;\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Zn<T>& zn) {\n\tlong long value;\n\tstream >> value;\n\tzn.value = static_cast<int>(value % T::value);\n\treturn stream;\n}\n\ntemplate <typename T>\nstruct IdentityHelper<Zn<T>> {\n\tstatic Zn<T> identity() {\n\t\treturn Zn<T>::valueOf(1);\n\t}\n};\n\ntemplate <int m>\nusing ZnConst = Zn<std::integral_constant<int, m>>;\n\n\nusing namespace std;\n\nclass TaskJ {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n, a, c, t;\n\t\tin >> n >> a >> c >> t;\n\n\t\tif (c % 2) {\n\t\t\tout << 0;\n\t\t\treturn;\n\t\t}\n\t\tc /= 2;\n\n\n\t\tusing Z = ZnConst<1000000007>;\n\n\t\tvector<Z> fact(10000), invfact(10000);\n\n\t\tfact[0] = invfact[0] = Z::valueOf(1);\n\t\tfor (int i: range(1, 10000)) {\n\t\t\tfact[i] = fact[i - 1] * i;\n\t\t\tinvfact[i] = 1 / fact[i];\n\t\t}\n\n\n\t\tauto stars_nd_bars = [&](int stars, int groups) {\n\t\t\tif (groups == 0) {\n\t\t\t\tif (stars == 0) {\n\t\t\t\t\treturn Z::rawValueOf(1);\n\t\t\t\t} else {\n\t\t\t\t\treturn Z();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fact[stars + groups - 1] * invfact[groups - 1] * invfact[stars];\n\t\t};\n\n\t\tZ ans;\n\t\tfor (int b = 0; b <= t && b <= a; ++b) {\n\t\t\tfor (int d = 0; d * 3 <= t - b; ++d) {\n\t\t\t\tint e = t - b - d * 3;\n\t\t\t\tint ca = a - b;\n\t\t\t\tans += fact[ca + b + c + d] * invfact[ca] * invfact[b] * invfact[c] * invfact[d] *\n\t\t\t\t\t\tstars_nd_bars(e, c);\n\t\t\t\t//cerr << ans << endl;\n\t\t\t}\n\t\t}\n\t\tout << ans << \"\\n\";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskJ solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define DN(en, ka) (F[en] * pot(F[ka] * F[en - ka] % Q, -1) % Q)\nusing namespace std;\ntypedef long long int ll;\nconst ll N = 8192, Q = 1000000007;\nll n, a, b, c, res, F[N] = {1};\nint pot(int a, int b){\n  if(b < 0)\n    return pot(pot(a, -b), Q - 2);\n  if(b == 0)\n    return 1;\n  if(b % 2 == 1)\n    return ((ll)pot(a, b - 1) * a) % Q;\n  ll t = pot(a, b / 2);\n  return (t * t) % Q;\n}\nint solve(int x, int y){\n  ll t = c - a + x - 3 * y,\n    l = F[a + y + b / 2],\n    m = F[x] * F[y] % Q * F[a - x] % Q * F[b / 2] % Q,\n    k = b ? DN(b / 2 + t - 1, t) : 1;\n  return (c < y * 3 + a - x) ? 0 : (l * pot(m, -1) % Q * k % Q);\n}  \nint main(){\n  for(int i = 1;i < N;i++)\n    F[i] = (F[i - 1] * i) % Q;\n  cin >> n >> a >> b >> c;\n  if(b % 2 == 1){\n    cout << \"0\\n\";\n    return 0;\n  }\n  for(int i = 0;i <= a;i++)\n    for(int j = 0;j <= c / 3;j++)\n      res += solve(i, j);\n  cout << res % Q << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst ll Mod = 1000000007LL;\nconst int Maxn = 1e5 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nll mul(ll a, ll b){\n\treturn (a * b) % Mod;\n}\nll bin_pow(ll b, ll p){\n\tll res = 1;\n\tfor(ll j = 1, pw = b; j <= p; j <<= 1, pw = mul(pw, pw))\n\t\tif(p & j)\n\t\t\tres = mul(res, pw);\n\treturn res;\n}\nll inv(ll x){\n\treturn bin_pow(x, Mod - 2);\n}\nll f[Maxn], iv[Maxn];\nll nCr(ll n, ll r){\n\tif((n < r) || (r < 0)) return 0;\n\treturn mul(f[n], mul(iv[r], iv[n - r]));\n}\n\n\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tf[0] = 1;\n\tfor(int i = 1; i < Maxn; i++) f[i] = mul(f[i - 1], i);\n\tfor(int i = 0; i < Maxn; i++) iv[i] = inv(f[i]);\n\t\n\tll n, a, b, c;\n\tcin >> n >> a >> b >> c;\n\tif(b & 1) return cout << 0, 0;\n\tb /= 2;\n\t\n\tll ans = 0;\n\tfor(int i = 0; i <= a; i++){\n\t\tfor(int j = 0; 3*j + (a - i) <= c; j++){\n\t\t\tif(b > 0){\n\t\t\t\tans += mul( mul( mul(nCr(a + j + b, i), nCr(a + j + b - i, a - i)), nCr(j + b, j) ), nCr(c - 3*j - (a - i) + b - 1, b - 1));\n\t\t\t} else {\n\t\t\t\tif(c == 3 * j + (a - i)){\n\t\t\t\t\tans += mul(nCr(a + j, i), nCr(a + j - i, a - i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans % Mod << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 100005\n#define M 200005\n#define seed 23333\n#define Mo 1000000007\n\nusing namespace std;\nint i,j,m,n,p,k,a,b,c,ans,fac[N],inv[N];\nint C(int x,int y)\n{\n\t\tif (x<y) return 0;\n\t\treturn 1ll*fac[x]*inv[y]%Mo*inv[x-y]%Mo;\n}\nint power(int x,int y)\n{\n\t\tint s=1;\n\t\tfor (;y;y>>=1)\n\t\t{\n\t\t\t\tif (y&1) s=1ll*s*x%Mo;\n\t\t\t\tx=1ll*x*x%Mo;\n\t\t}\n\t\treturn s;\n}\nvoid jia(int &x,int y)\n{\n\t\tx+=y; if (x>=Mo) x-=Mo;\n}\nint main()\n{\n\tscanf(\"%d%d%d%d\",&n,&a,&b,&c);\n\tfac[0]=inv[0]=1;\n\tfor (i=1;i<N;++i) fac[i]=1ll*fac[i-1]*i%Mo,inv[i]=power(fac[i],Mo-2);\n\tif (b&1) for (;;);\n\telse \n\t{\n\t\t  b/=2;\n\t\t  for (i=0;i<=a;++i)\n\t\t  \tfor (j=0;i+j<=c;++j)\n\t\t  \t\tif ((c-i-j)%3==0)\n\t\t  \t\t{\n\t\t  \t\t\t\tjia(ans,1ll*C(a+b,a)*C(a,i)%Mo*C(b+j-1,j)%Mo*C(a+b+1+(c-i-j)/3-1,(c-i-j)/3)%Mo); \n\t\t  \t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\n\tcin >> N;\n\tint A, B, C;\n\tcin >> A >> B >> C;\n\tif (B & 1) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tB /= 2;\n\tvector<long long int>by(N + 1, 1);\n\tvector<long long int>rev(N + 1, 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t\trev[i] = power(by[i], MOD - 2, MOD);\n\t}\n\tlong long int ans = by[A + B] * rev[A];\n\tans %= MOD;\n\tans *= rev[B];\n\tans %= MOD;\n\t//cout << ans << endl;\n\tlong long int ansby = 0;\n\tfor (int i = 0; i <= C; i += 3) {\n\t\tfor (int j = 0; j <= A; j++) {\n\t\t\tint box = C - i - j;\n\t\t\tif (box < 0)continue;\n\t\t\tif (!B&&box)continue;\n\t\t\tlong long int add = 0;\n\t\t\tadd = by[A] * rev[j];\n\t\t\tadd %= MOD;\n\t\t\tadd *= rev[A - j];\n\t\t\tadd %= MOD;\n\t\t\tadd *= by[A + B + i / 3];\n\t\t\tadd %= MOD;\n\t\t\tadd *= rev[A + B];\n\t\t\tadd %= MOD;\n\t\t\tadd *= rev[i / 3];\n\t\t\tadd %= MOD;\n\t\t\tif (box) {\n\t\t\t\tadd *= by[B - 1 + box];\n\t\t\t\tadd %= MOD;\n\t\t\t\tadd *= rev[B - 1];\n\t\t\t\tadd %= MOD;\n\t\t\t\tadd *= rev[box];\n\t\t\t\tadd %= MOD;\n\t\t\t}\n\t\t\tansby += add;\n\t\t\tansby %= MOD;\n\t\t}\n\t}\n\tans *= ansby;\n\tans %= MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nll MOD = 1E9 + 7;\n\nll F[20000], I[20000];\n\nll power(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b % 2) {\n            res *= a;\n            res %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid init() {\n    F[0] = 1;\n    for (ll i = 1;i < 20000;i++) {\n        F[i] = F[i - 1] * i;\n        F[i] %= MOD;\n    }\n    I[19999] = power(F[19999], MOD - 2);\n    for (ll i = 19998;i >= 0;i--) {\n        I[i] = I[i + 1] * (i + 1);\n        I[i] %= MOD;\n    }\n    return;\n}\n\nll nchoosek(int a, int b) {\n    ll ans = F[a] * I[b];\n    ans %= MOD;\n    ans *= I[a - b];\n    ans %= MOD;\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N, A, B, C;\n    init();\n    cin >> N >> A >> B >> C;\n    if (B % 2) {\n        cout << 0 << endl;\n        return 0;\n    }\n    ll res = 0;\n    for (int x = 0;x <= A;x++) {\n        int y = A - x;\n        int rem_c = C - y;\n        for (int c = 0;c * 3 <= rem_c;c++) {\n            ll crt = 1;\n            int all = x + y + c + B/2;\n            crt *= nchoosek(all, x);\n            crt *= nchoosek(all - x, y);\n            crt %= MOD;\n            crt *= nchoosek(all - x - y, c);\n            crt %= MOD;\n            if (B > 0) crt *= nchoosek(rem_c - c * 3 + B/2 - 1, B/2 - 1);\n            else if (rem_c - 3 * c != 0) crt = 0;\n            crt %= MOD;\n            res += crt;\n            res %= MOD;\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int MOD = (int) 1e9 + 7;\nvoid sadd(int &a, int b)\n{\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n}\nint add(int a, int b)\n{\n\tsadd(a, b);\n\treturn a;\n}\nint mul(int a, int b)\n{\n\treturn (a * 1LL * b) % MOD;\n}\nvoid smul(int &a, int b)\n{\n\ta = mul(a, b);\n}\n\nconst int N = 5005;\nint C[N][N];\n\nint getC(int a, int b)\n{\n\tif (a < 0 || b < 0 || b > a) return 0;\n\treturn C[a][b];\n}\n\nvoid init()\n{\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tC[i][j] = add(C[i - 1][j - 1], C[i - 1][j] );\n\t}\n}\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tinit();\n\n\tint n, a, b, c;\n\tscanf(\"%d%d%d%d\", &n, &a, &b, &c);\n\n\tif (b % 2 != 0)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\tint blocks = b / 2;\n\tfor (int c3b = 0; c3b <= c; c3b++)\n\t{\n\t\tint cur = (c3b == 0 ? 1 : getC(blocks + c3b - 1,c3b) );\n\t\tfor (int c1 = 0; c1 <= a; c1++)\n\t\t{\n\t\t\tint c31 = a - c1;\n\t\t\tint c333 = (c - c31 - c3b) / 3;\n\t\t\tif (c31 < 0 || c333 < 0) continue;\n\t\t\tif (c31 + c3b + 3 * c333 != c) continue;\n\t\t\tint loc = cur;\n\t\t\tsmul(loc, getC(blocks + c31, c31) );\n\t\t\tsmul(loc, getC(blocks + c31 + c333, c333) );\n\t\t\tsmul(loc, getC(blocks + c31 + c333 + c1, c1) );\n\t\t\tsadd(ans, loc);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 100005\n#define M 200005\n#define seed 23333\n#define Mo 1000000007\n\nusing namespace std;\nint i,j,m,n,p,k,a,b,c,ans,fac[N],inv[N];\nint C(int x,int y)\n{\n\t\tif (x<y) return 0;\n\t\treturn 1ll*fac[x]*inv[y]%Mo*inv[x-y]%Mo;\n}\nint power(int x,int y)\n{\n\t\tint s=1;\n\t\tfor (;y;y>>=1)\n\t\t{\n\t\t\t\tif (y&1) s=1ll*s*x%Mo;\n\t\t\t\tx=1ll*x*x%Mo;\n\t\t}\n\t\treturn s;\n}\nvoid jia(int &x,int y)\n{\n\t\tx+=y; if (x>=Mo) x-=Mo;\n}\nint main()\n{\n\tscanf(\"%d%d%d%d\",&n,&a,&b,&c);\n\tfac[0]=inv[0]=1;\n\tfor (i=1;i<N;++i) fac[i]=1ll*fac[i-1]*i%Mo,inv[i]=power(fac[i],Mo-2);\n\tif (b&1) puts(\"0\");\n\telse \n\t{\n\t\t  b/=2;\n\t\t  for (i=0;i<=a;++i)\n\t\t  \tfor (j=0;i+j<=c;++j)\n\t\t  \t\tif ((c-i-j)%3==0)\n\t\t  \t\t{\n\t\t  \t\t\t\tjia(ans,1ll*C(a+b,a)*C(a,i)%Mo*C(b+j-1,j)%Mo*C(a+b+1+(c-i-j)/3-1,(c-i-j)/3)%Mo); \n\t\t  \t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=10000+10,mod=1e9+7;\nint ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint fac[maxn],ifac[maxn];\ninline void init(int n){\n\tfac[0]=1;\n\tREP(i,1,n) fac[i]=(ll)i*fac[i-1]%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tDREP(i,n,1) ifac[i-1]=(ll)i*ifac[i]%mod;\n}\ninline int calc(int n,int m){\n\tif(n<0 || m<0 || m>n) return 1;\n\treturn (ll)fac[n]*ifac[n-m]%mod*ifac[m]%mod;\n}\nint main(){\n\tinit(maxn-10);\n\tint n=read(),A=read(),B=read(),C=read(),ans=0;\n\tREP(x1,0,A) REP(x3,0,C/3){\n\t\tint x2=A-x1,x4=B/2,S=C-x3*3-x2;\n\t\tif(S<0) continue;\n\t\tans=(ans+(ll)fac[x1+x2+x3+x4]*ifac[x1]%mod*ifac[x2]%mod*ifac[x3]%mod*ifac[x4]%mod*calc(x4+S-1,x4-1))%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\nint bsr(int x) { return 31 - __builtin_clz(x); }\n\ntemplate<class T>\nT pow(T x, ll n, T r = 1) {\n    while (n) {\n        if (n & 1) r *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return r;\n}\n\ntemplate<uint MD>\nstruct ModInt {\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll v) : v{normS(v%MD+MD)} {}\n    static uint normS(const uint &x) {return (x<MD)?x:x-MD;};\n    static ModInt make(const uint &x) {ModInt m; m.v = x; return m;}\n    ModInt operator+(const ModInt &r) const {return make(normS(v+r.v));}\n    ModInt operator-(const ModInt &r) const {return make(normS(v+MD-r.v));}\n    ModInt operator*(const ModInt &r) const {return make((ull)v*r.v%MD);}\n    ModInt& operator+=(const ModInt &r) {return *this=*this+r;}\n    ModInt& operator-=(const ModInt &r) {return *this=*this-r;}\n    ModInt& operator*=(const ModInt &r) {return *this=*this*r;}\n    static ModInt inv(const ModInt &x) {\n        return pow(ModInt(x), MD-2);\n    }\n};\nusing Mint = ModInt<TEN(9)+7>;\n\nusing T = tuple<int, int, int, int, int>;\nmap<T, Mint> dp;\nint n;\nMint calc(int p, int a, int b, int c, int f) {\n    if (p == 2*n) {\n        if (f == 0) return 1;\n        return 0;\n    }\n    T key = T(p, a, b, c, f);\n    if (dp.count(key)) {\n        return dp[key];\n    }\n    // non use\n    Mint ans = 0;\n    if ((f & 4) == 0) {\n        ans += calc(p+1, a, b, c, (f<<1)+1);\n    }\n    // back single\n    if (a && (f & 1)) {\n        ans += calc(p+1, a-1, b, c, (f^1)<<1);\n    }\n    if (b && (f & 2)) {\n        ans += calc(p+1, a, b-1, c, (f^2)<<1);\n    }\n    if (c && (f & 4)) {\n        ans += calc(p+1, a, b, c-1, (f^4)<<1);\n    }\n    return dp[key] = ans;\n}\n\n\nMint fact[100000], iFac[100000];\nMint C(int n, int k) {\n    return fact[n]*iFac[k]*iFac[n-k];\n}\nint main() {\n    fact[0] = 1;\n    for (int i = 1; i < 100000; i++) {\n        fact[i] = fact[i-1]*i;\n    }\n    for (int i = 0; i < 100000; i++) {\n        iFac[i] = Mint::inv(fact[i]);\n    }\n\n    ios::sync_with_stdio(0);\n    cout << setprecision(20);\n    cin >> n;\n    int a, b, c;\n    cin >> a >> b >> c;\n    Mint ans = 0;\n    for (int x = 0; x <= c; x++) {\n        for (int y = 0; y <= c; y++) {\n            int z = a-y;\n            if (z < 0) continue;\n            int nb = b;\n            int nc = c-3*x-y;\n            if (nc < 0) continue;\n            if (nb % 2) continue;\n            int w = nb/2;\n            Mint base = 1;\n            base *= C(x+y+z+w, x);\n            base *= C(y+z+w, y);\n            base *= C(z+w, z);\n            int cu = nc;\n            if (cu && w == 0) continue;\n            if (cu > 0) {\n                base *= C(cu+w-1, cu);\n            }\n            ans += base;\n        }\n    }\n    cout << ans.v << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 5005;\nconst int MOD = 1000000007;\n\nint cnk[maxn][maxn];\nint A, B, C;\nint n;\n\nll get(ll a, ll b)\n{\n    if (a == 0 && b > 0) return 0;\n    if (a == 0 && b == 0) return 1;\n    return cnk[a + b - 1][a - 1];\n}\n\nll calc(ll a, ll b, ll c, ll d)\n{\n//     cout << \"calc \" << a << ' ' << b << ' ' << c << ' ' << d << ' ' << endl;\n    if (d < 0) return 0;\n    if (a + b + c + d > n) return 0;\n    return (((ll)cnk[a + b][b] * cnk[a + b + c][c]) % MOD * cnk[a + b + c + d][d]) % MOD;\n}\n\nint main()\n{\n    scanf(\"%d%d%d%d\", &n, &A, &B, &C);\n    if (B % 2 == 1)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    cnk[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        cnk[i][0] = 1;\n        for (int j = 1; j <= i; j++) cnk[i][j] = (cnk[i - 1][j - 1] + cnk[i - 1][j]) % MOD;\n    }\n    ll answer = 0;\n    for (int x = 0; x <= C; x++)\n    {\n        for (int y = 0; 3 * y + x <= C; y++)\n        {\n            ll curans = calc(B / 2, y, C - 3 * y - x, A - (C - 3 * y - x));\n//             cout << x << ' ' << y << ' ' << curans << endl;\n            curans = ((ll)curans * get(B / 2, x)) % MOD;\n//             cout << curans << endl;\n            answer = (answer + curans) % MOD;\n        }\n    }\n    cout << answer << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define DN(en, ka) (F[en] * pot(F[ka] * F[en - ka] % Q, -1) % Q)\nusing namespace std;\ntypedef long long int ll;\nconst ll N = 1 << 16, Q = 1000000007;\nll n, a, b, c, res, F[N] = {1};\nint pot(int a, int b){\n  if(b < 0)\n    return pot(pot(a, -b), Q - 2);\n  if(b == 0)\n    return 1;\n  if(b % 2 == 1)\n    return ((ll)pot(a, b - 1) * a) % Q;\n  ll t = pot(a, b / 2);\n  return (t * t) % Q;\n}\nint solve(int x, int y){\n  ll t = c - a + x - 3 * y,\n    l = F[a + y + b / 2],\n    m = F[x] * F[y] % Q * F[a - x] % Q * F[b / 2] % Q,\n    k = b ? DN(b / 2 + t - 1, t) : 1;\n  return (c < y * 3 + a - x) ? 0 : (l * pot(m, -1) % Q * k % Q);\n}  \nint main(){\n  for(int i = 1;i < N;i++)\n    F[i] = (F[i - 1] * i) % Q;\n  cin >> n >> a >> b >> c;\n  if(b % 2 == 1){\n    cout << \"0\\n\";\n    return 0;\n  }\n  for(int i = 0;i <= a;i++)\n    for(int j = 0;j <= c / 3;j++)\n      res += solve(i, j);\n  cout << res % Q << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#include<iomanip>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\n#define N 100010\nll fac[N],inv[N],ivf[N];\nll C(ll n,ll k){\n    return fac[n]*ivf[k]%mod*ivf[n-k]%mod;\n}\nll H(ll n,ll k){\n    return C(n+k-1,k);\n}\nll beta(ll x,ll y,ll z,ll w){\n    ll res=fac[x+y+z+w];\n    mul(res,ivf[x]);\n    mul(res,ivf[y]);\n    mul(res,ivf[z]);\n    mul(res,ivf[w]);\n    return res;\n}\nll n,a,b,c;\nll alpha(ll d){\n    ll ans=0;\n    for(ll x=0;x<=a;x++){\n\tll y=b/2;\n\tll z=a-x;\n\tif((d-z)%3>0||d<z)continue;\n\tll w=(d-z)/3;\n\tmad(ans,beta(x,y,z,w));\n    }\n    return ans;\n}\nint main(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(ll i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-(mod/i*inv[mod%i]%mod))%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n    cin>>n>>a>>b>>c;\n    if(b%2==1)cout<<0<<endl;\n    else if(b==0){\n\tcout<<alpha(c)<<endl;\n    }\n    else{\n\tll ans=0;\n\tfor(ll i=0;i<=c;i++){\n\t    ll cur=alpha(c-i);\n\t    mul(cur,H(b/2,i));\n\t    mad(ans,cur);\n\t}\n\tcout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define P 1000000007\n\n#define NN 100010\n\nll F[NN], IF[NN];\nvoid gcd(int a,int b,int &x,int &y) {\n  if(b==0){x=1,y=0;return;}\n  gcd(b,a%b,y,x),y-=a/b*x;\n}\nint inv(int n) {\n  int x,y;gcd(n,P,x,y);\n  if(x<0)x+=P;return x;\n}\n\nll cc(int n, int m) {\n\t//printf (\"%d %d\\n\", n, m);\n\tif (m < 0) return 0;\n\tif (m > n) return 0;\n\treturn (ll) F[n] * IF[m] %P * IF[n-m]%P;\n}\n\nll ff(int m, int k) {\n\tif (k == 0) {\n\t\tif (m == 0) return 1;\n\t\treturn 0;\n\t}\n\treturn cc(m+k-1, k-1);\n}\n\nint main () {\n\tF[0]=1;for(int i=1;i<NN;i++)F[i]=(ll)F[i-1]*i%P;\n\tIF[NN-1]=inv(F[NN-1]);for(int i=NN-1;i;i--)IF[i-1]=(ll)IF[i]*i%P;\n\tint N, A, B, C;\n\tcin >> N >> A >> B >> C;\n\tif (B&1) {\n\t\tputs (\"0\");\n\t\treturn 0;\n\t}\n\tll S = 0;\n\tfor (int j = 0; j*3 <= C; j++) {\n\t\tC -= 3*j;\n\t\tfor (int i = 0; i <= C; i ++) {\n\t\t\tif (A-(C-i) < 0) continue;\n\t\t\tll T = ff(i, B/2);\n\t\t\t// C-i : 31\n\t\t\tT = (ll)T*ff(C-i, B/2+1)%P;\n\t\t\t// A-(C-i) : 1\n\t\t\tT = (ll)T*ff(A-(C-i), B/2 + (C-i) + 1)%P;\n\t\t\t\n\t\t\tT = (ll)T*ff(j, B/2 + A + 1)%P;\n\t\t\t(S += T) %= P;\n\t\t}\n\t\tC += 3*j;\n\t}\n\tcout << S << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\nusing namespace std;\n \n#define P 1000000007\nint N, A, B, C;\nint co[5010][5010];\nint dp[2501][5010][2];\nint ans;\n \nvoid up(int &x, int y) {\n\tx = (x + y) % P;\n}\n \nint main() {\n\tcin >> N >> A >> B >> C;\n\tco[0][0] = 1;\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tco[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tco[i][j] = (co[i - 1][j] + co[i - 1][j - 1]) % P;\n\t}\n\tif (B % 2 != 0) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= N; i++)\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (dp[i][j][1]) {\n\t\t\t\tup(dp[i][j][0], dp[i][j][1]);\n\t\t\t\tup(dp[i][j + 1][1], dp[i][j][1]);\n\t\t\t}\n\t\t\tif (dp[i][j][0]) {\n\t\t\t\tup(dp[i + 1][j][1], dp[i][j][0]);\n\t\t\t\t// up(dp[i + 1][j][0], dp[i][j][0]);\n\t\t\t}\n\t\t}\n\t// for (int i = 0; i <= N / 3; i++)\n\tfor (int j = 0; j <= C; j++)\n\t\tif (dp[B / 2][j][0])\n\t\t\tfor (int q = 0; j + 3 * q <= C; q++) {\n\t\t\t// if ((B - 2 * i) % 2 != 0)\n\t\t\t// \tcontinue;\n\t\t\tint aa = C - j - 3 * q, bb = q, cc = A - aa;\n\t\t\t// printf(\"?? %d %d %d %d %d\\n\", i, j, aa, bb, cc);\n\t\t\tif (aa < 0 || cc < 0)\n\t\t\t\tcontinue;\n\t\t\t// printf(\"?? %d %d %d %d %d %d\\n\", i, j, aa, bb, cc, dp[i][j][0]);\n\n\t\t\tint tmp = dp[B / 2][j][0];\n\t\t\ttmp = 1LL * tmp * co[B / 2 + aa][aa] % P;\n\t\t\ttmp = 1LL * tmp * co[B / 2 + aa + bb][bb] % P;\n\t\t\ttmp = 1LL * tmp * co[B / 2 + aa + bb + cc][cc] % P;\n\t\t\t// tmp = 1LL * tmp * co[i + aa + bb + cc][cc] % P;\n\t\t\t// tmp = 1LL * tmp * co[i + aa + bb + cc + q][q] % P;\n\t\t\t\n\t\t\tup(ans, tmp);\n\t\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\nusing namespace std;\n \n#define P 1000000007\nint N, A, B, C;\nint co[5010][5010];\nint dp[2511][5010][2];\nint ans;\n \nvoid up(int &x, int y) {\n\tx = (x + y) % P;\n}\n \nint main() {\n\tcin >> N >> A >> B >> C;\n\tco[0][0] = 1;\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tco[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tco[i][j] = (co[i - 1][j] + co[i - 1][j - 1]) % P;\n\t}\n\tif (B % 2 != 0) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= N / 2; i++)\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (dp[i][j][1]) {\n\t\t\t\tup(dp[i][j][0], dp[i][j][1]);\n\t\t\t\tup(dp[i][j + 1][1], dp[i][j][1]);\n\t\t\t}\n\t\t\tif (dp[i][j][0]) {\n\t\t\t\tup(dp[i + 1][j][1], dp[i][j][0]);\n\t\t\t\t// up(dp[i + 1][j][0], dp[i][j][0]);\n\t\t\t}\n\t\t}\n\t// for (int i = 0; i <= N / 3; i++)\n\tfor (int j = 0; j <= C; j++)\n\t\tif (dp[B / 2][j][0])\n\t\t\tfor (int q = 0; j + 3 * q <= C; q++) {\n\t\t\t// if ((B - 2 * i) % 2 != 0)\n\t\t\t// \tcontinue;\n\t\t\tint aa = C - j - 3 * q, bb = q, cc = A - aa;\n\t\t\t// printf(\"?? %d %d %d %d %d\\n\", i, j, aa, bb, cc);\n\t\t\tif (aa < 0 || cc < 0)\n\t\t\t\tcontinue;\n\t\t\t// printf(\"?? %d %d %d %d %d %d\\n\", i, j, aa, bb, cc, dp[i][j][0]);\n\n\t\t\tint tmp = dp[B / 2][j][0];\n\t\t\ttmp = 1LL * tmp * co[B / 2 + aa][aa] % P;\n\t\t\ttmp = 1LL * tmp * co[B / 2 + aa + bb][bb] % P;\n\t\t\ttmp = 1LL * tmp * co[B / 2 + aa + bb + cc][cc] % P;\n\t\t\t// tmp = 1LL * tmp * co[i + aa + bb + cc][cc] % P;\n\t\t\t// tmp = 1LL * tmp * co[i + aa + bb + cc + q][q] % P;\n\t\t\t\n\t\t\tup(ans, tmp);\n\t\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nconst in mdl=1000000007LL;\nin p2(in a){\n  return (1LL<<a);\n}\nin pw(in a, in b, in lm=62){\n  a%=mdl;\n  if(a<0)\n    a+=mdl;\n  in r=1;\n  for(in i=lm;i>=0;--i){\n    r=r*r%mdl;\n    if(b&p2(i))\n      r=r*a%mdl;\n  }\n  return r;\n}\nin inv(in a){\n  a%=mdl;\n  if(a<0)\n    a+=mdl;\n  assert(a!=0);\n  return pw(a,mdl-2,30);\n}\nVI fc,invfc;\nin ncr(in a, in b){\n  if(b==0 || b==a)\n    return 1;//even if a<0\n  if(b<0 || b>a)\n    return 0;\n  return fc[a]*invfc[b]%mdl*invfc[a-b]%mdl;\n}\nvoid inifc(){\n  const in mxfc=30000;\n  fc.resize(mxfc);\n  invfc.resize(mxfc);\n  fc[0]=fc[1]=invfc[0]=invfc[1]=1;\n  for(in i=2;i<mxfc;++i){\n    fc[i]=fc[i-1]*i%mdl;\n    invfc[i]=invfc[mdl%i]*(mdl-mdl/i)%mdl;\n  }\n  for(in i=2;i<mxfc;++i){\n    invfc[i]*=invfc[i-1];\n    invfc[i]%=mdl;\n  }\n}\n\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n,a,b,c;\n  cin>>n>>a>>b>>c;\n  inifc();\n  if(b%2){\n    cout<<0<<endl;\n    return 0;\n  }\n  b/=2;\n  in w=ncr(a+b,a);\n  in tf=0;\n  for(in ca=0;ca<=a;++ca){\n    for(in cc=0;3*cc+ca<=c;++cc){\n      if(b==0 && 3*cc+ca!=c)\n\tcontinue;\n      tf+=ncr(a+b+cc,cc)*ncr(a,ca)%mdl*ncr(b-1+(c-(3*cc+ca)),b-1)%mdl;\n    }\n  }\n  tf%=mdl;\n  tf*=w;\n  tf%=mdl;\n  cout<<tf<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<(int)(n);i++)\n#define N 200000\n\n\nlong long kai[N];\nlong long rkai[N];\nlong long xx[30];\nint yy[30];\n\nvoid kaiz(void) {\n\tkai[0] = 1;\n\tf(i, N - 1) {\n\t\tkai[i + 1] = kai[i] * (i + 1);\n\t\tkai[i + 1] = kai[i + 1] % MOD;\n\t}\n\tint x = MOD - 2;\n\tf(i, 30) {\n\t\tif (x % 2 == 1)yy[i] = 1;\n\t\telse yy[i] = 0;\n\t\tx = x / 2;\n\t}\n\tf(i, N) {\n\t\txx[0] = kai[i];\n\t\tf(j, 29) {\n\t\t\txx[j + 1] = xx[j] * xx[j];\n\t\t\txx[j + 1] = xx[j + 1] % MOD;\n\t\t}\n\t\trkai[i] = 1;\n\t\tf(j, 30) {\n\t\t\tif (yy[j] == 1) {\n\t\t\t\trkai[i] = rkai[i] * xx[j];\n\t\t\t\trkai[i] = rkai[i] % MOD;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long ni(long long x, long long y) {\n\tif (x < 0 || y<0 || y>x)return 0;\n\tlong long re = kai[x];\n\tre = re * rkai[x - y];\n\tre = re % MOD;\n\tre = re * rkai[y];\n\tre = re % MOD;\n\treturn re;\n}\n\nint main() {\n  kaiz();\n\tlong long x, y, z;\n\tlong long ww, xx, yy, zz;\n\tlong long k, s, ans;\n\tscanf(\"%lld %lld %lld %lld\",&k, &x, &y, &z);\n\tif (y % 2 == 1) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\ty /= 2;\n\tans = 0;\n\tfor (long long i = 0; (i <= x) && (i <= z); i++) {\n\t\tfor (long long j = 0; (3 * j) <= (z - i); j++) {\n\t\t\txx = x - i;\n\t\t\tyy = y;\n\t\t\tww = j;\n\t\t\tzz = i;\n\t\t\ts = ni(ww + xx + yy + zz, ww);\n\t\t\tk = ni(xx + yy + zz, xx);\n\t\t\ts = (s*k) % MOD;\n\t\t\tk = ni(yy + zz, yy);\n\t\t\ts = (s*k) % MOD;\n\t\t\tif((z - i -(3*j))>0){\n              k = ni(z - i -(3*j)+ yy - 1, yy - 1);\n\t\t\ts = (s*k) % MOD;\n            }\n\t\t\tans = (ans + s) % MOD;\n\t\t}\n\t}\n\n\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\n#define LL long long\nusing namespace std;\nconst int mo=1e9+7;\nint n,a,b,c; LL fc[N],xf[N],ans;\nLL fpm(LL x,LL y){ LL s=1; while(y){ if(y&1) s=(s*x)%mo; y>>=1,x=(x*x)%mo;} return s;}\nLL C(int n,int m){ return fc[n]*xf[m]%mo*xf[n-m]%mo;}\nLL f(int n,int m)\n{\n\tif(!n) return (m==0);\n\telse return xf[m]*C(m+n-1,n-1)%mo;\n}\nint main()\n{\n\tint i,j,p,q,r,s,v;\n\tcin>>n>>a>>b>>c;\n\tif(b&1){ printf(\"0\"); return 0;}\n\tfc[0]=xf[0]=1;\n\tfor(i=1;i<N;i++){\n\t\tfc[i]=(fc[i-1]*i)%mo;\n\t\txf[i]=fpm(fc[i],mo-2);\n\t  }\n\tfor(i=0;i<=a&&i<=c;i++)\n\t\tfor(j=0;i+3*j<=c;j++){\n\t\t\tp=a-i,q=i,r=j,s=b/2,v=c-i-3*j;\n\t\t\tans=(ans+fc[p+q+r+s]*xf[p]%mo*xf[q]%mo*xf[r]%mo*f(s,v))%mo;\n\t\t  }\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n  \n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\n\n\n\ntemplate<typename M>\nstruct Enumeration{\n  static vector<M> fact,finv,invs;\n  \n  static void init(int n){\n    int m=fact.size();\n    if(n<m) return;\n    \n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n    \n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n  \n  static M C(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static M H(int n,int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static M S(int n,int k){\n    M res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      M tmp=C(k,i)*M(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<M> > D(int n,int m){\n    vector<vector<M> > dp(n+1,vector<M>(m+1,0));\n    dp[0][0]=M(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static M B(int n,int k){\n    if(n==0) return M(1);\n    k=min(k,n);\n    init(k);    \n    vector<M> dp(k+1);\n    dp[0]=M(1);\n    for(int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);    \n    M res;\n    for(int i=1;i<=k;i++)\n      res+=M(i).pow(n)*finv[i]*dp[k-i];    \n    return res;\n  }\n\n  static M montmort(int n){\n    M res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static M LagrangePolynomial(vector<M> &y,M t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    M num(1);\n    for(int i=0;i<=n;i++) num*=t-M(i);\n    M res;\n    for(int i=0;i<=n;i++){\n      M tmp=y[i]*num/(t-M(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs = vector<M>();\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,a,b,c;\n  cin>>n>>a>>b>>c;  \n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  E::init(1e5);\n  \n  M ans{0};\n  for(int x=0;x<=c;x++){\n    for(int y=0;y*3<=c;y++){\n      int w=a-x;\n      int z=b/2;\n      int k=c-(x+y*3);\n      if(w<0||z<0||k<0) continue;\n      if(w+x==a&&z*2==b&&x+y*3+k==c){\n        M res=E::H(z,k);\n        \n        int sum=w+x+y+z;        \n        res*=E::fact[sum];\n        res*=E::finv[w];\n        res*=E::finv[x];\n        res*=E::finv[y];\n        res*=E::finv[z];\n        ans+=res;\n      }\n    }\n  }\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\nusing namespace std;\n \n#define P 1000000007\nint N, A, B, C;\nint co[5010][5010];\nint dp[2501][5010][2];\nint ans;\n \nvoid up(int &x, int y) {\n\tx = (x + y) % P;\n}\n \nint main() {\n\tcin >> N >> A >> B >> C;\n\tco[0][0] = 1;\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tco[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tco[i][j] = (co[i - 1][j] + co[i - 1][j - 1]) % P;\n\t}\n\tif (B % 2 != 0) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= N / 2; i++)\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (dp[i][j][1]) {\n\t\t\t\tup(dp[i][j][0], dp[i][j][1]);\n\t\t\t\tup(dp[i][j + 1][1], dp[i][j][1]);\n\t\t\t}\n\t\t\tif (dp[i][j][0]) {\n\t\t\t\tup(dp[i + 1][j][1], dp[i][j][0]);\n\t\t\t\t// up(dp[i + 1][j][0], dp[i][j][0]);\n\t\t\t}\n\t\t}\n\t// for (int i = 0; i <= N / 3; i++)\n\tfor (int j = 0; j <= C; j++)\n\t\tif (dp[B / 2][j][0])\n\t\t\tfor (int q = 0; j + 3 * q <= C; q++) {\n\t\t\t// if ((B - 2 * i) % 2 != 0)\n\t\t\t// \tcontinue;\n\t\t\tint aa = C - j - 3 * q, bb = q, cc = A - aa;\n\t\t\t// printf(\"?? %d %d %d %d %d\\n\", i, j, aa, bb, cc);\n\t\t\tif (aa < 0 || cc < 0)\n\t\t\t\tcontinue;\n\t\t\t// printf(\"?? %d %d %d %d %d %d\\n\", i, j, aa, bb, cc, dp[i][j][0]);\n\n\t\t\tint tmp = dp[B / 2][j][0];\n\t\t\ttmp = 1LL * tmp * co[B / 2 + aa][aa] % P;\n\t\t\ttmp = 1LL * tmp * co[B / 2 + aa + bb][bb] % P;\n\t\t\ttmp = 1LL * tmp * co[B / 2 + aa + bb + cc][cc] % P;\n\t\t\t// tmp = 1LL * tmp * co[i + aa + bb + cc][cc] % P;\n\t\t\t// tmp = 1LL * tmp * co[i + aa + bb + cc + q][q] % P;\n\t\t\t\n\t\t\tup(ans, tmp);\n\t\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  constexpr ModInt() : v(0) {}\n  constexpr ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool)*this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t)v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<(unsigned)1e9 + 7>;\nV<Mint> fact, ifact, inv, powB;\nvoid init(int n, int B = 2) {\n  fact.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = i * fact[i - 1];\n  }\n  ifact.resize(n + 1);\n  ifact[n] = 1 / fact[n];\n  for (int i = n; i > 0; --i) {\n    ifact[i - 1] = i * ifact[i];\n  }\n  inv.resize(n + 1);\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    int q = Mint::p() / i;\n    inv[i] = -q * inv[Mint::p() - i * q];\n  }\n  powB.resize(n + 1);\n  powB[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    powB[i + 1] = powB[i] * B;\n  }\n}\nMint comb(int n, int r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] * ifact[n - r];\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, a, b, c; cin >> n >> a >> b >> c;\n  if (b & 1) return cout << 0 << '\\n', 0;\n  b >>= 1;\n  init(n);\n\n  Mint res;\n  for (int x = 0; x <= c; ++x) for (int y = 0; x + 3 * y <= c; ++y) {\n    int z = c - x - 3 * y, w = a - z;\n    if (w < 0) continue;\n    if (!b and x) continue;\n    if (!b and !x) {\n      res += fact[y + z + w] * ifact[y] * ifact[z] * ifact[w];\n      continue;\n    }\n    res += comb(x + b - 1, x) * fact[b + y + z + w] * ifact[b] * ifact[y] * ifact[z] * ifact[w];\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nint a, b, c;\n\nlong long mod=1000000007;\nlong long sil[100007];\nlong long osil[100007];\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n\tlong long wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t{\n\t\t\ta*=b;\n\t\t\ta%=mod;\n\t\t}\n\t\tb*=b;\n\t\tb%=mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nlong long komb(int a, int b)\n{\n\tif (b<0 || b>a)\n\t\treturn 0;\n\treturn (sil[a]*((osil[b]*osil[a-b])%mod))%mod;\n}\n\nlong long komz(int a, int b)\n{\n\treturn komb(a+b-1, b);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%d%d%d\", &a, &b, &c);\n\tsil[0]=1;\n\tosil[0]=1;\n\tfor (int i=1; i<=2*n; i++)\n\t{\n\t\tsil[i]=(sil[i-1]*i)%mod;\n\t\tosil[i]=dziel(1, sil[i]);\n\t}\n\tif (b&1)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tb/=2;\n\tfor (int i=0; i<=c; i++)\n\t{\n\t\tfor (int j=0; j+i<=c; j++)\n\t\t{\n\t\t\tint r=c-j-i;\n\t\t\tif (r%3)\n\t\t\t\tcontinue;\n\t\t\tr/=3;\n\t\t\tlong long dod=1;\n\t\t\t\n\t\t\tdod*=komz(b, i);\n\t\t\tdod%=mod;\n\t\t\t\n\t\t\tdod*=komb(a, j);\n\t\t\tdod%=mod;\n\t\t\t\n\t\t\tdod*=komb(a+b+r, r);\n\t\t\tdod%=mod;\n\t\t\t\n\t\t\twyn+=dod;\n\t\t\twyn%=mod;\n\t\t}\n\t}\n\t\n\t\n\twyn*=komb(a+b, a);\n\twyn%=mod;\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n\nconst int N = 7510;\n\nint c[N][N];\n\nint main() {\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if (j == 0) c[i][j] = 1; else\n      if (i == 0) c[i][j] = 0; else {\n        c[i][j] = c[i - 1][j];\n        add(c[i][j], c[i - 1][j - 1]);\n      }\n    }\n  }\n  int n, A, B, C;\n  scanf(\"%d %d %d %d\", &n, &A, &B, &C);\n  if (B % 2 != 0) {\n    printf(\"%d\\n\", 0);\n    return 0;\n  }\n  int ans = 0;\n  for (int y = 0; y <= A && y <= C; y++) {\n    for (int z = 0; y + 3 * z <= C; z++) {\n      int x = A - y;\n      int rm = C - y - 3 * z;\n      if (rm > 0 && B == 0) {\n        continue;\n      }\n      int ways = mul(mul(c[x + y][y], c[x + y + z][z]), c[x + y + z + B / 2][B / 2]);\n      if (rm > 0) {\n        ways = mul(ways, c[rm + B / 2 - 1][rm]);\n      }\n      add(ans, ways);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 20005\n#define LL long long\nusing namespace std;\nconst int mo=1e9+7;\nint n,a,b,c; LL fc[N],xf[N],ans;\nLL fpm(LL x,LL y){ LL s=1; while(y){ if(y&1) s=(s*x)%mo; y>>=1,x=(x*x)%mo;} return s;}\nLL C(int n,int m){ return fc[n]*xf[m]%mo*xf[n-m]%mo;} \nint main()\n{\n\tint i,j,p,q,r,s,v;\n\tcin>>n>>a>>b>>c;\n\tif(b&1){ printf(\"0\"); return 0;}\n\tfc[0]=xf[0]=1;\n\tfor(i=1;i<N;i++){\n\t\tfc[i]=(fc[i-1]*i)%mo;\n\t\txf[i]=fpm(fc[i],mo-2);\n\t  }\n\tfor(i=0;i<=a&&i<=c;i++)\n\t\tfor(j=0;i+3*j<=c;j++){\n\t\t\tp=a-i,q=i,r=j,s=b/2,v=c-i-3*j;\n\t\t\tans=(ans+fc[p+q+r+s]*xf[p]%mo*xf[q]%mo*xf[r]%mo*xf[s]%mo*C(v+s-1,s-1))%mo;\n\t\t  }\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 100005\n#define M 200005\n#define seed 23333\n#define Mo 1000000007\n\nusing namespace std;\nint i,j,m,n,p,k,a,b,c,ans,fac[N],inv[N];\nint C(int x,int y)\n{\n\t\treturn 1ll*fac[x]*inv[y]%Mo*inv[x-y]%Mo;\n}\nint power(int x,int y)\n{\n\t\tint s=1;\n\t\tfor (;y;y>>=1)\n\t\t{\n\t\t\t\tif (y&1) s=1ll*s*x%Mo;\n\t\t\t\tx=1ll*x*x%Mo;\n\t\t}\n\t\treturn s;\n}\nvoid jia(int &x,int y)\n{\n\t\tx+=y; if (x>=Mo) x-=Mo;\n}\nint main()\n{\n\tscanf(\"%d%d%d%d\",&n,&a,&b,&c);\n\tfac[0]=inv[0]=1;\n\tfor (i=1;i<N;++i) fac[i]=1ll*fac[i-1]*i%Mo,inv[i]=power(fac[i],Mo-2);\n\tif (b&1) puts(\"0\");\n\telse \n\t{\n\t\t  b/=2;\n\t\t  for (i=0;i<=a;++i)\n\t\t  \tfor (j=0;i+j<=c;++j)\n\t\t  \t\tif ((c-i-j)%3==0)\n\t\t  \t\t{\n\t\t  \t\t\t\tjia(ans,1ll*C(a+b,a)*C(a,i)%Mo*C(b+j-1,j)%Mo*C(a+b+1+(c-i-j)/3-1,(c-i-j)/3)%Mo); \n\t\t  \t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#include<iomanip>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\n#define N 100010\nll fac[N],inv[N],ivf[N];\nll C(ll n,ll k){\n    return fac[n]*ivf[k]%mod*ivf[n-k]%mod;\n}\nll H(ll n,ll k){\n    return C(n+k-1,k);\n}\nll beta(ll x,ll y,ll z,ll w){\n    ll res=fac[x+y+z+w];\n    mul(res,ivf[x]);\n    mul(res,ivf[y]);\n    mul(res,ivf[z]);\n    mul(res,ivf[w]);\n    return res;\n}\nll n,a,b,c;\nll alpha(ll d){\n    ll ans=0;\n    for(ll x=0;x<=a;x++){\n\tll y=b/2;\n\tll z=a-x;\n\tif((d-z)%3>0||d<z)continue;\n\tll w=(d-z)/3;\n\tmad(ans,beta(x,y,z,w));\n    }\n    return ans;\n}\nint main(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(ll i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-(mod/i*inv[mod%i]%mod))%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n    cin>>n>>a>>b>>c;\n    if(b%2==1)cout<<0<<endl;\n    else{\n\tll ans=0;\n\tfor(ll i=0;i<=c;i++){\n\t    ll cur=alpha(c-i);\n\t    mul(cur,H(b/2,i));\n\t    mad(ans,cur);\n\t}\n\tcout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    return fact[n]*inv[n-k]%mod;\n}\n\nsigned main(){\n    int N,A,B,C;\n    cin>>N>>A>>B>>C;\n\n    if(B%2){\n        cout<<0<<endl;\n        return 0;\n    }\n\n    int ans=0;\n    for(int i=0;i<=A;i++){\n        for(int l=0;l*3<=C;l++){\n            int j=B/2;\n            int k=A-i;\n\n            int x=C-k-3*l;\n            if(x<0)continue;\n            if(j==0&&x>0)continue;\n            int tmp=fact[i+j+k+l]*inv[i]%mod*inv[j]%mod*inv[k]%mod*inv[l]%mod;\n            if(j)tmp=tmp*nCk(x+j-1,j-1)%mod;\n            add(ans,tmp);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=10000+10,mod=1e9+7;\nint ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint fac[maxn],ifac[maxn];\ninline void init(int n){\n\tfac[0]=1;\n\tREP(i,1,n) fac[i]=(ll)i*fac[i-1]%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tDREP(i,n,1) ifac[i-1]=(ll)i*ifac[i]%mod;\n}\ninline int calc(int S,int x4){\n\tif(S==0 && x4==0) return 1;\n\tif(x4==0) return 0;\n\treturn (ll)fac[S+x4-1]*ifac[S]%mod*ifac[x4-1]%mod;\n}\nint main(){\n\tinit(maxn-10);\n\tint n=read(),A=read(),B=read(),C=read(),ans=0;\n\tif(B&1) return printf(\"0\\n\"),0;\n\tREP(x1,0,A) REP(x3,0,C/3){\n\t\tint x2=A-x1,x4=B/2,S=C-x3*3-x2;\n\t\tif(S<0) continue;\n\t\tans=(ans+(ll)fac[x1+x2+x3+x4]*ifac[x1]%mod*ifac[x2]%mod*ifac[x3]%mod*ifac[x4]%mod*calc(S,x4))%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint c[5010][5010];\n\nll comb(int N, int K) {\n\tif (N < 0 || K < 0 || K > N) return 0;\n\treturn c[N][K];\n}\n\nll H(int N, int K) {\n\tif (K == 0) return !N;\n\treturn comb(N + K - 1, K - 1);\n}\n\nint main() {\n\trep(i, 5010) {\n\t\tc[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n\t}\n\tint N, A, B, C;\n\tcin >> N >> A >> B >> C;\n\tif (B % 2) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tll ans = 0;\n\tfor (int a = 0; a <= A; a++) {\n\t\tint d = A - a;\n\t\tfor (int c = 0; c * 3 + d <= C; c++) {\n\t\t\tint b = B / 2;\n\t\t\tll unko = comb(a+b+c+d, a) * comb(b+c+d, b) % MOD * comb(c+d, c) % MOD;\n\t\t\tint k = C - (c * 3 + d);\n\t\t\tunko = unko * H(k, b) % MOD;\n\t\t\tans = (ans + unko) % MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  constexpr ModInt() : v(0) {}\n  constexpr ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool)*this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t)v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<(unsigned)1e9 + 7>;\nV<Mint> fact, ifact, inv, powB;\nvoid init(int n, int B = 2) {\n  fact.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = i * fact[i - 1];\n  }\n  ifact.resize(n + 1);\n  ifact[n] = 1 / fact[n];\n  for (int i = n; i > 0; --i) {\n    ifact[i - 1] = i * ifact[i];\n  }\n  inv.resize(n + 1);\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    int q = Mint::p() / i;\n    inv[i] = -q * inv[Mint::p() - i * q];\n  }\n  powB.resize(n + 1);\n  powB[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    powB[i + 1] = powB[i] * B;\n  }\n}\nMint comb(int n, int r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] * ifact[n - r];\n}\n\nconstexpr double pi = acos(-1);\nstruct C {\n  double x, y;\n  C() : x(0), y(0) {}\n  C(double x, double y) : x(x), y(y) {}\n  C(double th) : x(cos(th)), y(sin(th)) {}\n  C operator~() const { return {x, -y}; }\n  C operator*(const C& r) const { return {x * r.x - y * r.y, x * r.y + y * r.x}; }\n  C operator+(const C& r) const { return {x + r.x, y + r.y}; }\n  C operator-(const C& r) const { return {x - r.x, y - r.y}; }\n};\nvoid fft(V<C>& a, bool inv = false) {\n  int n = a.size();\n  assert(__builtin_popcount(n) == 1);\n  int j = 0;\n  for (int i = 1; i < n; ++i) {\n    int w = n >> 1;\n    while (j >= w) j -= w, w >>= 1;\n    j += w;\n    if (i < j) swap(a[i], a[j]);\n  }\n  static VV<C> xi;\n  for (int k = 0; 1 << k < n; ++k) if (k >= (int)xi.size()) {\n    xi.emplace_back(1 << k);\n    for (int i = 0; i < 1 << k; ++i) {\n      xi[k][i] = C(i * pi / (1 << k));\n    }\n  }\n  for (int k = 0; 1 << k < n; ++k) {\n    const int w = 1 << k;\n    for (int s = 0; s < n; s += 2 * w) {\n      for (int i = s; i < s + w; ++i) {\n        C p = a[i], q = a[i + w] * (inv ? ~xi[k][i - s] : xi[k][i - s]);\n        a[i] = p + q, a[i + w] = p - q;\n      }\n    }\n  }\n}\ntemplate<unsigned P> V< ModInt<P> > multiply(const V< ModInt<P> >& a, const V< ModInt<P> >& b) {\n  int na = a.size(), nb = b.size();\n  if (!na or !nb) return {};\n  int nc = na + nb - 1, n = 1 << __lg(2 * nc - 1);\n  V<C> f(n), g(n);\n  for (int i = 0; i < na; ++i) {\n    f[i].x = a[i].v & ~(~0U << 15), f[i].y = a[i].v >> 15;\n  }\n  for (int i = 0; i < nb; ++i) {\n    g[i].x = b[i].v & ~(~0U << 15), g[i].y = b[i].v >> 15;\n  }\n  fft(f), fft(g);\n  V<C> Al(n), Au(n), Bl(n), Bu(n);\n  for (int i = 0; i < n; ++i) {\n    Al[i] = (f[i] + ~f[-i & n - 1]) * C(0.5, 0);\n    Au[i] = (f[i] - ~f[-i & n - 1]) * C(0, -0.5);\n    Bl[i] = (g[i] + ~g[-i & n - 1]) * C(0.5, 0);\n    Bu[i] = (g[i] - ~g[-i & n - 1]) * C(0, -0.5);\n  }\n  for (int i = 0; i < n; ++i) {\n    f[i] = Al[i] * Bl[i] + C(0, 1) * Al[i] * Bu[i];\n    g[i] = Au[i] * Bl[i] + C(0, 1) * Au[i] * Bu[i];\n  }\n  fft(f, true), fft(g, true);\n  V< ModInt<P> > c(nc);\n  for (int i = 0; i < nc; ++i) {\n    lint l = f[i].x / n + 0.5;\n    lint m = (f[i].y + g[i].x) / n + 0.5;\n    lint u = g[i].y / n + 0.5;\n    c[i] = l + (m % P << 15) + (u % P << 30);\n  }\n  return c;\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, a, b, c; cin >> n >> a >> b >> c;\n  if (b & 1) return cout << 0 << '\\n', 0;\n  b >>= 1;\n  init(n);\n\n  if (!b) {\n    Mint res;\n    for (int y = 0; 3 * y <= c; ++y) {\n      int z = c - 3 * y, w = a - z;\n      if (w < 0) continue;\n      res += fact[y + z + w] * ifact[y] * ifact[z] * ifact[w];\n    }\n    return cout << res << '\\n', 0;\n  }\n\n  V<Mint> f(c + 1), g(c + 1);\n  for (int i = 0; i <= c; ++i) {\n    f[i] = comb(i + b - 1, i);\n    if (i % 3 == 0) {\n      g[i] = fact[a + b + i / 3] * ifact[i / 3];\n    }\n  }\n  f = multiply(f, g);\n  Mint res;\n  for (int k = max(c - a, 0); k <= c; ++k) {\n    res += ifact[b] * ifact[c - k] * ifact[a - c + k] * f[k];\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint N,A,B,C;\nlong mod=1e9+7;\nlong F[5050],I[5050];\nlong power(long a,long b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}\nlong comb(long a,long b){return F[a]*I[b]%mod*I[a-b]%mod;}\nlong H(long a,long b){return a==0?b==0:comb(a-1+b,b);}\nmain()\n{\n\tcin>>N>>A>>B>>C;\n\tF[0]=1;\n\tfor(int i=1;i<=N;i++)F[i]=F[i-1]*i%mod;\n\tI[N]=power(F[N],mod-2);\n\tfor(int i=N;i--;)I[i]=I[i+1]*(i+1)%mod;\n\tif(B%2)\n\t{\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<=C;i++)\n\t{\n\t\tfor(int j=0;j<=A&&j+i<=C;j++)\n\t\t{\n\t\t\tif((C-i-j)%3)continue;\n\t\t\t(ans+=F[(C-i-j)/3+j+A-j+B/2]*I[(C-i-j)/3]%mod*I[j]%mod*I[A-j]%mod*I[B/2]%mod*H(B/2,i)%mod)%=mod;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define DN(en, ka) (F[en] * pot(F[ka] * F[en - ka] % Q, -1) % Q)\nusing namespace std;\ntypedef long long int ll;\nconst ll N = 1 << 16, Q = 1000000007;\nll n, a, b, c, res, F[N] = {1};\nint pot(ll a, ll b){\n  a %= Q;\n  if(b < 0)\n    return pot(pot(a, -b), Q - 2);\n  if(b == 0)\n    return 1;\n  if(b % 2 == 1)\n    return ((ll)pot(a, b - 1) * a) % Q;\n  ll t = pot(a, b / 2);\n  return (t * t) % Q;\n}\nint solve(int x, int y){\n  if(c < y * 3 + a - x)\n    return 0;\n  ll t = c - a + x - 3 * y,\n    l = F[a + y + b / 2],\n    m = F[x] * F[y] % Q * F[a - x] % Q * F[b / 2] % Q,\n    k = b ? DN(b / 2 + t - 1, t) : 1;\n  return l * pot(m, -1) % Q * k % Q;\n}  \nint main(){\n  for(int i = 1;i < N;i++)\n    F[i] = (F[i - 1] * i) % Q;\n  cin >> n >> a >> b >> c;\n  if(b % 2 == 1){\n    cout << \"0\\n\";\n    return 0;\n  }\n  for(int i = 0;i <= a;i++)\n    for(int j = 0;j <= c / 3;j++)\n      res += solve(i, j);\n  cout << res % Q << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\nusing namespace std;\n\n#define P 1000000007\nint N, A, B, C;\nint co[5010][5010];\nint dp[2010][5010][2];\nint ans;\n\nvoid up(int &x, int y) {\n\tx = (x + y) % P;\n}\n\nint main() {\n\tcin >> N >> A >> B >> C;\n\tco[0][0] = 1;\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tco[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tco[i][j] = (co[i - 1][j] + co[i - 1][j - 1]) % P;\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= N / 3; i++)\n\t\tfor (int j = i; j <= N - 2 * i; j++) {\n\t\t\tif (dp[i][j][1]) {\n\t\t\t\tup(dp[i][j][0], dp[i][j][1]);\n\t\t\t\tup(dp[i][j + 1][1], dp[i][j][1]);\n\t\t\t}\n\t\t\tif (dp[i][j][0]) {\n\t\t\t\tup(dp[i + 1][j + 1][1], dp[i][j][0]);\n\t\t\t}\n\t\t}\n\tfor (int i = 0; i <= N / 3; i++)\n\t\tfor (int j = i; j <= N - 2 * i; j++)\n\t\t\tif (dp[i][j][0]) {\n\t\t\t\tif ((B - 2 * i) % 2 != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int q = 0; C - 3 * q - j >= 0; q++) {\n\t\t\t\t\tint aa = C - 3 * q - j, bb = (B - 2 * i) / 2, cc = A - aa;\n\t\t\t\t\t// printf(\"?? %d %d %d %d %d\\n\", i, j, aa, bb, cc);\n\t\t\t\t\tif (aa < 0 || bb < 0 || cc < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// printf(\"?? %d %d %d %d %d %d\\n\", i, j, aa, bb, cc, dp[i][j][0]);\n\n\t\t\t\t\tint tmp = dp[i][j][0];\n\t\t\t\t\ttmp = 1LL * tmp * co[i + aa][aa] % P;\n\t\t\t\t\ttmp = 1LL * tmp * co[i + aa + bb][bb] % P;\n\t\t\t\t\ttmp = 1LL * tmp * co[i + aa + bb + cc][cc] % P;\n\t\t\t\t\ttmp = 1LL * tmp * co[i + aa + bb + cc + q][q] % P;\n\t\t\t\t\t\n\t\t\t\t\tup(ans, tmp);\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nll mod=1e9+7;\nconst int MX=50000;\nll f[MX+1],g[MX+1],inv[MX+1];\nvoid precalc(){\n\tf[0]=1;\n\trep1(i,MX) f[i]=f[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=MX;i++) inv[i]=mod-mod/i*inv[mod%i]%mod;\n\tg[0]=1;\n\trep1(i,MX) g[i]=g[i-1]*inv[i]%mod;\n}\nll C4(int a,int b,int c,int d){\n\treturn f[a+b+c+d]*g[a]%mod*g[b]%mod*g[c]%mod*g[d]%mod;\n}\nll C2(int a,int b){\n\tif(b==0) return 1;\n\tif(a<b) return 0;\n\treturn f[a]*g[b]%mod*g[a-b]%mod;\n}\nint main(){\n\tprecalc();\n\tint N,A,B,C;\n\tcin>>N>>A>>B>>C;\n\tif(B%2==1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tll ans=0;\n\trep(i,A+1){\n\t\trep(j,C/3+1){\n\t\t\tint l=C-(A-i)-3*j;\n\t\t\tif(l<0) break;\n\t\t\tll tmp=C4(i,A-i,j,B/2);\n\t\t\ttmp*=C2(l+B/2-1,l);\n\t\t\ttmp%=mod;\n\t\t\tans+=tmp;\n\t\t\tans%=mod;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i)\nconst int mo = 1000000007;\nusing namespace std;\nint n, A, B, C; ll c[5010][5010];\nint main() {\n\tscanf(\"%d%d%d%d\", &n, &A, &B, &C);\n\tif (B & 1) { printf(\"0\"); return 0; }\n\trep(i, 0, n) c[i][0] = 1; ll ans = 0;\n\trep(i, 1, n) rep(j, 1, i) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mo;\n\trep(p, 0, min(A, C)) rep(q, 0, (C - p) / 3) {\n\t\tint x = A - p;\n\t\tif (!B && C - p - 3 * q) continue;\n\t\tll ret = c[x + p][x] % mo * c[x + p + q][q] % mo * c[x + p + q + B / 2][B / 2] % mo;\n\t\tif (B) ret = ret * c[C - p - 3 * q + B / 2 - 1][B / 2 - 1] % mo;\n\t\tans = (ans + ret) % mo;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint A, B, C;\nlong long Mod = 1000000007, F[5010], InvF[5010], Res;\nlong long Pow(long long a, int b){\n    long long r = 1;\n    while(b){\n        if(b&1)r=r*a%Mod;\n        a=a*a%Mod;b>>=1;\n    }\n    return r;\n}\nint main(){\n    int n;\n    scanf(\"%d%d%d%d\",&n,&A,&B,&C);\n    int i, j;\n    F[0]=InvF[0]=1;\n    for(i=1;i<=5000;i++){\n        F[i]=F[i-1]*i%Mod;\n        InvF[i]=Pow(F[i],Mod-2);\n    }\n    if(B%2){\n        printf(\"0\\n\");\n        return 0;\n    }\n    for(i=0;i<=A;i++){\n        for(j=0;A-i+3*j<=C;j++){\n            int s = C - (A-i+3*j);\n            Res = (Res +F[A+j+B/2] * InvF[i] % Mod * InvF[j] % Mod * InvF[A-i] % Mod * InvF[B/2] % Mod * F[B/2+s-1] % Mod * InvF[s] % Mod * InvF[B/2-1])%Mod;\n        }\n    }\n    printf(\"%lld\\n\",Res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n\n    template<class T>\n    friend modint operator*(T l, modint r) { return modint(l) *= r; }\n    template<class T>\n    friend modint operator+(T l, modint r) { return modint(l) += r; }\n    template<class T>\n    friend modint operator-(T l, modint r) { return modint(l) -= r; }\n    template<class T>\n    friend modint operator/(T l, modint r) { return modint(l) /= r; }\n    template<class T>\n    friend bool operator==(T l, modint r) { return modint(l) == r; }\n    template<class T>\n    friend bool operator!=(T l, modint r) { return modint(l) != r; }\n    // Input/Output\n    friend ostream &operator<<(ostream& os, modint a) { return os << a.x; }\n    friend istream &operator>>(istream& is, modint &a) { return is >> a.x; }\n    friend string to_frac(modint v) {\n        static map<ll, PII> mp;\n        if(mp.empty()) {\n            mp[0] = mp[MOD] = {0, 1};\n            FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n                mp[(modint(i) / j).x] = {i, j};\n            }\n        }\n        auto itr = mp.lower_bound(v.x);\n        if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n        string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n        if(itr->second.second > 1) {\n            ret += '/';\n            ret += to_string(itr->second.second);\n        }\n        return ret;\n    }\n};\nusing mint = modint<1000000007>;\n\n// 前計算O(N) クエリO(1)\nmint combi(ll N, ll K) {\n    const int maxN=5e5; // !!!\n    static mint fact[maxN+1]={},factr[maxN+1]={};\n    if (fact[0]==0) {\n        fact[0] = factr[0] = 1;\n        FOR(i, 1, maxN+1) fact[i] = fact[i-1] * i;\n        factr[maxN] = fact[maxN].inv();\n        for(ll i=maxN-1; i>=0; --i) factr[i] = factr[i+1] * (i+1);\n    }\n    if(K<0 || K>N) return 0; // !!!\n    return factr[K]*fact[N]*factr[N-K];\n}\n\nmint frac[20001], ifrac[20001];\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, a, b, c;\n    cin >> n >> a >> b >> c;\n\n    if(b%2) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    frac[0] = 1;\n    FOR(i, 1, 20001) frac[i] = frac[i-1] * i;\n    ifrac[20000] = frac[20000].inv();\n    for(ll i=19999; i>=0; --i) ifrac[i] = ifrac[i+1] * (i+1);\n\n    if(b == 0) {\n        mint ret = 0;\n        REP(w, a+1) {\n            ll x = a-w, z = (c-x)/3;\n            if(c-x<0 || (c-x)%3 != 0) continue;\n            mint add = frac[w+x+z] * ifrac[w] * ifrac[x] * ifrac[z];\n            ret += add;\n        }\n        cout << ret << endl;\n        return 0;\n    }\n\n    mint ret = 0;\n    REP(w, a+1) REP(z, c/3+1) {\n        ll x = a-w, y = b/2, rest = c-x-3*z;\n        if(x+3*z > c) continue;\n        mint add = frac[w+x+y+z] * ifrac[w] * ifrac[x] * ifrac[y] * ifrac[z] * combi(rest+y-1, y-1);\n        ret += add;\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\n#define rep(i,a,b) for (rint i=(a),_E=(b); i<=_E; ++i)\n#define per(i,a,b) for (rint i=(a),_E=(b); i>=_E; --i)\n#define REP(i,n) for (rint i=0,_E=(n); i<_E; ++i)\n#define pb push_back\n#define cmin(x,y) (y<x?x=y:0)\n#define cmax(x,y) (y>x?x=y:0)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N = 10005;\nconst int mod = 1000000007;\nint n, a, b, c, n1, n2, n3, n4, K, res, now;\nint fac[N], rev[N];\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1ll * x * res % mod;\n\t\tx = 1ll * x * x % mod; p >>= 1;\n\t}\n\treturn res;\n}\n\ninline int C(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn 1ll * fac[n] * rev[m] % mod * rev[n-m] % mod;\n}\n\n//将n划分为m份，可以为空\ninline int calc(int n, int m) {\n\tif (!n) return !m;\n\treturn C(n + m - 1, m - 1);\n}\n\nint main() {\n\tscanf(\"%d%d%d%d\", &n, &a, &b, &c);\n\tif (b & 1) return puts(\"0\"), 0;\n\tfac[0] = rev[0] = 1;\n\trep (i, 1, 10000) {\n\t\tfac[i] = 1ll * i * fac[i-1] % mod;\n\t\trev[i] = power(fac[i], mod - 2);\n\t}\n\trep (x, 0, min(a, c)) rep (y, 0, (c - x) / 3) {\n\t\tn1 = b / 2, n2 = y, n3 = a - x, n4 = x, K = c - x - 3 * y;\n\t\tif (n1 < 0 || n2 < 0 || n3 < 0 || n4 < 0 || K < 0) continue;\n\t\tnow = 1ll * fac[n1 + n2 + n3 + n4] * calc(K, n1) % mod;\n\t\tnow = 1ll * now * rev[n1] % mod * rev[n2] % mod;\n\t\tnow = 1ll * now * rev[n3] % mod * rev[n4] % mod;\n\t\tres = (res + now) % mod;\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  constexpr ModInt() : v(0) {}\n  constexpr ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool)*this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t)v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<(unsigned)1e9 + 7>;\nV<Mint> fact, ifact, inv, powB;\nvoid init(int n, int B = 2) {\n  fact.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = i * fact[i - 1];\n  }\n  ifact.resize(n + 1);\n  ifact[n] = 1 / fact[n];\n  for (int i = n; i > 0; --i) {\n    ifact[i - 1] = i * ifact[i];\n  }\n  inv.resize(n + 1);\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    int q = Mint::p() / i;\n    inv[i] = -q * inv[Mint::p() - i * q];\n  }\n  powB.resize(n + 1);\n  powB[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    powB[i + 1] = powB[i] * B;\n  }\n}\nMint comb(int n, int r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] * ifact[n - r];\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, a, b, c; cin >> n >> a >> b >> c;\n  if (b & 1) return cout << 0 << '\\n', 0;\n  b >>= 1;\n  init(n);\n\n  Mint res;\n  for (int x = 0; x <= c; ++x) for (int y = 0; x + 3 * y <= c; ++y) {\n    int z = c - x - 3 * y, w = a - z;\n    if (w < 0) continue;\n    res += comb(x + b - 1, x) * fact[b + y + z + w] * ifact[b] * ifact[y] * ifact[z] * ifact[w];\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll memo[5050][5050];\nbool done[5050][5050];\n\nll com(int n, int k){\n\tif(n<k){\n\t\treturn 0ll;\n\t}\n\tif(done[n][k]){\n\t\treturn memo[n][k];\n\t}\n\tdone[n][k] = true;\n\tif(k==0 || k==n){\n\t\treturn memo[n][k] = 1ll;\n\t}\n\tmemo[n][k] = com(n-1,k);\n\tadd_mod(memo[n][k],com(n-1,k-1));\n\treturn memo[n][k];\n}\n\nll rwpw(ll a, int p){\n\tll ret = 1ll;\n\twhile(p){\n\t\tif(p&1){\n\t\t\tmul_mod(ret,a);\n\t\t}\n\t\tmul_mod(a,a);\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint n,m,i,j,k,a,b,c;\n\tll ans=0ll,tmp;\n\tcin >> n >> a >> b >> c;\n\tif(b%2){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tb /= 2;\n\tfor(i=0; i<=c; ++i){\n\t\tfor(j=0; j<=c; ++j){\n\t\t\tif(i+j>c){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(j>a){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tk = c - i - j;\n\t\t\tif(k%3){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tk /= 3;\n\t\t\tm = b + a + k;\n\t\t\ttmp = com(m,b);\n\t\t\tmul_mod(tmp,com(m-b,a));\n\t\t\tmul_mod(tmp,com(a,j));\n\t\t\tif(i+b>0){\n\t\t\t\tmul_mod(tmp,com(i+b-1,i));\n\t\t\t}\n\t\t\tadd_mod(ans,tmp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define DN(en, ka) (F[en] * pot(F[ka] * F[en - ka] % Q, -1) % Q)\nusing namespace std;\ntypedef long long int ll;\nconst ll N = 1 << 16, Q = 1000000007;\nll n, a, b, c, res, F[N] = {1};\nint pot(ll a, ll b){\n  a %= Q;\n  if(b < 0)\n    return pot(pot(a, -b), Q - 2);\n  if(b == 0)\n    return 1;\n  if(b % 2 == 1)\n    return ((ll)pot(a, b - 1) * a) % Q;\n  ll t = pot(a, b / 2);\n  return (t * t) % Q;\n}\nint solve(int x, int y){\n  ll t = c - a + x - 3 * y,\n    l = F[a + y + b / 2],\n    m = F[x] * F[y] % Q * F[a - x] % Q * F[b / 2] % Q,\n    k = b ? DN(b / 2 + t - 1, t) : 1;\n  return (c < y * 3 + a - x) ? 0 : (l * pot(m, -1) % Q * k % Q);\n}  \nint main(){\n  for(int i = 1;i < N;i++)\n    F[i] = (F[i - 1] * i) % Q;\n  cin >> n >> a >> b >> c;\n  if(b % 2 == 1){\n    cout << \"0\\n\";\n    return 0;\n  }\n  for(int i = 0;i <= a;i++)\n    for(int j = 0;j <= c / 3;j++)\n      res += solve(i, j);\n  cout << res % Q << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, A, B, C;\nint Comb[10050][5050];\n\nint main()\n{\n\tfor (int i = 0; i <= 5000; ++i) Comb[0][i] = 0;\n\tComb[0][0] = 1;\n\tfor (int i = 1; i <= 10010; ++i) {\n\t\tComb[i][0] = 1;\n\t\tfor (int j = 1; j <= 5010; ++j) Comb[i][j] = (Comb[i - 1][j - 1] + Comb[i - 1][j]) % MOD;\n\t}\n\tscanf(\"%d%d%d%d\", &N, &A, &B, &C);\n\tif (B % 2 == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\ti64 ret = 0;\n\tfor (int p = 0; p <= C; ++p) {\n\t\tif (B == 0 && p > 0) continue;\n\t\tfor (int q = 0; 3 * q <= C - p; q++) {\n\t\t\tint r = C - p - 3 * q;\n\t\t\tint iso = A - r;\n\t\t\tif (iso < 0) continue;\n\t\t\ti64 tmp = (i64)Comb[B / 2 + q + r + iso][iso] * Comb[B / 2 + q + r][B / 2] % MOD * Comb[q + r][q] % MOD;\n\t\t\tif (B > 0) {\n\t\t\t\ttmp = tmp * Comb[B / 2 - 1 + p][p];\n\t\t\t}\n\t\t\tADD(ret, tmp);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 10005;\nconst int mod = 1e9 + 7;\n\nint n, A, B, C;\nint fact[N], ifact[N];\nint res;\n\nvoid add(int &x, int y) {\n    x += y; while(x >= mod) x -= mod; while(x < 0) x += mod;\n}\n\nint pw(int a, int b) {\n    int ret = 1;\n    while(b) {\n        if (b & 1) ret = 1LL * ret * a % mod; a = 1LL * a * a % mod;\n        b >>= 1;\n    }\n    return ret;\n}\n\nint comb(int n, int k) {\n    if (n == k) return 1;\n    if (n < 0 || k < 0 || n < k) return 0;\n    return 1LL * fact[n] * (1LL * ifact[k] * ifact[n - k] % mod) % mod;\n}\n\nint candy(int n, int k) {\n    return comb(n + k - 1, k - 1);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n >> A >> B >> C;\n    if (B % 2 != 0) return cout << 0 << endl, 0;\n\n    fact[0] = 1; for (int i = 1; i < N; ++i) fact[i] = 1LL * fact[i - 1] * i % mod;\n    ifact[0] = 1; for (int i = 1; i < N; ++i) ifact[i] = pw(fact[i], mod - 2);\n\n    // type 1: 11\n    // type 2: 3113\n    // type 3: 333333\n    // type 4: 2222\n    // type 5: 2323333232\n\n    // remC = C - t2 - t3 (t3 % 3 == 0)\n    // candy(remC, B / 2)\n    // C(B / 2 + 1, t3 / 3)\n    // C(B / 2 + 1 + t3 / 3, t2)\n    // C(B / 2 + 1 + t2 + t3 / 3, t1)\n\n    B /= 2;\n    for (int t2 = 0; t2 <= min(A, C); ++t2) {\n        for (int t3 = 0; t3 <= C / 3; ++t3) {\n            int t1 = A - t2;\n            int remC = C - t2 - 3 * t3; if (remC < 0) continue;\n            \n            int mul = 1;\n            mul = 1LL * mul * candy(remC, B) % mod;\n            mul = 1LL * mul * candy(t3, B + 1) % mod;\n            mul = 1LL * mul * candy(t2, B + 1 + t3) % mod;\n            mul = 1LL * mul * candy(t1, B + 1 + t3 + t2) % mod;\n\n            add(res, mul);\n        }\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nconst int Mod = 1e9 + 7, Nmax = 1e5;\n\ntypedef long long ll;\n\n\nint n, A, B, C;\nint fact[Nmax], ifact[Nmax];\n\n\nvoid add_to(int &x, int y)\n{\n    x += y; if(x>=Mod) x-=Mod;\n}\nint inm(int x, int y)\n{\n    return (ll) x*y%Mod;\n}\nint inm(int x, int y, int z)\n{\n    return (ll) x*y%Mod*z%Mod;\n}\n\nint comb(int n, int k)\n{\n    if(!k) return 1;\n    return inm( fact[n], ifact[n-k], ifact[k] );\n}\n\nint permuta(int x, int y, int z, int t)\n{\n    return inm( inm(fact[x+y+z+t], ifact[x]), inm(ifact[y], ifact[z], ifact[t] ));\n}\n\nint power(int a, int b)\n{\n    int ans = 1;\n    while(b)\n    {\n        if(b&1) ans = inm(ans, a);\n        a = inm(a, a); b >>= 1;\n    }\n    return ans;\n}\n\nvoid prec(int lim)\n{\n    int i;\n    fact[0] = ifact[0] = 1;\n\n    for(i=1; i<=lim; ++i) fact[i] = inm(fact[i-1], i);\n\n    ifact[lim] = power(fact[lim], Mod - 2);\n    for(i=lim-1; i; --i) ifact[i] = inm(ifact[i+1], i+1);\n}\n\n\nint main()\n{\n //   freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false); cin.tie(0);\n\n    cin >> n >> A >> B >> C;\n\n    prec(5*n);\n\n    if(B&1)\n    {\n        cout << 0 << '\\n';\n        return 0;\n    }\n\n    int x, y, z, t;\n\n    y = B / 2;\n\n    int ans = 0;\n\n    for(x=0; x<=A; ++x)\n        for(z=0; 3*z<=C; ++z)\n        {\n            t = A - x;\n\n            int rest = C - 3*z - t;\n            if(rest < 0) continue;\n\n            int ways = comb(y + rest - 1, rest);\n            int perm = permuta(x, y, z, t);\n\n            add_to(ans, inm(ways, perm));\n        }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\nusing namespace std;\n\n#define P 1000000007\nint N, A, B, C;\nint co[5010][5010];\nint dp[2010][5010][2];\nint ans;\n\nvoid up(int &x, int y) {\n\tx = (x + y) % P;\n}\n\nint main() {\n\tcin >> N >> A >> B >> C;\n\tco[0][0] = 1;\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tco[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tco[i][j] = (co[i - 1][j] + co[i - 1][j - 1]) % P;\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= N / 3; i++)\n\t\tfor (int j = i; j <= N - 2 * i; j++) {\n\t\t\tif (dp[i][j][1]) {\n\t\t\t\tup(dp[i][j][0], dp[i][j][1]);\n\t\t\t\tup(dp[i][j + 1][1], dp[i][j][1]);\n\t\t\t}\n\t\t\tif (dp[i][j][0]) {\n\t\t\t\tup(dp[i + 1][j + 1][1], dp[i][j][0]);\n\t\t\t}\n\t\t}\n\tfor (int i = 0; i <= N / 3; i++)\n\t\tfor (int j = i; j <= N - 2 * i; j++)\n\t\t\tif (dp[i][j][0]) {\n\t\t\t\tif ((B - 2 * i) % 2 != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int q = max(0, (C - A - j) / 3); C - 3 * q - j >= 0; q++) {\n\t\t\t\t\tint aa = C - 3 * q - j, bb = (B - 2 * i) / 2, cc = A - aa;\n\t\t\t\t\t// printf(\"?? %d %d %d %d %d\\n\", i, j, aa, bb, cc);\n\t\t\t\t\tif (aa < 0 || bb < 0 || cc < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// printf(\"?? %d %d %d %d %d %d\\n\", i, j, aa, bb, cc, dp[i][j][0]);\n\n\t\t\t\t\tint tmp = dp[i][j][0];\n\t\t\t\t\ttmp = 1LL * tmp * co[i + aa][aa] % P;\n\t\t\t\t\ttmp = 1LL * tmp * co[i + aa + bb][bb] % P;\n\t\t\t\t\ttmp = 1LL * tmp * co[i + aa + bb + cc][cc] % P;\n\t\t\t\t\ttmp = 1LL * tmp * co[i + aa + bb + cc + q][q] % P;\n\t\t\t\t\t\n\t\t\t\t\tup(ans, tmp);\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mod=1000000007ll;\nlong long v[10010],P[10010],rP[10010];\n\nvoid pre(int N)\n{\n  v[1]=1;\n  for(int i=2;i<N;i++){\n    v[i]=(mod-mod/i)*v[mod%i]%mod;\n  }\n  P[0]=rP[0]=1ll;\n  for(int i=1;i<N;i++){\n    P[i]=P[i-1]*i%mod;\n    rP[i]=rP[i-1]*v[i]%mod;\n  }\n}\n\nlong long C(int a,int b)\n{\n  return P[a]*rP[b]%mod*rP[a-b]%mod;\n}\n\nint main()\n{\n  pre(10010);\n  int n,a,b,c;\n  scanf(\"%d%d%d%d\",&n,&a,&b,&c);\n  if(b%2!=0){\n    printf(\"0\\n\");\n    return 0;\n  }\n  b/=2;\n  long long ans=0ll;\n  for(int x=0;x<=a;x++){\n    for(int y=0;(a-x)+3*y<=c;y++){\n      int m=a+y,r=c-(a-x)-3*y;\n      long long P=C(m,a)%mod*C(a,x)%mod,Q;\n      if(b==0){\n\tQ=(r==0?1:0);\n      }\n      else{\n\tQ=C(b+m,m)*C(r+b-1,b-1)%mod;\n      }\n      ans+=P*Q%mod;\n      ans%=mod;\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\n#define rep(i,a,b) for (rint i=(a),_E=(b); i<=_E; ++i)\n#define per(i,a,b) for (rint i=(a),_E=(b); i>=_E; --i)\n#define REP(i,n) for (rint i=0,_E=(n); i<_E; ++i)\n#define pb push_back\n#define cmin(x,y) (y<x?x=y:0)\n#define cmax(x,y) (y>x?x=y:0)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N = 10005;\nconst int mod = 1000000007;\nint n, a, b, c, n1, n2, n3, n4, K, res, now;\nint fac[N], rev[N];\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1ll * x * res % mod;\n\t\tx = 1ll * x * x % mod; p >>= 1;\n\t}\n\treturn res;\n}\n\ninline int C(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn 1ll * fac[n] * rev[m] % mod * rev[n-m] % mod;\n}\n\n//将n划分为m份，可以为空\ninline int calc(int n, int m) {\n\tif (!n && !m) return 1;\n\treturn C(n + m - 1, m - 1);\n}\n\nint main() {\n\tscanf(\"%d%d%d%d\", &n, &a, &b, &c);\n\tif (b & 1) return puts(\"0\"), 0;\n\tfac[0] = rev[0] = 1;\n\trep (i, 1, 10000) {\n\t\tfac[i] = 1ll * i * fac[i-1] % mod;\n\t\trev[i] = power(fac[i], mod - 2);\n\t}\n\trep (x, 0, min(a, c)) rep (y, 0, (c - x) / 3) {\n\t\tn1 = b / 2, n2 = y, n3 = a - x, n4 = x, K = c - x - 3 * y;\n\t\tif (n1 < 0 || n2 < 0 || n3 < 0 || n4 < 0 || K < 0) continue;\n\t\tnow = 1ll * fac[n1 + n2 + n3 + n4] * calc(K, n1) % mod;\n\t\tnow = 1ll * now * rev[n1] % mod * rev[n2] % mod;\n\t\tnow = 1ll * now * rev[n3] % mod * rev[n4] % mod;\n\t\tres = (res + now) % mod;\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n#include<vector>\n\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int library\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\nclass J123Pairs {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, a, b, c; cin >> n >> a >> b >> c;\n      combination comb = combination(10000);\n\n      mint ans = 0;\n      for(int p=0; p<=a; p++) {\n        int r = a-p;\n        for(int q=0; q<=n; q++) {\n          if (b%2!=0) continue;\n          int k = b/2;\n          int s = c - p - 3*q;\n          if (s<0) continue;\n          if (s>0 && k==0) continue;\n          mint now = 1;\n          now = comb.fact[r+p+q+k];\n          now *= comb.inv[r];\n          now *= comb.inv[p];\n          now *= comb.inv[q];\n          now *= comb.inv[k];\n          now *= comb.get(s-1+k, s);\n          ans += now;\n        }\n      }\n\n      cout << ans.x << endl;\n    }\n};\n\nsigned main() {\n  J123Pairs solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nconst ll MOD=1000000007LL;\nvector<ll> f,fi;\nll mpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1){\n\t\t\tres*=x;\n\t\t\tres%=MOD;\n\t\t}\n\t\tx=x*x%MOD;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n){\n\tf.resize(n+1);\n\tfi.resize(n+1);\n\tf[0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tf[i]=f[i-1]*i;\n\t\tf[i]%=MOD;\n\t}\n\tfi[n]=mpow(f[n],MOD-2);\n\tfor(ll i=n-1;i>=0;i--){\n\t\tfi[i]=fi[i+1]*(i+1LL);\n\t\tfi[i]%=MOD;\n\t}\n}\nll ncr(ll n,ll r){\n\tif(n<r){\n\t\treturn 0;\n\t}\n\tif(r==0){\n\t\treturn 1;\n\t}\n\treturn f[n]*fi[r]%MOD*fi[n-r]%MOD;\n}\nint main(){\n\tll n,A,B,C;cin>>n>>A>>B>>C;\n\tif(B%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tinit(3*n+10);\n\tll ans=0;\n\tfor(ll b=0;b<=n/2;b++){\n\t\tfor(ll d=0;d<=n/3;d++){\n\t\t\tll c=B/2;\n\t\t\tll a=A-b;\n\t\t\tll x=C-b-3*d;\n\t\t\tif(x<0||a<0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<\" \"<<x<<endl;\n\t\t\tll sum=a+b+c+d;\n\t\t\tll s=ncr(sum,a)*ncr(sum-a,b)%MOD*ncr(sum-a-b,c)%MOD;\n\t\t\tif(c>0){\n\t\t\t\ts*=ncr(x+c-1,x);\n\t\t\t\ts%=MOD;\n\t\t\t}\n\t\t\tans+=s;\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\tcout<<ans<<endl;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    Combination Co(2 * N);\n    int A, B, C; cin >> A >> B >> C;\n    if(B % 2){\n        Out(0);\n        return 0;\n    }\n    mint ans = 0;\n\n    REP(a, A + 1) REP(c, C / 3 + 1){\n        int d = C - (A - a + 3 * c);\n        if(d < 0) continue;\n        int b = B / 2;\n        mint n1 = Co.fact[A + b + c] * Co.invfact[a] * Co.invfact[b] * Co.invfact[c] * Co.invfact[A - a];\n        mint n2 = Co.nCr(b + d - 1, d);\n        ans += n1 * n2;\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nconst ll MOD=1000000007LL;\nvector<ll> f,fi;\nll mpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1){\n\t\t\tres*=x;\n\t\t\tres%=MOD;\n\t\t}\n\t\tx=x*x%MOD;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n){\n\tf.resize(n+1);\n\tfi.resize(n+1);\n\tf[0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tf[i]=f[i-1]*i;\n\t\tf[i]%=MOD;\n\t}\n\tfi[n]=mpow(f[n],MOD-2);\n\tfor(ll i=n-1;i>=0;i--){\n\t\tfi[i]=fi[i+1]*(i+1LL);\n\t\tfi[i]%=MOD;\n\t}\n}\nll ncr(ll n,ll r){\n\tif(n<r){\n\t\treturn 0;\n\t}\n\tif(r==0){\n\t\treturn 1;\n\t}\n\treturn f[n]*fi[r]%MOD*fi[n-r]%MOD;\n}\nint main(){\n\tll n,A,B,C;cin>>n>>A>>B>>C;\n\tinit(2*n+10);\n\tll ans=0;\n\tfor(ll b=0;b<=n/2;b++){\n\t\tfor(ll d=0;d<=n/3;d++){\n\t\t\tif(B%2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll c=B/2;\n\t\t\tll a=A-b;\n\t\t\tll x=C-b-3*d;\n\t\t\tif(x<0||(x>0&&c==0)||a<0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<\" \"<<x<<endl;\n\t\t\tll sum=a+b+c+d;\n\t\t\tll s=ncr(sum,a)*ncr(sum-a,b)%MOD*ncr(sum-a-b,c)%MOD*ncr(sum-a-b-c,d)%MOD;\n\t\t\ts*=ncr(x+c-1,x);\n\t\t\ts%=MOD;\n\t\t\tans+=s;\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\tcout<<ans<<endl;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long LL;\nLL fact[6000];\nLL invfact[6000];\n\nLL gcd(LL a, LL b){\n\tif(b == 0) return a;\n\treturn gcd(b,a%b);\n}\nLL powmod(LL a, LL n){\n\tif(n == 0) return 1;\n\tif(n % 2) return (a*powmod(a,n-1)) % MOD;\n\tLL c = powmod(a,n/2);\n\treturn (c*c) % MOD;\n}\nLL inv(LL a){\n\treturn powmod(a,MOD-2) % MOD;\n}\n\nint main(){\n\tint n, a, b, c;\n\tcin >> n >> a >> b >> c;\n\t/*for(int i = 0; i < 6000; i++){\n\t\tfor(int j = 0; j < 6000; j++){\n\t\t\tif(j > i){\n\t\t\t\tncr[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i == 0 || j == i){\n\t\t\t\tncr[i][j] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tncr[i][j] = ncr[i-1][j-1] + ncr[i-1][j];\n\t\t\tncr[i][j] %= MOD;\n\t\t}\n\t}*/\n\tfact[0] = 1;\n\tinvfact[0] = inv(fact[0]);\n\tfor(int i = 1; i < 6000; i++){\n\t\tfact[i] = fact[i-1]*i;\n\t\tfact[i] %= MOD;\n\t\tinvfact[i] = inv(fact[i]);\n\t}\n\tif(b % 2 == 1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint p2 = b/2;\n\tLL ans = 0;\n\tfor(int i = 0; i <= 5000; i++){ // #13's\n\t\tfor(int j = 0; j <= 5000; j++){ // #333's\n\t\t\tint n1 = a - i;\n\t\t\tint n3 = c - i - 3*j;\n\t\t\tif(n1 < 0 || n3 < 0) continue;\n\t\t\tif(p2 == 0 && n3 != 0) continue;\n\t\t\tint z = n1+j+i+p2;\n\t\t\tLL cur = 1;\n\t\t\tcur = (cur*fact[z]) % MOD;\n\t\t\tcur = (cur*invfact[n1]) % MOD;\n\t\t\tcur = (cur*invfact[j]) % MOD;\n\t\t\tcur = (cur*invfact[i]) % MOD;\n\t\t\tcur = (cur*invfact[p2]) % MOD;\n\t\t\tif(p2){\n\t\t\t\tcur = (cur*fact[p2-1+n3]) % MOD;\n\t\t\t\tcur = (cur*invfact[p2-1]) % MOD;\n\t\t\t\tcur = (cur*invfact[n3]) % MOD;\n\t\t\t}\n\t\t\tans += cur;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint A, B, C;\nlong long Mod = 1000000007, F[5010], InvF[5010], Res;\nlong long Pow(long long a, int b){\n    long long r = 1;\n    while(b){\n        if(b&1)r=r*a%Mod;\n        a=a*a%Mod;b>>=1;\n    }\n    return r;\n}\nlong long H(int a, int b){\n    if(!a&&!b)return 1;\n    return F[a+b-1] * InvF[b] * InvF[a-1];\n}\nint main(){\n    int n;\n    scanf(\"%d%d%d%d\",&n,&A,&B,&C);\n    int i, j;\n    F[0]=InvF[0]=1;\n    for(i=1;i<=5000;i++){\n        F[i]=F[i-1]*i%Mod;\n        InvF[i]=Pow(F[i],Mod-2);\n    }\n    if(B%2){\n        printf(\"0\\n\");\n        return 0;\n    }\n    for(i=0;i<=A;i++){\n        for(j=0;A-i+3*j<=C;j++){\n            int s = C - (A-i+3*j);\n            Res = (Res +F[A+j+B/2] * InvF[i] % Mod * InvF[j] % Mod * InvF[A-i] % Mod * InvF[B/2] % Mod * H(B/2,s))%Mod;\n        }\n    }\n    printf(\"%lld\\n\",Res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i)\nconst int mo = 1000000007;\nusing namespace std;\nint n, A, B, C; ll c[5010][5010];\nint main() {\n\tscanf(\"%d%d%d%d\", &n, &A, &B, &C);\n\tif (B & 1) { printf(\"0\"); return 0; }\n\trep(i, 0, n) c[i][0] = 1; ll ans = 0;\n\trep(i, 1, n) rep(j, 1, i) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mo;\n\trep(p, 0, min(A, C)) rep(q, 0, (C - p) / 3) {\n\t\tint x = A - p;\n\t\tll ret = c[x + p][x] % mo * c[x + p + q][q] % mo * c[x + p + q + B / 2][B / 2] % mo;\n\t\tif (B) ret = ret * c[C - p - 3 * q + B / 2 - 1][B / 2 - 1] % mo;\n\t\tans = (ans + ret) % mo;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 5005;\nconst int MOD = 1000000007;\n\nint cnk[maxn][maxn];\nint A, B, C;\nint n;\n\nll get(ll a, ll b)\n{\n    if (a == 0 && b > 0) return 0;\n    if (a == 0 && b == 0) return 0;\n    return cnk[a + b - 1][a - 1];\n}\n\nll calc(ll a, ll b, ll c, ll d)\n{\n//     cout << \"calc \" << a << ' ' << b << ' ' << c << ' ' << d << ' ' << endl;\n    if (d < 0) return 0;\n    if (a + b + c + d > n) return 0;\n    return (((ll)cnk[a + b][b] * cnk[a + b + c][c]) % MOD * cnk[a + b + c + d][d]) % MOD;\n}\n\nint main()\n{\n    scanf(\"%d%d%d%d\", &n, &A, &B, &C);\n    if (B % 2 == 1)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    cnk[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        cnk[i][0] = 1;\n        for (int j = 1; j <= i; j++) cnk[i][j] = (cnk[i - 1][j - 1] + cnk[i - 1][j]) % MOD;\n    }\n    ll answer = 0;\n    for (int x = 0; x <= C; x++)\n    {\n        for (int y = 0; 3 * y + x <= C; y++)\n        {\n            ll curans = calc(B / 2, y, C - 3 * y - x, A - (C - 3 * y - x));\n//             cout << x << ' ' << y << ' ' << curans << endl;\n            curans = ((ll)curans * get(B / 2, x)) % MOD;\n//             cout << curans << endl;\n            answer = (answer + curans) % MOD;\n        }\n    }\n    cout << answer << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = (int)1e9 + 7;\nint add(int x, int y)\n{\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y)\n{\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y)\n{\n\treturn ((ll)x * y) % MOD;\n}\n\nconst int N = 5002;\nint C[N][N];\nint n;\nint a, b, c;\nint A[N], B[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d%d\", &n, &a, &b, &c);\n\n\tif (b & 1)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tb /= 2;\n\n\tfor (int i = 0; i < N; i++)\n\t\tC[i][0] = C[i][i] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tC[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);\n\n\tif (b == 0)\n\t{\n\t\tA[0] = 1;\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i <= c; i++)\n\t\t\tA[i] = C[b - 1 + i][i];\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i <= c; i++)\n\t{\n\t\tif (A[i] == 0) continue;\n\t\tfor (int j = 0; j <= c && j <= a; j++)\n\t\t{\n\t\t\tif (i + j > c || (c - i - j) % 3 != 0) continue;\n\t\t\tint val = mult(A[i], C[b + a][a]);\n\t\t\tval = mult(val, C[a][j]);\n\t\t\tval = mult(val, C[a + b + (c - i - j) / 3][a + b]);\n\t\t\tans = add(ans, val);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n#include<vector>\n\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int library\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\nclass J123Pairs {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, a, b, c; cin >> n >> a >> b >> c;\n      combination comb = combination(10000);\n\n      mint ans = 0;\n      for(int p=0; p<=a; p++) {\n        int r = a-p;\n        for(int q=0; q<=n; q++) {\n          if (b%2!=0) continue;\n          int k = b/2;\n          int s = c - p - 3*q;\n          if (s<0) continue;\n          if (s>0 && k==0) continue;\n          mint now = 1;\n          now = comb.fact[r+p+q+k];\n          now *= comb.inv[r];\n          now *= comb.inv[p];\n          now *= comb.inv[q];\n          now *= comb.inv[k];\n          if (k>0) {\n            now *= comb.get(s-1+k, s);\n          }\n          ans += now;\n        }\n      }\n\n      cout << ans.x << endl;\n    }\n};\n\nsigned main() {\n  J123Pairs solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    Combination Co(2 * N);\n    int A, B, C; cin >> A >> B >> C;\n    if(B % 2){\n        Out(0);\n        return 0;\n    }\n    mint ans = 0;\n\n    REP(a, A + 1) REP(c, C / 3 + 1){\n        int d = C - (A - a + 3 * c);\n        if(d < 0) continue;\n        int b = B / 2;\n        mint n1 = Co.fact[A + b + c] * Co.invfact[a] * Co.invfact[b] * Co.invfact[c] * Co.invfact[A - a];\n        mint n2 = Co.nCr(b + d - 1, d);\n        if(b == 0 && d == 0) n2 = 1;\n        ans += n1 * n2;\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(int64_t __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(int64_t(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   int N, A, B, C; cin >> N >> A >> B >> C;\n   if (B & 1) {\n      cout << \"0\\n\";\n      return 0;\n   }\n   B >>= 1;\n   vector<Mint> fact(N+1);\n   fact[0] = 1; for (int i = 1; i <= N; ++i) fact[i] = fact[i - 1] * i;\n   vector<Mint> ifact(N+1);\n   ifact[N] = fact[N].inv(); for (int i = N; i > 0; --i) ifact[i - 1] = ifact[i] * i;\n   Mint ans = 0;\n   for (int x = 0; x <= min(A, C); ++x) {\n      for (int y = 0; x + 3 * y <= C; ++y) {\n         int z = C - x - 3 * y;\n         Mint ways = (B == 0 ? Mint(!z) : fact[z + B - 1] * ifact[B - 1] * ifact[z]);\n         ways *= fact[x + y + B + A - x] * ifact[x] * ifact[y] * ifact[B] * ifact[A - x];\n         ans += ways;\n      }\n   }\n   cout << ans << '\\n';\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 100000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nint main()\n{\n\tinvinit();\n\tint n, a, b, c;\n\tscanf(\"%d%d%d%d\", &n, &a, &b, &c);\n\tif (b % 2 != 0)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i <= c / 3; i++)\n\t{\n\t\tfor (int j = 0; j <= min(a, c - i * 3); j++)\n\t\t{\n\t\t\tll t = com(a + b / 2 + i, i)*com(a + b / 2, a) % mod*com(a, j) % mod;\n\t\t\tif (b > 0)t *= com(c - i * 3 - j + b / 2 - 1, b / 2 - 1);\n\t\t\telse if (c != i * 3 + j)t = 0;\n\t\t\tans = (ans + t) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD=1000000007;\nint fact[10001];\nint ifact[10001];\n\nint powmod(int a, int b)\n{\n    int ret=1;\n    for(; b>0; b/=2)\n    {\n        if(b&1)\n            ret=1LL*ret*a%MOD;\n        a=1LL*a*a%MOD;\n    }\n    return ret;\n}\n\nint C(int n, int k)\n{\n    return 1LL*fact[n]*ifact[k]%MOD*ifact[n-k]%MOD;\n}\n\nint solve(int a, int b, int c, int d, int f)\n{\n    if(c==0)\n    {\n        if(d==0)\n            return C(a+b, a);\n        return 0;\n    }\n    int e=C(d+c-1, d);\n    return 1LL*e*C(a+b+c+f, a+b+c)%MOD*C(a+b+c, a+b)%MOD*C(a+b, a)%MOD;\n}\n\nint main()\n{\n    fact[0]=1;\n    ifact[0]=1;\n    for(int i=1; i<=10000; i++)\n    {\n        fact[i]=1LL*fact[i-1]*i%MOD;\n        ifact[i]=powmod(fact[i], MOD-2);\n    }\n    int N, A, B, C;\n    scanf(\"%d%d%d%d\", &N, &A, &B, &C);\n    if(B%2==1)\n        return printf(\"0\\n\"), 0;\n    int ans=0;\n    for(int c=0; c<=C; c+=3)\n        for(int i=0; i<=min(A, C-c); i++)\n            ans=(ans+solve(i, A-i, B/2, C-c-i, c/3))%MOD;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr lint MOD = 1000000007;\nvector<lint> fac, facInv, inv;\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\nlint nPr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return fac[n] * facInv[n-r] % MOD;\n}\nlint power(lint x, lint n, lint mod=MOD)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= mod;\n        (x *= x) %= mod;\n       n >>= 1;\n    }\n   return ans;\n}\nlint doublefac(lint n)\n{\n    if (n < 0) return 0;\n    lint k = (n + 1) / 2;\n    if (n & 1) return fac[k * 2] * power(facInv[2], k) % MOD * power(fac[k], MOD - 2) % MOD;\n    else return fac[k] * power(facInv[2], k) % MOD;\n}\nint main()\n{\n    int N, A, B, C;\n    cin >> N >> A >> B >> C;\n    facInit(N * 2);\n    if (B % 2)\n    {\n        puts(\"0\");\n        return 0;\n    }\n    lint ret = 0;\n    lint c = nCr(A + B / 2, A);\n\n    REP(i, A + 1) // 1をつつむ3の数\n    {\n        int j = C - i; // 残った3の数\n        if (j < 0) continue;\n        REP(k, j / 3 + 1) // 3のみの塊の数\n        {\n            int l = j - 3 * k; // 2に関与できる3の数\n            ret += c * nCr(A, i) % MOD * nCr(l + B / 2 - 1, l) % MOD * nCr(A + B / 2 + k, k) % MOD;\n        }\n    }\n    cout << ret % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nconst int NUM_=400001;\nstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\nll mo=1000000007;\nll combi(ll N_, ll C_) {\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\nll hcomb(int P_,int Q_) { return (P_==0&&Q_==0)?1:combi(P_+Q_-1,Q_);}\nint N,A,B,C;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y;;\n\t\n\tcombi(0,0);\n\t\n\tcin>>N>>A>>B>>C;\n\tll ret=0;\n\tfor(int p=0;p<=min(A,C);p++) for(int q=0;p+3*q<=C;q++) {\n\t\tint s1=A-p;\n\t\tint s2=B/2;\n\t\tint s3=C-(p+3*q);\n\t\tll tot=fact[p+q+s1+s2]*factr[s1]%mo*factr[p]%mo*factr[q]%mo*factr[s2]%mo;\n\t\ttot*=hcomb(s2,s3);\n\t\tret+=tot%mo;\n\t}\n\tif(B%2) ret=0;\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define DN(en, ka) (F[en] * pot(F[ka] * F[en - ka] % Q, -1) % Q)\nusing namespace std;\ntypedef long long int ll;\nconst ll N = 1 << 16, Q = 1000000007;\nll n, a, b, c, res, F[N] = {1};\nint pot(ll a, ll b){\n  a %= Q;\n  if(b < 0)\n    return pot(pot(a, -b), Q - 2);\n  if(b == 0)\n    return 1;\n  if(b % 2 == 1)\n    return ((ll)pot(a, b - 1) * a) % Q;\n  ll t = pot(a, b / 2);\n  return (t * t) % Q;\n}\nint solve(int x, int y){\n  if(b % 2 == 1 || c < y * 3 + a - x || (b == 0 && ((c - a + x) % 3 != 0 || c != y * 3 + a - x)))\n    return 0;\n  ll t = c - a + x - 3 * y,\n    l = F[a + y + b / 2],\n    m = F[x] * F[y] % Q * F[a - x] % Q * F[b / 2] % Q,\n    k = b ? DN(b / 2 + t - 1, t) : 1;\n  return l * pot(m, -1) % Q * k % Q;\n}  \nint main(){\n  for(int i = 1;i < N;i++)\n    F[i] = (F[i - 1] * i) % Q;\n  cin >> n >> a >> b >> c;\n  for(int i = 0;i <= a;i++)\n    for(int j = 0;j <= c / 3;j++){\n      res += solve(i, j);\n    }\n  cout << res % Q << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, A, B, C;\nint nCr[5100][2600];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  nCr[0][0] = 1;\n  for (int i=1; i<5100; i++) {\n    nCr[i][0] = 1;\n    for (int j=1; j<=min(i, 2600-1); j++) {\n      nCr[i][j] = nCr[i-1][j-1]+nCr[i-1][j];\n      if (nCr[i][j] >= MOD) nCr[i][j] -= MOD;\n    }\n  }\n  cin >> N >> A >> B >> C;\n  if (B%2) {\n    cout << 0 << \"\\n\";\n    return 0;\n  }\n  B /= 2;\n  int s = 0;\n  rep(y, A+1) {\n    rep(z, N+1) {\n      int rest = C-(3*z+y);\n      if (rest < 0) break;\n      if (B == 0 && rest != 0) continue;\n      int one = y+A-y;\n      int two = B*2;\n      int three = (3*z+y)+rest;\n      assert(one == A && two == B*2 && three == C);\n      int p = (1LL*((1LL*nCr[A+z+B][z]*nCr[A+B][B])%MOD)*nCr[A][y])%MOD;\n      if (B > 0) p = (1LL*p*nCr[rest+B-1][B-1]) % MOD;\n      s = (s+p) % MOD;\n    }\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef __int128_t ll;\ntypedef long double ld;\n\nusing namespace std;\n\n\nvector<pair<ll, ll> > vv;\nconst ll INF = 1e25;\n\nint n;\nll dp[2][5100];\nll dp2[2][5100];\n\nvoid out(ll a) {\n\tvector<int> o;\n\twhile (a != 0)\n\t\to.push_back(a % 10), a /= 10;\n\treverse(o.begin(), o.end());\n\tfor (int i: o)\n\t\tcout << i;\n}\n\n\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tvv.push_back(make_pair(l + r, l));\n\t}\n\tsort(vv.begin(), vv.end());\n\treverse(vv.begin(), vv.end());\n\tfor (int i = 0; i <= n; ++i)\n\t\tdp[0][i] = dp[1][i] = INF;\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < (int)vv.size(); ++i) {\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tdp2[0][j] = dp2[1][j] = INF;\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tdp2[0][j + 1] = min(dp2[0][j + 1], dp[0][j] + vv[i].first * j + (vv[i].first - vv[i].second));\n\t\t\tdp2[0][j] = min(dp2[0][j], dp[0][j] + vv[i].first * (i - j) + (vv[i].second));\n\t\t}\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\t\tdp[0][j] = dp2[0][j], dp[1][j] = dp2[1][j];\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tdp2[1][j + 1] = min(dp2[1][j + 1], dp[1][j] + vv[i].first * j + (vv[i].first - vv[i].second));\n\t\t\tdp2[1][j] = min(dp2[1][j], dp[1][j] + vv[i].first * (i - j) + (vv[i].second));\n\t\t\tdp2[1][j] = min(dp2[1][j], dp[0][j] + ((n - 1) / 2) * vv[i].first);\n\t\t}\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tdp[0][j] = dp2[0][j], dp[1][j] = dp2[1][j];\n\t\t}\n\t}\n\tif (n % 2 == 0) {\n\t\tout(dp[0][n / 2]);\n\t}\n\telse {\n\t\tout(dp[1][n / 2]);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n \ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\nnamespace {\n  const int mo = 1e9 + 7;\n  inline int add(int x, int y) {\n    if((x += y) >= mo) x -= mo;\n    return x;\n  }\n  inline int sub(int x, int y) {\n    if((x -= y) < 0) x += mo;\n    return x;\n  }\n  inline int mul(int x, int y) {\n    return 1LL * x * y % mo;\n  }\n  inline int pw(int a, int k) {\n    int ans = 1;\n    for (; k; k >>= 1, a = mul(a, a))\n      if (k & 1) ans = mul(ans, a);\n    return ans;\n  }\n  inline int inv(int n) {\n    return pw(n, mo - 2);\n  }\n}\n\nnamespace binom {\n  const int NN = 3e5 + 233;\n  int fac[NN], ifac[NN];\n  inline void init(void) {\n    int m = 3e5;\n    fac[0] = 1;\n    for (int i = 1; i <= m; i ++)\n      fac[i] = mul(fac[i - 1], i);\n    ifac[m] = inv(fac[m]);\n    for (int i = m - 1; i >= 0; i --)\n      ifac[i] = mul(ifac[i + 1], i + 1);\n  }\n\n  inline int Bi(int n, int m) {\n    if (n < 0) return 0;\n    else if (m == n || m == 0) return 1;\n    else return mul(fac[n], mul(ifac[m], ifac[n - m]));\n  }\n}\nusing namespace binom;\nint A, B, C, N, ans;\n\n/*\n  1.1\n  2.31\n  3.333\n  4.22\n  4.2332\n  4.23332\n*/\ninline int cao(int a, int b, int c, int d) {\n  return mul(mul(Bi(a + b + c + d, a), Bi(b + c + d, b)),\n             mul(Bi(c + d, c), Bi(d, d)));\n}\n\nint main(void) {\n  init();\n  read(N); read(A); read(B); read(C);\n  for (int two = 0; two <= A; two ++)\n    for (int three = 0; three <= C / 3; three ++) {\n      int one = A - two;\n      if (B % 2 == 1) continue;\n      int four = B / 2;\n      int resC = C - three * 3 - two;\n      if (resC < 0) continue;\n      auto gao = [](int n, int m) {\n        if (n == 0) return 1;\n        if (m == 0) return 0;\n        return Bi(n + m - 1, m - 1);\n      };\n       // cout << one << \" \" << two << \" \" << three << \" \" << four << \" \" << mul(fac[one + two + three + four],\n       //                                                                        gao(resC, four)) << \"\\n\";\n       ans = add(ans, mul(cao(one, two, three, four),\n                         gao(resC, four)));\n    }\n  cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\n#define rep(i,a,b) for (rint i=(a),_E=(b); i<=_E; ++i)\n#define per(i,a,b) for (rint i=(a),_E=(b); i>=_E; --i)\n#define REP(i,n) for (rint i=0,_E=(n); i<_E; ++i)\n#define pb push_back\n#define cmin(x,y) (y<x?x=y:0)\n#define cmax(x,y) (y>x?x=y:0)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N = 10005;\nconst int mod = 1000000007;\nint n, a, b, c, n1, n2, n3, n4, K, res, now;\nint fac[N], rev[N];\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1ll * x * res % mod;\n\t\tx = 1ll * x * x % mod; p >>= 1;\n\t}\n\treturn res;\n}\n\ninline int C(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn 1ll * fac[n] * rev[m] % mod * rev[n-m] % mod;\n}\n\n//将n划分为m份，可以为空\ninline int calc(int n, int m) {\n\treturn C(n + m - 1, m - 1);\n}\n\nint main() {\n\tscanf(\"%d%d%d%d\", &n, &a, &b, &c);\n\tif (b & 1) return puts(\"0\"), 0;\n\tfac[0] = rev[0] = 1;\n\trep (i, 1, 10000) {\n\t\tfac[i] = 1ll * i * fac[i-1] % mod;\n\t\trev[i] = power(fac[i], mod - 2);\n\t}\n\trep (x, 0, min(a, c)) rep (y, 0, (c - x) / 3) {\n\t\tn1 = b / 2, n2 = y, n3 = a - x, n4 = x, K = c - x - 3 * y;\n\t\tif (n1 < 0 || n2 < 0 || n3 < 0 || n4 < 0 || K < 0) continue;\n\t\tnow = 1ll * fac[n1 + n2 + n3 + n4] * calc(K, n1) % mod;\n\t\tnow = 1ll * now * rev[n1] % mod * rev[n2] % mod;\n\t\tnow = 1ll * now * rev[n3] % mod * rev[n4] % mod;\n\t\tres = (res + now) % mod;\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int mod = 1e9 + 7;\n\nlint fact[5005], invf[5005];\nlint dp[2505][5005];\n\nlint ipow(lint x, lint p){\n\tlint ret = 1, piv = x % mod;\n\twhile(p){\n\t\tif(p&1) ret *= piv;\n\t\tpiv *= piv;\n\t\tret %= mod;\n\t\tpiv %= mod;\n\t\tp >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nlint bino(int x, int y){\n\tif(x < y) return 0;\n\treturn fact[x] * (invf[y] * invf[x-y] % mod) % mod;\n}\n\nint n, a, b, c;\n\nint main(){\n\tcin >> n >> a >> b >> c;\n\tif(b % 2 == 1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tb /= 2;\n\tfact[0] = invf[0] = 1;\n\tfor(int i=1; i<=n; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tinvf[i] = ipow(fact[i], mod - 2);\n\t}\n\tlint ret = 0;\n\tdp[0][0] = 1;\n\tfor(int i=1; i<=b; i++){\n\t\tlint sum = 0;\n\t\tfor(int j=0; j<=c; j++){\n\t\t\tsum += dp[i-1][j];\n\t\t\tsum %= mod;\n\t\t\tdp[i][j] = sum;\n\t\t}\n\t}\n\tfor(int j=0; j<=c; j++){\n\t\tfor(int k=0; k<=a; k++){\n\t\t\tif((c - j - k) >= 0 && (c - j - k) % 3 == 0){\n\t\t\t\tint cnt = (c - j - k) / 3;\n\t\t\t\tret += dp[b][j] * ((bino(a, k) * bino(a + cnt + b, a + cnt) % mod) * bino(a + cnt, a) % mod);\n\t\t\t\tret %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\n#define rep(i,a,b) for (rint i=(a),_E=(b); i<=_E; ++i)\n#define per(i,a,b) for (rint i=(a),_E=(b); i>=_E; --i)\n#define REP(i,n) for (rint i=0,_E=(n); i<_E; ++i)\n#define pb push_back\n#define cmin(x,y) (y<x?x=y:0)\n#define cmax(x,y) (y>x?x=y:0)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N = 10005;\nconst int mod = 1000000007;\nint n, a, b, c, n1, n2, n3, n4, K, res, now;\nint fac[N], rev[N];\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1ll * x * res % mod;\n\t\tx = 1ll * x * x % mod; p >>= 1;\n\t}\n\treturn res;\n}\n\ninline int C(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn 1ll * fac[n] * rev[m] % mod * rev[n-m] % mod;\n}\n\n//将n划分为m份，可以为空\ninline int calc(int n, int m) {\n\tif (!n && !m) return 1;\n\treturn C(n + m - 1, m - 1);\n}\n\nint main() {\n\tscanf(\"%d%d%d%d\", &n, &a, &b, &c);\n\tif (b & 1) return puts(\"0\"), 0;\n\tfac[0] = rev[0] = 1;\n\trep (i, 1, 10000) {\n\t\tfac[i] = 1ll * i * fac[i-1] % mod;\n\t\trev[i] = power(fac[i], mod - 2);\n\t}\n\trep (x, 0, min(a, c)) rep (y, 0, (c - x) / 3) {\n\t\tn1 = b / 2, n2 = y, n3 = a - x, n4 = x, K = c - x - 3 * y;\n\t\tif (n1 < 0 || n2 < 0 || n3 < 0 || n4 < 0 || K < 0) continue;\n\t\tnow = 1ll * fac[n1 + n2 + n3 + n4] * calc(K, n1) % mod;\n\t\tnow = 1ll * now * rev[n1] % mod * rev[n2] % mod;\n\t\tnow = 1ll * now * rev[n3] % mod * rev[n4] % mod;\n\t\tres = (res + now) % mod;\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n  \n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\n\n\n\ntemplate<typename M>\nstruct Enumeration{\n  static vector<M> fact,finv,invs;\n  \n  static void init(int n){\n    int m=fact.size();\n    if(n<m) return;\n    \n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n    \n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n  \n  static M C(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static M H(int n,int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static M S(int n,int k){\n    M res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      M tmp=C(k,i)*M(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<M> > D(int n,int m){\n    vector<vector<M> > dp(n+1,vector<M>(m+1,0));\n    dp[0][0]=M(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static M B(int n,int k){\n    if(n==0) return M(1);\n    k=min(k,n);\n    init(k);    \n    vector<M> dp(k+1);\n    dp[0]=M(1);\n    for(int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);    \n    M res;\n    for(int i=1;i<=k;i++)\n      res+=M(i).pow(n)*finv[i]*dp[k-i];    \n    return res;\n  }\n\n  static M montmort(int n){\n    M res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static M LagrangePolynomial(vector<M> &y,M t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    M num(1);\n    for(int i=0;i<=n;i++) num*=t-M(i);\n    M res;\n    for(int i=0;i<=n;i++){\n      M tmp=y[i]*num/(t-M(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs = vector<M>();\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,a,b,c;\n  cin>>n>>a>>b>>c;  \n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  E::init(1e5);\n  \n  M ans{0};\n  for(int x=0;x<=c;x++){\n    for(int y=0;y*3<=c;y++){\n      int w=a-x;\n      int z=b/2;\n      int k=c-(x+y*3);\n      if(w<0||z<0||k<0) continue;\n      if(w+x==a&&z*2==b&&x+y*3+k==c){\n        M res=E::H(z,k);\n        \n        int sum=w+x+y+z;        \n        res*=E::fact[sum];\n        res*=E::finv[w];\n        res*=E::finv[x];\n        res*=E::finv[y];\n        res*=E::finv[z];\n        ans+=res;\n      }\n    }\n  }\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  }
]