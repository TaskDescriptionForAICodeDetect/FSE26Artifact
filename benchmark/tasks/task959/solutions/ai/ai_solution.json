[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nlong long dp[201][201][201];\n\nint main() {\n    int N, A, B, C;\n    scanf(\"%d %d %d %d\", &N, &A, &B, &C);\n\n    dp[0][0][0] = 1;\n\n    for (int a = 0; a <= A; a++) {\n        for (int b = 0; b <= B; b++) {\n            for (int c = 0; c <= C; c++) {\n                if (a + b + c >= N) continue;\n\n                int k = 2 * N - 2 * (a + b + c);\n                \n                // Pair with difference 1\n                if (a < A) {\n                    for (int i = 1; i < k; i++) {\n                        dp[a+1][b][c] = (dp[a+1][b][c] + dp[a][b][c] * (k - i)) % MOD;\n                    }\n                }\n                \n                // Pair with difference 2\n                if (b < B) {\n                    for (int i = 1; i < k; i++) {\n                        dp[a][b+1][c] = (dp[a][b+1][c] + dp[a][b][c] * (k - i)) % MOD;\n                    }\n                }\n                \n                // Pair with difference 3\n                if (c < C) {\n                    for (int i = 1; i < k; i++) {\n                        dp[a][b][c+1] = (dp[a][b][c+1] + dp[a][b][c] * (k - i)) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", dp[A][B][C]);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAXN 6000\n\nlong long dp[MAXN][MAXN][4];\nlong long fact[MAXN * 2 + 1];\nlong long inv_fact[MAXN * 2 + 1];\n\nlong long power(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid precompute_factorials(int max_n) {\n    fact[0] = 1;\n    for (int i = 1; i <= max_n; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    inv_fact[max_n] = power(fact[max_n], MOD - 2);\n    for (int i = max_n - 1; i >= 0; i--) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nlong long comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    int N, A, B, C;\n    scanf(\"%d %d %d %d\", &N, &A, &B, &C);\n    precompute_factorials(2 * N);\n\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            for (int k = 0; k <= 3; k++) {\n                if (dp[i][j][k] == 0) continue;\n                if (i + 1 <= N && k + 1 <= 3) {\n                    dp[i + 1][j][k + 1] = (dp[i + 1][j][k + 1] + dp[i][j][k]) % MOD;\n                }\n                if (j + 1 <= N && k + 2 <= 3) {\n                    dp[i][j + 1][k + 2] = (dp[i][j + 1][k + 2] + dp[i][j][k]) % MOD;\n                }\n                if (k + 3 <= 3) {\n                    dp[i][j][k + 3] = (dp[i][j][k + 3] + dp[i][j][k]) % MOD;\n                }\n            }\n        }\n    }\n\n    long long res = dp[A][B][0] * fact[A] % MOD;\n    res = res * fact[B] % MOD;\n    res = res * fact[C] % MOD;\n    res = res * power(2, B) % MOD;\n    res = res * power(2, C) % MOD;\n\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nlong long fact[200005], inv_fact[200005];\n\nlong long power(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute() {\n    fact[0] = 1;\n    for (int i = 1; i <= 200000; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    inv_fact[200000] = power(fact[200000], MOD - 2);\n    for (int i = 199999; i >= 0; i--) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nlong long comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    precompute();\n    int N, A, B, C;\n    cin >> N >> A >> B >> C;\n    \n    long long res = 0;\n    for (int t = 0; t <= B; t++) {\n        long long ways = comb(B, t) * comb(A + C, A) % MOD;\n        int k = A + C + t;\n        if (2 * k > N) continue;\n        long long temp = fact[2 * k] * power(2, k) % MOD;\n        temp = temp * comb(N, 2 * k) % MOD;\n        temp = temp * fact[N - 2 * k] % MOD;\n        res = (res + ways * temp) % MOD;\n    }\n    cout << res << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:30:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n    static long[][][][] dp;\n    static long[][] comb;\n    static int N, A, B, C;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        N = sc.nextInt();\n        A = sc.nextInt();\n        B = sc.nextInt();\n        C = sc.nextInt();\n        \n        int max = 2 * N;\n        comb = new long[max + 1][max + 1];\n        comb[0][0] = 1;\n        for (int i = 1; i <= max; i++) {\n            comb[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n            }\n        }\n        \n        dp = new long[A+1][B+1][C+1][3*N+1];\n        dp[0][0][0][0] = 1;\n        \n        for (int a = 0; a <= A; a++) {\n            for (int b = 0; b <= B; b++) {\n                for (int c = 0; c <= C; c++) {\n                    for (int used = 0; used <= 3*N; used++) {\n                        if (dp[a][b][c][used] == 0) continue;\n                        int rem = 2*N - used;\n                        if (rem == 0) continue;\n                        \n                        if (a < A) {\n                            long ways = rem;\n                            if (rem >= 2) {\n                                ways = rem * (rem - 1) % MOD;\n                            }\n                            dp[a+1][b][c][used+2] = (dp[a+1][b][c][used+2] + dp[a][b][c][used] * ways % MOD) % MOD;\n                        }\n                        \n                        if (b < B && rem >= 2) {\n                            long ways = 2 * (rem - 1) % MOD;\n                            ways = ways * rem % MOD;\n                            dp[a][b+1][c][used+2] = (dp[a][b+1][c][used+2] + dp[a][b][c][used] * ways % MOD) % MOD;\n                        }\n                        \n                        if (c < C && rem >= 2) {\n                            long ways = rem * (rem - 1) % MOD;\n                            dp[a][b][c+1][used+2] = (dp[a][b][c+1][used+2] + dp[a][b][c][used] * ways % MOD) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n        \n        long ans = dp[A][B][C][2*N];\n        ans = ans * pow(2, B) % MOD;\n        System.out.println(ans);\n    }\n    \n    static long pow(long a, long b) {\n        long res = 1;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % MOD;\n            }\n            a = a * a % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 23:30:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    static final int MOD = 1_000_000_007;\n    \n    public static void solve(int N, int A, int B, int C) {\n        long[][] dp = new long[N + 1][N + 1];\n        dp[0][0] = 1;\n        \n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j <= N; j++) {\n                if (dp[i][j] == 0) continue;\n                \n                // Try 1-diff pair\n                if (i < A) {\n                    for (int k = 1; k <= 2*N - 1; k++) {\n                        if ((k & 1) == 1 && (k + 1 <= 2*N)) {\n                            dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD;\n                        }\n                    }\n                }\n                \n                // Try 2-diff pair\n                if (j < B) {\n                    for (int k = 1; k <= 2*N - 2; k++) {\n                        if ((k & 1) == 1 && (k + 2 <= 2*N)) {\n                            dp[i][j+1] = (dp[i][j+1] + dp[i][j]) % MOD;\n                        }\n                    }\n                }\n                \n                // Try 3-diff pair\n                if (i + j < N) {\n                    for (int k = 1; k <= 2*N - 3; k++) {\n                        if ((k & 1) == 1 && (k + 3 <= 2*N)) {\n                            dp[i][j+1] = (dp[i][j+1] + dp[i][j]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp[A][B]);\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int A = Integer.parseInt(st.nextToken());\n        int B = Integer.parseInt(st.nextToken());\n        int C = Integer.parseInt(st.nextToken());\n        \n        solve(N, A, B, C);\n    }\n}",
    "timestamp": "2025-08-05 23:30:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 1e9 + 7;\n\nll solve(int N, int A, int B, int C) {\n    vector<vector<vector<vector<ll>>>> dp(2*N+1, \n        vector<vector<vector<ll>>>(A+1, \n            vector<vector<ll>>(B+1, \n                vector<ll>(C+1, 0))));\n    \n    dp[0][0][0][0] = 1;\n    \n    for (int num = 1; num <= 2*N; num++) {\n        for (int a = 0; a <= A; a++) {\n            for (int b = 0; b <= B; b++) {\n                for (int c = 0; c <= C; c++) {\n                    if (dp[num-1][a][b][c] == 0) continue;\n                    \n                    for (int paired = num+1; paired <= 2*N; paired++) {\n                        int diff = paired - num;\n                        \n                        if (diff == 1 && a < A) {\n                            dp[paired][a+1][b][c] = (dp[paired][a+1][b][c] + \n                                dp[num-1][a][b][c]) % MOD;\n                        }\n                        else if (diff == 2 && b < B) {\n                            dp[paired][a][b+1][c] = (dp[paired][a][b+1][c] + \n                                dp[num-1][a][b][c]) % MOD;\n                        }\n                        else if (diff == 3 && c < C) {\n                            dp[paired][a][b][c+1] = (dp[paired][a][b][c+1] + \n                                dp[num-1][a][b][c]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return dp[2*N][A][B][C];\n}\n\nint main() {\n    int N, A, B, C;\n    cin >> N >> A >> B >> C;\n    cout << solve(N, A, B, C) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:30:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef factorial(n):\n    result = 1\n    for i in range(2, n+1):\n        result = (result * i) % MOD\n    return result\n\ndef count_ways(A, B, C):\n    N = A + B + C\n    num_ways = factorial(A + B + C)\n    num_ways = (num_ways * pow(factorial(A), MOD-2, MOD)) % MOD\n    num_ways = (num_ways * pow(factorial(B), MOD-2, MOD)) % MOD\n    num_ways = (num_ways * pow(factorial(C), MOD-2, MOD)) % MOD\n    return num_ways\n\n# Example usage:\n# A, B, C = map(int, input().split())\n# print(count_ways(A, B, C))",
    "timestamp": "2025-08-13 15:29:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class SnukePairs {\n    static final int MOD = 1000000007;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // Read inputs\n        int N = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        int C = sc.nextInt();\n\n        // Total number of ways, using dynamic programming\n        long[][][][] dp = new long[N + 1][A + 1][B + 1][C + 1];\n        dp[0][0][0][0] = 1;\n\n        for (int i = 0; i < N; i++) {\n            for (int a = 0; a <= A; a++) {\n                for (int b = 0; b <= B; b++) {\n                    for (int c = 0; c <= C; c++) {\n                        long count = dp[i][a][b][c];\n                        if (a < A) dp[i + 1][a + 1][b][c] = (dp[i + 1][a + 1][b][c] + count) % MOD;\n                        if (b < B) dp[i + 1][a][b + 1][c] = (dp[i + 1][a][b + 1][c] + count) % MOD;\n                        if (c < C) dp[i + 1][a][b][c + 1] = (dp[i + 1][a][b][c + 1] + count) % MOD;\n                    }\n                }\n            }\n        }\n\n        // Output the number of ways % 10^9+7\n        System.out.println(dp[N][A][B][C]);\n    }\n}",
    "timestamp": "2025-08-13 15:30:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#define MOD 1000000007\n\nlong long factorial[200001];\nlong long invFactorial[200001];\n\nlong long modExp(long long base, long long exp, long long m) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = result * base % m;\n        }\n        base = base * base % m;\n        exp /= 2;\n    }\n    return result;\n}\n\nlong long comb(int n, int k, long long m) {\n    if (n < k) {\n        return 0;\n    }\n    long long result = factorial[n] * invFactorial[k] % m;\n    result = result * invFactorial[n - k] % m;\n    return result;\n}\n\nint main() {\n    int N, A, B, C;\n    scanf(\"%d %d %d\", &N, &A, &B, &C);\n\n    factorial[0] = 1;\n    for (int i = 1; i <= 2 * N; i++) {\n        factorial[i] = factorial[i - 1] * i % MOD;\n    }\n\n    invFactorial[2 * N] = modExp(factorial[2 * N], MOD - 2, MOD);\n    for (int i = 2 * N - 1; i >= 0; i--) {\n        invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;\n    }\n\n    long long waysA = comb(N, A, MOD);\n    long long waysB = comb(2 * N - 2 * A, B, MOD);\n    long long waysC = comb(2 * N - 2 * A - 2 * B, C, MOD);\n\n    long long result = waysA * waysB % MOD * waysC % MOD;\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 15:30:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\n// Function to compute factorial modulo MOD\nstd::vector<long long> factorial(int n) {\n    std::vector<long long> fact(n + 1, 1);\n    for (int i = 2; i <= n; ++i) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    return fact;\n}\n\n// Function to compute modular inverse using Fermat's Little Theorem\nlong long modInverse(long long a, int m) {\n    long long res = 1;\n    int power = m - 2;  // m is prime\n    while (power) {\n        if (power % 2) {\n            res = (res * a) % m;\n        }\n        a = (a * a) % m;\n        power /= 2;\n    }\n    return res;\n}\n\n// Function to compute binomial coefficient C(n, k) % MOD\nlong long binomial(int n, int k, const std::vector<long long>& fact) {\n    if (k > n) return 0;\n    return fact[n] * modInverse(fact[k], MOD) % MOD * modInverse(fact[n - k], MOD) % MOD;\n}\n\n// Main function to solve the problem\nint main() {\n    int A, B, C;\n    std::cin >> A >> B >> C;\n    int N = A + B + C;\n\n    // Precompute factorials\n    auto fact = factorial(2 * N);\n\n    // Calculate the number of ways to pair up with the given conditions\n    long long result = binomial(N, A, fact) * binomial(N - A, B, fact) % MOD;\n\n    std::cout << result << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:30:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, A, B, C):\n    MOD = 10**9 + 7\n    \n    @functools.lru_cache(None)\n    def dp(mask, a, b, c):\n        if mask == (1 << (2*N)) - 1:\n            return 1 if a == A and b == B and c == C else 0\n        \n        result = 0\n        for i in range(2*N):\n            if mask & (1 << i):\n                continue\n            \n            for j in range(i+1, 2*N):\n                if mask & (1 << j):\n                    continue\n                \n                diff = abs(j - i + 1)\n                if diff > 3:\n                    continue\n                \n                new_mask = mask | (1 << i) | (1 << j)\n                \n                if diff == 1:\n                    result += dp(new_mask, a+1, b, c)\n                elif diff == 2:\n                    result += dp(new_mask, a, b+1, c)\n                else:\n                    result += dp(new_mask, a, b, c+1)\n                \n                result %= MOD\n        \n        return result\n    \n    return dp(0, 0, 0, 0)",
    "timestamp": "2025-08-13 15:30:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N, A, B, C = map(int, sys.stdin.readline().split())\n    fact = [1] * (2*N + 1)\n    inv_fact = [1] * (2*N + 1)\n    for i in range(1, 2*N + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[2*N] = pow(fact[2*N], MOD-2, MOD)\n    for i in range(2*N -1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(a, b):\n        if a < 0 or b < 0 or a < b:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n    \n    res = 0\n    for a in range(A, N - B - C + 1):\n        for b in range(B, N - a - C + 1):\n            c = N - a - b\n            if c < C:\n                continue\n            # Compute the term for current a, b, c\n            # First part: (2N)! / (2^N)\n            term = fact[2*N] * pow(2, N, MOD) % MOD\n            # Multiply by 1/(a! b! c!)\n            term = term * inv_fact[a] % MOD\n            term = term * inv_fact[b] % MOD\n            term = term * inv_fact[c] % MOD\n            # Multiply by 2^b\n            term = term * pow(2, b, MOD) % MOD\n            # Multiply by 3^c\n            term = term * pow(3, c, MOD) % MOD\n            # Multiply by comb(a + 2b + 3c, a) * comb(2b + 3c, 2b)\n            ways = comb(a + 2*b + 3*c, a) * comb(2*b + 3*c, 2*b) % MOD\n            term = term * ways % MOD\n            res = (res + term) % MOD\n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 15:32:58"
  }
]