[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ALL(x) x.begin(), x.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nusing ll = long long;\nusing lld = long double;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing PII = pair<int, int>;\nrandom_device rnd;\nmt19937 mt(rnd());\n\nconst int IINF = 1 << 30;\nconst ll INF = 1ll << 60;\nconst ll MOD = 1e9 + 7;\n\nVI dijkstra(map<int, vector<int>> &g, int n, int start)\n{\n    VI ret(n, IINF);\n    priority_queue<PII, vector<PII>, greater<PII>> que;\n    que.push({0, start});\n    while (!que.empty())\n    {\n        int cost = que.top().first;\n        int cur = que.top().second;\n        que.pop();\n        if (cost < ret[cur])\n        {\n            ret[cur] = cost;\n            for (auto &&x : g[cur])\n            {\n                que.push({cost + 1, x});\n            }\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--;\n    t--;\n    map<int, vector<int>> g;\n    rep(i, m)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    auto ds = dijkstra(g, n, s);\n    auto dt = dijkstra(g, n, t);\n    ll dist = ds[t];\n    map<int, int> mps, mpt;\n    rep(i, n)\n    {\n        mps[ds[i]]++;\n        mpt[dt[i]]++;\n    }\n\n    ll ans = 0;\n    dist--;\n    rep(i, n)\n    {\n        ll cur = ds[i];\n        ans += mpt[dist - cur - 1];\n        //  ans += mpt[dist - 2 - cur];\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint N, M, S, T, X, Y;\nvector<int> E[100010];\n\nint wfs(int *count, int *ndist, int s, int t) {\n  bool visited[100010];\n  REP(i, 0, N) visited[i] = false;\n  REP(i, 0, N) count[i] = 0;\n\n  int dist;\n  queue<pii> q;\n  q.push(pii(0, s));\n\n  while(q.size()) {\n    int d = q.front().first, v = q.front().second;\n    q.pop();\n\n    if(visited[v]) continue;\n    visited[v] = true;\n\n    count[d]++;\n    ndist[v] = d;\n\n    if(v == t) {\n      dist = d;\n      break;\n    }\n\n    REP(i, 0, E[v].size()) if(!visited[E[v][i]]) q.push(pii(d + 1, E[v][i]));\n  }\n\n  return dist;\n}\n\nint main(void) {\n  cin >> N >> M >> S >> T; S--; T--;\n  REP(i, 0, M) {\n    cin >> X >> Y; X--; Y--;\n    E[X].push_back(Y);\n    E[Y].push_back(X);\n  }\n\n  int scount[300010], tcount[300010];\n  int sndist[300010], tndist[300010];\n  REP(i, 0, N) sndist[i] = tndist[i] = -1;\n  int sdist = wfs(scount, sndist, S, T);\n  int tdist = wfs(tcount, tndist, T, S);\n\n  ll ans = 0;\n  REP(i, 0, sdist - 1) ans += scount[i] * tcount[tdist - i - 2];\n  REP(i, 0, N) if(sndist[i] >= 0 && tndist[i] >= 0 && sndist[i] + tndist[i] == sdist - 1) ans--;\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF (int)1e6\nusing namespace std;\n\n\nvoid calc(int s, vector<int> &d, vector<vector<int> > &adj){\n\td[s] = 0;\n\tpriority_queue<pair<int,int> > npos;\n\tnpos.push(make_pair(0,s) );\n\n\twhile(!npos.empty()){\n\t\tpair<int,int> temp = npos.top();\n\t\tnpos.pop();\n\t\tint cost = temp.first + 1;\n\t\tint now = temp.second;\n\t\tfor(int i = 0, im = adj[now].size(); i < im; ++i){\n\t\t\tint next = adj[now][i];\n\t\t\tif(d[next] == INF){\n\t\t\t\td[next] = cost;\n\t\t\t\tnpos.push(make_pair(cost, next));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tint n,m,s,t;\n\tcin >> n >> m >> s >> t;\n\tvector<vector<int> > adj(n+1,vector<int>(0));\n\tfor(int i = 0; i < m; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n/*\n\tfor(int i = 1; i < n+1 ; i++){\n\t\tcout << i << \" ; \";\n\t\tfor(int j = 0; j < adj[i].size(); j++){\n\t\t\tcout << adj[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\tvector<int> sd(n+1,INF);\n\tvector<int> td(n+1,INF);\n\tcalc(s,sd,adj);\n\tcalc(t,td,adj);\n\n\tint stcost = sd[t];\n\t\n\tvector<int> sdis(stcost+1), tdis(stcost+1);\n\n\tfor(int i = 0, im = td.size(); i < im; ++i){\n\t\tif(sd[i] < stcost) sdis[sd[i]]++;\n//\t\tcout << i << \" ; \" << sd[i] << endl;\n\t}\n//\tcout << endl;\n\tfor(int i = 0, im = td.size(); i < im; ++i){\n\t\tif(td[i] < stcost) tdis[td[i]]++;\n//\t\tcout << i << \" ; \" << td[i] << endl;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i <= stcost -2; ++i){\n\t\tans += sdis[i] * tdis[stcost - i -2];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\t\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1LL<<60)\n#define EPS 1e-10\n#define MOD 1000000007\ntypedef long long ll;\ntypedef pair<ll, ll> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\n\nll N, M;\nvector<ll>G[100005];\n\nvector<ll> dijkstra(ll s)\n{\n  vector<ll>d(N, INF);\n  priority_queue<pi, vector<pi>, greater<pi> >Q;\n  Q.push(pi(0, s));\n  d[s] = 0;\n  while(!Q.empty()){\n    pi p = Q.top(); Q.pop();\n    ll n = p.second;\n    if(d[n] < p.first) continue;\n    for(auto g:G[n]){\n      if(d[g] >= d[n] + 1){\n\tQ.push(pi(d[n]+1, g));\n\td[g] = d[n] + 1;\n      }\n    }\n  }\n  return d;\n}\n\nint main()\n{\n  ll s, t;\n  scanf(\"%lld%lld%lld%lld\", &N, &M, &s, &t); s--; t--;\n  rep(i, M){\n    ll x, y; scanf(\"%lld%lld\", &x, &y); x--; y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n\n  vector<ll>S = dijkstra(s);\n  vector<ll>T = dijkstra(t);\n  \n  multiset<ll>dist;\n  for(auto x: T)\n    dist.insert(x);\n\n  ll d = S[t];\n  ll res = 0;\n  for(auto x: S){\n    //    cout << x << \" \" << d - x - 2 << \" \" << dist.count(d-x-2) << endl;\n    res += dist.count(d - x - 2);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#define mk make_pair\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nbool vis[100000];\nint main(){\n  int n,m,s,t,x,y;\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  vector<int> v[100000];\n  set<pair<int,int> >ss;\n  r(i,m){\n    cin>>x>>y;\n    x--;y--;\n    ss.insert(mk(x,y));\n    ss.insert(mk(y,x));\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int s1[n],t1[n];\n  queue<pair<int,int> >q;\n  q.push(mk(s,0));\n  vis[s]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    s1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  memset(vis,0,sizeof(vis));\n  q.push(mk(t,0));\n  vis[t]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    t1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  int po=s1[t],cc=0;\n  vector<int> d[100000];\n  r(i,n)d[s1[i]].push_back(i);\n  r(i,n){\n    int tt=po-t1[i]-2;\n    if(tt>-1)r(j,d[tt].size())\n      if(!ss.count(mk(d[tt][j],i))){\n       cc++;\n      }\n  }\n  cout<<cc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef pair<int,int> pp;\nset<int> G[105000];\n//set<pp> res;\nint dis[105000];\nset<int> S[105000];\n\nint main(void) {\n    int n,m,s,t;\n    scanf(\"%d%d%d%d\",&n,&m,&s,&t);\n    s--, t--;\n    memset(dis, 0x20, sizeof(dis));\n    for(int i=0; i<m; i++) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        x--, y--;\n        G[x].insert(y);\n        G[y].insert(x);\n    }\n\n    {\n        priority_queue<pp> q;\n        q.push(pp(-0, s));\n\n        while(!q.empty()) {\n            pp t = q.top(); q.pop();\n            int d = -t.fst, x = t.snd;\n\n            if(dis[x] != 0x20202020) continue;\n            dis[x] = d;\n            S[d].insert(x);\n\n            for(int y : G[x])\n                q.push(pp(-(d+1), y));\n        }\n    }\n\n    int old = dis[t];\n    memset(dis, 0x20, sizeof(dis));\n\n    int res=0;\n    {\n        priority_queue<pp> q;\n        q.push(pp(-0, t));\n\n        while(!q.empty()) {\n            pp t = q.top(); q.pop();\n            int d = -t.fst, x = t.snd;\n\n            if(dis[x] != 0x20202020) continue;\n            dis[x] = d;\n\n            if(old-2-d >= 0)\n                for(int y : S[old-2-d])\n                    if(G[x].find(y) == G[x].end())\n                        res++;\n\n            for(int y : G[x])\n                q.push(pp(-(d+1), y));\n        }\n    }\n\n    printf(\"%d\\n\", res);\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 100005\nint main(){\n  int n,m,s,t,di;\n  cin >> n >> m >> s >> t;\n  int i,j,k;\n  vector<int> v[MAX];\n  int d[MAX]={},d2[MAX]={};\n  for(i=0;i<m;i++){\n    cin >> j >> k;\n    v[j].push_back(k);\n    v[k].push_back(j);\n  }\n\n  bool used[MAX]={},used2[MAX]={};\n  queue<P> q;\n  P p,b;\n  p.first=s;\n  p.second=0;\n  q.push(p);\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(used[p.first]) continue;\n    //cout << p.first << \":\" << p.second << endl;\n    if(p.first==t) di=p.second;\n    used[p.first]=true;\n    d[p.second]++;\n    b.second=p.second+1;\n    for(i=0;i<v[p.first].size();i++){\n      b.first=v[p.first][i];\n      q.push(b);\n    }\n  }\n  p.first=t;\n  p.second=0;\n  q.push(p);\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(used2[p.first]) continue;\n    //cout << p.first << \":\" << p.second << endl;\n    used2[p.first]=true;\n    d2[p.second]++;\n    b.second=p.second+1;\n    for(i=0;i<v[p.first].size();i++){\n      b.first=v[p.first][i];\n      q.push(b);\n    }\n  }\n  \n  //cout << di << endl;\n  int o=0;\n  \n  for(i=0;i<di-1;i++){\n    o+=d[i]*d2[di-2-i];\n  }\n  \n  cout << o << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint N, M, S, T, X, Y;\nvector<int> E[100000];\nbool visited[100000];\n\nint wfs(int *count, int s, int t) {\n  REP(i, 0, N) visited[i] = false;\n  REP(i, 0, N) count[i] = 0;\n  queue<pii> q;\n  q.push(pii(0, s));\n  int dist;\n  REP(i, 0, N)\n  while(q.size()) {\n    int d = q.front().first, v = q.front().second;\n    q.pop();\n    if(visited[v]) continue;\n    visited[v] = true;\n    count[d]++;\n    if(v == t) dist = d;\n    REP(i, 0, E[v].size()) if(!visited[E[v][i]]) q.push(pii(d + 1, E[v][i]));\n  }\n\n  return dist;\n}\n\nint main(void) {\n  cin >> N >> M >> S >> T; S--; T--;\n  REP(i, 0, M) {\n    cin >> X >> Y;\n    E[X - 1].push_back(Y - 1);\n    E[Y - 1].push_back(X - 1);\n  }\n\n  int scount[100000], tcount[100000];\n  int sdist = wfs(scount, S, T);\n  int tdist = wfs(tcount, T, S);\n\n  int ans = 0;\n  REP(i, 0, sdist - 1) ans += scount[i] * tcount[tdist - i - 2];\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\ntypedef pair<int, int> State;\nint n;\nvvi edge;\n\nvoid bfs(int s, vi& dist){\n    dist = vi(n, inf);\n    vi used(n);\n\n    queue<State> q;\n    q.push(mp(0, s));\n\n    while(!q.empty()){\n        int cur_cost = q.front().F;\n        int cur_v = q.front().S;\n        q.pop();\n\n        dist[cur_v] = cur_cost;\n        used[cur_v] = true;\n\n        for(int u : edge[cur_v]){\n            if(used[u]) continue;\n\n            q.push(mp(cur_cost + 1, u));\n        }\n    }\n}\n\nint main(void){\n    ll res;\n    for(int m, s, t; cin >> n >> m >> s >> t; cout << res << endl){\n        res = 0;\n\n        s--, t--;\n        edge = vvi(n);\n\n        rep(i, m){\n            int x, y; cin >> x >> y;\n            x--, y--;\n            \n            edge[x].pb(y), edge[y].pb(x);\n        }\n\n        vi dist_fromS, dist_fromT;\n        bfs(s, dist_fromS);\n        bfs(t, dist_fromT);\n\n        map<int, int> distCnt_fromS, distCnt_fromT;\n        rep(u, n){\n            distCnt_fromS[dist_fromS[u]]++;\n            distCnt_fromT[dist_fromT[u]]++;\n        }\n\n        int path_len = dist_fromS[t];\n\n        rep(i, path_len + 1){\n            res += distCnt_fromS[i] * distCnt_fromT[path_len - i - 2];\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\nvector<int> used1,used2;\nvector<int> dp1,dp2;\npriority_queue<pair<int,int>> pq1;\npriority_queue<pair<int,int>> pq2;\nvector<vector<int>> v;\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    v=vector<vector<int>>(n);\n    // set<pair<int,int>> se;\n    rep(i,n){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    used1=vector<int>(n+10,-1);\n    used2=vector<int>(n+10,-1);\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    dp1=vector<int>(n+10,0);\n    dp2=vector<int>(n+10,0);\n    rep(i,n){\n        if(0<=used1[i]&&used1[i]<=n) dp1[used1[i]]++;\n        if(0<=used2[i]&&used2[i]<=n) dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nauto chmin = [](auto&& l, auto r) { return r < l ? l = r, 1 : 0; };\n\ntemplate <class T> struct dijkstra {\n  struct edge {\n    int to;\n    T w;\n  };\n  vector<vector<edge>> g;\n  const T inf;\n  dijkstra(int n, T _inf = numeric_limits<T>::max()) : g(n), inf(_inf) {}\n  void add_edge(int from, int to, T w) { g[from].push_back({to, w}); }\n  void add_undirected_edge(int u, int v, T w) {\n    add_edge(u, v, w), add_edge(v, u, w);\n  }\n  vector<T> run(int s) const {\n    vector<T> dist(g.size(), inf);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> pq;\n    pq.emplace(dist[s] = 0, s);\n    while (not pq.empty()) {\n      T d;\n      int v;\n      tie(d, v) = pq.top(), pq.pop();\n      if (d > dist[v]) continue;\n      for (auto e : g[v])\n        if (chmin(dist[e.to], dist[v] + e.w)) pq.emplace(dist[e.to], e.to);\n    }\n    return dist;\n  }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, s, t;\n  cin >> n >> m >> s >> t;\n  --s, --t;\n  dijkstra<int> g(n);\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    g.add_undirected_edge(u, v, 1);\n  }\n  auto ds = g.run(s), dt = g.run(t);\n  vector<int> cs(n), ct(n);\n  for (int v = 0; v < n; ++v) {\n    if (ds[v] < n) {\n      ++cs[ds[v]];\n    }\n    if (dt[v] < n) {\n      ++ct[dt[v]];\n    }\n  }\n  long long res = 0;\n  for (int i = 0; i <= ds[t] - 2; ++i) {\n    res += (long long)cs[i] * ct[ds[t] - 2 - i];\n  }\n  cout << res << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<bool> isReached(N, false), is(N,false);\n    vector<int> count(N,0),c(N,0);\n    vector< vector<ll> > graph(N);\n    queue<int> que;\n    vector<int> dist(N),d(N);\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    int x, y;\n    for(int i=0 ; i<M ; i++){\n        cin >> x >> y;\n        x--; y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n    int now;\n    que.push(s);\n    count[0] = 1;\n    isReached[s] = true;\n    dist[s] = 0;\n    while(!que.empty()){\n        now = que.front();\n        que.pop();\n        for(int i=0; i<graph[now].size() ; i++){\n            if(!isReached[graph[now][i]]){\n                que.push(graph[now][i]);\n                isReached[graph[now][i]] = true;\n                dist[graph[now][i]] = dist[now]+1;\n                count[dist[graph[now][i]]]++;\n            }\n        }\n    }\n    que.push(t);\n    c[0] = 1;\n    is[t] = true;\n    d[t]=0;\n    while(!que.empty()){\n        now = que.front();\n        que.pop();\n        for(int i=0; i<graph[now].size() ; i++){\n            if(!is[graph[now][i]]){\n                que.push(graph[now][i]);\n                is[graph[now][i]] = true;\n                d[graph[now][i]] = d[now]+1;\n                c[d[graph[now][i]]]++;\n            }\n        }\n    }\n    ll ans=0;\n    for(int i=0; i<= dist[t]-2 ; i++){\n        ans+= count[i]*c[dist[t]-2-i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\n\n#define MAX 100009\nusing namespace std;\ntypedef pair<int,int> P;\n\ntypedef struct Node\n{\n\tint n;\n\tvector<int>e;\n}Node;\n\nNode G[MAX];\nint SC[MAX], GC[MAX],N,M,s,t;\n\nint dijcstra(int s,int g)\n{\n\tint C[MAX];\n\tmemset(C,0x7f,sizeof(C));\n\tP tmp(0,s);\n\tpriority_queue<P>Q;\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(tmp.second==g)\n\t\t\treturn tmp.first;\n\t\tif(tmp.first>=C[tmp.second])\n\t\t\tcontinue;\n\t\tC[tmp.second]=tmp.first;\n\t\tfor(int i=0;i<G[tmp.second].e.size();i++)\n\t\t{\n\t\t\tint nn=G[tmp.second].e[i];\n\t\t\tif(C[nn]>tmp.first+1)\n\t\t\t{\n\t\t\t\tQ.push(make_pair(tmp.first+1,nn));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&M,&s,&t);\n\ts--;t--;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--;y--;\n\t\tG[x].e.push_back(y);\n\t\tG[y].e.push_back(x);\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tSC[i]=dijcstra(s,i);\n\t\t\tGC[i]=dijcstra(t,i);\n\t\t}\n\t}\n\tint mc=SC[t],res=0;\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(SC[i]==-1||GC[j]==-1)continue;\n\t\t\tif(SC[i]+GC[j]+1==mc-1)\n\t\t\t\tres++;\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define repr(i, a, b) for (int i = (int)(a - 1); i >= b; i--)\n#define rep(i, n) repl(i, 0, n)\n#define each(itr, v) for (auto itr : v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(), (x).end()\n#define dbg(x) cout << #x \" = \" << x << endl\n#define maxch(x, y) x = max(x, y)\n#define minch(x, y) x = min(x, y)\n#define uni(x) x.erase(unique(all(x)), x.end())\n#define exist(x, y) (find(all(x), y) != x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF INT_MAX / 3\n\nset<int> v[100000];\nint minds[100000], mindt[100000];\nint cnt[2][100000];\n\nint main() {\n  cin.sync_with_stdio(false);\n  int n, m, s, t;\n  cin >> n >> m >> s >> t;\n  s--, t--;\n  rep(i, m) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    v[x].insert(y);\n    v[y].insert(x);\n  }\n  rep(i, n) minds[i] = mindt[i] = INF;\n  queue<P> qs, qt;\n  qs.push(P(s, 0));\n  while (qs.size()) {\n    P p = qs.front();\n    qs.pop();\n    if (minds[p.fi] < INF) continue;\n    minds[p.fi] = p.se;\n    each(itr, v[p.fi]) if (minds[itr] == INF) qs.push(P(itr, p.se + 1));\n  }\n  qt.push(P(t, 0));\n  while (qt.size()) {\n    P p = qt.front();\n    qt.pop();\n    if (mindt[p.fi] < INF) continue;\n    mindt[p.fi] = p.se;\n    each(itr, v[p.fi]) if (mindt[itr] == INF) qt.push(P(itr, p.se + 1));\n  }\n  int st = minds[t];\n  rep(i, n) {\n    if (minds[i] < st) cnt[0][minds[i]]++;\n    if (mindt[i] < st) cnt[1][mindt[i]]++;\n  }\n  int ans = 0;\n  rep(i, st - 1) { ans += cnt[0][i] * cnt[1][st - 2 - i]; }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nstruct aa {\n\tint to;\n\tint time;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\nint main() {\n\tint N, M, S, T; cin >> N >> M >> S >> T;\n\tS--; T--;\n\tvector<vector<int>>edges(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint f, t; cin >> f >> t;\n\t\tf--; t--;\n\t\tedges[f].push_back(t);\n\t\tedges[t].push_back(f);\n\t}\n\n\tvector<int>starttimes(N, 999499);\n\tvector<long long int >starttimenum(1100000);\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ S,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tstarttimes[atop.to] = atop.time;\n\t\t\tfor (auto i : edges[atop.to]) {\n\t\t\t\tif (starttimes[i] > atop.time + 1) {\n\t\t\t\t\tstarttimes[i] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ i,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < starttimes.size(); ++i) {\n\t\t\tstarttimenum[starttimes[i]]++;\n\t\t}\n\t}\n\tvector<int>goaltimes(N, 999499);\n\tvector<long long int >goaltimenum(1100000);\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tgoaltimes[atop.to] = atop.time;\n\t\t\tfor (auto i : edges[atop.to]) {\n\t\t\t\tif (goaltimes[i] > atop.time + 1) {\n\t\t\t\t\tgoaltimes[i] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ i,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < goaltimes.size(); ++i) {\n\t\t\tgoaltimenum[goaltimes[i]]++;\n\t\t}\n\t}\n\n\tint fintime = starttimes[T];\n\n\tlong long int ans = 0;\n\tfor (int i = 0; i < fintime-1; ++i) {\n\t\tans += starttimenum[i] * goaltimenum[fintime-i-2];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n\ntemplate<class Type>\nType solve(Type res = Type()){\n    int N,M,s,t; cin >> N >> M >> s >> t;\n    s--; t--;\n    vector<vector<int>> G(N);\n    for(int i = 0; i < M;i++){\n        int u,v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    vector<int> dists(N,INF),distt(N,INF);\n    \n    auto dijkstra = [&](int from,vector<int>& dist){\n        queue<ll> q;\n        dist[from] = 0;\n        q.push(from);\n        while(q.size()){\n            ll u = q.front(); q.pop();\n            for(auto v:G[u]){\n                if(dist[v] > dist[u] + 1){\n                    dist[v] = dist[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n    };\n    \n    \n    dijkstra(s,dists);\n    dijkstra(t,distt);\n    \n    map<int,int> L,R;\n    for(int i = 0; i < N;i++){\n        if(dists[i] != INF) L[dists[i]]++;\n        if(distt[i] != INF) R[distt[i]]++;\n    }\n    int D = dists[t];\n    for(int i = 0; i <= D+1;i++){\n       if(D-i-2 < 0) continue;\n        res += L[i] * R[D-i-2];\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    //test();\n    //solve<ll>();\n    cout << fixed << setprecision(15) << solve<ll>() << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 10000000;\nint main(){\n  int N, M, s, t;\n  cin >> N >> M >> s >> t;\n  s--;\n  t--;\n  vector<vector<int>> E(N);\n  for (int i = 0; i < M; i++){\n    int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    E[x].push_back(y);\n    E[y].push_back(x);\n  }\n  vector<int> d1(N, INF);\n  d1[s] = 0;\n  queue<int> Q1;\n  Q1.push(s);\n  while (!Q1.empty()){\n    int v = Q1.front();\n    Q1.pop();\n    for (int w : E[v]){\n      if (d1[w] == INF){\n        d1[w] = d1[v] + 1;\n        Q1.push(w);\n      }\n    }\n  }\n  vector<int> d2(N, INF);\n  d2[t] = 0;\n  queue<int> Q2;\n  Q2.push(t);\n  while (!Q2.empty()){\n    int v = Q2.front();\n    Q2.pop();\n    for (int w : E[v]){\n      if (d2[w] == INF){\n        d2[w] = d2[v] + 1;\n        Q2.push(w);\n      }\n    }\n  }\n  int d = d1[t];\n  vector<int> cnt1(N, 0);\n  for (int i = 0; i < N; i++){\n    if (d1[i] != INF){\n      cnt1[d1[i]]++;\n    }\n  }\n  vector<int> cnt2(N, 0);\n  for (int i = 0; i < N; i++){\n    if (d2[i] != INF){\n      cnt2[d2[i]]++;\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= d - 2; i++){\n    ans += (long long) cnt1[i] * cnt2[d - 2 - i];\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\n#define INF (1 << 23)\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, s, t, u, v;\n\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &s); s--;\n\tscanf(\"%d\", &t); t--;\n\n\tvector<vector<int> > G(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &u);\n\t\tscanf(\"%d\", &v);\n\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\n\tvector<int> d1(N, INF); d1[s] = 0;\n\tvector<int> d2(N, INF); d2[t] = 0;\n\n\tqueue<int> que;\n\n\tque.push(s);\n\n\twhile (!que.empty())\n\t{\n\t\tint node = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tif (d1[G[node][i]] == INF)\n\t\t\t{\n\t\t\t\td1[G[node][i]] = d1[node] + 1; que.push(G[node][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tque.push(t);\n\n\twhile (!que.empty())\n\t{\n\t\tint node = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tif (d2[G[node][i]] == INF)\n\t\t\t{\n\t\t\t\td2[G[node][i]] = d2[node] + 1; que.push(G[node][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint shortest = d1[t];\n\n\tvector<int> r1(shortest - 1, 0); for (int i = 0; i < N; i++) { if (d1[i] < shortest - 1) { r1[d1[i]]++; } }\n\tvector<int> r2(shortest - 1, 0); for (int i = 0; i < N; i++) { if (d2[i] < shortest - 1) { r2[d2[i]]++; } }\n\n\tlong long ret = 0;\n\n\tfor (int i = 0; i < shortest - 1; i++)\n\t{\n\t\tret += (long long)(r1[i] * r2[shortest - i - 2]);\n\t}\n\t\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<bool> isReached(N, false), is(N,false);\n    vector<int> count(N,0),c(N,0);\n    vector< vector<int> > graph(N);\n    queue<int> que;\n    vector<int> dist(N),d(N);\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    int x, y;\n    for(int i=0 ; i<M ; i++){\n        cin >> x >> y;\n        x--; y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n    int now;\n    que.push(s);\n    count[0] = 1;\n    isReached[0] = true;\n    dist[0] = 0;\n    while(!que.empty()){\n        now = que.front();\n        que.pop();\n        for(int i=0; i<graph[now].size() ; i++){\n            if(!isReached[graph[now][i]]){\n                que.push(graph[now][i]);\n                isReached[graph[now][i]] = true;\n                dist[graph[now][i]] = dist[now]+1;\n                count[dist[graph[now][i]]]++;\n            }\n        }\n    }\n    que.push(t);\n    c[0] = 1;\n    is[0] = true;\n    d[0]=0;\n    while(!que.empty()){\n        now = que.front();\n        que.pop();\n        for(int i=0; i<graph[now].size() ; i++){\n            if(!is[graph[now][i]]){\n                que.push(graph[now][i]);\n                is[graph[now][i]] = true;\n                d[graph[now][i]] = d[now]+1;\n                c[d[graph[now][i]]]++;\n            }\n        }\n    }\n    ll ans=0;\n    for(int i=0; i<= dist[t]-2 ; i++){\n        ans+= count[i]*c[dist[t]-2-i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\ntypedef pair<int, int> State;\nint n;\nvvi edge;\n\nvoid bfs(int s, vi& dist){\n    dist = vi(n, inf);\n\n    queue<State> q;\n    q.push(mp(0, s));\n\n    while(!q.empty()){\n        int cur_cost = q.front().F;\n        int cur_v = q.front().S;\n        q.pop();\n\n        dist[cur_v] = cur_cost;\n\n        for(int u : edge[cur_v]){\n            if(dist[u] != inf) continue;\n\n            q.push(mp(cur_cost + 1, u));\n        }\n    }\n}\n\nint main(void){\n    ll res;\n    for(int m, s, t; cin >> n >> m >> s >> t; cout << res << endl){\n        res = 0;\n\n        s--, t--;\n        edge = vvi(n);\n\n        rep(i, m){\n            int x, y; cin >> x >> y;\n            x--, y--;\n            \n            edge[x].pb(y), edge[y].pb(x);\n        }\n\n        vi dist_fromS, dist_fromT;\n        bfs(s, dist_fromS);\n        bfs(t, dist_fromT);\n\n        map<int, ll> distCnt_fromS, distCnt_fromT;\n        rep(u, n){\n            if(dist_fromS[u] != inf) distCnt_fromS[dist_fromS[u]]++;\n            if(dist_fromT[u] != inf) distCnt_fromT[dist_fromT[u]]++;\n        }\n\n        int path_len = dist_fromS[t];\n\n        rep(i, path_len - 1){\n            res += distCnt_fromS[i] * distCnt_fromT[path_len - i - 2];\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint ds[2][100001];\nint ns[2][100001];\nvector<vector<int>> G;\nvoid dfs(int x, int d, int i){\n  if(ds[i][x] >= 0) return;\n  ds[i][x] = d;\n  ns[i][d]++;\n  for(int to: G[x]){\n\tdfs(to, d+1, i);\n  }\n}\n\nint main(){\n  fill((int*)ds, (int*)ds+2*100001, -1);\n  fill((int*)ns, (int*)ns+2*100001, 0);\n\n  int N, M, S, T;\n  cin >> N >> M >> S >> T;\n  --S, --T;\n  G.assign(N, vector<int>());\n  for(int i=0;i<M;++i){\n\tint x, y; cin >> x >> y;\n\t--x, --y;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n  }\n  dfs(S, 0, 0);\n  dfs(T, 0, 1);\n\n  long long ans = 0, d = ds[0][T];\n  for(int i=0;i<=d-2;++i)\n\tans += ns[0][i] * ns[1][d-2-i];\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n};\n\ntemplate <typename T>\nusing Edges = vector<Edge<T>>;\ntemplate <typename T>\nusing AdjList = vector<Edges<T>>;\n\ntemplate <typename T>\nclass Dijkstra {\n    private:\n        T INF = 1e9;\n        int V;           // 頂点数\n        AdjList<T> adj;  // adj[始点][動的配列で始点から伸びる枝]\n        vector<int> prever;\n\n    public:\n        Dijkstra(int n);\n        vector<T> cost;\n        void AddEdge(int f, int t, int c);\n        bool HasPath(int t);                 // tに至るパスはあるか\n        vector<int> GetShortestPath(int t);  // tへの最短路\n        void Run(int f);\n};\n\ntemplate <typename T>\nDijkstra<T>::Dijkstra(int n) : \n    V(n + 1), adj(V), prever(vector<int>(V, -1)), cost(V)\n{\n    fill(cost.begin(), cost.end(), INF);\n}\n\ntemplate <typename T>\nvoid Dijkstra<T>::AddEdge(int f, int t, int c) {\n    adj[f].push_back(Edge<T>(t, c));\n}\n\ntemplate <typename T>\nbool Dijkstra<T>::HasPath(int t) {\n    return cost[t] != INF;\n}\n\ntemplate <typename T>\nvector<int> Dijkstra<T>::GetShortestPath(int t) {\n    vector<int> path;\n    for (; t != -1; t = prever[t]) path.push_back(t);\n\n    reverse(path.begin(), path.end());\n    return path;\n}\n\ntemplate <typename T>\nvoid Dijkstra<T>::Run(int firstNode) {\n    // 初期化\n    cost.assign(V, INF);\n    prever.assign(V, -1);\n\n    using Pi = pair<T, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> pq;\n\n    cost[firstNode] = 0;\n    pq.push(Pi(cost[firstNode], firstNode));\n\n    while (!pq.empty()) {\n        Pi currentEdge = pq.top();\n        pq.pop();\n        if (cost[currentEdge.second] < currentEdge.first) continue;\n\n        for (Edge<T> tmp : adj[currentEdge.second]) {\n            T sumCost = currentEdge.first + tmp.cost;\n            if (cost[tmp.to] > sumCost) {\n                cost[tmp.to] = sumCost;\n                prever[tmp.to] = currentEdge.second;\n                pq.push(Pi(cost[tmp.to], tmp.to));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--, t--;\n    Dijkstra<int> ds(n), dt(n);\n    \n    vector<vector<int>> graph(n);\n    REP(i, m){\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        ds.AddEdge(x, y, 1);\n        ds.AddEdge(y, x, 1);\n        dt.AddEdge(x, y, 1);\n        dt.AddEdge(y, x, 1);\n    }\n\n    ds.Run(s); dt.Run(t);\n    vector<LL> ds_num(n, 0LL), dt_num(n, 0LL);\n    REP(i, n){\n        if(ds.cost[i] != INF) ds_num[ds.cost[i]]++;\n        if(dt.cost[i] != INF) dt_num[dt.cost[i]]++;\n    }\n    \n    LL ans = 0;\n    REP(i, ds.cost[t]){\n        ans += ds_num[i] * dt_num[ds.cost[t]-2-i];\n    }\n\n    cout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nvector<int> bfs(vector<vector<int>> &G, int s){\n    vector<int> d(G.size(), MOD);\n    d[s] = 0;\n    queue<int> Q;\n    Q.emplace(s);\n    while(!Q.empty()){\n        int i = Q.front(); Q.pop();\n        for (auto &&j : G[i]) {\n            if(d[i] + 1 < d[j]){\n                d[j] = d[i] + 1;\n                Q.emplace(j);\n            }\n        }\n    }\n    return d;\n}\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--; t--;\n    vector<vector<int>> G(n);\n    for (int i = 0; i < m; ++i) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--; y--;\n        G[x].emplace_back(y);\n        G[y].emplace_back(x);\n    }\n    auto d1 = bfs(G, s), d2 = bfs(G, t);\n    vector<int> cnt(n);\n    for (auto &&j : d2) {\n        if(j < n)cnt[j]++;\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        int to = d1[t]-d1[i]-2;\n        if(to >= 0 && to < n){\n            ans += cnt[to];\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int kMax_x = 100001;\n\nint main(void){\n    for(int n, d, x; cin >> n >> d >> x; cout << x << endl){\n        vvi p(d, vi(n));\n        rep(i, d) rep(j, n) cin >> p[i][j];\n\n        rep(i, d - 1){\n            vi dp(x + 1);\n            rep(j, x + 1) dp[j] = j;\n\n            rep(j, n){\n                rep(k, x + 1){\n                    if(k - p[i][j] >= 0){\n                        dp[k] = max(dp[k], dp[k - p[i][j]] + p[i + 1][j]);\n                    }\n                }\n            }\n\n            x = *max_element(all(dp));\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n \nusing namespace std;\n \n#define DEBUG(x) // cerr << #x << \" = \" << x << endl\n \nconst int INF = (int)1e9;\n \nint main() {\n\tint N, M, S, T; cin >> N >> M >> S >> T;\n\tS--, T--;\n\tvector<vector<int> > E(N);\n\tfor(int i = 0; i < M; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--, b--;\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n \n\tqueue<int> Q;\n \n\tvector<int> distS(N, INF);\n\tvector<int> distSumS(N, 0);\n \n\tQ.push(S);\n\tdistS[S] = 0;\n\tdistSumS[0]++;\n\twhile(!Q.empty()) {\n\t\tint cur = Q.front(); Q.pop();\n\t\tfor(int i = 0; i < (int)E[cur].size(); i++) {\n\t\t\tint to = E[cur][i];\n\t\t\tif(distS[cur] + 1 < distS[to]) {\n\t\t\t\tQ.push(to);\n\t\t\t\tdistS[to] = distS[cur] + 1;\n\t\t\t\tdistSumS[distS[to]]++;\n\t\t\t}\n\t\t}\n\t}\n \n\tfor(int i = 0; i < N; i++) {\n\t\t// cerr << \"distS[\" << i << \"]=\" << distS[i] << endl;\n\t\t// cerr << \"distSumS[\" << i << \"]=\" << distSumS[i] << endl;\n\t}\n \n\tQ = queue<int>();\n\tvector<int> distT(N, INF);\n\tvector<int> distSumT(N, 0);\n \n\tQ.push(T);\n\tdistT[T] = 0;\n\tdistSumT[0]++;\n\twhile(!Q.empty()) {\n\t\tint cur = Q.front(); Q.pop();\n\t\tfor(int i = 0; i < (int)E[cur].size(); i++) {\n\t\t\tint to = E[cur][i];\n\t\t\tif(distT[cur] + 1 < distT[to]) {\n\t\t\t\tQ.push(to);\n\t\t\t\tdistT[to] = distT[cur] + 1;\n\t\t\t\tdistSumT[distT[to]]++;\n\t\t\t}\n\t\t}\n\t}\n \n\tfor(int i = 0; i < N; i++) {\n\t\t// cerr << \"distT[\" << i << \"]=\" << distT[i] << endl;\n\t\t// cerr << \"distSumT[\" << i << \"]=\" << distSumT[i] << endl;\n\t}\n \n\tint minDist = distS[T];\n\tDEBUG(minDist);\n\tlong long ans = 0;\n\tfor(int i = 0; i <= minDist - 2; i++) {\n\t\tans += (long long)distSumS[i] * (long long)distSumT[minDist - i - 2];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int vmax=100010;\nint sdist[vmax];\nint tdist[vmax];\n\nll snum[vmax];\nll tnum[vmax];\n\nvi graph[vmax];\n\nint main(void){\n\tint n,m,s,t;\n\tcin  >> n >> m >> s >> t;\n\ts--,t--;\n\n\trep(i,m){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tx--,y--;\n\t\tgraph[x].pb(y);\n\t\tgraph[y].pb(x);\n\t}\n\trep(i,vmax) sdist[i]=tdist[i]=-1;\n\n\tqueue<pii> q;\n\tsdist[s]=0; q.push(mp(s,0));\n\twhile(!q.empty()){\n\t\tpii cur=q.front();q.pop();\n\t\tint v=cur.first;\n\t\tint c=cur.second;\n\t\tfor(auto &v2:graph[v]){\n\t\t\tif(sdist[v2]==-1){\n\t\t\t\tsdist[v2]=c+1;\n\t\t\t\tq.push(mp(v2,c+1));\n\t\t\t}\n\t\t}\n\t}\n\n\ttdist[t]=0; q.push(mp(t,0));\n\twhile(!q.empty()){\n\t\tpii cur=q.front();q.pop();\n\t\tint v=cur.first;\n\t\tint c=cur.second;\n\t\tfor(auto &v2:graph[v]){\n\t\t\tif(tdist[v2]==-1){\n\t\t\t\ttdist[v2]=c+1;\n\t\t\t\tq.push(mp(v2,c+1));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n) snum[sdist[i]]++;\n\trep(i,n) tnum[tdist[i]]++;\n\tint sp=sdist[t];\n\tll ans=0LL;\n\trep(i,sp-1) ans+=snum[i]*tnum[sp-2-i];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\n\nclass Edge{\n    public:\n        int to, cost;\n        Edge(int to, int cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n    public:\n        int dis;\n        bool isUsed;\n        Node(){\n            this->dis = INF;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\nlong long dist;\nvector<Node> node[2];\n\nvoid dijkstra(AdjList const g, int start, int n, int f, int t){\n    priority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    node[f] = vector<Node>(n);\n\n    q.push(make_pair(0, start));\n    node[f][start].dis = 0;\n\n    pair<int, int> u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second;\n        node[f][current].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            if(node[f][next].isUsed == 0){\n                if(node[f][next].dis > node[f][current].dis + g[current][i].cost){\n                    node[f][next].dis = node[f][current].dis + g[current][i].cost;\n                    q.push(make_pair(node[f][next].dis, next));\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--; t--;\n\n    AdjList g(n);\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        g[a].emplace_back(Edge{b,1});\n        g[b].emplace_back(Edge{a,1});\n    }\n    dijkstra(g,s,n,0,t);\n    dijkstra(g,t,n,1,t);\n\n    long long cnt[2][100005];\n    rep(i,n){\n        if(node[0][i].dis != INF) cnt[0][node[0][i].dis]++;\n        if(node[1][i].dis != INF) cnt[1][node[1][i].dis]++;\n    }\n    int dist = node[0][t].dis;\n\n    long long ans = 0;\n    rep(i,dist - 1) ans+=cnt[0][i] * cnt[1][dist - i - 2];\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst int inf=(int)1e9;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nint s,t;\n//Shortest_Path\n//グラフの最短距離を求めるアルゴリズムを3種類持っているクラスです\nclass shortest_path{\npublic:\n    \n    //dijkstra法とBellman_Ford法を使うときは、このコンストラクタを使ってください\n    explicit shortest_path(int n):vertex(n),INF((ll)1e14){\n        v1.resize(static_cast<unsigned long>(vertex));\n    }\n    \n    //Warshall_Floyd法を使うときは、こちらのコンストラクタを使ってください\n    shortest_path(int n,ll inf):vertex(n),INF(inf){\n        v2.resize(static_cast<unsigned long>(vertex));\n        for(int i=0;i<vertex;i++)v2[i].resize(static_cast<unsigned long>(vertex));\n        for(int i=0;i<vertex;i++){\n            for(int j=0;j<vertex;j++){\n                v2[i][j]=INF;\n            }\n        }\n        for(int i=0;i<vertex;i++)v2[i][i]=0;\n    }\n    \n    //dijkstra法とBellman_Ford法専用のadd_edge(int from,int to,ll cost)です\n    //コストcostの頂点fromから頂点toへの有向辺を追加するときadd_edge(int from,int to,ll cost)\n    void add_edge(int from,int to,ll cost){\n        v1[from].push_back({to,cost});\n    }\n    \n    //Warshall_Floyd法専用のadd_edge(int from,int to,ll cost)です\n    //コストcostの頂点fromから頂点toへの有向辺を追加するときadd_edge(int from,int to,ll cost)\n    void add_edge_(int from,int to,ll cost){//warshall_floyd\n        v2[from][to]=cost;\n    }\n    \n    //Dijkstra法です\n    //各頂点への距離が格納されたvector<ll>が求まります\n    //負のコストの辺がある場合は使えません\n    //start地点の頂点番号を引数に入れてください\n    vector<ll> dijkstra(unsigned int start){\n        vector<ll> d(static_cast<unsigned long>(vertex),INF);\n        priority_queue<pair<ll,int> > q;\n        d[start]=0;\n        q.push({0,start});\n        while(!q.empty()){\n            int now=q.top().se;\n            ll now_cost=-q.top().fi;\n            q.pop();\n            if(d[now]<now_cost)continue;\n            for (auto &i : v1[now]) {\n                if(d[i.fi]>now_cost+ i.se){\n                    d[i.fi]=now_cost+ i.se;\n                    q.push({-d[i.fi], i.fi});\n                }\n            }\n        }\n        return d;\n    }\n    \n    //Warshall_Floyd法です\n    //各頂点への距離が格納されたvector<ll>と閉路があるかどうかの情報の2つのtupleが返されます\n    //閉路があるとき、返り値はtrueです\n    tuple<vector<vector<ll> >,bool> warshall_floyd(){\n        for(int k=0;k<vertex;k++){\n            for(int i=0;i<vertex;i++){\n                if(v2[i][k]==INF)continue;\n                for(int j=0;j<vertex;j++){\n                    if(v2[k][j]==INF)continue;\n                    v2[i][j]=min(v2[i][j],v2[i][k]+v2[k][j]);\n                }\n            }\n        }\n        bool is_negative_cycle=false;\n        for(int i=0;i<vertex;i++){\n            if(v2[i][i]<0)is_negative_cycle=true;\n        }\n        return make_tuple(v2,is_negative_cycle);\n    }\n\n    //Bellman_Ford法です\n    //各頂点への距離が格納されたvector<ll>と閉路があるかどうかの情報の2つのtupleが返されます\n    //閉路があるとき、返り値はtrueです\n    //start地点の頂点番号を引数に入れてください\n    tuple<vector<ll>,bool> bellman_ford(int start){\n        vector<ll> d(static_cast<unsigned long>(vertex),INF);\n        d[start]=0;\n        bool is_negative_cycle=false;\n        for(int i=0;i<vertex;i++){\n            bool update= false;\n            for(int j=0;j<vertex;j++){\n                if(d[j]==INF)continue;\n                for(int k=0;k<(int)v1[j].size();k++){\n                    if(d[v1[j][k].fi]>d[j]+v1[j][k].se){\n                        d[v1[j][k].fi]=d[j]+v1[j][k].se;\n                        update= true;\n                    }\n                }\n            }\n            if(i==vertex-1 && update)is_negative_cycle=true;\n            else if(!update)break;\n        }\n        return make_tuple(d,is_negative_cycle);\n    }\nprivate:\n    ll INF;\n    int vertex;\n    vector<vector<pair<int,ll> > > v1;\n    vector<vector<ll> > v2;\n};\n//tuple tp<int,int,int> -> int a=get<0>(tp),b=get<1>(tp),c=get<2>(tp)\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  shortest_path sp(n);\n  for(int i=0;i<m;i++){\n    int a,b;cin>>a>>b;\n    a--;b--;\n    sp.add_edge(a,b,1);\n    sp.add_edge(b,a,1);\n  }\n  vector<ll> d=sp.dijkstra(s);\n  vector<ll> d2=sp.dijkstra(t);\n  int st=d[t];\n  if(st==1){\n    cout<<0<<endl;\n  }else{\n    int tmp=st-2;\n    sort(d2.begin(),d2.end());\n    sort(d.begin(),d.end());\n    int ans=0;\n    for(int i=0;i<=tmp;i++){\n      int a=upper_bound(d2.begin(),d2.end(),tmp-i)-lower_bound(d2.begin(),d2.end(),tmp-i);\n      int b=upper_bound(d.begin(),d.end(),i)-lower_bound(d.begin(),d.end(),i);\n      ans+=a*b;\n      //cout<<ans<<endl;\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define make make_pair\n#define N 100002\nusing namespace std;\ntypedef pair<int,int> P;\nvoid bfs(int,int);\nint n,m,s,t,a,b,cost[2][N],mincost,ans;\nvector<int> c[N];\nbool visited[N];\n\nint main(){\n  cin>>n>>m>>s>>t;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    c[a].push_back(b);\n    c[b].push_back(a);\n  }\n  bfs(0,s);\n  bfs(1,t);\n  for(int i=0;i<=mincost-2;i++) ans+=cost[0][i]*cost[1][mincost-2-i];\n  if(mincost-2<0) cout<<0<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}\n\nvoid bfs(int index,int start){\n  queue<P> q;\n  for(int i=1;i<=n;i++) visited[i]=false;\n  q.push(make(0,start));\n  cost[index][0]++;\n  while(!q.empty()){\n    P k=q.front(); q.pop();\n    int cos=k.first,u=k.second;\n    if(visited[u]) continue;\n    visited[u]=true;\n    for(int i=0;i<(int)c[u].size();i++){\n      if(visited[c[u][i]]) continue;\n      cost[index][cos+1]++;\n      if(!index&&c[u][i]==t) mincost=cos+1;\n      q.push(make(cos+1,c[u][i]));\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tint n,i,m,s,t;cin>>n>>m>>s>>t;s--;t--;\n\tvector<vector<int>>go(n);\n\tvector<int>sdis(n,mod);\n\tvector<int>tdis(n,mod);\n\tfor(i=0;i<m;i++){\n\t\tint x,y;cin>>x>>y;x--;y--;\n\t\tgo[x].pub(y);\n\t\tgo[y].pub(x);\n\t}\n\tqueue<int>que;\n\tque.push(s);\n\tsdis[s]=0;\n\twhile(que.size()){\n\t\tint x=que.front();\n\t\t\n\t\tque.pop();\n\t\tfor(auto it:go[x]){\n\t\t\tif(sdis[it]!=mod){continue;}\n\t\t\tsdis[it]=sdis[x]+1;\n\t\t\tque.push(it);\n\t\t}\n\t}\n\t//cerr<<sdis[t]<<endl;\n\tque.push(t);\n\ttdis[t]=0;\n\twhile(que.size()){\n\t\tint x=que.front();\n\t\tque.pop();\n\t\tfor(auto it:go[x]){\n\t\t\tif(tdis[it]!=mod){continue;}\n\t\t\ttdis[it]=tdis[x]+1;\n\t\t\tque.push(it);\n\t\t}\n\t}\n\tint f=sdis[t];\n\t//cerr<<f<<endl;\n\tvector<llint>sdn(n);\n\tvector<llint>tdn(n);\n\tfor(i=0;i<n;i++){\n\t\tif(sdis[i]<n){sdn[sdis[i]]++;}\n\t\tif(tdis[i]<n){tdn[tdis[i]]++;}\n\t}\n\tllint ans=0;\n\tfor(i=0;i+2<=f;i++){ans+=sdn[i]*tdn[f-i-2];}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <set>\n#include <queue>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e5 + 10;\nint N, M, L;\nset<int> T[MAX_N];\nvector<int> scnt, tcnt, sdist, tdist;\nvoid search(int s, int t, bool flag)\n{\n    queue<int> que;\n    vector<int> dist(N, INF);\n    vector<int> cnt(N, 0);\n    dist[s] = 0;\n    que.push(s);\n    while(que.size())\n    {\n        int v = que.front(); que.pop();\n        for(auto u : T[v])\n        {\n            if(dist[u] > dist[v] + 1)\n            {\n                dist[u] = dist[v] + 1;\n                que.push(u);\n            }\n        }\n    }\n    for(int i = 0; i < N; i++)\n    {\n        if(dist[i] == INF) continue;\n        cnt[dist[i]]++;\n    }\n    if(flag == false)\n    {\n        sdist = dist;\n        scnt = cnt;\n    }\n    else\n    {\n        tdist = dist;\n        tcnt = cnt;\n    }\n}\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int s, t; cin >> N >> M >> s >> t;\n    s--, t--;\n    for(int i = 0; i < M; i++)\n    {\n        int x, y; cin >> x >> y;\n        if(x == y) continue;\n        x--, y--;\n        T[x].insert(y);\n        T[y].insert(x);\n    }\n    search(s, t, 0);\n    search(t, s, 1);\n    L = sdist[t];\n    ll ans = 0;\n    for(int i = 0; i < N; i++)\n    {\n        int dist = L - 2 - sdist[i];\n        if(dist < 0) continue;\n        ans += tcnt[dist];\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2608.cc: Minus One\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\n/* global variables */\n\nvi nbrs[MAX_N];\nint dists0[MAX_N], dists1[MAX_N], cnts0[MAX_N], cnts1[MAX_N];\n\n/* subroutines */\n\nvoid dijkstra(int n, int dists[], int cnts[], int st, int gl) {\n  for (int i = 0; i < n; i++) dists[i] = INF;\n  dists[st] = 0;\n\n  qi q;\n  q.push(st);\n\n  while (! q.empty()) {\n    int u = q.front(); q.pop();\n    int ud = dists[u];\n    cnts[ud]++;\n    if (u == gl) break;\n\n    int vd = ud + 1;\n    vi &nbru = nbrs[u];\n    for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n      int &v = *vit;\n      if (dists[v] > vd) {\n\tdists[v] = vd;\n\tq.push(v);\n      }\n    }\n  }\n  //for (int i = 0; i <= dists[gl]; i++) printf(\"%d: %d\\n\", i, cnts[i]);\n}\n\n/* main */\n\nint main() {\n  int n, m, st, gl;\n  cin >> n >> m >> st >> gl;\n  st--, gl--;\n\n  for (int i = 0; i < m; i++) {\n    int xi, yi;\n    cin >> xi >> yi;\n    xi--, yi--;\n    nbrs[xi].push_back(yi);\n    nbrs[yi].push_back(xi);\n  }\n\n  dijkstra(n, dists0, cnts0, st, gl);\n  dijkstra(n, dists1, cnts1, gl, st);\n  \n  ll sum = 0;\n  int dg = dists0[gl];\n  for (int i = 0; i <= dg - 2; i++)\n    sum += (ll)cnts0[i] * cnts1[dg - i - 2];\n  printf(\"%lld\\n\", sum);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap<int, vector<int> > edges;\n\n// ?????¢?????????\nint s2t[100001];\nint t2s[100001];\n\n// ???????????¢???????????°\nint s2t_kinds[100001];\nint t2s_kinds[100001];\n\nvoid bfs(int s, int* kyori) {\n    queue<pair<int, int> > q;\n    q.push( make_pair(s,0) );\n\n    while (!q.empty()) {\n        pair<int,int> p = q.front(); q.pop();\n        int curr = p.first;\n        int step = p.second;\n        for (int i=0; i<edges[curr].size(); i++) {\n            int next = edges[curr][i];\n            if (*(kyori + next) != -1) continue;\n            *(kyori + next) = step + 1;\n            q.push( make_pair(next, step + 1) );\n        }\n    }\n}\n\nint main() {\n    int n,m,s,t; cin >> n >> m >> s >> t;\n    for (int i=0; i<m; i++) {\n        int x,y; cin >> x >> y;\n        if (edges.count(x) == 0) {\n            vector<int> v; v.push_back(y);\n            edges[x] = v;\n        } else {\n            edges[x].push_back(y);\n        }\n        if (edges.count(y) == 0) {\n            vector<int> v; v.push_back(x);\n            edges[y] = v;\n        } else {\n            edges[y].push_back(x);\n        }\n    }\n\n    // init\n    for (int i=0; i<=n; i++) s2t[i] = t2s[i] = -1;\n    s2t[s] = t2s[t] = 0;\n\n    bfs(s,s2t);\n    bfs(t,t2s);\n\n    for (int i=1; i<=n; i++) {\n        if (s2t[i] != -1) {\n            s2t_kinds[ s2t[i] ] += 1;\n        }\n        if (t2s[i] != -1) {\n            t2s_kinds[ t2s[i] ] += 1;\n        }\n    }\n\n    int dist = s2t[t];\n    int ans = 0;\n    for (int i=0; i<=dist-2; i++) {\n        ans += s2t_kinds[i] * t2s_kinds[dist - 2 - i];\n    }\n\n    cout << ans << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nstruct P {\n    int v;\n    int cost;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nint G1[100001];\nint G2[100001];\nint W1[100001];\nint W2[100001];\nbool exclude[100001];\n\nint get_min_cost(int s, int t, vvi& E, int* G) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    G[s] = 0;\n    que.push({s, 0});\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        if (p.v == t) {\n            return p.cost;\n        }\n        if (G[p.v] < p.cost) continue;\n        for (int to : E[p.v]) {\n            if (G[to] > p.cost+1) {\n                G[to] = p.cost+1;\n                que.push({to, p.cost+1});\n            }\n        }\n    }\n    return INF;\n}\n\nint get_min_cost2(int s, int t, vvi& E, int* G) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    G[s] = 0;\n    que.push({s, 0});\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        if (p.v == t) {\n            return p.cost;\n        }\n        if (G[p.v] < p.cost) continue;\n        for (int to : E[p.v]) {\n            if (G[to] > p.cost+1) {\n                G[to] = p.cost+1;\n                que.push({to, p.cost+1});\n            }\n        }\n    }\n    return INF;\n}\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    vvi E(n+1);\n    REP(i, m) {\n        int x, y;\n        cin >> x >> y;\n        E[x].push_back(y);\n        E[y].push_back(x);\n    }\n\n    fill_n((int *)G1, 100001, INF);\n    fill_n((int *)G2, 100001, INF);\n\n    int min_cost = get_min_cost(s, t, E, G1);\n    get_min_cost2(t, s, E, G2);\n\n    FOR(i, 1, n+1) {\n        if (G1[i] != INF) {\n            G1[i] = min_cost - G1[i];\n        }\n        // s, t??????????????????????????????????????????????????????????????????????????¨\n        if (G1[i] != INF && G1[i] == G2[i]) {\n        } else if ((G1[i] == INF && G2[i] != INF) || (G1[i] != INF && G2[i] == INF)) {\n        } else {\n            exclude[i] = true;\n        }\n        if (G1[i] <= min_cost) {\n            W1[G1[i]]++;\n        }\n    }\n\n    int cost = 0;\n    queue<int> que;\n    que.push(t);\n    que.push(-1);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        if (v == -1) {\n            cost++;\n            if (que.empty()) break;\n            if (cost > min_cost) break;\n            que.push(-1);\n            continue;\n        }\n        for (int to : E[v]) {\n            if (G1[to] == INF) {\n                G1[to] = cost+1;\n                que.push(to);\n            }\n        }\n    }\n\n    FOR(i, 1, n+1) {\n        if (G1[i] <= min_cost && !exclude[i]) {\n            W2[G1[i]]++;\n        }\n    }\n\n    W2[0] = 1;\n//    REP(i, min_cost+1) {\n//        LOG(\"%d -> %d %d\\n\", i, W1[i], W2[i]);\n//    }\n\n    if (min_cost < 2) {\n        cout << 0 << endl;\n    } else {\n        int res = 0;\n        FOR(i, 2, min_cost+1) {\n//            LOG(\"%d %d -> %d\\n\", W1[i], W2[i-2], W1[i]*W2[i-2]);\n            res += W1[i] * W2[i-2];\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> mp;\nint inf =  1e9;\n\nvector<int> daikus( vector<vector<int> >&g , int s ){\n    vector<int> res( g.size() , inf );\n    vector<bool> used( g.size() , false );\n    res[s] = 0;\n    used[s] = true;\n    queue<mp> q;\n    q.push( mp( 0, s ) );\n    while( !q.empty() ){\n\tmp now = q.front();\n\tq.pop();\n\tint nn = now.second;\n\tint cost = now.first;\n\tfor(int i=0;i<g[nn].size();i++){\n\t    int next = g[nn][i];\n\t    //if( res[ next ] <= cost + 1 ) continue;\n\t    if( used[next] )continue;\n\t    res[next] = cost + 1;\n\t    used[next] = true;\n\t    q.push( mp( cost + 1 ,next ) );\n\t}\n    }\n    return res;\n}\n\n\nint main(){\n    int n,m,s,t;\n    cin>>n>>m>>s>>t;\n    s--,t--;\n    vector< vector<int> > g(n);\n    for(int i=0;i<m;i++){\n\tint u,v;\n\tcin>>u>>v;\n\tu--,v--;\n\tg[u].push_back( v );\n\tg[v].push_back( u );\n    }\n    vector<int> sd = daikus( g ,s );\n    vector<int> td = daikus( g, t );\n    vector<ll> cnts( n+1 , 0 );\n    vector<ll> cntt( n+1 , 0 );\n    int pass = sd[t];\n    for(int i=0;i<n;i++) {\n\tif( sd[i] != inf )cnts[ sd[i] ]++ ;\n\tif( td[i] != inf )cntt[ td[i] ]++;\n    }\n    //cout<<\"OK\"<<endl;\n    ll res = 0;\n    for(int i=0;i<pass-1;i++){\n\tres += cnts[i]*cntt[pass-i-2];\n    }\n    cout<<res<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n\nstruct edge { int to, cost;};\n\nclass Dijkstra{\nprivate:\n    vector< vector<edge> > g;\n\npublic:\n    Dijkstra(){};\n    Dijkstra(int size){\n        g.resize(size);\n    }\n\n    vi dist;\n\n    void add(int a, int b, int c){//無向辺\n        edge e1 = {b, c}, e2 = {a, c};\n        g[a].push_back(e1);\n        g[b].push_back(e2);//有向辺の場合はここをコメントアウトする\n    }\n\n    void calc(int s){\n        priority_queue< pii, vector<pii>, greater<pii> > q;\n        int n = g.size();\n        dist = vi (n, INF);\n        dist[s] = 0;\n        q.push(pii(0, s));\n\n        while(!q.empty()){\n            pii p = q.top();\n            q.pop();\n            int v = p.second;\n            if(dist[v] < p.first)continue; //更新されていたら何もしない\n            for(int i = 0; i < g[v].size(); i++){\n                edge e = g[v][i];\n                if(dist[e.to] > dist[v] + e.cost){\n                    dist[e.to] = dist[v] + e.cost;\n                    q.push(pii(dist[e.to], e.to));\n                }\n            }\n        }\n    }\n\n};\n\nsigned main(void) {\n    int i,j;\n    int n,m,s,t;\n    cin >> n >> m >> s >> t;\n    s--,t--;\n    Dijkstra dij = Dijkstra(n);\n    rep(i,m){\n        int x,y;\n        cin >> x >> y;\n        x--,y--;\n        dij.add(x,y,1);\n    }\n    dij.calc(s);\n    int dist = dij.dist[t] - 2;\n    map<int,int> ma1;\n    rep(i,n)ma1[dij.dist[i]]++;\n    dij.calc(t);\n    map<int,int> ma2;\n    rep(i,n)ma2[dij.dist[i]]++;\n    int ans = 0;\n    for(auto itr = ma1.begin(); itr != ma1.end(); itr++){\n        int x = itr->first;//きょり\n        int a = itr->second;//個数\n        int b = ma2[dist-x];//個数\n        ans += a*b;\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\nvector<int> used1,used2;\nvector<int> dp1,dp2;\npriority_queue<pair<int,int>> pq1;\npriority_queue<pair<int,int>> pq2;\nvector<vector<int>> v;\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    v=vector<vector<int>>(n);\n    rep(i,m){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    used1=vector<int>(n+10,-1);\n    used2=vector<int>(n+10,-1);\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    long long ans=0;\n    int dist=used1[t];\n    dp1=vector<int>(n+10,0);\n    dp2=vector<int>(n+10,0);\n    rep(i,n){\n        if(0<=used1[i]&&used1[i]<=n) dp1[used1[i]]++;\n        if(0<=used2[i]&&used2[i]<=n) dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=(long long)dp1[i]*dp2[dist-2-i];\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n \nusing namespace std;\n \ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 110000\n\nint N;\n\nstruct edge{\n\tint to;\n\tlong long int cost;\n};\n\nvector<edge> G[MAX_V];\nlong long int d[MAX_V];\n\n// 速さはO(|E|log|V|)\n\nvoid shortest_path(int s, int V){ // Vは頂点数\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\t\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t} // 頂点への最小コストを更新\n\t}\n}\n\nlong long int cnt1[310000] = {}, cnt2[310000] = {};\n\nint main(){\n\t\n\tlong long int N, M, s, t;\n\tcin >> N >> M >> s >> t;\n\ts--;\n\tt--;\n\t\n\tfor(int i = 0; i < M; i++){\n\t\tedge e;\n\t\te.cost = 1;\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--;\n\t\tv--;\n\t\te.to = v;\n\t\tG[u].push_back(e);\n\t\te.to = u;\n\t\tG[v].push_back(e);\n\t}\n\t\n\tshortest_path(s, N);\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tif(d[i] <= M){\n\t\t\tcnt1[d[i]]++;\n\t\t}\n\t}\n\t\n\tint dist = d[t];\n\t\n\tshortest_path(t, N);\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tif(d[i] <= M){\n\t\t\tcnt2[d[i]]++;\n\t\t}\n\t}\n\t\n\tlong long int ans = 0;\n\t\n\tfor(int i = 0; i <= dist - 2; i++){\n\t\tans += cnt1[i] * cnt2[dist - i - 2];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\n\nint n, m, s, t;\n\nll dis_from_s[100000], dis_from_t[100000];\nll cnt_dis_s[200000], cnt_dis_t[200000];\nvector<vector<int>> edge;\n\nvoid djk(int pos, ll dis[], ll cnt[]) {\n\t\n\tpriority_queue<P, vector<P>, greater<P>> pq;\n\tpq.push(P(0, pos));\n\tdis[pos] = 0;\n\twhile (pq.size()) {\n\t\tauto tmp = pq.top(); pq.pop();\n\t\tif (dis[tmp.second] < tmp.first)continue;\n\n\t\tcnt[tmp.first]++;\n\n\t\tfor (int i = 0; i < edge[tmp.second].size(); i++) {\n\t\t\tint next = edge[tmp.second][i];\n\t\t\tif (dis[next] > dis[tmp.second] + 1) {\n\t\t\t\tdis[next] = dis[tmp.second] + 1;\n\t\t\t\tpq.push(P(dis[tmp.second] + 1, next));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\n\tcin >> n >> m >> s >> t;\n\ts--, t--;\n\tedge.resize(n);\n\tfor (int i = 0; i < n; i++)dis_from_s[i] = 100000000, dis_from_t[i] = 1000000000;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tdjk(s, dis_from_s, cnt_dis_s), djk(t, dis_from_t, cnt_dis_t);\n\t\n\tll ans = 0;\n\t\n\tint s_to_t = dis_from_s[t];\n\n\tfor (int i = 0; i <= s_to_t - 2; i++) {\n\t\tans += (cnt_dis_s[i] * cnt_dis_t[s_to_t - 2 - i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF (int)1e6\nusing namespace std;\n\n\nvoid calc(int s, vector<int> &d, vector<vector<int> > &adj){\n\td[s] = 0;\n\tpriority_queue<pair<int,int> > npos;\n\tnpos.push(make_pair(0,s) );\n\n\twhile(!npos.empty()){\n\t\tpair<int,int> temp = npos.top();\n\t\tnpos.pop();\n\t\tint cost = temp.first + 1;\n\t\tint now = temp.second;\n\t\tfor(int i = 0, im = adj[now].size(); i < im; ++i){\n\t\t\tint next = adj[now][i];\n\t\t\tif(d[next] == INF){\n\t\t\t\td[next] = cost;\n\t\t\t\tnpos.push(make_pair(cost, next));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tint n,m,s,t;\n\tcin >> n >> m >> s >> t;\n\tvector<vector<int> > adj(n+1,vector<int>(0));\n\tfor(int i = 0; i < m; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n/*\n\tfor(int i = 1; i < n+1 ; i++){\n\t\tcout << i << \" ; \";\n\t\tfor(int j = 0; j < adj[i].size(); j++){\n\t\t\tcout << adj[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\tvector<int> sd(n+1,INF);\n\tvector<int> td(n+1,INF);\n\tcalc(s,sd,adj);\n\tcalc(t,td,adj);\n\n\tint stcost = sd[t];\n\t\n\tvector<int> sdis(stcost+1), tdis(stcost+1);\n\n\tfor(int i = 0, im = td.size(); i < im; ++i){\n\t\tif(sd[i] < stcost) sdis[sd[i]]++;\n//\t\tcout << i << \" ; \" << sd[i] << endl;\n\t}\n//\tcout << endl;\n\tfor(int i = 0, im = td.size(); i < im; ++i){\n\t\tif(td[i] < stcost) tdis[td[i]]++;\n//\t\tcout << i << \" ; \" << td[i] << endl;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i <= stcost -2; ++i){\n\t\tans += sdis[i] * tdis[stcost - i -2];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\t\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define int long long\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nbool vis[100000];\nint main(){\n  int n,m,s,t,x,y;\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  vector<int> v[100000];\n  set<pair<int,int> >ss;\n  r(i,m){\n    cin>>x>>y;\n    x--;y--;\n    ss.insert(mk(x,y));\n    ss.insert(mk(y,x));\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int s1[n],t1[n];\n  memset(s1,1e6,sizeof(s1));\n  memset(t1,1e6,sizeof(t1));\n  queue<pair<int,int> >q;\n  q.push(mk(s,0));\n  vis[s]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    s1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  memset(vis,0,sizeof(vis));\n  q.push(mk(t,0));\n  vis[t]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    t1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  int po=s1[t],cc=0;\n  vector<int> d[100000];\n  r(i,n)if(s1[i]<n)d[s1[i]].push_back(i);\n  r(i,n)if(t1[i]<n){\n    int tt=po-t1[i]-2;\n    if(tt>-1)cc+=d[tt].size();\n  }\n  cout<<cc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, M, s, t;\nVVI es;\n\nVI bfs(int p0) {\n\tVI d(N, INF);\n\td[p0] = 0;\n\n\tqueue<int> q;\n\tq.push(p0);\n\n\twhile (q.size()) {\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tint next_cost = d[p] + 1;\n\t\t\n\t\tfor (auto next : es[p]) {\n\t\t\tint &dist = d[next];\n\t\t\tif (next_cost < dist) {\n\t\t\t\tdist = next_cost;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d;\n}\n\nint main(void) {\n\tcin >> N >> M >> s >> t;\n\t--t; --s;\n\tes.resize(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tes[a].PB(b);\n\t\tes[b].PB(a);\n\t}\n\n\t// s, t????????????????????¢?±???????\n\tVI sd = bfs(s);\n\tVI td = bfs(t);\n\tint st = sd[t];\n\n\t// ?????¢->?????°?????????\n\tVI d2c_t(100010);\n\tfor (auto d : td) {\n\t\tif (d == INF) continue;\n\t\td2c_t[d]++;\n\t}\n\n\t// count\n\tLL cnt = 0;\n\tfor (auto d : sd) {\n\t\tif (d == INF) continue;\n\t\tint idx = st - d - 2;\n\t\tif (idx >= 0) {\n\t\t\tcnt += d2c_t[idx];\n\t\t}\n\t}\n\n\tcout << cnt << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n//verified AOJ GRL_1\n#define MAX_V 100000\nstruct edge{int to,cost;};\n\nvoid dijkstra(int s, vector<int> &d, vector<edge> G[MAX_V]){\n    priority_queue< pii,vector<pii>,greater<pii> > que;\n    rep( i,d.size() )d[i]=INF;\n    d[s] = 0;\n    que.push( pii(0,s) );\n    \n    while( que.size() ){\n        pii p=que.top();\n        que.pop();\n        \n        int v=p.second;\n        if(d[v]<p.first)continue;\n        \n        rep(i,G[v].size()){\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost){\n                d[e.to]=d[v]+e.cost;\n                que.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n}\n\nint main(){\n    int v,e,s,t;\n    cin>>v>>e>>s>>t;\n    s--,t--;\n    \n    vector<edge> G[MAX_V];\n    \n    rep(i,e){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        G[a].pb(edge{b,1});\n        G[b].pb(edge{a,1});\n    }\n    \n    vector<int> d1(v),d2(v);\n    dijkstra(s,d1,G);\n    dijkstra(t,d2,G);\n\n    int length = d1[t];\n    assert(length!=INF);\n    \n    vector<int> a(MAX_V,0),b(MAX_V,0);\n    for(auto e:d1)if(e!=INF) a[e]++;\n    for(auto e:d2)if(e!=INF) b[e]++;\n    \n    ll ans = 0;\n    rep(i,MAX_V){\n        int less = length - i - 2;\n        if(less<0)continue;\n        ans += a[i] * b[less];\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nll N, M, S, T, X, Y;\nvector<ll> E[100010];\n\nll wfs(ll *count, ll s, ll t) {\n  bool visited[100010];\n  REP(i, 0, N) visited[i] = false;\n  REP(i, 0, N) count[i] = 0;\n\n  ll dist;\n  queue<pii> q;\n  q.push(pii(0, s));\n\n  while(q.size()) {\n    ll d = q.front().first, v = q.front().second;\n    q.pop();\n\n    if(visited[v]) continue;\n    visited[v] = true;\n\n    count[d]++;\n\n    if(v == t) {\n      dist = d;\n      break;\n    }\n\n    REP(i, 0, E[v].size()) if(!visited[E[v][i]]) q.push(pii(d + 1, E[v][i]));\n  }\n\n  return dist;\n}\n\nint main(void) {\n  cin >> N >> M >> S >> T; S--; T--;\n  REP(i, 0, M) {\n    cin >> X >> Y; X--; Y--;\n    E[X].push_back(Y);\n    E[Y].push_back(X);\n  }\n\n  ll scount[100010], tcount[100010];\n  ll sdist = wfs(scount, S, T);\n  ll tdist = wfs(tcount, T, S);\n\n  ll ans = 0;\n  REP(i, 0, sdist - 1) ans += scount[i] * tcount[tdist - i - 2];\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <map>\n#define INF 1000000000\nusing namespace std;\nstruct po{int node,flg;};\nint n,m,s,g;\nvector <int> G[100001];\nmap <int,int> mp[2];\n\nint bfs_2(){\n  int D[100001]={};\n  queue <int> Q; Q.push(s);\n  while(!Q.empty()){\n    int t=Q.front();Q.pop();\n    if(t==g) return D[g];\n    for(int i=0;i<G[t].size();i++) \n      if(D[G[t][i]]==0)Q.push(G[t][i]), D[G[t][i]] = D[t]+1;\n  }\n  return D[g];\n}\n\nint bfs(){\n  int D[100001];memset(D,-1,sizeof(D));\n  D[s]=D[g]=0;\n  queue <po> Q;\n  mp[0].clear(),mp[1].clear();\n  mp[0][0]++,mp[1][0]++;\n  Q.push(po{s,0}),Q.push(po{g,1});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    for(int i=0;i<G[t.node].size();i++) {\n      if(D[G[t.node][i]]==D[t.node]+1) mp[t.flg][D[t.node]+1]++;\n      if(D[G[t.node][i]]!=-1)continue;\n      Q.push(po{G[t.node][i],t.flg});\n      D[G[t.node][i]] = D[t.node]+1;\n      mp[t.flg][D[t.node]+1]++;\n    }\n  }\n  int DG = bfs_2();\n  int sum=0;\n  map<int,int>::iterator it=mp[0].begin();\n  while(it!=mp[0].end()){\n    if(mp[1].count(DG-2-it->first))sum += it->second * mp[1][DG - it->first-2];\n    it++;\n  }  \n  return sum;\n}\n\nint main() {\n  cin >> n >> m >> s >>g;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  cout << bfs() <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\n\nclass Edge{\n    public:\n        int to, cost;\n        Edge(int to, int cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n    public:\n        int dis;\n        bool isUsed;\n        Node(){\n            this->dis = INF;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\nvoid dijkstra(AdjList const g, int start, int n, int f, int t,vector<Node> node[2]){\n    priority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n    q.push(make_pair(0, start));\n    node[f][start].dis = 0;\n\n    pair<int, int> u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second;\n        node[f][current].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            if(node[f][next].isUsed == 0){\n                if(node[f][next].dis > node[f][current].dis + g[current][i].cost){\n                    node[f][next].dis = node[f][current].dis + g[current][i].cost;\n                    q.push(make_pair(node[f][next].dis, next));\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--; t--;\n\n    AdjList g(n);\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        g[a].emplace_back(Edge{b,1});\n        g[b].emplace_back(Edge{a,1});\n    }\n    vector<Node> node[2];\n    node[0] = vector<Node>(n);\n    node[1] = vector<Node>(n);\n    dijkstra(g,s,n,0,t,node);\n    dijkstra(g,t,n,1,t,node);\n\n    long long cnt[2][100005] = {{0}};\n    rep(i,n){\n        if(node[0][i].dis != INF) cnt[0][node[0][i].dis]++;\n        if(node[1][i].dis != INF) cnt[1][node[1][i].dis]++;\n    }\n    int dist = node[0][t].dis;\n\n    long long ans = 0;\n    rep(i,dist - 1) ans+=cnt[0][i] * cnt[1][dist - i - 2];\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst int MAX_N = 100010;\nvector<pair<int, int> > G[MAX_N];\nvector<int> dijkstra(int start){\n\tvector<int> dist(MAX_N, INF);\n\tdist[start] = 0;//dist[i] :=???start->i?????§??????????????¢\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > >  que;\n\tque.push(make_pair(0, start));\n\twhile(!que.empty()){\n\t\tint cost; int u;//????????§???????????£????????? ?????¨?????????\n\t\tcost = que.top().first, u = que.top().second;\n\t\tque.pop();\n\t\tif(dist[u] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first; int time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[v] > dist[u] + time){//u->v\n\t\t\t\tdist[v] = dist[u] + time;\n\t\t\t\tque.push(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nint N, M, s, t;\nint x[300010], y[300010];\nset<int> dists[100010], distg[100010];\n\nint main(void){\n\tscanf(\"%d %d %d %d\", &N, &M, &s, &t);\n\ts--, t--;\n\trep(i, M) scanf(\"%d %d\", &x[i], &y[i]);\n\trep(i, M) x[i]--, y[i]--;\n\trep(i, M) G[x[i]].pb(mp(y[i], 1)), G[y[i]].pb(mp(x[i], 1));\n\tauto start = dijkstra(s);\n\tauto goal  = dijkstra(t);\n\n\trep(i, N) if(start[i] != INF) dists[start[i]].insert(i);\n\trep(i, N) if(goal[i]  != INF) distg[goal[i]].insert(i);\n\t// set<pair<int, int> > ans;\n\tll ans = 0;\n\tint len = start[t];\n\t// printf(\"len %d\\n\", len);\n\trep(i, len - 1){\n\t\tint d1 = i;\n\t\tint d2 = (len - 2) - i;\n\t\t// printf(\"d1 %d d2 %d\\n\", d1, d2);\n\t\tfor(auto u : dists[d1]){ // s -> u ??? ?????¢ d1\n\t\t\t// u ??¨ v?????°????????°??????\n\t\t\tif(distg[d2].count(u) == 0) ans += distg[d2].size();\n\t\t\telse ans += distg[d2].size() - 1;\n\t\t\t/*\n\t\t\tfor(auto v : distg[d2]){\n\t\t\t\t// printf(\"%d %d\\n\", u, v);\n\t\t\t\tif(u != v) ans.insert(mp(min(u, v), max(u, v)));\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\t// printf(\"%d\\n\", (int)ans.size());\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nconst int MAX_N = 100005;\n\nint sdir[MAX_N];\nint tdir[MAX_N];\nint spt[MAX_N];\nint tpt[MAX_N];\nmap<P,int> mp;\nvector<int> G[MAX_N];\n\nvoid bfs(int u,int* flag)\n{\n    queue<P> que;\n    que.push(P(u,0));\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,G[p.first].size()){\n            if(flag[G[p.first][i]] > p.second + 1){\n                flag[G[p.first][i]] = p.second + 1;\n                que.push(P(G[p.first][i],flag[G[p.first][i]]));\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int n,m,s,t;\n\tscanf(\"%d%d%d%d\",&n,&m,&s,&t);\n\trep(i,m){\n\t\tint x,y;\n        scanf(\"%d%d\",&x,&y);\n        G[x-1].push_back(y-1);\n        G[y-1].push_back(x-1);\n        mp[P(x-1,y-1)]++;\n        mp[P(y-1,x-1)]++;\n\t}\n    fill(sdir,sdir+n,INF);\n    fill(tdir,tdir+n,INF);\n    bfs(s-1,sdir);\n    sdir[s-1] = 0;\n    bfs(t-1,tdir);\n    tdir[t-1] = 0;\n    rep(i,n){\n        if(sdir[i] != INF && tdir[i] != INF){\n            spt[sdir[i]]++;\n            tpt[tdir[i]]++;\n        }\n    }\n    int min_dir = sdir[t-1];\n    ll res = 0;\n    rep(i,min_dir-1){\n        res += (ll)spt[i] * tpt[min_dir - i - 2];\n    }\n    printf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <queue>\n\nint len[100001] = { 0 };\nint len2[100001] = { 0 };\nint count[100001] = { 0 };\nint count2[100001] = { 0 };\nstd::vector<int> e[100001];\n\nint main() {\n    int n, m, s, t;\n    std::cin >> n >> m >> s >> t;\n    s; t;\n\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n\n    std::queue<std::pair<int, int>> q; // first:今の場所 second:cost\n    q.push(std::make_pair(s, 0));\n\n    int minLen = 0;\n    bool isGoal = false;\n    while (!q.empty() && !isGoal) {\n        auto node = q.front(); q.pop();\n        node.second++;\n        for (auto to : e[node.first]) {\n            if (len[to] && len[to] <= node.second || to == s) continue;\n            auto next = node;\n            len[to] = next.second;\n            next.first = to;\n            q.push(next);\n\n            if (to == t) {\n                minLen = next.second;\n                isGoal = true;\n                break;\n            }\n        }\n    }\n\n    // 逆方向\n    q = std::queue<std::pair<int, int>>();\n    q.push(std::make_pair(t, 0));\n    isGoal = false;\n    while (!q.empty() && !isGoal) {\n        auto node = q.front(); q.pop();\n        node.second++;\n        // 打ち切り\n        if (node.second > minLen - 2) {\n            break;\n        }\n        for (auto to : e[node.first]) {\n            if ((len2[to] && len2[to] <= node.second) || to == s || to == t) continue;\n\n            auto next = node;\n            len2[to] = next.second;\n            next.first = to;\n            q.push(next);\n\n            if (to == t) {\n                isGoal = true;\n                break;\n            }\n        }\n    }\n\n    // 距離カウント\n    for (auto x : len) {\n        count[x]++;\n    }\n    for (auto x : len2) {\n        count2[x]++;\n    }\n\n    // 数カウント\n    long long num = 0;\n    for (int i = 0; i < minLen - 1; i++) {\n        long long from = count[i];\n        long long to = count2[minLen - (i + 2)];\n        if (!i) from = 1;\n        if (minLen - (i + 2) == 0) to = 1;\n\n        num += from * to;\n    }\n\n    std::cout << num << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\nint bfs(int start, vector<int>& d, vector<vector<int>>& g) {\n\td[start] = 0;\n\tint last = -1;\n\tqueue<int> q;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t\tint cur = q.front();\n\t\tq.pop();\n\t\tlast = cur;\n\t\tfor (int next : g[cur]) {\n\t\t\tif (d[next] != -1) continue;\n\t\t\td[next] = d[cur] + 1;\n\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn last;\n}\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m, s, t; cin >> n >> m >> s >> t; s--; t--;\n\tvector<int> cs(n), ct(n);\n\tvector<vector<int>> g(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tu--; v--;\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tvector<int> ds(n, -1);\n\tvector<int> dt(n, -1);\n\tbfs(s, ds, g);\n\tbfs(t, dt, g);\n\tll res = 0;\n\tint len = ds[t];\n\tfor (int i = 0; i < n; i++) {\n\t\tif (dt[i] != -1) {\n\t\t\tct[dt[i]]++;\n\t\t}\n\t\tif (ds[i] != -1) {\n\t\t\tcs[ds[i]]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint r = len - i - 2;\n\t\tif (r < 0) continue;\n\t\tres += 1LL * cs[i] * ct[r];\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define dbg(x) cout<<#x<<\":\"<<x<<endl\n#define int long long\n#define MOD 1000000007\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nsigned main(){\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n  s--,t--;\n  vector<vector<int> > g(n);\n  for(int i=0;i<m;i++){\n    int x,y;\n    cin>>x>>y;\n    x--,y--;\n    g[x].pb(y);\n    g[y].pb(x);\n  }\n  int INF = 1000000000;\n  queue<P> que;\n  que.push(P(s,0));\n  vector<int> d(n,INF);\n  while(que.size()){\n    int v=que.front().fi;\n    int cost=que.front().se;\n    que.pop();\n    if(d[v]!=INF)continue;\n    d[v]=cost;\n    for(int i=0;i<g[v].size();i++){\n\t int to=g[v][i];\n\t if(d[to]==INF)que.push(P(to,cost+1));\n    }\n  }\n\n  queue<P> que2;\n  que2.push(P(t,0));\n  vector<int> d2(n,INF);\n  while(que2.size()){\n    int v=que2.front().fi;\n    int cost=que2.front().se;\n    que2.pop();\n    if(d2[v]!=INF)continue;\n    d2[v]=cost;\n    for(int i=0;i<g[v].size();i++){\n\t int to=g[v][i];\n\t if(d2[to]==INF)que2.push(P(to,cost+1));\n    }\n  }\n  int l=d[t];\n  vector<int> cntd(l+1,0),cntd2(l+1,0);\n  for(int i=0;i<n;i++){\n    //  cout<<d[i]<<\" \"<<d2[i]<<endl;\n    if(d[i]<=l)cntd[d[i]]++;\n    if(d2[i]<=l)cntd2[d2[i]]++;\n  }\n  \n  int ans=0;\n  for(int i=0;i<=l-2;i++){\n    ans+=cntd[i]*cntd2[l-2-i];\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nstruct aa {\n\tint to;\n\tint time;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\nint main() {\n\tint N, M, S, T; cin >> N >> M >> S >> T;\n\tS--; T--;\n\tvector<vector<int>>edges(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint f, t; cin >> f >> t;\n\t\tf--; t--;\n\t\tedges[f].push_back(t);\n\t\tedges[t].push_back(f);\n\t}\n\n\tvector<int>starttimes(N, 999499);\n\tvector<int>starttimenum(1100000);\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ S,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tstarttimes[atop.to] = atop.time;\n\t\t\tfor (auto i : edges[atop.to]) {\n\t\t\t\tif (starttimes[i] > atop.time + 1) {\n\t\t\t\t\tstarttimes[i] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ i,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < starttimes.size(); ++i) {\n\t\t\tstarttimenum[starttimes[i]]++;\n\t\t}\n\t}\n\tvector<int>goaltimes(N, 999499);\n\tvector<int>goaltimenum(1100000);\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tgoaltimes[atop.to] = atop.time;\n\t\t\tfor (auto i : edges[atop.to]) {\n\t\t\t\tif (goaltimes[i] > atop.time + 1) {\n\t\t\t\t\tgoaltimes[i] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ i,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < goaltimes.size(); ++i) {\n\t\t\tgoaltimenum[goaltimes[i]]++;\n\t\t}\n\t}\n\n\tint fintime = starttimes[T];\n\n\tlong long int ans = 0;\n\tfor (int i = 0; i < fintime-1; ++i) {\n\t\tans += starttimenum[i] * goaltimenum[fintime-i-2];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define INF (1<<26)\n \nint N,M,a,b,si,ti;\nvector<int> G[MAX_N];\nint sd[MAX_N],td[MAX_N];\nint sc[MAX_N],tc[MAX_N];\n \nvoid calc(int si,int d[MAX_N],int c[MAX_N]){\n  for(int i=0;i<MAX_N;i++)d[i]=INF,c[i]=0;\n \n  queue<int> Q;\n  d[si]=0;\n  c[0]++;\n  Q.push(si);\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(d[pos]+1<d[to]){\n    d[to]=d[pos]+1;\n    c[d[to]]++;\n    Q.push(to);\n      }\n    }\n  }\n}\n \nint main(){\n  scanf(\"%d %d %d %d\",&N,&M,&si,&ti);\n  for(int i=0;i<M;i++){\n    scanf(\"%d %d\",&a,&b);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  calc(si,sd,sc);\n  calc(ti,td,tc);\n  \n  int total=sd[ti];\n  long long ans=0,A,B;\n  for(int i=0;i<=N;i++){\n    if(total-2-i<0)continue;\n    A=sc[i];\n    B=tc[total-2-i];\n    ans+=A*B;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct Edge {\n  int v, w;\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvector<int> bfs(int src, const Graph &g) {\n  const int n = g.size();\n  vector<int> cost(n, INF);\n  queue<int> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const int v = que.front();\n    que.pop();\n    for(int i = 0; i < g[v].size(); ++i) {\n      int nv = g[v][i].v;\n      if(cost[nv] != INF) continue;\n      cost[nv] = cost[v] + 1;\n      que.push(nv);\n    }\n  }\n  return cost;\n}\n\nint main() {\n  for(int N, M, s, t; cin >> N >> M >> s >> t; ) {\n    --s; --t;\n    Graph G(N);\n    for(int i = 0; i < M; ++i) {\n      int x, y; cin >> x >> y;\n      --x; --y;\n      G[x].push_back((Edge){y, 1});\n      G[y].push_back((Edge){x, 1});\n    }\n    vector<int> cs = bfs(s, G);\n    vector<int> ct = bfs(t, G);\n    int mini = cs[t];\n    sort(ct.begin(), ct.end());\n    int res = 0;\n    for(int i = 0; i < N; ++i) {\n      int target = mini - 2 - cs[i];\n      res += upper_bound(ct.begin(), ct.end(), target)\n        - lower_bound(ct.begin(), ct.end(), target);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n// 🔴\n\n// O(ElogE)\n\n// pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    int V, E, S, G; cin >> V >> E >> S >> G;     // V:= 頂点の数    E:= 辺の数    S:= スタートノード　　G:= ゴールノード\n    S--;\n    G--;\n    vector<vector<pair<int, int> > > adjlist(V);      //first := コスト　second := 行先\n\n    //入力\n    for(int i = 0; i < E; i++){\n        int a, b; cin >> a >> b;                    // a ,b 間に辺がある\n        a--;\n        b--;\n        adjlist[a].push_back(make_pair(1, b));\n        adjlist[b].push_back(make_pair(1, a));      \n    }\n\n    //int a, b; cin >> a >> b;\n    //adjlist[a].push_back(make_pair(1, b));\n    //adjlist[b].push_back(make_pair(1, a)); \n    \n\n    vector<int> result_S(V);                 //Sからの距離\n    vector<int> result_G(V);                 //Gからの距離\n    result_S = dijk(S, V, adjlist);\n    result_G = dijk(G, V, adjlist);    \n    //cout << result[G] << endl;\n\n    vector<int> s(100000, 0);\n    vector<int> g(100000, 0);\n    for(int i = 0; i < V; i++){\n\n        if(result_S[i] < 1000000) s[result_S[i]]++;\n        \n        if(result_G[i] < 1000000) g[result_G[i]]++;        \n    }\n\n    int ans = 0;\n    int dis = result_S[G] - 2;\n    //cout << dis << endl;\n    //result[S];\n    for(int i = 0; dis - i >= 0; i++){\n        \n        //cout << i << \" \" << dis - i << \" \" << s[i] << \" \" << g[i] << endl;\n        \n        ans += s[i] * g[dis - i];\n        //else ans += result_S[i] * result_G[dis - i] + result_S[dis - i] * result_G[i];\n        //cout << i << \": \" << result_S[i] << \" \" << result_G[i] << endl;\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<bitset>\n#include<random>\n#include<time.h>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<(ll)m; i++)\n#define FOR(i,n,m) for(long long i=n; i<(ll)m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,m,s,t;\n\tcin>>n>>m>>s>>t;\n\ts--;\n\tt--;\n\tvector<vector<ll>> adj(n);\n\tREP(i,m) {\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tx--;\n\t\ty--;\n\t\tadj[x].pb(y);\n\t\tadj[y].pb(x);\n\t}\n\tvector<ll> froms(n,INF);\n\tvector<ll> fromt(n,INF);\n\tfroms[s]=0;\n\tfromt[t]=0;\n\tqueue<ll> q;\n\tq.push(s);\n\twhile(!q.empty()) {\n\t\tll p=q.front();\n\t\tq.pop();\n\t\tREP(i,adj[p].size()) {\n\t\t\tif(froms[adj[p][i]]>froms[p]+1) {\n\t\t\t\tfroms[adj[p][i]]=froms[p]+1;\n\t\t\t\tq.push(adj[p][i]);\n\t\t\t}\n\t\t}\n\t}\n\tq.push(t);\n\twhile(!q.empty()) {\n\t\tll p=q.front();\n\t\tq.pop();\n\t\tREP(i,adj[p].size()) {\n\t\t\tif(fromt[adj[p][i]]>fromt[p]+1) {\n\t\t\t\tfromt[adj[p][i]]=fromt[p]+1;\n\t\t\t\tq.push(adj[p][i]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<ll> cnt1(n,0);\n\tvector<ll> cnt2(n,0);\n\tREP(i,n) if(froms[i]!=INF) cnt1[froms[i]]++;\n\tREP(i,n) if(fromt[i]!=INF) cnt2[fromt[i]]++;\n\tll ans=0;\n\tREP(i,n) {\n\t\tif(froms[t]-i-2>=0) ans+=cnt1[i]*cnt2[froms[t]-i-2];\n\t}\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nvector<vp> g;\nint n,m;\n\nvi dijkstra(int s){\n    priority_queue<pi,vp,greater<pi>> q;\n    vi d(n,inf);\n    d[s]=0;\n    q.push({0,s});\n    while(!q.empty()){\n        pi p=q.top();q.pop();\n        int v=p.se;\n        if(d[v]<p.fi)continue;\n        rep(i,g[v].size()){\n            pi e=g[v][i];\n            if(d[e.fi]>d[v]+e.se){\n                d[e.fi]=d[v]+e.se;\n                q.push({d[e.fi],e.fi});\n            }\n        }\n    }\n    return d;\n}\n\nint solve(int s,int t){\n    vi d1=dijkstra(s),d2=dijkstra(t);\n    int l=d1[t];\n    vi a1(l+1),a2(l+1);\n    rep(i,n){\n        if(d1[i]<=l)a1[d1[i]]++;\n        if(d2[i]<=l)a2[d2[i]]++;\n    }\n    int ret=0;\n    REP(i,0,l-2){\n        ret+=a1[i]*a2[l-i-2];\n    }\n    return ret;\n}\n\nvoid run(){\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--,t--;\n    g=vector<vp>(n);\n    rep(i,m){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        g[x].pb({y,1});\n        g[y].pb({x,1});\n    }\n    cout<<solve(s,t)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 100010;\nconst int IINF = INT_MAX;\nint V,E,s,t;\nvector<int> G[MAX];\nint mindist[2][MAX]; // 0 -> start, 1 -> goal\nll counter[2][MAX];\n\nvoid BFS(int sp){\n  int index = (sp==t);\n  mindist[index][sp] = 0;\n  deque<int> deq;\n  deq.push_back(sp);\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,G[cur].size()){\n      int next = G[cur][i];\n      if( mindist[index][next] == IINF ) {\n        mindist[index][next] = mindist[index][cur] + 1;\n        deq.push_back(next);\n      }\n    }\n  }\n}\n\nvoid compute(){\n  rep(i,2) rep(j,V) mindist[i][j] = IINF, counter[i][j] = 0;\n  BFS(s);\n  BFS(t);\n  int mini = mindist[0][t];\n  ll answer = 0;\n  rep(i,V) {\n    if( mindist[0][i] != IINF ) ++counter[0][mindist[0][i]];\n    if( mindist[1][i] != IINF ) ++counter[1][mindist[1][i]];\n  }\n  rep(i,mini-1) answer += ( counter[0][i] * counter[1][mini-2-i] );\n  cout << answer << endl;\n}\n\nint main(){\n  scanf(\"%d %d %d %d\",&V,&E,&s,&t);\n  --s,--t;\n  rep(i,E) {\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    --a, --b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nstruct Edge{ int dst, cost; };\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nconst int INF = 1000000000;\nvoid add_edge(Graph& G, int a, int b) {\n    G[a].push_back({b, 1});\n    G[b].push_back({a, 1});\n}\nvector<int> SPFA(const Graph& G, int s) {\n    int n = G.size();\n    vector<int> dist(n, INF);\n    vector<bool> inque(n);\n    queue<int> que;\n\n    dist[s] = 0;\n    que.push(s);\n    inque[s] = true;\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        inque[v] = false;\n        for(Edge e : G[v]) {\n            if(dist[e.dst] > dist[v] + e.cost) {\n                dist[e.dst] = dist[v] + e.cost;\n                if(!inque[e.dst]) {\n                    que.push(e.dst);\n                    inque[e.dst] = true;\n                }\n            }\n        }\n    }\n    return dist;\n}\nint main(){\n    iostream_init();\n    int N, M, s, t;\n    while(cin >> N >> M >> s >> t) {\n        s--; t--;\n        Graph G(N);\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            add_edge(G, a, b);\n        }\n\n        vector<int> ds = SPFA(G, s);\n        vector<int> dt = SPFA(G, t);\n        map<int, int> cnt;\n        for(int x : dt) cnt[x]++;\n        int D = ds[t];\n        long long ans = 0;\n        REP(i, N) {\n            // ds[i] + 1 + E == D-1\n            int E = D - ds[i] - 2;\n            ans += cnt[E];\n        }\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n[100000], m[100000];\nvector<int>rinsetu[100000];\nsigned main() {\n\tunordered_map<int, int>X, Y;\n\tint a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d); c--; d--;\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g; scanf(\"%d%d\", &f, &g);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tmemset(n, -1, sizeof(n));\n\tmemset(m, -1, sizeof(m));\n\tn[c] = 0; m[d] = 0;\n\tqueue<int>Q;\n\tQ.push(c);\n\twhile (Q.size()) {\n\t\tint e = Q.front(); Q.pop();\n\t\tX[n[e]]++;\n\t\tfor (int f : rinsetu[e]) {\n\t\t\tif (n[f] == -1) {\n\t\t\t\tn[f] = n[e] + 1;\n\t\t\t\tQ.push(f);\n\t\t\t}\n\t\t}\n\t}\n\tQ.push(d);\n\twhile (Q.size()) {\n\t\tint e = Q.front(); Q.pop();\n\t\tY[m[e]]++;\n\t\tfor (int f : rinsetu[e]) {\n\t\t\tif (m[f] == -1) {\n\t\t\t\tm[f] = m[e] + 1;\n\t\t\t\tQ.push(f);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < a; i++) {\n\t\tif(m[i]!=-1)ans += X[n[d] - m[i] - 2];\n\t\tif(n[i]!=-1)ans += Y[m[c] - n[i] - 2];\n\t}\n\tprintf(\"%lld\\n\", ans / 2);\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\n\nint a[100020]={0};\n\nint b[100020]={0};\nint st[100020];\nint ts[100020];\nvector<int> G[100020];\npriority_queue<pa,vector<pa>,greater<pa>> pq;\n     signed main(){\nint n,m,s,t;\n     \tcin>>n>>m>>s>>t;\n     \t\n     \tfor(int i=0;i<=n+10;i++)st[i]=-1,ts[i]=-1;\n     \t\n     \tfor(int i=0;i<m;i++){\n     \t\tint r,rr;\n     \t\tcin>>r>>rr;\n     \t\tG[r].pb(rr);\n     \t\tG[rr].pb(r);\n     \t}\n     \t\n     \tpq.push(mp(0,s));\n     \twhile(pq.size()>0){\n     \t\tpa z=pq.top();\n     \t\tpq.pop();\n     \t\tif(st[z.second]>=0) continue;\n     \t\tst[z.second]=z.first;\n     \t\tfor(auto r:G[z.second])pq.push(mp(z.first+1,r));\n     \t\t\n     \t}\n     \t\n     \tpq.push(mp(0,t));\n     \twhile(pq.size()>0){\n     \t\tpa z=pq.top();\n     \t\tpq.pop();\n     \t\tif(ts[z.second]>=0) continue;\n     \t\tts[z.second]=z.first;\n     \t\tfor(auto r:G[z.second])pq.push(mp(z.first+1,r));\n     \t\t\n     \t}\n     \tint dis=st[t];\n     \t\n     \tfor(int i=1;i<=n;i++){\n     \t//\tcout<<st[i]<<endl;\n     \t\tif(st[i]>=0)a[st[i]]++;\n     \t\tif(ts[i]>=0)b[ts[i]]++;\n     \t}\n     \t//cout<<endl;\n     \tint ans=0;\n     \t\n     \tfor(int i=0;i<=dis-2;i++){\n     \t\tans+=a[i]*b[dis-2-i];\n     \t}\n     \tcout<<ans<<endl;\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 0\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nusing Weight = int;\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INF) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Dijkstra O( |E|log|V| )\n//dist: ?§????????????????????????§??????????????¢\n//?????????: ???????????¨????????????(??????-1)\nvector<int> dijkstra(const Graph &g, int s, vector<Weight> &dist) {\n\ttypedef tuple<Weight, int, int> State; //?§?????????????????°?????????? ??? ???\n\tpriority_queue<State, vector<State>, greater<State> >PQ;\n\tint n = g.size();\n\tvector<int> color(n, WHITE);\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INF); //distance\n\tdist[s] = 0; PQ.emplace(0, s, -1); color[s] = GRAY; //?§????\n\twhile (!PQ.empty()) {\n\t\tWeight d; int v; int u;\n\t\ttie(d, v, u) = PQ.top(); PQ.pop(); //dist???????°??????¨??????????´????????????????\n\t\tif (dist[v] < d) continue; //?????§???????????§???????????°??????\n\t\tcolor[v] = BLACK;\n\t\tprev[v] = u;\n\t\tfor (auto &e : g[v]) { //??£??\\????????????????????¨????????????\t\t\n\t\t\tif (color[e.d] == BLACK)continue; //??¢?´¢????????????\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tPQ.emplace(dist[e.d], e.d, v);\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\nsigned main() {\n\tint N, M, s, t; cin >> N >> M >> s >> t; s--, t--;\n\tGraph G(N);\n\trep(i, 0, M) {\n\t\tint x, y; cin >> x >> y; x--, y--;\n\t\tG[x].emplace_back(x, y, 1);\n\t\tG[y].emplace_back(y, x, 1);\n\t}\n\tvector<int> dist;\n\tdijkstra(G, s, dist);\n\tdumpc(dist);\n\tint mi = dist[t];\n\n\tvector<int> cnt(N, 0);\n\tfor (auto &d : dist)if (d < N)cnt[d]++;\n\n\tdumpc(cnt);\n\tvector<int> dist2;\n\tdijkstra(G, t, dist2);\n\tdumpc(dist2);\n\tvector<int> cnt2(N, 0);\n\tfor (auto &d : dist2)if (d < N)cnt2[d]++;\n\tdumpc(cnt2);\n\n\tint ans = 0;\n\trep(i, 0, mi - 1) {\n\t\tans += cnt[i] * cnt2[mi - 1 - i - 1];\n\t\tdump(ans);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll c[2][100010],d[100010],INF=1<<29;\nvector<ll> v[100010];\nll n,m,s,t;\n\nvoid bfs(ll s,ll k) {\n  fill(d,d+n+1,INF);\n  d[s]=0;\n  c[k][0]++;\n  queue<ll> que;\n  que.push(s);\n  while(!que.empty()) {\n    ll x=que.front();que.pop();\n    for(int i=0; i<v[x].size(); i++) {\n      ll y=v[x][i];\n      if(d[y]<=d[x]+1) continue;\n      d[y]=d[x]+1;\n      c[k][d[y]]++;\n      que.push(y);\n    }\n  }\n}\n  \n\nint main() {\n  cin >> n >> m >> s >> t;\n  for(ll i=0; i<m; i++) {\n    ll x,y;\n    cin >> x >> y;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  memset(c,0,sizeof(c));\n  bfs(s,0);\n  bfs(t,1);\n  ll z=d[s],ans=0;\n  for(ll i=0; i<z-1; i++) ans+=c[0][i]*c[1][z-i-2];\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> dijkstra(const Graph &g, int st){\n    vector<int> d(g.size(),INF);\n    d[st] = 0;\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push(P(0,st)); // P(dis, pos)\n    while(!que.empty()){\n        int dist = que.top().first;\n        int v = que.top().second;\n        que.pop();\n        if(d[v]<dist) continue;\n        for(const auto &to: g[v]){\n            if(d[to]<d[v]) continue;\n            d[to] = d[v] + 1;\n            que.push(P(d[to], to));\n        }\n    }\n    return d;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m,st,gt;cin>>n>>m>>st>>gt;\n    st--;gt--;\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int x,y; cin>>x>>y; x--;y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<int> ds=dijkstra(g,st),dt=dijkstra(g,gt);\n    int dis=ds[gt];\n    if(dis==1){\n        cout<<0<<endl;\n    }\n    else{\n        map<int,int> mp;\n        for(int i=0;i<n;i++){\n            int d=dt[i];\n            mp[d]++;\n        }\n        int res=0;\n        for(int i=0;i<n;i++){\n            int d=dis-2-ds[i];\n            res+=mp[d];\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int N=100000, M=300000;\nconst int INF=12345678;\n\nint d[2][N];\nvector<int> G[N];\n\nint d_ct=0;\nvoid dijkstra(int s)\n{\n    // dijkstra\n    priority_queue<pi,vector<pi>,greater<pi>> que;\n    fill(d[d_ct],d[d_ct]+N,INF);\n    d[d_ct][s]=0;\n    que.push(pi(0,s));\n    while(!que.empty())\n    {\n        pi p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[d_ct][v]<p.fi) continue;\n        rep(i,G[v].size())\n        {\n            int nx=G[v][i];\n            if(d[d_ct][nx]>d[d_ct][v]+1)\n            {\n                d[d_ct][nx]=d[d_ct][v]+1;\n                que.push(pi(d[d_ct][nx],nx));\n            }\n        }\n    }\n    ++d_ct;\n}\n\nint cts[N]={0}, ctt[N]={0};\n\nint main()\n{\n    int n,m,s,t;\n    scanf(\" %d %d %d %d\", &n, &m, &s, &t);\n    --s;\n    --t;\n    rep(i,m)\n    {\n        int x,y;\n        scanf(\" %d %d\", &x, &y);\n        --x;\n        --y;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n\n    dijkstra(s);\n    dijkstra(t);\n\n    rep(i,n) if(d[0][i]<N) ++cts[d[0][i]];\n    rep(i,n) if(d[1][i]<N) ++ctt[d[1][i]];\n\n    ll ans=0;\n    rep(i,d[0][t]-1) ans+=(ll)cts[i]*ctt[d[0][t]-2-i];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n// 🔴\n\n// O(ElogE)\n\n// pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    int V, E, S, G; cin >> V >> E >> S >> G;     // V:= 頂点の数    E:= 辺の数    S:= スタートノード　　G:= ゴールノード\n    S--;\n    G--;\n    vector<vector<pair<int, int> > > adjlist(V);      //first := コスト　second := 行先\n\n    //入力\n    for(int i = 0; i < E; i++){\n        int a, b; cin >> a >> b;                    // a ,b 間に辺がある\n        a--;\n        b--;\n        adjlist[a].push_back(make_pair(1, b));\n        adjlist[b].push_back(make_pair(1, a));      \n    }\n\n    //int a, b; cin >> a >> b;\n    //adjlist[a].push_back(make_pair(1, b));\n    //adjlist[b].push_back(make_pair(1, a)); \n    \n\n    vector<int> result_S(V);                 //Sからの距離\n    vector<int> result_G(V);                 //Gからの距離\n    result_S = dijk(S, V, adjlist);\n    result_G = dijk(G, V, adjlist);    \n    //cout << result[G] << endl;\n\n    vector<int> s(1000000, 0);\n    vector<int> g(1000000, 0);\n    for(int i = 0; i < V; i++){\n\n        if(result_S[i] < 10000000) s[result_S[i]]++;\n        \n        if(result_G[i] < 10000000) g[result_G[i]]++;        \n    }\n\n    int ans = 0;\n    int dis = result_S[G] - 2;\n    //cout << dis << endl;\n    //result[S];\n    for(int i = 0; dis - i >= 0; i++){\n        \n        //cout << i << \" \" << dis - i << \" \" << s[i] << \" \" << g[i] << endl;\n        \n        ans += s[i] * g[dis - i];\n        //else ans += result_S[i] * result_G[dis - i] + result_S[dis - i] * result_G[i];\n        //cout << i << \": \" << result_S[i] << \" \" << result_G[i] << endl;\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    int N, M, S, T;\n    vector< vector<int> > G;\n    void input() {\n        cin >> N >> M >> S >> T;\n        S--; T--;\n        G.resize(N);\n        for (int i = 0; i < M; i++) {\n            int x, y; cin >> x >> y; x--; y--;\n            G[x].push_back(y);\n            G[y].push_back(x);\n        }\n    }\n\n    const int INF = 1<<28;\n\n    void dist(int s, vector<int>& d) {\n        d.clear(); d.resize(N, INF);\n        d[s] = 0;\n        queue< pair<int, int> > Q;\n        Q.push(make_pair(s, 0));\n        while (not Q.empty()) {\n            pair<int, int> c = Q.front(); Q.pop();\n            for (int i = 0; i < G[c.first].size(); i++) {\n                int n = G[c.first][i];\n                if (d[n] > c.second + 1) {\n                    d[n] = c.second + 1;\n                    Q.push(make_pair(n, c.second + 1));\n                }\n            }\n        }\n    }\n\n    void solve() {\n        vector<int> d1; dist(S, d1);\n        vector<int> d2; dist(T, d2);\n        int d = d1[T];\n        vector<int> D = d2;\n        sort(D.begin(), D.end());\n        ll ans = 0;\n        for (int i = 0; i < N; i++) {\n            int k = d - d1[i] - 2;\n            if (k < 0) continue;\n            ans += upper_bound(D.begin(), D.end(), k) - lower_bound(D.begin(), D.end(), k);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct sta{\n  int x;\n  int pre;\n  int ppre;\n};\n\nint main(){\n  int n,m,s,t;\n  cin >> n >> m >> s >> t;\n  s--,t--;\n  vector<vector<int>> e(n);\n  int u,v;\n  rep(i,m){\n    cin >> u >> v;\n    e[u-1].push_back(v-1);\n    e[v-1].push_back(u-1);\n  }\n  int len;\n  vector<LL> sd(n+1,0),td(n+1,0);\n  vector<int> dist(n,-1);\n  queue<pair<int,int>> q;\n  q.push({s,0});\n  dist[s]=0;\n  while(!q.empty()){\n    auto now = q.front();\n    q.pop();\n    for(int nx:e[now.first]){\n      if(dist[nx]==-1){\n        dist[nx]=now.second+1;\n        q.push({nx,now.second+1});\n      }else{ \n        if(dist[nx]==now.second+1){\n        }\n      }\n    }\n  }\n  rep(i,n) if(dist[i]!=-1) sd[dist[i]]++;\n  len=dist[t];\n  dist=vector<int>(n,-1);\n  q.push({t,0});\n  dist[t]=0;\n  while(!q.empty()){\n    auto now = q.front();\n    q.pop();\n    for(int nx:e[now.first]){\n      if(dist[nx]==-1){\n        dist[nx]=now.second+1;\n        q.push({nx,now.second+1});\n      }else{ \n        if(dist[nx]==now.second+1){\n        }\n      }\n    }\n  }\n  rep(i,n) if(dist[i]!=-1) td[dist[i]]++;\n  LL ans=0;\n  rep(i,len-1){\n    if(len-2-i<0) break;\n    ans+=sd[i]*td[len-2-i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (int)1e9\nusing namespace std;\n\nint n, m, s, t;\nvector<vector<int>> edge;\nvector<int> ds, dt;\nqueue<int> qu;\nmap<int, long long> mps, mpt;\n\nlong long solve();\n\nint main() {\n  cin >> n >> m >> s >> t;\n  --s, --t;\n  edge.resize(n);\n  for(int i = 0; i < m; ++i) {\n    int x, y;\n    cin >> x >> y;\n    edge[--x].push_back(--y);\n    edge[y].push_back(x);\n  }\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  ds.assign(n, inf);\n  dt.assign(n, inf);\n  ds[s] = 0;\n  dt[t] = 0;\n  qu.push(s);\n  while(!qu.empty()) {\n    int now = qu.front();\n    qu.pop();\n    for(int i = 0; i < edge[now].size(); ++i)\n      if(ds[edge[now][i]] == inf) {\n        ds[edge[now][i]] = ds[now] + 1;\n        qu.push(edge[now][i]);\n      }\n  }\n  qu.push(t);\n  while(!qu.empty()) {\n    int now = qu.front();\n    qu.pop();\n    for(int i = 0; i < edge[now].size(); ++i)\n      if(dt[edge[now][i]] == inf) {\n        dt[edge[now][i]] = dt[now] + 1;\n        qu.push(edge[now][i]);\n      }\n  }\n  for(int i = 0; i < n; ++i) {\n    ++mps[ds[i]];\n    ++mpt[dt[i]];\n  }\n  long long ans = 0, target = ds[t] - 2;\n  for(auto nmp : mps) {\n    long long nowds = nmp.first, nowdt;\n    nowdt = target - nowds;\n    ans += nmp.second * mpt[nowdt];\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\n#define MAX 100005\nint main(){\n  int n,m,s,t,di;\n  cin >> n >> m >> s >> t;\n  int i,j,k;\n  vector<int> v[MAX];\n  ll d[MAX]={},d2[MAX]={};\n  for(i=0;i<m;i++){\n    cin >> j >> k;\n    v[j].push_back(k);\n    v[k].push_back(j);\n  }\n\n  bool used[MAX]={},used2[MAX]={};\n  queue<P> q;\n  P p,b;\n  p.first=s;\n  p.second=0;\n  q.push(p);\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(used[p.first]) continue;\n    //cout << p.first << \":\" << p.second << endl;\n    if(p.first==t) di=p.second;\n    used[p.first]=true;\n    d[p.second]++;\n    b.second=p.second+1;\n    for(i=0;i<v[p.first].size();i++){\n      b.first=v[p.first][i];\n      q.push(b);\n    }\n  }\n  p.first=t;\n  p.second=0;\n  q.push(p);\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(used2[p.first]) continue;\n    //cout << p.first << \":\" << p.second << endl;\n    used2[p.first]=true;\n    d2[p.second]++;\n    b.second=p.second+1;\n    for(i=0;i<v[p.first].size();i++){\n      b.first=v[p.first][i];\n      q.push(b);\n    }\n  }\n  \n  //cout << di << endl;\n  ll o=0;\n  \n  for(i=0;i<di-1;i++){\n    o+=d[i]*d2[di-2-i];\n  }\n  \n  cout << o << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 100005\nint main(){\n  int n,m,s,t,di;\n  cin >> n >> m >> s >> t;\n  int i,j,k;\n  vector<int> v[MAX];\n  int d[MAX]={},d2[MAX]={};\n  for(i=0;i<m;i++){\n    cin >> j >> k;\n    v[j].push_back(k);\n    v[k].push_back(j);\n  }\n\n  bool used[MAX]={},used2[MAX]={};\n  queue<P> q;\n  P p,b;\n  p.first=s;\n  p.second=0;\n  q.push(p);\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(used[p.first]) continue;\n    //cout << p.first << \":\" << p.second << endl;\n    if(p.first==t) di=p.second;\n    used[p.first]=true;\n    d[p.second]++;\n    b.second=p.second+1;\n    for(i=0;i<v[p.first].size();i++){\n      b.first=v[p.first][i];\n      q.push(b);\n    }\n  }\n  p.first=t;\n  p.second=0;\n  q.push(p);\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(used2[p.first]) continue;\n    //cout << p.first << \":\" << p.second << endl;\n    used2[p.first]=true;\n    d2[p.second]++;\n    b.second=p.second+1;\n    for(i=0;i<v[p.first].size();i++){\n      b.first=v[p.first][i];\n      q.push(b);\n    }\n  }\n  \n  //cout << di << endl;\n  int o=0;\n  \n  for(i=0;i<di-1;i++){\n    o+=d[i]*d2[di-2-i];\n  }\n  \n  cout << o << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nint INF = 1000000000;\nvector<int> dijkstra(int s, int v, vector< vector< pair<int,int> > > G){\n  //s: テ・ツァツ凝ァツつケ, v: テゥツ?づァツつケテヲツ閉ー, G: テゥツ堋」テヲツ篠・テ」ツδェテ」ツつケテ」ツδ暗」ツ??」ツつウテ」ツつケテ」ツδ暗」ツ?ッテヲツュツ」テ」ツ?ァテ・ツ?・テ」ツつ古」ツ?ヲテ」ツ?甘」ツ??\n  priority_queue< pair<int, int> > wait;\n  vector<int> result(v, INF);\n  result[s] = 0;\n  wait.push(make_pair(0, s));\n  while(!wait.empty()){\n    int nowpoint = wait.top().second;\n    int nowcost = wait.top().first;\n    wait.pop();\n    if(nowcost <= result[nowpoint]){\n      for(int i = 0; i < G[nowpoint].size(); ++i){\n\tint nextpoint = G[nowpoint][i].second;\n\tint nextcost = -nowcost + G[nowpoint][i].first;\n\tif(nextcost < result[nextpoint]){\n\t  wait.push(make_pair(-nextcost, nextpoint));\n\t  result[nextpoint] = nextcost;\n\t}\n      }\n    }\n  }\n  return result;\n}\n\nlong long int count(vector< vector<pii> > &G, int s, int t, int N){\n  vector<int> r1 = dijkstra(s,N,G), r2 = dijkstra(t,N,G);\n  int l = r1[t], d1[l+1], d2[l+1];\n  fill(d1,d1+l+1,0);\n  fill(d2,d2+l+1,0);\n  for(int i = 0; i < N; ++i){\n    if(r1[i] <= l) ++d1[r1[i]];\n    if(r2[i] <= l) ++d2[r2[i]];\n  }\n  long long int ret = 0;\n  for(int i = 0; i < l-1; ++i){\n    ret += (long long int)d1[i]*d2[l-2-i];\n  }\n  return ret;\n}\n\nint main(){\n  int N, M, s, t, x, y;\n  cin >> N >> M >> s >> t;\n  --s;--t;\n  vector< vector<pii> > G(N);\n  for(int i = 0; i < M; ++i){\n    cin >> x >> y;\n    --x;--y;\n    G[x].push_back(make_pair(1,y));\n    G[y].push_back(make_pair(1,x));\n  }\n  cout << count(G,s,t,N) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\ntypedef pair<int, int> State;\nint n;\nvvi edge;\n\nvoid bfs(int s, vi& dist){\n    dist = vi(n, inf);\n    dist[s] = 0;\n\n    queue<int> q;\n    q.push(s);\n\n    while(!q.empty()){\n        int v = q.front(); q.pop();\n\n        for(int u : edge[v]){\n            if(dist[u] != inf) continue;\n\n            dist[u] = dist[v] + 1;\n            q.push(u);\n        }\n    }\n}\n\nint main(void){\n    ll res;\n    for(int m, s, t; cin >> n >> m >> s >> t; cout << res << endl){\n        res = 0;\n\n        s--, t--;\n        edge = vvi(n);\n\n        rep(i, m){\n            int x, y; cin >> x >> y;\n            x--, y--;\n            \n            edge[x].pb(y), edge[y].pb(x);\n        }\n\n        vi dist_fromS, dist_fromT;\n        bfs(s, dist_fromS);\n        bfs(t, dist_fromT);\n\n        map<int, ll> distCnt_fromS, distCnt_fromT;\n        rep(u, n){\n            distCnt_fromS[dist_fromS[u]]++;\n            distCnt_fromT[dist_fromT[u]]++;\n        }\n\n        int path_len = dist_fromS[t];\n\n        rep(i, path_len - 1){\n            res += distCnt_fromS[i] * distCnt_fromT[path_len - i - 2];\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nvector<int> G[100000];\n\nvector<int> bfs(int n,int s){\n  vector<int> dist(n,1e9),visited(n);\n  dist[s]=0;\n  visited[s]=1;\n  queue<int> que;\n  que.push(s);\n  while(!que.empty()){\n    int i = que.front();\n    que.pop();\n    rep(j,G[i].size()){\n      int to = G[i][j];\n      if (visited[to]!=1) {\n        visited[to]=1;\n        dist[to] = dist[i]+1;\n        que.push(to);\n      }\n    }\n  }\n  return dist;\n}\n\n\nint main(){\n\n  int n,m,s,t;\n  cin >> n >> m >> s >> t;\n  s--;\n  t--;\n  rep(i,m){\n    int x,y;\n    cin >> x >> y;\n    x--;\n    y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  vector<int> dist = bfs(n,s);\n  vector<int> dist_r = bfs(n,t);\n  int min_dist = dist[t];\n\n  vector<int> dd(min_dist,0),dd_r(min_dist,0);\n  rep(i,n){\n    if (dist[i]<=min_dist-2)dd[dist[i]]++;\n    if (dist_r[i]<=min_dist-2)dd_r[dist_r[i]]++;\n  }\n  long long sum = 0;\n  for(int i=0;i<min_dist-1;i++){\n    sum += dd[i]*dd_r[min_dist-2-i];\n  }\n  cout << sum << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> dijkstra(const Graph &g, int st){\n    vector<int> d(g.size(),INF);\n    d[st] = 0;\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push(P(0,st)); // P(dis, pos)\n    while(!que.empty()){\n        int dist = que.top().first;\n        int v = que.top().second;\n        que.pop();\n        if(d[v]<=dist+1) continue;\n        for(const auto &to: g[v]){\n            if(d[to]<d[v]) continue;\n            d[to] = d[v] + 1;\n            que.push(P(d[to], to));\n        }\n    }\n    return d;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m,st,gt;cin>>n>>m>>st>>gt;\n    st--;gt--;\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int x,y; cin>>x>>y; x--;y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<int> ds=dijkstra(g,st),dt=dijkstra(g,gt);\n    int dis=ds[gt];\n    if(dis==1){\n        cout<<0<<endl;\n    }\n    else{\n        map<int,int> mp;\n        for(int i=0;i<n;i++){\n            int d=dt[i];\n            mp[d]++;\n        }\n        int res=0;\n        for(int i=0;i<n;i++){\n            int d=dis-2-ds[i];\n            res+=mp[d];\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_cost_sum){\n\t\tnode_id = arg_node_id;\n\t\tcost_sum = arg_cost_sum;\n\t}\n\tint node_id,cost_sum;\n};\n\nint main(){\n\n\tint N,M,start,goal;\n\tscanf(\"%d %d %d %d\",&N,&M,&start,&goal);\n\n\tint* from_start_Dist = new int[N+1];\n\tint* from_goal_Dist = new int[N+1];\n\tint *Dist_num_from_start = new int[N+1];\n\tint *Dist_num_from_goal = new int[N+1];\n\n\tvector<int> V[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfrom_start_Dist[i] = BIG_NUM;\n\t\tfrom_goal_Dist[i] = BIG_NUM;\n\t\tDist_num_from_start[i] = 0;\n\t\tDist_num_from_goal[i] = 0;\n\t}\n\n\tfrom_start_Dist[start] = 0;\n\tfrom_goal_Dist[goal] = 0;\n\tDist_num_from_start[0] = 0;\n\tDist_num_from_goal[0] = 0;\n\n\tint from,to;\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tV[from].push_back(to);\n\t\tV[to].push_back(from);\n\t}\n\n\tqueue<Info> Q;\n\n\tfor(int i = 0; i < V[start].size(); i++){\n\t\tfrom_start_Dist[V[start][i]] = 1;\n\t\tQ.push(Info(V[start][i],1));\n\t}\n\n\tint min_index;\n\n\twhile(!Q.empty()){\n\t\tif(Q.front().cost_sum > from_start_Dist[Q.front().node_id]){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tmin_index = Q.front().node_id;\n\t\t\tQ.pop();\n\t\t}\n\n\t\tfor(int i = 0; i < V[min_index].size();i++){\n\t\t\tif(from_start_Dist[V[min_index][i]] > from_start_Dist[min_index] + 1){\n\t\t\t\tfrom_start_Dist[V[min_index][i]] =from_start_Dist[min_index] + 1;\n\t\t\t\tQ.push(Info(V[min_index][i],from_start_Dist[V[min_index][i]]));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tif(from_start_Dist[i] != BIG_NUM){\n\t\t\tDist_num_from_start[from_start_Dist[i]]++;\n\t\t}\n\t}\n\tint length = from_start_Dist[goal];\n\n\n\tfor(int i = 0; i < V[goal].size(); i++){\n\t\tfrom_goal_Dist[V[goal][i]] = 1;\n\t\tQ.push(Info(V[goal][i],1));\n\t}\n\n\twhile(!Q.empty()){\n\t\tif(Q.front().cost_sum > from_goal_Dist[Q.front().node_id]){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tmin_index = Q.front().node_id;\n\t\t\tQ.pop();\n\t\t}\n\n\t\tfor(int i = 0; i < V[min_index].size();i++){\n\t\t\tif(from_goal_Dist[V[min_index][i]] > from_goal_Dist[min_index] + 1){\n\t\t\t\tfrom_goal_Dist[V[min_index][i]] =from_goal_Dist[min_index] + 1;\n\t\t\t\tQ.push(Info(V[min_index][i],from_goal_Dist[V[min_index][i]]));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tif(from_goal_Dist[i] != BIG_NUM){\n\t\t\tDist_num_from_goal[from_goal_Dist[i]]++;\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 0; i <= length-2; i++){\n\t\tans += Dist_num_from_start[i]*Dist_num_from_goal[(length-2)-i];\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define repp(i, m, n) for(int i = m; i < n; i++)\n#define reps(i, n) for(int i = 1; i <= n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pai;\ntypedef pair<ll,ll> pal;\n\nint skara[100010];\nint sdone[100010];\nint tkara[100010];\nint tdone[100010];\nvector<int> edge[100010];\nqueue<int> q1, q2;\n\nvoid bfss(int v)\n{\n\tsdone[v]=1;\n\tq1.push(v);\n\twhile(!q1.empty())\n\t{\n\t\tint u=q1.front();\n\t\tq1.pop();\n\t\trep(i, edge[u].size())\n\t\t{\n\t\t\tif(sdone[edge[u][i]]==0)\n\t\t\t{\n\t\t\t\tskara[edge[u][i]]=skara[u]+1;\n\t\t\t\tsdone[edge[u][i]]=1;\n\t\t\t\tq1.push(edge[u][i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid bfst(int v)\n{\n\ttdone[v]=1;\n\tq2.push(v);\n\twhile(!q2.empty())\n\t{\n\t\tint u=q2.front();\n\t\tq2.pop();\n\t\trep(i, edge[u].size())\n\t\t{\n\t\t\tif(tdone[edge[u][i]]==0)\n\t\t\t{\n\t\t\t\ttkara[edge[u][i]]=tkara[u]+1;\n\t\t\t\ttdone[edge[u][i]]=1;\n\t\t\t\tq2.push(edge[u][i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, m, s, t, x, y;\n\tcin >> n >> m >> s >> t;\n\trep(i, m)\n\t{\n\t\tcin >> x >> y;\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tbfss(s);\n\tbfst(t);\n\tint kyori=skara[t];\n\tkyori-=2;\n\tint ss[100010]={}, tt[100010]={};\n\treps(i, n)\n\t{\n\t\tss[skara[i]]++;\n\t\ttt[tkara[i]]++;\n\t}\n\tll ans=0;\n\tif(skara[t]>2)\n\t{\n\t\tans+=(ss[kyori]+tt[kyori]);\n\t\treps(j, kyori-1) ans+=((ll)ss[j])*((ll)tt[kyori-j]);\n\t}\n\telse if(skara[t]==2) ans=1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int ll\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1LL<<59)\n\n//verified AOJ GRL_1\n#define MAX_V 100000\nstruct edge{int to,cost;};\n\nvoid dijkstra(int s, vector<int> &d, vector<edge> G[MAX_V]){\n    priority_queue< pii,vector<pii>,greater<pii> > que;\n    rep( i,d.size() )d[i]=INF;\n    d[s] = 0;\n    que.push( pii(0,s) );\n    \n    while( que.size() ){\n        pii p=que.top();\n        que.pop();\n        \n        int v=p.second;\n        if(d[v]<p.first)continue;\n        \n        rep(i,G[v].size()){\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost){\n                d[e.to]=d[v]+e.cost;\n                que.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n}\n\nsigned main(){\n    int v,e,s,t;\n    cin>>v>>e>>s>>t;\n    s--,t--;\n    \n    vector<edge> G[MAX_V];\n    \n    rep(i,e){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        G[a].pb(edge{b,1});\n        G[b].pb(edge{a,1});\n    }\n    \n    vector<int> d1(v),d2(v);\n    dijkstra(s,d1,G);\n    dijkstra(t,d2,G);\n\n    int length = d1[t];\n    assert(length!=INF);\n    \n    vector<int> a(MAX_V,0),b(MAX_V,0);\n    for(auto e:d1)if(e!=INF) a[e]++;\n    for(auto e:d2)if(e!=INF) b[e]++;\n    \n    ll ans = 0;\n    rep(i,MAX_V){\n        int less = length - i - 2;\n        if(less<0)continue;\n        ans += a[i] * b[less];\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    vector<vector<int>> v(n);\n    set<pair<int,int>> se;\n    rep(i,n){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        se.insert(minmax(a,b));\n    }\n    vector<int> used1(n,-1),used2(n,-1);\n    priority_queue<pair<int,int>> pq1;\n    priority_queue<pair<int,int>> pq2;\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    if(dist<2){\n        cout<<0<<endl;\n        return 0;\n    }\n    vector<int> dp1(n,0),dp2(n,0);\n    rep(i,n){\n        dp1[used1[i]]++;\n        dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n\n  long long int n, m, s, t;\n  cin >> n >> m >> s >> t;\n\n  s--;\n  t--;\n\n  vector< vector< long long int > > v;\n  vector< long long int > cs;\n  vector< long long int > ct;\n\n  for ( long long int i = 0; i < n; i++ ) {\n    vector< long long int > vv;\n    v.push_back( vv );\n    cs.push_back( m + 10 );\n    ct.push_back( m + 10 );\n  }\n\n  for ( long long int i = 0; i < m; i++ ) {\n\n    long long int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    v[x].push_back( y );\n    v[y].push_back( x );\n\n  }\n\n  vector< vector< long long int > > ps;\n  vector< vector< long long int > > pt;\n  for ( long long int i = 0; i <= m; i++ ) {\n    vector< long long int > vs;\n    ps.push_back( vs );\n    vector< long long int > vt;\n    pt.push_back( vt );\n  }\n\n\n  queue< long long int > q;\n  q.push( t );\n  ct[t] = 0;\n  pt[0].push_back( t );\n\n  while( q.size() > 0 ) {\n\n    long long int k = q.front();\n    q.pop();\n\n    for ( long long int i = 0; i < v[k].size(); i++ ) {\n\n      if ( ct[ v[k][i] ] > m ) {\n\tct[ v[k][i] ] = ct[k] + 1;\n\tq.push( v[k][i] );\n\tpt[ ct[ v[k][i] ] ].push_back( v[k][i] );\n      }\n\n    }\n\n  }\n\n\n  q.push( s );\n  cs[s] = 0;\n  ps[0].push_back( s );\n\n  while( q.size() > 0 ) {\n\n    long long int k = q.front();\n    q.pop();\n\n    for ( long long int i = 0; i < v[k].size(); i++ ) {\n\n      if ( cs[ v[k][i] ] > m ) {\n\tcs[ v[k][i] ] = cs[k] + 1;\n\tq.push( v[k][i] );\n\tps[ cs[ v[k][i] ] ].push_back( v[k][i] );\n      }\n\n    }\n\n  }\n\n\n  long long int ans = 0;\n\n  long long int k = cs[t] - 2;\n\n  for ( long long int i = 0; i <= k; i++ ) {\n\n    ans += ps[i].size() * pt[k-i].size();\n\n  }\n\n  cout << ans << endl;\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, s, t;\nvector< int > graph[100000];\n\nvoid bfs(int s, vector< int >& v)\n{\n  v.assign(N, -1);\n  queue< int > que;\n  que.push(s);\n  v[s] = 0;\n  while(!que.empty()) {\n    int p = que.front(); que.pop();\n    for(int to : graph[p]) {\n      if(v[to] == -1) {\n        v[to] = v[p] + 1;\n        que.push(to);\n      }\n    }\n  }            \n}\nint main()\n{\n  scanf(\"%d %d %d %d\", &N, &M, &s, &t);\n  --s, --t;\n  for(int i = 0; i < M; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    --x, --y;\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n\n  vector< int > m1, m2;\n  bfs(s, m1);\n  bfs(t, m2);\n  \n  int sum1[100001] = {}, sum2[100001] = {};\n  for(int k : m1) if(k >= 0) sum1[k]++;\n  for(int k : m2) if(k >= 0) sum2[k]++;\n  long long ret = 0;\n  for(int i = 0; i < m1[t] - 1; i++) {\n    ret += 1LL * sum1[i] * sum2[m1[t] - 2 - i];\n  }\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint n, m;\nvector<int> G[MAX];\n\nvector<int> bfs(int s){\n    vector<int> d(n, mod);\n    d[s] = 0;\n    queue<int> que;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        for(auto nv: G[v])if(chmin(d[nv], d[v] + 1)){\n            que.push(nv);\n        }\n    }\n    return d;\n}\n\nint main(){\n    int s, t;\n    scanf(\"%d%d%d%d\", &n, &m, &s, &t);\n    --s; --t;\n    rep(i, m){\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        --a; --b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    auto ds = bfs(s), dt = bfs(t);\n    int dst = ds[t];\n    lint ans = 0, cnt[n+10];\n    memset(cnt, 0LL, sizeof(cnt));\n    rep(i, n)if(dt[i] < n+10) ++cnt[dt[i]];\n    rep(i, n)if(dst-2 - ds[i] >= 0) ans += cnt[dst-2 - ds[i]];\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct state {\n  int cost, use, pos;\n  state(int c, int u, int p) : cost(c), use(u), pos(p){}\n};\n\nvector<int> bfs(vector<vector<pair<int, bool>>>& G, int s, int t, int& shortestLen) {\n  vector<int> dist(G.size(), inf), d2cnt(G.size()+1);\n  dist[s] = 0;\n\n  queue<state> q;\n  q.emplace(0, 0, s);\n\n  while(!q.empty()) {\n    const state s = q.front(); q.pop();\n    d2cnt[s.cost]++;\n    for(auto& e: G[s.pos]) {\n      const int next = e.first;\n      if(dist[next] > s.cost + 1) {\n        dist[next] = s.cost + 1;\n        q.emplace(dist[next], 0, next);\n      }\n    }\n  }\n\n  shortestLen = dist[t];\n  return move(d2cnt);\n}\n\nint main() {\n\n  int N, M, s, t; cin >> N >> M >> s >> t; s--, t--;\n  vector<vector<pair<int, bool>>> G(N);\n  rep(i, M) {\n    int x, y; cin >> x >> y;\n    G[x-1].emplace_back(y-1, false);\n    G[y-1].emplace_back(x-1, false);\n  }\n\n  int shortestLen;\n  auto d2cnt1 = bfs(G, s, t, shortestLen);\n  auto d2cnt2 = bfs(G, t, s, shortestLen);\n\n  ll ans = 0;\n\n  rep(i, N) {\n    if(shortestLen-i-2 >= 0)\n      ans += (ll)d2cnt1[i] * d2cnt2[shortestLen-i-2];\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <list>\n#include <queue>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nllint n, m, s, t;\nvector<llint> G[100005];\nllint distS[100005], distT[100005];\nllint cntS[100005], cntT[100005];\n\nvoid bfs(llint S, llint dist[])\n{\n\tfor(int i = 1; i <= n; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tqueue<llint> Q;\n\tQ.push(S);\n\t\n\tllint v;\n\twhile(Q.size()){\n\t\tv = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0 ;i < G[v].size(); i++){\n\t\t\tllint u = G[v][i];\n\t\t\tif(dist[u] < inf) continue;\n\t\t\tQ.push(u);\n\t\t\tdist[u] = dist[v] + 1;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> n >> m >> s >> t;\n\tllint u, v;\n\tfor(int i = 1; i <= m; i++){\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t\n\tbfs(s, distS);\n\tbfs(t, distT);\n\tllint d = distS[t];\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tif(distS[i] < inf/2) cntS[distS[i]]++;\n\t\tif(distT[i] < inf/2) cntT[distT[i]]++;\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i <= d-2; i++){\n\t\tans += cntS[i]*cntT[d-2-i];\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\nconst int inf = 1e9;\n\nvector<int> bfs(vector<vector<int> > &adj, int s){\n\tvector<int> ret(adj.size(), inf);\n\tret[s] = 0;\n\tqueue<pair<int,int> > wait;\n\twait.push(make_pair(s, 0));\n\twhile(!wait.empty()){\n\t\tint pos = wait.front().first;\n\t\tint cost = wait.front().second;\n\t\twait.pop();\n\t\tfor(int i=0; i<(int)adj[pos].size(); i++){\n\t\t\tif(ret[adj[pos][i]] == inf){\n\t\t\t\tret[adj[pos][i]] = cost+1;\n\t\t\t\twait.push(make_pair(adj[pos][i], cost+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n,m,s,t;\n\tcin >> n >> m >> s >> t;\n\tvector<vector<int> > adj(n+1);\n\tset<pair<int,int> > elist;\n\tfor(int i=0; i<m; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t\telist.insert(make_pair(min(x,y), max(x,y)));\n\t}\n\t\n\tvector<int> froms = bfs(adj, s);\n\tvector<int> fromt = bfs(adj, t);\n\tint dist_st = froms[t];\n\tvector<pair<int,int> > pfromt(n+1);\n\tfor(int i=0; i<n+1; i++){\n\t\tpfromt[i] = make_pair(fromt[i], i);\n\t}\n\tsort(pfromt.begin(), pfromt.end());\n\t\n\tint ans = 0;\n\tfor(int i=1; i<n+1; i++){\n\t\tint target = dist_st -froms[i] -2;\n\t\tvector<pair<int,int> >::iterator it;\n\t\tit = lower_bound(pfromt.begin(), pfromt.end(), make_pair(target, 0));\n\t\twhile(it->first == target){\n\t\t\tint vmin = min(i, it->second);\n\t\t\tint vmax = max(i, it->second);\n\t\t\tif(elist.find(make_pair(vmin, vmax)) == elist.end()){\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1<<28;\n \ntypedef long long lli;\n \nstruct Edge {\n  int v, w;\n};\n \ntypedef vector<vector<Edge> > Graph;\n \nvector<int> bfs(int src, const Graph &g) {\n  const int n = g.size();\n  vector<int> cost(n, INF);\n  queue<int> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const int v = que.front();\n    que.pop();\n    for(int i = 0; i < g[v].size(); ++i) {\n      int nv = g[v][i].v;\n      if(cost[nv] != INF) continue;\n      cost[nv] = cost[v] + 1;\n      que.push(nv);\n    }\n  }\n  return cost;\n}\n \nint main() {\n  for(int N, M, s, t; cin >> N >> M >> s >> t; ) {\n    --s; --t;\n    Graph G(N);\n    for(int i = 0; i < M; ++i) {\n      int x, y; cin >> x >> y;\n      --x; --y;\n      G[x].push_back((Edge){y, 1});\n      G[y].push_back((Edge){x, 1});\n    }\n    vector<int> cs = bfs(s, G);\n    vector<int> ct = bfs(t, G);\n    int mini = cs[t];\n    sort(ct.begin(), ct.end());\n    lli res = 0;\n    for(int i = 0; i < N; ++i) {\n      if(cs[i] == INF) continue;\n      int target = mini - 2 - cs[i];\n      res += upper_bound(ct.begin(), ct.end(), target)\n        - lower_bound(ct.begin(), ct.end(), target);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\n\n#define MAX 100009\nusing namespace std;\ntypedef pair<int,int> P;\n\ntypedef struct Node\n{\n\tint n;\n\tvector<int>e;\n}Node;\n\nNode G[MAX];\nint SC[MAX], GC[MAX],N,M,s,t;\n\nint dijcstra(int s,int g)\n{\n\tint C[MAX];\n\tmemset(C,0x7f,sizeof(C));\n\tP tmp(0,s);\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(tmp.second==g)\n\t\t\treturn tmp.first;\n\t\tif(tmp.first>=C[tmp.second])\n\t\t\tcontinue;\n\t\tC[tmp.second]=tmp.first;\n\t\tfor(int i=0;i<G[tmp.second].e.size();i++)\n\t\t{\n\t\t\tint nn=G[tmp.second].e[i];\n\t\t\tif(C[nn]>tmp.first+1)\n\t\t\t{\n\t\t\t\tQ.push(make_pair(tmp.first+1,nn));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&M,&s,&t);\n\ts--;t--;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--;y--;\n\t\tG[x].e.push_back(y);\n\t\tG[y].e.push_back(x);\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tSC[i]=dijcstra(s,i);\n\t\t\tGC[i]=dijcstra(t,i);\n\t\t}\n\t}\n\tint mc=SC[t],res=0;\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(SC[i]==-1||GC[j]==-1)continue;\n\t\t\tif(SC[i]+GC[j]+1==mc-1)\n\t\t\t\tres++;\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nstruct Dijkstra {\n  struct Edge {\n    int to;\n    T cost;\n  };\n  vector<int> prev;\n  vector<vector<Edge>> g;\n  Dijkstra(int n) : prev(n, -1), g(n) {}\n\n  void addEdge(int u, int v, T w) {\n    g[u].push_back({v, w});\n    g[v].push_back({u, w});\n  }\n  vector<T> build(int s) {\n    vector<T> dist(g.size(), -1);\n    using Node = pair<T, int>;\n    priority_queue<Node, vector<Node>, greater<Node>> pq;\n    pq.push({dist[s] = 0, s});\n\n    while (!pq.empty()) {\n      auto d = pq.top().first;\n      auto u = pq.top().second;\n      pq.pop();\n      if (dist[u] < d) continue;\n      for (auto&& v : g[u]) {\n        if (dist[v.to] < 0 || dist[v.to] > dist[u] + v.cost) {\n          dist[v.to] = dist[u] + v.cost;\n          prev[v.to] = u;\n          pq.push({dist[v.to], v.to});\n        }\n      }\n    }\n    return dist;\n  }\n  vector<int> getPath(int t) {\n    vector<int> path;\n    for (; t != -1; t = prev[t]) path.push_back(t);\n    reverse(begin(path), end(path));\n    return path;\n  }\n};\n\nint main() {\n  int n, m, s, t;\n  cin >> n >> m >> s >> t, s--, t--;\n  Dijkstra<int> g(n);\n  REP(i, m) {\n    int x, y;\n    cin >> x >> y, x--, y--;\n    g.addEdge(x, y, 1);\n  }\n  auto ds = g.build(s);\n  auto dt = g.build(t);\n  map<int, int> ms, mt;\n  for (auto x : ds) ms[x]++;\n  for (auto x : dt) mt[x]++;\n  ll ans = 0LL;\n  int c = ds[t] - 1;\n  REP(i, c) {\n    ans += (ll)ms[i] * mt[c - 1 - i];\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct edge{\n  int to, cost;\n};\nint qwe = 0;\nvector<edge> G[100000];\nll d[2][100000];\nint lis[2][100000] = {0};\n\nll longinf = 123451234512345LL;\n\nvoid dijkstra(int v, int e, int r){   //(vertex, edge, start)\n  ll res = 0;\n  int i, j;\n  rep(i, v)d[qwe][i] = longinf;\n  d[qwe][r] = 0LL;\n  priority_queue<ll_i, vector<ll_i>, greater<ll_i> > Q;\n  Q.push(mp(0LL, r));\n  for(;!Q.empty();){\n    ll_i now = Q.top();\n    Q.pop();\n    if(d[qwe][now.Y] < now.X)continue;\n    rep(i, G[now.Y].size()){\n      edge tmp = G[now.Y][i];\n      if(d[qwe][tmp.to] > d[qwe][now.Y] + tmp.cost){\n        d[qwe][tmp.to] = d[qwe][now.Y] + tmp.cost;\n        Q.push(mp(d[qwe][tmp.to], tmp.to));\n      }\n    }\n  }\n  return;\n}\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase < 1234567;testcase++){\n    int4(n, m, s, t);\n    --s; --t;\n    rep(i, m){\n      int2(x, y);\n      --x; --y;\n      G[x].pb((edge){y, 1});\n      G[y].pb((edge){x, 1});\n    }\n\n    dijkstra(n, m * 2, s); qwe++;\n    dijkstra(n, m * 2, t);\n    int dist = d[0][t];\n\n    rep(i, 2)rep(j, n)if(d[i][j] < longinf)lis[i][d[i][j]]++;\n\n    ll res = 0;\n    rep(i, dist - 1)res += lis[0][i] * lis[1][dist - 2 - i];\n    pri(res);\n\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int N=100000, M=300000;\nconst int INF=12345678;\n\nint d[N];\nint par[N];\nvector<int> G[N];\nvector<int> D[M];\n\nint ct[M]={0};\n\nint main()\n{\n    int n,m,s,t;\n    scanf(\" %d %d %d %d\", &n, &m, &s, &t);\n    --s;\n    --t;\n    rep(i,m)\n    {\n        int x,y;\n        scanf(\" %d %d\", &x, &y);\n        --x;\n        --y;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n\n    // dijkstra\n    priority_queue<pi,vector<pi>,greater<pi>> que;\n    fill(d,d+N,INF);\n    fill(par,par+N,-1);\n    d[s]=0;\n    que.push(pi(0,s));\n    while(!que.empty())\n    {\n        pi p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[v]<p.fi) continue;\n        rep(i,G[v].size())\n        {\n            int nx=G[v][i];\n            if(d[nx]>d[v]+1)\n            {\n                d[nx]=d[v]+1;\n                par[nx]=v;\n                que.push(pi(d[nx],nx));\n            }\n        }\n    }\n\n    rep(i,n) if(d[i]<d[t]) ct[d[i]]++;\n\n    rep(i,n)\n    {\n        if(d[i]<M && d[i]>d[t]) D[d[i]].pb(i);\n    }\n    vector<bool> leaf(n,false);\n    leaf[t]=true;\n    for(int i=d[t]+1; i<M; ++i)\n    {\n        rep(j,D[i].size())\n        {\n            int v=D[i][j];\n            if(leaf[par[v]])\n            {\n                leaf[v]=true;\n                ++ct[i];\n            }\n        }\n    }\n\n    ll ans=0;\n    rep(i,d[t]-1) ans+=ct[i];\n    for(int i=d[t]+1; i<M; ++i)\n    {\n        int w=i-d[t];\n        int idx=d[t]-w-2;\n        if(idx<0) break;\n        ans+=(ll)ct[i]*ct[idx];\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n};\n\ntemplate <typename T>\nusing Edges = vector<Edge<T>>;\ntemplate <typename T>\nusing AdjList = vector<Edges<T>>;\n\ntemplate <typename T>\nclass Dijkstra {\n    private:\n        T INF = 1e9;\n        int V;           // 頂点数\n        AdjList<T> adj;  // adj[始点][動的配列で始点から伸びる枝]\n        vector<int> prever;\n\n    public:\n        Dijkstra(int n);\n        vector<T> cost;\n        void AddEdge(int f, int t, int c);\n        bool HasPath(int t);                 // tに至るパスはあるか\n        vector<int> GetShortestPath(int t);  // tへの最短路\n        void Run(int f);\n};\n\ntemplate <typename T>\nDijkstra<T>::Dijkstra(int n) : \n    V(n + 1), adj(V), prever(vector<int>(V, -1)), cost(V)\n{\n    fill(cost.begin(), cost.end(), INF);\n}\n\ntemplate <typename T>\nvoid Dijkstra<T>::AddEdge(int f, int t, int c) {\n    adj[f].push_back(Edge<T>(t, c));\n}\n\ntemplate <typename T>\nbool Dijkstra<T>::HasPath(int t) {\n    return cost[t] != INF;\n}\n\ntemplate <typename T>\nvector<int> Dijkstra<T>::GetShortestPath(int t) {\n    vector<int> path;\n    for (; t != -1; t = prever[t]) path.push_back(t);\n\n    reverse(path.begin(), path.end());\n    return path;\n}\n\ntemplate <typename T>\nvoid Dijkstra<T>::Run(int firstNode) {\n    // 初期化\n    cost.assign(V, INF);\n    prever.assign(V, -1);\n\n    using Pi = pair<T, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> pq;\n\n    cost[firstNode] = 0;\n    pq.push(Pi(cost[firstNode], firstNode));\n\n    while (!pq.empty()) {\n        Pi currentEdge = pq.top();\n        pq.pop();\n        if (cost[currentEdge.second] < currentEdge.first) continue;\n\n        for (Edge<T> tmp : adj[currentEdge.second]) {\n            T sumCost = currentEdge.first + tmp.cost;\n            if (cost[tmp.to] > sumCost) {\n                cost[tmp.to] = sumCost;\n                prever[tmp.to] = currentEdge.second;\n                pq.push(Pi(cost[tmp.to], tmp.to));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--, t--;\n    Dijkstra<int> ds(n), dt(n);\n    \n    vector<vector<int>> graph(n);\n    REP(i, m){\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        ds.AddEdge(x, y, 1);\n        ds.AddEdge(y, x, 1);\n        dt.AddEdge(x, y, 1);\n        dt.AddEdge(y, x, 1);\n    }\n\n    ds.Run(s); dt.Run(t);\n    vector<LL> ds_num(n, 0LL), dt_num(n, 0LL);\n    REP(i, n){\n        if(ds.cost[i] != INF) ds_num[ds.cost[i]]++;\n        if(dt.cost[i] != INF) dt_num[dt.cost[i]]++;\n    }\n    \n    LL ans = 0;\n    REP(i, ds.cost[t]-1){\n        ans += ds_num[i] * dt_num[ds.cost[t]-2-i];\n    }\n\n    cout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\n#define INF (1 << 23)\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, s, t, u, v;\n\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &s); s--;\n\tscanf(\"%d\", &t); t--;\n\n\tvector<vector<int> > G(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &u);\n\t\tscanf(\"%d\", &v);\n\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\n\tvector<int> d1(N, INF); d1[s] = 0;\n\tvector<int> d2(N, INF); d2[t] = 0;\n\n\tqueue<int> que;\n\n\tque.push(s);\n\n\twhile (!que.empty())\n\t{\n\t\tint node = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tif (d1[G[node][i]] == INF)\n\t\t\t{\n\t\t\t\td1[G[node][i]] = d1[node] + 1; que.push(G[node][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tque.push(t);\n\n\twhile (!que.empty())\n\t{\n\t\tint node = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tif (d2[G[node][i]] == INF)\n\t\t\t{\n\t\t\t\td2[G[node][i]] = d2[node] + 1; que.push(G[node][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint shortest = d1[t];\n\n\tvector<int> r1(shortest - 1, 0); for (int i = 0; i < N; i++) { if (d1[i] < shortest - 1) { r1[d1[i]]++; } }\n\tvector<int> r2(shortest - 1, 0); for (int i = 0; i < N; i++) { if (d2[i] < shortest - 1) { r2[d2[i]]++; } }\n\n\tlong long ret = 0;\n\n\tfor (int i = 0; i < shortest - 1; i++)\n\t{\n\t\tret += 1LL * r1[i] * r2[shortest - i - 2];\n\t}\n\t\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nstruct Comp {\n\tbool operator() (pii a, pii b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nint main()\n{\n\tint N, M, s, t;\n\tcin >> N >> M >> s >> t;\n\ts--; t--;\n\n\tmap< int, vector<pii> > edge;\n\trep(i, 0, M)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tedge[x].push_back(pii(y, 1));\n\t\tedge[y].push_back(pii(x, 1));\n\t}\n\n\tvi dist(N, INF);\n\tvb done(N, false);\n\tpriority_queue<pii, vector<pii>, Comp> que;\n\tdist[s] = 0;\n\tque.push(pii(s, 0));\n\twhile (!que.empty())\n\t{\n\t\tpii p = que.top(); que.pop();\n\t\tif (done[p.first]) continue;\n\t\tdone[p.first] = true;\n\t\tfor (pii pp : edge[p.first])\n\t\t{\n\t\t\tint newcost = p.second + pp.second;\n\t\t\tif (newcost < dist[pp.first])\n\t\t\t{\n\t\t\t\tdist[pp.first] = newcost;\n\t\t\t\tque.push(pii(pp.first, newcost));\n\t\t\t}\n\t\t}\n\t}\n\n\tvi dist2(N, INF);\n\tvb done2(N, false);\n\tdist2[t] = 0;\n\tque.push(pii(t, 0));\n\twhile (!que.empty())\n\t{\n\t\tpii p = que.top(); que.pop();\n\t\tif (done2[p.first]) continue;\n\t\tdone2[p.first] = true;\n\t\tfor (pii pp : edge[p.first])\n\t\t{\n\t\t\tint newcost = p.second + pp.second;\n\t\t\tif (newcost < dist2[pp.first])\n\t\t\t{\n\t\t\t\tdist2[pp.first] = newcost;\n\t\t\t\tque.push(pii(pp.first, newcost));\n\t\t\t}\n\t\t}\n\t}\n\n\tint len = dist[t];\n\tvi from_s(len + 1, 0);\n\tvi from_t(len + 1, 0);\n\trep(i, 0, N)\n\t{\n\t\tif (dist[i] <= len)\n\t\t\tfrom_s[dist[i]]++;\n\t\tif (dist2[i] <= len)\n\t\t\tfrom_t[dist2[i]]++;\n\t}\n\n\tll ans = 0;\n\trep(i, 0, len-1)\n\t{\n\t\tans += from_s[i] * from_t[len - 1 - i - 1];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate <typename T>\nstd::vector<T> dijkstra(const Graph<T> &g, int s) {\n    int sz = (int)(g.size());\n    std::vector<T> dist(sz, std::numeric_limits<T>::max());\n    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> pq;\n    dist[s] = 0;\n    pq.push({0, s});\n    while(!pq.empty()) {\n        int d = pq.top().first, now = pq.top().second;\n        pq.pop();\n        if(d > dist[now]) continue;\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to, cost = g[now][i].cost;\n            if(dist[next] > dist[now] + cost) {\n                dist[next] = dist[now] + cost;\n                pq.push({cost, next});\n            }\n        }\n    }\n    return dist;\n}\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing vi = vector<ll>;\nusing vvi = vector<vector<ll>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(ll i=0;i<(ll)(s.size());++i) {\n    cout << s[i];\n    if(i == (ll)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nsigned main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  ll n, m, s, t; cin >> n >> m >> s >> t;\n  s--; t--;\n  Graph<ll> g(n);\n  vector<P> eds;\n  for(ll i=0;i<m;++i) {\n    ll u, v; cin >> u >> v;\n    u--; v--;\n    g[u].push_back(Edge<ll>(u, v, 1));\n    g[v].push_back(Edge<ll>(v, u, 1));\n    eds.push_back({u, v});\n  }\n  vector<ll> froms = dijkstra(g, s), fromt = dijkstra(g, t);\n  ll d = froms[t];\n  map<ll, ll> cnts, cntt;\n  for(ll i=0;i<n;++i) {\n    cnts[froms[i]]++;\n  }\n  for(ll i=0;i<n;++i) {\n    cntt[fromt[i]]++;\n  }\n  ll ans = 0;\n  for(ll i=0;i<=d-2;++i) {\n    ans += cnts[i] * cntt[d-2 - i];\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\n#define INF (1 << 23)\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, s, t, u, v;\n\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &s); s--;\n\tscanf(\"%d\", &t); t--;\n\n\tvector<vector<int> > G(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &u);\n\t\tscanf(\"%d\", &v);\n\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\n\tvector<int> d1(N, INF); d1[s] = 0;\n\tvector<int> d2(N, INF); d2[t] = 0;\n\n\tqueue<int> que;\n\n\tque.push(s);\n\n\twhile (!que.empty())\n\t{\n\t\tint node = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tif (d1[G[node][i]] == INF)\n\t\t\t{\n\t\t\t\td1[G[node][i]] = d1[node] + 1; que.push(G[node][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tque.push(t);\n\n\twhile (!que.empty())\n\t{\n\t\tint node = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tif (d2[G[node][i]] == INF)\n\t\t\t{\n\t\t\t\td2[G[node][i]] = d2[node] + 1; que.push(G[node][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint shortest = d1[t];\n\n\tvector<int> r1(shortest - 1, 0); for (int i = 0; i < N; i++) { if (d1[i] < shortest - 1) r1[d1[i]]++; }\n\tvector<int> r2(shortest - 1, 0); for (int i = 0; i < N; i++) { if (d2[i] < shortest - 1) r2[d2[i]]++; }\n\n\tlong long ret = 0;\n\n\tfor (int i = 0; i < shortest - 1; i++) ret += 1LL * r1[i] * r2[shortest - i - 2];\n\t\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// 01Trie BIT CHT DFT FFT avl cmd cusum dijkstra dinic geo2 gin graph kruskal lca lcm matrix ncm next_combination ppuf segtree st tmp topcoder uf vi \n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int s, d; Weight w; Flow c;\n    Edge() {};\n    Edge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n    g[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n    addArc(g, a, b, w);\n    addArc(g, b, a, w);\n}\n\nvoid bfs(Graph &g, vi &data, int p)\n{\n    deque<int> mmn;\n    mmn.push_back(p);\n    while (mmn.size()) {\n        deque<int> mm;\n        while (mmn.size()) {\n            int x = mmn.front();\n            mmn.pop_front();\n            for (auto i : g[x]) {\n                if (data[i.d] == -1) {\n                    data[i.d] = data[x] + 1;\n                    mm.pb(i.d);\n                }\n            }\n        }\n        mmn = mm;\n    }\n}\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int2(n, m);\n    int2(s, t);\n\n    Graph g(n);\n    for (int i = 0; i < m; i++) {\n        int2(tmpx, tmpy);\n        tmpx--; tmpy--;\n        addEdge(g, tmpx, tmpy );\n    }\n    \n    vi mmn(n, -1), mm(n, -1);\n    mmn[s-1] = 0;\n    mm[t-1] = 0;\n    bfs(g, mmn, s-1);\n    bfs(g, mm, t-1);\n\n    map<int, int> funami, yui;\n    rep(i, mmn.size()) {\n        funami[mmn[i]]++;\n    }\n    rep(i, mm.size()) {\n        yui[mm[i]]++;\n    }\n\n    int ans = 0;\n    for (int i = 0; i < mmn[t-1]-1; i++) {\n        ans += funami[i] * yui[mmn[t-1]-2-i];\n    }\n\n    std::cout << ans << std::endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\ntypedef pair<int, int> State;\nint n;\nmap<int, map<int, int>> cost;\n\nvoid dijkstra(int s, vi& dist){\n    vi used(n);\n    dist = vi(n, inf);\n\n    priority_queue<State, vector<State>> q;\n    dist[s] = 0;\n    q.push(mp(0, s));\n\n    while(!q.empty()){\n        int cur_cost = q.top().F;\n        int cur_v = q.top().S;\n        q.pop();\n\n        used[cur_v] = true;\n\n        rep(u, n){\n            if(cost[cur_v][u] == 0 || used[u]) continue;\n\n            if(cur_cost + cost[cur_v][u] < dist[u]){\n                dist[u] = cur_cost + cost[cur_v][u];\n                q.push(mp(dist[u], u));\n            }\n        }\n    }\n}\n\nint main(void){\n    ll res;\n    for(int m, s, t; cin >> n >> m >> s >> t; cout << res << endl){\n        res = 0;\n\n        s--, t--;\n        cost = map<int, map<int, int>>();\n\n        rep(i, m){\n            int x, y; cin >> x >> y;\n            x--, y--;\n            \n            cost[x][y] = cost[y][x] = 1;\n        }\n\n        vi dist_fromS, dist_fromT;\n        dijkstra(s, dist_fromS);\n        dijkstra(t, dist_fromT);\n\n        map<int, int> distCnt_fromS, distCnt_fromT;\n        rep(u, n){\n            distCnt_fromS[dist_fromS[u]]++;\n            distCnt_fromT[dist_fromT[u]]++;\n        }\n\n        int path_len = dist_fromS[t];\n\n        rep(i, path_len + 1){\n            res += distCnt_fromS[i] * distCnt_fromT[path_len - i - 2];\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nint INF = 1000000000;\nvector<int> dijkstra(int s, int v, vector< vector< pair<int,int> > > G){\n  //s: ?§????, v: ????????°, G: ??£??\\??????????????????????????£??§??\\????????????\n  priority_queue< pair<int, int> > wait;\n  vector<int> result(v, INF);\n  result[s] = 0;\n  wait.push(make_pair(0, s));\n  while(!wait.empty()){\n    int nowpoint = wait.top().second;\n    int nowcost = wait.top().first;\n    wait.pop();\n    if(nowcost <= result[nowpoint]){\n      for(int i = 0; i < G[nowpoint].size(); ++i){\n\tint nextpoint = G[nowpoint][i].second;\n\tint nextcost = -nowcost + G[nowpoint][i].first;\n\tif(nextcost < result[nextpoint]){\n\t  wait.push(make_pair(-nextcost, nextpoint));\n\t  result[nextpoint] = nextcost;\n\t}\n      }\n    }\n  }\n  return result;\n}\n\nlong long int count(vector< vector<pii> > &G, int s, int t, int N){\n  vector<int> r1 = dijkstra(s,N,G), r2 = dijkstra(t,N,G);\n  int l = r1[t], d1[l+1], d2[l+1];\n  fill(d1,d1+l+1,0);\n  fill(d2,d2+l+1,0);\n  for(int i = 0; i < N; ++i){\n    if(r1[i] <= l) ++d1[r1[i]];\n    if(r2[i] <= l) ++d2[r2[i]];\n  }\n  long long int ret = 0;\n  for(int i = 0; i < l-1; ++i){\n    ret += (long long int)d1[i]*d2[l-2-i];\n  }\n  return ret;\n}\n\nint main(){\n  int N, M, s, t, x, y;\n  cin >> N >> M >> s >> t;\n  --s;--t;\n  vector< vector<pii> > G(N);\n  for(int i = 0; i < M; ++i){\n    cin >> x >> y;\n    --x;--y;\n    G[x].push_back(make_pair(1,y));\n    G[y].push_back(make_pair(1,x));\n  }\n  cout << count(G,s,t,N) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\nusing Graph = vector< vector<int> >;\nusing ll = long long int;\n\nconst int INF = 1 << 29;\nint dist_st;\n\nvector<int> calc_dist(const Graph &G, int s, int t) {\n    int N = G.size();\n    vector<int> dist(N, INF);\n    dist[s] = 0;\n    \n    queue<int> que;\n    que.emplace(s);\n    while(que.size()) {\n        int cur = que.front(); que.pop();\n        for(auto to : G[cur]) {\n            if(dist[to] > dist[cur] + 1) {\n                dist[to] = dist[cur] + 1;\n                que.emplace(to);\n            }\n        }\n    }\n\n    dist_st = dist[t];\n    vector<int> min_dist(N+1);\n    for(int i=0; i<N; i++) if(dist[i] <= N) min_dist[ dist[i] ]++;\n    return min_dist;\n}\n\nint main() {\n    int N, M, s, t; cin >> N >> M >> s >> t; s--; t--;\n    Graph G(N);\n    for(int i=0; i<M; i++) {\n        int u, v; cin >> u >> v; u--; v--;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    vector<int> ds = calc_dist(G, s, t), dt = calc_dist(G, t, s);\n    \n    ll ans = 0;\n    for(int i=0; i<=N; i++) {\n        int target = dist_st - 2 - i;\n        if(target < 0) continue;\n        ans += 1LL * ds[i] * dt[target];\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define make make_pair\n#define N 100002\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nvoid bfs(ll,ll);\nll n,m,s,t,a,b,cost[2][N],mincost,ans;\nvector<ll> c[N];\nll C[N];\n\nint main(){\n  cin>>n>>m>>s>>t;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    c[a].push_back(b);\n    c[b].push_back(a);\n  }\n  bfs(0,s);\n  bfs(1,t);\n  for(int i=0;i<=mincost-2;i++) ans+=cost[0][i]*cost[1][mincost-2-i];\n  if(mincost-2<0) cout<<0<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}\n\nvoid bfs(ll index,ll start){\n  queue<P> q;\n  for(int i=1;i<=n;i++) C[i]=INF;\n  q.push(make(0,start));\n  C[start]=0;\n  while(!q.empty()){\n    P k=q.front(); q.pop();\n    int cos=k.first,u=k.second;\n    for(int i=0;i<(int)c[u].size();i++){\n      int nu=c[u][i];\n      if(C[nu]>cos+1){\n\tC[nu]=cos+1;\n\tq.push(make(C[nu],nu));\n      }\n    }\n  }\n  if(!index) mincost=C[t];\n  for(int i=1;i<=n;i++){\n    if(C[i]==INF) continue;\n    cost[index][C[i]]++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M,S,T;\nvector<int>G[100000];\n\nvint bfs(int s){\n    vint dist(N,1001001001);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n    while(que.size()){\n        int v=que.front();\n        que.pop();\n        for(auto u:G[v]){\n            if(dist[u]!=1001001001)continue;\n            dist[u]=dist[v]+1;\n            que.push(u);\n        }\n    }\n    return dist;\n}\n\nsigned main(){\n    cin>>N>>M>>S>>T;\n    S--;T--;\n    rep(i,M){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n\n    vint distS=bfs(S);\n    vint distT=bfs(T);\n\n    int D=distS[T]-1;\n\n    vint cntS(N),cntT(N);\n    rep(i,N){\n        if(distS[i]<N)cntS[distS[i]]++;\n        if(distT[i]<N)cntT[distT[i]]++;\n    }\n\n    int ans=0;\n    for(int i=0;i<D;i++){\n        ans+=cntS[i]*cntT[D-i-1];\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap<int, vector<int> > edges;\n\n// ?????¢?????????\nint s2t[100001];\nint t2s[100001];\n\n// ???????????¢???????????°\nint s2t_kinds[100001];\nint t2s_kinds[100001];\n\nvoid bfs(int s, int* kyori) {\n    queue<pair<int, int> > q;\n    q.push( make_pair(s,0) );\n\n    while (!q.empty()) {\n        pair<int,int> p = q.front(); q.pop();\n        int curr = p.first;\n        int step = p.second;\n        for (int i=0; i<edges[curr].size(); i++) {\n            int next = edges[curr][i];\n            if (*(kyori + next) != -1) continue;\n            *(kyori + next) = step + 1;\n            q.push( make_pair(next, step + 1) );\n        }\n    }\n}\n\nint main() {\n    int n,m,s,t; cin >> n >> m >> s >> t;\n    for (int i=0; i<m; i++) {\n        int x,y; cin >> x >> y;\n        if (edges.count(x) == 0) {\n            vector<int> v; v.push_back(y);\n            edges[x] = v;\n        } else {\n            edges[x].push_back(y);\n        }\n        if (edges.count(y) == 0) {\n            vector<int> v; v.push_back(x);\n            edges[y] = v;\n        } else {\n            edges[y].push_back(x);\n        }\n    }\n\n    // init\n    for (int i=0; i<=n; i++) s2t[i] = t2s[i] = -1;\n    s2t[s] = t2s[t] = 0;\n\n    bfs(s,s2t);\n    bfs(t,t2s);\n\n    for (int i=1; i<=n; i++) {\n        if (s2t[i] != -1) {\n            s2t_kinds[ s2t[i] ] += 1;\n        }\n        if (t2s[i] != -1) {\n            t2s_kinds[ t2s[i] ] += 1;\n        }\n    }\n\n    int dist = s2t[t];\n    long long ans = 0;\n    for (int i=0; i<=dist-2; i++) {\n        ans += (long long)s2t_kinds[i] * (long long)t2s_kinds[dist - 2 - i];\n    }\n\n    cout << ans << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 100000\n#define INF (1<<29)\ntypedef long long ll;\n\nvoid bfs(int s,int *d,ll *cnt,vector<int> G[MAX_V]){\n  queue<int> Q; Q.push(s);\n  memset(cnt,0,sizeof(cnt));\n  fill(d,d+MAX_V,INF);\n  d[s] = 0;\n  cnt[d[s]]++;\n  while(!Q.empty()){\n    int v = Q.front(); Q.pop();\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      int to = G[v][i];\n      if(d[v] + 1 < d[to]){\n        d[to] = d[v] + 1;\n        cnt[d[to]]++;\n        Q.push(to);\n      }\n    }\n  }\n}\n\nint main(){\n  int V,E,S,T,x,y;\n  int ds[MAX_V],dt[MAX_V];\n  ll cs[MAX_V],ct[MAX_V];\n  vector<int> G[MAX_V];\n  cin >> V >> E >> S >> T;\n  S--; T--;\n  for(int i = 0 ; i < E ; i++){\n    cin >> x >> y; x--; y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  \n  bfs(S,ds,cs,G); \n  bfs(T,dt,ct,G);\n  \n  ll ans = 0LL;\n  int min_dist = ds[T];\n  for(int i = 0 ; i < V ; i++){\n    int j = min_dist-2-i;\n    ans += (j >= 0 ? cs[i]*ct[j] : 0);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct edge{\n  int to, cost;\n};\nint qwe = 0;\nvector<edge> G[100000];\nll d[2][100000];\nll lis[2][100000] = {0};\n\nll longinf = 123451234512345LL;\n\nvoid dijkstra(int v, int e, int r){   //(vertex, edge, start)\n  ll res = 0;\n  int i, j;\n  rep(i, v)d[qwe][i] = longinf;\n  d[qwe][r] = 0LL;\n  priority_queue<ll_i, vector<ll_i>, greater<ll_i> > Q;\n  Q.push(mp(0LL, r));\n  for(;!Q.empty();){\n    ll_i now = Q.top();\n    Q.pop();\n    if(d[qwe][now.Y] < now.X)continue;\n    rep(i, G[now.Y].size()){\n      edge tmp = G[now.Y][i];\n      if(d[qwe][tmp.to] > d[qwe][now.Y] + tmp.cost){\n        d[qwe][tmp.to] = d[qwe][now.Y] + tmp.cost;\n        Q.push(mp(d[qwe][tmp.to], tmp.to));\n      }\n    }\n  }\n  return;\n}\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase < 1234567;testcase++){\n    int4(n, m, s, t);\n    --s; --t;\n    rep(i, m){\n      int2(x, y);\n      --x; --y;\n      G[x].pb((edge){y, 1});\n      G[y].pb((edge){x, 1});\n    }\n\n    dijkstra(n, m * 2, s); qwe++;\n    dijkstra(n, m * 2, t);\n    int dist = d[0][t];\n\n    rep(i, 2)rep(j, n)if(d[i][j] < longinf)lis[i][d[i][j]]++;\n\n    ll res = 0;\n    rep(i, dist - 1)res += lis[0][i] * lis[1][dist - 2 - i];\n    pri(res);\n\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\nvector<int> used1,used2;\nvector<int> dp1,dp2;\npriority_queue<pair<int,int>> pq1;\npriority_queue<pair<int,int>> pq2;\nvector<vector<int>> v;\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    v=vector<vector<int>>(n);\n    // set<pair<int,int>> se;\n    rep(i,m){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    used1=vector<int>(n+10,-1);\n    used2=vector<int>(n+10,-1);\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    dp1=vector<int>(n+10,0);\n    dp2=vector<int>(n+10,0);\n    rep(i,n){\n        if(0<=used1[i]&&used1[i]<=n) dp1[used1[i]]++;\n        if(0<=used2[i]&&used2[i]<=n) dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_V 100000\n#define INF (1<<29)\ntypedef long long ll;\n \nvoid bfs(int s,int *d,ll *cnt,vector<int> G[MAX_V]){\n    queue<int> Q; Q.push(s);\n    memset(cnt,0,sizeof(cnt));\n    fill(d,d+MAX_V,INF);\n    d[s] = 0;\n    cnt[d[s]]++;\n    while(!Q.empty()){\n\tint v = Q.front(); Q.pop();\n\tfor(int i = 0 ; i < (int)G[v].size() ; i++){\n\t    int to = G[v][i];\n\t    if(d[v] + 1 < d[to]){\n\t\td[to] = d[v] + 1;\n\t\tcnt[d[to]]++;\n\t\tQ.push(to);\n\t    }\n\t}\n    }\n}\n \nint main(){\n    int V,E,S,T,x,y;\n    int ds[MAX_V],dt[MAX_V];\n    ll cs[MAX_V],ct[MAX_V];\n    vector<int> G[MAX_V];\n    cin >> V >> E >> S >> T;\n    S--; T--;\n    for(int i = 0 ; i < E ; i++){\n\tcin >> x >> y; x--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n   \n    bfs(S,ds,cs,G); \n    bfs(T,dt,ct,G);\n   \n    ll ans = 0LL;\n    int min_dist = ds[T];\n    for(int i = 0 ; i < V ; i++){\n\tint j = min_dist-2-i;\n\tans += (j >= 0 ? cs[i]*ct[j] : 0);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n\ntemplate<class Type>\nType solve(Type res = Type()){\n    int N,M,s,t; cin >> N >> M >> s >> t;\n    s--; t--;\n    vector<vector<int>> G(N);\n    for(int i = 0; i < M;i++){\n        int u,v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    vector<int> dists(N,INF),distt(N,INF);\n    \n    auto dijkstra = [&](int from,vector<int>& dist){\n        queue<ll> q;\n        dist[from] = 0;\n        q.push(from);\n        while(q.size()){\n            ll u = q.front(); q.pop();\n            for(auto v:G[u]){\n                if(dist[v] > dist[u] + 1){\n                    dist[v] = dist[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n    };\n    \n    \n    dijkstra(s,dists);\n    dijkstra(t,distt);\n    \n    map<int,int> L,R;\n    for(int i = 0; i < N;i++){\n        if(dists[i] != INF) L[dists[i]]++;\n        if(distt[i] != INF) R[distt[i]]++;\n    }\n    int D = dists[t];\n    for(int i = 0; i <= D+1;i++){\n       //if(D-i-2 < 0) continue;\n        res += L[i] * R[D-i-2];\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    //test();\n    //solve<ll>();\n    cout << fixed << setprecision(15) << solve<ll>() << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass Dijkstra {\npublic:\n    struct edge { long long v, dist; };\n\n    struct state {\n        long long v, cost;\n        bool operator>(const state s) const { return cost > s.cost; }\n    };\n\n    const long long INF = (1LL << 60);\n    long long N;\n    vector< vector<edge> > E;\n\n    Dijkstra(long long n): N(n), E(n) {}\n\n    //有効グラフの時はこっち。u→vに距離dで結ぶ\n    void add_directed_edge(long long u, long long v, long long d) {\n        E[u].push_back((edge) { v, d });\n    }\n\n    //無向グラフの時はこっち。uとvを双方向に距離dで結ぶ\n    void add_undirected_edge(long long u, long long v, long long d) {\n        E[u].push_back((edge) { v, d });\n        E[v].push_back((edge) { u, d });\n    }\n\n    //Sを始点として、他の頂点への最短経路を探す\n    vector<long long> shortest_path(long long S) {\n        vector<long long> dp(E.size(), INF);\n        priority_queue<state, vector<state>, greater<state> > q;\n        q.push((state) { S, 0 });\n        while(!q.empty()) {\n            long long v = q.top().v, cost = q.top().cost;\n            q.pop();\n            if(dp[v] <= cost) continue;\n            dp[v] = cost;\n            for(int i=0;i < E[v].size() ; i++) {\n            long long nv = E[v][i].v, ncost = cost + E[v][i].dist;\n            if(dp[nv] > ncost) q.push((state) { nv, ncost });\n            }\n        }\n        return dp;\n    }\n};\n\n\nint main(){\n    int n,m,s,t;\n    cin>>n>>m>>s>>t;\n    s--,t--;\n    Dijkstra d(n);\n    long long x,y;\n    for(int i=0;i<m;i++){\n        cin>>x>>y;\n        x--,y--;\n        d.add_undirected_edge(x,y,1);\n    }\n    vector<long long> vs=d.shortest_path(s);\n    vector<long long> vt=d.shortest_path(t);\n    long long dist=vs[t];\n    map<long long,long long> cs,ct;\n    for(int i=0;i<n;i++){\n        cs[vs[i]]++;\n        ct[vt[i]]++;\n        //cerr<<\"a \"<<vs[i]<<\" \"<<vt[i]<<endl;\n    }\n    long long ans=0;\n    for(int i=0;i<=n;i++){\n        ans+=cs[i]*ct[dist-2-i];\n        //cerr<<\"b\"<<\" \"<<cs[i]<<\" \"<<ct[dist-2-i]<<endl;\n    }\n    cout<<ans<<endl;\n\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "Something"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 500000\n#define INF 999999999999999\n\nvector<long long>x[MAX_N];\nlong long d[MAX_N];\nlong long n,m,a,b,s,t,q;\nqueue<long long>Q;\nlong long sum1[MAX_N];\nlong long sum2[MAX_N];\nlong long sum;\n\nvoid bfs(int P){\n\tfor(int i=0;i<MAX_N;i++){\n\t\td[i]=INF;\n\t}\n\td[P]=0;\n\tQ.push(P);\n\twhile(!Q.empty()){\n\t\tint w=Q.front();Q.pop();\n\t\tfor(int i=0;i<x[w].size();i++){\n\t\t\tif(d[x[w][i]]==INF){\n\t\t\t\td[x[w][i]]=d[w]+1;\n\t\t\t\tQ.push(x[w][i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>n>>m>>s>>t;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b;\n\t\tx[a].push_back(b);\n\t\tx[b].push_back(a);\n\t}\n\tbfs(s);\n\tq=d[t];\n\tfor(int i=1;i<=n;i++){\n\t\tsum1[d[i]]++;\n\t}\n\tbfs(t);\n\tfor(int i=1;i<=n;i++){\n\t\tsum2[d[i]]++;\n\t}\n\tfor(int i=0;i<q-1;i++){\n\t\tsum+=sum1[i]*sum2[q-i-2];\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <queue>\n\nint min[100000] = {0};\nint min2[100000] = { 0 };\nint dp[100000] = {1, 0};\nint dp2[100000] = { 1, 0 };\n\nint main() {\n\tint n, m, s, t;\n\tint len;\n\tstd::cin >> n >> m >> s >> t;\n\tstd::unordered_multimap<int, int> e;//from, to\n\te.reserve(300000);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tstd::cin >> x >> y;\n\t\te.insert(std::make_pair(x, y));\n\t\te.insert(std::make_pair(y, x));\n\t}\n\n\tstd::queue<std::pair<int, int>> q;\n\tq.push(std::make_pair(0, s));\n\n\twhile (!q.empty()) {\n\t\tauto node = q.front(); q.pop();\n\t\tauto it = e.find(node.second);\n\t\tint count = e.count(node.second);\n\t\tfor (int i = 0; i < count; i++, ++it) {\n\t\t\tauto next = node;\n\t\t\tnext.first++;\n\t\t\tnext.second = it->second;\n\t\t\tif (next.second == s || (min[next.second] > 0 && min[next.second] <= next.first)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmin[next.second] = next.first;\n\t\t\tdp[next.first]++;\n\t\t\tif (next.second == t) len = next.first;\n\t\t\tq.push(next);\n\t\t}\n\t}\n\n\tq.push(std::make_pair(0, t));\n\twhile (!q.empty()) {\n\t\tauto node = q.front(); q.pop();\n\t\tauto it = e.find(node.second);\n\t\tint count = e.count(node.second);\n\t\tfor (int i = 0; i < count; i++, ++it) {\n\t\t\tauto next = node;\n\t\t\tnext.first++;\n\t\t\tnext.second = it->second;\n\t\t\tif (next.second == t || (min2[next.second] > 0 && min2[next.second] <= next.first)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmin2[next.second] = next.first;\n\t\t\tdp2[next.first]++;\n\t\t\tq.push(next);\n\t\t}\n\t}\n\n\tlong long count = 0;\n\tfor (int i = 0; i <= len - 2; i++) {\n\t\t\tcount += dp[i] * dp2[len - i - 2];\n\t}\n\tstd::cout << count << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\nusing namespace std;\ntypedef long long LL;\nconst int INF = 999999999;\n\nstruct edge{\n    int src, to, cost;\n};\nusing Edges = vector<edge>;\nusing WeightedGraph = vector<Edges>;\n\nvector<int> dijkstra(WeightedGraph &G, int st){\n    vector<int> dist(G.size(), INF);\n    using pi = pair<int, int>;\n    priority_queue<pi, vector<pi>, greater<pi>> q;\n    dist[st] = 0;\n    q.push(mp(dist[st], st));\n    while(!q.empty()){\n        int cost, idx;\n        tie(cost, idx) = q.top(); q.pop();\n        if(dist[idx] < cost) continue;\n        for(auto &e: G[idx]){\n            if(dist[e.to] <= cost+e.cost) continue;\n            dist[e.to] = cost+e.cost;\n            q.push(mp(dist[e.to], e.to));\n        }\n    }\n    return dist;\n}\n\nint main(){\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n    s--; t--;\n    WeightedGraph G(N);\n    rep(i, M){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        G[x].emplace_back((edge){x, y, 1});\n        G[y].emplace_back((edge){y, x, 1});\n    }\n    vector<int> ds, dt;\n    ds = dijkstra(G, s);\n    dt = dijkstra(G, t);\n    int X = ds[t];\n    map<int, int> ms, mt;\n    rep(i, N){\n        ms[ds[i]]++;\n        mt[dt[i]]++;\n    }\n\n    LL ans = 0;\n    for(auto &i: ms){\n        int tmp = X-2-i.first;\n        ans += 1LL*i.second*mt[tmp];\n    }\n    cout << ans << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> dijkstra(const Graph &g, int st){\n    vector<int> d(g.size(),INF);\n    d[st] = 0;\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push(P(0,st)); // P(dis, pos)\n    while(!que.empty()){\n        int dist = que.top().first;\n        int v = que.top().second;\n        que.pop();\n        if(d[v]<dist) continue;\n        for(const auto &to: g[v]){\n            if(d[to]<=d[v]+1) continue;\n            d[to] = d[v] + 1;\n            que.push(P(d[to], to));\n        }\n    }\n    return d;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m,st,gt;cin>>n>>m>>st>>gt;\n    st--;gt--;\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int x,y; cin>>x>>y; x--;y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<int> ds=dijkstra(g,st),dt=dijkstra(g,gt);\n    int dis=ds[gt];\n    if(dis==1){\n        cout<<0<<endl;\n    }\n    else{\n        map<int,int> mp;\n        for(int i=0;i<n;i++){\n            int d=dt[i];\n            mp[d]++;\n        }\n        ll res=0;\n        for(int i=0;i<n;i++){\n            int d=dis-2-ds[i];\n            res+=mp[d];\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <queue>\n\nint min[100000] = {0};\nint min2[100000] = { 0 };\nint dp[100000] = {1, 0};\nint dp2[100000] = { 1, 0 };\n\nint main() {\n\tint n, m, s, t;\n\tint len;\n\tstd::cin >> n >> m >> s >> t;\n\tstd::unordered_multimap<int, int> e;//from, to\n\te.reserve(300000);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tstd::cin >> x >> y;\n\t\te.insert(std::make_pair(x, y));\n\t\te.insert(std::make_pair(y, x));\n\t}\n\n\tstd::queue<std::pair<int, int>> q;\n\tq.push(std::make_pair(0, s));\n\n\twhile (!q.empty()) {\n\t\tauto node = q.front(); q.pop();\n\t\tauto it = e.find(node.second);\n\t\tint count = e.count(node.second);\n\t\tfor (int i = 0; i < count; i++, ++it) {\n\t\t\tauto next = node;\n\t\t\tnext.first++;\n\t\t\tnext.second = it->second;\n\t\t\tif (next.second == s || (min[next.second] > 0 && min[next.second] <= next.first)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmin[next.second] = next.first;\n\t\t\tdp[next.first]++;\n\t\t\tif (next.second == t) len = next.first;\n\t\t\tq.push(next);\n\t\t}\n\t}\n\n\tq.push(std::make_pair(0, t));\n\twhile (!q.empty()) {\n\t\tauto node = q.front(); q.pop();\n\t\tauto it = e.find(node.second);\n\t\tint count = e.count(node.second);\n\t\tfor (int i = 0; i < count; i++, ++it) {\n\t\t\tauto next = node;\n\t\t\tnext.first++;\n\t\t\tnext.second = it->second;\n\t\t\tif (next.second == t || (min2[next.second] > 0 && min2[next.second] <= next.first)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmin2[next.second] = next.first;\n\t\t\tdp2[next.first]++;\n\t\t\tq.push(next);\n\t\t}\n\t}\n\n\tint count = 0;\n\tfor (int i = 0; i <= len - 2; i++) {\n\t\t\tcount += dp[i] * dp2[len - i - 2];\n\t}\n\tstd::cout << count << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int inf = 1e9;\n\nvector<int> bfs(vector<vector<int> > &adj, int s){\n\tvector<int> ret(adj.size(), inf);\n\tret[s] = 0;\n\tqueue<pair<int,int> > wait;\n\twait.push(make_pair(s, 0));\n\twhile(!wait.empty()){\n\t\tint pos = wait.front().first;\n\t\tint cost = wait.front().second;\n\t\twait.pop();\n\t\tfor(int i=0; i<(int)adj[pos].size(); i++){\n\t\t\tif(ret[adj[pos][i]] == inf){\n\t\t\t\tret[adj[pos][i]] = cost+1;\n\t\t\t\twait.push(make_pair(adj[pos][i], cost+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n,m,s,t;\n\tcin >> n >> m >> s >> t;\n\tvector<vector<int> > adj(n+1);\n\tvector<int> x(m),y(m);\n\tfor(int i=0; i<m; i++){\n\t\tcin >> x[i] >> y[i];\n\t\tadj[x[i]].push_back(y[i]);\n\t\tadj[y[i]].push_back(x[i]);\n\t}\n\t\n\tvector<int> froms = bfs(adj, s);\n\tvector<int> fromt = bfs(adj, t);\n\tint dist_st = froms[t];\n\tvector<int> bsums(n+1, 0), bsumt(n+1, 0);\n\tfor(int i=1; i<n+1; i++){\n\t\tif(froms[i]!=inf) bsums[froms[i]]++;\n\t\tif(fromt[i]!=inf) bsumt[fromt[i]]++;\n\t}\n\t\n\tlong long int ans = 0;\n\tfor(int i=0; i<dist_st -1; i++){\n\t\tint j=dist_st -i -2;\n\t\tif(i<j){\n\t\t\tans += bsums[i]*bsumt[j] +bsums[j]*bsumt[i];\n\t\t}else if(i==j){\n\t\t\tans += bsums[i]*bsumt[j];\n\t\t}\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tif(froms[x[i]] + fromt[y[i]] == dist_st-2 ||\n\t\tfroms[y[i]] + fromt[x[i]] == dist_st-2){\n\t\t\t ans--;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    --s;\n    --t;\n    vector<vector<int>> edge(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    vector<int> ds(n, -1);\n    vector<int> cs(n, 0);\n    queue<int> q;\n    q.push(s);\n    ds[s] = 0;\n    ++cs[0];\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        for (int i : edge[p]) {\n            if (ds[i] == -1) {\n                ds[i] = ds[p] + 1;\n                ++cs[ds[i]];\n                q.push(i);\n            }\n        }\n    }\n    vector<int> dt(n, -1);\n    vector<int> ct(n, 0);\n    q.push(t);\n    dt[t] = 0;\n    ++ct[0];\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        for (int i : edge[p]) {\n            if (dt[i] == -1) {\n                dt[i] = dt[p] + 1;\n                ++ct[dt[i]];\n                q.push(i);\n            }\n        }\n    }\n    int l = ds[t] - 1;\n    long long ans = 0;\n    for (int i = 0; i <= l; ++i) {\n        ans += cs[i] * ct[l - i - 1];\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nint N, M, s, t;\nvector<vector<int>> edges;\n\nvector<int> dijkstra(int s) {\n\tpriority_queue<pii, vector<pii>, greater<pii>> pq;\n\tvector<int> d(N, INF);\n\n\td[s] = 0;\n\tpq.push({ 0,s });\n\twhile (!pq.empty()) {\n\t\tauto now = pq.top(); pq.pop();\n\t\tint v = now.second;\n\t\tfor (auto next : edges[v]) {\n\t\t\tif (d[next] > d[v] + 1) {\n\t\t\t\td[next] = d[v] + 1;\n\t\t\t\tpq.push({ d[next],next });\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tcin >> N >> M >> s >> t;\n\ts--; t--;\n\tedges.resize(N);\n\tREP(i, M) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tedges[x].push_back(y);\n\t\tedges[y].push_back(x);\n\t}\n\tauto dl = dijkstra(s);\n\tauto dr = dijkstra(t);\n\tint len = dl[t];\n\n\t// len - cnt\n\tmap<int, int> mpl, mpr;\n\tfor (auto d : dl)mpl[d]++;\n\tfor (auto d : dr)mpr[d]++;\n\n\tll res = 0;\n\tREP(i, len - 1) {\n\t\tint l = i;\n\t\tint r = len - 2 - i;\n\t\tif (mpl.find(l) == mpl.end())continue;\n\t\tif (mpr.find(r) == mpr.end())continue;\n\t\tres += (ll)mpl[l] * mpr[r];\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n, m, start, goal;\n\tcin>> n>> m>> start>> goal;\n\tstart--;\n\tgoal--;\n\tvvi root(n);\n\tREP(i,m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\troot[a].push_back(b);\n\t\troot[b].push_back(a);\n\t}\n\n\tvi start_dis(n,1e9);\n\tvi sdn(100001,0);\n\tstart_dis[start] = 0;\n\tsdn[0]++;\n\tqueue<int> Q;\n\tQ.push(start);\n\twhile (!Q.empty()) {\n\t\tint q = Q.front();Q.pop();\n\t\tREP(i, root[q].size()) {\n\t\t\tif (start_dis[root[q][i]] > start_dis[q] + 1) {\n\t\t\t\tstart_dis[root[q][i]] = start_dis[q] + 1;\n\t\t\t\tQ.push(root[q][i]);\n\t\t\t\tsdn[start_dis[q] + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tvi goal_dis(n, 1e9);\n\tvi gdn(100001,0);\n\tgoal_dis[goal] = 0;\n\tgdn[0]++;\n\tQ.push(goal);\n\twhile (!Q.empty()) {\n\t\tint q = Q.front();Q.pop();\n\t\tREP(i, root[q].size()) {\n\t\t\tif (goal_dis[root[q][i]] > goal_dis[q] + 1) {\n\t\t\t\tgoal_dis[root[q][i]] = goal_dis[q] + 1;\n\t\t\t\tQ.push(root[q][i]);\n\t\t\t\tgdn[goal_dis[q] + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tint dis = start_dis[goal];\n\tlong long ercnt = 0;\n\tREP(i, n)\n\t\tif (start_dis[i] + goal_dis[i]+1 == dis-1)\n\t\t\tercnt++;\n\tlong long ans = 0;\n\tREP(i, dis-1) {\n\t\tans += sdn[i] * gdn[dis - i-2];\n\t}\n\tcout << ans - ercnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\n\n#define MAX 100009\nusing namespace std;\ntypedef pair<int,int> P;\n\ntypedef struct Node\n{\n\tint n;\n\tvector<int>e;\n}Node;\n\nNode G[MAX];\nint N,M,s,t,d,a,b,res=0;\nmap<int,int>SC,GC;\nvoid dijcstra(int s,int g,map<int,int>&X)\n{\n\tint C[MAX];\n\tmemset(C,0x7f,sizeof(C));\n\tP tmp(0,s);\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\t//if(tmp.second==g)\n\t\t//\tcontinue;\n\t\tif(tmp.first>=C[tmp.second])\n\t\t\tcontinue;\n\t\tC[tmp.second]=tmp.first;\n\t\tfor(int i=0;i<G[tmp.second].e.size();i++)\n\t\t{\n\t\t\tint nn=G[tmp.second].e[i];\n\t\t\tif(C[nn]>tmp.first+1)\n\t\t\t{\n\t\t\t\tQ.push(make_pair(tmp.first+1,nn));\n\t\t\t}\n\t\t}\n\t}\n\tif(g==t)d=C[t];\n\tfor(int i=0;i<N;i++)\n\t\tX[C[i]]++;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&M,&s,&t);\n\ts--;t--;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--;y--;\n\t\tG[x].e.push_back(y);\n\t\tG[y].e.push_back(x);\n\t}\n\tdijcstra(s,t,SC);\n\tdijcstra(t,s,GC);\n\tfor(int i=0;i<=d;i++)\n\t{\n\t\tif(d-i-2>=0)\n\t\t\tres+=SC[i]*GC[d-i-2];\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n    --s, --t;\n    vvi graph(N);\n    REP(i, M) {\n        int u, v; cin >> u >> v; --u, --v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vi distS(N, INF), distT(N, INF);\n    {\n        queue<int> que;\n        que.push(s);\n        distS[s] = 0;\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (int u : graph[v]) {\n                if (chmin(distS[u], distS[v] + 1)) {\n                    que.push(u);\n                }\n            }\n        }\n    }\n    {\n        queue<int> que;\n        que.push(t);\n        distT[t] = 0;\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (int u : graph[v]) {\n                if (chmin(distT[u], distT[v] + 1)) {\n                    que.push(u);\n                }\n            }\n        }\n    }\n\n    map<int,ll> cntS, cntT;\n    for (int d : distS) ++cntS[d];\n    for (int d : distT) ++cntT[d];\n\n    int D = distS[t];\n    ll ans = 0;\n    for (auto &tp : cntS) {\n        ans += tp.second * cntT[D - 2 - tp.first];\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define OUT(x)                cout << #x << \" = \" << x << endl; \n#define rep(i, n)             for (int (i) = 0; (i) < (int)(n); (i)++)\n#define rer(i, l, r)          for (int (i) = (int)(l); (i) <= (int)(r); (i)++)\n#define reu(i, l, r)          for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define each(i, v)            for (auto i : v)\n#define all(x)                (x).begin(), (x).end()\n#define rall(x)               (x).rbegin(), (x).rend()\n#define pb(x)                 push_back(x)\n#define bp(x)                 __builtin_popcount(x)\n#define mp(x, y)              make_pair((x), (y))\n#define fi                    first\n#define se                    second\n#define setp(x)               setprecision(x)\n#define mset(m, v)            memset(m, v, sizeof(m))\n#define sz(x)                 (int)(x.size())\nstatic const int INF        = 0x3f3f3f3f;\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD        = 1000000007;\nstatic const double PI      = 3.14159265358979;\n\n//#define int                   long long\n\ntypedef vector<double>        vd;\ntypedef vector<string>        vs;\ntypedef vector<bool>          vb;\ntypedef vector<int>           vi;\ntypedef pair<int, int>        pii;\ntypedef vector<pii>           vpii;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; i ++) cout << *i << \" \"; cout << endl; }\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\nint in() { int _x; scanf(\"%d\", &_x); return _x; }\nlong long lin() {long long _x; scanf(\"%lld\", &_x); return _x; };\n\nvpii g[101010];\nint dis[101010];\nint sdis[101010];\nint n;\n\nvoid dijkstra(int s) {\n        priority_queue<pii, vector<pii>, greater<pii>> q;\n        fill(dis, dis + n, INF);\n        dis[s] = 0;\n        q.push(mp(s, 0));\n        while (!q.empty()) {\n                pii p = q.top(); q.pop();\n                int v = p.fi;\n                if (dis[v] < p.se) continue;\n                each(e, g[v]) {\n                        if (dis[e.fi] > dis[v] + e.se) {\n                                dis[e.fi] = dis[v] + e.se;\n                                q.push(mp(e.fi, dis[e.fi]));\n                        }\n                }\n        }\n}\n\nsigned main() { \n        int m;\n        cin >> n >> m;\n        int s, t;\n        cin >> s >> t;\n        s --;\n        t --;\n        rep(i, m) {\n                int a, b;\n                cin >> a >> b;\n                a --;\n                b --;\n                g[a].pb(mp(b, 1));\n                g[b].pb(mp(a, 1));\n        }\n        dijkstra(s);\n        rep(i, n) sdis[i] = dis[i];\n        dijkstra(t);\n        int scnt[101010] = { 0 };\n        int tcnt[101010] = { 0 };\n        rep(i, n) {\n                if (sdis[i] == INF) continue;\n                scnt[sdis[i]] ++;\n        }\n        rep(i, n) {\n                if (dis[i] == INF) continue;\n                tcnt[dis[i]] ++;\n        }\n        scnt[0] = 1;\n        tcnt[0] = 1;\n        int k = sdis[t];\n        k -= 2;\n        int ans = 0;\n        rer(l, 0, k) ans += scnt[l] * tcnt[k - l];\n        cout << ans << endl;\n        return 0;\n}               "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nint n[100000], m[100000];\nvector<int>rinsetu[100000];\nsigned main() {\n\tunordered_map<int, int>X, Y;\n\tint a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d); c--; d--;\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g; scanf(\"%d%d\", &f, &g);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tmemset(n, -1, sizeof(n));\n\tmemset(m, -1, sizeof(m));\n\tn[c] = 0; m[d] = 0;\n\tqueue<int>Q;\n\tQ.push(c);\n\twhile (Q.size()) {\n\t\tint e = Q.front(); Q.pop();\n\t\tX[n[e]]++;\n\t\tfor (int f : rinsetu[e]) {\n\t\t\tif (n[f] == -1) {\n\t\t\t\tn[f] = n[e] + 1;\n\t\t\t\tQ.push(f);\n\t\t\t}\n\t\t}\n\t}\n\tQ.push(d);\n\twhile (Q.size()) {\n\t\tint e = Q.front(); Q.pop();\n\t\tY[m[e]]++;\n\t\tfor (int f : rinsetu[e]) {\n\t\t\tif (m[f] == -1) {\n\t\t\t\tm[f] = m[e] + 1;\n\t\t\t\tQ.push(f);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < a; i++) {\n\t\tif(m[i]!=-1)ans += X[n[d] - m[i] - 2];\n\t\tif(n[i]!=-1)ans += Y[m[c] - n[i] - 2];\n\t}\n\tprintf(\"%lld\\n\", ans / 2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<long, long> P;\nvector<int> G[100010];\nlong d[100010],INF=99999999;\nlong par[100010],rank[100010]={};\n\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nlong find(int x){\n  if(par[x]==x){\n    return x;\n  }else{\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y) return ;\n\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid dijkstra(int s){\nfill(d,d+100010,INF);\npriority_queue<P, vector<P>, greater<P> > que;\nd[s-1]=0;\nque.push(P(0,s-1));\n\nwhile(!que.empty()){\n  P p=que.top();\n  que.pop();\n  int v=p.second;\n  if(d[v]<p.first) continue;\n  for(int i=0;i<G[v].size();i++){\n    if(d[G[v][i]]>d[v]+1){\n      d[G[v][i]]=d[v]+1;\n      que.push(P(d[G[v][i]],G[v][i]));\n    }\n  }\n}\n}\n\nint main(){\n  long N,M,s,t,x,y;\n  cin>>N>>M>>s>>t;\n  init(N);\n\n  for(int i=0;i<M;i++){\n    cin>>x>>y;\n    G[x-1].push_back(y-1);\n    G[y-1].push_back(x-1);\n    unite(x-1,y-1);\n  }\n\n  dijkstra(s);\n  long jdg[N]={},ans=0;\n  for(int i=0;i<N;i++){\n    if(same(t-1,i)) jdg[d[i]]+=1;\n    }\n  for(int i=0;i<N;i++){\n  //  cout<<\"jdg[\"<<i<<\"]=\"<<jdg[i]<<endl;\n  }\n  long spath=d[t-1];\n\n  dijkstra(t);\n\n  long jdg2[N]={};\n  for(int i=0;i<N;i++){\n    if(same(t-1,i)) jdg2[d[i]]+=1;\n    }\n  for(int i=0;i<N;i++){\n  //  cout<<\"jdg2[\"<<i<<\"]=\"<<jdg2[i]<<endl;\n  }\n\n  for(int i=0;i<spath-1&&spath-2-i>=0;i++){\n    ans+=jdg[i]*jdg2[spath-2-i];\n  }\n/*\n  for(int i=0;i<spath-1;i++){\n      if(i+2<=spath){\n        ans+=jdg[i];\n        cout<<\"i+2=\"<<jdg[i]*jdg2[spath-i-1]<<endl;\n      }\n      if(spath<2*spath-2-i&&2*spath-2-i<N){\n        ans+=jdg[i]*jdg[2*spath-2-i];\n        cout<<\"spath*2=\"<<jdg[i]*jdg[2*spath-2-i]<<endl;\n      }\n  }\n  */\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n \n#define INF (1 << 23)\n \nusing namespace std;\n\nvoid reader(int *x)\n{\n    int k = getchar_unlocked(); *x = k - '0';\n    \n    while(true)\n    {\n        k = getchar_unlocked();\n        \n        if(k < '0' || k > '9') break;\n        \n        *x = ((*x) << 1) + ((*x) << 3) + k - '0';\n    }\n}\n\nchar memarr[17000000]; void *mem = memarr;\n \nint main()\n{\n    int N, M, s, t, u, v;\n \n    reader(&N);\n    reader(&M);\n    reader(&s); s--;\n    reader(&t); t--;\n \n    vector<vector<int> > G(N);\n \n    for (int i = 0; i < M; i++)\n    {\n        reader(&u);\n        reader(&v);\n \n        G[u - 1].push_back(v - 1);\n        G[v - 1].push_back(u - 1);\n    }\n \n    vector<int> d1(N, INF); d1[s] = 0;\n    vector<int> d2(N, INF); d2[t] = 0;\n \n    queue<int> que;\n \n    que.push(s);\n \n    while (!que.empty())\n    {\n        int node = que.front(); que.pop();\n \n        for (int i = 0; i < G[node].size(); i++)\n        {\n            if (d1[G[node][i]] == INF)\n            {\n                d1[G[node][i]] = d1[node] + 1; que.push(G[node][i]);\n            }\n        }\n    }\n \n    que.push(t);\n \n    while (!que.empty())\n    {\n        int node = que.front(); que.pop();\n \n        for (int i = 0; i < G[node].size(); i++)\n        {\n            if (d2[G[node][i]] == INF)\n            {\n                d2[G[node][i]] = d2[node] + 1; que.push(G[node][i]);\n            }\n        }\n    }\n \n    int shortest = d1[t];\n \n    vector<int> r1(shortest - 1, 0); for (int i = 0; i < N; i++) { if (d1[i] < shortest - 1) r1[d1[i]]++; }\n    vector<int> r2(shortest - 1, 0); for (int i = 0; i < N; i++) { if (d2[i] < shortest - 1) r2[d2[i]]++; }\n \n    long long ret = 0;\n \n    for (int i = 0; i < shortest - 1; i++) ret += 1LL * r1[i] * r2[shortest - i - 2];\n     \n    printf(\"%lld\\n\", ret);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 500000\n#define INF 999999999999999\n\nvector<long long>x[MAX_N];\nlong long d[MAX_N];\nlong long n,m,a,b,s,t,q;\nqueue<long long>Q;\nlong long sum1[MAX_N];\nlong long sum2[MAX_N];\nlong long sum;\n\nvoid bfs(int P){\n\tfor(int i=0;i<MAX_N;i++){\n\t\td[i]=INF;\n\t}\n\td[P]=0;\n\tQ.push(P);\n\twhile(!Q.empty()){\n\t\tint w=Q.front();Q.pop();\n\t\tfor(int i=0;i<x[w].size();i++){\n\t\t\tif(d[x[w][i]]==INF){\n\t\t\t\td[x[w][i]]=d[w]+1;\n\t\t\t\tQ.push(x[w][i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>n>>m>>s>>t;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b;\n\t\tx[a].push_back(b);\n\t\tx[b].push_back(a);\n\t}\n\tbfs(s);\n\tq=d[t];\n\tfor(int i=1;i<=n;i++){\n\t\tif(d[i]<INF){\n\t\t\tsum1[d[i]]++;\n\t\t}\n\t}\n\tbfs(t);\n\tfor(int i=1;i<=n;i++){\n\t\tif(d[i]<INF){\n\t\t\tsum2[d[i]]++;\n\t\t}\n\t}\n\tfor(int i=0;i<q-1;i++){\n\t\tsum+=sum1[i]*sum2[q-i-2];\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct Edge {\n  int v, w;\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvector<int> bfs(int src, const Graph &g) {\n  const int n = g.size();\n  vector<int> cost(n, INF);\n  queue<int> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const int v = que.front();\n    que.pop();\n    for(int i = 0; i < g[v].size(); ++i) {\n      int nv = g[v][i].v;\n      if(cost[nv] != INF) continue;\n      cost[nv] = cost[v] + 1;\n      que.push(nv);\n    }\n  }\n  return cost;\n}\n\nint main() {\n  for(int N, M, s, t; cin >> N >> M >> s >> t; ) {\n    --s; --t;\n    Graph G(N);\n    for(int i = 0; i < M; ++i) {\n      int x, y; cin >> x >> y;\n      --x; --y;\n      G[x].push_back((Edge){y, 1});\n      G[y].push_back((Edge){x, 1});\n    }\n    vector<int> cs = bfs(s, G);\n    vector<int> ct = bfs(t, G);\n    int mini = cs[t];\n    sort(ct.begin(), ct.end());\n    int res = 0;\n    for(int i = 0; i < N; ++i) {\n      if(cs[i] == INF) continue;\n      int target = mini - 2 - cs[i];\n      res += upper_bound(ct.begin(), ct.end(), target)\n        - lower_bound(ct.begin(), ct.end(), target);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?2e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tint to,cost;\n\t};\n\tvector<vector<edge> >G;\n\tint n;\n\tvi d;//distance\n\tDIJ(int size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int a,int b,int c){\n\t\tedge e={b,c},ee={a,c};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(int s){\n\t\td=vi(n,inf);\n\t\td[s]=0;\n\t\tpriority_queue<pii>q;\n\t\tq.push(pii(0,s));\n\t\twhile(!q.empty()){\n\t\t\tpii p=q.top();\n\t\t\tq.pop();\n\t\t\tint pos=p.second,cost=-p.first;\n\t\t\tif(cost>d[pos])continue;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e=G[pos][i];\n\t\t\t\tint to=e.to;\n\t\t\t\tint nowcost=cost+e.cost;\n\t\t\t\tif(nowcost<d[to]){\n\t\t\t\t\td[to]=nowcost;\n\t\t\t\t\tq.push(pii(-d[to],to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nint main(){\n\tint n,m,s,t;\n\tcin>>n>>m>>s>>t;\n\ts--;t--;\n\tDIJ dij(n);\n\trep(i,m){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tdij.add_edge(a,b,1);\n\t\tdij.add_edge(b,a,1);\n\t}\n\tdij.dij(s);\n\tvi d=dij.d;\n\tdij.dij(t);\n\tvi co(n);\n\trep(i,n)if(dij.d[i]<n)co[dij.d[i]]++;\n\tll out=0;\n\trep(i,n)if(d[t]-2-d[i]<n&&d[t]-2-d[i]>=0)out+=co[d[t]-2-d[i]];\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint ds[2][100001];\nint ns[2][100001];\nvector<vector<int>> G;\nvoid bfs(int x, int d, int i){\n  queue<int> q, dis;\n  q.push(x);\n  dis.push(0);\n\n  while(!q.empty()){\n\tx = q.front(); q.pop();\n\td = dis.front(); dis.pop();\n\tif(ds[i][x] >= 0) continue;\n\tds[i][x] = d;\n\tns[i][d]++;\n\tfor(int to: G[x]){\n\t  q.push(to);\n\t  dis.push(d+1);\n\t}\n  }\n}\n\nint main(){\n  fill((int*)ds, (int*)ds+2*100001, -1);\n  fill((int*)ns, (int*)ns+2*100001, 0);\n\n  int N, M, S, T;\n  cin >> N >> M >> S >> T;\n  --S, --T;\n  G.assign(N, vector<int>());\n  for(int i=0;i<M;++i){\n\tint x, y; cin >> x >> y;\n\t--x, --y;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n  }\n  bfs(S, 0, 0);\n  bfs(T, 0, 1);\n\n  long long ans = 0, d = ds[0][T];\n  for(int i=0;i<=d-2;++i)\n\tans += (long long)ns[0][i] * ns[1][d-2-i];\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n, m, start, goal;\n\tcin>> n>> m>> start>> goal;\n\tstart--;\n\tgoal--;\n\tvvi root(n);\n\tREP(i,m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\troot[a].push_back(b);\n\t\troot[b].push_back(a);\n\t}\n\n\tvi start_dis(n,1e9);\n\tvi sdn(100001,0);\n\tstart_dis[start] = 0;\n\tsdn[0]++;\n\tqueue<int> Q;\n\tQ.push(start);\n\twhile (!Q.empty()) {\n\t\tint q = Q.front();Q.pop();\n\t\tREP(i, root[q].size()) {\n\t\t\tif (start_dis[root[q][i]] > start_dis[q] + 1) {\n\t\t\t\tstart_dis[root[q][i]] = start_dis[q] + 1;\n\t\t\t\tQ.push(root[q][i]);\n\t\t\t\tsdn[start_dis[q] + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tvi goal_dis(n, 1e9);\n\tvi gdn(100001,0);\n\tgoal_dis[goal] = 0;\n\tgdn[0]++;\n\tQ.push(goal);\n\twhile (!Q.empty()) {\n\t\tint q = Q.front();Q.pop();\n\t\tREP(i, root[q].size()) {\n\t\t\tif (goal_dis[root[q][i]] > goal_dis[q] + 1) {\n\t\t\t\tgoal_dis[root[q][i]] = goal_dis[q] + 1;\n\t\t\t\tQ.push(root[q][i]);\n\t\t\t\tgdn[goal_dis[q] + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tint dis = start_dis[goal];\n\tint ercnt = 0;\n\tREP(i, n)\n\t\tif (start_dis[i] + goal_dis[i]+1 == dis-1)\n\t\t\tercnt++;\n\tlong long ans = 0;\n\tREP(i, dis-1) {\n\t\tans += sdn[i] * gdn[dis - i-2];\n\t}\n\tcout << ans - ercnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define allof(a) (a).begin(),(a).end()\n\ntypedef long long lint;\n\nstruct State { int v, step; };\n\nint N, M, term[2], dst[2][100010];\nvector< vector< int > > adj;\nvector< int > sdl[2][100010];\n\nint bfs() {\n\tfor_(i,0,2) {\n\t\tqueue< State > que;\n\t\tque.push(State{term[i], 0});\n\t\t\n\t\tvector< bool > vis(N + 1, false);\n\t\tvis[term[i]] = true;\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tState s = que.front(); que.pop();\n\t\t\tdst[i][s.v] = s.step;\n\t\t\tsdl[i][s.step].push_back(s.v);\n\t\t\t\n\t\t\tfor (int v : adj[s.v]) {\n\t\t\t\tif (vis[v]) continue;\n\t\t\t\tvis[v] = true;\n\t\t\t\tque.push(State{v, s.step + 1});\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dst[0][term[1]];\n}\n\nvoid solve() {\n\tint min_dst = bfs();\n\t\n\tlint ans = 0;\n\t\n\tfor_(step,0,N) ans += (lint)sdl[0][step].size() * (lint)sdl[1][min_dst - step - 2].size();\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> N >> M >> term[0] >> term[1];\n\t\n\tadj.assign(N+1, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef pair<int,int> pp;\nset<int> G[105000];\nset<pp> res;\nint dis[105000];\nset<int> S[105000];\nint n,m,s,t;\n\nint main(void) {\n    scanf(\"%d%d%d%d\",&n,&m,&s,&t);\n    s--, t--;\n    memset(dis, 0x20, sizeof(dis));\n    for(int i=0; i<m; i++) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        x--, y--;\n        G[x].insert(y);\n        G[y].insert(x);\n    }\n\n    {\n        priority_queue<pp> q;\n        q.push(pp(-0, s));\n\n        while(!q.empty()) {\n            pp t = q.top(); q.pop();\n            int d = -t.fst, x = t.snd;\n\n            if(dis[x] != 0x20202020) continue;\n            dis[x] = d;\n            S[d].insert(x);\n\n            for(int y : G[x])\n                q.push(pp(-(d+1), y));\n        }\n    }\n\n    int old = dis[t];\n    memset(dis, 0x20, sizeof(dis));\n\n    {\n        priority_queue<pp> q;\n        q.push(pp(-0, t));\n\n        while(!q.empty()) {\n            pp t = q.top(); q.pop();\n            int d = -t.fst, x = t.snd;\n\n            if(dis[x] != 0x20202020) continue;\n            dis[x] = d;\n\n            if(old-2-d >= 0)\n                for(int y : S[old-2-d])\n                    if(G[x].find(y) == G[x].end())\n                        res.insert(pp(x,y)), res.insert(pp(y,x));\n\n            for(int y : G[x])\n                q.push(pp(-(d+1), y));\n        }\n    }\n\n    printf(\"%d\\n\", res.size()/2);\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst int inf=(int)1e9;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nint s,t;\n//Shortest_Path\n//グラフの最短距離を求めるアルゴリズムを3種類持っているクラスです\nclass shortest_path{\npublic:\n    \n    //dijkstra法とBellman_Ford法を使うときは、このコンストラクタを使ってください\n    explicit shortest_path(int n):vertex(n),INF((ll)1e14){\n        v1.resize(static_cast<unsigned long>(vertex));\n    }\n    \n    //Warshall_Floyd法を使うときは、こちらのコンストラクタを使ってください\n    shortest_path(int n,ll inf):vertex(n),INF(inf){\n        v2.resize(static_cast<unsigned long>(vertex));\n        for(int i=0;i<vertex;i++)v2[i].resize(static_cast<unsigned long>(vertex));\n        for(int i=0;i<vertex;i++){\n            for(int j=0;j<vertex;j++){\n                v2[i][j]=INF;\n            }\n        }\n        for(int i=0;i<vertex;i++)v2[i][i]=0;\n    }\n    \n    //dijkstra法とBellman_Ford法専用のadd_edge(int from,int to,ll cost)です\n    //コストcostの頂点fromから頂点toへの有向辺を追加するときadd_edge(int from,int to,ll cost)\n    void add_edge(int from,int to,ll cost){\n        v1[from].push_back({to,cost});\n    }\n    \n    //Warshall_Floyd法専用のadd_edge(int from,int to,ll cost)です\n    //コストcostの頂点fromから頂点toへの有向辺を追加するときadd_edge(int from,int to,ll cost)\n    void add_edge_(int from,int to,ll cost){//warshall_floyd\n        v2[from][to]=cost;\n    }\n    \n    //Dijkstra法です\n    //各頂点への距離が格納されたvector<ll>が求まります\n    //負のコストの辺がある場合は使えません\n    //start地点の頂点番号を引数に入れてください\n    vector<ll> dijkstra(unsigned int start){\n        vector<ll> d(static_cast<unsigned long>(vertex),INF);\n        priority_queue<pair<ll,int> > q;\n        d[start]=0;\n        q.push({0,start});\n        while(!q.empty()){\n            int now=q.top().se;\n            ll now_cost=-q.top().fi;\n            q.pop();\n            if(d[now]<now_cost)continue;\n            for (auto &i : v1[now]) {\n                if(d[i.fi]>now_cost+ i.se){\n                    d[i.fi]=now_cost+ i.se;\n                    q.push({-d[i.fi], i.fi});\n                }\n            }\n        }\n        return d;\n    }\n    \n    //Warshall_Floyd法です\n    //各頂点への距離が格納されたvector<ll>と閉路があるかどうかの情報の2つのtupleが返されます\n    //閉路があるとき、返り値はtrueです\n    tuple<vector<vector<ll> >,bool> warshall_floyd(){\n        for(int k=0;k<vertex;k++){\n            for(int i=0;i<vertex;i++){\n                if(v2[i][k]==INF)continue;\n                for(int j=0;j<vertex;j++){\n                    if(v2[k][j]==INF)continue;\n                    v2[i][j]=min(v2[i][j],v2[i][k]+v2[k][j]);\n                }\n            }\n        }\n        bool is_negative_cycle=false;\n        for(int i=0;i<vertex;i++){\n            if(v2[i][i]<0)is_negative_cycle=true;\n        }\n        return make_tuple(v2,is_negative_cycle);\n    }\n\n    //Bellman_Ford法です\n    //各頂点への距離が格納されたvector<ll>と閉路があるかどうかの情報の2つのtupleが返されます\n    //閉路があるとき、返り値はtrueです\n    //start地点の頂点番号を引数に入れてください\n    tuple<vector<ll>,bool> bellman_ford(int start){\n        vector<ll> d(static_cast<unsigned long>(vertex),INF);\n        d[start]=0;\n        bool is_negative_cycle=false;\n        for(int i=0;i<vertex;i++){\n            bool update= false;\n            for(int j=0;j<vertex;j++){\n                if(d[j]==INF)continue;\n                for(int k=0;k<(int)v1[j].size();k++){\n                    if(d[v1[j][k].fi]>d[j]+v1[j][k].se){\n                        d[v1[j][k].fi]=d[j]+v1[j][k].se;\n                        update= true;\n                    }\n                }\n            }\n            if(i==vertex-1 && update)is_negative_cycle=true;\n            else if(!update)break;\n        }\n        return make_tuple(d,is_negative_cycle);\n    }\nprivate:\n    ll INF;\n    int vertex;\n    vector<vector<pair<int,ll> > > v1;\n    vector<vector<ll> > v2;\n};\n//tuple tp<int,int,int> -> int a=get<0>(tp),b=get<1>(tp),c=get<2>(tp)\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  shortest_path sp(n);\n  for(int i=0;i<m;i++){\n    int a,b;cin>>a>>b;\n    a--;b--;\n    sp.add_edge(a,b,1);\n    sp.add_edge(b,a,1);\n  }\n  vector<ll> d=sp.dijkstra(s);\n  vector<ll> d2=sp.dijkstra(t);\n  int st=d[t];\n  if(st==1){\n    cout<<0<<endl;\n  }else{\n    int tmp=st-2;\n    sort(d2.begin(),d2.end());\n    sort(d.begin(),d.end());\n    ll ans=0;\n    for(int i=0;i<=tmp;i++){\n      ll a=upper_bound(d2.begin(),d2.end(),tmp-i)-lower_bound(d2.begin(),d2.end(),tmp-i);\n      ll b=upper_bound(d.begin(),d.end(),i)-lower_bound(d.begin(),d.end(),i);\n      ans+=a*b;\n      //cout<<ans<<endl;\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF 1<<30\n\n// dist_from_s[u] + dist_from_t[v] = dist_from_s[t] - 2\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\n\t/* input */\n\tint N, M; cin >> N >> M;\n\tint s, t; cin >> s >> t; s--; t--;\n\tvector<vector<int>> G(N);\n\tfor (int i = 0; i < M;i++) {\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\n\t/* initialize */\n\tvector<int> d_s(N, INF), d_t(N, INF);\n\tqueue<int> q_s, q_t;\n\t\n\t// d_s(t)[n] := distance n from s(t)\n\td_s[s] = 0, d_t[t] = 0;\n\tq_s.push(s), q_t.push(t);\n\n\t/* Dijkstra */\n\twhile (!q_s.empty()) {\n\t\tint u = q_s.front(); q_s.pop();\n\t\tfor (int v : G[u]) {\n\t\t\tif (d_s[v] > d_s[u] + 1) {\n\t\t\t\td_s[v] = d_s[u] + 1;\n\t\t\t\tq_s.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!q_t.empty()) {\n\t\tint u = q_t.front(); q_t.pop();\n\t\tfor (int v : G[u]) {\n\t\t\tif (d_t[v] > d_t[u] + 1) {\n\t\t\t\td_t[v] = d_t[u] + 1;\n\t\t\t\tq_t.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* solve */\n\tint ans = 0;\n\n\t// dist_is(t)[i] := sum of distance i from s(t)\n\tvector<int> dist_is(N + 1, 0);\n\tvector<int> dist_it(N + 1, 0);\n\tfor (int i = 0; i < N;i++) {\n\t\tif (d_s[i] != INF) {\n\t\t\tdist_is[d_s[i]]++;\n\t\t}\n\t\tif (d_t[i] != INF) {\n\t\t\tdist_it[d_t[i]]++;\n\t\t}\n\t}\n\n\tint Const = d_s[t] - 2;\n\tfor (int i = 0; i <= Const;i++) {\n\t\tans += (dist_is[i] * dist_it[Const - i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n// 🔴\n\n// O(ElogE)\n\n// pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<long long> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<long long> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    int V, E, S, G; cin >> V >> E >> S >> G;     // V:= 頂点の数    E:= 辺の数    S:= スタートノード　　G:= ゴールノード\n    S--;\n    G--;\n    vector<vector<pair<int, int> > > adjlist(V);      //first := コスト　second := 行先\n\n    //入力\n    for(int i = 0; i < E; i++){\n        int a, b; cin >> a >> b;                    // a ,b 間に辺がある\n        a--;\n        b--;\n        adjlist[a].push_back(make_pair(1, b));\n        adjlist[b].push_back(make_pair(1, a));      \n    }\n\n    //int a, b; cin >> a >> b;\n    //adjlist[a].push_back(make_pair(1, b));\n    //adjlist[b].push_back(make_pair(1, a)); \n    \n\n    vector<long long> result_S(V);                 //Sからの距離\n    vector<long long> result_G(V);                 //Gからの距離\n    result_S = dijk(S, V, adjlist);\n    result_G = dijk(G, V, adjlist);    \n    //cout << result[G] << endl;\n\n    vector<long long> s(1000000, 0);\n    vector<long long> g(1000000, 0);\n    for(int i = 0; i < V; i++){\n\n        if(result_S[i] < 10000000) s[result_S[i]]++;\n        \n        if(result_G[i] < 10000000) g[result_G[i]]++;        \n    }\n\n    long long ans = 0;\n    long long dis = result_S[G] - 2;\n    //cout << dis << endl;\n    //result[S];\n    for(int i = 0; dis - i >= 0; i++){\n        \n        //cout << i << \" \" << dis - i << \" \" << s[i] << \" \" << g[i] << endl;\n        \n        ans += s[i] * g[dis - i];\n        //else ans += result_S[i] * result_G[dis - i] + result_S[dis - i] * result_G[i];\n        //cout << i << \": \" << result_S[i] << \" \" << result_G[i] << endl;\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 100010;\nVI e[N];\nint d1[N], d2[N], p1[N], p2[N];\n\nvoid bfs(int s, int d[], int p[]){\n    REP(i,N) d[i] = -1;\n    d[s] = 0;\n    queue<int> que;\n    que.push(s);\n    while (!que.empty()){\n        int now = que.front();\n        que.pop();\n        p[d[now]]++;\n        REP(i,e[now].size()){\n            int next = e[now][i];\n            if (d[next] >= 0) continue;\n            d[next] = d[now] + 1;\n            que.push(next);\n        }\n    }\n}\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--;\n    t--;\n    REP(i,m){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--;\n        y--;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    bfs(s,d1,p1);\n    bfs(t,d2,p2);\n    int x = d1[t];\n    \n    ll ans = 0;\n    REP(i,x-1){\n        ans += p1[i] * p2[x-2-i];\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nstruct Edge{ int dst, cost; };\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nconst int INF = 1000000000;\nvoid add_edge(Graph& G, int a, int b) {\n    G[a].push_back({b, 1});\n    G[b].push_back({a, 1});\n}\nvector<int> SPFA(const Graph& G, int s) {\n    int n = G.size();\n    vector<int> dist(n, INF);\n    vector<bool> inque(n);\n    queue<int> que;\n\n    dist[s] = 0;\n    que.push(s);\n    inque[s] = true;\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        inque[v] = false;\n        for(Edge e : G[v]) {\n            if(dist[e.dst] > dist[v] + e.cost) {\n                dist[e.dst] = dist[v] + e.cost;\n                if(!inque[e.dst]) {\n                    que.push(e.dst);\n                    inque[e.dst] = true;\n                }\n            }\n        }\n    }\n    return dist;\n}\nint main(){\n    iostream_init();\n    int N, M, s, t;\n    while(cin >> N >> M >> s >> t) {\n        s--; t--;\n        Graph G(N);\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            add_edge(G, a, b);\n        }\n\n        vector<int> ds = SPFA(G, s);\n        vector<int> dt = SPFA(G, t);\n        vector<int> cnt(N+10);\n        for(int x : dt){\n            if(x < INF) cnt[x]++;\n        }\n        int D = ds[t];\n        long long ans = 0;\n        REP(i, N) {\n            // ds[i] + 1 + E == D-1\n            int E = D - ds[i] - 2;\n            if(E >= 0) ans += cnt[E];\n        }\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge {\n\tint from,to;\n\tint cost;\n\n\tedge(int t,int c) : to(t),cost(c) {}\n\tedge(int f,int t,int c) : from(f),to(t),cost(c) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nvector<edge> G[100005];\nint d[100005], d2[100005], cnt[100005];\n\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\trep(i, 100005) d[i] = INF;\n\t\n\tque.push(mp(0, s));\n\td[s] = 0;\n\n\twhile(que.size()) {\n\t\tP p = que.top(); que.pop();\n\t\tint cost = p.first;\n\t\tint v = p.second;\n\n\t\tif(d[v] < cost) continue;\n\n\t\trep(i, G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(mp(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tint s, t;\n\tcin >> s >> t;\n\ts--; t--;\n\n\trep(i, m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\n\t\tG[a].push_back(edge(b, 1));\n\t\tG[b].push_back(edge(a, 1));\n\t}\n\n\tdijkstra(s);\n\trep(i, n) d2[i] = d[i];\n\n\tdijkstra(t);\n\trep(i, n) swap(d[i], d2[i]);\n\n\tmemset(cnt, 0, sizeof(cnt));\n\trep(i, n) {\n\t\tif(d2[i] == INF) continue;\n\t\tcnt[d2[i]]++;\n\t}\n\n\tll ans = 0;\n\trep(i, n) {\n\t\tif(d[i] == INF || d2[i] == INF) continue;\n\t\tint x = d[t] - 2 - d[i];\n\n\t\tif(x >= 0) {\n\t\t\tans += cnt[x];\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)N;i++)\n#define p(s) cout<<(s)<<endl\n#define ck(n,a,b) ((a)<=(n)&&(n)<(b))\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\n\nll d[100010];//dist\nll fromS[100010];\nll fromT[100010];\nvector<ll> edge[100100];\nint main() {\n\tll N,M,s,t;\n\tcin>>N>>M>>s>>t;\n\ts--;t--;\n\tREP(i,0,M){\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tx--;y--;\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tqueue<ll> q,qq;\n\tfromS[0]=1;fromT[0]=1;\n\tq.push(s);\n\tREP(i,0,N) d[i]=inf;\n\td[s]=0;\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\tfor(int next:edge[now]){\n\t\t\tif(d[next]<inf) continue;\n\t\t\tq.push(next);\n\t\t\td[next]=d[now]+1;\n\t\t\tfromS[d[next]]++;\n\t\t}\n\t\tif(d[t]<inf) break;\n\t}\n\n\tREP(i,0,N) d[i]=inf;\n\tqq.push(t);\n\td[t]=0;\n\twhile(!qq.empty()){\n\t\tint now=qq.front();qq.pop();\n\t\tfor(auto next:edge[now]){\n\t\t\tif(d[next]<inf) continue;\n\t\t\tqq.push(next);\n\t\t\td[next]=d[now]+1;\n\t\t\tfromT[d[next]]++;\n\t\t}\n\t\tif(d[s]<inf) break;\n\t}\n\tll ans=0;\n\tREP(i,0,d[s]-1){\n\t\tans+=fromS[i]*fromT[d[s]-2-i];\n\t}\n\tp(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nusing P=pair<int,int>;\nint main(){\n    int N,M,s,t;\n    cin>>N>>M>>s>>t;\n    s--;t--;\n    vector<int> G[N];\n    for(int i=0;i<M;i++){\n        int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    int dist_s[N],dist_t[N];\n    fill(dist_s,dist_s+N,1000000000);\n    fill(dist_t,dist_t+N,1000000000);\n    queue<int> Q;\n    dist_s[s]=0;\n    Q.push(s);\n    while(!Q.empty()){\n        int v=Q.front(); Q.pop();\n        for(auto to:G[v]){\n            if(dist_s[to]==1000000000){\n                dist_s[to]=dist_s[v]+1;\n                Q.push(to);\n            }\n        }\n    }\n    dist_t[t]=0;\n    Q.push(t);\n    while(!Q.empty()){\n        int v=Q.front(); Q.pop();\n        for(auto to:G[v]){\n            if(dist_t[to]==1000000000){\n                dist_t[to]=dist_t[v]+1;\n                Q.push(to);\n            }\n        }\n    }\n    int64_t cnt_s[N],cnt_t[N];\n    fill(cnt_s,cnt_s+N,0);\n    fill(cnt_t,cnt_t+N,0);\n    for(int i=0;i<N;i++){\n        if(dist_s[i]!=1000000000)cnt_s[dist_s[i]]++;\n        if(dist_t[i]!=1000000000)cnt_t[dist_t[i]]++;\n    }\n    int64_t ans=0;\n    int dist=dist_s[t];\n    for(int i=0;i<=dist-2;i++){\n        ans+=cnt_s[i]*cnt_t[dist-2-i];\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll c[2][100010],d[100010],INF=1<<29;\nvector<ll> v[100010];\nll n,m,s,t;\n \nvoid bfs(ll s,ll k) {\n  fill(d,d+n+1,INF);\n  d[s]=0;\n  c[k][0]++;\n  queue<ll> que;\n  que.push(s);\n  while(!que.empty()) {\n    ll x=que.front();que.pop();\n    for(int i=0; i<v[x].size(); i++) {\n      ll y=v[x][i];\n      if(d[y]<=d[x]+1) continue;\n      d[y]=d[x]+1;\n      c[k][d[y]]++;\n      que.push(y);\n    }\n  }\n}\n   \n \nint main() {\n  cin >> n >> m >> s >> t;\n  for(ll i=0; i<m; i++) {\n    ll x,y;\n    cin >> x >> y;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  memset(c,0,sizeof(c));\n  bfs(s,0);\n  bfs(t,1);\n  ll z=d[s],ans=0;\n  for(ll i=0; i<z-1; i++) ans+=c[0][i]*c[1][z-i-2];\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nvector<int> g[100005];\nint depth[100005], cnt[2][100005];\nint dep[100005];\nbool used[100005];\n\nvoid dfs(int c){\n    used[c] = true;\n    for(auto i:g[c]){\n        if(used[i]) continue;\n        depth[i] = depth[c] + 1;\n        dfs(i);\n    }\n}\n\nvoid dfs_(int c){\n    used[c] = true;\n    for(auto i:g[c]){\n        if(used[i]) continue;\n        dep[i] = dep[c] + 1;\n        dfs_(i);\n    }\n}\n\nint main(){\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--; t--;\n\n    rep(i,n) depth[i] = dep[i] = 1e8;\n    depth[s] = dep[t] = 0;\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        g[a].emplace_back(b);\n        g[b].emplace_back(a);\n    }\n    dfs(s);\n    memset(used, 0, sizeof(used));\n    dfs_(t);\n\n    rep(i,n){\n        if(depth[i] == 1e8) continue;\n        cnt[0][ depth[i] ]++;\n        if(dep[i] == 1e8) continue;\n        cnt[1][ dep[i]   ]++;\n    }\n    long long ans = 0;\n    rep(i,depth[t]) ans+=static_cast<long long>(cnt[0][i] * cnt[1][depth[t] - i - 2]);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#define INF (1 << 23)\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, s, t, u, v;\n\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &s);\n\tscanf(\"%d\", &t);\n\n\tvector<vector<int> > G(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &u);\n\t\tscanf(\"%d\", &v);\n\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\n\tvector<int> d1(N, INF); d1[s] = 0;\n\tvector<int> d2(N, INF); d2[t] = 0;\n\n\tqueue<int> que;\n\n\tque.push(s);\n\n\twhile (!que.empty())\n\t{\n\t\tint node = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tif (d1[G[node][i]] == INF)\n\t\t\t{\n\t\t\t\td1[G[node][i]] = d1[node] + 1; que.push(G[node][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tque.push(t);\n\n\twhile (!que.empty())\n\t{\n\t\tint node = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tif (d2[G[node][i]] == INF)\n\t\t\t{\n\t\t\t\td2[G[node][i]] = d2[node] + 1; que.push(G[node][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint shortest = d1[t];\n\n\tvector<int> r1(N, 0); for (int i = 0; i < N; i++) { if (d1[i] != INF) { r1[d1[i]]++; } }\n\tvector<int> r2(N, 0); for (int i = 0; i < N; i++) { if (d2[i] != INF) { r2[d2[i]]++; } }\n\n\tlong long ret = 0;\n\n\tfor (int i = 0; i < shortest; i++)\n\t{\n\t\tret += (long long)(r1[i] * r2[shortest - i - 1]);\n\t}\n\t\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define OUT(x)                cout << #x << \" = \" << x << endl; \n#define rep(i, n)             for (int (i) = 0; (i) < (int)(n); (i)++)\n#define rer(i, l, r)          for (int (i) = (int)(l); (i) <= (int)(r); (i)++)\n#define reu(i, l, r)          for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define each(i, v)            for (auto i : v)\n#define all(x)                (x).begin(), (x).end()\n#define rall(x)               (x).rbegin(), (x).rend()\n#define pb(x)                 push_back(x)\n#define bp(x)                 __builtin_popcount(x)\n#define mp(x, y)              make_pair((x), (y))\n#define fi                    first\n#define se                    second\n#define setp(x)               setprecision(x)\n#define mset(m, v)            memset(m, v, sizeof(m))\n#define sz(x)                 (int)(x.size())\nstatic const int INF        = 0x3f3f3f3f;\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD        = 1000000007;\nstatic const double PI      = 3.14159265358979;\n\n#define int                   long long\n\ntypedef vector<double>        vd;\ntypedef vector<string>        vs;\ntypedef vector<bool>          vb;\ntypedef vector<int>           vi;\ntypedef pair<int, int>        pii;\ntypedef vector<pii>           vpii;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; i ++) cout << *i << \" \"; cout << endl; }\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\nint in() { int _x; scanf(\"%d\", &_x); return _x; }\nlong long lin() {long long _x; scanf(\"%lld\", &_x); return _x; };\n\nvpii g[101010];\nint dis[101010];\nint sdis[101010];\nint n;\n\nvoid dijkstra(int s) {\n        priority_queue<pii, vector<pii>, greater<pii>> q;\n        fill(dis, dis + n, INF);\n        dis[s] = 0;\n        q.push(mp(s, 0));\n        while (!q.empty()) {\n                pii p = q.top(); q.pop();\n                int v = p.fi;\n                if (dis[v] < p.se) continue;\n                each(e, g[v]) {\n                        if (dis[e.fi] > dis[v] + e.se) {\n                                dis[e.fi] = dis[v] + e.se;\n                                q.push(mp(e.fi, dis[e.fi]));\n                        }\n                }\n        }\n}\n\nsigned main() { \n        int m;\n        cin >> n >> m;\n        int s, t;\n        cin >> s >> t;\n        s --;\n        t --;\n        rep(i, m) {\n                int a, b;\n                cin >> a >> b;\n                a --;\n                b --;\n                g[a].pb(mp(b, 1));\n                g[b].pb(mp(a, 1));\n        }\n        dijkstra(s);\n        rep(i, n) sdis[i] = dis[i];\n        dijkstra(t);\n        int scnt[101010] = { 0 };\n        int tcnt[101010] = { 0 };\n        rep(i, n) {\n                if (sdis[i] == INF) continue;\n                scnt[sdis[i]] ++;\n        }\n        rep(i, n) {\n                if (dis[i] == INF) continue;\n                tcnt[dis[i]] ++;\n        }\n        scnt[0] = 1;\n        tcnt[0] = 1;\n        int k = sdis[t];\n        k -= 2;\n        int ans = 0;\n        rer(l, 0, k) ans += scnt[l] * tcnt[k - l];\n        cout << ans << endl;\n        return 0;\n}               "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nvector<ll> dijkstra(ll s, vector<vector<P>>& adj) {\n\tvector<ll> dir(adj.size(),INF*INF);\n\tdir[s]=0;\n\tpriority_queue<P,vector<P>,greater<P>> q;\n\tq.push(P(0,s));\n\twhile(!q.empty()) {\n\t\tll d=q.top().first;\n\t\tll p=q.top().second;\n\t\tq.pop();\n\t\tif(dir[p]!=d) continue;\n\t\tREP(i,adj[p].size()) {\n\t\t\tll c=adj[p][i].second;\n\t\t\tll np=adj[p][i].first;\n\t\t\tif(dir[np]>d+c) {\n\t\t\t\tdir[np]=d+c;\n\t\t\t\tq.push(P(dir[np],np));\n\t\t\t}\n\t\t}\n\t}\n\treturn dir;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,m,s,t;\n\tcin>>n>>m>>s>>t;\n\ts--; t--;\n\tvector<vector<P>> adj(n);\n\tREP(i,m) {\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tx--;\n\t\ty--;\n\t\tadj[x].pb(P(y,1));\n\t\tadj[y].pb(P(x,1));\n\t}\n\tvector<ll> froms=dijkstra(s,adj);\n\tvector<ll> fromt=dijkstra(t,adj);\n\tmap<ll,ll> cnt;\n\tREP(i,n) cnt[fromt[i]]++;\n\tll ans=0;\n\tREP(i,n) ans+=cnt[froms[t]-froms[i]-2];\n\tcout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100005,INF=1<<30;\n\nvector<int> G[MAX];\n\nint dis[MAX][2];\nll cnt[MAX][2];\n\nvoid BFS(int u,int type){\n    queue<int> Q;\n    Q.push(u);\n    dis[u][type]=0;\n    \n    while(!Q.empty()){\n        int a=Q.front();Q.pop();\n        for(int to:G[a]){\n            if(dis[to][type]==INF){\n                dis[to][type]=dis[a][type]+1;\n                Q.push(to);\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M,s,t;cin>>N>>M>>s>>t;\n    s--;t--;\n    \n    for(int i=0;i<M;i++){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    \n    for(int i=0;i<N;i++) dis[i][0]=dis[i][1]=INF;\n    \n    BFS(s,0);\n    BFS(t,1);\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<2;j++){\n            if(dis[i][j]==INF) continue;\n            \n            cnt[dis[i][j]][j]++;\n        }\n    }\n    \n    ll ans=0;\n    \n    int ma=dis[t][0];\n    \n    for(int l=0;l<=ma-2;l++){\n        ans+=cnt[l][0]*cnt[ma-2-l][1];\n        \n        //cout<<ans<<endl;\n    }\n    \n    cout<<ans<<endl;\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)N;i++)\n#define p(s) cout<<(s)<<endl\n#define ck(n,a,b) ((a)<=(n)&&(n)<(b))\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\n\nint d[100010];//dist\nint fromS[100010];\nint fromT[100010];\nvector<int> edge[100100];\nint main() {\n\tint N,M,s,t;\n\tcin>>N>>M>>s>>t;\n\ts--;t--;\n\tREP(i,0,M){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--;y--;\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tqueue<int> q,qq;\n\tfromS[0]=1;fromT[0]=1;\n\tq.push(s);\n\tREP(i,0,N) d[i]=inf;\n\td[s]=0;\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\tfor(int next:edge[now]){\n\t\t\tif(d[next]<inf) continue;\n\t\t\tq.push(next);\n\t\t\td[next]=d[now]+1;\n\t\t\tfromS[d[next]]++;\n\t\t}\n\t\tif(d[t]<inf) break;\n\t}\n\n\tREP(i,0,N) d[i]=inf;\n\tqq.push(t);\n\td[t]=0;\n\twhile(!qq.empty()){\n\t\tint now=qq.front();qq.pop();\n\t\tfor(auto next:edge[now]){\n\t\t\tif(d[next]<inf) continue;\n\t\t\tqq.push(next);\n\t\t\td[next]=d[now]+1;\n\t\t\tfromT[d[next]]++;\n\t\t}\n\t\tif(d[s]<inf) break;\n\t}\n\tint sans=0;\n\tREP(i,2,d[s]){\n\t\tif(i==2){\n\t\t\tsans=1;\n\t\t\tcontinue;\n\t\t}\n\t\tsans+=fromS[i]*fromS[i-2];\n\t}\n\tif(d[s]>1) sans++;\n\tint tans=0;\n\tREP(i,2,d[s]){\n\t\tif(i==2){\n\t\t\ttans=1;\n\t\t\tcontinue;\n\t\t}\n\t\ttans+=fromT[i]*fromT[i-2];\n\t}\n\tif(d[s]>1)tans++;\n\tp(tans+sans-d[s]+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (int)1e6\nusing namespace std;\ntypedef vector<pair<int,int> > vpii;\n\nvoid calc(int s, vector<int> &d, vpii &adj){\n\td[s] = 0;\n\tpriority_queue<pair<int,int> > npos;\n\tnpos.push(make_pair(0,s) );\n\n\twhile(!npos.empty()){\n\t\tpair<int,int> temp = npos.top();\n\t\tnpos.pop();\n\t\tint cost = temp.first + 1;\n\t\tint now = temp.second;\n\t\tvpii::iterator it = lower_bound(adj.begin(),adj.end(), make_pair( now, 0) );\n\t\tvpii::iterator iend = lower_bound(adj.begin(), adj.end(),make_pair( now+1, 0) );\n\t\tfor(; it != iend; ++it){\n\t\t\tint next = it->second;\n\t\t\tif(d[next] > cost){\n\t\t\t\td[next] = cost;\n\t\t\t\tnpos.push(make_pair(cost, next));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tint n,m,s,t;\n\tcin >> n >> m >> s >> t;\n\t/*\n\tvector<list<int> > adj(n+1,list<int>(0));\n\tfor(int i = 0; i < m; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\t*/\n\tvpii adj(2 * m);\n\tfor(int i = 0; i < m; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tadj[2*i] = make_pair(x,y);\n\t\tadj[2*i+1] = make_pair(y,x);\n\t}\n\tsort(adj.begin(), adj.end());\n\n\t//for(int i = 1; i < n+1 ; i++){ \\\n\t\tcout << i << \" ; \";\t\t\t\\\n\t\tfor(int j = 0; j < adj[i].size(); j++){ \\\n\t\t\tcout << adj[i][j] << \" \"; \\\n\t\t} \\\n\t\tcout << endl; \\\n\t}\n\n\tvector<int> sd(n+1,INF);\n\tvector<int> td(n+1,INF);\n\tcalc(s,sd,adj);\n\tcalc(t,td,adj);\n\n\tint stcost = sd[t];\n\t\n\tvector<int> sdis(stcost+1), tdis(stcost+1);\n\n\tfor(int i = 0, im = td.size(); i < im; ++i){\n\t\tif(sd[i] < stcost) sdis[sd[i]]++;\n\t//\tcout << i << \" ; \" << sd[i] << endl;\n\t}\n//\tcout << endl;\n\tfor(int i = 0, im = td.size(); i < im; ++i){\n\t\tif(td[i] < stcost) tdis[td[i]]++;\n\t//\tcout << i << \" ; \" << td[i] << endl;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i <= stcost -2; ++i){\n\t\tans += sdis[i] * tdis[stcost - i -2];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\t\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    --s;\n    --t;\n    vector<vector<int>> edge(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    vector<int> ds(n, -1);\n    vector<int> cs(n, 0);\n    queue<int> q;\n    q.push(s);\n    ds[s] = 0;\n    ++cs[0];\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        for (int i : edge[p]) {\n            if (ds[i] == -1) {\n                ds[i] = ds[p] + 1;\n                ++cs[ds[i]];\n                q.push(i);\n            }\n        }\n    }\n    vector<int> dt(n, -1);\n    vector<int> ct(n, 0);\n    q.push(t);\n    dt[t] = 0;\n    ++ct[0];\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        for (int i : edge[p]) {\n            if (dt[i] == -1) {\n                dt[i] = dt[p] + 1;\n                ++ct[dt[i]];\n                q.push(i);\n            }\n        }\n    }\n    int l = ds[t] - 1;\n    long long ans = 0;\n    for (int i = 0; i <= l; ++i) {\n        ans += cs[i] * (long long)ct[l - i - 1];\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n[100000], m[100000];\nvector<int>rinsetu[100000];\nsigned main() {\n\tunordered_map<int, int>X, Y;\n\tint a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d); c--; d--;\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g; scanf(\"%d%d\", &f, &g);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tmemset(n, -1, sizeof(n));\n\tmemset(m, -1, sizeof(m));\n\tn[c] = 0; m[d] = 0;\n\tqueue<int>Q;\n\tQ.push(c);\n\twhile (Q.size()) {\n\t\tint e = Q.front(); Q.pop();\n\t\tX[n[e]]++;\n\t\tfor (int f : rinsetu[e]) {\n\t\t\tif (n[f] == -1) {\n\t\t\t\tn[f] = n[e] + 1;\n\t\t\t\tQ.push(f);\n\t\t\t}\n\t\t}\n\t}\n\tQ.push(d);\n\twhile (Q.size()) {\n\t\tint e = Q.front(); Q.pop();\n\t\tY[m[e]]++;\n\t\tfor (int f : rinsetu[e]) {\n\t\t\tif (m[f] == -1) {\n\t\t\t\tm[f] = m[e] + 1;\n\t\t\t\tQ.push(f);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < a; i++) {\n\t\tans += X[n[d] - m[i] - 2];\n\t\tans += Y[m[c] - n[i] - 2];\n\t}\n\tprintf(\"%lld\\n\", ans / 2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nstruct P {\n    int v;\n    int cost;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nint G1[100001];\nint G2[100001];\nint W1[100001];\nint W2[100001];\nbool exclude[100001];\n\nint get_min_cost(int s, int t, vvi& E, int* G) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    G[s] = 0;\n    que.push({s, 0});\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        if (p.v == t) {\n            return p.cost;\n        }\n        if (G[p.v] < p.cost) continue;\n        for (int to : E[p.v]) {\n            if (G[to] > p.cost+1) {\n                G[to] = p.cost+1;\n                que.push({to, p.cost+1});\n            }\n        }\n    }\n    return INF;\n}\n\nint get_min_cost2(int s, int t, vvi& E, int* G) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    G[s] = 0;\n    que.push({s, 0});\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        if (p.v == t) {\n            return p.cost;\n        }\n        if (G[p.v] < p.cost) continue;\n        for (int to : E[p.v]) {\n            if (G[to] > p.cost+1) {\n                G[to] = p.cost+1;\n                que.push({to, p.cost+1});\n            }\n        }\n    }\n    return INF;\n}\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    vvi E(n+1);\n    REP(i, m) {\n        int x, y;\n        cin >> x >> y;\n        E[x].push_back(y);\n        E[y].push_back(x);\n    }\n\n    fill_n((int *)G1, 100001, INF);\n    fill_n((int *)G2, 100001, INF);\n\n    int min_cost = get_min_cost(s, t, E, G1);\n    get_min_cost2(t, s, E, G2);\n\n    FOR(i, 1, n+1) {\n        if (G1[i] != INF) {\n            G1[i] = min_cost - G1[i];\n        }\n        // s, t??????????????????????????????????????????????????????????????????????????¨\n        if (G1[i] != INF && G1[i] == G2[i]) {\n        } else if ((G1[i] == INF && G2[i] != INF) || (G1[i] != INF && G2[i] == INF)) {\n        } else {\n            exclude[i] = true;\n        }\n        if (G1[i] <= min_cost) {\n            W1[G1[i]]++;\n        }\n    }\n\n    int cost = 0;\n    queue<int> que;\n    que.push(t);\n    que.push(-1);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        if (v == -1) {\n            cost++;\n            if (que.empty()) break;\n            if (cost > min_cost) break;\n            que.push(-1);\n            continue;\n        }\n        for (int to : E[v]) {\n            if (G1[to] == INF) {\n                G1[to] = cost+1;\n                que.push(to);\n            }\n        }\n    }\n\n    FOR(i, 1, n+1) {\n        if (G1[i] <= min_cost && !exclude[i]) {\n            W2[G1[i]]++;\n        }\n    }\n\n//    REP(i, min_cost+1) {\n//        LOG(\"%d -> %d %d\\n\", i, W1[i], W2[i]);\n//    }\n\n    if (min_cost < 2) {\n        cout << 0 << endl;\n    } else {\n        int res = 0;\n        FOR(i, 2, min_cost+1) {\n//            LOG(\"%d %d -> %d\\n\", W1[i], W2[i-2], W1[i]*W2[i-2]);\n            res += W1[i] * W2[i-2];\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\ntypedef pair<int, int> State;\nint n;\nvvi cost;\n\nvoid dijkstra(int s, vi& dist){\n    dist = vi(n, inf);\n\n    priority_queue<State, vector<State>> q;\n    dist[s] = 0;\n    q.push(mp(0, s));\n\n    while(!q.empty()){\n        int cur_cost = q.top().F;\n        int cur_v = q.top().S;\n        q.pop();\n\n        rep(u, n){\n            if(cur_cost + cost[cur_v][u] < dist[u]){\n                dist[u] = cur_cost + cost[cur_v][u];\n                q.push(mp(dist[u], u));\n            }\n        }\n    }\n}\n\nint main(void){\n    for(int m, s, t, res; cin >> n >> m >> s >> t; cout << res << endl){\n        res = 0;\n\n        s--, t--;\n        cost = vvi(n, vi(n, inf));\n\n        rep(i, m){\n            int x, y; cin >> x >> y;\n            x--, y--;\n            \n            cost[x][y] = cost[y][x] = 1;\n        }\n\n        vi dist_fromS, dist_fromT;\n        dijkstra(s, dist_fromS);\n        dijkstra(t, dist_fromT);\n\n        map<int, int> distCnt_fromS, distCnt_fromT;\n        rep(u, n){\n            distCnt_fromS[dist_fromS[u]]++;\n            distCnt_fromT[dist_fromT[u]]++;\n        }\n\n        int path_len = dist_fromS[t];\n\n        rep(i, path_len + 1){\n            res += distCnt_fromS[i] * distCnt_fromT[path_len - i - 2];\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\nvector<int> used1,used2;\nvector<int> dp1,dp2;\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    vector<vector<int>> v(n);\n    // set<pair<int,int>> se;\n    rep(i,n){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    used1=vector<int>(n+10,-1);\n    used2=vector<int>(n+10,-1);\n    priority_queue<pair<int,int>> pq1;\n    priority_queue<pair<int,int>> pq2;\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    dp1=vector<int>(n+10,0);\n    dp2=vector<int>(n+10,0);\n    rep(i,n){\n        if(0<=used1[i]&&used1[i]<=n) dp1[used1[i]]++;\n        if(0<=used2[i]&&used2[i]<=n) dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n  \n#define INF (1 << 23)\n  \nusing namespace std;\n \nvoid reader(int *x)\n{\n    int k = getchar_unlocked(); *x = k - '0';\n     \n    while(true)\n    {\n        k = getchar_unlocked();\n         \n        if(k < '0' || k > '9') break;\n         \n        *x = ((*x) << 1) + ((*x) << 3) + k - '0';\n    }\n}\n \nchar memarr[17000000]; void *mem = memarr;\n\nint N, M, s, t, u, v;\n\nint r1[100000], r2[100000], d1[100000], d2[100000];\n\nvector<int> G[100000];\n  \nint main()\n{\n    reader(&N);\n    reader(&M);\n    reader(&s); s--;\n    reader(&t); t--;\n\n    for (int i = 0; i < M; i++)\n    {\n        reader(&u);\n        reader(&v);\n  \n        G[u - 1].push_back(v - 1);\n        G[v - 1].push_back(u - 1);\n    }\n    \n    for(int i = 0; i < N; i++) { d1[i] = INF; d2[i] = INF; }\n  \n    d1[s] = 0;\n    d2[t] = 0;\n  \n    queue<int> que;\n  \n    que.push(s);\n  \n    while (!que.empty())\n    {\n        int node = que.front(); que.pop();\n  \n        for (int i = 0; i < G[node].size(); i++)\n        {\n            if (d1[G[node][i]] == INF)\n            {\n                d1[G[node][i]] = d1[node] + 1; que.push(G[node][i]);\n            }\n        }\n    }\n  \n    que.push(t);\n  \n    while (!que.empty())\n    {\n        int node = que.front(); que.pop();\n  \n        for (int i = 0; i < G[node].size(); i++)\n        {\n            if (d2[G[node][i]] == INF)\n            {\n                d2[G[node][i]] = d2[node] + 1; que.push(G[node][i]);\n            }\n        }\n    }\n  \n    int shortest = d1[t];\n  \n    for (int i = 0; i < N; i++) { if (d1[i] < shortest - 1) r1[d1[i]]++; }\n    for (int i = 0; i < N; i++) { if (d2[i] < shortest - 1) r2[d2[i]]++; }\n  \n    long long ret = 0;\n  \n    for (int i = 0; i < shortest - 1; i++) ret += 1LL * r1[i] * r2[shortest - i - 2];\n      \n    printf(\"%lld\\n\", ret);\n  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n#include<vector>\n#include<queue>\n#include<limits>\ntemplate<typename T>\nvector<T>dijkstra(int s,const vector<vector<pair<int,T> > >&G,T INF=numeric_limits<T>::max())\n{\n\tint n=G.size();\n\tvector<T>d(n,INF);\n\tvector<int>parent(n,-1);\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > >P;\n\td[s]=0;\n\tP.push(make_pair(d[s],s));\n\twhile(!P.empty())\n\t{\n\t\tpair<T,int>p=P.top();P.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tfor(const pair<int,T>&e:G[v])\n\t\t{\n\t\t\tint u=e.first;\n\t\t\tT cost=d[v]+e.second;\n\t\t\tif(d[u]>cost)\n\t\t\t{\n\t\t\t\td[u]=cost;\n\t\t\t\tparent[u]=v;\n\t\t\t\tP.push(make_pair(d[u],u));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nint n,m,s,t;\nmain()\n{\n\tcin>>n>>m>>s>>t;\n\ts--,t--;\n\tvector<vector<pair<int,int> > >G(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a,b;cin>>a>>b;\n\t\ta--,b--;\n\t\tG[a].push_back(make_pair(b,1));\n\t\tG[b].push_back(make_pair(a,1));\n\t}\n\tvector<int>ds=dijkstra(s,G);\n\tvector<int>dt=dijkstra(t,G);\n\tint lim=ds[t];\n\tvector<int>cnts(lim,0),cntt(lim,0);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(ds[i]<lim)cnts[ds[i]]++;\n\t\tif(dt[i]<lim)cntt[dt[i]]++;\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<lim-1;i++)\n\t{\n\t\tans+=1LL*cnts[i]*cntt[lim-i-2];\n\t}\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n// 🔴\n\n// O(ElogE)\n\n// pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    int V, E, S, G; cin >> V >> E >> S >> G;     // V:= 頂点の数    E:= 辺の数    S:= スタートノード　　G:= ゴールノード\n    S--;\n    G--;\n    vector<vector<pair<int, int> > > adjlist(V);      //first := コスト　second := 行先\n\n    //入力\n    for(int i = 0; i < E; i++){\n        int a, b; cin >> a >> b;                    // a ,b 間に辺がある\n        a--;\n        b--;\n        adjlist[a].push_back(make_pair(1, b));\n        adjlist[b].push_back(make_pair(1, a));      \n    }\n\n    //int a, b; cin >> a >> b;\n    //adjlist[a].push_back(make_pair(1, b));\n    //adjlist[b].push_back(make_pair(1, a)); \n    \n\n    vector<long long> result_S(V);                 //Sからの距離\n    vector<long long> result_G(V);                 //Gからの距離\n    result_S = dijk(S, V, adjlist);\n    result_G = dijk(G, V, adjlist);    \n    //cout << result[G] << endl;\n\n    vector<long long> s(1000000, 0);\n    vector<long long> g(1000000, 0);\n    for(int i = 0; i < V; i++){\n\n        if(result_S[i] < 10000000) s[result_S[i]]++;\n        \n        if(result_G[i] < 10000000) g[result_G[i]]++;        \n    }\n\n    long long ans = 0;\n    long long dis = result_S[G] - 2;\n    //cout << dis << endl;\n    //result[S];\n    for(int i = 0; dis - i >= 0; i++){\n        \n        //cout << i << \" \" << dis - i << \" \" << s[i] << \" \" << g[i] << endl;\n        \n        ans += s[i] * g[dis - i];\n        //else ans += result_S[i] * result_G[dis - i] + result_S[dis - i] * result_G[i];\n        //cout << i << \": \" << result_S[i] << \" \" << result_G[i] << endl;\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF (long long)(1e18)\n#define MOD (int)(1e9+7)\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 110000\n\nvector<int> G[MAX];\nint d[MAX], d2[MAX], con[MAX],con2[MAX];\nint N, M, s, t, x, y;\n\nvoid bfs(int ss, int d[]){\n\tfill(d,d+N+1,INF);\n\tqueue<int> Q;\n\t\n\td[ss] = 0;\n\tQ.push(ss);\n\t\n\twhile(!Q.empty()){\n\t\tint f = Q.front(); Q.pop();//cout<<f<<endl;\n\t\t// if(f == t) break;\n\t\tfor(int y : G[f]){\n\t\t\tif(d[y] == INF){\n\t\t\t\td[y] = d[f]+1;\n\t\t\t\tQ.push(y);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint re = 0;\n\tbfs(s,d);bfs(t,d2);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(d[i] != INF)con[d[i]]++;\n\t\tif(d2[i] != INF)con2[d2[i]]++;\n\t}//cout<<\" test test \"<<endl;\n\tfor(int i = 0; i <= d[t]-2; i++){\n\t\t// cout<<i<<\" \"<<con[i]<<\" \"<<con2[i]<<endl;\n\t\tre += con[i]*con2[d[t]-i-2];\n\t}\n\treturn re;\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(7);\n\t\n\tcin>>N>>M>>s>>t;\n\t\n\t\n\n\trep(i,M){\n\t\tcin>>x>>y;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\t\n\tcout<<solve()<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> edges[123456];\n\nint N,M,s,t;\n\nvector<int> dijkstra(int s){\n  vector<int> d(N,1e9);\n  queue<pair<int,int> > que;\n  que.push({s,0});\n  while(!que.empty()){\n    auto c=que.front();\n    que.pop();\n    if(d[c.first]<=c.second)continue;\n    d[c.first]=c.second;\n    for(auto e:edges[c.first]){\n      que.push({e,c.second+1});\n    }\n  }\n  return d;\n}\n\nint main(){\n  cin>>N>>M>>s>>t;\n  s--;\n  t--;\n  while(M--){\n    int x,y;\n    cin>>x>>y;\n    x--;\n    y--;\n    edges[x].push_back(y);\n    edges[y].push_back(x);\n  }\n  auto sto=dijkstra(s);\n  auto tto=dijkstra(t);\n  int sp=sto[t];\n  sort(begin(sto),end(sto));\n  long long ans=0;\n  for(auto e:tto){\n    ans+=upper_bound(begin(sto),end(sto),sp-2-e)-lower_bound(begin(sto),end(sto),sp-2-e);\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N, M;\nvector<int>G[100005];\n\nvector<int> dijkstra(int s)\n{\n  vector<int>d(N, INF);\n  priority_queue<pi, vector<pi>, greater<pi> >Q;\n  Q.push(pi(0, s));\n  d[s] = 0;\n  while(!Q.empty()){\n    pi p = Q.top(); Q.pop();\n    int n = p.second;\n    if(d[n] < p.first) continue;\n    for(auto g:G[n]){\n      if(d[g] >= d[n] + 1){\n\tQ.push(pi(d[n]+1, g));\n\td[g] = d[n] + 1;\n      }\n    }\n  }\n  return d;\n}\n\nint main()\n{\n  int s, t;\n  scanf(\"%d%d%d%d\", &N, &M, &s, &t); s--; t--;\n  rep(i, M){\n    int x, y; scanf(\"%d%d\", &x, &y); x--; y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n\n  vector<int>S = dijkstra(s);\n  vector<int>T = dijkstra(t);\n  \n  multiset<int>dist;\n  for(auto x: T)\n    dist.insert(x);\n\n  int d = S[t];\n  ll res = 0;\n  for(auto x: S){\n    //    cout << x << \" \" << d - x - 2 << \" \" << dist.count(d-x-2) << endl;\n    res += dist.count(d - x - 2);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nint dp[2][200000];\nvector<int> vertexs[200000];\nint cnt[2][200000];\nvector<int> check[2][200000];\nvoid solve(){\n\tint n, m, s, t;\n\tcin >> n >> m >> s >> t;\n\tREP(i, n) {\n\t\tdp[0][i+1] = 1e9;\n\t\tdp[1][i+1] = 1e9;\n\t}\n\tdp[0][s] = 0;\n\tdp[1][t] = 0;\n\tREP(i, m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tvertexs[a].push_back(b);\n\t\tvertexs[b].push_back(a);\n\t}\n\tREP(tea, 2) {\n\t\tqueue<int> next;\n\t\tnext.push(s);\n\t\twhile (next.empty() == false) {\n\t\t\tint now = next.front();\n\t\t\tnext.pop();\n\t\t\tcnt[tea][dp[tea][now]]++;\n\t\t\tcheck[tea][dp[tea][now]].push_back(now);\n\t\t\tfor (auto x : vertexs[now]) {\n\t\t\t\tif (dp[tea][x] > dp[tea][now] + 1) {\n\t\t\t\t\tdp[tea][x] = dp[tea][now] + 1;\n\t\t\t\t\tnext.push(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(s, t);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= dp[0][t] - 2; ++i) {\n\t\tans += cnt[0][i] * cnt[1][dp[0][t] - 2 - i];\n\t\tfor (auto x : check[0][i]) {\n\t\t\tcnt[1][dp[1][x]]--;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n#undef int\n\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 100000\n#define INF (1<<29)\ntypedef long long ll;\n\nvoid bfs(int s,int *d,int *cnt,vector<int> G[MAX_V]){\n  queue<int> Q; Q.push(s);\n  memset(cnt,0,sizeof(cnt));\n  fill(d,d+MAX_V,INF);\n  d[s] = 0;\n  cnt[d[s]]++;\n  while(!Q.empty()){\n    int v = Q.front(); Q.pop();\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      int to = G[v][i];\n      if(d[v] + 1 < d[to]){\n        d[to] = d[v] + 1;\n        cnt[d[to]]++;\n        Q.push(to);\n      }\n    }\n  }\n}\n\nint main(){\n  int V,E,S,T,x,y;\n  int ds[MAX_V],dt[MAX_V];\n  int cs[MAX_V],ct[MAX_V];\n  vector<int> G[MAX_V];\n  cin >> V >> E >> S >> T;\n  S--; T--;\n  for(int i = 0 ; i < E ; i++){\n    cin >> x >> y; x--; y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  \n  bfs(S,ds,cs,G); \n  bfs(T,dt,ct,G);\n  \n  ll ans = 0LL;\n  int min_dist = ds[T];\n  for(int i = 0 ; i < V ; i++){\n    int j = min_dist-2-i;\n    ans += (j >= 0 ? cs[i]*ct[j] : 0);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<bool> isReached(N, false), is(N,false);\n    vector<int> count(N,0),c(N,0);\n    vector< vector<int> > graph(N);\n    queue<int> que;\n    vector<int> dist(N),d(N);\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    int x, y;\n    for(int i=0 ; i<M ; i++){\n        cin >> x >> y;\n        x--; y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n    int now;\n    que.push(s);\n    count[0] = 1;\n    isReached[s] = true;\n    dist[s] = 0;\n    while(!que.empty()){\n        now = que.front();\n        que.pop();\n        for(int i=0; i<graph[now].size() ; i++){\n            if(!isReached[graph[now][i]]){\n                que.push(graph[now][i]);\n                isReached[graph[now][i]] = true;\n                dist[graph[now][i]] = dist[now]+1;\n                count[dist[graph[now][i]]]++;\n            }\n        }\n    }\n    que.push(t);\n    c[0] = 1;\n    is[t] = true;\n    d[t]=0;\n    while(!que.empty()){\n        now = que.front();\n        que.pop();\n        for(int i=0; i<graph[now].size() ; i++){\n            if(!is[graph[now][i]]){\n                que.push(graph[now][i]);\n                is[graph[now][i]] = true;\n                d[graph[now][i]] = d[now]+1;\n                c[d[graph[now][i]]]++;\n            }\n        }\n    }\n    ll ans=0;\n    for(int i=0; i<= dist[t]-2 ; i++){\n        ans+= count[i]*c[dist[t]-2-i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge {\n\tint from,to;\n\tint cost;\n\n\tedge(int t,int c) : to(t),cost(c) {}\n\tedge(int f,int t,int c) : from(f),to(t),cost(c) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nvector<edge> G[100005];\nint d[100005], d2[100005], cnt[100005], in[100005], pre[100005];\nbool used[100005];\n\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\trep(i, 100005) d[i] = INF, pre[i] = -1;\n\t\n\n\tque.push(mp(0, s));\n\td[s] = 0;\n\n\twhile(que.size()) {\n\t\tP p = que.top(); que.pop();\n\t\tint cost = p.first;\n\t\tint v = p.second;\n\n\t\tif(d[v] < cost) continue;\n\n\t\trep(i, G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tpre[e.to] = v;\n\t\t\t\tque.push(mp(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<int> get_path(int t) {\n\tvector<int> path;\n\tfor(;t!=-1;t=pre[t]) path.push_back(t);\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tint s, t;\n\tcin >> s >> t;\n\ts--; t--;\n\n\trep(i, m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\n\t\tG[a].push_back(edge(b, 1));\n\t\tG[b].push_back(edge(a, 1));\n\t}\n\n\tdijkstra(s);\n\tvector<int> ret = get_path(t);\n\n\tmemset(used, 0, sizeof(used));\n\trep(i, ret.size()) used[ret[i]] = true;\n\n\tmemset(cnt, 0, sizeof(cnt));\n\trep(i, n) {\n\t\td2[i] = d[i];\n\t\tif(d[i] == INF) continue;\n\t\tcnt[d[i]]++;\n\t\tif(used[i]) {\n\t\t\tin[d[i]]++;\n\t\t}\n\t}\n\n\tdijkstra(t);\n\trep(i, n) swap(d[i], d2[i]);\n\n\tll ans = 0;\n\trep(i, n) {\n\t\tif(d[i] == INF) continue;\n\t\tif(d[i] + 1 == d[t] || d[i] == d[t]) continue;\n\n\t\tif(d[i] <= d[t]) {\n\t\t\tans += in[ d[i] + 2 ];\n\t\t} else {\n\t\t\tif(d[i] - d[t] == d2[i]) {\n\t\t\t\tint ov = d[i] - d[t] + 1;\n\t\t\t\tif(d[t] - 1 - ov >= 0) {\n\t\t\t\t\tans += cnt[ d[t] -1 - ov ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n};\n\ntemplate <typename T>\nusing Edges = vector<Edge<T>>;\ntemplate <typename T>\nusing AdjList = vector<Edges<T>>;\n\ntemplate <typename T>\nclass Dijkstra {\n    private:\n        T INF = 1e9;\n        int V;           // 頂点数\n        AdjList<T> adj;  // adj[始点][動的配列で始点から伸びる枝]\n        vector<int> prever;\n\n    public:\n        Dijkstra(int n);\n        vector<T> cost;\n        void AddEdge(int f, int t, int c);\n        bool HasPath(int t);                 // tに至るパスはあるか\n        vector<int> GetShortestPath(int t);  // tへの最短路\n        void Run(int f);\n};\n\ntemplate <typename T>\nDijkstra<T>::Dijkstra(int n) : \n    V(n + 1), adj(V), prever(vector<int>(V, -1)), cost(V)\n{\n    fill(cost.begin(), cost.end(), INF);\n}\n\ntemplate <typename T>\nvoid Dijkstra<T>::AddEdge(int f, int t, int c) {\n    adj[f].push_back(Edge<T>(t, c));\n}\n\ntemplate <typename T>\nbool Dijkstra<T>::HasPath(int t) {\n    return cost[t] != INF;\n}\n\ntemplate <typename T>\nvector<int> Dijkstra<T>::GetShortestPath(int t) {\n    vector<int> path;\n    for (; t != -1; t = prever[t]) path.push_back(t);\n\n    reverse(path.begin(), path.end());\n    return path;\n}\n\ntemplate <typename T>\nvoid Dijkstra<T>::Run(int firstNode) {\n    // 初期化\n    cost.assign(V, INF);\n    prever.assign(V, -1);\n\n    using Pi = pair<T, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> pq;\n\n    cost[firstNode] = 0;\n    pq.push(Pi(cost[firstNode], firstNode));\n\n    while (!pq.empty()) {\n        Pi currentEdge = pq.top();\n        pq.pop();\n        if (cost[currentEdge.second] < currentEdge.first) continue;\n\n        for (Edge<T> tmp : adj[currentEdge.second]) {\n            T sumCost = currentEdge.first + tmp.cost;\n            if (cost[tmp.to] > sumCost) {\n                cost[tmp.to] = sumCost;\n                prever[tmp.to] = currentEdge.second;\n                pq.push(Pi(cost[tmp.to], tmp.to));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--, t--;\n    Dijkstra<int> ds(n), dt(n);\n    \n    vector<vector<int>> graph(n);\n    REP(i, m){\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        ds.AddEdge(x, y, 1);\n        ds.AddEdge(y, x, 1);\n        dt.AddEdge(x, y, 1);\n        dt.AddEdge(y, x, 1);\n    }\n\n    ds.Run(s); dt.Run(t);\n    vector<LL> ds_num(n, 0LL), dt_num(n, 0LL);\n    REP(i, n){\n        if(ds.cost[i] != INF) ds_num[ds.cost[i]]++;\n        if(dt.cost[i] != INF) dt_num[dt.cost[i]]++;\n    }\n    \n    LL ans = 0;\n    REP(i, ds.cost[t]){\n        ans += ds_num[i] * dt_num[ds.cost[t]-2-i];\n    }\n\n    cout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    --s;\n    --t;\n    vector<vector<int>> edge(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    vector<int> ds(n, -1);\n    vector<long long> cs(n, 0);\n    queue<int> q;\n    q.push(s);\n    ds[s] = 0;\n    ++cs[0];\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        for (int i : edge[p]) {\n            if (ds[i] == -1) {\n                ds[i] = ds[p] + 1;\n                ++cs[ds[i]];\n                q.push(i);\n            }\n        }\n    }\n    vector<int> dt(n, -1);\n    vector<long long> ct(n, 0);\n    q.push(t);\n    dt[t] = 0;\n    ++ct[0];\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        for (int i : edge[p]) {\n            if (dt[i] == -1) {\n                dt[i] = dt[p] + 1;\n                ++ct[dt[i]];\n                q.push(i);\n            }\n        }\n    }\n    int l = ds[t] - 1;\n    long long ans = 0;\n    for (int i = 0; i <= l; ++i) {\n        ans += cs[i] * ct[l - i - 1];\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst int V = 100010;\n\nint n, m;\nvector<int> G[100010];\nint d[100010], dr[100010];\n\nstruct dijkstra{\n    vector<int> d;\n    dijkstra(){}\n    dijkstra(int V){\n        d.resize(V, INF);\n    }\n    void calc(int s){\n        d[s] = 0;\n        priority_queue<P, vector<P>, greater<P> > q;\n        q.push(P(d[s], s));\n        while(!q.empty()){\n            P p = q.top(); q.pop();\n            int from = p.second;\n            int cost = p.first;\n            if(d[from] < cost) continue;\n            rep(i, 0, G[from].size()){\n                int next = G[from][i];\n                int newCost = cost + 1;\n                if(d[next] > newCost){\n                    d[next] = newCost;\n                    q.push(P(newCost, next));\n                }\n            }\n        }\n    }\n};\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int s, t;\n    cin >> n >> m >> s >> t;\n    s--; t--;\n    rep(i, 0, m){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dijkstra d1(n), d2(n);\n    d1.calc(s);\n    d2.calc(t);\n    int MIN = d1.d[t];\n    int ans = 0;\n    map<P, int> mp;\n    map<int, int> mp1, mp2;\n    rep(i, 0, n){\n        mp[P(d1.d[i], d2.d[i])]++;\n        mp1[d1.d[i]]++;\n        mp2[d2.d[i]]++;\n    }\n    rep(i, 0, MIN){\n        // ans += mp[P(i, MIN - i)] * mp[P(i + 2, MIN - i - 2)];\n        ans += mp1[i] * mp2[MIN - i - 2];\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 10000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_cost_sum){\n\t\tnode_id = arg_node_id;\n\t\tcost_sum = arg_cost_sum;\n\t}\n\tint node_id,cost_sum;\n};\n\nint main(){\n\n\tint N,M,start,goal;\n\tscanf(\"%d %d %d %d\",&N,&M,&start,&goal);\n\n\tll* from_start_Dist = new ll[N+1];\n\tll* from_goal_Dist = new ll[N+1];\n\tll *Dist_num_from_start = new ll[N+1];\n\tll *Dist_num_from_goal = new ll[N+1];\n\n\tvector<int> V[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfrom_start_Dist[i] = BIG_NUM;\n\t\tfrom_goal_Dist[i] = BIG_NUM;\n\t\tDist_num_from_start[i] = 0;\n\t\tDist_num_from_goal[i] = 0;\n\t}\n\n\tfrom_start_Dist[start] = 0;\n\tfrom_goal_Dist[goal] = 0;\n\tDist_num_from_start[0] = 0;\n\tDist_num_from_goal[0] = 0;\n\n\tint from,to;\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tV[from].push_back(to);\n\t\tV[to].push_back(from);\n\t}\n\n\tqueue<Info> Q;\n\n\tfor(int i = 0; i < V[start].size(); i++){\n\t\tfrom_start_Dist[V[start][i]] = 1;\n\t\tQ.push(Info(V[start][i],1));\n\t}\n\n\tint min_index;\n\n\twhile(!Q.empty()){\n\t\tif(Q.front().cost_sum > from_start_Dist[Q.front().node_id]){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tmin_index = Q.front().node_id;\n\t\t\tQ.pop();\n\t\t}\n\n\t\tfor(int i = 0; i < V[min_index].size();i++){\n\t\t\tif(from_start_Dist[V[min_index][i]] > from_start_Dist[min_index] + 1){\n\t\t\t\tfrom_start_Dist[V[min_index][i]] =from_start_Dist[min_index] + 1;\n\t\t\t\tQ.push(Info(V[min_index][i],from_start_Dist[V[min_index][i]]));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tif(from_start_Dist[i] != BIG_NUM){\n\t\t\tDist_num_from_start[from_start_Dist[i]]++;\n\t\t}\n\t}\n\tint length = from_start_Dist[goal];\n\n\n\tfor(int i = 0; i < V[goal].size(); i++){\n\t\tfrom_goal_Dist[V[goal][i]] = 1;\n\t\tQ.push(Info(V[goal][i],1));\n\t}\n\n\twhile(!Q.empty()){\n\t\tif(Q.front().cost_sum > from_goal_Dist[Q.front().node_id]){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tmin_index = Q.front().node_id;\n\t\t\tQ.pop();\n\t\t}\n\n\t\tfor(int i = 0; i < V[min_index].size();i++){\n\t\t\tif(from_goal_Dist[V[min_index][i]] > from_goal_Dist[min_index] + 1){\n\t\t\t\tfrom_goal_Dist[V[min_index][i]] =from_goal_Dist[min_index] + 1;\n\t\t\t\tQ.push(Info(V[min_index][i],from_goal_Dist[V[min_index][i]]));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tif(from_goal_Dist[i] != BIG_NUM){\n\t\t\tDist_num_from_goal[from_goal_Dist[i]]++;\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 0; i <= length-2; i++){\n\t\tans += Dist_num_from_start[i]*Dist_num_from_goal[(length-2)-i];\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nvector<int> bfs(vector<vector<int> > &G, int s) {  \n  vector<int> d(G.size(), -1);  \n  queue<int> Q;\n  Q.push(s);\n  d[s] = 0;\n  while ( !Q.empty() ) {\n    int v = Q.front(); Q.pop();\n\n    for ( int u : G[v] ) {\n      if ( d[u] >= 0 ) continue;\n      d[u] = d[v]+1;\n      Q.push(u);      \n    }    \n  }\n\n  return d;  \n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M, s, t;\n  cin >> N >> M >> s >> t;\n  s--; t--;\n\n  vector<vector<int> > G(N);\n  for ( int i = 0; i < M; i++ ) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);    \n  }\n\n  vector<int> ds = bfs(G, s);\n  vector<int> dt = bfs(G, t);\n  vector<int> cnts(N, 0), cntt(N, 0);  \n  for ( int i = 0; i < N; i++ ) {\n    if ( ds[i] >= 0 ) cnts[ds[i]]++;\n    if ( dt[i] >= 0 ) cntt[dt[i]]++;    \n  }\n\n  int ans = 0;\n  int mi = ds[t];\n  for ( int i = 0; i < N; i++ ) {    \n    if ( mi-i-2 >= 0 ) ans += cnts[i] * cntt[mi-i-2];    \n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n \nusing namespace std;\n \ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 110000\n\nint N;\n\nstruct edge{\n\tint to;\n\tlong long int cost;\n};\n\nvector<edge> G[MAX_V];\nlong long int d[MAX_V];\n\n// 速さはO(|E|log|V|)\n\nvoid shortest_path(int s, int V){ // Vは頂点数\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\t\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t} // 頂点への最小コストを更新\n\t}\n}\n\nlong long int cnt1[310000] = {}, cnt2[310000] = {};\n\nint main(){\n\t\n\tlong long int N, M, s, t;\n\tcin >> N >> M >> s >> t;\n\ts--;\n\tt--;\n\t\n\tfor(int i = 0; i < M; i++){\n\t\tedge e;\n\t\te.cost = 1;\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--;\n\t\tv--;\n\t\te.to = v;\n\t\tG[u].push_back(e);\n\t\te.to = u;\n\t\tG[v].push_back(e);\n\t}\n\t\n\tshortest_path(s, N);\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tif(d[i] < M){\n\t\t\tcnt1[d[i]]++;\n\t\t}\n\t}\n\t\n\tint dist = d[t];\n\t\n\tshortest_path(t, N);\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tif(d[i] < M){\n\t\t\tcnt2[d[i]]++;\n\t\t}\n\t}\n\t\n\tlong long int ans = 0;\n\t\n\tfor(int i = 0; i <= dist - 2; i++){\n\t\tans += cnt1[i] * cnt2[dist - i - 2];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\n#define MAX 100010\nusing namespace std;\n\nconst int INF = 1e9;\nvoid bfs(int s, vector<ll> &d, vector<int> g[]) {\n    vector<bool> used(MAX, false);\n    d[s] = 0;\n    queue<int> que;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n        if (used[v]) continue;\n        used[v] = true;\n        for (int nx : g[v]) {\n            if (!used[nx] && d[nx] > d[v] + 1) {\n                d[nx] = d[v] + 1;\n                que.push(nx);\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--;\n    t--;\n    vector<int> g[n];\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<ll> ds(MAX, INF), dt(MAX, INF);\n    bfs(s, ds, g);\n    bfs(t, dt, g);\n    vector<int> ca(MAX, 0);\n    for (int i = 0; i < n; i++) {\n        if (dt[i] == INF) continue;\n        ca[dt[i]]++;\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; i++){\n        if(dt[i] == INF || ds[i] == INF) continue;\n        int x = ds[t] - 2 - ds[i];\n        if (x >= 0) ans += ca[x];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nmap<ll,ll> prime_factor(ll n) {\n  map<ll,ll> res;\n  for(ll i=2; i*i <= n; i++) {\n      while(n%i == 0) {\n          res[i]++;\n          n /= i;\n      }\n  }\n\n  if(n != 1) res[n] = 1;\n  return res;\n}\n\nstruct Node {\n    int mi, mx;\n    Node(int mi, int mx) : mi(mi), mx(mx) {}\n    Node(){}\n} seg[1<<23];\n\nvoid update(int i, int x){\n    i += (1<<22)-1;\n    seg[i].mi = seg[i].mx = x;\n\n    while(i > 0){\n        i = (i-1)/2;\n        seg[i].mi = min(seg[i*2+1].mi, seg[i*2+2].mi);\n        seg[i].mx = max(seg[i*2+1].mx, seg[i*2+2].mx);\n    }\n}\n\nNode query(int a, int b, int k=0, int l=0, int r = (1<<22)){\n    if(r <= a || b <= l) return Node(INT_MAX, -INT_MAX);\n    if(a <= l && r <= b) return seg[k];\n    else{\n        Node vl = query(a, b, k*2+1, l, (l+r)/2);\n        Node vr = query(a, b, k*2+2, (l+r)/2, r);\n\n        return Node(min(vl.mi, vr.mi), max(vl.mx, vr.mx));\n    }\n}\n\nvector<vector<int>> g(100010);\nint ds[100010];\nint dg[100010];\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n    \n    \n    int N, M, s, t; cin >> N >> M >> s >> t;\n\n    s--; t--;\n\n    REP(i,M){\n        int x, y; cin >> x >> y;\n        x--; y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    REP(i,N) ds[i] = dg[i] = INT_MAX;\n\n    {\n        queue<int> q;\n        q.push(s);\n        ds[s] = 0;\n        while(q.size()){\n            int v = q.front();\n            q.pop();\n\n            for(int i=0; i<g[v].size(); i++){\n                if(ds[g[v][i]] == INT_MAX){\n                    ds[g[v][i]] = ds[v] + 1;\n                    q.push(g[v][i]);\n                }\n            }\n        }\n    }\n\n    \n    {\n        queue<int> q;\n        q.push(t);\n        dg[t] = 0;\n        while(q.size()){\n            int v = q.front();\n            q.pop();\n\n            for(int i=0; i<g[v].size(); i++){\n                if(dg[g[v][i]] == INT_MAX){\n                    dg[g[v][i]] = dg[v] + 1;\n                    q.push(g[v][i]);\n                }\n            }\n        }\n    }\n\n    map<ll, ll> mp, mp2;\n    REP(i,N){\n        mp[ds[i]]++;\n        mp2[dg[i]]++;\n    }\n\n    int e = ds[t]-2;\n    ll ans = 0;\n    for(int i=0; i<=e; i++){\n        int v = e-i;\n        \n        ans += mp[i] * mp2[v];\n    }\n    cout << ans << endl;\n\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nvector<int> v[100001];\nint n,m,s,t,d1[100001],d2[100001];\n\nvoid dijkstra1(){\n  for(int i=0;i<n;i++)d1[i]=inf;\n  priority_queue<pair<int,int> > pq;\n  d1[s]=0;\n  pq.push(mp(0,s));\n  while(!pq.empty()){\n    pair<int,int> u=pq.top();\n    pq.pop();\n    int a=(-1)*u.f,b=u.s;\n\n    if(d1[b]<a)continue;\n\n    for(int i=0;i<v[b].size();i++){\n      if(a+1<d1[v[b][i]]){\n\td1[v[b][i]]=a+1;\n\tpq.push(mp((-1)*(a+1),v[b][i]));\n      }\n    }\n  }\n}\n\nvoid dijkstra2(){\n  for(int i=0;i<n;i++)d2[i]=inf;\n  priority_queue<pair<int,int> > pq;\n  d2[t]=0;\n  pq.push(mp(0,t));\n  while(!pq.empty()){\n    pair<int,int> u=pq.top();\n    pq.pop();\n    int a=(-1)*u.f,b=u.s;\n\n    if(d2[b]<a)continue;\n\n    for(int i=0;i<v[b].size();i++){\n      if(a+1<d2[v[b][i]]){\n\td2[v[b][i]]=a+1;\n\tpq.push(mp((-1)*(a+1),v[b][i]));\n      }\n    }\n  }\n}\n\nint main()\n{\n  int a,b;\n\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--;b--;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  dijkstra1();\n  dijkstra2();\n\n  int A[100001]={},B[100001]={},minc=d1[t],ans=0;\n\n  for(int i=0;i<100001;i++){\n    A[i]=0;\n    B[i]=0;\n  }\n  for(int i=0;i<n;i++){\n    if(d1[i]==inf)continue;\n    A[d1[i]]++;\n    B[d2[i]]++;\n  }\n  for(int i=0;i<d1[t]-1;i++){\n    ans+=A[i]*B[minc-2-i];\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\n\nusing  namespace std;\n\n#define rep(i,x)for(int i=0;i<(int)(x);++i)\n\nint N, M, s, t;\nvector<int> G[100010];\nint ds[100010], dt[100010];\nint cnts[100010], cntt[100010];\n\nint main()\n{\n    cin >> N >> M >> s >> t;\n    --s, --t;\n\n    rep(i, M) {\n        int a, b; cin >> a >> b;\n        --a, --b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    {\n        queue<int> q;\n        memset(ds, -1, sizeof ds);\n        ds[s] = 0;\n        q.push(s);\n        while (q.size()) {\n            int u = q.front(); q.pop();\n            for (int v : G[u]) {\n                if (ds[v] == -1) {\n                    ds[v] = ds[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        rep(i, N) cnts[ds[i]]++;\n    }\n    {\n        queue<int> q;\n        memset(dt, -1, sizeof dt);\n        dt[t] = 0;\n        q.push(t);\n        while (q.size()) {\n            int u = q.front(); q.pop();\n            for (int v : G[u]) {\n                if (dt[v] == -1) {\n                    dt[v] = dt[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        rep(i, N) cntt[dt[i]]++;\n    }\n\n    long long ans = 0;\n\n    int dist = ds[t];\n\n    for (int i = 0; ; ++i) {\n        if (i < 0 or dist - i - 2 < 0) break;\n        if (1 or i <= dist - i - 2) {\n            ans += (long long)cnts[i] * cntt[dist - i - 2];\n            //printf(\"ans += cnts[%d] * cntt[%d]\\n\", i, dist-i-2);\n        }\n    }\n    \n    //rep(i, dist+1) printf(\"cnts[%d] = %d\\n\", i, cnts[i]);\n    //rep(i, dist+1) printf(\"cntt[%d] = %d\\n\", i, cntt[i]);\n    \n\n    printf(\"%lld\\n\", ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\n\n#define MAX 100009\nusing namespace std;\ntypedef pair<int,int> P;\n\ntypedef struct Node\n{\n\tint n;\n\tvector<int>e;\n}Node;\n\nNode G[MAX];\nint N,M,s,t,d,a,b;\nlong long res=0;\nmap<int,int>SC,GC;\nvoid dijcstra(int s,int g,map<int,int>&X)\n{\n\tint C[MAX];\n\tmemset(C,0x7f,sizeof(C));\n\tP tmp(0,s);\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(tmp.first>=C[tmp.second])\n\t\t\tcontinue;\n\t\tC[tmp.second]=tmp.first;\n\t\tfor(int i=0;i<G[tmp.second].e.size();i++)\n\t\t{\n\t\t\tint nn=G[tmp.second].e[i];\n\t\t\tif(C[nn]>tmp.first+1)\n\t\t\t{\n\t\t\t\tQ.push(make_pair(tmp.first+1,nn));\n\t\t\t}\n\t\t}\n\t}\n\tif(g==t)d=C[t];\n\tfor(int i=0;i<N;i++)\n\t\tX[C[i]]++;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&M,&s,&t);\n\ts--;t--;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--;y--;\n\t\tG[x].e.push_back(y);\n\t\tG[y].e.push_back(x);\n\t}\n\tdijcstra(s,t,SC);\n\tdijcstra(t,s,GC);\n\tfor(int i=0;i<=d;i++)\n\t{\n\t\tif(d-i-2>=0)\n\t\t\tres+=SC[i]*GC[d-i-2];\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\nvector<int> used1,used2;\nvector<int> dp1,dp2;\npriority_queue<pair<int,int>> pq1;\npriority_queue<pair<int,int>> pq2;\nvector<vector<int>> v;\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    v=vector<vector<int>>(n);\n    // set<pair<int,int>> se;\n    rep(i,m){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    used1=vector<int>(n+10,-1);\n    used2=vector<int>(n+10,-1);\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    dp1=vector<int>(n+10,0);\n    dp2=vector<int>(n+10,0);\n    rep(i,n){\n        dp1[used1[i]]++;\n        dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        // if(i==dist-2-i) ans+=dp1[i]*dp2[dist-2-i]/2;\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n  \n#define INF (1 << 23)\n  \nusing namespace std;\n \nvoid reader(int *x)\n{\n    int k = getchar_unlocked(); *x = k - '0';\n     \n    while(true)\n    {\n        k = getchar_unlocked();\n         \n        if(k < '0' || k > '9') break;\n         \n        *x = ((*x) << 1) + ((*x) << 3) + k - '0';\n    }\n}\n \nchar memarr[17000000]; void *mem = memarr;\n\nint N, M, s, t, u, v;\n\nint r1[100000], r2[100000], d1[100000], d2[100000];\n\nvector<int> G[100000];\n  \nint main()\n{\n    reader(&N);\n    reader(&M);\n    reader(&s); s--;\n    reader(&t); t--;\n\n    for (int i = 0; i < M; i++)\n    {\n        reader(&u);\n        reader(&v);\n  \n        G[u - 1].push_back(v - 1);\n        G[v - 1].push_back(u - 1);\n    }\n    \n    for(int i = 0; i < N; i++) { d1[i] = INF; d2[i] = INF; }\n  \n    d1[s] = 0;\n    d2[t] = 0;\n  \n    queue<int> que;\n  \n    que.push(s);\n  \n    while (!que.empty())\n    {\n        int node = que.front(); que.pop();\n  \n        for (int i = 0; i < G[node].size(); i++)\n        {\n            if (d1[G[node][i]] == INF)\n            {\n                d1[G[node][i]] = d1[node] + 1; que.push(G[node][i]);\n            }\n        }\n    }\n  \n    que.push(t);\n  \n    while (!que.empty())\n    {\n        int node = que.front(); que.pop();\n  \n        for (int i = 0; i < G[node].size(); i++)\n        {\n            if (d2[G[node][i]] == INF)\n            {\n                d2[G[node][i]] = d2[node] + 1; que.push(G[node][i]);\n            }\n        }\n    }\n  \n    int shortest = d1[t];\n  \n    for (int i = 0; i < N; i++) { if (d1[i] < shortest - 1) r1[d1[i]]++; }\n    for (int i = 0; i < N; i++) { if (d2[i] < shortest - 1) r2[d2[i]]++; }\n  \n    long long ret = 0;\n  \n    for (int i = 0; i < shortest - 1; i++) ret += 1LL * r1[i] * r2[shortest - i - 2];\n      \n    printf(\"%lld\\n\", ret);\n  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nstruct P {\n    int v;\n    int cost;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nint G1[100001];\nint G2[100001];\nint W1[100001];\nint W2[100001];\nbool exclude[100001];\n\nint get_min_cost(int s, int t, vvi& E, int* G) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    G[s] = 0;\n    que.push({s, 0});\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        if (p.v == t) {\n            return p.cost;\n        }\n        if (G[p.v] < p.cost) continue;\n        for (int to : E[p.v]) {\n            if (G[to] > p.cost+1) {\n                G[to] = p.cost+1;\n                que.push({to, p.cost+1});\n            }\n        }\n    }\n    return INF;\n}\n\nint get_min_cost2(int s, int t, vvi& E, int* G) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    G[s] = 0;\n    que.push({s, 0});\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        if (p.v == t) {\n            return p.cost;\n        }\n        if (G[p.v] < p.cost) continue;\n        for (int to : E[p.v]) {\n            if (G[to] > p.cost+1) {\n                G[to] = p.cost+1;\n                que.push({to, p.cost+1});\n            }\n        }\n    }\n    return INF;\n}\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    vvi E(n+1);\n    REP(i, m) {\n        int x, y;\n        cin >> x >> y;\n        E[x].push_back(y);\n        E[y].push_back(x);\n    }\n\n    fill_n((int *)G1, 100001, INF);\n    fill_n((int *)G2, 100001, INF);\n\n    int min_cost = get_min_cost(s, t, E, G1);\n    get_min_cost2(t, s, E, G2);\n\n    FOR(i, 1, n+1) {\n        if (G1[i] != INF) {\n            G1[i] = min_cost - G1[i];\n        }\n        // s, t??????????????????????????????????????????????????????????????????????????¨\n        if (G1[i] != INF && G1[i] == G2[i]) {\n        } else if ((G1[i] == INF && G2[i] != INF) || (G1[i] != INF && G2[i] == INF)) {\n        } else {\n            exclude[i] = true;\n        }\n        if (G1[i] <= min_cost) {\n            W1[G1[i]]++;\n        }\n    }\n\n    int cost = 0;\n    queue<int> que;\n    que.push(t);\n    que.push(-1);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        if (v == -1) {\n            cost++;\n            if (que.empty()) break;\n            if (cost > min_cost) break;\n            que.push(-1);\n            continue;\n        }\n        for (int to : E[v]) {\n            if (G1[to] == INF) {\n                G1[to] = cost+1;\n                que.push(to);\n            }\n        }\n    }\n\n    FOR(i, 1, n+1) {\n        if (G1[i] <= min_cost && !exclude[i]) {\n            W2[G1[i]]++;\n        }\n    }\n\n    W2[0] = 1;\n    REP(i, min_cost+1) {\n        LOG(\"%d -> %d %d\\n\", i, W1[i], W2[i]);\n    }\n\n    if (min_cost < 2) {\n        cout << 0 << endl;\n    } else {\n        int res = 0;\n        FOR(i, 2, min_cost+1) {\n            LOG(\"%d %d -> %d\\n\", W1[i], W2[i-2], W1[i]*W2[i-2]);\n            res += W1[i] * W2[i-2];\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define make make_pair\n#define N 100001\nusing namespace std;\ntypedef pair<int,int> P;\nvoid bfs(int,int);\nint n,m,s,t,a,b,cost[2][N],mincost,ans;\nvector<int> c[N];\nbool visited[N];\n\nint main(){\n  cin>>n>>m>>s>>t;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    c[a].push_back(b);\n    c[b].push_back(a);\n  }\n  bfs(0,s);\n  bfs(1,t);\n  for(int i=0;i<=mincost-2;i++) ans+=cost[0][i]*cost[1][mincost-2-i];\n  cout<<ans<<endl;\n  return 0;\n}\n\nvoid bfs(int index,int start){\n  queue<P> q;\n  for(int i=1;i<=n;i++) visited[i]=false;\n  q.push(make(0,start));\n  cost[index][0]++;\n  while(!q.empty()){\n    P k=q.front(); q.pop();\n    int cos=k.first,u=k.second;\n    if(visited[u]) continue;\n    visited[u]=true;\n    for(int i=0;i<(int)c[u].size();i++){\n      if(visited[c[u][i]]) continue;\n      cost[index][cos+1]++;\n      if(!index&&c[u][i]==t) mincost=cos+1;\n      q.push(make(cos+1,c[u][i]));\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#define mk make_pair\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nbool vis[100000];\nint main(){\n  int n,m,s,t,x,y;\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  vector<int> v[100000];\n  set<pair<int,int> >ss;\n  r(i,m){\n    cin>>x>>y;\n    x--;y--;\n    ss.insert(mk(x,y));\n    ss.insert(mk(y,x));\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int s1[n],t1[n];\n  memset(s1,1e6,sizeof(s1));\n  memset(t1,1e6,sizeof(t1));\n  queue<pair<int,int> >q;\n  q.push(mk(s,0));\n  vis[s]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    s1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  memset(vis,0,sizeof(vis));\n  q.push(mk(t,0));\n  vis[t]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    t1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  int po=s1[t],cc=0;\n  vector<int> d[100000];\n  r(i,n)if(s1[i]<n)d[s1[i]].push_back(i);\n  r(i,n)if(t1[i]<n){\n    int tt=po-t1[i]-2;\n    if(tt>-1)r(j,d[tt].size())\n      if(!ss.count(mk(d[tt][j],i))){\n        //cout<<d[tt][j]<<' '<<i<<tt<<endl;\n       cc++;\n      }\n  }\n  cout<<cc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct state {\n  int cost, use, pos;\n  state(int c, int u, int p) : cost(c), use(u), pos(p){}\n};\n\nvector<int> bfs(vector<vector<pair<int, bool>>>& G, int s, int t, int& shortestLen) {\n  vector<int> dist(G.size(), inf), d2cnt(G.size()+1);\n  dist[s] = 0;\n\n  queue<state> q;\n  q.emplace(0, 0, s);\n\n  while(!q.empty()) {\n    const state s = q.front(); q.pop();\n    d2cnt[s.cost]++;\n    for(auto& e: G[s.pos]) {\n      const int next = e.first;\n      if(dist[next] > s.cost + 1) {\n        dist[next] = s.cost + 1;\n        q.emplace(dist[next], 0, next);\n      }\n    }\n  }\n\n  shortestLen = dist[t];\n  return d2cnt;\n}\n\nint main() {\n\n  int N, M, s, t; cin >> N >> M >> s >> t; s--, t--;\n  vector<vector<pair<int, bool>>> G(N);\n  rep(i, M) {\n    int x, y; cin >> x >> y;\n    G[x-1].emplace_back(y-1, false);\n    G[y-1].emplace_back(x-1, false);\n  }\n\n  int shortestLen;\n  auto && d2cnt1 = bfs(G, s, t, shortestLen);\n  auto && d2cnt2 = bfs(G, t, s, shortestLen);\n\n  ll ans = 0;\n\n  rep(i, N) {\n    if(shortestLen-i-2 >= 0)\n      ans += (ll)d2cnt1[i] * d2cnt2[shortestLen-i-2];\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef pair<int,int> pp;\nset<int> G[105000];\n//set<pp> res;\nint dis[105000];\nint S[105000];\n\nint main(void) {\n    int n,m,s,t;\n    scanf(\"%d%d%d%d\",&n,&m,&s,&t);\n    s--, t--;\n    memset(dis, 0x20, sizeof(dis));\n    for(int i=0; i<m; i++) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        x--, y--;\n        G[x].insert(y);\n        G[y].insert(x);\n    }\n\n    {\n        priority_queue<pp> q;\n        q.push(pp(-0, s));\n\n        while(!q.empty()) {\n            pp t = q.top(); q.pop();\n            int d = -t.fst, x = t.snd;\n\n            if(dis[x] != 0x20202020) continue;\n            dis[x] = d;\n            S[d]++;\n\n            for(int y : G[x])\n                if(dis[y] == 0x20202020)\n                    q.push(pp(-(d+1), y));\n        }\n    }\n\n    int old = dis[t];\n    memset(dis, 0x20, sizeof(dis));\n\n    long long int res=0;\n    {\n        priority_queue<pp> q;\n        q.push(pp(-0, t));\n\n        while(!q.empty()) {\n            pp t = q.top(); q.pop();\n            int d = -t.fst, x = t.snd;\n\n            if(dis[x] != 0x20202020) continue;\n            dis[x] = d;\n\n            if(old-2-d >= 0)\n                res += S[old-2-d];\n\n            for(int y : G[x])\n                if(dis[y] == 0x20202020)\n                    q.push(pp(-(d+1), y));\n        }\n    }\n\n    printf(\"%lld\\n\", res);\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst int MAX_N = 100010;\nvector<pair<int, ll> > G[MAX_N];\nvector<ll> dijkstra(int start){\n\tvector<ll> dist(MAX_N, INFF);\n\tdist[start] = 0;//dist[i] :=???start->i?????§??????????????¢\n\tpriority_queue<pair<ll, int>, vector<pair<ll, int> >, greater<pair<ll, int> > >  que;\n\tque.push(make_pair(0, start));\n\twhile(!que.empty()){\n\t\tll cost; int u;//????????§???????????£????????? ?????¨?????????\n\t\tcost = que.top().first, u = que.top().second;\n\t\tque.pop();\n\t\tif(dist[u] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first; ll time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[v] > dist[u] + time){//u->v\n\t\t\t\tdist[v] = dist[u] + time;\n\t\t\t\tque.push(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nint N, M, s, t;\nint x[300010], y[300010];\nset<int> dists[100010], distg[100010];\n\nint main(void){\n\tscanf(\"%d %d %d %d\", &N, &M, &s, &t);\n\ts--, t--;\n\trep(i, M) scanf(\"%d %d\", &x[i], &y[i]);\n\trep(i, M) x[i]--, y[i]--;\n\trep(i, M) G[x[i]].pb(mp(y[i], 1)), G[y[i]].pb(mp(x[i], 1));\n\tauto start = dijkstra(s);\n\tauto goal  = dijkstra(t);\n\n\trep(i, N) if(start[i] != INFF) dists[start[i]].insert(i);\n\trep(i, N) if(goal[i]  != INFF) distg[goal[i]].insert(i);\n\tset<pair<int, int> > ans;\n\tint len = start[t];\n\t// printf(\"len %d\\n\", len);\n\trep(i, len - 1){\n\t\tint d1 = i;\n\t\tint d2 = (len - 2) - i;\n\t\t// printf(\"d1 %d d2 %d\\n\", d1, d2);\n\t\tfor(auto u : dists[d1]){ // s -> u ??? ?????¢ d1\n\t\t\t// u ??¨ v?????°????????°??????\n\t\t\tfor(auto v : distg[d2]){\n\t\t\t\t// printf(\"%d %d\\n\", u, v);\n\t\t\t\tif(u != v) ans.insert(mp(min(u, v), max(u, v)));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (int)ans.size());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nvector<int> G[100010];\nint d[100010],INF=99999999;\nint par[100010],rank[100010]={};\n\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else{\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y) return ;\n\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid dijkstra(int s){\nfill(d,d+100010,INF);\npriority_queue<P, vector<P>, greater<P> > que;\nd[s-1]=0;\nque.push(P(0,s-1));\n\nwhile(!que.empty()){\n  P p=que.top();\n  que.pop();\n  int v=p.second;\n  if(d[v]<p.first) continue;\n  for(int i=0;i<G[v].size();i++){\n    if(d[G[v][i]]>d[v]+1){\n      d[G[v][i]]=d[v]+1;\n      que.push(P(d[G[v][i]],G[v][i]));\n    }\n  }\n}\n}\n\nint main(){\n  int N,M,s,t,x,y;\n  cin>>N>>M>>s>>t;\n  init(N);\n\n  for(int i=0;i<M;i++){\n    cin>>x>>y;\n    G[x-1].push_back(y-1);\n    G[y-1].push_back(x-1);\n    unite(x-1,y-1);\n  }\n\n  dijkstra(s);\n  int jdg[N]={},ans=0;\n  for(int i=0;i<N;i++){\n    if(same(t-1,i)) jdg[d[i]]+=1;\n    }\n  for(int i=0;i<N;i++){\n  //  cout<<\"jdg[\"<<i<<\"]=\"<<jdg[i]<<endl;\n  }\n  int spath=d[t-1];\n\n  dijkstra(t);\n\n  int jdg2[N]={};\n  for(int i=0;i<N;i++){\n    if(same(t-1,i)) jdg2[d[i]]+=1;\n    }\n  for(int i=0;i<N;i++){\n  //  cout<<\"jdg2[\"<<i<<\"]=\"<<jdg2[i]<<endl;\n  }\n\n  for(int i=0;i<spath-1&&spath-2-i>=0;i++){\n    ans+=jdg[i]*jdg2[spath-2-i];\n  }\n/*\n  for(int i=0;i<spath-1;i++){\n      if(i+2<=spath){\n        ans+=jdg[i];\n        cout<<\"i+2=\"<<jdg[i]*jdg2[spath-i-1]<<endl;\n      }\n      if(spath<2*spath-2-i&&2*spath-2-i<N){\n        ans+=jdg[i]*jdg[2*spath-2-i];\n        cout<<\"spath*2=\"<<jdg[i]*jdg[2*spath-2-i]<<endl;\n      }\n  }\n  */\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, M, s, t;\nvector<int> G[100010];\nint ca[100010], cb[100010];\n\nvector<int> dijkstra(int s) {\n    vector<int> ret(N, INF);\n    ret[s] = 0;\n\n    // dist, point\n    priority_queue< pii, vector<pii>, greater<pii> > q;\n    q.push(pii(0, s));\n\n    while(!q.empty()) {\n        pii t = q.top(); q.pop();\n        int cost = t.first, cur = t.second;\n        for(int to : G[cur]) {\n            if(ret[to] > ret[cur] + 1) {\n                ret[to] = ret[cur] + 1;\n                q.push(pii(ret[to], to));\n            }\n        }\n    }\n\n    return ret;\n}\n\nsigned main() {\n    cin >> N >> M >> s >> t; s--; t--;\n    rep(i,0,M) {\n        int x, y; cin >> x >> y; x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n\n    vector<int> da = dijkstra(s), db = dijkstra(t);\n    rep(i,0,N) if(da[i] != INF) ca[ da[i] ]++;\n    rep(i,0,N) if(db[i] != INF) cb[ db[i] ]++;\n\n    \n    int dist = da[t], ans = 0;\n    repq(i,0,dist-2) {\n        int j = dist - 2 - i;\n        ans += ca[i] * cb[j];\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\n\nclass Edge{\n    public:\n        int to, cost;\n        Edge(int to, int cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n    public:\n        int dis;\n        bool isUsed;\n        Node(){\n            this->dis = INF;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\nvector<Node> node[2];\n\nvoid dijkstra(AdjList const g, int start, int n, int f, int t){\n    priority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    node[f] = vector<Node>(n);\n\n    q.push(make_pair(0, start));\n    node[f][start].dis = 0;\n\n    pair<int, int> u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second;\n        node[f][current].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            if(node[f][next].isUsed == 0){\n                if(node[f][next].dis > node[f][current].dis + g[current][i].cost){\n                    node[f][next].dis = node[f][current].dis + g[current][i].cost;\n                    q.push(make_pair(node[f][next].dis, next));\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--; t--;\n\n    AdjList g(n);\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        g[a].emplace_back(Edge{b,1});\n        g[b].emplace_back(Edge{a,1});\n    }\n    dijkstra(g,s,n,0,t);\n    dijkstra(g,t,n,1,t);\n\n    long long cnt[2][100005];\n    rep(i,n){\n        if(node[0][i].dis != INF) cnt[0][node[0][i].dis]++;\n        if(node[1][i].dis != INF) cnt[1][node[1][i].dis]++;\n    }\n    int dist = node[0][t].dis;\n\n    long long ans = 0;\n    rep(i,dist - 1) ans+=cnt[0][i] * cnt[1][dist - i - 2];\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint bfs1[100000];\nint bfs2[100000];\nint v1[100000];\nint v2[100000];\nint A[100000];\nint B[100000];\nvector<int> g[100000];\nint main(){\n\tint a,b,c,d;\n\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\tc--;d--;\n\tfor(int i=0;i<b;i++){\n\t\tint e,f;\n\t\tscanf(\"%d%d\",&e,&f);\n\t\te--;f--;\n\t\tg[e].push_back(f);\n\t\tg[f].push_back(e);\n\t}\n\tqueue<int> Q;\n\tQ.push(c);\n\tfor(int i=0;i<a;i++)bfs1[i]=bfs2[i]=-1;\n\tbfs1[c]=0;\n\twhile(Q.size()){\n\t\tint at=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\tif(!~bfs1[g[at][i]]){\n\t\t\t\tbfs1[g[at][i]]=bfs1[at]+1;\n\t\t\t\tQ.push(g[at][i]);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> P;\n\tP.push(d);\n\tbfs2[d]=0;\n\twhile(P.size()){\n\t\tint at=P.front();\n\t\tP.pop();\n\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\tif(!~bfs2[g[at][i]]){\n\t\t\t\tbfs2[g[at][i]]=bfs2[at]+1;\n\t\t\t\tP.push(g[at][i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tif(~bfs1[i]){\n\t\t\tA[bfs1[i]]++;\n\t\t}\n\t\tif(~bfs2[i]){\n\t\t\tB[bfs2[i]]++;\n\t\t}\n\t}\n\tint dis=bfs1[d];\n\tlong long ret=0LL;\n\tfor(int i=0;i<dis-1;i++){\n//\t\tprintf(\"%d %d\\n\",A[i],B[i]);\n\t\tret+=(long long)A[i]*B[dis-2-i];\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint N, M;\nint s, t;\nint x, y;\nvi G[111111];\nint ds[111111];\nint dt[111111];\nint ns[111111];\nint nt[111111];\n\nint main(int argc, char *argv[])\n{\n  cin >> N >> M;\n  cin >> s >> t;\n  s -= 1;\n  t -= 1;\n  rep(i, M){\n    cin >> x >> y;\n    G[x - 1].pb(y - 1);\n    G[y - 1].pb(x - 1);\n  }\n\n  rep(i, N) ds[i] = -1;\n  ds[s] = 0;\n  queue<int> ques;\n  ques.push(s);\n  while(!ques.empty()){\n    int v = ques.front();  ques.pop();\n    vrep(w, G[v]) if(ds[*w] < 0){\n      ds[*w] = ds[v] + 1;\n      ques.push(*w);\n    }\n  }\n\n  rep(i, N) dt[i] = -1;\n  dt[t] = 0;\n  queue<int> quet;\n  quet.push(t);\n  while(!quet.empty()){\n    int v = quet.front();  quet.pop();\n    vrep(w, G[v]) if(dt[*w] < 0){\n      dt[*w] = dt[v] + 1;\n      quet.push(*w);\n    }\n  }\n\n  int res = 0;\n  rep(i, N) ns[ds[i]] += 1;\n  rep(i, N) nt[dt[i]] += 1;\n  rep(i, ds[t] - 1) res += ns[i] * nt[ds[t] - i - 2];\n  cout << res << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\nvector<int> used1,used2;\nvector<int> dp1,dp2;\npriority_queue<pair<int,int>> pq1;\npriority_queue<pair<int,int>> pq2;\nvector<vector<int>> v;\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    v=vector<vector<int>>(n);\n    // set<pair<int,int>> se;\n    rep(i,m){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    used1=vector<int>(n+10,-1);\n    used2=vector<int>(n+10,-1);\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    dp1=vector<int>(n+10,0);\n    dp2=vector<int>(n+10,0);\n    rep(i,n){\n        if(0<=used1[i]&&used1[i]<=n) dp1[used1[i]]++;\n        if(0<=used2[i]&&used2[i]<=n) dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        // if(i==dist-2-i) ans+=dp1[i]*dp2[dist-2-i]/2;\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, s, t;\nvector<int> g[100000];\nint d1[100000], d2[100000];\nint c1[100010], c2[100010];\n\nvoid bfs(int dist[], int s)\n{\n\tqueue<int> q;\n\tfill_n(dist, 100000, -1);\n\tdist[s] = 0;\n\tq.push(s);\n\twhile (q.size()){\n\t\tint v = q.front(); q.pop();\n\t\tfor (int to : g[v]){\n\t\t\tif (dist[to] >= 0) continue;\n\t\t\tdist[to] = dist[v] + 1;\n\t\t\tq.push(to);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> n >> m >> s >> t, s--, t--;\n\tfor (int i = 0; i < m; i++){\n\t\tint x, y;\n\t\tcin >> x >> y, x--, y--;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tbfs(d1, s);\n\tbfs(d2, t);\n\n\tfor (int i = 0; i < n; i++){\n\t\tif (d1[i] >= 0) c1[d1[i]]++;\n\t\tif (d2[i] >= 0) c2[d2[i]]++;\n\t}\n\n\tlong long res = 0;\n\tfor (int i = 0; i < d1[t] - 1; i++){\n\t\tres += (long long)c1[i] * c2[d1[t] - 2 - i];\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\n\n#define MAX 100009\nusing namespace std;\ntypedef pair<int,int> P;\n\ntypedef struct Node\n{\n\tint n;\n\tvector<int>e;\n}Node;\n\nNode G[MAX];\nint N,M,s,t,d,a,b,res=0;\nmap<int,int>SC,GC;\nint dijcstra(int s,int g)\n{\n\tint C[MAX];\n\tmemset(C,0x7f,sizeof(C));\n\tP tmp(0,s);\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(tmp.second==g)\n\t\t\treturn tmp.first;\n\t\tif(tmp.first>=C[tmp.second])\n\t\t\tcontinue;\n\t\tC[tmp.second]=tmp.first;\n\t\tfor(int i=0;i<G[tmp.second].e.size();i++)\n\t\t{\n\t\t\tint nn=G[tmp.second].e[i];\n\t\t\tif(C[nn]>tmp.first+1)\n\t\t\t{\n\t\t\t\tQ.push(make_pair(tmp.first+1,nn));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&M,&s,&t);\n\ts--;t--;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--;y--;\n\t\tG[x].e.push_back(y);\n\t\tG[y].e.push_back(x);\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\ta=dijcstra(s,i);\n\t\tb=dijcstra(t,i);\n\t\tif(i==t)d=a;\n\t\tSC[a]++;\n\t\tGC[b]++;\n\t}\n\tfor(int i=0;i<=d;i++)\n\t{\n\t\tif(d-i-2>=0)\n\t\t\tres+=SC[i]*GC[d-i-2];\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n,m,s,t;\nvector<int> G[111111];\n\nint sd[111111],td[111111];\nbool vis[111111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n>>m>>s>>t;\n\ts--; t--;\n\trep(i,m){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tG[x].pb(y); G[y].pb(x);\n\t}\n\tint maxd;\n\tqueue<P> que;\n\tque.push(P(s,0));\n\tmemset(sd,0,sizeof(sd));\n\tvis[s]=true;\n\twhile(!que.empty()){\n\t\tint nv=que.front().fi,dist=que.front().se; que.pop();\n\t\tsd[dist]++;\n\t\tif(nv==t){\n\t\t\tmaxd=dist;\n\t\t}\n\t\trep(i,G[nv].size()){\n\t\t\tint next=G[nv][i];\n\t\t\tif(vis[next])continue;\n\t\t\tvis[next]=true;\n\t\t\tque.push(P(next,dist+1));\n\t\t}\n\t}\n\n\tqueue<P>().swap(que);\n\tmemset(td,0,sizeof(td));\n\tmemset(vis,0,sizeof(vis));\n\tque.push(P(t,0));\n\tvis[t]=true;\n\twhile(!que.empty()){\n\t\tint nv=que.front().fi,dist=que.front().se; que.pop();\n\t\ttd[dist]++;\n\t\trep(i,G[nv].size()){\n\t\t\tint next=G[nv][i];\n\t\t\tif(vis[next])continue;\n\t\t\tvis[next]=true;\n\t\t\tque.push(P(next,dist+1));\n\t\t}\n\t}\n\n\tll res=0;\n\trep(i,maxd-1){\n\t\tres+=(ll)sd[i]*td[maxd-i-2];\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 10000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_cost_sum){\n\t\tnode_id = arg_node_id;\n\t\tcost_sum = arg_cost_sum;\n\t}\n\tint node_id,cost_sum;\n};\n\nint main(){\n\n\tint N,M,start,goal;\n\tscanf(\"%d %d %d %d\",&N,&M,&start,&goal);\n\n\tll* from_start_Dist = new ll[N+1];\n\tll* from_goal_Dist = new ll[N+1];\n\tll *Dist_num_from_start = new ll[N+1];\n\tll *Dist_num_from_goal = new ll[N+1];\n\n\tvector<int> V[N+1]; //????????°???????????????:?????¢???1??¨??????\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfrom_start_Dist[i] = BIG_NUM;\n\t\tfrom_goal_Dist[i] = BIG_NUM;\n\t\tDist_num_from_start[i] = 0;\n\t\tDist_num_from_goal[i] = 0;\n\t}\n\n\tfrom_start_Dist[start] = 0;\n\tfrom_goal_Dist[goal] = 0;\n\tDist_num_from_start[0] = 0;\n\tDist_num_from_goal[0] = 0;\n\n\tint from,to;\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tV[from].push_back(to);\n\t\tV[to].push_back(from);\n\t}\n\n\tqueue<Info> Q;\n\n\t//?????????start???????????????????????§??????????????¢????¨????\n\tfor(int i = 0; i < V[start].size(); i++){\n\t\tfrom_start_Dist[V[start][i]] = 1;\n\t\tQ.push(Info(V[start][i],1));\n\t}\n\n\tint min_index;\n\n\twhile(!Q.empty()){\n\t\tif(Q.front().cost_sum > from_start_Dist[Q.front().node_id]){ //???????????????????????¶?????????????????£??????SKIP\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tmin_index = Q.front().node_id;\n\t\t\tQ.pop();\n\t\t}\n\n\t\tfor(int i = 0; i < V[min_index].size();i++){\n\t\t\tif(from_start_Dist[V[min_index][i]] > from_start_Dist[min_index] + 1){\n\t\t\t\tfrom_start_Dist[V[min_index][i]] =from_start_Dist[min_index] + 1;\n\t\t\t\tQ.push(Info(V[min_index][i],from_start_Dist[V[min_index][i]]));\n\t\t\t}\n\t\t}\n\t}\n\n\t//?????¢?????¨????????°????¨????\n\tfor(int i = 1; i <= N; i++){\n\t\tif(from_start_Dist[i] != BIG_NUM){\n\t\t\tDist_num_from_start[from_start_Dist[i]]++;\n\t\t}\n\t}\n\tint length = from_start_Dist[goal];\n\n\n\t//?¬????goal???????????????????????§??????????????¢????¨????\n\tfor(int i = 0; i < V[goal].size(); i++){\n\t\tfrom_goal_Dist[V[goal][i]] = 1;\n\t\tQ.push(Info(V[goal][i],1));\n\t}\n\n\twhile(!Q.empty()){\n\t\tif(Q.front().cost_sum > from_goal_Dist[Q.front().node_id]){ //???????????????????????¶?????????????????£??????SKIP\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tmin_index = Q.front().node_id;\n\t\t\tQ.pop();\n\t\t}\n\n\t\tfor(int i = 0; i < V[min_index].size();i++){\n\t\t\tif(from_goal_Dist[V[min_index][i]] > from_goal_Dist[min_index] + 1){\n\t\t\t\tfrom_goal_Dist[V[min_index][i]] =from_goal_Dist[min_index] + 1;\n\t\t\t\tQ.push(Info(V[min_index][i],from_goal_Dist[V[min_index][i]]));\n\t\t\t}\n\t\t}\n\t}\n\n\t//?????¢?????¨????????°????¨????\n\tfor(int i = 1; i <= N; i++){\n\t\tif(from_goal_Dist[i] != BIG_NUM){\n\t\t\tDist_num_from_goal[from_goal_Dist[i]]++;\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 0; i <= length-2; i++){\n\t\tans += Dist_num_from_start[i]*Dist_num_from_goal[(length-2)-i];\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\nvector<int> used1,used2;\nvector<int> dp1,dp2;\npriority_queue<pair<int,int>> pq1;\npriority_queue<pair<int,int>> pq2;\nvector<vector<int>> v;\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    v=vector<vector<int>>(n);\n    // set<pair<int,int>> se;\n    rep(i,m){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    used1=vector<int>(n+10,-1);\n    used2=vector<int>(n+10,-1);\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    long long ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    dp1=vector<int>(n+10,0);\n    dp2=vector<int>(n+10,0);\n    rep(i,n){\n        if(0<=used1[i]&&used1[i]<=n) dp1[used1[i]]++;\n        if(0<=used2[i]&&used2[i]<=n) dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        // if(i==dist-2-i) ans+=dp1[i]*dp2[dist-2-i]/2;\n        ans+=(long long)dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* monkukui 競技プログラミング用のテンプレート  (ここから) */\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nusing ll = long long int;\nusing lnt = long long int;\nusing Graph = vector<vector<int>>;\nusing Wgraph = vector<vector<pair<int, long long int>>>;\nconstexpr long long int INF = 1001001001001001LL;\nconstexpr long long int MOD = 1000000007LL;\nconstexpr double PI = 3.1415926535897932;\nconstexpr long long int di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nconstexpr long long int dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ninline void yes(){ cout << \"yes\" << endl; }\ninline void Yes(){ cout << \"Yes\" << endl; }\ninline void YES(){ cout << \"YES\" << endl; }\ninline void no(){ cout << \"no\" << endl; }\ninline void No(){ cout << \"No\" << endl; }\ninline void NO(){ cout << \"NO\" << endl; }\ninline void possible(){ cout << \"possible\" << endl; }\ninline void Possible(){ cout << \"Possible\" << endl; }\ninline void POSSIBLE(){ cout << \"POSSIBLE\" << endl; }\ninline void impossible(){ cout << \"impossible\" << endl; }\ninline void Impossible(){ cout << \"Impossible\" << endl; }\ninline void IMPOSSIBLE(){ cout << \"IMPOSSIBLE\" << endl; }\n\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define RREP(i,n) for(int i = 1; i <= (n); i++)\n#define DREP(i,n) for(int i = (n)-1; i >= 0; i--)\n#define SREP(i,s,t) for(int i = s; i < t; i++)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define PB push_back\n\n/* monkukui 競技プログラミング用のテンプレート (ここまで)*/\n\n// verified : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_A\n// 負辺があると動作しない?\n// O(E log V)\ntemplate<typename T>\nvector<T> dijkstra(vector<vector<pair<int, T>>> &g, int s){\n     \n    int n = g.size();\n    // numeric_limits がうまく使えない場合は自分で INF を定義する.\n    const auto inf = numeric_limits<T>::max();\n    vector<T> dist(n, inf);\n \n    using P = pair<T, int>;\n    // 小さい順に取り出せる\n    priority_queue<P, vector<P>, greater<P>> que;\n    dist[s] = 0;\n    que.emplace(dist[s], s);\n    while(!que.empty()){\n        T cost;\n        int node;\n        tie(cost, node) = que.top();\n        que.pop();\n        if(dist[node] < cost) continue;\n        for(auto &e : g[node]){\n            auto next_cost = cost + e.second;\n            int next_node = e.first;\n            if(dist[next_node] <= next_cost) continue;\n            dist[next_node] = next_cost;\n            que.emplace(next_cost, next_node);\n        }\n    }\n \n    return dist;\n}\n\nint main(){\n  \n  lnt n, m, s, t; cin >> n >> m >> s >> t;\n  s--;\n  t--;\n  vector<vector<pair<int, lnt>>> g(n);\n  for(int i = 0; i < m; i++) {\n    lnt x, y; cin >> x >> y;\n    x--;\n    y--;\n    g[x].push_back({y, 1});\n    g[y].push_back({x, 1});\n  }\n\n  auto distFromS = dijkstra(g, s);\n  auto distFromT = dijkstra(g, t);\n  map<lnt, lnt> mpFromS;\n  map<lnt, lnt> mpFromT;\n  for(int i = 0; i < n; i++) mpFromS[distFromS[i]]++;\n  for(int i = 0; i < n; i++) mpFromT[distFromT[i]]++;\n  \n  lnt ans = 0;\n  lnt dist = distFromS[t];\n  for(lnt x = 0; x < dist - 1; x++) {\n    lnt y = dist - x - 2;\n    ans += mpFromS[x] * mpFromT[y];\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tll cost;\n\t};\n\n\tint prev[100010];\n\tll d[100010];\n\tint N;\n\tvector<edge> G[100010];//各頂点からの辺\n\n\tvoid dijkstra(int start) {\n\t\tfill(d, d + 100010, INF);\n\t\td[start] = 0;\n\t\tfill(prev, prev + 100010, -1);\n\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, start));\n\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second;\n\t\t\tif (d[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge e = G[v][i];\n\t\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\t\tprev[e.to] = v;\n\t\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> get_path(int goal) {\n\t\tvector<int> path;\n\t\tfor (int t = goal; t != -1; t = prev[t]) {\n\t\t\tpath.push_back(t);\n\t\t}//このままでは逆順なのでひっくり返す\n\t\treverse(ALL(path));\n\t\treturn path;\n\t}\n};\n\nint n, m, s, t;\nDK dk;\nll cnt[2][200100] = {};\nll ans;\n\nint main() {\n\tcin >> n >> m >> s >> t;\n\ts--;\n\tt--;\n\trep(i, m) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tdk.G[x].push_back({ y,1 });\n\t\tdk.G[y].push_back({ x,1 });\n\t}\n\tdk.dijkstra(s);\n\trep(i, n) {\n\t\tif (dk.d[i] != INF)cnt[0][dk.d[i]]++;\n\t}\n\tdk.dijkstra(t);\n\trep(i, n) {\n\t\tif (dk.d[i] != INF)cnt[1][dk.d[i]]++;\n\t}\n\tint now = 0;\n\trep(i, dk.d[s] - 1) {\n\t\t//cout << cnt[0][i] << \" \" << cnt[1][dk.d[s] - 2 - i] << endl;\n\t\tans += cnt[0][i] * cnt[1][dk.d[s] - 2 - i];\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint inf=1e8;\nint cs[100000],ct[100000];\nvector<int> G[100000];\nint ds[100000],dt[100000];\nint N;\nvoid bfs(int s,int* d){\n\tqueue<int> que;\n\tque.push(s);\n\trep(i,N) d[i]=inf;\n\td[s]=0;\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int u:G[v]){\n\t\t\tif(d[u]==inf){\n\t\t\t\tque.push(u);\n\t\t\t\td[u]=d[v]+1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint M,s,t;\n\tcin>>N>>M>>s>>t;\n\ts--,t--;\n\trep(i,M){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tG[x].pb(y),G[y].pb(x);\n\t}\n\tbfs(s,ds);\n\tbfs(t,dt);\n\tint D=ds[t];\n\trep(i,N) if(ds[i]!=inf) cs[ds[i]]++;\n\trep(i,N) if(dt[i]!=inf) ct[dt[i]]++;\n\tlong long ans=0;\n\trep(i,D-1) ans+=(long long)cs[i]*ct[D-2-i];\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n \ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\n\nsigned main(){\n    int n,m,s,t;cin>>n>>m>>s>>t;s--,t--;\n    vector<vector<int>> g(n);\n    rep(i,m){\n        int u,v;cin>>u>>v;u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    vector<int> d(n,INF),rd(n,INF);\n    {\n        queue<int> que;\n        que.push(s);d[s]=0;\n        while(!que.empty()){\n            int u=que.front();que.pop();\n            for(auto to:g[u])if(chmin(d[to],d[u]+1))que.push(to);\n        }\n    }\n    {\n        queue<int> que;\n        que.push(t);rd[t]=0;\n        while(!que.empty()){\n            int u=que.front();que.pop();\n            for(auto to:g[u])if(chmin(rd[to],rd[u]+1))que.push(to);\n        }\n    }\n\n    vector<ll> cnt(n,0);\n    rep(i,n)if(rd[i]<n)cnt[rd[i]]++;\n    ll res=0;\n    rep(i,n){\n        int op=d[t]-1-1-d[i];\n        if(0<=op and op<n)res+=cnt[op];\n    }\n    cout<<res<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<bool> isReached(N, false), is(N,false);\n    vector<ll> count(N,0),c(N,0);\n    vector< vector<int> > graph(N);\n    queue<int> que;\n    vector<int> dist(N),d(N);\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    int x, y;\n    for(int i=0 ; i<M ; i++){\n        cin >> x >> y;\n        x--; y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n    int now;\n    que.push(s);\n    count[0] = 1;\n    isReached[s] = true;\n    dist[s] = 0;\n    while(!que.empty()){\n        now = que.front();\n        que.pop();\n        for(int i=0; i<graph[now].size() ; i++){\n            if(!isReached[graph[now][i]]){\n                que.push(graph[now][i]);\n                isReached[graph[now][i]] = true;\n                dist[graph[now][i]] = dist[now]+1;\n                count[dist[graph[now][i]]]++;\n            }\n        }\n    }\n    que.push(t);\n    c[0] = 1;\n    is[t] = true;\n    d[t]=0;\n    while(!que.empty()){\n        now = que.front();\n        que.pop();\n        for(int i=0; i<graph[now].size() ; i++){\n            if(!is[graph[now][i]]){\n                que.push(graph[now][i]);\n                is[graph[now][i]] = true;\n                d[graph[now][i]] = d[now]+1;\n                c[d[graph[now][i]]]++;\n            }\n        }\n    }\n    ll ans=0;\n    for(int i=0; i<= dist[t]-2 ; i++){\n        ans+= count[i]*c[dist[t]-2-i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n, m, start, goal;\n\tcin>> n>> m>> start>> goal;\n\tstart--;\n\tgoal--;\n\tvvi root(n);\n\tREP(i,m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\troot[a].push_back(b);\n\t\troot[b].push_back(a);\n\t}\n\n\tvi start_dis(n,1e9);\n\tvi sdn(100001,0);\n\tstart_dis[start] = 0;\n\tsdn[0]++;\n\tqueue<int> Q;\n\tQ.push(start);\n\twhile (!Q.empty()) {\n\t\tint q = Q.front();Q.pop();\n\t\tREP(i, root[q].size()) {\n\t\t\tif (start_dis[root[q][i]] > start_dis[q] + 1) {\n\t\t\t\tstart_dis[root[q][i]] = start_dis[q] + 1;\n\t\t\t\tQ.push(root[q][i]);\n\t\t\t\tsdn[start_dis[q] + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tvi goal_dis(n, 1e9);\n\tvi gdn(100001,0);\n\tgoal_dis[goal] = 0;\n\tgdn[0]++;\n\tQ.push(goal);\n\twhile (!Q.empty()) {\n\t\tint q = Q.front();Q.pop();\n\t\tREP(i, root[q].size()) {\n\t\t\tif (goal_dis[root[q][i]] > goal_dis[q] + 1) {\n\t\t\t\tgoal_dis[root[q][i]] = goal_dis[q] + 1;\n\t\t\t\tQ.push(root[q][i]);\n\t\t\t\tgdn[goal_dis[q] + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tint dis = start_dis[goal];\n\tint ercnt = 0;\n\tREP(i, n)\n\t\tif (start_dis[i] + goal_dis[i]+1 == dis-1)\n\t\t\tercnt++;\n\tint ans = 0;\n\tREP(i, dis-1) {\n\t\tans += sdn[i] * gdn[dis - i-2];\n\t}\n\tcout << ans - ercnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nbool vis[100000];\nint main(){\n  int n,m,s,t,x,y;\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  vector<int> v[100000];\n  set<pair<int,int> >ss;\n  r(i,m){\n    cin>>x>>y;\n    x--;y--;\n    ss.insert(mk(x,y));\n    ss.insert(mk(y,x));\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int s1[n],t1[n];\n  memset(s1,1e6,sizeof(s1));\n  memset(t1,1e6,sizeof(t1));\n  queue<pair<int,int> >q;\n  q.push(mk(s,0));\n  vis[s]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    s1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  memset(vis,0,sizeof(vis));\n  q.push(mk(t,0));\n  vis[t]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    t1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  int po=s1[t],cc=0;\n  vector<int> d[100000];\n  r(i,n)if(s1[i]<n)d[s1[i]].push_back(i);\n  r(i,n)if(t1[i]<n){\n    int tt=po-t1[i]-2;\n    if(tt>-1)cc+=d[tt].size();\n  }\n  cout<<cc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nint n[100000], m[100000];\nvector<int>rinsetu[100000];\nsigned main() {\n\tunordered_map<int, int>X, Y;\n\tint a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d); c--; d--;\n\tfor (int e = 0; e < b; e++) {\n\t\tint f, g; scanf(\"%d%d\", &f, &g);\n\t\tf--; g--;\n\t\trinsetu[f].push_back(g);\n\t\trinsetu[g].push_back(f);\n\t}\n\tmemset(n, -1, sizeof(n));\n\tmemset(m, -1, sizeof(m));\n\tn[c] = 0; m[d] = 0;\n\tqueue<int>Q;\n\tQ.push(c);\n\twhile (Q.size()) {\n\t\tint e = Q.front(); Q.pop();\n\t\tX[n[e]]++;\n\t\tfor (int f : rinsetu[e]) {\n\t\t\tif (n[f] == -1) {\n\t\t\t\tn[f] = n[e] + 1;\n\t\t\t\tQ.push(f);\n\t\t\t}\n\t\t}\n\t}\n\tQ.push(d);\n\twhile (Q.size()) {\n\t\tint e = Q.front(); Q.pop();\n\t\tY[m[e]]++;\n\t\tfor (int f : rinsetu[e]) {\n\t\t\tif (m[f] == -1) {\n\t\t\t\tm[f] = m[e] + 1;\n\t\t\t\tQ.push(f);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < a; i++) {\n\t\tans += X[n[d] - m[i] - 2];\n\t\tans += Y[m[c] - n[i] - 2];\n\t}\n\tprintf(\"%lld\\n\", ans / 2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <map>\n#define INF 1000000000\nusing namespace std;\nstruct po{int node,flg;};\nint n,m,s,g;\nvector <int> G[100001];\nmap <int,int> mp[2];\n\nint bfs(){\n  int D[2][100001]={};\n  queue <po> Q;\n  mp[0].clear(),mp[1].clear();\n  mp[0][0]++,mp[1][0]++;\n  Q.push(po{s,0}),Q.push(po{g,1});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    for(int i=0;i<G[t.node].size();i++) {\n      if(D[t.flg][G[t.node][i]]!=0)continue;\n      Q.push(po{G[t.node][i],t.flg});\n      D[t.flg][G[t.node][i]] = D[t.flg][t.node]+1;\n      mp[t.flg][D[t.flg][t.node]+1]++;\n    }\n  }\n  mp[0][D[0][s]]--,mp[1][D[1][g]]--;\n  int DG = D[0][g];\n  int sum=0;\n  map<int,int>::iterator it=mp[0].begin();\n  while(it!=mp[0].end()){\n    if(mp[1].count(DG-2-it->first))sum += it->second * mp[1][DG - it->first-2];\n    it++;\n  }\n  return sum;\n}\n\nint main() {\n  cin >> n >> m >> s >>g;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  cout << bfs() <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define allof(a) (a).begin(),(a).end()\n\nstruct State { int v, step; };\n\nint N, M, term[2], dst[2][100010];\nvector< vector< int > > adj;\nvector< int > sdl[2][100010];\n\nint bfs() {\n\tfor_(i,0,2) {\n\t\tqueue< State > que;\n\t\tque.push(State{term[i], 0});\n\t\t\n\t\tvector< bool > vis(N + 1, false);\n\t\tvis[term[i]] = true;\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tState s = que.front(); que.pop();\n\t\t\tdst[i][s.v] = s.step;\n\t\t\tsdl[i][s.step].push_back(s.v);\n\t\t\t\n\t\t\tfor (int v : adj[s.v]) {\n\t\t\t\tif (vis[v]) continue;\n\t\t\t\tvis[v] = true;\n\t\t\t\tque.push(State{v, s.step + 1});\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dst[0][term[1]];\n}\n\nvoid solve() {\n\tint min_dst = bfs();\n\t\n\tint ans = 0;\n\t\n\tfor_(step,0,N) ans += sdl[0][step].size() * sdl[1][min_dst - step - 2].size();\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> N >> M >> term[0] >> term[1];\n\t\n\tadj.assign(N+1, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\ntypedef pair<int, int> State;\nint n;\nvvi edge;\n\nvoid bfs(int s, vi& dist){\n    dist = vi(n, inf);\n    vi used(n);\n\n    queue<State> q;\n    q.push(mp(0, s));\n\n    while(!q.empty()){\n        int cur_cost = q.front().F;\n        int cur_v = q.front().S;\n        q.pop();\n\n        dist[cur_v] = cur_cost;\n        used[cur_v] = true;\n\n        for(int u : edge[cur_v]){\n            if(used[u]) continue;\n\n            q.push(mp(cur_cost + 1, u));\n        }\n    }\n}\n\nint main(void){\n    ll res;\n    for(int m, s, t; cin >> n >> m >> s >> t; cout << res << endl){\n        res = 0;\n\n        s--, t--;\n        edge = vvi(n);\n\n        rep(i, m){\n            int x, y; cin >> x >> y;\n            x--, y--;\n            \n            edge[x].pb(y), edge[y].pb(x);\n        }\n\n        vi dist_fromS, dist_fromT;\n        bfs(s, dist_fromS);\n        bfs(t, dist_fromT);\n\n        map<int, int> distCnt_fromS, distCnt_fromT;\n        rep(u, n){\n            distCnt_fromS[dist_fromS[u]]++;\n            distCnt_fromT[dist_fromT[u]]++;\n        }\n\n        int path_len = dist_fromS[t];\n\n        rep(i, path_len + 5){\n            res += distCnt_fromS[i] * distCnt_fromT[path_len - i - 2];\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nint32_t main() {\n    int n,m,s,t; cin >> n >> m >> s >> t; --s,--t;\n    vector<vector<int>> g(n);\n    rep (i,m) {\n        int x,y; cin >> x >> y; --x,--y;\n        g[x].eb(y);\n        g[y].eb(x);\n    }\n\n    auto bfs = [&](int s) {\n        vector<int> d(n,INF);\n        d[s] = 0;\n        queue<int> q;\n        q.push(s);\n        while (q.size()) {\n            int x = q.front(); q.pop();\n            for (int y : g[x]) {\n                if (chmin(d[y], d[x]+1)) {\n                    q.push(y);\n                }\n            }\n        }\n        return d;\n    };\n    auto ds = bfs(s);\n    auto dt = bfs(t);\n    dump(ds);\n    dump(dt);\n\n    int dist = ds[t];\n    if (dist == 1) quit(0);\n    assert(2 <= dist && dist < INF);\n\n    vector<int> a(dist+1),b(dist+1);\n    rep (i,n) if (ds[i] <= dist) a[ds[i]]++;\n    rep (i,n) if (dt[i] <= dist) b[dt[i]]++;\n    dump(dist);\n    dump(a);\n    dump(b);\n\n    int ans = 0;\n    rep (i,dist-1) {\n        int j = dist-2-i;\n        ans += a[i]*b[j];\n    }\n    cout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, M, s, t;\nVVI es;\n\nVI bfs(int p0) {\n\tVI d(N, INF);\n\td[p0] = 0;\n\n\tqueue<int> q;\n\tq.push(p0);\n\n\twhile (q.size()) {\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tint next_cost = d[p] + 1;\n\t\t\n\t\tfor (auto next : es[p]) {\n\t\t\tint &dist = d[next];\n\t\t\tif (next_cost < dist) {\n\t\t\t\tdist = next_cost;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d;\n}\n\nint main(void) {\n\tcin >> N >> M >> s >> t;\n\t--t; --s;\n\tes.resize(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tes[a].PB(b);\n\t\tes[b].PB(a);\n\t}\n\n\t// s, t????????????????????¢?±???????\n\tVI sd = bfs(s);\n\tVI td = bfs(t);\n\tint st = sd[t];\n\n\t// ?????¢->?????°?????????\n\tVI d2c_t(100010);\n\tfor (auto d : td) {\n\t\tif (d == INF) continue;\n\t\td2c_t[d]++;\n\t}\n\n\t// count\n\tint cnt = 0;\n\tfor (auto d : sd) {\n\t\tif (d == INF) continue;\n\t\tint idx = st - d - 2;\n\t\tif (idx >= 0) {\n\t\t\tcnt += d2c_t[idx];\n\t\t}\n\t}\n\n\tcout << cnt << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> edges[123456];\n\nint N,M,s,t;\n\nvector<int> dijkstra(int s){\n  vector<int> d(N,1e9);\n  queue<pair<int,int> > que;\n  que.push({s,0});\n  while(!que.empty()){\n    auto c=que.front();\n    que.pop();\n    if(d[c.first]<=c.second)continue;\n    d[c.first]=c.second;\n    for(auto e:edges[c.first]){\n      que.push({e,c.second+1});\n    }\n  }\n  return d;\n}\n\nint main(){\n  cin>>N>>M>>s>>t;\n  s--;\n  t--;\n  while(M--){\n    int x,y;\n    cin>>x>>y;\n    x--;\n    y--;\n    edges[x].push_back(y);\n    edges[y].push_back(x);\n  }\n  auto sto=dijkstra(s);\n  auto tto=dijkstra(t);\n  int sp=sto[t];\n  sort(begin(sto),end(sto));\n  long long ans=0;\n  for(auto e:tto){\n    ans+=upper_bound(begin(sto),end(sto),sp-2-e)-lower_bound(begin(sto),end(sto),sp-2-e);\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    vector<vector<int>> v(n);\n    // set<pair<int,int>> se;\n    rep(i,n){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    vector<int> used1(n,-1),used2(n,-1);\n    priority_queue<pair<int,int>> pq1;\n    priority_queue<pair<int,int>> pq2;\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    vector<int> dp1(n+10,0),dp2(n+10,0);\n    rep(i,n){\n        if(0<=used1[i]&&used1[i]<=n) dp1[used1[i]]++;\n        if(0<=used2[i]&&used2[i]<=n) dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    vector<vector<int>> v(n);\n    // set<pair<int,int>> se;\n    rep(i,n){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    vector<int> used1(n+10,-1),used2(n+10,-1);\n    priority_queue<pair<int,int>> pq1;\n    priority_queue<pair<int,int>> pq2;\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    vector<int> dp1(n+10,0),dp2(n+10,0);\n    rep(i,n){\n        if(0<=used1[i]&&used1[i]<=n) dp1[used1[i]]++;\n        if(0<=used2[i]&&used2[i]<=n) dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\nstruct Edge { int from; int to; long long weight; };\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\ntypedef std::pair<long long, int> P;\n\nstd::vector<long long> dijkstra(const Graph& g, int src) {\n\tstd::vector<long long> d(g.size(), std::numeric_limits<long long>::max());\n\td[src] = 0;\n\t//vector<int> prev(g.size());\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>> q;\n\tq.push({ 0, src });\n\twhile (!q.empty()) {\n\t\tauto p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (p.first > d[v]) continue;\n\t\tfor (int i = 0; i < (int)g[v].size(); ++i) {\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.weight) {\n\t\t\t\td[e.to] = d[v] + e.weight;\n\t\t\t\tq.push({ d[e.to],e.to });\n\t\t\t\t//prev[e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, s, t;\n\tcin >> n >> m >> s >> t;\n\ts--; t--;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].push_back({ a,b,1 });\n\t\tg[b].push_back({ b,a,1 });\n\t}\n\tauto a = dijkstra(g, s), b = dijkstra(g, t);\n\tll d = a[t];\n\tvl cnta(n), cntb(n);\n\tREP(i, n) {\n\t\tif (a[i] == numeric_limits<ll>::max())continue;\n\t\tcnta[a[i]]++;\n\t\tcntb[b[i]]++;\n\t}\n\tll ans = 0;\n\tREP(i, d - 1) {\n\t\tans += cnta[i] * cntb[d - i - 2];\n\t}\n\tcout << ans << endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define make make_pair\n#define N 100002\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\nvoid bfs(int,int);\nint n,m,s,t,a,b,cost[2][N],mincost,ans;\nvector<int> c[N];\nint C[N];\n\nint main(){\n  cin>>n>>m>>s>>t;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    c[a].push_back(b);\n    c[b].push_back(a);\n  }\n  bfs(0,s);\n  bfs(1,t);\n  for(int i=0;i<=mincost-2;i++) ans+=cost[0][i]*cost[1][mincost-2-i];\n  if(mincost-2<0) cout<<0<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}\n\nvoid bfs(int index,int start){\n  queue<P> q;\n  for(int i=1;i<=n;i++) C[i]=INF;\n  q.push(make(0,start));\n  C[start]=0;\n  while(!q.empty()){\n    P k=q.front(); q.pop();\n    int cos=k.first,u=k.second;\n    for(int i=0;i<(int)c[u].size();i++){\n      int nu=c[u][i];\n      if(C[nu]>cos+1){\n\tC[nu]=cos+1;\n\tq.push(make(C[nu],nu));\n      }\n    }\n  }\n  if(!index) mincost=C[t];\n  for(int i=1;i<=n;i++){\n    if(C[i]==INF) continue;\n    cost[index][C[i]]++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint N, M;\nint s, t;\nint x, y;\nvi G[111111];\nint ds[111111];\nint dt[111111];\nll ns[111111];\nll nt[111111];\n\nint main(int argc, char *argv[])\n{\n  cin >> N >> M;\n  cin >> s >> t;\n  s -= 1;\n  t -= 1;\n  rep(i, M){\n    cin >> x >> y;\n    G[x - 1].pb(y - 1);\n    G[y - 1].pb(x - 1);\n  }\n\n  rep(i, N) ds[i] = -1;\n  ds[s] = 0;\n  queue<int> ques;\n  ques.push(s);\n  while(!ques.empty()){\n    int v = ques.front();  ques.pop();\n    vrep(w, G[v]) if(ds[*w] < 0){\n      ds[*w] = ds[v] + 1;\n      ques.push(*w);\n    }\n  }\n\n  rep(i, N) dt[i] = -1;\n  dt[t] = 0;\n  queue<int> quet;\n  quet.push(t);\n  while(!quet.empty()){\n    int v = quet.front();  quet.pop();\n    vrep(w, G[v]) if(dt[*w] < 0){\n      dt[*w] = dt[v] + 1;\n      quet.push(*w);\n    }\n  }\n\n  ll res = 0LL;\n  rep(i, N) ns[ds[i]] += 1;\n  rep(i, N) nt[dt[i]] += 1;\n  rep(i, ds[t] - 1) res += ns[i] * nt[ds[t] - i - 2];\n  cout << res << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct edge{int to, cost;};\n\nint n, d[100010];\nvector<edge> g[100010];\n\nvoid dijkstra(int s) {\n  priority_queue<PII, vector<PII>, greater<PII>> que;\n  fill(d, d+n, INF);\n  d[s] = 0;\n  que.push(PII{0, s});\n\n  while(que.size()) {\n    PII p = que.top(); que.pop();\n    // cout << p.first << \",\" << p.second << endl;\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(edge e: g[v]) {\n      // cout << d[e.to] << \":\" << d[v] << \":\" << e.cost << endl;\n      if(d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        que.push(PII{d[e.to], e.to});\n      }\n    }\n  }\n}\n\nint cnt1[300010], cnt2[300010];\nsigned main(void)\n{\n  int m, s, t;\n  cin >> n >> m >> s >> t;\n  s--, t--;\n  REP(i, m) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    g[x].PB({y, 1});\n    g[y].PB({x, 1});\n  }\n\n  dijkstra(s);\n  // REP(i, n) cout << d[i] << \" \"; cout << endl;\n  int dist = d[t]-1;\n  REP(i, n) if(d[i] != INF) cnt1[d[i]]++;\n  dijkstra(t);\n  REP(i, n) if(d[i] != INF) cnt2[d[i]]++;\n\n  // cout << dist << endl;\n  ll ret = 0;\n  REP(i, dist) {\n    // cout << i << \",\" << cnt1[i] << \" \" << dist-i-1 << \",\" << cnt2[dist-i-1] << endl;\n    ret += cnt1[i] * cnt2[dist-i-1];\n  }\n  cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 100010;\nVI e[N];\nll d1[N], d2[N], p1[N], p2[N];\n\nvoid bfs(int s, ll d[], ll p[]){\n    REP(i,N) d[i] = -1;\n    d[s] = 0;\n    queue<int> que;\n    que.push(s);\n    while (!que.empty()){\n        int now = que.front();\n        que.pop();\n        p[d[now]]++;\n        REP(i,e[now].size()){\n            int next = e[now][i];\n            if (d[next] >= 0) continue;\n            d[next] = d[now] + 1;\n            que.push(next);\n        }\n    }\n}\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--;\n    t--;\n    REP(i,m){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--;\n        y--;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    bfs(s,d1,p1);\n    bfs(t,d2,p2);\n    int x = d1[t];\n\n    ll ans = 0;\n    REP(i,x-1){\n        ans += p1[i] * p2[x-2-i];\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    vector<vector<int>> v(n);\n    // set<pair<int,int>> se;\n    rep(i,n){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    vector<int> used1(n,-1),used2(n,-1);\n    priority_queue<pair<int,int>> pq1;\n    priority_queue<pair<int,int>> pq2;\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    if(n>=100){\n        return 0;\n    }\n    vector<int> dp1(n+10,0),dp2(n+10,0);\n    rep(i,n){\n        dp1[used1[i]]++;\n        dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\n\n#define MAX 100009\nusing namespace std;\ntypedef pair<int,int> P;\n\ntypedef struct Node\n{\n\tint n;\n\tvector<int>e;\n}Node;\n\nNode G[MAX];\nint N,M,s,t,d,a,b;\nlong long res=0;\nmap<int,long long>SC,GC;\nvoid dijcstra(int s,int g,map<int,long long>&X)\n{\n\tint C[MAX];\n\tmemset(C,0x7f,sizeof(C));\n\tP tmp(0,s);\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(tmp.first>=C[tmp.second])\n\t\t\tcontinue;\n\t\tC[tmp.second]=tmp.first;\n\t\tfor(int i=0;i<G[tmp.second].e.size();i++)\n\t\t{\n\t\t\tint nn=G[tmp.second].e[i];\n\t\t\tif(C[nn]>tmp.first+1)\n\t\t\t{\n\t\t\t\tQ.push(make_pair(tmp.first+1,nn));\n\t\t\t}\n\t\t}\n\t}\n\tif(g==t)d=C[t];\n\tfor(int i=0;i<N;i++)\n\t\tX[C[i]]++;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&M,&s,&t);\n\ts--;t--;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--;y--;\n\t\tG[x].e.push_back(y);\n\t\tG[y].e.push_back(x);\n\t}\n\tdijcstra(s,t,SC);\n\tdijcstra(t,s,GC);\n\tfor(int i=0;i<=d;i++)\n\t{\n\t\tif(d-i-2>=0)\n\t\t\tres+=SC[i]*GC[d-i-2];\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#define mk make_pair\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nbool vis[100000];\nint main(){\n  int n,m,s,t,x,y;\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  vector<int> v[100000];\n  set<pair<int,int> >ss;\n  r(i,m){\n    cin>>x>>y;\n    x--;y--;\n    ss.insert(mk(x,y));\n    ss.insert(mk(y,x));\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int s1[n],t1[n];\n  queue<pair<int,int> >q;\n  q.push(mk(s,0));\n  vis[s]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    s1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n\tvis[v[pp][i]]=1;\n\tq.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  memset(vis,0,sizeof(vis));\n  q.push(mk(t,0));\n  vis[t]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    t1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n\tvis[v[pp][i]]=1;\n\tq.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  int po=s1[t],cc=0;\n  vector<int> d[100000];\n  r(i,n)d[s1[i]].push_back(i);\n  r(i,n){\n    int tt=po-t1[i]-1;\n    if(t==i){\n      if(po==2&&!ss.count(mk(t,s)))cc++;\n    }\n    else if(tt>-1)r(j,d[tt].size())\n      if(!ss.count(mk(d[tt][j],i))){\n\tcc++;\n      }\n  }\n  cout<<cc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define all(v) v.begin(),v.end()\n#define int long long\nusing namespace std;\n\nvector<int> dijkstra(vector<vector<int>> es,int n,int s){\n  \n  vector<int> dist(n,LLONG_MAX);\n  using Pi = pair<int,int>;\n  priority_queue<Pi,vector<Pi>,greater<Pi>> q;\n  dist[s] = 0;\n  q.emplace(dist[s],s);\n  while(!q.empty()){\n    int cost;\n    int idx;\n    tie(cost,idx) = q.top();\n    q.pop();\n    if(dist[idx] < cost) continue;\n    for( auto e : es[idx]){\n      auto next_cost = cost + 1;\n      if(dist[e] <= next_cost) continue;\n      dist[e] = next_cost;\n      q.emplace(dist[e],e);\n    }\n  }\n  return dist;\n}\n\n\nmain(){\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n  s--;t--;\n\n  vector<vector<int>> es(n);\n\n  for(int i=0;i<m;i++){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    es[x].push_back(y);\n    es[y].push_back(x);\n  }\n\n  vector<int> sv = dijkstra(es,n,s);\n  vector<int> tv = dijkstra(es,n,t);\n\n  int dist = sv[t];\n  if(dist==LLONG_MAX){\n    cout<<0<<endl;\n    return 0;\n  }\n  sort(all(sv));\n  sort(all(tv));\n  int ans=0;\n//  cout<<dist<<endl;\n\n  for(int i=0;i<dist;i++){\n    int d = dist-i-2;\n    int res1 = upper_bound(all(sv),i) - lower_bound(all(sv),i);\n    int res2 = upper_bound(all(tv),d)- lower_bound(all(tv),d);\n    \n//    cout<<res1<<' '<<res2<<endl;\n    ans+=res1*res2;\n  }\n\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nvector< vector<int> > G;\nint dist[2][100100];\nll cnt[2][100100];\nint N, M, s, t;\n\nvoid bfs(int v)\n{\n  int c = v == s ? 0 : 1;\n  queue<int> que;\n  dist[c][v] = 0;\n  que.push(v);\n  while(!que.empty()) {\n    int now = que.front(); que.pop();\n    for(int i = 0; i < G[now].size(); i++) {\n      int to = G[now][i];\n      if(!~dist[c][to]) {\n\tdist[c][to] = dist[c][now] + 1;\n\tque.push(to);\n      }\n    }\n  }\n}\n\nint main()\n{\n  cin >> N >> M >> s >> t;\n  --s, --t;\n  G.resize(N);\n  for(int i = 0; i < M; i++) {\n    int x, y; cin >> x >> y;\n    --x, --y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  memset(dist, -1, sizeof(dist));\n  memset(cnt, 0, sizeof(cnt));  \n  bfs(s); bfs(t);  \n  for(int i = 0; i < N; i++) {\n    cnt[0][dist[0][i]]++;\n    cnt[1][dist[1][i]]++;\n  }\n  ll ans = 0LL;\n  for(int i = 0; i < dist[0][t]-1; i++) {\n    ans += cnt[0][i]*cnt[1][dist[0][t]-i-2];\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<bool> vb;\ntypedef pair<int, ll> pii;\n\nstruct Comp {\n\tbool operator() (pii a, pii b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nint main()\n{\n\tint N, M, s, t;\n\tcin >> N >> M >> s >> t;\n\ts--; t--;\n\n\tmap< int, vector<pii> > edge;\n\trep(i, 0, M)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tedge[x].push_back(pii(y, 1));\n\t\tedge[y].push_back(pii(x, 1));\n\t}\n\n\tvi dist(N, INF);\n\tvb done(N, false);\n\tpriority_queue<pii, vector<pii>, Comp> que;\n\tdist[s] = 0;\n\tque.push(pii(s, 0));\n\twhile (!que.empty())\n\t{\n\t\tpii p = que.top(); que.pop();\n\t\tif (done[p.first]) continue;\n\t\tdone[p.first] = true;\n\t\tfor (pii pp : edge[p.first])\n\t\t{\n\t\t\tint newcost = p.second + pp.second;\n\t\t\tif (newcost < dist[pp.first])\n\t\t\t{\n\t\t\t\tdist[pp.first] = newcost;\n\t\t\t\tque.push(pii(pp.first, newcost));\n\t\t\t}\n\t\t}\n\t}\n\n\tvi dist2(N, INF);\n\tvb done2(N, false);\n\tdist2[t] = 0;\n\tque.push(pii(t, 0));\n\twhile (!que.empty())\n\t{\n\t\tpii p = que.top(); que.pop();\n\t\tif (done2[p.first]) continue;\n\t\tdone2[p.first] = true;\n\t\tfor (pii pp : edge[p.first])\n\t\t{\n\t\t\tint newcost = p.second + pp.second;\n\t\t\tif (newcost < dist2[pp.first])\n\t\t\t{\n\t\t\t\tdist2[pp.first] = newcost;\n\t\t\t\tque.push(pii(pp.first, newcost));\n\t\t\t}\n\t\t}\n\t}\n\n\tint len = dist[t];\n\tvi from_s(len + 1, 0);\n\tvi from_t(len + 1, 0);\n\trep(i, 0, N)\n\t{\n\t\tif (dist[i] <= len)\n\t\t\tfrom_s[dist[i]]++;\n\t\tif (dist2[i] <= len)\n\t\t\tfrom_t[dist2[i]]++;\n\t}\n\n\tll ans = 0;\n\trep(i, 0, len-1)\n\t{\n\t\tans += from_s[i] * from_t[len - 1 - i - 1];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\ntypedef pair<int, int> State;\nint n;\nvvi edge;\n\nvoid bfs(int s, vi& dist){\n    dist = vi(n, inf);\n\n    queue<State> q;\n    q.push(mp(0, s));\n\n    while(!q.empty()){\n        int cur_cost = q.front().F;\n        int cur_v = q.front().S;\n        q.pop();\n\n        dist[cur_v] = cur_cost;\n\n        for(int u : edge[cur_v]){\n            if(dist[u] != inf) continue;\n\n            q.push(mp(cur_cost + 1, u));\n        }\n    }\n}\n\nint main(void){\n    ll res;\n    for(int m, s, t; cin >> n >> m >> s >> t; cout << res << endl){\n        res = 0;\n\n        s--, t--;\n        edge = vvi(n);\n\n        rep(i, m){\n            int x, y; cin >> x >> y;\n            x--, y--;\n            \n            edge[x].pb(y), edge[y].pb(x);\n        }\n\n        vi dist_fromS, dist_fromT;\n        bfs(s, dist_fromS);\n        bfs(t, dist_fromT);\n\n        map<int, ll> distCnt_fromS, distCnt_fromT;\n        rep(u, n){\n            distCnt_fromS[dist_fromS[u]]++;\n            distCnt_fromT[dist_fromT[u]]++;\n        }\n\n        int path_len = dist_fromS[t];\n\n        rep(i, path_len - 1){\n            res += distCnt_fromS[i] * distCnt_fromT[path_len - i - 2];\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define INF (1<<26)\n\nint N,M,a,b,si,ti;\nvector<int> G[MAX_N];\nint sd[MAX_N],td[MAX_N];\nint sc[MAX_N],tc[MAX_N];\n\nvoid calc(int si,int d[MAX_N],int c[MAX_N]){\n  for(int i=0;i<MAX_N;i++)d[i]=INF,c[i]=0;\n\n  queue<int> Q;\n  d[si]=0;\n  c[0]++;\n  Q.push(si);\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(d[pos]+1<d[to]){\n\td[to]=d[pos]+1;\n\tc[d[to]]++;\n\tQ.push(to);\n      }\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d %d %d %d\",&N,&M,&si,&ti);\n  for(int i=0;i<M;i++){\n    scanf(\"%d %d\",&a,&b);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  calc(si,sd,sc);\n  calc(ti,td,tc);\n \n  int total=sd[ti];\n  long long ans=0,A,B;\n  for(int i=0;i<=N;i++){\n    if(total-2-i<0)continue;\n    A=sc[i];\n    B=tc[total-2-i];\n    ans+=A*B;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N, M, S, T;\n\nint shortest_path(vector<vector<int>> G){\n    vector<int> d(N, -1);\n    \n    queue<int> que;\n    que.push(S);\n    d[S] = 0;\n    \n    while(!que.empty()){\n        auto u = que.front(); que.pop();\n        for(auto v: G[u]){\n            if(d[v] == -1){\n                d[v] = d[u] + 1;\n                if(v == T)\n                    return d[v];\n                que.push(v);\n            }\n        }\n    }\n    return -1;\n}\n\n\nvector<ll> bfs(vector<vector<int>> G, int s){\n    vector<int> d(N, -1);\n    \n    queue<int> que;\n    que.push(s);\n    d[s] = 0;\n    \n    while(!que.empty()){\n        auto u = que.front(); que.pop();\n        for(auto v: G[u]){\n            if(d[v] == -1){\n                d[v] = d[u] + 1;\n                que.push(v);\n            }\n        }\n    }\n    \n    vector<ll> res(N);\n    for(int i=0; i<N; i++) if(d[i] >= 0)\n        res[d[i]]++;\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    cin >> N >> M >> S >> T; S--; T--;\n    \n    vector<vector<int>> G(N);\n    for(int i=0; i<M; i++){\n        int x, y; cin >> x >> y; x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    \n    int sp = shortest_path(G);\n    auto st = bfs(G, S);\n    auto tt = bfs(G, T);\n    \n    ll ans = 0;\n    for(int i=0; i<=sp-2; i++)\n        ans += st[i] * tt[sp-2-i];\n    \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, Array &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tint n, m, s, t;\n\tcin >> n >> m >> s >> t;\n\ts--; t--;\n\tGraph g(n);\n\tREP(i, m)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, 1);\n\t\tadd_edge(g, b, a, 1);\n\t}\n\tArray d1, d2;\n\tdijkstra(g, d1, s);\n\tdijkstra(g, d2, t);\n\tint dist = d1[t] - 1;\n\tvi v1(111111), v2(111111);\n\tREP(i, d1.size()) if (d1[i] != INF) v1[d1[i]]++;\n\tREP(i, d2.size()) if (d2[i] != INF) v2[d2[i]]++;\n\tll ans = 0;\n\tREP(i, v1.size())\n\t{\n\t\tint t = dist - i - 1;\n\t\tif(t>=0&&t<111111) ans += v2[t]*v1[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n,m,s,t;\nvector<int> G[111111];\n\nint sd[111111],td[111111];\nbool vis[111111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n>>m>>s>>t;\n\ts--; t--;\n\trep(i,m){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tG[x].pb(y); G[y].pb(x);\n\t}\n\tint maxd;\n\tqueue<P> que;\n\tque.push(P(s,0));\n\twhile(!que.empty()){\n\t\tint nv=que.front().fi,dist=que.front().se; que.pop();\n\t\tvis[nv]=true;\n\t\tsd[dist]++;\n\t\tif(nv==t){\n\t\t\tmaxd=dist;\n\t\t\tbreak;\n\t\t}\n\t\trep(i,G[nv].size()){\n\t\t\tint next=G[nv][i];\n\t\t\tif(vis[next])continue;\n\t\t\tque.push(P(next,dist+1));\n\t\t}\n\t}\n\n\tqueue<P>().swap(que);\n\tmemset(vis,0,sizeof(vis));\n\tque.push(P(t,0));\n\twhile(!que.empty()){\n\t\tint nv=que.front().fi,dist=que.front().se; que.pop();\n\t\tvis[nv]=true;\n\t\ttd[dist]++;\n\t\tif(nv==s)break;\n\t\trep(i,G[nv].size()){\n\t\t\tint next=G[nv][i];\n\t\t\tif(vis[next])continue;\n\t\t\tque.push(P(next,dist+1));\n\t\t}\n\t}\n\n\tll res=0;\n\trep(i,maxd){\n\t\tif(maxd-i-2<0)break;\n\t\tres+=sd[i]*td[maxd-i-2];\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (int)1e6\nusing namespace std;\n\ntypedef list<int>::iterator liitr;\n\n\nvoid calc(int s, vector<int> &d, vector<list<int> > &adj){\n\td[s] = 0;\n\tpriority_queue<pair<int,int> > npos;\n\tnpos.push(make_pair(0,s) );\n\n\twhile(!npos.empty()){\n\t\tpair<int,int> temp = npos.top();\n\t\tnpos.pop();\n\t\tint cost = temp.first + 1;\n\t\tint now = temp.second;\n\t\tfor(liitr it = adj[now].begin(); it != adj[now].end(); ++it){\n\t\t\tint next = *it;\n\t\t\tif(d[next] > cost){\n\t\t\t\td[next] = cost;\n\t\t\t\tnpos.push(make_pair(cost, next));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tint n,m,s,t;\n\tcin >> n >> m >> s >> t;\n\tvector<list<int> > adj(n+1,list<int>(0));\n\tfor(int i = 0; i < m; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\n\t//for(int i = 1; i < n+1 ; i++){ \\\n\t\tcout << i << \" ; \";\t\t\t\\\n\t\tfor(int j = 0; j < adj[i].size(); j++){ \\\n\t\t\tcout << adj[i][j] << \" \"; \\\n\t\t} \\\n\t\tcout << endl; \\\n\t}\n\n\tvector<int> sd(n+1,INF);\n\tvector<int> td(n+1,INF);\n\tcalc(s,sd,adj);\n\tcalc(t,td,adj);\n\n\tint stcost = sd[t];\n\t\n\tvector<int> sdis(stcost+1), tdis(stcost+1);\n\n\tfor(int i = 0, im = td.size(); i < im; ++i){\n\t\tif(sd[i] < stcost) sdis[sd[i]]++;\n\t//\tcout << i << \" ; \" << sd[i] << endl;\n\t}\n//\tcout << endl;\n\tfor(int i = 0, im = td.size(); i < im; ++i){\n\t\tif(td[i] < stcost) tdis[td[i]]++;\n\t//\tcout << i << \" ; \" << td[i] << endl;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i <= stcost -2; ++i){\n\t\tans += sdis[i] * tdis[stcost - i -2];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\t\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <queue>\n\nint min[100000] = {0};\nint min2[100000] = { 0 };\nlong long dp[100000] = {1, 0};\nlong long dp2[100000] = { 1, 0 };\n\nint main() {\n\tint n, m, s, t;\n\tint len;\n\tstd::cin >> n >> m >> s >> t;\n\tstd::unordered_multimap<int, int> e;//from, to\n\te.reserve(300000);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tstd::cin >> x >> y;\n\t\te.insert(std::make_pair(x, y));\n\t\te.insert(std::make_pair(y, x));\n\t}\n\n\tstd::queue<std::pair<int, int>> q;\n\tq.push(std::make_pair(0, s));\n\n\twhile (!q.empty()) {\n\t\tauto node = q.front(); q.pop();\n\t\tauto it = e.find(node.second);\n\t\tint count = e.count(node.second);\n\t\tfor (int i = 0; i < count; i++, ++it) {\n\t\t\tauto next = node;\n\t\t\tnext.first++;\n\t\t\tnext.second = it->second;\n\t\t\tif (next.second == s || (min[next.second] > 0 && min[next.second] <= next.first)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmin[next.second] = next.first;\n\t\t\tdp[next.first]++;\n\t\t\tif (next.second == t) len = next.first;\n\t\t\tq.push(next);\n\t\t}\n\t}\n\n\tq.push(std::make_pair(0, t));\n\twhile (!q.empty()) {\n\t\tauto node = q.front(); q.pop();\n\t\tauto it = e.find(node.second);\n\t\tint count = e.count(node.second);\n\t\tfor (int i = 0; i < count; i++, ++it) {\n\t\t\tauto next = node;\n\t\t\tnext.first++;\n\t\t\tnext.second = it->second;\n\t\t\tif (next.second == t || (min2[next.second] > 0 && min2[next.second] <= next.first)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmin2[next.second] = next.first;\n\t\t\tdp2[next.first]++;\n\t\t\tq.push(next);\n\t\t}\n\t}\n\n\tlong long count = 0;\n\tfor (int i = 0; i <= len - 2; i++) {\n\t\t\tcount += dp[i] * dp2[len - i - 2];\n\t}\n\tstd::cout << count << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m, s, t;\nint dist[2][100000];\nvector<int> e[100000];\nlong long num[2][100001];\n\nint main(){\n\tcin >> n >> m >> s >> t;\n\trep(u,2) rep(i,100000) dist[u][i] = INF;\n\ts--; t--;\n\trep(i,m){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tqueue<P> que;\n\tdist[0][s] = 0;\n\tnum[0][0]++;\n\tque.push(P(0,s));\n\twhile(true){\n\t\tif(que.size() == 0) break;\n\t\tP q = que.front();\n\t\tque.pop();\n\t\trep(i,e[q.second].size()){\n\t\t\tif(dist[0][e[q.second][i]] != INF) continue;\n\t\t\tdist[0][e[q.second][i]] = q.first+1;\n\t\t\tnum[0][q.first+1]++;\n\t\t\tque.push(P(q.first+1,e[q.second][i]));\n\t\t}\n\t}\n\tdist[1][t] = 0;\n\tnum[1][0]++;\n\tque.push(P(0,t));\n\twhile(true){\n\t\tif(que.size() == 0) break;\n\t\tP q = que.front();\n\t\tque.pop();\n\t\trep(i,e[q.second].size()){\n\t\t\tif(dist[1][e[q.second][i]] != INF) continue;\n\t\t\tdist[1][e[q.second][i]] = q.first+1;\n\t\t\tnum[1][q.first+1]++;\n\t\t\tque.push(P(q.first+1,e[q.second][i]));\n\t\t}\n\t}\n\tlong long ans = 0;\n\tint D = dist[0][t];\n\tfor(int i = 0; i <= D-2; i++){\n\t\tans += num[0][i]*num[1][D-2-i];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m, s, t;\nint dist[2][100000];\nvector<int> e[100000];\nint num[2][100001];\n\nint main(){\n\tcin >> n >> m >> s >> t;\n\trep(u,2) rep(i,100000) dist[u][i] = INF;\n\ts--; t--;\n\trep(i,m){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tqueue<P> que;\n\tdist[0][s] = 0;\n\tnum[0][0]++;\n\tque.push(P(0,s));\n\twhile(true){\n\t\tif(que.size() == 0) break;\n\t\tP q = que.front();\n\t\tque.pop();\n\t\trep(i,e[q.second].size()){\n\t\t\tif(dist[0][e[q.second][i]] != INF) continue;\n\t\t\tdist[0][e[q.second][i]] = q.first+1;\n\t\t\tnum[0][q.first+1]++;\n\t\t\tque.push(P(q.first+1,e[q.second][i]));\n\t\t}\n\t}\n\tdist[1][t] = 0;\n\tnum[1][0]++;\n\tque.push(P(0,t));\n\twhile(true){\n\t\tif(que.size() == 0) break;\n\t\tP q = que.front();\n\t\tque.pop();\n\t\trep(i,e[q.second].size()){\n\t\t\tif(dist[1][e[q.second][i]] != INF) continue;\n\t\t\tdist[1][e[q.second][i]] = q.first+1;\n\t\t\tnum[1][q.first+1]++;\n\t\t\tque.push(P(q.first+1,e[q.second][i]));\n\t\t}\n\t}\n\tlong long ans = 0;\n\tint D = dist[0][t];\n\tfor(int i = 0; i <= D-2; i++){\n\t\tans += num[0][i]*num[1][D-2-i];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> dijkstra(const Graph &g, int st){\n    vector<int> d(g.size(),INF);\n    d[st] = 0;\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push(P(0,st)); // P(dis, pos)\n    while(!que.empty()){\n        int dist = que.top().first;\n        int v = que.top().second;\n        que.pop();\n        if(d[v]<dist) continue;\n        for(const auto &to: g[v]){\n            if(d[to]<=d[v]+1) continue;\n            d[to] = d[v] + 1;\n            que.push(P(d[to], to));\n        }\n    }\n    return d;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m,st,gt;cin>>n>>m>>st>>gt;\n    st--;gt--;\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int x,y; cin>>x>>y; x--;y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<int> ds=dijkstra(g,st),dt=dijkstra(g,gt);\n    int dis=ds[gt];\n    if(dis==1){\n        cout<<0<<endl;\n    }\n    else{\n        map<int,int> mp;\n        for(int i=0;i<n;i++){\n            int d=dt[i];\n            mp[d]++;\n        }\n        int res=0;\n        for(int i=0;i<n;i++){\n            int d=dis-2-ds[i];\n            res+=mp[d];\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (int)1e6\nusing namespace std;\n\n\nvoid calc(int s, vector<int> &d, vector<vector<int> > &adj){\n\td[s] = 0;\n\tpriority_queue<pair<int,int> > npos;\n\tnpos.push(make_pair(0,s) );\n\n\twhile(!npos.empty()){\n\t\tpair<int,int> temp = npos.top();\n\t\tnpos.pop();\n\t\tint cost = temp.first + 1;\n\t\tint now = temp.second;\n\t\tfor(int i = 0, im = adj[now].size(); i < im; ++i){\n\t\t\tint next = adj[now][i];\n\t\t\tif(d[next] > cost){\n\t\t\t\td[next] = cost;\n\t\t\t\tnpos.push(make_pair(cost, next));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tint n,m,s,t;\n\tcin >> n >> m >> s >> t;\n\tvector<vector<int> > adj(n+1,vector<int>(0));\n\tfor(int i = 0; i < m; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\n\t//for(int i = 1; i < n+1 ; i++){ \\\n\t\tcout << i << \" ; \";\t\t\t\\\n\t\tfor(int j = 0; j < adj[i].size(); j++){ \\\n\t\t\tcout << adj[i][j] << \" \"; \\\n\t\t} \\\n\t\tcout << endl; \\\n\t}\n\n\tvector<int> sd(n+1,INF);\n\tvector<int> td(n+1,INF);\n\tcalc(s,sd,adj);\n\tcalc(t,td,adj);\n\n\tint stcost = sd[t];\n\t\n\tvector<int> sdis(stcost+1), tdis(stcost+1);\n\n\tfor(int i = 0, im = td.size(); i < im; ++i){\n\t\tif(sd[i] < stcost) sdis[sd[i]]++;\n\t//\tcout << i << \" ; \" << sd[i] << endl;\n\t}\n//\tcout << endl;\n\tfor(int i = 0, im = td.size(); i < im; ++i){\n\t\tif(td[i] < stcost) tdis[td[i]]++;\n\t//\tcout << i << \" ; \" << td[i] << endl;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i <= stcost -2; ++i){\n\t\tans += sdis[i] * tdis[stcost - i -2];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\t\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nconst int MAX_N = 100005;\n\nint sdir[MAX_N];\nint tdir[MAX_N];\nint spt[MAX_N];\nint tpt[MAX_N];\nmap<P,int> mp;\nvector<int> G[MAX_N];\n\nvoid bfs(int u,int* flag)\n{\n    queue<P> que;\n    que.push(P(u,0));\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,G[p.first].size()){\n            if(flag[G[p.first][i]] > p.second + 1){\n                flag[G[p.first][i]] = p.second + 1;\n                que.push(P(G[p.first][i],flag[G[p.first][i]]));\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int n,m,s,t;\n\tscanf(\"%d%d%d%d\",&n,&m,&s,&t);\n\trep(i,m){\n\t\tint x,y;\n        scanf(\"%d%d\",&x,&y);\n        G[x-1].push_back(y-1);\n        G[y-1].push_back(x-1);\n        mp[P(x-1,y-1)]++;\n        mp[P(y-1,x-1)]++;\n\t}\n    fill(sdir,sdir+n,INF);\n    fill(tdir,tdir+n,INF);\n    bfs(s-1,sdir);\n    sdir[s-1] = 0;\n    bfs(t-1,tdir);\n    tdir[t-1] = 0;\n    rep(i,n){\n        if(sdir[i] != INF && tdir[i] != INF){\n            spt[sdir[i]]++;\n            tpt[tdir[i]]++;\n        }\n    }\n    int min_dir = sdir[t-1];\n    ll res = 0;\n    rep(i,min_dir-1){\n        res += spt[i] * tpt[min_dir - i - 2];\n    }\n    printf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nstruct Edge{ int dst, cost; };\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nconst int INF = 1000000000;\nvoid add_edge(Graph& G, int a, int b) {\n    G[a].push_back({b, 1});\n    G[b].push_back({a, 1});\n}\nvector<int> SPFA(const Graph& G, int s) {\n    int n = G.size();\n    vector<int> dist(n, INF);\n    vector<bool> inque(n);\n    queue<int> que;\n\n    dist[s] = 0;\n    que.push(s);\n    inque[s] = true;\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        inque[v] = false;\n        for(Edge e : G[v]) {\n            if(dist[e.dst] > dist[v] + e.cost) {\n                dist[e.dst] = dist[v] + e.cost;\n                if(!inque[e.dst]) {\n                    que.push(e.dst);\n                    inque[e.dst] = true;\n                }\n            }\n        }\n    }\n    return dist;\n}\nint main(){\n    iostream_init();\n    int N, M, s, t;\n    while(cin >> N >> M >> s >> t) {\n        s--; t--;\n        Graph G(N);\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            add_edge(G, a, b);\n        }\n\n        vector<int> ds = SPFA(G, s);\n        vector<int> dt = SPFA(G, t);\n        unordered_map<int, int> cnt;\n        for(int x : dt) cnt[x]++;\n        int D = ds[t];\n        long long ans = 0;\n        REP(i, N) {\n            // ds[i] + 1 + E == D-1\n            int E = D - ds[i] - 2;\n            ans += cnt[E];\n        }\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct state {\n  int cost, use, pos;\n  state(int c, int u, int p) : cost(c), use(u), pos(p){}\n};\n\nvector<int> bfs(vector<vector<pair<int, bool>>>& G, int s, int t, int& shortestLen) {\n  vector<int> dist(G.size(), inf), d2cnt(G.size()+1);\n  dist[s] = 0;\n\n  queue<state> q;\n  q.emplace(0, 0, s);\n\n  while(!q.empty()) {\n    const state s = q.front(); q.pop();\n    d2cnt[s.cost]++;\n    for(auto& e: G[s.pos]) {\n      const int next = e.first;\n      if(dist[next] > s.cost + 1) {\n        dist[next] = s.cost + 1;\n        q.emplace(dist[next], 0, next);\n      }\n    }\n  }\n\n  shortestLen = dist[t];\n  return d2cnt;\n}\n\nint main() {\n\n  int N, M, s, t; cin >> N >> M >> s >> t; s--, t--;\n  vector<vector<pair<int, bool>>> G(N);\n  rep(i, M) {\n    int x, y; cin >> x >> y;\n    G[x-1].emplace_back(y-1, false);\n    G[y-1].emplace_back(x-1, false);\n  }\n\n  int shortestLen;\n  auto d2cnt1 = bfs(G, s, t, shortestLen);\n  auto d2cnt2 = bfs(G, t, s, shortestLen);\n\n  ll ans = 0;\n\n  rep(i, N) {\n    if(shortestLen-i-2 >= 0)\n      ans += (ll)d2cnt1[i] * d2cnt2[shortestLen-i-2];\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct state {\n  int cost, use, pos;\n  state(int c, int u, int p) : cost(c), use(u), pos(p){}\n};\n\nvector<int> bfs(vector<vector<pair<int, bool>>>& G, int s, int t, int& shortestLen) {\n  vector<int> dist(G.size(), inf), d2cnt(G.size());\n  dist[s] = 0;\n\n  queue<state> q;\n  q.emplace(0, 0, s);\n\n  while(!q.empty()) {\n    const state s = q.front(); q.pop();\n    d2cnt[s.cost]++;\n    for(auto& e: G[s.pos]) {\n      const int next = e.first;\n      if(dist[next] > s.cost + 1) {\n        dist[next] = s.cost + 1;\n        q.emplace(dist[next], 0, next);\n      }\n    }\n  }\n\n  shortestLen = dist[t];\n  return d2cnt;\n}\n\nint main() {\n\n  int N, M, s, t; cin >> N >> M >> s >> t; s--, t--;\n  vector<vector<pair<int, bool>>> G(N);\n  rep(i, M) {\n    int x, y; cin >> x >> y;\n    G[x-1].emplace_back(y-1, false);\n    G[y-1].emplace_back(x-1, false);\n  }\n\n  int shortestLen;\n  auto && d2cnt1 = bfs(G, s, t, shortestLen);\n  auto && d2cnt2 = bfs(G, t, s, shortestLen);\n\n  ll ans = 0;\n\n  rep(i, N) {\n    if(shortestLen-i-2 >= 0)\n      ans += d2cnt1[i] * d2cnt2[shortestLen-i-2];\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DBG 0\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nusing Weight = int;\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INF) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Dijkstra O( |E|log|V| )\n//dist: ?§????????????????????????§??????????????¢\n//?????????: ???????????¨????????????(??????-1)\nvector<int> dijkstra(const Graph &g, int s, vector<Weight> &dist) {\n\ttypedef tuple<Weight, int, int> State; //?§?????????????????°?????????? ??? ???\n\tpriority_queue<State, vector<State>, greater<State> >PQ;\n\tint n = g.size();\n\tvector<int> color(n, WHITE);\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INF); //distance\n\tdist[s] = 0; PQ.emplace(0, s, -1); color[s] = GRAY; //?§????\n\twhile (!PQ.empty()) {\n\t\tWeight d; int v; int u;\n\t\ttie(d, v, u) = PQ.top(); PQ.pop(); //dist???????°??????¨??????????´????????????????\n\t\tif (dist[v] < d) continue; //?????§???????????§???????????°??????\n\t\tcolor[v] = BLACK;\n\t\tprev[v] = u;\n\t\tfor (auto &e : g[v]) { //??£??\\????????????????????¨????????????\t\t\n\t\t\tif (color[e.d] == BLACK)continue; //??¢?´¢????????????\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tPQ.emplace(dist[e.d], e.d, v);\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\nsigned main() {\n\tint N, M, s, t; cin >> N >> M >> s >> t; s--, t--;\n\tGraph G(N);\n\trep(i, 0, M) {\n\t\tint x, y; cin >> x >> y; x--, y--;\n\t\tG[x].emplace_back(x, y, 1);\n\t\tG[y].emplace_back(y, x, 1);\n\t}\n\tvector<int> dist;\n\tdijkstra(G, s, dist);\n\tdumpc(dist);\n\tint mi = dist[t];\n\n\tvector<int> cnt(N, 0);\n\tfor (auto &d : dist)if (d < N)cnt[d]++;\n\n\tdumpc(cnt);\n\tvector<int> dist2;\n\tdijkstra(G, t, dist2);\n\tdumpc(dist2);\n\tvector<int> cnt2(N, 0);\n\tfor (auto &d : dist2)if (d < N)cnt2[d]++;\n\tdumpc(cnt2);\n\n\tint ans = 0;\n\trep(i, 0, mi - 1) {\n\t\tans += cnt[i] * cnt2[mi - 1 - i - 1];\n\t\tdump(ans);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#define mk make_pair\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nbool vis[100000];\nint main(){\n  int n,m,s,t,x,y;\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  vector<int> v[100000];\n  set<pair<int,int> >ss;\n  r(i,m){\n    cin>>x>>y;\n    x--;y--;\n    ss.insert(mk(x,y));\n    ss.insert(mk(y,x));\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int s1[n],t1[n];\n  queue<pair<int,int> >q;\n  q.push(mk(s,0));\n  vis[s]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    s1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n\tvis[v[pp][i]]=1;\n\tq.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  memset(vis,0,sizeof(vis));\n  q.push(mk(t,0));\n  vis[t]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    t1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n\tvis[v[pp][i]]=1;\n\tq.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  int po=s1[t],cc=0;\n  vector<int> d[100000];\n  r(i,n)d[s1[i]].push_back(i);\n  r(i,n){\n    int tt=po-t1[i]-1;\n    if(tt>-1)r(j,d[tt].size())\n      if(!ss.count(mk(d[tt][j],i))&&d[tt][i]!=i){\n\tcc++;\n      }\n  }\n  cout<<cc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\nvector<int> used1,used2;\nvector<int> dp1,dp2;\npriority_queue<pair<int,int>> pq1;\npriority_queue<pair<int,int>> pq2;\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    vector<vector<int>> v(n);\n    // set<pair<int,int>> se;\n    rep(i,n){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    used1=vector<int>(n+10,-1);\n    used2=vector<int>(n+10,-1);\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    dp1=vector<int>(n+10,0);\n    dp2=vector<int>(n+10,0);\n    rep(i,n){\n        if(0<=used1[i]&&used1[i]<=n) dp1[used1[i]]++;\n        if(0<=used2[i]&&used2[i]<=n) dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n,m,s,t;\nvector<int> G[111111];\n\nint sd[111111],td[111111];\nbool vis[111111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n>>m>>s>>t;\n\ts--; t--;\n\trep(i,m){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tG[x].pb(y); G[y].pb(x);\n\t}\n\tint maxd;\n\tqueue<P> que;\n\tque.push(P(s,0));\n\twhile(!que.empty()){\n\t\tint nv=que.front().fi,dist=que.front().se; que.pop();\n\t\tvis[nv]=true;\n\t\tsd[dist]++;\n\t\tif(nv==t){\n\t\t\tmaxd=dist;\n\t\t\tbreak;\n\t\t}\n\t\trep(i,G[nv].size()){\n\t\t\tint next=G[nv][i];\n\t\t\tif(vis[next])continue;\n\t\t\tque.push(P(next,dist+1));\n\t\t}\n\t}\n\n\tqueue<P>().swap(que);\n\tmemset(vis,0,sizeof(vis));\n\tque.push(P(t,0));\n\twhile(!que.empty()){\n\t\tint nv=que.front().fi,dist=que.front().se; que.pop();\n\t\tvis[nv]=true;\n\t\ttd[dist]++;\n\t\tif(nv==s)break;\n\t\trep(i,G[nv].size()){\n\t\t\tint next=G[nv][i];\n\t\t\tif(vis[next])continue;\n\t\t\tque.push(P(next,dist+1));\n\t\t}\n\t}\n\n\tll res=0;\n\trep(i,maxd){\n\t\tif(maxd-i-2<0)break;\n\t\tres+=sd[i]*td[maxd-i-2];\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF 1<<30\n\n// dist_from_s[u] + dist_from_t[v] = dist_from_s[t] - 2\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\n\t/* input */\n\tint N, M; cin >> N >> M;\n\tint s, t; cin >> s >> t; s--; t--;\n\tvector<vector<ll>> G(N);\n\tfor (int i = 0; i < M;i++) {\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\n\t/* initialize */\n\tvector<ll> d_s(N, INF), d_t(N, INF);\n\tqueue<ll> q_s, q_t;\n\t\n\t// d_s(t)[n] := distance n from s(t)\n\td_s[s] = 0, d_t[t] = 0;\n\tq_s.push(s), q_t.push(t);\n\n\t/* Dijkstra */\n\twhile (!q_s.empty()) {\n\t\tint u = q_s.front(); q_s.pop();\n\t\tfor (int v : G[u]) {\n\t\t\tif (d_s[v] > d_s[u] + 1) {\n\t\t\t\td_s[v] = d_s[u] + 1;\n\t\t\t\tq_s.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!q_t.empty()) {\n\t\tint u = q_t.front(); q_t.pop();\n\t\tfor (int v : G[u]) {\n\t\t\tif (d_t[v] > d_t[u] + 1) {\n\t\t\t\td_t[v] = d_t[u] + 1;\n\t\t\t\tq_t.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* solve */\n\tll ans = 0;\n\n\t// dist_is(t)[i] := sum of distance i from s(t)\n\tvector<ll> dist_is(N + 1, 0);\n\tvector<ll> dist_it(N + 1, 0);\n\tfor (int i = 0; i < N;i++) {\n\t\tif (d_s[i] != INF) {\n\t\t\tdist_is[d_s[i]]++;\n\t\t}\n\t\tif (d_t[i] != INF) {\n\t\t\tdist_it[d_t[i]]++;\n\t\t}\n\t}\n\n\tll Const = d_s[t] - 2;\n\tfor (int i = 0; i <= Const;i++) {\n\t\tans += (dist_is[i] * dist_it[Const - i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Graph{\n\tprivate:\n\tint V;\n\tvvi List;\n\tvi DIJ(int s){\n\t\tpriority_queue<P> que;\n\t\tvi d(V,inf);\n\t\td[s]=0;\n\t\tque.push({0,s});\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(d[v]<-p.first) continue;\n\t\t\tfor(int i=0;i<List[v].size();i++){\n\t\t\t\tint F=List[v][i];\n\t\t\t\tif(d[F]>d[v]+1){\n\t\t\t\t\td[F]=d[v]+1;\n\t\t\t\t\tque.push({-d[F],F});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic:\n\tGraph(int v){\n\t\tV=v;\n\t\tList=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tList[s].push_back(t);\n\t\tList[t].push_back(s);\n\t}\n\tll solve(int s,int t){\n\t\tvi ds=DIJ(s),dt=DIJ(t);\n\t\tsort(dt.begin(),dt.end());\n\t\tll res=0,d=ds[t]-2;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tres+=upper_bound(dt.begin(),dt.end(),d-ds[i])-lower_bound(dt.begin(),dt.end(),d-ds[i]);\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint n,m,s,t;\n\nint main(){\n\tcin>>n>>m>>s>>t;\n\tGraph g(n);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tg.add_edge(u-1,v-1);\n\t}\n\tcout<<g.solve(s-1,t-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n, m, start, goal;\n\tcin>> n>> m>> start>> goal;\n\tstart--;\n\tgoal--;\n\tvvi root(n);\n\tREP(i,m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\troot[a].push_back(b);\n\t\troot[b].push_back(a);\n\t}\n\n\tvi start_dis(n,1e9);\n\tvi sdn(100001,0);\n\tstart_dis[start] = 0;\n\tsdn[0]++;\n\tqueue<int> Q;\n\tQ.push(start);\n\twhile (!Q.empty()) {\n\t\tint q = Q.front();Q.pop();\n\t\tREP(i, root[q].size()) {\n\t\t\tif (start_dis[root[q][i]] > start_dis[q] + 1) {\n\t\t\t\tstart_dis[root[q][i]] = start_dis[q] + 1;\n\t\t\t\tQ.push(root[q][i]);\n\t\t\t\tsdn[start_dis[q] + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tvi goal_dis(n, 1e9);\n\tvi gdn(100001,0);\n\tgoal_dis[goal] = 0;\n\tgdn[0]++;\n\tQ.push(goal);\n\twhile (!Q.empty()) {\n\t\tint q = Q.front();Q.pop();\n\t\tREP(i, root[q].size()) {\n\t\t\tif (goal_dis[root[q][i]] > goal_dis[q] + 1) {\n\t\t\t\tgoal_dis[root[q][i]] = goal_dis[q] + 1;\n\t\t\t\tQ.push(root[q][i]);\n\t\t\t\tgdn[goal_dis[q] + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\tint dis = start_dis[goal];\n\tlong long ercnt = 0;\n\tREP(i, n)\n\t\tif (start_dis[i] + goal_dis[i]+1 == dis-1)\n\t\t\tercnt++;\n\tlong long ans = 0;\n\tREP(i, dis-1) {\n\t\tans += (long long)sdn[i] * (long long)gdn[dis - i-2];\n\t}\n\tcout << ans - ercnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nbool solve(){\n\n    int n, m, s, t;\n    input(n, m, s, t);\n    --s, --t;\n    vector<int> a(m), b(m);\n    pararell_input(m, a, b);\n    vector<vector<int>> edges(n);\n    for(int i = 0; i < m; ++i){\n        edges[--a[i]].emplace_back(--b[i]);\n        edges[b[i]].emplace_back(a[i]);\n    }\n\n    auto f = [&](int k){\n        vector<int> range(n, MOD);\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> que;\n        range[k] = 0;\n        que.emplace(0, k);\n        while(!que.empty()){\n            int p = que.top().second;\n            que.pop();\n            for(auto& e : edges[p])\n                if(chmin(range[e], range[p] + 1))\n                    que.emplace(range[e], e);\n        }\n        return range;\n    };\n\n    auto range_s = f(s);\n    auto range_t = f(t);\n    int dist = range_s[t];\n    vector<int> cnt_s(n, 0), cnt_t(n, 0);\n    for(int i = 0; i < n; ++i){\n        if(range_s[i] != MOD)\n            ++cnt_s[range_s[i]];\n        if(range_t[i] != MOD)\n            ++cnt_t[range_t[i]];\n    }\n    i64 ans = 0;\n    for(int i = 0; i < n; ++i)\n        if(dist - i - 2 >= 0)\n            ans += 1L * cnt_s[i] * cnt_t[dist - i - 2];\n\n    cout << ans << endl;\n\n    return false;\n}\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <map>\n#define INF 1000000000\nusing namespace std;\nstruct po{int node,flg;};\ntypedef long long ll;\nint n,m,s,g;\nvector <int> G[100001];\nmap <int,int> mp[2];\n\nll bfs(){\n  int D[2][100001]={};\n  queue <po> Q;\n  mp[0].clear(),mp[1].clear();\n  mp[0][0]++,mp[1][0]++;\n  Q.push(po{s,0}),Q.push(po{g,1});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    for(int i=0;i<G[t.node].size();i++) {\n      if(D[t.flg][G[t.node][i]]!=0)continue;\n      Q.push(po{G[t.node][i],t.flg});\n      D[t.flg][G[t.node][i]] = D[t.flg][t.node]+1;\n      mp[t.flg][D[t.flg][t.node]+1]++;\n    }\n  }\n  mp[0][D[0][s]]--,mp[1][D[1][g]]--;\n  int DG = D[0][g];\n  ll sum=0;\n  map<int,int>::iterator it=mp[0].begin();\n  while(it!=mp[0].end()){\n    if(mp[1].count(DG-2-it->first))sum += (ll)it->second * mp[1][DG - it->first-2];\n    it++;\n  }\n  return sum;\n}\n\nint main() {\n  cin >> n >> m >> s >>g;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  cout << bfs() <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\ntypedef pair<int, int> State;\nint n;\nvvi edge;\n\nvoid bfs(int s, vi& dist){\n    dist = vi(n, inf);\n    dist[s] = 0;\n\n    queue<int> q;\n    q.push(s);\n\n    while(!q.empty()){\n        int v = q.front(); q.pop();\n\n        for(int u : edge[v]){\n            if(dist[u] != inf) continue;\n\n            dist[u] = dist[v] + 1;\n            q.push(u);\n        }\n    }\n}\n\nint main(void){\n    ll res;\n    for(int m, s, t; cin >> n >> m >> s >> t; cout << res << endl){\n        res = 0;\n\n        s--, t--;\n        edge = vvi(n);\n\n        rep(i, m){\n            int x, y; cin >> x >> y;\n            x--, y--;\n            \n            edge[x].pb(y), edge[y].pb(x);\n        }\n\n        vi dist_fromS, dist_fromT;\n        bfs(s, dist_fromS);\n        bfs(t, dist_fromT);\n\n        map<int, ll> distCnt_fromS, distCnt_fromT;\n        rep(u, n){\n            distCnt_fromS[dist_fromS[u]]++;\n            distCnt_fromT[dist_fromT[u]]++;\n        }\n\n        int path_len = dist_fromS[t];\n\n        rep(i, path_len - 1){\n            res += distCnt_fromS[i] * distCnt_fromT[path_len - i - 2];\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    vector<vector<int>> v(n);\n    set<pair<int,int>> se;\n    rep(i,n){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        se.insert(minmax(a,b));\n    }\n    vector<int> used1(n,-1),used2(n,-1);\n    priority_queue<pair<int,int>> pq1;\n    priority_queue<pair<int,int>> pq2;\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    if(dist<2){\n        cout<<0<<endl;\n        return 0;\n    }\n    vector<int> dp1(n+10,0),dp2(n+10,0);\n    rep(i,n){\n        dp1[used1[i]]++;\n        dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define int long long\n\nvector<int> G[100000];\n\nvector<int> bfs(int n,int s){\n  vector<int> dist(n,1e9),visited(n);\n  dist[s]=0;\n  visited[s]=1;\n  queue<int> que;\n  que.push(s);\n  while(!que.empty()){\n    int i = que.front();\n    que.pop();\n    rep(j,G[i].size()){\n      int to = G[i][j];\n      if (visited[to]!=1) {\n        visited[to]=1;\n        dist[to] = dist[i]+1;\n        que.push(to);\n      }\n    }\n  }\n  return dist;\n}\n\nsigned main(){\n\n  int n,m,s,t;\n  cin >> n >> m >> s >> t;\n  s--;\n  t--;\n  rep(i,m){\n    int x,y;\n    cin >> x >> y;\n    x--;\n    y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  vector<int> dist = bfs(n,s);\n  vector<int> dist_r = bfs(n,t);\n  int min_dist = dist[t];\n\n  vector<int> dd(min_dist,0),dd_r(min_dist,0);\n  rep(i,n){\n    if (dist[i]<=min_dist-2)dd[dist[i]]++;\n    if (dist_r[i]<=min_dist-2)dd_r[dist_r[i]]++;\n  }\n  long long sum = 0;\n  for(int i=0;i<min_dist-1;i++){\n    sum += dd[i]*dd_r[min_dist-2-i];\n  }\n  cout << sum << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef pair<int,int> pp;\nset<int> G[105000];\n//set<pp> res;\nint dis[105000];\nset<int> S[105000];\n\nint main(void) {\n    int n,m,s,t;\n    scanf(\"%d%d%d%d\",&n,&m,&s,&t);\n    s--, t--;\n    memset(dis, 0x20, sizeof(dis));\n    for(int i=0; i<m; i++) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        x--, y--;\n        G[x].insert(y);\n        G[y].insert(x);\n    }\n\n    {\n        priority_queue<pp> q;\n        q.push(pp(-0, s));\n\n        while(!q.empty()) {\n            pp t = q.top(); q.pop();\n            int d = -t.fst, x = t.snd;\n\n            if(dis[x] != 0x20202020) continue;\n            dis[x] = d;\n            S[d].insert(x);\n\n            for(int y : G[x])\n                if(dis[y] == 0x20202020)\n                    q.push(pp(-(d+1), y));\n        }\n    }\n\n    int old = dis[t];\n    memset(dis, 0x20, sizeof(dis));\n\n    int res=0;\n    {\n        priority_queue<pp> q;\n        q.push(pp(-0, t));\n\n        while(!q.empty()) {\n            pp t = q.top(); q.pop();\n            int d = -t.fst, x = t.snd;\n\n            if(dis[x] != 0x20202020) continue;\n            dis[x] = d;\n\n            if(old-2-d >= 0)\n                for(int y : S[old-2-d])\n                    if(G[x].find(y) == G[x].end())\n                        res++;\n\n            for(int y : G[x])\n                if(dis[y] == 0x20202020)\n                    q.push(pp(-(d+1), y));\n        }\n    }\n\n    printf(\"%d\\n\", res);\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <map>\n#define INF 1000000000\nusing namespace std;\nstruct po{int node,flg;};\ntypedef long long ll;\nint n,m,s,g;\nvector <int> G[100001];\nmap <int,int> mp[2];\n\nll bfs(){\n  int D[2][100001]={};\n  queue <po> Q;\n  mp[0].clear(),mp[1].clear();\n  mp[0][0]++,mp[1][0]++;\n  Q.push(po{s,0}),Q.push(po{g,1});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    for(int i=0;i<G[t.node].size();i++) {\n      if(D[t.flg][G[t.node][i]]!=0)continue;\n      Q.push(po{G[t.node][i],t.flg});\n      D[t.flg][G[t.node][i]] = D[t.flg][t.node]+1;\n      mp[t.flg][D[t.flg][t.node]+1]++;\n    }\n  }\n  mp[0][D[0][s]]--,mp[1][D[1][g]]--;\n  int DG = D[0][g];\n  ll sum=0;\n  map<int,int>::iterator it=mp[0].begin();\n  while(it!=mp[0].end()){\n    if(mp[1].count(DG-2-it->first))sum += (ll)it->second * mp[1][DG - it->first-2];\n    it++;\n  }\n  return sum;\n}\n\nint main() {\n  cin >> n >> m >> s >>g;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  cout << bfs() <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nvector<int> G[100010];\nint d[100010],INF=99999999;\nint par[100010],rank[100010]={};\n\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else{\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y) return ;\n\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid dijkstra(int s){\nfill(d,d+100010,INF);\npriority_queue<P, vector<P>, greater<P> > que;\nd[s-1]=0;\nque.push(P(0,s-1));\n\nwhile(!que.empty()){\n  P p=que.top();\n  que.pop();\n  int v=p.second;\n  if(d[v]<p.first) continue;\n  for(int i=0;i<G[v].size();i++){\n    if(d[G[v][i]]>d[v]+1){\n      d[G[v][i]]=d[v]+1;\n      que.push(P(d[G[v][i]],G[v][i]));\n    }\n  }\n}\n}\n\nint main(){\n  int N,M,s,t,x,y;\n  cin>>N>>M>>s>>t;\n  init(N);\n\n  for(int i=0;i<M;i++){\n    cin>>x>>y;\n    G[x-1].push_back(y-1);\n    G[y-1].push_back(x-1);\n    unite(x-1,y-1);\n  }\n\n  dijkstra(s);\n  int jdg[N]={},ans=0;\n  for(int i=0;i<N;i++){\n    if(same(t-1,i)) jdg[d[i]]+=1;\n    }\n  for(int i=0;i<N;i++){\n  //  cout<<\"jdg[\"<<i<<\"]=\"<<jdg[i]<<endl;\n  }\n  int spath=d[t-1];\n\n  dijkstra(t);\n\n  int jdg2[N]={};\n  for(int i=0;i<N;i++){\n    if(same(t-1,i)) jdg2[d[i]]+=1;\n    }\n  for(int i=0;i<N;i++){\n  //  cout<<\"jdg2[\"<<i<<\"]=\"<<jdg2[i]<<endl;\n  }\n\n  for(int i=0;i<spath-1&&spath-2-i>=0;i++){\n    ans+=jdg[i]*jdg2[spath-2-i];\n  }\n/*\n  for(int i=0;i<spath-1;i++){\n      if(i+2<=spath){\n        ans+=jdg[i];\n        cout<<\"i+2=\"<<jdg[i]*jdg2[spath-i-1]<<endl;\n      }\n      if(spath<2*spath-2-i&&2*spath-2-i<N){\n        ans+=jdg[i]*jdg[2*spath-2-i];\n        cout<<\"spath*2=\"<<jdg[i]*jdg[2*spath-2-i]<<endl;\n      }\n  }\n  */\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int inf = 1e9;\n\nvector<int> bfs(vector<vector<int> > &adj, int s){\n\tvector<int> ret(adj.size(), inf);\n\tret[s] = 0;\n\tqueue<pair<int,int> > wait;\n\twait.push(make_pair(s, 0));\n\twhile(!wait.empty()){\n\t\tint pos = wait.front().first;\n\t\tint cost = wait.front().second;\n\t\twait.pop();\n\t\tfor(int i=0; i<(int)adj[pos].size(); i++){\n\t\t\tif(ret[adj[pos][i]] == inf){\n\t\t\t\tret[adj[pos][i]] = cost+1;\n\t\t\t\twait.push(make_pair(adj[pos][i], cost+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n,m,s,t;\n\tcin >> n >> m >> s >> t;\n\tvector<vector<int> > adj(n+1);\n\tvector<int> x(m),y(m);\n\tfor(int i=0; i<m; i++){\n\t\tcin >> x[i] >> y[i];\n\t\tadj[x[i]].push_back(y[i]);\n\t\tadj[y[i]].push_back(x[i]);\n\t}\n\t\n\tvector<int> froms = bfs(adj, s);\n\tvector<int> fromt = bfs(adj, t);\n\tint dist_st = froms[t];\n\tvector<long long int> bsums(n+1, 0), bsumt(n+1, 0);\n\tfor(int i=1; i<n+1; i++){\n\t\tif(froms[i]!=inf) bsums[froms[i]]++;\n\t\tif(fromt[i]!=inf) bsumt[fromt[i]]++;\n\t}\n\t\n\tlong long int ans = 0;\n\tfor(int i=0; i<dist_st -1; i++){\n\t\tint j=dist_st -i -2;\n\t\tif(i<j){\n\t\t\tans += bsums[i]*bsumt[j] +bsums[j]*bsumt[i];\n\t\t}else if(i==j){\n\t\t\tans += bsums[i]*bsumt[j];\n\t\t}\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tif(froms[x[i]] + fromt[y[i]] == dist_st-2 ||\n\t\tfroms[y[i]] + fromt[x[i]] == dist_st-2){\n\t\t\t ans--;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> graph;\n\nvector<int> bfs(int s, const graph &G) {\n\tconstexpr int INF = (1 << 30);\n\tconst int n = G.size();\n\n\tvector<int> dist(n, INF);\n\tqueue<int> que;\n\tdist[s] = 0;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(dist[to] > dist[v] + 1) {\n\t\t\t\tdist[to] = dist[v] + 1;\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m, s, t;\n\tcin >> n >> m >> s >> t;\n\t--s; --t;\n\n\tgraph G(n);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].emplace_back(b);\n\t\tG[b].emplace_back(a);\n\t}\n\n\tconst auto dist_from_s = bfs(s, G);\n\tconst auto dist_from_t = bfs(t, G);\n\tconst auto dist_st = dist_from_s[t];\n\n\tunordered_map<int, int> cnt;\n\tfor(const auto &d : dist_from_t) {\n\t\t++cnt[d];\n\t}\n\n\tlong long ans = 0;\n\tfor(const auto &e : dist_from_s) {\n\t\tans += cnt[dist_st - e - 2];\n\t}\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<set>\n\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nll n,m,s,t,x,y;\nvector<ll> g[100100];\nll ds[100100], dt[100100];\nvector<ll> nums[100100];\nset<ll> numt[100100];\nconst ll INF = 1e12;\n\nint main(){\n  cin >> n >> m >> s >> t;\n  rep(i,m){\n    cin >> x >> y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n\n  queue<ll> q;\n  q.push(s);\n  rep(i,n+1)ds[i] = INF;\n  ds[s] = 0;\n  nums[0].push_back(s);\n\n  while(q.size()){\n    ll v = q.front(); q.pop();\n\n    for(int i=0;i<g[v].size();i++){\n      if(ds[g[v][i]] > ds[v] + 1){\n\tds[g[v][i]] = ds[v] + 1;\n\tq.push(g[v][i]);\n\tnums[ds[g[v][i]]].push_back(g[v][i]);\n      }\n    }\n  }\n\n  q.push(t);\n  rep(i,n+1)dt[i] = INF;\n  dt[t] = 0;\n  numt[0].insert(t);\n\n  while(q.size()){\n    ll v = q.front(); q.pop();\n    for(int i=0;i<g[v].size();i++){\n      if(dt[g[v][i]] > dt[v] + 1){\n\tdt[g[v][i]] = dt[v] + 1;\n\tq.push(g[v][i]);\n\tnumt[dt[g[v][i]]].insert(g[v][i]);\n      }\n    }\n  }\n\n\n  ll res = 0;\n  ll len = ds[t]-1;\n  /*\n  rep(i,len+1){\n    cout << \"---\" << i << \"---\" << endl;\n    rep(j,nums[i].size())cout << nums[i][j] << \" \";cout << endl;\n  }\n\n  rep(i,len+1){\n    cout << \"---\" << i << \"---\" << endl;\n    for(set<ll>::iterator it=numt[i].begin();it!=numt[i].end();it++){\n      cout << *it << \" \";cout << endl;\n    }\n  }\n  */\n  for(int i=0;i<len;i++){\n    res += (ll)nums[i].size()*numt[len-i-1].size();\n    rep(j,nums[i].size()){\n      rep(k,g[nums[i][j]].size()){\n\tint nxt = g[nums[i][j]][k];\n\tif(numt[len-i-1].find(nxt)!=numt[len-i-1].end()){\n\t  res--;\n\t}\n      }\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1LL<<60)\n#define EPS 1e-10\n#define MOD 1000000007\ntypedef long long ll;\ntypedef pair<ll, ll> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\n\nll N, M;\nvector<ll>G[100005];\n\nvector<ll> dijkstra(ll s)\n{\n  vector<ll>d(N, INF);\n\n  priority_queue<pi, vector<pi>, greater<pi> >Q;\n  Q.push(pi(0, s));\n  d[s] = 0;\n  while(!Q.empty()){\n    pi p = Q.top(); Q.pop();\n    ll n = p.second;\n    if(d[n] < p.first) continue;\n    for(auto g:G[n]){\n      if(d[g] > d[n] + 1){\n\tQ.push(pi(d[n]+1, g));\n\td[g] = d[n] + 1;\n      }\n    }\n  }\n  return d;\n}\n\nint main()\n{\n  ll s, t;\n  scanf(\"%lld%lld%lld%lld\", &N, &M, &s, &t); s--; t--;\n  rep(i, M){\n    ll x, y; scanf(\"%lld%lld\", &x, &y); x--; y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n\n  vector<ll>S = dijkstra(s);\n  vector<ll>T = dijkstra(t);\n  map<ll, ll>dist1;\n  multiset<ll>dist2;\n  for(auto x: S){\n    if(dist1.count(x)) dist1[x] = dist1[x] + 1;\n    else dist1[x] = 1;\n  }\n  for(auto x: T) dist2.insert(x);\n\n  ll d = S[t];\n  ll res = 0;\n  for(auto x: dist1){\n    //    cout << x << \" \" << d - x - 2 << \" \" << dist.count(d-x-2) << endl;\n    res += x.second*dist2.count(d - x.first - 2);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint ds[2][100001];\nint ns[2][100001];\nvector<vector<int>> G;\nvoid bfs(int x, int d, int i){\n  queue<int> q, dis;\n  q.push(x);\n  dis.push(0);\n\n  while(!q.empty()){\n\tx = q.front(); q.pop();\n\td = dis.front(); dis.pop();\n\tif(ds[i][x] >= 0) continue;\n\tds[i][x] = d;\n\tns[i][d]++;\n\tfor(int to: G[x]){\n\t  q.push(to);\n\t  dis.push(d+1);\n\t}\n  }\n}\n\nint main(){\n  fill((int*)ds, (int*)ds+2*100001, -1);\n  fill((int*)ns, (int*)ns+2*100001, 0);\n\n  int N, M, S, T;\n  cin >> N >> M >> S >> T;\n  --S, --T;\n  G.assign(N, vector<int>());\n  for(int i=0;i<M;++i){\n\tint x, y; cin >> x >> y;\n\t--x, --y;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n  }\n  bfs(S, 0, 0);\n  bfs(T, 0, 1);\n\n  long long ans = 0, d = ds[0][T];\n  for(int i=0;i<=d-2;++i)\n\tans += ns[0][i] * ns[1][d-2-i];\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n\nint main(){\n    int n,m,s,t;cin>>n>>m>>s>>t;\n    vvi edge(n+1);\n    rep(i,m){\n        int a,b;cin>>a>>b;\n        edge[a].pb(b);\n        edge[b].pb(a);\n    }\n\n    vi depth(n+1,-1);\n    depth[s]=0;\n    queue<int> que; que.push(s);\n    int ms=0;\n    while(!que.empty()){\n        int f=que.front();\n        ms=depth[f];\n        for(auto to:edge[f]){\n            if(depth[to]==-1){\n                depth[to]=depth[f]+1;\n                que.push(to);\n            }\n        }\n        que.pop();\n    }\n    int mt=0;\n    vi depth2(n+1,-1);\n    depth2[t]=0;\n    que.push(t);\n    while(!que.empty()){\n        int f=que.front();\n        mt=depth2[f];\n        for(auto to:edge[f]){\n            if(depth2[to]==-1){\n                depth2[to]=depth2[f]+1;\n                que.push(to);\n            }\n        }\n        que.pop();\n    }\n    vvi ds(ms+1);\n    range(i,1,n+1){if(depth[i]!=-1)ds[depth[i]].pb(i);}\n    //for(auto l:ds){for(auto i:l)cout<<i<<\",\";cout<<endl;}\n    vvi dt(mt+1);\n    range(i,1,n+1){if(depth2[i]!=-1)dt[depth2[i]].pb(i);}\n    //for(auto l:dt){for(auto i:l)cout<<i<<\",\";cout<<endl;}\n    \n    ll ans=0;\n    for(int i=0;i<depth[t]-1;i++){\n        ans+=ds[i].size()*dt[depth[t]-2-i].size();\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<bitset>\n#include<random>\n#include<time.h>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<(ll)m; i++)\n#define FOR(i,n,m) for(long long i=n; i<(ll)m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,m,s,t;\n\tcin>>n>>m>>s>>t;\n\ts--;\n\tt--;\n\tvector<vector<ll>> adj(n);\n\tREP(i,m) {\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tx--;\n\t\ty--;\n\t\tadj[x].pb(y);\n\t\tadj[y].pb(x);\n\t}\n\tvector<ll> froms(n,INF);\n\tvector<ll> fromt(n,INF);\n\tfroms[s]=0;\n\tfromt[t]=0;\n\tqueue<ll> q;\n\tq.push(s);\n\twhile(!q.empty()) {\n\t\tll p=q.front();\n\t\tq.pop();\n\t\tREP(i,adj[p].size()) {\n\t\t\tif(froms[adj[p][i]]>froms[p]+1) {\n\t\t\t\tfroms[adj[p][i]]=froms[p]+1;\n\t\t\t\tq.push(adj[p][i]);\n\t\t\t}\n\t\t}\n\t}\n\tq.push(t);\n\twhile(!q.empty()) {\n\t\tll p=q.front();\n\t\tq.pop();\n\t\tREP(i,adj[p].size()) {\n\t\t\tif(fromt[adj[p][i]]>fromt[p]+1) {\n\t\t\t\tfromt[adj[p][i]]=fromt[p]+1;\n\t\t\t\tq.push(adj[p][i]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<ll> cnt1(n,0);\n\tvector<ll> cnt2(n,0);\n\tREP(i,n) if(froms[i]!=INF) cnt1[froms[i]]++;\n\tREP(i,n) if(fromt[i]!=INF) cnt2[fromt[i]]++;\n\tll ans=0;\n\tREP(i,n) {\n\t\tif(froms[t]-i-2>=0) ans+=cnt1[i]*cnt2[froms[t]-i-2];\n\t}\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        // cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--, t--;\n    vector<vector<int>> g(n);\n    REP(i, m) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    queue<pii> q;\n    q.push({0, s});\n    vector<int> dist1(n, INF), dist2(n, INF);\n    dist1[s] = dist2[t] = 0;\n    while (!q.empty()) {\n        int v = q.front().second; q.pop();\n        FORE(w, g[v]) {\n            if (chmin(dist1[w], dist1[v] + 1)) {\n                q.push({dist1[w], w});\n            }\n        }\n    }\n    q.push({0, t});\n    while (!q.empty()) {\n        int v = q.front().second; q.pop();\n        FORE(w, g[v]) {\n            if (chmin(dist2[w], dist2[v] + 1)) {\n                q.push({dist2[w], w});\n            }\n        }\n    }\n    int D = dist1[t];\n\n    map<int, int> cnt;\n    REP(v, n) cnt[dist2[v]]++;\n\n    int ans = 0;\n    REP(v, n) {\n        int tmp = cnt[D - dist1[v] - 2];\n        FORE(w, g[v]) {\n            if (dist2[w] == D - dist1[v] - 2) {\n                tmp--;\n            }\n        }\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\n\nint main()\n{\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n    s--, t--;\n    Graph g(N);\n    for (int i = 0; i < M; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        g.addEdge(x, y);\n        g.addEdge(y, x);\n    }\n    vector<bool> used(N, false);\n    using P = pair<int, int>;\n    queue<P> q;\n    used[s] = true;\n    q.push(make_pair(s, 0));\n    constexpr int INF = 1 << 30;\n    vector<int> dist(N, INF);\n    while (not q.empty()) {\n        const P p = q.front();\n        dist[p.first] = p.second;\n        q.pop();\n        for (const int to : g.edge[p.first]) {\n            if (not used[to]) {\n                used[to] = true;\n                q.push(make_pair(to, p.second + 1));\n            }\n        }\n    }\n    while (not q.empty()) {\n        q.pop();\n    }\n\n    fill(used.begin(), used.end(), false);\n    used[t] = true;\n    q.push(make_pair(t, 0));\n    vector<int> back_dist(N, INF);\n    while (not q.empty()) {\n        const P p = q.front();\n        back_dist[p.first] = p.second;\n        q.pop();\n        for (const int to : g.edge[p.first]) {\n            if (not used[to]) {\n                used[to] = true;\n                q.push(make_pair(to, p.second + 1));\n            }\n        }\n    }\n    const int D = dist[t] - 2;\n\n    vector<int> num(D + 1, 0);\n    vector<int> back_num(D + 1, 0);\n    for (int i = 0; i < N; i++) {\n        if (dist[i] <= D) {\n            num[dist[i]]++;\n        }\n        if (back_dist[i] <= D) {\n            back_num[back_dist[i]]++;\n        }\n    }\n\n    ll sum = 0;\n    for (int i = 0; i <= D; i++) {\n        sum += num[i] * back_num[D - i];\n    }\n    cout << sum << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define int long long\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nbool vis[100000];\nmain(){\n  int n,m,s,t,x,y;\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  vector<int> v[100000];\n  set<pair<int,int> >ss;\n  r(i,m){\n    cin>>x>>y;\n    x--;y--;\n    ss.insert(mk(x,y));\n    ss.insert(mk(y,x));\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int s1[n],t1[n];\n  memset(s1,1e6,sizeof(s1));\n  memset(t1,1e6,sizeof(t1));\n  queue<pair<int,int> >q;\n  q.push(mk(s,0));\n  vis[s]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    s1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  memset(vis,0,sizeof(vis));\n  q.push(mk(t,0));\n  vis[t]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    t1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  int po=s1[t],cc=0;\n  vector<int> d[100000];\n  r(i,n)if(s1[i]<n)d[s1[i]].push_back(i);\n  r(i,n)if(t1[i]<n){\n    int tt=po-t1[i]-2;\n    if(tt>-1)cc+=d[tt].size();\n  }\n  cout<<cc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\n\n#define MAX 100009\nusing namespace std;\ntypedef pair<int,int> P;\n\ntypedef struct Node\n{\n\tint n;\n\tvector<int>e;\n}Node;\n\nNode G[MAX];\nint SC[MAX], GC[MAX],N,M,s,t;\n\nint dijcstra(int s,int g)\n{\n\tint C[MAX];\n\tmemset(C,0x7f,sizeof(C));\n\tP tmp(0,s);\n\tpriority_queue<P>Q;\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(tmp.second==g)\n\t\t\treturn tmp.first;\n\t\tif(tmp.first>=C[tmp.second])\n\t\t\tcontinue;\n\t\tC[tmp.second]=tmp.first;\n\t\tfor(int i=0;i<G[tmp.second].e.size();i++)\n\t\t{\n\t\t\tint nn=G[tmp.second].e[i];\n\t\t\tif(C[nn]>tmp.first+1)\n\t\t\t{\n\t\t\t\tQ.push(make_pair(tmp.first+1,nn));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&M,&s,&t);\n\ts--;t--;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--;y--;\n\t\tG[x].e.push_back(y);\n\t\tG[y].e.push_back(x);\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tSC[i]=dijcstra(s,i);\n\t\t\tGC[i]=dijcstra(t,i);\n\t\t}\n\t}\n\tint mc=SC[t],res=0;\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(SC[i]==-1||GC[j]==-1)continue;\n\t\t\tif(i!=t&&j!=s&&i!=j&&SC[i]+GC[j]+1==mc-1)\n\t\t\t\tres++;\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y) {\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n}\n\nvector<int> bfs(const Graph& G, int s) {\n\tint n = G.size();\n    vector<int> d(n, inf);\n\tqueue<int> que;\n    que.push(s);\n    d[s] = 0;\n\n    while (!que.empty()) {\n        int pre = que.front(); que.pop();\n        for (auto nxt: G[pre]) {\n            if (d[nxt] == inf) {\n                que.push(nxt);\n                d[nxt] = d[pre] + 1;\n            }\n        }\n    }\n\n    return d;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--; t--;\n    Graph G(n);\n    rep(i, m) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        addEdge(G, x, y);\n    }\n\n\n    auto d1 = bfs(G, s);\n    auto d2 = bfs(G, t);\n    int D = d1[t];\n\n    if (D == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    vi c1(n);\n    vi c2(n);\n\n    rep(i, n) {\n        if (d1[i] == inf) continue;\n        c1[d1[i]]++;\n    }\n    rep(i, n) {\n        if (d2[i] == inf) continue;\n        c2[d2[i]]++;\n    }\n\n    int ans = 0;\n    for (int i = 0, j = D - 2; j >= 0; i++, j--) {\n        ans += c1[i] * c2[j];\n    }\n\n    rep(i, n) {\n        for (auto j : G[i]) {\n            if (i < j) continue;\n            if (d1[i] + d2[j] == D - 2 || d2[i] + d1[j] == D - 2) {\n                ans--;\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nstruct edge { int to, cost; };\nint V;\nvector<edge> G[100000];\nint d[100000]; int ds[100000]; int dg[100000]; ll cnt[100000] = {};\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tfill(d, d + V, (int)MOD);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint m;\n\tcin >> V >> m;\n\tint s, g; cin >> s >> g; s--; g--;\n\trep(i, m) {\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\tG[x].push_back({ y,1 });\n\t\tG[y].push_back({ x,1 });\n\t}\n\tdijkstra(s);\n\trep(i, V) {\n\t\tds[i] = d[i];\n\t}\n\tdijkstra(g);\n\trep(i, V) {\n\t\tdg[i] = d[i];\n\t}\n\tint r = ds[g];\n\trep(i, V) {\n\t\tif (ds[i] < (int)MOD) {\n\t\t\tcnt[ds[i]]++;\n\t\t}\n\t}\n\tll res = 0;\n\trep(i, V) {\n\t\tint x = r - dg[i] - 2;\n\t\tif (x < 0)continue;\n\t\tres += cnt[x];\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst int MAX_N = 100010;\nvector<pair<int, int> > G[MAX_N];\nvector<int> dijkstra(int start){\n\tvector<int> dist(MAX_N, INF);\n\tdist[start] = 0;//dist[i] :=???start->i?????§??????????????¢\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > >  que;\n\tque.push(make_pair(0, start));\n\twhile(!que.empty()){\n\t\tint cost; int u;//????????§???????????£????????? ?????¨?????????\n\t\tcost = que.top().first, u = que.top().second;\n\t\tque.pop();\n\t\tif(dist[u] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first; int time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[v] > dist[u] + time){//u->v\n\t\t\t\tdist[v] = dist[u] + time;\n\t\t\t\tque.push(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nint N, M, s, t;\nint x[300010], y[300010];\nset<int> dists[100010], distg[100010];\n\nint main(void){\n\tscanf(\"%d %d %d %d\", &N, &M, &s, &t);\n\ts--, t--;\n\trep(i, M) scanf(\"%d %d\", &x[i], &y[i]);\n\trep(i, M) x[i]--, y[i]--;\n\trep(i, M) G[x[i]].pb(mp(y[i], 1)), G[y[i]].pb(mp(x[i], 1));\n\tauto start = dijkstra(s);\n\tauto goal  = dijkstra(t);\n\n\trep(i, N) if(start[i] != INF) dists[start[i]].insert(i);\n\trep(i, N) if(goal[i]  != INF) distg[goal[i]].insert(i);\n\tset<pair<int, int> > ans;\n\tint len = start[t];\n\t// printf(\"len %d\\n\", len);\n\trep(i, len - 1){\n\t\tint d1 = i;\n\t\tint d2 = (len - 2) - i;\n\t\t// printf(\"d1 %d d2 %d\\n\", d1, d2);\n\t\tfor(auto u : dists[d1]){ // s -> u ??? ?????¢ d1\n\t\t\t// u ??¨ v?????°????????°??????\n\t\t\tfor(auto v : distg[d2]){\n\t\t\t\t// printf(\"%d %d\\n\", u, v);\n\t\t\t\tif(u != v) ans.insert(mp(min(u, v), max(u, v)));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (int)ans.size());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst int MAX_N = 100010;\nint N, M, s, t;\nint d1[MAX_N], d2[MAX_N];\nvector<int> G[MAX_N];\nint cnt1[MAX_N], cnt2[MAX_N];\n\nvoid bfs(int v, int *d) {\n  queue<int> que;\n  que.emplace(v);\n  memset(d, -1, sizeof(int) * N);\n  d[v] = 0;\n  while (!que.empty()) {\n    int curr = que.front(); que.pop();\n    for (int next : G[curr]) {\n      if (d[next] < 0) {\n        d[next] = d[curr] + 1;\n        que.emplace(next);\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> N >> M >> s >> t;\n  s--, t--;\n  for (int i = 0; i < M; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n  }\n  bfs(s, d1);\n  bfs(t, d2);\n  for (int i = 0; i < N; i++) {\n    if (d1[i] >= 0) cnt1[d1[i]]++;\n    if (d2[i] >= 0) cnt2[d2[i]]++;\n  }\n  ll ans = 0;\n  for (int i = 0; i < d1[t] - 1; i++) {\n    ans += (ll)cnt1[i] * cnt2[d1[t] - 2 - i];\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n// 🔴\n\n// O(ElogE)\n\n// pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<long long> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    int V, E, S, G; cin >> V >> E >> S >> G;     // V:= 頂点の数    E:= 辺の数    S:= スタートノード　　G:= ゴールノード\n    S--;\n    G--;\n    vector<vector<pair<int, int> > > adjlist(V);      //first := コスト　second := 行先\n\n    //入力\n    for(int i = 0; i < E; i++){\n        int a, b; cin >> a >> b;                    // a ,b 間に辺がある\n        a--;\n        b--;\n        adjlist[a].push_back(make_pair(1, b));\n        adjlist[b].push_back(make_pair(1, a));      \n    }\n\n    //int a, b; cin >> a >> b;\n    //adjlist[a].push_back(make_pair(1, b));\n    //adjlist[b].push_back(make_pair(1, a)); \n    \n\n    vector<long long> result_S(V);                 //Sからの距離\n    vector<long long> result_G(V);                 //Gからの距離\n    result_S = dijk(S, V, adjlist);\n    result_G = dijk(G, V, adjlist);    \n    //cout << result[G] << endl;\n\n    vector<long long> s(1000000, 0);\n    vector<long long> g(1000000, 0);\n    for(int i = 0; i < V; i++){\n\n        if(result_S[i] < 10000000) s[result_S[i]]++;\n        \n        if(result_G[i] < 10000000) g[result_G[i]]++;        \n    }\n\n    long long ans = 0;\n    long long dis = result_S[G] - 2;\n    //cout << dis << endl;\n    //result[S];\n    for(int i = 0; dis - i >= 0; i++){\n        \n        //cout << i << \" \" << dis - i << \" \" << s[i] << \" \" << g[i] << endl;\n        \n        ans += s[i] * g[dis - i];\n        //else ans += result_S[i] * result_G[dis - i] + result_S[dis - i] * result_G[i];\n        //cout << i << \": \" << result_S[i] << \" \" << result_G[i] << endl;\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\n#define MAX 100005\nint main(){\n  int n,m,s,t,di;\n  cin >> n >> m >> s >> t;\n  int i,j,k;\n  vector<int> v[MAX];\n  int d[MAX]={},d2[MAX]={};\n  for(i=0;i<m;i++){\n    cin >> j >> k;\n    v[j].push_back(k);\n    v[k].push_back(j);\n  }\n\n  bool used[MAX]={},used2[MAX]={};\n  queue<P> q;\n  P p,b;\n  p.first=s;\n  p.second=0;\n  q.push(p);\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(used[p.first]) continue;\n    //cout << p.first << \":\" << p.second << endl;\n    if(p.first==t) di=p.second;\n    used[p.first]=true;\n    d[p.second]++;\n    b.second=p.second+1;\n    for(i=0;i<v[p.first].size();i++){\n      b.first=v[p.first][i];\n      q.push(b);\n    }\n  }\n  p.first=t;\n  p.second=0;\n  q.push(p);\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(used2[p.first]) continue;\n    //cout << p.first << \":\" << p.second << endl;\n    used2[p.first]=true;\n    d2[p.second]++;\n    b.second=p.second+1;\n    for(i=0;i<v[p.first].size();i++){\n      b.first=v[p.first][i];\n      q.push(b);\n    }\n  }\n  \n  //cout << di << endl;\n  ll o=0;\n  \n  for(i=0;i<di-1;i++){\n    o+=d[i]*d2[di-2-i];\n  }\n  \n  cout << o << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define INF 1e6\nusing namespace std;\ntypedef long long ll;\nvector<int> G[100001];\nint n,m,s,t;\nint dist_s[100001];\nint dist_l[100001];\nint main(void){\n\tscanf(\"%d %d %d %d\",&n,&m,&s,&t);\n\ts--;\n\tt--;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tfill(dist_s,dist_s+n,INF);\n\tqueue<int> que;\n\tque.push(s);\n\tdist_s[s]=0;\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nec=G[v][i];\n\t\t\tif(dist_s[nec]==INF){\n\t\t\t\tdist_s[nec]=dist_s[v]+1;\n\t\t\t\tque.push(nec);\n\t\t\t}\n\t\t}\n\t}\n\tfill(dist_l,dist_l+n,INF);\n\tque.push(t);\n\tdist_l[t]=0;\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nec=G[v][i];\n\t\t\tif(dist_l[nec]==INF){\n\t\t\t\tdist_l[nec]=dist_l[v]+1;\n\t\t\t\tque.push(nec);\n\t\t\t}\n\t\t}\n\t}\n\tint mincost=dist_s[t];\n\tll cnt=0;\n\tsort(dist_s,dist_s+n);\n\tsort(dist_l,dist_l+n);\n\tfor(int i=0;i<n;i++){\n\t\tint midl=lower_bound(dist_l,dist_l+n,mincost-dist_s[i]-2)-dist_l;\n\t\tint midr=upper_bound(dist_l,dist_l+n,mincost-dist_s[i]-2)-dist_l;\n\t\tif(midl<n && midl>=0 && dist_s[i]+dist_l[midl]+2==mincost){\n\t\t\tcnt+=(ll)(midr-midl);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\n\nclass Edge{\n    public:\n        int to, cost;\n        Edge(int to, int cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n    public:\n        int dis;\n        bool isUsed;\n        Node(){\n            this->dis = INF;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\nvector<Node> node[2];\n\nvoid dijkstra(AdjList const g, int start, int n, int f, int t){\n    priority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    node[f] = vector<Node>(n);\n\n    q.push(make_pair(0, start));\n    node[f][start].dis = 0;\n\n    pair<int, int> u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second;\n        node[f][current].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            if(node[f][next].isUsed == 0){\n                if(node[f][next].dis > node[f][current].dis + g[current][i].cost){\n                    node[f][next].dis = node[f][current].dis + g[current][i].cost;\n                    q.push(make_pair(node[f][next].dis, next));\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--; t--;\n\n    AdjList g(n);\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        g[a].emplace_back(Edge{b,1});\n        g[b].emplace_back(Edge{a,1});\n    }\n    dijkstra(g,s,n,0,t);\n    dijkstra(g,t,n,1,t);\n\n    long long cnt[2][100005];\n    rep(i,n){\n        if(node[0][i].dis != INF) cnt[0][node[0][i].dis]++;\n        if(node[1][i].dis != INF) cnt[1][node[1][i].dis]++;\n    }\n    int dist = node[0][t].dis;\n\n    long long ans = 0;\n    rep(i,dist - 1) ans+=cnt[0][i] * cnt[1][dist - i - 2];\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n\nusing type = long long;\nusing P = pair<type, type>;\nstruct Edge{\n    int to, cost;\n    Edge(int a, long long b){\n        to = a;\n        cost = b;\n    }\n};\n\nclass Dijkstra{\nprivate:\n    const type _INF = 100000000;\n    int V; // 頂点数\n    vector<type> d;\n    vector<int> prev;\n    vector<vector<Edge> > G;\npublic:\n    Dijkstra(int v){\n        V = v + 1;\n        d.resize(V);\n        G.resize(V);\n        prev.resize(V);\n    }\n\n    void shortest_path(int s){\n        priority_queue<P, vector<P>, greater<P>> que;\n        d.assign(V, _INF);\n        prev.assign(V, -1);\n        d[s] = 0;\n        que.push(P(0, s));\n        while(que.size()){\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(auto e : G[v]){\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    prev[e.to] = v;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n    }\n    \n    void add_path(int from, int to, type cost){\n        G[from].push_back(Edge(to, cost));\n    }\n\n    type get_cost(int t){\n        return d[t];\n    }\n\n    bool enable_move(int t){\n        return d[t] != _INF;\n    }\n  \n    vector<int> get_path(int t){\n        vector<int> path;\n        for(; t != -1; t = prev[t])\n            path.push_back(t);\n        reverse(path.begin(), path.end());\n        return path;\n    }\n};\n\nint main(){\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n\n  Dijkstra ds(n),dt(n);\n  vector<int> x(m),y(m); \n  for(int i=0;i<m;i++){\n    cin>>x[i]>>y[i];\n    ds.add_path(x[i],y[i],1);\n    ds.add_path(y[i],x[i],1);\n    dt.add_path(x[i],y[i],1);\n    dt.add_path(y[i],x[i],1);    \n  }\n  ds.shortest_path(s);\n  dt.shortest_path(t);\n\n  ll ds_cost[300005]={0};\n  for(int i=1;i<n+1;i++){\n    if(ds.enable_move(i))ds_cost[ds.get_cost(i)]++;\n  }\n\n  ll dt_cost[300005]={0};\n  for(int i=1;i<n+1;i++){\n    if(dt.enable_move(i))dt_cost[dt.get_cost(i)]++;\n  }\n\n  ll min_cost=ds.get_cost(t);\n  ll ans=0;\n  for(int i=0;i<min_cost-1;i++){\n    ans+=(ds_cost[i]*dt_cost[min_cost-2-i]);\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define repr(i, a, b) for (int i = (int)(a - 1); i >= b; i--)\n#define rep(i, n) repl(i, 0, n)\n#define each(itr, v) for (auto itr : v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(), (x).end()\n#define dbg(x) cout << #x \" = \" << x << endl\n#define maxch(x, y) x = max(x, y)\n#define minch(x, y) x = min(x, y)\n#define uni(x) x.erase(unique(all(x)), x.end())\n#define exist(x, y) (find(all(x), y) != x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF INT_MAX / 3\n\nset<int> v[100000];\nint minds[100000], mindt[100000];\nll cnt[2][100000];\n\nint main() {\n  cin.sync_with_stdio(false);\n  int n, m, s, t;\n  cin >> n >> m >> s >> t;\n  s--, t--;\n  rep(i, m) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    v[x].insert(y);\n    v[y].insert(x);\n  }\n  rep(i, n) minds[i] = mindt[i] = INF;\n  queue<P> qs, qt;\n  qs.push(P(s, 0));\n  while (qs.size()) {\n    P p = qs.front();\n    qs.pop();\n    if (minds[p.fi] < INF) continue;\n    minds[p.fi] = p.se;\n    each(itr, v[p.fi]) if (minds[itr] == INF) qs.push(P(itr, p.se + 1));\n  }\n  qt.push(P(t, 0));\n  while (qt.size()) {\n    P p = qt.front();\n    qt.pop();\n    if (mindt[p.fi] < INF) continue;\n    mindt[p.fi] = p.se;\n    each(itr, v[p.fi]) if (mindt[itr] == INF) qt.push(P(itr, p.se + 1));\n  }\n  int st = minds[t];\n  rep(i, n) {\n    if (minds[i] < st) cnt[0][minds[i]]++;\n    if (mindt[i] < st) cnt[1][mindt[i]]++;\n  }\n  ll ans = 0;\n  rep(i, st - 1) { ans += cnt[0][i] * cnt[1][st - 2 - i]; }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\ntypedef pair<int, int> State;\nint n;\nmap<int, map<int, int>> cost;\n\nvoid dijkstra(int s, vi& dist){\n    dist = vi(n, inf);\n\n    priority_queue<State, vector<State>> q;\n    dist[s] = 0;\n    q.push(mp(0, s));\n\n    while(!q.empty()){\n        int cur_cost = q.top().F;\n        int cur_v = q.top().S;\n        q.pop();\n\n        rep(u, n){\n            if(cost[cur_v][u] == 0) continue;\n\n            if(cur_cost + cost[cur_v][u] < dist[u]){\n                dist[u] = cur_cost + cost[cur_v][u];\n                q.push(mp(dist[u], u));\n            }\n        }\n    }\n}\n\nint main(void){\n    for(int m, s, t, res; cin >> n >> m >> s >> t; cout << res << endl){\n        res = 0;\n\n        s--, t--;\n        cost = map<int, map<int, int>>();\n\n        rep(i, m){\n            int x, y; cin >> x >> y;\n            x--, y--;\n            \n            cost[x][y] = cost[y][x] = 1;\n        }\n\n        vi dist_fromS, dist_fromT;\n        dijkstra(s, dist_fromS);\n        dijkstra(t, dist_fromT);\n\n        map<int, int> distCnt_fromS, distCnt_fromT;\n        rep(u, n){\n            distCnt_fromS[dist_fromS[u]]++;\n            distCnt_fromT[dist_fromT[u]]++;\n        }\n\n        int path_len = dist_fromS[t];\n\n        rep(i, path_len + 1){\n            res += distCnt_fromS[i] * distCnt_fromT[path_len - i - 2];\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge {\n\tint from,to;\n\tint cost;\n\n\tedge(int t,int c) : to(t),cost(c) {}\n\tedge(int f,int t,int c) : from(f),to(t),cost(c) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nvector<edge> G[100005];\nint d[100005], d2[100005], cnt[100005], in[100005], pre[100005];\nbool used[100005];\n\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\trep(i, 100005) d[i] = INF, pre[i] = -1;\n\t\n\n\tque.push(mp(0, s));\n\td[s] = 0;\n\n\twhile(que.size()) {\n\t\tP p = que.top(); que.pop();\n\t\tint cost = p.first;\n\t\tint v = p.second;\n\n\t\tif(d[v] < cost) continue;\n\n\t\trep(i, G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tpre[e.to] = v;\n\t\t\t\tque.push(mp(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<int> get_path(int t) {\n\tvector<int> path;\n\tfor(;t!=-1;t=pre[t]) path.push_back(t);\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tint s, t;\n\tcin >> s >> t;\n\ts--; t--;\n\n\trep(i, m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\n\t\tG[a].push_back(edge(b, 1));\n\t\tG[b].push_back(edge(a, 1));\n\t}\n\n\tdijkstra(s);\n\trep(i, n) d2[i] = d[i];\n\n\tdijkstra(t);\n\trep(i, n) swap(d[i], d2[i]);\n\n\tmemset(cnt, 0, sizeof(cnt));\n\trep(i, n) {\n\t\tif(d2[i] == INF) continue;\n\t\tcnt[d2[i]]++;\n\t}\n\n\tll ans = 0;\n\trep(i, n) {\n\t\tif(d[i] == INF || d2[i] == INF) continue;\n\t\tint x = d[t] - 2 - d[i];\n\n\t\tif(x >= 0) {\n\t\t\tans += cnt[x];\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst int INF = 1 << 30;\n\nvector<int> bfs(const vector<vector<int>>& graph, int s, int t) {\n    vector<int> dist(graph.size(), INF);\n    dist[s] = 0;\n\n    queue<int> que;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        for (int sv : graph[v]) {\n            if (dist[sv] <= dist[v] + 1) continue;\n            dist[sv] = dist[v] + 1;\n            que.push(sv);\n        }\n    }\n    return dist;\n}\n\nint main() {\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n    --s, --t;\n\n    vector<vector<int>> graph(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    auto dist = bfs(graph, s, t);\n    int D = dist[t];\n\n    vector<lint> num(N, 0);\n    for (int v = 0; v < N; ++v) {\n        if (dist[v] < INF) ++num[dist[v]];\n    }\n\n    dist = bfs(graph, t, s);\n    vector<lint> rnum(N, 0);\n    for (int v = 0; v < N; ++v) {\n        if (dist[v] < INF) ++rnum[dist[v]];\n    }\n\n    lint ans = 0;\n    for (int d = 0; d <= D - 2; ++d) {\n        ans += num[d] * rnum[D - d - 2];\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct state {\n  int cost, use, pos;\n  state(int c, int u, int p) : cost(c), use(u), pos(p){}\n};\n\nvector<int> bfs(vector<vector<pair<int, bool>>>& G, int s, int t, int& shortestLen) {\n  vector<int> dist(G.size(), inf), d2cnt(G.size()+1);\n  dist[s] = 0;\n\n  queue<state> q;\n  q.emplace(0, 0, s);\n\n  while(!q.empty()) {\n    const state s = q.front(); q.pop();\n    d2cnt[s.cost]++;\n    for(auto& e: G[s.pos]) {\n      const int next = e.first;\n      if(dist[next] > s.cost + 1) {\n        dist[next] = s.cost + 1;\n        q.emplace(dist[next], 0, next);\n      }\n    }\n  }\n\n  shortestLen = dist[t];\n  return move(d2cnt);\n}\n\nint main() {\n\n  int N, M, s, t; cin >> N >> M >> s >> t; s--, t--;\n  vector<vector<pair<int, bool>>> G(N);\n  rep(i, M) {\n    int x, y; cin >> x >> y;\n    G[x-1].emplace_back(y-1, false);\n    G[y-1].emplace_back(x-1, false);\n  }\n\n  int shortestLen;\n  auto && d2cnt1 = bfs(G, s, t, shortestLen);\n  auto && d2cnt2 = bfs(G, t, s, shortestLen);\n\n  ll ans = 0;\n\n  rep(i, N) {\n    if(shortestLen-i-2 >= 0)\n      ans += (ll)d2cnt1[i] * d2cnt2[shortestLen-i-2];\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#define mk make_pair\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nbool vis[100000];\nint main(){\n  int n,m,s,t,x,y;\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  vector<int> v[100000];\n  set<pair<int,int> >ss;\n  r(i,m){\n    cin>>x>>y;\n    x--;y--;\n    ss.insert(mk(x,y));\n    ss.insert(mk(y,x));\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int s1[n],t1[n];\n  queue<pair<int,int> >q;\n  q.push(mk(s,0));\n  vis[s]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    s1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  memset(vis,0,sizeof(vis));\n  q.push(mk(t,0));\n  vis[t]=1;\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    t1[p.first]=p.second;\n    int pp=p.first;\n    r(i,v[pp].size()){\n      if(!vis[v[pp][i]]){\n    vis[v[pp][i]]=1;\n    q.push(mk(v[pp][i],p.second+1));\n      }\n    }\n  }\n  int po=s1[t],cc=0;\n  vector<int> d[100000];\n  r(i,n)d[s1[i]].push_back(i);\n  r(i,n){\n    int tt=po-t1[i]-2;\n    if(tt>-1)r(j,d[tt].size())\n      if(!ss.count(mk(d[tt][j],i))){\n       cc++;\n      }\n  }\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n\nusing type = long long;\nusing P = pair<type, type>;\nstruct Edge{\n    int to, cost;\n    Edge(int a, long long b){\n        to = a;\n        cost = b;\n    }\n};\n\nclass Dijkstra{\nprivate:\n    const type _INF = 100000000;\n    int V; // 頂点数\n    vector<type> d;\n    vector<int> prev;\n    vector<vector<Edge> > G;\npublic:\n    Dijkstra(int v){\n        V = v + 1;\n        d.resize(V);\n        G.resize(V);\n        prev.resize(V);\n    }\n\n    void shortest_path(int s){\n        priority_queue<P, vector<P>, greater<P>> que;\n        d.assign(V, _INF);\n        prev.assign(V, -1);\n        d[s] = 0;\n        que.push(P(0, s));\n        while(que.size()){\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(auto e : G[v]){\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    prev[e.to] = v;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n    }\n    \n    void add_path(int from, int to, type cost){\n        G[from].push_back(Edge(to, cost));\n    }\n\n    type get_cost(int t){\n        return d[t];\n    }\n\n    bool enable_move(int t){\n        return d[t] != _INF;\n    }\n  \n    vector<int> get_path(int t){\n        vector<int> path;\n        for(; t != -1; t = prev[t])\n            path.push_back(t);\n        reverse(path.begin(), path.end());\n        return path;\n    }\n};\n\nint main(){\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n\n  Dijkstra ds(n),dt(n);\n  vector<int> x(m),y(m); \n  for(int i=0;i<m;i++){\n    cin>>x[i]>>y[i];\n    ds.add_path(x[i],y[i],1);\n    ds.add_path(y[i],x[i],1);\n    dt.add_path(x[i],y[i],1);\n    dt.add_path(y[i],x[i],1);    \n  }\n  ds.shortest_path(s);\n  dt.shortest_path(t);\n\n  int ds_cost[300005]={0};\n  for(int i=1;i<n+1;i++){\n    if(ds.enable_move(i))ds_cost[ds.get_cost(i)]++;\n  }\n\n  int dt_cost[300005]={0};\n  for(int i=1;i<n+1;i++){\n    if(dt.enable_move(i))dt_cost[dt.get_cost(i)]++;\n  }\n\n  int min_cost=ds.get_cost(t);\n  ll ans=0;\n  for(int i=0;i<min_cost-1;i++){\n    ans+=(ds_cost[i]*dt_cost[min_cost-2-i]);\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1<<28;\n\ntypedef long long lli;\n\nstruct Edge {\n  int v, w;\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvector<int> bfs(int src, const Graph &g) {\n  const int n = g.size();\n  vector<int> cost(n, INF);\n  queue<int> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const int v = que.front();\n    que.pop();\n    for(int i = 0; i < g[v].size(); ++i) {\n      int nv = g[v][i].v;\n      if(cost[nv] != INF) continue;\n      cost[nv] = cost[v] + 1;\n      que.push(nv);\n    }\n  }\n  return cost;\n}\n\nint main() {\n  for(int N, M, s, t; cin >> N >> M >> s >> t; ) {\n    --s; --t;\n    Graph G(N);\n    for(int i = 0; i < M; ++i) {\n      int x, y; cin >> x >> y;\n      --x; --y;\n      G[x].push_back((Edge){y, 1});\n      G[y].push_back((Edge){x, 1});\n    }\n    vector<int> cs = bfs(s, G);\n    vector<int> ct = bfs(t, G);\n    int mini = cs[t];\n    sort(ct.begin(), ct.end());\n    lli res = 0;\n    for(int i = 0; i < N; ++i) {\n      if(cs[i] == INF) continue;\n      int target = mini - 2 - cs[i];\n      res += upper_bound(ct.begin(), ct.end(), target)\n        - lower_bound(ct.begin(), ct.end(), target);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nvector<int> bfs(vector<vector<int>> const& g, int s) {\n    vector<int> d(g.size(), INF);\n    d[s] = 0;\n    queue<int> que;\n    que.push(s);\n    while(!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for(auto to : g[v]) {\n            if(d[to] == INF) {\n                d[to] = d[v] + 1;\n                que.push(to);\n            }\n        }\n    }\n    return d;\n}\n\nint main() {\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n    s--; t--;\n    vector<vector<int>> g(N);\n    for(int i = 0; i < M; ++i) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    auto sd = bfs(g, s), td = bfs(g, t);\n    int const min_d = sd[t];\n    vector<int> cnt1(N), cnt2(N);\n    for(int i = 0; i < N; ++i) {\n        if(sd[i] != INF) {\n            cnt1[sd[i]]++;\n        }\n        if(td[i] != INF) {\n            cnt2[td[i]]++;\n        }\n    }\n    long long res = 0;\n    for(int i = 0; 0 <= min_d - i - 2; ++i) {\n        res += 1LL * cnt1[i] * cnt2[min_d - i - 2];\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\nvoid yesno(bool ok, string yes = \"Yes\", string no = \"No\") {\n    if (ok) {\n        cout << yes << endl;\n    } else {\n        cout << no << endl;\n    }\n}\n\nstruct edge {\n    ll to, cost;\n};\n\nint V;\nvector<edge> G[1000000];\nvector<ll> d1, d2;\n\nvoid addedge(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\nvoid dijkstra(int s, vector<ll> &distance) {\n    priority_queue<plglg, vector<plglg>, greater<plglg> > que;\n    distance = vector<ll>(V, inf);\n    distance[s] = 0;\n    que.push(plglg(0, s));\n\n    while (!que.empty()) {\n        plglg p = que.top();\n        que.pop();\n        ll v = p.second;\n        if (distance[v] < p.first) {\n            continue;\n        }\n        int len = G[v].size();\n        for (int i = 0; i < len; i++) {\n            edge e = G[v][i];\n            if (distance[e.to] > distance[v] + e.cost) {\n                distance[e.to] = distance[v] + e.cost;\n                que.push(plglg(distance[e.to], e.to));\n            }\n        }\n    }\n}\n\nll snum[200010];\nll tnum[200010];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, M, s, t;\n    cin >> N >> M >> s >> t;\n    V = N;\n    s--;\n    t--;\n    REP(i, 0, M) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        addedge(a, b, 1);\n        addedge(b, a, 1);\n    }\n    dijkstra(s, d1);\n    dijkstra(t, d2);\n    REP(i, 0, N) {\n        if (d1[i] != inf) {\n            snum[d1[i]]++;\n        }\n        if (d2[i] != inf) {\n            tnum[d2[i]]++;\n        }\n    }\n    ll ans = 0;\n    REP(i, 0, d1[t] - 1) {\n        ans += snum[i] * tnum[d1[t] - i - 2];\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nvoid dijkstra(int from, vector<int>* v, vector<int> &d){\n    queue<int> q;\n    q.push(from);\n    d[from] = 0;\n    while(!q.empty()){\n        int x = q.front();  q.pop();\n        for(int next : v[x]){\n            if(d[next] != 1<<30)    continue;\n            d[next] = d[x]+1;\n            q.push(next);\n        }\n    }\n}\n\ntypedef long long ll;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--, t--;\n    \n    vector<int> v[n];\n    while(m-- > 0){\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n\n    vector<int> a(n, 1<<30), b(n, 1<<30);\n    dijkstra(s, v, a);\n    dijkstra(t, v, b);\n\n    vector<int> cnta(n+1, 0), cntb(n+1, 0);\n    for(int i = 0; i < n; i++)  if(a[i] != 1<<30)   cnta[a[i]]++;\n    for(int i = 0; i < n; i++)  if(b[i] != 1<<30)   cntb[b[i]]++;\n\n    ll ans = 0;\n    for(int i = 0; i <= a[t]-2; i++){\n        ans += (ll)(cnta[i]) * cntb[a[t]-2-i];\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> pii;\n\nint bfs(int s, int t, const vector<vector<int> > &G, vector<int> &cnt){\n\tint n = G.size();\n\tvector<int> ds(n, -1);\n\tds[s] = 0;\n\tqueue<int> q;\n\tq.push(s);\n\tq.push(-1);\n\tint tm = 1;\n\twhile(q.size() > 1){\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tif(u == -1){\n\t\t\tq.push(-1);\n\t\t\t++tm;\n\t\t}\n\t\telse{\n\t\t\tfor(int v : G[u]){\n\t\t\t\tif(ds[v] == -1){\n\t\t\t\t\tds[v] = tm;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcnt.assign(n, 0);\n\tfor(int i = 0; i < n; ++i){\n\t\tif(ds[i] != -1){ ++cnt[ds[i]]; }\n\t}\n\n\treturn ds[t];\n}\n\nint main(){\n\tint n, m, s, t;\n\tscanf(\"%d%d%d%d\", &n, &m, &s, &t);\n\tvector<vector<int> > G(n + 1), rG, tmp;\n\tvector<int> cnt1, cnt2;\n\tfor(int i = 0; i < m; ++i){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\n\tint ds = bfs(s, t, G, cnt1);\n\tbfs(t, s, G, cnt2);\n\tLL ans = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(ds - i - 2 >= 0){\n\t\t\tans += (LL)cnt1[i] * cnt2[ds - i - 2];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n,m,s,t;\nvector<vector<ll>> edge;\n\nvoid dijk(ll s,vector<ll> &dp){\n    dp.resize(n);\n    for(auto &i:dp){i=E;}\n    dp[s]=0;\n    priority_queue<pll,vector<pll>,greater<pll>> Q;\n    Q.push({0,s});\n    while(!Q.empty()){\n        pll w=Q.top(); Q.pop();\n        if(dp[w.S]!=w.F){continue;}\n        for(auto &i:edge[w.S]){\n            if(dp[i]>dp[w.S]+1){\n                dp[i]=dp[w.S]+1;\n                Q.push({dp[i],i});\n            }\n        }\n    }\n}\n\n\nint main(){\n    cin>>n>>m>>s>>t;\n    edge.resize(n);\n    for(int i=0;i<m;i++){\n        ll u,v;\n        cin>>u>>v;\n        u--; v--;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    s--; t--;\n    vector<ll> dp,dp2;\n    dijk(s,dp);\n    dijk(t,dp2);\n    map<ll,ll> M,M2;\n    for(auto &i:dp){M[i]++;}\n    for(auto &i:dp2){M2[i]++;}\n    ll ans=0;\n    ll dist=dp[t];\n    for(int i=0;i<n;i++){\n        ans+=M[i]*M2[dist-i-2];\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)N;i++)\n#define p(s) cout<<(s)<<endl\n#define ck(n,a,b) ((a)<=(n)&&(n)<(b))\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\n\nint d[100010];//dist\nint fromS[100010];\nint fromT[100010];\nvector<int> edge[100100];\nint main() {\n\tint N,M,s,t;\n\tcin>>N>>M>>s>>t;\n\ts--;t--;\n\tREP(i,0,M){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--;y--;\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tqueue<int> q,qq;\n\tfromS[0]=1;fromT[0]=1;\n\tq.push(s);\n\tREP(i,0,N) d[i]=inf;\n\td[s]=0;\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\tfor(int next:edge[now]){\n\t\t\tif(d[next]<inf) continue;\n\t\t\tq.push(next);\n\t\t\td[next]=d[now]+1;\n\t\t\tfromS[d[next]]++;\n\t\t}\n\t\tif(d[t]<inf) break;\n\t}\n\n\tREP(i,0,N) d[i]=inf;\n\tqq.push(t);\n\td[t]=0;\n\twhile(!qq.empty()){\n\t\tint now=qq.front();qq.pop();\n\t\tfor(auto next:edge[now]){\n\t\t\tif(d[next]<inf) continue;\n\t\t\tqq.push(next);\n\t\t\td[next]=d[now]+1;\n\t\t\tfromT[d[next]]++;\n\t\t}\n\t\tif(d[s]<inf) break;\n\t}\n\tint sans=0;\n\tREP(i,2,d[s]+1){\n\t\tif(i==2){\n\t\t\tsans=1;\n\t\t\tcontinue;\n\t\t}\n\t\tsans+=fromS[i]*fromS[i-2];\n\t}\n\n\tint tans=0;\n\tREP(i,2,d[s]){\n\t\ttans+=fromT[i]*fromT[i-2];\n\t}\n\tif(d[s]>1)tans++;\n\tp(tans+sans-d[s]+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef pair<int,int> pp;\nvector<int> G[105000];\nint dis[105000];\nint S[105000];\n\nint main(void) {\n    int n,m,s,t;\n    scanf(\"%d%d%d%d\",&n,&m,&s,&t);\n    s--, t--;\n    memset(dis, 0x20, sizeof(dis));\n    for(int i=0; i<m; i++) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        x--, y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n\n    {\n        priority_queue<pp> q;\n        q.push(pp(-0, s));\n\n        while(!q.empty()) {\n            pp t = q.top(); q.pop();\n            int d = -t.fst, x = t.snd;\n\n            if(dis[x] != 0x20202020) continue;\n            dis[x] = d;\n            S[d]++;\n\n            for(int y : G[x])\n                if(dis[y] == 0x20202020)\n                    q.push(pp(-(d+1), y));\n        }\n    }\n\n    int old = dis[t];\n    memset(dis, 0x20, sizeof(dis));\n\n    long long int res=0;\n    {\n        priority_queue<pp> q;\n        q.push(pp(-0, t));\n\n        while(!q.empty()) {\n            pp t = q.top(); q.pop();\n            int d = -t.fst, x = t.snd;\n\n            if(dis[x] != 0x20202020) continue;\n            dis[x] = d;\n\n            if(old-2-d >= 0)\n                res += S[old-2-d];\n\n            for(int y : G[x])\n                if(dis[y] == 0x20202020)\n                    q.push(pp(-(d+1), y));\n        }\n    }\n\n    printf(\"%lld\\n\", res);\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define make make_pair\n#define N 100002\nusing namespace std;\ntypedef pair<int,int> P;\nvoid bfs(int,int);\nint n,m,s,t,a,b,cost[2][N],mincost,ans;\nvector<int> c[N];\nbool visited[N];\n\nint main(){\n  cin>>n>>m>>s>>t;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    c[a].push_back(b);\n    c[b].push_back(a);\n  }\n  bfs(0,s);\n  bfs(1,t);\n  for(int i=0;i<=mincost-2;i++) ans+=cost[0][i]*cost[1][mincost-2-i];\n  cout<<ans<<endl;\n  return 0;\n}\n\nvoid bfs(int index,int start){\n  queue<P> q;\n  for(int i=1;i<=n;i++) visited[i]=false;\n  q.push(make(0,start));\n  cost[index][0]++;\n  while(!q.empty()){\n    P k=q.front(); q.pop();\n    int cos=k.first,u=k.second;\n    if(visited[u]) continue;\n    visited[u]=true;\n    for(int i=0;i<(int)c[u].size();i++){\n      if(visited[c[u][i]]) continue;\n      cost[index][cos+1]++;\n      if(!index&&c[u][i]==t) mincost=cos+1;\n      q.push(make(cos+1,c[u][i]));\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;const int M=1<<21;vector<int>x[M];long long d[M],n,m,a,b,s,t,q,w,i,V[M],W[M],S;queue<int>Q;void B(int P){memset(d,1,M);d[P]=0;Q.push(P);while(Q.size()){w=Q.front();Q.pop();for(i=0;i<x[w].size();i++){if(d[x[w][i]]>M){d[x[w][i]]=d[w]+1;Q.push(x[w][i]);}}}}main(){cin>>n>>m>>s>>t;for(i=0;i<m;i++){cin>>a>>b;x[a].push_back(b);x[b].push_back(a);}B(s);q=d[t];for(i=1;i<=n;i++)if(d[i]<M)V[d[i]]++;B(t);for(i=1;i<=n;i++)if(d[i]<M)W[d[i]]++;for(i=0;i<q;i++)S+=V[i]*W[q-i-2];cout<<S<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int INF = 0x3f3f3f3f;\n\nint N, M, S, T;\n\nint shortest_path(vector<vector<int>> G){\n    vector<int> d(N, -1);\n    \n    queue<int> que;\n    que.push(S);\n    d[S] = 0;\n    \n    while(!que.empty()){\n        auto u = que.front(); que.pop();\n        for(auto v: G[u]){\n            if(d[v] == -1){\n                d[v] = d[u] + 1;\n                if(v == T)\n                    return d[v];\n                que.push(v);\n            }\n        }\n    }\n    return -1;\n}\n\n\nvector<ll> bfs(vector<vector<int>> G, int s){\n    vector<int> d(N, -1);\n    \n    queue<int> que;\n    que.push(s);\n    d[s] = 0;\n    \n    while(!que.empty()){\n        auto u = que.front(); que.pop();\n        for(auto v: G[u]){\n            if(d[v] == -1){\n                d[v] = d[u] + 1;\n                que.push(v);\n            }\n        }\n    }\n    \n    vector<ll> res(N);\n    for(int i=0; i<N; i++)\n        res[d[i]]++;\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    cin >> N >> M >> S >> T; S--; T--;\n    \n    vector<vector<int>> G(N);\n    for(int i=0; i<M; i++){\n        int x, y; cin >> x >> y; x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    \n    int sp = shortest_path(G);\n    auto st = bfs(G, S);\n    auto tt = bfs(G, T);\n    \n    ll ans = 0;\n    for(int i=0; i<=sp-2; i++)\n        ans += st[i] * tt[sp-2-i];\n    \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll c[2][100001],d[100001],INF=1<<29;\nvector<ll> v[100001];\nll n,m,s,t;\n\nvoid bfs(int s,int k) {\n  fill(d,d+n+1,INF);\n  d[s]=0;\n  c[k][0]++;\n  queue<ll> que;\n  que.push(s);\n  while(!que.empty()) {\n    ll x=que.front();que.pop();\n    for(int i=0; i<v[x].size(); i++) {\n      ll y=v[x][i];\n      if(d[y]<d[x]+1) continue;\n      d[y]=d[x]+1;\n      c[k][d[y]]++;\n      que.push(y);\n    }\n  }\n}\n  \n\nint main() {\n  cin >> n >> m >> s >> t;\n  for(int i=0; i<m; i++) {\n    ll x,y;\n    cin >> x >> y;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  memset(c,0,sizeof(c));\n  bfs(s,0);\n  bfs(t,1);\n  ll z=d[s],ans=0;\n  for(int i=0; i<z-1; i++) ans+=c[0][i]*c[1][z-i-2];\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, m, s, t, x, y, ds[100100], dt[100100], dsn[100100], dtn[100100];\nvi e[100100];\n\nvoid dijkstra(int *d, int s) {\n\tpriority_queue<pii, vector<pii>, greater<pii> > que;\n\tfill(d, d+n, inf), d[s] = 0;\n\tque.push({0,s});\n\twhile(!que.empty()) {\n\t\tpii p = que.top(); que.pop();\n\t\tint v = p.se, dis = p.fi;\n\t\tif (d[v] < dis) continue;\n\t\tfor (int i = 0; i < e[v].size(); ++i) {\n\t\t\tint u = e[v][i];\n\t\t\tif (d[u] > d[v] + 1) {\n\t\t\t\td[u] = d[v] + 1;\n\t\t\t\tque.push({d[u],u});\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin >> n >> m >> s >> t;\n\ts--, t--;\n\trep(i,m) {\n\t\tcin >> x >> y;\n\t\tx--, y--;\n\t\te[x].pb(y), e[y].pb(x);\n\t}\n\tdijkstra(ds,s), dijkstra(dt,t);\n\trep(i,n) {\n\t\tif (ds[i]!=inf) dsn[ds[i]]++;\n\t\tif (dt[i]!=inf) dtn[dt[i]]++;\n\t}\n\tint m = ds[t]-2, res = 0;\n\trept(i,m) res += dsn[i]*dtn[m-i];\n\tcout << res << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\n\nint main()\n{\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n    s--, t--;\n    Graph g(N);\n    for (int i = 0; i < M; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        g.addEdge(x, y);\n        g.addEdge(y, x);\n    }\n    vector<bool> used(N, false);\n    using P = pair<int, int>;\n    queue<P> q;\n    used[s] = true;\n    q.push(make_pair(s, 0));\n    constexpr int INF = 1 << 30;\n    vector<int> dist(N, INF);\n    while (not q.empty()) {\n        const P p = q.front();\n        dist[p.first] = p.second;\n        q.pop();\n        for (const int to : g.edge[p.first]) {\n            if (not used[to]) {\n                used[to] = true;\n                q.push(make_pair(to, p.second + 1));\n            }\n        }\n    }\n    while (not q.empty()) {\n        q.pop();\n    }\n\n    fill(used.begin(), used.end(), false);\n    used[t] = true;\n    q.push(make_pair(t, 0));\n    vector<int> back_dist(N, INF);\n    while (not q.empty()) {\n        const P p = q.front();\n        back_dist[p.first] = p.second;\n        q.pop();\n        for (const int to : g.edge[p.first]) {\n            if (not used[to]) {\n                used[to] = true;\n                q.push(make_pair(to, p.second + 1));\n            }\n        }\n    }\n    const int D = dist[t] - 2;\n\n    vector<ll> num(D + 1, 0);\n    vector<ll> back_num(D + 1, 0);\n    for (int i = 0; i < N; i++) {\n        if (dist[i] <= D) {\n            num[dist[i]]++;\n        }\n        if (back_dist[i] <= D) {\n            back_num[back_dist[i]]++;\n        }\n    }\n\n    ll sum = 0;\n    for (int i = 0; i <= D; i++) {\n        sum += num[i] * back_num[D - i];\n    }\n    cout << sum << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nint N, M, K, H, W, L, R;\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> L >> R;\n\tL--;\n\tR--;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> H >> W;\n\t\tH--;\n\t\tW--;\n\t\tedge[H].push_back(W);\n\t\tedge[W].push_back(H);\n\t}\n\tvector<int>depthL(N, MOD);\n\tvector<int>depthR(N, MOD);\n\tCalculate_Depth(edge, depthL, L);\n\tCalculate_Depth(edge, depthR, R);\n\t//cout << depthL[R] << endl;\n\tif (depthL[R] == 1) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tlong long int ans = 0;\n\tvector<int>Lnum(N);\n\tvector<int>Rnum(N);\n\tfor (auto i : depthL)if (i != MOD)Lnum[i]++;\n\tfor (auto i : depthR)if (i != MOD)Rnum[i]++;\n\tfor (int i = 0; i < depthL[R] - 1; i++) {\n\t\tans += 1LL * Lnum[i] * Rnum[depthL[R] - i - 2];\n\t\t//cout << Lnum[i] << \" \" << Rnum[depthL[R] - i - 2] << endl;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define lint long long\n#define P pair<int, int>\n#define LLP pair<long long, long long>\n#define REP(i, x, n) for(int i = (x), i##_len = (int)(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = (int)(n) ; i < i##_len ; ++i)\n#define reps(i, n) for(int i = 1, i##_len = (int)(n) ; i <= i##_len ; ++i)\n#define rrep(i, n) for(int i = (int)(n) - 1 ; i >= 0 ; --i)\n#define rreps(i, n) for(int i = (int)(n) ; i > 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n\nconst int IINF = (1 << 30) - 1;\nconst long long LLINF = 1LL << 61;\nconst long long MOD = 1000000007LL;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\ntemplate<typename T>\nbool chmin(T &_a, T _b){\n    if(_a > _b){\n        _a = _b;\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    vector<int> st(2);\n    cin >> n >> m >> st[0] >> st[1];\n    rep(i, 2){\n        --st[i];\n    }\n\n    vector< vector<int> > g(n);\n    rep(i, m){\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n\n    vector< vector<int> > cost(2, vector<int>(n, IINF));\n    rep(i, 2){\n        queue< P > que;\n        que.push({st[i], 0});\n        while(!que.empty()){\n            P now = que.front();\n            que.pop();\n            if(!chmin(cost[i][now.first], now.second)){\n                continue;\n            }\n            for(auto e : g[now.first]){\n                if(cost[i][e] > now.second + 1){\n                    que.push({e, now.second + 1});\n                }\n            }\n        }\n    }\n\n    int d = cost[0][st[1]];\n\n    vector< vector<lint> > cnt(2, vector<lint>(d + 1, 0LL));\n    rep(i, 2){\n        rep(j, n){\n            if(cost[i][j] <= d){\n                ++cnt[i][cost[i][j]];\n            }\n        }\n    }\n\n    lint ans = 0;\n    rep(i, d - 1){\n        ans += cnt[0][i] * cnt[1][d - i - 2];\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n\ntemplate<class Type>\nType solve(Type res = Type()){\n    int N,M,s,t; cin >> N >> M >> s >> t;\n    s--; t--;\n    vector<vector<int>> G(N);\n    for(int i = 0; i < M;i++){\n        int u,v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    vector<int> dists(N,INF),distt(N,INF);\n    \n    auto dijkstra = [&](int from,vector<int>& dist){\n        queue<ll> q;\n        dist[from] = 0;\n        q.push(from);\n        while(q.size()){\n            int u = q.front(); q.pop();\n            for(auto v:G[u]){\n                if(dist[v] > dist[u] + 1){\n                    dist[v] = dist[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n    };\n    \n    dijkstra(s,dists);\n    dijkstra(t,distt);\n    \n    map<int,ll> L,R;\n    for(int i = 0; i < N;i++){\n        if(dists[i] != INF) L[dists[i]]++;\n        if(distt[i] != INF) R[distt[i]]++;\n    }\n    int D = dists[t];\n    for(int i = 0; i <= D;i++){\n       //if(D-i-2 < 0) continue;\n        res += L[i] * R[D-i-2];\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    //test();\n    //solve<ll>();\n    cout << fixed << setprecision(15) << solve<ll>() << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\nusing ll=long long;\nconst int INF=1e9;\n\nvoid make_dist(int v,vector<int> &d,const Graph &g){\n    d[v]=0;\n    queue<int> que;\n    que.push(v);\n    while(!que.empty()){\n        int ver=que.front(); que.pop();\n        for(int i=0;i<g[ver].size();i++){\n            int to=g[ver][i];\n            if(d[ver]+1<d[to]){\n                d[to]=d[ver]+1;\n                que.push(to);\n            }\n        }\n    }\n}\nint main(){\n    int n,m,s,t;\n    cin>>n>>m>>s>>t;\n    s--,t--;\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<int> ds(n,INF);\n    make_dist(s,ds,g);\n    vector<int> dt(n,INF);\n    make_dist(t,dt,g);\n\n    map<int,ll> cnts;\n    map<int,ll> cntt;\n    for(int i=0;i<n;i++){\n        cnts[ds[i]]++;\n        cntt[dt[i]]++;\n    }\n\n    int dist=ds[t];\n    ll res=0;\n    for(auto &e:cnts){\n        res+=e.second*cntt[dist-e.first-2];\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#define INF (1 << 23)\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, s, t, u, v;\n\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &s); s--;\n\tscanf(\"%d\", &t); t--;\n\n\tvector<vector<int> > G(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &u);\n\t\tscanf(\"%d\", &v);\n\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\n\tvector<int> d1(N, INF); d1[s] = 0;\n\tvector<int> d2(N, INF); d2[t] = 0;\n\n\tqueue<int> que;\n\n\tque.push(s);\n\n\twhile (!que.empty())\n\t{\n\t\tint node = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tif (d1[G[node][i]] == INF)\n\t\t\t{\n\t\t\t\td1[G[node][i]] = d1[node] + 1; que.push(G[node][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tque.push(t);\n\n\twhile (!que.empty())\n\t{\n\t\tint node = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tif (d2[G[node][i]] == INF)\n\t\t\t{\n\t\t\t\td2[G[node][i]] = d2[node] + 1; que.push(G[node][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint shortest = d1[t];\n\n\tvector<int> r1(N, 0); for (int i = 0; i < N; i++) { if (d1[i] != INF) { r1[d1[i]]++; } }\n\tvector<int> r2(N, 0); for (int i = 0; i < N; i++) { if (d2[i] != INF) { r2[d2[i]]++; } }\n\n\tlong long ret = 0;\n\n\tfor (int i = 0; i < shortest; i++)\n\t{\n\t\tret += (long long)(r1[i] * r2[shortest - i - 1]);\n\t}\n\t\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d1[100000], d2[100000];\nint c1[100000], c2[100000];\nvector<int>E[100000];\nvoid bfs(int*d,int*c, int s) {\n\tqueue<int>que;\n\td[s] = 0; que.push(s);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tc[d[p]]++;\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == -1) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, s, t; scanf(\"%d%d%d%d\", &n, &m, &s, &t); s--; t--;\n\trep(i, m) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y); x--; y--;\n\t\tE[x].push_back(y); E[y].push_back(x);\n\t}\n\tmemset(d1, -1, sizeof(d1));\n\tmemset(d2, -1, sizeof(d2));\n\tbfs(d1, c1, s); bfs(d2, c2, t);\n\tll ans = 0;\n\tfor (int i = 0; i <= d1[t] - 2; i++) {\n\t\tans += (ll)c1[i] * c2[d1[t] - 2 - i];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\n\n#define MAX 100009\nusing namespace std;\n\ntypedef struct Node\n{\n\tint n;\n\tvector<int>e;\n}Node;\n\nNode G[MAX];\nint N,M,s,t,d,a,b;\nlong long res=0;\nmap<int,long long>SC,GC;\nvoid dijcstra(int s,int g,map<int,long long>&X)\n{\n\tint C[MAX];\n\tmemset(C,0x7f,sizeof(C));\n\tP tmp(0,s);\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(tmp.first>=C[tmp.second])\n\t\t\tcontinue;\n\t\tC[tmp.second]=tmp.first;\n\t\tfor(int i=0;i<G[tmp.second].e.size();i++)\n\t\t{\n\t\t\tint nn=G[tmp.second].e[i];\n\t\t\tif(C[nn]>tmp.first+1)\n\t\t\t{\n\t\t\t\tQ.push(make_pair(tmp.first+1,nn));\n\t\t\t}\n\t\t}\n\t}\n\tif(g==t)d=C[t];\n\tfor(int i=0;i<N;i++)\n\t\tX[C[i]]++;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&M,&s,&t);\n\ts--;t--;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--;y--;\n\t\tG[x].e.push_back(y);\n\t\tG[y].e.push_back(x);\n\t}\n\tdijcstra(s,t,SC);\n\tdijcstra(t,s,GC);\n\tfor(int i=0;i<=d;i++)\n\t{\n\t\tif(d-i-2>=0)\n\t\t\tres+=SC[i]*GC[d-i-2];\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nlong long cnt[2][100005];\n\nclass Edge{\n    public:\n        int to, cost;\n        Edge(int to, int cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n    public:\n        int dis;\n        bool isUsed;\n        Node(){\n            this->dis = INF;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\nlong long dist;\n\nvoid dijkstra(AdjList g, int start, int n, int f, int t){\n    vector<Node> node(n);\n    priority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n    q.push(make_pair(0, start));\n    node[start].dis = 0;\n\n    pair<int, int> u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second;\n        node[current].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            if(node[next].isUsed == 0){\n                if(node[next].dis > node[current].dis + g[current][i].cost){\n                    node[next].dis = node[current].dis + g[current][i].cost;\n                    q.push(make_pair(node[next].dis, next));\n                }\n            }\n        }\n    }\n    rep(i,n){\n        if(node[i].dis != INF) cnt[f][node[i].dis]++;\n    }\n    if(not f) dist = node[t].dis;\n}\n\nint main(){\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--; t--;\n\n    AdjList g(n);\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        g[a].emplace_back(Edge{b,1});\n        g[b].emplace_back(Edge{a,1});\n    }\n    dijkstra(g,s,n,0,t);\n    dijkstra(g,s,n,1,t);\n\n    long long ans = 0;\n    rep(i,dist - 1) ans+=static_cast<long long>(cnt[0][i] * cnt[1][dist - i - 2]);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing graph = vector<vector<int>>;\n\nconst int INF = 1e9;\n\nvector<int> bfs(int s, const graph& G) {\n\tvector<int> d(G.size(), INF);\n\tqueue<int> q;\n\tq.push(s);\n\td[s] = 0;\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (auto to : G[v]) if (d[to] == INF) {\n\t\t\tq.push(to);\n\t\t\td[to] = d[v] + 1;\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N, M, s, t;\n\tcin >> N >> M >> s >> t; --s, --t;\n\tgraph G(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v; --u, --v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tauto d1 = bfs(s, G);\n\tauto d2 = bfs(t, G);\n\tint dist = d1[t];\n\tsort(d1.begin(), d1.end());\n\tsort(d2.begin(), d2.end());\n\tll res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (d1[i] <= dist - 2) {\n\t\t\tres += upper_bound(d2.begin(), d2.end(), dist - 2 - d1[i])\n\t\t\t\t - lower_bound(d2.begin(), d2.end(), dist - 2 - d1[i]);\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nconst int MAX_N = 100005;\n\nint sdir[MAX_N];\nint tdir[MAX_N];\nint spt[MAX_N];\nint tpt[MAX_N];\nmap<P,int> mp;\nvector<int> G[MAX_N];\n\nvoid bfs(int u,int* flag)\n{\n    queue<P> que;\n    que.push(P(u,0));\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,G[p.first].size()){\n            if(flag[G[p.first][i]] > p.second + 1){\n                flag[G[p.first][i]] = p.second + 1;\n                que.push(P(G[p.first][i],flag[G[p.first][i]]));\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int n,m,s,t;\n\tscanf(\"%d%d%d%d\",&n,&m,&s,&t);\n\trep(i,m){\n\t\tint x,y;\n        scanf(\"%d%d\",&x,&y);\n        G[x-1].push_back(y-1);\n        G[y-1].push_back(x-1);\n        mp[P(x-1,y-1)]++;\n        mp[P(y-1,x-1)]++;\n\t}\n    fill(sdir,sdir+n,INF);\n    fill(tdir,tdir+n,INF);\n    bfs(s-1,sdir);\n    sdir[s-1] = 0;\n    bfs(t-1,tdir);\n    tdir[t-1] = 0;\n    rep(i,n){\n        spt[sdir[i]]++;\n        tpt[tdir[i]]++;\n    }\n    int min_dir = sdir[t-1];\n    ll res = 0;\n    rep(i,min_dir-1){\n        res += spt[i] * tpt[min_dir - i - 2];\n    }\n    printf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m,s,t,ds[100000],dt[100000],ans = 0,scnt[100000] = {},tcnt[100000] = {};\n\tvector<int> G[100000];\n\tqueue<int> que;\n\tcin >> n >> m >> s >> t; s--;t--;\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b;\n\t\tcin >> a >> b; a--;b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tds[i] = -1;\n\t\tdt[i] = -1;\n\t}\n\tds[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front();que.pop();\n\t\tfor(int to : G[v]){\n\t\t\tif(ds[to] == -1){\n\t\t\t\tds[to] = ds[v] + 1;\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tdt[t] = 0;\n\tque.push(t);\n\twhile(!que.empty()){\n\t\tint v = que.front();que.pop();\n\t\tfor(int to : G[v]){\n\t\t\tif(dt[to] == -1){\n\t\t\t\tdt[to] = dt[v] + 1;\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(ds[i] >= 0) scnt[ds[i]]++;\n\t\tif(dt[i] >= 0) tcnt[dt[i]]++;\n\t}\n\tfor(int i = 0;i < ds[t] - 1;i++){\n\t\tans += scnt[i] * tcnt[ds[t] - i - 2];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\ntypedef pair<int, int> State;\nint n;\nvvi cost;\n\nvoid dijkstra(int s, vi& dist){\n    dist = vi(n, inf);\n\n    priority_queue<State, vector<State>> q;\n    dist[s] = 0;\n    q.push(mp(0, s));\n\n    while(!q.empty()){\n        int cur_cost = q.top().F;\n        int cur_v = q.top().S;\n        q.pop();\n\n        rep(u, n){\n            if(cur_cost + cost[cur_v][u] < dist[u]){\n                dist[u] = cur_cost + cost[cur_v][u];\n                q.push(mp(dist[u], u));\n            }\n        }\n    }\n}\n\nint main(void){\n    for(int m, s, t, res; cin >> n >> m >> s >> t; cout << res << endl){\n        res = 0;\n\n        s--, t--;\n        cost = vvi(n, vi(n, inf));\n\n        rep(i, m){\n            int x, y; cin >> x >> y;\n            x--, y--;\n            \n            cost[x][y] = cost[y][x] = 1;\n        }\n\n        vi dist_fromS, dist_fromT;\n        dijkstra(s, dist_fromS);\n        dijkstra(t, dist_fromT);\n\n        map<int, int> distCnt_fromS, distCnt_fromT;\n        rep(u, n){\n            distCnt_fromS[dist_fromS[u]]++;\n            distCnt_fromT[dist_fromT[u]]++;\n        }\n\n        int path_len = dist_fromS[t];\n\n        rep(i, path_len + 1){\n            res += distCnt_fromS[i] * distCnt_fromT[path_len - i - 2];\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint N, M, S, T, X, Y;\nvector<int> E[100010];\nbool visited[100010];\n\nint wfs(int *count, int s, int t) {\n  REP(i, 0, N) visited[i] = false;\n  REP(i, 0, N) count[i] = 0;\n  queue<pii> q;\n  q.push(pii(0, s));\n  int dist;\n  REP(i, 0, N)\n  while(q.size()) {\n    int d = q.front().first, v = q.front().second;\n    q.pop();\n    if(visited[v]) continue;\n    visited[v] = true;\n    count[d]++;\n    if(v == t) dist = d;\n    REP(i, 0, E[v].size()) if(!visited[E[v][i]]) q.push(pii(d + 1, E[v][i]));\n  }\n\n  return dist;\n}\n\nint main(void) {\n  cin >> N >> M >> S >> T; S--; T--;\n  REP(i, 0, M) {\n    cin >> X >> Y;\n    E[X - 1].push_back(Y - 1);\n    E[Y - 1].push_back(X - 1);\n  }\n\n  int scount[300010], tcount[300010];\n  int sdist = wfs(scount, S, T);\n  int tdist = wfs(tcount, T, S);\n\n  ll ans = 0;\n  REP(i, 0, sdist - 1) ans += scount[i] * tcount[tdist - i - 2];\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nstruct Edge{ int dst, cost; };\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nconst int INF = 1000000000;\nvoid add_edge(Graph& G, int a, int b) {\n    G[a].push_back({b, 1});\n    G[b].push_back({a, 1});\n}\nvector<int> SPFA(const Graph& G, int s) {\n    int n = G.size();\n    vector<int> dist(n, INF);\n    vector<bool> inque(n);\n    queue<int> que;\n\n    dist[s] = 0;\n    que.push(s);\n    inque[s] = true;\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        inque[v] = false;\n        for(Edge e : G[v]) {\n            if(dist[e.dst] > dist[v] + e.cost) {\n                dist[e.dst] = dist[v] + e.cost;\n                if(!inque[e.dst]) {\n                    que.push(e.dst);\n                    inque[e.dst] = true;\n                }\n            }\n        }\n    }\n    return dist;\n}\nint main(){\n    iostream_init();\n    int N, M, s, t;\n    while(cin >> N >> M >> s >> t) {\n        s--; t--;\n        Graph G(N);\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            add_edge(G, a, b);\n        }\n\n        vector<int> ds = SPFA(G, s);\n        vector<int> dt = SPFA(G, t);\n        vector<int> cnt(N);\n        for(int x : dt) cnt[x]++;\n        int D = ds[t];\n        long long ans = 0;\n        REP(i, N) {\n            // ds[i] + 1 + E == D-1\n            int E = D - ds[i] - 2;\n            ans += cnt[E];\n        }\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n\nusing type = long long;\nusing P = pair<type, type>;\nstruct Edge{\n    int to, cost;\n    Edge(int a, long long b){\n        to = a;\n        cost = b;\n    }\n};\n\nclass Dijkstra{\nprivate:\n    const type _INF = 100000000;\n    int V; // 頂点数\n    vector<type> d;\n    vector<int> prev;\n    vector<vector<Edge> > G;\npublic:\n    Dijkstra(int v){\n        V = v + 1;\n        d.resize(V);\n        G.resize(V);\n        prev.resize(V);\n    }\n\n    void shortest_path(int s){\n        priority_queue<P, vector<P>, greater<P>> que;\n        d.assign(V, _INF);\n        prev.assign(V, -1);\n        d[s] = 0;\n        que.push(P(0, s));\n        while(que.size()){\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(auto e : G[v]){\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    prev[e.to] = v;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n    }\n    \n    void add_path(int from, int to, type cost){\n        G[from].push_back(Edge(to, cost));\n    }\n\n    type get_cost(int t){\n        return d[t];\n    }\n\n    bool enable_move(int t){\n        return d[t] != _INF;\n    }\n  \n    vector<int> get_path(int t){\n        vector<int> path;\n        for(; t != -1; t = prev[t])\n            path.push_back(t);\n        reverse(path.begin(), path.end());\n        return path;\n    }\n};\n\nint main(){\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n\n  Dijkstra ds(n),dt(n);\n  vector<int> x(n),y(n); \n  for(int i=0;i<m;i++){\n    cin>>x[i]>>y[i];\n    ds.add_path(x[i],y[i],1);\n    ds.add_path(y[i],x[i],1);\n    dt.add_path(x[i],y[i],1);\n    dt.add_path(y[i],x[i],1);    \n  }\n  ds.shortest_path(s);\n  dt.shortest_path(t);\n\n  int ds_cost[300005]={0};\n  for(int i=1;i<n+1;i++){\n    if(ds.enable_move(i))ds_cost[ds.get_cost(i)]++;\n  }\n\n  int dt_cost[300005]={0};\n  for(int i=1;i<n+1;i++){\n    if(dt.enable_move(i))dt_cost[dt.get_cost(i)]++;\n  }\n\n  int min_cost=ds.get_cost(t);\n  ll ans=0;\n  for(int i=0;i<min_cost-1;i++){\n    ans+=(ds_cost[i]*dt_cost[min_cost-2-i]);\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n#define INF 10000000000000\nstruct edge\n{\n    long long to, cost;\n};\nstruct graph\n{\n    int V;                  //頂点数\n    vector<vector<edge>> G; //頂点sからの最短距離\n    vector<long long> d;\n    graph(int n)\n    {\n        init(n);\n    }\n    void init(int n)\n    {\n        V = n;\n        G.resize(V);\n        d.resize(V);\n        for (int i = 0; i < V; i++)\n        {\n            d[i] = INF;\n        }\n    }\n    void add_edge(int s, int t, long long cost)\n    {\n        edge e;\n        e.to = t;      //行き先\n        e.cost = cost; //cost\n        G[s].push_back(e);\n    }\n    void dijkstra(int s)\n    {\n        for (int i = 0; i < V; i++)\n        {\n            d[i] = INF;\n        }\n        d[s] = 0;\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push(P(0, s));\n        while (!que.empty())\n        {\n            P p = que.top();\n            que.pop();\n            long long v = p.second;\n            if (d[v] < p.first)\n                continue;\n            for (auto e : G[v])\n            {\n                if (d[e.to] > d[v] + e.cost)\n                {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n    }\n};\n\nint main()\n{\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n    s--, t--;\n    graph G1(N);\n    graph G2(N);\n    for (int i = 0; i < M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        G1.add_edge(x, y, 1);\n        G2.add_edge(x, y, 1);\n        G1.add_edge(y, x, 1);\n        G2.add_edge(y, x, 1);\n    }\n    G1.dijkstra(s);\n    G2.dijkstra(t);\n    map<long long, long long> g1, g2;\n    for (int i = 0; i < N; i++)\n    {\n        g1[G1.d[i]]++;\n        g2[G2.d[i]]++;\n    }\n    long long ans = 0;\n    int dis = G1.d[t];\n    for (int i = 0; i <= dis - 2; i++)\n    {\n        ans += g1[i] * g2[dis - i - 2];\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    --s;\n    --t;\n    vector<vector<int>> edge(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    vector<int> ds(n, -1);\n    vector<long long> cs(n, 0);\n    queue<int> q;\n    q.push(s);\n    ds[s] = 0;\n    ++cs[0];\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        for (int i : edge[p]) {\n            if (ds[i] == -1) {\n                ds[i] = ds[p] + 1;\n                ++cs[ds[i]];\n                q.push(i);\n            }\n        }\n    }\n    vector<int> dt(n, -1);\n    vector<long long> ct(n, 0);\n    q.push(t);\n    dt[t] = 0;\n    ++ct[0];\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        for (int i : edge[p]) {\n            if (dt[i] == -1) {\n                dt[i] = dt[p] + 1;\n                ++ct[dt[i]];\n                q.push(i);\n            }\n        }\n    }\n    int l = ds[t] - 1;\n    long long ans = 0;\n    for (int i = 0; i <= l; ++i) {\n        ans += cs[i] * ct[l - i - 1];\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<vector>\n#include<utility>\n#include<queue>\n#define MAX 100009\nusing namespace std;\ntypedef pair<int,int> P;\n\ntypedef struct Node\n{\n\tint n;\n\tvector<int>e;\n}Node;\n\nNode G[MAX];\nint SC[MAX], GC[MAX],N,M,s,t;\n\nint dijcstra(int s,int g)\n{\n\tint C[MAX];\n\tmemset(C,0x7f,sizeof(C));\n\tP tmp(0,s);\n\tpriority_queue<P>Q;\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(tmp.second==g)\n\t\t\treturn tmp.first;\n\t\tif(tmp.first>=C[tmp.second])\n\t\t\tcontinue;\n\t\tC[tmp.second]=tmp.first;\n\t\tfor(int i=0;i<G[tmp.second].e.size();i++)\n\t\t{\n\t\t\tint nn=G[tmp.second].e[i];\n\t\t\tif(C[nn]>tmp.first+1)\n\t\t\t{\n\t\t\t\tQ.push(make_pair(tmp.first+1,nn));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&M,&s,&t);\n\ts--;t--;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--;y--;\n\t\tG[x].e.push_back(y);\n\t\tG[y].e.push_back(x);\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tSC[i]=dijcstra(s,i);\n\t\t\tGC[i]=dijcstra(t,i);\n\t\t}\n\t}\n\tint mc=SC[t],res=0;\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(SC[i]==-1||GC[j]==-1)continue;\n\t\t\tif(i!=t&&j!=s&&i!=j&&SC[i]+GC[j]+1==mc-1)\n\t\t\t\tres++;\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nint INF = 1000000000;\nvector<int> dijkstra(int s, int v, vector< vector< pair<int,int> > > G){\n  //s: テ・ツァツ凝ァツつケ, v: テゥツ?づァツつケテヲツ閉ー, G: テゥツ堋」テヲツ篠・テ」ツδェテ」ツつケテ」ツδ暗」ツ??」ツつウテ」ツつケテ」ツδ暗」ツ?ッテヲツュツ」テ」ツ?ァテ・ツ?・テ」ツつ古」ツ?ヲテ」ツ?甘」ツ??\n  priority_queue< pair<int, int> > wait;\n  vector<int> result(v, INF);\n  result[s] = 0;\n  wait.push(make_pair(0, s));\n  while(!wait.empty()){\n    int nowpoint = wait.top().second;\n    int nowcost = wait.top().first;\n    wait.pop();\n    if(nowcost <= result[nowpoint]){\n      for(int i = 0; i < G[nowpoint].size(); ++i){\n\tint nextpoint = G[nowpoint][i].second;\n\tint nextcost = -nowcost + G[nowpoint][i].first;\n\tif(nextcost < result[nextpoint]){\n\t  wait.push(make_pair(-nextcost, nextpoint));\n\t  result[nextpoint] = nextcost;\n\t}\n      }\n    }\n  }\n  return result;\n}\n\nint count(vector< vector<pii> > &G, int s, int t, int N){\n  vector<int> r1 = dijkstra(s,N,G), r2 = dijkstra(t,N,G);\n  int l = r1[t], d1[l+1], d2[l+1];\n  fill(d1,d1+l+1,0);\n  fill(d2,d2+l+1,0);\n  for(int i = 0; i < N; ++i){\n    if(r1[i] <= l) ++d1[r1[i]];\n    if(r2[i] <= l) ++d2[r2[i]];\n  }\n  int ret = 0;\n  for(int i = 0; i < l-1; ++i){\n    ret += d1[i]*d2[l-2-i];\n  }\n  return ret;\n}\n\nint main(){\n  int N, M, s, t, x, y;\n  cin >> N >> M >> s >> t;\n  --s;--t;\n  vector< vector<pii> > G(N);\n  for(int i = 0; i < M; ++i){\n    cin >> x >> y;\n    --x;--y;\n    G[x].push_back(make_pair(1,y));\n    G[y].push_back(make_pair(1,x));\n  }\n  cout << count(G,s,t,N) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\n\nvector<ll>path[101010];\nll depth[2][101010];\n\nll cnt[2][101010];\n\nint main(){\n    for(ll i = 0; i < 101010; i++){\n        depth[0][i] = -1;\n        depth[1][i] = -1;\n    }\n    ll N, M, s, t;\n    cin >> N >> M >> s >> t;\n    for(ll i = 0; i < M; i++){\n        ll x, y;\n        cin >> x >> y;\n        path[x].push_back(y);\n        path[y].push_back(x);\n    }\n    for(ll i = 0; i < 2; i++){\n        queue<ll>Q;\n        if(i==0){\n            Q.push(s);\n            depth[i][s] = 0;\n        }\n        else{\n            Q.push(t);\n            depth[i][t] = 0;\n        }\n        while(!Q.empty()){\n            ll idx = Q.front();\n            Q.pop();\n            cnt[i][depth[i][idx]]++;\n            for(ll j = 0; j < path[idx].size(); j++){\n                ll nxt = path[idx][j];\n                if(depth[i][nxt] >= 0)continue;\n                depth[i][nxt] = depth[i][idx] + 1;\n                Q.push(nxt);\n            }\n        }\n    }\n    ll mn = depth[1][s];\n    ll ans = 0;\n    for(ll a = 0; a <= N; a++){\n        ll b = mn - a - 2;\n        if(b < 0)continue;\n        ans += cnt[0][a] * cnt[1][b];\n    }\n    cout << ans << endl;\n    \n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\ntypedef pair<int,pi> edge;\n\nconst int N=100000, M=300000;\nconst int INF=12345678;\n\nint n,m,s,t,x[M],y[M];\n\nint d[N];\nint par[N];\nvector<int> G[N];\n\nint ct[M],ct2[M];\n\nll fore()\n{\n    fill(ct,ct+M,0);\n    fill(ct2,ct2+M,0);\n\n    // calc ct\n    rep(i,n) if(d[i]<M) ++ct[d[i]];\n\n    // calc ct2\n    vector<edge> e;\n    rep(i,m)\n    {\n        if(max(d[x[i]],d[y[i]])>d[t]) continue;\n\n        if(d[x[i]]<d[y[i]])\n        {\n            if(d[y[i]]==d[x[i]]+1) e.pb(edge(d[y[i]], pi(y[i],x[i])));\n        }\n        if(d[x[i]]>d[y[i]])\n        {\n            if(d[y[i]]+1==d[x[i]]) e.pb(edge(d[x[i]], pi(x[i],y[i])));\n        }\n    }\n\n    sort(all(e),greater<edge>());\n\n    vector<bool> vis(n,false);\n    vis[t]=true;\n    rep(i,e.size())\n    {\n        int now=e[i].se.fi, to=e[i].se.se;\n        if(vis[now]) vis[to]=true;\n    }\n\n    rep(i,n)\n    {\n        if(vis[i]) ++ct2[d[i]];\n    }\n\n    ll ret=0;\n    for(int i=d[t]; i>=2; --i) ret+=(ll)ct2[i]*ct[i-2];\n    return ret;\n}\n\nll back()\n{\n    vector<int> D[M];\n    rep(i,n)\n    {\n        if(d[i]<M) D[d[i]].pb(i);\n    }\n\n    ll ret=0;\n    fill(ct,ct+M,0);\n\n    rep(i,n) if(d[i]<d[t]) ct[d[i]]++;\n\n    vector<bool> leaf(n,false);\n    leaf[t]=true;\n    for(int i=d[t]+1; i<M; ++i)\n    {\n        rep(j,D[i].size())\n        {\n            int v=D[i][j];\n            if(leaf[par[v]])\n            {\n                leaf[v]=true;\n                ++ct[i];\n            }\n        }\n    }\n\n    for(int i=d[t]+1; i<M; ++i)\n    {\n        int w=i-d[t];\n        int idx=d[t]-w-2;\n        if(idx<0) break;\n        ret+=(ll)ct[i]*ct[idx];\n    }\n    return ret;\n}\n\nint main()\n{\n    scanf(\" %d %d %d %d\", &n, &m, &s, &t);\n    --s;\n    --t;\n    rep(i,m)\n    {\n        scanf(\" %d %d\", &x[i], &y[i]);\n        --x[i];\n        --y[i];\n        G[x[i]].pb(y[i]);\n        G[y[i]].pb(x[i]);\n    }\n\n    // dijkstra\n    priority_queue<pi,vector<pi>,greater<pi>> que;\n    fill(d,d+N,INF);\n    fill(par,par+N,-1);\n    d[s]=0;\n    que.push(pi(0,s));\n    while(!que.empty())\n    {\n        pi p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[v]<p.fi) continue;\n        rep(i,G[v].size())\n        {\n            int nx=G[v][i];\n            if(d[nx]>d[v]+1)\n            {\n                d[nx]=d[v]+1;\n                par[nx]=v;\n                que.push(pi(d[nx],nx));\n            }\n        }\n    }\n\n    // printf(\" target : %d ,dist= %d\\n\", t,d[t]);\n    ll ans=back()+fore();\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nvector<int> v[100001];\nint n,m,s,t,d1[100001],d2[100001];\n\nvoid dijkstra1(){\n  for(int i=0;i<n;i++)d1[i]=inf;\n  priority_queue<pair<int,int> > pq;\n  d1[s]=0;\n  pq.push(mp(0,s));\n  while(!pq.empty()){\n    pair<int,int> u=pq.top();\n    pq.pop();\n    int a=(-1)*u.f,b=u.s;\n\n    if(d1[b]<a)continue;\n\n    for(int i=0;i<v[b].size();i++){\n      if(a+1<d1[v[b][i]]){\n\td1[v[b][i]]=a+1;\n\tpq.push(mp((-1)*(a+1),v[b][i]));\n      }\n    }\n  }\n}\n\nvoid dijkstra2(){\n  for(int i=0;i<n;i++)d2[i]=inf;\n  priority_queue<pair<int,int> > pq;\n  d2[t]=0;\n  pq.push(mp(0,t));\n  while(!pq.empty()){\n    pair<int,int> u=pq.top();\n    pq.pop();\n    int a=(-1)*u.f,b=u.s;\n\n    if(d2[b]<a)continue;\n\n    for(int i=0;i<v[b].size();i++){\n      if(a+1<d2[v[b][i]]){\n\td2[v[b][i]]=a+1;\n\tpq.push(mp((-1)*(a+1),v[b][i]));\n      }\n    }\n  }\n}\n\nint main()\n{\n  int a,b;\n\n  cin>>n>>m>>s>>t;\n  s--;t--;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--;b--;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  dijkstra1();\n  dijkstra2();\n\n  long long A[100001]={},B[100001]={},minc=d1[t],ans=0;\n\n  for(int i=0;i<100001;i++){\n    A[i]=0;\n    B[i]=0;\n  }\n  for(int i=0;i<n;i++){\n    if(d1[i]==inf)continue;\n    A[d1[i]]++;\n    B[d2[i]]++;\n  }\n  for(int i=0;i<d1[t]-1;i++){\n    ans+=A[i]*B[minc-2-i];\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n\nint main(){\n    int n,m;\n    int s,t;\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    vector<vector<int>> v(n);\n    // set<pair<int,int>> se;\n    rep(i,n){\n        int a,b;\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        // se.insert(minmax(a,b));\n    }\n    vector<int> used1(n,-1),used2(n,-1);\n    priority_queue<pair<int,int>> pq1;\n    priority_queue<pair<int,int>> pq2;\n    pq1.push(make_pair(0,s));\n    pq2.push(make_pair(0,t));\n    while(pq1.size()){\n        auto top=pq1.top();\n        pq1.pop();\n        if(used1[top.second]>=0) continue;\n        used1[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used1[x]>=0) continue;\n            pq1.push(make_pair(top.first-1,x));\n        }\n    }\n    while(pq2.size()){\n        auto top=pq2.top();\n        pq2.pop();\n        if(used2[top.second]>=0) continue;\n        used2[top.second]=-top.first;\n        for(int x:v[top.second]){\n            if(used2[x]>=0) continue;\n            pq2.push(make_pair(top.first-1,x));\n        }\n    }\n    // for(auto x:se){\n    //     cout<<x.first<<\" \"<<x.second<<endl;\n    // }\n    int ans=0;\n    int dist=used1[t];\n    // if(dist<2){\n        // cout<<0<<endl;\n        // return 0;\n    // }\n    vector<int> dp1(n+10,0),dp2(n+10,0);\n    rep(i,n){\n        dp1[used1[i]]++;\n        dp2[used2[i]]++;\n    }\n    rep(i,dist-1){\n        ans+=dp1[i]*dp2[dist-2-i];\n    }\n    // rep(i,n){\n        // cout<<i<<\" \"<<used1[i]<<\" \"<<used2[i]<<endl;\n        // if(s==i||t==i) continue;\n        // if(used2[i]==dist-2&&se.find(minmax(s,i))==se.end()) ans++;\n        // if(used1[i]==dist-2&&se.find(minmax(t,i))==se.end()) ans++;\n    // }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint main(){\n    int n,m,s,t;\n    cin>>n>>m>>s>>t;\n    --s;--t;\n    vector<int> v[n];\n    rep(i,m){\n        int x,y;\n        cin>>x>>y;\n        --x;--y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    vector<int> ds(n,inf),dt(n,inf);\n    queue<int> q;\n    ds[s]=0;q.push(s);\n    while(q.size()){\n        int x=q.front();q.pop();\n        for(auto to : v[x]){\n            if(ds[to]>ds[x]+1){\n                ds[to]=ds[x]+1;\n                q.push(to);\n            }\n        }\n    }\n    dt[t]=0;q.push(t);\n    while(q.size()){\n        int x=q.front();q.pop();\n        for(auto to : v[x]){\n            if(dt[to]>dt[x]+1){\n                dt[to]=dt[x]+1;\n                q.push(to);\n            }\n        }\n    }\n    vector<ll> cnts(n+1),cntt(n+1);\n    rep(i,n){\n        if(ds[i]<inf)cnts[ds[i]]++;\n        if(dt[i]<inf)cntt[dt[i]]++;\n    }\n    ll ans=0;\n    int x = ds[t];\n    rep(i,x-1){\n        ans+=cnts[i]*cntt[x-2-i];\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <queue>\n\nint len[100001] = { 0 };\nint len2[100001] = { 0 };\nint count[100001] = { 0 };\nint count2[100001] = { 0 };\nstd::vector<int> e[100001];\n\nint main() {\n    int n, m, s, t;\n    std::cin >> n >> m >> s >> t;\n    s; t;\n\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n\n    std::queue<std::pair<int, int>> q; // first:今の場所 second:cost\n    q.push(std::make_pair(s, 0));\n\n    int minLen = 0;\n    bool isGoal = false;\n    while (!q.empty() && !isGoal) {\n        auto node = q.front(); q.pop();\n        node.second++;\n        for (auto to : e[node.first]) {\n            if (len[to] && len[to] <= node.second || to == s) continue;\n            auto next = node;\n            len[to] = next.second;\n            next.first = to;\n            q.push(next);\n\n            if (to == t) {\n                minLen = next.second;\n                isGoal = true;\n                break;\n            }\n        }\n    }\n\n    // 逆方向\n    q = std::queue<std::pair<int, int>>();\n    q.push(std::make_pair(t, 0));\n    isGoal = false;\n    while (!q.empty() && !isGoal) {\n        auto node = q.front(); q.pop();\n        node.second++;\n        // 打ち切り\n        if (node.second > minLen - 2) {\n            break;\n        }\n        for (auto to : e[node.first]) {\n            if ((len2[to] && len2[to] <= node.second) || to == s || to == t) continue;\n\n            auto next = node;\n            len2[to] = next.second;\n            next.first = to;\n            q.push(next);\n\n            if (to == t) {\n                isGoal = true;\n                break;\n            }\n        }\n    }\n\n    // 距離カウント\n    for (auto x : len) {\n        count[x]++;\n    }\n    for (auto x : len2) {\n        count2[x]++;\n    }\n\n    // 数カウント\n    int num = 0;\n    for (int i = 0; i < minLen - 1; i++) {\n        int from = count[i];\n        int to = count2[minLen - (i + 2)];\n        if (!i) from = 1;\n        if (minLen - (i + 2) == 0) to = 1;\n\n        num += from * to;\n    }\n\n    std::cout << num << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[100000];\nint c1[100000], c2[100000];\nvector<int>E[100000];\nvoid bfs(int*c, int s) {\n\tmemset(d, -1, sizeof(d));\n\tqueue<int>que;\n\td[s] = 0; que.push(s);\n\twhile (!que.empty()) {\n\t\tint p = que.front(); que.pop();\n\t\tc[d[p]]++;\n\t\tfor (int v : E[p]) {\n\t\t\tif (d[v] == -1) {\n\t\t\t\td[v] = d[p] + 1; que.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, s, t; scanf(\"%d%d%d%d\", &n, &m, &s, &t); s--; t--;\n\trep(i, m) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y); x--; y--;\n\t\tE[x].push_back(y); E[y].push_back(x);\n\t}\n\tbfs(c1, t); bfs(c2, s);\n\tll ans = 0;\n\tfor (int i = 0; i <= d[t] - 2; i++) {\n\t\tans += (ll)c1[i] * c2[d[t] - 2 - i];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF 1<<30\n\n// dist_from_s[u] + dist_from_t[v] = dist_from_s[t] - 2\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\n\t/* input */\n\tint N, M; cin >> N >> M;\n\tint s, t; cin >> s >> t; s--; t--;\n\tvector<vector<int>> G(N);\n\tfor (int i = 0; i < M;i++) {\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\n\t/* initialize */\n\tvector<int> d_s(N, INF), d_t(N, INF);\n\tqueue<int> q_s, q_t;\n\t\n\t// d_s(t)[n] := distance n from s(t)\n\td_s[s] = 0, d_t[t] = 0;\n\tq_s.push(s), q_t.push(t);\n\n\t/* Dijkstra */\n\twhile (!q_s.empty()) {\n\t\tint u = q_s.front(); q_s.pop();\n\t\tfor (int v : G[u]) {\n\t\t\tif (d_s[v] > d_s[u] + 1) {\n\t\t\t\td_s[v] = d_s[u] + 1;\n\t\t\t\tq_s.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!q_t.empty()) {\n\t\tint u = q_t.front(); q_t.pop();\n\t\tfor (int v : G[u]) {\n\t\t\tif (d_t[v] > d_t[u] + 1) {\n\t\t\t\td_t[v] = d_t[u] + 1;\n\t\t\t\tq_t.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* solve */\n\tll ans = 0;\n\n\t// dist_is(t)[i] := sum of distance i from s(t)\n\tvector<int> dist_is(N + 1, 0);\n\tvector<int> dist_it(N + 1, 0);\n\tfor (int i = 0; i < N;i++) {\n\t\tif (d_s[i] != INF) {\n\t\t\tdist_is[d_s[i]]++;\n\t\t}\n\t\tif (d_t[i] != INF) {\n\t\t\tdist_it[d_t[i]]++;\n\t\t}\n\t}\n\n\tint Const = d_s[t] - 2;\n\tfor (int i = 0; i <= Const;i++) {\n\t\tans += (dist_is[i] * dist_it[Const - i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n \nvector<int> G[100001];\nint S[100001], T[100001];\nint Sc[100001], Tc[100001];\n \nint main()\n{\n\tint N, M, s, t;\n\t\n\tscanf(\"%d %d %d %d\", &N, &M, &s, &t);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint src, dst;\n\t\tscanf(\"%d %d\", &src, &dst);\n\t\tG[src].push_back(dst);\n\t\tG[dst].push_back(src);\n\t}\n\t\n\tfor (int i = 1; i <= N; i++){\n\t\tS[i] = T[i] = 1000000000;\n\t}\n\t\n\tqueue<int> q;\n\t\n\tS[s] = 0;\n\t\n\tfor (q.push(s); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tSc[S[x]]++;\n\t\tfor (int i = 0; i < G[x].size(); i++){\n\t\t\tif (S[G[x][i]] > S[x] + 1){\n\t\t\t\tS[G[x][i]] = S[x] + 1; q.push(G[x][i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tT[t] = 0;\n\t\n\tfor (q.push(t); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tTc[T[x]]++;\n\t\tfor (int i = 0; i < G[x].size(); i++){\n\t\t\tif (T[G[x][i]] > T[x] + 1){\n\t\t\t\tT[G[x][i]] = T[x] + 1; q.push(G[x][i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long ans = 0;\n\tfor (int i = 0; S[t] - i - 2 >= 0; i++){\n\t\tans += (long long)Sc[i] * Tc[S[t] - i - 2];\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define INF ((1LL<<62)-(1LL<<31))\n\n\n\n//辺の情報を個別に持つタイプ\ntypedef struct edge{ll s,g,c;}E;\ntypedef struct graph{\n\tint vcnt,ecnt;\n\tE  e[600010];//適宜変える\n\tint id[100010];//適宜変える\n}G;\n\nint esort(const void*a,const void*b){\n\tE*p=(E*)a,*q=(E*)b;\n\tif((*p).s<(*q).s)return -1;\n\tif((*p).s>(*q).s)return  1;\n\tif((*p).g<(*q).g)return -1;\n\treturn 1;\n}\n\nG g;\nll s,t;\nvoid readgraph(){\n\t//適宜変える\n\tll n,m;\n\tscanf(\"%lld%lld\",&n,&m);\n\tscanf(\"%lld%lld\",&s,&t);\n\ts--;t--;\n\trep(i,0,m){\n\t\tll x,y,c;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tx--,y--;\n\t\tg.e[2*i].s=x;\n\t\tg.e[2*i].g=y;\n\t\tg.e[2*i].c=1;\n\t\tg.e[2*i+1].s=y;\n\t\tg.e[2*i+1].g=x;\n\t\tg.e[2*i+1].c=1;\n\t}\n\tg.vcnt=n;\n\tg.ecnt=2*m;\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n//\tqsort(g.e,g.ecnt,sizeof(E),csort);\n\n\tint p=0;\n\trep(i,0,g.vcnt){\n\t\twhile(p<g.ecnt&&g.e[p].s<i)p++;\n\t\tg.id[i]=p;\n\t}\n\tg.id[g.vcnt]=g.ecnt;//番兵\n}\n\nll daikusutorappp[1<<21];\n\n//プラキュー（二分ヒープ）（優先度変更ありバージョン）\nll heapN,heap[1<<20],heapinv[1<<20];\nint PQhikaku(int i,int j);//jの方が優先度が高いならtrueを返す\nvoid PQchange(int n);\nvoid heap_utod(int n){\n\tif(2*n>heapN)return;\n\tint rflag=(2*n+1<=heapN)&&(PQhikaku(2*n,2*n+1));\n\tif(PQhikaku(n,2*n+rflag)){\n\t\tll temp=heap[2*n+rflag];\n\t\theap[2*n+rflag]=heap[n];\n\t\theap[n]=temp;\n\t\theapinv[heap[n]]=n;\n\t\theapinv[heap[2*n+rflag]]=2*n+rflag;\t\n\t\theap_utod(2*n+rflag);\n\t}\n}\nvoid heap_dtou(int n){\n\tif(n==1||PQhikaku(n,n/2))return;\n\tll temp=heap[n];\n\theap[n]=heap[n/2];\n\theap[n/2]=temp;\n\theapinv[heap[n]]=n;\n\theapinv[heap[n/2]]=n/2;\n\theap_dtou(n/2);\n}\nll PQpop(){\n\tll rr=heap[1];\n\theapinv[heap[1]]=0;\n\theap[1]=heap[heapN--];\n\theapinv[heap[1]]=1;\n\theap_utod(1);\n\treturn rr;\n}\nvoid PQpush(ll n){\n\theap[++heapN]=n;\n\theapinv[heap[heapN]]=heapN;\n\theap_dtou(heapN);\n}\n//この2つを変える\n//ダイクストラ用\nint PQhikaku(int i,int j){return daikusutorappp[heap[i]]>daikusutorappp[heap[j]];}//これをdaikusutora2の最後に書く\nvoid PQchange(int n){if(heapinv[n])heap_dtou(heapinv[n]);}//必ず優先度を高く変更するので\n\n//早い方のダイクストラ\n//グラフと始点を引いて各点への最短距離・最短経路を返す\n//プラキューが必要\n//O((E+V)logV)\nvoid daikusutora2(ll s){\n\trep(i,0,g.vcnt)daikusutorappp[i]=i==s?0:INF;\n\trep(i,0,g.vcnt)PQpush(i);\n\twhile(heapN){\n\t\tll mv=PQpop();\n\t\tfor(ll t=g.id[mv];g.e[t].s==mv;t++){\n\t\t\tif(daikusutorappp[g.e[t].g]>daikusutorappp[mv]+g.e[t].c){\n\t\t\t\tdaikusutorappp[g.e[t].g]=daikusutorappp[mv]+g.e[t].c;\n\t\t\t\t//daikusutorappp[n+g.e[t].g]=mv;//最短経路がいる場合はこれ\n\t\t\t\tPQchange(g.e[t].g);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint a[100010];\nint main(){\n\treadgraph();\n\tdaikusutora2(s);\n\trep(i,0,g.vcnt)if(daikusutorappp[i]!=INF)a[daikusutorappp[i]]++;\n\tll len=daikusutorappp[t];\n\tdaikusutora2(t);\n\tll ans=0;\n\trep(i,0,g.vcnt)if(daikusutorappp[i]<=len-2)ans+=a[len-2-daikusutorappp[i]];\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint lb(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<=d[m]?lb(l,m,n,d):lb(m+1,r,n,d);\n}\nint ub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<d[m]?ub(l,m,n,d):ub(m+1,r,n,d);\n}\nint cnt(int l,int r,int n,int *d){return ub(l,r,n,d)-lb(l,r,n,d);}\nint n,m,s,g,r,t,a,b,l,ta[100010],to[600010],nt[600010],q[600010];\nint main(){\n  int c[2][100010]={};\n  int i,f[100010]={};\n  long long ans=0;\n  scanf(\"%d %d %d %d\",&n,&m,&s,&g);\n  for(i=0;i<n;i++)ta[i+1]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[i  ]=ta[to[i+m]=a];\n    nt[i+m]=ta[to[i  ]=b];\n    ta[a]=i  ;\n    ta[b]=i+m;\n  }\n  q[t=0]=s;\n  c[0][0]=0;\n  f[s]=1;\n  for(r=1;r-t;t++){\n    if(q[t]==g)l=c[0][t];//printf(\"%d %d\\n\",q[t],c[0][q[t]]);\n    for(i=ta[q[t]];i+1;i=nt[i]){//printf(\"%d \",c[0][q[t]]);\n      if(f[to[i]])continue;//printf(\"%d \",c[0][q[t]]);\n      c[0][r]=c[0][t]+1;//printf(\":%d %d %d\\n\",q[t],c[0][r],to[i]);\n      f[to[i]]=1;\n      q[r++]=to[i];\n    }\n  }//printf(\"\\n\");\n  m=r;//printf(\"%d %d\\n\",r,l);\n  //for(i=0;i<r;i++)printf(\"%d \",c[0][i]);printf(\"\\n\");\n  q[t=0]=g;\n  f[g]=2;\n  for(r=1;r-t;t++){\n    ans+=cnt(0,m-1,l-2-c[1][t],c[0]);\n    //printf(\"%d %d %d\\n\",a,c[1][t],q[t]);\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]]-1)continue;\n      c[1][r]=c[1][t]+1;\n      f[to[i]]=2;\n      q[r++]=to[i];\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint lub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<=d[m]?lub(l,m,n,d):lub(m+1,r,n,d);\n}\nint ub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<d[m]?ub(l,m,n,d):ub(m+1,r,n,d);\n}\nvoid prls(int v,int *ta,int *to,int *nt){\n  int i,j;\n  for(i=1;i<=v;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d \",to[j]);\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n  int n,m,s,g,r,t,a,b,l,ta[100010],to[600010],nt[600010],q[600010];\nint main(){\n  int c[2][100010]={};\n  int i,f[100010]={};\n  scanf(\"%d %d %d %d\",&n,&m,&s,&g);\n  for(i=0;i<n;i++)ta[i+1]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[i  ]=ta[to[i+m]=a];\n    nt[i+m]=ta[to[i  ]=b];\n    ta[a]=i  ;\n    ta[b]=i+m;\n  }\n  q[t=0]=s;\n  c[0][0]=0;\n  f[s]=1;\n  for(r=1;r-t;t++){\n    if(q[t]==g)l=c[0][t];//printf(\"%d %d\\n\",q[t],c[0][q[t]]);\n    for(i=ta[q[t]];i+1;i=nt[i]){//printf(\"%d \",c[0][q[t]]);\n      if(f[to[i]])continue;//printf(\"%d \",c[0][q[t]]);\n      c[0][r]=c[0][t]+1;//printf(\":%d %d %d\\n\",q[t],c[0][r],to[i]);\n      f[to[i]]=1;\n      q[r++]=to[i];\n    }\n  }//printf(\"\\n\");\n  m=r;//printf(\"%d %d\\n\",r,l);\n  //for(i=0;i<r;i++)printf(\"%d \",c[0][i]);printf(\"\\n\");\n  q[t=a=0]=g;\n  f[g]=2;\n  for(r=1;r-t;t++){\n    a+=ub(0,m-1,l-2-c[1][t],c[0])-lub(0,m-1,l-2-c[1][t],c[0]);\n    //printf(\"%d %d %d\\n\",a,c[1][t],q[t]);\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]]-1)continue;\n      c[1][r]=c[1][t]+1;\n      f[to[i]]=2;\n      q[r++]=to[i];\n    }\n  }\n  printf(\"%d\\n\",a);\n  return 0;\n}\n      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint lub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<=d[m]?lub(l,m,n,d):lub(m+1,r,n,d);\n}\nint ub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<d[m]?ub(l,m,n,d):ub(m+1,r,n,d);\n}\nvoid prls(int v,int *ta,int *to,int *nt){\n  int i,j;\n  for(i=1;i<=v;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d \",to[j]);\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n  int n,m,s,g,r,t,a,b,l,ta[100010],to[600010],nt[600010],q[600010];\nint main(){\n  int c[2][100010]={};\n  int i,f[100010]={};\n  long long ans=0;\n  scanf(\"%d %d %d %d\",&n,&m,&s,&g);\n  for(i=0;i<n;i++)ta[i+1]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[i  ]=ta[to[i+m]=a];\n    nt[i+m]=ta[to[i  ]=b];\n    ta[a]=i  ;\n    ta[b]=i+m;\n  }\n  q[t=0]=s;\n  c[0][0]=0;\n  f[s]=1;\n  for(r=1;r-t;t++){\n    if(q[t]==g)l=c[0][t];//printf(\"%d %d\\n\",q[t],c[0][q[t]]);\n    for(i=ta[q[t]];i+1;i=nt[i]){//printf(\"%d \",c[0][q[t]]);\n      if(f[to[i]])continue;//printf(\"%d \",c[0][q[t]]);\n      c[0][r]=c[0][t]+1;//printf(\":%d %d %d\\n\",q[t],c[0][r],to[i]);\n      f[to[i]]=1;\n      q[r++]=to[i];\n    }\n  }//printf(\"\\n\");\n  m=r;//printf(\"%d %d\\n\",r,l);\n  //for(i=0;i<r;i++)printf(\"%d \",c[0][i]);printf(\"\\n\");\n  q[t=0]=g;\n  f[g]=2;\n  for(r=1;r-t;t++){\n    ans+=ub(0,m-1,l-2-c[1][t],c[0])-lub(0,m-1,l-2-c[1][t],c[0]);\n    //printf(\"%d %d %d\\n\",a,c[1][t],q[t]);\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]]-1)continue;\n      c[1][r]=c[1][t]+1;\n      f[to[i]]=2;\n      q[r++]=to[i];\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n      "
  },
  {
    "language": "C",
    "code": "// AOJ 2608: Minus One\n// 2017.11.30 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 300000\ntypedef struct { int t, node; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int n, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int *to; } TBL;\nTBL *tbl; int len[100001];\nint x[100001], y[100001];\nint smin[100001], tmin[100001];\nint scnt[100001], tcnt[100001];\n\nvoid dijkstra(int *node, int start)\n{\n\tint i, s, e, d;\n\n\tqsize = 0;\n\tnode[start] = 0;\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].node; deq();\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s].to[i];\n\t\t\td = node[s] + 1;\n\t\t\tif (d < node[e]) node[e] = d, enq(e, d);\n\t\t}\n\t}\n}\n\nchar buf[40], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, s, t, i;\n\tlong long ans;\n\n\tfgets(p=buf, 40, stdin);\n\tn = getint(), p++, m = getint(), p++, s = getint()-1, p++, t = getint()-1;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p=buf, 20, stdin);\n\t\tx[i] = getint()-1, p++, y[i] = getint()-1;\n\t\tlen[x[i]]++, len[y[i]]++;\n\t}\n\ttbl = calloc(n+2, sizeof(TBL));\n\tfor (i = 0; i < n; i++) tbl[i].to = calloc(len[i]+2, sizeof(int));\n\tmemset(len, 0, sizeof(len));\n\tfor (i = 0; i < m; i++) {\n\t\ttbl[x[i]].to[len[x[i]]++] = y[i];\n\t\ttbl[y[i]].to[len[y[i]]++] = x[i];\n\t}\n\n\tmemset(smin, 0x33, sizeof(smin));\n\tdijkstra(smin, s);\n\tmemset(tmin, 0x33, sizeof(tmin));\n\tdijkstra(tmin, t);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (smin[i] < n) scnt[smin[i]]++;\n\t\tif (tmin[i] < n) tcnt[tmin[i]]++;\n\t}\n\n\tans = 0, s = smin[t]-1;\n\tfor (i = 0; i < s; i++) ans += (long long)scnt[i] * tcnt[s-1-i];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2608: Minus One\n// 2017.11.26 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 300000\ntypedef struct { int t, node; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int n, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int to[30]; } TBL;\nTBL tbl[100001];\nint len[100001];\nint smin[100001], tmin[100001];\nint scnt[100001], tcnt[100001];\n\nchar visited[100001];\n\nvoid dijkstra(int *node, int start)\n{\n\tint i, s, e, d;\n\n\tqsize = 0;\n//\tmemset(visited, 0, sizeof(visited));\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].node, d = que[0].t; deq();\n\t\tif (visited[s]) continue;\n\t\tvisited[s] = 1;\n\t\tnode[s] = d;\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s].to[i];\n\t\t\tif (visited[e]) continue;\n\t\t\tenq(e, d + 1);\n\t\t}\n\t}\n}\n\nchar buf[40], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, s, t, i, x, y;\n\tlong long ans;\n\n\tfgets(p=buf, 40, stdin);\n\tn = getint(), p++, m = getint(), p++, s = getint()-1, p++, t = getint()-1;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p=buf, 20, stdin);\n\t\tx = getint()-1, p++, y = getint()-1;\n\t\ttbl[x].to[len[x]++] = y;\n\t\ttbl[y].to[len[y]++] = x;\n\t}\n\n\tmemset(smin, 0x33, sizeof(smin));\n\tdijkstra(smin, s);\n\tmemset(visited, 0, sizeof(visited));\n\tmemset(tmin, 0x33, sizeof(tmin));\n\tdijkstra(tmin, t);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (smin[i] < n) scnt[smin[i]]++;\n\t\tif (tmin[i] < n) tcnt[tmin[i]]++;\n\t}\n\n\tans = 0, s = smin[t]-1;\n\tfor (i = 0; i < s; i++) ans += (long long)scnt[i] * tcnt[s-1-i];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2608: Minus One\n// 2017.11.26 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 300000\ntypedef struct { int t, node; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int n, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int to[30]; } TBL;\nTBL tbl[100001];\nint len[100001];\nint smin[100001], tmin[100001];\nint scnt[100001], tcnt[100001];\n\nvoid dijkstra(int *node, int start)\n{\n\tint i, s, e, d;\n\n\tqsize = 0;\n\tnode[start] = 0;\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].node; deq();\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s].to[i];\n\t\t\td = node[s] + 1;\n\t\t\tif (d < node[e]) node[e] = d, enq(e, d);\n\t\t}\n\t}\n}\n\nchar buf[40], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, s, t, i, x, y;\n\tlong long ans;\n\n\tfgets(p=buf, 40, stdin);\n\tn = getint(), p++, m = getint(), p++, s = getint()-1, p++, t = getint()-1;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p=buf, 20, stdin);\n\t\tx = getint()-1, p++, y = getint()-1;\n\t\ttbl[x].to[len[x]++] = y;\n\t\ttbl[y].to[len[y]++] = x;\n\t}\n\n\tmemset(smin, 0x33, sizeof(smin));\n\tdijkstra(smin, s);\n\tmemset(tmin, 0x33, sizeof(tmin));\n\tdijkstra(tmin, t);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (smin[i] < n) scnt[smin[i]]++;\n\t\tif (tmin[i] < n) tcnt[tmin[i]]++;\n\t}\n\n\tans = 0, s = smin[t]-1;\n\tfor (i = 0; i < s; i++) ans += (long long)scnt[i] * tcnt[s-1-i];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2608: Minus One\n// 2017.11.30 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 300000\ntypedef struct { int t, node; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int n, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int *to; } TBL;\nTBL tbl[100001]; int len[100001];\nint x[300000], y[300000];\nint smin[100001], tmin[100001];\nint scnt[100001], tcnt[100001];\n\nvoid dijkstra(int *node, int start)\n{\n\tint i, s, e, d;\n\n\tqsize = 0;\n\tnode[start] = 0;\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].node; deq();\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s].to[i];\n\t\t\td = node[s] + 1;\n\t\t\tif (d < node[e]) node[e] = d, enq(e, d);\n\t\t}\n\t}\n}\n\nchar buf[40], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, s, t, i;\n\tlong long ans;\n\n\tfgets(p=buf, 40, stdin);\n\tn = getint(), p++, m = getint(), p++, s = getint()-1, p++, t = getint()-1;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p=buf, 20, stdin);\n\t\tx[i] = getint()-1, p++, y[i] = getint()-1;\n\t\tlen[x[i]]++, len[y[i]]++;\n\t}\n\tfor (i = 0; i < n; i++) tbl[i].to = calloc(len[i], sizeof(int));\n\tmemset(len, 0, sizeof(len));\n\tfor (i = 0; i < m; i++) {\n\t\ttbl[x[i]].to[len[x[i]]++] = y[i];\n\t\ttbl[y[i]].to[len[y[i]]++] = x[i];\n\t}\n\n\tmemset(smin, 0x33, sizeof(smin));\n\tdijkstra(smin, s);\n\tmemset(tmin, 0x33, sizeof(tmin));\n\tdijkstra(tmin, t);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (smin[i] < n) scnt[smin[i]]++;\n\t\tif (tmin[i] < n) tcnt[tmin[i]]++;\n\t}\n\n\tans = 0, s = smin[t]-1;\n\tfor (i = 0; i < s; i++) ans += (long long)scnt[i] * tcnt[s-1-i];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint lub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<=d[m]?lub(l,m,n,d):lub(m+1,r,n,d);\n}\nint ub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<d[m]?ub(l,m,n,d):ub(m+1,r,n,d);\n}\nvoid prls(int v,int *ta,int *to,int *nt){\n  int i,j;\n  for(i=1;i<=v;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d \",to[j]);\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\nint main(){\n  int n,m,s,g,r,t,a,b,l,ta[100010],to[100010],nt[100010],q[100010];\n  int c[2][100010]={};\n  int i,f[100010]={};\n  scanf(\"%d %d %d %d\",&n,&m,&s,&g);\n  for(i=0;i<n;i++)ta[i+1]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[i  ]=ta[to[i+m]=a];\n    nt[i+m]=ta[to[i  ]=b];\n    ta[a]=i  ;\n    ta[b]=i+m;\n  }\n  q[t=0]=s;\n  c[0][0]=0;\n  f[s]=1;\n  for(r=1;r-t;t++){\n    if(q[t]==g)l=c[0][t];//printf(\"%d %d\\n\",q[t],c[0][q[t]]);\n    for(i=ta[q[t]];i+1;i=nt[i]){//printf(\"%d \",c[0][q[t]]);\n      if(f[to[i]])continue;//printf(\"%d \",c[0][q[t]]);\n      c[0][r]=c[0][t]+1;//printf(\":%d %d %d\\n\",q[t],c[0][r],to[i]);\n      f[to[i]]=1;\n      q[r++]=to[i];\n    }\n  }//printf(\"\\n\");\n  m=r;//printf(\"%d %d\\n\",r,l);\n  //for(i=0;i<r;i++)printf(\"%d \",c[0][i]);printf(\"\\n\");\n  q[t=a=0]=g;\n  f[g]=2;\n  for(r=1;r-t;t++){\n    a+=ub(0,m-1,l-2-c[1][t],c[0])-lub(0,m-1,l-2-c[1][t],c[0]);\n    //printf(\"%d %d %d\\n\",a,c[1][t],q[t]);\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]]-1)continue;\n      c[1][r]=c[1][t]+1;\n      f[to[i]]=2;\n      q[r++]=to[i];\n    }\n  }\n  printf(\"%d\\n\",a);\n  return 0;\n}\n      "
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static int N, M, S, T;\n    static int[] X, Y;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        S = sc.nextInt()-1;\n        T = sc.nextInt()-1;\n        X = new int[M];\n        Y = new int[M];\n        for (int i = 0; i < M; i++) {\n            X[i] = sc.nextInt()-1;\n            Y[i] = sc.nextInt()-1;\n        }\n\n        System.out.println(solve());\n    }\n\n    static long solve() {\n        int[][] G = adjB(N, X, Y);\n        int[] distFromS = calcDist(S, G);\n        int st = distFromS[T];\n        int[] cnts = distCount(distFromS, st-1);\n        int[] cntt = distCount(calcDist(T, G), st-1);\n\n        long ans = 0;\n        for (int i = 0; i <= st-2; i++) {\n            // i + j + 1 = st-1\n            // j = st-i-2\n            int j = st-i-2;\n            ans += (long)cnts[i] * cntt[j];\n        }\n        return ans;\n    }\n\n    static int[][] adjB(int n, int[] from, int[] to) {\n        int[][] adj = new int[n][];\n        int[] cnt = new int[n];\n        for (int f : from) {\n            cnt[f]++;\n        }\n        for (int t : to) {\n            cnt[t]++;\n        }\n        for (int i = 0; i < n; i++) {\n            adj[i] = new int[cnt[i]];\n        }\n        for (int i = 0; i < from.length; i++) {\n            adj[from[i]][--cnt[from[i]]] = to[i];\n            adj[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return adj;\n    }\n\n    static int[] distCount(int[] dist, int max) {\n        int[] cnt = new int[max+1];\n        for (int i = 0; i < N; i++) {\n            if( dist[i] <= max ) {\n                cnt[dist[i]]++;\n            }\n        }\n        return cnt;\n    }\n\n    static int[] calcDist(int start, int[][] G) {\n        int[] dist = new int[N];\n        Arrays.fill(dist, Integer.MAX_VALUE/2);\n        dist[start] = 0;\n        int[] q = new int[N];\n        int u = 0, v = 0;\n        q[v++] = start;\n\n        while(u != v ) {\n            int a = q[u++];\n            for (int b : G[a]) {\n                if( dist[b] > dist[a] + 1 ) {\n                    dist[b] = dist[a] + 1;\n                    q[v++] = b;\n                }\n            }\n        }\n        return dist;\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic class T{\n\t\tint a,b,c;\n\t\tT(int a,int b,int c){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint s = sc.nextInt()-1;\n\t\tint t = sc.nextInt()-1;\n\t\tArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i = 0 ; i < N ; i++)\n\t\t\tg.add(new ArrayList<Integer>());\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tint a = sc.nextInt()-1;\n\t\t\tint b = sc.nextInt()-1;\n\t\t\tg.get(a).add(b);\n\t\t\tg.get(b).add(a);\n\t\t}\n\t\tArrayDeque<Integer> Q = new ArrayDeque<Integer>();\n\t\tint[] shortest1 = new int[N+1];\n\t\tint[] shortest2 = new int[N+1];\n\t\t\n\t\tint[] counter1 = new int[N+1];\n\t\tint[] counter2 = new int[N+1];\n\t\t\n\t\tArrays.fill(shortest1,N);\n\t\tArrays.fill(shortest2,N);\n\t\tQ.offer(s);\n\t\tshortest1[s] = 0;\n\t\twhile( Q.size() > 0 ){\n\t\t\tint q = Q.poll();\n\t\t\tcounter1[shortest1[q]]++;\n\t\t\t//System.out.println(q+1+\" \"+shortest1[q]);\n\t\t\tfor( int to : g.get(q) ){\n\t\t\t\tif( shortest1[to] == N ){\n\t\t\t\t\tshortest1[to] = shortest1[q] + 1;\n\t\t\t\t\tQ.offer(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.offer(t);\n\t\tshortest2[t] = 0;\n\t\twhile( Q.size() > 0 ){\n\t\t\tint q = Q.poll();\n\t\t\tcounter2[shortest2[q]]++;\n\t\t\t//System.out.println(q+1+\" \"+shortest2[q]);\n\t\t\tfor( int to : g.get(q) ){\n\t\t\t\tif( shortest2[to] == N ){\n\t\t\t\t\tshortest2[to] = shortest2[q] + 1;\n\t\t\t\t\tQ.offer(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"\");\n\n\t\tint maximum = shortest1[t];\n\t\tlong ans = 0;\n\t\t//for(int i = 0 ; i <= maximum ; i++){\n\t\t//\tSystem.out.println(i+\" \"+counter[i]);\n\t\t//}\n\t\tfor(int i = 0 ; i+2 <= maximum ; i++){\n\n\t\t\tans += (long) counter1[i] * counter2[maximum-(i+2)];\n\t\t}\n\t\tSystem.out.println(ans);\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nn, m, s, t = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map {|i| g.add_node({:name => i}) }\nedges = []\nm.times {\n\ti, j = gets.split.map &:to_i \n\tedges << g.add_edge(nodes[i], nodes[j])\n}\n\nf_layers = g.each_layer_from([nodes[s]]).to_a\nf_dist = g.bfs([nodes[s]])\nb_layers = g.each_layer_from([nodes[t]]).to_a\nb_dist = g.bfs([nodes[t]])\ndst = f_dist[nodes[t]]\n\ncount = 0\n(0..dst-2).each{|i|\n\t(f_layers[i] || []).each{|u|\n\t\t(b_layers[dst-2-i] || []).each{|v|\n\t\t\tcount += 1 if f_dist[v] + b_dist[u] >= dst - 2\n\t\t}\n\t}\n}\np count"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\n# Header {{{\ndef assert(p)\n  raise 'Assertion Failed' unless p\nend\n\n# Constants {{{\nINF = 10**9\n# }}}\n\n# IO {{{\nclass MyIO\n  def initialize\n    @input = $stdin\n    @output = $stdout\n  end\n\n  # @param filename [String]\n  def set_input(filename)\n    @input = File.open(filename, 'r')\n  end\n\n  def set_output(filename)\n    @output = File.open(filename, 'w')\n  end\n\n  def int\n    gets.to_i\n  end\n\n  def ints\n    split.map(&:to_i)\n  end\n\n  def split\n    @input.gets.chomp.split(' ')\n  end\n  alias_method :strings, :split\n\n  def gets\n    @input.gets.chomp\n  end\n\n  def puts(*args)\n    @output.puts(*args)\n  end\nend\n\nio = MyIO.new\n# }}}\n\n# Algorithms {{{\n\ndef lower_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] < val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] >= val\n    low\n  else\n    high\n  end\nend\n\ndef upper_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] <= val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] > val\n    low\n  else\n    high\n  end\nend\n\n# }}}\n\n# }}}\n\n# io.set_input('inputs/4.txt')\n\nclass Node\n  attr_accessor :neighbors\n  def initialize\n    @neighbors = Set.new\n  end\n\n  def connect(n)\n    @neighbors << n\n  end\nend\n\nn, m, s, t = io.ints\ns -= 1\nt -= 1\nnodes = Array.new(n) { Node.new }\nm.times do\n  x, y = io.ints\n  x -= 1\n  y -= 1\n  nodes[x].connect(y)\n  nodes[y].connect(x)\nend\n\nmin_dist = INF\nnodes_by_dist_from_start = Hash.new { |h, k| h[k] = Set.new }\nnodes_by_dist_from_end = Hash.new { |h, k| h[k] = Set.new }\n[s, t].each do |start|\n  visited = Array.new(n, false)\n  q = []\n  q << [start, 0]\n  while !q.empty?\n    i, d = q.shift\n    next if visited[i]\n    visited[i] = true\n    min_dist = d if start == s && i == t\n    nodes_by_dist_from_start[d] << i if start == s\n    nodes_by_dist_from_end[d] << i if start == t\n    nodes[i].neighbors.each do |j|\n      q.push([j, d+1])\n    end\n  end\nend\n\nans = 0\n(0...min_dist).each do |i|\n  j = min_dist - i - 2\n  ans += nodes_by_dist_from_start[i].size * nodes_by_dist_from_end[j].size\nend\n\nputs ans\n\n# vim: foldmethod=marker"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nn, m, s, t = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map {|i| g.add_node({:name => i}) }\nedges = []\nm.times {\n\ti, j = gets.split.map &:to_i \n\tedges << g.add_edge(nodes[i], nodes[j])\n}\n\nf_layers = g.each_layer_from([nodes[s]]).to_a\nf_dist = g.bfs([nodes[s]])\nb_layers = g.each_layer_from([nodes[t]]).to_a\nb_dist = g.bfs([nodes[t]])\ndst = f_dist[nodes[t]]\n\ncount = 0\n(0..dst-2).each{|i|\n\ta = f_layers[i]\n\tnext if !a\n\ta.sort_by!{|u| -b_dist[u]}\n\n\tb = b_layers[dst-2-i]\n\tnext if !b\n\tb.sort_by{|u| f_dist[u]}\n\n\tk = 0\t\n\ta.each{|u|\n\t\tk += 1 until k == b.size || b_dist[u] + f_dist[b[k]] >= dst-2\n\t\tcount += b.size - k\n\t}\n}\np count"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\n# Header {{{\ndef assert(p)\n  raise 'Assertion Failed' unless p\nend\n\n# Constants {{{\nINF = 10**9\n# }}}\n\n# IO {{{\nclass MyIO\n  def initialize\n    @input = $stdin\n    @output = $stdout\n  end\n\n  # @param filename [String]\n  def set_input(filename)\n    @input = File.open(filename, 'r')\n  end\n\n  def set_output(filename)\n    @output = File.open(filename, 'w')\n  end\n\n  def int\n    gets.to_i\n  end\n\n  def ints\n    split.map(&:to_i)\n  end\n\n  def split\n    @input.gets.chomp.split(' ')\n  end\n  alias_method :strings, :split\n\n  def gets\n    @input.gets.chomp\n  end\n\n  def puts(*args)\n    @output.puts(*args)\n  end\nend\n\nio = MyIO.new\n# }}}\n\n# Algorithms {{{\n\ndef lower_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] < val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] >= val\n    low\n  else\n    high\n  end\nend\n\ndef upper_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] <= val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] > val\n    low\n  else\n    high\n  end\nend\n\n# }}}\n\n# }}}\n\n# io.set_input('inputs/0.txt')\n\nclass Node\n  attr_accessor :neighbors\n  def initialize\n    @neighbors = Set.new\n  end\n\n  def connect(n)\n    @neighbors << n\n  end\nend\n\nn, m, s, t = io.ints\ns -= 1\nt -= 1\nnodes = Array.new(n) { Node.new }\nm.times do\n  x, y = io.ints\n  x -= 1\n  y -= 1\n  nodes[x].connect(y)\n  nodes[y].connect(x)\nend\n\nmin_dist = INF\nnodes_by_dist_from_start = Hash.new { |h, k| h[k] = Set.new }\nnodes_by_dist_from_end = Hash.new { |h, k| h[k] = Set.new }\n[s, t].each do |start|\n  visited = Array.new(n, false)\n  q = []\n  q << [start, 0]\n  while !q.empty?\n    i, d = q.pop\n    next if visited[i]\n    visited[i] = true\n    min_dist = d if start == s && i == t\n    nodes_by_dist_from_start[d] << i if start == s\n    nodes_by_dist_from_end[d] << i if start == t\n    nodes[i].neighbors.each do |j|\n      q.push([j, d+1])\n    end\n  end\nend\n\nans = 0\n(0...min_dist).each do |i|\n  j = min_dist - i - 2\n  ans += nodes_by_dist_from_start[i].size * nodes_by_dist_from_end[j].size\nend\n\nputs ans\n\n# vim: foldmethod=marker"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport queue\nn,m,s,t=map(int,input().split())\ntable=[[] for i in range(n)]\ninf=300001\ndist_s=[inf for i in range(n)]\ndist_t=[inf for i in range(n)]\ns_list=[0 for i in range(inf+1)]\nt_list=[0 for i in range(inf+1)]\ns-=1;t-=1\nfor i in range(m):\n    a,b=map(int,input().split())\n    a-=1;b-=1\n    table[a].append(b)\n    table[b].append(a)\ndist_s[s]=0\nq=queue.Queue()\nq.put(s)\nwhile not q.empty():\n    p=q.get()\n    for e in table[p]:\n        if dist_s[e]>dist_s[p]+1:\n            dist_s[e]=dist_s[p]+1\n            q.put(e)\ndist_t[t]=0\nq=queue.Queue()\nq.put(t)\nwhile not q.empty():\n    p=q.get()\n    for e in table[p]:\n        if dist_t[e]>dist_t[p]+1:\n            dist_t[e]=dist_t[p]+1\n            q.put(e)\nfor i in range(n):\n    s_list[dist_s[i]]+=1\n    t_list[dist_t[i]]+=1\nmindist=dist_s[t]\nans=0\nfor i in range(mindist-1):\n    ans+=s_list[i]*t_list[(mindist-2)-i]\nprint(ans)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 2608: Minus One\n# Python3 2018.6.30 bal4u\n\nimport heapq\nMAX = 0x7fffffff\n\ndef dijkstra(dist, start):\n\tQ = []\n\tdist[start] = 0\n\theapq.heappush(Q, (0, start))\n\twhile Q:\n\t\tt, s = heapq.heappop(Q)\n\t\tif dist[s] < t: continue\n\t\tfor e in to[s]:\n\t\t\tnt = t + 1\n\t\t\tif dist[e] > nt:\n\t\t\t\tdist[e] = nt\n\t\t\t\theapq.heappush(Q, (nt, e))\n\nN, M, s, t = map(int, input().split())\ns, t = s-1, t-1\nto = [[] for i in range(N)]\nfor i in range(M):\n\tx, y = map(int, input().split())\n\tx, y = x-1, y-1\n\tto[x].append(y)\n\tto[y].append(x)\nsmin = [MAX]*N\ndijkstra(smin, s)\ntmin = [MAX]*N\ndijkstra(tmin, t)\nscnt = [0]*N\ntcnt = [0]*N\nfor i in range(N):\n\tif smin[i] < N: scnt[smin[i]] += 1\n\tif tmin[i] < N: tcnt[tmin[i]] += 1\nans = 0\ns = smin[t]-1\nfor i in range(s): ans += scnt[i]*tcnt[s-1-i]\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import heapq\ndef dijkstra_heap(s):\n    d = [float(\"inf\")] * n\n    used = [True] * n\n    d[s] = 0\n    used[s] = False\n    edgelist = []\n    for e in edge[s]:\n        heapq.heappush(edgelist,e)\n    while len(edgelist):\n        minedge = heapq.heappop(edgelist)\n        if not used[minedge[1]]:\n            continue\n        v = minedge[1]\n        d[v] = minedge[0]\n        used[v] = False\n        for e in edge[v]:\n            if used[e[1]]:\n                heapq.heappush(edgelist,(e[0]+d[v],e[1]))\n    return d\n\nn,w,s,t = map(int,input().split())\n\nedge = [[] for i in range(n)]\nfor i in range(w):\n    x,y = map(int,input().split())\n    edge[x-1].append((1,y-1))\n    edge[y-1].append((1,x-1))\na,b = [0]*n,[0]*n\nx = dijkstra_heap(s-1)\ny = dijkstra_heap(t-1)\ndistance = x[t-1] - 1\nfor t in x:\n    if t < n:\n        a[t] += 1\nfor t in y:\n    if t < n:\n        b[t] += 1\nans = 0\nfor i in range(distance + 1):\n    if distance - i > 0:\n        ans += a[i] * b[distance - i - 1]\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,m,s,t = LI()\n    xy = [LI() for _ in range(m)]\n    e = collections.defaultdict(list)\n    for x,y in xy:\n        e[x].append((y,1))\n        e[y].append((x,1))\n\n    def search(s):\n        d = collections.defaultdict(lambda: inf)\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while len(q):\n            k, u = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n\n            for uv, ud in e[u]:\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n\n        return d\n\n    d1 = search(s)\n    d2 = search(t)\n    tt = d1[t]\n    if tt == 1:\n        return 0\n    if tt == 2:\n        return 1\n    v1 = collections.defaultdict(int)\n    v2 = collections.defaultdict(int)\n    for k,v in d1.items():\n        v1[v] += 1\n    for k,v in d2.items():\n        v2[v] += 1\n    r = 0\n    for i in range(tt-1):\n        r += v1[i] * v2[tt-i-2]\n\n    return r\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "N, M, s, t = map(int, input().split())\nE = [[] for _ in range(N+1)]\nfor _ in range(M):\n    x, y = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\n\nclosed = [False] * (N+1)\nclosed[s] = True\ndist = [float(\"inf\")] * (N+1)\nq = [s]\nfor dist_ in range(N):\n    q_new = []\n    for v in q:\n        dist[v] = dist_\n        for u in E[v]:\n            if closed[u]:\n                continue\n            closed[u] = True\n            q_new.append(u)\n\n    q = q_new\n    if len(q) == 0:\n        break\n\ndist_st = dist[t]\n\nclosed = [False] * (N+1)\nclosed[t] = True\ndist_t = [float(\"inf\")] * (N+1)\nq = [t]\nfor dist_ in range(N):\n    q_new = []\n    for v in q:\n        dist_t[v] = dist_\n        for u in E[v]:\n            if closed[u]:\n                continue\n            closed[u] = True\n            q_new.append(u)\n\n    q = q_new\n    if len(q) == 0:\n        break\nds = [0] * (dist_st-1)\ndt = [0] * (dist_st-1)\nfor d in dist:\n    if d < (dist_st-1):\n        ds[d] += 1\nfor d in dist_t:\n    if d < (dist_st-1):\n        dt[d] += 1\n\nans = 0\nfor a, b in zip(ds, dt[::-1]):\n    ans += a*b\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    while 1:\n        n = I()\n        if n == 0:\n            quit()\n        a = LI()\n        m = sum(a)/n\n        c = 0\n        for i in range(n):\n            if a[i] <= m:\n                c += 1\n        print(c)\n    return\n\n#B\ndef B():\n    while 1:\n        n = I()\n        if n == 0:\n            quit()\n        t = [0 for i in range(24*3600)]\n        for i in range(n):\n            x,y = input().split()\n            x = list(map(int, x.split(\":\")))\n            y = list(map(int, y.split(\":\")))\n            l = x[0]*3600+x[1]*60+x[2]\n            r = y[0]*3600+y[1]*60+y[2]\n            t[l] += 1\n            t[r] -= 1\n        ans = 0\n        for i in range(24*3600-1):\n            t[i+1] += t[i]\n            ans = max(ans, t[i])\n        print(ans)\n    return\n#C\ndef C():\n    n = I()\n    if n == 0:\n        print(1)\n    elif n == 1:\n        print(2)\n    elif n == 2:\n        print(1)\n    else:\n        print(0)\n    return\n\n#D\ndef D():\n    def dijkstra(s):\n        d = [float(\"inf\") for i in range(n)]\n        q = [[0,s]]\n        d[s] = 0\n        while q:\n            dx,x = heappop(q)\n            for y in v[x]:\n                if dx+1 < d[y]:\n                    d[y] = d[x]+1\n                    heappush(q,[d[y],y])\n        return d\n    n,m,s,t = LI()\n    s -= 1\n    t -= 1\n    v = [[] for i in range(n)]\n    for i in range(m):\n        x,y = LI()\n        x -= 1\n        y -= 1\n        v[x].append(y)\n        v[y].append(x)\n    l = dijkstra(s)\n    l2 = dijkstra(t)\n    k = l[t]-2\n    d = defaultdict(int)\n    ans = 0\n    for i in l2:\n        d[i] += 1\n    for i in l:\n        ans += d[max(-1,k-i)]\n    print(ans)\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#I\ndef I_():\n    return\n\n#J\ndef J():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    D()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\nn, m, s, t = map(int, input().split())\ns -= 1\nt -= 1\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n  x, y = map(int, input().split())\n  x -= 1\n  y -= 1\n  edges[x].append(y)\n  edges[y].append(x)\n\ndef dist_from(s):\n  INF = 10 ** 20\n  dist = [INF] * n\n  dist[s] = 0\n  que = deque()\n  que.append((0, s))\n  while que:\n    score, node = que.popleft()\n    for to in edges[node]:\n      if dist[to] > score + 1:\n        dist[to] = score + 1\n        que.append((score + 1, to))\n  return dist\n\ndist_from_s = dist_from(s)\ndic1 = {}\nfor i, d in enumerate(dist_from_s):\n  if d in dic1:\n    dic1[d].add(i)\n  else:\n    dic1[d] = {i}\n\ndist_from_t = dist_from(t)\ndic2 = {}\nfor i, d in enumerate(dist_from_t):\n  if d in dic2:\n    dic2[d].add(i)\n  else:\n    dic2[d] = {i}\n\nst_dist = dist_from_s[t]\nans = 0\nfor key in dic1:\n  another_key = st_dist - key - 2\n  if another_key in dic2:\n    add = len(dic1[key]) * len(dic2[another_key])\n    for u in dic1[key]:\n      for to in edges[u]:\n        if to in dic2[another_key]:\n          add -= 1\n    ans += add\nprint(ans)\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BinaryHeap, BTreeMap, VecDeque};\nuse std::fmt::{Display, Formatter, Error};\nuse std::ops::Range;\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nstruct ValueWithKey<K, V> {\n    key: K, value: V,\n}\nimpl <K, V> Ord for ValueWithKey<K, V> where K: Ord {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.key.cmp(&other.key)\n    }\n}\nimpl <K, V> PartialOrd for ValueWithKey<K, V> where K: PartialOrd {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K, V> PartialEq for ValueWithKey<K, V> where K: PartialEq {\n    fn eq(&self, other: &Self) -> bool {\n        self.key == other.key\n    }\n}\nimpl <K, V> Eq for ValueWithKey<K, V> where K: Eq {}\n\nfn lower_bound<T>(array: &Vec<T>, target: &T) -> usize where T: Ord {\n    let mut left = 0;\n    let mut right = array.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if array[mid] < *target {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    right\n}\nfn upper_bound<T>(array: &Vec<T>, target: &T) -> usize where T: Ord {\n    let mut left = 0;\n    let mut right = array.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if array[mid] <= *target {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    right\n}\nfn main(){\n    let_all!(n: usize, m: usize, s: usize, t: usize);\n    let mut nodes = vec![Vec::<usize>::new(); n];\n    for _ in 0 .. m {\n        let_all!(x: usize, y: usize);\n        nodes[x - 1].push(y - 1);\n        nodes[y - 1].push(x - 1);\n    }\n    let mut queue = VecDeque::<usize>::new();\n    let mut min_length_from_start = vec![-1; n];\n    min_length_from_start[s - 1] = 0;\n    queue.push_back(s -1);\n    while let Some(c) = queue.pop_front() {\n        for &n in &nodes[c] {\n            if min_length_from_start[n] == -1 {\n                min_length_from_start[n] = min_length_from_start[c] + 1;\n                queue.push_back(n);\n            }\n        }\n    }\n    let mut min_length_from_goal = vec![-1; n];\n    min_length_from_goal[t - 1] = 0;\n    queue.push_back(t - 1);\n    while let Some(c) = queue.pop_front() {\n        for &n in &nodes[c] {\n            if min_length_from_goal[n] == -1 {\n                min_length_from_goal[n] = min_length_from_goal[c] + 1;\n                queue.push_back(n);\n            }\n        }\n    }\n    min_length_from_goal.sort();\n    let target_length = min_length_from_start[t - 1] - 1;\n    let mut result = 0;\n    for &from_start in &min_length_from_start {\n        if target_length > from_start && from_start >= 0 {\n            result += upper_bound(&min_length_from_goal, &(target_length - from_start - 1)) - lower_bound(&min_length_from_goal, &(target_length - from_start - 1));\n        }\n    }\n    println!(\"{}\", result);\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BinaryHeap, BTreeMap, VecDeque};\nuse std::fmt::{Display, Formatter, Error};\nuse std::ops::Range;\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nfn main(){\n    let_all!(n: usize, m: usize, s: usize, t: usize);\n    let mut nodes = vec![Vec::<usize>::new(); n];\n    for _ in 0 .. m {\n        let_all!(x: usize, y: usize);\n        nodes[x - 1].push(y - 1);\n        nodes[y - 1].push(x - 1);\n    }\n    let mut queue = VecDeque::<usize>::new();\n    let mut min_length_from_start = vec![-1; n];\n    min_length_from_start[s - 1] = 0;\n    queue.push_back(s -1);\n    while let Some(c) = queue.pop_front() {\n        for &n in &nodes[c] {\n            if min_length_from_start[n] == -1 {\n                min_length_from_start[n] = min_length_from_start[c] + 1;\n                queue.push_back(n);\n            }\n        }\n    }\n    let mut min_length_from_goal = vec![-1; n];\n    min_length_from_goal[t - 1] = 0;\n    queue.push_back(t - 1);\n    while let Some(c) = queue.pop_front() {\n        for &n in &nodes[c] {\n            if min_length_from_goal[n] == -1 {\n                min_length_from_goal[n] = min_length_from_goal[c] + 1;\n                queue.push_back(n);\n            }\n        }\n    }\n    let mut to_goal_count = vec![0; n];\n    for m in min_length_from_goal {\n        if m >= 0 {\n            to_goal_count[m as usize] += 1;\n        }\n    }\n    let target_length = min_length_from_start[t - 1] - 1;\n    let mut result = 0;\n    for m in min_length_from_start {\n        if m >= 0 && target_length > m {\n            result += to_goal_count[(target_length - m - 1) as usize];\n        }\n    }\n    println!(\"{}\", result);\n}\n\n\n"
  }
]