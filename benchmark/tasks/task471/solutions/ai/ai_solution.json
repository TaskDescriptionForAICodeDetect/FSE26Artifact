[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_V 1001\n\nint dist[MAX_V][MAX_V];\nint graph[MAX_V][MAX_V];\nint n, m;\n\nvoid floyd_warshall() {\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int s, t;\n    scanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            dist[i][j] = (i == j) ? 0 : INT_MAX / 2;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = graph[v][u] = 1;\n        dist[u][v] = dist[v][u] = 1;\n    }\n\n    floyd_warshall();\n    int original_dist = dist[s][t];\n    int beauty = 0;\n\n    for (int u = 1; u <= n; u++) {\n        for (int v = u + 1; v <= n; v++) {\n            if (graph[u][v]) continue;\n\n            graph[u][v] = graph[v][u] = 1;\n            \n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= n; j++) {\n                    dist[i][j] = (i == j) ? 0 : INT_MAX / 2;\n                }\n            }\n\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= n; j++) {\n                    if (graph[i][j]) {\n                        dist[i][j] = 1;\n                    }\n                }\n            }\n\n            floyd_warshall();\n            \n            if (dist[s][t] == original_dist + 1) {\n                beauty++;\n            }\n\n            graph[u][v] = graph[v][u] = 0;\n        }\n    }\n\n    printf(\"%d\\n\", beauty);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 1000\n\nint n, m, s, t;\nint adj[MAX_N][MAX_N];\nint dist_original[MAX_N];\nint dist_with_e[MAX_N];\nint visited[MAX_N];\n\nvoid bfs(int start, int* dist) {\n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    dist[start] = 0;\n    visited[start] = 1;\n    int queue[MAX_N];\n    int front = 0, rear = 0;\n    queue[rear++] = start;\n\n    while (front < rear) {\n        int u = queue[front++];\n        for (int v = 0; v < n; v++) {\n            if (adj[u][v] && !visited[v]) {\n                dist[v] = dist[u] + 1;\n                visited[v] = 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d %d\", &n, &m, &s, &t);\n    s--; t--;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            adj[i][j] = 0;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        adj[u][v] = 1;\n        adj[v][u] = 1;\n    }\n\n    bfs(s, dist_original);\n    int original_dist = dist_original[t];\n    int beauty = 0;\n\n    for (int u = 0; u < n; u++) {\n        for (int v = u + 1; v < n; v++) {\n            if (!adj[u][v]) {\n                adj[u][v] = 1;\n                adj[v][u] = 1;\n                bfs(s, dist_with_e);\n                if (dist_with_e[t] == original_dist - 1) {\n                    beauty++;\n                }\n                adj[u][v] = 0;\n                adj[v][u] = 0;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", beauty);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nvoid bfs(const vector<vector<int>>& adj, int s, vector<int>& dist) {\n    int n = adj.size();\n    dist.assign(n, INT_MAX);\n    queue<int> q;\n    dist[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n    s--; t--; // converting to 0-based index\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<int> dist_s, dist_t;\n    bfs(adj, s, dist_s);\n    bfs(adj, t, dist_t);\n\n    int original_dist = dist_s[t];\n    int beauty = 0;\n\n    for (int u = 0; u < N; ++u) {\n        for (int v = u + 1; v < N; ++v) {\n            bool edge_exists = false;\n            for (int neighbor : adj[u]) {\n                if (neighbor == v) {\n                    edge_exists = true;\n                    break;\n                }\n            }\n            if (!edge_exists) {\n                if (dist_s[u] + 1 + dist_t[v] == original_dist + 1 ||\n                    dist_s[v] + 1 + dist_t[u] == original_dist + 1) {\n                    beauty++;\n                }\n            }\n        }\n    }\n\n    cout << beauty << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BeautyOfGraph {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int s = scanner.nextInt() - 1;\n        int t = scanner.nextInt() - 1;\n\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        int[] distS = bfs(adj, s);\n        int[] distT = bfs(adj, t);\n\n        int originalDist = distS[t];\n        int beauty = 0;\n\n        for (int u = 0; u < N; u++) {\n            for (int v = u + 1; v < N; v++) {\n                if (adj.get(u).contains(v)) {\n                    continue;\n                }\n                if (distS[u] + 1 + distT[v] == originalDist + 1 || distS[v] + 1 + distT[u] == originalDist + 1) {\n                    beauty++;\n                }\n            }\n        }\n\n        System.out.println(beauty);\n    }\n\n    private static int[] bfs(List<List<Integer>> adj, int start) {\n        int N = adj.size();\n        int[] dist = new int[N];\n        Arrays.fill(dist, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        dist[start] = 0;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : adj.get(u)) {\n                if (dist[v] == -1) {\n                    dist[v] = dist[u] + 1;\n                    queue.add(v);\n                }\n            }\n        }\n        return dist;\n    }\n}",
    "timestamp": "2025-08-05 21:49:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphBeauty {\n    public static int calculateBeauty(int n, List<int[]> edges, int s, int t) {\n        int beauty = 0;\n        \n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1];\n            \n            // Create a graph with the current edge added\n            List<List<Integer>> graph = new ArrayList<>(n + 1);\n            for (int i = 0; i < n + 1; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            for (int[] e : edges) {\n                graph.get(e[0]).add(e[1]);\n                graph.get(e[1]).add(e[0]);\n            }\n            \n            int originalShortestPath = bfs(graph, s, t);\n            \n            // Add temporary edge\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n            \n            int newShortestPath = bfs(graph, s, t);\n            \n            if (newShortestPath == originalShortestPath + 1) {\n                beauty++;\n            }\n        }\n        \n        return beauty;\n    }\n    \n    private static int bfs(List<List<Integer>> graph, int start, int end) {\n        int[] distance = new int[graph.size()];\n        Arrays.fill(distance, Integer.MAX_VALUE);\n        distance[start] = 0;\n        \n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            \n            if (current == end) {\n                return distance[end];\n            }\n            \n            for (int neighbor : graph.get(current)) {\n                if (distance[neighbor] == Integer.MAX_VALUE) {\n                    distance[neighbor] = distance[current] + 1;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        return Integer.MAX_VALUE;\n    }\n}",
    "timestamp": "2025-08-05 21:49:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint shortestPath(vector<vector<int>>& graph, int s, int t) {\n    int n = graph.size();\n    vector<int> dist(n, numeric_limits<int>::max());\n    dist[s] = 0;\n    queue<int> q;\n    q.push(s);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : graph[u]) {\n            if (dist[v] == numeric_limits<int>::max()) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n\n    return dist[t];\n}\n\nint calculateBeauty(vector<vector<int>>& graph, int s, int t) {\n    int n = graph.size();\n    int originalShortestPath = shortestPath(graph, s, t);\n    int beauty = 0;\n\n    for (int u = 0; u < n; u++) {\n        for (int v = u + 1; v < n; v++) {\n            if (find(graph[u].begin(), graph[u].end(), v) == graph[u].end()) {\n                graph[u].push_back(v);\n                graph[v].push_back(u);\n\n                int newShortestPath = shortestPath(graph, s, t);\n                if (newShortestPath == originalShortestPath + 1) {\n                    beauty++;\n                }\n\n                graph[u].pop_back();\n                graph[v].pop_back();\n            }\n        }\n    }\n\n    return beauty;\n}\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n\n    vector<vector<int>> graph(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u-1].push_back(v-1);\n        graph[v-1].push_back(u-1);\n    }\n\n    int result = calculateBeauty(graph, s-1, t-1);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef shortest_path_length(graph, start, target):\n    if start == target:\n        return 0\n    visited = set()\n    queue = deque([(start, 0)])\n    while queue:\n        current, dist = queue.popleft()\n        if current == target:\n            return dist\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, dist + 1))\n    return float('inf')\n\ndef calculate_beauty(n, edges, s, t):\n    graph = {i: [] for i in range(n)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    original_path_len = shortest_path_length(graph, s, t)\n    beauty_count = 0\n    \n    for u in range(n):\n        for v in range(u + 1, n):\n            if v not in graph[u]:\n                graph[u].append(v)\n                graph[v].append(u)\n                new_path_len = shortest_path_length(graph, s, t)\n                if new_path_len == original_path_len - 1:\n                    beauty_count += 1\n                graph[u].remove(v)\n                graph[v].remove(u)\n\n    return beauty_count\n\n# Example usage:\nn = 5  # number of vertices\nedges = [(0, 1), (1, 2), (1, 3), (3, 4)]\ns = 0\nt = 4\nprint(calculate_beauty(n, edges, s, t))  # Output: the beauty of the graph",
    "timestamp": "2025-08-13 07:41:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphBeauty {\n\n    static class Graph {\n        int V;\n        List<List<Integer>> adjList;\n\n        Graph(int V) {\n            this.V = V;\n            adjList = new ArrayList<>();\n            for (int i = 0; i < V; i++) {\n                adjList.add(new ArrayList<>());\n            }\n        }\n\n        void addEdge(int u, int v) {\n            adjList.get(u).add(v);\n            adjList.get(v).add(u);\n        }\n\n        int shortestPath(int s, int t) {\n            Queue<Integer> queue = new LinkedList<>();\n            boolean[] visited = new boolean[V];\n            int[] dist = new int[V];\n            \n            queue.add(s);\n            visited[s] = true;\n            dist[s] = 0;\n            \n            while (!queue.isEmpty()) {\n                int current = queue.poll();\n                for (int neighbor : adjList.get(current)) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        dist[neighbor] = dist[current] + 1;\n                        queue.add(neighbor);\n                    }\n                }\n            }\n            return visited[t] ? dist[t] : -1; // Return -1 if t is not reachable from s\n        }\n        \n        int calculateBeauty(int s, int t) {\n            int originalDistance = shortestPath(s, t);\n            if (originalDistance == -1) return 0;\n\n            int beauty = 0;\n            for (int u = 0; u < V; u++) {\n                for (int v = u + 1; v < V; v++) {\n                    if (!adjList.get(u).contains(v)) {\n                        adjList.get(u).add(v);\n                        adjList.get(v).add(u);\n\n                        int newDistance = shortestPath(s, t);\n\n                        adjList.get(u).remove(Integer.valueOf(v));\n                        adjList.get(v).remove(Integer.valueOf(u));\n\n                        if (originalDistance == newDistance + 1) {\n                            beauty++;\n                        }\n                    }\n                }\n            }\n            return beauty;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        Graph graph = new Graph(V);\n        for (int i = 0; i < E; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph.addEdge(u, v);\n        }\n\n        int s = scanner.nextInt();\n        int t = scanner.nextInt();\n\n        System.out.println(graph.calculateBeauty(s, t));\n    }\n}",
    "timestamp": "2025-08-13 07:41:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAXN 100\n\ntypedef struct {\n    int u, v;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAXN * MAXN];\n    int edgeCount;\n} EdgeList;\n\nint graph[MAXN][MAXN];\nint visited[MAXN];\nint dist[MAXN];\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid bfs(int start, int n) {\n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    dist[start] = 0;\n    int queue[MAXN];\n    int front = 0, rear = 0;\n    queue[rear++] = start;\n\n    while (front < rear) {\n        int current = queue[front++];\n        visited[current] = 1;\n        for (int i = 0; i < n; i++) {\n            if (graph[current][i] && !visited[i]) {\n                if (dist[current] + 1 < dist[i]) {\n                    dist[i] = dist[current] + 1;\n                    queue[rear++] = i;\n                }\n            }\n        }\n    }\n}\n\nint calculateBeauty(int n, int s, int t) {\n    EdgeList edgeList = {0};\n    int originalDist;\n    int beauty = 0;\n\n    bfs(s, n);\n    originalDist = dist[t];\n\n    for (int u = 0; u < n; u++) {\n        for (int v = u + 1; v < n; v++) {\n            if (!graph[u][v]) {\n                graph[u][v] = graph[v][u] = 1;\n                bfs(s, n);\n                if (dist[t] == originalDist - 1) {\n                    beauty++;\n                }\n                graph[u][v] = graph[v][u] = 0;\n            }\n        }\n    }\n\n    return beauty;\n}\n\nint main() {\n    int n, m, s, t;\n    scanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = graph[v][u] = 1;\n    }\n\n    int result = calculateBeauty(n, s, t);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:41:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef calculate_beauty(graph, s, t):\n    def shortest_path_length(g, start, end):\n        queue = deque([(start, 0)])\n        visited = set([start])\n        \n        while queue:\n            node, dist = queue.popleft()\n            \n            if node == end:\n                return dist\n            \n            for neighbor in g[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n        \n        return float('inf')\n\n    original_path_length = shortest_path_length(graph, s, t)\n    beauty = 0\n\n    for u in graph:\n        for v in graph[u]:\n            if u < v:  # Avoid counting same edge twice\n                # Create a new graph with the additional edge\n                modified_graph = defaultdict(list, {k: list(neighbors) for k, neighbors in graph.items()})\n                \n                if v not in modified_graph[u]:\n                    modified_graph[u].append(v)\n                    modified_graph[v].append(u)\n                \n                modified_path_length = shortest_path_length(modified_graph, s, t)\n                \n                if modified_path_length == original_path_length + 1:\n                    beauty += 1\n\n    return beauty",
    "timestamp": "2025-08-13 07:41:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    s = int(input[ptr]) - 1\n    ptr += 1\n    t = int(input[ptr]) - 1\n    ptr += 1\n    \n    adj = [[] for _ in range(N)]\n    existing_edges = set()\n    \n    for _ in range(M):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n        if u > v:\n            u, v = v, u\n        existing_edges.add((u, v))\n    \n    # BFS to compute distances from s and t\n    def bfs(start):\n        dist = [-1] * N\n        q = deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        return dist\n    \n    dist_s = bfs(s)\n    dist_t = bfs(t)\n    \n    if dist_s[t] == -1:\n        # t is unreachable from s\n        # Adding any edge will connect them, but the condition requires original distance +1 == new distance\n        # Original distance is infinity, so no edge can satisfy\n        print(0)\n        return\n    \n    original_dist = dist_s[t]\n    count = 0\n    \n    for u in range(N):\n        for v in range(u + 1, N):\n            if (u, v) in existing_edges:\n                continue\n            if dist_s[u] + 1 + dist_t[v] == original_dist or dist_s[v] + 1 + dist_t[u] == original_dist:\n                count += 1\n    \n    print(count)\n\nsolve()",
    "timestamp": "2025-08-13 07:41:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Graph {\n    int V;\n    vector<vector<int>> adj;\n\n    Graph(int V) : V(V), adj(V) {}\n\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int bfsShortestPath(int src, int dest) {\n        vector<int> dist(V, INT_MAX);\n        queue<int> q;\n\n        q.push(src);\n        dist[src] = 0;\n\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n\n            for (int v : adj[u]) {\n                if (dist[v] == INT_MAX) {\n                    dist[v] = dist[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        return dist[dest];\n    }\n};\n\nint calculateBeauty(Graph &graph, int s, int t) {\n    int originalDistance = graph.bfsShortestPath(s, t);\n    int beauty = 0;\n\n    for (int u = 0; u < graph.V; ++u) {\n        for (int v = u + 1; v < graph.V; ++v) {\n            // Check edge {u, v} doesn't exist\n            if (find(graph.adj[u].begin(), graph.adj[u].end(), v) == graph.adj[u].end()) {\n                // Temporarily add edge {u, v}\n                graph.addEdge(u, v);\n\n                int newDistance = graph.bfsShortestPath(s, t);\n\n                // Remove edge {u, v}\n                graph.adj[u].pop_back();\n                graph.adj[v].pop_back();\n\n                if (newDistance == originalDistance - 1) {\n                    beauty++;\n                }\n            }\n        }\n    }\n\n    return beauty;\n}\n\nint main() {\n    int V, E, s, t;\n    cin >> V >> E >> s >> t;\n\n    Graph graph(V);\n\n    for (int i = 0; i < E; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph.addEdge(u, v);\n    }\n\n    int beauty = calculateBeauty(graph, s, t);\n    cout << beauty << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:40:11"
  }
]