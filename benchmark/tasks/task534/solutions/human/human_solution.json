[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  import scala.io.StdIn._\n\n  val mod = 1000000007\n  val s = readLine.trim\n  implicit val memo = Array.tabulate(s.length){l ⇒ Array.tabulate(s.length - l){_ ⇒ -1L}}\n  val chars = new CharIndex(s)\n  println(\n    ('a' to 'z').map{c ⇒\n      (chars.nearestRight(c, 0), chars.nearestLeft(c, s.length - 1)) match{\n        case (Some(l), Some(r)) ⇒ f(l, r, chars)\n        case _ ⇒ 0\n      }\n    }.foldLeft(0L){case (l, r) ⇒ (l + r) % mod}\n  )\n  def f(exclusiveLeft: Int, exclusiveRight: Int, chars: CharIndex)(implicit memo: Array[Array[Long]]): Long = {\n    if (memo(exclusiveLeft)(exclusiveRight - exclusiveLeft) == -1) {\n      memo(exclusiveLeft)(exclusiveRight - exclusiveLeft) = if (exclusiveLeft == exclusiveRight) 1\n      else ('a' to 'z').map {c ⇒\n        (chars.nearestRight(c, exclusiveLeft + 1), chars.nearestLeft(c, exclusiveRight - 1)) match {\n          case (Some(l), Some(r)) if l <= r ⇒ f(l, r, chars)\n          case _ ⇒ 0\n        }\n      }.foldLeft(2L){case (l, r) ⇒ (l + r) % mod}\n    }\n    memo(exclusiveLeft)(exclusiveRight - exclusiveLeft)\n  }\n  class CharIndex(str: String) {\n    private val nearestRightArray = ('a' to 'z').map(c ⇒ Array.tabulate(str.length){i ⇒ if (str(i) == c) i else - 1}.also{a ⇒\n      for (i ← (1 until a.length).reverse){\n        if (a(i - 1) == -1) a(i - 1) = a(i)\n      }\n    })\n    private val nearestLeftArray = ('a' to 'z').map(c ⇒ Array.tabulate(str.length){i ⇒ if (str(i) == c) i else - 1}.also{a ⇒\n      for (i ← (1 until a.length)){\n        if (a(i) == -1) a(i) = a(i - 1)\n      }\n    })\n    def nearestRight(char: Char, index: Int): Option[Int] = {\n      nearestRightArray(char - 'a')(index) match {\n        case i if i == -1 ⇒ None\n        case i ⇒ Some(i)\n      }\n    }\n    def nearestLeft(char: Char, index: Int): Option[Int] = {\n      nearestLeftArray(char - 'a')(index) match {\n        case i if i == -1 ⇒ None\n        case i ⇒ Some(i)\n      }\n    }\n    def includeChatType(exclusiveLeft: Int, exclusiveRight: Int): Int = {\n      nearestLeftArray.count(a ⇒ a(exclusiveRight) > exclusiveLeft)\n    }\n  }\n  implicit class ScopeFunc[T](value: T){\n    def let[A](func: T ⇒ A): A = func(value)\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 1100000;\nll dy[8] = {0,1,0,-1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n\treturn modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n\treturn modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n\treturn modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n\treturn modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n\ta += rhs.a;\n\tif (a >= Modulus) {\n\t  a -= Modulus;\n\t}\n\treturn *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n\tif (a < rhs.a) {\n\t  a += Modulus;\n\t}\n\ta -= rhs.a;\n\treturn *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n\ta = a * rhs.a % Modulus;\n\treturn *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n\tu64 exp = Modulus - 2;\n\twhile (exp) {\n\t  if (exp % 2) {\n\t\t*this *= rhs;\n\t  }\n\t  rhs *= rhs;\n\t  exp /= 2;\n\t}\n\treturn *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nmint dp[5050][5050];\n\nint main(){\n\tstring s; cin >> s;\n\tstring t = s;\n\tll n = s.size();\n\treverse(all(t));\n\tvvl ns(n+1,vl(26,n)), nt(n+1,vl(26,n));\n\tfor(ll i=n-1; i>=0; i--){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j) ns[i][j] = i;\n\t\t\telse ns[i][j] = ns[i+1][j];\n\t\t\tif(t[i]-'a'==j) nt[i][j] = i;\n\t\t\telse nt[i][j] = nt[i+1][j];\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\trep(k,26){\n\t\t\t\tll nsid = ns[i][k];\n\t\t\t\tll ntid = nt[j][k];\n\t\t\t\tif(nsid + ntid + 2 <= n) dp[nsid+1][ntid+1] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmint ans = 0;\n\trep(i,n+1){\n\t\tfor(ll j=0; i+j<=n; j++){\n\t\t\tll mul = 1;\n\t\t\trep(k,26){\n\t\t\t\tif(ns[i][k] + 1 + j <= n) mul++;\n\t\t\t}\n\t\t\tans += dp[i][j] * mul;\n\t\t}\n\t}\n\tans -= 1;\n\tcout << ans.value() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int INF = 1 << 30;\nconst int mod = 1e9 + 7;\n\nstring S;\nint dp[2001][2001];\nint nearL[26][2001];\nint nearR[26][2001];\n\n\nint dfs(int l, int r) {\n  if(~dp[l][r]) return dp[l][r];\n  int64 ret = 0;\n  for(int i = 0; i < 26; i++) {\n    if(nearL[i][l] <= nearR[i][r]) ++ret;\n    if(nearL[i][l] < nearR[i][r]) ret += dfs(nearL[i][l] + 1, nearR[i][r] - 1) + 1;\n  }\n  return dp[l][r] = ret % mod;\n}\n\nint main() {\n  cin >> S;\n  fill_n(*nearL, 26 * 2001, INF);\n  memset(nearR, -1, sizeof(nearR));\n  for(int i = 0; i < S.size(); i++) {\n    nearL[S[i] - 'a'][i] = i;\n    nearR[S[i] - 'a'][i] = i;\n  }\n  for(int i = 0; i < 26; i++) {\n    for(int j = S.size() - 1; j >= 0; j--) {\n      nearL[i][j] = min(nearL[i][j], nearL[i][j + 1]);\n    }\n    for(int j = 1; j < S.size(); j++) {\n      nearR[i][j] = max(nearR[i][j], nearR[i][j - 1]);\n    }\n  }\n\n  memset(dp, -1, sizeof(dp));\n  cout << dfs(0, S.size() - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    string s;\n    cin>>s;\n    vector<vector<ll>> mx1(s.size()+2,vector<ll>(26,s.size()+1));\n    vector<vector<ll>> mx2(s.size()+2,vector<ll>(26,s.size()+1));\n    vector<ll> mx(26,s.size()+1);\n    for(ll i=s.size()-1;i>=0;i--){\n        mx[s[i]-'a']=i+1;\n        mx1[i]=mx;\n    }\n    reverse(s.begin(),s.end());\n    for(int i=0;i<26;i++){mx[i]=s.size()+1;}\n    for(ll i=s.size()-1;i>=0;i--){\n        mx[s[i]-'a']=i+1;\n        mx2[i]=mx;\n    }\n    vector<vector<ll>> dp(s.size()+2,vector<ll>(s.size()+2,0));\n    ll ans=0;\n    dp[0][0]=1;\n    for(int i=0;i<=s.size();i++){\n        for(int t=0;t<=s.size();t++){\n            dp[i][t]%=MOD;\n            for(int h=0;h<26;h++){\n                if(mx1[i][h]+mx2[t][h]<=s.size()){ans+=dp[i][t]; ans%=MOD;}\n                dp[mx1[i][h]][mx2[t][h]]+=dp[i][t];\n            }\n        }\n    }\n    for(int i=1;i<=s.size();i++){\n        for(int t=1;i+t<=s.size()+1;t++){\n            //cout<<i<<\" \"<<t<<\" \"<<dp[i][t]<<endl;\n            ans+=dp[i][t];\n            ans%=MOD;\n        }\n    }\n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return vec<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\n\n\nusing namespace std;\n\nconst size_t SIZE = 2010;\nconst ll mod = 1e9 + 7;\nconst ll inf = 5e15;\narray<array<ll, SIZE>, SIZE> dp;\narray<array<bool, SIZE>, SIZE> calced;\narray<array<ll, 26>, SIZE> cntf, cntb;\n\nll calc(ll l, ll r) {\n    if (calced[l][r]) return dp[l][r];\n    calced[l][r] = true;\n    ll ret = 0;\n    for (ll i = 0; i < 26; i++) {\n        ll fst = cntf[l][i], snd = cntb[r][i];\n        if (l <= fst && fst <= snd && snd <= r) ret += 1;\n        if (l <= fst && fst < snd && snd <= r) ret += calc(fst + 1, snd - 1) + 1;\n    }\n    return dp[l][r] = ret % mod;\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    for (auto &&e : cntf) fill(ALL(e), inf);\n    for (ll i = (ll)s.size() - 1; 0 <= i; i--) {\n        for (ll j = 0; j < 26; j++) cntf[i][j] = cntf[i + 1][j];\n        cntf[i][s[i] - 'a'] = i;\n    }\n\n    for (auto &&e : cntb) fill(ALL(e), -1);\n    cntb[0][s[0] - 'a'] = 0;\n    for (ll i = 1; i < s.size(); i++) {\n        for (ll j = 0; j < 26; j++) cntb[i][j] = cntb[i - 1][j];\n        cntb[i][s[i] - 'a'] = i;\n    }\n\n    cout << calc(0, s.size() - 1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(int i = (a); i > (b); --i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) __builtin_clzll(x)\n#define SZ(x) ((long long)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define cinfast() cin.tie(0), ios::sync_with_stdio(false)\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define MKORDER(n)                                                             \\\n    vector<int> od(n);                                                         \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    long long __VA_ARGS__;                                                     \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst double PI = atan(1.0) * 4.0;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n\n// 1000000007 で割ったあまりを扱う構造体\ntemplate <int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if(val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator-() const noexcept { return val ? MOD - val : 0; }\n    constexpr Fp operator+(const Fp &r) const noexcept {\n        return Fp(*this) += r;\n    }\n    constexpr Fp operator-(const Fp &r) const noexcept {\n        return Fp(*this) -= r;\n    }\n    constexpr Fp operator*(const Fp &r) const noexcept {\n        return Fp(*this) *= r;\n    }\n    constexpr Fp operator/(const Fp &r) const noexcept {\n        return Fp(*this) /= r;\n    }\n    constexpr Fp &operator+=(const Fp &r) noexcept {\n        val += r.val;\n        if(val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp &operator-=(const Fp &r) noexcept {\n        val -= r.val;\n        if(val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp &operator*=(const Fp &r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp &operator/=(const Fp &r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while(b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if(val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const Fp &r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const Fp &r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream &operator<<(ostream &os, const Fp<MOD> &x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream &operator>>(istream &is, Fp<MOD> &x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if(n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if(n & 1) t = t * a;\n        return t;\n    }\n};\n\nusing mint = Fp<MOD>;\n\nmint dp[2010][2010];\n\n// next c idx\nvector<vector<int>> calcNext(const string &S) {\n    int n = (int)S.size();\n    vector<vector<int>> res(n + 1, vector<int>(26, n));\n    for(int i = n - 1; i >= 0; --i) {\n        for(int j = 0; j < 26; ++j) res[i][j] = res[i + 1][j];\n        res[i][S[i] - 'a'] = i;\n    }\n    return res;\n}\n\nsigned main() {\n    SCIN(S);\n    ll N = S.length();\n    string T(S);\n    reverse(All(T));\n    auto nex = calcNext(S);\n    auto rnex = calcNext(T);\n    dp[0][0] = 1;\n    REP(i, N + 1) REP(j, N + 1) REP(k, 26) {\n        dp[nex[i][k] + 1][rnex[j][k] + 1] += dp[i][j];\n    }\n    mint res = 0;\n    REP(i, N + 1) REP(j, N + 1) {\n        if(i + j > N) continue;\n        int num = 1;\n        REP(k, 26) if(nex[i][k] + 1 + j <= N) num++;\n        res += dp[i][j] * num;\n    }\n    cout << res - 1 << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <set>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define SIZE 100010\n#define INF 1000000000\n#define mod 1000000007\n\nll dp[2010][2010];\nint posl[26][SIZE], posr[26][SIZE];\n\nint main(){\n  char s[2010];\n  int n;\n  set<int> ss[26], ss_b[26];\n\n  \n  \n  scanf(\"%s\", s);\n  n = strlen(s);\n\n  for(int i=0;i<26;i++){\n    for(int j=0;j<=n;j++){\n      posl[i][j] = INF;\n      posr[i][j] = -INF;\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    ss[s[i]-'a'].insert(i);\n    ss_b[s[i]-'a'].insert(-i);\n    //vec[s[i]-'a'].push_back(i);\n    posl[s[i]-'a'][i] = i;\n    posr[s[i]-'a'][i] = i;\n  }\n\n  for(int k=0;k<26;k++){\n    for(int i=0;i<n;i++) posr[k][i+1] = max(posr[k][i], posr[k][i+1]);\n    for(int i=n;i>0;i--) posl[k][i-1] = min(posl[k][i], posl[k][i-1]);\n  }\n  \n  for(int i=0;i<26;i++){\n    ss[i].insert(INF);\n    ss_b[i].insert(INF);\n  }\n\n  for(int i=0;i<26;i++){\n    int a = *ss[i].begin();\n    int b = -*ss_b[i].begin();\n\n    //cerr << a << \" \" << b << endl;\n    \n    if(a != b && a != INF && b != -INF){\n      dp[a][b]++;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      for(int k=0;k<26;k++){\n        int nextl = posl[k][i+1]; //*ss[k].lower_bound(i+1);\n        int nextr = posr[k][j-1]; //-*ss_b[k].lower_bound(-(j-1));\n\n        //if(i == 0 && j == 6) cerr << \" > \" << nextl << \" \" << nextr << endl;\n        \n        if(nextl < nextr){\n          dp[nextl][nextr] = (dp[nextl][nextr] + dp[i][j])%mod;\n        }\n      }      \n    }\n  }\n\n  ll ans = 0;\n  \n  for(int i=0;i<26;i++){\n    ans += ss[i].size() >= 2;\n  }\n\n  //cerr << ans << endl;\n  \n  for(int i=0;i<n;i++){\n    for(int j=i;j<n;j++){\n      //if(dp[i][j]) cerr << i << \" \" << j << \" \" << dp[i][j] << endl; \n      ans = (ans + dp[i][j])%mod;\n\n      for(int k=0;k<26;k++){\n        if(posl[k][i+1] < j){\n          ans = (ans + dp[i][j])%mod;\n        }\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", ans%mod);\n  return 0;\n}\n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n\nconst ll MOD = 1000000007;\nvector<vector<int> > calcNext(const string &S) {\n    int n = (int)S.size();\n    vector<vector<int> > res(n+1, vector<int>(26, n));\n    for (int i = n-1; i >= 0; --i) {\n        for (int j = 0; j < 26; ++j) res[i][j] = res[i+1][j];\n        res[i][S[i]-'a'] = i;\n    }\n    return res;\n}\n\n\nint main(void){\n    // Your code here!\n    string S;\n    cin >> S;\n    auto ns = calcNext(S);\n    string T = S;\n    reverse(T.begin(), T.end());\n    auto nt = calcNext(T);\n    \n    int N = (int)S.size();\n    vector<vector<ll> > dp(N+1, vector<ll>(N+1, 0));\n    dp[0][0] = 1;\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            for(int k = 0; k < 26; k++){\n                if(ns[i][k] + nt[j][k] + 2 > N) continue;\n                dp[ns[i][k] + 1][nt[j][k] + 1] += dp[i][j];\n                dp[ns[i][k] + 1][nt[j][k] + 1] = dp[ns[i][k] + 1][nt[j][k] + 1] % MOD;\n            }\n        }\n    }\n    \n    ll res = 0;\n    for(int i = 0; i<= N; i++) {\n        for(int j = 0; j <= N; j++){\n            int num = 1;\n            for(int k = 0; k < 26; k++){\n                if(ns[i][k] + 1 + j <= N) num++;\n                \n            }\n            res += (num * dp[i][j]) % MOD;\n            res =  res % MOD;\n        }\n    }\n    cout << res-1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> &a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\ntemplate<class T>void prArr(T a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n_int used[2001][2001];\n_int mem[2001][2001];\nvector<vector<Int> >Idx(30);\nstring s;\nInt dfs(Int l, Int r){\n  //pr(l, r);\n  if(l > r) return 1;\n  if(l == r) return 2;\n  if(used[l][r]++) return mem[l][r];\n\n  Int res = 1;\n  for(Int i=0;i<26;i++){\n    Int idxl = lower_bound(Idx[i].begin(), Idx[i].end(), l) - Idx[i].begin();\n    Int idxr = upper_bound(Idx[i].begin(), Idx[i].end(), r) - Idx[i].begin();\n    idxr--;\n    \n    if(idxl >= (int)Idx[i].size() || idxr >=(int)Idx[i].size()) continue;\n    if(idxl < 0 || idxr < 0) continue;\n    int nl = Idx[i][idxl];\n    int nr = Idx[i][idxr];\n    if((nl > nr)) continue;\n    if(!(l <= nl && nr <= r)) continue;\n    if(s[nl] != i + 'a' || s[nr] != i + 'a') continue;\n    res = (res + 1) % mod;\n    if(nl != nr) res = (res + dfs(nl+1, nr-1)) % mod;\n  }\n  return mem[l][r] = res;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin>>s;\n  int n = s.size();\n  for(Int i=0;i<(Int)s.size();i++) Idx[s[i] - 'a'].push_back(i);\n\n  int ans = 0;\n  for(Int i=0;i<26;i++){\n    Int idxl = lower_bound(Idx[i].begin(), Idx[i].end(), 0) - Idx[i].begin();\n    Int idxr = upper_bound(Idx[i].begin(), Idx[i].end(), n-1) - Idx[i].begin();\n    idxr--;\n    if(idxl >= (int)Idx[i].size() || idxr >=(int)Idx[i].size()) continue;\n    if(idxl < 0 || idxr < 0) continue;\n    \n    int nl = Idx[i][idxl];\n    int nr = Idx[i][idxr];\n    \n    if(nl >= n || nr >= n) continue;\n    if(nl < 0 || nr < 0) continue;\n    if(s[nl] != i + 'a' || s[nr] != i + 'a') continue;    \n    //pr(char(i+'a'), nl, nr,dfs(nl+1, nr-1));\n    ans = (ans+1)%mod;\n    if(nl != nr) ans = (ans + dfs(nl+1, nr-1)) % mod;\n  } \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nint main(){\n    string s;\n    cin >> s;\n    int n = int(s.length());\n    string t = string(s);\n    reverse(t.begin(), t.end());\n\n    /*\n    type_cnt[i][j]: i文字目からj文字目までの間 (閉区間) に何種類の文字があるか\n    */\n    ll type_cnt[n+1][n+1];\n    fill(type_cnt[0], type_cnt[n+1], 0LL);\n    for(int i=0;i<n;i++){\n        type_cnt[i+1][i+1] = 1LL;\n        bool alphabets[26];\n        fill(alphabets, alphabets+26, false);\n        alphabets[s[i]-'a'] = true;\n        for(int j=i+1;j<n;j++){\n            if(alphabets[s[j]-'a']){\n                type_cnt[i+1][j+1] = type_cnt[i+1][j];\n            }else{\n                type_cnt[i+1][j+1] = type_cnt[i+1][j]+1LL;\n                alphabets[s[j]-'a'] = true;\n            }\n        }\n    }\n\n    /*\n    next_pos[k][i][j]: i文字目よりも後ろに登場する文字('a'+j)で最も近いものが何文字目か\n    k = 0ならs，k=1ならt\n    */\n   ll next_pos[2][n+1][26];\n   fill(next_pos[0][0], next_pos[1][n+1], n+1);\n   for(int i=n-1;i>=0;i--){\n       for(int j=0;j<26;j++){\n           if(s[i] - 'a' == j){\n               next_pos[0][i][j] = i+1;\n           }else{\n               next_pos[0][i][j] = next_pos[0][i+1][j];\n           }\n           if(t[i] - 'a' == j){\n               next_pos[1][i][j] = i+1;\n           }else{\n               next_pos[1][i][j] = next_pos[1][i+1][j];\n           }\n       }\n   }\n\n    /*\n    dp[i][j]: sをs[i-1]まで，tをt[j-1]まで見た\n    */\n    ll dp[n+1][n+1];\n    fill(dp[0], dp[n+1], 0LL);\n    dp[0][0] = 1LL;\n    for(int k=0;k<26;k++){\n        if(next_pos[0][0][k] != n+1 && next_pos[1][0][k] != n+1){\n            dp[next_pos[0][0][k]][next_pos[1][0][k]]++;\n        }\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            dp[i][j] %= MOD;\n            if(dp[i][j]) for(int k=0;k<26;k++){\n                if(next_pos[0][i][k] != n+1 && next_pos[1][j][k] != n+1){\n                    dp[next_pos[0][i][k]][next_pos[1][j][k]] += dp[i][j];\n                }\n            }\n        }\n    }\n    \n    ll ans = 0LL;\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=n;j++){\n            if(!dp[i][j]) continue;\n            if(i+j <= n){\n                ans += (dp[i][j] * (((i+1<=n-j)?type_cnt[i+1][n-j]:0LL)+1LL)) % MOD;\n                ans %= MOD;\n            }\n        }\n    }\n    ans--;\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n#include <queue>\n#include <tuple>\n#include <cmath>\n#include <bitset>\n#include <cctype>\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define PRINT(V) cout << V << \"\\n\"\n#define SORT(V) sort((V).begin(),(V).end())\n#define RSORT(V) sort((V).rbegin(), (V).rend())\nusing namespace std;\nusing ll = long long;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n    auto val = table(args...);\n    return vector<decltype(val)>(n, move(val));\n}\nconst ll INF = 1e10;\nconst ll MOD = 1000000007;\ntypedef pair<ll,ll> P;\nconst ll MAX = 200005;\nvector<vector<ll>> Next(string s){\n    int n = s.size();\n    vector<vector<ll>> res(n+1,vector<ll>(26,n));\n    for(int i = n-1;i >= 0;i--){\n        rep(j,26){\n            res[i][j] = res[i+1][j];\n        }\n        res[i][s[i]-'a'] = i;\n    }\n    return res;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s,t = \"\";\n    cin >> s;\n    ll n = s.size();\n    rep(i,n){\n        t += s[n-i-1];\n    }\n    vector<vector<ll>> ns = Next(s);\n    vector<vector<ll>> nt = Next(t);\n    vector<vector<ll>> dp(n+1,vector<ll>(n+1,0));\n    dp[0][0] = 1;\n    rep(i,n){\n        rep(j,n){\n            rep(k,26){\n                if(ns[i][k] + nt[j][k] + 2 > n) continue;\n                dp[ns[i][k]+1][nt[j][k]+1] += dp[i][j];\n                dp[ns[i][k]+1][nt[j][k]+1] %= MOD;\n            }\n        }\n    }\n    ll ans = 0,c;\n    rep(i,n+1){\n        rep(j,n+1){\n            c = 1;\n            if (i+j > n) continue;\n            rep(k,26){\n                if(ns[i][k]+1+j <= n) c++;\n            }\n            ans += c*dp[i][j]%MOD;\n            ans %= MOD;\n        }\n    }\n    PRINT((ans+MOD-1)%MOD);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\n\n\nint N;\nstring S;\nvint idx[26];\nint dp[2222][2222];\n\nconst int INF=1001001001;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nint uku[26][2222];\nint beet[26][2222];\n\nsigned main(){\n    cin>>S;\n    N=S.size();\n\n    fill_n(*uku,26*2222,INF);\n    fill_n(*beet,26*2222,-1);\n\n    rep(i,N){\n        uku[S[i]-'a'][i]=i;\n        beet[S[i]-'a'][i]=i;\n    }\n    for(int k=0;k<26;k++)for(int i=N-1;i>=0;i--)chmin(uku[k][i],uku[k][i+1]);\n    for(int k=0;k<26;k++)for(int i=0;i<N;i++)chmax(beet[k][i+1],beet[k][i]);\n\n    rep(i,N){\n        dp[i][i]=1;\n        dp[i][i+1]=2;\n    }\n\n    vint s(26),t(26);\n\n    for(int len=2;len<=N;len++){\n        for(int i=0;i+len<=N;i++){\n            int j=i+len;\n            dp[i][j]=1;\n            rep(k,26){\n                s[k]=uku[k][i];\n                t[k]=beet[k][j-1];\n            }\n            rep(k,26){\n                if(i<=s[k]&&s[k]<j)dp[i][j]++;\n                if(j<=s[k])continue;\n                if(s[k]>=t[k])continue;\n                add(dp[i][j],dp[s[k]+1][t[k]]);\n            }\n        }\n    }\n    cout<<(dp[0][N]-1+mod)%mod<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\n\nconst ll MOD = 1e9+7;\n\nstring S, T;\nint n;\nint nxt[2005][26], nxt_reverse[2005][26]; // i文字目以降で最初に文字cが登場するidx\nll dp[2005][2005]; //\n\nint main() {\n    cin >> S;\n    n = S.size();\n    T = S;\n    reverse(T.begin(), T.end());\n\n    fill(nxt[0], nxt[n+1], n);\n    for (int i = n-1; i >= 0; i--) {\n        for (int j = 0; j < 26; j++) {\n            nxt[i][j] = nxt[i+1][j];\n        }\n        nxt[i][S[i] - 'a'] = i;\n    }\n\n    fill(nxt_reverse[0], nxt_reverse[n+1], n);\n    for (int i = n-1; i >= 0; i--) {\n        for (int j = 0; j < 26; j++) {\n            nxt_reverse[i][j] = nxt_reverse[i+1][j];\n        }\n        nxt_reverse[i][T[i] - 'a'] = i;\n    }\n\n    dp[0][0] = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < 26; k++) {\n                int s_idx = nxt[i][k];\n                int t_idx = nxt_reverse[j][k];\n                if (s_idx + t_idx + 2 > n) continue;\n                (dp[s_idx + 1][t_idx + 1] += dp[i][j]) %= MOD;\n            }\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int cnt = 1;\n            for (int k = 0; k < 26; k++) {\n                if (nxt[i][k] + 1 + j <= n) {\n                    cnt++;\n                }\n            }\n            (ans += dp[i][j] * cnt) %= MOD;\n        }\n    }\n\n    cout << ans - 1<< \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nconst Int MAX = 2020;\nInt dp[MAX][MAX];\nconst Int MOD = 1e9+7;\nInt ri[MAX][27],le[MAX][27];;\nInt n;\nstring s;\nInt dfs(Int l,Int r){\n  if(~dp[l][r]) return dp[l][r];\n  Int &res=dp[l][r];\n  res=1;\n  for(Int i=0;i<26;i++){\n    if(ri[l][i]<r&&le[r][i]>l){\n      res++;\n      if(ri[l][i]<le[r][i]) res+=dfs(ri[l][i],le[r][i]);\n      res%=MOD;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  cin>>s;\n  s=char('a'+26)+s+char('a'+26);\n  n=s.size();\n  for(Int i=0;i<n;i++) s[i]-='a';\n  memset(dp,-1,sizeof(dp));\n  for(Int i=0;i<27;i++) ri[n-1][i]=n,le[0][i]=-1;\n  for(Int i=n-2;i>=0;i--){\n    for(Int j=0;j<27;j++){\n      if(s[i+1]==j) ri[i][j]=i+1;\n      else ri[i][j]=ri[i+1][j];\n    }\n  }\n  for(Int i=1;i<n;i++){\n    for(Int j=0;j<27;j++){\n      if(s[i-1]==j) le[i][j]=i-1;\n      else le[i][j]=le[i-1][j];\n    }\n  }\n  cout<<(dfs(0,n-1)+MOD-1)%MOD<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr<<#x<<\" = \"<<(x)<<\" (line \"<<__LINE__<< \")\"<<endl\n#define showA(a, n) \\\n  do{for(int i=0;i<(n);i++)cerr<<\"(\"<<i<<\" = \"<<(a)[i]<<\") \";cerr<<endl;}while(0)\n#define showA2(a, n, m) \\\n  do{for(int i=0;i<(n);i++){for(int j=0;j<(m);j++){cerr<<\"(\"<<i<<\", \"<<j<<\" = \"<<(a)[i][j]<<\") \";}cerr<<endl;}cerr<<endl;}while(0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n/* MOD */\nll MOD = 1000000000LL + 7LL;\nclass Mint {\npublic:\n  ll x;\n  Mint() : x(0) {}\n  Mint(const int x) {\n    if (x < MOD && x >= 0) this->x = x;\n    else this->x = (MOD + x % MOD) % MOD;\n  }\n  Mint(const ll x) {\n    if (x < MOD && x >= 0) this->x = x;\n    else this->x = (MOD + x % MOD) % MOD;\n  }\n  Mint(const Mint& c) {\n    this->x = c.x;\n  }\n  Mint& operator=(const int c) {\n    if (c < MOD && c >= 0) this->x = c;\n    else this->x = (MOD + c % MOD) % MOD;\n    return *this;\n  }\n  Mint& operator=(const ll c) {\n    if (c < MOD && c >= 0) this->x = c;\n    else this->x = (MOD + c % MOD) % MOD;\n    return *this;\n  }\n  Mint& operator=(const Mint c) {\n    this->x = c.x;\n    return *this;\n  }\n  bool operator==(const Mint &b) {\n    return x == b.x;\n  }\n  bool operator!=(const Mint &b) {\n    return !(x == b.x);\n  }\n  bool operator<(const Mint &b) {\n    return x < b.x;\n  }\n  bool operator>(const Mint &b) {\n    return x > b.x;\n  }\n};\nostream &operator<<(ostream& out, const Mint &mint) {\n  out << mint.x;\n  return out;\n}\nistream &operator>>(istream& in, const Mint &mint) {\n  in >> mint.x;\n  return in;\n}\ninline Mint add(const Mint a, const Mint b) {\n  const ll x = (a.x + b.x) % MOD;\n  return Mint(x);\n}\ninline Mint mul(const Mint a, const Mint b) {\n  ll x = (a.x * b.x) % MOD;\n  return Mint(x);\n}\ntemplate <typename T>\nMint ModPow(Mint a, T b) {\n  assert(b >= 0);\n  Mint res = 1;\n  while (b)\n  {\n    if (b & 1)\n      res = mul(res, a);\n    b >>= 1;\n    a = mul(a, a);\n  }\n  return res;\n}\ninline Mint ModInverse(const Mint x) {\n  ll a = x.x, b = MOD, u = 1, v = 0;\n  while (b) {\n    ll t = a / b;\n    swap(a -= t * b, b);\n    swap(u -= t * v, v);\n  }\n  Mint res(u);\n  return res;\n}\ninline Mint operator-(const Mint x) {\n  return Mint(-x.x);\n}\ninline Mint operator+(const Mint a, const Mint b) {\n  return add(a, b);\n}\ninline Mint operator*(const Mint a, const Mint b) {\n  return mul(a, b);\n}\ninline Mint operator-(const Mint a, const Mint b) {\n  return add(a, -b);\n}\ntemplate<typename T>\ninline Mint operator+(const Mint a, const T b) {\n  return add(a, Mint(b));\n}\ntemplate<typename T>\ninline Mint operator*(const Mint a, const T b) {\n  return mul(a, Mint(b));\n}\ntemplate<typename T>\ninline Mint operator-(const Mint a, const T b) {\n  return add(a, Mint(-b));\n}\ntemplate<typename T>\ninline Mint operator/(const Mint a, const T b) {\n  return mul(a, ModInverse(Mint(b)));\n}\ntemplate<typename T>\ninline Mint operator^(const Mint a, const T b) {\n  return ModPow(a, b);\n}\ntemplate<typename T>\ninline Mint operator+=(Mint& a, const T b) {\n  a = a + b;\n  return a;\n}\ntemplate<typename T>\ninline Mint operator-=(Mint& a, const T b) {\n  a = a - b;\n  return a;\n}\ntemplate<typename T>\ninline Mint operator*=(Mint& a, const T b) {\n  a = a * b;\n  return a;\n}\ntemplate<typename T>\ninline Mint operator/=(Mint& a, const T b) {\n  a = a / b;\n  return a;\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      res *= v[i].fi - 1;\n    }\n    else\n    {\n      res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n    }\n  }\n  return res;\n}\ntemplate<typename T, typename S>\nMint comb(T a, S b)\n{\n  chmin(b, a - b);\n  Mint res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res *= now;\n    res /= i;\n    now -= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\ntemplate<typename T>\nclass Dinic{\npublic:\n  Dinic(int SIZE) :SIZE(SIZE) {\n    v = vector<vector<tuple<int, T, int>>>(SIZE + 10);\n  }\n\n  void AddEdge(int from, int to, T cap) {\n    v[from].push_back(make_tuple(to, cap, v[to].size()));\n    v[to].push_back(make_tuple(from, 0, v[from].size() - 1));\n  }\n\n  void bfs(int s) {\n    level = vector<int>(SIZE + 10, -1);\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int now = q.front(); q.pop();\n      for (int i = 0; i < (int)v[now].size(); i++) {\n        int next, nextrv; T nextc; tie(next, nextc, nextrv) = v[now][i];\n        if (nextc > 0 && level[next] < 0) {\n          level[next] = level[now] + 1;\n          q.push(next);\n        }\n      }\n    }\n  }\n\n  T dfs(int now, int t, T f) {\n    if (now == t) return f;\n    for (int &i = iter[now]; i < (int)v[now].size(); i++) {\n      int next, nextrv; T nextc; tie(next, nextc, nextrv) = v[now][i];\n      if (nextc > 0 && level[now] < level[next]) {\n        T d = dfs(next, t, min(f, nextc));\n        if (d > 0) {\n          get<1>(v[now][i]) -= d;\n          get<1>(v[next][nextrv]) += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  T max_flow(int s, int t) {\n    T flow = 0;\n    for (;;) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      iter = vector<int>(SIZE + 10, 0);\n      int f;\n      while ((f = dfs(s, t, INT_MAX)) > 0) {\n        flow += f;\n      }\n    }\n  }\nprivate:\n  int SIZE;\n  vector<vector<tuple<int, T, int>>> v;\n  vector<int> level, iter;\n};\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\ntemplate<typename T>\nusing Matrix = vector<vector<T>>;\n\ntemplate<typename T>\nvoid init(int h, int w, Matrix<T> &matrix) {\n    matrix = vector<vector<T>>(h, vector<T>(w));\n    /*for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cin >> matrix[i][j];\n        }\n    }*/\n}\ntemplate<typename T>\nMatrix<T> &operator*(Matrix<T> &matrix, Matrix<T> &matrix1) {\n    int height = (int)matrix.size();\n    int width = (int)matrix[0].size();\n    int height2 = (int)matrix1.size();\n    int width2 = (int)matrix1[0].size();\n    assert(width == height2);\n    Matrix<T> res;\n    res = vector<vector<T>>(height, vector<T>(width2, 0));\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width2; j++) {\n            for (int k = 0; k < width; k++) {\n                res[i][j] += matrix[i][k] * matrix1[k][j];\n            }\n        }\n    }\n    matrix.swap(res);\n    return matrix;\n}\ntemplate<typename T>\nMatrix<T> Pow(Matrix<T> matrix, ll x) {\n    Matrix<T> res = vector<vector<T>>(matrix.size(), vector<T>(matrix.size(), 0));\n    for (int i = 0; i < (int)matrix.size(); i++) {\n        res[i][i] = 1;\n    }\n    while (x) {\n        if (x & 1) {\n            res = res * matrix;\n        }\n        matrix = matrix * matrix;\n        x >>= 1;\n    }\n    return res;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n// Mintの数値にしたいときは、Mint(i)みたいにキャストしてね\n\nstring s;\nint nexts[2001][30], nextt[2001][30];\nMint dp[2001][2001];\n\nint main() {\n  cin >> s;\n  string t = s;\n  int n = (int)s.size();\n  reverse(all(t));\n  rep(i, 0, 26) {\n    nexts[n][i] = n;\n    nextt[n][i] = n;\n  }\n  rrep(i, n - 1, -1) {\n    rep(j, 0, 26) {\n      nextt[i][j] = nextt[i + 1][j];\n      nexts[i][j] = nexts[i + 1][j];\n    }\n    nexts[i][s[i] - 'a'] = i;\n    nextt[i][t[i] - 'a'] = i;\n  }\n  dp[0][0] = 1;\n  rep(i, 0, n + 1) {\n    rep(j, 0, n + 1) {\n      if (i > 0 && j > 0 && s[i - 1] != t[j - 1]) continue;\n      if (i + j > n) continue;\n      rep(k, 0, 26) {\n        if (nexts[i][k] != n && nextt[j][k] != n && nextt[j][k] + nexts[i][k] + 2 <= n)\n          dp[nexts[i][k] + 1][nextt[j][k] + 1] += dp[i][j];\n      }\n    }\n  }\n  Mint ans = 0;\n  rep(i, 0, n + 1) {\n    rep(j, 0, n + 1) {\n      int cnt = 1;\n      rep(k, 0, 26) if (nexts[i][k] + j + 1 <= n) cnt++;\n      ans += dp[i][j] * cnt;\n    }\n  }\n  cout << ans - 1 << endl;\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n/*\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nlong long int INF = 1001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\n\ntemplate<typename T1,typename T2>inline void chmin(T1 &a,const T2 &b){if(a>b) a=b;}\ntemplate<typename T1,typename T2>inline void chmax(T1 &a,const T2 &b){if(a<b) a=b;}\n\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n\n/* do your best */\n\nlint solve(string s) {\n  \n  int n = s.size();\n  string t = s;\n  reverse(ALL(t));\n\n  // next[i][c] := s[i] 以降で最初に出現する c の位置\n  vector<vector<int>> ns(n + 1, vector<int>(26, n));\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = 0; j < 26; j++) {\n      ns[i][j] = ns[i + 1][j];\n    }\n    ns[i][s[i] - 'a'] = i;\n  }\n\n  vector<vector<int>> nt(n + 1, vector<int>(26, n));\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = 0; j < 26; j++) {\n      nt[i][j] = nt[i + 1][j];\n    }\n    nt[i][t[i] - 'a'] = i;\n  }\n\n  vector<vector<lint>> dp(n + 1, vector<lint>(n + 1, 0));\n  dp[0][0] = 1;\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      for (int k = 0; k < 26; k++) {\n        int ni = ns[i][k];\n        int nj = nt[j][k];\n        if (ni + nj + 2 > n) continue;\n        dp[ni + 1][nj + 1] += dp[i][j];\n        dp[ni + 1][nj + 1] %= MOD;\n      }\n    }\n  }\n\n  lint ret = 0;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; i + j <= n; j++) {\n      int num = 1;\n      for (int k = 0; k < 26; k++) {\n        if (ns[i][k] + 1 + j <= n) {\n          num++;\n        }\n      }\n      ret = (ret + dp[i][j] * num % MOD) % MOD;\n    }\n  }\n\n  return (ret - 1) % MOD;\n}\n\nint main() {\n  \n  string s; cin >> s;\n  cout << solve(s) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nusing ll = long long;\nusing P = pair<int, int>;\n\nconst int mod = 1000000007;\nstruct mint {\n  ll x; \n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n\nmint f(int n){ \n  if(n == 0)return 1;\n  mint x = f(n / 2); \n  x *= x; \n  if(n % 2 == 1)x *= 2;\n  return x;\n}\n\nmint choose(int n, int a){\n  mint x = 1, y = 1;\n  for(int i = 0; i < a; ++i){\n    x *= n - i;\n    y *= i + 1;\n  }\n  return x / y;\n}\n\nvector<vector<int>> calcNext(const string &s){\n\tint n = s.size();\n\tvector<vector<int>> res(n + 1, vector<int>(26, n)); \n\tfor(int i = n - 1; i >= 0; --i){\n\t\tfor(int c = 0; c < 26; ++c){\n\t\t\tres[i][c] = res[i + 1][c]; \n\t\t\tres[i][s[i] - 'a'] = i; \n\t\t}\n\t}\n\n\treturn res;\n}\n\nvector<vector<mint>> dp;\n\nint main(){\n  string s;\n  cin >> s;\n\n  int n = s.size();\n  string t = s;\n  reverse(t.begin(), t.end());\n\n  auto next_s = calcNext(s);\n  auto next_t = calcNext(t);\n  dp = vector<vector<mint>>(n + 1, vector<mint>(n + 1, 0));\n  dp[0][0] = 1; \n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      for(int c = 0; c < 26; ++c){\n        int ni = next_s[i][c];\n        int nj = next_t[j][c];\n        if(ni + nj <= n - 2)dp[ni + 1][nj + 1] += dp[i][j];\n      }\n    }\n  }\n\n  mint ans = 0;\n  for(int i = 0; i <= n; ++i){\n  \tfor(int j = 0; j <= n - i; ++j){\n      mint num = 1;\n      for(int c = 0; c < 26; ++c){\n        if(next_s[i][c] + 1 + j <= n)num += 1;\n      }\n      ans += dp[i][j] * num;\n    }\n  }\n\n  cout << ans.x - 1 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nusing V = vector<LL>;\nusing VV = vector<V>;\n\nconstexpr int mod = 1e9 + 7;\nint main() {\n\tstring S;\n\tcin >> S;\n\tLL ret = 0;\n\tint N = S.size();\n\tVV prev_link(N, V(26));\n\tVV next_link(N, V(26));\n\tV lp(26, -1), ln(26, -1);\n\n\t{\n\t\tfor(int i:range(N)){\n\t\t\tprev_link[i] = lp;\n\t\t\tlp[S[i] - 'a'] = i;\n\t\t}\n\t}\n\t{\n\t\tfor (int ri : range(N)) {\n\t\t\tconst int i = N - 1 - ri;\n\t\t\tnext_link[i] = ln;\n\t\t\tln[S[i] - 'a'] = i;\n\t\t}\n\t}\n\tVV dp(N, V(N, 0));\n\tfor(int i:range(26)) {\n\t\tif (ln[i] >= 0 && lp[i] >= 0) {\n\t\t\tdp[ln[i]][lp[i]]++;\n\t\t\tret++;\n\t\t}\n\t}\n\tfor (int l : range(N)) {\n\t\tfor (int rr : range(N)) {\n\t\t\tconst int r = N - 1 - rr;\n\t\t\tif (l >= r)continue;\n\t\t\tret += dp[l][r];\n\t\t\tfor (int i : range(26)) {\n\t\t\t\tint nl = next_link[l][i];\n\t\t\t\tint nr = prev_link[r][i];\n\t\t\t\tif (nl >= 0 && nr >= 0 && nl < nr) {\n\t\t\t\t\t(dp[nl][nr] += dp[l][r]) %= mod;\n\t\t\t\t}\n\t\t\t\tif (nl == -1 && nr == -1)continue;\n\t\t\t\tint p = max(nl, nr);\n\t\t\t\tif (l < p&&p < r) {\n\t\t\t\t\tret += dp[l][r];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret%mod << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tint L[2002][26];\n\tint R[2002][26];\n\tstring str;cin>>str;\n\tint i,j,c,n=str.size();\n\tstr.insert(str.begin(),'#');\n\tstr.pub('#');\n\tfor(c=0;c<26;c++){\n\t\tint gen=0;\n\t\tfor(i=0;i<=n+1;i++){\n\t\t\tL[i][c]=gen;\n\t\t\tif(str[i]-'a'==c){gen=i;}\n\t\t}\n\t\tgen=n+1;\n\t\tfor(i=n+1;i>=0;i--){\n\t\t\tR[i][c]=gen;\n\t\t\tif(str[i]-'a'==c){gen=i;}\n\t\t}\n\t}\n\tllint ans=-2;\n\tstatic llint dp[2002][2002]={0};\n\tdp[0][n+1]=1;\n\tfor(i=0;i<=n+1;i++){\n\t\tfor(j=n+1;j>=i;j--){\n\t\t\tdp[i][j]%=mod;\n\t\t\tans+=dp[i][j];\n\t\t\tif(i<j){ans+=dp[i][j];}\n\t\t\tans%=mod;\n\t\t\tfor(c=0;c<26;c++){dp[R[i][c]][L[j][c]]+=dp[i][j];}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (int)(n); i ++)\n#define irep(i,n) for (int i = (int)n - 1;i >= 0;--i)\nusing namespace std;\nusing ll = long long;\nusing PL = pair<ll,ll>;\nusing P = pair<int,int>;\nconstexpr int INF = 1000000000;\nconstexpr long long HINF = 1000000000000000;\nconstexpr long long MOD = 1000000007;// = 998244353;\nconstexpr double EPS = 1e-4;\nconstexpr double PI = 3.14159265358979;\n\ntemplate<int Modulus> \nstruct ModInt {\n    long long x;\n    ModInt(long long x = 0) :x((x%Modulus + Modulus)%Modulus) {}\n    constexpr ModInt &operator+=(const ModInt a) {if ((x += a.x) >= Modulus) x -= Modulus; return *this;}\n    constexpr ModInt &operator-=(const ModInt a) {if ((x += Modulus - a.x) >= Modulus) x -= Modulus; return *this;}\n    constexpr ModInt &operator*=(const ModInt a) {(x *= a.x) %= Modulus; return *this;}\n    constexpr ModInt &operator/=(const ModInt a) {return *this *= a.inverse();}\n\n    constexpr ModInt operator+(const ModInt a) const {return ModInt(*this) += a.x;}\n    constexpr ModInt operator-(const ModInt a) const {return ModInt(*this) -= a.x;}\n    constexpr ModInt operator*(const ModInt a) const {return ModInt(*this) *= a.x;}\n    constexpr ModInt operator/(const ModInt a) const {return ModInt(*this) /= a.x;}\n    \n    friend constexpr ostream& operator<<(ostream& os,const ModInt<Modulus>& a) {return os << a.x;}\n    friend constexpr istream& operator>>(istream& is,ModInt<Modulus>& a) {return is >> a.x;}\n    \n    ModInt inverse() const {// x ^ (-1) \n        long long a = x,b = Modulus,p = 1,q = 0;\n        while (b) {long long d = a/b; a -= d*b; swap(a,b); p -= d*q; swap(p,q);}\n        return ModInt(p);\n    }\n    ModInt pow(long long N) {// x ^ N \n        ModInt a = 1;\n        while (N) {\n            if (N&1) a *= *this;\n            *this *= *this;\n            N >>= 1;\n        }\n        return a;\n    }\n};\n\nusing mint = ModInt<1000000007>;\n\n//nexS[i][j] = i番目以降でj番目のアルファベットが一番初めに現れるindex\nvector<vector<int>> next_calc(const string &S) {\n    int N = S.size();\n    vector<vector<int>> ret(N + 1,vector<int>(26,N));\n    for (int i = N - 1;i >= 0;--i) {\n        for (int j = 0; j < 26;++j) {\n            ret[i][j] = ret[i + 1][j];\n        }\n        ret[i][S[i] - 'a'] = i;\n    }\n    return ret;\n}\n\nint main() {\n    string S; cin >> S;\n    string T = S;\n    reverse(T.begin(),T.end());\n    int N = S.size();\n    vector<vector<mint>> dp(N + 1,vector<mint>(N + 1,0));\n    vector<vector<int>> nexS = next_calc(S);\n    vector<vector<int>> nexT = next_calc(T);\n\n    dp[0][0] = 1;\n    rep(i,N) {\n        rep(j,N) {\n            rep(k,26) {\n                if (nexS[i][k] + 1 > N || nexT[j][k] + 1 > N || nexS[i][k] + nexT[j][k] + 2 > N) continue;\n                dp[nexS[i][k] + 1][nexT[j][k] + 1] += dp[i][j];\n            }\n        }\n    }\n\n    mint ans = 0;\n    rep(i,N + 1) {\n        rep(j,N + 1) {\n            if (i + j > N) break;\n            mint ret = 1;\n            rep(k,26) {\n                if (nexS[i][k] + j < N) ret += 1;\n            }\n            ans += ret * dp[i][j];\n        }\n    }\n    ans -= 1;\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nconst ll mod = 1000000007LL;\n#define MAX 2010\nll dp[MAX][MAX]; // [L,R]\nstring s;\nint n;\n\nconst bool debug = 0;\n\nint rpos[26][MAX], lpos[26][MAX];\nint used[30];\n\nvoid precalc() {\n  memset(rpos,-1,sizeof rpos);\n  memset(lpos,-1,sizeof lpos);\n  rep(i,n) rpos[s[i]-'a'][i] = lpos[s[i]-'a'][i] = i;\n  for(int i=n-2;i>=0;--i) rep(j,26) if( rpos[j][i] == -1 ) {\n      rpos[j][i] =  rpos[j][i+1];\n    }\n  REP(i,1,n) rep(j,26) if( lpos[j][i] == -1 ) {\n    lpos[j][i] = lpos[j][i-1];\n  }\n}\n\nint cnt[26];\nint getUniqueNum(int l,int r) {\n  memset(cnt, 0, sizeof cnt);\n  int c = 0;\n  rep(i,26) {\n    if( ( l <= lpos[i][r] && lpos[i][r] <= r ) && !cnt[i] ) cnt[i] = 1, ++c;\n    if( ( l <= rpos[i][l] && rpos[i][l] <= r ) && !cnt[i] ) cnt[i] = 1, ++c;\n  }\n  return c;\n}\n\n\nvoid compute() {\n  map<char,int> most_left;\n  n = s.size();\n\n  precalc();\n\n  ll answer = getUniqueNum(0,n-1);\n  \n  rep(i,n) if( !used[s[i]-'a'] ) {\n    used[s[i]-'a'] = 1;\n    int p = lpos[s[i]-'a'][n-1];\n    if( p != -1 && p >= i ) {\n      ++dp[i][p];\n    }\n  }\n\n  rep(l,n) {\n    REP(r,l+1,n) {\n      rep(i,26) {\n\tint rp = rpos[i][l+1];\n\tif( rp == -1 || rp >= r ) continue;\n\tint lp = lpos[i][r-1];\n\tif( lp == -1 || lp <= l ) continue;\n\t( dp[rp][lp] += dp[l][r] ) %= mod;\n      }\n    }\n  }\n\n  rep(l,n) REP(r,l+1,n) {\n    ( answer += dp[l][r] ) %= mod;\n    ll unique = getUniqueNum(l+1,r-1);\n    ( answer += ( ( dp[l][r] * unique ) % mod ) ) %= mod;\n  }\n\n  cout << answer << endl;\n}\n\nint bf() {\n  set<string> S;\n  n = s.size();\n  REP(i,1,(1<<n)) {\n    string t = \"\";\n    rep(j,n) if( (i>>j) & 1 ) t = t + s[j];\n    string rt = string(t.rbegin(),t.rend());\n    if( t == rt ) {\n      //if( t.find(\"k\") != string::npos )\n      S.insert(t);\n    }\n  }\n  for(auto t : S) {\n    cout << \"  \" << t << endl;\n  }\n  return S.size();\n}\n\nint main() {\n  if( 0 ) {\n    //rep(i,2000) cout << (char)('a'+rand()%26); puts(\"\");\n    rep(i,2000) cout << (char)('a'); puts(\"\");\n    return 0;\n  }\n  cin >> s;\n  //cout << bf() << endl;\n  compute();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "  #include <bits/stdc++.h>\n                                            #include<iostream>\n                                            #include<cstdio>\n                                            #include<vector>\n                                            #include<queue>\n                                            #include<map>\n                                            #include<cstring>\n                                            #include<string>\n                                            #include <math.h>\n                                            #include<algorithm>\n                                        //    #include <boost/multiprecision/cpp_int.hpp>\n                                            #include<functional>\n                                   #define int long long\n                                            #define inf  1000000007\n                                            #define pa pair<int,int>\n                                            #define ll long long\n                                            #define pal pair<double,double>\n                                            #define ppap pair<pa,int>\n                                      #define PI 3.14159265358979323846\n                                            #define paa pair<int,char>\n                                            #define  mp make_pair\n                                            #define  pb push_back\n                                            #define EPS (1e-10)\n                                            #define equals(a,b) (fabs((a)-(b))<EPS)\n    int dx[4]={0,-1,0,1};\n    int dy[4]={1,0,-1,0};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n                                                   #define ppa pair<int,pas>\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                 \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                int pr[2010];\n                int inv[2010];\n               \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                \tint zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n                /*\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }*/\n        /*        \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n          */      \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n            \n                //vector<double> ans(100000000),ans2(100000000)\nstring s;\nint ri[2020][26]={0};\nint le[2020][26]={0};\n\nint dp[2020][2020];\n\nint dfs(int h,int m){\n  //  cout<<h<<\" \"<<m<<endl;\n\tif(h>m) exit(1);\n\tif(dp[h][m]>=0) return dp[h][m];\n\t\n\tif(h==m){\n\t\tdp[h][m]=1;\n\t\treturn 1;\n\t}\n\tif(h+1==m){\n\t\tdp[h][m]=2;\n\t\treturn 2;\n\t}\n\tint ans=2;\n\tfor(int i=0;i<26;i++){\n\t\tif(ri[h+1][i]>=m && le[m-1][i]<=h) continue;\n\t\tans+=dfs(ri[h+1][i],le[m-1][i]);\n\t\tans%=inf;\n\t}\n\tdp[h][m]=ans;\n//\tcout<<h<<\" \"<<m<<\" \"<<ans<<endl;\n\treturn ans;\n\t\n}\n    signed main(){\n               cin.tie(0);\n    \t\tios::sync_with_stdio(false);\ncin>>s;\n    \tint l=s.length();\n    \t\n    \ts=\"1\"+s+\"1\";\n    \t\n    \tfor(int i=1;i<=l+1;i++){\n    \t\tfor(int j=0;j<26;j++)le[i][j]=le[i-1][j];\n    \t\tif(i<=l)le[i][s[i]-'a']=i;\n    \t}\n    \t\n    \tfor(int j=0;j<26;j++)ri[l+1][j]=l+1;\n    \tfor(int i=l;i>=0;i--){\n    \t\tfor(int j=0;j<26;j++)ri[i][j]=ri[i+1][j];\n    \t\tif(i>0)ri[i][s[i]-'a']=i;\n    \t}\n    \tfor(int i=0;i<2020;i++)for(int j=0;j<2020;j++)dp[i][j]=-1;\n    \tint ans=0;\n    \n    \tfor(int i=0;i<26;i++){\n    \t  \n    \t\tif(le[l+1][i]==0 && ri[0][i]==l+1) continue;\n    \t\tif(le[l+1][i]==ri[0][i]){\n    \t\t\tans++;\n    \t\t\tans%=inf;\n    \t\t\tcontinue;\n    \t\t}\n    \t\t\n    \t\tans+=dfs(ri[0][i],le[l+1][i]);\n    \t\tans%=inf;\n    \t}\n    \tcout<<ans<<endl;\nreturn 0;\n    \t\n            }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n\n#define MOD 1000000007\n\nint n;\nchar s[2521];\nll dp[2521][2521];\n\nset<int> cs[26];\n\nint main(){\n  scanf(\"%s\",s);\n  n = strlen(s);\n  REP(i,n)cs[s[i]-'a'].insert(i);\n\n  dp[0][n] = 1;\n  ll ans = 0;\n  FORR(len,0,n+1)REP(l,n){\n    int r = l+len;\n    if(r>n)break;\n    ll cnt = dp[l][r];\n    if(cnt==0)continue;\n    // step\n    REP(i,26){\n      auto it1 = cs[i].lower_bound(l);\n      auto it2 = cs[i].lower_bound(r);\n      if(it1==cs[i].end())continue;\n      if(it2==cs[i].begin())continue;\n      it2--;\n      int x = *it1;\n      int y = *it2;\n      if(x>=y)continue;\n      if(x>=r)continue;\n      if(y<l)continue;\n      ans += cnt;\n      ans %= MOD;\n      (dp[x+1][y] += cnt) %= MOD;\n      // printf(\"%c(%d-%d)%c: %lld\\n\",'a'+i,x+1,y-1,'a'+i,cnt);\n    }\n    // finish\n    REP(i,26){\n      auto it = cs[i].lower_bound(l);\n      if(it==cs[i].end())continue;\n      int x = *it;\n      if(x<r){\n        // printf(\"%c single\\n\",'a'+i);\n        ans += cnt;\n        ans %= MOD;\n      }\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define rep(i, n) for (long long i = (long long)(0); i < (long long)(n); ++i)\n#define reps(i, n) for (long long i = (long long)(1); i <= (long long)(n); ++i)\n#define rrep(i, n) for (long long i = ((long long)(n)-1); i >= 0; i--)\n#define rreps(i, n) for (long long i = ((long long)(n)); i > 0; i--)\n#define irep(i, m, n) for (long long i = (long long)(m); i < (long long)(n); ++i)\n#define ireps(i, m, n) for (long long i = (long long)(m); i <= (long long)(n); ++i)\n#define SORT(v, n) sort(v, v + n);\n#define REVERSE(v, n) reverse(v, v+n);\n#define vsort(v) sort(v.begin(), v.end());\n#define all(v) v.begin(), v.end()\n#define mp(n, m) make_pair(n, m);\n#define cout(d) cout<<d<<endl;\n#define coutd(d) cout<<std::setprecision(10)<<d<<endl;\n#define cinline(n) getline(cin,n);\n#define replace_all(s, b, a) replace(s.begin(),s.end(), b, a);\n#define PI (acos(-1))\n#define FILL(v, n, x) fill(v, v + n, x);\n#define sz(x) long long(x.size())\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vs = vector<string>;\nusing vpll = vector<pair<ll, ll>>;\nusing vtp = vector<tuple<ll,ll,ll>>;\nusing vb = vector<bool>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9+7;\nconst ll LINF = 1e18;\n\nll dp[2005][2005]; // 0~i-1, j+1~n-1の文字を使ってできる回文の個数\n\n// res[i][c]:=i文字目以降で最初に文字cが登場するindex\nvvll calcNext(string &s){\n  ll n=s.size();\n  vvll res(n+1, vll(26,n));\n  // sを後ろから見ていく\n  for(ll i=n-1; i>=0; i--){\n    // まずi+1文字目以降で最初に文字cが登場するindexをiにも格納する\n    for(ll j=0; j<26; j++) res[i][j]=res[i+1][j];\n    // その後、i番目の文字cに対応する値だけiとして更新する\n    res[i][s[i]-'a']=i;\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie( 0 ); ios::sync_with_stdio( false );\n  string s; cin>>s;\n  ll n=s.size();\n  string t=s;\n  reverse(all(t));\n  \n  auto ns=calcNext(s);\n  auto nt=calcNext(t);\n  \n  dp[0][0]=1;\n  \n  // sのi文字目\n  for(ll i=0; i<n; i++){\n    // tのj文字目\n    for(ll j=0; j<n; j++){\n      // 文字k\n      for(ll k=0; k<26; k++){\n        // s,tにおいて、i文字目以降でkが登場する最初のindex\n        ll ni=ns[i][k];\n        ll nj=nt[j][k];\n        // +2はi-1とj-1の文字は必ず採用することを意味する\n        if(ni+nj+2>n) continue;\n        (dp[ni+1][nj+1]+=dp[i][j])%=MOD;\n      }\n    }\n  }\n  \n  ll res=0;\n  for(ll i=0;i<=n;i++){\n    // i+j<=nを満たすi,jに対して、元の文字列sの左側i文字分と右側j文字分から作れる回文を調べている\n    for(ll j=0; i+j<=n; j++){\n      ll num=1;\n      // 左側i文字と右側j文字を削ぎ取って残る文字列中に含まれる文字の種類数を調べている\n      for(ll k=0; k<26; k++) if(ns[i][k]+1+j<=n) ++num;\n      res=(res+dp[i][j]*num%MOD)%MOD;\n    }\n  }\n  cout<<res-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 2005\n\nint length;\nstring input_str,rev_str;\nll dp[NUM][NUM];\nint next_loc[NUM][26],rev_next[NUM][26];\nll ruisekiwa[NUM][26],num_alpha[NUM][NUM];\n\nint main(){\n\n\tcin >> input_str;\n\n\tlength = input_str.size();\n\n\trev_str = input_str;\n\n\treverse(rev_str.begin(),rev_str.end());\n\n\tfor(int i = 0; i < 26; i++){\n\t\tnext_loc[length][i] = BIG_NUM;\n\t}\n\n\tfor(int i = length-1; i >= 0; i--){\n\t\tfor(int k = 0; k < 26; k++){\n\t\t\tif(input_str[i] == 'a'+k){\n\n\t\t\t\tnext_loc[i][k] = i;\n\t\t\t}else{\n\n\t\t\t\tnext_loc[i][k] = next_loc[i+1][k];\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i < 26; i++){\n\t\trev_next[length][i] = BIG_NUM;\n\t}\n\n\tfor(int i = length-1; i >= 0; i--){\n\t\tfor(int k = 0; k < 26; k++){\n\t\t\tif(rev_str[i] == 'a'+k){\n\n\t\t\t\trev_next[i][k] = i;\n\t\t\t}else{\n\n\t\t\t\trev_next[i][k] = rev_next[i+1][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= length; i++){\n\t\tfor(int k = 0; k <= length; k++){\n\t\t\tdp[i][k] = 0;\n\t\t}\n\t}\n\n\n\tdp[0][0] = 1;\n\tint next_i,next_rev_i;\n\n\tfor(int i = 0; i < length; i++){\n\t\tfor(int rev_i = 0; rev_i < length; rev_i++){\n\t\t\tfor(int k = 0; k < 26; k++){\n\n\t\t\t\tnext_i = next_loc[i][k];\n\t\t\t\tnext_rev_i = rev_next[rev_i][k];\n\n\t\t\t\tif(next_i == BIG_NUM || next_rev_i == BIG_NUM || next_i+1+next_rev_i+1 > length)continue;\n\n\t\t\t\tdp[next_i+1][next_rev_i+1] += dp[i][rev_i];\n\t\t\t\tdp[next_i+1][next_rev_i+1] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0,add;\n\n\tfor(int i = 0; i <= length; i++){\n\t\tfor(int rev_i = 0; rev_i+i <= length; rev_i++){\n\t\t\tadd = 1;\n\t\t\tfor(int k = 0; k < 26; k++){\n\t\t\t\tif(next_loc[i][k]+1 <= length-(rev_i)){\n\t\t\t\t\tadd++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (dp[i][rev_i]*add)%MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans-1);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const {\n        long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u);\n    }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r;\n}\ntypedef ModInt<1000000007> mint;\nstruct StringMaster {\n    string S; int N; StringMaster() {}StringMaster(string s) { init(s); }\n    void init(string s) { S = s; N = S.length(); }\n\n    // get the nearest index for the char\n    vector<int> hidari[26], migi[26];\n    inline void initgo() {\n        rep(c, 0, 26) { migi[c].resize(N); migi[c][N - 1] = inf; }\n        rrep(i, N - 2, 0) { rep(c, 0, 26) migi[c][i] = migi[c][i + 1]; migi[S[i + 1]][i] = i + 1; }\n        rep(c, 0, 26) { hidari[c].resize(N); hidari[c][0] = -1; }\n        rep(i, 1, N) { rep(c, 0, 26) hidari[c][i] = hidari[c][i - 1]; hidari[S[i - 1]][i] = i - 1; }\n    }\n    inline int gomigi(int cu, int c) { return migi[c][cu]; }\n    inline int gohidari(int cu, int c) { return hidari[c][cu]; }\n};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\nstring S; int N;\nmint dp[2020][2020];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> S;\n    N = S.length();\n    S = \"a\" + S + \"a\";\n    fore(c, S) c -= 'a';\n\n    StringMaster sm(S);\n    sm.initgo();\n\n    mint ans = 0;\n    dp[0][N + 1] = 1;\n    rrep(len, N + 2, 2) {\n        rep(L, 0, N + 1) {\n            int R = L + len - 1;\n            if (N + 1 < R) break;\n\n            if (len != N + 2) ans += dp[L][R];\n            rep(c, 0, 26) {\n                int LL = sm.gomigi(L, c);\n                int RR = sm.gohidari(R, c);\n\n                if (LL <= RR) ans += dp[L][R];\n                if (LL < RR) dp[LL][RR] += dp[L][R];\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nstruct Edge\n{\n  int to;\n  int weight;\n  Edge(int t, int w) : to(t), weight(w) {}\n};\nusing Graph = vector<vector<Edge>>;\n// using Graph = vector<vector<int>>;\n\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1000000000;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, 1, -1, 1, 0, -1};\n\nconst int MOD = 1000000007;\n\n// res[i][c] := i 文字目以降で最初に文字 c が登場する index (存在しないときは n)\nvector<vector<int>> calcNext(const string &S)\n{\n  int n = (int)S.size();\n  vector<vector<int>> res(n + 1, vector<int>(26, n));\n  for (int i = n - 1; i >= 0; --i)\n  {\n    for (int j = 0; j < 26; ++j)\n      res[i][j] = res[i + 1][j];\n    res[i][S[i] - 'a'] = i;\n  }\n  return res;\n}\n\nvoid add(long long &a, long long b)\n{\n  a += b;\n  if (a >= MOD)\n    a -= MOD;\n}\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  string S;\n  cin >> S;\n  int n = (int)S.size();\n  string T = S;\n  reverse(T.begin(), T.end());\n\n  auto ns = calcNext(S);\n  auto nt = calcNext(T);\n  vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, 0));\n  dp[0][0] = 1;\n  for (int i = 0; i < n; ++i)\n  {\n    for (int j = 0; j < n; ++j)\n    {\n      for (int k = 0; k < 26; ++k)\n      {\n        int ni = ns[i][k];\n        int nj = nt[j][k];\n        if (ni + nj + 2 > n)\n          continue;\n        add(dp[ni + 1][nj + 1], dp[i][j]);\n      }\n    }\n  }\n  long long res = 0;\n  for (int i = 0; i <= n; ++i)\n  {\n    for (int j = 0; i + j <= n; ++j)\n    {\n      int num = 1;\n      for (int k = 0; k < 26; ++k)\n        if (ns[i][k] + 1 + j <= n)\n          ++num;\n      res = (res + dp[i][j] * num % MOD) % MOD;\n    }\n  }\n  cout << res - 1 << endl;\n  return 0;\n}\n\n// https://qiita.com/drken/items/a207e5ae3ea2cf17f4bd\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<ll mod>\nstruct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x (y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    Mod_Int &operator += (const Mod_Int &p){\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p){\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p){\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p){\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int &operator ++ () {return *this += Mod_Int(1);}\n\n    Mod_Int operator ++ (int){\n        Mod_Int tmp = *this;\n        ++*this;\n        return tmp;\n    }\n\n    Mod_Int &operator -- () {return *this -= Mod_Int(1);}\n\n    Mod_Int operator -- (int){\n        Mod_Int tmp = *this;\n        --*this;\n        return tmp;\n    }\n\n    Mod_Int operator - () const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow(ll n) const{\n        Mod_Int now = *this, ret = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse() const{\n        return pow(mod-2);\n    }\n\n    friend ostream &operator << (ostream &os, const Mod_Int &p){\n        return os << p.x;\n    }\n\n    friend istream &operator >> (istream &is, Mod_Int &p){\n        ll a;\n        is >> a;\n        p = Mod_Int<mod>(a);\n        return is;\n    }\n};\n\nusing mint = Mod_Int<MOD>;\n\nconst int MAX_N = 2001;\nmint dp[MAX_N][MAX_N];\nbool used[MAX_N][MAX_N];\nint L[MAX_N][26], R[MAX_N][26];\n\nmint dfs(int l, int r){\n    if(l > r) return 0;\n    if(l == r) return 1;\n    if(used[l][r]) return dp[l][r];\n    rep(i, 26) if(R[l][i] <= r) dp[l][r]++;\n    rep(i, 26){\n        int nl = R[l][i], nr = L[r][i];\n        dp[l][r] += dfs(nl, nr);\n    }\n    used[l][r] = true;\n    return dp[l][r];\n}\n\nint main(){\n    string S;\n    cin >> S;\n    int N = sz(S);\n    rep(j, 26) L[0][j] = -1;\n    rep(i, N){\n        rep(j, 26) L[i+1][j] = L[i][j];\n        L[i+1][S[i]-'a'] = i;\n    }\n    rep(j, 26) R[N][j] = N+1;\n    rep3(i, N-1, 0){\n        rep(j, 26) R[i][j] = R[i+1][j];\n        R[i][S[i]-'a'] = i+1;\n    }\n    rep(i, MAX_N){\n        rep(j, MAX_N) dp[i][j] = 1, used[i][j] = false;\n    }\n    cout << --dfs(0, N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nconst Int MAX = 2020;\nInt dp[MAX][MAX];\nconst Int MOD = 1e9+7;\nInt ri[MAX][27],le[MAX][27];;\nInt n;\nstring s;\nInt dfs(Int l,Int r){\n  if(~dp[l][r]) return dp[l][r];\n  Int &res=dp[l][r];\n  res=1;\n  for(Int i=0;i<26;i++){\n    if(ri[l][i]<r&&le[r][i]>l){\n      res++;\n      if(ri[l][i]<le[r][i]) res+=dfs(ri[l][i],le[r][i]);\n      res%=MOD;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  cin>>s;\n  s=char('a'+26)+s+char('a'+26);\n  n=s.size();\n  for(Int i=0;i<n;i++) s[i]-='a';\n  memset(dp,-1,sizeof(dp));\n  for(Int i=0;i<27;i++) ri[n-1][i]=n,le[0][i]=-1;\n  for(Int i=n-2;i>=0;i--){\n    for(Int j=0;j<27;j++){\n      if(s[i+1]==j) ri[i][j]=i+1;\n      else ri[i][j]=ri[i+1][j];\n    }\n  }\n  for(Int i=1;i<n;i++){\n    for(Int j=0;j<27;j++){\n      if(s[i-1]==j) le[i][j]=i-1;\n      else le[i][j]=le[i-1][j];\n    }\n  }\n  cout<<(dfs(0,n-1)+MOD-1)%MOD<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\n\nvector<vector<int>> calc_next(const string &s) {\n    int n = s.size();\n    vector<vector<int>> nxt(n + 1, vector<int>(26, n));\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = 0; j < 26; j++) nxt[i][j] = nxt[i + 1][j];\n        nxt[i][s[i] - 'a'] = i;\n    }\n    return nxt;\n}\n\nint main() {\n    string s; cin >> s;\n    string t = s; reverse(t.begin(), t.end());\n    auto ns = calc_next(s);\n    auto nt = calc_next(t);\n    int n = s.size();\n    vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {\n        for (int k = 0; k < 26; k++) {\n            int ni = ns[i][k] + 1, nj = nt[j][k] + 1;\n            if (ni + nj > n) continue;\n            (dp[ni][nj] += dp[i][j]) %= MOD;\n        }\n    }\n    long long res = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; i + j <= n; j++) {\n            int cnt = 1;\n            for (int k = 0; k < 26; k++) if (ns[i][k] + 1 + j <= n) cnt++;\n            (res += dp[i][j] * cnt % MOD) %= MOD;\n        }\n    }\n    cout << res - 1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\nusing namespace std;\nint n;\nstring s;\nvector<int> vec[26];\nll dp[2005][2005];\n\nint main(void){\n\tcin >> s;\n\tn=s.size();\n\tfor(int i=0;i<n;i++){\n\t\tint a=s[i]-'a';\n\t\tvec[a].push_back(i);\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tll ans=0;\n\tdp[0][n]=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=n;j>i;j--){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\tfor(int k=0;k<26;k++){\n\t\t\t\tint v=lower_bound(vec[k].begin(),vec[k].end(),i)-vec[k].begin();\n\t\t\t\tif(v==vec[k].size())continue;\n\t\t\t\tint f=vec[k][v];\n\t\t\t\t//printf(\"%d %d %d %d\\n\",i,j,f,k);\n\t\t\t\tif(f>=j)continue;\n\t\t\t\t//printf(\"%d %d %d %d\\n\",i,j,f,k);\n\t\t\t\tans+=dp[i][j];\n\t\t\t\tans%=MOD;\n\t\t\t\tint v2=lower_bound(vec[k].begin(),vec[k].end(),j)-vec[k].begin();\n\t\t\t\tv2--;\n\t\t\t\tif(v2<0)continue;\n\t\t\t\t//printf(\"%d %d %d %d\\n\",i,j,k,v,v2);\n\t\t\t\tif(vec[k][v2]>f){\n\t\t\t\t\tdp[f+1][vec[k][v2]]+=dp[i][j];\n\t\t\t\t\tdp[f+1][vec[k][v2]]%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tans+=dp[i][j];\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid add(ll &a, ll b) {\n    a += b;\n    if(a >= mod) a %= mod;\n}\n\nvoid solve() {\n\tstring s; cin >> s;\n    int n = (int)s.size();\n    string t = s;\n    reverse(all(t));\n    vector<vector<int>> ns(n + 1, vector<int>(26, n));\n    vector<vector<int>> nt(n + 1, vector<int>(26, n));\n    for(int i = n - 1; i >= 0; --i) {\n        rep(j, 26) ns[i][j] = ns[i + 1][j];\n        ns[i][s[i] - 'a'] = i;\n    }\n    for(int i = n - 1; i >= 0; --i) {\n        rep(j, 26) nt[i][j] = nt[i + 1][j];\n        nt[i][t[i] - 'a'] = i;\n    }\n    vector<vector<ll>> dp(n + 1, vector<ll>(n + 1, 0));\n    dp[0][0] = 1;\n    rep(i, n) {\n        rep(j, n) {\n            rep(k, 26) {\n                int ni = ns[i][k] + 1;\n                int nj = nt[j][k] + 1;\n                if(ni + nj <= n) add(dp[ni][nj], dp[i][j]);\n            }\n        }\n    }\n    ll res = 0;\n    for(int i = 0; i <= n; ++i) {\n        set<int> se;\n        for(int j = n - i; j >= 0; --j) {\n            add(res, ((int)se.size() + 1) * dp[i][j]);\n            if(j - 1 >= 0) se.insert(t[j - 1] - 'a');\n            //cerr << i << \" \" << j << \" \" << ((int)se.size() + 1) * dp[i][j] << endl;\n        }\n    }\n    cout << (res + mod - 1) % mod << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define pie 3.141592653589793238462643383279\n#define int long long\n#define P pair<int,int>\n#define all(vec) vec.begin(),vec.end()\n\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y)*y;\n}\nint kai(int x, int y, int m) {\n\tint res = 1;\n\tfor (int i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nint mod_pow(int x, int y, int m) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint comb(int x, int y, int m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nconst int mod = 1000000007;\n\nstring s, t;\nint d[2010][2010];\nint snex[2010][26], tnex[2010][26];\nint ans;\n\nsigned main() {\n\tcin >> s;\n\tint n = (int)s.size();\n\tfor (int i = n - 1; i >= 0; i--)t += s[i];\n\tfor (int i = 0; i < 26; i++)snex[n][i] = n;\n\tfor (int i = n - 1; i >= 0; i--)for (int j = 0; j < 26; j++) {\n\t\tsnex[i][j] = snex[i + 1][j];\n\t\tsnex[i][s[i] - 'a'] = i;\n\t}\n\tfor (int i = 0; i < 26; i++)tnex[n][i] = n;\n\tfor (int i = n - 1; i >= 0; i--)for (int j = 0; j < 26; j++) {\n\t\ttnex[i][j] = tnex[i + 1][j];\n\t\ttnex[i][t[i] - 'a'] = i;\n\t}\n\td[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < 26; k++) {\n\t\t\t\tint p = snex[i][k] + 1;\n\t\t\t\tint q = tnex[j][k] + 1;\n\t\t\t\tif (p + q > n)continue;\n\t\t\t\td[p][q] = (d[p][q] + d[i][j]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++)for (int j = 0; i + j <= n; j++) {\n\t\tint cnt = 1;\n\t\tfor (int k = 0; k < 26; k++) {\n\t\t\tint x = snex[i][k] + 1;\n\t\t\tif (x + j <= n)cnt++;\n\t\t}\n\t\tans = (ans + d[i][j] * cnt) % mod;\n\t}\n\tans--;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nstring s;\nint t[2005];\n\nll n;\nll A[26][2005];\nll B[26][2005];\n\n\nll mem2[2005][2005];\nset<ll> T[26];\n\nll Counting(int l,int r){\n  ll res=0;\n  for(int i=0;i<26;i++){\n    set<ll> :: iterator it = T[i].lower_bound(l);\n    if(it != T[i].end() &&  *it <= r)res++;\n  }\n  return res;\n}\n\nll solve2(int l,int r){\n  if(mem2[l][r]!=-1)return mem2[l][r];\n\n  \n  ll res= Counting(l,r);\n  for(int i=0;i<26;i++){\n    int nl=B[i][l];\n    int nr=A[i][r];\n\n    \n    if(nl+1<=nr-1){\n      res=add(res, solve2(nl+1,nr-1) );\n    }\n  }\n  return mem2[l][r]=res;\n}\n\nll mem[2005][2005];\n\nll solve(int l,int r){\n  if(mem[l][r]!=-1)return mem[l][r];\n  if(l+1==r)return (t[l]==t[l+1]?2:1);\n  \n  ll res=1;\n  for(int i=0;i<26;i++){\n    int nl=B[i][l];\n    int nr=A[i][r];\n    if(nl==nr){\n      continue;\n    }\n    if(nl+1==nr){\n      res++;\n      continue;\n    }\n    if(nl+1<=nr-1){\n      res=add(res, solve(nl+1,nr-1) );\n    }\n  }\n  return mem[l][r]=res;\n}\nint main(){\n  memset(mem,-1,sizeof(mem));\n  memset(mem2,-1,sizeof(mem2));\n  cin>>s;\n  \n  n=s.size();\n  \n  for(int i=0;i<n;i++){\n    t[i+1]=s[i]-'a';\n\n    T[ t[i+1] ].insert(i+1);\n  }\n  \n  for(int i=0;i<26;i++){\n    A[i][0]=-1;\n    for(int j=1;j<=n;j++){\n      if(i==t[j])A[i][j]=j;\n      else A[i][j]=A[i][j-1];\n    }\n  }\n\n  for(int i=0;i<26;i++){\n    B[i][n+1]=n+1;\n    for(int j=n;j>=1;j--){\n      if(i==t[j])B[i][j]=j;\n      else B[i][j]=B[i][j+1];\n    }\n  }\n\n  cout<< ( solve(1,n) + solve2(1,n) + mod - 1 ) %mod <<endl;\n  //cout<< solve(1,n) <<endl;\n  //cout<< solve2(1,n) <<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nstring s;\nint n;\nll dp[2011][2011];\nll pre[2011][27],nxt[2011][27];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>s;\n  s=(char)('a'+26)+s+(char)('a'+26);\n  n=s.size();\n\n  rep(i,2001)rep(c,26)nxt[i][c]=INF;\n  for(ll i=n-2;i>=0;i--){\n    repl(c,'a','z'+1){\n      if(s[i+1]==c)nxt[i][c-'a']=i+1;\n      else nxt[i][c-'a']=nxt[i+1][c-'a'];\n    }\n  }\n\n  memset(pre,-1,sizeof(pre));\n  repl(i,1,n+1){\n    repl(c,'a','z'+1){\n      if(s[i-1]==c)pre[i][c-'a']=i-1;\n      else pre[i][c-'a']=pre[i-1][c-'a'];\n    }\n  }\n\n  rep(i,n)dp[i][i]=dp[i][i+1]=1;\n  repl(len,2,n+1){\n    rep(l,n){\n      ll r=l+len;\n      if(r>n)break;\n      ll res=1;\n      rep(c,26){\n        if(nxt[l][c]<r&&pre[r][c]>l){\n          res++;\n          if(nxt[l][c]<pre[r][c])res+=dp[nxt[l][c]][pre[r][c]];\n        }\n      }\n      dp[l][r]=res%mod;\n    }\n  }\n  cout<<(dp[0][n]-1+mod)%mod<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\n#define rep(i, n) for(int i=0;i<n;++i)\n#define rrep(i, n) for(int i=n;i>=0;--i)\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\nconst ll big=1e18;\nconst double PI=2*asin(1);\n\nll DP[2005][2005]; //Sのi文字目までとTのj文字目までを使ってできる回文の数\n\nint main() {\n  string S, T;\n  cin>>S;\n  for(ll i=S.size()-1;i>=0;--i) {\n    T += S[i];\n  }\n  ll next1[26][S.size()+1];\n  ll next2[26][S.size()+1];\n  for(ll i=0;i<26;++i) {\n    for(ll j=0;j<=S.size();++j) {\n      next1[i][j] = -1;\n      next2[i][j] = -1;\n    }\n  }\n  for(ll j=S.size()-1;j>=0;--j) {\n    for(ll i=0;i<26;++i) {\n      next1[i][j] = next1[i][j+1];\n      next2[i][j] = next2[i][j+1];\n    }\n    next1[S[j]-'a'][j] = j+1;\n    next2[T[j]-'a'][j] = j+1;\n  }\n  DP[0][0] = 1;\n  for(ll i=0;i<=S.size();++i) {\n    for(ll j=0;j<=T.size();++j) {\n      for(ll k=0;k<26;++k) {\n        if(next1[k][i]==-1 || next2[k][j]==-1) continue;\n        DP[next1[k][i]][next2[k][j]] += DP[i][j];\n        DP[next1[k][i]][next2[k][j]] %= mod;\n      }\n    }\n  }\n  ll ans = 0;\n  ll num;\n  for(ll i=0;i<=S.size();++i) {\n    for(ll j=0;j<=T.size();++j) {\n      if(i+j>S.size()) continue;\n      num = 0;\n      for(ll k=0;k<26;++k) {\n        if(next1[k][i]!=-1 && next1[k][i]<=S.size()-j) num++;\n      }\n      ans += DP[i][j]*(num+1)%mod;\n      ans %= mod;\n    }\n  }\n  cout<<ans-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nvector<vector<int> > calcNext(const string &S) {\n    int n = (int)S.size();\n    vector<vector<int> > res(n+1, vector<int>(26, n+10));\n    for (int i = n-1; i >= 0; --i) {\n        for (int j = 0; j < 26; ++j) res[i][j] = res[i+1][j];\n        res[i][S[i]-'a'] = i;\n    }\n    return res;\n}\n\nint main(){\n    //input\n    string S;\n    cin >> S;\n\n    //calc\n    string T = S;\n    reverse(T.begin(),T.end());\n    int n = S.length();\n    vector<vector<int> > nextS = calcNext(S);\n    vector<vector<int> > nextT = calcNext(T);\n    vector<vector<long long> > dp(n+1,vector<long long>(n+1,0));\n    int i,j,k;\n    dp[0][0]=1;\n    for(i=0; i<=n; i++){\n        for(j=0; j<=n; j++){\n            for(k=0; k<26; k++){\n                if(nextS[i][k]+1+nextT[j][k]+1<=n){\n                    dp[nextS[i][k]+1][nextT[j][k]+1]+=dp[i][j];\n                    dp[nextS[i][k]+1][nextT[j][k]+1]%=MOD;\n                }\n            }\n        }\n    }\n    vector<vector<long long> > dq(n+1,vector<long long>(n+1,0));\n    for(i=0; i<=n; i++){\n        for(j=0; j<=n; j++){\n            for(k=0; k<26; k++){\n                if(nextS[i][k]<=n-j-1){\n                    dq[i][j]++;\n                }\n            }\n        }\n    }\n    dq[0][0]--;\n    long long ans=0;\n    for(i=0; i<=n; i++){\n        for(j=0; j<=n; j++){\n            if(i+j<=n){\n                ans+=(dq[i][j]+1)*dp[i][j];\n                ans%=MOD;\n            }\n        }\n    }\n\n    //output\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#pragma region macro\n#include <bits/stdc++.h>\ntypedef long long int64;\nusing namespace std;\ntypedef vector<int> vi;\nconst int MOD = (int)1e9 + 7;\nconst int64 INF = 1LL << 62;\nconst int inf = 1<<30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\n#define bn '\\n'\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        if (i!=N-1) os << \" \";\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T,typename S>\nostream& operator<<(ostream& os, pair<T,S> const&P){\n    os << \"(\";\n    os << P.first;\n    os << \" , \";\n    os << P.second;\n    os << \")\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> &S){\n    auto it=S.begin();\n    while(it!=S.end()){\n        os << *it;\n        os << \" \";\n        it++;\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, deque<T> &q){\n    for(auto it=q.begin();it<q.end();it++){\n        os<<*it;\n        os<<\" \";\n    }\n    os<<endl;\n    return os;\n}\ntemplate <typename T,typename S>\nostream& operator<<(ostream& os, map<T,S> const&M){\n    for(auto e:M){\n        os<<e;\n    }\n    os<<endl;\n    return os;\n}\nvector<pair<int,int>> dxdy = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1)};\n#pragma endregion\n//fixed<<setprecision(10)<<ans<<endl;\n\nint64 pow(int a,int b,int mod){\n    vector<bool> bit;\n    for(b=b;b>0;b>>=1){\n        bit.push_back(b&1);\n    }\n    vector<int64> fac(bit.size()); fac[0] = a;\n    int64 res = 1;\n    for(int i=1;i<bit.size();i++){\n        fac[i] = (fac[i-1] * fac[i-1])%mod;\n    }\n    for(int i=0;i<bit.size();i++){\n        if(bit[i]) res*=fac[i];\n        res%=mod;\n    }\n    return res;\n}\n\n\n//mint\nstruct mint {\n    int64 x;\n    mint(int64 x=0):x((x+2*MOD)%MOD){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += MOD-a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(int64 t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n\n    // for prime MOD\n    mint inv() const {\n        return pow(MOD-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\nostream& operator<<(ostream& os, mint a){\n    os << a.x;\n    return os;\n}\n\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    \n    string S; cin >> S;\n    int N = S.size();\n    vector<vector<int>> next_(N), prev_(N);\n    vector<int> last(26,2*N);\n    REP(i,N){\n        last[S[i]-'a'] = i;\n        prev_[i] = last;\n    }\n    last.assign(26,2*N);\n    for(int i=N-1;i>=0;i--){\n        last[S[i]-'a'] = i+1;\n        next_[i] = last;\n    }\n\n    vector<vector<mint>> DP(N+1,vector<mint>(N+1,0));\n    DP[0][N] = 1;\n    REP(i,N){\n        for(int j=N;j>0;j--){\n            REP(k,26){\n                int to_i = next_[i][k], to_j = prev_[j-1][k];\n                if(to_i==2*N or to_j==2*N) continue;\n                DP[to_i][to_j] += DP[i][j];\n            }\n        }\n    }\n\n\n    mint ans=0;\n    REP(i,N){\n        for(int j=i;j<=N;j++){\n            int tmp = 0;\n            REP(k,26){\n                if(next_[i][k]<=j) tmp++;\n            }\n            ans += DP[i][j] * (tmp+1);\n        }\n    }\n\n    cout << ans-1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const {\n        long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u);\n    }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r;\n}\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\nstruct StringMaster {\n    string S; int N;\n    StringMaster() {}\n    StringMaster(string s) { init(s); }\n\n    void init(string s) {\n        S = s;\n        N = S.length();\n    }\n\n    // get the nearest index for the char\n    vector<int> hidari[26], migi[26];\n    bool isInitGo = false;\n    inline void initgo() {\n        if (isInitGo) return;\n        isInitGo = true;\n        \n        \n\n        rep(c, 0, 26) {\n            migi[c].resize(N);\n            migi[c][N - 1] = inf;\n        }\n        rrep(i, N - 2, 0) {\n            rep(c, 0, 26) migi[c][i] = migi[c][i + 1];\n            migi[S[i + 1]][i] = i + 1;\n        }\n\n        rep(c, 0, 26) {\n            hidari[c].resize(N);\n            hidari[c][0] = -1;\n        }\n        rep(i, 1, N) {\n            rep(c, 0, 26) hidari[c][i] = hidari[c][i - 1];\n            hidari[S[i - 1]][i] = i - 1;\n        }\n    }\n    inline int gomigi(int cu, int c) { \n        initgo(); \n    return migi[c][cu]; \n    }\n    inline int gohidari(int cu, int c) { initgo(); return hidari[c][cu]; }\n\n};\n\n\n\n\nstring S; int N;\nmint dp[2020][2020];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> S;\n    N = S.length();\n    S = \"a\" + S + \"a\";\n    fore(c, S) c -= 'a';\n\n    StringMaster sm(S);\n\n    mint ans = 0;\n    dp[0][N + 1] = 1;\n    rrep(len, N + 2, 2) {\n        rep(L, 0, N + 1) {\n            int R = L + len - 1;\n            if (N + 1 < R) break;\n\n            if (len != N + 2) ans += dp[L][R];\n            rep(c, 0, 26) {\n                int LL = sm.gomigi(L, c);\n                int RR = sm.gohidari(R, c);\n\n                if (LL <= RR) ans += dp[L][R];\n                if (LL < RR) dp[LL][RR] += dp[L][R];\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nconst int mod = 1e9 + 7;\n\nstruct mint {\n  int n;\n  mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator+(mint a, mint b) { return (a.n += b.n) >= mod ? a.n - mod : a.n; }\nmint operator-(mint a, mint b) { return (a.n -= b.n) < 0 ? a.n + mod : a.n; }\nmint operator*(mint a, mint b) { return 1LL * a.n * b.n % mod; }\nmint &operator+=(mint &a, mint b) { return a = a + b; }\nmint &operator-=(mint &a, mint b) { return a = a - b; }\nmint &operator*=(mint &a, mint b) { return a = a * b; }\n\nint n;\nchar s[2003];\nmint dp[2003][2003];\nint succ[2003][26];\nint pred[2003][26];\n\nint main() {\n  scanf(\"%s\", s + 1);\n  s[0] = 'a';\n  n = strlen(s) + 2;\n  s[n - 1] = 'a';\n  for (int j = 0; j < 26; j++) {\n    succ[n - 1][j] = n;\n    pred[0][j] = -1;\n  }\n  for (int i = n - 2; i >= 0; i--) {\n    for (int j = 0; j < 26; j++) {\n      succ[i][j] = s[i + 1] == j + 'a' ? i + 1 : succ[i + 1][j];\n    }\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < 26; j++) {\n      pred[i][j] = s[i - 1] == j + 'a' ? i - 1 : pred[i - 1][j];\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n  for (int d = 1; d <= n - 1; d++) {\n    for (int l = 0; l + d < n; l++) {\n      int r = l + d;\n      if (s[l] != s[r]) continue;\n      dp[l][r] += 1;\n      for (int k = 0; k < 26; k++) {\n        int ll = succ[l][k];\n        int rr = pred[r][k];\n        if (ll <= rr) {\n          dp[l][r] += dp[ll][rr];\n        }\n        if (ll < rr) {\n          dp[l][r] += 1;\n        }\n      }\n    }\n  }\n  dp[0][n - 1] -= 1;\n  printf(\"%d\\n\", dp[0][n - 1].n);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> &a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\ntemplate<class T>void prArr(T a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n_int used[2001][2001];\n_int mem[2001][2001];\nvector<vector<Int> >Idx(30);\nstring s;\nInt dfs(Int l, Int r){\n  if(l > r) return 1;\n  if(l == r) return 2;\n  if(used[l][r]++) return mem[l][r];\n\n  Int res = 1;\n  for(Int i=0;i<26;i++){\n    Int idxl = lower_bound(Idx[i].begin(), Idx[i].end(), l) - Idx[i].begin();\n    Int idxr = upper_bound(Idx[i].begin(), Idx[i].end(), r) - Idx[i].begin();\n    idxr--;\n    \n    if(idxl >= (int)Idx[i].size() || idxr >=(int)Idx[i].size()) continue;\n    if(idxl < 0 || idxr < 0) continue;\n    int nl = Idx[i][idxl];\n    int nr = Idx[i][idxr];\n    if((nl > nr)) continue;\n    if(!(l <= nl && nr <= r)) continue;\n    if(s[nl] != i + 'a' || s[nr] != i + 'a') continue;\n    res = (res + 1) % mod;\n    if(nl != nr) res = (res + dfs(nl+1, nr-1)) % mod;\n  }\n  return mem[l][r] = res;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin>>s;\n  int n = s.size();\n  for(Int i=0;i<(Int)s.size();i++) Idx[s[i] - 'a'].push_back(i);\n\n  int ans = dfs(0, n-1) - 1;\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n\nconst int mod = 1e9+7;\n\nconst int A = 26;\nvector<int> pos[A];\n\nint n;\n\nconst int N = 2002;\nint dp[N][N];\nint dfs(int l, int r){\n    if(l>=n || r<0) return 0;\n    if(dp[l][r]>=0) return dp[l][r];\n\n    // printf(\" (%d %d)\\n\", l,r);\n    int ret = 0;\n\n    rep(i,26){\n        auto il = lower_bound(all(pos[i]),l);\n        if(il == pos[i].end()) continue;\n\n        auto ir = upper_bound(all(pos[i]),r);\n        if(ir == pos[i].begin()) continue;\n        --ir;\n\n        int nl = *il, nr = *ir;\n        if(nl<=nr){\n            ++ret;\n            if(nl<nr){\n                ++ret;\n                (ret += dfs(nl+1,nr-1)) %= mod;\n            }\n        }\n    }\n\n    return dp[l][r] = ret;\n}\n\nint main(){\n    string s;\n    cin >>s;\n    n = s.size();\n\n    rep(i,n) pos[s[i]-'a'].pb(i);\n\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,n-1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst long long MAX = 5100000;\nconst long long INF = 1LL << 60;\nconst long long mod = 1000000007LL;\n//const long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nvector<vector<ll>> nextchar(string& s) {\n\tvector<vector<ll>> next(s.size() + 1, vector<ll>(26, INF));\n\tfor (ll i = (ll)s.size() - 1; i >= 0; i--) {\n\t\tfor (ll j = 0; j < 26; j++) next[i][j] = next[i + 1][j];\n\t\tnext[i][s[i] - 'a'] = i;\n\t}\n\treturn next;\n}\n\nstruct mint {\n\tll x; // typedef long long ll;\n\tmint(ll x = 0) :x((x% mod + mod) % mod) {}\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += mod - a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) {\n\t\t(x *= a.x) %= mod;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime mod\n\tmint inv() const {\n\t\treturn pow(mod - 2);\n\t}\n\tmint& operator/=(const mint a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n};\n\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\n\tstring s; cin >> s;\n\tstring t = s;\n\tll n = s.size();\n\treverse(t.begin(), t.end());\n\n\tvector<vector<mint>> dp(n + 1, vector<mint>(n + 1));\n\tdp[0][0] = 1;\n\tvector<vector<ll>> ns = nextchar(s);\n\tvector<vector<ll>> nt = nextchar(t);\n\tfor (ll i = 0; i < n; i++) {\n\t\tfor (ll j = 0; j < n; j++) {\n\t\t\tfor (ll k = 0; k < 26; k++) {\n\t\t\t\tll ni = ns[i][k];\n\t\t\t\tll nj = nt[j][k];\n\t\t\t\t//cout << ni << \" \" << nj << endl;\n\t\t\t\tif (ni + nj + 2 > n) continue;\n\t\t\t\tdp[ni + 1][nj + 1] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tmint res = 0;\n\tfor (ll i = 0; i <= n; i++) {\n\t\tfor (ll j = 0; j <= n; j++) {\n\t\t\tmint cnt = 1;\n\t\t\tfor (ll k = 0; k < 26; k++) {\n\t\t\t\tll ni = ns[i][k];\n\t\t\t\tif (ni + j + 1 > n) continue;\n\t\t\t\tcnt += 1;\n\t\t\t}\n\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j].x << \" \" << cnt.x << endl;\n\t\t\tres += dp[i][j] * cnt;\n\t\t}\n\t}\n\tres.x -= 1;\n\tcout << res.x << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<random>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nvector<vector<ll>> nxt;\nvector<vector<ll>> bef;\nvector<vector<ll>> cnt;\nll dp[2020][2020];\n\nll dfs(ll l, ll r) {\n\tif(l > r) return 0;\n\tif(dp[l][r] != -1) return dp[l][r];\n\tvector<ll> c(26);\n\tREP(i,26) c[i]=cnt[r][i];\n\tif(l) {\n\t\tREP(i,26) c[i]-=cnt[l - 1][i];\n\t}\n\tll ret = 0;\n\tREP(i,26) if(c[i]) ret++;\n\tREP(i,26) {\n\t\tif(nxt[l][i] <= r && bef[r][i] >= l && nxt[l][i] != bef[r][i]) {\n\t\t\tret++;\n\t\t\tret += dfs(nxt[l][i] + 1, bef[r][i] - 1);\n\t\t}\n\t}\n\tret %= MOD;\n\treturn dp[l][r] = ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tREP(i,2020) REP(j,2020) dp[i][j] = -1;\n\tstring s;\n\tcin >> s;\n\tll n = (ll)s.size();\n\tnxt.resize(n, vector<ll>(26, -1));\n\tbef.resize(n, vector<ll>(26, -1));\n\tcnt.resize(n, vector<ll>(26, 0));\n\tREP(i,n) {\n\t\tREP(j,26) {\n\t\t\tif(i) cnt[i][j] = cnt[i - 1][j];\n\t\t}\n\t\tcnt[i][s[i] - 'a']++;\n\t}\n\tbef[0][s[0]-'a'] = 0;\n\tFOR(i,1,n) REP(j,26) {\n\t\tif(s[i] - 'a' == j) bef[i][j] = i;\n\t\telse bef[i][j] = bef[i - 1][j];\n\t}\n\tnxt[n - 1][s[n - 1] - 'a'] = n - 1;\n\tfor(ll i = n - 2; i >= 0; i--) REP(j,26) {\n\t\tif(s[i] - 'a' == j) nxt[i][j] = i;\n\t\telse nxt[i][j] = nxt[i + 1][j];\n\t}\n\tcout << dfs(0, n - 1) << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  cin >> s;\n  ll n = s.size();\n  string t(s);\n  reverse(t.begin(), t.end());\n\n  vector<vector<ll>> spos(n+1, vector<ll>(26, n)), tpos(n+1, vector<ll>(26, n));\n  for(int i=n-1; i>=0; --i) {\n    REP(j, 26) {\n      if(s[i]=='a'+j) {\n        spos[i][j] = i;\n      } else {\n        spos[i][j] = spos[i+1][j];\n      }\n    }\n  }\n  for(int i=n-1; i>=0; --i) {\n    REP(j, 26) {\n      if(t[i]=='a'+j) {\n        tpos[i][j] = i;\n      } else {\n        tpos[i][j] = tpos[i+1][j];\n      }\n    }\n  }\n\n  auto dp = make_v<ll>(n+1, n+1);\n  dp[0][0] = 1;\n  REP(i, n) REP(j, n) {\n    REP(k, 26) {\n      if(spos[i][k]+tpos[j][k]+2 > n) continue;\n      (dp[spos[i][k]+1][tpos[j][k]+1] += dp[i][j]) %= MOD;\n    }\n  }\n\n  ll ret = 0;\n  REP(i, n+1) for(int j=0; i+j<=n; ++j) {\n    ll num = 1;\n    REP(k, 26) {\n      if(spos[i][k] < n-j) {\n        num++;\n      }\n    }\n    (ret += dp[i][j] * num % MOD) %= MOD;\n  }\n  cout << ret-1 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing lpair = pair<ll, ll>;\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(int i=(m);i<(n);i++)\n#define rrep(i,m,n) for(ll i=(m);i>=(n);i--)\n#define printa(x,n) for(ll i=0;i<n;i++){cout<<(x[i])<<\" \\n\"[i==n-1];};\nvoid print() {}\ntemplate <class H,class... T>\nvoid print(H&& h, T&&... t){cout<<h<<\" \\n\"[sizeof...(t)==0];print(forward<T>(t)...);}\nint dp[2010][2010] = {};\nint nxt_s[2010][30] = {};\nint nxt_t[2010][30] = {};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    string T = S;\n    reverse(T.begin(), T.end());\n    vector<int> pos_s[30], pos_t[30];\n    ll N = S.size();\n    rep(i,0,N) pos_s[S[i]-'a'].push_back(i);\n    rep(i,0,N) pos_t[T[i]-'a'].push_back(i);\n    memset(nxt_s, -1, sizeof(nxt_s));\n    memset(nxt_t, -1, sizeof(nxt_t));\n\n    dp[0][0] = 1;\n    rrep(i,N-1,0){\n        rep(k,0,26){\n            nxt_s[i][k] = nxt_s[i+1][k];\n        }\n        nxt_s[i][S[i]-'a'] = i;\n    }\n    rrep(i,N-1,0){\n        rep(k,0,26){\n            nxt_t[i][k] = nxt_t[i+1][k];\n        }\n        nxt_t[i][T[i]-'a'] = i;\n    }\n\n\n    rep(i,0,N){\n        rep(j,0,N){\n            rep(k,0,26){\n                ll ps = nxt_s[i][k];\n                ll pt = nxt_t[j][k];\n                if(ps != -1 && pt != -1){\n                    if(ps + pt + 2 <= N){\n                        dp[ps+1][pt+1] += dp[i][j];\n                        dp[ps+1][pt+1] %= MOD;\n                    }\n                }\n            }\n        }\n    }\n    ll ans = 0;\n    rep(i,0,N+1){\n        rep(j,0,N+1){\n            if(dp[i][j] != 0 && i + j <= N){\n                ll cnt = 0;\n                ll lv = i, rv = N-1-j;\n                rep(k,0,26){\n                    ll p = upper_bound(pos_s[k].begin(), pos_s[k].end(), rv) - pos_s[k].begin();\n                    ll p2 = lower_bound(pos_s[k].begin(), pos_s[k].end(), lv) - pos_s[k].begin();\n                    if(p - p2 > 0) cnt++;\n                }\n                ans += dp[i][j] * (cnt+1);\n                ans %= MOD;\n\n            }\n\n        }\n    }\n    ans--;\n    print(ans);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nstring s;\nint n;\nint nx[26][2010], nx2[26][2010];\nll dp[2010][2010];\nint main()\n{\n    cin>>s;\n    n=s.size();\n    for(int i=0; i<=n; i++){\n        for(int j=0; j<26; j++){\n            nx2[j][i+1]=nx2[j][i];\n        }\n        if(i>0) nx2[s[i-1]-'a'][i+1]=i;\n    }\n    for(int j=0; j<26; j++) nx[j][n+1]=n+1;\n    for(int i=n; i>=0; i--){\n        for(int j=0; j<26; j++) nx[j][i]=nx[j][i+1];\n        if(i<n) nx[s[i]-'a'][i]=i+1;\n    }\n    dp[0][n+1]=1;\n    ll ans=MOD-1;\n    for(int i=0; i<=n; i++){\n        for(int j=n+1; j>=i+1; j--){\n            (ans+=dp[i][j])%=MOD;\n            for(int k=0; k<26; k++){\n                if(nx[k][i]<j) (ans+=dp[i][j])%=MOD;\n                if(nx[k][i]<nx2[k][j]) (dp[nx[k][i]][nx2[k][j]]+=dp[i][j])%=MOD;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define rep2(i,start,end) for(int i=(int)start;i<=(int)end;i++)\n#define vrep(i, n) for(int i=(int)n-1;i>=0;i--)\n#define vrep1(i, n) for(int i=(int)n;i>0;i--)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<long,long> plong;\ntypedef vector<int> vint;\ntypedef vector<long> vlong;\n\nconst double pi=M_PI;\nconst int INF10 = 1000000001;\nconst long long INF18 = 1e18 + 1;\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\nstruct edge{\n    edge(int i,long c=1){\n        to=i;\n        cost=c;\n    }\n    int to;\n    long cost;\n};\n\n//bを何回足せばaを超えるか(O(a/b))\n//a+b-1/bとすればよし\n\n//2進数表示したときの最高桁(O(log n))\nint bi_max(long n){\n    int m = 0;\n    for (m; (1 << m) <= n; m++);\n    m = m - 1;\n    return m;\n}\n//bi_eに二進数表示したやつを代入(O(log^2 n))\n//bitset<N> a(n)でnの二進数表示が得られて、a[i]=0or1でi番目のfragが立ってるかわかる\n//x^n mod m (nが負の時は０)(O(log n))\nlong myPow(long x, long n, long m=mod){\n    if (n < 0)\n        return 0;\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return myPow(x * x % m, n / 2, m);\n    else\n        return x * myPow(x, n - 1, m) % m;\n}\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\nstruct mint{\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n    mint operator-() const { return mint(-x); }\n    mint &operator+=(const mint a)\n    {\n        if ((x += a.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n    mint &operator-=(const mint a)\n    {\n        if ((x += mod - a.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n    mint &operator*=(const mint a)\n    {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const { return mint(*this) += a; }\n    mint operator-(const mint a) const { return mint(*this) -= a; }\n    mint operator*(const mint a) const { return mint(*this) *= a; }\n    mint pow(ll t) const\n    {\n        if (!t)\n            return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1)\n            a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const { return pow(mod - 2); }\n    mint &operator/=(const mint a) { return *this *= a.inv(); }\n    mint operator/(const mint a) const { return mint(*this) /= a; }\n    bool operator!=(const int a) { return this->x!=a; }\n};\nistream &operator>>(istream &is, const mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n// combination mod prime\n// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619\nstruct combination{\n    vector<mint> fact, ifact;\n    combination(int n) : fact(n + 1), ifact(n + 1)\n    {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i)\n            ifact[i - 1] = ifact[i] * i;\n    }\n    mint operator()(int n, int k)\n    {\n        if (k < 0 || k > n)\n            return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n};\ntemplate<class T>\nvoid maxin (T &a,T b){a=max(a,b);}\ntemplate<class T>\nvoid minin (T &a,T b){a=min(a,b);}\ntemplate<class M,class N> \nconstexpr common_type_t<M,N> gcd(M a,N b){\n    a=abs(a);b=abs(b);\n    if(a < b) return gcd(b, a);\n    M r;\n    while ((r=a%b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\ntemplate<class M,class N>\nconstexpr common_type_t<M,N> lcm(M a,N b){\n    return a*b/gcd(a,b);\n}\n\nconst int N_MAX=2005;\nstring s,t;\nint nxts[N_MAX][26],nxtt[N_MAX][26],n;\n//mint dp[N_MAX];\n//素直に実装  間に合わない\n/*mint solve(){\n    auto compare=[](pint a,pint b){\n        return a.first>b.first;\n    };\n    mint res=0,r=1;\n    priority_queue<pint,vector<pint>,decltype(compare)> que {compare};\n    que.push({-1,-1});\n    int nows,nowt,ns,nt,count;\n    while(!que.empty()){\n        pint a=que.top();que.pop();\n        nows=a.first+1;\n        nowt=a.second+1;\n        //if(a.first>=0)r=dp[a.first];\n        r=1;\n        if(a.first+a.second==n-2){\n            res+=r;\n        }else{\n            count=1;\n            rep(i,26){\n                if(nxts[nows][i]<n-nowt)count++;\n            }\n            r*=count;\n            res+=r;\n        }\n        //cout << \"s[\"<<a.first<<\"]=\"<<s[a.first]<<\" t[\"<<a.second<<\"]=\"<<t[a.second] <<endl;\n        //cout <<\"count=\"<<count<<\" r=\" <<r<<\" res=\"<<res <<endl;\n        rep(j,26){\n            ns=nxts[nows][j];nt=nxtt[nowt][j];\n            if(ns+nt<=n-2){\n                //cout << \"nxts[\"<<nows<<\"][\"<<j<<\"]=\"<<ns<<\" nxtt[\"<<nowt<<\"][\"<<j<<\"]=\"<<nt <<\" s[ns]=\"<<s[ns]<<endl;\n                que.push({ns,nt});\n                //if(nows-1<0)dp[ns]=1;\n                //else dp[ns]+=dp[nows-1];\n            }\n        }\n    }\n    res-=1;\n    return res;\n}*/\n\nmint dp[N_MAX][N_MAX];\nmint solve(){\n    dp[0][0]=1;\n    rep(i,n){\n        rep(j,n){\n            rep(l,26){\n                if(nxts[i][l]+nxtt[j][l]+2>n)continue;\n                dp[nxts[i][l]+1][nxtt[j][l]+1]+=dp[i][j];\n            }\n        }\n    }\n    mint res=0,r;\n    int x,y,count;\n    rep(i,n+1){\n        rep(j,i+1){\n            x=j;y=i-j;\n            count=1;\n            rep(l,26){\n                if(nxts[x][l]<n-y)count++;\n            }\n            r=dp[x][y];\n            r*=count;\n            res+=r;\n        }\n    }\n    res-=1;\n    return res;\n}\n\n\nint main(){\n    int x,y;\n    //入力\n    cin>>s;\n    t=s;\n    reverse(t.begin(),t.end());\n    //処理\n    n=s.size();\n    rep(i,n+1){\n        rep(j,26){\n            nxts[i][j]=n;\n            nxtt[i][j]=n;\n        }\n    }\n    vrep(i,n){\n        rep(j,26){\n            nxts[i][j]=nxts[i+1][j];\n            nxtt[i][j]=nxtt[i+1][j];\n        }\n        nxts[i][s[i]-'a']=i;\n        nxtt[i][t[i]-'a']=i;\n    }\n    mint ans=solve();\n    //出力\n    cout << ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rrep(i,n) for(int (i)=((n)-1);(i)>=0;(i)--)\n#define itn int\n#define miele(v) min_element(v.begin(), v.end())\n#define maele(v) max_element(v.begin(), v.end())\n#define SUM(v) accumulate(v.begin(), v.end(), 0LL)\n#define lb(a, key) lower_bound(a.begin(),a.end(),key)\n#define ub(a, key) upper_bound(a.begin(),a.end(),key)\n#define COUNT(a, key) count(a.begin(), a.end(), key) \n#define BITCOUNT(x) __builtin_popcount(x)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\nusing P = pair <int,int>;\nusing WeightedGraph = vector<vector <P>>;\nusing UnWeightedGraph = vector<vector<int>>;\nusing Real = long double;\nusing Point = complex<Real>; //Point and Vector2d is the same!\nusing Vector2d = complex<Real>;\nconst long long INF = 1LL << 60;\nconst int MOD = 1000000007;\nconst double EPS = 1e-15;\nconst double PI=3.14159265358979323846;\ntemplate <typename T> \nint getIndexOfLowerBound(vector <T> &v, T x){\n    return lower_bound(v.begin(),v.end(),x)-v.begin();\n}\ntemplate <typename T> \nint getIndexOfUpperBound(vector <T> &v, T x){\n    return upper_bound(v.begin(),v.end(),x)-v.begin();\n}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n#define DUMPOUT cerr\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\nistream &operator>>(istream &is, Point &p) {\n    Real a, b; is >> a >> b; p = Point(a, b); return is;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T,U> &p_var) {\n    is >> p_var.first >> p_var.second;\n    return is;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<vector<T>> &df) {\n    for(int i=0;i<df.size();i++)for(int j=0;j<df[i].size();j++)\n    is >> df[i][j];\n    return is;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    DUMPOUT<<'{';\n    os << pair_var.first;\n    DUMPOUT<<',';\n    os << \" \"<< pair_var.second;\n    DUMPOUT<<'}';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> &vec) {\n    DUMPOUT<<'[';\n    for (int i = 0; i < vec.size(); i++) \n    os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    DUMPOUT<<']';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<vector<T>> &df) {\n  for (auto& vec : df) os<<vec;\n  return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    DUMPOUT << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) DUMPOUT << \", \";\n        itr--;\n    }\n    DUMPOUT << \"}\";\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    DUMPOUT << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) DUMPOUT << \", \";\n        itr--;\n    }\n    DUMPOUT << \"}\";\n    return os;\n}\nvoid print() {cout << endl;}\ntemplate <class Head, class... Tail>\nvoid print(Head&& head, Tail&&... tail) {\n  cout << head;\n  if (sizeof...(tail) != 0) cout << \" \";\n  print(forward<Tail>(tail)...);\n}\nvoid dump_func() {DUMPOUT << '#'<<endl;}\ntemplate <typename Head, typename... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<1000000007>;\nvector <vector<int>> calcNext(string &s){\n    int n = s.size();\n    vector <vector<int>> res(n+1,vector <int>(26, n));\n    rrep(i, n){\n        rep(j, 26) res[i][j] = res[i+1][j];\n        res[i][s[i] - 'a'] = i;\n    }\n    return res;\n}\nsigned main(void) { cin.tie(0); ios::sync_with_stdio(false);\n    string s; cin>>s;\n    string t = s;\n    int n = s.size();\n    reverse(t.begin(),t.end());\n\n    auto ns = calcNext(s), nt = calcNext(t);\n    vector <vector<mint>> dp(n+1,vector <mint>(n+1));\n    dp[0][0] = 1;\n    rep(i, n){\n        rep(j, n){\n            rep(k, 26){\n                int nei = ns[i][k];\n                int nej = nt[j][k];\n                if(nei + nej +2 > n) continue;\n                dp[nei+1][nej+1] += dp[i][j];\n            }\n        }\n    }\n    mint ans = 0;\n    rep(i, n+1){\n        for(int j = 0; j+i <= n; ++j){\n            mint cnt = 1;\n            rep(k, 26){\n                int ne = ns[i][k];\n                if (ns[i][k] + 1 + j <= n) cnt += 1;\n            }\n            ans += dp[i][j]*cnt;\n        }\n    }\n    print(ans -1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\n// res[i][c] := i 文字目以降で最初に文字 c が登場する index (存在しないときは n)\nvector<vector<int> > calcNext(const string &S) {\n\tint n = (int)S.size();\n\tvector<vector<int> > res(n + 1, vector<int>(26, n));\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tfor (int j = 0; j < 26; ++j) res[i][j] = res[i + 1][j];\n\t\tres[i][S[i] - 'a'] = i;\n\t}\n\treturn res;\n}\n\nvoid add(long long &a, long long b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n}\n\nint main() {\n\tstring S; cin >> S;\n\tint n = (int)S.size();\n\tstring T = S;\n\treverse(T.begin(), T.end());\n\t\n\tauto ns = calcNext(S);\n\tauto nt = calcNext(T);\n\tvector<vector<long long> > dp(n + 1, vector<long long>(n + 1, 0));\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tfor (int k = 0; k < 26; ++k) {\n\t\t\t\tint ni = ns[i][k];\n\t\t\t\tint nj = nt[j][k];\n\t\t\t\tif (ni + nj + 2 > n) continue;\n\t\t\t\tadd(dp[ni + 1][nj + 1], dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tlong long res = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; i + j <= n; ++j) {\n\t\t\tint num = 1;\n\t\t\tfor (int k = 0; k < 26; ++k) if (ns[i][k] + 1 + j <= n) ++num;\n\t\t\t\n\n\t\t\t//cout << i << \", \" << j << \": \" << dp[i][j] << \";;; \" << num << endl;\n\n\t\t\tres = (res + dp[i][j] * num % MOD) % MOD;\n\t\t}\n\t}\n\tcout << res - 1 << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MOD 1000000007\n#define SMAX 2000\n#define CMAX 26\n\nint dp[SMAX][SMAX], nearl[CMAX][SMAX], nearr[CMAX][SMAX];\nint dfs(int l, int r);\nint main(void)\n{\n  int i, j, slen;\n  char str[SMAX+1];\n  scanf(\"%s\", str);\n  slen = strlen(str);\n  for (i = 0; i < CMAX; i++) {\n    for (j = 0; j < slen; j++) {\n      nearl[i][j] = slen;\n      nearr[i][j] = -1;\n    }\n  }\n  for (i = 0; i < slen; i++) nearl[str[i]-'a'][i] = nearr[str[i]-'a'][i] = i;\n  for (i = 0; i < CMAX; i++) {\n    for (j = slen - 2; j >= 0; j--) {\n      if (nearl[i][j] > nearl[i][j+1]) nearl[i][j] = nearl[i][j+1];\n    }\n    for (j = 1; j < slen; j++) {\n      if (nearr[i][j] < nearr[i][j-1]) nearr[i][j] = nearr[i][j-1];\n    }\n  }\n  memset(dp, -1, sizeof(dp));\n  printf(\"%d\\n\", dfs(0, slen - 1));\n}\n\nint dfs(int l, int r)\n{\n  int i;\n  long long res = 0;\n  if (~dp[l][r]) return dp[l][r];\n  for (i = 0; i < CMAX; i++) {\n    if (nearl[i][l] <= nearr[i][r]) res++;\n    if (nearl[i][l] < nearr[i][r]) res += dfs(nearl[i][l] + 1, nearr[i][r] - 1) + 1;\n  }\n  return dp[l][r] = res % MOD;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using System.Text;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\n//using System.Numerics;\n//using static System.Math;\n//using pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    void chmax<T>(ref T a, T b) where T : IComparable<T> { a = a.CompareTo(b) < 0 ? b : a; }\n    void chmin<T>(ref T a, T b) where T : IComparable<T> { a = a.CompareTo(b) < 0 ? a : b; }\n\n    void solve()\n    {\n        var X = ReadLine();\n        var Y = string.Concat(X.Reverse());\n        int N = X.Length;\n        int M = 26;\n        var cnt = new int[N, M];\n        for (int i = 0; i < N; i++)\n        {\n            for (int k = 0; k < M; k++)\n            {\n                if (i > 0) cnt[i, k] = cnt[i - 1, k];\n            }\n            cnt[i, X[i] - 'a']++;\n        }\n\n        var C = new int[N, N];\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = i; j < N; j++)\n            {\n                int tmp = 0;\n                for (int k = 0; k < M; k++)\n                {\n                    var t = cnt[j, k];\n                    if (i > 0) t -= cnt[i - 1, k];\n                    if (t > 0) tmp++;\n                }\n                C[i, j] = tmp;\n            }\n        }\n        //WriteLine(C[0, N - 1]);\n\n        var V = new int[N + 1, 26]; //i番目の文字にいるときに、次のjという文字の場所\n        for (int i = 0; i < 26; i++)\n        {\n            V[N, i] = int.MaxValue;\n        }\n        for (int i = N - 1; i >= 0; i--)\n        {\n            for (int j = 0; j < 26; j++)\n            {\n                V[i, j] = V[i + 1, j];\n            }\n            V[i, X[i] - 'a'] = i + 1;\n        }\n        var W = new int[N + 1, 26];\n        for (int i = 0; i < 26; i++)\n        {\n            W[N, i] = int.MaxValue;\n        }\n        for (int i = N - 1; i >= 0; i--)\n        {\n            for (int j = 0; j < 26; j++)\n            {\n                W[i, j] = W[i + 1, j];\n            }\n            W[i, Y[i] - 'a'] = i + 1;\n        }\n\n        var dp = new ModInt[N + 1, N + 1];\n        dp[0, 0] = 1;\n        ModInt ans = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                for (int k = 0; k < M; k++)\n                {\n                    if (V[i, k] == int.MaxValue || W[j, k] == int.MaxValue)\n                    {\n                        continue;\n                    }\n                    dp[V[i, k], W[j, k]] += dp[i, j];\n                }\n                if (i + j <= N)\n                {\n                    ans += dp[i, j] * (1 + C[i, N - j - 1]);\n                    //WriteLine(i + \" \" + j + \" \" + dp[i, j] + \" \" + dp[i, j] * (1 + C[i, N - j - 1]));\n                }\n            }\n        }\n\n        WriteLine(ans - 1);\n\n\n\n    }\n\n}\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt\n{\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k)\n    {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n\n#region Binomial Coefficient\npublic class BinomialCoefficient\n{\n    public ModInt[] fact, ifact;\n    public BinomialCoefficient(int n)\n    {\n        fact = new ModInt[n + 1];\n        ifact = new ModInt[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = ModInt.Inverse(fact[n]);\n        for (int i = n - 1; i >= 0; i--)\n            ifact[i] = ifact[i + 1] * (i + 1);\n        ifact[0] = ifact[1];\n    }\n    public ModInt this[int n, int r]\n    {\n        get\n        {\n            if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n            return fact[n] * ifact[n - r] * ifact[r];\n        }\n    }\n    public ModInt RepeatedCombination(int n, int k)\n    {\n        if (k == 0) return 1;\n        return this[n + k - 1, k];\n    }\n}\n#endregion\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n    public string join<T>(IEnumerable<T> values) { return string.Join(\" \", values); }\n}\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    from bisect import bisect_left as bl\n    from bisect import bisect_right as br\n    s=input()\n    alpha=\"abcdefghijklmnopqrstuvwxyz\"\n    l=len(s)\n    alpha2={j:i for i,j in enumerate(alpha)}\n    memo=[[] for _ in [0]*26]\n    mod=10**9+7\n    for i in range(l):\n        memo[alpha2[s[i]]].append(i)\n    dp=[[0]*(l+1) for _ in range(l+1)]\n    dp[0][l]=1\n    ans=0\n    for i in range(l):\n        for j in range(i+1,l+1):\n            p=dp[i][j]\n            if p==0:\n                continue\n            for k in range(26):\n                x=bl(memo[k],i)\n                y=br(memo[k],j-1)-1\n                if x>y:\n                    continue\n                ans+=p\n                if x<y:\n                    mx,my=memo[k][x],memo[k][y]\n                    dp[mx+1][my]=(dp[mx+1][my]+p)%mod\n            ans=ans%mod\n    ans=(ans+sum([sum([i for i in j])%mod for j in dp])+mod-1)%mod\n    print(ans)\n    \nif __name__=='__main__':\n    main()\n"
  }
]