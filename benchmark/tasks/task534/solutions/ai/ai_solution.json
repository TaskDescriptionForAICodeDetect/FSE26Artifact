[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#define MOD 1000000007\n#define MAX_LEN 1005\n\nint distinctPalindromicSubsequences(char* s) {\n    int n = strlen(s);\n    int dp[MAX_LEN][MAX_LEN] = {0};\n    \n    // Single characters are palindromes\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    \n    // Build up palindrome subsequences bottom-up\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            \n            if (s[i] == s[j]) {\n                int left = i + 1;\n                int right = j - 1;\n                \n                // Find first and last matching characters\n                while (left <= right && s[left] != s[i]) left++;\n                while (left <= right && s[right] != s[i]) right--;\n                \n                if (left > right) {\n                    // No other matching chars, double the previous result\n                    dp[i][j] = 2 * dp[i+1][j-1] + 2;\n                }\n                else if (left == right) {\n                    // Single matching char between\n                    dp[i][j] = 2 * dp[i+1][j-1] + 1;\n                }\n                else {\n                    // Multiple matching chars\n                    dp[i][j] = 2 * dp[i+1][j-1] - dp[left+1][right-1];\n                }\n            }\n            else {\n                // Different chars at ends\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1];\n            }\n            \n            // Ensure non-negative and within mod\n            dp[i][j] = (dp[i][j] + MOD) % MOD;\n        }\n    }\n    \n    return dp[0][n-1];\n}",
    "timestamp": "2025-08-05 22:03:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MOD 1000000007\n\nint countPalindromicSubsequences(char* S) {\n    int n = strlen(S);\n    int dp[n][n];\n    memset(dp, 0, sizeof(dp));\n    \n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    \n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if (S[i] == S[j]) {\n                int left = i + 1;\n                int right = j - 1;\n                while (left <= right && S[left] != S[i]) left++;\n                while (left <= right && S[right] != S[i]) right--;\n                \n                if (left > right) {\n                    dp[i][j] = dp[i+1][j-1] * 2 + 2;\n                } else if (left == right) {\n                    dp[i][j] = dp[i+1][j-1] * 2 + 1;\n                } else {\n                    dp[i][j] = dp[i+1][j-1] * 2 - dp[left+1][right-1];\n                }\n            } else {\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1];\n            }\n            dp[i][j] = (dp[i][j] < 0) ? dp[i][j] + MOD : dp[i][j] % MOD;\n        }\n    }\n    return dp[0][n-1];\n}\n\nint main() {\n    char S[1000];\n    scanf(\"%s\", S);\n    printf(\"%d\\n\", countPalindromicSubsequences(S));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:03:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countPalindromicSubsequences(string S) {\n    int n = S.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    \n    for (int i = 0; i < n; ++i) {\n        dp[i][i] = 1;\n    }\n    \n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n            if (S[i] == S[j]) {\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] + 1) % MOD;\n            } else {\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % MOD;\n                if (dp[i][j] < 0) dp[i][j] += MOD;\n            }\n        }\n    }\n    \n    return dp[0][n - 1];\n}\n\nint main() {\n    string S;\n    cin >> S;\n    cout << countPalindromicSubsequences(S) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:03:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PalindromicSubsequences {\n    private static final int MOD = 1_000_000_007;\n\n    public static int countPalindromicSubsequences(String s) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1;\n                if (s.charAt(i) == s.charAt(j)) {\n                    int left = i + 1;\n                    int right = j - 1;\n                    while (left <= right && s.charAt(i) != s.charAt(left)) {\n                        left++;\n                    }\n                    while (left <= right && s.charAt(j) != s.charAt(right)) {\n                        right--;\n                    }\n                    if (left > right) {\n                        dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + 1;\n                    } else if (left == right) {\n                        dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + 1;\n                    } else {\n                        dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[left + 1][right - 1];\n                    }\n                } else {\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1];\n                }\n                dp[i][j] = dp[i][j] < 0 ? dp[i][j] + MOD : dp[i][j] % MOD;\n            }\n        }\n        return dp[0][n - 1];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();\n        System.out.println(countPalindromicSubsequences(s));\n    }\n}",
    "timestamp": "2025-08-05 22:04:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public int countPalindromicSubsequences(String s) {\n        int n = s.length();\n        int mod = 1000000007;\n        \n        int[][][] dp = new int[n][n][4];\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i; j < n; j++) {\n                for (int k = 0; k < 4; k++) {\n                    char ch = (char) ('a' + k);\n                    \n                    if (i == j) {\n                        dp[i][j][k] = s.charAt(i) == ch ? 1 : 0;\n                    } else {\n                        if (s.charAt(i) != ch) {\n                            dp[i][j][k] = dp[i + 1][j][k];\n                        } else if (s.charAt(j) != ch) {\n                            dp[i][j][k] = dp[i][j - 1][k];\n                        } else {\n                            dp[i][j][k] = 2;\n                            \n                            if (i + 1 <= j - 1) {\n                                for (int m = 0; m < 4; m++) {\n                                    dp[i][j][k] = (dp[i][j][k] + dp[i + 1][j - 1][m]) % mod;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        int result = 0;\n        for (int k = 0; k < 4; k++) {\n            result = (result + dp[0][n - 1][k]) % mod;\n        }\n        \n        return result;\n    }\n}",
    "timestamp": "2025-08-05 22:04:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    int countPalindromicSubsequences(string s) {\n        int n = s.length();\n        const int MOD = 1e9 + 7;\n        vector<vector<int>> dp(n, vector<int>(n, 0));\n        \n        // Single character subsequences\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n        \n        // Iterate over lengths\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i < n - len + 1; i++) {\n                int j = i + len - 1;\n                \n                if (s[i] == s[j]) {\n                    int left = i + 1;\n                    int right = j - 1;\n                    \n                    // Find leftmost and rightmost same character\n                    while (left <= right && s[left] != s[i]) left++;\n                    while (left <= right && s[right] != s[j]) right--;\n                    \n                    if (left > right) {\n                        // No same characters between\n                        dp[i][j] = dp[i+1][j-1] * 2 + 2;\n                    } else if (left == right) {\n                        // Single same character\n                        dp[i][j] = dp[i+1][j-1] * 2 + 1;\n                    } else {\n                        // Multiple same characters\n                        dp[i][j] = dp[i+1][j-1] * 2 - dp[left+1][right-1];\n                    }\n                } else {\n                    dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1];\n                }\n                \n                dp[i][j] = (dp[i][j] + MOD) % MOD;\n            }\n        }\n        \n        return dp[0][n-1];\n    }\n};",
    "timestamp": "2025-08-05 22:04:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_palindromic_subsequences(S: str) -> int:\n    MOD = 1_000_000_007\n    n = len(S)\n    \n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if S[i] == S[j]:\n                low, high = i + 1, j - 1\n                while low <= high and S[low] != S[i]:\n                    low += 1\n                while low <= high and S[high] != S[j]:\n                    high -= 1\n                \n                if low > high:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                elif low == high:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 - dp[low + 1][high - 1]\n            else:\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n            \n            dp[i][j] = (dp[i][j] + MOD) % MOD\n    \n    return dp[0][n - 1]\n\n# Example usage:\n# S = \"bccb\"\n# print(count_palindromic_subsequences(S))  # Output: 6",
    "timestamp": "2025-08-13 08:44:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DistinctPalindromicSubsequences {\n    \n    private static final int MOD = 1000000007;\n\n    public int countPalindromicSubsequences(String S) {\n        int n = S.length();\n        int[][] dp = new int[n][n];\n        int[] next = new int[n], prev = new int[n], last = new int[26];\n        \n        Arrays.fill(last, -1);\n        \n        for (int i = 0; i < n; i++) {\n            char ch = S.charAt(i);\n            if (last[ch - 'a'] != -1) {\n                prev[i] = last[ch - 'a'];\n            } else {\n                prev[i] = -1;\n            }\n            last[ch - 'a'] = i;\n        }\n        \n        Arrays.fill(last, -1);\n        for (int i = n - 1; i >= 0; i--) {\n            char ch = S.charAt(i);\n            if (last[ch - 'a'] != -1) {\n                next[i] = last[ch - 'a'];\n            } else {\n                next[i] = n;\n            }\n            last[ch - 'a'] = i;\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            dp[i][i] = 1;\n            for (int j = i + 1; j < n; j++) {\n                if (S.charAt(i) == S.charAt(j)) {\n                    int next_i = next[i], prev_j = prev[j];\n                    if (next_i > prev_j) {\n                        dp[i][j] = (2 * dp[i + 1][j - 1] + 2) % MOD;\n                    } else if (next_i == prev_j) {\n                        dp[i][j] = (2 * dp[i + 1][j - 1] + 1) % MOD;\n                    } else {\n                        dp[i][j] = (2 * dp[i + 1][j - 1] - dp[next_i + 1][prev_j - 1] + MOD) % MOD;\n                    }\n                } else {\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] + MOD) % MOD;\n                }\n            }\n        }\n        \n        return dp[0][n - 1];\n    }\n\n    public static void main(String[] args) {\n        DistinctPalindromicSubsequences solver = new DistinctPalindromicSubsequences();\n        System.out.println(solver.countPalindromicSubsequences(\"bccb\"));  // Example usage\n    }\n}",
    "timestamp": "2025-08-13 08:44:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint countPalindromicSubsequences(char *S) {\n    int n = strlen(S);\n    int dp[n][n];\n    int prev[26];\n    int next[26];\n\n    memset(dp, 0, sizeof(dp));\n    memset(prev, -1, sizeof(prev));\n    memset(next, -1, sizeof(next));\n\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            if (S[i] == S[j]) {\n                dp[i][j] = (2 + dp[i+1][j-1]) % MOD;\n                int p = next[i+1];\n                int q = prev[j-1];\n                if (p <= q) {\n                    if (p == q) {\n                        dp[i][j] = (dp[i][j] - dp[p+1][q-1] + MOD) % MOD;\n                    } else {\n                        dp[i][j] = (dp[i][j] - (2 * dp[p+1][q-1]) % MOD + MOD) % MOD;\n                    }\n                }\n            } else {\n                dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + MOD) % MOD;\n            }\n        }\n        for (int i = n - len; i >= 0; i--) {\n            next[i] = (S[i] == S[i+len-1] ? i : next[i+1]);\n        }\n        for (int j = n - len; j >= 0; j--) {\n            prev[j] = (S[j] == S[j+len-1] ? j : prev[j+1]);\n        }\n    }\n\n    return dp[0][n-1];\n}\n\nint main() {\n    char S[1001];\n    scanf(\"%s\", S);\n    printf(\"%d\\n\", countPalindromicSubsequences(S));\n    return 0;\n}",
    "timestamp": "2025-08-13 08:44:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Solution:\n    def countPalindromicSubsequences(self, s: str) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        # Each single character is a palindrome\n        for i in range(n):\n            dp[i][i] = 1\n        \n        # Iterate through all possible substring lengths\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                \n                # If characters at start and end match\n                if s[i] == s[j]:\n                    left = i + 1\n                    right = j - 1\n                    \n                    # Find first and last occurrence of this character\n                    while left <= right and s[left] != s[i]:\n                        left += 1\n                    while left <= right and s[right] != s[j]:\n                        right -= 1\n                    \n                    # Different cases for character occurrences\n                    if left > right:\n                        # No same characters between i and j\n                        dp[i][j] = dp[i+1][j-1] * 2 + 2\n                    elif left == right:\n                        # One same character between i and j\n                        dp[i][j] = dp[i+1][j-1] * 2 + 1\n                    else:\n                        # Multiple same characters between i and j\n                        dp[i][j] = dp[i+1][j-1] * 2 - dp[left+1][right-1]\n                \n                # If characters don't match\n                else:\n                    dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                \n                # Ensure non-negative and apply modulo\n                dp[i][j] = (dp[i][j] + MOD) % MOD\n        \n        return dp[0][n-1]",
    "timestamp": "2025-08-13 08:44:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef countPalindromicSubsequences(S):\n    n = len(S)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if S[i] == S[j]:\n                left = i + 1\n                right = j - 1\n                while left <= right and S[left] != S[i]:\n                    left += 1\n                while left <= right and S[right] != S[i]:\n                    right -= 1\n                if left > right:\n                    dp[i][j] = dp[i+1][j] + dp[i][j-1] + 1\n                elif left == right:\n                    dp[i][j] = dp[i+1][j] + dp[i][j-1] + 1\n                else:\n                    dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[left+1][right-1]\n            else:\n                dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]\n            dp[i][j] %= MOD\n    return dp[0][n-1] % MOD",
    "timestamp": "2025-08-13 08:45:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nconst int MOD = 1000000007;\n\nint countPalindromicSubsequences(const std::string &S) {\n    int n = S.size();\n    std::vector<std::vector<long long>> dp(n, std::vector<long long>(n, 0));\n    std::vector<std::vector<bool>> isPalindrome(n, std::vector<bool>(n, false));\n    \n    for (int i = 0; i < n; ++i) {\n        dp[i][i] = 1;\n        isPalindrome[i][i] = true;\n    }\n    \n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n            if (S[i] == S[j]) {\n                dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) % MOD;\n                isPalindrome[i][j] = isPalindrome[i+1][j-1] || len == 2;\n            } else {\n                dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + MOD) % MOD;\n            }\n        }\n    }\n\n    std::unordered_map<std::string, bool> uniquePalindromes;\n    \n    for (int len = 1; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n            if (isPalindrome[i][j]) {\n                uniquePalindromes[S.substr(i, len)] = true;\n            }\n        }\n    }\n\n    return uniquePalindromes.size();\n}\n\nint main() {\n    std::string S;\n    std::cin >> S;\n    std::cout << countPalindromicSubsequences(S) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:47:47"
  }
]