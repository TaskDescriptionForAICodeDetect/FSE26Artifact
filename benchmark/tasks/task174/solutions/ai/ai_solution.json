[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_ROOMS 20\n\nint main() {\n    int battery, start, battery_room, junk_room;\n    int adj[MAX_ROOMS][MAX_ROOMS];\n    int degree[MAX_ROOMS];\n    double prob[MAX_ROOMS][2];\n    int current, next;\n    int i, j, k, n, dataset = 1;\n\n    while (1) {\n        scanf(\"%d\", &battery);\n        if (battery == 0) break;\n        scanf(\"%d %d %d\", &start, &battery_room, &junk_room);\n\n        memset(adj, 0, sizeof(adj));\n        memset(degree, 0, sizeof(degree));\n        n = 0;\n\n        while (1) {\n            int a, b;\n            scanf(\"%d %d\", &a, &b);\n            if (a == 0 && b == 0) break;\n            adj[a][degree[a]++] = b;\n            adj[b][degree[b]++] = a;\n            if (a > n) n = a;\n            if (b > n) n = b;\n        }\n\n        memset(prob, 0, sizeof(prob));\n        prob[start][0] = 1.0;\n\n        for (k = 1; k <= battery; k++) {\n            current = (k - 1) % 2;\n            next = k % 2;\n            for (i = 1; i <= n; i++) {\n                prob[i][next] = 0.0;\n            }\n\n            for (i = 1; i <= n; i++) {\n                if (i == battery_room || i == junk_room) continue;\n                if (degree[i] == 0) continue;\n                double p = prob[i][current] / degree[i];\n                for (j = 0; j < degree[i]; j++) {\n                    int neighbor = adj[i][j];\n                    prob[neighbor][next] += p;\n                }\n            }\n        }\n\n        printf(\"Case %d: %.5f\\n\", dataset++, prob[battery_room][battery % 2]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:55:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CleaningRobotProbability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int batteryPoints = scanner.nextInt();\n            if (batteryPoints == 0) break;\n            \n            int totalRooms = scanner.nextInt();\n            int startRoom = scanner.nextInt();\n            int batteryRoom = scanner.nextInt();\n            int junkRoom = scanner.nextInt();\n            \n            int[][] adjacencyMatrix = new int[totalRooms + 1][totalRooms + 1];\n            for (int i = 1; i <= totalRooms; i++) {\n                int connections = scanner.nextInt();\n                for (int j = 0; j < connections; j++) {\n                    int connectedRoom = scanner.nextInt();\n                    adjacencyMatrix[i][connectedRoom] = 1;\n                    adjacencyMatrix[connectedRoom][i] = 1;\n                }\n            }\n            \n            double probability = computeProbability(batteryPoints, startRoom, batteryRoom, junkRoom, adjacencyMatrix);\n            System.out.printf(\"%.3f%n\", probability);\n        }\n        \n        scanner.close();\n    }\n    \n    private static double computeProbability(int batteryPoints, int startRoom, int batteryRoom, int junkRoom, int[][] adjacencyMatrix) {\n        int totalRooms = adjacencyMatrix.length - 1;\n        double[][][] dp = new double[batteryPoints + 1][totalRooms + 1][2];\n        \n        dp[0][startRoom][0] = 1.0;\n        \n        for (int battery = 1; battery <= batteryPoints; battery++) {\n            for (int currentRoom = 1; currentRoom <= totalRooms; currentRoom++) {\n                if (currentRoom == junkRoom) continue;\n                \n                for (int visitedBattery = 0; visitedBattery < 2; visitedBattery++) {\n                    for (int nextRoom = 1; nextRoom <= totalRooms; nextRoom++) {\n                        if (nextRoom == junkRoom || adjacencyMatrix[currentRoom][nextRoom] == 0) continue;\n                        \n                        int newVisitedBattery = visitedBattery | (nextRoom == batteryRoom ? 1 : 0);\n                        double newProbability = dp[battery - 1][currentRoom][visitedBattery] / countConnections(currentRoom, adjacencyMatrix);\n                        \n                        dp[battery][nextRoom][newVisitedBattery] += newProbability;\n                    }\n                }\n            }\n        }\n        \n        double totalProbability = 0.0;\n        for (int currentRoom = 1; currentRoom <= totalRooms; currentRoom++) {\n            totalProbability += dp[batteryPoints][currentRoom][1];\n        }\n        \n        return totalProbability;\n    }\n    \n    private static int countConnections(int room, int[][] adjacencyMatrix) {\n        int count = 0;\n        for (int i = 1; i < adjacencyMatrix.length; i++) {\n            if (adjacencyMatrix[room][i] == 1) count++;\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 18:56:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nvoid solve(int n, int start, int battery, int junk, vector<vector<int>>& adj) {\n    vector<vector<double>> dp(n, vector<double>(battery + 1, 0.0));\n    dp[start][battery] = 1.0;\n\n    for (int b = battery; b > 0; --b) {\n        for (int room = 0; room < n; ++room) {\n            if (room == junk || dp[room][b] == 0.0) continue;\n            int options = 0;\n            for (int next : adj[room]) {\n                if (next != junk) options++;\n            }\n            if (options == 0) continue;\n            double prob = dp[room][b] / options;\n            for (int next : adj[room]) {\n                if (next != junk) dp[next][b - 1] += prob;\n            }\n        }\n    }\n\n    double result = 0.0;\n    for (int b = 0; b <= battery; ++b) {\n        result += dp[battery][b];\n    }\n    cout << fixed << setprecision(5) << result << endl;\n}\n\nint main() {\n    while (true) {\n        int n, start, battery, junk, m;\n        cin >> n >> start >> battery >> junk >> m;\n        if (n == 0) break;\n\n        vector<vector<int>> adj(n);\n        for (int i = 0; i < m; ++i) {\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        solve(n, start, battery, junk, adj);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_ROOMS 100\n\ntypedef struct {\n    int battery_points;\n    int start_room;\n    int battery_room;\n    int junk_room;\n    int num_rooms;\n    int adjacency_matrix[MAX_ROOMS][MAX_ROOMS];\n} RobotDataset;\n\nvoid compute_probability(RobotDataset *dataset) {\n    int total_paths = 0;\n    int paths_to_battery = 0;\n    \n    // Use recursive depth-first search with backtracking\n    int visited[MAX_ROOMS];\n    memset(visited, 0, sizeof(visited));\n    \n    void dfs(int current_room, int remaining_battery, int path_length) {\n        // Base cases\n        if (remaining_battery < 0) return;\n        if (current_room == dataset->battery_room) {\n            paths_to_battery++;\n            total_paths++;\n            return;\n        }\n        \n        visited[current_room] = 1;\n        \n        // Explore adjacent rooms\n        for (int next_room = 0; next_room < dataset->num_rooms; next_room++) {\n            if (dataset->adjacency_matrix[current_room][next_room] &&\n                next_room != dataset->junk_room &&\n                !visited[next_room]) {\n                dfs(next_room, remaining_battery - 1, path_length + 1);\n            }\n        }\n        \n        visited[current_room] = 0;\n        total_paths++;\n    }\n    \n    dfs(dataset->start_room, dataset->battery_points, 0);\n    \n    // Compute and print probability\n    if (total_paths > 0) {\n        double probability = (double)paths_to_battery / total_paths;\n        printf(\"%.2f\\n\", probability);\n    } else {\n        printf(\"0.00\\n\");\n    }\n}\n\nint main() {\n    RobotDataset dataset;\n    \n    while (1) {\n        // Read dataset inputs\n        scanf(\"%d\", &dataset.battery_points);\n        \n        // Termination condition\n        if (dataset.battery_points == 0) break;\n        \n        scanf(\"%d %d %d %d\", \n              &dataset.num_rooms, \n              &dataset.start_room, \n              &dataset.battery_room, \n              &dataset.junk_room);\n        \n        // Read adjacency matrix\n        for (int i = 0; i < dataset.num_rooms; i++) {\n            for (int j = 0; j < dataset.num_rooms; j++) {\n                scanf(\"%d\", &dataset.adjacency_matrix[i][j]);\n            }\n        }\n        \n        // Compute and print probability\n        compute_probability(&dataset);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_ROOMS = 30;\n\nint main() {\n    int battery, rooms, start, battery_room, junk_room;\n    \n    while (true) {\n        cin >> battery;\n        \n        if (battery == 0) break;\n        \n        cin >> rooms >> start >> battery_room >> junk_room;\n        \n        vector<vector<int>> adjacency(rooms + 1);\n        vector<bool> visited(rooms + 1, false);\n        \n        int connections;\n        cin >> connections;\n        \n        for (int i = 0; i < connections; i++) {\n            int room1, room2;\n            cin >> room1 >> room2;\n            adjacency[room1].push_back(room2);\n            adjacency[room2].push_back(room1);\n        }\n        \n        int success_paths = 0;\n        int total_paths = 0;\n        \n        function<void(int, int, int)> dfs = [&](int current, int remaining_battery, int path_battery) {\n            if (remaining_battery < 0) return;\n            \n            if (current == battery_room) {\n                success_paths++;\n                total_paths++;\n                return;\n            }\n            \n            total_paths++;\n            visited[current] = true;\n            \n            for (int next : adjacency[current]) {\n                if (next != junk_room && !visited[next]) {\n                    dfs(next, remaining_battery - 1, path_battery + 1);\n                }\n            }\n            \n            visited[current] = false;\n        };\n        \n        dfs(start, battery, 0);\n        \n        double probability = total_paths > 0 ? (double)success_paths / total_paths : 0.0;\n        \n        cout << fixed << setprecision(2) << probability << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class CleaningRobotProbability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int B = scanner.nextInt();\n            if (B == 0) break;\n            int N = scanner.nextInt();\n            int M = scanner.nextInt();\n            int S = scanner.nextInt();\n            int J = scanner.nextInt();\n\n            double[][][] dp = new double[B + 1][N + 1][2];\n            dp[B][S][0] = 1.0;\n\n            for (int b = B; b >= 0; b--) {\n                for (int r = 1; r <= N; r++) {\n                    for (int k = 0; k < 2; k++) {\n                        if (dp[b][r][k] == 0) continue;\n                        if (b == 0 || r == J) continue;\n                        if (r == M) {\n                            continue;\n                        }\n\n                        int nextB = b - 1;\n                        if (nextB < 0) continue;\n\n                        int left = r - 1;\n                        if (left == 0) left = N;\n                        int right = r + 1;\n                        if (right > N) right = 1;\n\n                        double prob = dp[b][r][k] * 0.5;\n                        if (left == M) {\n                            dp[nextB][left][1] += prob;\n                        } else {\n                            dp[nextB][left][k] += prob;\n                        }\n\n                        if (right == M) {\n                            dp[nextB][right][1] += prob;\n                        } else {\n                            dp[nextB][right][k] += prob;\n                        }\n                    }\n                }\n            }\n\n            double result = 0.0;\n            for (int b = 0; b <= B; b++) {\n                result += dp[b][M][1];\n            }\n            System.out.printf(\"%.5f\\n\", result);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:57:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def robot_probability(datasets):\n    results = []\n    \n    for data in datasets:\n        battery, start, battery_room, junk_room = data\n        if battery == 0:\n            continue\n        \n        if start == battery_room:\n            results.append(1.0)\n            continue\n\n        dp = {start: 1.0}  # Start with 100% probability at the starting room\n        \n        for _ in range(battery):\n            new_dp = {}\n            for room, prob in dp.items():\n                neighbors = [r for r in range(1, max(start, battery_room, junk_room) + 1) if r != room and r != junk_room]\n                if neighbors:\n                    prob_share = prob / len(neighbors)\n                    for neighbor in neighbors:\n                        if neighbor not in new_dp:\n                            new_dp[neighbor] = 0.0\n                        new_dp[neighbor] += prob_share\n            \n            dp = new_dp\n            if battery_room in dp:\n                break\n\n        results.append(dp.get(battery_room, 0.0))\n    \n    return results\n\n# Example usage\ndatasets = [\n    (10, 1, 3, 2),\n    (5, 1, 3, 0),\n    (12, 2, 4, 0),\n    (0, 0, 0, 0)  # Termination dataset\n]\n\nfor result in robot_probability(datasets):\n    print(f\"{result:.6f}\")",
    "timestamp": "2025-08-13 01:32:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CleaningRobot {\n\n    static class Room {\n        int id;\n        List<Room> neighbors = new ArrayList<>();\n        boolean isJunk;\n\n        public Room(int id, boolean isJunk) {\n            this.id = id;\n            this.isJunk = isJunk;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true) {\n            int batteryPoints = sc.nextInt();\n            if (batteryPoints == 0) break;\n\n            int numRooms = sc.nextInt();\n            int startRoom = sc.nextInt();\n            int batteryRoom = sc.nextInt();\n            int junkRoom = sc.nextInt();\n\n            Map<Integer, Room> rooms = new HashMap<>();\n            for (int i = 1; i <= numRooms; i++) {\n                rooms.put(i, new Room(i, i == junkRoom));\n            }\n\n            for (int i = 1; i <= numRooms; i++) {\n                int numNeighbors = sc.nextInt();\n                for (int j = 0; j < numNeighbors; j++) {\n                    int neighborId = sc.nextInt();\n                    rooms.get(i).neighbors.add(rooms.get(neighborId));\n                }\n            }\n\n            double probability = computeProbability(rooms, startRoom, batteryRoom, batteryPoints);\n            System.out.printf(\"%.6f%n\", probability);\n        }\n\n        sc.close();\n    }\n\n    private static double computeProbability(Map<Integer, Room> rooms, int startRoom, int batteryRoom, int batteryPoints) {\n        Queue<int[]> queue = new LinkedList<>();\n        Map<Integer, Map<Integer, Double>> probabilities = new HashMap<>();\n        queue.offer(new int[]{startRoom, batteryPoints});\n        probabilities.computeIfAbsent(startRoom, k -> new HashMap<>()).put(batteryPoints, 1.0);\n\n        double result = 0.0;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int currentRoom = current[0];\n            int currentBattery = current[1];\n            double currentProbability = probabilities.get(currentRoom).get(currentBattery);\n\n            if (currentRoom == batteryRoom) {\n                result += currentProbability;\n                continue;\n            }\n\n            List<Room> nextRooms = rooms.get(currentRoom).neighbors;\n            if (nextRooms.isEmpty() || currentBattery == 0) continue;\n\n            double nextProbability = currentProbability / nextRooms.size();\n            for (Room nextRoom : nextRooms) {\n                if (nextRoom.isJunk) continue;\n                int nextBattery = currentBattery - 1;\n                if (nextBattery < 0) continue;\n\n                probabilities.computeIfAbsent(nextRoom.id, k -> new HashMap<>())\n                    .merge(nextBattery, nextProbability, Double::sum);\n                queue.offer(new int[]{nextRoom.id, nextBattery});\n            }\n        }\n\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 01:32:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_ROOMS 100\n#define MAX_BATTERY 100\n\ndouble dp[MAX_ROOMS][MAX_BATTERY];\n\nvoid initialize_dp(int rooms, int battery) {\n    for(int i = 0; i < rooms; ++i) {\n        for(int j = 0; j <= battery; ++j) {\n            dp[i][j] = -1;\n        }\n    }\n}\n\ndouble probability(int current_room, int battery_left, int total_rooms, int battery_room, int junk_room) {\n    if(battery_left < 0) return 0;\n    if(current_room == battery_room) return 1;\n    if(current_room == junk_room) return 0;\n    \n    if(dp[current_room][battery_left] != -1) return dp[current_room][battery_left];\n\n    // Simulating movement to each room except the current one\n    double prob = 0;\n    int valid_moves = 0;\n    for(int next_room = 0; next_room < total_rooms; ++next_room) {\n        if(next_room != current_room && next_room != junk_room) {\n            prob += probability(next_room, battery_left - 1, total_rooms, battery_room, junk_room);\n            valid_moves++;\n        }\n    }\n    return dp[current_room][battery_left] = valid_moves > 0 ? prob / valid_moves : 0;\n}\n\nint main() {\n    int battery_points, start_pos, battery_room, junk_room, rooms;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d\", &battery_points, &rooms, &start_pos, &battery_room, &junk_room);\n\n        if(battery_points == 0) break;\n\n        initialize_dp(rooms, battery_points);\n        \n        double result = probability(start_pos, battery_points, rooms, battery_room, junk_room);\n        printf(\"Probability: %.6f\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:32:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_robot_probability(battery_points, start_room, battery_room, junk_room, total_rooms):\n    def dfs(current_room, remaining_battery):\n        if current_room == junk_room:\n            return 0\n        \n        if remaining_battery == 0:\n            return 1 if current_room == battery_room else 0\n        \n        valid_moves = [r for r in range(1, total_rooms + 1) if r != junk_room]\n        prob_per_move = 1 / len(valid_moves)\n        \n        total_prob = 0\n        for next_room in valid_moves:\n            total_prob += prob_per_move * dfs(next_room, remaining_battery - 1)\n        \n        return total_prob\n\n    return dfs(start_room, battery_points)\n\ndef main():\n    while True:\n        battery_points = int(input())\n        \n        if battery_points == 0:\n            break\n        \n        start_room = int(input())\n        battery_room = int(input())\n        junk_room = int(input())\n        total_rooms = int(input())\n        \n        result = solve_robot_probability(battery_points, start_room, battery_room, junk_room, total_rooms)\n        print(f\"{result:.3f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 01:32:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        parts = line.strip().split()\n        if not parts:\n            continue\n        B = int(parts[0])\n        if B == 0:\n            break\n        N = int(parts[1])\n        M = int(parts[2])\n        S = int(parts[3])\n        battery_room = int(parts[4])\n        junk_room = int(parts[5])\n        \n        # Read adjacency list\n        adj = [[] for _ in range(N+1)]\n        for _ in range(M):\n            u, v = map(int, sys.stdin.readline().split())\n            adj[u].append(v)\n            adj[v].append(u)\n        \n        # Initialize DP table: dp[b][u] = probability\n        dp_prev = [[0.0] * (N+1) for _ in range(B+1)]\n        dp_prev[B][S] = 1.0\n        \n        for b in range(B, 0, -1):\n            dp_next = [[0.0] * (N+1) for _ in range(B+1)]\n            for u in range(1, N+1):\n                if u == battery_room or u == junk_room:\n                    continue\n                if dp_prev[b][u] == 0.0:\n                    continue\n                neighbors = []\n                for v in adj[u]:\n                    if v != junk_room:\n                        neighbors.append(v)\n                if not neighbors:\n                    continue\n                prob = dp_prev[b][u] / len(neighbors)\n                for v in neighbors:\n                    if b - 1 >= 0:\n                        dp_next[b-1][v] += prob\n            dp_prev = dp_next\n        \n        total_prob = 0.0\n        for b in range(B+1):\n            total_prob += dp_prev[b][battery_room]\n        \n        print(\"{0:.10f}\".format(total_prob))\n\nsolve()",
    "timestamp": "2025-08-13 01:32:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct State {\n    int room;\n    int battery;\n    double probability;\n};\n\nint main() {\n    int numRooms;\n    while (cin >> numRooms, numRooms != 0) {\n        vector<vector<int>> adj(numRooms);\n        int batteryPoints, start, batteryRoom, junkRoom;\n        cin >> batteryPoints >> start >> batteryRoom >> junkRoom;\n\n        for (int i = 0; i < numRooms; ++i) {\n            int to;\n            while (cin >> to, to != -1) {\n                adj[i].push_back(to);\n            }\n        }\n\n        vector<vector<double>> prob(numRooms, vector<double>(batteryPoints + 1, 0.0));\n        queue<State> q;\n\n        prob[start][batteryPoints] = 1.0;\n        q.push({start, batteryPoints, 1.0});\n\n        while (!q.empty()) {\n            State current = q.front();\n            q.pop();\n            \n            if (current.room == junkRoom || current.battery == 0) continue;\n\n            int transitions = adj[current.room].size();\n            double nextProb = current.probability / transitions;\n            \n            for (int nextRoom : adj[current.room]) {\n                int nextBattery = current.battery - 1;\n                if (nextRoom == junkRoom || nextBattery < 0) continue;\n                \n                if (nextRoom == batteryRoom) {\n                    prob[nextRoom][nextBattery] += nextProb;\n                } else {\n                    if (prob[nextRoom][nextBattery] == 0) {\n                        q.push({nextRoom, nextBattery, 0});\n                    }\n                    prob[nextRoom][nextBattery] += nextProb;\n                }\n            }\n        }\n\n        double result = 0.0;\n        for (int i = 0; i <= batteryPoints; ++i) {\n            result += prob[batteryRoom][i];\n        }\n\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:00:50"
  }
]