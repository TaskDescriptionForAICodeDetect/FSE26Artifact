[
  {
    "language": "Scala",
    "code": "//import java.util.Scanner\n\nimport java.io._\nimport java.nio.file.{Files, Path}\nimport java.util.StringTokenizer\n\nimport scala.collection.immutable._\nimport scala.io.Codec\n\n/**\n  * Scala implementation of a faster java.util.Scanner\n  * See: http://codeforces.com/blog/entry/7018\n  */\n\nclass Scanner(reader: LineNumberReader) extends Iterable[String] with AutoCloseable {\n  def this(reader: BufferedReader) = this(new LineNumberReader(reader))\n\n  def this(reader: Reader) = this(new BufferedReader(reader))\n\n  def this(inputStream: InputStream)(implicit codec: Codec) = this(new InputStreamReader(inputStream, codec.charSet))\n\n  def this(path: Path)(implicit codec: Codec) = this(Files.newBufferedReader(path, codec.charSet))\n\n  def this(file: File)(implicit codec: Codec) = this(file.toPath)(codec)\n\n  def this(str: String) = this(new StringReader(str))\n\n  override def iterator = for {\n    line <- Iterator.continually(reader.readLine()).takeWhile(_ != null)\n    tokenizer = new StringTokenizer(line)\n    tokens <- Iterator.continually(tokenizer).takeWhile(_.hasMoreTokens)\n  } yield tokens.nextToken()\n\n  private[this] var current = iterator\n\n  def hasNext = current.hasNext\n\n  @inline def next() = current.next()\n\n  /**\n    * This is different from Java's scanner.nextLine\n    * The Java one is a misnomer since it actually travel to end of current line\n    * This one actually does fetch the next line\n    */\n  def nextLine(): String = {\n    val line = reader.readLine()\n    current = iterator\n    line\n  }\n\n  def lineNumber: Int = reader.getLineNumber\n\n  def nextString(): String = next()\n\n  def nextBoolean(): Boolean = next().toBoolean\n\n  def nextByte(radix: Int = 10): Byte = java.lang.Byte.parseByte(next(), radix)\n\n  def nextShort(radix: Int = 10): Short = java.lang.Short.parseShort(next(), radix)\n\n  def nextInt(radix: Int = 10): Int = java.lang.Integer.parseInt(next(), radix)\n\n  def nextLong(radix: Int = 10): Long = java.lang.Long.parseLong(next(), radix)\n\n  def nextBigInt(radix: Int = 10): BigInt = BigInt(next(), radix)\n\n  def nextFloat(): Float = next().toFloat\n\n  def nextDouble(): Double = next().toDouble\n\n  def nextBigDecimal(): BigDecimal = BigDecimal(next())\n\n  override def close() = reader.close()\n}\n\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => {\n      nodes(t).parent = Some(root(p))\n      nodes(t).parent.get\n    }\n  }\n}\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    println(recursive(sc.nextLong(), 0, sc.nextLong(), 0))\n  }\n\n  def getPermutation(begin: Long = 0): Stream[Long] =\n    Stream.cons(begin, getPermutation(begin + 1))\n\n  def calc(N: Long, R: Long, M: Long): Double = {\n    math.sqrt(R * R - (R * 2 * ((M * 1.0 / N) - 0.5)) * (R * 2 * ((M * 1.0 / N) - 0.5))) * 2\n  }\n\n  def recursive(N1: Long, N2: Long, M1: Long, M2: Long): Long = {\n    if (N1 + N2 == 0 || M1 + M2 == 0) (-1) else (recursive(math.max(0, M1 - N1 - N2), math.max(0, M2 + M1 - math.max(0, M1 - N1 - N2) - math.max(0, (N1 + N2 - M1))), N1, N2) + 1)\n  }\n\n  def check(s: String): Boolean = {\n    if (s == \"0\") (true) else (s(0) != '0' && 0 <= s.toInt && s.toInt <= 255)\n  }\n\n  def shift(n: Long): Long = {\n    if (n == 0) (0) else if (n == 1) (1) else (shift(n - 1) << 1)\n  }\n\n  def unShift(n: Long): Long = {\n    if (n == 0) (0) else (unShift(n >> 1) + 1)\n  }\n\n  def gcd(i: Long, j: Long): Long = {\n    if (i < j) (gcd(j, i)) else (if (j == 0) (i) else (gcd(j, i % j)))\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n    solve(sc)\n  }\n}\n\nobject Util {\n  def getPermutation(begin: Long = 0): Stream[Long] =\n    Stream.cons(begin, getPermutation(begin + 1))\n\n  def getPrimeList(): Stream[Long] =\n    getPrimeListRecursive(getPermutation(begin = 2))\n\n  private def getPrimeListRecursive(A: Stream[Long]): Stream[Long] =\n    Stream.cons(A.head, getPrimeListRecursive(A.tail.filter(_ % A.head != 0)))\n\n  def fib(a: Long = 0, b: Long = 1, mod: Long = Long.MaxValue): Stream[Long] = a #:: fib(b % mod, (a + b) % mod, mod)\n}\n\nobject ArabicRoman {\n\n  type =?>[A, B] = PartialFunction[A, B]\n\n  val codeTable = List(\n    (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"),\n    (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\"))\n\n  val arabicToRoman: (Int) =?> String = {\n    case src if (src >= 1 && src <= 3999) => {\n\n      def convert(left: Int, cont: String = \"\", code: List[(Int, String)] = codeTable): String = {\n        val (unitVal, unitChar) = code.head\n        left - unitVal match {\n          case n if (n == 0) => cont + unitChar\n          case n if (n > 0) => convert(n, cont + unitChar, code)\n          case _ => convert(left, cont, code.tail)\n        }\n      }\n\n      convert(src)\n    }\n  }\n\n  val romanToArabic: (String) =?> Int = {\n    case src if (Option(src).exists { s => {\n      s.nonEmpty && (\"\"\"[^MDCLXVI]\"\"\".r.findFirstMatchIn(s.toUpperCase) == None)\n    }\n    }) => {\n\n      def convert(left: String, cont: Int = 0, code: List[(Int, String)] = codeTable): Int = {\n        val (unitVal, unitChar) = code.head\n        left.splitAt(unitChar.length) match {\n          case (\"\", _) => cont\n          case (`unitChar`, tail) => convert(tail, cont + unitVal, code)\n          case _ => convert(left, cont, code.tail)\n        }\n      }\n\n      convert(src.toUpperCase())\n    }\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n\n  val Array(uku, usi) = readLine.trim.split(' ').map(_.toLong)\n  println(math.min(killUkuFirst(uku, usi), killUsiFirst(uku, usi)))\n  def killUsiFirst(uku: Long, usi: Long): Int = {\n    val ukuT = new Team(uku)\n    val usiT = new Team(usi)\n    var count = 0\n    while (ukuT.isAlive && usiT.isAlive){\n      usiT.decrease(ukuT.maxVote)\n      if (usiT.isAlive){\n        ukuT.decrease(usiT.minVote)\n        count += 1\n        if (ukuT.isAlive) count += 1\n      }\n    }\n    count\n  }\n  def killUkuFirst(uku: Long, usi: Long): Int = {\n    val ukuT = new Team(uku)\n    val usiT = new Team(usi)\n    var count = 0\n    while (ukuT.isAlive && usiT.isAlive){\n      usiT.decrease(ukuT.minVote)\n      if (usiT.isAlive){\n        ukuT.decrease(usiT.maxVote)\n        count += 1\n        if (ukuT.isAlive) count += 1\n      }\n    }\n    count\n  }\n  class Team(private val start: Long) {\n    private var health: Long = start * 2\n    def decrease(vote: Long): Unit = {\n      health -= vote\n    }\n    def maxVote: Long = math.min(start, health)\n    def minVote: Long = (health + 1) / 2\n    def isAlive: Boolean = health > 0\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nlong long Nattack(long long n, long long m){\n\tlong long res = 0;\n\tlong long nd = 0, md = 0;\n\tbool beat = false;\n\twhile(true){\n\t\tm -= n / 2;\n\t\tif(n % 2 == 1){\n\t\t\tif(md == 1){\n\t\t\t\tmd = 0;\n\t\t\t\tm--;\n\t\t\t}else{\n\t\t\t\tmd++;\n\t\t\t}\n\t\t}\n\t\tif(m <= 0) break;\n\t\tres++;\n\n\t\tif(beat){\n\t\t\tn -= m;\n\t\t}else{\n\t\t\tnd += m;\n\t\t\tif(nd >= n){\n\t\t\t\tbeat = true;\n\t\t\t\tn -= nd - n;\n\t\t\t}\n\t\t}\n\n\t\tif(n <= 0) break;\n\t\tres++;\n\t}\n\treturn res;\n}\n\nlong long Mattack(long long n, long long m){\n\tlong long res = 0;\n\tlong long nd = 0, md = 0;\n\tbool beat = false;\n\twhile(true){\n\t\tif(beat){\n\t\t\tn -= m;\n\t\t}else{\n\t\t\tnd += m;\n\t\t\tif(nd >= n){\n\t\t\t\tbeat = true;\n\t\t\t\tn -= nd - n;\n\t\t\t}\n\t\t}\n\t\tif(n <= 0) break;\n\t\tres++;\n\n\t\tm -= n / 2;\n\t\tif(n % 2 == 1){\n\t\t\tif(md == 1){\n\t\t\t\tmd = 0;\n\t\t\t\tm--;\n\t\t\t}else{\n\t\t\t\tmd++;\n\t\t\t}\n\t\t}\n\t\tif(m <= 0) break;\n\t\tres++;\n\n\t}\n\treturn res;\n}\n\nint main(){\n\tlong long n, m;\n\tcin >> n >> m;\n\n\tcout << min(Nattack(n, m), Mattack(m, n)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"complex\"\n#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"complex\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tif (N >= 2 * M) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tif (2 * M > N&&N >= M) {\n\t\tcout << 2 << endl;\n\t\treturn 0;\n\t}\n\tif (M >= 2 * N) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tlong long int box = 0;\n\tlong long int bag = 0;\n\tbox += N;\n\tbag += M - (box / 2);\n\tbox += N - max((long long int)0, bag - N);\n\tint ans = 100;\n\tif (M*2 <= box) {\n\t\tans = min(ans,2);\n\t}\n\telse {\n\t\tbag += M - (box / 2);\n\t\tif (N*4 <= bag * 2) {\n\t\t\tans = min(ans, 3);\n\t\t}\n\t\telse {\n\t\t\tbox += N - max((long long int)0, bag - N);\n\t\t\tif (M*4 <= box * 2) {\n\t\t\t\tans = min(ans, 4);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbag += M - (box / 2);\n\t\t\t\tif (N*4 <= bag * 2) {\n\t\t\t\t\tans = min(ans, 5);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t}\n\t//cout << ans << endl;\n\tbox = 0;\n\tbag = 0;\n\tbox += N;\n\tbag += M - max((long long int)0, box - M);\n\tbox += N - (bag / 2);\n\tif (M*4 <= box * 2) {\n\t\tans = min(ans, 2);\n\t}\n\telse {\n\t\tbag += M - max((long long int)0, box - M);\n\t\tif (N*4 <= bag * 2) {\n\t\t\tans = min(ans, 3);\n\t\t}\n\t\telse {\n\t\t\tbox += N - (bag / 2);\n\t\t\tif (M*4 <= box * 2) {\n\t\t\t\tans = min(ans, 4);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbag += M - max((long long int)0, box - M);\n\t\t\t\tif (N*4 <= bag * 2) {\n\t\t\t\t\tans = min(ans, 5);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntypedef pair<ll,ll> P;\nsigned main(){\n    P a,b;\n    ll n,m;\n    cin>>n>>m;\n    a.first=n,a.second=n*2;\n    b.first=m,b.second=m*2;\n    ll cnt1=0,cnt2=0;\n    ll atk;\n    \n    while(1){\n        atk=min(n,a.second);\n        b.second-=atk;\n        if(b.second<=0) break;\n        cnt1++;\n        \n        \n        atk=min(m,b.second/2+b.second%2);\n        a.second-=atk;\n        if(a.second<=0) break;\n        cnt1++;\n        \n    }\n    \n    a.first=n,a.second=n*2;\n    b.first=m,b.second=m*2;\n    \n    while(1){\n        atk=min(n,a.second/2+a.second%2);\n        b.second-=atk;\n        if(b.second<=0) break;\n        cnt2++;\n        \n        \n        atk=min(m,b.second);\n        a.second-=atk;\n        if(a.second<=0) break;\n        cnt2++;\n        \n    }\n    ll ans=min(cnt1,cnt2);\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll solve(){\n    ll res = LINF;\n    ll N,M; cin >> N >> M;\n    {\n        ll num = 0;\n        ll uku = 2*N,ei = 2*M;\n        ll uku_dame = 0,ei_dame = 0;\n        while(true){\n            if(num%2 == 0){\n                ll uku_num = (uku-uku_dame)/2;\n                ei_dame+=uku_num;\n            }else{\n                ll ei_num = min(M,ei-ei_dame);\n                uku_dame+=ei_num;\n            }\n            if(uku-uku_dame<=0) break;\n            if(ei-ei_dame<=0) break;\n            num++;\n        }\n        res = min(res,num);\n    }\n    {\n        ll num = 0;\n        ll uku = 2*N,ei = 2*M;\n        ll uku_dame = 0,ei_dame = 0;\n        while(true){\n            if(num%2 == 0){\n                ll uku_num = min(N,uku-uku_dame);\n                ei_dame+=uku_num;\n            }else{\n                ll ei_num = (ei-ei_dame)/2;\n                uku_dame+=ei_num;\n            }\n            if(uku-uku_dame<=0) break;\n            if(ei-ei_dame<=0) break;\n            num++;\n        }\n        res = min(res,num);\n        \n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll find1(ll n, ll m) {\n\tll N = n;\n\tn *= 2, m *= 2;\n\tll res = 0;\n\twhile (true) {\n\t\tm -= min(N, n);\n\t\tif (m <= 0) break;\n\t\t++res;\n\t\tn -= (m + 1) / 2;\n\t\tif (n <= 0) break;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nll find2(ll n, ll m) {\n\tll M = m;\n\tn *= 2, m *= 2;\n\tll res = 0;\n\twhile (true) {\n\t\tm -= (n + 1) / 2;\n\t\tif (m <= 0) break;\n\t\t++res;\n\t\tn -= min(M, m);\n\t\tif (n <= 0) break;\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tll N, M;\n\tcin >> N >> M;\n\tcout << min(find1(N, M), find2(N, M)) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:https://onlinejudge.u-aizu.ac.jp/services/room.html#ACPC2018Day2/problems/B>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n \n ukuが優先的にダメージを与えることができる場合と\n 牛が優先的にダメージを与えることができる場合をそれぞれ考える\n\n ================================================================\n */\n\nll solve(){\n    ll res = LINF;\n    ll N,M; cin >> N >> M;\n    {\n        ll num = 0;\n        ll uku = 2*N,ei = 2*M;\n        ll uku_dame = 0,ei_dame = 0;\n        while(true){\n            if(num%2 == 0){\n                ll uku_num = (uku-uku_dame)/2;\n                ei_dame+=uku_num;\n            }else{\n                ll ei_num = min(M,ei-ei_dame);\n                uku_dame+=ei_num;\n            }\n            if(uku-uku_dame<=0) break;\n            if(ei-ei_dame<=0) break;\n            num++;\n        }\n        res = min(res,num);\n    }\n    {\n        ll num = 0;\n        ll uku = 2*N,ei = 2*M;\n        ll uku_dame = 0,ei_dame = 0;\n        while(true){\n            if(num%2 == 0){\n                ll uku_num = min(N,uku-uku_dame);\n                ei_dame+=uku_num;\n            }else{\n                ll ei_num = (ei-ei_dame)/2;\n                uku_dame+=ei_num;\n            }\n            if(uku-uku_dame<=0) break;\n            if(ei-ei_dame<=0) break;\n            num++;\n        }\n        res = min(res,num);\n\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n\nint f(int n2, int n1, int m2, int m1,bool flag){\n//    cout<<n2<<\" \"<<n1<<\" \"<<m2<<\" \"<<m1<<endl;\n    if( (2*m2+m1)-(n2+n1)<=0 )return 0;\n    \n    if(flag){\n        int atkm2 = min(m2,(n2+n1));\n        m2 = max<ll>(0,m2-(n2+n1));\n        m1 += atkm2;\n        m1 = m1-(n2+n1-atkm2);\n        assert(m1>0);\n        return f(m2,m1,n2,n1,!flag)+1;\n    }else{\n        int atkm1 = min(m1,(n2+n1));\n        m1 = max<ll>(0,m1-(n2+n1));\n        int less = n2+n1-atkm1;\n        m2 -= less/2;\n        m2 -=less%2;\n        m1 += less%2;\n        assert(m1+m2>0);\n        return f(m2,m1,n2,n1,!flag)+1;\n    }\n}\n\n\n//int f(int n, int nd, int m, int md){\n//    //    cout<<nd<<\" \"<<md<<endl;\n//    int ndd = md-min(nd,n);\n//    int mdd = nd;\n//    if(ndd>0)return f(m,ndd,n,mdd)+1;\n//    else return 0;\n//}\n\n\nsigned main(){\n    int n,m;\n    cin>>n>>m;\n    cout<<min(f(n,0,m,0,0),f(n,0,m,0,1))<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint main(){\n    ll n,m;\n    cin >> n >> m;\n    ll p,q;\n    p = n*2;\n    q = m*2;\n    ll cnt = 0;\n    while(1){\n        ll x = min(p,n);\n        q -= x;\n        if(p<=0||q<=0){\n            break;\n        }\n        cnt++;\n        ll y = (q+1)/2;\n        p -= y;\n        if(p<=0||q<=0){\n            break;\n        }\n        cnt++;\n    }\n    ll ans = 0;\n    p = n*2;\n    q = m*2;\n    while(1){\n        ll x = (p+1)/2;\n        q -= x;\n        if(p<=0||q<=0){\n            break;\n        }\n        ans++;\n        ll y = min(q,m);\n        p -= y;\n        if(p<=0||q<=0){\n            break;\n        }\n        ans++;\n    }\n    cout << min(ans,cnt) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint cal(int a,int b,int t,int A){\n\tfor(int i=0 ; i<114514 ; i+=2){\n\n\t\tb -= min( A , a );\n\t\ta -= b/2 + b%2 ;\n\n\t\tif( b<1 )return i+t ;\n\t}\n\treturn 1e17;\n}\nsigned main(){\n\tint a,b;\n\tcin>> a >> b ;\n\tcout<< min( cal(a*2,b*2,0,a) , cal(b*2-a,a*2,1,b) ) <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  long long N, M;\n  cin >> N >> M;\n  long long N_ = N, M_ = M;\n  //  if(N > 2*M || M > 2*N){\n  //cout << 0 << endl;\n  //return 0;\n  //}\n  int ans = 0;\n  long long n = 2*N, m = 2*M;\n  while(n > 0 && m > 0){\n    m -= N;\n    if(m <= 0) break;\n    ++ans;\n    M = min(m,M);\n    n -= M;\n    if(n <= 0) break;\n    ++ans;\n    N = (n+1)/2;\n  }\n  int ans2 = 0;\n  N = N_;\n  M = M_;\n  n = 2*N;\n  m = 2*M;\n  while(n > 0 && m > 0){\n    m -= N;\n    if(m <= 0) break;\n    ++ans2;\n    M = (m+1)/2;\n    n -= M;\n    if(n <= 0) break;\n    ++ans2;\n    N = min(n,N);\n  }\n  cout << min(ans,ans2) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nstruct State {\n\tint ones;\n\tint twos;\n};\nbool att(State &A, State &B, int type) {\n\tif (type == 0) {\n\t\tint num = A.ones + A.twos;\n\t\tint k = min(B.ones, num);\n\t\tB.ones -= k;\n\t\tnum -= k;\n\t\tif (num > 0) {\n\t\t\tB.twos -= num / 2;\n\t\t\tnum -= (num / 2) * 2;\n\t\t\tif (num == 1) {\n\t\t\t\tB.twos--;\n\t\t\t\tB.ones++;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t\tif (B.twos < 0) {\n\t\t\t\tB.twos = 0;\n\t\t\t\tB.ones = 0;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint num = A.ones + A.twos;\n\t\tint k = min(B.twos, num);\n\t\tB.twos -= k;\n\t\tB.ones += k;\n\t\tnum -= k;\n\t\tk = min(B.ones, num);\n\t\tB.ones -= k;\n\t\tnum -= k;\n\n\t}\n\treturn (B.ones + B.twos <= 0);\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M;\n\tcin >> N >> M;\n\tState A;\n\tA.twos = N;\n\tA.ones = 0;\n\tState B;\n\tB.twos = M;\n\tB.ones = 0;\n\tint ans = 0;\n\twhile (true) {\n\t\tif (!att(A, B, 0)) {\n\t\t\tans++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\t//cerr << A.twos << \" \" << A.ones << \" \" << B.twos << \" \" << B.ones << endl;\n\t\tif (!att(B, A, 1)) {\n\t\t\tans++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\t//cerr << A.twos << \" \" << A.ones << \" \" << B.twos << \" \" << B.ones << endl;\n\t}\n\t//cerr << ans << endl;\n\tint res = ans;\n\tA.twos = N;\n\tA.ones = 0;\n\tB.twos = M;\n\tB.ones = 0;\n\tans = 0;\n\twhile (true) {\n\t\tif (!att(A, B, 1)) {\n\t\t\tans++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\tif (!att(B, A, 0)) {\n\t\t\tans++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cerr << ans << endl;\n\tres = min(res, ans);\n\n\t//if (N >= 2 * M) {\n\t//\tres = 0;\n\t//}\n\t//else if (N >= M) {\n\t//\tres = 2;\n\t//}\n\t//else if (N * 2 <= M) {\n\t//\tres = 1;\n\t//}\n\t//else if (N < M) {\n\t//\tint res = 0;\n\n\t//}\n\t//else {\n\n\t//}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int2(a, b);\n\n    int c = a * 2, d = b * 2;\n    int cnt = 0;\n    while (1) {\n        if (cnt % 2 == 0) {\n            // sente UKU\n            d -= min(a, c);\n        } else {\n            c -= (d / 2) + (d % 2);\n        }\n        if (c > 0 && d > 0) \n            cnt++;\n        else \n            break;\n    }\n\n    int ans = 0;\n    c = a * 2; d = b * 2;\n    while (1) {\n        if (ans % 2 == 0) {\n            // sente UKU\n            d -= (c / 2) + (c % 2);\n        } else {\n            c -= min(b, d);\n        }\n        if (c > 0 && d > 0) \n            ans++;\n        else \n            break;\n    }\n\n    std::cout << min(ans, cnt) << std::endl;\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <array>\n\nusing namespace std;\nusing ll = long long;\n\nll solve(ll a, ll b, ll a1, ll b1, ll ans){\n  //cout<<a<<\" \"<<b <<\" \"<<a1 << \" \"<< b1<<\" \"<<ans<<endl;\n  if(a >= b * 2) return ans;\n  if(a<=0 || b<=0)return ans-1;\n  else {\n    if(ans%2==1){//殺す\n      ll b2 = a-b1;//HP1を殺したあと余っている攻撃数\n      if(b2>=0){\n        //b1を殺しきった後さらに抹殺する\n        //if(b2%2==0)return solve(b-b2/2, a, 0, a1, ans+1);\n        return solve(b-b2/2-b1, a, b2%2, a1, ans+1);//余ったので一人b1に\n      }\n      else return solve(b-a, a, -b2, a1, ans+1);//b1が大量にいたのでとりあえずa人殺す\n    }else {//殺さない世界\n      ll b2 = b-b1;//HP2の人の数\n      //HP2の人から攻撃していく\n      if(b2-a>=0)return solve(b, a, b1+a, a1, ans+1);//誰も殺さずb1が増える\n      else return solve(b-(a-b2), a, b -(a-b2), a1, ans+1);//b1殺す数最小\n    }\n  }\n}\n\n\nint main(){\n  ll n,m;\n  cin>>n>>m;\n  //cout<<solve(n,m,0, 0, 0)<<\" \"<<solve(n,m,0, 0,1)-1<<endl;\n\n  cout<<min(solve(n,m,0, 0, 0),solve(n,m,0, 0,1)-1)<<endl;//*/\n\n  /*for(int i=1;i<1000;++i){\n    for(int j=1;j<1000;++j){\n      cout<<\"n=\"<<i<<\" ,m=\"<<j<<\" \"<<solve(i,j,0,0,0)<<\" \"<<solve(i,j,0,0,1)-1<<endl;\n\n    }\n  }//*/\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 10000000\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nusing namespace std;\nint main()\n{\n\tlong long n, m;\n\tcin >> n >> m;\n\tif (n == m)\n\t{\n\t\tcout << 2 << endl;\n\t\treturn 0;\n\t}\n\tlong long n1 = 0, n2 = n, m1 = 0, m2 = m;\n\tint cnt1 = 0;\n\twhile (1)\n\t{\n\t\tlong long tmp = min(n1 + n2, m2);\n\t\tm2 -= tmp;\n\t\tm1 += tmp;\n\t\tlong long r = (n1 + n2) - tmp;\n\t\tm1 -= r;\n\t\tif (m1 <= 0 && m2 <= 0)\n\t\t\tbreak;\n\t\tcnt1++;\n\t\tlong long sum = m1 + m2;\n\t\tif (n1 > 0)\n\t\t{\n\t\t\tn1--;\n\t\t\tsum--;\n\t\t}\n\t\tn2 -= sum / 2;\n\t\tif (sum % 2 != 0 && n2 > 0)\n\t\t{\n\t\t\tn1++;\n\t\t\tn2--;\n\t\t}\n\t\tif (n1 <= 0 && n2 <= 0)\n\t\t\tbreak;\n\t\tcnt1++;\n\t}\n\tint cnt2 = 0;\n\tn1 = 0;\n\tn2 = m;\n\tm1 = 0;\n\tm2 = n;\n\twhile (1)\n\t{\n\t\tlong long sum = m1 + m2;\n\t\tif (n1 > 0)\n\t\t{\n\t\t\tn1--;\n\t\t\tsum--;\n\t\t}\n\t\tn2 -= sum / 2;\n\t\tif (sum % 2 != 0 && n2 > 0)\n\t\t{\n\t\t\tn1++;\n\t\t\tn2--;\n\t\t}\n\t\t//cout << n1 << \" \" << n2 << \" \" << m1 << \" \" << m2 << endl;;\n\t\tif (n1 <= 0 && n2 <= 0)\n\t\t\tbreak;\n\t\tcnt2++;\n\t\tlong long tmp = min(n1 + n2, m2);\n\t\tm2 -= tmp;\n\t\tm1 += tmp;\n\t\tlong long r = (n1 + n2) - tmp;\n\t\tm1 -= r;\n\t\t//cout << n1 << \" \" << n2 << \" \" << m1 << \" \" << m2 << endl;\n\t\tif (m1 <= 0 && m2 <= 0)\n\t\t\tbreak;\n\t\tcnt2++;\n\t}\n\t//cout << cnt1 << \" \" << cnt2 << endl;\n\tint ans = min(cnt1, cnt2);\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tllint n,m,ans;cin>>n>>m;\n\tif(n>=2*m){ans=0;}\n\telse if(2*n<=m){ans=1;}\n\telse if(n>=m){ans=2;}\n\telse if(2*n<=3*m-2*n+m/2){ans=3;}\n\telse{ans=4;}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n \nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n \n    int2(a, b);\n \n    int c = a * 2, d = b * 2;\n    int cnt = 0;\n    while (1) {\n        if (cnt % 2 == 0) {\n            // sente UKU\n            d -= min(a, c);\n        } else {\n            c -= (d / 2) + (d % 2);\n        }\n        if (c > 0 && d > 0) \n            cnt++;\n        else\n            break;\n    }\n \n    int ans = 0;\n    c = a * 2; d = b * 2;\n    while (1) {\n        if (ans % 2 == 0) {\n            // sente UKU\n            d -= (c / 2) + (c % 2);\n        } else {\n            c -= min(b, d);\n        }\n        if (c > 0 && d > 0) \n            ans++;\n        else\n            break;\n    }\n \n    std::cout << min(ans, cnt) << std::endl;\n \n \n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P,P> PP;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nll ans = IINF;\n\nvoid rec(ll x2, ll x1, ll y2, ll y1, ll cnt){\n    if(cnt > ans)return;\n    if(x2+x1 >= y2*2+y1){\n        ans = min(ans, cnt);\n        return;\n    }\n    ll x = x2+x1;\n    rec(y2-max(0LL,x-y1+1)/2,max(0LL,y1-x)+max(0LL,x-y1)%2,x2,x1,cnt+1); // 体力1を優先的に倒す\n    rec(max(0LL,y2-x),y1+min(x,y2)-max(0LL,x-y2),x2,x1,cnt+1);  // 体力2を優先的に倒す\n}\n\nint main() {\n    ll n, m;\n    cin >> n >> m;\n    rec(n,0,m,0,0);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& w:r)std::cin>>w;\n\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint calc(int a, int b, int c, int d, int e) {\n\tif (e) {\n\t\tint x = a + b;\n\t\tif (d && x) --d, --x;\n\t\tc -= x / 2;\n\t\tx %= 2;\n\t\tif (c < 0) x += -c * 2, c = 0;\n\t\tif (x) {\n\t\t\tif (d) d -= x;\n\t\t\telse if(c) --c, ++d, --x;\n\t\t}\n\t}\n\telse {\n\t\tint x = a + b;\n\t\tif (c) {\n\t\t\tif (c <= x) {\n\t\t\t\tx -= c;\n\t\t\t\td += c;\n\t\t\t\tc = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\td += x;\n\t\t\t\tc -= x;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}\n\t\td -= x;\n\t}\n\tif (c <= 0 && d <= 0) return 0;\n\treturn 1 + calc(c, d, a, b, 1 - e);\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tint ans = INFINT;\n\tREP(i, 2) CHMIN(ans, calc(n, 0, m, 0, i));\n\tOUT(ans)BR;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nbool tacticX(ll n,ll &b1,ll &b2){\n  if(b1+b2*2<=n) return true;\n\n  ll tmp=min(b1,n);\n  b1-=tmp;\n  n-=tmp;\n  tmp=min(b2,n/2);\n  b2-=tmp;\n  n-=tmp*2;\n  if(n){\n    b2--;\n    b1++;\n    n--;\n  }\n  return false;\n}\n\nbool tacticY(ll n,ll &b1,ll &b2){\n  if(b1+b2*2<=n) return true;\n  ll tmp=min(n,b2);\n  b2-=tmp;\n  b1+=tmp;\n  n-=tmp;\n  tmp=min(n,b1);\n  b1-=tmp;\n  n-=tmp;\n  return false;\n}\n\n\nint main(){\n  ll n,m;\n  cin>>n>>m;\n  ll sc0=0;\n  {\n    ll a2=n,a1=0;\n    ll b2=m,b1=0;\n      while(true){\n\tif(tacticX(a2+a1,b1,b2)) break;\n\tsc0++;\n\tif(tacticY(b1+b2,a1,a2)) break;\n\tsc0++;\n      }\n  }\n  \n  ll sc1=0;\n  {\n    ll a2=n,a1=0;\n    ll b2=m,b1=0;\n      while(true){\n\tif(tacticY(a2+a1,b1,b2)) break;\n\tsc1++;\n\tif(tacticX(b1+b2,a1,a2)) break;\n\tsc1++;\n      }\n  }\n  cout<<min(sc0,sc1)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint foo(long long n, long long m, long long X){\n  long long at = 0, a0 = n, a1 = n, b0 = m, b1 = m, a2 = 0, b2 = 0, time=0, temp;\n \n  while(1){\n    if(time%2==X){\n      at = a0;\n      temp = min(b2,at);\n      b2 -= temp; at -= temp;\n      temp = min(b1, at/2);\n      b1 -= temp; at -= temp*2;\n      if(at){\n\tif(b2)b2--;\n\telse if(b1)b1--,b2++;\n      }\n    }else{\n       at = b0;\n       temp = min(a1,at);\n       a1 -= temp; a2 += temp; at -= temp;\n       temp = min(a2, at);\n       a2 -= temp; at -= temp;\n    }\n    a0 = a1+a2;\n    b0 = b1+b2;\n    \n\n    if(!a0||!b0)break;\n    time++;\n  }\n  //cout<<time<<endl;\n  return time;\n}\n\nint main(){\n  long long n, m;\n  cin>>n>>m;\n  cout<<min(foo(n,m,0), foo(m,n,1))<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 10000000\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nusing namespace std;\nint main()\n{\n\tlong long n, m;\n\tcin >> n >> m;\n\tif (n == m)\n\t{\n\t\tcout << 2 << endl;\n\t\treturn 0;\n\t}\n\tlong long n1 = 0, n2 = n, m1 = 0, m2 = m;\n\tint cnt1 = 0;\n\twhile (1)\n\t{\n\t\tlong long tmp = min(n1 + n2, m2);\n\t\tm2 -= tmp;\n\t\tm1 += tmp;\n\t\tlong long r = (n1 + n2) - tmp;\n\t\tm1 -= r;\n\t\tif (m1 <= 0 && m2 <= 0)\n\t\t\tbreak;\n\t\tcnt1++;\n\t\tlong long sum = m1 + m2;\n\t\tif (n1 > 0)\n\t\t{\n\t\t\tn1--;\n\t\t\tsum--;\n\t\t}\n\t\tn2 -= sum / 2;\n\t\tif (sum % 2 != 0 && n2 > 0)\n\t\t{\n\t\t\tn1++;\n\t\t\tn2--;\n\t\t}\n\t\tif (n1 <= 0 && n2 <= 0)\n\t\t\tbreak;\n\t\tcnt1++;\n\t}\n\tint cnt2 = 0;\n\tn1 = 0;\n\tn2 = m;\n\tm1 = 0;\n\tm2 = n;\n\twhile (1)\n\t{\n\t\tlong long sum = m1 + m2;\n\t\tif (n1 > 0)\n\t\t{\n\t\t\tn1--;\n\t\t\tsum--;\n\t\t}\n\t\tn2 -= sum / 2;\n\t\tif (sum % 2 != 0 && n2 > 0)\n\t\t{\n\t\t\tn1++;\n\t\t\tn2--;\n\t\t}\n\t\t//cout << n1 << \" \" << n2 << \" \" << m1 << \" \" << m2 << endl;;\n\t\tif (n1 <= 0 && n2 <= 0)\n\t\t\tbreak;\n\t\tcnt2++;\n\t\tlong long tmp = min(n1 + n2, m2);\n\t\tm2 -= tmp;\n\t\tm1 += tmp;\n\t\tlong long r = (n1 + n2) - tmp;\n\t\tm1 -= r;\n\t\t//cout << n1 << \" \" << n2 << \" \" << m1 << \" \" << m2 << endl;\n\t\tif (m1 <= 0 && m2 <= 0)\n\t\t\tbreak;\n\t\tcnt2++;\n\t}\n\t//cout << cnt1 << \" \" << cnt2 << endl;\n\tint ans = min(cnt1, cnt2);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tlong long n, m;\n\tcin >> n >> m;\n\n\tif (2*m <= n) {\n\t\tcout << 0 << endl;\n\t}\n\telse if (2*n <= m) {\n\t\tcout << 1 << endl;\n\t}\n\telse if (m <= n) {\n\t\tcout << 2 << endl;\n\t}\n\telse if (2 * n <= m + m - ((n + n - m / 2) - m)) {\n\t\tcout << 3 << endl;\n\t}\n\telse {\n\t\tcout << 4 << endl;\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst long long INF = 1LL << 60;    // 1.15x10^18\nusing ll = long long;\n\nll ans = INF;\nvoid rec(ll x2, ll x1, ll y2, ll y1, ll cnt) {\n    if (cnt > ans) return ;\n    ll all = x2 + x1;\n    if (y2 * 2 + y1 <= all) return void(ans = min(ans, cnt));\n    rec(\n        max(0LL, y2 - all),\n        y1 + min(all, y2) - max(0LL, all - y2),\n        x2, x1, cnt + 1\n    );\n    rec(\n        y2 - max(0LL, all - y1 + 1) / 2,\n        max(0LL, y1 - all) + max(0LL, all - y1) % 2,\n        x2, x1, cnt + 1\n    );\n}\n\nint main() {\n    ll n, m; cin >> n >> m;\n    rec(n, 0, m, 0, 0);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint solve(ll n, ll m, int u){\n  ll num[2][2] = {{n,0},{m,0}};\n  int f = 0;\n  int res = 0;\n\n  while(1){\n    ll attack = num[f][0] + num[f][1];\n    //debug(attack);\n    \n    if(u == f){\n      ll q = min(attack, num[!f][0]);\n      num[!f][0] -= q;\n      attack -= q;\n      num[!f][1] += q;\n      q = min(attack, num[!f][1]);\n      num[!f][1] -= q;\n    }else{\n      ll q = min(attack, num[!f][1]);\n      num[!f][1] -= q;\n      attack -= q;\n      q = min(attack/2, num[!f][0]);\n      num[!f][0] -= q;\n      attack -= q * 2;\n      if(attack && num[!f][0]){\n        num[!f][1]++; num[!f][0]--;\n      }\n    }\n\n    if(num[0][0] + num[0][1] <= 0 || num[1][0] + num[1][1] <= 0) break;\n    res++;\n    f = !f;\n  }\n  \n  return res;\n}\n\nint main(){\n  ll n, m;\n\n  scanf(\"%lld%lld\", &n, &m);\n\n  cout << min(solve(n,m,0), solve(n,m,1)) << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tll num_1,num_2;\n};\n\nInfo delete_max(ll attack_num,ll num_1,ll num_2){\n\n\tInfo ret;\n\n\tif(attack_num <= num_1){\n\n\t\tnum_1 -= attack_num;\n\t\tret.num_1 = num_1;\n\t\tret.num_2 = num_2;\n\n\t}else{\n\n\t\tret.num_1 = 0;\n\t\tattack_num -= num_1;\n\n\t\tif(attack_num/2 >= num_2){\n\n\t\t\tret.num_2 = 0;\n\t\t}else{\n\n\t\t\tret.num_2 = num_2 - attack_num/2;\n\t\t\tif(attack_num%2 == 1){\n\t\t\t\tret.num_1 += 1;\n\t\t\t\tret.num_2 -= 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nInfo delete_min(ll attack_num,ll num_1,ll num_2){\n\n\tInfo ret;\n\n\tif(attack_num < num_2){\n\n\t\tnum_1 += attack_num;\n\t\tnum_2 -= attack_num;\n\t\tret.num_2 = num_2;\n\t\tret.num_1 = num_1;\n\n\t}else{\n\n\t\tnum_1 += num_2;\n\t\tattack_num -= num_2;\n\t\tnum_2 = 0;\n\n\t\tnum_1 -= attack_num;\n\t\tif(num_1 < 0){\n\t\t\tnum_1 = 0;\n\t\t}\n\t\tret.num_1 = num_1;\n\t\tret.num_2 = 0;\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tll A,B;\n\tscanf(\"%lld %lld\",&A,&B);\n\n\tll ans_1 = 0;\n\tInfo tmp_A,tmp_B;\n\n\ttmp_A.num_1 = 0;\n\ttmp_A.num_2 = A;\n\n\ttmp_B.num_1 = 0;\n\ttmp_B.num_2 = B;\n\n\twhile(true){\n\n\t\ttmp_B = delete_max(tmp_A.num_1+tmp_A.num_2,tmp_B.num_1,tmp_B.num_2);\n\n\t\tif(tmp_B.num_1 == 0 && tmp_B.num_2 == 0){\n\t\t\tbreak;\n\t\t}\n\t\tans_1++;\n\n\t\ttmp_A = delete_min(tmp_B.num_1+tmp_B.num_2,tmp_A.num_1,tmp_A.num_2);\n\n\t\tif(tmp_A.num_1 == 0 && tmp_A.num_2 == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tans_1++;\n\t}\n\n\n\tll ans_2 = 0;\n\n\ttmp_A.num_1 = 0;\n\ttmp_A.num_2 = A;\n\n\ttmp_B.num_1 = 0;\n\ttmp_B.num_2 = B;\n\n\twhile(true){\n\n\t\ttmp_B = delete_min(tmp_A.num_1+tmp_A.num_2,tmp_B.num_1,tmp_B.num_2);\n\n\t\tif(tmp_B.num_1 == 0 && tmp_B.num_2 == 0){\n\t\t\tbreak;\n\t\t}\n\t\tans_2++;\n\n\t\ttmp_A = delete_max(tmp_B.num_1+tmp_B.num_2,tmp_A.num_1,tmp_A.num_2);\n\n\t\tif(tmp_A.num_1 == 0 && tmp_A.num_2 == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tans_2++;\n\t}\n\n\tprintf(\"%lld\\n\",min(ans_1,ans_2));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nll N, M;\n//---------------------------------------------------------------------------------------------------\npair<ll, ll> taosu(ll n, ll m1, ll m2) {\n    ll c1 = min(n, m1);\n    m1 -= c1;\n    n -= c1;\n\n    ll c2 = min(n / 2, m2);\n    m2 -= c2;\n    n -= c2 * 2;\n\n    ll c21 = min(m2, n);\n\n    m2 -= c21;\n    m1 += c21;\n\n    return { m1, m2 };\n}\n//---------------------------------------------------------------------------------------------------\npair<ll, ll> nokosu(ll n, ll m1, ll m2) {\n    ll c2 = min(m2, n);\n\n    n -= c2;\n    m2 -= c2;\n    m1 += c2;\n\n    ll c1 = min(n, m1);\n\n    n -= c1;\n    m1 -= c1;\n\n    return { m1, m2 };\n}\n//---------------------------------------------------------------------------------------------------\nll solve1() { // ukuが勝つ\n    ll n2 = N, n1 = 0;\n    ll m2 = M, m1 = 0;\n\n    ll res = 0;\n    while (0 < n2 + n1 and 0 < m2 + m1) {\n        tie(m1, m2) = taosu(n1 + n2, m1, m2);\n        if (m1 + m2 == 0) return res;\n\n        res++;\n\n        tie(n1, n2) = nokosu(m1 + m2, n1, n2);\n        if (n1 + n2 == 0) return res;\n\n        res++;\n    }\n}\n//---------------------------------------------------------------------------------------------------\nll solve2() { // うしが勝つ\n    ll n2 = N, n1 = 0;\n    ll m2 = M, m1 = 0;\n\n    ll res = 0;\n    while (0 < n2 + n1 and 0 < m2 + m1) {\n        tie(m1, m2) = nokosu(n1 + n2, m1, m2);\n        if (m1 + m2 == 0) return res;\n\n        res++;\n\n        tie(n1, n2) = taosu(m1 + m2, n1, n2);\n        if (n1 + n2 == 0) return res;\n\n        res++;\n    }\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n    ll ans = infl;\n    chmin(ans, solve1());\n    chmin(ans, solve2());\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nll a2, a1, b2, b1;\n\nvoid step1(){\n  // 相手をできるだけ減らさない\n  ll pls = a2 + a1;\n  ll sb = min(b2, pls);\n  pls -= sb;\n  b2 -= sb;\n  b1 += sb;\n  sb = min(b1, pls);\n  pls -= sb;\n  b1 -= sb;\n  swap(a1,b1);swap(a2,b2);\n}\nvoid step2(){\n  // 相手をできるだけ減らす\n  ll pls = a2 + a1;\n  if(pls>0 && b1>0){\n    b1--;pls--;\n  }\n  ll sb = min(b2, pls/2);\n  pls -= sb*2;\n  b2 -= sb;\n  if(pls>0 && b2>0){\n    pls--;\n    b2--;\n    b1++;\n  }\n  swap(a1,b1);swap(a2,b2);\n}\n\nint main(){\n  ll n,m;\n  cin>>n>>m;\n  ll ans = max(n,m)*2ll;\n  {\n    a2=n,a1=0,b2=m,b1=0;\n    ll tmp = 0;\n    while(true){\n      step1();\n      if(a1+a2==0)break;\n      tmp++;\n      step2();\n      if(a1+a2==0)break;\n      tmp++;\n    }\n    ans = min(ans,tmp);\n  }\n  {\n    a2=n,a1=0,b2=m,b1=0;\n    ll tmp = 0;\n    while(true){\n      step2();\n      if(a1+a2==0)break;\n      tmp++;\n      step1();\n      if(a1+a2==0)break;\n      tmp++;\n    }\n    ans = min(ans,tmp);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n, m;\nlong long data[2][2] = {0};\n\nlong long solve(int x);\n\nint main() {\n  cin >> n >> m;\n  cout << min(solve(0), solve(1)) << endl;\n  return 0;\n}\n\nlong long solve(int x) {\n  long long o = 0, d = 1, cnt = 0, bf;\n  data[0][0] = n;\n  data[1][0] = m;\n  data[0][1] = 0;\n  data[1][1] = 0;\n  while(data[0][0] > 0 && data[1][0] > 0) {\n    data[d][1] += data[o][0];\n    if((o + x) % 2) {\n      if(data[d][0] < data[d][1]) {\n        bf = data[d][1] - data[d][0];\n        data[d][0] -= bf;\n        data[d][1] = data[d][0];\n      }\n    }\n    else {\n      data[d][0] -= data[d][1] / 2;\n      data[d][1] %= 2;\n    }\n    if(data[0][0] <= 0 || data[1][0] <= 0) break;\n    swap(o, d);\n    ++cnt;\n  }\n  return cnt;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Team{\n    ll size,hp;\n    bool pr;\n    ll rem(){\n        if(pr) return (hp+1)/2;\n        return (size <= hp) ? size : hp;\n    }\n};\n\n\nint solve(ll n, ll m, int pr){\n    Team t[2] = {{n,n*2LL,false},{m,m*2LL,false}};\n    t[pr].pr = true;\n    int turn = 0, cnt = 0;\n    while(true){\n        ll attack = t[turn].rem();\n        t[(turn+1)%2].hp -= attack;\n        if(t[0].rem()>0 && t[1].rem()>0){\n            cnt++;\n            turn = (turn+1)%2;\n        }else{\n            break;\n        }\n    }\n    return cnt;\n}\n\nint main(void){\n    ll n,m;\n    cin>>n>>m;\n    cout<<min(solve(n,m,0), solve(n,m,1))<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n, m;\nlong long data[2][2];\n\nlong long solve(int f);\n\nint main() {\n  cin >> n >> m;\n  cout << min(solve(1), solve(0)) << endl;\n  return 0;\n}\n\nlong long solve(int f) {\n  long long o = 0, d = 1, cnt = 0, bf;\n  data[0][0] = n;\n  data[1][0] = m;\n  data[0][1] = 0;\n  data[1][1] = 0;\n  while(data[0][0] > 0 && data[1][0] > 0) {\n    data[d][1] += data[o][0];\n    if(d == f) {\n      bf = max(0LL, data[d][1] - data[d][0]);\n    }else{\n      bf = data[d][1]/2;\n    }\n    data[d][0] -= bf;\n    data[d][1] -= bf * 2;\n    if(data[0][0] <= 0 || data[1][0] <= 0) break;\n    swap(o, d);\n    ++cnt;\n  }\n  return cnt;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\ntypedef unsigned long long ll;\nconst ll maxi = 1e18;\n\n// kill as many as possible\nvoid kill_max(const ll num, ll ar[3]){\n  ll can_move = num;\n  // attack 1\n  ll tmp = 0;\n  tmp = min(ar[1], can_move);\n  can_move -= tmp;\n  ar[1] -= tmp;\n  ar[0] += tmp;\n\n  // attack 2\n  tmp = min(ar[2], can_move/2);\n  can_move -= 2*tmp;\n  ar[2] -= tmp;\n  ar[0] += tmp;\n\n  // attack1 again\n  tmp = min(ar[2], can_move);\n  ar[2] -= tmp;\n  ar[1] += tmp;\n}\n\nvoid kill_min(const ll num,  ll ar[3]){\n  // attack 2\n  ll can_move = num;\n  ll tmp = 0;\n  tmp = min(ar[2], can_move);\n  can_move -= tmp;\n  ar[2] -= tmp;\n  ar[1] += tmp;\n\n  // attack 1\n  tmp = min(ar[1], can_move);\n  can_move -= tmp;\n  ar[1] -= tmp;\n  ar[0] += tmp;\n}\n\n\nint solve(const ll a, const ll b, bool fg){\n  ll ta[3] = {0, 0, a};\n  ll tb[3] = {0, 0, b};\n  int cnt = 0;\n\n  while(true){\n    if (cnt %2 == 0){\n      if (fg){\n\tkill_max(ta[1] + ta[2], tb);\n      } else {\n\tkill_min(ta[1] + ta[2], tb);\n      }\n    } else {\n      if (fg){\n\tkill_min(tb[1] + tb[2], ta);\n      } else {\n\tkill_max(tb[1] + tb[2], ta);\n      }\n    }\n    if (ta[0] == a || tb[0] == b){\n      break;\n    }\n    cnt++;\n  }\n  return cnt;\n}\n\nint solve2(const ll a, const ll b, bool fg1, bool fg2){\n  ll ta[3] = {0, 0, a};\n  ll tb[3] = {0, 0, b};\n  int cnt = 0;\n\n  while(true){\n    if (cnt %2 == 0){\n      if (fg1){\n\tkill_max(ta[1] + ta[2], tb);\n      } else {\n\tkill_min(ta[1] + ta[2], tb);\n      }\n    } else {\n      if (fg2){\n\tkill_max(tb[1] + tb[2], ta);\n      } else {\n\tkill_min(tb[1] + tb[2], ta);\n      }\n    }\n    if (ta[0] == a || tb[0] == b){\n      break;\n    }\n    cnt++;\n  }\n  return cnt;\n}\n\nint main(){\n  ll n, m;\n  cin >> n >> m;\n\n  if (n >= m){\n    if (n >= 2 * m){\n      cout << 0 << endl;\n    } else {\n      cout << 2 << endl;\n    }\n  } else {\n    if ( n * 2 <= m ){\n      cout << 1 << endl;\n    } else {\n      //int mini = solve(n, m, false);\n      //mini = min(mini, solve(n, m, true));\n      //cout << mini << endl;\n\n\n      int a = solve2(n, m, false, true);\n      int b = solve2(n, m, true, false);\n      int c = solve2(n, m, false, false);\n      int d = solve2(n, m, true, true);\n      \n      ///cout << mini <<\" \" << min(c, d) << endl;\n      cout << min(min(a, b), min(c, d)) << endl;\n\n\n\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n                                            //    #include <boost/multiprecision/cpp_int.hpp>\n \n                               \t       #define int long long\n                                                #define inf  1000000007\n                                              #define pa pair<int,int>\n                                               #define pad pair<double,double>\n                                                #define ll long long\n                                                #define pal pair<double,double>\n                                                #define ppap pair<pa,int>\n                                          #define PI 3.14159265358979323846\n                                                #define paa pair<pa,pa>\n                                                #define  mp make_pair\n                                                #define  pb push_back\n                                                #define EPS (1e-10)\n                                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                                            //    #define double long double\n        int dx[4]={0,-1,0,1};\n        int dy[4]={1,0,-1,0};\n                                                using namespace std;\n                                       \t\t\tclass pa3{\n                                                \tpublic:\n                                                \tint x,y,z;\n                                                \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                                \tbool operator < (const pa3 &p) const{\n                                                \t\tif(x!=p.x) return x<p.x;\n                                                \t\tif(y!=p.y) return y<p.y;\n                                                \t\t return z<p.z;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                       \t\t\t\tbool operator > (const pa3 &p) const{\n                                                \t\tif(x!=p.x) return x>p.x;\n                                                \t\tif(y!=p.y) return y>p.y;\n                                                \t\t return z>p.z;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const pa3 &p) const{\n                                                \t\treturn x==p.x && y==p.y && z==p.z;\n                                                \t}\n                                                \t\tbool operator != (const pa3 &p) const{\n                                                \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                                \t}\n                                                \n                                                };\n                                                \n                                                class pa4{\n                                                \tpublic:\n                                                \tint x;\n                                                \tint y,z,w;\n                                                \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                                \tbool operator < (const pa4 &p) const{\n                                                \t\tif(x!=p.x) return x<p.x;\n                                                \t\tif(y!=p.y) return y<p.y;\n                                                \t\tif(z!=p.z)return z<p.z;\n                                                \t\treturn w<p.w;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator > (const pa4 &p) const{\n                                                \t\tif(x!=p.x) return x>p.x;\n                                                \t\tif(y!=p.y) return y>p.y;\n                                                \t\tif(z!=p.z)return z>p.z;\n                                                \t\treturn w>p.w;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const pa4 &p) const{\n                                                \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                                \t}\n                                                \t\n                                                \tbool operator != (const pa4 &p) const{\n                                                \t\treturn !(x==p.x && y==p.y && z==p.z &&w==p.w);\n                                                \t}\n                                                \t\t\n                                                \n                                                };\n                                                class pa2{\n                                                \tpublic:\n                                                \tint x,y;\n                                                \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                                \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                                \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                                \tbool operator < (const pa2 &p) const{\n                                                \t\treturn x!= p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator > (const pa2 &p) const{\n                                                \t\treturn x != p.x ? x>p.x: y>p.y;\n                                                \t}\n                                                \tbool operator == (const pa2 &p) const{\n                                                \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                                \t}\n                                                \tbool operator != (const pa2 &p) const{\n                                                \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                                \t}\n                                                \t\t\n                                                \n                                                };\n                                                \n                                              \n                                                \n                                                       #define ppa pair<int,pas>\n                                                class Point{\n                                                \tpublic:\n                                                \tdouble x,y;\n                                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                                \tdouble absv() {return sqrt(norm());}\n                                                \tdouble norm() {return x*x+y*y;}\n                                                \tbool operator < (const Point &p) const{\n                                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const Point &p) const{\n                                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                                \t}\n                                                };\n                                                typedef Point Vector;\n                                         #define pl pair<int,pas>\n                                                struct Segment{\n                                                Point p1,p2;\n                                                };\n                                                 double dot(Vector a,Vector b){\n                                                \treturn a.x*b.x+a.y*b.y;\n                                                }\n                                                double cross(Vector a,Vector b){\n                                                \treturn a.x*b.y-a.y*b.x;\n                                                }\n                                            \n                    bool parareru(Point a,Point b,Point c,Point d){\n                    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                    \treturn abs(cross(a-b,d-c))<EPS;\n                    }\n                    double distance_ls_p(Point a, Point b, Point c) {\n                      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                      return abs(cross(b-a, c-a)) / (b-a).absv();\n                    }\n                    bool is_intersected_ls(Segment a,Segment b) {\n                    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return 1;\n                    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                    //\t\tcout<<\"sss\"<<endl;\n                    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                    \t\treturn false;\n                    \t}\n                      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                    }\n                     \n                    double segment_dis(Segment a,Segment b){\n                    \tif(is_intersected_ls(a,b))return 0;\n                    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                    \treturn r;\n                    }\n                    Point intersection_ls(Segment a, Segment b) {\n                      Point ba = b.p2-b.p1;\n                      double d1 = abs(cross(ba, a.p1-b.p1));\n                      double d2 = abs(cross(ba, a.p2-b.p1));\n                      double t = d1 / (d1 + d2);\n                     \n                      return a.p1 + (a.p2-a.p1) * t;\n                    }\n                     \n                                    string itos( int i ) {\n                                    ostringstream s ;\n                                    s << i ;\n                                    return s.str() ;\n                                    }\n                                     \n                                    int gcd(int v,int b){\n                                    \tif(v==0) return b;\n                                    \tif(v>b) return gcd(b,v);\n                                    \tif(v==b) return b;\n                                    \tif(b%v==0) return v;\n                                    \treturn gcd(v,b%v);\n                                    }\n                     \n                                    double distans(double x1,double y1,double x2,double y2){\n                                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                    \treturn sqrt(rr);\n                                    \t\n                                    }\n                                                        /*\n        double bekid(double w,int r){\n        \tif(r==0) return 1.0;\n        \tif(r==1) return w;\n        \tif(r%2) return bekid(w,r-1)*w;\n        \tdouble f=bekid(w,r/2);\n        \treturn f*f;\n        }*/\n                                    int mod;\n                    ll beki(ll wa,ll rr,ll warukazu){\n                    \tif(rr==0) return 1ll%warukazu;\n                    \tif(rr==1) return wa%warukazu;\n                    \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%(ll)warukazu;\n                    \tll zx=beki(wa,rr/2,warukazu);\n                    \treturn (zx*zx)%warukazu;\n                    }\n                                    \n                    int pr[401000];\n                    int inv[401000];\n                   \n                   \n\n                  \n        \t\t\tint comb(int nn,int rr){\n        \t\t\t\tint r=pr[nn]*inv[rr];\n        \t\t\t\tr%=mod;\n        \t\t\t\tr*=inv[nn-rr];\n        \t\t\t\tr%=mod;\n        \t\t\t\t\n        \t\t\t\treturn r;\n        \t\t\t}\n                  \n                    void gya(int ert){\n                    \tpr[0]=1;\n                    \tfor(int i=1;i<ert;i++){\n                    \t\tpr[i]=(pr[i-1]*i)%mod;\n                    \t}\n                    \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                    \t\n                    }\n                    \n                    \n                  //   cin.tie(0);\n        \t\t//\tios::sync_with_stdio(false);\n        \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                     //sort(ve.begin(),ve.end(),greater<int>());\n\n\n///////////////////////////////////////////////////////////\n\n\n\n  signed main(){\n// \t              cin.tie(0);\n  // \t\tios::sync_with_stdio(false);\n\n  \tint a2,b2;\n  \tcin>>a2>>b2;\n  \tint X=a2,Y=b2;\n  \tint a1=0,b1=0;\n  \tint ans1=0;\n  \t\n\n  \twhile(1){\n  \t//\tcout<<a<<\" \"<<b<<endl;\n  \t//\tcout<<a1<<\" \"<<a2<<\" \"<<b1<<\" \"<<b2<<endl;\n  \t\tint kesu=a1+a2;\n  \t\tif(kesu>=b1+2*b2){\n  \t\t\tbreak;\n  \t\t}\n  \t\tif(ans1%2){\n  \t\t\t{\n  \t\t\t\tint g=min(b2,kesu);\n  \t\t\t\tb2-=g;\n  \t\t\t\tb1+=g;\n  \t\t\t\tkesu-=g;\n  \t\t\t}\n  \t\t\tif(kesu){\n  \t\t\t\tb1-=kesu;\n  \t\t\t\n  \t\t\t}\n  \t\t}\n  \t\telse{\n  \t\t\tif(b1){\n  \t\t\t\tb1--;\n  \t\t\t\tkesu--;\n  \t\t\t}\n  \t\t\tif(kesu%2==0){\n  \n  \t\t\t\tb2-=kesu/2;\n  \t\t\t}\n  \t\t\telse{\n  \t\t\t\tb2-=kesu/2;\n  \t\t\t\tb2--;\n  \t\t\t\tb1++;\n  \t\t\t}\n  \t\t}\n  \t\t\n  \t//\tcout<<\"  \"<<a1<<\" \"<<a2<<\" \"<<b1<<\" \"<<b2<<endl;\n  \t\tif(b2<0||b1<0) break;\n  \t\tans1++;\n  \t\tswap(a1,b1);\n  \t\tswap(a2,b2);\n  \t}\n  \t\n  \tint ans2=0;\n  \ta2=X,b2=Y,a1=0,b1=0;\n  \twhile(1){\n  \t//\tcout<<a<<\" \"<<b<<endl;\n  \t//\tcout<<a1<<\" \"<<a2<<\" \"<<b1<<\" \"<<b2<<endl;\n  \t\tint kesu=a1+a2;\n  \t\tif(kesu>=b1+2*b2){\n  \t\t\tbreak;\n  \t\t}\n  \t\tif(ans2%2==0){\n  \t\t\t{\n  \t\t\t\tint g=min(b2,kesu);\n  \t\t\t\tb2-=g;\n  \t\t\t\tb1+=g;\n  \t\t\t\tkesu-=g;\n  \t\t\t}\n  \t\t\tif(kesu){\n  \t\t\t\tb1-=kesu;\n  \t\t\t\n  \t\t\t}\n  \t\t}\n  \t\telse{\n  \t\t\tif(b1){\n  \t\t\t\tb1--;\n  \t\t\t\tkesu--;\n  \t\t\t}\n  \t\t\tif(kesu%2==0){\n  \n  \t\t\t\tb2-=kesu/2;\n  \t\t\t}\n  \t\t\telse{\n  \t\t\t\tb2-=kesu/2;\n  \t\t\t\tb2--;\n  \t\t\t\tb1++;\n  \t\t\t}\n  \t\t}\n  \t\t\n  \t//\tcout<<\"  \"<<a1<<\" \"<<a2<<\" \"<<b1<<\" \"<<b2<<endl;\n  \t\tif(b2<0||b1<0) break;\n  \t\tans2++;\n  \t\tswap(a1,b1);\n  \t\tswap(a2,b2);\n  \t}\n  \tcout<<min(ans1,ans2)<<endl;\n  \treturn 0;\n  \t\n               }\n                \n                \n                \n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tlong long a, b;\n\tcin >> a >> b;\n\tint ans=0;\n\tlong long a1=a, a2=a, b1=b, b2=b, t1=0, t2=0, l1=a, l2=b;\n\twhile(1)\n\t{\n\t\t//a1 save b1 die\n\t\tb1-=a1/2;\n\t\tif(t1==1&&a1%2==1) --b1, t1=0;\n\t\telse if(a1%2==1) t1=1;\n\t\tif(b1<=0) break;\t\t\n\n\t\t//a2 die b2 save\n\t\tif(l2>0)\n\t\t{\n\t\t\tif(l2>a2) l2-=a2;\n\t\t\telse b2-=a2-l2;\n\t\t} \n\t\telse b2-=a2;\n\t\t++ans;\n\n\t\tif(l1>0)\n\t\t{\n\t\t\tif(l1>b1) l1-=b1;\n\t\t\telse a1-=b1-l1;\n\t\t} \n\t\telse a1-=b1;\n\n\t\ta2-=b2/2;\n\t\tif(t2==1&&b2%2==1) --a2, t2=0;\n\t\telse if(b2%2==1) t2=1;\n\t\tif(a2<=0) break;\n\t\t++ans;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = vector<V<T>>;\ntemplate <typename T> using VVV = vector<VV<T>>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll INF = (1LL<<60);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n\n  int ans = INF;\n\n  int ret = 0;\n  int n2 = n, n1 = 0, m2 = m, m1 = 0;\n  while(1) {\n    // uku\n    int tmp = 0;\n    // m1を減らす\n    if(m1 > (n2+n1)) m1 -= n2+n1, tmp = n1+n2;\n    else tmp = m1, m1 = 0;\n    // m2を減らす (n2+n1) - tmp\n    m2 -= (n2+n1-tmp)/2;\n    // 余ってたらm1\n    if(m2 <= 0 && m1 <= 0) break;\n    if((n2+n1-tmp)%2 == 1) m2--, m1++; \n    ret++;\n    // usi\n    // n2->n1\n    tmp = 0;\n    if(n2 < m1+m2) tmp = n2, n1 += n2, n2 = 0;\n    else n2 -= m1+m2, n1 += m1+m2, tmp = m1+m2;\n    // n1を減らす (m1+m2) - tmp\n    n1 -= m1+m2-tmp;\n    if(n2 <= 0 && n1 <= 0) break;\n    ret++;\n  }\n  chmin(ans, ret);\n\n  swap(n, m);\n  ret = 0;\n  n2 = n, n1 = 0, m2 = m, m1 = 0;\n  while(1) {\n    // uku\n    // n2->n1\n    int tmp = 0;\n    if(n2 < m1+m2) tmp = n2, n1 += n2, n2 = 0;\n    else n2 -= m1+m2, n1 += m1+m2, tmp = m1+m2;\n    // n1を減らす (m1+m2) - tmp\n    n1 -= m1+m2-tmp;\n    if(n2 <= 0 && n1 <= 0) break;\n    ret++;\n    // usi\n    tmp = 0;\n    // m1を減らす\n    if(m1 > (n2+n1)) m1 -= n2+n1, tmp = n1+n2;\n    else tmp = m1, m1 = 0;\n    // m2を減らす (n2+n1) - tmp\n    m2 -= (n2+n1-tmp)/2;\n    // 余ってたらm1\n    if(m2 <= 0 && m1 <= 0) break;\n    if((n2+n1-tmp)%2 == 1) m2--, m1++; \n    ret++;\n  }\n  chmin(ans, ret);\n\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nlong long ans(long long a, long long b, int f) {\n    long long x[2][3] = {};\n    x[0][2] = a;\n    x[1][2] = b;\n\n    int ans = 0;\n    int idx = 0;\n    while (true) {\n        long long p = x[idx][1] + x[idx][2];\n\n        if (f == idx) {\n            //　殺しムーブ\n            {\n                long long k2 = min(x[idx ^ 1][1], p);\n                x[idx ^ 1][1] -= k2;\n                p -= k2;\n\n                long long total_kill = min(x[idx ^ 1][2], p / 2);\n                p -= total_kill * 2;\n                x[idx ^ 1][2] -= total_kill;\n            }\n\n            {\n                long long k = min(x[idx ^ 1][2], p);\n                p -= k;\n                x[idx ^ 1][2] -= k;\n                x[idx ^ 1][1] += k;\n\n                long long k2 = min(x[idx ^ 1][1], p);\n                x[idx ^ 1][1] -= k2;\n                p -= k2;\n            }\n\n        } else {\n            // 活かしムーブ\n            long long k = min(x[idx ^ 1][2], p);\n            p -= k;\n            x[idx ^ 1][2] -= k;\n            x[idx ^ 1][1] += k;\n\n            long long k2 = min(x[idx ^ 1][1], p);\n            x[idx ^ 1][1] -= k2;\n            p -= k2;\n        }\n\n        if (x[idx ^ 1][1] == 0 && x[idx ^ 1][2] == 0) {\n            return ans;\n        }\n        ans++;\n        idx ^= 1;\n    }\n\n}\n\n\nint main() {\n    long long a, b;\n    cin >> a >> b;\n    cout << min(ans(a, b, true), ans(a, b, false)) << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 3040 U and U\n// 2019.4.2 bal4u\n\n#include <stdio.h>\n\nint main()\n{\n\tlong long N, M;\n\n\tscanf(\"%lld%lld\", &N, &M);\n\tif (N >= (M << 1)) puts(\"0\");\n\telse if (M >= (N << 1)) puts(\"1\");\n\telse if (M <= N) puts(\"2\");\n\telse if ((M<<1)+M+(M>>1) >= (N<<2)) puts(\"3\");\n\telse puts(\"4\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define min(p,q)((p)<(q)?(p):(q))\n\nint main(){\n\tlong long X,Y;\n\tscanf(\"%lld%lld\",&X,&Y);\n\tint ans1=0;\n\t//aを滅ぼす場合\n\tlong long a=X*2,b1=0,b2=Y;\n\twhile(1){\n\t\tlong long t=(a+1)/2;\n\t\tlong long tt=min(b2,t);\n\t\tb2-=tt;\n\t\tb1+=tt;\n\t\tb1-=min(b1,t-tt);\n\t\tif(b1+b2==0)break;\n\t\tans1++;\n\t\ta-=b1+b2;\n\t\tif(a<=0)break;\n\t\tans1++;\n\t}\n\n\tint ans2=0;\n\t//bを滅ぼす場合\n\tlong long b=Y*2,a1=0,a2=X;\n\twhile(1){\n\t\tb-=a1+a2;\n\t\tif(b<=0)break;\n\t\tans2++;\n\t\tlong long t=(b+1)/2;\n\t\tlong long tt=min(a2,t);\n\t\ta2-=tt;\n\t\ta1+=tt;\n\t\ta1-=min(a1,t-tt);\n\t\tif(a1+a2==0)break;\n\t\tans2++;\n\t}\n\tprintf(\"%d\\n\",min(ans1,ans2));\n}\n"
  },
  {
    "language": "Python",
    "code": "A, B = map(int, input().split())\nscore = 0\nscore_a = A * 2\nscore_b = B * 2\na = A\nb = B\n\nwhile True :\n    score_b -= a\n    if score_b <= 0 :\n        break\n    else :\n        score += 1\n        if score_b < b :\n            b = score_b\n    \n    score_a -= b\n    if score_a <= 0 :\n        break\n    else :\n        score += 1\n        if score_a < a :\n            a = score_a\n            \nans = score\n\na = A\nb = B\nscore = 0\nscore_a = a * 2\nscore_b = b * 2\n\nwhile True :\n    score_b -= a\n    if score_b <= 0 :\n        break\n    else :\n        score += 1\n        if score_b < b and A < B :\n            b = score_b\n        elif score_b < b and A > B :\n            if score_b % 2 == 0 :\n                b = score_b // 2\n            else :\n                b = score_b // 2 + 1\n    \n    score_a -= b\n    if score_a <= 0 :\n        break\n    else :\n        score += 1\n        if score_a < a and A > B :\n            a = score_a\n        elif score_a < a and A < B:\n            if score_a % 2 == 0 :\n                a = score_a // 2\n            else :\n                a = score_a // 2 + 1\n\nif ans < score :\n    print(ans)\nelse :\n    print(score)\n"
  },
  {
    "language": "Python",
    "code": "def solve(A, B, hoge):\n    C, D = 0, 0\n    turn = 0\n    while True:\n        if turn % 2 == 0 and hoge == 0:\n            n = A + C\n            m = min(n, D)\n            D -= m\n            n -= m\n            m = min(n/2, B)\n            B -= m\n            n -= m*2\n            if B > 0 and n > 0:\n                B -= 1\n                D += 1\n        elif turn % 2 == 1 and hoge == 0:\n            n = B + D\n            m = min(n, A)\n            A -= m\n            C += m\n            n -= m\n            m = min(n, C)\n            C -= m\n            n -= m\n        elif turn % 2 == 0 and hoge == 1:\n            n = A + C\n            m = min(n, B)\n            B -= m\n            D += m\n            n -= m\n            m = min(n, D)\n            D -= m\n            n -= m\n        else:\n            n = B + D\n            m = min(n, C)\n            C -= m\n            n -= m\n            m = min(n/2, A)\n            A -= m\n            n -= m*2\n            if A > 0 and n > 0:\n                A -= 1\n                C += 1\n        if A + C <= 0 or B + D <= 0:\n            return turn\n        turn += 1\n\nif __name__ == \"__main__\":\n    A, B = map(int, raw_input().split())\n    print min(solve(A, B, 0), solve(A, B, 1))\n\n"
  },
  {
    "language": "Python",
    "code": "N,M = map(int,input().split())\n\nah = N*2\nbh = M*2\nans1 = 0\nwhile True:\n    ap = min(N,ah)\n    bh -= ap\n    if bh <= 0:\n        break\n    ans1 += 1\n    #print('ans1,ah,bh,ap',ans1,ah,bh,ap)\n    bp = (bh+1)//2\n    ah -= bp\n    if ah <= 0:\n        break\n    ans1 += 1\n    #print('ans1,ah,bh,bp',ans1,ah,bh,bp)\n\n#print(ans1)\n\nah = N*2\nbh = M*2\nans2 = 0\nwhile True:\n    ap = (ah+1)//2\n    bh -= ap\n    if bh <= 0:\n        break\n    ans2 += 1\n    bp = min(M,bh)\n    ah -= bp\n    if ah <= 0:\n        break\n    ans2 += 1\n\n#print(ans2)\n\nprint(min(ans1,ans2))\n\n"
  },
  {
    "language": "Python",
    "code": "def inpl(): return list(map(int, input().split()))\nN, M = inpl()\n\nn2 = N * 1\nn1 = N * 1\nm1 = M * 1\nmall = M * 2\n\n# うくをほろぼす\nans1 = 0\nwhile True:\n    mall -= n1\n    m1 = -(-mall//2)\n    \n    if mall <= 0:\n        break\n    ans1 += 1\n    \n    if n2 - m1 >= 0:\n        n2 -= m1\n    else:\n        n1 = n1 + n2 - m1\n        n2 = 0\n    if n1 <= 0:\n\n        break\n    ans1 += 1\n\n# ushiを滅ぼす\n\nans2 = 0\nn2 = N * 1\nn1 = N * 1\nm1 = M * 1\nm2 = M * 1\nmall = M * 2\nnall = N * 2\n\nwhile True:\n    if m2 - n1 >= 0:\n        m2 -= n1\n    else:\n        m1 = m1 + m2 - n1\n        m2 = 0\n    if m1 <= 0:\n\n        break\n    ans2 += 1\n\n    nall -= m1\n    n1 = -(-nall//2)\n    \n    if nall <= 0:\n        break\n    ans2 += 1\n\nprint(min(ans1, ans2))\n"
  }
]