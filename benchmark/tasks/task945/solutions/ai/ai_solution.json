[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint stones[MAX_N];\nint degree[MAX_N];\nint parent[MAX_N];\nint graph[MAX_N][MAX_N];\nint graph_size[MAX_N];\n\nvoid dfs(int node, int prev) {\n    parent[node] = prev;\n    for (int i = 0; i < graph_size[node]; i++) {\n        int child = graph[node][i];\n        if (child != prev) {\n            dfs(child, node);\n        }\n    }\n}\n\nbool check_path(int u, int v) {\n    bool on_path[MAX_N] = {false};\n    \n    while (u != -1) {\n        on_path[u] = true;\n        u = parent[u];\n    }\n    \n    while (v != -1) {\n        if (on_path[v]) return true;\n        v = parent[v];\n    }\n    \n    return false;\n}\n\nbool find_leaves_path(int n) {\n    for (int u = 1; u <= n; u++) {\n        if (degree[u] != 1) continue;\n        \n        for (int v = u + 1; v <= n; v++) {\n            if (degree[v] != 1) continue;\n            \n            if (!check_path(u, v)) continue;\n            \n            bool valid_path = true;\n            int curr_u = u, curr_v = v;\n            \n            while (curr_u != curr_v) {\n                if (stones[curr_u] == 0 || stones[curr_v] == 0) {\n                    valid_path = false;\n                    break;\n                }\n                \n                curr_u = parent[curr_u];\n                curr_v = parent[curr_v];\n            }\n            \n            if (!valid_path) continue;\n            \n            curr_u = u;\n            curr_v = v;\n            \n            while (curr_u != curr_v) {\n                stones[curr_u]--;\n                stones[curr_v]--;\n                \n                curr_u = parent[curr_u];\n                curr_v = parent[curr_v];\n            }\n            \n            stones[curr_u]--;\n            \n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    memset(degree, 0, sizeof(degree));\n    memset(graph_size, 0, sizeof(graph_size));\n    \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &stones[i]);\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        \n        graph[u][graph_size[u]++] = v;\n        graph[v][graph_size[v]++] = u;\n        \n        degree[u]++;\n        degree[v]++;\n    }\n    \n    dfs(1, -1);\n    \n    bool possible = true;\n    while (possible) {\n        possible = find_leaves_path(n);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (stones[i] > 0) {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n    \n    printf(\"Yes\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 23:25:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100000\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* adj[MAXN + 1];\nint degree[MAXN + 1];\nint stones[MAXN + 1];\nint queue[MAXN + 1];\nint visited[MAXN + 1];\n\nvoid addEdge(int u, int v) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->vertex = v;\n    newNode->next = adj[u];\n    adj[u] = newNode;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &stones[i]);\n    }\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n        addEdge(v, u);\n        degree[u]++;\n        degree[v]++;\n    }\n\n    int front = 0, rear = 0;\n    for (int i = 1; i <= N; i++) {\n        if (degree[i] == 1) {\n            queue[rear++] = i;\n            visited[i] = 1;\n        }\n    }\n\n    while (front < rear) {\n        int u = queue[front++];\n        if (stones[u] != 0) {\n            printf(\"NO\\n\");\n            return 0;\n        }\n        Node* curr = adj[u];\n        while (curr != NULL) {\n            int v = curr->vertex;\n            if (!visited[v]) {\n                stones[v] -= stones[u];\n                if (stones[v] < 0) {\n                    printf(\"NO\\n\");\n                    return 0;\n                }\n                degree[v]--;\n                if (degree[v] == 1) {\n                    queue[rear++] = v;\n                    visited[v] = 1;\n                }\n            }\n            curr = curr->next;\n        }\n    }\n\n    printf(\"YES\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nbool solve() {\n    int N;\n    cin >> N;\n    vector<int> stones(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        cin >> stones[i];\n    }\n\n    vector<vector<int>> adj(N + 1);\n    vector<int> degree(N + 1, 0);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n        degree[u]++;\n        degree[v]++;\n    }\n\n    queue<int> q;\n    for (int i = 1; i <= N; ++i) {\n        if (degree[i] == 1) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        if (stones[u] < 0) {\n            return false;\n        }\n\n        for (int v : adj[u]) {\n            if (degree[v] > 0) {\n                stones[v] -= stones[u];\n                degree[v]--;\n                if (degree[v] == 1) {\n                    q.push(v);\n                }\n            }\n        }\n        degree[u] = 0;\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        if (stones[i] != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    if (solve()) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class StoneRemoval {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] stones = new int[N + 1];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 1; i <= N; i++) {\n            stones[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        Queue<Integer> leaves = new LinkedList<>();\n        int[] degree = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            degree[i] = adj.get(i).size();\n            if (degree[i] == 1) {\n                leaves.add(i);\n            }\n        }\n\n        boolean possible = true;\n        while (!leaves.isEmpty()) {\n            int u = leaves.poll();\n            if (stones[u] != 0) {\n                possible = false;\n                break;\n            }\n            for (int v : adj.get(u)) {\n                if (degree[v] > 0) {\n                    stones[v]--;\n                    if (stones[v] < 0) {\n                        possible = false;\n                        break;\n                    }\n                    degree[v]--;\n                    if (degree[v] == 1) {\n                        leaves.add(v);\n                    }\n                }\n            }\n            if (!possible) {\n                break;\n            }\n        }\n\n        System.out.println(possible ? \"YES\" : \"NO\");\n    }\n}",
    "timestamp": "2025-08-05 23:26:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class StoneRemoval {\n    static class Graph {\n        int N;\n        List<List<Integer>> adj;\n        int[] stones;\n        int[] degree;\n\n        Graph(int n) {\n            N = n;\n            adj = new ArrayList<>(N + 1);\n            for (int i = 0; i <= N; i++) {\n                adj.add(new ArrayList<>());\n            }\n            stones = new int[N + 1];\n            degree = new int[N + 1];\n        }\n\n        void addEdge(int u, int v) {\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        boolean canRemoveStones() {\n            Queue<Integer> leaves = new LinkedList<>();\n            for (int i = 1; i <= N; i++) {\n                if (degree[i] == 1) {\n                    leaves.offer(i);\n                }\n            }\n\n            while (!leaves.isEmpty()) {\n                int leaf1 = leaves.poll();\n                if (stones[leaf1] == 0) continue;\n\n                for (int neighbor1 : adj.get(leaf1)) {\n                    if (stones[neighbor1] == 0) continue;\n\n                    for (int leaf2 : leaves) {\n                        if (leaf1 == leaf2 || stones[leaf2] == 0) continue;\n\n                        List<Integer> path = findPath(leaf1, leaf2);\n                        if (path == null) continue;\n\n                        boolean canRemove = true;\n                        for (int vertex : path) {\n                            if (stones[vertex] == 0) {\n                                canRemove = false;\n                                break;\n                            }\n                        }\n\n                        if (canRemove) {\n                            for (int vertex : path) {\n                                stones[vertex]--;\n                            }\n\n                            updateDegreeAndLeaves(path);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            for (int i = 1; i <= N; i++) {\n                if (stones[i] > 0) return false;\n            }\n            return true;\n        }\n\n        List<Integer> findPath(int start, int end) {\n            boolean[] visited = new boolean[N + 1];\n            int[] parent = new int[N + 1];\n            Queue<Integer> queue = new LinkedList<>();\n\n            queue.offer(start);\n            visited[start] = true;\n\n            while (!queue.isEmpty()) {\n                int current = queue.poll();\n                if (current == end) {\n                    List<Integer> path = new ArrayList<>();\n                    while (current != start) {\n                        path.add(current);\n                        current = parent[current];\n                    }\n                    path.add(start);\n                    Collections.reverse(path);\n                    return path;\n                }\n\n                for (int neighbor : adj.get(current)) {\n                    if (!visited[neighbor]) {\n                        queue.offer(neighbor);\n                        visited[neighbor] = true;\n                        parent[neighbor] = current;\n                    }\n                }\n            }\n            return null;\n        }\n\n        void updateDegreeAndLeaves(List<Integer> path) {\n            for (int vertex : path) {\n                if (degree[vertex] == 1) {\n                    stones[vertex] = 0;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        Graph graph = new Graph(N);\n\n        for (int i = 1; i <= N; i++) {\n            graph.stones[i] = sc.nextInt();\n        }\n\n        for (int i = 1; i < N; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            graph.addEdge(u, v);\n        }\n\n        System.out.println(graph.canRemoveStones() ? \"YES\" : \"NO\");\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 23:27:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPossibleToRemoveStones(int N, vector<int>& stones, vector<vector<int>>& edges) {\n        vector<vector<int>> graph(N + 1);\n        vector<int> degree(N + 1, 0);\n        \n        // Build adjacency list and calculate vertex degrees\n        for (const auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n            degree[edge[0]]++;\n            degree[edge[1]]++;\n        }\n        \n        // Find leaves with non-zero stones\n        vector<int> leaves;\n        for (int i = 1; i <= N; i++) {\n            if (degree[i] == 1 && stones[i - 1] > 0) {\n                leaves.push_back(i);\n            }\n        }\n        \n        // If no leaves or odd number of leaves, removal is impossible\n        if (leaves.empty() || leaves.size() % 2 != 0) {\n            return false;\n        }\n        \n        // Try to match leaves and find path\n        vector<bool> visited(N + 1, false);\n        for (int i = 0; i < leaves.size(); i += 2) {\n            int u = leaves[i], v = leaves[i + 1];\n            \n            // Check if path exists and all vertices have stones\n            if (!hasPathWithStones(u, v, graph, stones, visited)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \nprivate:\n    bool hasPathWithStones(int start, int end, vector<vector<int>>& graph, vector<int>& stones, vector<bool>& visited) {\n        vector<int> path;\n        if (!dfs(start, end, graph, visited, path)) {\n            return false;\n        }\n        \n        // Check if all vertices in path have stones\n        for (int vertex : path) {\n            if (stones[vertex - 1] == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    bool dfs(int current, int target, vector<vector<int>>& graph, vector<bool>& visited, vector<int>& path) {\n        visited[current] = true;\n        path.push_back(current);\n        \n        if (current == target) {\n            return true;\n        }\n        \n        for (int neighbor : graph[current]) {\n            if (!visited[neighbor]) {\n                if (dfs(neighbor, target, graph, visited, path)) {\n                    return true;\n                }\n            }\n        }\n        \n        path.pop_back();\n        return false;\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> stones(N);\n    for (int i = 0; i < N; i++) {\n        cin >> stones[i];\n    }\n    \n    vector<vector<int>> edges(N - 1, vector<int>(2));\n    for (int i = 0; i < N - 1; i++) {\n        cin >> edges[i][0] >> edges[i][1];\n    }\n    \n    Solution solution;\n    cout << (solution.isPossibleToRemoveStones(N, stones, edges) ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_remove_all_stones(N, stones, edges):\n    from collections import defaultdict, deque\n    \n    # Create adjacency list and degree dictionary\n    adj = defaultdict(list)\n    degree = defaultdict(int)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n\n    # Identify leaves\n    leaves = [i for i in range(1, N+1) if degree[i] == 1]\n\n    # Calculate total stones\n    total_stones = sum(stones)\n\n    # Condition to check\n    return total_stones % 2 == 0 and len(leaves) > 1\n\n# Example Usage\nN = 5\nstones = [2, 1, 2, 1, 1]\nedges = [(1, 2), (1, 3), (3, 4), (3, 5)]\nprint(can_remove_all_stones(N, stones, edges))",
    "timestamp": "2025-08-13 15:20:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class StonesOnTree {\n    \n    public static boolean canRemoveAllStones(int n, int[] stones, List<int[]> edges) {\n        if (n == 2) {\n            return stones[0] == stones[1];\n        }\n        \n        Map<Integer, List<Integer>> tree = new HashMap<>();\n        for (int[] edge : edges) {\n            tree.putIfAbsent(edge[0] - 1, new ArrayList<>());\n            tree.get(edge[0] - 1).add(edge[1] - 1);\n            tree.putIfAbsent(edge[1] - 1, new ArrayList<>());\n            tree.get(edge[1] - 1).add(edge[0] - 1);\n        }\n\n        int leafCount = 0;\n        int totalStones = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (tree.get(i).size() == 1) {\n                leafCount++;\n            }\n            totalStones += stones[i];\n        }\n\n        return totalStones % 2 == 0 && totalStones >= leafCount * 2;\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        int[] stones = {3, 2, 1, 1, 2};\n        List<int[]> edges = Arrays.asList(new int[]{1, 2}, new int[]{1, 3}, new int[]{3, 4}, new int[]{3, 5});\n        \n        boolean result = canRemoveAllStones(n, stones, edges);\n        System.out.println(result ? \"YES\" : \"NO\");\n    }\n}",
    "timestamp": "2025-08-13 15:20:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 100000\n\ntypedef struct {\n    int vertex, next;\n} Edge;\n\nint head[MAXN + 1], degree[MAXN + 1], stones[MAXN + 1], queue[MAXN];\nEdge edges[2 * MAXN];\nint edgeCount = 0;\n\nvoid add_edge(int u, int v) {\n    edges[edgeCount].vertex = v;\n    edges[edgeCount].next = head[u];\n    head[u] = edgeCount++;\n}\n\nint main() {\n    int N, a, b;\n    scanf(\"%d\", &N);\n    \n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &stones[i]);\n        head[i] = -1;\n        degree[i] = 0;\n    }\n    \n    for (int i = 0; i < N - 1; i++) {\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a, b);\n        add_edge(b, a);\n        degree[a]++;\n        degree[b]++;\n    }\n    \n    int front = 0, rear = 0;\n\n    for (int i = 1; i <= N; i++) {\n        if (degree[i] == 1) {\n            queue[rear++] = i;\n        }\n    }\n    \n    int stonesSum = 0;\n    for (int i = 1; i <= N; i++) {\n        stonesSum += stones[i];\n    }\n\n    if (stonesSum % 2 != 0) {\n        printf(\"NO\\n\");\n        return 0;\n    }\n\n    while (front < rear) {\n        int leaf = queue[front++];\n        \n        if (stones[leaf] % 2 != 0) {\n            printf(\"NO\\n\");\n            return 0;\n        }\n\n        for (int j = head[leaf]; j != -1; j = edges[j].next) {\n            int neighbor = edges[j].vertex;\n            stones[neighbor] -= stones[leaf];\n            if (--degree[neighbor] == 1) {\n                queue[rear++] = neighbor;\n            }\n        }\n\n        stones[leaf] = 0;\n    }\n\n    printf(\"YES\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-13 15:20:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool canRemoveAllStones(vector<int> &deg, vector<int> &stones) {\n    for (int i = 1; i <= deg.size(); ++i) {\n        if ((deg[i] == 1 && stones[i] % 2 != 0) || (deg[i] != 1 && stones[i] < 0)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> stones(N + 1), deg(N + 1, 0);\n    for (int i = 1; i <= N; ++i) {\n        cin >> stones[i];\n    }\n    for (int i = 1; i < N; ++i) {\n        int u, v;\n        cin >> u >> v;\n        deg[u]++;\n        deg[v]++;\n    }\n\n    int totalStones = 0;\n    for (int i = 1; i <= N; ++i) {\n        totalStones += stones[i];\n    }\n\n    if (totalStones % 2 != 0 || !canRemoveAllStones(deg, stones)) {\n        cout << \"NO\\n\";\n    } else {\n        cout << \"YES\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:20:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef can_remove_stones(N, stones, edges):\n    # Create adjacency list representation of the tree\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Compute degree of each vertex\n    degree = [len(graph[i]) for i in range(1, N+1)]\n    \n    # Find leaves\n    leaves = [i for i in range(1, N+1) if degree[i-1] == 1 and stones[i-1] > 0]\n    \n    # Use BFS to track possible paths between leaves\n    def find_path(start, end):\n        visited = set()\n        queue = deque([(start, [start])])\n        \n        while queue:\n            current, path = queue.popleft()\n            \n            if current == end:\n                return path\n            \n            visited.add(current)\n            \n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    queue.append((neighbor, path + [neighbor]))\n        \n        return None\n    \n    # Check if all stones can be removed\n    while leaves:\n        # Select first two leaves\n        leaf1 = leaves[0]\n        found_pair = False\n        \n        for leaf2 in leaves[1:]:\n            # Find path between leaves\n            path = find_path(leaf1, leaf2)\n            \n            # Check if path is valid (all vertices have stones)\n            if path and all(stones[node-1] > 0 for node in path):\n                # Remove one stone from each vertex in path\n                for node in path:\n                    stones[node-1] -= 1\n                \n                found_pair = True\n                \n                # Update leaves list\n                leaves = [l for l in leaves if stones[l-1] > 0 and degree[l-1] == 1]\n                break\n        \n        # If no valid pair found, return False\n        if not found_pair:\n            return False\n    \n    return True\n\ndef main():\n    # Read input\n    N = int(input())\n    stones = list(map(int, input().split()))\n    edges = []\n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    # Print result\n    print(\"YES\" if can_remove_stones(N, stones, edges) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 15:20:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    stones = list(map(int, sys.stdin.readline().split()))\n    adj = [[] for _ in range(N)]\n    degree = [0] * N\n    for _ in range(N-1):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n    \n    q = deque()\n    for i in range(N):\n        if degree[i] == 1:\n            q.append(i)\n    \n    possible = True\n    while q:\n        u = q.popleft()\n        if degree[u] != 1:\n            continue\n        for v in adj[u]:\n            if degree[v] > 0:\n                break\n        degree[u] = 0\n        if stones[u] < 0:\n            possible = False\n            break\n        if stones[u] == 0:\n            degree[v] -= 1\n            if degree[v] == 1:\n                q.append(v)\n            continue\n        if degree[v] == 0:\n            possible = False\n            break\n        stones[v] -= stones[u]\n        stones[u] = 0\n        degree[v] -= 1\n        if degree[v] == 1:\n            q.append(v)\n    \n    if possible and all(s == 0 for s in stones):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()",
    "timestamp": "2025-08-13 15:21:01"
  }
]