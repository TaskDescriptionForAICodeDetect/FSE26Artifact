[
  {
    "language": "Scala",
    "code": "\n\n\nimport scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.io.StdIn._\nobject Main extends App {\n\n  solve()\n  @tailrec def solve(): Unit = {\n    val expected = readLine.trim.toList match {\n      case e Equals _ ⇒ e\n      case '.'::_ ⇒ return\n    }\n    equals(expected)\n    println(\".\")\n    solve()\n  }\n  @tailrec def equals(expected: Expression): Unit = {\n    val candidate = readLine.trim.toList match {\n      case e Equals _ ⇒ e\n      case '.'::_ ⇒ return\n    }\n    println(if (candidate == expected) \"yes\" else \"no\")\n    equals(expected)\n  }\n\n}\ncase class Expression(val map: Map[List[Char], Long]) {\n  def *(that: Expression): Expression = {\n    val result = mutable.Map[List[Char], Long]().withDefaultValue(0L)\n    for ((key, value) ← map) {\n      for ((k, v) ← that.map) {\n        result((k ++ key).sorted) += value * v\n      }\n    }\n    Expression(result.toMap.filterNot(_._2 == 0))\n  }\n  def +(that: Expression): Expression = {\n    val result = mutable.Map[List[Char], Long]().withDefaultValue(0L)\n    for ((key, value) ← map) {\n      result(key) += value\n    }\n    for ((key, value) ← that.map) {\n      result(key) += value\n    }\n    Expression(result.toMap.filterNot(_._2 == 0))\n  }\n  def -(that: Expression): Expression = {\n    val result = mutable.Map[List[Char], Long]().withDefaultValue(0L)\n    for ((key, value) ← map) {\n      result(key) += value\n    }\n    for ((key, value) ← that.map) {\n      result(key) -= value\n    }\n    Expression(result.toMap.filterNot(_._2 == 0))\n  }\n  def power(exp: Long): Expression = {\n    exp match {\n      case 0L ⇒ Expression(Map(Nil → 1L))\n      case 1L ⇒ this\n      case _ ⇒ power(exp & 1L) * (this * this).power(exp >> 1)\n    }\n  }\n\n  override def equals(obj: Any): Boolean = {\n    obj match {\n      case that: Expression ⇒ map.count(_._2 != 0) == that.map.count(_._2 != 0) && map.forall{case (k, v) ⇒ that.map.getOrElse(k, 0) == v}\n      case _ ⇒ super.equals(obj)\n    }\n  }\n}\n\nobject Equals {\n  def unapply(arg: List[Char]): Option[(Expression, List[Char])] = {\n    arg.dropWhile(_.isWhitespace) match {\n      case f Factor r ⇒ Some(express(f, r))\n      case _ ⇒ None\n    }\n  }\n  @tailrec private def express(left: Expression, arg: List[Char]): (Expression, List[Char]) = {\n    arg.dropWhile(_.isWhitespace) match {\n      case '+'::(right Factor r) ⇒ express(left + right, r)\n      case '-'::(right Factor r) ⇒ express(left - right, r)\n      case _ ⇒ (left, arg)\n    }\n  }\n  object Number {\n    def unapply(arg: List[Char]): Option[(Long, List[Char])] = {\n      arg.dropWhile(_.isWhitespace).span(_.isDigit) match {\n        case (Nil, _) ⇒ None\n        case (n, r) ⇒ Some( n.foldLeft(0L){case (acc, v) ⇒ acc * 10 + v.asDigit}, r)\n      }\n    }\n  }\n  object Factor {\n    def unapply(arg: List[Char]): Option[(Expression, List[Char])] = {\n      arg.dropWhile(_.isWhitespace) match {\n        case t Term r ⇒ Some(takeAll(t, r))\n        case _ ⇒ None\n      }\n    }\n    @tailrec private def takeAll(left: Expression, arg: List[Char]): (Expression, List[Char]) = {\n      arg.dropWhile(_.isWhitespace) match {\n        case right Term rest ⇒ takeAll(left * right, rest)\n        case _ ⇒ (left, arg)\n      }\n    }\n  }\n  object Term {\n    def unapply(arg: List[Char]): Option[(Expression, List[Char])] = {\n      arg.dropWhile(_.isWhitespace) match {\n        case n Number r ⇒Some(takeExp(Expression(Map(Nil → n)), r))\n        case '(':: (e Equals rest) ⇒\n          rest.dropWhile(_.isWhitespace) match {\n            case ')'::r ⇒ Some(takeExp (e, r) )\n            case _ ⇒ ???\n          }\n        case c::r if c.isLetter ⇒ Some(takeExp(Expression(Map(List(c) → 1L)), r))\n        case _ ⇒ None\n      }\n    }\n    private def takeExp(left: Expression, arg: List[Char]): (Expression, List[Char]) = {\n      arg.dropWhile(_.isWhitespace) match {\n        case '^'::(n Number r) ⇒ (left.power(n), r)\n        case _ ⇒ (left, arg)\n      }\n    }\n  }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef __int128  Val;\n\n\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return static_cast<long long int>(pow(double(res),double(term2(s,p)))+1e9-7);\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%4;\n      }\n      Val cor=formula(state[0],p);\n      p=0;\n      Val ans=formula(state[i],p);\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double EPS=1e-8;\nvector<double> var;\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\ndouble formula(string &s,int &p);\n\ndouble num(string &s,int &p){\n  double res=0;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\ndouble var_val(string &s,int &p){\n  double res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\ndouble get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    double res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\ndouble term2(string &s,int &p){\n  double res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p));\n  }\n  return res;\n}\n\ndouble term1(string& s,int &p){\n  double res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    double val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\ndouble formula(string& s,int &p){\n  double res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    double val=term1(s,p);\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd();\n      }\n      double cor=formula(state[0],p);\n      p=0;\n      double ans=formula(state[i],p);\n      isok&=(abs(cor-ans)<EPS);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nmap<vector<int>, long long> calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        map<vector<int>, long long> ret;\n        long long tmp = 0;\n        for(int i=0; i<n; ++i){\n            tmp *= 10;\n            tmp += s[i] - '0';\n        }\n        ret[vector<int>(26, 0)] = tmp;\n        return ret;\n    }\n\n    if(n == 1){\n        map<vector<int>, long long> ret;\n        vector<int> tmp(26, 0);\n        tmp[s[0]-'a'] = 1;\n        ret[tmp] = 1;\n        return ret;\n    }\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                map<vector<int>, long long> a = calculate(t1);\n                map<vector<int>, long long> b = calculate(t2);\n\n                map<vector<int>, long long> ret;\n                if(i == 0){\n                    ret = a;\n                    for(auto it=b.begin(); it!=b.end(); ++it)\n                        ret[it->first] += it->second;\n                }else if(i == 1){\n                    ret = a;\n                    for(auto it=b.begin(); it!=b.end(); ++it)\n                        ret[it->first] -= it->second;\n                }else if(i == 2){\n                    for(auto it1=a.begin(); it1!=a.end(); ++it1){\n                        for(auto it2=b.begin(); it2!=b.end(); ++it2){\n                            vector<int> tmp(26);\n                            for(int k=0; k<26; ++k)\n                                tmp[k] = it1->first[k] + it2->first[k];\n                            ret[tmp] += it1->second * it2->second;\n                        }\n                    }\n                }else{\n                    vector<int> tmp(26);\n                    for(int k=0; k<26; ++k)\n                        tmp[k] = a.begin()->first[k] * b.begin()->second;\n                    ret[tmp] = 1;\n                }\n                return ret;\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nstring solve(string s, string t)\n{\n    s = normalize(s);\n    t = normalize(t);\n\n    map<vector<int>, long long> a = calculate(s);\n    map<vector<int>, long long> b = calculate(t);\n\n    if(a == b)\n        return \"yes\";\n    else\n        return \"no\";\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            cout << solve(s, t) << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< char,int > P;\ntypedef vector< P > vec;\ntypedef pair< int, vec > PP;\ntypedef vector< PP > mat;\nstring s;\nint p,len;\n\nmat add(mat a,mat b){\n  map< vec , int > mp;\n  \n  for(int i=0;i< (int)a.size();i++){\n    mp[ a[i].second ]+= a[i].first;\n  }\n\n  for(int i=0;i<(int)b.size();i++){\n    mp[ b[i].second ]+= b[i].first;\n  }\n\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  return res;\n}\n\nPP mul(PP a,PP b){\n  int fi=a.first*b.first;\n  vec &va=a.second;\n  vec &vb=b.second;\n  map<char,int> mp;\n  for(int i=0;i<(int)va.size();i++){\n    P p=va[i];\n    mp[ p.first ]+=p.second;\n  }\n  for(int j=0;j<(int)vb.size();j++){\n    P p=vb[j];\n    mp[ p.first ]+=p.second;\n  }  \n  vec se;\n  map<char,int> :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    se.push_back( *it );\n  }\n  return PP(fi,se);\n}\n\nmat mul(mat a,mat b){\n  map< vec , int > mp;\n  for(int i=0;i<(int)a.size();i++){\n    PP as=a[i];\n    for(int j=0;j<(int)b.size();j++){\n      PP bs=b[j];\n\n      PP c=mul(as,bs);\n      mp[  c.second ] += c.first;\n    }\n  }\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  return res;  \n}\n\nmat target;\nmat solve();\n\nmat getNum(){\n  while(s[p]==' ')p++;\n\n  if('0'<=s[p]&&s[p]<='9'){\n    int res=0;\n    while('0'<=s[p]&&s[p]<='9'){\n      res=res*10+(s[p]-'0');\n      p++;\n    }\n    mat re;\n    vec r;\n    re.push_back(PP( res , r ));\n    return re;\n  }\n\n  if('('==s[p]){\n    p++;\n    mat res=solve();\n    p++;\n    return res;\n  }\n\n  char ch=s[p++];\n  while(s[p]==' ')p++;\n  int num=1;\n  if(s[p]=='^'){\n    mat tmp=getNum();\n    num=tmp[0].first;\n  }\n  mat res;\n  vec r;\n  r.push_back(P(ch,num));\n  res.push_back(PP(1,r));\n  return res;\n}\n\nmat solve(){\n  while(s[p]==' ')p++;\n\n  stack < mat > st;\n  st.push( getNum() );\n\n  while(1){\n    while(s[p]==' ')p++;\n\n    if(p>=len){\n      break;\n    }else if(s[p]=='+'){\n      p++;\n      mat num=getNum();\n      st.push(num);\n    }else if(s[p]=='-'){\n      p++;\n      mat num=getNum();\n      for(int i=0;i<(int)num.size();i++)\n        num[i].first*=-1;\n      st.push(num);\n      \n    }else if(s[p]==')'){\n      break;\n    }else{\n      mat num=getNum();\n      mat A=st.top();\n      st.pop();\n      st.push( mul(A,num) );\n      \n    }\n  }\n  mat res=st.top();\n  st.pop();\n  while(!st.empty()){\n    res=add(res,st.top());\n    st.pop();\n  }\n\n  for(int i=0;i<(int)res.size();i++){\n    sort(res[i].second.begin(),res[i].second.end());\n  }\n  sort(res.begin(),res.end());\n  return res;\n}\n\nint main(){\n  while(1){\n    getline(cin,s);\n    if(s==\".\")break;\n    p=0;len=s.size();\n    target=solve();\n    \n    while(1){\n      getline(cin,s);\n      if(s==\".\")break;\n      p=0;len=s.size();\n      mat tmp=solve();\n      if(target==tmp)cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    cout<<'.'<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n\n#define fprintf(...) void(0)\n\nclass Poly {\n  std::map<std::string, int> coefs;\n  // e.g. coefs[\"aab\"] == 2 <=> the polynomial has the term 2 a^2 b\n  const std::string s;\n\n  Poly &operator ^=(const Poly &oth) {\n    if (oth.coefs.size() == 1 && oth.coefs.find(\"\") != oth.coefs.end()) {\n      return (*this) ^= oth.coefs.find(\"\")->second;\n    } else if (oth.coefs.empty()) {\n      // means 0\n      coefs.clear();\n      coefs[\"\"] = 1;  // means 1\n      return (*this);\n    }\n\n    assert(false);\n  }\n\n  Poly &op_eq(char op, const Poly &rhs) {\n    // (*this) @= rhs\n    switch (op) {\n      case '+': return (*this) += rhs;\n      case '-': return (*this) -= rhs;\n      case '*': return (*this) *= rhs;\n      case '^': return (*this) ^= rhs;\n      default: assert(false);\n    }\n  }\n\n  Poly fourt(\n      size_t &i, \n      const std::vector<std::string> &ops={\"+-\", \"*\", \"^\", \"\"},\n      size_t prec=0) {\n\n    if (ops[prec].empty()) {\n      if (s[i] == '(') {\n        Poly tmp=fourt(++i, ops, 0);\n        assert(s[i] == ')');\n        ++i;\n        return tmp;\n      }\n      if (isalpha(s[i])) {\n        // we assume only one-character variables\n        return Poly(s[i++]);\n      }\n      int coef=0;\n      while (s[i] >= '0' && s[i] <= '9')\n        coef = coef*10 + s[i++]-'0';\n      return Poly(coef);\n    }\n\n    Poly res=fourt(i, ops, prec+1);\n    while (i < s.length()) {\n      char op=s[i];\n      if (!std::count(ops[prec].begin(), ops[prec].end(), op))\n        break;\n      Poly tmp=fourt(++i, ops, prec+1);\n      res.op_eq(op, tmp);\n    }\n    return res;\n  }\n\n  Poly &normalized() {\n    for (auto it=coefs.begin(); it!=coefs.end(); ++it) {\n      if (it->second == 0) {\n        fprintf(stderr, \"Removed: %s\\n\", it->first.c_str());\n        coefs.erase(it);\n      }\n    }\n    return *this;\n  }\n\npublic:\n  Poly(const std::string &s): s(s) {\n    size_t i=0;\n    coefs = fourt(i).coefs;  // ugh\n  }\n\n  Poly(char ch): s(1, ch) {\n    assert(isalpha(ch));\n    coefs[s] = 1;\n  }\n\n  Poly(int n): s(std::to_string(n)) {\n    if (n)\n      coefs[\"\"] = n;\n  }\n\n  Poly &operator +=(const Poly &oth) {\n    for (const auto &p: oth.coefs) {\n      const std::string &param=p.first;\n      int coef=p.second;\n      coefs[param] += coef;\n    }\n    return normalized();\n  }\n\n  Poly &operator -=(const Poly &oth) {\n    for (const auto &p: oth.coefs) {\n      const std::string &param=p.first;\n      int coef=p.second;\n      coefs[param] -= coef;\n    }\n    return normalized();\n  }\n\n  Poly &operator *=(const Poly &oth) {\n    Poly tmp(*this);\n    coefs.clear();\n    for (const auto &pl: tmp.coefs) {\n      for (const auto &pr: oth.coefs) {\n        std::string param=pl.first+pr.first;\n        std::sort(param.begin(), param.end());\n        coefs[param] += pl.second*pr.second;\n      }\n    }\n    return normalized();\n  }\n\n  Poly &operator ^=(int iexp) {\n    if (iexp == 0) {\n      // does not appear in #1233\n      coefs.clear();\n      coefs[\"\"] = 1;  // means 1\n    } else {\n      Poly tmp(*this);\n      for (int i=1; i<iexp; ++i)\n        // O(iexp) multiplications, ugh\n        *this *= tmp;\n    }\n    return normalized();\n  }\n\n  Poly operator +(const Poly &oth) const { return Poly(*this) += oth; }\n  Poly operator -(const Poly &oth) const { return Poly(*this) -= oth; }\n  Poly operator *(const Poly &oth) const { return Poly(*this) *= oth; }\n  Poly operator ^(int iexp) const { return Poly(*this) ^= iexp; }\n  bool operator ==(const Poly &oth) const { return coefs == oth.coefs; }\n\n  void debug() const {\n    if (coefs.empty()) {\n      fprintf(stderr, \"#> 0\\n\");\n      return;\n    }\n    fprintf(stderr, \"#>\");\n    for (const auto &p: coefs)\n      fprintf(stderr, \" %d%s\", p.second, p.first.c_str());\n    fprintf(stderr, \"\\n\");\n  }\n};\n\nstd::string normalize(const std::string &s) {\n  // explicit `*' signs and no spaces\n  std::string res;\n  enum {\n    NONE, PAREN, FACTOR, OPERATOR\n  } last=NONE;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '(') {\n      if (last == FACTOR) {\n        res += '*';\n      }\n      res += '(';\n      last = PAREN;\n    } else if (s[i] == ')') {\n      res += ')';\n      last = FACTOR;\n    } else if (isalnum(s[i])) {\n      if (last == FACTOR) {\n        res += '*';\n      }\n      res += s[i];\n      if (isdigit(s[i])) {\n        while (i+1 < s.length() && isdigit(s[i+1]))\n          res += s[++i];\n      }\n      last = FACTOR;\n    } else if (!isspace(s[i])) {\n      res += s[i];\n      last = OPERATOR;\n    }\n  }\n  fprintf(stderr, \"#< %s\\n\", res.c_str());\n  return res;\n}\n\nint testcase_ends() {\n  char buf[96];\n  fgets(buf, sizeof buf, stdin);\n  std::string s=buf;\n  if (s == \".\\n\")\n    return 1;\n\n  s = normalize(s);\n  Poly ps(s);\n  ps.debug();\n  while (true) {\n    fgets(buf, sizeof buf, stdin);\n    std::string t=buf;\n    if (t == \".\\n\") {\n      printf(\".\\n\");\n      return 0;\n    }\n\n    t = normalize(t);\n    Poly pt(t);\n    pt.debug();\n    printf(\"%s\\n\", (ps == pt)? \"yes\":\"no\");\n  }\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\n\n\nstruct T{\n  map<string, Int> ms;\n  T(){}\n  T(string s, Int c){\n    sort(s.begin(),s.end());\n    ms[s]+=c;\n  }\n\n  T operator+=(const T &a){\n    for(auto p:a.ms)\n      ms[p.first]+=p.second;\n    return *this;\n  }\n  \n  T operator-=(const T &a){\n    for(auto p:a.ms)\n      ms[p.first]-=p.second;\n    return *this;\n  }\n  \n  T operator+(const T &a) const{\n    T res(*this);\n    return res+=a;\n  }\n  \n  T operator-(const T &a) const{\n    T res(*this);\n    return res-=a;\n  }\n  \n  T operator*(const T &a) const{\n    T res;\n    for(auto p:ms)\n      for(auto q:a.ms)\n        res+=T(p.first+q.first,p.second*q.second);\n    return res;\n  }\n\n  T pow(Int k) const{\n    assert(k>=1);\n    T res(*this);\n    for(Int i=1;i<k;i++) res=res*(*this);\n    return res;\n  }\n  \n  bool operator==(const T &a){\n    return ms==a.ms;\n  }\n};\n\nusing V = vector<string>; \nT expr  (const V &vs,Int &p);\nT term  (const V &vs,Int &p);\nT factor(const V &vs,Int &p);\nT power (const V &vs,Int &p);\nInt number(const V &vs,Int &p);\n\nT expr  (const V &vs,Int &p){\n  T res=term(vs,p);\n  while(p<(Int)vs.size()){\n    if(vs[p]==\"+\"s){\n      p++;\n      res=res+term(vs,p);\n      continue;\n    }\n    if(vs[p]==\"-\"s){\n      p++;\n      res=res-term(vs,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nT term  (const V &vs,Int &p){  \n  T res=factor(vs,p);\n  while(p<(Int)vs.size()){\n    if(vs[p]==\"+\"s) break;\n    if(vs[p]==\"-\"s) break;\n    if(vs[p]==\"^\"s) break;\n    if(vs[p]==\")\"s) break;\n    res=res*factor(vs,p);\n  }\n  return res;\n}\n\nT factor(const V &vs,Int &p){  \n  T res=power(vs,p);\n  if(p<(Int)vs.size()&&vs[p]==\"^\"s){\n    p++;\n    Int k=number(vs,p);\n    return res.pow(k);\n  }  \n  return res;\n}\n\nT power (const V &vs,Int &p){\n  if(vs[p]==\"(\"s){\n    p++;\n    T res=expr(vs,p);\n    assert(vs[p]==\")\"s);\n    p++;\n    return res;\n  }\n  if(isalpha(vs[p][0])) return T(vs[p++],1);\n  return T(\"\"s, number(vs,p));\n}\n\nInt number(const V &vs,Int &p){\n  return stoll(vs[p++]);\n}\n\nT tran(string s){\n  Int n=s.size();\n  string t;\n  for(Int i=0;i<n;i++){\n    if(!isdigit(s[i])) t+=' ';\n    t+=s[i];\n    if(!isdigit(s[i])) t+=' ';\n  }  \n  V vs;\n  stringstream ss(t);\n  while(ss>>t) vs.emplace_back(t);\n  Int p=0;\n  return expr(vs,p);\n}\n\nsigned main(){\n  string s;\n  while(getline(cin,s)){\n    if(s==\".\"s) break;\n    auto vs=tran(s);\n    while(1){\n      string t;\n      getline(cin,t);      \n      if(t==\".\"s) break;\n      auto vt=tran(t);\n      cout<<(vs==vt?\"yes\":\"no\")<<endl;\n    }    \n    cout<<\".\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ll;\n\nstring s;\nint p;\n\nll A[200][300];\nint idx;\n\nll bnf();\n\nll get_num(){\n\n  if(s[p]=='('){\n    \n    p++;\n\n    ll res=bnf();\n    \n    p++;\n\n    return res;\n  }\n  \n  if('a'<=s[p]&&s[p]<='z') return A[idx][s[p++]];\n  \n  ll num=0;\n  \n  while('0'<=s[p]&&s[p]<='9') num=num*10+s[p]-'0', p++;\n\n  return num;\n  \n}\n\nll bnf3(){\n\n  ll res=get_num();\n  \n  while(p<s.size()){\n\n    if(s[p]=='^'){\n\n      p++;\n\n      ll r=get_num();\n\n      ll tmp=1;\n\n      for(int i=0;i<r;i++) tmp*=res;\n\n      res=tmp;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nll bnf2(){\n\n  ll res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n\n      p++;\n\n      ll r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nll bnf(){\n\n  ll res=bnf2();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='+'){\n\n      p++;\n      \n      ll r=bnf2();\n      \n      res+=r;\n      \n    }\n    else if(s[p]=='-'){\n\n      p++;\n\n      ll r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nvoid change(){\n  \n  for(int i=0;i<s.size();i++)\n    if((s[i]==')'||('a'<=s[i]&&s[i]<='z')||('0'<=s[i]&&s[i]<='9')))\n      if((s[i+1]=='('||('a'<=s[i+1]&&s[i+1]<='z')||('0'<=s[i+1]&&s[i+1]<='9')))\n\tif(!('0'<=s[i]&&s[i]<='9'&&'0'<=s[i+1]&&s[i+1]<='9'))\n\t  s=s.substr(0,i+1)+'*'+s.substr(i+1);\n\n  \n  for(int i=0;i<s.size();i++)\n    \n    if(s[i]==' ')\n      \n      while(s[i]==' '&&i+1<s.size()&&s[i+1]==' ') s.erase(s.begin()+i);\n  \n\n  if(s[0]==' ') s.erase(s.begin());\n  \n  if(s[s.size()-1]==' ') s.erase(s.begin()+s.size()-1);\n\n  for(int i=0;i<s.size();i++)\n    if(s[i]==' ')\n      if((s[i-1]==')'||('a'<=s[i-1]&&s[i-1]<='z')||('0'<=s[i-1]&&s[i-1]<='9')))\n\tif((s[i+1]=='('||('a'<=s[i+1]&&s[i+1]<='z')||('0'<=s[i+1]&&s[i+1]<='9'))) s[i]='*';\n\n  for(int i=0;i<s.size();i++)\n    \n    if(s[i]==' ') s.erase(s.begin()+i), i--;\n  \n  \n}\n\nint main(){\n  \n  for(int T=0;T<200;T++)\n    \n    for(int i=0;i<300;i++) A[T][i]=rand();\n  \n  while(1){\n\n    string tmp=s;\n    \n    getline(cin,s);\n    \n    if(s==\".\") break;\n    \n    change();\n    \n    ll base[200];\n\n    for(int T=0;T<200;T++){\n      idx=T;\n      p=0;\n      base[T]=bnf();\n    }\n    \n    while(1){\n      \n      getline(cin,s);\n      \n      if(s==\".\"){\n\tcout<<\".\"<<endl;\n\tbreak;\n      }\n      \n      change();\n      \n      bool ans=true;\n      \n      for(int T=0;T<200;T++){\n          \n\tidx=T;  \n\tp=0;\n      \n\tll r=bnf();\n\t\n\tif(base[T]!=r) ans=false;\n\t\n      }\n      \n      if(ans) cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n      \n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\nusing namespace std;\nstring s,t;\nint p;\nmap<char,int>m;\nvoid convertS(){\n    r(i,s.size()){\n        if(i&&s[i]==' '){\n            if(s[i-1]==')'&&s[i+1]=='(')s[i]='*';\n            else if(isalpha(s[i-1])&&isalpha(s[i+1]))s[i]='*';\n            else if(s[i-1]==')'&&isalpha(s[i+1]))s[i]='*';\n            else if(isalpha(s[i-1])&&s[i+1]=='(')s[i]='*';\n            else if(s[i-1]==')'&&isdigit(s[i+1]))s[i]='*';\n            else if(isdigit(s[i-1])&&s[i+1]=='(')s[i]='*';\n            else if(isdigit(s[i-1])&&isalpha(s[i+1]))s[i]='*';\n            else if(isalpha(s[i-1])&&isdigit(s[i+1]))s[i]='*';\n            else if(isdigit(s[i-1])&&isdigit(s[i+1]))s[i]='*';\n            else s.erase(s.begin()+i--);\n        }\n        if(isdigit(s[i])&&isalpha(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(isalpha(s[i])&&isalpha(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(isalpha(s[i])&&isdigit(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(s[i]==')'&&isalpha(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(s[i]==')'&&isdigit(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(s[i+1]=='('&&isalpha(s[i]))s.insert(s.begin()+i+1,'*');\n        if(s[i+1]=='('&&isdigit(s[i]))s.insert(s.begin()+i+1,'*');\n        if(s[i+1]=='('&&s[i]==')')s.insert(s.begin()+i+1,'*');\n    }\n}\nvoid convertT(){\n    r(i,t.size()){\n        if(i&&t[i]==' '){\n            if(t[i-1]==')'&&t[i+1]=='(')t[i]='*';\n            else if(isalpha(t[i-1])&&isalpha(t[i+1]))t[i]='*';\n            else if(t[i-1]==')'&&isalpha(t[i+1]))t[i]='*';\n            else if(isalpha(t[i-1])&&t[i+1]=='(')t[i]='*';\n            else if(t[i-1]==')'&&isdigit(t[i+1]))t[i]='*';\n            else if(isdigit(t[i-1])&&t[i+1]=='(')t[i]=='*';\n            else if(isdigit(t[i-1])&&isalpha(t[i+1]))t[i]='*';\n            else if(isalpha(t[i-1])&&isdigit(t[i+1]))t[i]='*';\n            else if(isdigit(t[i-1])&&isdigit(t[i+1]))t[i]='*';\n            else t.erase(t.begin()+i--);\n        }\n        if(isdigit(t[i])&&isalpha(t[i+1]))t.insert(t.begin()+i+1,'*');\n        if(isalpha(t[i])&&isalpha(t[i+1]))t.insert(t.begin()+i+1,'*');\n        if(isalpha(t[i])&&isdigit(t[i+1]))t.insert(t.begin()+i+1,'*');\n        if(t[i]==')'&&isalpha(t[i+1]))t.insert(t.begin()+i+1,'*');\n        if(t[i]==')'&&isdigit(t[i+1]))t.insert(t.begin()+i+1,'*');\n        if(t[i+1]=='('&&isalpha(t[i]))t.insert(t.begin()+i+1,'*');\n        if(t[i+1]=='('&&isdigit(t[i]))t.insert(t.begin()+i+1,'*');\n        if(t[i+1]=='('&&t[i]==')')t.insert(t.begin()+i+1,'*');\n    }\n}\nint Sbnf1();\nint get_S(){\n    int res=0;\n    if(s[p]=='(')p++,res=Sbnf1(),p++;\n    else if(isdigit(s[p])){\n        while(isdigit(s[p])){\n            res=res*10+(s[p++]-'0');\n        }\n    }\n    else res=m[s[p++]];\n    return res%mod;\n}\nint Sbnf3(){\n    int res=get_S();\n    while(s[p]=='^'){\n        p++;\n        int ret=get_S(),kit=res;\n        r(i,ret-1){\n            res*=kit;\n            res=res%mod;\n        }\n    }\n    return res%mod;\n}\nint Sbnf2(){\n    int res=Sbnf3();\n    while(s[p]=='*'){\n        p++;\n        res*=Sbnf3();\n        res=res%mod;\n    }\n    return res%mod;\n}\nint Sbnf1(){\n    int res=Sbnf2();\n    while(s[p]=='+'||s[p]=='-'){\n        int pp=p++;\n        if(s[pp]=='+')res+=Sbnf2();\n        if(s[pp]=='-')res-=Sbnf2();\n        while(res<0)res+=mod;\n        res=res%mod;\n    }\n    return res%mod;\n}\nint Tbnf1();\nint get_T(){\n    int res=0;\n    if(t[p]=='(')p++,res=Tbnf1(),p++;\n    else if(isdigit(t[p])){\n        while(isdigit(t[p])){\n            res=res*10+(t[p++]-'0');\n        }\n    }\n    else res=m[t[p++]];\n    return res%mod;\n}\nint Tbnf3(){\n    int res=get_T();\n    while(t[p]=='^'){\n        p++;\n        int ret=get_T(),kit=res;\n        r(i,ret-1){\n            res*=kit;\n            res=res%mod;\n        }\n    }\n    return res%mod;\n}\nint Tbnf2(){\n    int res=Tbnf3();\n    while(t[p]=='*'){\n        p++;\n        res*=Tbnf3();\n        res=res%mod;\n    }\n    return res%mod;\n}\nint Tbnf1(){\n    int res=Tbnf2();\n    while(t[p]=='+'||t[p]=='-'){\n        int pp=p++;\n        if(t[pp]=='+')res+=Tbnf2();\n        if(t[pp]=='-')res-=Tbnf2();\n        while(res<0)res+=mod;\n        res=res%mod;\n    }\n    return res%mod;\n}\nmain(){\n    while(getline(cin,t)){\n        if(t==\".\")break;\n        convertT();\n        while(getline(cin,s)){\n            if(s==\".\"){\n                cout<<'.'<<endl;\n                break;\n            }\n            int flag = 0;\n            convertS();\n            r(i,100){\n                r(j,26)m[j+'a']=rand()%mod;\n                p=0;\n                int y=Tbnf1()%mod;\n                p=0;\n                int x=Sbnf1()%mod;\n                if(y!=x)flag++;\n            }\n            cout<<(flag?\"no\":\"yes\")<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double Val;\n\nconst Val EPS=1e-5;\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p));\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=double(rnd())/1e10;\n      }\n      Val cor=formula(state[0],p);\n      p=0;\n      Val ans=formula(state[i],p);\n      isok&=(abs(cor-ans)<cor*ans*EPS);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double Val;\n\nconst Val EPS=1e-8;\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p));\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=double(rnd())/1e8;\n      }\n      Val cor=formula(state[0],p);\n      p=0;\n      Val ans=formula(state[i],p);\n      isok&=(abs(cor-ans)<EPS);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    tmp.p[in[p]-'a']++;\n    //    while(p < in.size() && isalpha(in[p])){\n\n      p++;\n      //    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n\n    //debug\n    p=0;\n    in=pre_processing2(tmp);\n    formula me2=fact(in,p);\n    assert(is_same_formula(me,me2));\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      p=0;\n      cmp=pre_processing2(tmp);\n      formula you2=fact(cmp,p);\n      assert(is_same_formula(you,you2));\n\n      //      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (tmp.size()&&is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n\n  return ret;\n}\n\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n      //cout << \"formula :\"<<cmp<<endl;output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n/*\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n*/\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(tmp[0])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(tmp[0])){\n\tret=ret+'*'+tmp;\n      }\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(tmp[0])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(tmp[0])){\n\tret=ret+'*'+tmp;\n      }\n    }\n  }\n\n  return ret;\n}\n\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double EPS=1e-8;\nvector<long long int > var;\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\nlong long int formula(string &s,int &p);\n\nlong long int num(string &s,int &p){\n  long long int res=0;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nlong long int var_val(string &s,int &p){\n  long long int res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nlong long int get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    long long  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nlong long int term2(string &s,int &p){\n  long long int res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p))+EPS;\n  }\n  return res;\n}\n\nlong long int term1(string& s,int &p){\n  long long int res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    long long int val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nlong long int formula(string& s,int &p){\n  long long int res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    long long int val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%(TIME*TIME)-rnd()%(TIME*TIME);\n      }\n      long long int cor=formula(state[0],p);\n      p=0;\n      long long int ans=formula(state[i],p);\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double EPS=1e-8;\nvector<double> var;\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\ndouble formula(string &s,int &p);\n\ndouble num(string &s,int &p){\n  double res=0;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\ndouble var_val(string &s,int &p){\n  double res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\ndouble get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    double res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\ndouble term2(string &s,int &p){\n  double res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p));\n  }\n  return res;\n}\n\ndouble term1(string& s,int &p){\n  double res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip();\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    double val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\ndouble formula(string& s,int &p){\n  double res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    double val=term1(s,p);\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd();\n      }\n      double cor=formula(state[0],p);\n      p=0;\n      double ans=formula(state[i],p);\n      isok&=(abs(cor-ans)<EPS);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef pair<int,string> term;\n\nvector<term> add(const vector<term>& a,const vector<term>& b)\n{\n\tmap<string,int> f;\n\tfor(auto x:a){\n\t\tsort(all(x.second));\n\t\tf[x.second]+=x.first;\n\t}\n\tfor(auto x:b){\n\t\tsort(all(x.second));\n\t\tf[x.second]+=x.first;\n\t}\n\tvector<term> c;\n\tfor(auto p:f) if(p.second) c.emplace_back(p.second,p.first);\n\treturn c;\n}\n\nvector<term> mul(const vector<term>& a,const vector<term>& b)\n{\n\tmap<string,int> f;\n\tfor(auto x:a) for(auto y:b){\n\t\tstring s=x.second+y.second; sort(all(s));\n\t\tf[s]+=x.first*y.first;\n\t}\n\tvector<term> c;\n\tfor(auto p:f) if(p.second) c.emplace_back(p.second,p.first);\n\treturn c;\n}\n\nvector<term> pow(const vector<term>& a,int r)\n{\n\tvector<term> b(1,term(1,\"\"));\n\trep(i,r) b=mul(b,a);\n\treturn b;\n}\n\npair<vector<term>,int> parse_expr(string f,int i);\n\npair<vector<term>,int> parse_fact(string f,int i)\n{\n\twhile(i<f.size() && f[i]==' ') i++;\n\tvector<term> x;\n\tif(f[i]=='('){\n\t\ti++;\n\t\ttie(x,i)=parse_expr(f,i);\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t\ti++;\n\t}\n\telse if(isdigit(f[i])){\n\t\tint n=0;\n\t\twhile(i<f.size() && isdigit(f[i]))\n\t\t\tn=n*10+f[i++]-'0';\n\t\tx.emplace_back(n,\"\");\n\t}\n\telse if(isalpha(f[i])){\n\t\tx.emplace_back(1,f.substr(i,1));\n\t\ti++;\n\t}\n\t\n\twhile(i<f.size() && f[i]==' ') i++;\n\tif(i<f.size() && f[i]=='^'){\n\t\ti++;\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t\tint n=0;\n\t\twhile(i<f.size() && isdigit(f[i])){\n\t\t\tn=n*10+f[i]-'0';\n\t\t\ti++;\n\t\t}\n\t\tx=pow(x,n);\n\t}\n\treturn mp(x,i);\n}\n\npair<vector<term>,int> parse_term(string f,int i)\n{\n\twhile(i<f.size() && f[i]==' ') i++;\n\tvector<term> x; tie(x,i)=parse_fact(f,i);\n\twhile(i<f.size() && f[i]==' ') i++;\n\twhile(i<f.size() && (f[i]=='(' || isdigit(f[i]) || isalpha(f[i]))){\n\t\tvector<term> y; tie(y,i)=parse_fact(f,i);\n\t\tx=mul(x,y);\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t}\n\treturn mp(x,i);\n}\n\npair<vector<term>,int> parse_expr(string f,int i)\n{\n\twhile(i<f.size() && f[i]==' ') i++;\n\tvector<term> x; tie(x,i)=parse_term(f,i);\n\twhile(i<f.size() && f[i]==' ') i++;\n\twhile(i<f.size() && (f[i]=='+' || f[i]=='-')){\n\t\ti++;\n\t\tvector<term> y; tie(y,i)=parse_term(f,i);\n\t\tx=add(x,y);\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t}\n\treturn mp(x,i);\n}\n\nint main()\n{\n\tfor(string line;getline(cin,line) && line!=\".\";){\n\t\tvs fs;\n\t\tdo{\n\t\t\tfs.push_back(line);\n\t\t\tgetline(cin,line);\n\t\t}while(line!=\".\");\n\t\t\n\t\tauto t0=parse_expr(fs[0],0).first;\n\t\trepi(i,1,fs.size())\n\t\t\tcout<<(parse_expr(fs[i],0).first==t0?\"yes\":\"no\")<<endl;\n\t\tcout<<'.'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nbool is_operator(char c){\n  string opes = \"+-^*\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nstring preprocessing(string s){\n  stringstream ss(s);\n  string res;\n  ss >> res;\n  while(ss>>s){\n    char a = res[res.size() - 1];\n    char b = s[0];\n    if(is_operator(a) || is_operator(b)) res += s;\n    else res += \"*\" + s;\n  }\n  REP(i, res.size() - 1){\n    if((isalpha(res[i]) && isalpha(res[i + 1])) ||\n       (isdigit(res[i]) && isalpha(res[i + 1])) ||\n       (isalpha(res[i]) && isdigit(res[i + 1]))){\n      res.insert(++i, \"*\");\n    }\n  }\n  return res;\n}\ntypedef map<char,int> Var;\nVar mul(Var x, Var y){\n  FORIT(it, y){\n    x[it->first] += it->second;\n  }\n  return x;\n}\nstruct Result{\n  map<Var, int> value;\n  int p;\n  Result(map<Var, int> v, int p) : \n    value(v), p(p) {}\n};\nResult expression(const string& s, int p);\nResult term(const string& s, int p);\nResult factor(const string& s, int p);\nResult expression(const string& s, int p){\n  Result r = term(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result t = term(s, r.p + 1);\n    FORIT(it, t.value){\n      if(s[r.p] == '+') r.value[it->first] += it->second;\n      if(s[r.p] == '-') r.value[it->first] -= it->second;\n    }\n    r.p = t.p;\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  Result r = factor(s, p);\n  while(s[r.p] == '*'){\n    Result t = factor(s, r.p + 1);\n    map<Var, int> new_val;\n    FORIT(it1, r.value)FORIT(it2, t.value){\n      new_val[mul(it1->first, it2->first)] += it1->second * it2->second;\n    }\n    r.value = new_val;\n    r.p = t.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p){\n  if(s[p] == '('){\n    Result r = expression(s, p + 1);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(isdigit(s[p])){\n    int val = 0;\n    while(isdigit(s[p])){\n      val = val * 10 + s[p++] - '0';\n    }\n    map<Var, int> expr;\n    expr[ Var() ] = val;\n    return Result(expr, p);\n  }else if(isalpha(s[p])){\n    char c = s[p++];\n    if(s[p] == '^'){\n      p++;\n      int val = 0;\n      while(isdigit(s[p])){\n        val = val * 10 + s[p++] - '0';\n      }\n      map<Var, int> expr;\n      Var v; v[c] = val;\n      expr[v] = 1;\n      return Result(expr, p);\n    }else{\n      map<Var, int> expr;\n      Var v; v[c] = 1;\n      expr[v] = 1;\n      return Result(expr, p);\n    }\n  }else {\n    assert(s[p] != ' ');\n    assert(false);\n  }\n}\nint main(){\n  string line;\n  while(getline(cin, line) && line != \".\"){\n    line = preprocessing(line);\n    Result r = expression(line, 0);\n    map<Var, int> expr = r.value;\n    while(getline(cin, line) && line != \".\"){\n      line = preprocessing(line);\n      Result r = expression(line, 0);\n      map<Var, int> expr2 = r.value;\n      if(expr == expr2) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n    cout << \".\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(s[i-1] != '(' && s[i+1] != ')' && ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nmap<vector<int>, long long> calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        map<vector<int>, long long> ret;\n        long long tmp = 0;\n        for(int i=0; i<n; ++i){\n            tmp *= 10;\n            tmp += s[i] - '0';\n        }\n        if(tmp != 0)\n            ret[vector<int>(26, 0)] = tmp;\n        return ret;\n    }\n\n    if(n == 1){\n        map<vector<int>, long long> ret;\n        vector<int> tmp(26, 0);\n        tmp[s[0]-'a'] = 1;\n        ret[tmp] = 1;\n        return ret;\n    }\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                map<vector<int>, long long> a = calculate(t1);\n                map<vector<int>, long long> b = calculate(t2);\n\n                map<vector<int>, long long> ret;\n                if(i == 0){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it){\n                        ret[it->first] += it->second;\n                        if(ret[it->first] == 0)\n                            ret.erase(it->first);\n                    }\n                }else if(i == 1){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it){\n                        ret[it->first] -= it->second;\n                        if(ret[it->first] == 0)\n                            ret.erase(it->first);\n                    }\n                }else if(i == 2){\n                    for(map<vector<int>, long long>::iterator it1=a.begin(); it1!=a.end(); ++it1){\n                        for(map<vector<int>, long long>::iterator it2=b.begin(); it2!=b.end(); ++it2){\n                            vector<int> tmp(26);\n                            for(int k=0; k<26; ++k)\n                                tmp[k] = it1->first[k] + it2->first[k];\n                            ret[tmp] += it1->second * it2->second;\n                        }\n                    }\n                }else{\n                    vector<int> tmp(26);\n                    for(int k=0; k<26; ++k)\n                        tmp[k] = a.begin()->first[k] * b.begin()->second;\n                    ret[tmp] = 1;\n                }\n                return ret;\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        s = normalize(s);\n        map<vector<int>, long long> a = calculate(s);\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            t = normalize(t);\n            map<vector<int>, long long> b = calculate(t);\n            if(a == b)\n                cout << \"yes\" << endl;\n            else\n                cout << \"no\" << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define LIMIT 1000\n\n\nenum Type{\n\tNONE,\n\tNUMBER,\n\tOPEN,\n\tCLOSE,\n\tALPHABET,\n\tPOWER,\n\tSPACE,\n\tPLUS_MINUS,\n};\n\n\nll value[3][26],simpson[3];\nchar buf[1001],mid[20000],line[20000];\n\nll calc_line(){\n\n\tll n,tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\tnegFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(negFLG){\n\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\tnegFLG = false;\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push((tmp*op1)%MOD);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp%MOD);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '/' || line[k-1] == '(')){\n\t\t\t\t\tnegFLG = true;\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork %= MOD;\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && OP.top() == '*'){\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork *= work2;\n\t\t\t\t}else if(OP.empty() == false &&OP.top() == '/'){\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork = work2/work;\n\t\t\t\t}\n\t\t\t\twork %= MOD;\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}else{\n\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork %= MOD;\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn (work+MOD)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1; //must not reach here\n}\n\nvoid make_mid(){\n\n\tint mid_index = 0;\n\tchar pre_ch;\n\n\tType pre = NONE,current;\n\n\tfor(int i = 0; buf[i] != '\\n' && buf[i] != '\\0';){\n\n\t\tswitch(buf[i]){\n\t\tcase ' ':\n\n\t\t\twhile(buf[i] == ' ')i++;\n\n\t\t\tswitch(buf[i]){\n\t\t\tcase '(':\n\t\t\t\tcurrent = OPEN;\n\t\t\t\tif(pre == NUMBER || pre == ALPHABET || pre == CLOSE){\n\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t}\n\t\t\t\tmid[mid_index++] = '(';\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tcurrent = CLOSE;\n\t\t\t\tmid[mid_index++] = ')';\n\t\t\t\tbreak;\n\t\t\tcase '^':\n\t\t\t\tcurrent = POWER;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\t\tcurrent = PLUS_MINUS;\n\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(buf[i] >= '0' && buf[i] <= '9'){\n\t\t\t\t\tif(pre == POWER){\n\t\t\t\t\t\tcurrent = ALPHABET;\n\t\t\t\t\t\tfor(int k = 0; k < ((buf[i]-'0')-1); k++){\n\t\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t\t\tmid[mid_index++] = pre_ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(pre == NUMBER || pre == ALPHABET|| pre == CLOSE){\n\t\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrent = NUMBER;\n\t\t\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcurrent = ALPHABET;\n\n\t\t\t\t\tif(pre == NUMBER || pre == ALPHABET|| pre == CLOSE){\n\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t}\n\t\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\t\tpre_ch = buf[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tcurrent = OPEN;\n\t\t\tif(pre == CLOSE || pre == NUMBER || pre == ALPHABET){\n\t\t\t\tmid[mid_index++] = '*';\n\t\t\t}\n\t\t\tmid[mid_index++] = '(';\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tcurrent = CLOSE;\n\t\t\tmid[mid_index++] = ')';\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '^':\n\t\t\tcurrent = POWER;\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '+':\n\t\tcase '-':\n\t\t\tcurrent = PLUS_MINUS;\n\t\t\tmid[mid_index++] = buf[i];\n\t\t\ti++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif(buf[i] >= '0' && buf[i] <= '9'){\n\t\t\t\tif(pre == POWER){\n\t\t\t\t\tcurrent = ALPHABET;\n\t\t\t\t\tfor(int k = 0; k < ((buf[i]-'0')-1); k++){\n\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t\tmid[mid_index++] = pre_ch;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\tif(pre == ALPHABET || pre == CLOSE){\n\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t}\n\t\t\t\t\tcurrent = NUMBER;\n\t\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcurrent = ALPHABET;\n\n\t\t\t\tif(pre == NUMBER || pre == ALPHABET || pre == CLOSE){\n\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t}\n\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\tpre_ch = buf[i];\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tpre = current;\n\t}\n\tmid[mid_index] = '\\0';\n}\n\nvoid make_line(int num){\n\n\tint line_index = 0;\n\n\tstack<char> S;\n\n\tfor(int i = 0; mid[i] != '\\0'; i++){\n\n\t\tif(mid[i] >= 'a' && mid[i] <= 'z'){\n\n\t\t\tint tmp = value[num][mid[i]-'a'];\n\n\t\t\twhile(tmp != 0){\n\t\t\t\tS.push('0'+(tmp%10));\n\t\t\t\ttmp /= 10;\n\t\t\t}\n\n\t\t\twhile(!S.empty()){\n\t\t\t\tline[line_index++] = S.top();\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}else{\n\t\t\tline[line_index++] = mid[i];\n\t\t}\n\t}\n\tline[line_index] = '=';\n\tline[line_index+1] = '\\0';\n}\n\nvoid func(){\n\n\tmake_mid();\n\n\tfor(int i = 0; i < 3; i++){\n\t\tmake_line(i);\n\t\tsimpson[i] = calc_line();\n\t}\n\n\tbool FLG;\n\tll tmp;\n\n\twhile(true){\n\t\tfgets(buf,1000,stdin);\n\t\tif(buf[0] == '.')break;\n\n\t\tFLG = true;\n\n\t\tmake_mid();\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tmake_line(i);\n\t\t\ttmp = calc_line();\n\t\t\tif(tmp != simpson[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(FLG){\n\t\t\tprintf(\"yes\\n\");\n\t\t}\n\t}\n\tprintf(\".\\n\");\n}\n\n\nint main(){\n\n\tll table[LIMIT];\n\tfor(ll i = 0; i < LIMIT; i++){\n\t\ttable[i] = 1;\n\t}\n\ttable[0] = 0;\n\ttable[1] = 0;\n\n\tfor(ll i = 2; i <= sqrt(LIMIT); i++){\n\t\tif(table[i] == 1){\n\t\t\tfor(ll k = 2*i; k < LIMIT; k += i){\n\t\t\t\ttable[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tll prime[LIMIT],prime_index = 0;\n\tfor(ll i = 2; i < LIMIT; i++){\n\t\tif(table[i] == 1){\n\t\t\tprime[prime_index++] = i;\n\t\t}\n\t}\n\n\tfor(ll i = 0; i < 3; i++){\n\t\tll base = 7*(i+1);\n\n\t\tfor(ll k = 0; k < 26; k++){\n\t\t\tvalue[i][k] = prime[base+k];\n\t\t}\n\t}\n\n\n\twhile(true){\n\t\tfgets(buf,1000,stdin);\n\t\tif(buf[0] == '.')break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\nusing namespace std;\nstring s,t;\nint p;\nmap<char,int>m;\nvoid convertS(){\n    r(i,s.size()){\n        if(i&&s[i]==' '){\n            if(s[i-1]==')'&&s[i+1]=='(')s[i]='*';\n            else if(isalpha(s[i-1])&&isalpha(s[i+1]))s[i]='*';\n            else if(s[i-1]==')'&&isalpha(s[i+1]))s[i]='*';\n            else if(isalpha(s[i-1])&&s[i+1]=='(')s[i]='*';\n            else if(s[i-1]==')'&&isdigit(s[i+1]))s[i]='*';\n            else if(isdigit(s[i-1])&&s[i+1]=='(')s[i]='*';\n            else if(isdigit(s[i-1])&&isalpha(s[i+1]))s[i]='*';\n            else if(isalpha(s[i-1])&&isdigit(s[i+1]))s[i]='*';\n            else if(isdigit(s[i-1])&&isdigit(s[i+1]))s[i]='*';\n            else s.erase(s.begin()+i--);\n        }\n        if(isdigit(s[i])&&isalpha(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(isalpha(s[i])&&isalpha(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(isalpha(s[i])&&isdigit(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(s[i]==')'&&isalpha(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(s[i]==')'&&isdigit(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(s[i+1]=='('&&isalpha(s[i]))s.insert(s.begin()+i+1,'*');\n        if(s[i+1]=='('&&isdigit(s[i]))s.insert(s.begin()+i+1,'*');\n        if(s[i+1]=='('&&s[i]==')')s.insert(s.begin()+i+1,'*');\n    }\n}\nvoid convertT(){\n    r(i,t.size()){\n        if(i&&t[i]==' '){\n            if(t[i-1]==')'&&t[i+1]=='(')t[i]='*';\n            else if(isalpha(t[i-1])&&isalpha(t[i+1]))t[i]='*';\n            else if(t[i-1]==')'&&isalpha(t[i+1]))t[i]='*';\n            else if(isalpha(t[i-1])&&t[i+1]=='(')t[i]='*';\n            else if(t[i-1]==')'&&isdigit(t[i+1]))t[i]='*';\n            else if(isdigit(t[i-1])&&t[i+1]=='(')t[i]=='*';\n            else if(isdigit(t[i-1])&&isalpha(t[i+1]))t[i]='*';\n            else if(isalpha(t[i-1])&&isdigit(t[i+1]))t[i]='*';\n            else if(isdigit(t[i-1])&&isdigit(t[i+1]))t[i]='*';\n            else t.erase(t.begin()+i--);\n        }\n        if(isdigit(t[i])&&isalpha(t[i+1]))t.insert(t.begin()+i+1,'*');\n        if(isalpha(t[i])&&isalpha(t[i+1]))t.insert(t.begin()+i+1,'*');\n        if(isalpha(t[i])&&isdigit(t[i+1]))t.insert(t.begin()+i+1,'*');\n        if(t[i]==')'&&isalpha(t[i+1]))t.insert(t.begin()+i+1,'*');\n        if(t[i]==')'&&isdigit(t[i+1]))t.insert(t.begin()+i+1,'*');\n        if(t[i+1]=='('&&isalpha(t[i]))t.insert(t.begin()+i+1,'*');\n        if(t[i+1]=='('&&isdigit(t[i]))t.insert(t.begin()+i+1,'*');\n        if(t[i+1]=='('&&t[i]==')')t.insert(t.begin()+i+1,'*');\n    }\n}\nint Sbnf1();\nint get_S(){\n    int res=0;\n    if(s[p]=='(')p++,res=Sbnf1(),p++;\n    else if(isdigit(s[p])){\n        while(isdigit(s[p])){\n            res=res*10+(s[p++]-'0');\n        }\n    }\n    else res=m[s[p++]];\n    return res%mod;\n}\nint Sbnf3(){\n    int res=get_S();\n    while(s[p]=='^'){\n        p++;\n        int ret=get_S(),kit=res;\n        r(i,ret-1){\n            res*=kit;\n            res=res%mod;\n        }\n    }\n    return res%mod;\n}\nint Sbnf2(){\n    int res=Sbnf3();\n    while(s[p]=='*'){\n        p++;\n        res*=Sbnf3();\n        res=res%mod;\n    }\n    return res%mod;\n}\nint Sbnf1(){\n    int res=Sbnf2();\n    while(s[p]=='+'||s[p]=='-'){\n        int pp=p++;\n        if(s[pp]=='+')res+=Sbnf2();\n        if(s[pp]=='-')res-=Sbnf2();\n        while(res<0)res+=mod;\n        res=res%mod;\n    }\n    return res%mod;\n}\nint Tbnf1();\nint get_T(){\n    int res=0;\n    if(t[p]=='(')p++,res=Tbnf1(),p++;\n    else if(isdigit(t[p])){\n        while(isdigit(t[p])){\n            res=res*10+(t[p++]-'0');\n        }\n    }\n    else res=m[t[p++]];\n    return res%mod;\n}\nint Tbnf3(){\n    int res=get_T();\n    while(t[p]=='^'){\n        p++;\n        int ret=get_T(),kit=res;\n        r(i,ret-1){\n            res*=kit;\n            res=res%mod;\n        }\n    }\n    return res%mod;\n}\nint Tbnf2(){\n    int res=Tbnf3();\n    while(t[p]=='*'){\n        p++;\n        res*=Tbnf3();\n        res=res%mod;\n    }\n    return res%mod;\n}\nint Tbnf1(){\n    int res=Tbnf2();\n    while(t[p]=='+'||t[p]=='-'){\n        int pp=p++;\n        if(t[pp]=='+')res+=Tbnf2();\n        if(t[pp]=='-')res-=Tbnf2();\n        while(res<0)res+=mod;\n        res=res%mod;\n    }\n    return res%mod;\n}\nmain(){\n    while(getline(cin,t)){\n        if(t==\".\")break;\n        convertT();\n        while(getline(cin,s)){\n            if(s==\".\"){\n                cout<<'.'<<endl;\n                break;\n            }\n            int flag = 0;\n            convertS();\n            r(i,7){\n                r(j,26)m[j+'a']=rand()%mod;\n                p=0;\n                int y=Tbnf1()%mod;\n                p=0;\n                int x=Sbnf1()%mod;\n                if(y!=x)flag++;\n            }\n            cout<<(flag?\"no\":\"yes\")<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nll expr(string& s, int& i);\nll term1(string& s, int& i);\nll term(string& s, int& i);\nll factor(string& s, int& i);\nll number(string& s, int& i);\n\nbool isdigit(char t) {\n\treturn '0' <= t && t <= '9';\n}\nbool isalf(char t) {\n\treturn 'a' <= t && t <= 'z';\n}\n\nll mod_pow(ll x, int n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\n\nll expr(string& s, int& i) {\n\tll val = term1(s, i);\n\twhile (i < s.length()) {\n\t\tif (s[i] == ' ') {\n\t\t\ti++; continue;\n\t\t}\n\t\tif (s[i] == '+' || s[i] == '-') {\n\t\t\tchar op = s[i];\n\t\t\ti++;\n\t\t\tll val2 = term1(s, i);\n\t\t\tif (op == '+') {\n\t\t\t\tval += val2; if (val >= mod)val -= mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval += mod - val2; while (val >= mod)val -= mod;\n\t\t\t}\n\t\t}\n\t\telse break;\n\t}\n\t//cout << i << \" expr \" << val << endl;\n\treturn val;\n}\nll term1(string& s, int& i) {\n\tll val = term(s, i);\n\twhile (i < s.length() && s[i] == ' ')i++;\n\tif (i >= s.length() || s[i] == '+' || s[i] == '-'||s[i]==')') {\n\t\treturn val;\n\t}\n\telse {\n\t\tll val2 = term1(s, i);\n\t\tval = val * val2%mod;\n\t}\n\t//cout << i << \" term1 \" << val << endl;\n\treturn val;\n}\nll term(string& s, int& i) {\n\tll val = factor(s, i);\n\twhile (i < s.length() && s[i] == ' ')i++;\n\tif (i<s.length() && s[i] == '^') {\n\t\ti++;\n\t\tll val2 = number(s, i);\n\t\tval = mod_pow(val, val2);\n\t}\n\t//cout << i << \" term \" << val << endl;\n\treturn val;\n}\nll factor(string& s, int& i) {\n\twhile (i < s.length() && s[i] == ' ')i++;\n\tif (i<s.length() && isdigit(s[i]))return number(s, i);\n\ti++;\n\twhile (i < s.length() && s[i] == ' ')i++;\n\tll ret = expr(s, i);\n\ti++;\n\twhile (i < s.length() && s[i] == ' ')i++;\n\t//cout << i << \" fact \" << ret << endl;\n\treturn ret;\n}\nll number(string& s, int& i) {\n\twhile (s[i] == ' ')i++;\n\tll ret = s[i++] - '0';\n\twhile (i < s.length() && isdigit(s[i])) {\n\t\tret = ret * 10 + s[i++] - '0';\n\t\tret %= mod;\n\t}\n\t//cout << i << \" numb \" << ret << endl;\n\treturn ret;\n}\n\nvector<vector<ll>> gene(int len) {\n\trandom_device rnd;\n\tmt19937 mt(rnd());\n\tuniform_int_distribution<> u(0, 2147483647);\n\tvector<vector<ll>> ret(len);\n\trep(i, len) {\n\t\tret[i].resize(26);\n\t\trep(j, 26) {\n\t\t\tret[i][j] = u(mt);\n\t\t}\n\t}\n\treturn ret;\n}\n\nll calc(string s, vector<ll> t) {\n\tstring upd;\n\trep(i, s.length()) {\n\t\tif (isalf(s[i])) {\n\t\t\tstring u = to_string(t[s[i] - 'a']);\n\t\t\tupd.push_back(' ');\n\t\t\tupd = upd + u;\n\t\t}\n\t\telse if (isdigit(s[i])) {\n\t\t\tint le = i;\n\t\t\twhile (i + 1 < s.length() && isdigit(s[i + 1]))i++;\n\t\t\tupd.push_back(' ');\n\t\t\tRep1(j, le, i)upd.push_back(s[j]);\n\t\t}\n\t\telse {\n\t\t\tupd.push_back(s[i]);\n\t\t}\n\t}\n\tint i = 0;\n\t//cout << s << endl;\n\t//cout << upd << endl;\n\t//cout << upd << endl;\n\treturn expr(upd, i);\n}\n\nconst int sz = 100;\nbool solve() {\n\tstring s;\n\tvector<string> v;\n\twhile (getline(cin, s)) {\n\t\tif (s[0] == '.') {\n\t\t\tbreak;\n\t\t}\n\t\tv.push_back(s);\n\t}\n\tif (v.size() == 0)return false;\n\tvector<vector<ll>> test = gene(sz);\n\tvector<vector<ll>> ans(v.size());\n\trep(i, v.size()) {\n\t\tans[i].resize(sz);\n\t\trep(j, sz) {\n\t\t\tans[i][j] = calc(v[i], test[j]);\n\t\t\t//cout << i << \" \" << ans[i][j] << endl;\n\t\t}\n\t}\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tbool f = (ans[i] == ans[0]);\n\t\tif (f) {\n\t\t\tcout << \"yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"no\" << endl;\n\t\t}\n\t}\n\tcout << \".\" << endl;\n\treturn true;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t/*string s = \"a+b+c\";\n\tstring ss = \"(a+b)+c\";\n\tvector<ll> c(26, 0); c[0] = 1, c[1] = 2; c[2] = 3;\n\tcout << calc(s, c) << endl;\n\tcout << calc(ss, c) << endl;*/\n\n\t//cout << fixed << setprecision(10);\n\t//init();\n\twhile (true) {\n\t\tif (!solve())break;\n\t}\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef __int128  Val;\n\nconst Val MOD=1e18+9;\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    res%=MOD;\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    res%=MOD;\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    Val val=term2(s,p);\n    Val a=res;\n    res=1;\n    for(int i=0;i<val;i++){\n      res*=a;\n      res%=MOD;\n    }\n    return res;\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n    res%=MOD;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n    if(op=='+') res+=val;\n    else res-=val;\n    res%=MOD;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%TIME;\n      }\n      Val cor=formula(state[0],p);\n      cor%=MOD;\n      cor+=MOD;\n      cor%=MOD;\n      p=0;\n      Val ans=formula(state[i],p);\n      ans%=MOD;\n      ans+=MOD;\n      ans%=MOD;\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nusing K = string;\nusing M = map<K, int>;\n\nK mul(K k1, K k2){\n\tk1 += k2;\n\tsort(k1.begin(), k1.end());\n\treturn k1;\n}\n\nM add(M m1, M m2){\n\tfor(auto v : m2){\n\t\tm1[v.first] += v.second;\n\t}\n\treturn m1;\n}\n\nM mul(M m1, M m2){\n\tM ret;\n\tfor(const auto& v1 : m1){\n\t\tfor(const auto& v2 : m2){\n\t\t\tK k = mul(v1.first, v2.first);\n\t\t\tret[k] += v1.second * v2.second;\n\t\t}\n\t}\n\treturn ret;\n}\n\nM pow(M m, int x){\n\tM ret;\n\tret[\"\"] = 1;\n\tM a = m;\n\twhile(x){\n\t\tif(x & 1) ret = mul(ret, a);\n\t\tx /= 2;\n\t\ta = mul(a, a);\n\t}\n\treturn ret;\n}\n\nint c;\nint N;\nstring s;\n\nM exp();\nM term();\nM fact();\n\nvoid skip(){\n\twhile(c < N && (s[c] == ' ')) c++;\n}\n\nM exp(){\n\tskip();\n\tM t1 = term();\n\n\tskip();\n\twhile(c < N && (s[c] == '+' || s[c] == '-')){\n\t\tchar ch = s[c];\n\t\tc++;\n\t\tskip();\n\t\tM t2 = term();\n\t\tif(ch == '-'){\n\t\t\tfor(auto& v : t2){\n\t\t\t\tv.second *= -1;\n\t\t\t}\n\t\t}\n\t\tt1 = add(t1, t2);\n\t}\n\treturn t1;\n}\n\nM term(){\n\tskip();\n\tM f1 = fact();\n\tskip();\n\twhile(c < N && (isalnum(s[c]) || s[c] == '(')){\n\t\tM f2 = fact();\n\t\tskip();\n\t\tf1 = mul(f1, f2);\n\t}\n\treturn f1;\n}\n\nM fact(){\n\tskip();\n\tM r;\n\tif(s[c] == '('){\n\t\tc++;\n\t\tr = exp();\n\t\tc++;\n\t\tskip();\n\t}\n\telse if(isalpha(s[c])){\n\t\tK k;\n\t\tk += s[c];\n\t\tc++;\n\t\tr[k]++;\n\t}\n\telse if(isdigit(s[c])){\n\t\tint x = 0;\n\t\twhile(c < N && isdigit(s[c])){\n\t\t\tx = x * 10 + s[c] - '0';\n\t\t\tc++;\n\t\t}\n\t\tr[\"\"] += x;\n\t}\n\tskip();\n\tif(c < N && s[c] == '^'){\n\t\tc++;\n\t\tskip();\n\t\tint x = s[c] - '0';\n\t\tc++;\n\t\tskip();\n\t\tr = pow(r, x);\n\t}\n\treturn r;\n}\n\nM f(string t){\n\tc = 0;\n\ts = t;\n\tN = s.size();\n\treturn exp();\n}\n\nM filter(M m){\n\tM ret;\n\tfor(auto v : m){\n\t\tif(v.second == 0) continue;\n\t\tret[v.first] = v.second;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\t//auto ret = f(\"a- (b-c)+2\");\n\n\tstring x, y;\n\twhile(getline(cin, x), x != \".\"){\n\t\tM xm = filter(f(x));\n\t\twhile(getline(cin, y), y != \".\"){\n\t\t\tauto res = filter(f(y));\n\t\t\tif(xm == res){\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << \"no\" << endl;\n\t\t\t}\n\t\t}\n\t\tcout << \".\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double EPS=1e-8;\nvector<double> var;\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\ndouble formula(string &s,int &p);\n\ndouble num(string &s,int &p){\n  double res=0;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\ndouble var_val(string &s,int &p){\n  double res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\ndouble get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    double res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\ndouble term2(string &s,int &p){\n  double res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p));\n  }\n  return res;\n}\n\ndouble term1(string& s,int &p){\n  double res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    double val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\ndouble formula(string& s,int &p){\n  double res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    double val=term1(s,p);\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=10000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd();\n      }\n      double cor=formula(state[0],p);\n      p=0;\n      double ans=formula(state[i],p);\n      isok&=(abs(cor-ans)<EPS);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\n#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  //if (ret.size() == 0)ret.pb(ori);\n}\n\nbool is_same_formula(formula a,formula b){\n  erase_duplicate(a);\n  erase_duplicate(b);\n  if (a.size() != b.size())return false;\n  if (a.size() == 1 && b.size() == 1){\n    //if (a[0].c == 0 && b[0].c == 0)return true;\n  }\n\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n    \n  }\n  if (b.size() == 0)return true;\n  else return false;\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    tmp.p[in[p]-'a']++;\n      p++;\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n/*\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n  return ret;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\ntypedef vector<pair<int,map<string,int> > > express;\n\nstring processSpace(const string &str){\n    string res=\"\";\n    bool sp=false;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i]!=' '){\n            if(!sp&&res.size()!=0&&(res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                &&(str[i]>='0'&&str[i]<='9')){\n\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&(str[i]=='(')){\n                    res+='*';\n            }\n            else if(res.size()!=0&&(res[res.size()-1]==')')\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&res[res.size()-1]==')'&&str[i]=='(')\n                res+='*';\n            res+=str[i];\n            sp=false;\n        }\n        else{\n            sp=true;\n        }\n    }\n    return res;\n}\n\nexpress analysis(string str){\n    express res;\n    if(str.size()==0)return res;\n    bool allNum=true;\n    for(int i = 0; i < str.size(); i++){\n        if(!(str[i]>='0'&&str[i]<='9')){\n            allNum=false;\n            break;\n        }\n    }\n    if(allNum){\n        int num=atoi(str.c_str());\n        if(num!=0)\n            res.push_back(make_pair(num,map<string,int>()));\n        return res;\n    }\n    if(str.size()==1&&str[0]>='a'&&str[0]<='z'){\n        map<string,int> msi;\n        string tmp;\n        tmp+=(str[0]);\n        msi[tmp]=1;\n        res.push_back(make_pair(1,msi));\n        return res;\n    }\n    if(str[0]=='('){\n        int cnt=0;\n        bool no=false;\n        for(int i = 1; i < str.size()-1; i++){\n            if(str[i]==')')\n                cnt--;\n            else if(str[i]=='(')\n                cnt++;\n            if(cnt<0){\n                no=true;\n                break;\n            }\n        }\n        if(!no)\n            return analysis(str.substr(1,str.size()-2));\n    }\n    int cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='+'||str[i]=='-'){\n                express left=analysis(str.substr(0,i));\n                express right=analysis(str.substr(i+1));\n                for(int j = 0; j < left.size(); j++){\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==left[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+left[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-left[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no)\n                        res.push_back(left[j]);\n                }\n                for(int j = 0; j < right.size(); j++){\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==right[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+right[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-right[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no){\n                        if(str[i]=='-')right[j].first*=-1;\n                        res.push_back(right[j]);\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='*'){\n                express left=analysis(str.substr(0,i));\n                express right=analysis(str.substr(i+1));\n                for(int k = 0; k < left.size(); k++){\n                    for(int j = 0; j < right.size(); j++){\n                        int co=left[k].first*right[j].first;\n                        map<string,int> literals=left[k].second;\n                        for(map<string,int>::iterator it=right[j].second.begin();it!=right[j].second.end();it++)\n                            literals[it->first]+=it->second;\n                        pair<int,map<string,int> > p=make_pair(co,literals);\n                        bool no=false;\n                        for(int l = 0; l < res.size(); l++){\n                            if(p.second==res[l].second){\n                                int coSum=p.first+res[l].first;\n                                if(coSum==0){\n                                    res.erase(res.begin()+l);\n                                    no=true;\n                                    break;\n                                }\n                                else{\n                                    res[l].first=coSum;\n                                    no=true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!no)\n                            res.push_back(p);\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='^'){\n                express left=analysis(str.substr(0,i));\n                express right=analysis(str.substr(i+1));\n                map<string,int> msi;\n                msi[left[0].second.begin()->first]=right[0].first;\n                res.push_back(make_pair(1,msi));\n                return res;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    string teacher;\n    while(getline(cin,teacher)&&teacher!=\".\"){\n        teacher=processSpace(teacher);\n        vector<pair<int,map<string,int> > > t=analysis(teacher);\n        sort(t.begin(),t.end());\n        string student;\n        while(getline(cin,student)&&student!=\".\"){\n            student=processSpace(student);\n            vector<pair<int,map<string,int> > > s=analysis(student);\n            sort(s.begin(),s.end());\n            if(s==t)\n                cout<<\"yes\"<<endl;\n            else\n                cout<<\"no\"<<endl;\n        }\n        cout<<\".\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct V {\n  string s;\n  V(const string &s) : s(s){\n  }\n  V operator*(const V &rhs) const {\n    string res;\n    int i=0,j=0;\n    int n = s.size(), m = rhs.s.size();\n    while(i<n||j<m) {\n      if (i<n && j<m) {\n        if (s[i]<rhs.s[j]) res.push_back(s[i++]);\n        else res.push_back(rhs.s[j++]);\n      } else if(i<n) {\n        res.push_back(s[i++]);\n      } else {\n        res.push_back(rhs.s[j++]);\n      }\n    }\n    return V(res);\n  }\n  bool operator<(const V &rhs) const {\n    return s < rhs.s;\n  }\n};\n\ntypedef map<V, int> MP;\n\nstruct P {\n  MP mp;\n  P() {}\n  P(int num) {\n    mp[V(\"\")] = num;\n  }\n  P (char c) {\n    mp[V(string(1,c))] = 1;\n  }\n  P(const MP mp) : mp(mp) {}\n  P operator+(const P &rhs) const {\n    MP res(mp);\n    FOR(it,rhs.mp) {\n      res[it->first] += it->second;\n    }\n    return P(res);\n  }\n  P operator-(const P &rhs) const {\n    MP res(mp);\n    FOR(it,rhs.mp)\n      res[it->first] -= it->second;\n    return P(res);\n  }\n  P operator*(const P &rhs) const {\n    MP res;\n    FOR(it,rhs.mp) {\n      FOR(jt, mp) {\n        res[it->first * jt->first] += it->second * jt->second;\n      }\n    }\n    return P(res);\n  }\n};\n\nP pow(const P &p1, P p2) {\n  assert(p2.mp.size() == 1);\n  int num = p2.mp[V(\"\")];\n  MP res;\n  FOR(it, p1.mp) {\n    string s;\n    FOR(jt,it->first.s) {\n      REP(i,num) s.push_back(*jt);\n    }\n    int a = 1;\n    REP(i,num) a*=it->second;\n    res[s] = a;\n  }\n  return res;\n}\n\nP number(const string &s) {\n  int num = 0;\n  REP(i,s.size()) {\n    num *= 10;\n    num += s[i]-'0';\n  }\n  return P(num);\n}\nint type(char c) {\n  if (isdigit(c)) return -1;\n  return (int)c;\n}\nP parse(string s) {\n  // テ」ツ?ィテ」ツつ甘」ツ?づ」ツ?暗」ツ?堙・ツ、ツ姪・ツ?エテ」ツ?ョテ」ツつケテ」ツδ堙」ツδシテ」ツつケテ」ツつ津・ツ渉姪」ツつ凝ッツシツ?\n  int p1,p2;\n  for (p1=0;p1<s.size();++p1) {\n    if (s[p1]!=' ') break;\n  }\n  if (p1==s.size()) return P();\n  for (p2=s.size()-1;p2>=0; --p2) {\n    if (s[p2]!=' ') break;\n  }\n  s = s.substr(p1, p2-p1+1);\n\n  if (s[0]=='(') {\n    // テ」ツつォテ」ツδε」ツつウテ」ツ?ァテ・ツ崢イテ」ツ?セテ」ツつ古」ツ?淌・ツシツ湘」ツ?ッテ」ツつォテ」ツδε」ツつウテ」ツつ津・ツ渉姪」ツつ?\n    bool f = 0;                 \n    int cnt = 0;\n    REP(i,s.size()-1) {\n      if (s[i]=='(') cnt++;\n      else if (s[i]==')') cnt--;\n      if(cnt==0) f=1;\n    }\n    if (!f) s = s.substr(1,s.size()-2);\n  }\n  \n  // cout << s << endl;\n\n  \n  int cnt = 0;\n  int pm = -1;\n  int tp = -1;\n  REP(i,s.size()) {\n    if (s[i]=='(') cnt++;\n    else if (s[i]==')') cnt--;\n    else if (cnt==0) {\n      if ((s[i]=='+'||s[i]=='-')) pm=i;\n      if (s[i]=='^') tp=i;\n    }\n  }\n  if (pm==-1) {\n    // テ」ツδ催」ツつケテ」ツδ?テ」ツ?ァテ」ツつソテ」ツつ、テ」ツδ療」ツ?古ゥツ?陛」ツ??」ツつづ」ツ?ョテ」ツ?古」ツ?づ」ツつ古」ツ?ーテ」ツ?敕」ツ?禿」ツ?ァテ・ツ按?」ツ?」テ」ツ?ヲテァツゥツ催」ツ?ィテ」ツ?凖」ツつ?\n    int pos=-1;\n    int cnt = 0;\n    REP(i,s.size()-1) {\n      if (s[i]=='(') cnt++;\n      else if (s[i]==')')cnt--;\n      if (cnt==0 && s[i]!=' ' && s[i]!='^') {\n        bool ok = 0;\n        int j=i+1;\n        while(j<s.size()&&s[j]==' ')j++;\n        if (j!=i+1){\n          if (j<s.size() && s[j] != '^') ok = 1;\n        } else {\n          if (j<s.size() && s[j]!='^' && !(isdigit(s[i]) && isdigit(s[j]))) ok = 1;\n        }\n        if (ok) {\n          pos = i; break;\n        }\n      }\n    }\n    if (pos != -1) {\n      P p1 = parse(s.substr(0,pos+1));\n      P p2 = parse(s.substr(pos+1));\n      return p1*p2;\n    }\n  }\n  if (pm!=-1) {\n    P p1 = parse(s.substr(0,pm));\n    P p2 = parse(s.substr(pm+1));\n    if (s[pm]=='+')return p1+p2;\n    else return p1-p2;\n  }\n  if (tp!=-1) {\n    P p1 = parse(s.substr(0,tp));\n    P p2 = parse(s.substr(tp+1)); // p2テ」ツ?ッテヲツ閉ーテ・ツュツ療」ツ?ョテ」ツδ湘」ツつコ\n    return pow(p1,p2);\n  }\n  // 1テ」ツ?、テ」ツ?ョテヲツ閉ーテ・ツュツ療」ツ?凝・ツ、ツ嘉ヲツ閉ー\n  if (isdigit(s[0])) {\n    return number(s);\n  } else {\n    return P(s[0]);\n  }\n  \n  assert(0);\n}\n\nbool eq(const MP &a, const MP &b) {\n  MP tmp(a);\n  FOR(it, b) tmp[it->first]-=it->second;\n  FOR(it,tmp) if (it->second) return 0;\n  return 1;\n}\n\nint main() {\n  string line;\n  while(getline(cin,line), line!=\".\") {\n    vector<MP> v;\n    do {\n      P p = parse(line);\n      v.push_back(p.mp);\n      // FOR(it, p.mp) {\n      //   cout << it->first.s << \" \" << it->second << endl;\n      // }\n      // cout << endl;\n    } while(getline(cin,line), line!=\".\");\n    for (int i=1; i<v.size(); ++i) {\n      if (eq(v[i],v[0])) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n    cout << \".\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define LIMIT 1000\n\n\nenum Type{\n\tNONE,\n\tNUMBER,\n\tOPEN,\n\tCLOSE,\n\tALPHABET,\n\tPOWER,\n\tSPACE,\n\tPLUS_MINUS,\n};\n\n\nll value[3][26],simpson[3];\nchar buf[81],mid[2000],line[2000];\n\nll calc_line(){\n\n\tll n,tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\tnegFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(negFLG){\n\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\tnegFLG = false;\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push((tmp*op1)%MOD);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '/' || line[k-1] == '(')){\n\t\t\t\t\tnegFLG = true;\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork %= MOD;\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && OP.top() == '*'){\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork *= work2;\n\t\t\t\t}else if(OP.empty() == false &&OP.top() == '/'){\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork = work2/work;\n\t\t\t\t}\n\t\t\t\twork %= MOD;\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}else{\n\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork %= MOD;\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1; //must not reach here\n}\n\nvoid make_mid(){\n\n\tint mid_index = 0;\n\tchar pre_ch;\n\n\tType pre = NONE,current;\n\n\tfor(int i = 0; buf[i] != '\\n' && buf[i] != '\\0';){\n\n\t\tswitch(buf[i]){\n\t\tcase ' ':\n\n\t\t\twhile(buf[i] == ' ')i++;\n\n\t\t\tswitch(buf[i]){\n\t\t\tcase '(':\n\t\t\t\tcurrent = OPEN;\n\t\t\t\tif(pre == NUMBER || pre == ALPHABET || pre == CLOSE){\n\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t}\n\t\t\t\tmid[mid_index++] = '(';\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tcurrent = CLOSE;\n\t\t\t\tmid[mid_index++] = ')';\n\t\t\t\tbreak;\n\t\t\tcase '^':\n\t\t\t\tcurrent = POWER;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\t\tcurrent = PLUS_MINUS;\n\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(buf[i] >= '0' && buf[i] <= '9'){\n\t\t\t\t\tif(pre == POWER){\n\t\t\t\t\t\tcurrent = ALPHABET;\n\t\t\t\t\t\tfor(int k = 0; k < ((buf[i]-'0')-1); k++){\n\t\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t\t\tmid[mid_index++] = pre_ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(pre == NUMBER || pre == ALPHABET|| pre == CLOSE){\n\t\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrent = NUMBER;\n\t\t\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcurrent = ALPHABET;\n\n\t\t\t\t\tif(pre == NUMBER || pre == ALPHABET|| pre == CLOSE){\n\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t}\n\t\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\t\tpre_ch = buf[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tcurrent = OPEN;\n\t\t\tif(pre == CLOSE || pre == NUMBER || pre == ALPHABET){\n\t\t\t\tmid[mid_index++] = '*';\n\t\t\t}\n\t\t\tmid[mid_index++] = '(';\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tcurrent = CLOSE;\n\t\t\tmid[mid_index++] = ')';\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '^':\n\t\t\tcurrent = POWER;\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '+':\n\t\tcase '-':\n\t\t\tcurrent = PLUS_MINUS;\n\t\t\tmid[mid_index++] = buf[i];\n\t\t\ti++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif(buf[i] >= '0' && buf[i] <= '9'){\n\t\t\t\tif(pre == POWER){\n\t\t\t\t\tcurrent = ALPHABET;\n\t\t\t\t\tfor(int k = 0; k < ((buf[i]-'0')-1); k++){\n\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t\tmid[mid_index++] = pre_ch;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\tif(pre == ALPHABET || pre == CLOSE){\n\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t}\n\t\t\t\t\tcurrent = NUMBER;\n\t\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcurrent = ALPHABET;\n\n\t\t\t\tif(pre == NUMBER || pre == ALPHABET || pre == CLOSE){\n\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t}\n\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\tpre_ch = buf[i];\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tpre = current;\n\t}\n\tmid[mid_index] = '\\0';\n}\n\nvoid make_line(int num){\n\n\tint line_index = 0;\n\n\tstack<char> S;\n\n\tfor(int i = 0; mid[i] != '\\0'; i++){\n\n\t\tif(mid[i] >= 'a' && mid[i] <= 'z'){\n\n\t\t\tint tmp = value[num][mid[i]-'a'];\n\n\t\t\twhile(tmp != 0){\n\t\t\t\tS.push('0'+(tmp%10));\n\t\t\t\ttmp /= 10;\n\t\t\t}\n\n\t\t\twhile(!S.empty()){\n\t\t\t\tline[line_index++] = S.top();\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}else{\n\t\t\tline[line_index++] = mid[i];\n\t\t}\n\t}\n\tline[line_index] = '=';\n\tline[line_index+1] = '\\0';\n}\n\nvoid func(){\n\n\tmake_mid();\n\n\tfor(int i = 0; i < 3; i++){\n\t\tmake_line(i);\n\t\tsimpson[i] = calc_line();\n\t}\n\n\tbool FLG;\n\tll tmp;\n\n\twhile(true){\n\t\tfgets(buf,80,stdin);\n\t\tif(buf[0] == '.')break;\n\n\t\tFLG = true;\n\n\t\tmake_mid();\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tmake_line(i);\n\t\t\ttmp = calc_line();\n\t\t\tif(tmp != simpson[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(FLG){\n\t\t\tprintf(\"yes\\n\");\n\t\t}\n\t}\n\tprintf(\".\\n\");\n}\n\n\nint main(){\n\n\tll table[LIMIT];\n\tfor(ll i = 0; i < LIMIT; i++){\n\t\ttable[i] = 1;\n\t}\n\ttable[0] = 0;\n\ttable[1] = 0;\n\n\tfor(ll i = 2; i <= sqrt(LIMIT); i++){\n\t\tif(table[i] == 1){\n\t\t\tfor(ll k = 2*i; k < LIMIT; k += i){\n\t\t\t\ttable[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tll prime[LIMIT],prime_index = 0;\n\tfor(ll i = 2; i < LIMIT; i++){\n\t\tif(table[i] == 1){\n\t\t\tprime[prime_index++] = i;\n\t\t}\n\t}\n\n\tfor(ll i = 0; i < 3; i++){\n\t\tll base = 7*(i+1);\n\n\t\tfor(ll k = 0; k < 26; k++){\n\t\t\tvalue[i][k] = prime[base+k];\n\t\t}\n\t}\n\n\n\twhile(true){\n\t\tfgets(buf,80,stdin);\n\t\tif(buf[0] == '.')break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<string,int> P;\ntypedef map<string,int> M;\n\nM add(M a,M b){\n  for(P p2:b) a[p2.first] += p2.second;\n  return a;\n}\n\nM Minus(M a,M b){\n  for(P p2:b) a[p2.first] -= p2.second;\n  return a;\n}\n \nM mult(M a,M b){\n  M res;\n  for(P p1:a)\n    for(P p2:b){\n      string s = p1.first + p2.first; sort(s.begin(),s.end());\n      int num = p1.second * p2.second;\n      res[s] += num;\n    }\n  return res;\n}\n \nM bnf();\nint pos;\nstring S;\nvoid skipsp(){while(S[pos] == ' ') pos++;}\n \nint getNum(){\n  int res = 0;\n  while(isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n \nint getNum2(const string &S,int &pos){\n  int res = 0;\n  while(isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n\nstring getBlock(){\n  string res;\n  skipsp();\n  while(isdigit(S[pos]) || isalpha(S[pos])) res += S[pos++];\n  skipsp();\n  if(S[pos] == '^') {\n    pos++;\n    skipsp();\n    assert(isdigit(S[pos])&&\"hut\");\n    int p = getNum();\n    for(int i=0;i<p-1;i++) res += res.back();\n  }\n  return res;\n}\n \nM BtoM(string b){\n  M res;\n  int num = 1;\n  string val;\n  for(int i=0;i<(int)b.size();i++){\n    char ch = b[i];\n    if(isalpha(ch)) val += ch;\n    else if(isdigit(ch)) num *= getNum2(b,i),i--;\n    else assert(ch == ' ' &&  \"BtoM\");\n  }\n  res[val] = num;\n  return res;\n}\n \nM calc(){\n  M res; res[\"\"] = 1;\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(isalpha(ch) || isdigit(ch)){\n      string block = getBlock();\n      res = mult(res,BtoM(block));\n    }\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n  return res;\n}\n \nM bnf(){\n  M res = calc();\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(isalpha(ch) || isdigit(ch)) res = mult(res,calc());\n    else if(ch == '+')pos++,res = add(res,calc());\n    else if(ch == '-')pos++,res = Minus(res,calc());\n    else if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n  if(res.begin()->second == 0) res.clear();\n  return res;\n}\n \nsigned main(){\n  while(1){\n    getline(cin,S);\n    if(S == \".\") break;\n    pos = 0;\n    M ori = bnf();\n    while(1){\n      getline(cin,S);\n      if(S == \".\") break;\n      pos = 0;\n      M res = bnf();\n      cout<<((ori == res)? \"yes\":\"no\")<<endl;\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring f;\nint len;\nint p = 0;\n\nll exp();\nll term();\nll fact();\n\nll tbl['z' - 'a' + 1];\ninline ll c2n(char c){\n    return tbl[c - 'a'];\n}\n\nchar next_c(){\n    while(p < len and f[p] == ' ') p++;\n    return f[p];\n}\n\nll exp(){\n    ll ret = term();\n\n    char c;\n    while(c = next_c(), (c == '+' or c == '-')){\n        p++;\n        ll r = term();\n        if(c == '+') ret = ADD(ret, r, mod);\n        else         ret = SUB(ret, r, mod);\n    }\n\n    return ret;\n}\n\nconst ll ERR = 2LL * mod;\n\nll term(){\n    ll ret = fact();\n\n    ll r;\n    while((r = fact()) != ERR){\n        ret = MUL(ret, r, mod);\n    }\n\n    return ret;\n}\n\ninline ll num(){\n    ll ret = 0LL;\n    next_c();\n    while(isdigit(f[p])){\n        ret = ret * 10 + (f[p] - '0');\n        p++; // [0,9]\n    }\n    return ret % mod;\n} \n\nll fact(){\n    ll ret = ERR;\n\n    char c = next_c();\n    if(c == '('){\n        p++; // (\n        ret = exp();\n        assert(next_c() == ')'); p++;\n    }\n    else if(islower(c)){\n        p++; // [a,z]\n        ret = c2n(c);\n\n        c = next_c();\n        if(c == '^'){\n            p++; // ^\n            ll d = num();\n            ll b = ret;\n            rep(loop, d - 1){\n                ret = MUL(ret, b, mod);\n            }\n        }\n    }\n    else if(isdigit(c)){\n        ret = num();\n    }\n    else {\n        // cerr << \"cur... \" << c << endl;\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    auto myrand = bind(uniform_int_distribution<int>(0, (int)1e6), mt19937(static_cast<unsigned int>(time(nullptr))));\n\n    while(true){\n        string mine;\n        getline(cin, mine);\n        if(mine == \".\") break;\n        \n        while(true){\n            string opp;\n            getline(cin, opp);\n            if(opp == \".\") break;\n\n            bool ok = true;\n            rep(loop, 1000){\n                rep(i, 'z' - 'a' + 1) tbl[i] = myrand();\n\n                // cerr << \"-> \" << mine << endl;\n                f = mine; p = 0; len = f.size(); ll a = exp();\n                // cerr << \"-> \" << opp << endl;\n                f =  opp; p = 0; len = f.size(); ll b = exp();\n\n                if(a != b){\n                    ok = false;\n                    break;\n                }\n            }\n\n            if(ok){\n                cout << \"yes\" << endl;\n            }\n            else {\n                cout << \"no\" << endl;\n            }\n        }\n        cout << \".\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n\n    //debug\n    p=0;\n    in=pre_processing2(tmp);\n    formula me2=fact(in,p);\n    assert(is_same_formula(me,me2));\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      p=0;\n      cmp=pre_processing2(tmp);\n      formula you2=fact(cmp,p);\n      assert(is_same_formula(you,you2));\n\n      //      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n\n  return ret;\n}\n\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdlib>\n#include<iostream>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint var[128];\n\nll expr(const string &,int &);\nll term(const string &,int &);\nll factor(const string &,int &);\nll primary(const string &,int &);\nll number(const string &,int &);\n\nll expr(const string &s,int &idx){\n\tll a=term(s,idx);\n\twhile(idx<s.length() && (s[idx]=='+' || s[idx]=='-')){\n\t\tchar op=s[idx++];\n\t\tif     (op=='+') a+=term(s,idx);\n\t\telse if(op=='-') a-=term(s,idx);\n\t}\n\treturn a;\n}\n\nll term(const string &s,int &idx){\n\tll a=factor(s,idx);\n\twhile(idx<s.length() && s[idx]=='*'){\n\t\tidx++;\n\t\ta*=factor(s,idx);\n\t}\n\treturn a;\n}\n\nll factor(const string &s,int &idx){\n\tll a=primary(s,idx);\n\tif(idx<s.length() && s[idx]=='^'){\n\t\tidx++;\n\t\tll b=primary(s,idx);\n\t\tll apowb=1;\n\t\trep(i,b) apowb*=a;\n\t\ta=apowb;\n\t}\n\treturn a;\n}\n\nll primary(const string &s,int &idx){\n\tll a;\n\tif(s[idx]=='('){\n\t\tidx++;\n\t\ta=expr(s,idx);\n\t\tidx++;\n\t}\n\telse a=number(s,idx);\n\treturn a;\n}\n\nll number(const string &s,int &idx){\n\tll a;\n\tif(isalpha(s[idx])) a=var[s[idx++]];\n\telse{\n\t\tfor(a=0;idx<s.length()&&isdigit(s[idx]);idx++) a=10*a+(s[idx]-'0');\n\t}\n\treturn a;\n}\n\nll parse(const string &s){\n\tint idx=0;\n\treturn expr(s,idx);\n}\n\nvoid normalize(string &s){\n\tstring t;\n\tint n=s.length();\n\t// óð\n\t// ½¾µAóªÈ¢ÆÓ¡ªÏíéÆ±ë (_) ÉÍ ~ ðÍ³Þ\n\trep(i,n) if(s[i]!=' ') {\n\t\tif(i>0 && s[i-1]==' ' && !t.empty()){\n\t\t\tif(isdigit(*t.rbegin()) && isdigit(s[i])) t+='*';\n\t\t}\n\t\tt+=s[i];\n\t}\n\n\t// BNF É¤æ¤É ~ ðÍ³Þ\n\ts.clear();\n\tn=t.length();\n\trep(i,n){\n\t\tif(i>0){\n\t\t\tif(isdigit(t[i-1]) && isalpha(t[i])\n\t\t\t|| isdigit(t[i-1]) && t[i]=='('\n\t\t\t|| isalpha(t[i-1]) && isdigit(t[i])\n\t\t\t|| isalpha(t[i-1]) && isalpha(t[i])\n\t\t\t|| isalpha(t[i-1]) && t[i]=='('\n\t\t\t|| t[i-1]==')' && isdigit(t[i])\n\t\t\t|| t[i-1]==')' && isalpha(t[i])\n\t\t\t|| t[i-1]==')' && t[i]=='(') s+='*';\n\t\t}\n\t\ts+=t[i];\n\t}\n}\n\nint main(){\n\tfor(string ex0;getline(cin,ex0),ex0!=\".\";){\n\t\tnormalize(ex0);\n\t\twhile(1){\n\t\t\tstring ex; getline(cin,ex);\n\t\t\tif(ex==\".\") break;\n\t\t\tnormalize(ex);\n\n\t\t\tbool ok=true;\n\t\t\trep(_,100){\n\t\t\t\tfor(int c='a';c<='z';c++) var[c]=rand()%7;\n\t\t\t\tif(parse(ex0)!=parse(ex)){ ok=false; break; }\n\t\t\t}\n\t\t\tputs(ok?\"yes\":\"no\");\n\t\t}\n\t\tputs(\".\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef __int128  Val;\n\n\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    Val val=term2(s,p);\n    Val a=res;\n    res=1;\n    for(int i=0;i<val;i++) res*=a;\n    return res;\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%4;\n      }\n      Val cor=formula(state[0],p);\n      p=0;\n      Val ans=formula(state[i],p);\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int mod = 1000000007;\n\nstruct Mod {\n  int num;\n  Mod () : num(0) {;}\n  Mod (int n) : num(n) {;}\n  operator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator^(Mod a, int n) {\n  if (n == 0) return Mod(1);\n  Mod res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\n\npair<Mod, int> expr(const string &s, int i);\npair<Mod, int> num(const string &s, int i) {\n  Mod v;\n  while('0' <= s[i] && s[i] <= '9') {\n    v = v * Mod(10);\n    v += Mod(s[i] - '0');\n    ++i;\n  }\n  while(i < s.size() && s[i] == ' ') ++i;\n  return make_pair(v, i);\n}\n\npair<Mod, int> factor(const string &s, int i) {\n  //cerr << \"factor: \" << i << ' ';\n  Mod val;\n  if (s[i] == '(') {\n    ++i;\n    while(s[i] == ' ') ++i;\n    tie(val, i) = expr(s, i);\n    assert(s[i] == ')');\n    ++i;\n    while(i < s.size() && s[i]==' ') ++i;\n  } else {\n    tie(val, i) = num(s, i);\n  }\n  if (i < s.size() && s[i] == '^') {\n    ++i;\n    while(s[i] == ' ') ++i;\n    Mod index;\n    tie(index, i) = num(s, i);\n    val = val ^ index;\n  }\n  return make_pair(val, i);\n}\n\npair<Mod, int> term(const string &s, int i) {\n  //cerr << \"term: \" << i << ' ';\n  Mod val;\n  tie(val, i) = factor(s, i);\n  while(i < s.size() && !(s[i] == '+' || s[i] == '-' || s[i] == ')')) {\n    while(s[i] == ' ') ++i;\n    auto p = factor(s, i);\n    val = val * p.first;\n    i = p.second;\n  }\n  return make_pair(val, i);\n}\n\npair<Mod, int> expr(const string &s, int i) {\n  //cerr << \"expr: \" << i << ' ';\n  Mod val;\n  tie(val, i) = term(s, i);\n  while(i < s.size() && (s[i] == '+' || s[i] == '-')) {\n    char op = s[i];\n    ++i;\n    while(s[i] == ' ') ++i;\n    auto p = term(s, i);\n    if (op == '+') val += p.first;\n    else val -= p.first;\n    i = p.second;\n  }\n  return make_pair(val, i);\n}\n\nint main() {\n  random_device rd;\n  mt19937 mt(rd());\n  while(1){\n    vector<string> lines;\n    while(1){\n      string line;\n      getline(cin,line);\n      if(line[0] == '.') break;\n      lines.push_back(line);\n    }\n    if(lines.empty()) break;\n    vector<char> vals;\n    for (auto line:lines)\n      for (auto c : line)\n        if ('a' <= c && c <= 'z')\n          vals.push_back(c);\n    sort(begin(vals),end(vals));\n    vals.erase(unique(begin(vals),end(vals)),end(vals));\n    vector<Mod> rnums;\n    for (char c:vals) rnums.emplace_back(mt()%mod);\n    vector<Mod> res;\n    for (auto line:lines) {\n      string rep;\n      for (char c:line) {\n        if ('a' <= c && c <= 'z') {\n          int index = lower_bound(begin(vals),end(vals),c)-begin(vals);\n          rep += ' ' + to_string(rnums[index]) + ' ';\n        } else {\n          rep += c;\n        }\n      }\n      //cout<<rep<<endl;\n      int ofs = 0;\n      while(rep[ofs] == ' ') ++ofs;\n      res.push_back(expr(rep, ofs).first);\n    }\n    REP(i,res.size()) {\n      if (!i) continue;\n      //cout<<res[i]<<' '<<res[0]<<endl;\n      if (res[i] == res[0]) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef __int128  Val;\n\nconst Val MOD=1e18+9;\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    res%=MOD;\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    res%=MOD;\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    Val val=term2(s,p);\n    Val a=res;\n    res=1;\n    for(int i=0;i<val;i++){\n      res*=a;\n      res%=MOD;\n    }\n    return res;\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n    res%=MOD;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n    if(op=='+') res+=val;\n    else res-=val;\n    res%=MOD;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%TIME;\n      }\n      Val cor=formula(state[0],p);\n      cor%=MOD;\n      cor+=MOD;\n      cor%=MOD;\n      p=0;\n      Val ans=formula(state[i],p);\n      ans%=MOD;\n      ans+=MOD;\n      ans%=MOD;\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  cout<<\".\"<<endl;\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\ntypedef map<vi, int> E;\n\nE operator+(E a, const E &b){\n\teach(i, b) a[i->first] += i->second;\n\treturn a;\n}\nE operator-(E a, const E &b){\n\teach(i, b) a[i->first] -= i->second;\n\treturn a;\n}\nE operator*(const E &a, const E &b){\n\tE c;\n\teach(i, a) each(j, b){\n\t\tvi v = i->first;\n\t\trep(k, 26) v[k] += (j->first)[k];\n\t\tc[v] += i->second * j->second;\n\t}\n\treturn c;\n}\nint p;\nstring in, next;\nE expr();\nvoid get(){\n\tnext = \"\";\n\twhile(p < in.size() && isspace(in[p])) p++;\n\tif(p >= in.size()) return;\n\tif(isdigit(in[p])){\n\t\twhile(p < in.size() && isdigit(in[p])) next += in[p++];\n\t}else{\n\t\tnext += in[p++];\n\t}\n}\nE primary(){\n\tE res;\n\tif(isdigit(next[0])){\n\t\tvi v(26);\n\t\tres[v] = atoi(next.c_str());\n\t\treturn res;\n\t}\n\tif(isalpha(next[0])){\n\t\tvi v(26);\n\t\tv[next[0] - 'a'] = 1;\n\t\tres[v] = 1;\n\t\treturn res;\n\t}\n\tget();\n\tres = expr();\n\treturn res;\n}\nE factor(){\n\tE res = primary();\n\tget();\n\tif(next == \"^\"){\n\t\tget();\n\t\tint d = atoi(next.c_str()) - 1;\n\t\tE e = res;\n\t\twhile(d--) res = res * e;\n\t\tget();\n\t}\n\treturn res;\n}\nE term(){\n\tE res;\n\twhile(1){\n\t\tE f = factor();\n\t\tif(res.empty()) res = f;\n\t\telse res = res * f;\n\t\tif(next == \"\" || next == \"+\" || next == \"-\" || next ==\")\") break;\n\t}\n\treturn res;\n}\nE expr(){\n\tE t = term();\n\twhile(next == \"+\" || next == \"-\"){\n\t\tbool op = next == \"+\";\n\t\tget();\n\t\tE u = term();\n\t\tif(op) t = t + u;\n\t\telse t = t - u;\n\t}\n\treturn t;\n}\n\nE parse(){\n\tp = 0;\n\tget();\n\treturn expr();\n}\nint main(){\n\twhile(getline(cin, in), in != \".\"){\n\t\tE a = parse();\n\t\twhile(getline(cin, in), in != \".\")\n\t\t\tcout << (a == parse() ? \"yes\" : \"no\") << endl;\n\t\tcout << \".\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nstring norm(string s)\n{\n\tstring res;\n\tfor(int i=0; i<s.size(); i++) {\n\t\tres += s[i];\n\t\twhile(s[i] == ' ') i++;\n\t\tif(i!=0 && s[i-1] == ' ') res += s[i];\n\t}\n\n\ts = res;\n\tres = \"\";\n\n\tfor(int i=0; i<s.size(); i++) {\n\t\tif(s[i]==' ' && !(isdigit(s[i-1]) && isdigit(s[i+1]))) continue;\n\t\t\n\t\tres += s[i];\n\t}\n\n\ts = res;\n\tres = \"\";\n\tfor(int i=0; i<s.size(); i++) {\n\t\tif(s[i] == ' ') {\n\t\t\tres += '*';\n\t\t}\n\n\t\telse {\n\t\t\tres += s[i];\n\t\t\tif(isalnum(s[i]) && s[i+1] == '(' ||\n\t\t\t\ts[i]=='(' && s[i+1] == ')' ||\n\t\t\t\ts[i]==')' && s[i+1] == '(' ||\n\t\t\t\ts[i]==')' && isalnum(s[i+1]) ||\n\t\t\t\tisalnum(s[i]) && isalpha(s[i+1]) ||\n\t\t\t\tisalpha(s[i]) && isalnum(s[i+1])) {\n\t\t\t\tres += '*';\n\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\n\nclass Polynomial\n{\npublic:\n\tmap<string, ll> tem;\n\tPolynomial() \n\t{\n\t\ttem[\"Digit\"] = 0;\n\t}\n\n\tPolynomial(ll k) \n\t{\n\t\ttem[\"Digit\"] = k;\n\t}\n\n\tPolynomial(char a)\n\t{\n\t\ttem[string(1,a)] = 1;\n\t\ttem[\"Digit\"] = 0;\n\t}\n\n\tvoid add(Polynomial& p)\n\t{\n\t\tmap<string, ll>::iterator it = p.tem.begin();\n\t\tfor(; it != p.tem.end(); it++) {\n\t\t\tif(it->second == 0) continue;\n\n\t\t\tif(!tem.count(it->first)) tem[it->first] = it->second;\n\t\t\telse tem[it->first] += it->second;\n\t\t}\n\t}\n\n\tvoid sub(Polynomial& p)\n\t{\n\t\tmap<string, ll>::iterator it = p.tem.begin();\n\t\tfor(; it != p.tem.end(); it++) {\n\t\t\tif(it->second == 0) continue;\n\n\t\t\tif(!tem.count(it->first)) tem[it->first] = -it->second;\n\t\t\telse tem[it->first] -= it->second;\n\t\t}\n\n\t}\n\n\tvoid mul(Polynomial& p)\n\t{\n\t\tPolynomial tmp;\n\n\t\tmap<string, ll>::iterator pit = p.tem.begin();\n\t\tmap<string, ll>::iterator it = tem.begin();\n\t\tfor(; it != tem.end(); it++) \n\t\tfor(pit = p.tem.begin(); pit != p.tem.end(); pit++) {\n\t\t\tstring nt;\n\n\t\t\tif(it->first == \"Digit\" && pit->first == \"Digit\") {\n\t\t\t\tnt = it->first;\n\t\t\t}\n\t\t\telse if(it->first == \"Digit\") {\n\t\t\t\tnt = pit->first;\n\t\t\t}\n\t\t\telse if(pit->first == \"Digit\") {\n\t\t\t\tnt = it->first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnt = string(it->first) + string(pit->first);\n\t\t\t\tsort(nt.begin(), nt.end()); \n\t\t\t}\n\n\t\t\tll k = it->second * pit->second;\n\t\t\t\n\n\t\t\tif(k==0) continue;\n\n\t\t\tif(!tmp.tem.count(nt)) tmp.tem[nt] = k;\n\t\t\telse tmp.tem[nt] += k;\n\t\t}\n\n\t\t*this = tmp;\n\t}\n\n\tvoid pow(Polynomial& p)\n\t{\n\t\tint pw = p.tem[\"Digit\"];\n\t\t\n\t\tPolynomial res(1LL);\n\t\tPolynomial tmp = *this;\n\t\tfor(int i=0; i<pw; i++)\n\t\t\tres.mul(tmp);\n\n\t\t*this = res;\n\t}\n\n\tbool equals(Polynomial& p) {\n\t\tmap<string, ll>::iterator pit = p.tem.begin();\n\t\tmap<string, ll>::iterator it = tem.begin();\n\n\t\tfor(; it != tem.end(); ++it) {\n\t\t\tif(p.tem.count(it->first) == 0) {\n\t\t\t\tif(it->second != 0) return false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(it->second != p.tem[it->first]) return false;\n\t\t\t}\n\t\t}\n\n\t\tfor(; pit != p.tem.end(); ++pit) {\n\t\t\tif(tem.count(pit->first) == 0) {\n\t\t\t\tif(pit->second != 0) return false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(pit->second != tem[pit->first]) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n};\n\nstring str;\nint p;\n\nPolynomial expr();\nPolynomial term();\nPolynomial factor();\nPolynomial primary();\nPolynomial digit();\n\nPolynomial expr()\n{\n\tPolynomial a = term();\n\twhile(str[p] == '+' || str[p] == '-') {\n\t\tchar op = str[p++];\n\t\tPolynomial b = term();\n\n\t\tif(op == '+') a.add(b);\n\t\tif(op == '-') a.sub(b);\n\t}\n\n\treturn a;\n}\n\nPolynomial term()\n{\n\tPolynomial a = factor();\n\twhile(str[p] == '*') {\n\t\tchar op = str[p++];\n\t\tPolynomial b = factor();\n\n\t\ta.mul(b);\n\t}\n\n\treturn a;\n}\n\nPolynomial factor()\n{\n\tPolynomial a = primary();\n\tif(str[p] == '^') {\n\t\tp++;\n\n\t\tPolynomial pw = digit();\n\t\ta.pow(pw);\n\t}\n\n\treturn a;\n}\n\nPolynomial primary()\n{\n\tPolynomial a;\n\tif(isdigit(str[p])) {\n\t\ta = digit();\n\t}\n\telse if(isalpha(str[p])) {\n\t\ta = Polynomial(str[p]);\n\t\tp++;\n\t}\n\telse {\n\t\tp++;\n\t\ta = expr();\n\t\tp++;\n\t}\n\n\treturn a;\n}\n\nPolynomial digit()\n{\n\tll res = 0;\n\twhile(isdigit(str[p])) {\n\t\tres *= 10;\n\t\tres += str[p] - '0';\n\t\tp++;\n\t}\n\n\treturn Polynomial(res);\n}\n\nPolynomial parse()\n{\n\tp = 0;\n\tstr += '$';\n\tstr = norm(str);\n\t//cout << str << endl;\n\n\treturn expr();\n}\n\nint main()\n{\n\twhile(1) {\n\t\tgetline(cin, str);\n\t\tif(str == \".\") break;\n\t\tPolynomial a = parse();\n\n\t\twhile(1) {\n\t\t\tgetline(cin, str);\n\t\t\tif(str == \".\") {\n\t\t\t\tcout << str << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPolynomial b = parse();\n\n\t\t\tcout << (a.equals(b) ? \"yes\":\"no\") << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< char,int > P;\ntypedef vector< P > vec;\ntypedef pair< int, vec > PP;\ntypedef vector< PP > mat;\nstring s;\nint p,len;\n\nmat add(mat a,mat b){\n  map< vec , int > mp;\n  \n  for(int i=0;i< (int)a.size();i++){\n    mp[ a[i].second ]+= a[i].first;\n  }\n\n  for(int i=0;i<(int)b.size();i++){\n    mp[ b[i].second ]+= b[i].first;\n  }\n\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  \n  sort(res.begin(),res.end());\n  \n  return res;\n}\n\nPP mul(PP a,PP b){\n  int fi=a.first*b.first;\n  vec &va=a.second;\n  vec &vb=b.second;\n  map<char,int> mp;\n  for(int i=0;i<(int)va.size();i++){\n    P p=va[i];\n    mp[ p.first ]+=p.second;\n  }\n  for(int j=0;j<(int)vb.size();j++){\n    P p=vb[j];\n    mp[ p.first ]+=p.second;\n  }\n\n  \n  vec se;\n\n  if(fi==0){\n    return PP(fi,se);\n  }\n  \n  map<char,int> :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    se.push_back( *it );\n  }\n  return PP(fi,se);\n}\n\nmat mul(mat a,mat b){\n  map< vec , int > mp;\n  for(int i=0;i<(int)a.size();i++){\n    PP as=a[i];\n    for(int j=0;j<(int)b.size();j++){\n      PP bs=b[j];\n\n      PP c=mul(as,bs);\n      mp[  c.second ] += c.first;\n    }\n  }\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  return res;  \n}\n\nmat target;\nmat solve();\n\nmat getNum(bool flg=false){\n  while(s[p]==' ')p++;\n\n  if('0'<=s[p]&&s[p]<='9'){\n    int res=0;\n    while('0'<=s[p]&&s[p]<='9'){\n      res=res*10+(s[p]-'0');\n      p++;\n    }\n    mat re;\n    vec r;\n    if(res>0)re.push_back(PP( res , r ));\n    return re;\n  }\n\n  assert(flg==false);\n  \n  if('('==s[p]){\n    p++;\n    mat res=solve();\n    p++;\n    return res;\n  }\n\n  char ch=s[p++];\n  while(s[p]==' ')p++;\n  int num=1;\n  if(s[p]=='^'){\n    mat tmp=getNum(true);\n    num=tmp[0].first;\n    assert(num>0);\n  }\n  mat res;\n  vec r;\n  r.push_back(P(ch,num));\n  res.push_back(PP(1,r));\n  return res;\n}\n\nmat solve(){\n  while(s[p]==' ')p++;\n\n  stack < mat > st;\n  st.push( getNum() );\n\n  while(1){\n    while(s[p]==' ')p++;\n\n    if(p>=len){\n      break;\n    }else if(s[p]=='+'){\n      p++;\n      mat num=getNum();\n      st.push(num);\n    }else if(s[p]=='-'){\n      p++;\n      mat num=getNum();\n      for(int i=0;i<(int)num.size();i++)\n        num[i].first*=-1;\n      st.push(num);\n      \n    }else if(s[p]==')'){\n      break;\n    }else{\n      mat num=getNum();\n      mat A=st.top();\n      st.pop();\n      st.push( mul(A,num) );\n      \n    }\n  }\n  mat res=st.top();\n  st.pop();\n  while(!st.empty()){\n    res=add(res,st.top());\n    st.pop();\n  }\n\n  for(int i=0;i<(int)res.size();i++){\n    sort(res[i].second.begin(),res[i].second.end());\n  }\n  sort(res.begin(),res.end());\n  return res;\n}\n\nint main(){\n  while(1){\n    getline(cin,s);\n    if(s==\".\")break;\n    p=0;len=s.size();\n    target=solve();\n    \n    while(1){\n      getline(cin,s);\n      if(s==\".\")break;\n      p=0;len=s.size();\n      mat tmp=solve();\n      if(target==tmp)cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    cout<<'.'<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\n#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element &a,Element &b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  //if (ret.size() == 0)ret.pb(ori);\n}\n\nbool is_same_formula(formula &a,formula &b){\n  erase_duplicate(a);\n  erase_duplicate(b);\n  if (a.size() != b.size())return false;\n  if (a.size() == 1 && b.size() == 1){\n    //if (a[0].c == 0 && b[0].c == 0)return true;\n  }\n\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n    \n  }\n  if (b.size() == 0)return true;\n  else return false;\n}\n\nformula mult(formula &a,formula &b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula &a,formula &b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula &a,formula &b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    tmp.p[in[p]-'a']++;\n      p++;\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n/*\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n  return ret;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< char,int > P;\ntypedef vector< P > vec;\ntypedef pair< int, vec > PP;\ntypedef vector< PP > mat;\nstring s;\nint p,len;\n\nmat add(mat a,mat b){\n  map< vec , int > mp;\n  \n  for(int i=0;i< (int)a.size();i++){\n    mp[ a[i].second ]+= a[i].first;\n  }\n\n  for(int i=0;i<(int)b.size();i++){\n    mp[ b[i].second ]+= b[i].first;\n  }\n\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  return res;\n}\n\nPP mul(PP a,PP b){\n  int fi=a.first*b.first;\n  vec &va=a.second;\n  vec &vb=b.second;\n  map<char,int> mp;\n  for(int i=0;i<(int)va.size();i++){\n    P p=va[i];\n    mp[ p.first ]+=p.second;\n  }\n  for(int j=0;j<(int)vb.size();j++){\n    P p=vb[j];\n    mp[ p.first ]+=p.second;\n  }  \n  vec se;\n  map<char,int> :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    se.push_back( *it );\n  }\n  return PP(fi,se);\n}\n\nmat mul(mat a,mat b){\n  map< vec , int > mp;\n  for(int i=0;i<(int)a.size();i++){\n    PP as=a[i];\n    for(int j=0;j<(int)b.size();j++){\n      PP bs=b[j];\n\n      PP c=mul(as,bs);\n      mp[  c.second ] += c.first;\n    }\n  }\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  return res;  \n}\n\nmat target;\nmat solve();\n\nmat getNum(){\n  while(s[p]==' ')p++;\n\n  if('0'<=s[p]&&s[p]<='9'){\n    int res=0;\n    while('0'<=s[p]&&s[p]<='9'){\n      res=res*10+(s[p]-'0');\n      p++;\n    }\n    mat re;\n    vec r;\n    re.push_back(PP( res , r ));\n    return re;\n  }\n\n  if('('==s[p]){\n    p++;\n    mat res=solve();\n    p++;\n    return res;\n  }\n\n  char ch=s[p++];\n  while(s[p]==' ')p++;\n  int num=1;\n  if(s[p]=='^'){\n    mat tmp=getNum();\n    assert(tmp.size()==1);\n    num=tmp[0].first;\n  }\n  mat res;\n  vec r;\n  r.push_back(P(ch,num));\n  res.push_back(PP(1,r));\n  return res;\n}\n\nmat solve(){\n  while(s[p]==' ')p++;\n\n  stack < mat > st;\n  st.push( getNum() );\n\n  while(1){\n    while(s[p]==' ')p++;\n\n    if(p>=len){\n      break;\n    }else if(s[p]=='+'){\n      p++;\n      mat num=getNum();\n      st.push(num);\n    }else if(s[p]=='-'){\n      p++;\n      mat num=getNum();\n      for(int i=0;i<(int)num.size();i++)\n        num[i].first*=-1;\n      st.push(num);\n      \n    }else if(s[p]==')'){\n      break;\n    }else{\n      mat num=getNum();\n      mat A=st.top();\n      st.pop();\n      st.push( mul(A,num) );\n      \n    }\n  }\n  mat res=st.top();\n  st.pop();\n  while(!st.empty()){\n    res=add(res,st.top());\n    st.pop();\n  }\n\n  for(int i=0;i<(int)res.size();i++){\n    sort(res[i].second.begin(),res[i].second.end());\n  }\n  sort(res.begin(),res.end());\n  return res;\n}\n\nint main(){\n  while(1){\n    getline(cin,s);\n    if(s==\".\")break;\n    p=0;len=s.size();\n    target=solve();\n    \n    while(1){\n      getline(cin,s);\n      if(s==\".\")break;\n      p=0;len=s.size();\n      mat tmp=solve();\n      if(target==tmp)cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    cout<<'.'<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\n\n\nstruct T{\n  map<string, Int> ms;\n  T(){}\n  T(string s, Int c){\n    sort(s.begin(),s.end());\n    ms[s]+=c;\n  }\n\n  T operator+=(const T &a){\n    for(auto p:a.ms)\n      ms[p.first]+=p.second;\n    return *this;\n  }\n  \n  T operator-=(const T &a){\n    for(auto p:a.ms)\n      ms[p.first]-=p.second;\n    return *this;\n  }\n  \n  T operator+(const T &a) const{\n    T res(*this);\n    return res+=a;\n  }\n  \n  T operator-(const T &a) const{\n    T res(*this);\n    return res-=a;\n  }\n  \n  T operator*(const T &a) const{\n    T res;\n    for(auto p:ms)\n      for(auto q:a.ms)\n        res+=T(p.first+q.first,p.second*q.second);\n    return res;\n  }\n\n  T pow(Int k) const{\n    assert(k>=1);\n    T res(*this);\n    for(Int i=1;i<k;i++) res=res*(*this);\n    return res;\n  }\n  \n  bool operator==(const T &a){\n    return ms==a.ms;\n  }\n};\n\nusing V = vector<string>; \nT expr  (const V &vs,Int &p);\nT term  (const V &vs,Int &p);\nT factor(const V &vs,Int &p);\nT power (const V &vs,Int &p);\nInt number(const V &vs,Int &p);\n\nT expr  (const V &vs,Int &p){\n  T res=term(vs,p);\n  while(p<(Int)vs.size()){\n    if(vs[p]==\"+\"s){\n      p++;\n      res=res+term(vs,p);\n      continue;\n    }\n    if(vs[p]==\"-\"s){\n      p++;\n      res=res-term(vs,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nT term  (const V &vs,Int &p){  \n  T res=factor(vs,p);\n  while(p<(Int)vs.size()){\n    if(vs[p]==\"+\"s) break;\n    if(vs[p]==\"-\"s) break;\n    if(vs[p]==\"^\"s) break;\n    if(vs[p]==\")\"s) break;\n    res=res*factor(vs,p);\n  }\n  return res;\n}\n\nT factor(const V &vs,Int &p){  \n  T res=power(vs,p);\n  if(p<(Int)vs.size()&&vs[p]==\"^\"s){\n    p++;\n    Int k=number(vs,p);\n    return res.pow(k);\n  }  \n  return res;\n}\n\nT power (const V &vs,Int &p){\n  if(vs[p]==\"(\"s){\n    p++;\n    T res=expr(vs,p);\n    assert(vs[p]==\")\"s);\n    p++;\n    return res;\n  }\n  if(isalpha(vs[p][0])) return T(vs[p++],1);\n  return T(\"\"s, number(vs,p));\n}\n\nInt number(const V &vs,Int &p){\n  return stoll(vs[p++]);\n}\n\nT tran(string s){\n  Int n=s.size();\n  string t;\n  for(Int i=0;i<n;i++){\n    if(!isdigit(s[i])) t+=' ';\n    t+=s[i];\n    if(!isdigit(s[i])) t+=' ';\n  }  \n  V vs;\n  stringstream ss(t);\n  while(ss>>t) vs.emplace_back(t);\n  Int p=0;\n  return expr(vs,p);\n}\n\nsigned main(){\n  string s;\n  while(getline(cin,s)){\n    if(s==\".\"s) break;\n    auto vs=tran(s);\n    while(1){\n      string t;\n      getline(cin,t);      \n      if(t==\".\"s) break;\n      auto vt=tran(t);\n      cout<<(vs==vt?\"yes\":\"no\")<<endl;\n    }    \n    cout<<\".\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,int> P;\ntypedef map<string,int> M;\n\nvoid pr(M a,string s=\"\"){\n   return;\n  cout<<s<<endl;\n  for(P p:a) cout<<p.first<<\" \"<<p.second<<endl;\n  cout<<\"end\"<<endl;\n}\n\nM add(M a,M b,int f=1){\n  for(P p1:a) b[p1.first] += f * p1.second;\n  return b;\n}\n\nM mult(M a,M b){\n  M res;\n  for(P p1:a)\n    for(P p2:b){\n      string s = p1.first + p2.first; sort(s.begin(),s.end());\n      int num = p1.second * p2.second;\n      res[s] += num;\n    }\n  return res;\n}\n\n\nM bnf();\nint pos;\nstring S;\nvoid skipsp(){while(S[pos] == ' ') pos++;}\n\nint getNum(){\n  int res = 0;\n  while((int)S.size()> pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n\nint getNum2(const string &S,int &pos){\n  int res = 0;\n  while((int)S.size()>pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n\nstring getBlock(){\n  string res;\n  skipsp();\n  while(isdigit(S[pos]) || isalpha(S[pos])) res += S[pos++];\n  skipsp();\n  if(S[pos] == '^') {\n    pos++;\n    skipsp();\n    assert(isdigit(S[pos])&&\"hut\");\n    int p = getNum();\n    string tmp = res; res = \"\";\n    for(int i=0;i<p;i++) res += tmp, res += ' ';\n  }\n  return res;\n}\n\nM BtoM(string b){\n  M res;\n  int num = 1;\n  string val;\n  for(int i=0;i<(int)b.size();i++){\n    char ch = b[i];\n    if(isalpha(ch)) val += ch;\n    else if(isdigit(ch)) num *= getNum2(b,i),i--;\n  }\n  res[val] = num;\n  return res;\n}\n\nM calc(){\n  M res; res[\"\"] = 1;\n  skipsp();\n  while(1){\n    char ch = S[pos];\n    if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(isalpha(ch) || isdigit(ch)){\n      string block = getBlock();\n      res = mult(res,BtoM(block));\n    }\n    else break;\n  }\n  pr(res,\"calc,res\");\n  return res;\n}\n\nM bnf(){\n  M res = calc();\n  pr(res,\"start bnf\");\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(isalpha(ch) || isdigit(ch)) res = mult(res,calc());\n    else if(ch == '+')pos++,res =add(res,calc());\n    else if(ch == '-')pos++,res = add(res,calc(),-1);\n    else if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else break;\n  }\n  \n  for(auto it=res.begin();it!=res.end();it++) if(it->second==0) res.erase(it--);\n  pr(res,\"return bnf\");\n  return res;\n}\n\nint main(){\n  while(1){\n    getline(cin,S);\n    //cin.ignore();\n    if(S == \".\") break;\n    pos = 0;\n    M ori = bnf();\n    pr(ori,\"ori\");\n    while(1){\n      getline(cin,S);\n      if(S == \".\") break;\n      pos = 0;\n      M res = bnf();\n      cout<<((ori == res)? \"yes\":\"no\")<<endl;\n      pr(res,S);\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[27];\n  Element(){\n    c=0;rep(i,27)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,27)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,27){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,27){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p]=='+'||in[p]=='-')break;\n    \n    else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }\n    else if (in[p] ==')')break;\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;\n    //    output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n      //      cout << \"formula :\"<<cmp<<endl;\n      //      output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[27];\n  Element(){\n    c=0;rep(i,27)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,27)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  //  if (a.size() != b.size())return false;\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,27){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,27){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p]=='+'||in[p]=='-')break;\n    \n    else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }\n    else if (in[p] ==')')break;\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;\n    //    output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n      //      cout << \"formula :\"<<cmp<<endl;\n      //      output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef pair<int,string> term;\n\nvector<term> normalize(const vector<term>& a)\n{\n\tmap<string,int> f;\n\tfor(auto x:a){\n\t\tsort(all(x.second));\n\t\tf[x.second]+=x.first;\n\t}\n\tvector<term> b;\n\tfor(auto p:f) if(p.second) b.emplace_back(p.second,p.first);\n\treturn b;\n}\n\nvector<term> add(const vector<term>& a,const vector<term>& b)\n{\n\tmap<string,int> f;\n\tfor(auto x:a){\n\t\tsort(all(x.second));\n\t\tf[x.second]+=x.first;\n\t}\n\tfor(auto x:b){\n\t\tsort(all(x.second));\n\t\tf[x.second]+=x.first;\n\t}\n\tvector<term> c;\n\tfor(auto p:f) if(p.second) c.emplace_back(p.second,p.first);\n\treturn c;\n}\n\nvector<term> mul(const vector<term>& a,const vector<term>& b)\n{\n\tmap<string,int> f;\n\tfor(auto x:a) for(auto y:b){\n\t\tstring s=x.second+y.second; sort(all(s));\n\t\tf[s]+=x.first*y.first;\n\t}\n\tvector<term> c;\n\tfor(auto p:f) if(p.second) c.emplace_back(p.second,p.first);\n\treturn c;\n}\n\nvector<term> pow(const vector<term>& a,int r)\n{\n\tvector<term> b(1,term(1,\"\"));\n\trep(i,r) b=mul(b,a);\n\treturn b;\n}\n\npair<vector<term>,int> parse_expr(string f,int i);\n\npair<vector<term>,int> parse_fact(string f,int i)\n{\n\twhile(i<f.size() && f[i]==' ') i++;\n\tvector<term> x;\n\tif(f[i]=='('){\n\t\ti++;\n\t\ttie(x,i)=parse_expr(f,i);\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t\ti++;\n\t}\n\telse if(isdigit(f[i])){\n\t\tint n=0;\n\t\twhile(i<f.size() && isdigit(f[i]))\n\t\t\tn=n*10+f[i++]-'0';\n\t\tx.emplace_back(n,\"\");\n\t}\n\telse if(isalpha(f[i])){\n\t\tx.emplace_back(1,f.substr(i,1));\n\t\ti++;\n\t}\n\t\n\twhile(i<f.size() && f[i]==' ') i++;\n\tif(i<f.size() && f[i]=='^'){\n\t\ti++;\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t\tint n=0;\n\t\twhile(i<f.size() && isdigit(f[i])){\n\t\t\tn=n*10+f[i]-'0';\n\t\t\ti++;\n\t\t}\n\t\tx=pow(x,n);\n\t}\n\treturn mp(x,i);\n}\n\npair<vector<term>,int> parse_term(string f,int i)\n{\n\twhile(i<f.size() && f[i]==' ') i++;\n\tvector<term> x; tie(x,i)=parse_fact(f,i);\n\twhile(i<f.size() && f[i]==' ') i++;\n\twhile(i<f.size() && (f[i]=='(' || isdigit(f[i]) || isalpha(f[i]))){\n\t\tvector<term> y; tie(y,i)=parse_fact(f,i);\n\t\tx=mul(x,y);\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t}\n\treturn mp(x,i);\n}\n\npair<vector<term>,int> parse_expr(string f,int i)\n{\n\twhile(i<f.size() && f[i]==' ') i++;\n\tvector<term> x; tie(x,i)=parse_term(f,i);\n\twhile(i<f.size() && f[i]==' ') i++;\n\twhile(i<f.size() && (f[i]=='+' || f[i]=='-')){\n\t\ti++;\n\t\tvector<term> y; tie(y,i)=parse_term(f,i);\n\t\tx=add(x,y);\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t}\n\treturn mp(x,i);\n}\n\nint main()\n{\n\tfor(string line;getline(cin,line) && line!=\".\";){\n\t\tvs fs;\n\t\tdo{\n\t\t\tfs.push_back(line);\n\t\t\tgetline(cin,line);\n\t\t}while(line!=\".\");\n\t\t\n\t\tauto t0=normalize(parse_expr(fs[0],0).first);\n\t\trepi(i,1,fs.size())\n\t\t\tcout<<(normalize(parse_expr(fs[i],0).first)==t0?\"yes\":\"no\")<<endl;\n\t\tcout<<'.'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef __int128  Val;\n\nconst Val EPS=1e-5;\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p));\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%4;\n      }\n      Val cor=formula(state[0],p);\n      p=0;\n      Val ans=formula(state[i],p);\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nstring processSpace(const string &str){\n    string res=\"\";\n    bool sp=false;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i]!=' '){\n            if(!sp&&res.size()!=0&&(res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                &&(str[i]>='0'&&str[i]<='9')){\n\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&(str[i]=='(')){\n                    res+='*';\n            }\n            else if(res.size()!=0&&(res[res.size()-1]==')')\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&res[res.size()-1]==')'&&str[i]=='(')\n                res+='*';\n            res+=str[i];\n            sp=false;\n        }\n        else{\n            sp=true;\n        }\n    }\n    return res;\n}\n\n\nvector<pair<int,map<string,int> > > analysis(string str){\n    vector<pair<int,map<string,int> > > res;\n    if(str.size()==0)return res;\n    // ©Ç¤©`FbN\n    bool allNum=true;\n    for(int i = 0; i < str.size(); i++){\n        if(!(str[i]>='0'&&str[i]<='9'))\n            allNum=false;\n    }\n    if(allNum){\n        res.push_back(make_pair(atoi(str.c_str()),map<string,int>()));\n        return res;\n    }\n    // e©`FbN\n    if(str.size()==1&&str[0]>='a'&&str[0]<='z'){\n        map<string,int> msi;\n        string tmp;\n        tmp+=(str[0]);\n        msi[tmp]=1;\n        res.push_back(make_pair(1,msi));\n        return res;\n    }\n    if(str[0]=='('){\n        int cnt=0;\n        bool no=false;\n        for(int i = 1; i < str.size()-1; i++){\n            if(str[i]==')')\n                cnt--;\n            else if(str[i]=='(')\n                cnt++;\n            if(cnt<0){\n                no=true;\n                break;\n            }\n        }\n        // ÊðÆé\n        if(!no)\n            return analysis(str.substr(1,str.size()-2));\n    }\n    // ÊÉZqðµÄ¢­\n\n    // vXZqÆ}CiXZqðTõ\n    int cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='+'||str[i]=='-'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                for(int j = 0; j < left.size(); j++){\n                    // Lªêv·éàÌðTõ\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==left[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+left[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-left[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no)\n                        res.push_back(left[j]);\n                }\n                for(int j = 0; j < right.size(); j++){\n                    // Lªêv·éàÌðTõ\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==right[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+right[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-right[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no)\n                        res.push_back(right[j]);\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='*'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                for(int k = 0; k < left.size(); k++){\n                    for(int j = 0; j < right.size(); j++){\n                        // êÂ¸Âvfð|¯ZµÄ¢­\n                        // W\n                        int co=left[k].first*right[j].first;\n                        map<string,int> literals=left[k].second;\n                        for(map<string,int>::iterator it=right[j].second.begin();it!=right[j].second.end();it++)\n                            literals[it->first]+=it->second;\n                        pair<int,map<string,int> > p=make_pair(co,literals);\n                        bool no=false;\n                        for(int l = 0; l < res.size(); l++){\n                            if(p.second==res[l].second){\n                                int coSum=p.first+res[l].first;\n                                if(coSum==0){\n                                    res.erase(res.begin()+l);\n                                    no=true;\n                                    break;\n                                }\n                                else{\n                                    res[l].first=coSum;\n                                    no=true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!no)\n                            res.push_back(p);\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='^'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                map<string,int> msi;\n                msi[left[0].second.begin()->first]=right[0].first;\n                res.push_back(make_pair(1,msi));\n                return res;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    string teacher;\n    while(getline(cin,teacher)&&teacher!=\".\"){\n        teacher=processSpace(teacher);\n        vector<pair<int,map<string,int> > > t=analysis(teacher);\n        string student;\n        while(getline(cin,student)&&student!=\".\"){\n            student=processSpace(student);\n            vector<pair<int,map<string,int> > > s=analysis(student);\n            if(s==t)\n                cout<<\"yes\"<<endl;\n            else\n                cout<<\"no\"<<endl;\n        }\n        cout<<\".\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1LL<<59)\n\n#define int ll\n\ntypedef array<int,27> AI;\ntypedef vector<AI> EX;\ntypedef string::const_iterator State;\n\nstring normalize(string s){\n\tstring t=\"\";\n\trep(i,s.size()){\n\t\tif(s[i]!=' ')t+=s[i];\n\t\telse if(i+1==s.size()||s[i+1]!=' ') t+=s[i];\n\t}\n\trep(i,t.size()-1)assert(t[i]!=' '||t[i+1]!=' ');\n\n\tstring u=\"\";\n\trep(i,t.size()){\n\t\tchar ch = t[i];\n\t\tif(ch!=' '){u+=ch;continue;}\n\n\t\tif(!(i-1<0||t[i-1]=='('||t[i-1]=='-'||t[i-1]=='+'||t[i-1]=='^')&&!(i+1>=t.size()||t[i+1]==')'||t[i+1]=='-'||t[i+1]=='+'||t[i+1]=='^'))u+=' ';\n\t}\n\trep(i,u.size())if(u[i]==' ')u[i] = '*';\n\t\n\tstring ret = \"\";\n\trep(i,u.size()){\n\t\tret+=u[i];\n\t\tif(i+1>=u.size())continue;\n\t\tif(isdigit(u[i])){\n\t\t\tif(u[i+1]=='('||isalpha(u[i+1]))ret+='*';\n\t\t}\n\t\tif(isalpha(u[i])){\n\t\t\tif(u[i+1]=='('||isnumber(u[i+1])||isalpha(u[i+1]))ret+='*';\n\t\t}\n\t}\n\treturn ret;\n}\n\nEX E(State &beg);\n\n\nint dig(State &beg){\n\tassert(isdigit(*beg));\n\tstring res = \"\";\n\twhile(isdigit(*beg)){\n\t\tres+=*beg;\n\t\tbeg++;\n\t}\n\treturn  stoll(res);\n}\n\n\nEX P(State &beg){\n\tif(isdigit(*beg)){\n\t\tint res = dig(beg);\n\t\tAI ret;\n\t\tret[0]=res;\n\t\tfor(int i=1;i<ret.size();i++)ret[i]=0;\n\t\treturn EX(1,ret);\n\t}\n\telse{\n\t\tassert(isalpha(*beg));\n\t\tchar ch = *beg;\n\t\tbeg++;\n\n\t\tif(*beg=='^'){\n\t\t\tbeg++;\n\t\t\tint t = dig(beg);\n\t\t\tAI ret;\n\t\t\trep(i,ret.size()){\n\t\t\t\tif(i==ch-'a'+1)ret[i] = t;\n\t\t\t\telse ret[i] = 0;\n\t\t\t}\n\t\t\tret[0]=1;\n\t\t\t\n\t\t\treturn EX(1,ret);\n\t\t}\n\t\telse{\n\t\t\tAI ret;\n\t\t\trep(i,ret.size()){\n\t\t\t\tif(i==ch-'a'+1)ret[i] = 1;\n\t\t\t\telse ret[i] = 0;\n\t\t\t}\n\t\t\tret[0]=1;\n\n\t\t\treturn EX(1,ret);\n\t\t}\n\t}\n}\n\n\nAI mul(AI a,AI b){\n\tAI ret;\n\tret[0] = a[0]*b[0];\n\tfor(int i=1;i<a.size();i++){\n\t\tret[i] = a[i]+b[i];\n\t}\n\treturn ret;\n}\n\nEX mulEX(EX a,EX b){\n\tEX ret;\n\trep(i,a.size()){\n\t\trep(j,b.size()){\n\t\t\tret.pb(mul(a[i],b[j]));\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nEX T(State &beg){\n\tEX ret;\n\tif(*beg=='('){\n\t\tbeg++;\n\t\tret = E(beg);\n\t\tbeg++;\n\t}\n\telse{\n\t\tassert(isdigit(*beg)||isalpha(*beg));\n\t\tret = P(beg);\n\t}\n\t\n\twhile(*beg=='*'){\n\t\tbeg++;\n\t\tEX t = T(beg);\n\t\tret = mulEX(ret,t);\n\t}\n\treturn ret;\n}\n\n\nbool isSame(AI a,AI b){\n\tfor(int i=1;i<a.size();i++){\n\t\tif( a[i]!=b[i] )return false;\n\t}\n\treturn true;\n}\n\n\nEX E(State &beg){\n\tEX res = T(beg);\n\t\n\twhile(*beg=='+'||*beg=='-'){\n\t\tif(*beg=='+'){\n\t\t\tbeg++;\n\t\t\tEX t = T(beg);\n\t\t\trep(i,t.size()){\n\t\t\t\tbool f=false;\n\t\t\t\trep(j,res.size()){\n\t\t\t\t\tif(isSame(t[i],res[j])){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tres[j][0]+=t[i][0];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tres.pb(t[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*beg=='-'){\n\t\t\tbeg++;\n\t\t\tEX t = T(beg);\n\t\t\trep(i,t.size()){\n\t\t\t\tbool f=false;\n\t\t\t\trep(j,res.size()){\n\t\t\t\t\tif(isSame(t[i],res[j])){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tres[j][0]-=t[i][0];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tt[i][0]*=-1;\n\t\t\t\t\tres.pb(t[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\nbool isMatch(EX a,EX b){\n\tsort(all(a));\n\tsort(all(b));\n\tif(a==b)return true;\n\telse return false;\n}\n\n\nvoid output(vector<EX> ans){\n\trep(i,ans.size()){\n\t\trep(j,ans[i].size()){\n\t\t\trep(k,ans[i][j].size()){\n\t\t\t\tcout<<ans[i][j][k]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl<<endl;\n\t}\n}\n\n\nsigned main(){\n\tassert(normalize(\"(a - b) (0-b+a) - 1a ^ 2 - b ^ 2\")==\"(a-b)*(0-b+a)-1*a^2-b^2\");\n\twhile(1){\n\t\tvector<string> vs;\n\t\tstring s;\n\t\twhile(getline(cin,s)&&s!=\".\"){\n\t\t\tvs.pb(s);\n\t\t}\n\t\tif(vs.size()==0)break;\n\t\t\n\t\trep(i,vs.size()) vs[i] = normalize(vs[i]);\n\t\t\n\t\tvector<EX> ans;\n\t\trep(i,vs.size()){\n\t\t\tState beg = vs[i].begin();\n\t\t\tEX res = E(beg);\n\t\t\tans.pb(res);\n\t\t}\n\t\t\n//\t\trep(i,vs.size())cout<<vs[i]<<\" \";cout<<endl;\n//\t\toutput(ans);\n\t\t\n\t\tfor(int i=1;i<ans.size();i++){\n\t\t\tif(isMatch(ans[0],ans[i])){\n\t\t\t\tcout<<\"yes\"<<endl;\n\t\t\t}\n\t\t\telse cout<<\"no\"<<endl;\n\t\t}\n\t\tcout<<\".\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <random>\n\nintmax_t ppow(intmax_t base, intmax_t iexp) {\n  intmax_t res=1;\n  for (intmax_t dbl=base; iexp; iexp>>=1) {\n    if (iexp & 1)\n      res *= dbl;\n\n    dbl *= dbl;\n  }\n  return res;\n}\n\nintmax_t apply(intmax_t lhs, char op, intmax_t rhs) {\n  switch (op) {\n    case '+': return lhs + rhs;\n    case '-': return lhs - rhs;\n    case '*': return lhs * rhs;\n    case '^': return ppow(lhs, rhs);\n    default: assert(false);\n  }\n}\n\nintmax_t fourt(\n    const std::string &s, size_t &i, const std::vector<intmax_t> &vars,\n    const std::vector<std::string> &ops={\"+-\", \"*\", \"^\", \"\"},\n    size_t prec=0) {\n\n  /* tsurai parser */\n  if (ops[prec].empty()) {\n    if (s[i] == '(') {\n      intmax_t tmp=fourt(s, ++i, vars, ops, 0);\n      assert(s[i] == ')');\n      ++i;\n      return tmp;\n    }\n    if (isalpha(s[i])) {\n      // we assume only one-character variables\n      return vars[s[i++]-'a'];\n    }\n    intmax_t res=0;\n    while (s[i] >= '0' && s[i] <= '9')\n      res = res*10 + s[i++]-'0';\n    return res;\n  }\n\n  intmax_t res=fourt(s, i, vars, ops, prec+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (!std::count(ops[prec].begin(), ops[prec].end(), op))\n      break;\n    intmax_t tmp=fourt(s, ++i, vars, ops, prec+1);\n    res = apply(res, op, tmp);\n  }\n  return res;\n}\n\nintmax_t parse(const std::string &s, const std::vector<intmax_t> &vars) {\n  size_t i=0;\n  return fourt(s, i, vars);\n}\n\nstd::string normalize(const std::string &s) {\n  // explicit `*' signs and no spaces\n  std::string res;\n  enum {\n    NONE, PAREN, FACTOR, OPERATOR\n  } last=NONE;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '(') {\n      if (last == FACTOR) {\n        res += '*';\n      }\n      res += '(';\n      last = PAREN;\n    } else if (s[i] == ')') {\n      res += ')';\n      last = FACTOR;\n    } else if (isalnum(s[i])) {\n      if (last == FACTOR) {\n        res += '*';\n      }\n      res += s[i];\n      if (isdigit(s[i])) {\n        while (i+1 < s.length() && isdigit(s[i+1]))\n          res += s[++i];\n      }\n      last = FACTOR;\n    } else if (!isspace(s[i])) {\n      res += s[i];\n      last = OPERATOR;\n    }\n  }\n  // fprintf(stderr, \"#< %s\\n\", res.c_str());\n  return res;\n}\n\nstd::mt19937 rsk(0315);\nint testcase_ends() {\n  char buf[96];\n  fgets(buf, sizeof buf, stdin);\n  std::string s=buf;\n  if (s == \".\\n\")\n    return 1;\n\n  s = normalize(s);\n  while (true) {\n    fgets(buf, sizeof buf, stdin);\n    std::string t=buf;\n    if (t == \".\\n\") {\n      printf(\".\\n\");\n      return 0;\n    }\n\n    t = normalize(t);\n    bool yes=true;\n    for (int i=0; i<810; ++i) {\n      std::vector<intmax_t> vars(26);\n      for (int j=0; j<26; ++j)\n        vars[j] = rsk() % 100;\n      \n      if (parse(s, vars) != parse(t, vars))\n        yes = false;\n    }\n\n    printf(\"%s\\n\", yes? \"yes\":\"no\");\n  }\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar in[120];\nlong double var[30];\nchar str[210];\nint cur;\nlong double expr();\nlong double term(){\n\tif('0'<=str[cur]&&str[cur]<='9'){\n\t\tlong double ret=0.0L;\n\t\twhile('0'<=str[cur]&&str[cur]<='9'){\n\t\t\tret*=10.0L;ret+=(long double)(str[cur++]-'0');\n\t\t}\n\t\treturn ret;\n\t}\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tlong double ret=expr();\n\t\tcur++;\n\t\treturn ret;\n\t}\n\tif('a'<=str[cur]&&str[cur]<='z'){\n\t\tlong double ret=var[str[cur]-'a'];\n\t\tcur++;\n\t\tif(str[cur]=='^'){\n\t\t\tcur++;\n\t\t\tint po=str[cur]-'0';cur++;\n\t\t\tlong double val=1.0L;\n\t\t\tfor(int i=0;i<po;i++)val*=ret;\n\t\t\tret=val;\n\t\t}\n\t\treturn ret;\n\t}\n}\nlong double fact(){\n\tlong double ret=term();\n\twhile(str[cur]=='*'||(str[cur]!='+'&&str[cur]!='-'&&str[cur]&&str[cur]!=')')){\n\t\tif(str[cur]=='*')cur++;\n\t\tlong double tmp=term();\n\t//\tprintf(\"%Lf * %Lf = %Lf\\n\",ret,tmp,ret*tmp);\n\t\tret*=tmp;\n\t}\n//\tprintf(\"%d %Lf\\n\",cur,ret);\n\treturn ret;\n}\nlong double expr(){\n\tlong double ret=fact();\n\twhile(str[cur]=='+'||str[cur]=='-'){\n\t\tcur++;\n\t\tchar ch=str[cur-1];\n\t\tlong double tmp=fact();\n\t\tif(ch=='+')ret+=tmp;\n\t\telse ret-=tmp;\n\t}\n\treturn ret;\n}\nlong double ABS(long double a){return max(a,-a);}\nint main(){\n\twhile(1){\n\t\tgets(in);\n\t\tif(in[0]=='.')break;\n\t\tint at=0;\n\t\tfor(int i=0;in[i];i++){\n\t\t\tif(in[i]==' '&&i&&'0'<=str[at-1]&&str[at-1]<='9'&&'0'<=in[i+1]&&in[i+1]<='9'){\n\t\t\t\tstr[at++]='*';\n\t\t\t}\n\t\t\tif(in[i]!=' ')str[at++]=in[i];\n\t\t}\n\t\twhile(1){\n\t\t\tgets(in);\n\t\t\tif(in[0]=='.')break;\n\t\t\tstr[at]='-';\n\t\t\tstr[at+1]='(';\n\t\t\tint ind=at+2;\n\t\t\tfor(int i=0;in[i];i++){\n\t\t\t\tif(in[i]==' '){\n\t\t\t\t\tif(i&&'0'<=str[ind-1]&&str[ind-1]<='9'&&'0'<=in[i+1]&&in[i+1]<='9'){\n\t\t\t\t\t\tstr[ind++]='*';\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstr[ind++]=in[i];\n\t\t\t}\n\t\t\tstr[ind++]=')';\n\t\t\tstr[ind]=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int i=0;i<500;i++){\n\t\t\t\tfor(int j=0;j<26;j++)var[j]=(long double)(rand()%1000)/200;\n\t\t\t\tcur=0;\n\t\t\t\tlong double res=expr();\n\t\t\t\tif(ABS(res)>0.5L){\n\t\t//\t\t\tprintf(\"%s %Lf %Lf\\n\",str,var[23],res);\n\t\t\t\t\tok=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t}\n\t\tprintf(\".\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar in[120];\nlong long var[30];\nchar str[210];\nint cur;\nlong long expr();\nlong long term(){\n\tif('0'<=str[cur]&&str[cur]<='9'){\n\t\tlong long ret=0;\n\t\twhile('0'<=str[cur]&&str[cur]<='9'){\n\t\t\tret*=10;ret+=str[cur++]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tlong long ret=expr();\n\t\tcur++;\n\t\treturn ret;\n\t}\n\tif('a'<=str[cur]&&str[cur]<='z'){\n\t\tlong long ret=var[str[cur]-'a'];\n\t\tcur++;\n\t\tif(str[cur]=='^'){\n\t\t\tcur++;\n\t\t\tint po=str[cur]-'0';cur++;\n\t\t\tlong long val=1;\n\t\t\tfor(int i=0;i<po;i++)val*=ret;\n\t\t\tret=val;\n\t\t}\n\t\treturn ret;\n\t}\n}\nlong long fact(){\n\tlong long ret=term();\n\twhile(str[cur]=='*'||(str[cur]!='+'&&str[cur]!='-'&&str[cur]&&str[cur]!=')')){\n\t\tif(str[cur]=='*')cur++;\n\t\tlong long tmp=term();\n\t\tret*=tmp;\n\t}\n\treturn ret;\n}\nlong long expr(){\n\tlong long ret=fact();\n\twhile(str[cur]=='+'||str[cur]=='-'){\n\t\tcur++;\n\t\tlong long tmp=fact();\n\t\tif(str[cur-1]=='+')ret+=tmp;\n\t\telse ret-=tmp;\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(1){\n\t\tgets(in);\n\t\tif(in[0]=='.')break;\n\t\tint at=0;\n\t\tfor(int i=0;in[i];i++){\n\t\t\tif(in[i]!=' ')str[at++]=in[i];\n\t\t}\n\t\twhile(1){\n\t\t\tgets(in);\n\t\t\tif(in[0]=='.')break;\n\t\t\tstr[at]='-';\n\t\t\tstr[at+1]='(';\n\t\t\tint ind=at+2;\n\t\t\tfor(int i=0;in[i];i++){\n\t\t\t\tif(in[i]==' '){\n\t\t\t\t\tif(i&&'0'<=in[i-1]&&in[i-1]<='9'&&'0'<=in[i+1]&&in[i+1]<='9'){\n\t\t\t\t\t\tstr[ind++]='*';\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstr[ind++]=in[i];\n\t\t\t}\n\t\t\tstr[ind++]=')';\n\t\t\tstr[ind]=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int i=0;i<500;i++){\n\t\t\t\tfor(int j=0;j<26;j++)var[j]=rand()%30;\n\t\t\t\tcur=0;\n\t\t\t\tif(expr()){ok=false;break;}\n\t\t\t}\n\t\t\tif(ok)printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t}\n\t\tprintf(\".\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nbool is_operator(char c){\n  string opes = \"+-^*\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nstring preprocessing(string s){\n  stringstream ss(s);\n  string res;\n  ss >> res;\n  while(ss>>s){\n    char a = res[res.size() - 1];\n    char b = s[0];\n    if(isdigit(a) && isdigit(b)) res += \"*\" + s;\n    else res +=  s;\n  }\n  /*\n  REP(i, res.size() - 1){\n    if((isalpha(res[i]) && isalpha(res[i + 1])) ||\n       (isdigit(res[i]) && isalpha(res[i + 1])) ||\n       (isalpha(res[i]) && isdigit(res[i + 1]))){\n      res.insert(++i, \"*\");\n    }\n  }\n  */\n  return res;\n}\ntypedef map<char,int> Var;\nVar mul(Var x, Var y){\n  FORIT(it, y){\n    x[it->first] += it->second;\n  }\n  return x;\n}\nstruct Result{\n  map<Var, int> value;\n  int p;\n  Result(map<Var, int> v, int p) : \n    value(v), p(p) {}\n};\nResult expression(const string& s, int p);\nResult term(const string& s, int p);\nResult term_pow(const string& s, int p);\nResult factor(const string& s, int p);\nResult expression(const string& s, int p){\n  Result r = term(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result t = term(s, r.p + 1);\n    FORIT(it, t.value){\n      if(s[r.p] == '+') r.value[it->first] += it->second;\n      if(s[r.p] == '-') r.value[it->first] -= it->second;\n    }\n    r.p = t.p;\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  Result r = factor(s, p);\n  while(r.p < s.size() && (isdigit(s[r.p]) || isalpha(s[r.p]) || s[r.p] == '(')){\n    if(s[r.p] == '*') r.p++;\n    Result t = factor(s, r.p);\n    map<Var, int> new_val;\n    FORIT(it1, r.value)FORIT(it2, t.value){\n      new_val[mul(it1->first, it2->first)] += it1->second * it2->second;\n    }\n    r.value = new_val;\n    r.p = t.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p){\n  if(s[p] == '('){\n    Result r = expression(s, p + 1);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(isdigit(s[p])){\n    int val = 0;\n    while(isdigit(s[p])){\n      val = val * 10 + s[p++] - '0';\n    }\n    map<Var, int> expr;\n    expr[ Var() ] = val;\n    return Result(expr, p);\n  }else if(isalpha(s[p])){\n    char c = s[p++];\n    if(s[p] == '^'){\n      p++;\n      int val = 0;\n      while(isdigit(s[p])){\n        val = val * 10 + s[p++] - '0';\n      }\n      map<Var, int> expr;\n      Var v; v[c] = val;\n      expr[v] = 1;\n      return Result(expr, p);\n    }else{\n      map<Var, int> expr;\n      Var v; v[c] = 1;\n      expr[v] = 1;\n      return Result(expr, p);\n    }\n    /*\n  }else if(s[p] == '-'){\n    Result r = factor(s, p + 1);\n    FORIT(it, r.value){\n      r.value[it->first] = -it->second;\n    }\n    return r;\n  }else if(s[p] == '+'){\n    Result r = factor(s, p + 1);\n    return r;\n    */\n  }else {\n    assert(false);\n  }\n}\nstring to_str(const Var& v){\n  string res;\n  FORIT(it, v){\n    if(res != \"\") res += \"*\";\n    stringstream ss;\n    ss << it->first;\n    if(it->second != 1){\n      ss << \"^\";\n      ss << it->second;\n    }\n    res += ss.str();\n  }\n  return res;\n}\nvoid print(map<Var, int>& expr){\n  FORIT(it, expr){\n    printf(\"%+d%s\", it->second, to_str(it->first).c_str());\n  }\n  putchar('\\n');\n}\nbool equal(map<Var, int> e1, map<Var, int> e2){\n  FORIT(it, e1){\n    if(e1[it->first] != e2[it->first]) return false;\n  }\n  FORIT(it, e2){\n    if(e1[it->first] != e2[it->first]) return false;\n  }\n  return true;\n}\nint main(){\n  string line;\n  while(getline(cin, line) && line != \".\"){\n    //cout << line << endl;\n    line = preprocessing(line);\n    //cout << line << endl;\n    Result r = expression(line, 0);\n    map<Var, int> expr = r.value;\n    //print(expr);\n    while(getline(cin, line) && line != \".\"){\n      line = preprocessing(line);\n      //cout << line << endl;\n      Result r = expression(line, 0);\n      map<Var, int> expr2 = r.value;\n      //print(expr2);\n      if(equal(expr, expr2)) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n    cout << \".\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nbool is_operator(char c){\n  string opes = \"+-^*\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nstring preprocessing(string s){\n  stringstream ss(s);\n  string res;\n  ss >> res;\n  while(ss>>s){\n    char a = res[res.size() - 1];\n    char b = s[0];\n    if(isdigit(a) && isdigit(b)) res += \"*\" + s;\n    else res +=  s;\n  }\n  return res;\n}\ntypedef map<char,int> Var;\nVar mul(Var x, Var y){\n  FORIT(it, y){\n    x[it->first] += it->second;\n  }\n  return x;\n}\nstruct Result{\n  map<Var, int> value;\n  int p;\n  Result(map<Var, int> v, int p) : \n    value(v), p(p) {}\n};\nResult expression(const string& s, int p);\nResult term(const string& s, int p);\nResult term_pow(const string& s, int p);\nResult factor(const string& s, int p);\nResult expression(const string& s, int p){\n  Result r = term(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result t = term(s, r.p + 1);\n    FORIT(it, t.value){\n      if(s[r.p] == '+') r.value[it->first] += it->second;\n      if(s[r.p] == '-') r.value[it->first] -= it->second;\n    }\n    r.p = t.p;\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  Result r = factor(s, p);\n  while(r.p < s.size() && (isdigit(s[r.p]) || isalpha(s[r.p]) || s[r.p] == '(' || s[r.p] == '*')){\n    if(s[r.p] == '*') r.p++;\n    Result t = factor(s, r.p);\n    map<Var, int> new_val;\n    FORIT(it1, r.value)FORIT(it2, t.value){\n      new_val[mul(it1->first, it2->first)] += it1->second * it2->second;\n    }\n    r.value = new_val;\n    r.p = t.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p){\n  if(s[p] == '('){\n    Result r = expression(s, p + 1);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(isdigit(s[p])){\n    int val = 0;\n    while(isdigit(s[p])){\n      val = val * 10 + s[p++] - '0';\n    }\n    map<Var, int> expr;\n    expr[ Var() ] = val;\n    return Result(expr, p);\n  }else if(isalpha(s[p])){\n    char c = s[p++];\n    if(s[p] == '^'){\n      p++;\n      int val = 0;\n      while(isdigit(s[p])){\n        val = val * 10 + s[p++] - '0';\n      }\n      map<Var, int> expr;\n      Var v; v[c] = val;\n      expr[v] = 1;\n      return Result(expr, p);\n    }else{\n      map<Var, int> expr;\n      Var v; v[c] = 1;\n      expr[v] = 1;\n      return Result(expr, p);\n    }\n    /*\n  }else if(s[p] == '-'){\n    Result r = factor(s, p + 1);\n    FORIT(it, r.value){\n      r.value[it->first] = -it->second;\n    }\n    return r;\n  }else if(s[p] == '+'){\n    Result r = factor(s, p + 1);\n    return r;\n    */\n  }else {\n    assert(false);\n  }\n}\nstring to_str(const Var& v){\n  string res;\n  FORIT(it, v){\n    if(res != \"\") res += \"*\";\n    stringstream ss;\n    ss << it->first;\n    if(it->second != 1){\n      ss << \"^\";\n      ss << it->second;\n    }\n    res += ss.str();\n  }\n  return res;\n}\nvoid print(map<Var, int>& expr){\n  FORIT(it, expr){\n    printf(\"%+d%s\", it->second, to_str(it->first).c_str());\n  }\n  putchar('\\n');\n}\nbool equal(map<Var, int> e1, map<Var, int> e2){\n  FORIT(it, e1){\n    if(e1[it->first] != e2[it->first]) return false;\n  }\n  FORIT(it, e2){\n    if(e1[it->first] != e2[it->first]) return false;\n  }\n  return true;\n}\nint main(){\n  string line;\n  while(getline(cin, line) && line != \".\"){\n    //cout << line << endl;\n    line = preprocessing(line);\n    //cout << line << endl;\n    Result r = expression(line, 0);\n    map<Var, int> expr = r.value;\n    //print(expr);\n    while(getline(cin, line) && line != \".\"){\n      line = preprocessing(line);\n      //cout << line << endl;\n      Result r = expression(line, 0);\n      map<Var, int> expr2 = r.value;\n      //print(expr2);\n      if(equal(expr, expr2)) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n    cout << \".\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstdlib>\n\nusing namespace std;\n\nchar s[1234567];\nchar *p;\n\ntypedef map<map<char,int>,int> E;\n\nE exp();\n\nE mul(){\n  while(*p==' '){\n    p++;\n  }\n  if(isdigit(*p)){\n    E e;\n    e[map<char,int>()]=strtol(p,&p,10);\n    return e;\n  }else if(*p=='('){\n    p++;\n    auto r=exp();\n    p++;\n    return r;\n  }else{\n    char c=*p;\n    p++;\n    while(*p==' '){\n      p++;\n    }\n    int pw;\n    if(*p!='^'){\n      pw=1;\n    }else{\n      p++;\n      pw=strtol(p,&p,10);\n    }\n    map<char,int> v;\n    v[c]=pw;\n    E e;\n    e[v]=1;\n    return e;\n  }\n}\n\nE term(){\n  auto l=mul();\n  for(;;){\n    while(*p==' '){\n      p++;\n    }\n    if(!isalnum(*p)&&*p!='(')break;\n    auto lo=l;\n    l.clear();\n    auto r=mul();\n    for(auto &e:lo){\n      for(auto &f:r){\n\tmap<char,int> v;\n\tfor(auto &ee:e.first){\n\t  v[ee.first]+=ee.second;\n\t}\n\tfor(auto &ff:f.first){\n\t  v[ff.first]+=ff.second;\n\t}\n\tl[v]+=e.second*f.second;\n      }\n    }\n  }\n  return l;\n}\n\nE exp(){\n  auto l=term();\n  for(;;){\n    while(*p==' '){\n      p++;\n    }\n    int f;\n    if(*p=='+'){\n      f=1;\n    }else if(*p=='-'){\n      f=-1;\n    }else{\n      break;\n    }\n    auto r=term();\n    for(auto &e:r){\n      l[e.first]+=f*e.second;\n    }\n  }\n  return l;\n}\n\nE startexp(){\n  p=s;\n  auto r=exp();\n  for(auto it=r.begin();it!=r.end();){\n    if(it->second==0){\n      it=r.erase(it);\n    }else{\n      it++;\n    }\n  }\n  return r;\n}\n\nint main(){\n  while(cin.getline(s,sizeof s),s[0]!='.'){\n    auto ans=startexp();\n    while(cin.getline(s,sizeof s),s[0]!='.'){\n      auto c=startexp();\n      cout<<((ans==c)?\"yes\":\"no\")<<endl;\n    }\n    cout<<\".\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<string,int> P;\ntypedef map<string,int> M;\n \nvoid pr(M a,string s=\"\"){\n  return;\n  cout<<s<<endl;\n  for(P p:a) cout<<p.first<<\" \"<<p.second<<endl;\n  cout<<\"end\"<<endl;\n}\n \nM add(M a,M b,int f=1){\n  for(P p2:b) a[p2.first] += f * p2.second;\n  return a;\n}\n \nM mult(M a,M b){\n  M res;\n  for(P p1:a)\n    for(P p2:b){\n      string s = p1.first + p2.first; sort(s.begin(),s.end());\n      int num = p1.second * p2.second;\n      res[s] += num;\n    }\n  return res;\n}\n \n \nM bnf();\nint pos;\nstring S;\nvoid skipsp(){while(S[pos] == ' ') pos++;}\n \nint getNum(){\n  int res = 0;\n  while((int)S.size()> pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n \nint getNum2(const string &S,int &pos){\n  int res = 0;\n  while((int)S.size()>pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n \nstring getBlock(){\n  string res;\n  skipsp();\n  while(isdigit(S[pos]) || isalpha(S[pos])) res += S[pos++];\n  skipsp();\n  if(S[pos] == '^') {\n    pos++;\n    skipsp();\n    assert(isdigit(S[pos])&&\"hut\");\n    int p = getNum();\n    for(int i=0;i<p-1;i++) res += res.back();\n  }\n  return res;\n}\n \nM BtoM(string b){\n  M res;\n  int num = 1;\n  string val;\n  for(int i=0;i<(int)b.size();i++){\n    char ch = b[i];\n    if(isalpha(ch)) val += ch;\n    else if(isdigit(ch)) num *= getNum2(b,i),i--;\n    else if(ch != ' ') assert(!\"BtoM\");\n  }\n  res[val] = num;\n  return res;\n}\n \nM calc(){\n  M res; res[\"\"] = 1;\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(isalpha(ch) || isdigit(ch)){\n      string block = getBlock();\n      res = mult(res,BtoM(block));\n    }\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n  pr(res,\"calc,res\");\n  return res;\n}\n \nM bnf(){\n  M res = calc();\n  pr(res,\"start bnf\");\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(isalpha(ch) || isdigit(ch)) res = mult(res,calc());\n    else if(ch == '+')pos++,res = add(res,calc());\n    else if(ch == '-')pos++,res = add(res,calc(),-1);\n    else if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n   \n  for(auto it=res.begin();it!=res.end();it++) if(it->second==0) res.erase(it);\n  pr(res,\"return bnf\");\n  return res;\n}\n \nsigned main(){\n  while(1){\n    getline(cin,S);\n    //cin.ignore();\n    if(S == \".\") break;\n    pos = 0;\n    M ori = bnf();\n    pr(ori,\"ori\");\n    while(1){\n      getline(cin,S);\n      if(S == \".\") break;\n      pos = 0;\n      M res = bnf();\n      cout<<((ori == res)? \"yes\":\"no\")<<endl;\n      pr(res,S);\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring f;\nint len;\nint p = 0;\n\nll exp();\nll term();\nll fact();\n\nll tbl['z' - 'a' + 1];\ninline ll c2n(char c){\n    return tbl[c - 'a'];\n}\n\nchar next_c(){\n    while(p < len and f[p] == ' ') p++;\n    return f[p];\n}\n\nll exp(){\n    ll ret = term();\n\n    char c;\n    while(c = next_c(), (c == '+' or c == '-')){\n        p++;\n        ll r = term();\n        if(c == '+') ret = ADD(ret, r, mod);\n        else         ret = SUB(ret, r, mod);\n    }\n\n    return ret;\n}\n\nconst ll ERR = 2LL * mod;\n\nll term(){\n    ll ret = fact();\n\n    ll r;\n    while((r = fact()) != ERR){\n        ret = MUL(ret, r, mod);\n    }\n\n    return ret;\n}\n\ninline ll num(){\n    ll ret = 0LL;\n    next_c();\n    while(isdigit(f[p])){\n        ret = ret * 10 + (f[p] - '0');\n        p++; // [0,9]\n    }\n    return ret;\n} \n\nll fact(){\n    ll ret = ERR;\n\n    char c = next_c();\n    if(c == '('){\n        p++; // (\n        ret = exp();\n        assert(next_c() == ')'); p++;\n    }\n    else if(islower(c)){\n        p++; // [a,z]\n        ret = c2n(c);\n\n        c = next_c();\n        if(c == '^'){\n            p++; // ^\n            ll d = num();\n            rep(loop, d - 1){\n                ret = MUL(ret, ret, mod);\n            }\n        }\n    }\n    else if(isdigit(c)){\n        ret = num();\n    }\n    else {\n        // cerr << \"cur... \" << c << endl;\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    auto myrand = bind(uniform_int_distribution<int>(0, (int)1e6), mt19937(static_cast<unsigned int>(time(nullptr))));\n\n    while(true){\n        string mine;\n        getline(cin, mine);\n        if(mine == \".\") break;\n        \n        while(true){\n            string opp;\n            getline(cin, opp);\n            if(opp == \".\") break;\n\n            bool ok = true;\n            rep(loop, 100){\n                rep(i, 'z' - 'a' + 1) tbl[i] = myrand();\n\n                // cerr << \"-> \" << mine << endl;\n                f = mine; p = 0; len = f.size(); ll a = exp();\n                // cerr << \"-> \" << opp << endl;\n                f =  opp; p = 0; len = f.size(); ll b = exp();\n\n                if(a != b){\n                    ok = false;\n                    break;\n                }\n            }\n\n            if(ok){\n                cout << \"yes\" << endl;\n            }\n            else {\n                cout << \"no\" << endl;\n            }\n        }\n        cout << \".\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstdlib>\n\nusing namespace std;\n\nchar s[1234567];\nchar *p;\n\ntypedef map<map<char,int>,int> E;\n\nE exp();\n\nE mul(){\n  while(*p==' '){\n    p++;\n  }\n  if(isdigit(*p)){\n    E e;\n    e[map<char,int>()]=strtol(p,&p,10);\n    return e;\n  }else if(*p=='('){\n    p++;\n    auto r=exp();\n    while(*p==' '){\n      p++;\n    }\n    p++;\n    return r;\n  }else{\n    char c=*p;\n    p++;\n    while(*p==' '){\n      p++;\n    }\n    int pw;\n    if(*p!='^'){\n      pw=1;\n    }else{\n      p++;\n      pw=strtol(p,&p,10);\n    }\n    map<char,int> v;\n    v[c]=pw;\n    E e;\n    e[v]=1;\n    return e;\n  }\n}\n\nE term(){\n  auto l=mul();\n  for(;;){\n    while(*p==' '){\n      p++;\n    }\n    if(!isalnum(*p)&&*p!='(')break;\n    auto lo=l;\n    l.clear();\n    auto r=mul();\n    for(auto &e:lo){\n      for(auto &f:r){\n\tmap<char,int> v;\n\tfor(auto &ee:e.first){\n\t  v[ee.first]+=ee.second;\n\t}\n\tfor(auto &ff:f.first){\n\t  v[ff.first]+=ff.second;\n\t}\n\tl[v]+=e.second*f.second;\n      }\n    }\n  }\n  return l;\n}\n\nE exp(){\n  auto l=term();\n  for(;;){\n    while(*p==' '){\n      p++;\n    }\n    int f;\n    if(*p=='+'){\n      f=1;\n    }else if(*p=='-'){\n      f=-1;\n    }else{\n      break;\n    }\n    p++;\n    auto r=term();\n    for(auto &e:r){\n      l[e.first]+=f*e.second;\n    }\n  }\n  return l;\n}\n\nE startexp(){\n  p=s;\n  auto r=exp();\n  for(auto it=r.begin();it!=r.end();){\n    if(it->second==0){\n      it=r.erase(it);\n    }else{\n      it++;\n    }\n  }\n  // for(auto e:r){\n  //   cout<<e.second;\n  //   for(auto f:e.first){\n  //     cout<<f.first<<f.second;\n  //   }\n  //   cout<<'*';\n  // }\n  // cout<<endl;\n  return r;\n}\n\nint main(){\n  while(cin.getline(s,sizeof s),s[0]!='.'){\n    auto ans=startexp();\n    while(cin.getline(s,sizeof s),s[0]!='.'){\n      auto c=startexp();\n      cout<<((ans==c)?\"yes\":\"no\")<<endl;\n    }\n    cout<<\".\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ll;\n \nstring s;\nint p;\n \nll A[200][300];\nint idx;\n \nll bnf();\n \nll get_num(){\n \n  if(s[p]=='('){\n     \n    p++;\n \n    ll res=bnf();\n     \n    p++;\n \n    return res;\n  }\n   \n  if('a'<=s[p]&&s[p]<='z') return A[idx][s[p++]];\n   \n  ll num=0;\n   \n  while('0'<=s[p]&&s[p]<='9') num=num*10+s[p]-'0', p++;\n \n  return num;\n   \n}\n \nll bnf3(){\n \n  ll res=get_num();\n   \n  while(p<s.size()){\n \n    if(s[p]=='^'){\n \n      p++;\n \n      ll r=get_num();\n \n      ll tmp=1;\n \n      for(int i=0;i<r;i++) tmp*=res;\n \n      res=tmp;\n       \n    }else break;\n     \n  }\n   \n  return res;\n}\n \nll bnf2(){\n \n  ll res=bnf3();\n \n  while(p<s.size()){\n \n    if(s[p]=='*'){\n \n      p++;\n \n      ll r=bnf3();\n       \n      res*=r;\n       \n    }else break;\n     \n  }\n   \n  return res;\n}\n \nll bnf(){\n \n  ll res=bnf2();\n   \n  while(p<s.size()){\n     \n    if(s[p]=='+'){\n \n      p++;\n       \n      ll r=bnf2();\n       \n      res+=r;\n       \n    }\n    else if(s[p]=='-'){\n \n      p++;\n \n      ll r=bnf2();\n \n      res-=r;\n       \n    }else break;\n     \n  }\n   \n  return res;\n}\n \nvoid change(){\n   \n  for(int i=0;i<s.size();i++)\n    if((s[i]==')'||('a'<=s[i]&&s[i]<='z')||('0'<=s[i]&&s[i]<='9')))\n      if((s[i+1]=='('||('a'<=s[i+1]&&s[i+1]<='z')||('0'<=s[i+1]&&s[i+1]<='9')))\n    if(!('0'<=s[i]&&s[i]<='9'&&'0'<=s[i+1]&&s[i+1]<='9'))\n      s=s.substr(0,i+1)+'*'+s.substr(i+1);\n \n   \n  for(int i=0;i<s.size();i++)\n     \n    if(s[i]==' ')\n       \n      while(s[i]==' '&&i+1<s.size()&&s[i+1]==' ') s.erase(s.begin()+i);\n   \n \n  if(s[0]==' ') s.erase(s.begin());\n   \n  if(s[s.size()-1]==' ') s.erase(s.begin()+s.size()-1);\n \n  for(int i=0;i<s.size();i++)\n    if(s[i]==' ')\n      if((s[i-1]==')'||('a'<=s[i-1]&&s[i-1]<='z')||('0'<=s[i-1]&&s[i-1]<='9')))\n    if((s[i+1]=='('||('a'<=s[i+1]&&s[i+1]<='z')||('0'<=s[i+1]&&s[i+1]<='9'))) s[i]='*';\n \n  for(int i=0;i<s.size();i++)\n     \n    if(s[i]==' ') s.erase(s.begin()+i), i--;\n   \n   \n}\n \nint main(){\n   \n  for(int T=0;T<200;T++)\n     \n    for(int i=0;i<300;i++) A[T][i]=rand();\n   \n  while(1){\n \n    string tmp=s;\n     \n    getline(cin,s);\n     \n    if(s==\".\") break;\n     \n    change();\n     \n    ll base[200];\n \n    for(int T=0;T<200;T++){\n      idx=T;\n      p=0;\n      base[T]=bnf();\n    }\n     \n    while(1){\n       \n      getline(cin,s);\n       \n      if(s==\".\"){\n    cout<<\".\"<<endl;\n    break;\n      }\n       \n      change();\n       \n      bool ans=true;\n       \n      for(int T=0;T<200;T++){\n           \n    idx=T;  \n    p=0;\n       \n    ll r=bnf();\n     \n    if(base[T]!=r) ans=false;\n     \n      }\n       \n      if(ans) cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n       \n    }\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nbool is_operator(char c){\n  string opes = \"+-^*\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nstring preprocessing(string s){\n  stringstream ss(s);\n  string res;\n  ss >> res;\n  while(ss>>s){\n    char a = res[res.size() - 1];\n    char b = s[0];\n    if(isdigit(a) && isdigit(b)) res += \"*\" + s;\n    else res +=  s;\n  }\n  return res;\n}\ntypedef map<char,int> Var;\nVar mul(Var x, Var y){\n  FORIT(it, y){\n    x[it->first] += it->second;\n  }\n  return x;\n}\nstruct Result{\n  map<Var, int> value;\n  int p;\n  Result(map<Var, int> v, int p) : \n    value(v), p(p) {}\n};\nResult expression(const string& s, int p);\nResult term(const string& s, int p);\nResult term_pow(const string& s, int p);\nResult factor(const string& s, int p);\nResult expression(const string& s, int p){\n  Result r = term(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result t = term(s, r.p + 1);\n    FORIT(it, t.value){\n      if(s[r.p] == '+') r.value[it->first] += it->second;\n      if(s[r.p] == '-') r.value[it->first] -= it->second;\n    }\n    r.p = t.p;\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  Result r = factor(s, p);\n  while(r.p < s.size() && (isdigit(s[r.p]) || isalpha(s[r.p]) || s[r.p] == '(' || s[r.p] == '*')){\n    if(s[r.p] == '*') r.p++;\n    Result t = factor(s, r.p);\n    map<Var, int> new_val;\n    FORIT(it1, r.value)FORIT(it2, t.value){\n      new_val[mul(it1->first, it2->first)] += it1->second * it2->second;\n    }\n    r.value = new_val;\n    r.p = t.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p){\n  if(s[p] == '('){\n    Result r = expression(s, p + 1);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(isdigit(s[p])){\n    int val = 0;\n    while(isdigit(s[p])){\n      val = val * 10 + s[p++] - '0';\n    }\n    map<Var, int> expr;\n    expr[ Var() ] = val;\n    return Result(expr, p);\n  }else if(isalpha(s[p])){\n    char c = s[p++];\n    if(s[p] == '^'){\n      p++;\n      int val = 0;\n      while(isdigit(s[p])){\n        val = val * 10 + s[p++] - '0';\n      }\n      map<Var, int> expr;\n      Var v; v[c] = val;\n      expr[v] = 1;\n      return Result(expr, p);\n    }else{\n      map<Var, int> expr;\n      Var v; v[c] = 1;\n      expr[v] = 1;\n      return Result(expr, p);\n    }\n  }else {\n    assert(false);\n  }\n}\nstring to_str(const Var& v){\n  string res;\n  FORIT(it, v){\n    if(res != \"\") res += \"*\";\n    stringstream ss;\n    ss << it->first;\n    if(it->second != 1){\n      ss << \"^\";\n      ss << it->second;\n    }\n    res += ss.str();\n  }\n  return res;\n}\nvoid print(map<Var, int>& expr){\n  FORIT(it, expr){\n    printf(\"%+d%s\", it->second, to_str(it->first).c_str());\n  }\n  putchar('\\n');\n}\nbool equal(map<Var, int> e1, map<Var, int> e2){\n  FORIT(it, e1){\n    if(e1[it->first] != e2[it->first]) return false;\n  }\n  FORIT(it, e2){\n    if(e1[it->first] != e2[it->first]) return false;\n  }\n  return true;\n}\nint main(){\n  string line;\n  while(getline(cin, line) && line != \".\"){\n    line = preprocessing(line);\n    Result r = expression(line, 0);\n    map<Var, int> expr = r.value;\n    while(getline(cin, line) && line != \".\"){\n      line = preprocessing(line);\n      Result r = expression(line, 0);\n      map<Var, int> expr2 = r.value;\n      if(equal(expr, expr2)) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n    cout << \".\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nstring processSpace(const string &str){\n    string res=\"\";\n    bool sp=false;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i]!=' '){\n            if(!sp&&res.size()!=0&&(res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                &&(str[i]>='0'&&str[i]<='9')){\n\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&(str[i]=='(')){\n                    res+='*';\n            }\n            else if(res.size()!=0&&(res[res.size()-1]==')')\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&res[res.size()-1]==')'&&str[i]=='(')\n                res+='*';\n            res+=str[i];\n            sp=false;\n        }\n        else{\n            sp=true;\n        }\n    }\n    return res;\n}\n\n\nvector<pair<int,map<string,int> > > analysis(string str){\n    vector<pair<int,map<string,int> > > res;\n    if(str.size()==0)return res;\n    // ©Ç¤©`FbN\n    bool allNum=true;\n    for(int i = 0; i < str.size(); i++){\n        if(!(str[i]>='0'&&str[i]<='9'))\n            allNum=false;\n    }\n    if(allNum){\n        res.push_back(make_pair(atoi(str.c_str()),map<string,int>()));\n        return res;\n    }\n    // e©`FbN\n    if(str.size()==1&&str[0]>='a'&&str[0]<='z'){\n        map<string,int> msi;\n        string tmp;\n        tmp+=(str[0]);\n        msi[tmp]=1;\n        res.push_back(make_pair(1,msi));\n        return res;\n    }\n    if(str[0]=='('){\n        int cnt=0;\n        bool no=false;\n        for(int i = 1; i < str.size()-1; i++){\n            if(str[i]==')')\n                cnt--;\n            else if(str[i]=='(')\n                cnt++;\n            if(cnt<0){\n                no=true;\n                break;\n            }\n        }\n        // ÊðÆé\n        if(!no)\n            return analysis(str.substr(1,str.size()-2));\n    }\n    // ÊÉZqðµÄ¢­\n\n    // vXZqÆ}CiXZqðTõ\n    int cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='+'||str[i]=='-'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                for(int j = 0; j < left.size(); j++){\n                    // Lªêv·éàÌðTõ\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==left[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+left[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-left[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no)\n                        res.push_back(left[j]);\n                }\n                for(int j = 0; j < right.size(); j++){\n                    // Lªêv·éàÌðTõ\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==right[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+right[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-right[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no)\n                        res.push_back(right[j]);\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='*'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                for(int k = 0; k < left.size(); k++){\n                    for(int j = 0; j < right.size(); j++){\n                        // êÂ¸Âvfð|¯ZµÄ¢­\n                        // W\n                        int co=left[k].first*right[j].first;\n                        map<string,int> literals=left[k].second;\n                        for(map<string,int>::iterator it=right[j].second.begin();it!=right[j].second.end();it++)\n                            literals[it->first]+=it->second;\n                        pair<int,map<string,int> > p=make_pair(co,literals);\n                        bool no=false;\n                        for(int l = 0; l < res.size(); l++){\n                            if(p.second==res[l].second){\n                                int coSum=p.first+res[l].first;\n                                if(coSum==0){\n                                    res.erase(res.begin()+l);\n                                    no=true;\n                                    break;\n                                }\n                                else{\n                                    res[l].first=coSum;\n                                    no=true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!no)\n                            res.push_back(p);\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='^'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                map<string,int> msi;\n                msi[left[0].second.begin()->first]=right[0].first;\n                res.push_back(make_pair(1,msi));\n                return res;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    string teacher;\n    while(getline(cin,teacher)&&teacher!=\".\"){\n        teacher=processSpace(teacher);\n        vector<pair<int,map<string,int> > > t=analysis(teacher);\n        sort(t.begin(),t.end());\n        string student;\n        while(getline(cin,student)&&student!=\".\"){\n            student=processSpace(student);\n            vector<pair<int,map<string,int> > > s=analysis(student);\n            sort(s.begin(),s.end());\n            if(s==t)\n                cout<<\"yes\"<<endl;\n            else\n                cout<<\"no\"<<endl;\n        }\n        cout<<\".\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<string,int> P;\ntypedef map<string,int> M;\n \nvoid pr(M a,string s=\"\"){\n  return;\n  cout<<s<<endl;\n  for(P p:a) cout<<p.first<<\" \"<<p.second<<endl;\n  cout<<\"end\"<<endl;\n}\n \nM add(M a,M b,int f=1){\n  for(P p2:b) a[p2.first] += f * p2.second;\n  return a;\n}\n \nM mult(M a,M b){\n  M res;\n  for(P p1:a)\n    for(P p2:b){\n      string s = p1.first + p2.first; sort(s.begin(),s.end());\n      int num = p1.second * p2.second;\n      res[s] += num;\n    }\n  return res;\n}\n \n \nM bnf();\nint pos;\nstring S;\nvoid skipsp(){while(S[pos] == ' ') pos++;}\n \nint getNum(){\n  int res = 0;\n  while((int)S.size()> pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n \nint getNum2(const string &S,int &pos){\n  int res = 0;\n  while((int)S.size()>pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n \nstring getBlock(){\n  string res;\n  skipsp();\n  while(isdigit(S[pos]) || isalpha(S[pos])) res += S[pos++];\n  skipsp();\n  if(S[pos] == '^') {\n    pos++;\n    skipsp();\n    assert(isdigit(S[pos])&&\"hut\");\n    int p = getNum();\n    for(int i=0;i<p-1;i++) res += res.back();\n  }\n  return res;\n}\n \nM BtoM(string b){\n  M res;\n  int num = 1;\n  string val;\n  for(int i=0;i<(int)b.size();i++){\n    char ch = b[i];\n    if(isalpha(ch)) val += ch;\n    else if(isdigit(ch)) num *= getNum2(b,i),i--;\n    else if(ch != ' ') assert(!\"BtoM\");\n  }\n  res[val] = num;\n  return res;\n}\n \nM calc(){\n  M res; res[\"\"] = 1;\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(isalpha(ch) || isdigit(ch)){\n      string block = getBlock();\n      res = mult(res,BtoM(block));\n    }\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n  pr(res,\"calc,res\");\n  return res;\n}\n \nM bnf(){\n  M res = calc();\n  pr(res,\"start bnf\");\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(isalpha(ch) || isdigit(ch)) res = mult(res,calc());\n    else if(ch == '+')pos++,res = add(res,calc());\n    else if(ch == '-')pos++,res = add(res,calc(),-1);\n    else if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n   \n  for(auto it=res.begin();it!=res.end();it++) if(it->second==0) res.erase(it--);\n  pr(res,\"return bnf\");\n  return res;\n}\n \nsigned main(){\n  while(1){\n    getline(cin,S);\n    //cin.ignore();\n    if(S == \".\") break;\n    pos = 0;\n    M ori = bnf();\n    pr(ori,\"ori\");\n    while(1){\n      getline(cin,S);\n      if(S == \".\") break;\n      pos = 0;\n      M res = bnf();\n      cout<<((ori == res)? \"yes\":\"no\")<<endl;\n      pr(res,S);\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\ntypedef map<vi, int> E;\n\nE operator+(E a, const E &b){\n\teach(i, b) a[i->first] += i->second;\n\treturn a;\n}\nE operator-(E a, const E &b){\n\teach(i, b) a[i->first] -= i->second;\n\treturn a;\n}\nE operator*(const E &a, const E &b){\n\tE c;\n\teach(i, a) each(j, b){\n\t\tvi v = i->first;\n\t\trep(k, 26) v[k] += (j->first)[k];\n\t\tc[v] += i->second * j->second;\n\t}\n\treturn c;\n}\nint p;\nstring in, next;\nE expr();\nvoid get(){\n\tnext = \"\";\n\twhile(p < in.size() && isspace(in[p])) p++;\n\tif(p >= in.size()) return;\n\tif(isdigit(in[p])){\n\t\twhile(p < in.size() && isdigit(in[p])) next += in[p++];\n\t}else{\n\t\tnext += in[p++];\n\t}\n}\nE primary(){\n\tE res;\n\tif(isdigit(next[0])){\n\t\tvi v(26);\n\t\tres[v] = atoi(next.c_str());\n\t\treturn res;\n\t}\n\tif(isalpha(next[0])){\n\t\tvi v(26);\n\t\tv[next[0] - 'a'] = 1;\n\t\tres[v] = 1;\n\t\treturn res;\n\t}\n\tget();\n\tres = expr();\n\treturn res;\n}\nE factor(){\n\tE res = primary();\n\tget();\n\tif(next == \"^\"){\n\t\tget();\n\t\tint d = atoi(next.c_str()) - 1;\n\t\tE e = res;\n\t\twhile(d--) res = res * e;\n\t\tget();\n\t}\n\treturn res;\n}\nE term(){\n\tE res;\n\twhile(1){\n\t\tE f = factor();\n\t\tif(res.empty()) res = f;\n\t\telse res = res * f;\n\t\tif(next == \"\" || next == \"+\" || next == \"-\" || next ==\")\") break;\n\t}\n\treturn res;\n}\nE expr(){\n\tE t = term();\n\twhile(next == \"+\" || next == \"-\"){\n\t\tbool op = next == \"+\";\n\t\tget();\n\t\tE u = term();\n\t\tif(op) t = t + u;\n\t\telse t = t - u;\n\t}\n\treturn t;\n}\n\nE parse(){\n\tp = 0;\n\tget();\n\tE e = expr();\n\teach(i, e) if(i->second == 0) e.erase(i);\n\treturn e;\n}\nint main(){\n\twhile(getline(cin, in), in != \".\"){\n\t\tE a = parse();\n\t\twhile(getline(cin, in), in != \".\")\n\t\t\tcout << (a == parse() ? \"yes\" : \"no\") << endl;\n\t\tcout << \".\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nbool is_operator(char c){\n  string opes = \"+-^*\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nstring preprocessing(string s){\n  stringstream ss(s);\n  string res;\n  ss >> res;\n  while(ss>>s){\n    char a = res[res.size() - 1];\n    char b = s[0];\n    if(is_operator(a) || is_operator(b)) res += s;\n    else res += \"*\" + s;\n  }\n  REP(i, res.size() - 1){\n    if((isalpha(res[i]) && isalpha(res[i + 1])) ||\n       (isdigit(res[i]) && isalpha(res[i + 1])) ||\n       (isalpha(res[i]) && isdigit(res[i + 1]))){\n      res.insert(++i, \"*\");\n    }\n  }\n  return res;\n}\ntypedef map<char,int> Var;\nVar mul(Var x, Var y){\n  FORIT(it, y){\n    x[it->first] += it->second;\n  }\n  return x;\n}\nstruct Result{\n  map<Var, int> value;\n  int p;\n  Result(map<Var, int> v, int p) : \n    value(v), p(p) {}\n};\nResult expression(const string& s, int p);\nResult term(const string& s, int p);\nResult term_pow(const string& s, int p);\nResult factor(const string& s, int p);\nResult expression(const string& s, int p){\n  Result r = term(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result t = term(s, r.p + 1);\n    FORIT(it, t.value){\n      if(s[r.p] == '+') r.value[it->first] += it->second;\n      if(s[r.p] == '-') r.value[it->first] -= it->second;\n    }\n    r.p = t.p;\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  Result r = factor(s, p);\n  while(s[r.p] == '*'){\n    Result t = factor(s, r.p + 1);\n    map<Var, int> new_val;\n    FORIT(it1, r.value)FORIT(it2, t.value){\n      new_val[mul(it1->first, it2->first)] += it1->second * it2->second;\n    }\n    r.value = new_val;\n    r.p = t.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p){\n  if(s[p] == '('){\n    Result r = expression(s, p + 1);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(isdigit(s[p])){\n    int val = 0;\n    while(isdigit(s[p])){\n      val = val * 10 + s[p++] - '0';\n    }\n    map<Var, int> expr;\n    expr[ Var() ] = val;\n    return Result(expr, p);\n  }else if(isalpha(s[p])){\n    char c = s[p++];\n    if(s[p] == '^'){\n      p++;\n      int val = 0;\n      while(isdigit(s[p])){\n        val = val * 10 + s[p++] - '0';\n      }\n      map<Var, int> expr;\n      Var v; v[c] = val;\n      expr[v] = 1;\n      return Result(expr, p);\n    }else{\n      map<Var, int> expr;\n      Var v; v[c] = 1;\n      expr[v] = 1;\n      return Result(expr, p);\n    }\n  }else if(s[p] == '-'){\n    Result r = factor(s, p + 1);\n    FORIT(it, r.value){\n      r.value[it->first] = -it->second;\n    }\n    return r;\n  }else if(s[p] == '+'){\n    Result r = factor(s, p + 1);\n    return r;\n  }else {\n    assert(false);\n  }\n}\nstring to_str(const Var& v){\n  string res;\n  FORIT(it, v){\n    if(res != \"\") res += \"*\";\n    stringstream ss;\n    ss << it->first;\n    if(it->second != 1){\n      ss << \"^\";\n      ss << it->second;\n    }\n    res += ss.str();\n  }\n  return res;\n}\nvoid print(map<Var, int>& expr){\n  FORIT(it, expr){\n    printf(\"%+d%s\", it->second, to_str(it->first).c_str());\n  }\n  putchar('\\n');\n}\nbool equal(map<Var, int> e1, map<Var, int> e2){\n  FORIT(it, e1){\n    if(e1[it->first] != e2[it->first]) return false;\n  }\n  FORIT(it, e2){\n    if(e1[it->first] != e2[it->first]) return false;\n  }\n  return true;\n}\nint main(){\n  string line;\n  while(getline(cin, line) && line != \".\"){\n    //cout << line << endl;\n    line = preprocessing(line);\n    Result r = expression(line, 0);\n    map<Var, int> expr = r.value;\n    //print(expr);\n    while(getline(cin, line) && line != \".\"){\n      //cout << line << endl;\n      line = preprocessing(line);\n      Result r = expression(line, 0);\n      map<Var, int> expr2 = r.value;\n      //print(expr2);\n      if(equal(expr, expr2)) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n    cout << \".\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double Val;\n\nconst Val EPS=1e-8;\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p));\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=double(rnd())/1e10;\n      }\n      Val cor=formula(state[0],p);\n      p=0;\n      Val ans=formula(state[i],p);\n      isok&=(abs(cor-ans)<EPS);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n  Parsing(string s){ parse = s, pos = 0; }\n\n  ll fact(){\n    if(parse[pos] == '('){\n      pos++;\n      ll p = expression();\n      pos++;\n      return p;\n    }else{\n      ll p=0;\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n        p *= 10LL;\n        p += parse[pos]-'0';\n        pos++;\n      }\n      return p;\n    }\n  }\n\n  ll pow(){\n    ll p = fact();\n    while( parse[pos] == '^' ){\n      pos++;\n      ll limit = fact();\n      ll tmp = 1LL;\n      rep(_,limit) tmp *= p;\n      p = tmp;\n    }\n    return p;\n  }\n \n  ll term(){\n    ll p = pow();\n    while(parse[pos] == '*' || parse[pos] == '/'){\n      if(parse[pos] == '*'){pos++;p *= pow();}\n      else {pos++;p /= pow();}\n    }\n    return p;\n  }\n \n  ll expression(){\n    ll p = term();\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){pos++;p+=term();}\n      else {pos++;p-=term();}\n    }\n    return p;\n  } \n \n};\n\ninline bool isNum(char c) { return '0' <= c && c <= '9'; }\ninline bool isVar(char c) { return 'a' <= c && c <= 'z'; }\n\nbool isMulti(char a,char b,bool flag){\n  if( flag && isNum(a) && isNum(b) ) return true;\n  if( isNum(a) && isVar(b) ) return true;\n  if( isVar(a) && isVar(b) ) return true;\n  if( isVar(a) && isNum(b) ) return true;\n  if( ( a == ')' ) && ( b == '(' ) ) return true;\n  if( ( a == ')' ) && ( isNum(b) || isVar(b) ) ) return true;\n  if( ( isNum(a) || isVar(a) ) && ( b == '(' ) ) return true;\n  return false;\n}\n\nstring Craftworks(string s){\n  string ret = \"\",tmp = \"\";\n  stringstream ss;\n  ss << s;\n  vector<string> buf;\n  while( !(ss>>s).fail() ) buf.push_back(s);\n  rep(i,buf.size()){\n    if( i+1 < buf.size() && isMulti(buf[i][(int)buf[i].size()-1],buf[i+1][0],true) ) {\n      tmp += ( buf[i] + \"*\" );\n    } else tmp += buf[i];\n  }\n  rep(i,tmp.size()){\n    if( i+1 < tmp.size() && isMulti(tmp[i],tmp[i+1],false) ) ret += string(1,tmp[i]) + \"*\";\n    else                                                     ret += string(1,tmp[i]);\n  }\n  return ret;\n}\n\nconst int MOD = 10;\n\nstring itos(int i) { stringstream ss; ss << i; return ss.str(); }\n\nint main(){\n  srand((unsigned int)time(NULL));\n  string s;\n  while( 1 ){\n    vector<string> vec;\n    while( getline(cin,s) ) {\n      if( s == \".\" ) break;\n      vec.push_back(s);\n    }\n    if( vec.empty() ) break;\n    rep(i,vec.size()) vec[i] = Craftworks(vec[i]);\n\n    vector<bool> verdict(vec.size(),true);\n\n    rep(_,100){\n      vector<string> value(26);\n      rep(i,26) value[i] = itos(rand() % MOD + 1);\n      vector<ll> result;\n\n      rep(i,vec.size()){\n        string buf;\n        rep(j,vec[i].size()) {\n          if( vec[i][j] == ' ' ) continue;\n          if( 'a' <= vec[i][j] && vec[i][j] <= 'z' ) buf += value[vec[i][j]-'a'];\n          else                                       buf += vec[i][j];\n        }\n        Parsing par(buf);\n        result.push_back(par.expression());\n        if( i ) verdict[i] = verdict[i] & ( result[i] == result[0] );\n      }\n    }\n    REP(i,1,vec.size()) puts(verdict[i]?\"yes\":\"no\");\n    puts(\".\");\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nstring processSpace(const string &str){\n    string res=\"\";\n    bool sp=false;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i]!=' '){\n            if(!sp&&res.size()!=0&&(res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                &&(str[i]>='0'&&str[i]<='9')){\n\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&(str[i]=='(')){\n                    res+='*';\n            }\n            else if(res.size()!=0&&(res[res.size()-1]==')')\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&res[res.size()-1]==')'&&str[i]=='(')\n                res+='*';\n            res+=str[i];\n            sp=false;\n        }\n        else{\n            sp=true;\n        }\n    }\n    return res;\n}\n\n\nvector<pair<int,map<string,int> > > analysis(string str){\n    vector<pair<int,map<string,int> > > res;\n    if(str.size()==0)return res;\n    // ©Ç¤©`FbN\n    bool allNum=true;\n    for(int i = 0; i < str.size(); i++){\n        if(!(str[i]>='0'&&str[i]<='9')){\n            allNum=false;\n            break;\n        }\n    }\n    if(allNum){\n        int num=atoi(str.c_str());\n        if(num!=0)\n            res.push_back(make_pair(num,map<string,int>()));\n        return res;\n    }\n    // e©`FbN\n    if(str.size()==1&&str[0]>='a'&&str[0]<='z'){\n        map<string,int> msi;\n        string tmp;\n        tmp+=(str[0]);\n        msi[tmp]=1;\n        res.push_back(make_pair(1,msi));\n        return res;\n    }\n    if(str[0]=='('){\n        int cnt=0;\n        bool no=false;\n        for(int i = 1; i < str.size()-1; i++){\n            if(str[i]==')')\n                cnt--;\n            else if(str[i]=='(')\n                cnt++;\n            if(cnt<0){\n                no=true;\n                break;\n            }\n        }\n        // ÊðÆé\n        if(!no)\n            return analysis(str.substr(1,str.size()-2));\n    }\n    // ÊÉZqðµÄ¢­\n\n    // vXZqÆ}CiXZqðTõ\n    int cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='+'||str[i]=='-'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                for(int j = 0; j < left.size(); j++){\n                    // Lªêv·éàÌðTõ\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==left[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+left[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-left[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no)\n                        res.push_back(left[j]);\n                }\n                for(int j = 0; j < right.size(); j++){\n                    // Lªêv·éàÌðTõ\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==right[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+right[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-right[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no){\n                        if(str[i]=='-')right[j].first*=-1;\n                        res.push_back(right[j]);\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='*'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                for(int k = 0; k < left.size(); k++){\n                    for(int j = 0; j < right.size(); j++){\n                        // êÂ¸Âvfð|¯ZµÄ¢­\n                        // W\n                        int co=left[k].first*right[j].first;\n                        map<string,int> literals=left[k].second;\n                        for(map<string,int>::iterator it=right[j].second.begin();it!=right[j].second.end();it++)\n                            literals[it->first]+=it->second;\n                        pair<int,map<string,int> > p=make_pair(co,literals);\n                        bool no=false;\n                        for(int l = 0; l < res.size(); l++){\n                            if(p.second==res[l].second){\n                                int coSum=p.first+res[l].first;\n                                if(coSum==0){\n                                    res.erase(res.begin()+l);\n                                    no=true;\n                                    break;\n                                }\n                                else{\n                                    res[l].first=coSum;\n                                    no=true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!no)\n                            res.push_back(p);\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='^'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                map<string,int> msi;\n                msi[left[0].second.begin()->first]=right[0].first;\n                res.push_back(make_pair(1,msi));\n                return res;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    string teacher;\n    while(getline(cin,teacher)&&teacher!=\".\"){\n        teacher=processSpace(teacher);\n        vector<pair<int,map<string,int> > > t=analysis(teacher);\n        sort(t.begin(),t.end());\n        string student;\n        while(getline(cin,student)&&student!=\".\"){\n            student=processSpace(student);\n            vector<pair<int,map<string,int> > > s=analysis(student);\n            sort(s.begin(),s.end());\n            if(s==t)\n                cout<<\"yes\"<<endl;\n            else\n                cout<<\"no\"<<endl;\n        }\n        cout<<\".\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n\n#define fprintf(...) void(0)\n\nclass Poly {\n  std::map<std::string, int> coefs;\n  // e.g. coefs[\"aab\"] == 2 <=> the polynomial has the term 2 a^2 b\n  const std::string s;\n\n  Poly &operator ^=(const Poly &oth) {\n    if (oth.coefs.size() == 1 && oth.coefs.find(\"\") != oth.coefs.end()) {\n      return (*this) ^= oth.coefs.find(\"\")->second;\n    } else if (oth.coefs.empty()) {\n      // means 0\n      coefs.clear();\n      coefs[\"\"] = 1;  // means 1\n      return (*this);\n    }\n\n    assert(false);\n  }\n\n  Poly &op_eq(char op, const Poly &rhs) {\n    // (*this) @= rhs\n    switch (op) {\n      case '+': return (*this) += rhs;\n      case '-': return (*this) -= rhs;\n      case '*': return (*this) *= rhs;\n      case '^': return (*this) ^= rhs;\n      default: assert(false);\n    }\n  }\n\n  Poly fourt(\n      size_t &i, \n      const std::vector<std::string> &ops={\"+-\", \"*\", \"^\", \"\"},\n      size_t prec=0) {\n\n    if (ops[prec].empty()) {\n      if (s[i] == '(') {\n        Poly tmp=fourt(++i, ops, 0);\n        assert(s[i] == ')');\n        ++i;\n        return tmp;\n      }\n      if (isalpha(s[i])) {\n        // we assume only one-character variables\n        return Poly(s[i++]);\n      }\n      int coef=0;\n      while (s[i] >= '0' && s[i] <= '9')\n        coef = coef*10 + s[i++]-'0';\n      return Poly(coef);\n    }\n\n    Poly res=fourt(i, ops, prec+1);\n    while (i < s.length()) {\n      char op=s[i];\n      if (!std::count(ops[prec].begin(), ops[prec].end(), op))\n        break;\n      Poly tmp=fourt(++i, ops, prec+1);\n      res.op_eq(op, tmp);\n    }\n    return res;\n  }\n\n  Poly &normalized() {\n    for (auto it=coefs.begin(); it!=coefs.end(); ++it) {\n      if (it->second == 0) {\n        fprintf(stderr, \"Removed: %s\\n\", it->first.c_str());\n        coefs.erase(it);\n      }\n    }\n    return *this;\n  }\n\npublic:\n  Poly(const std::string &s): s(s) {\n    size_t i=0;\n    coefs = fourt(i).coefs;  // ugh\n  }\n\n  Poly(char ch): s(1, ch) {\n    assert(isalpha(ch));\n    coefs[s] = 1;\n  }\n\n  Poly(int n): s(std::to_string(n)) {\n    if (n)\n      coefs[\"\"] = n;\n  }\n\n  Poly &operator +=(const Poly &oth) {\n    for (const auto &p: oth.coefs) {\n      const std::string &param=p.first;\n      int coef=p.second;\n      coefs[param] += coef;\n    }\n    return normalized();\n  }\n\n  Poly &operator -=(const Poly &oth) {\n    for (const auto &p: oth.coefs) {\n      const std::string &param=p.first;\n      int coef=p.second;\n      coefs[param] -= coef;\n    }\n    return normalized();\n  }\n\n  Poly &operator *=(const Poly &oth) {\n    Poly tmp(*this);\n    coefs.clear();\n    for (const auto &pl: tmp.coefs) {\n      for (const auto &pr: oth.coefs) {\n        std::string param=pl.first+pr.first;\n        std::sort(param.begin(), param.end());\n        coefs[param] += pl.second*pr.second;\n      }\n    }\n    return normalized();\n  }\n\n  Poly &operator ^=(int iexp) {\n    if (iexp == 0) {\n      // does not appear in #1233\n      coefs.clear();\n      coefs[\"\"] = 1;  // means 1\n    } else {\n      Poly tmp(*this);\n      for (int i=1; i<iexp; ++i)\n        // O(iexp) multiplications, ugh\n        *this *= tmp;\n    }\n    return normalized();\n  }\n\n  Poly operator +(const Poly &oth) const { return Poly(*this) += oth; }\n  Poly operator -(const Poly &oth) const { return Poly(*this) -= oth; }\n  Poly operator *(const Poly &oth) const { return Poly(*this) *= oth; }\n  Poly operator ^(int iexp) const { return Poly(*this) ^= iexp; }\n  bool operator ==(const Poly &oth) const { return coefs == oth.coefs; }\n\n  void debug() const {\n    if (coefs.empty()) {\n      fprintf(stderr, \"#> 0\\n\");\n      return;\n    }\n    fprintf(stderr, \"#>\");\n    for (const auto &p: coefs)\n      fprintf(stderr, \" %d%s\", p.second, p.first.c_str());\n    fprintf(stderr, \"\\n\");\n  }\n};\n\nstd::string normalize(const std::string &s) {\n  // explicit `*' signs and no spaces\n  std::string res;\n  enum {\n    NONE, PAREN, FACTOR, OPERATOR\n  } last=NONE;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '(') {\n      if (last == FACTOR) {\n        res += '*';\n      }\n      res += '(';\n      last = PAREN;\n    } else if (s[i] == ')') {\n      res += ')';\n      last = FACTOR;\n    } else if (isalnum(s[i])) {\n      if (last == FACTOR) {\n        res += '*';\n      }\n      res += s[i];\n      if (isdigit(s[i])) {\n        while (i+1 < s.length() && isdigit(s[i+1]))\n          res += s[++i];\n      }\n      last = FACTOR;\n    } else if (!isspace(s[i])) {\n      res += s[i];\n      last = OPERATOR;\n    }\n  }\n  fprintf(stderr, \"#< %s\\n\", res.c_str());\n  return res;\n}\n\nint testcase_ends() {\n  char buf[96];\n  fgets(buf, sizeof buf, stdin);\n  std::string s=buf;\n  if (s == \".\\n\")\n    return 1;\n\n  s = normalize(s);\n  Poly ps(s);\n  ps.debug();\n  while (true) {\n    fgets(buf, sizeof buf, stdin);\n    std::string t=buf;\n    if (t == \".\\n\") {\n      printf(\".\\n\");\n      return 0;\n    }\n\n    t = normalize(t);\n    Poly pt(t);\n    pt.debug();\n    printf(\"%s\\n\", (ps == pt)? \"yes\":\"no\");\n  }\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <random>\n\nint ppow(int base, int iexp) {\n  int res=1;\n  for (int dbl=base; iexp; iexp>>=1) {\n    if (iexp & 1)\n      res *= dbl;\n\n    dbl *= dbl;\n  }\n  return res;\n}\n\nint apply(int lhs, char op, int rhs) {\n  switch (op) {\n    case '+': return lhs + rhs;\n    case '-': return lhs - rhs;\n    case '*': return lhs * rhs;\n    case '^': return ppow(lhs, rhs);\n    default: assert(false);\n  }\n}\n\nint fourt(\n    const std::string &s, size_t &i, const std::vector<int> &vars,\n    const std::vector<std::string> &ops={\"+-\", \"*\", \"^\", \"\"},\n    size_t prec=0) {\n\n  /* tsurai parser */\n  if (ops[prec].empty()) {\n    if (s[i] == '(') {\n      int tmp=fourt(s, ++i, vars, ops, 0);\n      assert(s[i] == ')');\n      ++i;\n      return tmp;\n    }\n    if (isalpha(s[i])) {\n      // we assume only one-character variables\n      return vars[s[i++]-'a'];\n    }\n    int res=0;\n    while (s[i] >= '0' && s[i] <= '9')\n      res = res*10 + s[i++]-'0';\n    return res;\n  }\n\n  int res=fourt(s, i, vars, ops, prec+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (!std::count(ops[prec].begin(), ops[prec].end(), op))\n      break;\n    int tmp=fourt(s, ++i, vars, ops, prec+1);\n    res = apply(res, op, tmp);\n  }\n  return res;\n}\n\nint parse(const std::string &s, const std::vector<int> &vars) {\n  size_t i=0;\n  return fourt(s, i, vars);\n}\n\nstd::string normalize(const std::string &s) {\n  // explicit `*' signs and no spaces\n  std::string res;\n  enum {\n    NONE, PAREN, FACTOR, OPERATOR\n  } last=NONE;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '(') {\n      if (last == FACTOR) {\n        res += '*';\n      }\n      res += '(';\n      last = PAREN;\n    } else if (s[i] == ')') {\n      res += ')';\n      last = FACTOR;\n    } else if (isalnum(s[i])) {\n      if (last == FACTOR) {\n        res += '*';\n      }\n      res += s[i];\n      if (isdigit(s[i])) {\n        while (i+1 < s.length() && isdigit(s[i+1]))\n          res += s[++i];\n      }\n      last = FACTOR;\n    } else if (!isspace(s[i])) {\n      res += s[i];\n      last = OPERATOR;\n    }\n  }\n  // fprintf(stderr, \"#< %s\\n\", res.c_str());\n  return res;\n}\n\nstd::mt19937 rsk(0315);\nint testcase_ends() {\n  char buf[96];\n  fgets(buf, sizeof buf, stdin);\n  std::string s=buf;\n  if (s == \".\\n\")\n    return 1;\n\n  s = normalize(s);\n  while (true) {\n    fgets(buf, sizeof buf, stdin);\n    std::string t=buf;\n    if (t == \".\\n\") {\n      printf(\".\\n\");\n      return 0;\n    }\n\n    t = normalize(t);\n    bool yes=true;\n    for (int i=0; i<810; ++i) {\n      std::vector<int> vars(26);\n      for (int j=0; j<26; ++j)\n        vars[j] = rsk() % 10;\n      \n      if (parse(s, vars) != parse(t, vars))\n        yes = false;\n    }\n\n    printf(\"%s\\n\", yes? \"yes\":\"no\");\n  }\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< char,int > P;\ntypedef vector< P > vec;\ntypedef pair< int, vec > PP;\ntypedef vector< PP > mat;\nstring s;\nint p,len;\n\nmat add(mat a,mat b){\n  map< vec , int > mp;\n  \n  for(int i=0;i< (int)a.size();i++){\n    mp[ a[i].second ]+= a[i].first;\n  }\n\n  for(int i=0;i<(int)b.size();i++){\n    mp[ b[i].second ]+= b[i].first;\n  }\n\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  \n  sort(res.begin(),res.end());\n  \n  return res;\n}\n\nPP mul(PP a,PP b){\n  int fi=a.first*b.first;\n  vec &va=a.second;\n  vec &vb=b.second;\n  map<char,int> mp;\n  for(int i=0;i<(int)va.size();i++){\n    P p=va[i];\n    mp[ p.first ]+=p.second;\n  }\n  for(int j=0;j<(int)vb.size();j++){\n    P p=vb[j];\n    mp[ p.first ]+=p.second;\n  }\n\n  \n  vec se;\n\n  if(fi==0){\n    return PP(fi,se);\n  }\n  \n  map<char,int> :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    se.push_back( *it );\n  }\n  return PP(fi,se);\n}\n\nmat mul(mat a,mat b){\n  map< vec , int > mp;\n  for(int i=0;i<(int)a.size();i++){\n    PP as=a[i];\n    for(int j=0;j<(int)b.size();j++){\n      PP bs=b[j];\n\n      PP c=mul(as,bs);\n      mp[  c.second ] += c.first;\n    }\n  }\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  return res;  \n}\n\nmat target;\nmat solve();\n\nmat getNum(bool flg=false){\n  while(s[p]==' ')p++;\n\n\n\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    int res=0;\n    while('0'<=s[p]&&s[p]<='9'){\n      res=res*10+(s[p]-'0');\n      p++;\n    }\n    mat re;\n    vec r;\n    if(res>0)re.push_back(PP( res , r ));\n    return re;\n  }\n\n\n  \n  if('('==s[p]){\n    p++;\n    mat res=solve();\n    p++;\n    return res;\n  }\n\n  char ch=s[p++];\n  while(s[p]==' ')p++;\n  int num=1;\n  if(s[p]=='^'){\n    p++;\n    mat tmp=getNum(true);\n    num=tmp[0].first;\n\n  }\n  mat res;\n  vec r;\n  r.push_back(P(ch,num));\n  res.push_back(PP(1,r));\n  return res;\n}\n\nmat solve(){\n  while(s[p]==' ')p++;\n\n  stack < mat > st;\n  st.push( getNum() );\n\n  while(1){\n    while(s[p]==' ')p++;\n\n    if(p>=len){\n      break;\n    }else if(s[p]=='+'){\n      p++;\n      mat num=getNum();\n      st.push(num);\n    }else if(s[p]=='-'){\n      p++;\n      mat num=getNum();\n      for(int i=0;i<(int)num.size();i++)\n        num[i].first*=-1;\n      st.push(num);\n      \n    }else if(s[p]==')'){\n      break;\n    }else{\n      mat num=getNum();\n      mat A=st.top();\n      st.pop();\n      st.push( mul(A,num) );\n      \n    }\n  }\n  mat res=st.top();\n  st.pop();\n  while(!st.empty()){\n    res=add(res,st.top());\n    st.pop();\n  }\n\n  for(int i=0;i<(int)res.size();i++){\n    sort(res[i].second.begin(),res[i].second.end());\n  }\n  sort(res.begin(),res.end());\n  return res;\n}\n\nint main(){\n  while(1){\n    getline(cin,s);\n    if(s==\".\")break;\n    p=0;len=s.size();\n    target=solve();\n    \n    while(1){\n      getline(cin,s);\n      if(s==\".\")break;\n      p=0;len=s.size();\n      mat tmp=solve();\n      if(target==tmp)cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    cout<<'.'<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< char,int > P;\ntypedef vector< P > vec;\ntypedef pair< int, vec > PP;\ntypedef vector< PP > mat;\nstring s;\nint p,len;\n\nmat add(mat a,mat b){\n  map< vec , int > mp;\n  \n  for(int i=0;i< (int)a.size();i++){\n    mp[ a[i].second ]+= a[i].first;\n  }\n\n  for(int i=0;i<(int)b.size();i++){\n    mp[ b[i].second ]+= b[i].first;\n  }\n\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  return res;\n}\n\nPP mul(PP a,PP b){\n  int fi=a.first*b.first;\n  vec &va=a.second;\n  vec &vb=b.second;\n  map<char,int> mp;\n  for(int i=0;i<(int)va.size();i++){\n    P p=va[i];\n    mp[ p.first ]+=p.second;\n  }\n  for(int j=0;j<(int)vb.size();j++){\n    P p=vb[j];\n    mp[ p.first ]+=p.second;\n  }\n\n  \n  vec se;\n\n  if(fi==0){\n    return PP(fi,se);\n  }\n  \n  map<char,int> :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    se.push_back( *it );\n  }\n  return PP(fi,se);\n}\n\nmat mul(mat a,mat b){\n  map< vec , int > mp;\n  for(int i=0;i<(int)a.size();i++){\n    PP as=a[i];\n    for(int j=0;j<(int)b.size();j++){\n      PP bs=b[j];\n\n      PP c=mul(as,bs);\n      mp[  c.second ] += c.first;\n    }\n  }\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  return res;  \n}\n\nmat target;\nmat solve();\n\nmat getNum(){\n  while(s[p]==' ')p++;\n\n  if('0'<=s[p]&&s[p]<='9'){\n    int res=0;\n    while('0'<=s[p]&&s[p]<='9'){\n      res=res*10+(s[p]-'0');\n      p++;\n    }\n    mat re;\n    vec r;\n    if(res>0)re.push_back(PP( res , r ));\n    return re;\n  }\n\n  if('('==s[p]){\n    p++;\n    mat res=solve();\n    p++;\n    return res;\n  }\n\n  char ch=s[p++];\n  while(s[p]==' ')p++;\n  int num=1;\n  if(s[p]=='^'){\n    mat tmp=getNum();\n    assert(tmp.size()==1);\n    num=tmp[0].first;\n  }\n  mat res;\n  vec r;\n  r.push_back(P(ch,num));\n  res.push_back(PP(1,r));\n  return res;\n}\n\nmat solve(){\n  while(s[p]==' ')p++;\n\n  stack < mat > st;\n  st.push( getNum() );\n\n  while(1){\n    while(s[p]==' ')p++;\n\n    if(p>=len){\n      break;\n    }else if(s[p]=='+'){\n      p++;\n      mat num=getNum();\n      st.push(num);\n    }else if(s[p]=='-'){\n      p++;\n      mat num=getNum();\n      for(int i=0;i<(int)num.size();i++)\n        num[i].first*=-1;\n      st.push(num);\n      \n    }else if(s[p]==')'){\n      break;\n    }else{\n      mat num=getNum();\n      mat A=st.top();\n      st.pop();\n      st.push( mul(A,num) );\n      \n    }\n  }\n  mat res=st.top();\n  st.pop();\n  while(!st.empty()){\n    res=add(res,st.top());\n    st.pop();\n  }\n\n  for(int i=0;i<(int)res.size();i++){\n    sort(res[i].second.begin(),res[i].second.end());\n  }\n  sort(res.begin(),res.end());\n  return res;\n}\n\nint main(){\n  while(1){\n    getline(cin,s);\n    if(s==\".\")break;\n    p=0;len=s.size();\n    target=solve();\n    \n    while(1){\n      getline(cin,s);\n      if(s==\".\")break;\n      p=0;len=s.size();\n      mat tmp=solve();\n      if(target==tmp)cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    cout<<'.'<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nvector<vector<ll>> rnd(100, vector<ll>(26));\nint p, var;\n\nll sum(string& s);\n\nll num(string& s)\n{\n\tll res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nll unit(string& s)\n{\n\tll res;\n\twhile (s[p] == ' ') p++;\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\tres = sum(s);\n\t\tp++;\n\t}\n\telse if (isdigit(s[p])) res = num(s);\n\telse if (islower(s[p]))\n\t{\n\t\tres = rnd[var][s[p] - 'a'];\n\t\tp++;\n\t}\n\telse assert(false);\n\treturn res;\n}\n\nll pow(string& s)\n{\n\tll lhs = unit(s);\n\twhile (s[p] == '^')\n\t{\n\t\tp++;\n\t\twhile (s[p] == ' ') p++;\n\t\tll rhs = pow(s);\n\t\tll tmp = 1;\n\t\tREP(i, rhs)\n\t\t{\n\t\t\ttmp *= lhs;\n\t\t}\n\t\tlhs = tmp;\n\t}\n\treturn lhs;\n}\n\nll mul(string& s)\n{\n\tll lhs = pow(s);\n\twhile (s[p] == '*')\n\t{\n\t\tp++;\n\t\tll rhs;\n\t\trhs = pow(s);\n\t\tlhs *= rhs;\n\t}\n\treturn lhs;\n}\n\nll sum(string& s)\n{\n\tll lhs = mul(s);\n\twhile (s[p] == '+' || s[p] == '-')\n\t{\n\t\tif (s[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = mul(s);\n\t\t\tlhs += rhs;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = mul(s);\n\t\t\tlhs -= rhs;\n\t\t}\n\t}\n\treturn lhs;\n}\n\nll parse(string& s)\n{\n\tp = 0;\n\treturn sum(s);\n}\n\nbool isMulti(char a, char b, bool flag) {\n\tif (flag && isdigit(a) && isdigit(b)) return true;\n\tif (isdigit(a) && islower(b)) return true;\n\tif (islower(a) && islower(b)) return true;\n\tif (islower(a) && isdigit(b)) return true;\n\tif ((a == ')') && (b == '(')) return true;\n\tif ((a == ')') && (isdigit(b) || islower(b))) return true;\n\tif ((isdigit(a) || islower(a)) && (b == '(')) return true;\n\treturn false;\n}\n\nstring make(string s) {\n\tstring tmp, res;\n\tstringstream ss;\n\tss << s;\n\tvector<string> buf;\n\twhile (!(ss >> s).fail()) buf.push_back(s);\n\tREP(i, buf.size()) \n\t{\n\t\tif (i + 1 < buf.size() && isMulti(buf[i].back(), buf[i + 1][0], true)) \n\t\t{\n\t\t\ttmp += (buf[i] + \"*\");\n\t\t}\n\t\telse tmp += buf[i];\n\t}\n\tREP(i, tmp.size()) {\n\t\tif (i + 1 < tmp.size() && isMulti(tmp[i], tmp[i + 1], false)) res += string(1, tmp[i]) + \"*\";\n\t\telse res += string(1, tmp[i]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstring s, t;\n\tREP(i, 100)REP(j, 26) rnd[i][j] = rand() % 20;\n\twhile (getline(cin, s), s != \".\")\n\t{\n\t\tstring s_ = make(s);\n\t\twhile (getline(cin, t), t != \".\")\n\t\t{\n\t\t\tstring t_ = make(t);\n\t\t\tbool f = true;\n\t\t\tfor (var = 0; var < 100 && f; var++)\n\t\t\t{\n\t\t\t\tll lhs = parse(s_);\n\t\t\t\tll rhs = parse(t_);\n\t\t\t\tif (lhs != rhs) f = false;\n\t\t\t}\n\t\t\tputs(f ? \"yes\" : \"no\");\n\t\t}\n\t\tputs(\".\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint a = 0;\nvoid getspace(string st) {\n\twhile (st[a] == ' ')a++;\n\treturn;\n}\nmap<vector<int>, int>getcal(string st);\nint getnum(string st) {\n\tint num = 0;\n\t//getspace();\n\twhile (isdigit(st[a])) {\n\t\tnum = num * 10 + st[a] - '0';\n\t\ta++;\n\t}\n\treturn num;\n}\npair<char, int>getchar(string st) {\n\tchar ch = st[a];\n\ta++;\n\tbool  kakeru = false;\n\tgetspace(st);\n\t\n\tint num = 1;\n\tif (st[a] == '^') {\n\t\ta++;\n\t\tgetspace(st);\n\t\tassert(isdigit(st[a]));\n\t\tnum = getnum(st);\n\t}\n\treturn make_pair(ch, num);\n}\n\nmap<vector<int>, int>geta(string st) {\n\tgetspace(st);\n\tmap<vector<int>, int>mp;\n\tif (isdigit(st[a])) {\n\t\tconst int num(getnum(st));\n\t\tmap<vector<int>, int>newmp;\n\t\tnewmp[vector<int>(26, 0)] = num;\n\t\tmp=newmp;\n\t}\n\telse if (isalpha(st[a])) {\n\t\tpair<char, int>amp(getchar(st));\n\t\tmap<vector<int>, int>newmp;\n\t\tvector<int>v(26,0);\n\t\tv[amp.first - 'a'] += amp.second;\n\t\tnewmp[v] =1;\n\t\tmp = newmp;\n\t}\n\telse if (st[a] == '(') {\n\t\ta++;\n\t\tmp = getcal(st);\n\t\ta++;\n\t}\n\telse {\n\t\tassert(false);\n\t}\n\twhile (1) {\n\t\tgetspace(st);\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\treturn mp;\n\t\t}\n\t\telse if (st[a] == '(') {\n\t\t\ta++;\n\t\t\tmap<vector<int>, int>amp = getcal(st);\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (auto a : mp) {\n\t\t\t\tfor (auto b : amp) {\n\t\t\t\t\tvector<int>v1(a.first);\n\t\t\t\t\tvector<int>v2(b.first);\n\t\t\t\t\ttransform(v1.begin(), v1.end(), v2.begin(), v1.begin(), [](const int l, const int r) {return l + r; });\n\t\t\t\t\tnewmp[v1] += a.second*b.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t\tassert(st[a] == ')');\n\t\t\ta++;\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\treturn mp;\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\treturn mp;\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tconst int num(getnum(st));\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (const auto m : mp) {\n\t\t\t\tvector<int>v(m.first);\n\t\t\t\tnewmp[v] = m.second*num;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t}\n\t\telse if (isalpha(st[a])) {\n\t\t\tpair<char, int>amp(getchar(st));\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (const auto m : mp) {\n\t\t\t\tvector<int>v(m.first);\n\t\t\t\tv[amp.first - 'a'] += amp.second;\n\t\t\t\tnewmp[v] = m.second;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n}\n\nmap<vector<int>, int>getplmi(string st) {\n\tmap<vector<int>, int>mp(geta(st));\n\tgetspace(st);\n\twhile (1) {\n\t\tgetspace(st);\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\treturn mp;\n\t\t}\n\t\tif (st[a] == '(') {\n\t\t\tassert(false);\n\t\t\ta++;\n\t\t\tmap<vector<int>, int>amp = getcal(st);\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (auto a : mp) {\n\t\t\t\tfor (auto b : amp) {\n\t\t\t\t\tvector<int>v1(a.first);\n\t\t\t\t\tvector<int>v2(b.first);\n\t\t\t\t\ttransform(v1.begin(), v1.end(), v2.begin(), v2.end(), [](const int l, const int r) {return l + r; });\n\t\t\t\t\tnewmp[v1] += a.second*b.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t\tassert(st[a] == ')');\n\t\t\ta++;\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\treturn mp;\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\treturn mp;\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tassert(false);\n\t\t\tconst int num(getnum(st));\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (const auto m : mp) {\n\t\t\t\tvector<int>v(m.first);\n\t\t\t\tnewmp[v] = m.second*num;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t\ta++;\n\t\t}\n\t\telse if (isalpha(st[a])) {\n\t\t\tassert(false);\n\t\t\tpair<char, int>amp(getchar(st));\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (const auto m : mp) {\n\t\t\t\tvector<int>v(m.first);\n\t\t\t\tv[amp.first - 'a'] += amp.second;\n\t\t\t\tnewmp[v] = m.second;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t\ta++;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n}\n\nmap<vector<int>, int>getcal(string st) {\n\tmap<vector<int>, int>mp;\n\tgetspace(st);\n\tmp = getplmi(st);\n\twhile (1) {\n\t\tgetspace(st);\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\treturn mp;\n\t\t}else if (st[a] == '+') {\n\t\t\ta++;\n\t\t\tmap<vector<int>, int>amp = getplmi(st);\n\t\t\tmap<vector<int>, int>newmp(mp);\n\t\t\tfor (auto aa : amp) {\n\t\t\t\tnewmp[aa.first] += aa.second;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\ta++;\n\t\t\tmap<vector<int>, int>amp = getplmi(st);\n\t\t\tmap<vector<int>, int>newmp(mp);\n\t\t\tfor (auto a : amp) {\n\t\t\t\tnewmp[a.first] -= a.second;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tassert(false);\n\t\t}\n\t\telse if (isalpha(st[a])) {\n\t\t\tassert(false);\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\t\n}\n\nmap<vector<int>, int>getans(string st) {\n\ta = 0;\n\tmap<vector<int>,int> prov(getcal(st));\n\tmap<vector<int>, int> ans;\n\tfor (auto p : prov) {\n\t\tif (p.second) {\n\t\t\tans[p.first] = p.second;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tstring st;\n\twhile (1) {\n\t\tmap<vector<int>, int>ans;\n\t\tgetline(cin, st);\n\t\tans = getans(st);\n\t\tif (st == \".\") {\n\t\t\treturn 0;\n\t\t}\n\t\twhile (1) {\n\t\t\tgetline(cin, st);\n\t\t\tif (st == \".\") {\n\t\t\t\tcout << st << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap<vector<int>, int>nans(getans(st));\n\t\t\t\n\t\t\tif (nans == ans) {\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"no\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<string,int> P;\ntypedef map<string,int> M;\n\nM add(M a,M b){\n  for(P p2:b) a[p2.first] += p2.second;\n  return a;\n}\n\nM Minus(M a,M b){\n  for(P p2:b) a[p2.first] -= p2.second;\n  return a;\n}\n \nM mult(M a,M b){\n  M res;\n  for(P p1:a)\n    for(P p2:b){\n      string s = p1.first + p2.first; sort(s.begin(),s.end());\n      int num = p1.second * p2.second;\n      res[s] += num;\n    }\n  return res;\n}\n \nM bnf();\nint pos;\nstring S;\nvoid skipsp(){while(S[pos] == ' ') pos++;}\n \nint getNum(){\n  int res = 0;\n  while(isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n \nint getNum2(const string &S,int &pos){\n  int res = 0;\n  while(isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n\nstring getBlock(){\n  string res;\n  skipsp();\n  while(isdigit(S[pos]) || isalpha(S[pos])) res += S[pos++];\n  skipsp();\n  if(S[pos] == '^') {\n    pos++;\n    skipsp();\n    assert(isdigit(S[pos])&&\"hut\");\n    int p = getNum();\n    for(int i=0;i<p-1;i++) res += res.back();\n  }\n  return res;\n}\n \nM BtoM(string b){\n  M res;\n  int num = 1;\n  string val;\n  for(int i=0;i<(int)b.size();i++){\n    char ch = b[i];\n    if(isalpha(ch)) val += ch;\n    else if(isdigit(ch)) num *= getNum2(b,i),i--;\n    else assert(ch == ' ' &&  \"BtoM\");\n  }\n  res[val] = num;\n  return res;\n}\n \nM calc(){\n  M res; res[\"\"] = 1;\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(isalpha(ch) || isdigit(ch)){\n      string block = getBlock();\n      res = mult(res,BtoM(block));\n    }\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n  return res;\n}\n \nM bnf(){\n  M res = calc();\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(isalpha(ch) || isdigit(ch)) res = mult(res,calc());\n    else if(ch == '+')pos++,res = add(res,calc());\n    else if(ch == '-')pos++,res = Minus(res,calc());\n    else if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n  for(auto it=res.begin();it!=res.end();it++) if(it->second == 0) res.erase(it);\n  return res;\n}\n \nsigned main(){\n  while(1){\n    getline(cin,S);\n    if(S == \".\") break;\n    pos = 0;\n    M ori = bnf();\n    while(1){\n      getline(cin,S);\n      if(S == \".\") break;\n      pos = 0;\n      M res = bnf();\n      cout<<((ori == res)? \"yes\":\"no\")<<endl;\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef __int128  Val;\n\n\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return static_cast<long long int>(pow(res,term2(s,p))+1e9-7);\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%4;\n      }\n      Val cor=formula(state[0],p);\n      p=0;\n      Val ans=formula(state[i],p);\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nvector<vector<ll>> rnd(10, vector<ll>(26));\nint p, var;\n\nll sum(string& s);\n\nll num(string& s)\n{\n\tll res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nll unit(string& s)\n{\n\tll res;\n\twhile (s[p] == ' ') p++;\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\tres = sum(s);\n\t\tp++;\n\t}\n\telse if (isdigit(s[p])) res = num(s);\n\telse if (islower(s[p]))\n\t{\n\t\tres = rnd[var][s[p] - 'a'];\n\t\tp++;\n\t}\n\telse assert(false);\n\treturn res;\n}\n\nll pow(string& s)\n{\n\tll lhs = unit(s);\n\twhile (s[p] == '^')\n\t{\n\t\tp++;\n\t\twhile (s[p] == ' ') p++;\n\t\tll rhs = pow(s);\n\t\tll tmp = 1;\n\t\tREP(i, rhs)\n\t\t{\n\t\t\ttmp *= lhs;\n\t\t}\n\t\tlhs = tmp;\n\t}\n\treturn lhs;\n}\n\nll mul(string& s)\n{\n\tll lhs = pow(s);\n\twhile (s[p] == '*')\n\t{\n\t\tp++;\n\t\tll rhs;\n\t\trhs = pow(s);\n\t\tlhs *= rhs;\n\t}\n\treturn lhs;\n}\n\nll sum(string& s)\n{\n\tll lhs = mul(s);\n\twhile (s[p] == '+' || s[p] == '-')\n\t{\n\t\tif (s[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = mul(s);\n\t\t\tlhs += rhs;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = mul(s);\n\t\t\tlhs -= rhs;\n\t\t}\n\t}\n\treturn lhs;\n}\n\nll parse(string& s)\n{\n\tp = 0;\n\treturn sum(s);\n}\n\nbool isMulti(char a, char b, bool flag) {\n\tif (flag && isdigit(a) && isdigit(b)) return true;\n\tif (isdigit(a) && islower(b)) return true;\n\tif (islower(a) && islower(b)) return true;\n\tif (islower(a) && isdigit(b)) return true;\n\tif ((a == ')') && (b == '(')) return true;\n\tif ((a == ')') && (isdigit(b) || islower(b))) return true;\n\tif ((isdigit(a) || islower(a)) && (b == '(')) return true;\n\treturn false;\n}\n\nstring make(string s) {\n\tstring tmp, res;\n\tstringstream ss;\n\tss << s;\n\tvector<string> buf;\n\twhile (!(ss >> s).fail()) buf.push_back(s);\n\tREP(i, buf.size()) \n\t{\n\t\tif (i + 1 < buf.size() && isMulti(buf[i].back(), buf[i + 1][0], true)) \n\t\t{\n\t\t\ttmp += (buf[i] + \"*\");\n\t\t}\n\t\telse tmp += buf[i];\n\t}\n\tREP(i, tmp.size()) {\n\t\tif (i + 1 < tmp.size() && isMulti(tmp[i], tmp[i + 1], false)) res += string(1, tmp[i]) + \"*\";\n\t\telse res += string(1, tmp[i]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstring s, t;\n\tREP(i, 10)REP(j, 26) rnd[i][j] = rand() % 20;\n\twhile (getline(cin, s), s != \".\")\n\t{\n\t\tstring s_ = make(s);\n\t\twhile (getline(cin, t), t != \".\")\n\t\t{\n\t\t\tstring t_ = make(t);\n\t\t\tbool f = true;\n\t\t\tfor (var = 0; var < 10 && f; var++)\n\t\t\t{\n\t\t\t\tll lhs = parse(s_);\n\t\t\t\tll rhs = parse(t_);\n\t\t\t\tif (lhs != rhs) f = false;\n\t\t\t}\n\t\t\tputs(f ? \"yes\" : \"no\");\n\t\t}\n\t\tputs(\".\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint MOD;\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nlong long power(long long a, long long b)\n{\n    long long ret = 1;\n    long long tmp = a;\n    while(b > 0){\n        if(b & 1){\n            ret *= tmp;\n            ret %= MOD;\n        }\n        tmp *= tmp;\n        tmp %= MOD;\n        b >>= 1;\n    }\n    return ret;\n}\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nlong long calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        long long ret = 0;\n        for(int i=0; i<n; ++i){\n            ret *= 10;\n            ret += s[i] - '0';\n        }\n        return ret;\n    }\n\n    if(n == 1)\n        return variable[s[0]];\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                if(i == 0)\n                    return (calculate(t1) + calculate(t2)) % MOD;\n                else if(i == 1)\n                    return (calculate(t1) - calculate(t2) + MOD) % MOD;\n                else if(i == 2)\n                    return (calculate(t1) * calculate(t2)) % MOD;\n                else\n                    return power(calculate(t1), calculate(t2));\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nstring solve(string s, string t)\n{\n    s = normalize(s);\n    t = normalize(t);\n\n    for(int i=0; i<50; ++i){\n        MOD = xor128() % 10 + 1;\n        for(char c='a'; c<='z'; ++c)\n            variable[c] = xor128() % MOD;\n\n        long long x = calculate(s) % MOD;\n        long long y = calculate(t) % MOD;\n\n        if(x != y)\n            return \"no\";\n    }\n\n    return \"yes\";\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            cout << solve(s, t) << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\t//26\ntypedef map<vi,int> mvi;\nstring s;\nvi operator+(const vi& x,const vi& y){\n\tvi z;\n\trep(i,26) z.pb(x[i]+y[i]);\n\treturn z;\n}\nmvi pro(mvi a,mvi b){\n\tmvi c;\n\tfor(auto p:a) for(auto q:b){\n\t\tc[p.fs+q.fs]+=p.sc*q.sc;\n\t}\n\treturn c;\n}\nmvi expr(int& it);\nint dig(int &it){\n\tint x=0;\n\twhile(isdigit(s[it])){\n\t\tx*=10;\n\t\tx+=s[it]-'0';\n\t\tit++;\n\t}\n\treturn x;\n}\nmvi fac(int &it){\n\tif(s[it]==' ') it++;\n\tif(s[it]=='('){\n\t\tit++;\n\t\tmvi ret=expr(it);\n\t\tassert(s[it]==')');\n\t\tit++;\n\t\treturn ret;\n\t}else if(islower(s[it])){\n\t\tint c=s[it]-'a';\n\t\tint o=1;\n\t\tif(s[it+1]=='^'){\n\t\t\to=s[it+2]-'0';\n\t\t\tit+=2;\n\t\t}\n\t\tit++;\n\t\tmvi ret;\n\t\tvi a(26,0);\n\t\ta[c]=o;\n\t\tret[a]=1;\n\t\treturn ret;\n\t}else{\n\t\tassert(isdigit(s[it]));\n\t\tint x=dig(it);\n\t\tmvi ret;\n\t\tvi a(26,0);\n\t\tret[a]=x;\n\t\treturn ret;\n\t}\n}\nmvi term(int &it){\n\tmvi ret=fac(it);\n\twhile(it<s.size()&&s[it]!='+'&&s[it]!='-'&&s[it]!=')'){\n\t\tmvi a=fac(it);\n\t\tret=pro(ret,a);\n\t}\n\treturn ret;\n}\nmvi expr(int& it){\n\tmvi ret=term(it);\n\twhile(s[it]=='+'||s[it]=='-'){\n\t\tif(s[it]=='+'){\n\t\t\tit++;\n\t\t\tmvi a=term(it);\n\t\t\tfor(auto p:a) ret[p.fs]+=p.sc;\n\t\t}else{\n\t\t\tit++;\n\t\t\tmvi a=term(it);\n\t\t\tfor(auto p:a) ret[p.fs]-=p.sc;\n\t\t}\n\t}\n\treturn ret;\n}\nstring igs(string s){\n\tint i=0;\n\twhile(i<s.size()){\n\t\tif(s[i]==' ' && (i==0||!isdigit(s[i-1])||i+1==s.size()||!isdigit(s[i+1])) ) s.erase(i,1);\n\t\telse i++;\n\t}\n\treturn s;\n}\nbool isame(mvi a,mvi b){\n\tmvi x,y;\n\tfor(auto p:a) if(p.sc!=0) x[p.fs]=p.sc;\n\tfor(auto p:b) if(p.sc!=0) y[p.fs]=p.sc;\n\treturn x==y;\n}\nint main(){\n\twhile(true){\n\t\tgetline(cin,s);\n\t\tif(s[0]=='.'){\n\t\t\tputs(\".\");\n\t\t\tbreak;\n\t\t}\n\t\ts=igs(s);\n\t\tint it=0;\n\t\tmap<vi,int> ms=expr(it);\n\t\twhile(true){\n\t\t\tgetline(cin,s);\n\t\t\tif(s[0]=='.') break;\n\t\t\ts=igs(s);\n\t\t\tit=0;\n\t\t\tif(isame(expr(it),ms)) puts(\"yes\");\n\t\t\telse puts(\"no\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1LL<<59)\n\n#define int ll\n\ntypedef array<int,27> AI;\ntypedef vector<AI> EX;\ntypedef string::const_iterator State;\n\nstring normalize(string s){\n\tstring t=\"\";\n\trep(i,s.size()){\n\t\tif(s[i]!=' ')t+=s[i];\n\t\telse if(i+1==s.size()||s[i+1]!=' ') t+=s[i];\n\t}\n\trep(i,t.size()-1)assert(t[i]!=' '||t[i+1]!=' ');\n\t\n\tstring u=\"\";\n\trep(i,t.size()){\n\t\tchar ch = t[i];\n\t\tif(ch!=' '){u+=ch;continue;}\n\t\t\n\t\tif(!(i-1<0||t[i-1]=='('||t[i-1]=='-'||t[i-1]=='+'||t[i-1]=='^')&&!(i+1>=t.size()||t[i+1]==')'||t[i+1]=='-'||t[i+1]=='+'||t[i+1]=='^'))u+=' ';\n\t}\n\trep(i,u.size())if(u[i]==' ')u[i] = '*';\n\t\n\tstring ret = \"\";\n\trep(i,u.size()){\n\t\tret+=u[i];\n\t\tif(i+1>=u.size())continue;\n\t\tif(isdigit(u[i])){\n\t\t\tif(u[i+1]=='('||isalpha(u[i+1]))ret+='*';\n\t\t}\n\t\tif(isalpha(u[i])){\n\t\t\tif(u[i+1]=='('||isdigit(u[i+1])||isalpha(u[i+1]))ret+='*';\n\t\t}\n\t\tif(u[i]==')'&&(isalpha(u[i+1])||isdigit(u[i+1])||u[i+1]=='('))ret+='*';\n\t}\n\treturn ret;\n}\n\n\nEX E(State &beg);\n\n\nint dig(State &beg){\n\tassert(isdigit(*beg));\n\tstring res = \"\";\n\twhile(isdigit(*beg)){\n\t\tres+=*beg;\n\t\tbeg++;\n\t}\n\treturn  stoll(res);\n}\n\n\nEX P(State &beg){\n\tif(*beg=='('){\n\t\tEX ret;\n\t\tbeg++;\n\t\tret = E(beg);\n\t\tbeg++;\n\t\treturn ret;\n\t}\n\telse if(isdigit(*beg)){\n\t\tint res = dig(beg);\n\t\tAI ret;\n\t\tret[0]=res;\n\t\tfor(int i=1;i<ret.size();i++)ret[i]=0;\n\t\treturn EX(1,ret);\n\t}\n\telse{\n\t\tassert(isalpha(*beg));\n\t\tchar ch = *beg;\n\t\tbeg++;\n\t\t\n\t\tif(*beg=='^'){\n\t\t\tbeg++;\n\t\t\tint t = dig(beg);\n\t\t\tAI ret;\n\t\t\trep(i,ret.size())ret[i]=0;\n\t\t\tret[ch-'a'+1]=t;\n\t\t\tret[0]=1;\n\t\t\t\n\t\t\treturn EX(1,ret);\n\t\t}\n\t\telse{\n\t\t\tAI ret;\n\t\t\trep(i,ret.size())ret[i]=0;\n\t\t\tret[ch-'a'+1]=1;\n\t\t\tret[0]=1;\n\t\t\t\n\t\t\treturn EX(1,ret);\n\t\t}\n\t}\n}\n\n\nAI mul(AI a,AI b){\n\tAI ret;\n\tret[0] = a[0]*b[0];\n\tfor(int i=1;i<a.size();i++){\n\t\tret[i] = a[i]+b[i];\n\t}\n\treturn ret;\n}\n\n\nbool isZero(AI a){\n\tif(a[0]==0)return true;\n\telse return false;\n}\n\n\nbool isSame(AI a,AI b){\n\tassert(a[0]!=0&&b[0]!=0);\n\tfor(int i=1;i<a.size();i++){\n\t\tif( a[i]!=b[i] )return false;\n\t}\n\treturn true;\n}\n\n\nEX mulEX(EX a,EX b){\n\tEX t;\n\trep(i,a.size()){\n\t\trep(j,b.size()){\n\t\t\tAI res = mul(a[i],b[j]);\n\t\t\tif(!isZero(res))t.pb(res);\n\t\t}\n\t}\n\tEX ret;\n\tret.pb(t[0]);\n\tfor(int i=1;i<t.size();i++){\n\t\tbool f=false;\n\t\trep(j,ret.size()){\n\t\t\tif(isSame(t[i],ret[j])){\n\t\t\t\tf=true;\n\t\t\t\tret[j][0]+=t[i][0];\n\t\t\t\tif(isZero(ret[j])) ret.erase(ret.begin()+j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f){\n\t\t\tret.pb(t[i]);\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\n\nEX T(State &beg){\n\tassert(isdigit(*beg)||isalpha(*beg)||*beg=='(');\n\tvector<EX> t;\n\tt.pb(P(beg));\n\t\n\twhile(*beg=='*'){\n\t\tbeg++;\n\t\tt.pb(P(beg));\n\t\t\n\t}\n\tEX ret = t[0];\n\t\n\tfor(int i=1;i<t.size();i++){\n\t\tret = mulEX(ret,t[i]);\n\t}\n\treturn ret;\n}\n\n\nEX removeZero(EX a){\n\tEX ret;\n\trep(i,a.size()){\n\t\tif(!isZero(a[i]))ret.pb(a[i]);\n\t}\n\treturn ret;\n}\n\n\nEX E(State &beg){\n\tEX ret = removeZero(T(beg));\n\t\n\twhile(*beg=='+'||*beg=='-'){\n\t\tif(*beg=='+'){\n\t\t\tbeg++;\n\t\t\tEX t = removeZero(T(beg));\n\t\t\trep(i,t.size()){\n\t\t\t\tbool f=false;\n\t\t\t\trep(j,ret.size()){\n\t\t\t\t\tif(isSame(t[i],ret[j])){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tret[j][0]+=t[i][0];\n\t\t\t\t\t\tif(isZero(ret[j])) ret.erase(ret.begin()+j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tret.pb(t[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*beg=='-'){\n\t\t\tbeg++;\n\t\t\tEX t = removeZero(T(beg));\n\t\t\trep(i,t.size()){\n\t\t\t\tbool f=false;\n\t\t\t\trep(j,ret.size()){\n\t\t\t\t\tif(isSame(t[i],ret[j])){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tret[j][0]-=t[i][0];\n\t\t\t\t\t\tif(isZero(ret[j])) ret.erase(ret.begin()+j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tt[i][0]*=-1;\n\t\t\t\t\tret.pb(t[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = removeZero(ret);\n\t}\n\treturn ret;\n}\n\n\nbool isMatch(EX a,EX b){\n\tsort(all(a));\n\tsort(all(b));\n\tif(a==b)return true;\n\telse return false;\n}\n\n\nsigned main(){\n\tassert(normalize(\" (a - b) (0-b+a) - 1a ^ 2 - b ^ 2+ xyz^3xx(a+b)(b+a) \")==\"(a-b)*(0-b+a)-1*a^2-b^2+x*y*z^3*x*x*(a+b)*(b+a)\");\n\twhile(1){\n\t\tvector<string> vs;\n\t\tstring s;\n\t\twhile(getline(cin,s)&&s!=\".\"){\n\t\t\tvs.pb(s);\n\t\t}\n\t\tif(vs.size()==0)break;\n\t\t\n\t\trep(i,vs.size()) vs[i] = normalize(vs[i]);\n\t\t\n\t\tvector<EX> ans;\n\t\trep(i,vs.size()){\n\t\t\tState beg = vs[i].begin();\n\t\t\tEX res = E(beg);\n\t\t\tans.pb(res);\n\t\t\trep(i,res.size())assert(!isZero(res[i]));\n\t\t}\n\t\t\n\t\tfor(int i=1;i<ans.size();i++){\n\t\t\tif(isMatch(ans[0],ans[i])){\n\t\t\t\tcout<<\"yes\"<<endl;\n\t\t\t}\n\t\t\telse cout<<\"no\"<<endl;\n\t\t}\n\t\tcout<<\".\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct term {\n    int coff;\n    vector<int> deg;\n\n    term() : coff(1), deg(26, 0) {}\n\n    bool operator<(const term& other) const {\n        return deg < other.deg;\n    }\n    bool operator==(const term& other) const {\n        return coff == other.coff && deg == other.deg;\n    }\n};\n\nstruct expression {\n    void add_term(term new_term) {\n        for(auto& t : terms) {\n            if(t.deg == new_term.deg) {\n                t.coff += new_term.coff;\n                return;\n            }\n        }\n        terms.push_back(move(new_term));\n        sort(begin(terms), end(terms));\n        clean_up();\n    }\n\n    void add_expr(expression e) {\n        for(auto& t : e.terms) {\n            add_term(t);\n        }\n        clean_up();\n    }\n\n    expression operator-() const {\n        expression res;\n        res.terms = terms;\n        for(auto& t : res.terms) {\n            t.coff = -t.coff;\n        }\n        return res;\n    }\n\n    bool operator==(expression const& other) const {\n        return terms == other.terms;\n    }\n\n    void clean_up() {\n        terms.erase(remove_if(begin(terms), end(terms),\n                              [](const auto& t1) {\n                                  return t1.coff == 0;\n                              }),\n                    end(terms));\n    }\n\n    void debug_print() const {\n        cout << \"sz: \" << terms.size() << endl;\n        for(auto& t : terms) {\n            cout << \"coff: \" << t.coff << \" deg: \";\n            for(int i = 0; i < 26; ++i) {\n                cout << t.deg[i] << ' ';\n            }\n            cout << endl;\n        }\n    }\n\n    vector<term> terms;\n};\n\nterm operator*(term a, term const& rhs) {\n    a.coff *= rhs.coff;\n    for(int i = 0; i < 26; ++i) {\n        a.deg[i] += rhs.deg[i];\n    }\n    return a;\n}\n\nexpression operator*(expression const& lhs, expression const& rhs) {\n    expression res;\n    for(auto const& t1 : lhs.terms) {\n        for(auto const& t2 : rhs.terms) {\n            res.add_term(t1 * t2);\n        }\n    }\n    return res;\n}\n\n\nexpression parse_expr(string const& s, int& p);\nexpression parse_term(string const& s, int& p);\nexpression parse_factor(string const& s, int& p);\nvoid skip_sp(string const& s, int& p);\nint number(string const& s, int& p);\n\nexpression parse_expr(string const& s, int& p) {\n    auto e = parse_term(s, p);\n    skip_sp(s, p);\n    while(p < (int)s.size() && (s[p] == '+' || s[p] == '-')) {\n        const char op = s[p++];\n        skip_sp(s, p);\n        auto t2 = parse_term(s, p);\n        if(op == '-') {\n            t2 = -t2;\n        }\n        e.add_expr(t2);\n        skip_sp(s, p);\n    }\n    return e;\n}\n\nexpression parse_term(string const& s, int& p) {\n    auto e = parse_factor(s, p);\n    skip_sp(s, p);\n    while(p < (int)s.size() && s[p] != '+' && s[p] != '-' && s[p] != ')') {\n        auto f = parse_factor(s, p);\n        e = e * f;\n    }\n    return e;\n}\n\nexpression parse_factor(string const& s, int& p) {\n    expression res;\n    skip_sp(s, p);\n\n    if(s[p] == '(') {\n        skip_sp(s, ++p);\n        auto e = parse_expr(s, p);\n        res = e;\n        skip_sp(s, p);\n        assert(s[p] == ')');\n        skip_sp(s, ++p); // )\n        if(p < (int)s.size() && s[p] == '^') {\n            skip_sp(s, ++p);\n            int d = number(s, p); // todo: only \"^ (number)\" ?\n            for(int i = 0; i < d - 1; ++i) {\n                res = res * e;\n            }\n        }\n        skip_sp(s, p);\n    } else if(isdigit(s[p])) {\n        const int n = number(s, p);\n        term t;\n        t.coff = n;\n        res.add_term(t);\n        skip_sp(s, p);\n    } else if(isalpha(s[p])) {\n        const int idx = s[p++] - 'a';\n        term t;\n        t.deg[idx] = 1;\n        skip_sp(s, p);\n        if(p < (int)s.size() && s[p] == '^') {\n            skip_sp(s, ++p);\n            t.deg[idx] *= number(s, p);\n            skip_sp(s, p);\n        }\n        res.add_term(t);\n    } else {\n        cout << \"str: \" << s << \"  p: \" << p << \" s[p]: \" << s[p] << endl;\n        assert(false);\n    }\n\n    return res;\n}\n\nint number(string const& s, int& p) {\n    assert(isdigit(s[p]));\n    int res = 0;\n    while(p < (int)s.size() && isdigit(s[p])) {\n        res *= 10;\n        res += s[p++] - '0';\n    }\n    return res;\n}\n\nvoid skip_sp(string const& s, int& p) {\n    while(p < (int)s.size() && s[p] == ' ') {\n        p++;\n    }\n}\n\nexpression parse(string const& s) {\n    int p = 0;\n    return parse_expr(s, p);\n}\n\n\nint main() {\n    string s;\n    while(getline(cin, s), s[0] != '.') {\n        if(s.back() == '\\r') s.pop_back();\n        const auto target = parse(s);\n        string t;\n        while(getline(cin, t), t[0] != '.') {\n            if(t.back() == '\\r') t.pop_back();\n            const auto ss = parse(t);\n            if(target == ss) {\n                cout << \"yes\" << endl;\n            } else {\n                cout << \"no\" << endl;\n            }\n        }\n        cout << \".\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<string,int> P;\ntypedef map<string,int> M;\n\nvoid pr(M a,string s=\"\"){\n  return;\n  cout<<s<<endl;\n  for(P p:a) cout<<p.first<<\" \"<<p.second<<endl;\n  cout<<\"end\"<<endl;\n}\n\nM add(M a,M b,int f=1){\n  for(P p1:a) b[p1.first] += f * p1.second;\n  return b;\n}\n\nM mult(M a,M b){\n  M res;\n  for(P p1:a)\n    for(P p2:b){\n      string s = p1.first + p2.first; sort(s.begin(),s.end());\n      int num = p1.second * p2.second;\n      res[s] += num;\n    }\n  return res;\n}\n\n\nM bnf();\nint pos;\nstring S;\nvoid skipsp(){while(S[pos] == ' ') pos++;}\n\nint getNum(){\n  int res = 0;\n  while((int)S.size()> pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n\nint getNum2(const string &S,int &pos){\n  int res = 0;\n  while((int)S.size()>pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n\nstring getBlock(){\n  string res;\n  skipsp();\n  while(isdigit(S[pos]) || isalpha(S[pos])) res += S[pos++];\n  skipsp();\n  if(S[pos] == '^') {\n    pos++;\n    skipsp();\n    assert(isdigit(S[pos])&&\"hut\");\n    int p = getNum();\n    string tmp = res; res = \"\";\n    for(int i=0;i<p;i++) res += tmp, res += ' ';\n  }\n  return res;\n}\n\nM BtoM(string b){\n  M res;\n  int num = 1;\n  string val;\n  for(int i=0;i<(int)b.size();i++){\n    char ch = b[i];\n    if(isalpha(ch)) val += ch;\n    else if(isdigit(ch)) num *= getNum2(b,i),i--;\n  }\n  res[val] = num;\n  return res;\n}\n\nM calc(){\n  M res; res[\"\"] = 1;\n  skipsp();\n  while(1){\n    char ch = S[pos];\n    if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(isalpha(ch) || isdigit(ch)){\n      string block = getBlock();\n      res = mult(res,BtoM(block));\n    }\n    else break;\n  }\n  pr(res,\"calc,res\");\n  return res;\n}\n\nM bnf(){\n  M res = calc();\n  pr(res,\"start bnf\");\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(isalpha(ch) || isdigit(ch)) res = mult(res,calc());\n    else if(ch == '+')pos++,res =add(res,calc());\n    else if(ch == '-')pos++,res = add(res,calc(),-1);\n    else if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else break;\n  }\n  \n  for(auto it=res.begin();it!=res.end();it++) if(it->second==0) res.erase(it--);\n  pr(res,\"return bnf\");\n  return res;\n}\n\nsigned main(){\n  while(1){\n    getline(cin,S);\n    //cin.ignore();\n    if(S == \".\") break;\n    pos = 0;\n    M ori = bnf();\n    pr(ori,\"ori\");\n    while(1){\n      getline(cin,S);\n      if(S == \".\") break;\n      pos = 0;\n      M res = bnf();\n      cout<<((ori == res)? \"yes\":\"no\")<<endl;\n      pr(res,S);\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[27];\n  Element(){\n    c=0;rep(i,27)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,27)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  if (a.size() != b.size())return false;\n  rep(i,a.size()){\n    bool canfind=false;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,27){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,27){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p]=='+'||in[p]=='-')break;\n    \n    else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }\n    else if (in[p] ==')')break;\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    cout << \"formula :\" << in << endl;\n    output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n      cout << \"formula :\"<<cmp<<endl;\n      output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  rep(i,ret.size()-1){\n    if (ret[i] == '^' && ret[i+1] == '(')assert(false);\n  }\n  return ret;\n}\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ll;\n\nstring s;\nint p;\n\nll A[200][300];\nint idx;\n\nll bnf();\n\nll get_num(){\n\n  if(s[p]=='('){\n    \n    p++;\n\n    ll res=bnf();\n    \n    p++;\n\n    return res;\n  }\n  \n  if('a'<=s[p]&&s[p]<='z') return A[idx][s[p++]];\n  \n  ll num=0;\n  \n  while('0'<=s[p]&&s[p]<='9') num=num*10+s[p]-'0', p++;\n\n  return num;\n  \n}\n\nll bnf3(){\n\n  ll res=get_num();\n  \n  while(p<s.size()){\n\n    if(s[p]=='^'){\n\n      p++;\n\n      ll r=get_num();\n\n      ll tmp=1;\n\n      for(int i=0;i<r;i++) tmp*=res;\n\n      res=tmp;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nll bnf2(){\n\n  ll res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n\n      p++;\n\n      ll r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nll bnf(){\n\n  ll res=bnf2();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='+'){\n\n      p++;\n      \n      ll r=bnf2();\n      \n      res+=r;\n      \n    }\n    else if(s[p]=='-'){\n\n      p++;\n\n      ll r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nvoid change(){\n  \n  for(int i=0;i<s.size();i++)\n    if((s[i]==')'||('a'<=s[i]&&s[i]<='z')||('0'<=s[i]&&s[i]<='9')))\n      if((s[i+1]=='('||('a'<=s[i+1]&&s[i+1]<='z')||('0'<=s[i+1]&&s[i+1]<='9')))\n\tif(!('0'<=s[i]&&s[i]<='9'&&'0'<=s[i+1]&&s[i+1]<='9'))\n\t  s=s.substr(0,i+1)+'*'+s.substr(i+1);\n\n  \n  for(int i=0;i<s.size();i++)\n    \n    if(s[i]==' ')\n      \n      while(s[i]==' '&&i+1<s.size()&&s[i+1]==' ') s.erase(s.begin()+i);\n  \n\n  if(s[0]==' ') s.erase(s.begin());\n  \n  if(s[s.size()-1]==' ') s.erase(s.begin()+s.size()-1);\n\n  for(int i=0;i<s.size();i++)\n    if(s[i]==' ')\n      if((s[i-1]==')'||('a'<=s[i-1]&&s[i-1]<='z')||('0'<=s[i-1]&&s[i-1]<='9')))\n\tif((s[i+1]=='('||('a'<=s[i+1]&&s[i+1]<='z')||('0'<=s[i+1]&&s[i+1]<='9'))) s[i]='*';\n\n  for(int i=0;i<s.size();i++)\n    \n    if(s[i]==' ') s.erase(s.begin()+i), i--;\n  \n  \n}\n\nint main(){\n  \n  for(int T=0;T<200;T++)\n    \n    for(int i=0;i<300;i++) A[T][i]=rand();\n  \n  while(1){\n\n    string tmp=s;\n    \n    getline(cin,s);\n    \n    if(s==\".\") break;\n    \n    change();\n    \n    ll base[200];\n\n    for(int T=0;T<200;T++){\n      idx=T;\n      p=0;\n      base[T]=bnf();\n    }\n    \n    while(1){\n      \n      getline(cin,s);\n      \n      if(s==\".\"){\n\tcout<<\".\"<<endl;\n\tbreak;\n      }\n      \n      change();\n      \n      bool ans=true;\n      \n      for(int T=0;T<200;T++){\n          \n\tidx=T;  \n\tp=0;\n      \n\tll r=bnf();\n\t\n\tif(base[T]!=r) ans=false;\n\t\n      }\n      \n      if(ans) cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n      \n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nlong long power(long long a, long long b)\n{\n    long long ret = 1;\n    long long tmp = a;\n    while(b > 0){\n        if(b & 1){\n            ret *= tmp;\n            ret %= MOD;\n        }\n        tmp *= tmp;\n        tmp %= MOD;\n        b >>= 1;\n    }\n    return ret;\n}\n\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nlong long calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        istringstream iss(s);\n        long long ret;\n        iss >> ret;\n        return ret % MOD;\n    }\n\n    if(n == 1)\n        return variable[s[0]];\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                if(i == 0)\n                    return (calculate(t1) + calculate(t2)) % MOD;\n                else if(i == 1)\n                    return (calculate(t1) - calculate(t2) + MOD) % MOD;\n                else if(i == 2)\n                    return (calculate(t1) * calculate(t2)) % MOD;\n                else\n                    return power(calculate(t1), calculate(t2));\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nstring solve(string s, string t)\n{\n    s = normalize(s);\n    t = normalize(t);\n\n    for(int i=0; i<50; ++i){\n        for(char c='a'; c<='z'; ++c)\n            variable[c] = xor128() % MOD;\n\n        long long x = calculate(s);\n        long long y = calculate(t);\n\n        if(x != y)\n            return \"no\";\n    }\n\n    return \"yes\";\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            cout << solve(s, t) << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define int long long\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n\n    //debug\n    p=0;\n    in=pre_processing2(tmp);\n    formula me2=fact(in,p);\n    assert(is_same_formula(me,me2));\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      p=0;\n      cmp=pre_processing2(tmp);\n      formula you2=fact(cmp,p);\n      assert(is_same_formula(you,you2));\n\n      //      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n\n  return ret;\n}\n\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nstring normalize(string s)\n{\n    // 連続するスペースを1つのスペースに変換、先頭と末尾のスペースを削除\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if(s[i] != ' ' || s[i-1] != ' ')\n            t += s[i];\n    }\n    if(t[0] == ' ')\n        t = t.substr(1);\n    if(t[t.size()-1] == ' ')\n        t = t.substr(0, t.size()-1);\n    s = t;\n\n    // 必要に応じて * を挿入する\n    n = s.size();\n    t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += '*';\n        t += s[i];\n    }\n    s = t;\n\n    // スペースを * に変換、もしくは削除する\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(s[i-1] != '(' && s[i+1] != ')' && ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nmap<vector<int>, long long> calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        map<vector<int>, long long> ret;\n        long long tmp = 0;\n        for(int i=0; i<n; ++i){\n            tmp *= 10;\n            tmp += s[i] - '0';\n        }\n        if(tmp != 0)\n            ret[vector<int>(26, 0)] = tmp;\n        return ret;\n    }\n\n    if(n == 1){\n        map<vector<int>, long long> ret;\n        vector<int> tmp(26, 0);\n        tmp[s[0]-'a'] = 1;\n        ret[tmp] = 1;\n        return ret;\n    }\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                map<vector<int>, long long> a = calculate(t1);\n                map<vector<int>, long long> b = calculate(t2);\n\n                map<vector<int>, long long> ret;\n                if(i == 0){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it){\n                        ret[it->first] += it->second;\n                        if(ret[it->first] == 0)\n                            ret.erase(it->first);\n                    }\n                }else if(i == 1){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it){\n                        ret[it->first] -= it->second;\n                        if(ret[it->first] == 0)\n                            ret.erase(it->first);\n                    }\n                }else if(i == 2){\n                    for(map<vector<int>, long long>::iterator it1=a.begin(); it1!=a.end(); ++it1){\n                        for(map<vector<int>, long long>::iterator it2=b.begin(); it2!=b.end(); ++it2){\n                            vector<int> tmp(26);\n                            for(int k=0; k<26; ++k)\n                                tmp[k] = it1->first[k] + it2->first[k];\n                            ret[tmp] += it1->second * it2->second;\n                        }\n                    }\n                }else{\n                    vector<int> tmp(26);\n                    for(int k=0; k<26; ++k)\n                        tmp[k] = a.begin()->first[k] * b.begin()->second;\n                    ret[tmp] = 1;\n                }\n                return ret;\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        s = normalize(s);\n        map<vector<int>, long long> a = calculate(s);\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            t = normalize(t);\n            map<vector<int>, long long> b = calculate(t);\n            if(a == b)\n                cout << \"yes\" << endl;\n            else\n                cout << \"no\" << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nstring _s;\nunsigned _ix;\nint token;\n\nvoid next() {\n    while (_ix < _s.size() && isspace(_s[_ix])) _ix++;\n    if (_ix == _s.size()) {\n        token = 0;\n        return ;\n    }\n    if (!isdigit(_s[_ix])) {\n        token = _s[_ix++];\n    }\n    else {\n        int a = 0;\n        while (isdigit(_s[_ix])) a = a*10+(_s[_ix++]-'0');\n        token = -a-1;\n    }\n}\n\ntypedef vector<int> T;\ntypedef vector<pair<int, T> > E;\n\nvoid dump(const E& e) {\n    printf(\"E = \");\n    rep (k, e.size()) {\n        if (k) printf(\"+\");\n        printf(\"(%d)\", e[k].first);\n        rep (i, 26) if (e[k].second[i]) {\n            printf(\"%c^%d\", i+'a', e[k].second[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\nE norm(const E& e) {\n    map<T, int> f;\n    rep (i, e.size()) f[e[i].second] += e[i].first;\n    E n;\n    for (map<T, int>::iterator it = f.begin(); it != f.end(); ++it) {\n        if (it->second) n.push_back(mp(it->second, it->first));\n    }\n    return n;\n}\n\nT mul(T l, const T& r) {\n    rep (i, 26) l[i] += r[i];\n    return l;\n}\n\nE mul(const E& l, const E& r) {\n    E e;\n    rep (i, l.size()) rep (j, r.size()) {\n        e.push_back(mp(l[i].first*r[j].first, mul(l[i].second, r[j].second)));\n    }\n    return e;\n}\n\nE expr(), term(), factor();\n\nE expr() {\n//    printf(\"expr token = %d\\n\", token);\n    E a = term();\n    while (token == '+' || token == '-') {\n        const bool neg = token == '-';\n        next();\n        E b = term();\n        if (neg) rep (i, b.size()) b[i].first *= -1;\n        rep (i, b.size()) a.push_back(b[i]);\n    }\n    return norm(a);\n}\n\nE term() {\n//    printf(\"term token = %d\\n\", token);\n    E a = factor();\n    while (token < 0 || isalpha(token) || token == '(') {\n        E b = factor();\n        a = mul(a, b);\n    }\n    return a;\n}\n\nE factor() {\n//    printf(\"factor token = %d\\n\", token);\n    if (token < 0) {\n        const int a = -token-1;\n        next();\n        E e;\n        e.push_back(mp(a, T(26, 0)));\n        return e;\n    }\n    else if (isalpha(token)) {\n        const int a = token-'a';\n        int x = 1;\n        next();\n        if (token == '^') {\n            next();\n            bool neg = false;\n            if (token == '-') {\n                neg = true;\n                next();\n            }\n            x = -token-1;\n            if (neg) x = -x;\n            next();\n        }\n        T t(26, 0);\n        t[a] = x;\n        E e;\n        e.push_back(mp(1, t));\n        return e;\n    }\n    else {\n        assert(token == '(');\n        next();\n        E e = expr();\n        assert(token == ')');\n        next();\n        return e;\n    }\n}\n\nE parse(string s) {\n    _s = s;\n    _ix = 0;\n    next();\n    return expr();\n}\n\nint main() {\n    string s;\n    for (;;) {\n        getline(cin, s);\n        if (s[0] == '.') return 0;\n        E my = parse(s);\n//        dump(my);\n        for (;;) {\n            getline(cin, s);\n            if (s[0] == '.') break;\n            E your = parse(s);\n//            dump(your);\n            puts(my == your ? \"yes\" : \"no\");\n        }\n        puts(\".\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n\n//#define fprintf(...) void(0)\n\nclass Poly {\n  std::map<std::string, int> coefs;\n  // e.g. coefs[\"aab\"] == 2 <=> the polynomial has the term 2 a^2 b\n  const std::string s;\n\n  Poly &operator ^=(const Poly &oth) {\n    if (oth.coefs.size() == 1 && oth.coefs.find(\"\") != oth.coefs.end()) {\n      return (*this) ^= oth.coefs.find(\"\")->second;\n    } else if (oth.coefs.empty()) {\n      // means 0\n      coefs.clear();\n      coefs[\"\"] = 1;  // means 1\n      return (*this);\n    }\n\n    assert(false);\n  }\n\n  Poly &op_eq(char op, const Poly &rhs) {\n    // (*this) @= rhs\n    switch (op) {\n      case '+': return (*this) += rhs;\n      case '-': return (*this) -= rhs;\n      case '*': return (*this) *= rhs;\n      case '^': return (*this) ^= rhs;\n      default: assert(false);\n    }\n  }\n\n  Poly fourt(\n      size_t &i, \n      const std::vector<std::string> &ops={\"+-\", \"*\", \"^\", \"\"},\n      size_t prec=0) {\n\n    /* based-on tsurai parser */\n\n    if (ops[prec].empty()) {\n      if (s[i] == '(') {\n        Poly tmp=fourt(++i, ops, 0);\n        assert(s[i] == ')');\n        ++i;\n        return tmp;\n      }\n      if (isalpha(s[i])) {\n        // we assume only one-character variables\n        return Poly(s[i++]);\n      }\n      int coef=0;\n      while (s[i] >= '0' && s[i] <= '9')\n        coef = coef*10 + s[i++]-'0';\n      return Poly(coef);\n    }\n\n    Poly res=fourt(i, ops, prec+1);\n    while (i < s.length()) {\n      char op=s[i];\n      if (!std::count(ops[prec].begin(), ops[prec].end(), op))\n        break;\n      Poly tmp=fourt(++i, ops, prec+1);\n      res.op_eq(op, tmp);\n    }\n    return res;\n  }\n\n  Poly &normalized() {\n    for (auto it=coefs.begin(); it!=coefs.end(); ++it)\n      if (it->second == 0)\n        coefs.erase(it);\n\n    return *this;\n  }\n\npublic:\n  Poly(const std::string &s): s(s) {\n    size_t i=0;\n    coefs = fourt(i).coefs;  // ugh\n  }\n\n  Poly(char ch): s(1, ch) {\n    assert(isalpha(ch));\n    coefs[s] = 1;\n  }\n\n  Poly(int n): s(std::to_string(n)) {\n    if (n)\n      coefs[\"\"] = n;\n  }\n\n  Poly &operator +=(const Poly &oth) {\n    for (const auto &p: oth.coefs) {\n      const std::string &param=p.first;\n      int coef=p.second;\n      coefs[param] += coef;\n    }\n    return normalized();\n  }\n\n  Poly &operator -=(const Poly &oth) {\n    for (const auto &p: oth.coefs) {\n      const std::string &param=p.first;\n      int coef=p.second;\n      coefs[param] -= coef;\n    }\n    return normalized();\n  }\n\n  Poly &operator *=(const Poly &oth) {\n    Poly tmp(*this);\n    coefs.clear();\n    for (const auto &pl: tmp.coefs) {\n      for (const auto &pr: oth.coefs) {\n        std::string param=pl.first+pr.first;\n        std::sort(param.begin(), param.end());\n        coefs[param] += pl.second*pr.second;\n      }\n    }\n    return normalized();\n  }\n\n  Poly &operator ^=(int iexp) {\n    if (iexp == 0) {\n      // does not appear in #1233\n      coefs.clear();\n      coefs[\"\"] = 1;  // means 1\n    } else {\n      Poly tmp(*this);\n      for (int i=1; i<iexp; ++i)\n        // O(iexp) multiplications, ugh\n        *this *= tmp;\n    }\n    return normalized();\n  }\n\n  Poly operator +(const Poly &oth) const { return Poly(*this) += oth; }\n  Poly operator -(const Poly &oth) const { return Poly(*this) -= oth; }\n  Poly operator *(const Poly &oth) const { return Poly(*this) *= oth; }\n  Poly operator ^(int iexp) const { return Poly(*this) ^= iexp; }\n  bool operator ==(const Poly &oth) const { return coefs == oth.coefs; }\n\n  void debug() const {\n    if (coefs.empty()) {\n      fprintf(stderr, \"#> 0\\n\");\n      return;\n    }\n    fprintf(stderr, \"#>\");\n    for (const auto &p: coefs)\n      fprintf(stderr, \" %d%s\", p.second, p.first.c_str());\n    fprintf(stderr, \"\\n\");\n  }\n};\n\nstd::string normalize(const std::string &s) {\n  // explicit `*' signs and no spaces\n  std::string res;\n  enum {\n    NONE, PAREN, FACTOR, OPERATOR\n  } last=NONE;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '(') {\n      if (last == FACTOR) {\n        res += '*';\n      }\n      res += '(';\n      last = PAREN;\n    } else if (s[i] == ')') {\n      res += ')';\n      last = FACTOR;\n    } else if (isalnum(s[i])) {\n      if (last == FACTOR) {\n        res += '*';\n      }\n      res += s[i];\n      if (isdigit(s[i])) {\n        while (i+1 < s.length() && isdigit(s[i+1]))\n          res += s[++i];\n      }\n      last = FACTOR;\n    } else if (!isspace(s[i])) {\n      res += s[i];\n      last = OPERATOR;\n    }\n  }\n  // fprintf(stderr, \"#< %s\\n\", res.c_str());\n  return res;\n}\n\nint testcase_ends() {\n  char buf[96];\n  fgets(buf, sizeof buf, stdin);\n  std::string s=buf;\n  if (s == \".\\n\")\n    return 1;\n\n  s = normalize(s);\n  Poly ps(s);\n  while (true) {\n    fgets(buf, sizeof buf, stdin);\n    std::string t=buf;\n    if (t == \".\\n\") {\n      printf(\".\\n\");\n      return 0;\n    }\n\n    t = normalize(t);\n    Poly pt(t);\n    printf(\"%s\\n\", (ps == pt)? \"yes\":\"no\");\n  }\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double EPS=1e-8;\nvector<long long int > var;\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\nlong long int formula(string &s,int &p);\n\nlong long int num(string &s,int &p){\n  long long int res=0;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nlong long int var_val(string &s,int &p){\n  long long int res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nlong long int get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    long long  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nlong long int term2(string &s,int &p){\n  long long int res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p))+EPS;\n  }\n  return res;\n}\n\nlong long int term1(string& s,int &p){\n  long long int res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    long long int val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nlong long int formula(string& s,int &p){\n  long long int res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    long long int val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%(TIME*TIME)-rnd()%(TIME*TIME);\n      }\n      long long int cor=formula(state[0],p);\n      p=0;\n      long long int ans=formula(state[i],p);\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n  Parsing(string s){ parse = s, pos = 0; }\n\n  ll fact(){\n    if(parse[pos] == '('){\n      pos++;\n      ll p = expression();\n      pos++;\n      return p;\n    }else{\n      ll p=0;\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n        p *= 10LL;\n        p += parse[pos]-'0';\n        pos++;\n      }\n      return p;\n    }\n  }\n\n  ll pow(){\n    ll p = fact();\n    while( parse[pos] == '^' ){\n      pos++;\n      ll limit = fact();\n      ll tmp = 1LL;\n      rep(_,limit) tmp *= p;\n      p = tmp;\n    }\n    return p;\n  }\n \n  ll term(){\n    ll p = pow();\n    while(parse[pos] == '*' || parse[pos] == '/'){\n      if(parse[pos] == '*'){pos++;p *= pow();}\n      else {pos++;p /= pow();}\n    }\n    return p;\n  }\n \n  ll expression(){\n    ll p = term();\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){pos++;p+=term();}\n      else {pos++;p-=term();}\n    }\n    return p;\n  } \n \n};\n\ninline bool isNum(char c) { return '0' <= c && c <= '9'; }\ninline bool isVar(char c) { return 'a' <= c && c <= 'z'; }\n\nbool isMulti(char a,char b,bool flag){\n  if( flag && isNum(a) && isNum(b) ) return true;\n  if( isNum(a) && isVar(b) ) return true;\n  if( isVar(a) && isVar(b) ) return true;\n  if( isVar(a) && isNum(b) ) return true;\n  if( ( a == ')' ) && ( b == '(' ) ) return true;\n  if( ( a == ')' ) && ( isNum(b) || isVar(b) ) ) return true;\n  if( ( isNum(a) || isVar(a) ) && ( b == '(' ) ) return true;\n  return false;\n}\n\nstring Craftworks(string s){\n  string ret = \"\",tmp = \"\";\n  stringstream ss;\n  ss << s;\n  vector<string> buf;\n  while( !(ss>>s).fail() ) buf.push_back(s);\n  rep(i,buf.size()){\n    if( i+1 < buf.size() && isMulti(buf[i][(int)buf[i].size()-1],buf[i+1][0],true) ) {\n      tmp += ( buf[i] + \"*\" );\n    } else tmp += buf[i];\n  }\n  rep(i,tmp.size()){\n    if( i+1 < tmp.size() && isMulti(tmp[i],tmp[i+1],false) ) ret += string(1,tmp[i]) + \"*\";\n    else                                                     ret += string(1,tmp[i]);\n  }\n  return ret;\n}\n\nconst int MOD = 10;\n\nstring itos(int i) { stringstream ss; ss << i; return ss.str(); }\n\nint main(){\n  srand((unsigned int)time(NULL));\n  string s;\n  while( 1 ){\n    vector<string> vec;\n    while( getline(cin,s) ) {\n      if( s == \".\" ) break;\n      vec.push_back(s);\n    }\n    if( vec.empty() ) break;\n    rep(i,vec.size()) vec[i] = Craftworks(vec[i]);\n\n    vector<bool> verdict(vec.size(),true);\n\n    rep(_,100){\n      vector<string> value(26);\n      rep(i,26) value[i] = itos(rand() % MOD + 1);\n      vector<ll> result;\n\n      rep(i,vec.size()){\n        string buf;\n        rep(j,vec[i].size()) {\n          if( vec[i][j] == ' ' ) continue;\n          if( 'a' <= vec[i][j] && vec[i][j] <= 'z' ) buf += value[vec[i][j]-'a'];\n          else                                       buf += vec[i][j];\n        }\n        Parsing par(buf);\n        result.push_back(par.expression());\n        if( i ) verdict[i] = verdict[i] & ( result[i] == result[0] );\n      }\n    }\n    REP(i,1,vec.size()) puts(verdict[i]?\"yes\":\"no\");\n    puts(\".\");\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef __int128  Val;\n\nconst Val MOD=1e18+9;\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    res%=MOD;\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    res%=MOD;\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    Val val=term2(s,p);\n    Val a=res;\n    res=1;\n    for(int i=0;i<val;i++){\n      res*=a;\n      res%=MOD;\n    }\n    return res;\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n    res%=MOD;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n    if(op=='+') res+=val;\n    else res-=val;\n    res%=MOD;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%TIME;\n      }\n      Val cor=formula(state[0],p);\n      p=0;\n      Val ans=formula(state[i],p);\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n\n  ll fact(){\n    if(parse[pos] == '('){\n      pos++;\n      ll p = expression();\n      pos++;\n      return p;\n    }else{\n      ll p=0;\n      \n      while('0' <= parse[pos] && parse[pos] <= '9'){\n        p *= 10LL;\n        p += parse[pos]-'0';\n        pos++;\n      }\n      return p;\n    }\n  }\n\n  ll pow(){\n    ll p = fact();\n    while( parse[pos] == '^' ){\n      pos++;\n      ll limit = fact();\n      ll tmp = 1LL;\n      rep(_,limit) tmp *= p;\n      p = tmp;\n    }\n    return p;\n  }\n \n  ll term(){\n    ll p = pow();\n    while(parse[pos] == '*' || parse[pos] == '/'){\n      if(parse[pos] == '*'){pos++;p *= pow();}\n      else {pos++;p /= pow();}\n    }\n    return p;\n  }\n \n  ll expression(){\n    ll p = term();\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){pos++;p+=term();}\n      else {pos++;p-=term();}\n    }\n    return p;\n  } \n \n};\n\ninline bool isNum(char c) { return '0' <= c && c <= '9'; }\ninline bool isVar(char c) { return 'a' <= c && c <= 'z'; }\n\nbool isMulti(char a,char b,bool flag){\n  if( flag && isNum(a) && isNum(b) ) return true;\n  if( isNum(a) && isVar(b) ) return true;\n  if( isVar(a) && isVar(b) ) return true;\n  if( isVar(a) && isNum(b) ) return true;\n  if( ( a == ')' ) && ( b == '(' ) ) return true;\n  if( ( a == ')' ) && ( isNum(b) || isVar(b) ) ) return true;\n  if( ( isNum(a) || isVar(a) ) && ( b == '(' ) ) return true;\n  return false;\n}\n\nstring Craftworks(string s){\n  string ret = \"\",tmp = \"\";\n  stringstream ss;\n  ss << s;\n  vector<string> buf;\n  while( !(ss>>s).fail() ) buf.push_back(s);\n  rep(i,buf.size()){\n    if( i+1 < buf.size() && isMulti(buf[i][(int)buf[i].size()-1],buf[i+1][0],true) ) {\n      tmp += ( buf[i] + \"*\" );\n    } else tmp += buf[i];\n  }\n  rep(i,tmp.size()){\n    if( i+1 < tmp.size() && isMulti(tmp[i],tmp[i+1],false) ) ret += string(1,tmp[i]) + \"*\";\n    else                                                     ret += string(1,tmp[i]);\n  }\n  return ret;\n}\n\nconst int MOD = 10;\n\nstring itos(int i) { stringstream ss; ss << i; return ss.str(); }\n\nint main(){\n  /*\n  string test;\n  while( getline(cin,test) ){\n  Parsing par(test);\n  cout << par.expression() << endl;\n  }\n\n  string test;\n  while( getline(cin,test) ){\n    cout << Craftworks(test) << endl;\n  }\n  */\n  srand((unsigned int)time(NULL));\n  string s;\n  while( 1 ){\n    vector<string> vec;\n    while( getline(cin,s) ) {\n      if( s == \".\" ) break;\n      vec.push_back(s);\n    }\n    if( vec.empty() ) break;\n    //cout << endl;\n    rep(i,vec.size()){\n      //cout << vec[i] << \" => \";\n      vec[i] = Craftworks(vec[i]);\n      //cout << vec[i] << endl;\n    }\n\n    vector<bool> verdict(vec.size(),true);\n\n    rep(_,100){\n      vector<string> value(26);\n      rep(i,26) value[i] = itos(rand() % MOD + 1);\n      vector<ll> result;\n\n      rep(i,vec.size()){\n        string buf;\n        rep(j,vec[i].size()) {\n          if( vec[i][j] == ' ' ) continue;\n          if( 'a' <= vec[i][j] && vec[i][j] <= 'z' ) buf += value[vec[i][j]-'a'];\n          else                                       buf += vec[i][j];\n        }\n        Parsing par(buf);\n        result.push_back(par.expression());\n        if( i ) verdict[i] = verdict[i] & ( result[i] == result[0] );\n      }\n\n    }\n    REP(i,1,vec.size()) puts(verdict[i]?\"yes\":\"no\");\n    puts(\".\");\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<string,int> P;\ntypedef map<string,int> M;\n\nvoid pr(M a,string s=\"\"){\n  return;\n  cout<<s<<endl;\n  for(P p:a) cout<<p.first<<\" \"<<p.second<<endl;\n  cout<<\"end\"<<endl;\n}\n\nM add(M a,M b,int f=1){\n  for(P p1:a) b[p1.first] += f * p1.second;\n  return b;\n}\n\nM mult(M a,M b){\n  M res;\n  for(P p1:a)\n    for(P p2:b){\n      string s = p1.first + p2.first; sort(s.begin(),s.end());\n      int num = p1.second * p2.second;\n      res[s] += num;\n    }\n  return res;\n}\n\n\nM bnf();\nint pos;\nstring S;\nvoid skipsp(){while(S[pos] == ' ') pos++;}\n\nint getNum(){\n  int res = 0;\n  while((int)S.size()> pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n\nint getNum2(const string &S,int &pos){\n  int res = 0;\n  while((int)S.size()>pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n\nstring getBlock(){\n  string res;\n  skipsp();\n  while(isdigit(S[pos]) || isalpha(S[pos])) res += S[pos++];\n  skipsp();\n  if(S[pos] == '^') {\n    pos++;\n    skipsp();\n    assert(isdigit(S[pos])&&\"hut\");\n    int p = getNum();\n    string tmp = res; res = \"\";\n    for(int i=0;i<p;i++) res += tmp, res += ' ';\n  }\n  return res;\n}\n\nM BtoM(string b){\n  M res;\n  int num = 1;\n  string val;\n  for(int i=0;i<(int)b.size();i++){\n    char ch = b[i];\n    if(isalpha(ch)) val += ch;\n    else if(isdigit(ch)) num *= getNum2(b,i),i--;\n    else if(ch != ' ') assert(!\"BtoM\");\n  }\n  res[val] = num;\n  return res;\n}\n\nM calc(){\n  M res; res[\"\"] = 1;\n  skipsp();\n  while(1){\n    char ch = S[pos];\n    if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(isalpha(ch) || isdigit(ch)){\n      string block = getBlock();\n      res = mult(res,BtoM(block));\n    }\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n  pr(res,\"calc,res\");\n  return res;\n}\n\nM bnf(){\n  M res = calc();\n  pr(res,\"start bnf\");\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(isalpha(ch) || isdigit(ch)) res = mult(res,calc());\n    else if(ch == '+')pos++,res =add(res,calc());\n    else if(ch == '-')pos++,res = add(res,calc(),-1);\n    else if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n  \n  for(auto it=res.begin();it!=res.end();it++) if(it->second==0) res.erase(it--);\n  pr(res,\"return bnf\");\n  return res;\n}\n\nsigned main(){\n  while(1){\n    getline(cin,S);\n    //cin.ignore();\n    if(S == \".\") break;\n    pos = 0;\n    M ori = bnf();\n    pr(ori,\"ori\");\n    while(1){\n      getline(cin,S);\n      if(S == \".\") break;\n      pos = 0;\n      M res = bnf();\n      cout<<((ori == res)? \"yes\":\"no\")<<endl;\n      pr(res,S);\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nmap<vector<int>, long long> calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        map<vector<int>, long long> ret;\n        long long tmp = 0;\n        for(int i=0; i<n; ++i){\n            tmp *= 10;\n            tmp += s[i] - '0';\n        }\n        if(tmp != 0)\n            ret[vector<int>(26, 0)] = tmp;\n        return ret;\n    }\n\n    if(n == 1){\n        map<vector<int>, long long> ret;\n        vector<int> tmp(26, 0);\n        tmp[s[0]-'a'] = 1;\n        ret[tmp] = 1;\n        return ret;\n    }\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                map<vector<int>, long long> a = calculate(t1);\n                map<vector<int>, long long> b = calculate(t2);\n\n                map<vector<int>, long long> ret;\n                if(i == 0){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it){\n                        ret[it->first] += it->second;\n                        if(ret[it->first] == 0)\n                            ret.erase(it->first);\n                    }\n                }else if(i == 1){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it){\n                        ret[it->first] -= it->second;\n                        if(ret[it->first] == 0)\n                            ret.erase(it->first);\n                    }\n                }else if(i == 2){\n                    for(map<vector<int>, long long>::iterator it1=a.begin(); it1!=a.end(); ++it1){\n                        for(map<vector<int>, long long>::iterator it2=b.begin(); it2!=b.end(); ++it2){\n                            vector<int> tmp(26);\n                            for(int k=0; k<26; ++k)\n                                tmp[k] = it1->first[k] + it2->first[k];\n                            ret[tmp] += it1->second * it2->second;\n                        }\n                    }\n                }else{\n                    vector<int> tmp(26);\n                    for(int k=0; k<26; ++k)\n                        tmp[k] = a.begin()->first[k] * b.begin()->second;\n                    ret[tmp] = 1;\n                }\n                return ret;\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        s = normalize(s);\n        map<vector<int>, long long> a = calculate(s);\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            t = normalize(t);\n            map<vector<int>, long long> b = calculate(t);\n            if(a == b)\n                cout << \"yes\" << endl;\n            else\n                cout << \"no\" << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<string,int> P;\ntypedef map<string,int> M;\n\nvoid pr(M a,string s=\"\"){\n   return;\n  cout<<s<<endl;\n  for(P p:a) cout<<p.first<<\" \"<<p.second<<endl;\n  cout<<\"end\"<<endl;\n}\n\nM add(M a,M b,int f=1){\n  for(P p1:b) a[p1.first] += f * p1.second;\n  return a;\n}\n\nM mult(M a,M b){\n  M res;\n  for(P p1:a)\n    for(P p2:b){\n      string s = p1.first + p2.first; sort(s.begin(),s.end());\n      int num = p1.second * p2.second;\n      res[s] += num;\n    }\n  return res;\n}\n\n\nM bnf();\nint pos;\nstring S;\nvoid skipsp(){while(S[pos] == ' ') pos++;}\n\nint getNum(){\n  int res = 0;\n  while((int)S.size()> pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n\nint getNum2(const string &S,int &pos){\n  int res = 0;\n  while((int)S.size()>pos && isdigit(S[pos])) res = res * 10 + S[pos++]-'0';\n  return res;\n}\n\nstring getBlock(){\n  string res;\n  skipsp();\n  while(isdigit(S[pos]) || isalpha(S[pos])) res += S[pos++];\n  skipsp();\n  if(S[pos] == '^') {\n    pos++;\n    skipsp();\n    assert(isdigit(S[pos])&&\"hut\");\n    int p = getNum();\n    for(int i=0;i<p-1;i++) res += res.back();\n  }\n  return res;\n}\n\nM BtoM(string b){\n  M res;\n  int num = 1;\n  string val;\n  for(int i=0;i<(int)b.size();i++){\n    char ch = b[i];\n    if(isalpha(ch)) val += ch;\n    else if(isdigit(ch)) num *= getNum2(b,i),i--;\n    else if(ch != ' ') assert(!\"BtoM\");\n  }\n  res[val] = num;\n  return res;\n}\n\nM calc(){\n  M res; res[\"\"] = 1;\n  skipsp();\n  while(1){\n    char ch = S[pos];\n    if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(isalpha(ch) || isdigit(ch)){\n      string block = getBlock();\n      res = mult(res,BtoM(block));\n    }\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n  pr(res,\"calc,res\");\n  return res;\n}\n\nM bnf(){\n  M res = calc();\n  pr(res,\"start bnf\");\n  while(1){\n    skipsp();\n    char ch = S[pos];\n    if(isalpha(ch) || isdigit(ch)) res = mult(res,calc());\n    else if(ch == '+')pos++,res =add(res,calc());\n    else if(ch == '-')pos++,res = add(res,calc(),-1);\n    else if(ch == '(') pos++,res = mult(res,bnf()),pos++;\n    else if(ch == '^') assert(!\"^\");\n    else break;\n  }\n  \n  for(auto it=res.begin();it!=res.end();it++) if(it->second==0) res.erase(it--);\n  pr(res,\"return bnf\");\n  return res;\n}\n\nsigned main(){\n  while(1){\n    getline(cin,S);\n    //cin.ignore();\n    if(S == \".\") break;\n    pos = 0;\n    M ori = bnf();\n    pr(ori,\"ori\");\n    while(1){\n      getline(cin,S);\n      if(S == \".\") break;\n      pos = 0;\n      M res = bnf();\n      cout<<((ori == res)? \"yes\":\"no\")<<endl;\n      pr(res,S);\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double EPS=1e-8;\nvector<long long int > var;\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\nlong long int formula(string &s,int &p);\n\nlong long int num(string &s,int &p){\n  long long int res=0;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nlong long int var_val(string &s,int &p){\n  long long int res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nlong long int get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    long long  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nlong long int term2(string &s,int &p){\n  long long int res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p))+EPS;\n  }\n  return res;\n}\n\nlong long int term1(string& s,int &p){\n  long long int res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    long long int val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nlong long int formula(string& s,int &p){\n  long long int res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    long long int val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%TIME*TIME;\n      }\n      long long int cor=formula(state[0],p);\n      p=0;\n      long long int ans=formula(state[i],p);\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <cctype>\nusing namespace std;\n\n\ntypedef map<vector<int>,int> expr_t;\n\nvoid normalize(expr_t &e){\n\texpr_t::iterator it;\n\tfor(it = e.begin(); it != e.end();){\n\t\tif( it->second ){\n\t\t\t++it;\n\t\t}\n\t\telse{\n\t\t\te.erase(it++);\n\t\t}\n\t}\n}\n\n\nstringstream ss;\n\n\nvoid mul(expr_t &e1, expr_t &e2){\n\texpr_t e3;\n\texpr_t::iterator it1, it2;\n\n\tfor(it1 = e1.begin(); it1 != e1.end(); ++it1)\n\tfor(it2 = e2.begin(); it2 != e2.end(); ++it2){\n\t\tvector<int> v = it1->first;\n\t\tfor(int i = 0; i < 26; ++i){\n\t\t\tv[i] += it2->first[i];\n\t\t}\n\t\t\n\t\te3[v] += it1->second * it2->second;\n\t}\n\t\n\te1.swap(e3);\n}\n\n\nexpr_t expr();\nexpr_t term();\nexpr_t power();\nexpr_t factor();\n\nexpr_t expr(){\n\texpr_t::iterator it;\n\n\texpr_t t = term();\n\n\twhile(true){\n\t\tchar ch = 0;\n\t\tss >> ch;\n\t\tif( ch == '+' ){\n\t\t\texpr_t t2 = term();\n\t\t\tfor(it = t2.begin(); it != t2.end(); ++it){\n\t\t\t\tt[it->first] += it->second;\n\t\t\t}\n\t\t}\n\t\telse if( ch == '-' ){\n\t\t\texpr_t t2 = term();\n\t\t\tfor(it = t2.begin(); it != t2.end(); ++it){\n\t\t\t\tt[it->first] -= it->second;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tss.unget();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnormalize(t);\n\treturn t;\n}\n\nexpr_t term(){\n\texpr_t::iterator it1, it2;\n\n\texpr_t p = power();\n\n\twhile(true){\n\t\tchar ch = 0;\n\t\tss >> ch;\n\n\t\tif( ch == '(' || isalnum(ch) ){\n\t\t\tss.unget();\n\t\t\texpr_t p2 = power();\n\n\t\t\tmul(p, p2);\n\t\t}\n\t\telse{\n\t\t\tss.unget();\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tnormalize(p);\n\treturn p;\n}\n\nexpr_t power(){\n\texpr_t f = factor();\n\t\n\twhile(true){\n\t\tchar ch = 0;\n\t\tss >> ch;\n\n\t\tif( ch == '^' ){\n\t\t\tint x;\n\t\t\tss >> x;\n\t\t\t\n\t\t\texpr_t f2;\n\t\t\tf2.insert( make_pair(vector<int>(26), 1) );\n\n\t\t\twhile( x-- ){\n\t\t\t\tmul(f2, f);\n\t\t\t}\n\t\t\tf.swap(f2);\n\t\t}\n\t\telse{\n\t\t\tss.unget();\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nexpr_t factor(){\n\tchar ch = 0;\n\tss >> ch;\n\n\texpr_t ret;\n\tvector<int> v(26);\n\t\n\tif( ch == '(' ){\n\t\tret = expr();\n\t\tss >> ch;\n\t}\n\telse if( isdigit(ch) ){\n\t\tss.unget();\n\t\tint x;\n\t\tss >> x;\n\t\tif( x != 0 ) ret[v] = x;\n\t}\n\telse{\n\t\tv[ch - 'a'] = 1;\n\t\tret[v] = 1;\n\t}\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tstring str;\n\t\n\twhile( getline(cin, str), str[0] != '.' ){\n\t\tss.str(str);\n\t\tss.clear();\n\t\texpr_t e1 = expr();\n\n\t\twhile( getline(cin, str), str[0] != '.' ){\n\t\t\tss.str(str);\n\t\t\tss.clear();\n\t\t\texpr_t e2 = expr();\n\n\t\t\tif( e1 == e2 ){\tcout << \"yes\\n\";\t}\n\t\t\telse{\tcout << \"no\\n\";\t}\n\t\t}\n\t\t\n\t\tcout << \".\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ll;\n\nstring s;\nint p;\n\nll A[200][300];\nint idx;\n\nll bnf();\n\nll get_num(){\n\n  if(s[p]=='('){\n    \n    p++;\n\n    ll res=bnf();\n    \n    p++;\n\n    return res;\n  }\n  \n  if('a'<=s[p]&&s[p]<='z') return A[T][s[p++]];\n  \n  ll num=0;\n  \n  while('0'<=s[p]&&s[p]<='9') num=num*10+s[p]-'0', p++;\n\n  return num;\n  \n}\n\nll bnf3(){\n\n  ll res=get_num();\n  \n  while(p<s.size()){\n\n    if(s[p]=='^'){\n\n      p++;\n\n      ll r=get_num();\n\n      ll tmp=1;\n\n      for(int i=0;i<r;i++) tmp*=res;\n\n      res=tmp;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nll bnf2(){\n\n  ll res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n\n      p++;\n\n      ll r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nll bnf(){\n\n  ll res=bnf2();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='+'){\n\n      p++;\n      \n      ll r=bnf2();\n      \n      res+=r;\n      \n    }\n    else if(s[p]=='-'){\n\n      p++;\n\n      ll r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nvoid change(){\n  \n  for(int i=0;i<s.size();i++)\n    if((s[i]==')'||('a'<=s[i]&&s[i]<='z')||('0'<=s[i]&&s[i]<='9')))\n      if((s[i+1]=='('||('a'<=s[i+1]&&s[i+1]<='z')||('0'<=s[i+1]&&s[i+1]<='9')))\n\tif(!('0'<=s[i]&&s[i]<='9'&&'0'<=s[i+1]&&s[i+1]<='9'))\n\t  s=s.substr(0,i+1)+'*'+s.substr(i+1);\n\n  \n  for(int i=0;i<s.size();i++)\n    \n    if(s[i]==' ')\n      \n      while(s[i]==' '&&i+1<s.size()&&s[i+1]==' ') s.erase(s.begin()+i);\n  \n\n  if(s[0]==' ') s.erase(s.begin());\n  \n  if(s[s.size()-1]==' ') s.erase(s.begin()+s.size()-1);\n\n  for(int i=0;i<s.size();i++)\n    if(s[i]==' ')\n      if((s[i-1]==')'||('a'<=s[i-1]&&s[i-1]<='z')||('0'<=s[i-1]&&s[i-1]<='9')))\n\tif((s[i+1]=='('||('a'<=s[i+1]&&s[i+1]<='z')||('0'<=s[i+1]&&s[i+1]<='9'))) s[i]='*';\n\n  for(int i=0;i<s.size();i++)\n    \n    if(s[i]==' ') s.erase(s.begin()+i), i--;\n  \n  \n}\n\nint main(){\n\n  for(int T=0;T<200;T++)\n    \n    for(int i=0;i<300;i++) A[T][i]=rand();\n      \n  while(1){\n\n    for(int T=0;T<200;T++){\n\n      idx=T;\n      \n      getline(cin,s);\n    \n      if(s==\".\") break;\n    \n      change();\n    \n      p=0;\n    \n      ll ans=bnf();\n\n      while(1){\n      \n\tgetline(cin,s);\n      \n\tchange();\n      \n\tp=0;\n      \n\tll r=bnf();\n      \n\tif(s==\".\"){\n\t  cout<<\".\"<<endl;\n\t  break;\n\t}\n\n\tcout<<(ans==r?\"yes\":\"no\")<<endl;      \n      }\n\n    \n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint MOD = 1000000007;\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nlong long power(long long a, long long b)\n{\n    long long ret = 1;\n    long long tmp = a;\n    while(b > 0){\n        if(b & 1){\n            ret *= tmp;\n            ret %= MOD;\n        }\n        tmp *= tmp;\n        tmp %= MOD;\n        b >>= 1;\n    }\n    return ret;\n}\n\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nlong long calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        long long ret = 0;\n        for(int i=0; i<n; ++i){\n            ret *= 10;\n            ret += s[i] - '0';\n            ret %= MOD;\n        }\n        return ret;\n    }\n\n    if(n == 1)\n        return variable[s[0]];\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                if(i == 0)\n                    return (calculate(t1) + calculate(t2)) % MOD;\n                else if(i == 1)\n                    return (calculate(t1) - calculate(t2) + MOD) % MOD;\n                else if(i == 2)\n                    return (calculate(t1) * calculate(t2)) % MOD;\n                else\n                    return power(calculate(t1), calculate(t2));\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nstring solve(string s, string t)\n{\n    s = normalize(s);\n    t = normalize(t);\n\n    for(int i=0; i<50; ++i){\n        MOD = xor128() % INT_MAX + 1;\n        for(char c='a'; c<='z'; ++c)\n            variable[c] = xor128() % MOD;\n\n        long long x = calculate(s);\n        long long y = calculate(t);\n\n        if(x != y)\n            return \"no\";\n    }\n\n    return \"yes\";\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            cout << solve(s, t) << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define LIMIT 1000\n\n\nenum Type{\n\tNONE,\n\tNUMBER,\n\tOPEN,\n\tCLOSE,\n\tALPHABET,\n\tPOWER,\n\tSPACE,\n\tPLUS_MINUS,\n};\n\n\nll value[3][26],simpson[3];\nchar buf[1000],mid[20000],line[20000];\n\nll calc_line(){\n\n\tll n,tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\tnegFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(negFLG){\n\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\tnegFLG = false;\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push((tmp*op1)%MOD);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '/' || line[k-1] == '(')){\n\t\t\t\t\tnegFLG = true;\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork %= MOD;\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && OP.top() == '*'){\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork *= work2;\n\t\t\t\t}else if(OP.empty() == false &&OP.top() == '/'){\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork = work2/work;\n\t\t\t\t}\n\t\t\t\twork %= MOD;\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}else{\n\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork %= MOD;\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1; //must not reach here\n}\n\nvoid make_mid(){\n\n\tint mid_index = 0;\n\tchar pre_ch;\n\n\tType pre = NONE,current;\n\n\tfor(int i = 0; buf[i] != '\\n' && buf[i] != '\\0';){\n\n\t\tswitch(buf[i]){\n\t\tcase ' ':\n\n\t\t\twhile(buf[i] == ' ')i++;\n\n\t\t\tswitch(buf[i]){\n\t\t\tcase '(':\n\t\t\t\tcurrent = OPEN;\n\t\t\t\tif(pre == NUMBER || pre == ALPHABET || pre == CLOSE){\n\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t}\n\t\t\t\tmid[mid_index++] = '(';\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tcurrent = CLOSE;\n\t\t\t\tmid[mid_index++] = ')';\n\t\t\t\tbreak;\n\t\t\tcase '^':\n\t\t\t\tcurrent = POWER;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\t\tcurrent = PLUS_MINUS;\n\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(buf[i] >= '0' && buf[i] <= '9'){\n\t\t\t\t\tif(pre == POWER){\n\t\t\t\t\t\tcurrent = ALPHABET;\n\t\t\t\t\t\tfor(int k = 0; k < ((buf[i]-'0')-1); k++){\n\t\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t\t\tmid[mid_index++] = pre_ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(pre == NUMBER || pre == ALPHABET|| pre == CLOSE){\n\t\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrent = NUMBER;\n\t\t\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcurrent = ALPHABET;\n\n\t\t\t\t\tif(pre == NUMBER || pre == ALPHABET|| pre == CLOSE){\n\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t}\n\t\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\t\tpre_ch = buf[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tcurrent = OPEN;\n\t\t\tif(pre == CLOSE || pre == NUMBER || pre == ALPHABET){\n\t\t\t\tmid[mid_index++] = '*';\n\t\t\t}\n\t\t\tmid[mid_index++] = '(';\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tcurrent = CLOSE;\n\t\t\tmid[mid_index++] = ')';\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '^':\n\t\t\tcurrent = POWER;\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '+':\n\t\tcase '-':\n\t\t\tcurrent = PLUS_MINUS;\n\t\t\tmid[mid_index++] = buf[i];\n\t\t\ti++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif(buf[i] >= '0' && buf[i] <= '9'){\n\t\t\t\tif(pre == POWER){\n\t\t\t\t\tcurrent = ALPHABET;\n\t\t\t\t\tfor(int k = 0; k < ((buf[i]-'0')-1); k++){\n\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t\tmid[mid_index++] = pre_ch;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\tif(pre == ALPHABET || pre == CLOSE){\n\t\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t\t}\n\t\t\t\t\tcurrent = NUMBER;\n\t\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcurrent = ALPHABET;\n\n\t\t\t\tif(pre == NUMBER || pre == ALPHABET || pre == CLOSE){\n\t\t\t\t\tmid[mid_index++] = '*';\n\t\t\t\t}\n\t\t\t\tmid[mid_index++] = buf[i];\n\t\t\t\tpre_ch = buf[i];\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tpre = current;\n\t}\n\tmid[mid_index] = '\\0';\n}\n\nvoid make_line(int num){\n\n\tint line_index = 0;\n\n\tstack<char> S;\n\n\tfor(int i = 0; mid[i] != '\\0'; i++){\n\n\t\tif(mid[i] >= 'a' && mid[i] <= 'z'){\n\n\t\t\tint tmp = value[num][mid[i]-'a'];\n\n\t\t\twhile(tmp != 0){\n\t\t\t\tS.push('0'+(tmp%10));\n\t\t\t\ttmp /= 10;\n\t\t\t}\n\n\t\t\twhile(!S.empty()){\n\t\t\t\tline[line_index++] = S.top();\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}else{\n\t\t\tline[line_index++] = mid[i];\n\t\t}\n\t}\n\tline[line_index] = '=';\n\tline[line_index+1] = '\\0';\n}\n\nvoid func(){\n\n\tmake_mid();\n\n\tfor(int i = 0; i < 3; i++){\n\t\tmake_line(i);\n\t\tsimpson[i] = calc_line();\n\t}\n\n\tbool FLG;\n\tll tmp;\n\n\twhile(true){\n\t\tfgets(buf,1000,stdin);\n\t\tif(buf[0] == '.')break;\n\n\t\tFLG = true;\n\n\t\tmake_mid();\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tmake_line(i);\n\t\t\ttmp = calc_line();\n\t\t\tif(tmp != simpson[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(FLG){\n\t\t\tprintf(\"yes\\n\");\n\t\t}\n\t}\n\tprintf(\".\\n\");\n}\n\n\nint main(){\n\n\tll table[LIMIT];\n\tfor(ll i = 0; i < LIMIT; i++){\n\t\ttable[i] = 1;\n\t}\n\ttable[0] = 0;\n\ttable[1] = 0;\n\n\tfor(ll i = 2; i <= sqrt(LIMIT); i++){\n\t\tif(table[i] == 1){\n\t\t\tfor(ll k = 2*i; k < LIMIT; k += i){\n\t\t\t\ttable[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tll prime[LIMIT],prime_index = 0;\n\tfor(ll i = 2; i < LIMIT; i++){\n\t\tif(table[i] == 1){\n\t\t\tprime[prime_index++] = i;\n\t\t}\n\t}\n\n\tfor(ll i = 0; i < 3; i++){\n\t\tll base = 7*(i+1);\n\n\t\tfor(ll k = 0; k < 26; k++){\n\t\t\tvalue[i][k] = prime[base+k];\n\t\t}\n\t}\n\n\n\twhile(true){\n\t\tfgets(buf,1000,stdin);\n\t\tif(buf[0] == '.')break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nstring processSpace(const string &str){\n    string res=\"\";\n    bool sp=false;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i]!=' '){\n            if(!sp&&res.size()!=0&&(res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                &&(str[i]>='0'&&str[i]<='9')){\n\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&(str[i]=='(')){\n                    res+='*';\n            }\n            else if(res.size()!=0&&(res[res.size()-1]==')')\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&res[res.size()-1]==')'&&str[i]=='(')\n                res+='*';\n            res+=str[i];\n            sp=false;\n        }\n        else{\n            sp=true;\n        }\n    }\n    return res;\n}\n\n\nvector<pair<int,map<string,int> > > analysis(string str){\n    vector<pair<int,map<string,int> > > res;\n    if(str.size()==0)return res;\n    // ©Ç¤©`FbN\n    bool allNum=true;\n    for(int i = 0; i < str.size(); i++){\n        if(!(str[i]>='0'&&str[i]<='9'))\n            allNum=false;\n    }\n    if(allNum){\n        res.push_back(make_pair(atoi(str.c_str()),map<string,int>()));\n        return res;\n    }\n    // e©`FbN\n    if(str.size()==1&&str[0]>='a'&&str[0]<='z'){\n        map<string,int> msi;\n        string tmp;\n        tmp+=(str[0]);\n        msi[tmp]=1;\n        res.push_back(make_pair(1,msi));\n        return res;\n    }\n    if(str[0]=='('){\n        int cnt=0;\n        bool no=false;\n        for(int i = 1; i < str.size()-1; i++){\n            if(str[i]==')')\n                cnt--;\n            else if(str[i]=='(')\n                cnt++;\n            if(cnt<0){\n                no=true;\n                break;\n            }\n        }\n        // ÊðÆé\n        if(!no)\n            return analysis(str.substr(1,str.size()-2));\n    }\n    // ÊÉZqðµÄ¢­\n\n    // vXZqÆ}CiXZqðTõ\n    int cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='+'||str[i]=='-'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                for(int j = 0; j < left.size(); j++){\n                    // Lªêv·éàÌðTõ\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==left[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+left[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-left[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no){\n                        //if(str[i]=='-')\n                        //    left[j].first*=-1;\n                        res.push_back(left[j]);\n                    }\n                }\n                for(int j = 0; j < right.size(); j++){\n                    // Lªêv·éàÌðTõ\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==right[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+right[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-right[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no){\n                        if(str[i]=='-')right[j].first*=-1;\n                        res.push_back(right[j]);\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='*'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                for(int k = 0; k < left.size(); k++){\n                    for(int j = 0; j < right.size(); j++){\n                        // êÂ¸Âvfð|¯ZµÄ¢­\n                        // W\n                        int co=left[k].first*right[j].first;\n                        map<string,int> literals=left[k].second;\n                        for(map<string,int>::iterator it=right[j].second.begin();it!=right[j].second.end();it++)\n                            literals[it->first]+=it->second;\n                        pair<int,map<string,int> > p=make_pair(co,literals);\n                        bool no=false;\n                        for(int l = 0; l < res.size(); l++){\n                            if(p.second==res[l].second){\n                                int coSum=p.first+res[l].first;\n                                if(coSum==0){\n                                    res.erase(res.begin()+l);\n                                    no=true;\n                                    break;\n                                }\n                                else{\n                                    res[l].first=coSum;\n                                    no=true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!no)\n                            res.push_back(p);\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='^'){\n                vector<pair<int,map<string,int> > > left=analysis(str.substr(0,i));\n                vector<pair<int,map<string,int> > > right=analysis(str.substr(i+1));\n                map<string,int> msi;\n                msi[left[0].second.begin()->first]=right[0].first;\n                res.push_back(make_pair(1,msi));\n                return res;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    string teacher;\n    while(getline(cin,teacher)&&teacher!=\".\"){\n        teacher=processSpace(teacher);\n        vector<pair<int,map<string,int> > > t=analysis(teacher);\n        sort(t.begin(),t.end());\n        string student;\n        while(getline(cin,student)&&student!=\".\"){\n            student=processSpace(student);\n            vector<pair<int,map<string,int> > > s=analysis(student);\n            sort(s.begin(),s.end());\n            if(s==t)\n                cout<<\"yes\"<<endl;\n            else\n                cout<<\"no\"<<endl;\n        }\n        cout<<\".\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\n\nstruct T{\n  map<string, Int> ms;\n  T(){}\n  T(string s, Int c){\n    sort(s.begin(),s.end());\n    ms[s]+=c;\n  }\n\n  T operator+=(const T &a){\n    for(auto p:a.ms)\n      ms[p.first]+=p.second;\n    return *this;\n  }\n  \n  T operator-=(const T &a){\n    for(auto p:a.ms)\n      ms[p.first]-=p.second;\n    return *this;\n  }\n  \n  T operator+(const T &a) const{\n    T res(*this);\n    return res+=a;\n  }\n  \n  T operator-(const T &a) const{\n    T res(*this);\n    return res-=a;\n  }\n  \n  T operator*(const T &a) const{\n    T res;\n    for(auto p:ms)\n      for(auto q:a.ms)\n        res+=T(p.first+q.first,p.second*q.second);\n    return res;\n  }\n\n  T pow(Int k) const{\n    assert(k>=1);\n    T res(*this);\n    for(Int i=1;i<k;i++) res=res*(*this);\n    return res;\n  }\n\n  map<string, Int> norm(){\n    map<string, Int> res;\n    for(auto p:ms)\n      if(p.second) res[p.first]=p.second;\n    return res;\n  }\n};\n\nusing V = vector<string>; \nT expr  (const V &vs,Int &p);\nT term  (const V &vs,Int &p);\nT factor(const V &vs,Int &p);\nT power (const V &vs,Int &p);\nInt number(const V &vs,Int &p);\n\nT expr  (const V &vs,Int &p){\n  T res=term(vs,p);\n  while(p<(Int)vs.size()){\n    if(vs[p]==\"+\"s){\n      p++;\n      res=res+term(vs,p);\n      continue;\n    }\n    if(vs[p]==\"-\"s){\n      p++;\n      res=res-term(vs,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nT term  (const V &vs,Int &p){  \n  T res=factor(vs,p);\n  while(p<(Int)vs.size()){\n    if(vs[p]==\"+\"s) break;\n    if(vs[p]==\"-\"s) break;\n    if(vs[p]==\"^\"s) break;\n    if(vs[p]==\")\"s) break;\n    res=res*factor(vs,p);\n  }\n  return res;\n}\n\nT factor(const V &vs,Int &p){  \n  T res=power(vs,p);\n  if(p<(Int)vs.size()&&vs[p]==\"^\"s){\n    p++;\n    Int k=number(vs,p);\n    return res.pow(k);\n  }  \n  return res;\n}\n\nT power (const V &vs,Int &p){\n  if(vs[p]==\"(\"s){\n    p++;\n    T res=expr(vs,p);\n    assert(vs[p]==\")\"s);\n    p++;\n    return res;\n  }\n  if(isalpha(vs[p][0])) return T(vs[p++],1);\n  return T(\"\"s, number(vs,p));\n}\n\nInt number(const V &vs,Int &p){\n  return stoll(vs[p++]);\n}\n\nT tran(string s){\n  Int n=s.size();\n  string t;\n  for(Int i=0;i<n;i++){\n    if(!isdigit(s[i])) t+=' ';\n    t+=s[i];\n    if(!isdigit(s[i])) t+=' ';\n  }  \n  V vs;\n  stringstream ss(t);\n  while(ss>>t) vs.emplace_back(t);\n  Int p=0;\n  return expr(vs,p);\n}\n\nsigned main(){\n  string s;\n  while(getline(cin,s)){\n    if(s==\".\"s) break;\n    auto vs=tran(s);\n    while(1){\n      string t;\n      getline(cin,t);      \n      if(t==\".\"s) break;\n      auto vt=tran(t);\n      cout<<(vs.norm()==vt.norm()?\"yes\":\"no\")<<endl;\n    }    \n    cout<<\".\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef pair<int,string> term;\n\nvector<term> normalize(const vector<term>& a)\n{\n\tmap<string,int> f;\n\tfor(auto x:a){\n\t\tsort(all(x.second));\n\t\tf[x.second]+=x.first;\n\t}\n\tvector<term> b;\n\tfor(auto p:f) if(p.second) b.emplace_back(p.second,p.first);\n\treturn b;\n}\n\nvector<term> add(const vector<term>& a,const vector<term>& b)\n{\n\tmap<string,int> f;\n\tfor(auto x:a){\n\t\tsort(all(x.second));\n\t\tf[x.second]+=x.first;\n\t}\n\tfor(auto x:b){\n\t\tsort(all(x.second));\n\t\tf[x.second]+=x.first;\n\t}\n\tvector<term> c;\n\tfor(auto p:f) if(p.second) c.emplace_back(p.second,p.first);\n\treturn c;\n}\n\nvector<term> sub(const vector<term>& a,const vector<term>& b)\n{\n\tmap<string,int> f;\n\tfor(auto x:a){\n\t\tsort(all(x.second));\n\t\tf[x.second]+=x.first;\n\t}\n\tfor(auto x:b){\n\t\tsort(all(x.second));\n\t\tf[x.second]-=x.first;\n\t}\n\tvector<term> c;\n\tfor(auto p:f) if(p.second) c.emplace_back(p.second,p.first);\n\treturn c;\n}\n\nvector<term> mul(const vector<term>& a,const vector<term>& b)\n{\n\tmap<string,int> f;\n\tfor(auto x:a) for(auto y:b){\n\t\tstring s=x.second+y.second; sort(all(s));\n\t\tf[s]+=x.first*y.first;\n\t}\n\tvector<term> c;\n\tfor(auto p:f) if(p.second) c.emplace_back(p.second,p.first);\n\treturn c;\n}\n\nvector<term> pow(const vector<term>& a,int r)\n{\n\tvector<term> b(1,term(1,\"\"));\n\trep(i,r) b=mul(b,a);\n\treturn b;\n}\n\npair<vector<term>,int> parse_expr(string f,int i);\n\npair<vector<term>,int> parse_fact(string f,int i)\n{\n\twhile(i<f.size() && f[i]==' ') i++;\n\tvector<term> x;\n\tif(f[i]=='('){\n\t\ttie(x,i)=parse_expr(f,i+1);\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t\ti++;\n\t}\n\telse if(isdigit(f[i])){\n\t\tint n=0;\n\t\twhile(i<f.size() && isdigit(f[i]))\n\t\t\tn=n*10+f[i++]-'0';\n\t\tx.emplace_back(n,\"\");\n\t}\n\telse if(isalpha(f[i])){\n\t\tx.emplace_back(1,f.substr(i,1));\n\t\ti++;\n\t}\n\t\n\twhile(i<f.size() && f[i]==' ') i++;\n\tif(i<f.size() && f[i]=='^'){\n\t\ti++;\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t\tint n=0;\n\t\twhile(i<f.size() && isdigit(f[i]))\n\t\t\tn=n*10+f[i++]-'0';\n\t\tx=pow(x,n);\n\t}\n\treturn mp(x,i);\n}\n\npair<vector<term>,int> parse_term(string f,int i)\n{\n\twhile(i<f.size() && f[i]==' ') i++;\n\tvector<term> x; tie(x,i)=parse_fact(f,i);\n\twhile(i<f.size() && f[i]==' ') i++;\n\twhile(i<f.size() && (f[i]=='(' || isdigit(f[i]) || isalpha(f[i]))){\n\t\tvector<term> y; tie(y,i)=parse_fact(f,i);\n\t\tx=mul(x,y);\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t}\n\treturn mp(x,i);\n}\n\npair<vector<term>,int> parse_expr(string f,int i)\n{\n\twhile(i<f.size() && f[i]==' ') i++;\n\tvector<term> x; tie(x,i)=parse_term(f,i);\n\twhile(i<f.size() && f[i]==' ') i++;\n\twhile(i<f.size() && (f[i]=='+' || f[i]=='-')){\n\t\tchar op=f[i++];\n\t\tvector<term> y; tie(y,i)=parse_term(f,i);\n\t\tif(op=='+') x=add(x,y);\n\t\tif(op=='-') x=sub(x,y);\n\t\twhile(i<f.size() && f[i]==' ') i++;\n\t}\n\treturn mp(x,i);\n}\n\nint main()\n{\n\tfor(string line;getline(cin,line) && line!=\".\";){\n\t\tvs fs;\n\t\tdo{\n\t\t\tfs.push_back(line);\n\t\t\tgetline(cin,line);\n\t\t}while(line!=\".\");\n\t\t\n\t\tauto t0=normalize(parse_expr(fs[0],0).first);\n\t\trepi(i,1,fs.size()){\n\t\t\tauto t=normalize(parse_expr(fs[i],0).first);\n\t\t\tcout<<(t==t0?\"yes\":\"no\")<<endl;\n\t\t}\n\t\tcout<<'.'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ll;\n\nstring s;\nint p;\n\nll A[300];\n\n\nll bnf();\n\nll get_num(){\n\n  if(s[p]=='('){\n    \n    p++;\n\n    ll res=bnf();\n    \n    p++;\n\n    return res;\n  }\n  \n  if('a'<=s[p]&&s[p]<='z') return A[s[p++]];\n  \n  ll num=0;\n  \n  while('0'<=s[p]&&s[p]<='9') num=num*10+s[p]-'0', p++;\n\n  return num;\n  \n}\n\nll bnf3(){\n\n  ll res=get_num();\n  \n  while(p<s.size()){\n\n    if(s[p]=='^'){\n\n      p++;\n\n      ll r=get_num();\n\n      ll tmp=1;\n\n      for(int i=0;i<r;i++) tmp*=res;\n\n      res=tmp;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nll bnf2(){\n\n  ll res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n\n      p++;\n\n      ll r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nll bnf(){\n\n  ll res=bnf2();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='+'){\n\n      p++;\n      \n      ll r=bnf2();\n      \n      res+=r;\n      \n    }\n    else if(s[p]=='-'){\n\n      p++;\n\n      ll r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n  \n  return res;\n}\n\nvoid change(){\n  \n  for(int i=0;i<s.size();i++)\n    if((s[i]==')'||('a'<=s[i]&&s[i]<='z')||('0'<=s[i]&&s[i]<='9')))\n      if((s[i+1]=='('||('a'<=s[i+1]&&s[i+1]<='z')||('0'<=s[i+1]&&s[i+1]<='9')))\n\tif(!('0'<=s[i]&&s[i]<='9'&&'0'<=s[i+1]&&s[i+1]<='9'))\n\t  s=s.substr(0,i+1)+'*'+s.substr(i+1);\n\n  \n  for(int i=0;i<s.size();i++)\n    \n    if(s[i]==' ')\n      \n      while(s[i]==' '&&i+1<s.size()&&s[i+1]==' ') s.erase(s.begin()+i);\n  \n\n  if(s[0]==' ') s.erase(s.begin());\n  \n  if(s[s.size()-1]==' ') s.erase(s.begin()+s.size()-1);\n\n  for(int i=0;i<s.size();i++)\n    if(s[i]==' ')\n      if((s[i-1]==')'||('a'<=s[i-1]&&s[i-1]<='z')||('0'<=s[i-1]&&s[i-1]<='9')))\n\tif((s[i+1]=='('||('a'<=s[i+1]&&s[i+1]<='z')||('0'<=s[i+1]&&s[i+1]<='9'))) s[i]='*';\n\n  for(int i=0;i<s.size();i++)\n    \n    if(s[i]==' ') s.erase(s.begin()+i), i--;\n  \n  \n}\n\nint main(){\n\n  for(int i=0;i<300;i++) A[i]=rand();\n      \n  while(1){\n    \n    getline(cin,s);\n    \n    if(s==\".\") break;\n    \n    change();\n    \n    p=0;\n    \n    ll ans=bnf();\n\n    while(1){\n      \n      getline(cin,s);\n      \n      change();\n      \n      p=0;\n      \n      ll r=bnf();\n      \n      if(s==\".\"){\n\tcout<<\".\"<<endl;\n\tbreak;\n      }\n\n      cout<<(ans==r?\"yes\":\"no\")<<endl;      \n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1LL<<59)\n\n#define int ll\n\ntypedef array<int,27> AI;\ntypedef vector<AI> EX;\ntypedef string::const_iterator State;\n\nstring normalize(string s){\n\tstring t=\"\";\n\trep(i,s.size()){\n\t\tif(s[i]!=' ')t+=s[i];\n\t\telse if(i+1==s.size()||s[i+1]!=' ') t+=s[i];\n\t}\n\trep(i,t.size()-1)assert(t[i]!=' '||t[i+1]!=' ');\n\n\tstring u=\"\";\n\trep(i,t.size()){\n\t\tchar ch = t[i];\n\t\tif(ch!=' '){u+=ch;continue;}\n\n\t\tif(!(i-1<0||t[i-1]=='('||t[i-1]=='-'||t[i-1]=='+'||t[i-1]=='^')&&!(i+1>=t.size()||t[i+1]==')'||t[i+1]=='-'||t[i+1]=='+'||t[i+1]=='^'))u+=' ';\n\t}\n\trep(i,u.size())if(u[i]==' ')u[i] = '*';\n\t\n\tstring ret = \"\";\n\trep(i,u.size()){\n\t\tret+=u[i];\n\t\tif(i+1>=u.size())continue;\n\t\tif(isdigit(u[i])){\n\t\t\tif(u[i+1]=='('||isalpha(u[i+1]))ret+='*';\n\t\t}\n\t\tif(isalpha(u[i])){\n\t\t\tif(u[i+1]=='('||isdigit(u[i+1])||isalpha(u[i+1]))ret+='*';\n\t\t}\n\t}\n\treturn ret;\n}\n\nEX E(State &beg);\n\n\nint dig(State &beg){\n\tassert(isdigit(*beg));\n\tstring res = \"\";\n\twhile(isdigit(*beg)){\n\t\tres+=*beg;\n\t\tbeg++;\n\t}\n\treturn  stoll(res);\n}\n\n\nEX P(State &beg){\n\tif(isdigit(*beg)){\n\t\tint res = dig(beg);\n\t\tAI ret;\n\t\tret[0]=res;\n\t\tfor(int i=1;i<ret.size();i++)ret[i]=0;\n\t\treturn EX(1,ret);\n\t}\n\telse{\n\t\tassert(isalpha(*beg));\n\t\tchar ch = *beg;\n\t\tbeg++;\n\n\t\tif(*beg=='^'){\n\t\t\tbeg++;\n\t\t\tint t = dig(beg);\n\t\t\tAI ret;\n\t\t\trep(i,ret.size()){\n\t\t\t\tif(i==ch-'a'+1)ret[i] = t;\n\t\t\t\telse ret[i] = 0;\n\t\t\t}\n\t\t\tret[0]=1;\n\t\t\t\n\t\t\treturn EX(1,ret);\n\t\t}\n\t\telse{\n\t\t\tAI ret;\n\t\t\trep(i,ret.size()){\n\t\t\t\tif(i==ch-'a'+1)ret[i] = 1;\n\t\t\t\telse ret[i] = 0;\n\t\t\t}\n\t\t\tret[0]=1;\n\n\t\t\treturn EX(1,ret);\n\t\t}\n\t}\n}\n\n\nAI mul(AI a,AI b){\n\tAI ret;\n\tret[0] = a[0]*b[0];\n\tfor(int i=1;i<a.size();i++){\n\t\tret[i] = a[i]+b[i];\n\t}\n\treturn ret;\n}\n\nEX mulEX(EX a,EX b){\n\tEX ret;\n\trep(i,a.size()){\n\t\trep(j,b.size()){\n\t\t\tret.pb(mul(a[i],b[j]));\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nEX T(State &beg){\n\tEX ret;\n\tif(*beg=='('){\n\t\tbeg++;\n\t\tret = E(beg);\n\t\tbeg++;\n\t}\n\telse{\n\t\tassert(isdigit(*beg)||isalpha(*beg));\n\t\tret = P(beg);\n\t}\n\t\n\twhile(*beg=='*'){\n\t\tbeg++;\n\t\tEX t = T(beg);\n\t\tret = mulEX(ret,t);\n\t}\n\treturn ret;\n}\n\n\nbool isSame(AI a,AI b){\n\tfor(int i=1;i<a.size();i++){\n\t\tif( a[i]!=b[i] )return false;\n\t}\n\treturn true;\n}\n\n\nEX E(State &beg){\n\tEX res = T(beg);\n\t\n\twhile(*beg=='+'||*beg=='-'){\n\t\tif(*beg=='+'){\n\t\t\tbeg++;\n\t\t\tEX t = T(beg);\n\t\t\trep(i,t.size()){\n\t\t\t\tbool f=false;\n\t\t\t\trep(j,res.size()){\n\t\t\t\t\tif(isSame(t[i],res[j])){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tres[j][0]+=t[i][0];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tres.pb(t[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*beg=='-'){\n\t\t\tbeg++;\n\t\t\tEX t = T(beg);\n\t\t\trep(i,t.size()){\n\t\t\t\tbool f=false;\n\t\t\t\trep(j,res.size()){\n\t\t\t\t\tif(isSame(t[i],res[j])){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tres[j][0]-=t[i][0];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tt[i][0]*=-1;\n\t\t\t\t\tres.pb(t[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\nbool isMatch(EX a,EX b){\n\tsort(all(a));\n\tsort(all(b));\n\tif(a==b)return true;\n\telse return false;\n}\n\n\nvoid output(vector<EX> ans){\n\trep(i,ans.size()){\n\t\trep(j,ans[i].size()){\n\t\t\trep(k,ans[i][j].size()){\n\t\t\t\tcout<<ans[i][j][k]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl<<endl;\n\t}\n}\n\n\nsigned main(){\n\tassert(normalize(\"(a - b) (0-b+a) - 1a ^ 2 - b ^ 2\")==\"(a-b)*(0-b+a)-1*a^2-b^2\");\n\twhile(1){\n\t\tvector<string> vs;\n\t\tstring s;\n\t\twhile(getline(cin,s)&&s!=\".\"){\n\t\t\tvs.pb(s);\n\t\t}\n\t\tif(vs.size()==0)break;\n\t\t\n\t\trep(i,vs.size()) vs[i] = normalize(vs[i]);\n\t\t\n\t\tvector<EX> ans;\n\t\trep(i,vs.size()){\n\t\t\tState beg = vs[i].begin();\n\t\t\tEX res = E(beg);\n\t\t\tans.pb(res);\n\t\t}\n\t\t\n//\t\trep(i,vs.size())cout<<vs[i]<<\" \";cout<<endl;\n//\t\toutput(ans);\n\t\t\n\t\tfor(int i=1;i<ans.size();i++){\n\t\t\tif(isMatch(ans[0],ans[i])){\n\t\t\t\tcout<<\"yes\"<<endl;\n\t\t\t}\n\t\t\telse cout<<\"no\"<<endl;\n\t\t}\n\t\tcout<<\".\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstring norm(string s)\n{\n\tstring res;\n\tfor(int i=0; i<s.size(); i++) {\n\t\tif(s[i] == ' ') {\n\t\t\tif(isalnum(s[i-1]) && isalnum(s[i+1]))\n\t\t\t\tres += '*';\n\t\t}\n\t\telse {\n\t\t\tres += s[i];\n\t\t\tif((isalnum(s[i]) && isalnum(s[i+1])) && (!(isdigit(s[i]) && isdigit(s[i+1])))) {\n\t\t\t\tres += '*';\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\n\nclass Polynomial\n{\npublic:\n\tmap<string, int> tem;\n\tPolynomial() \n\t{\n\t\ttem[\"Digit\"] = 0;\n\t}\n\n\tPolynomial(int k) \n\t{\n\t\ttem[\"Digit\"] = k;\n\t}\n\n\tPolynomial(char a)\n\t{\n\t\ttem[string(1,a)] = 1;\n\t\ttem[\"Digit\"] = 0;\n\t}\n\n\tvoid add(Polynomial& p)\n\t{\n\t\tmap<string, int>::iterator it = p.tem.begin();\n\t\tfor(; it != p.tem.end(); it++) {\n\t\t\tif(it->second == 0) continue;\n\n\t\t\tif(!tem.count(it->first)) tem[it->first] = it->second;\n\t\t\telse tem[it->first] += it->second;\n\t\t}\n\t}\n\n\tvoid sub(Polynomial& p)\n\t{\n\t\tmap<string, int>::iterator it = p.tem.begin();\n\t\tfor(; it != p.tem.end(); it++) {\n\t\t\tif(it->second == 0) continue;\n\n\t\t\tif(!tem.count(it->first)) tem[it->first] = -it->second;\n\t\t\telse tem[it->first] -= it->second;\n\t\t}\n\n\t}\n\n\tvoid mul(Polynomial& p)\n\t{\n\t\tPolynomial tmp;\n\n\t\tmap<string, int>::iterator pit = p.tem.begin();\n\t\tmap<string, int>::iterator it = tem.begin();\n\t\tfor(; it != tem.end(); it++) \n\t\tfor(pit = p.tem.begin(); pit != p.tem.end(); pit++) {\n\t\t\tstring nt;\n\n\t\t\tif(it->first == \"Digit\" && pit->first == \"Digit\") {\n\t\t\t\tnt = it->first;\n\t\t\t}\n\t\t\telse if(it->first == \"Digit\") {\n\t\t\t\tnt = pit->first;\n\t\t\t}\n\t\t\telse if(pit->first == \"Digit\") {\n\t\t\t\tnt = it->first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnt = string(it->first) + string(pit->first);\n\t\t\t\tsort(nt.begin(), nt.end()); \n\t\t\t}\n\n\t\t\tint k = it->second * pit->second;\n\t\t\t\n\n\t\t\tif(k==0) continue;\n\n\t\t\tif(!tmp.tem.count(nt)) tmp.tem[nt] = k;\n\t\t\telse tmp.tem[nt] += k;\n\t\t}\n\n\t\t*this = tmp;\n\t}\n\n\tvoid pow(Polynomial& p)\n\t{\n\t\tint pw = p.tem[\"Digit\"];\n\t\t\n\t\tPolynomial res(1);\n\t\tPolynomial tmp = *this;\n\t\tfor(int i=0; i<pw; i++)\n\t\t\tres.mul(tmp);\n\n\t\t*this = res;\n\t}\n\n\tbool equals(Polynomial& p) {\n\t\tmap<string, int>::iterator pit = p.tem.begin();\n\t\tmap<string, int>::iterator it = tem.begin();\n\n\t\tfor(; it != tem.end(); ++it) {\n\t\t\tif(p.tem.count(it->first) == 0) {\n\t\t\t\tif(it->second != 0) return false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(it->second != p.tem[it->first]) return false;\n\t\t\t}\n\t\t}\n\n\t\tfor(; pit != p.tem.end(); ++pit) {\n\t\t\tif(tem.count(pit->first) == 0) {\n\t\t\t\tif(pit->second != 0) return false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(pit->second != tem[pit->first]) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n};\n\nstring str;\nint p;\n\nPolynomial expr();\nPolynomial term();\nPolynomial factor();\nPolynomial primary();\nPolynomial digit();\n\nPolynomial expr()\n{\n\tPolynomial a = term();\n\twhile(str[p] == '+' || str[p] == '-') {\n\t\tchar op = str[p++];\n\t\tPolynomial b = term();\n\n\t\tif(op == '+') a.add(b);\n\t\tif(op == '-') a.sub(b);\n\t}\n\n\treturn a;\n}\n\nPolynomial term()\n{\n\tPolynomial a = factor();\n\twhile(str[p] == '*') {\n\t\tchar op = str[p++];\n\t\tPolynomial b = factor();\n\n\t\ta.mul(b);\n\t}\n\n\treturn a;\n}\n\nPolynomial factor()\n{\n\tPolynomial a = primary();\n\tif(str[p] == '^') {\n\t\tp++;\n\n\t\tPolynomial pw = digit();\n\t\ta.pow(pw);\n\t}\n\n\treturn a;\n}\n\nPolynomial primary()\n{\n\tPolynomial a;\n\tif(isdigit(str[p])) {\n\t\ta = digit();\n\t}\n\telse if(isalpha(str[p])) {\n\t\ta = Polynomial(str[p]);\n\t\tp++;\n\t}\n\telse {\n\t\tp++;\n\t\ta = expr();\n\t\tp++;\n\t}\n\n\treturn a;\n}\n\nPolynomial digit()\n{\n\tint res = 0;\n\twhile(isdigit(str[p])) {\n\t\tres *= 10;\n\t\tres += str[p] - '0';\n\t\tp++;\n\t}\n\n\treturn Polynomial(res);\n}\n\nPolynomial parse()\n{\n\tp = 0;\n\tstr += '$';\n\tstr = norm(str);\n\n\treturn expr();\n}\n\nint main()\n{\n\twhile(1) {\n\t\tgetline(cin, str);\n\t\tif(str == \".\") break;\n\t\tPolynomial a = parse();\n\n\t\twhile(1) {\n\t\t\tgetline(cin, str);\n\t\t\tif(str == \".\") {\n\t\t\t\tcout << str << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPolynomial b = parse();\n\n\t\t\tcout << (a.equals(b) ? \"yes\":\"no\") << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdlib>\n#include<iostream>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint var[128];\n\nll expr(const string &,int &);\nll term(const string &,int &);\nll factor(const string &,int &);\nll primary(const string &,int &);\nll number(const string &,int &);\n\nll expr(const string &s,int &idx){\n\tll a=term(s,idx);\n\twhile(idx<s.length() && (s[idx]=='+' || s[idx]=='-')){\n\t\tchar op=s[idx++];\n\t\tif     (op=='+') a+=term(s,idx);\n\t\telse if(op=='-') a-=term(s,idx);\n\t}\n\treturn a;\n}\n\nll term(const string &s,int &idx){\n\tll a=factor(s,idx);\n\twhile(idx<s.length() && s[idx]=='*'){\n\t\tidx++;\n\t\ta*=factor(s,idx);\n\t}\n\treturn a;\n}\n\nll factor(const string &s,int &idx){\n\tll a=primary(s,idx);\n\tif(idx<s.length() && s[idx]=='^'){\n\t\tidx++;\n\t\tll b=primary(s,idx);\n\t\tll apowb=1;\n\t\trep(i,b) apowb*=a;\n\t\ta=apowb;\n\t}\n\treturn a;\n}\n\nll primary(const string &s,int &idx){\n\tll a;\n\tif(s[idx]=='('){\n\t\tidx++;\n\t\ta=expr(s,idx);\n\t\tidx++;\n\t}\n\telse a=number(s,idx);\n\treturn a;\n}\n\nll number(const string &s,int &idx){\n\tll a;\n\tif(isalpha(s[idx])) a=var[s[idx++]];\n\telse{\n\t\tfor(a=0;idx<s.length()&&isdigit(s[idx]);idx++) a=10*a+(s[idx]-'0');\n\t}\n\treturn a;\n}\n\nll parse(const string &s){\n\tint idx=0;\n\treturn expr(s,idx);\n}\n\nvoid normalize(string &s){\n\tstring t;\n\tint n=s.length();\n\t// óð\n\t// ½¾µAóªÈ¢ÆÓ¡ªÏíéÆ±ë (_) ÉÍ ~ ðÍ³Þ\n\trep(i,n) if(s[i]!=' ') {\n\t\tif(i>0 && s[i-1]==' ' && !t.empty()){\n\t\t\tif(isdigit(*t.rbegin()) && isdigit(s[i])) t+='*';\n\t\t}\n\t\tt+=s[i];\n\t}\n\n\t// BNF É¤æ¤É ~ ðÍ³Þ\n\ts.clear();\n\tn=t.length();\n\trep(i,n){\n\t\tif(i>0){\n\t\t\tif(isdigit(t[i-1]) && isalpha(t[i])\n\t\t\t|| isdigit(t[i-1]) && t[i]=='('\n\t\t\t|| isalpha(t[i-1]) && isdigit(t[i])\n\t\t\t|| isalpha(t[i-1]) && isalpha(t[i])\n\t\t\t|| isalpha(t[i-1]) && t[i]=='('\n\t\t\t|| t[i-1]==')' && isdigit(t[i])\n\t\t\t|| t[i-1]==')' && isalpha(t[i])\n\t\t\t|| t[i-1]==')' && t[i]=='(') s+='*';\n\t\t}\n\t\ts+=t[i];\n\t}\n}\n\nint main(){\n\tfor(string ex0;getline(cin,ex0),ex0!=\".\";){\n\t\tnormalize(ex0);\n\t\twhile(1){\n\t\t\tstring ex; getline(cin,ex);\n\t\t\tif(ex==\".\") break;\n\t\t\tnormalize(ex);\n\n\t\t\tbool ok=true;\n\t\t\trep(_,10){\n\t\t\t\tfor(int c='a';c<='z';c++) var[c]=rand()%7;\n\t\t\t\tif(parse(ex0)!=parse(ex)){ ok=false; break; }\n\t\t\t}\n\t\t\tputs(ok?\"yes\":\"no\");\n\t\t}\n\t\tputs(\".\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    assert(isdigit(in[p]));\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n\n    //debug\n    p=0;\n    in=pre_processing2(tmp);\n    formula me2=fact(in,p);\n    assert(is_same_formula(me,me2));\n    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      p=0;\n      cmp=pre_processing2(tmp);\n      formula you2=fact(cmp,p);\n      assert(is_same_formula(you,you2));\n\n      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n\n  return ret;\n}\n\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define int long long\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  if (a.size() != b.size())return false;\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  //  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    tmp.p[in[p]-'a']++;\n    //    while(p < in.size() && isalpha(in[p])){\n\n      p++;\n      //    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n\n    //debug\n    /*\n    p=0;\n    in=pre_processing2(tmp);\n    formula me2=fact(in,p);\n    assert(is_same_formula(me,me2));\n    */\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n      \n      /*\n      p=0;\n      cmp=pre_processing2(tmp);\n      formula you2=fact(cmp,p);\n      assert(is_same_formula(you,you2));\n      */\n      //      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[27];\n  Element(){\n    c=0;rep(i,27)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,27)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  if (a.size() != b.size())return false;\n  rep(i,a.size()){\n    bool canfind=false;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,27){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,27){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p]=='+'||in[p]=='-')break;\n    else if (in[p] ==')')break;\n    else {\n      formula tmp = digit(in,p);\n\tret=mult(ret,tmp);\n    }\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;\n    //    output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n      //      cout << \"formula :\"<<cmp<<endl;\n      //      output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\ntypedef vector<pair<int,map<string,int> > > express;\n\nstring processSpace(const string &str){\n    string res=\"\";\n    bool sp=false;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i]!=' '){\n            if(!sp&&res.size()!=0&&(res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                &&(str[i]>='0'&&str[i]<='9')){\n\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&((res[res.size()-1]>='0'&&res[res.size()-1]<='9')\n                ||(res[res.size()-1]>='a'&&res[res.size()-1]<='z'))\n                &&(str[i]=='(')){\n                    res+='*';\n            }\n            else if(res.size()!=0&&(res[res.size()-1]==')')\n                &&((str[i]>='0'&&str[i]<='9')||(str[i]>='a'&&str[i]<='z'))){\n                    res+='*';\n            }\n            else if(res.size()!=0&&res[res.size()-1]==')'&&str[i]=='(')\n                res+='*';\n            res+=str[i];\n            sp=false;\n        }\n        else{\n            sp=true;\n        }\n    }\n    return res;\n}\n\nexpress analysis(string str){\n    express res;\n    if(str.size()==0)return res;\n    // ©Ç¤©`FbN\n    bool allNum=true;\n    for(int i = 0; i < str.size(); i++){\n        if(!(str[i]>='0'&&str[i]<='9')){\n            allNum=false;\n            break;\n        }\n    }\n    if(allNum){\n        int num=atoi(str.c_str());\n        if(num!=0)\n            res.push_back(make_pair(num,map<string,int>()));\n        return res;\n    }\n    // e©`FbN\n    if(str.size()==1&&str[0]>='a'&&str[0]<='z'){\n        map<string,int> msi;\n        string tmp;\n        tmp+=(str[0]);\n        msi[tmp]=1;\n        res.push_back(make_pair(1,msi));\n        return res;\n    }\n    if(str[0]=='('){\n        int cnt=0;\n        bool no=false;\n        for(int i = 1; i < str.size()-1; i++){\n            if(str[i]==')')\n                cnt--;\n            else if(str[i]=='(')\n                cnt++;\n            if(cnt<0){\n                no=true;\n                break;\n            }\n        }\n        // ÊðÆé\n        if(!no)\n            return analysis(str.substr(1,str.size()-2));\n    }\n    // ÊÉZqðµÄ¢­\n\n    // vXZqÆ}CiXZqðTõ\n    int cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='+'||str[i]=='-'){\n                express left=analysis(str.substr(0,i));\n                express right=analysis(str.substr(i+1));\n                for(int j = 0; j < left.size(); j++){\n                    // Lªêv·éàÌðTõ\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==left[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+left[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-left[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no)\n                        res.push_back(left[j]);\n                }\n                for(int j = 0; j < right.size(); j++){\n                    // Lªêv·éàÌðTõ\n                    bool no=true;\n                    for(int k = 0; k < res.size(); k++){\n                        if(res[k].second==right[j].second){\n                            int co=0;\n                            if(str[i]=='+')\n                                co=res[k].first+right[j].first;\n                            else if(str[i]=='-')\n                                co=res[k].first-right[j].first;\n                            if(co==0){\n                                res.erase(res.begin()+k);\n                                no=false;\n                                break;\n                            }\n                            else{\n                                res[k].first=co;\n                                no=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(no){\n                        if(str[i]=='-')right[j].first*=-1;\n                        res.push_back(right[j]);\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='*'){\n                express left=analysis(str.substr(0,i));\n                express right=analysis(str.substr(i+1));\n                for(int k = 0; k < left.size(); k++){\n                    for(int j = 0; j < right.size(); j++){\n                        // êÂ¸Âvfð|¯ZµÄ¢­\n                        // W\n                        int co=left[k].first*right[j].first;\n                        map<string,int> literals=left[k].second;\n                        for(map<string,int>::iterator it=right[j].second.begin();it!=right[j].second.end();it++)\n                            literals[it->first]+=it->second;\n                        pair<int,map<string,int> > p=make_pair(co,literals);\n                        bool no=false;\n                        for(int l = 0; l < res.size(); l++){\n                            if(p.second==res[l].second){\n                                int coSum=p.first+res[l].first;\n                                if(coSum==0){\n                                    res.erase(res.begin()+l);\n                                    no=true;\n                                    break;\n                                }\n                                else{\n                                    res[l].first=coSum;\n                                    no=true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!no)\n                            res.push_back(p);\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    cnt=0;\n    for(int i = str.size()-1; i >= 0; i--){\n        if(str[i]==')')\n            cnt++;\n        else if(str[i]=='(')\n            cnt--;\n        else if(cnt==0){\n            if(str[i]=='^'){\n                express left=analysis(str.substr(0,i));\n                express right=analysis(str.substr(i+1));\n                map<string,int> msi;\n                msi[left[0].second.begin()->first]=right[0].first;\n                res.push_back(make_pair(1,msi));\n                return res;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    string teacher;\n    while(getline(cin,teacher)&&teacher!=\".\"){\n        teacher=processSpace(teacher);\n        vector<pair<int,map<string,int> > > t=analysis(teacher);\n        sort(t.begin(),t.end());\n        string student;\n        while(getline(cin,student)&&student!=\".\"){\n            student=processSpace(student);\n            vector<pair<int,map<string,int> > > s=analysis(student);\n            sort(s.begin(),s.end());\n            if(s==t)\n                cout<<\"yes\"<<endl;\n            else\n                cout<<\"no\"<<endl;\n        }\n        cout<<\".\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-5;\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nstring ope = \"+-*^\";\nvector<double> variable(256);\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\ndouble calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        istringstream iss(s);\n        double ret;\n        iss >> ret;\n        return ret;\n    }\n\n    if(n == 1)\n        return variable[s[0]];\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                if(i == 0)\n                    return calculate(t1) + calculate(t2);\n                else if(i == 1)\n                    return calculate(t1) - calculate(t2);\n                else if(i == 2)\n                    return calculate(t1) * calculate(t2);\n                else\n                    return pow(calculate(t1), calculate(t2));\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nstring solve(string s, string t)\n{\n    s = normalize(s);\n    t = normalize(t);\n\n    for(int i=0; i<50; ++i){\n        for(char c='a'; c<='z'; ++c)\n            variable[c] = (long long)xor128() / 10000.0;\n\n        double x = calculate(s);\n        double y = calculate(t);\n\n        if(abs(x-y) > max(abs(x), abs(y)) * EPS)\n            return \"no\";\n    }\n\n    return \"yes\";\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            cout << solve(s, t) << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define int long long\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  if (a.size() != b.size())return false;\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    tmp.p[in[p]-'a']++;\n    //    while(p < in.size() && isalpha(in[p])){\n\n      p++;\n      //    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n\n    //debug\n    /*\n    p=0;\n    in=pre_processing2(tmp);\n    formula me2=fact(in,p);\n    assert(is_same_formula(me,me2));\n    */\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      /*\n      p=0;\n      cmp=pre_processing2(tmp);\n      formula you2=fact(cmp,p);\n      assert(is_same_formula(you,you2));\n      */\n      //      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (tmp.size()&&is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n\n  return ret;\n}\n\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nbool is_operator(char c){\n  string opes = \"+-^*\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nstring preprocessing(string s){\n  stringstream ss(s);\n  string res;\n  ss >> res;\n  while(ss>>s){\n    char a = res[res.size() - 1];\n    char b = s[0];\n    if(is_operator(a) || is_operator(b)) res += s;\n    else res += \"*\" + s;\n  }\n  REP(i, res.size() - 1){\n    if((isalpha(res[i]) && isalpha(res[i + 1])) ||\n       (isdigit(res[i]) && isalpha(res[i + 1])) ||\n       (isalpha(res[i]) && isdigit(res[i + 1]))){\n      res.insert(++i, \"*\");\n    }\n  }\n  return res;\n}\ntypedef map<char,int> Var;\nVar mul(Var x, Var y){\n  FORIT(it, y){\n    x[it->first] += it->second;\n  }\n  return x;\n}\nstruct Result{\n  map<Var, int> value;\n  int p;\n  Result(map<Var, int> v, int p) : \n    value(v), p(p) {}\n};\nResult expression(const string& s, int p);\nResult term(const string& s, int p);\nResult factor(const string& s, int p);\nResult expression(const string& s, int p){\n  Result r = term(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result t = term(s, r.p + 1);\n    FORIT(it, t.value){\n      if(s[r.p] == '+') r.value[it->first] += it->second;\n      if(s[r.p] == '-') r.value[it->first] -= it->second;\n    }\n    r.p = t.p;\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  Result r = factor(s, p);\n  while(s[r.p] == '*'){\n    Result t = factor(s, r.p + 1);\n    map<Var, int> new_val;\n    FORIT(it1, r.value)FORIT(it2, t.value){\n      new_val[mul(it1->first, it2->first)] += it1->second * it2->second;\n    }\n    r.value = new_val;\n    r.p = t.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p){\n  if(s[p] == '('){\n    Result r = expression(s, p + 1);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(isdigit(s[p])){\n    int val = 0;\n    while(isdigit(s[p])){\n      val = val * 10 + s[p++] - '0';\n    }\n    map<Var, int> expr;\n    expr[ Var() ] = val;\n    return Result(expr, p);\n  }else if(isalpha(s[p])){\n    char c = s[p++];\n    if(s[p] == '^'){\n      p++;\n      int val = 0;\n      while(isdigit(s[p])){\n        val = val * 10 + s[p++] - '0';\n      }\n      map<Var, int> expr;\n      Var v; v[c] = val;\n      expr[v] = 1;\n      return Result(expr, p);\n    }else{\n      map<Var, int> expr;\n      Var v; v[c] = 1;\n      expr[v] = 1;\n      return Result(expr, p);\n    }\n  }else {\n    assert(s[p] != '-');\n    assert(false);\n  }\n}\nint main(){\n  string line;\n  while(getline(cin, line) && line != \".\"){\n    line = preprocessing(line);\n    Result r = expression(line, 0);\n    map<Var, int> expr = r.value;\n    while(getline(cin, line) && line != \".\"){\n      line = preprocessing(line);\n      Result r = expression(line, 0);\n      map<Var, int> expr2 = r.value;\n      if(expr == expr2) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n    cout << \".\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstruct Polynomial{\n    map<string, int> terms;\n    Polynomial(int a){\n        terms[\"\"] = a;\n    }\n    Polynomial(string s){\n        terms[s] = 1;\n    }\n    Polynomial(){}\n    static void erase_zero(Polynomial &a){\n        for(auto it=a.terms.begin(); it!=a.terms.end();){\n            if(it->second == 0){\n                it = a.terms.erase(it);\n            }else{\n                it++;\n            }\n        }\n    }\n    Polynomial operator +(const Polynomial &a) const{\n        Polynomial res = *this;\n        for(const auto &p: a.terms){\n            res.terms[p.first] += p.second;\n        }\n        erase_zero(res);\n        return res;\n    }\n    Polynomial operator -(const Polynomial &a) const{\n        Polynomial res = *this;\n        for(const auto &p: a.terms){\n            res.terms[p.first] -= p.second;\n        }\n        erase_zero(res);\n        return res;\n    }\n    Polynomial operator *(const Polynomial &a) const{\n        Polynomial res;\n        for(const auto &p: terms){\n            for(const auto &q: a.terms){\n                string key = p.first + q.first;\n                sort(key.begin(), key.end());\n                res.terms[key] += p.second * q.second;\n            }\n        }\n        erase_zero(res);\n        return res;\n    }\n    bool operator ==(const Polynomial &a) const{\n        return terms == a.terms;\n    }\n};\n\nint getnum(int &p, const string &s){\n    int num = 0;\n    while(p<(int)s.length() and '0'<=s[p] and s[p]<='9'){\n        num *= 10;\n        num += s[p]-'0';\n        p++;\n    }\n    return num;\n}\nPolynomial parse(int &p, const string &s){\n    Polynomial res;\n    Polynomial term(1);\n    int sign = 1;\n    while(1){\n        if(p<(int)s.length() and s[p] == ' '){\n            p++;\n            continue;\n        }\n        if(p>=(int)s.length() or s[p]=='+' or s[p]=='-' or s[p]==')'){\n            if(sign == 1) res = res + term;\n            else res = res - term;\n            term = Polynomial(1);\n            if(p>=(int)s.length() or s[p]==')'){\n                p++;\n                return res;\n            }\n            if(s[p] == '+') sign = 1;\n            else sign = -1;\n            p++;\n            continue;\n        }\n        if('0'<=s[p] and s[p]<='9'){\n            term = term * Polynomial(getnum(p, s));\n            continue;\n        }\n        if('a'<=s[p] and s[p]<='z'){\n            char var = s[p];\n            p++;\n            int num = 1;\n            while(p<(int)s.length() and s[p]==' '){\n                p++;\n            }\n            if(p<(int)s.length() and s[p]=='^'){\n                p++;\n                while(s[p] == ' ') p++;\n                num = getnum(p, s);\n            }\n            term = term * Polynomial(string(num, var));\n            continue;\n        }\n        if(s[p] == '('){\n            p++;\n            term = term * parse(p, s);\n            continue;\n        }\n    }\n}\n\nint main(){\n    while(1){\n        vector<string> s;\n        string t;\n        while(getline(cin, t), t!=\".\"){\n            s.push_back(t);\n        }\n        if(s.empty()) break;\n\n        vector<Polynomial> p;\n        for(auto ss: s){\n            int i=0;\n            p.push_back(parse(i, ss));\n        }\n        for(int i=1; i<(int)p.size(); i++){\n            if(p[i] == p[0]){\n                cout << \"yes\" << endl;\n            }else{\n                cout << \"no\" << endl;\n            }\n        }\n        cout << \".\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar in[120];\nlong double var[30];\nchar str[210];\nint cur;\nlong double expr();\nlong double term(){\n\tif('0'<=str[cur]&&str[cur]<='9'){\n\t\tlong double ret=0.0L;\n\t\twhile('0'<=str[cur]&&str[cur]<='9'){\n\t\t\tret*=10.0L;ret+=(long double)(str[cur++]-'0');\n\t\t}\n\t\treturn ret;\n\t}\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tlong double ret=expr();\n\t\tcur++;\n\t\treturn ret;\n\t}\n\tif('a'<=str[cur]&&str[cur]<='z'){\n\t\tlong double ret=var[str[cur]-'a'];\n\t\tcur++;\n\t\tif(str[cur]=='^'){\n\t\t\tcur++;\n\t\t\tint po=str[cur]-'0';cur++;\n\t\t\tlong double val=1.0L;\n\t\t\tfor(int i=0;i<po;i++)val*=ret;\n\t\t\tret=val;\n\t\t}\n\t\treturn ret;\n\t}\n}\nlong double fact(){\n\tlong double ret=term();\n\twhile(str[cur]=='*'||(str[cur]!='+'&&str[cur]!='-'&&str[cur]&&str[cur]!=')')){\n\t\tif(str[cur]=='*')cur++;\n\t\tlong double tmp=term();\n\t//\tprintf(\"%Lf * %Lf = %Lf\\n\",ret,tmp,ret*tmp);\n\t\tret*=tmp;\n\t}\n//\tprintf(\"%d %Lf\\n\",cur,ret);\n\treturn ret;\n}\nlong double expr(){\n\tlong double ret=fact();\n\twhile(str[cur]=='+'||str[cur]=='-'){\n\t\tcur++;\n\t\tchar ch=str[cur-1];\n\t\tlong double tmp=fact();\n\t\tif(ch=='+')ret+=tmp;\n\t\telse ret-=tmp;\n\t}\n\treturn ret;\n}\nlong double ABS(long double a){return max(a,-a);}\nint main(){\n\twhile(1){\n\t\tgets(in);\n\t\tif(in[0]=='.')break;\n\t\tint at=0;\n\t\tfor(int i=0;in[i];i++){\n\t\t\tif(i&&'0'<=str[at-1]&&str[at-1]<='9'&&'0'<=in[i+1]&&in[i+1]<='9'){\n\t\t\t\tstr[at++]='*';\n\t\t\t}\n\t\t\tif(in[i]!=' ')str[at++]=in[i];\n\t\t}\n\t\twhile(1){\n\t\t\tgets(in);\n\t\t\tif(in[0]=='.')break;\n\t\t\tstr[at]='-';\n\t\t\tstr[at+1]='(';\n\t\t\tint ind=at+2;\n\t\t\tfor(int i=0;in[i];i++){\n\t\t\t\tif(in[i]==' '){\n\t\t\t\t\tif(i&&'0'<=str[ind-1]&&str[ind-1]<='9'&&'0'<=in[i+1]&&in[i+1]<='9'){\n\t\t\t\t\t\tstr[ind++]='*';\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstr[ind++]=in[i];\n\t\t\t}\n\t\t\tstr[ind++]=')';\n\t\t\tstr[ind]=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int i=0;i<500;i++){\n\t\t\t\tfor(int j=0;j<26;j++)var[j]=(long double)(rand()%1000)/200;\n\t\t\t\tcur=0;\n\t\t\t\tlong double res=expr();\n\t\t\t\tif(ABS(res)>0.5L){\n\t\t\t\t//\tprintf(\"%s %Lf %Lf\\n\",str,var[23],res);\n\t\t\t\t\tok=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t}\n\t\tprintf(\".\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nvector<vector<ll>> rnd(10, vector<ll>(26));\nint p, var;\n\nll sum(string& s);\n\nll num(string& s)\n{\n\tll res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nll unit(string& s)\n{\n\tll res;\n\twhile (s[p] == ' ') p++;\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\tres = sum(s);\n\t\tp++;\n\t}\n\telse if (isdigit(s[p])) res = num(s);\n\telse if (islower(s[p]))\n\t{\n\t\tres = rnd[var][s[p] - 'a'];\n\t\tp++;\n\t}\n\telse assert(false);\n\treturn res;\n}\n\nll pow(string& s)\n{\n\tll lhs = unit(s);\n\twhile (s[p] == '^')\n\t{\n\t\tp++;\n\t\twhile (s[p] == ' ') p++;\n\t\tll rhs = pow(s);\n\t\tll tmp = 1;\n\t\tREP(i, rhs)\n\t\t{\n\t\t\ttmp *= lhs;\n\t\t}\n\t\tlhs = tmp;\n\t}\n\treturn lhs;\n}\n\nll mul(string& s)\n{\n\tll lhs = pow(s);\n\twhile (s[p] == '*' || isdigit(s[p])||islower(s[p]))\n\t{\n\t\twhile (s[p] == '*') p++;\n\t\tll rhs;\n\t\trhs = pow(s);\n\t\tlhs *= rhs;\n\t}\n\treturn lhs;\n}\n\nll sum(string& s)\n{\n\tll lhs = mul(s);\n\twhile (s[p] == '+' || s[p] == '-')\n\t{\n\t\tif (s[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = mul(s);\n\t\t\tlhs += rhs;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = mul(s);\n\t\t\tlhs -= rhs;\n\t\t}\n\t}\n\treturn lhs;\n}\n\nll parse(string& s)\n{\n\tp = 0;\n\treturn sum(s);\n}\n\nbool isop(char c)\n{\n\treturn !(c != '+'&&c != '-'&&c != '^'&&c != '*');\n}\n\nstring make(string s)\n{\n\tstring res;\n\tREP(i, s.size())\n\t{\n\t\tif(s[i]==' ')\n\t\t{\n\t\t\tchar c = res.back();\n\t\t\twhile (s[i] == ' ') i++;\n\t\t\tchar d = s[i];\n\t\t\tif (isop(c) || isop(d)) res.push_back(d);\n\t\t\telse\n\t\t\t{\n\t\t\t\tres.push_back('*');\n\t\t\t\tres.push_back(d);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres.push_back(s[i]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstring s, t;\n\tREP(i, 10)REP(j, 26) rnd[i][j] = rand() % 20;\n\twhile (getline(cin, s), s != \".\")\n\t{\n\t\tstring s_ = make(s);\n\t\twhile (getline(cin, t), t != \".\")\n\t\t{\n\t\t\tstring t_ = make(t);\n\t\t\tbool f = true;\n\t\t\tfor (var = 0; var < 10 && f; var++)\n\t\t\t{\n\t\t\t\tll lhs = parse(s_);\n\t\t\t\tll rhs = parse(t_);\n\t\t\t\tif (lhs != rhs) f = false;\n\t\t\t}\n\t\t\tputs(f ? \"yes\" : \"no\");\n\t\t}\n\t\tputs(\".\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nstring normalize(string s)\n{\n    // 連続するスペースを1つのスペースに変換、先頭と末尾のスペースを削除\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if(s[i] != ' ' || s[i-1] != ' ')\n            t += s[i];\n    }\n    if(t[0] == ' ')\n        t = t.substr(1);\n    if(t[t.size()-1] == ' ')\n        t = t.substr(0, t.size()-1);\n    s = t;\n\n    // 必要に応じて * を挿入する\n    n = s.size();\n    t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += '*';\n        t += s[i];\n    }\n    s = t;\n\n    // スペースを * に変換、もしくは削除する\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(s[i-1] != '(' && s[i+1] != ')' && ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nmap<vector<int>, long long> calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        map<vector<int>, long long> ret;\n        long long tmp = 0;\n        for(int i=0; i<n; ++i){\n            tmp *= 10;\n            tmp += s[i] - '0';\n        }\n        if(tmp != 0)\n            ret[vector<int>(26, 0)] = tmp;\n        return ret;\n    }\n\n    if(n == 1){\n        map<vector<int>, long long> ret;\n        vector<int> tmp(26, 0);\n        tmp[s[0]-'a'] = 1;\n        ret[tmp] = 1;\n        return ret;\n    }\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                map<vector<int>, long long> a = calculate(t1);\n                map<vector<int>, long long> b = calculate(t2);\n\n                map<vector<int>, long long> ret;\n                if(i == 0){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it)\n                        ret[it->first] += it->second;\n                }else if(i == 1){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it)\n                        ret[it->first] -= it->second;\n                }else if(i == 2){\n                    for(map<vector<int>, long long>::iterator it1=a.begin(); it1!=a.end(); ++it1){\n                        for(map<vector<int>, long long>::iterator it2=b.begin(); it2!=b.end(); ++it2){\n                            vector<int> tmp(26);\n                            for(int k=0; k<26; ++k)\n                                tmp[k] = it1->first[k] + it2->first[k];\n                            ret[tmp] += it1->second * it2->second;\n                        }\n                    }\n                }else{\n                    vector<int> tmp(26);\n                    for(int k=0; k<26; ++k)\n                        tmp[k] = a.begin()->first[k] * b.begin()->second;\n                    ret[tmp] = 1;\n                }\n\n                for(map<vector<int>, long long>::iterator it=ret.begin(); it!=ret.end(); ){\n                    if(it->second == 0)\n                        it = ret.erase(it);\n                    else\n                        ++ it;\n                }\n\n                return ret;\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        s = normalize(s);\n        map<vector<int>, long long> a = calculate(s);\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            t = normalize(t);\n            map<vector<int>, long long> b = calculate(t);\n            if(a == b)\n                cout << \"yes\" << endl;\n            else\n                cout << \"no\" << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstdlib>\n\nusing namespace std;\n\nchar s[1234567];\nchar *p;\n\ntypedef map<map<char,int>,int> E;\n\nE exp();\n\nE mul(){\n  while(*p==' '){\n    p++;\n  }\n  if(isdigit(*p)){\n    E e;\n    e[map<char,int>()]=strtol(p,&p,10);\n    return e;\n  }else if(*p=='('){\n    p++;\n    auto r=exp();\n    while(*p==' '){\n      p++;\n    }\n    p++;\n    return r;\n  }else{\n    char c=*p;\n    p++;\n    while(*p==' '){\n      p++;\n    }\n    int pw;\n    if(*p!='^'){\n      pw=1;\n    }else{\n      p++;\n      pw=strtol(p,&p,10);\n    }\n    map<char,int> v;\n    v[c]=pw;\n    E e;\n    e[v]=1;\n    return e;\n  }\n}\n\nE term(){\n  auto l=mul();\n  for(;;){\n    while(*p==' '){\n      p++;\n    }\n    if(!isalnum(*p)&&*p!='(')break;\n    auto lo=l;\n    l.clear();\n    auto r=mul();\n    for(auto &e:lo){\n      for(auto &f:r){\n\tmap<char,int> v;\n\tfor(auto &ee:e.first){\n\t  v[ee.first]+=ee.second;\n\t}\n\tfor(auto &ff:f.first){\n\t  v[ff.first]+=ff.second;\n\t}\n\tl[v]+=e.second*f.second;\n      }\n    }\n  }\n  return l;\n}\n\nE exp(){\n  auto l=term();\n  for(;;){\n    while(*p==' '){\n      p++;\n    }\n    int f;\n    if(*p=='+'){\n      f=1;\n    }else if(*p=='-'){\n      f=-1;\n    }else{\n      break;\n    }\n    auto r=term();\n    for(auto &e:r){\n      l[e.first]+=f*e.second;\n    }\n  }\n  return l;\n}\n\nE startexp(){\n  p=s;\n  auto r=exp();\n  for(auto it=r.begin();it!=r.end();){\n    if(it->second==0){\n      it=r.erase(it);\n    }else{\n      it++;\n    }\n  }\n  return r;\n}\n\nint main(){\n  while(cin.getline(s,sizeof s),s[0]!='.'){\n    auto ans=startexp();\n    while(cin.getline(s,sizeof s),s[0]!='.'){\n      auto c=startexp();\n      cout<<((ans==c)?\"yes\":\"no\")<<endl;\n    }\n    cout<<\".\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\n#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nbool is_same_formula(formula a,formula b){\n  erase_duplicate(a);\n  erase_duplicate(b);\n  if (a.size() != b.size())return false;\n  if (a.size() == 1 && b.size() == 1){\n    if (a[0].c == 0 && b[0].c == 0)return true;\n  }\n\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n    \n  }\n  if (b.size() == 0)return true;\n  else return false;\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    tmp.p[in[p]-'a']++;\n      p++;\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n/*\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n  return ret;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n      //cout << \"formula :\"<<cmp<<endl;output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\n#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element &a,Element &b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  //if (ret.size() == 0)ret.pb(ori);\n}\n\nbool is_same_formula(formula &a,formula &b){\n  erase_duplicate(a);\n  erase_duplicate(b);\n  if (a.size() != b.size())return false;\n  if (a.size() == 1 && b.size() == 1){\n    //if (a[0].c == 0 && b[0].c == 0)return true;\n  }\n\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n    \n  }\n  if (b.size() == 0)return true;\n  else return false;\n}\n\nformula mult(formula &a,formula &b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula &a,formula &b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula &a,formula &b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    tmp.p[in[p]-'a']++;\n      p++;\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n/*\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n  return ret;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< char,int > P;\ntypedef vector< P > vec;\ntypedef pair< int, vec > PP;\ntypedef vector< PP > mat;\nstring s;\nint p,len;\n\nmat add(mat a,mat b){\n  map< vec , int > mp;\n  \n  for(int i=0;i< (int)a.size();i++){\n    mp[ a[i].second ]+= a[i].first;\n  }\n\n  for(int i=0;i<(int)b.size();i++){\n    mp[ b[i].second ]+= b[i].first;\n  }\n\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  \n  sort(res.begin(),res.end());\n  \n  return res;\n}\n\nPP mul(PP a,PP b){\n  int fi=a.first*b.first;\n  vec &va=a.second;\n  vec &vb=b.second;\n  map<char,int> mp;\n  for(int i=0;i<(int)va.size();i++){\n    P p=va[i];\n    mp[ p.first ]+=p.second;\n  }\n  for(int j=0;j<(int)vb.size();j++){\n    P p=vb[j];\n    mp[ p.first ]+=p.second;\n  }\n\n  \n  vec se;\n\n  if(fi==0){\n    return PP(fi,se);\n  }\n  \n  map<char,int> :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    se.push_back( *it );\n  }\n  return PP(fi,se);\n}\n\nmat mul(mat a,mat b){\n  map< vec , int > mp;\n  for(int i=0;i<(int)a.size();i++){\n    PP as=a[i];\n    for(int j=0;j<(int)b.size();j++){\n      PP bs=b[j];\n\n      PP c=mul(as,bs);\n      mp[  c.second ] += c.first;\n    }\n  }\n  \n  mat res;\n  map< vec , int > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    if(it->second==0)continue;\n    res.push_back( PP( it->second , it->first) );\n  }\n  return res;  \n}\n\nmat target;\nmat solve();\n\nmat getNum(){\n  while(s[p]==' ')p++;\n\n  if('0'<=s[p]&&s[p]<='9'){\n    int res=0;\n    while('0'<=s[p]&&s[p]<='9'){\n      res=res*10+(s[p]-'0');\n      p++;\n    }\n    mat re;\n    vec r;\n    if(res>0)re.push_back(PP( res , r ));\n    return re;\n  }\n\n  if('('==s[p]){\n    p++;\n    mat res=solve();\n    p++;\n    return res;\n  }\n\n  char ch=s[p++];\n  while(s[p]==' ')p++;\n  int num=1;\n  if(s[p]=='^'){\n    mat tmp=getNum();\n    num=tmp[0].first;\n    assert(num>0);\n  }\n  mat res;\n  vec r;\n  r.push_back(P(ch,num));\n  res.push_back(PP(1,r));\n  return res;\n}\n\nmat solve(){\n  while(s[p]==' ')p++;\n\n  stack < mat > st;\n  st.push( getNum() );\n\n  while(1){\n    while(s[p]==' ')p++;\n\n    if(p>=len){\n      break;\n    }else if(s[p]=='+'){\n      p++;\n      mat num=getNum();\n      st.push(num);\n    }else if(s[p]=='-'){\n      p++;\n      mat num=getNum();\n      for(int i=0;i<(int)num.size();i++)\n        num[i].first*=-1;\n      st.push(num);\n      \n    }else if(s[p]==')'){\n      break;\n    }else{\n      mat num=getNum();\n      mat A=st.top();\n      st.pop();\n      st.push( mul(A,num) );\n      \n    }\n  }\n  mat res=st.top();\n  st.pop();\n  while(!st.empty()){\n    res=add(res,st.top());\n    st.pop();\n  }\n\n  for(int i=0;i<(int)res.size();i++){\n    sort(res[i].second.begin(),res[i].second.end());\n  }\n  sort(res.begin(),res.end());\n  return res;\n}\n\nint main(){\n  while(1){\n    getline(cin,s);\n    if(s==\".\")break;\n    p=0;len=s.size();\n    target=solve();\n    \n    while(1){\n      getline(cin,s);\n      if(s==\".\")break;\n      p=0;len=s.size();\n      mat tmp=solve();\n      if(target==tmp)cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    cout<<'.'<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\nusing namespace std;\nstring s,t;\nint p;\nmap<char,int>m;\nvoid convert(string &s){\n    r(i,s.size()){\n        if(i&&s[i]==' '){\n            if(s[i-1]==')'&&s[i+1]=='(')s[i]='*';\n            else if(isalpha(s[i-1])&&isalpha(s[i+1]))s[i]=='*';\n            else if(s[i-1]==')'&&isalpha(s[i+1]))s[i]='*';\n            else if(isalpha(s[i-1])&&s[i+1]=='(')s[i]=='*';\n            else if(s[i-1]==')'&&isdigit(s[i+1]))s[i]='*';\n            else if(isdigit(s[i-1])&&s[i+1]=='(')s[i]=='*';\n            else if(isdigit(s[i-1])&&isalpha(s[i+1]))s[i]=='*';\n            else if(isalpha(s[i-1])&&isdigit(s[i+1]))s[i]=='*';\n            else s.erase(s.begin()+i--);\n        }\n    }\n}\nint Sbnf1();\nint get_S(){\n    int res=0;\n    if(s[p]=='(')p++,res=Sbnf1(),p++;\n    else res=m[s[p++]];\n    return res;\n}\nint Sbnf3(){\n    int res=get_S();\n    while(s[p]=='^'){\n        p++;\n        int ret=get_S(),kit=res;\n        r(i,ret){\n            res*=kit;\n            res=res%mod;\n        }\n    }\n    return res;\n}\nint Sbnf2(){\n    int res=Sbnf3();\n    while(s[p]=='*'){\n        p++;\n        res*=Sbnf3();\n        res=res%mod;\n    }\n    return res;\n}\nint Sbnf1(){\n    int res=Sbnf2();\n    while(s[p]=='+'||s[p]=='-'){\n        int pp=p++;\n        if(s[pp]=='+')res+=Sbnf2();\n        if(s[pp]=='-')res-=Sbnf2();\n        if(res<0)res=(res+mod)%mod;\n        else res=res%mod;\n    }\n    return res;\n}\nint Tbnf1();\nint get_T(){\n    int res=0;\n    if(t[p]=='(')p++,res=Sbnf1(),p++;\n    else res=m[t[p++]];\n    return res;\n}\nint Tbnf3(){\n    int res=get_T();\n    while(t[p]=='^'){\n        p++;\n        int ret=get_T(),kit=res;\n        r(i,ret){\n            res*=kit;\n            res=res%mod;\n        }\n    }\n    return res;\n}\nint Tbnf2(){\n    int res=Tbnf3();\n    while(t[p]=='*'){\n        p++;\n        res*=Tbnf3();\n        res=res%mod;\n    }\n    return res;\n}\nint Tbnf1(){\n    int res=Tbnf2();\n    while(t[p]=='+'||t[p]=='-'){\n        int pp=p++;\n        if(t[pp]=='+')res+=Tbnf2();\n        if(t[pp]=='-')res-=Tbnf2();\n        if(res<0)res=(res+mod)%mod;\n        else res=res%mod;\n    }\n    return res;\n}\nmain(){\n    while(getline(cin,t)){\n        if(t==\".\")break;\n        convert(t);\n        while(getline(cin,s)){\n            if(s==\".\"){\n                cout<<'.'<<endl;\n                break;\n            }\n            int flag = 0;\n            convert(s);\n            r(i,100){\n                m.clear();\n                r(j,26)m[j+'a']=rand();\n                p=0;\n                int y=Tbnf1();\n                p=0;\n                int x=Sbnf1();\n                if(y!=x)flag++;\n            }\n            cout<<(flag?\"no\":\"yes\")<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nmap<vector<int>, long long> calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        map<vector<int>, long long> ret;\n        long long tmp = 0;\n        for(int i=0; i<n; ++i){\n            tmp *= 10;\n            tmp += s[i] - '0';\n        }\n        ret[vector<int>(26, 0)] = tmp;\n        return ret;\n    }\n\n    if(n == 1){\n        map<vector<int>, long long> ret;\n        vector<int> tmp(26, 0);\n        tmp[s[0]-'a'] = 1;\n        ret[tmp] = 1;\n        return ret;\n    }\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                map<vector<int>, long long> a = calculate(t1);\n                map<vector<int>, long long> b = calculate(t2);\n\n                map<vector<int>, long long> ret;\n                if(i == 0){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it)\n                        ret[it->first] += it->second;\n                }else if(i == 1){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it)\n                        ret[it->first] -= it->second;\n                }else if(i == 2){\n                    for(map<vector<int>, long long>::iterator it1=a.begin(); it1!=a.end(); ++it1){\n                        for(map<vector<int>, long long>::iterator it2=b.begin(); it2!=b.end(); ++it2){\n                            vector<int> tmp(26);\n                            for(int k=0; k<26; ++k)\n                                tmp[k] = it1->first[k] + it2->first[k];\n                            ret[tmp] += it1->second * it2->second;\n                        }\n                    }\n                }else{\n                    vector<int> tmp(26);\n                    for(int k=0; k<26; ++k)\n                        tmp[k] = a.begin()->first[k] * b.begin()->second;\n                    ret[tmp] = 1;\n                }\n                return ret;\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nstring solve(string s, string t)\n{\n    s = normalize(s);\n    t = normalize(t);\n\n    map<vector<int>, long long> a = calculate(s);\n    map<vector<int>, long long> b = calculate(t);\n\n    if(a == b)\n        return \"yes\";\n    else\n        return \"no\";\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            cout << solve(s, t) << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef __int128  Val;\n\nconst Val EPS=1e-5;\nvector<Val > var;\n\n\nvoid skip(string &s,int &p){\n  while(p<s.size() && s[p]==' ') p++;\n}\n\nVal formula(string &s,int &p);\n\nVal num(string &s,int &p){\n  Val res=0.;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10.;\n    res+=s[p]-'0';\n    p++;\n  }\n  skip(s,p);\n  return res;\n}\n\nVal var_val(string &s,int &p){\n  Val res=var[s[p]-'a'];\n  p++;\n  skip(s,p);\n  return res;\n}\n\nVal get_val(string &s,int &p){\n  if(s[p]=='('){\n    p++;\n    skip(s,p);\n    Val  res=formula(s,p);\n    assert(s[p]==')');\n    p++;\n    skip(s,p);\n    return res;\n  }\n  if(isalpha(s[p])){\n    return var_val(s,p);\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  assert(0);\n}\n\nVal term2(string &s,int &p){\n  Val res=get_val(s,p);\n  if(p<s.size() && s[p]=='^'){\n    p++;\n    skip(s,p);\n    return pow(res,term2(s,p));\n  }\n  return res;\n}\n\nVal term1(string& s,int &p){\n  Val res=term2(s,p);\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    skip(s,p);\n    assert(isalpha(s[p])||isdigit(s[p])||s[p]=='(');\n    Val val=term2(s,p);\n    res*=val;\n  }\n  return res;\n}\n\nVal formula(string& s,int &p){\n  Val res=term1(s,p);\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    assert(op=='+' || op=='-');\n    p++;\n    skip(s,p);\n    Val val=term1(s,p);\n\n    if(op=='+') res+=val;\n    else res-=val;\n  }\n  return res;\n}\n\nvoid solve(vector<string> &state){\n  random_device rnd;\n  var.resize('z'-'a'+1);\n  for(int i=1;i<state.size();i++){\n    bool isok=true;\n    const int TIME=1000;\n    for(int j=0;j<TIME;j++){\n      int p=0;\n      for(int i=0;i<='z'-'a';i++){\n\tvar[i]=rnd()%4;\n      }\n      Val cor=formula(state[0],p);\n      p=0;\n      Val ans=formula(state[i],p);\n      isok&=(cor==ans);\n    }\n    cout<<(isok ? \"yes\" : \"no\")<<endl;\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    vector<string> state;\n    while(true){\n      string buf;\n      getline(cin,buf);\n      if(buf==\".\") break;\n      state.push_back(buf);\n    }\n    if(state.size()==0) break;\n    solve(state);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //        cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n      //      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n/*\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n*/\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n\n  return ret;\n}\n\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nstring ope = \"+-*^\";\nvector<double> variable(256);\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\ndouble calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        istringstream iss(s);\n        double ret;\n        iss >> ret;\n        return ret;\n    }\n\n    if(n == 1)\n        return variable[s[0]];\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=0; j<n; ++j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                if(i == 0)\n                    return calculate(t1) + calculate(t2);\n                else if(i == 1)\n                    return calculate(t1) - calculate(t2);\n                else if(i == 2)\n                    return calculate(t1) * calculate(t2);\n                else\n                    return pow(calculate(t1), calculate(t2));\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nstring solve(string s, string t)\n{\n    s = normalize(s);\n    t = normalize(t);\n\n    for(int i=0; i<30; ++i){\n        for(char c='a'; c<='z'; ++c)\n            variable[c] = (xor128() - ULLONG_MAX / 2) / 10000.0;\n\n        double x = calculate(s);\n        double y = calculate(t);\n\n        if(abs(x-y) > max(abs(x), abs(y)) * EPS)\n            return \"no\";\n    }\n\n    return \"yes\";\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            cout << solve(s, t) << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint MOD;\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nlong long power(long long a, long long b)\n{\n    long long ret = 1;\n    long long tmp = a;\n    while(b > 0){\n        if(b & 1){\n            ret *= tmp;\n            ret %= MOD;\n        }\n        tmp *= tmp;\n        tmp %= MOD;\n        b >>= 1;\n    }\n    return ret;\n}\n\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nlong long calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        long long ret = 0;\n        for(int i=0; i<n; ++i){\n            ret *= 10;\n            ret += s[i] - '0';\n        }\n        return ret;\n    }\n\n    if(n == 1)\n        return variable[s[0]];\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                if(i == 0)\n                    return (calculate(t1) + calculate(t2)) % MOD;\n                else if(i == 1)\n                    return (calculate(t1) - calculate(t2) + MOD) % MOD;\n                else if(i == 2)\n                    return (calculate(t1) * calculate(t2)) % MOD;\n                else\n                    return power(calculate(t1), calculate(t2));\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nstring solve(string s, string t)\n{\n    s = normalize(s);\n    t = normalize(t);\n\n    for(int i=0; i<50; ++i){\n        MOD = xor128() % 10 + 1;\n        for(char c='a'; c<='z'; ++c)\n            variable[c] = xor128() % MOD;\n\n        long long x = calculate(s);\n        long long y = calculate(t);\n\n        if(x != y)\n            return \"no\";\n    }\n\n    return \"yes\";\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            cout << solve(s, t) << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define int long long\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    tmp.p[in[p]-'a']++;\n    //    while(p < in.size() && isalpha(in[p])){\n\n      p++;\n      //    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n\n    //debug\n    /*\n    p=0;\n    in=pre_processing2(tmp);\n    formula me2=fact(in,p);\n    assert(is_same_formula(me,me2));\n    */\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      /*\n      p=0;\n      cmp=pre_processing2(tmp);\n      formula you2=fact(cmp,p);\n      assert(is_same_formula(you,you2));\n      */\n      //      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (tmp.size()&&is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n\n  return ret;\n}\n\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n\n    //debug\n    p=0;\n    in=pre_processing2(tmp);\n    formula me2=fact(in,p);\n    assert(is_same_formula(me,me2));\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      p=0;\n      cmp=pre_processing2(tmp);\n      formula you2=fact(cmp,p);\n      assert(is_same_formula(you,you2));\n\n      //      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (tmp.size()&&is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n\n  return ret;\n}\n\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[27];\n  Element(){\n    c=0;rep(i,27)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,27)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  if (a.size() != b.size())return false;\n  rep(i,a.size()){\n    bool canfind=false;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,27){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,27){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p]=='+'||in[p]=='-')break;\n    else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }\n    else if (in[p] ==')')break;\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;\n    //    output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n      //      cout << \"formula :\"<<cmp<<endl;\n      //      output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\t//26\ntypedef map<vi,int> mvi;\nstring s;\nvi operator+(const vi& x,const vi& y){\n\tvi z;\n\trep(i,26) z.pb(x[i]+y[i]);\n\treturn z;\n}\nmvi pro(mvi a,mvi b){\n\tmvi c;\n\tfor(auto p:a) for(auto q:b){\n\t\tc[p.fs+q.fs]+=p.sc*q.sc;\n\t}\n\treturn c;\n}\nmvi expr(int& it);\nint dig(int &it){\n\tint x=0;\n\twhile(isdigit(s[it])){\n\t\tx*=10;\n\t\tx+=s[it]-'0';\n\t\tit++;\n\t}\n\treturn x;\n}\nmvi fac(int &it){\n\tif(s[it]==' ') it++;\n\tif(s[it]=='('){\n\t\tit++;\n\t\tmvi ret=expr(it);\n\t\tassert(s[it]==')');\n\t\tit++;\n\t\treturn ret;\n\t}else if(islower(s[it])){\n\t\tint c=s[it]-'a';\n\t\tint o=1;\n\t\tif(s[it+1]=='^'){\n\t\t\to=s[it+2]-'0';\n\t\t\tit+=2;\n\t\t}\n\t\tit++;\n\t\tmvi ret;\n\t\tvi a(26,0);\n\t\ta[c]=o;\n\t\tret[a]=1;\n\t\treturn ret;\n\t}else{\n\t\tassert(isdigit(s[it]));\n\t\tint x=dig(it);\n\t\tmvi ret;\n\t\tvi a(26,0);\n\t\tret[a]=x;\n\t\treturn ret;\n\t}\n}\nmvi term(int &it){\n\tmvi ret=fac(it);\n\twhile(it<s.size()&&s[it]!='+'&&s[it]!='-'&&s[it]!=')'){\n\t\tmvi a=fac(it);\n\t\tret=pro(ret,a);\n\t}\n\treturn ret;\n}\nmvi expr(int& it){\n\tmvi ret=term(it);\n\twhile(s[it]=='+'||s[it]=='-'){\n\t\tif(s[it]=='+'){\n\t\t\tit++;\n\t\t\tmvi a=term(it);\n\t\t\tfor(auto p:a) ret[p.fs]+=p.sc;\n\t\t}else{\n\t\t\tit++;\n\t\t\tmvi a=term(it);\n\t\t\tfor(auto p:a) ret[p.fs]-=p.sc;\n\t\t}\n\t}\n\treturn ret;\n}\nstring igs(string s){\n\tint i=0;\n\twhile(i<s.size()){\n\t\tif(s[i]==' ' && (i==0||!isdigit(s[i-1])||i+1==s.size()||!isdigit(s[i+1])) ) s.erase(i,1);\n\t\telse i++;\n\t}\n\treturn s;\n}\nbool isame(mvi a,mvi b){\n\tmvi x,y;\n\tfor(auto p:a) if(p.sc!=0) x[p.fs]=p.sc;\n\tfor(auto p:b) if(p.sc!=0) y[p.fs]=p.sc;\n\treturn x==y;\n}\nint main(){\n\twhile(true){\n\t\tgetline(cin,s);\n\t\tif(s[0]=='.') break;\n\t\ts=igs(s);\n\t\tint it=0;\n\t\tmap<vi,int> ms=expr(it);\n\t\twhile(true){\n\t\t\tgetline(cin,s);\n\t\t\tif(s[0]=='.'){\n\t\t\t\tputs(\".\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts=igs(s);\n\t\t\tit=0;\n\t\t\tif(isame(expr(it),ms)) puts(\"yes\");\n\t\t\telse puts(\"no\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\nusing namespace std;\nstring s,t;\nint p;\nmap<char,int>m;\nvoid convert(string &s){\n    r(i,s.size()){\n        if(i&&s[i]==' '){\n            if(s[i-1]==')'&&s[i+1]=='(')s[i]='*';\n            else if(isalpha(s[i-1])&&isalpha(s[i+1]))s[i]='*';\n            else if(s[i-1]==')'&&isalpha(s[i+1]))s[i]='*';\n            else if(isalpha(s[i-1])&&s[i+1]=='(')s[i]='*';\n            else if(s[i-1]==')'&&isdigit(s[i+1]))s[i]='*';\n            else if(isdigit(s[i-1])&&s[i+1]=='(')s[i]='*';\n            else if(isdigit(s[i-1])&&isalpha(s[i+1]))s[i]='*';\n            else if(isalpha(s[i-1])&&isdigit(s[i+1]))s[i]='*';\n            else if(isdigit(s[i-1])&&isdigit(s[i+1]))s[i]='*';\n            else s.erase(s.begin()+i--);\n        }\n        if(isdigit(s[i])&&isalpha(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(isalpha(s[i])&&isalpha(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(isalpha(s[i])&&isdigit(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(s[i]==')'&&isalpha(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(s[i]==')'&&isdigit(s[i+1]))s.insert(s.begin()+i+1,'*');\n        if(s[i+1]=='('&&isalpha(s[i]))s.insert(s.begin()+i+1,'*');\n        if(s[i+1]=='('&&isdigit(s[i]))s.insert(s.begin()+i+1,'*');\n        if(s[i+1]=='('&&s[i]==')')s.insert(s.begin()+i+1,'*');\n    }\n}\nint Sbnf1(string &s);\nint get_S(string &s){\n    int res=0;\n    if(s[p]=='(')p++,res=Sbnf1(s),p++;\n    else if(isdigit(s[p])){\n        while(isdigit(s[p])){\n            res=res*10+(s[p++]-'0');\n        }\n    }\n    else res=m[s[p++]];\n    return res%mod;\n}\nint Sbnf3(string &s){\n    int res=get_S(s);\n    while(s[p]=='^'){\n        p++;\n        int ret=get_S(s),kit=res;\n        r(i,ret-1){\n            res*=kit;\n            res=res%mod;\n        }\n    }\n    return res%mod;\n}\nint Sbnf2(string &s){\n    int res=Sbnf3(s);\n    while(s[p]=='*'){\n        p++;\n        res*=Sbnf3(s);\n        res=res%mod;\n    }\n    return res%mod;\n}\nint Sbnf1(string &s){\n    int res=Sbnf2(s);\n    while(s[p]=='+'||s[p]=='-'){\n        int pp=p++;\n        if(s[pp]=='+')res+=Sbnf2(s);\n        if(s[pp]=='-')res-=Sbnf2(s);\n        while(res<0)res+=mod;\n        res=res%mod;\n    }\n    return res%mod;\n}\nmain(){\n    while(getline(cin,t)){\n        if(t==\".\")break;\n        convert(t);\n        while(getline(cin,s)){\n            if(s==\".\"){\n                cout<<'.'<<endl;\n                break;\n            }\n            int flag = 0;\n            convert(s);\n            r(i,7){\n                r(j,26)m[j+'a']=rand()%mod;\n                p=0;\n                int y=Sbnf1(t)%mod;\n                p=0;\n                int x=Sbnf1(s)%mod;\n                if(y!=x)flag++;\n            }\n            cout<<(flag?\"no\":\"yes\")<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <sstream>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\n/*\n  factor = {(expr) | var | num} (^ num)\n  term = factor (term)\n  expr = term (+- expr)\n */\n\nstring in;\nint pos;\n\ntypedef map<string, long long> El;\nvoid go(){\n  while(pos < SZ(in) && in[pos]==' ') ++pos;\n}\nEl expr();\nEl factor(){\n  go();\n  El ret;\n  if(isdigit(in[pos])){\n    ll a = 0;\n    while(pos<SZ(in) && isdigit(in[pos]))\n      a = a*10 + in[pos++] - '0';\n    ret[\"\"] = a;\n  }else if(isalpha(in[pos])){\n    string a;\n    a += in[pos++];\n    go();\n    if(pos<SZ(in) && in[pos]=='^'){\n      ++pos;\n      go();\n      a = string(in[pos++]-'0',a[0]);\n      //cout << a << endl;\n    }\n    ret[a] = 1;\n  }else if(in[pos]=='('){\n    ++pos;\n    ret = expr();\n    go();\n    ++pos;\n  }\n  \n  return ret;\n}\n\nEl term(){\n  go();\n  auto p = factor();\n  go();\n\n  while(pos < SZ(in) && in[pos] != ')' &&\n        in[pos] != '+' && in[pos] != '-'){\n    El np;\n    for(auto i : factor())\n      for(auto j : p){\n        auto ns = i.first + j.first;\n        sort(ns.begin(), ns.end());\n        np[ns] += i.second*j.second;\n      }\n    p = np;\n    go();\n  }\n  \n  return p;\n}\n\nEl expr(){\n  go();\n  auto p = term();\n  go();\n  while(pos < SZ(in) && (in[pos]=='+' || in[pos]=='-')){\n    auto op = in[pos++];\n    for(auto f : term())\n      p[f.first] += op == '+' ? f.second : -f.second;\n    go();\n  }\n  El ret;\n  for(auto f : p) if(f.second) ret[f.first] = f.second;\n  return ret;\n}\n\nint main(int argc, char *argv[])\n{\n  while(getline(cin, in) && in != \".\"){\n    pos = 0;\n    auto p = expr();\n    //for(auto pp : p) cout << pp.first << \" \" << pp.second << endl;\n    \n    while(getline(cin, in) && in != \".\"){\n      pos = 0;\n      auto q = expr();\n      //for(auto pp : q) cout << pp.first << \" \" << pp.second << endl;        \n      cout << (q == p ? \"yes\": \"no\") << endl;\n    }\n    cout << '.' << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing f = map<string,ll>;\n\nvoid PRINT(f a){\n    for(const auto &p:a){\n        cout << p.se << p.fi << \" + \";\n    }\n    cout << endl;\n}\n\nf norm(f a){\n    f ret;\n    for(const auto &p:a){\n        string v = p.fi;\n        sort(all(v));\n        if(p.se != 0) ret[v] = p.se;\n    }\n    return ret;\n}\n\nf sub(f a){\n    a = norm(a);\n\n    f ret;\n    for(const auto &p:a){\n        string v = p.fi;\n        if(p.se != 0) ret[v] = -p.se;\n    }\n    return ret;\n}\n\nf add(f a, f b){\n    a = norm(a);\n    b = norm(b);\n\n    for(const auto &p:b) a[p.fi] += p.se;\n\n    return norm(a);\n}\n\nf mul(f a, f b){\n    a = norm(a);\n    b = norm(b);\n\n    f ret;\n    for(const auto &p:a)for(const auto &q:b){\n        string var = p.fi+q.fi;\n        sort(all(var));\n\n        ret[var] += p.se*q.se;\n    }\n    return norm(ret);\n}\n\nf E(string s);\n\nf T(string s){\n    int n = s.size();\n    f ret;\n    ret[\"\"]=1;\n\n    int idx = 0;\n    while(idx<n){\n        f m;\n        if(s[idx]==' '){\n            ++idx;\n            continue;\n        }\n        else if(s[idx]=='('){\n            int ep = idx;\n            int p = 0;\n            while(ep<n){\n                if(s[ep]=='(') ++p;\n                if(s[ep]==')'){\n                    --p;\n                    if(p==0) break;\n                }\n                ++ep;\n            }\n            assert(ep<n);\n            assert(s[ep]==')');\n\n            string t = s.substr(idx+1,ep-idx-1);\n            m = E(t);\n            idx = ep+1;\n        }\n        else if(isdigit(s[idx])){\n            ll val = 0;\n            while(idx<n && isdigit(s[idx])){\n                val = val*10 + (s[idx]-'0');\n                ++idx;\n            }\n\n            int pw = 1;\n            int nx = idx;\n            while(nx<n && s[nx]==' ') ++nx;\n            if(nx<n && s[nx]=='^'){\n                ++nx;\n                while(nx<n && s[nx]==' ') ++nx;\n\n                assert(nx<n);\n                assert(isdigit(s[nx]));\n\n                pw = 0;\n                while(nx<n && isdigit(s[nx])){\n                    pw = 10*pw + (s[nx]-'0');\n                    ++nx;\n                }\n            }\n\n            ll vv = 1;\n            rep(_,pw) vv *= val;\n\n            m[\"\"] = vv;\n            idx = nx;\n        }\n        else if(islower(s[idx])){\n            char c = s[idx];\n            ++idx;\n\n            int pw = 1;\n            int nx = idx;\n            while(nx<n && s[nx]==' ') ++nx;\n            if(nx<n && s[nx]=='^'){\n                ++nx;\n                while(nx<n && s[nx]==' ') ++nx;\n\n                assert(nx<n);\n                assert(isdigit(s[nx]));\n\n                pw = 0;\n                while(nx<n && isdigit(s[nx])){\n                    pw = 10*pw + (s[nx]-'0');\n                    ++nx;\n                }\n            }\n\n            string t = \"\";\n            rep(_,pw) t += c;\n\n            m[t] = 1;\n            idx = nx;\n        }\n        else assert(false);\n\n        ret = mul(ret, m);\n    }\n\n    return norm(ret);\n}\n\nf E(string s){\n    int n = s.size();\n    f ret;\n\n    int p = 0;\n    int start = 0;\n    bool plus = true;\n\n    rep(i,n){\n        if(s[i]=='(') ++p;\n        if(s[i]==')') --p;\n\n        if(s[i]=='+' || s[i]=='-'){\n            if(p==0){\n                string term = s.substr(start,i-start);\n                f t = norm(T(term));\n                if(!plus) t = sub(t);\n                plus = (s[i]=='+');\n\n                ret = add(ret, t);\n\n                start = i+1;\n            }\n        }\n    }\n\n    string term = s.substr(start,n-start);\n    f t = norm(T(term));\n    if(!plus) t = sub(t);\n\n    ret = add(ret, t);\n\n    return norm(ret);\n}\n\nint main(){\n    string s;\n    while(getline(cin, s),(s!=\".\")){\n        f S = E(s);\n        // PRINT(S);\n\n        string t;\n        while(getline(cin, t),(t!=\".\")){\n            f T = E(t);\n            // PRINT(T);\n            cout << (S==T?\"yes\":\"no\") << endl;\n        }\n        cout << \".\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint MOD;\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nlong long power(long long a, long long b)\n{\n    long long ret = 1;\n    long long tmp = a;\n    while(b > 0){\n        if(b & 1){\n            ret *= tmp;\n            ret %= MOD;\n        }\n        tmp *= tmp;\n        tmp %= MOD;\n        b >>= 1;\n    }\n    return ret;\n}\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nlong long calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        long long ret = 0;\n        for(int i=0; i<n; ++i){\n            ret *= 10;\n            ret += s[i] - '0';\n        }\n        return ret;\n    }\n\n    if(n == 1)\n        return variable[s[0]];\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                if(i == 0)\n                    return (calculate(t1) + calculate(t2)) % MOD;\n                else if(i == 1)\n                    return (calculate(t1) - calculate(t2) + MOD) % MOD;\n                else if(i == 2)\n                    return (calculate(t1) * calculate(t2)) % MOD;\n                else\n                    return power(calculate(t1), calculate(t2));\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nstring solve(string s, string t)\n{\n    s = normalize(s);\n    t = normalize(t);\n\n    for(int i=0; i<50; ++i){\n        MOD = xor128() % INT_MAX + 1;\n        for(char c='a'; c<='z'; ++c)\n            variable[c] = xor128() % MOD;\n\n        long long x = calculate(s) % MOD;\n        long long y = calculate(t) % MOD;\n\n        if(x != y)\n            return \"no\";\n    }\n\n    return \"yes\";\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            cout << solve(s, t) << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar in[120];\nlong double var[30];\nchar str[210];\nint cur;\nlong double expr();\nlong double term(){\n\tif('0'<=str[cur]&&str[cur]<='9'){\n\t\tlong double ret=0.0L;\n\t\twhile('0'<=str[cur]&&str[cur]<='9'){\n\t\t\tret*=10.0L;ret+=(long double)(str[cur++]-'0');\n\t\t}\n\t\treturn ret;\n\t}\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tlong double ret=expr();\n\t\tcur++;\n\t\treturn ret;\n\t}\n\tif('a'<=str[cur]&&str[cur]<='z'){\n\t\tlong double ret=var[str[cur]-'a'];\n\t\tcur++;\n\t\tif(str[cur]=='^'){\n\t\t\tcur++;\n\t\t\tint po=str[cur]-'0';cur++;\n\t\t\tlong double val=1.0L;\n\t\t\tfor(int i=0;i<po;i++)val*=ret;\n\t\t\tret=val;\n\t\t}\n\t\treturn ret;\n\t}\n}\nlong double fact(){\n\tlong double ret=term();\n\twhile(str[cur]=='*'||(str[cur]!='+'&&str[cur]!='-'&&str[cur]&&str[cur]!=')')){\n\t\tif(str[cur]=='*')cur++;\n\t\tlong double tmp=term();\n\t//\tprintf(\"%Lf * %Lf = %Lf\\n\",ret,tmp,ret*tmp);\n\t\tret*=tmp;\n\t}\n//\tprintf(\"%d %Lf\\n\",cur,ret);\n\treturn ret;\n}\nlong double expr(){\n\tlong double ret=fact();\n\twhile(str[cur]=='+'||str[cur]=='-'){\n\t\tcur++;\n\t\tchar ch=str[cur-1];\n\t\tlong double tmp=fact();\n\t\tif(ch=='+')ret+=tmp;\n\t\telse ret-=tmp;\n\t}\n\treturn ret;\n}\nlong double ABS(long double a){return max(a,-a);}\nint main(){\n\twhile(1){\n\t\tgets(in);\n\t\tif(in[0]=='.')break;\n\t\tint at=0;\n\t\tfor(int i=0;in[i];i++){\n\t\t\tif(in[i]!=' ')str[at++]=in[i];\n\t\t}\n\t\twhile(1){\n\t\t\tgets(in);\n\t\t\tif(in[0]=='.')break;\n\t\t\tstr[at]='-';\n\t\t\tstr[at+1]='(';\n\t\t\tint ind=at+2;\n\t\t\tfor(int i=0;in[i];i++){\n\t\t\t\tif(in[i]==' '){\n\t\t\t\t\tif(i&&'0'<=in[i-1]&&in[i-1]<='9'&&'0'<=in[i+1]&&in[i+1]<='9'){\n\t\t\t\t\t\tstr[ind++]='*';\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstr[ind++]=in[i];\n\t\t\t}\n\t\t\tstr[ind++]=')';\n\t\t\tstr[ind]=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int i=0;i<500;i++){\n\t\t\t\tfor(int j=0;j<26;j++)var[j]=(long double)(rand()%1000)/200;\n\t\t\t\tcur=0;\n\t\t\t\tlong double res=expr();\n\t\t\t\tif(ABS(res)>0.5L){\n\t\t\t\t//\tprintf(\"%s %Lf %Lf\\n\",str,var[23],res);\n\t\t\t\t\tok=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t}\n\t\tprintf(\".\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1LL<<59)\n\n#define int ll\n\ntypedef array<int,27> AI;\ntypedef vector<AI> EX;\ntypedef string::const_iterator State;\n\nstring normalize(string s){\n\tstring t=\"\";\n\trep(i,s.size()){\n\t\tif(s[i]!=' ')t+=s[i];\n\t\telse if(i+1==s.size()||s[i+1]!=' ') t+=s[i];\n\t}\n\trep(i,t.size()-1)assert(t[i]!=' '||t[i+1]!=' ');\n\n\tstring u=\"\";\n\trep(i,t.size()){\n\t\tchar ch = t[i];\n\t\tif(ch!=' '){u+=ch;continue;}\n\n\t\tif(!(i-1<0||t[i-1]=='('||t[i-1]=='-'||t[i-1]=='+'||t[i-1]=='^')&&!(i+1>=t.size()||t[i+1]==')'||t[i+1]=='-'||t[i+1]=='+'||t[i+1]=='^'))u+=' ';\n\t}\n\trep(i,u.size())if(u[i]==' ')u[i] = '*';\n\t\n\tstring ret = \"\";\n\trep(i,u.size()){\n\t\tret+=u[i];\n\t\tif( i+1<s.size() && ((isalpha(u[i])&&isdigit(u[i+1])) || (isdigit(u[i])&&isalpha(u[i+1])))){\n\t\t\tret+='*';\n\t\t}\n\t}\n\treturn ret;\n}\n\nEX E(State &beg);\n\n\nint  dig(State &beg){\n\tstring res = \"\";\n\twhile(isdigit(*beg)){\n\t\tres+=*beg;\n\t\tbeg++;\n\t}\n\treturn  stoi(res);\n}\n\n\nEX P(State &beg){\n\tif(isdigit(*beg)){\n\t\tint res = dig(beg);\n\t\tAI ret;\n\t\tret[0]=res;\n\t\tfor(int i=1;i<ret.size();i++)ret[i]=0;\n\t\treturn EX(1,ret);\n\t}\n\telse{\n\t\tassert(isalpha(*beg));\n\t\tchar ch = *beg;\n\t\tbeg++;\n\n\t\tif(*beg=='^'){\n\t\t\tbeg++;\n\t\t\tint t = dig(beg);\n\t\t\tAI ret;\n\t\t\trep(i,ret.size()){\n\t\t\t\tif(i==ch-'a'+1)ret[i] = 1;\n\t\t\t\telse ret[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\treturn EX(1,ret);\n\t\t}\n\t\telse{\n\t\t\tAI ret;\n\t\t\trep(i,ret.size()){\n\t\t\t\tif(i==ch-'a'+1)ret[i] = 1;\n\t\t\t\telse ret[i] = 0;\n\t\t\t}\n\n\t\t\treturn EX(1,ret);\n\t\t}\n\t}\n}\n\n\nAI mul(AI a,AI b){\n\tAI ret;\n\tret[0] = a[0]*b[0];\n\tfor(int i=1;i<a.size();i++){\n\t\tret[i] = a[i]+b[i];\n\t}\n\treturn ret;\n}\n\nEX mulEX(EX a,EX b){\n\tEX ret;\n\trep(i,a.size()){\n\t\trep(j,b.size()){\n\t\t\tret.pb(mul(a[i],b[j]));\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nEX T(State &beg){\n\tif(*beg=='('){\n\t\tEX res;\n\t\tbeg++;\n\t\tres = E(beg);\n\t\tbeg++;\n\t\treturn res;\n\t}\n\telse{\n\t\tassert(isdigit(*beg)||isalpha(*beg));\n\t\tEX res = P(beg);\n\t\t\n\t\tif(*beg=='*'){\n\t\t\tbeg++;\n\t\t\tEX t = T(beg);\n\t\t\tres = mulEX(res,t);\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\n\nbool isSame(AI a,AI b){\n\tfor(int i=1;i<a.size();i++){\n\t\tif( a[i]!=b[i] )return false;\n\t}\n\treturn true;\n}\n\n\nEX E(State &beg){\n\tEX res = T(beg);\n\tif(*beg=='+'){\n\t\tbeg++;\n\t\tEX t = E(beg);\n\t\trep(i,t.size()){\n\t\t\tbool f=false;\n\t\t\trep(j,res.size()){\n\t\t\t\tif(isSame(t[i],res[j])){\n\t\t\t\t\tf=true;\n\t\t\t\t\tres[j][0]+=t[i][0];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f){\n\t\t\t\tres.pb(t[i]);\n\t\t\t}\n\t\t}\n\t}\n\telse if(*beg=='-'){\n\t\tbeg++;\n\t\tEX t = E(beg);\n\t\trep(i,t.size()){\n\t\t\tbool f;\n\t\t\trep(j,res.size()){\n\t\t\t\tif(isSame(t[i],res[j])){\n\t\t\t\t\tf=true;\n\t\t\t\t\tres[j][0]-=t[i][0];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f){\n\t\t\t\tAI tmp = t[i];\n\t\t\t\ttmp[0]*=-1;\n\t\t\t\tres.pb(tmp);\n\t\t\t}\n\t\t}\n\t}\n\telse return res;\n\treturn res;\n}\n\n\nbool isMatch(EX a,EX b){\n\tsort(all(a));\n\tsort(all(b));\n\tif(a==b)return true;\n\telse return false;\n}\n\n\nsigned main(){\n\tassert(normalize(\"(a - b) (0-b+a) - 1a ^ 2 - b ^ 2\")==\"(a-b)*(0-b+a)-1*a^2-b^2\");\n\twhile(1){\n\t\tvector<string> vs;\n\t\tstring s;\n\t\twhile(getline(cin,s)&&s!=\".\"){\n\t\t\tvs.pb(s);\n\t\t}\n\t\tif(vs.size()==0)break;\n\t\t\n\t\trep(i,vs.size()) vs[i] = normalize(vs[i]);\n\t\t\n\t\tvector<EX> ans;\n\t\trep(i,vs.size()){\n\t\t\tState beg = vs[i].begin();\n\t\t\tEX res = E(beg);\n\t\t\tans.pb(res);\n\t\t}\n\t\t\n\t\tfor(int i=1;i<ans.size();i++){\n\t\t\tif(isMatch(ans[0],ans[i])){\n\t\t\t\tcout<<\"yes\"<<endl;\n\t\t\t}\n\t\t\telse cout<<\"no\"<<endl;\n\t\t}\n\t\tcout<<\".\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint a = 0;\nvoid getspace(string st) {\n\twhile (st[a] == ' ')a++;\n\treturn;\n}\nmap<vector<int>, int>getcal(string st);\nint getnum(string st) {\n\tint num = 0;\n\t//getspace();\n\twhile (isdigit(st[a])) {\n\t\tnum = num * 10 + st[a] - '0';\n\t\ta++;\n\t}\n\treturn num;\n}\npair<char, int>getchar(string st) {\n\tchar ch = st[a];\n\ta++;\n\tbool  kakeru = false;\n\tgetspace(st);\n\t\n\tint num = 1;\n\tif (st[a] == '^') {\n\t\ta++;\n\t\tgetspace(st);\n\t\tassert(isdigit(st[a]));\n\t\tnum = getnum(st);\n\t}\n\treturn make_pair(ch, num);\n}\n\nmap<vector<int>, int>geta(string st) {\n\tgetspace(st);\n\tmap<vector<int>, int>mp;\n\tif (isdigit(st[a])) {\n\t\tconst int num(getnum(st));\n\t\tmap<vector<int>, int>newmp;\n\t\tnewmp[vector<int>(26, 0)] = num;\n\t\tmp=newmp;\n\t}\n\telse if (isalpha(st[a])) {\n\t\tpair<char, int>amp(getchar(st));\n\t\tmap<vector<int>, int>newmp;\n\t\tvector<int>v(26,0);\n\t\tv[amp.first - 'a'] += amp.second;\n\t\tnewmp[v] =1;\n\t\tmp = newmp;\n\t}\n\telse if (st[a] == '(') {\n\t\ta++;\n\t\tmp = getcal(st);\n\t\ta++;\n\t}\n\telse {\n\t\tassert(false);\n\t}\n\twhile (1) {\n\t\tgetspace(st);\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\treturn mp;\n\t\t}\n\t\telse if (st[a] == '(') {\n\t\t\ta++;\n\t\t\tmap<vector<int>, int>amp = getcal(st);\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (auto a : mp) {\n\t\t\t\tfor (auto b : amp) {\n\t\t\t\t\tvector<int>v1(a.first);\n\t\t\t\t\tvector<int>v2(b.first);\n\t\t\t\t\ttransform(v1.begin(), v1.end(), v2.begin(), v1.begin(), [](const int l, const int r) {return l + r; });\n\t\t\t\t\tnewmp[v1] += a.second*b.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t\tassert(st[a] == ')');\n\t\t\ta++;\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\treturn mp;\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\treturn mp;\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tconst int num(getnum(st));\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (const auto m : mp) {\n\t\t\t\tvector<int>v(m.first);\n\t\t\t\tnewmp[v] = m.second*num;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t}\n\t\telse if (isalpha(st[a])) {\n\t\t\tpair<char, int>amp(getchar(st));\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (const auto m : mp) {\n\t\t\t\tvector<int>v(m.first);\n\t\t\t\tv[amp.first - 'a'] += amp.second;\n\t\t\t\tnewmp[v] = m.second;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n}\n\nmap<vector<int>, int>getplmi(string st) {\n\tmap<vector<int>, int>mp(geta(st));\n\tgetspace(st);\n\twhile (1) {\n\t\tgetspace(st);\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\treturn mp;\n\t\t}\n\t\tif (st[a] == '(') {\n\t\t\tassert(false);\n\t\t\ta++;\n\t\t\tmap<vector<int>, int>amp = getcal(st);\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (auto a : mp) {\n\t\t\t\tfor (auto b : amp) {\n\t\t\t\t\tvector<int>v1(a.first);\n\t\t\t\t\tvector<int>v2(b.first);\n\t\t\t\t\ttransform(v1.begin(), v1.end(), v2.begin(), v2.end(), [](const int l, const int r) {return l + r; });\n\t\t\t\t\tnewmp[v1] += a.second*b.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t\tassert(st[a] == ')');\n\t\t\ta++;\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\treturn mp;\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\treturn mp;\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tassert(false);\n\t\t\tconst int num(getnum(st));\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (const auto m : mp) {\n\t\t\t\tvector<int>v(m.first);\n\t\t\t\tnewmp[v] = m.second*num;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t\ta++;\n\t\t}\n\t\telse if (isalpha(st[a])) {\n\t\t\tassert(false);\n\t\t\tpair<char, int>amp(getchar(st));\n\t\t\tmap<vector<int>, int>newmp;\n\t\t\tfor (const auto m : mp) {\n\t\t\t\tvector<int>v(m.first);\n\t\t\t\tv[amp.first - 'a'] += amp.second;\n\t\t\t\tnewmp[v] = m.second;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t\ta++;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n}\n\nmap<vector<int>, int>getcal(string st) {\n\tmap<vector<int>, int>mp;\n\tgetspace(st);\n\tmp = getplmi(st);\n\twhile (1) {\n\t\tgetspace(st);\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\treturn mp;\n\t\t}else if (st[a] == '+') {\n\t\t\ta++;\n\t\t\tmap<vector<int>, int>amp = getplmi(st);\n\t\t\tmap<vector<int>, int>newmp(mp);\n\t\t\tfor (auto aa : amp) {\n\t\t\t\tnewmp[aa.first] += aa.second;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\ta++;\n\t\t\tmap<vector<int>, int>amp = getplmi(st);\n\t\t\tmap<vector<int>, int>newmp(mp);\n\t\t\tfor (auto a : amp) {\n\t\t\t\tnewmp[a.first] -= a.second;\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tassert(false);\n\t\t}\n\t\telse if (isalpha(st[a])) {\n\t\t\tassert(false);\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\t\n}\n\nmap<vector<int>, int>getans(string st) {\n\ta = 0;\n\tmap<vector<int>,int> prov(getcal(st));\n\tmap<vector<int>, int> ans;\n\tfor (auto p : prov) {\n\t\tif (p.second) {\n\t\t\tans[p.first] = p.second;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tstring st;\n\twhile (1) {\n\t\tmap<vector<int>, int>ans;\n\t\tgetline(cin, st);\n\t\tif (st == \".\") {\n\t\t\treturn 0;\n\t\t}\n\t\tans = getans(st);\n\t\t\n\t\twhile (1) {\n\t\t\tgetline(cin, st);\n\t\t\tif (st == \".\") {\n\t\t\t\tcout << st << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap<vector<int>, int>nans(getans(st));\n\t\t\t\n\t\t\tif (nans == ans) {\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"no\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\n#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\n\nbool is_same_formula(formula a,formula b){\n  erase_duplicate(a);\n  erase_duplicate(b);\n  if (a.size() != b.size())return false;\n  if (a.size() == 1 && b.size() == 1){\n    if (a[0].c == 0 && b[0].c == 0)return true;\n  }\n\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n    \n  }\n  if (b.size() == 0)return true;\n  else return false;\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    tmp.p[in[p]-'a']++;\n    //    while(p < in.size() && isalpha(in[p])){\n\n      p++;\n      //    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n\n    //debug\n    /*\n    p=0;\n    in=pre_processing2(tmp);\n    formula me2=fact(in,p);\n    assert(is_same_formula(me,me2));\n    */\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n      \n      /*\n      p=0;\n      cmp=pre_processing2(tmp);\n      formula you2=fact(cmp,p);\n      assert(is_same_formula(you,you2));\n      */\n      //      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n/*\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n  return ret;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<class Z> Z rng(Z a, Z b) {\n  static mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n  return uniform_int_distribution<Z>(a, b - 1)(mt);\n}\n\nlint powll(lint a, int n) {\n  assert(n >= 0);\n  lint res = 1;\n  for (; n > 0; a *= a, n >>= 1) if (n & 1) res *= a;\n  return res;\n}\n\nlint digits(auto& i) {\n  lint res = 0;\n  while (isdigit(*i)) res = 10 * res + *i++ - '0';\n  return res;\n}\nlint expr(auto& i);\nlint num(auto& i) {\n  switch (*i) {\n    case '(': {\n      lint res = expr(++i);\n      return ++i, res;\n    }\n    default: return digits(i);\n  }\n}\nlint pw(auto& i) {\n  lint res = num(i);\n  if (*i == '^') return ++i, powll(res, num(i));\n  return res;\n}\nlint term(auto& i) {\n  lint res = pw(i);\n  while (true) switch (*i) {\n    case '*': res *= pw(++i); break;\n    default: return res;\n  }\n}\nlint expr(auto& i) {\n  lint res = term(i);\n  while (true) switch (*i) {\n    case '+': res += term(++i); break;\n    case '-': res -= term(++i); break;\n    default: return res;\n  }\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  auto pre = [&](string s) -> string {\n    while (true) {\n      bool b = false;\n      for (int i = 0; i < (int)s.size(); ++i) if (s.substr(i, 2) == \"  \") {\n        s.erase(begin(s) + i);\n        b = true;\n        break;\n      }\n      if (!b) break;\n    }\n    string res;\n    for (int i = 0; i < (int)s.size(); ++i) {\n      if (s[i] == ' ') {\n        if (isdigit(s[i - 1]) and isdigit(s[i + 1])) {\n          res += '*';\n        }\n      } else res += s[i];\n      if (isdigit(res.back()) and isdigit(s[i + 1])) continue;\n      bool b0 = res.back() == ')' or isdigit(res.back()) or islower(res.back());\n      bool b1 = s[i + 1] == '(' or isdigit(s[i + 1]) or islower(s[i + 1]);\n      if (b0 and b1) res += '*';\n    }\n    return res;\n  };\n  auto eval = [&](string s, const V<>& a) -> lint {\n    for (int i = 0; i < (int)s.size(); ++i) if (islower(s[i])) {\n      s.replace(i, 1, to_string(a[s[i] - 'a']));\n    }\n    auto i = begin(s);\n    lint res = expr(i);\n    // cerr << s << ' ' << res << '\\n';\n    return res;\n  };\n  auto comp = [&](string s, string t) -> bool {\n    s = pre(s);\n    t = pre(t);\n    bool ok = true;\n    for (int _ = 0; _ < 100; ++_) {\n      V<> a(26);\n      for (auto&& e : a) e = rng(0, 100);\n      if (eval(s, a) != eval(t, a)) {\n        ok = false;\n        break;\n      }\n    }\n    return ok;\n  };\n  while (true) {\n    string s; getline(cin, s);\n    if (s == \".\") break;\n    while (true) {\n      string t; getline(cin, t);\n      if (t == \".\") {\n        cout << \".\\n\";\n        break;\n      }\n      cout << (comp(s, t) ? \"yes\\n\" : \"no\\n\");\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nbool is_operator(char c){\n  string opes = \"+-^*\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nstring preprocessing(string s){\n  stringstream ss(s);\n  string res;\n  ss >> res;\n  while(ss>>s){\n    char a = res[res.size() - 1];\n    char b = s[0];\n    if(is_operator(a) || is_operator(b)) res += s;\n    else res += \"*\" + s;\n  }\n  REP(i, res.size() - 1){\n    if((isalpha(res[i]) && isalpha(res[i + 1])) ||\n       (isdigit(res[i]) && isalpha(res[i + 1])) ||\n       (isalpha(res[i]) && isdigit(res[i + 1]))){\n      res.insert(++i, \"*\");\n    }\n  }\n  return res;\n}\ntypedef map<char,int> Var;\nVar mul(Var x, Var y){\n  FORIT(it, y){\n    x[it->first] += it->second;\n  }\n  return x;\n}\nstruct Result{\n  map<Var, int> value;\n  int p;\n  Result(map<Var, int> v, int p) : \n    value(v), p(p) {}\n};\nResult expression(const string& s, int p);\nResult term(const string& s, int p);\nResult factor(const string& s, int p);\nResult expression(const string& s, int p){\n  Result r = term(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result t = term(s, r.p + 1);\n    FORIT(it, t.value){\n      if(s[r.p] == '+') r.value[it->first] += it->second;\n      if(s[r.p] == '-') r.value[it->first] -= it->second;\n    }\n    r.p = t.p;\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  Result r = factor(s, p);\n  while(s[r.p] == '*'){\n    Result t = factor(s, r.p + 1);\n    map<Var, int> new_val;\n    FORIT(it1, r.value)FORIT(it2, t.value){\n      new_val[mul(it1->first, it2->first)] += it1->second * it2->second;\n    }\n    r.value = new_val;\n    r.p = t.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p){\n  if(s[p] == '('){\n    Result r = expression(s, p + 1);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(isdigit(s[p])){\n    int val = 0;\n    while(isdigit(s[p])){\n      val = val * 10 + s[p++] - '0';\n    }\n    map<Var, int> expr;\n    expr[ Var() ] = val;\n    return Result(expr, p);\n  }else if(isalpha(s[p])){\n    char c = s[p++];\n    if(s[p] == '^'){\n      p++;\n      int val = 0;\n      while(isdigit(s[p])){\n        val = val * 10 + s[p++] - '0';\n      }\n      map<Var, int> expr;\n      Var v; v[c] = val;\n      expr[v] = 1;\n      return Result(expr, p);\n    }else{\n      map<Var, int> expr;\n      Var v; v[c] = 1;\n      expr[v] = 1;\n      return Result(expr, p);\n    }\n  }else {\n    assert(false);\n  }\n}\nint main(){\n  string line;\n  while(getline(cin, line) && line != \".\"){\n    line = preprocessing(line);\n    Result r = expression(line, 0);\n    map<Var, int> expr = r.value;\n    while(getline(cin, line) && line != \".\"){\n      line = preprocessing(line);\n      Result r = expression(line, 0);\n      map<Var, int> expr2 = r.value;\n      if(expr == expr2) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n    cout << \".\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\nbool is_same_formula(formula a,formula b){\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n  }\n  return true;\n}\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  if (ret.size() == 0)ret.pb(ori);\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n \n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    while(p < in.size() && isalpha(in[p])){\n      tmp.p[in[p]-'a']++;\n      p++;\n    }\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  //test();\n\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n\n    //debug\n    p=0;\n    in=pre_processing2(tmp);\n    formula me2=fact(in,p);\n    assert(is_same_formula(me,me2));\n    //        cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      p=0;\n      cmp=pre_processing2(tmp);\n      formula you2=fact(cmp,p);\n      assert(is_same_formula(you,you2));\n\n      //      cout << \"formula :\"<<cmp<<endl;output(you);\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n\n\n\n\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n\n  return ret;\n}\n\n\n\n\nvoid test(){\n  Element a,b,c;\n  a.c=2;\n  a.p[0]=1;\n  a.p[1]=2;\n  b.c=1;\n  b.p[0]=1;\n  b.p[1]=3;\n  b.p[2]=3;\n  c.c=1;\n  c.p[0]=1;\n  c.p[2]=1;\n  \n\n  formula A,B,C;\n  A.pb(a);\n  A.pb(b);\n  B.pb(c);\n\n  cout <<\"A\"<<endl;\n  output(A);\n  \n  cout <<\"B\"<<endl;\n  output(B);\n  \n  cout <<\"C\"<<endl;\n  output(C);\n\n  formula Mtest  =minu(A,A);\n  \n \n  cout <<\"test\"<<endl;\n  output(Mtest);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nclass State{\npublic:\n  int a; //ツ係ツ青?\n  int x[26]; //ツ各ツ陛渉青?a~z)ツつェツ可スツ湘ヲツつゥ\n\n  State(int _a, const int _x[26]){\n    a = _a;\n    for(int i = 0; i < 26; i++){\n      x[i] = _x[i];\n    }\n  }\n\n  State operator*(const State &st)const{\n    State res(a * st.a, x);\n    for(int i = 0; i < 26; i++){\n      res.x[i] += st.x[i];\n    }\n    return res;\n  }\n\n  State operator+(const State &st)const{\n    return State(a + st.a, x);\n  }\n\n  State operator-(const State &st)const{\n    return State(a - st.a, x);\n  }\n\n  State operator^(const int &p)const{\n    State res((int)pow(a, p), x);\n    for(int i = 0; i < 26; i++){\n      res.x[i] *= p;\n    }\n    return res;\n  }\n\n  bool operator<(const State &st)const{\n    if(a == st.a){\n      for(int i = 0; i < 26; i++){\n        if(x[i] < st.x[i]){\n          return true;\n        }\n        if(x[i] > st.x[i]){\n          return false;\n        }\n      }\n    }\n    return a < st.a;\n  }\n\n  bool operator==(const State &st)const{\n    if(a != st.a) return false;\n    for(int i = 0; i < 26; i++){\n      if(x[i] != st.x[i]){\n        return false;\n      }\n    }\n    return true;\n  }\n\n  bool eqx(const State &st)const{\n    for(int i = 0; i < 26; i++){\n      if(x[i] != st.x[i]){\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void show(){\n    cout << a << \" \";\n    for(int i = 0; i < 26; i++){\n      if(x[i] != 0){\n        cout << (char)('a' + i) << \"^\" << x[i] << \" \";\n      }\n    }\n    cout<<endl;\n  }\n};\n\nint idx, n;\nstring s;\n\nState mkState(int a, char ch){\n  int tmp[26];\n  memset(tmp, 0, sizeof(tmp));\n  if(ch != ' '){\n    tmp[ch - 'a'] = 1;\n  }\n  return State(a, tmp);\n}\n\nvoid init(){\n  string ts = \"\";\n  int si = 0, gi = s.length() - 1;\n  while(s[si] == ' ') si++;\n  while(s[gi] == ' ') gi--;\n\n  //ツづ?づィツつ?つヲツつクツ凝ウツ板陳全ツづ?湘?つキ\n  for(int i = si; i <= gi; i++){\n    if(s[i] != ' '){\n      ts += s[i];\n    }\n    else{\n      int j, k;\n      for(j = i - 1; s[j] == ' '; j--);\n      for(k = i + 1; s[k] == ' '; k++);\n\n      if(isdigit(s[j]) && isdigit(s[k])){\n        ts += \"*\";\n      }\n\n      i = k - 1;\n    }\n  }\n\n  for(int i = ts.length() - 1; i > 0; i--){\n    if(ts[i - 1] == ')' && (ts[i] == '(' || isdigit(ts[i]) || isalpha(ts[i])) ||\n       ts[i] == '(' && (isdigit(ts[i - 1]) || isalpha(ts[i - 1])) ||\n       isdigit(ts[i]) && isalpha(ts[i - 1]) ||\n       isdigit(ts[i - 1]) && isalpha(ts[i]) ||\n       isalpha(ts[i]) && isalpha(ts[i - 1])){\n      ts.insert(ts.begin() + i, '*');\n    }\n  }\n\n  s = ts;\n  n = s.length();\n}\n\nvector<State> zeroClear(const vector<State> &v){\n  vector<State> res;\n\n  for(int i = 0; i < v.size(); i++){\n    if(v[i].a != 0){\n      res.push_back(v[i]);\n    }\n  }\n\n  return res;\n}\n\nvector<State> solve();\n\nvoid Add(vector<State> &v1, const vector<State> &v2){\n  bool used[v2.size()];\n  memset(used, 0, sizeof(used));\n\n  for(int i = 0; i < v1.size(); i++){\n    for(int j = 0; j < v2.size(); j++){\n      if(used[j]) continue;\n      if(v1[i].eqx(v2[j])){\n        v1[i] = v1[i] + v2[j];\n        used[j] = true;\n      }\n    }\n  }\n\n  for(int i = 0; i < v2.size(); i++){\n    if(!used[i]){\n      v1.push_back(v2[i]);\n    }\n  }\n}\n\nvoid Sub(vector<State> &v1, const vector<State> &v2){\n  bool used[v2.size()];\n  memset(used, 0, sizeof(used));\n\n  for(int i = 0; i < v1.size(); i++){\n    for(int j = 0; j < v2.size(); j++){\n      if(used[j]) continue;\n      if(v1[i].eqx(v2[j])){\n        v1[i] = v1[i] - v2[j];\n        used[j] = true;\n      }\n    }\n  }\n\n  for(int i = 0; i < v2.size(); i++){\n    if(!used[i]){\n      v1.push_back(State(-1 * v2[i].a, v2[i].x));\n    }\n  }\n}\n\nvector<State> Mul(const vector<State> &v1, const vector<State> &v2){\n  vector<State> res;\n\n  for(int i = 0; i < v1.size(); i++){\n    for(int j = 0; j < v2.size(); j++){\n      bool flg = false;\n      State st = v1[i] * v2[j];\n\n      for(int k = 0; k < res.size(); k++){\n        if(res[k].eqx(st)){\n          res[k] = res[k] + st;\n          flg = true;\n          break;\n        }\n      }\n\n      if(!flg){\n        res.push_back(st);\n      }\n    }\n  }\n\n  return res;\n}\n\nvoid Pow(vector<State> &v, const int &p){\n  for(int i = 0; i < v.size(); i++){\n    v[i] = v[i] ^ p;\n  }\n}\n\nint digit(){\n  int res = 0;\n\n  while(idx < n && isdigit(s[idx])){\n    res *= 10;\n    res += s[idx] - '0';\n    idx++;\n  }\n\n  return res;\n}\n\nvector<State> factor(){\n  vector<State> v;\n\n  if(s[idx] == '('){\n    idx++;\n    v = solve();\n    idx++;\n  }\n  else if(isdigit(s[idx])){\n    int d = digit();\n    v.push_back(mkState(d, ' '));\n  }\n  else{\n    v.push_back(mkState(1, s[idx]));\n    idx++;\n  }\n\n  if(idx < n && s[idx] == '^'){\n    idx++;\n    int d = digit();\n    Pow(v, d);\n  }\n\n  return v;\n}\n\nvector<State> term(){\n  vector<State> v = factor();\n\n  while(idx < n){\n    if(s[idx] == '*'){\n      idx++;\n      v = Mul(v, factor());\n    }\n    else{\n      return v;\n    }\n  }\n\n  return v;\n}\n\nvector<State> solve(){\n  vector<State> v = term();\n\n  while(idx < n){\n    if(s[idx] == '+'){\n      idx++;\n      Add(v, term());\n    }\n    else if(s[idx] == '-'){\n      idx++;\n      Sub(v, term());\n    }\n    else{\n      return v;\n    }\n  }\n\n  return v;\n}\n\nint main(){\n  while(getline(cin, s), s != \".\"){\n    init();\n    idx = 0;\n    vector<State> v1 = solve();\n    v1 = zeroClear(v1);\n    sort(v1.begin(), v1.end());\n\n    while(getline(cin, s), s != \".\"){\n      init();\n      idx = 0;\n      vector<State> v2 = solve();\n      v2 = zeroClear(v2);\n      sort(v2.begin(), v2.end());\n\n      if(v1 == v2){\n        cout << \"yes\\n\";\n      }\n      else{\n        cout << \"no\\n\";\n      }\n    }\n\n    cout << \".\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\n#include<string>\n#include<sstream>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\nstring pre_processing(string &in);\nstring pre_processing2(string &in);\n\nclass Element{\npublic:\n  int c;\n  int p[26];\n  Element(){\n    c=0;rep(i,26)p[i]=0;\n  }\n};\n\ntypedef vector<Element> formula;\nElement ori;\n\n\nbool is_same_Element(Element a,Element b){\n  rep(i,26)if (a.p[i] != b.p[i])return false;\n  return true;\n}\n\n\nvoid erase_duplicate(formula &ret){\n  rep(i,ret.size()){\n    REP(j,i+1,ret.size()){\n      if (is_same_Element(ret[i],ret[j])){\n\tret[i].c+=ret[j].c;\n\tret.erase(ret.begin()+j);\n\tj--;\n      }\n    }\n  }\n  rep(i,ret.size()){\n    if (ret[i].c == 0){\n      ret.erase(ret.begin()+i);\n      i--;\n    }\n  }\n  //if (ret.size() == 0)ret.pb(ori);\n}\n\nbool is_same_formula(formula a,formula b){\n  erase_duplicate(a);\n  erase_duplicate(b);\n  if (a.size() != b.size())return false;\n  if (a.size() == 1 && b.size() == 1){\n    //if (a[0].c == 0 && b[0].c == 0)return true;\n  }\n\n  rep(i,a.size()){\n    bool canfind=false;\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (is_same_Element(a[i],b[j]) &&\n\t  a[i].c == b[j].c){\n\tb.erase(b.begin()+j);\n\tcanfind=true;\n\tbreak;\n      }\n    }\n    if (!canfind)return false;\n    \n  }\n  if (b.size() == 0)return true;\n  else return false;\n}\n\nformula mult(formula a,formula b){\n  formula ret;\n  rep(i,a.size()){\n    if (a[i].c == 0)continue;\n    rep(j,b.size()){\n      if (b[j].c == 0)continue;\n      Element tmp;\n      tmp.c=a[i].c*b[j].c;\n      rep(k,26){\n\ttmp.p[k]=a[i].p[k]+b[j].p[k];\n      }\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula plu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c !=0)ret.pb(a[i]);\n  rep(i,b.size())if (b[i].c !=0)ret.pb(b[i]);\n  erase_duplicate(ret);\n  return ret;\n}\n\nformula minu(formula a,formula b){\n  formula ret;\n  rep(i,a.size())if (a[i].c!=0)ret.pb(a[i]);\n  rep(i,b.size()){\n    if (b[i].c != 0){\n      Element tmp = b[i];\n      tmp.c*=-1;\n      ret.pb(tmp);\n    }\n  }\n  erase_duplicate(ret);\n  return ret;\n}\n\nvoid output(formula a){\n  cout <<\"output begin\"<<endl;\n  rep(i,a.size()){\n    cout << a[i].c ;\n    rep(j,26){\n      if (a[i].p[j]==0)continue;\n      cout << (char)(j+'a') <<\"^\"<<\n\ta[i].p[j];\n    }\n    cout << endl;\n  }\n  cout <<\"output end\" << endl;\n}\n\nformula term(string &in,int &p);\nformula fact(string &in,int &p);\nformula digit(string &in,int &p);\nint       num(string &in,int &p);\n\nformula fact(string &in,int &p){\n  formula ret=term(in,p);\n  while(p < in.size()){\n    if (in[p] == '+'){\n      p++;\n      formula tmp = term(in,p);\n      ret=plu(ret,tmp);\n    }else if (in[p]=='-'){\n      p++;\n      formula tmp = term(in,p);\n      ret=minu(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\nformula term(string &in,int &p){\n  formula ret = digit(in,p);\n  while(p < in.size()){\n    if (in[p] == '*'){\n      p++;\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else if (in[p] == '('||isdigit(in[p])||\n\t     isalpha(in[p])){\n      formula tmp = digit(in,p);\n      ret=mult(ret,tmp);\n    }else break;\n  }\n  return ret;\n}\n\nformula digit(string &in,int &p){\n  formula ret;\n  if(in[p] == '('){\n    p++;\n    ret=fact(in,p);\n    p++;//skip ')'\n  }else if (isdigit(in[p])){\n    int tmp = num(in,p);\n    Element ins;\n    ins.c=tmp;\n    ret.pb(ins);\n  }else if (isalpha(in[p])){\n    Element tmp;\n    tmp.c=1;\n    tmp.p[in[p]-'a']++;\n      p++;\n    ret.pb(tmp);\n  }\n\n  if (p < in.size() && in[p]=='^'){\n    formula ori = ret;\n    p++;\n    int power=num(in,p);\n    Element tmp;\n    tmp.c=1;\n    ret.clear();\n    ret.pb(tmp);\n    rep(i,power){\n      ret=mult(ret,ori);\n    }\n  }\n  return ret;\n}\n\nint num(string &in,int &p){\n  int tmp=0;\n  while(p < in.size() && isdigit(in[p])){\n    tmp=(tmp*10)+(in[p]-'0');\n    p++;\n  }\n  return tmp;\n}\n\nmain(){\n  string in;\n  while(getline(cin,in) && in != \".\"){\n    string tmp=in;\n    in = pre_processing(in);\n    int p=0;\n\n    formula me = fact(in,p);\n    //    cout << \"formula :\" << in << endl;output(me);\n    string cmp;\n\n    while(getline(cin,cmp) && cmp != \".\"){\n      tmp=cmp;\n      cmp=pre_processing(cmp);\n      p=0;\n      formula you = fact(cmp,p);\n\n      if (is_same_formula(me,you))cout <<\"yes\"<<endl;\n      else cout <<\"no\"<<endl;\n    }\n    cout << \".\"<<endl;\n  }\n  return false;\n}\n\n\n\nstring pre_processing(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\";\n  rep(i,in.size()){\n    if (in[i] == ' ')continue;\n    if (isdigit(in[i])||isalpha(in[i])){\n      if (i!=0&&in[i-1]==' '&&last==true)ret+='*';\n      last=true;\n    }else last=false;\n    ret+=in[i];\n  }\n  return ret;\n}\n/*\nstring pre_processing2(string &in){\n  bool last=false;\n  int prev=-2;\n  string ret=\"\",tmp;\n  stringstream sin(in);\n  sin>>ret;\n  while(sin>>tmp){\n    int p=ret.size()-1;\n    if (tmp[0] == '+'){\n      ret+=tmp;\n    }else if (tmp[0] == '-'){\n      ret+=tmp;\n    }else if (tmp[0] =='('){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (tmp[0] == ')'){\n      ret+=tmp;\n    }else if (tmp[0] == '^'){\n      ret+=tmp;\n    }else if (isdigit(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }else if (isalpha(tmp[0])){\n      if (ret[p] == ')'){\n\tret=ret+'*'+tmp;\n      }else if (isdigit(ret[p])){\n\tret=ret+'*'+tmp;\n      }else if (isalpha(ret[p])){\n\tret=ret+'*'+tmp;\n      }else ret+=tmp;\n    }\n  }\n  return ret;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-5;\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nstring ope = \"+-*^\";\nvector<double> variable(256);\n\nstring normalize(string s)\n{\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += ' ';\n        t += s[i];\n    }\n    s = t;\n\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\ndouble calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        istringstream iss(s);\n        double ret;\n        iss >> ret;\n        return ret;\n    }\n\n    if(n == 1)\n        return variable[s[0]];\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                if(i == 0)\n                    return calculate(t1) + calculate(t2);\n                else if(i == 1)\n                    return calculate(t1) - calculate(t2);\n                else if(i == 2)\n                    return calculate(t1) * calculate(t2);\n                else\n                    return pow(calculate(t1), calculate(t2));\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nstring solve(string s, string t)\n{\n    s = normalize(s);\n    t = normalize(t);\n\n    for(int i=0; i<50; ++i){\n        for(char c='a'; c<='z'; ++c)\n            variable[c] = (long long)xor128() / 10000.0;\n\n        double x = calculate(s);\n        double y = calculate(t);\n\n        if(abs(x) > EPS && abs(y) > EPS && abs(x-y) > max(abs(x), abs(y)) * EPS)\n            return \"no\";\n    }\n\n    return \"yes\";\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            cout << solve(s, t) << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nstring ope = \"+-*^\";\nvector<long long> variable(256);\n\nstring normalize(string s)\n{\n    // 連続するスペースを1つのスペースに変換、先頭と末尾のスペースを削除\n    int n = s.size();\n    string t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if(s[i] != ' ' || s[i-1] != ' ')\n            t += s[i];\n    }\n    if(t[0] == ' ')\n        t = t.substr(1);\n    if(t[t.size()-1] == ' ')\n        t = t.substr(0, t.size()-1);\n    s = t;\n\n    // 必要に応じて * を挿入する\n    n = s.size();\n    t = s.substr(0, 1);\n    for(int i=1; i<n; ++i){\n        if((isalnum(s[i-1]) || s[i-1] == ')') && (isalnum(s[i]) || s[i] == '(') && !(isdigit(s[i-1]) && isdigit(s[i])))\n            t += '*';\n        t += s[i];\n    }\n    s = t;\n\n    // スペースを * に変換、もしくは削除する\n    n = s.size();\n    t = \"\";\n    for(int i=0; i<n; ++i){\n        if(s[i] == ' '){\n            if(s[i-1] != '(' && s[i+1] != ')' && ope.find(s[i-1]) == string::npos && ope.find(s[i+1]) == string::npos)\n                t += '*';\n        }else{\n            t += s[i];\n        }\n    }\n\n    return t;\n}\n\nmap<vector<int>, long long> calculate(string s)\n{\n    int n = s.size();\n    \n    bool isNum = true;\n    for(int i=0; i<n; ++i){\n        if(!isdigit(s[i]))\n            isNum = false;\n    }\n    if(isNum){\n        map<vector<int>, long long> ret;\n        long long tmp = 0;\n        for(int i=0; i<n; ++i){\n            tmp *= 10;\n            tmp += s[i] - '0';\n        }\n        if(tmp != 0)\n            ret[vector<int>(26, 0)] = tmp;\n        return ret;\n    }\n\n    if(n == 1){\n        map<vector<int>, long long> ret;\n        vector<int> tmp(26, 0);\n        tmp[s[0]-'a'] = 1;\n        ret[tmp] = 1;\n        return ret;\n    }\n\n    for(int i=0; i<4; ++i){\n        int bracket = 0;\n        for(int j=n-1; j>=0; --j){\n            if(s[j] == '(')\n                ++ bracket;\n            else if(s[j] == ')')\n                -- bracket;\n            else if(s[j] == ope[i] && bracket == 0){\n                string t1 = s.substr(0, j);\n                string t2 = s.substr(j+1);\n                map<vector<int>, long long> a = calculate(t1);\n                map<vector<int>, long long> b = calculate(t2);\n\n                map<vector<int>, long long> ret;\n                if(i == 0){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it)\n                        ret[it->first] += it->second;\n                }else if(i == 1){\n                    ret = a;\n                    for(map<vector<int>, long long>::iterator it=b.begin(); it!=b.end(); ++it)\n                        ret[it->first] -= it->second;\n                }else if(i == 2){\n                    for(map<vector<int>, long long>::iterator it1=a.begin(); it1!=a.end(); ++it1){\n                        for(map<vector<int>, long long>::iterator it2=b.begin(); it2!=b.end(); ++it2){\n                            vector<int> tmp(26);\n                            for(int k=0; k<26; ++k)\n                                tmp[k] = it1->first[k] + it2->first[k];\n                            ret[tmp] += it1->second * it2->second;\n                        }\n                    }\n                }else{\n                    vector<int> tmp(26);\n                    for(int k=0; k<26; ++k)\n                        tmp[k] = a.begin()->first[k] * b.begin()->second;\n                    ret[tmp] = 1;\n                }\n\n                for(map<vector<int>, long long>::iterator it=ret.begin(); it!=ret.end(); ){\n                    map<vector<int>, long long>::iterator it2 = it;\n                    ++ it;\n                    if(it2->second == 0)\n                        ret.erase(it2);\n                }\n\n                return ret;\n            }\n        }\n    }\n\n    return calculate(s.substr(1, n-2));\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \".\")\n            return 0;\n\n        s = normalize(s);\n        map<vector<int>, long long> a = calculate(s);\n\n        for(;;){\n            string t;\n            getline(cin, t);\n            if(t == \".\")\n                break;\n\n            t = normalize(t);\n            map<vector<int>, long long> b = calculate(t);\n            if(a == b)\n                cout << \"yes\" << endl;\n            else\n                cout << \"no\" << endl;\n        }\n        cout << '.' << endl;\n    }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1233: Equals are Equals\n// 2017.12.23 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX 2000\n\n#define HSIZ 5003\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HSIZ+2], *hashend = hash + HSIZ;\n\nint lookup(char *s, int id)\n{\n\tint w = strlen(s);\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n#define INF 0x7fffffff\ntypedef struct { int c, var; } T; // var < 0: constants\nT ans[MAX]; int alen;\nT stu[MAX]; int slen;\nchar s[100];\nchar var[2500][265]; int sz;\n\nchar *parse();\n\nint cmp(char *a, char *b) { return (int)(*a - *b); }\n\nint norm(T *a, int len)\n{\n\tint i, j, f, tlen;\n\tT t[MAX];\n\n\tf = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (a[i].c == INF) continue;\n\t\tfor (j = i+1; j < len; j++) {\n\t\t\tif (a[j].c == INF) continue;\n\t\t\tif (a[j].var == a[i].var) a[i].c += a[j].c, a[j].c = INF, f = 1;\n\t\t}\n\t}\n\tif (!f) return len;\n\tmemcpy(t, a, sizeof(T)*len), tlen = len;\n\tlen = 0; for (j = 0; j < tlen; j++) {\n\t\tif (t[j].c == INF) continue;\n\t\ta[len].c = t[j].c, a[len++].var = t[j].var;\n\t}\n\treturn len;\n}\n\nint add(T *a, int alen, T *b, int blen, int op)\n{\n\tint i, j;\n\n\tfor (i = 0; i < blen; i++) {\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == alen) {\n\t\t\t\ta[alen].c = op ? b[i].c: -b[i].c;\n\t\t\t\ta[alen++].var = b[i].var;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (b[i].var == a[j].var) {\n\t\t\t\tif (op) a[j].c += b[i].c;\n\t\t\t\telse    a[j].c -= b[i].c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn alen;\n}\n\nint mul(T *a, int alen, T *b, int blen)\n{\n\tint i, j, id, tlen;\n\tT t[MAX];\n\tchar s[265], *p;\n\n\ttlen = 0;\n\tfor (i = 0; i < alen; i++) for (j = 0; j < blen; j++) {\n\t\tt[tlen].c = a[i].c * b[j].c;\n\t\tif (     a[i].var < 0) t[tlen].var = b[j].var;\n\t\telse if (b[j].var < 0) t[tlen].var = a[i].var;\n\t\telse {\n\t\t\tp = var[a[i].var], strcpy(s, p);\n\t\t\tp = var[b[j].var], strcat(s, p);\n\t\t\tqsort(s, strlen(s), 1, cmp);\n\t\t\tif (sz > 1500) return -1;\n\t\t\tstrcpy(var[sz], s);\n\t\t\tid = lookup(var[sz], sz);\n\t\t\tif (id < 0) id = sz++;\n\t\t\tt[tlen].var = id;\n\t\t}\n\t\ttlen++;\n\t}\n\tmemcpy(a, t, sizeof(T)*tlen);\n\treturn tlen;\n}\n\n\nint eq(T *a, int alen, T *b, int blen)\n{\n\tint i, j;\n\t\n\tfor (i = 0; i < alen; i++) {\n\t\tif (a[i].c == 0) continue;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == blen) return 0;\n\t\t\tif (a[i].var == b[j].var) {\n\t\t\t\tif (a[i].c != b[j].c) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < blen; i++) {\n\t\tif (b[i].c == 0) continue;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == alen) return 0;\n\t\t\tif (b[i].var == a[j].var) {\n\t\t\t\tif (b[i].c != a[j].c) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nchar *factor(T *q, int *len, char *p)\n{\n\tint c, x, w, id;\n\tchar a[265];\n\n\twhile (isspace(*p)) p++;\n\tif (*p == '(') {\n\t\tp++; while (isspace(*p)) p++;\n\t\tp = parse(q, len, p);\n\t\twhile (isspace(*p)) p++;\n\t\tif (*p == ')') p++;\n\t} else {\n\t\tw = 0, c = 1;\n\t\twhile (1) {\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tif (isdigit(*p)) {\n\t\t\t\tx = 0; while (isdigit(*p)) x = 10*x + (*p++ & 0xf);\n\t\t\t\tc *= x;\n\t\t\t} else if (isalpha(*p)) {\n\t\t\t\tid = *p++;\n\t\t\t\twhile (isspace(*p)) p++;\n\t\t\t\tx = 1;\n\t\t\t\tif (*p == '^') {\n\t\t\t\t\tp++;\n\t\t\t\t\twhile (isspace(*p)) p++;\n\t\t\t\t\tif (isdigit(*p)) {\n\t\t\t\t\t\tx = 0; while (isdigit(*p)) x = 10*x + (*p++ & 0xf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (x--) a[w++] = id;\n\t\t\t} else break;\n\t\t}\n\t\tif (w == 0) q[*len].var = -1;\n\t\telse {\n\t\t\tqsort(a, w, 1, cmp), a[w] = 0;\n\t\t\tstrcpy(var[sz], a);\n\t\t\tid = lookup(var[sz], sz);\n\t\t\tif (id < 0) id = sz++;\n\t\t\tq[*len].var = id;\n\t\t}\n\t\tq[*len].c = c;\n\t\t(*len)++;\n\t}\n\treturn p;\n}\n\nchar *term(T *q, int *len, char *p)\n{\n\tint tlen;\n\tT t[MAX];\n\n\tp = factor(q, len, p);\n\twhile (1) {\n\t\twhile (isspace(*p)) p++;\n\t\tif (*p == ')' || *p == '+' || *p == '-') break;\n\t\tif (*p < ' ') break;\n\t\ttlen = 0; p = factor(t, &tlen, p);\n\t\t*len = mul(q, *len, t, tlen);\n\t\tif (*len < 0) return NULL;\n\t\t*len = norm(q, *len);\n\t}\n\treturn p;\n}\n\nchar *parse(T *q, int *len, char *p)\n{\n\tint op, tlen;\n\tT t[MAX];\n\n\tif ((p = term(q, len, p)) == NULL) return NULL;\n\t*len = norm(q, *len);\n\twhile (1) {\n\t\twhile (isspace(*p)) p++;\n\t\tif      (*p == '+') op = 1;\n\t\telse if (*p == '-') op = 0;\n\t\telse break;\n\t\tp++;\n\t\ttlen = 0; \n\t\tif ((p = term(t, &tlen, p)) == NULL) return NULL;\n\t\t*len = add(q, *len, t, tlen, op);\n\t\t*len = norm(q, *len);\n\t}\n\treturn p;\n}\n\nint main()\n{\n\twhile (fgets(s, 100, stdin) && *s != '.') {\n\t\tmemset(hash, 0, sizeof(hash));\n\n\t\tsz = 0;\n\t\talen = 0; parse(ans, &alen, s);\n\t\talen = norm(ans, alen);\n\n\t\twhile (fgets(s, 100, stdin) && *s != '.') {\n\t\t\tslen = 0;\n\t\t\tif (parse(stu, &slen, s) == NULL) { puts(\"no\"); continue; }\n\t\t\tslen = norm(stu, slen);\n\n\t\t\tputs(eq(ans, alen, stu, slen)? \"yes\": \"no\");\n\t\t}\n\t\tputs(\".\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1233: Equals are Equals\n// 2017.12.23 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define HSIZ 199\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HSIZ+2], *hashend = hash + HSIZ;\n\nint lookup(char *s, int id)\n{\n\tint w = strlen(s);\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n#define INF 0x7fffffff\ntypedef struct { int c, var; } T; // var < 0: constants\nT ans[101]; int alen;\nT stu[101]; int slen;\nchar s[102];\nchar var[100][100]; int sz;\n\nchar *parse();\n\nint cmp(char *a, char *b) { return (int)(*a - *b); }\n\nint norm(T *a, int len)\n{\n\tint i, j, f, tlen;\n\tT t[101];\n\n\tf = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (a[i].c == INF) continue;\n\t\tfor (j = i+1; j < len; j++) {\n\t\t\tif (a[j].c == INF) continue;\n\t\t\tif (a[j].var == a[i].var) a[i].c += a[j].c, a[j].c = INF, f = 1;\n\t\t}\n\t}\n\tif (!f) return len;\n\tmemcpy(t, a, sizeof(T)*len), tlen = len;\n\tlen = 0; for (j = 0; j < tlen; j++) {\n\t\tif (t[j].c == INF) continue;\n\t\ta[len].c = t[j].c, a[len++].var = t[j].var;\n\t}\n\treturn len;\n}\n\nint add(T *a, int alen, T *b, int blen, int op)\n{\n\tint i, j;\n\n\tfor (i = 0; i < blen; i++) {\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == alen) {\n\t\t\t\ta[alen].c = op ? b[i].c: -b[i].c;\n\t\t\t\ta[alen++].var = b[i].var;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (b[i].var == a[j].var) {\n\t\t\t\tif (op) a[j].c += b[i].c;\n\t\t\t\telse    a[j].c -= b[i].c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn alen;\n}\n\nint mul(T *a, int alen, T *b, int blen)\n{\n\tint i, j, id, tlen;\n\tT t[101];\n\tchar s[100], *p;\n\n\ttlen = 0;\n\tfor (i = 0; i < alen; i++) for (j = 0; j < blen; j++) {\n\t\tt[tlen].c = a[i].c * a[j].c;\n\t\tif (     a[i].var < 0) t[tlen].var = b[j].var;\n\t\telse if (b[j].var < 0) t[tlen].var = a[i].var;\n\t\telse {\n\t\t\tp = var[a[i].var], strcpy(s, p);\n\t\t\tp = var[b[j].var], strcat(s, p);\n\t\t\tqsort(s, strlen(s), 1, cmp);\n\t\t\tstrcpy(var[sz], s);\n\t\t\tid = lookup(var[sz], sz);\n\t\t\tif (id < 0) id = sz++;\n\t\t\tt[tlen].var = id;\n\t\t}\n\t\ttlen++;\n\t}\n\tmemcpy(a, t, sizeof(T)*tlen);\n\talen = norm(a, tlen);\n\treturn alen;\n}\n\n\nint eq(T *a, int alen, T *b, int blen)\n{\n\tint i, j;\n\t\n\tfor (i = 0; i < alen; i++) {\n\t\tif (a[i].c == 0) continue;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == blen) return 0;\n\t\t\tif (a[i].var == b[j].var) {\n\t\t\t\tif (a[i].c != b[i].c) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < blen; i++) {\n\t\tif (b[i].c == 0) continue;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == alen) return 0;\n\t\t\tif (b[i].var == a[j].var) {\n\t\t\t\tif (b[i].c != a[j].c) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nchar *factor(T *q, int *len, char *p)\n{\n\tint c, x, w, id;\n\tchar a[100];\n\n\twhile (isspace(*p)) p++;\n\tif (*p == '(') {\n\t\tp++; while (isspace(*p)) p++;\n\t\tp = parse(q, len, p);\n\t\twhile (isspace(*p)) p++;\n\t\tif (*p == ')') p++;\n\t} else {\n\t\tw = 0, c = 1;\n\t\twhile (1) {\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tif (isdigit(*p)) {\n\t\t\t\tx = 0; while (isdigit(*p)) x = 10*x + (*p++ & 0xf);\n\t\t\t\tc *= x;\n\t\t\t} else if (isalpha(*p)) {\n\t\t\t\tid = *p++;\n\t\t\t\twhile (isspace(*p)) p++;\n\t\t\t\tx = 1;\n\t\t\t\tif (*p == '^') {\n\t\t\t\t\tp++;\n\t\t\t\t\twhile (isspace(*p)) p++;\n\t\t\t\t\tif (isdigit(*p)) {\n\t\t\t\t\t\tx = 0; while (isdigit(*p)) x = 10*x + (*p++ & 0xf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (x--) a[w++] = id;\n\t\t\t} else break;\n\t\t}\n\t\tif (w == 0) q[*len].var = -1;\n\t\telse {\n\t\t\tqsort(a, w, 1, cmp), a[w] = 0;\n\t\t\tstrcpy(var[sz], a);\n\t\t\tid = lookup(var[sz], sz);\n\t\t\tif (id < 0) id = sz++;\n\t\t\tq[*len].var = id;\n\t\t}\n\t\tq[*len].c = c;\n\t\t(*len)++;\n\t}\n\treturn p;\n}\n\nchar *term(T *q, int *len, char *p)\n{\n\tint tlen;\n\tT t[101];\n\n\tp = factor(q, len, p);\n\twhile (1) {\n\t\twhile (isspace(*p)) p++;\n\t\tif (*p == '(' || *p == ')' || *p == '+' || *p == '-') break;\n\t\tif (*p < ' ') break;\n\t\ttlen = 0; p = factor(t, &tlen, p);\n\t\t*len = mul(q, *len, t, tlen);\n\t}\n\treturn p;\n}\n\nchar *parse(T *q, int *len, char *p)\n{\n\tint op, tlen;\n\tT t[101];\n\n\tp = term(q, len, p);\n\t*len = norm(q, *len);\n\twhile (1) {\n\t\twhile (isspace(*p)) p++;\n\t\tif      (*p == '+') op = 1;\n\t\telse if (*p == '-') op = 0;\n\t\telse break;\n\t\tp++;\n\t\ttlen = 0; p = term(t, &tlen, p);\n\t\t*len = add(q, *len, t, tlen, op);\n\t\t*len = norm(q, *len);\n\t}\n\treturn p;\n}\n\nint main()\n{\n\twhile (fgets(s, 100, stdin) && *s != '.') {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\talen = 0; parse(ans, &alen, s);\n\t\talen = norm(ans, alen);\n\n\t\twhile (fgets(s, 100, stdin) && *s != '.') {\n\t\t\tslen = 0; parse(stu, &slen, s);\n\t\t\tslen = norm(stu, slen);\n\n\t\t\tputs(eq(ans, alen, stu, slen) ? \"yes\" : \"no\");\n\t\t}\n\t\tputs(\".\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Equals are Equals\npublic class Main{\n\n\tchar[] s;\n\tint id;\n\t\n\tclass P{\n\t\tMap<String, Integer> c;\n\t\tint c0;\n\t\tpublic P() {\n\t\t\tc = new HashMap<String, Integer>();\n\t\t\tc0 = 0;\n\t\t}\n\t\tboolean eq(P p){\n\t\t\tif(c.size()!=p.c.size()||c0!=p.c0)return false;\n\t\t\tfor(String t:c.keySet())if(!p.c.containsKey(t)||c.get(t)!=p.c.get(t))return false;\n\t\t\treturn true;\n\t\t}\n\t\tP add(P p){\n//\t\t\tSystem.out.println(\"ADD:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String t:c.keySet()){\n\t\t\t\tif(p.c.containsKey(t))r.c.put(t, c.get(t)+p.c.get(t));\n\t\t\t\telse r.c.put(t, c.get(t));\n\t\t\t}\n\t\t\tfor(String t:p.c.keySet()){\n\t\t\t\tif(!c.containsKey(t))r.c.put(t, p.c.get(t));\n\t\t\t}\n\t\t\tr.c0 = c0+p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP sub(P p){\n//\t\t\tSystem.out.println(\"SUB:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String t:c.keySet()){\n\t\t\t\tif(p.c.containsKey(t))r.c.put(t, c.get(t)-p.c.get(t));\n\t\t\t\telse r.c.put(t, c.get(t));\n\t\t\t}\n\t\t\tfor(String t:p.c.keySet()){\n\t\t\t\tif(!c.containsKey(t))r.c.put(t, -p.c.get(t));\n\t\t\t}\n\t\t\tr.c0 = c0-p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP mul(P p){\n//\t\t\tSystem.out.println(\"MUL:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String s:c.keySet())for(String t:p.c.keySet()){\n\t\t\t\tchar[] x = (s+t).toCharArray();\n\t\t\t\tArrays.sort(x);\n\t\t\t\tString v = new String(x);\n\t\t\t\tif(r.c.containsKey(v))r.c.put(v, r.c.get(v)+c.get(s)*p.c.get(t));\n\t\t\t\telse r.c.put(v, c.get(s)*p.c.get(t));\n\t\t\t}\n//\t\t\tSystem.out.println(\"R1:\" + r);\n\t\t\tfor(String s:c.keySet()){\n\t\t\t\tif(r.c.containsKey(s))r.c.put(s, r.c.get(s)+p.c0*c.get(s));\n\t\t\t\telse r.c.put(s, p.c0*c.get(s));\n\t\t\t}\n\t\t\tfor(String s:p.c.keySet()){\n\t\t\t\tif(r.c.containsKey(s))r.c.put(s, r.c.get(s)+c0*p.c.get(s));\n\t\t\t\telse r.c.put(s, c0*p.c.get(s));\n\t\t\t}\n\t\t\tr.c0 += c0*p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP pow(int k){\n//\t\t\tSystem.out.println(\"POW:\" + this + \" \" + k);\n\t\t\tP r = new P();\n\t\t\tr.c0 = 1;\n\t\t\twhile(k--!=0)r = r.mul(this);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tfor(String t:c.keySet())r+=\" \"+c.get(t)+t;\n\t\t\tr+=\" \"+c0;\n\t\t\treturn r;\n\t\t}\n\t}\n\t\n\tchar get(){\n//\t\tSystem.out.println(s[id]);\n\t\treturn s[id++];\n\t}\n\tchar next(){\n\t\twhile(s[id]==' ')id++;\n//\t\tSystem.out.println(s[id]);\n\t\treturn s[id++];\n\t}\n\t\n\tP exp(){\n\t\tP r = term();\n\t\tchar ch = next(); \n\t\twhile(ch=='+'||ch=='-'){\n//\t\t\tSystem.out.println(\"CH:\" + ch);\n\t\t\tP f = term();\n//\t\t\tSystem.out.println(f);\n\t\t\tif(ch=='+')r = r.add(f);\n\t\t\telse r = r.sub(f);\n//\t\t\tSystem.out.println(\"RRR:\" + r);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tP term(){\n\t\tP r = fact();\n\t\tchar ch = next();\n\t\twhile(Character.isDigit(ch)||Character.isLowerCase(ch)||ch=='('){\n//\t\t\tSystem.out.println(\"Term char:\" + ch);\n\t\t\tid--;\n\t\t\tP f = fact();\n//\t\t\tSystem.out.println(\"F:\" + f);\n\t\t\tr = r.mul(f);\n//\t\t\tSystem.out.println(\"MUL : \" + r);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n//\t\tSystem.out.println(\"Term end with: \" + s[id]);\n\t\treturn r;\n\t}\n\t\n\tP fact(){\n\t\tchar ch = next();\n//\t\tSystem.out.println(\"INIT: \" + ch);\n\t\tP r = new P();\n\t\tif(ch=='('){\n\t\t\tr = exp();\n\t\t\tnext();\n\t\t}\n\t\telse if(Character.isLowerCase(ch))r.c.put(ch+\"\", 1);\n\t\telse if(Character.isDigit(ch)){\n\t\t\tint x = ch-'0';\n\t\t\tfor(;;){\n\t\t\t\tch = get();\n\t\t\t\tif(!Character.isDigit(ch)){\n\t\t\t\t\tid--;break;\n\t\t\t\t}\n\t\t\t\tx = x*10 + ch-'0';\n\t\t\t}\n//\t\t\tSystem.out.println(\"X:\" + x);\n\t\t\tr.c0 = x;\n\t\t}\n//\t\tSystem.out.println(\"R0:\" + r);\n\t\tch = next();\n\t\twhile(ch=='^'){\n\t\t\tint x = next()-'0';\n\t\t\tr = r.pow(x);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n//\t\tSystem.out.println(\"Fact end with: \" + s[id]);\n\t\treturn r;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\tif(s[0]=='.')break;\n\t\t\tid = 0;\n\t\t\tP ans = exp();\n//\t\t\tSystem.out.println(\"ANS:\" + ans);\n\t\t\tfor(;;){\n\t\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\t\tif(s[0]=='.')break;\n\t\t\t\tid = 0;\n\t\t\t\tP p = exp();\n//\t\t\t\tSystem.out.println(\"Pol:\" + p);\n\t\t\t\tSystem.out.println(ans.eq(p)?\"yes\":\"no\");\n\t\t\t}\n\t\t\tSystem.out.println(\".\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Equals are Equals\npublic class Main{\n\n\tchar[] s;\n\tint id;\n\t\n\tclass P{\n\t\tMap<String, Integer> c;\n\t\tint c0;\n\t\tpublic P() {\n\t\t\tc = new HashMap<String, Integer>();\n\t\t\tc0 = 0;\n\t\t}\n\t\tboolean eq(P p){\n\t\t\tif(c.size()!=p.c.size()||c0!=p.c0)return false;\n\t\t\tfor(String t:c.keySet())if(!p.c.containsKey(t)||c.get(t)!=p.c.get(t))return false;\n\t\t\treturn true;\n\t\t}\n\t\tP add(P p){\n//\t\t\tSystem.out.println(\"ADD:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String t:c.keySet()){\n\t\t\t\tif(p.c.containsKey(t))r.c.put(t, c.get(t)+p.c.get(t));\n\t\t\t\telse r.c.put(t, c.get(t));\n\t\t\t}\n\t\t\tfor(String t:p.c.keySet()){\n\t\t\t\tif(!c.containsKey(t))r.c.put(t, p.c.get(t));\n\t\t\t}\n\t\t\tr.c0 = c0+p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP sub(P p){\n//\t\t\tSystem.out.println(\"SUB:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String t:c.keySet()){\n\t\t\t\tif(p.c.containsKey(t))r.c.put(t, c.get(t)-p.c.get(t));\n\t\t\t\telse r.c.put(t, c.get(t));\n\t\t\t}\n\t\t\tfor(String t:p.c.keySet()){\n\t\t\t\tif(!c.containsKey(t))r.c.put(t, -p.c.get(t));\n\t\t\t}\n\t\t\tr.c0 = c0-p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP mul(P p){\n//\t\t\tSystem.out.println(\"MUL:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String s:c.keySet())for(String t:p.c.keySet()){\n\t\t\t\tchar[] x = (s+t).toCharArray();\n\t\t\t\tArrays.sort(x);\n\t\t\t\tString v = new String(x);\n\t\t\t\tif(r.c.containsKey(v))r.c.put(v, r.c.get(v)+c.get(s)*p.c.get(t));\n\t\t\t\telse r.c.put(v, c.get(s)*p.c.get(t));\n\t\t\t}\n//\t\t\tSystem.out.println(\"R1:\" + r);\n\t\t\tfor(String s:c.keySet()){\n\t\t\t\tif(r.c.containsKey(s))r.c.put(s, r.c.get(s)+p.c0*c.get(s));\n\t\t\t\telse r.c.put(s, p.c0*c.get(s));\n\t\t\t}\n\t\t\tfor(String s:p.c.keySet()){\n\t\t\t\tif(r.c.containsKey(s))r.c.put(s, r.c.get(s)+c0*p.c.get(s));\n\t\t\t\telse r.c.put(s, c0*p.c.get(s));\n\t\t\t}\n\t\t\tr.c0 += c0*p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP pow(int k){\n//\t\t\tSystem.out.println(\"POW:\" + this + \" \" + k);\n\t\t\tP r = new P();\n\t\t\tr.c0 = 1;\n\t\t\twhile(k--!=0)r = r.mul(this);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n\t\t\treturn r;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tfor(String t:c.keySet())r+=\" \"+c.get(t)+t;\n\t\t\tr+=\" \"+c0;\n\t\t\treturn r;\n\t\t}\n\t}\n\t\n\tchar get(){\n//\t\tSystem.out.println(s[id]);\n\t\treturn s[id++];\n\t}\n\tchar next(){\n\t\twhile(s[id]==' ')id++;\n//\t\tSystem.out.println(s[id]);\n\t\treturn s[id++];\n\t}\n\t\n\tP exp(){\n\t\tP r = term();\n\t\tchar ch = next(); \n\t\twhile(ch=='+'||ch=='-'){\n//\t\t\tSystem.out.println(\"CH:\" + ch);\n\t\t\tP f = term();\n//\t\t\tSystem.out.println(f);\n\t\t\tif(ch=='+')r = r.add(f);\n\t\t\telse r = r.sub(f);\n//\t\t\tSystem.out.println(\"RRR:\" + r);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tP term(){\n\t\tP r = fact();\n\t\tchar ch = next();\n\t\twhile(Character.isDigit(ch)||Character.isLowerCase(ch)||ch=='('){\n//\t\t\tSystem.out.println(\"Term char:\" + ch);\n\t\t\tid--;\n\t\t\tP f = fact();\n//\t\t\tSystem.out.println(\"F:\" + f);\n\t\t\tr = r.mul(f);\n//\t\t\tSystem.out.println(\"MUL : \" + r);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n//\t\tSystem.out.println(\"Term end with: \" + s[id]);\n\t\treturn r;\n\t}\n\t\n\tP fact(){\n\t\tchar ch = next();\n//\t\tSystem.out.println(\"INIT: \" + ch);\n\t\tP r = new P();\n\t\tif(ch=='('){\n\t\t\tr = exp();\n\t\t\tnext();\n\t\t}\n\t\telse if(Character.isLowerCase(ch))r.c.put(ch+\"\", 1);\n\t\telse if(Character.isDigit(ch)){\n\t\t\tint x = ch-'0';\n\t\t\tfor(;;){\n\t\t\t\tch = get();\n\t\t\t\tif(!Character.isDigit(ch)){\n\t\t\t\t\tid--;break;\n\t\t\t\t}\n\t\t\t\tx = x*10 + ch-'0';\n\t\t\t}\n//\t\t\tSystem.out.println(\"X:\" + x);\n\t\t\tr.c0 = x;\n\t\t}\n//\t\tSystem.out.println(\"R0:\" + r);\n\t\tch = next();\n\t\twhile(ch=='^'){\n\t\t\tint x = next()-'0';\n\t\t\tr = r.pow(x);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n//\t\tSystem.out.println(\"Fact end with: \" + s[id]);\n\t\treturn r;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\tif(s[0]=='.')break;\n\t\t\tid = 0;\n\t\t\tP ans = exp();\n//\t\t\tSystem.out.println(\"ANS:\" + ans);\n\t\t\tfor(;;){\n\t\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\t\tif(s[0]=='.')break;\n\t\t\t\tid = 0;\n\t\t\t\tP p = exp();\n//\t\t\t\tSystem.out.println(\"Pol:\" + p);\n\t\t\t\tSystem.out.println(ans.eq(p)?\"yes\":\"no\");\n\t\t\t}\n\t\t\tSystem.out.println(\".\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Equals are Equals\npublic class Main{\n\n\tchar[] s;\n\tint id;\n\t\n\tclass P{\n\t\tMap<String, Integer> c;\n\t\tint c0;\n\t\tpublic P() {\n\t\t\tc = new HashMap<String, Integer>();\n\t\t\tc0 = 0;\n\t\t}\n\t\tboolean eq(P p){\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:c.keySet())if(c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)c.remove(t);\n\t\t\tset = new HashSet<String>();\n\t\t\tfor(String t:p.c.keySet())if(p.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)p.c.remove(t);\n//\t\t\tSystem.out.println(\"P1:\" + this + \" P2:\" + p);\n//\t\t\tSystem.out.println(c.size()+\" \"+p.c.size() + \" \" + c0 + \" \" + p.c0);\n\t\t\tif(c.size()!=p.c.size()||c0!=p.c0){\n//\t\t\t\tSystem.out.println(\"DIFF22:\" + c.size() + \" \" + p.c.size() + \" \" + c0 + \" \"  +p.c0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor(String t:c.keySet())if(!p.c.containsKey(t)||c.get(t).intValue()!=p.c.get(t).intValue()){\n//\t\t\t\tSystem.out.println(\"DIFF:\" + c.get(t)+\" \"+p.c.get(t));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tP add(P p){\n//\t\t\tSystem.out.println(\"ADD:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String t:c.keySet()){\n\t\t\t\tif(p.c.containsKey(t))r.c.put(t, c.get(t)+p.c.get(t));\n\t\t\t\telse r.c.put(t, c.get(t));\n\t\t\t}\n\t\t\tfor(String t:p.c.keySet()){\n\t\t\t\tif(!c.containsKey(t))r.c.put(t, p.c.get(t));\n\t\t\t}\n\t\t\tr.c0 = c0+p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP sub(P p){\n//\t\t\tSystem.out.println(\"SUB:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String t:c.keySet()){\n\t\t\t\tif(p.c.containsKey(t))r.c.put(t, c.get(t)-p.c.get(t));\n\t\t\t\telse r.c.put(t, c.get(t));\n\t\t\t}\n\t\t\tfor(String t:p.c.keySet()){\n\t\t\t\tif(!c.containsKey(t))r.c.put(t, -p.c.get(t));\n\t\t\t}\n\t\t\tr.c0 = c0-p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP mul(P p){\n//\t\t\tSystem.out.println(\"MUL:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String s:c.keySet())for(String t:p.c.keySet()){\n\t\t\t\tchar[] x = (s+t).toCharArray();\n\t\t\t\tArrays.sort(x);\n\t\t\t\tString v = new String(x);\n\t\t\t\tif(r.c.containsKey(v))r.c.put(v, r.c.get(v)+c.get(s)*p.c.get(t));\n\t\t\t\telse r.c.put(v, c.get(s)*p.c.get(t));\n\t\t\t}\n//\t\t\tSystem.out.println(\"R1:\" + r);\n\t\t\tfor(String s:c.keySet()){\n\t\t\t\tif(r.c.containsKey(s))r.c.put(s, r.c.get(s)+p.c0*c.get(s));\n\t\t\t\telse r.c.put(s, p.c0*c.get(s));\n\t\t\t}\n\t\t\tfor(String s:p.c.keySet()){\n\t\t\t\tif(r.c.containsKey(s))r.c.put(s, r.c.get(s)+c0*p.c.get(s));\n\t\t\t\telse r.c.put(s, c0*p.c.get(s));\n\t\t\t}\n\t\t\tr.c0 += c0*p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP pow(int k){\n//\t\t\tSystem.out.println(\"POW:\" + this + \" \" + k);\n\t\t\tP r = new P();\n\t\t\tr.c0 = 1;\n\t\t\twhile(k--!=0)r = r.mul(this);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n\t\t\treturn r;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tfor(String t:c.keySet())r+=\" \"+c.get(t)+t;\n\t\t\tr+=\" \"+c0;\n\t\t\treturn r;\n\t\t}\n\t}\n\t\n\tchar get(){\n//\t\tSystem.out.println(s[id]);\n\t\treturn s[id++];\n\t}\n\tchar next(){\n\t\twhile(s[id]==' ')id++;\n//\t\tSystem.out.println(s[id]);\n\t\treturn s[id++];\n\t}\n\t\n\tP exp(){\n\t\tP r = term();\n\t\tchar ch = next(); \n\t\twhile(ch=='+'||ch=='-'){\n//\t\t\tSystem.out.println(\"CH:\" + ch);\n\t\t\tP f = term();\n//\t\t\tSystem.out.println(f);\n\t\t\tif(ch=='+')r = r.add(f);\n\t\t\telse r = r.sub(f);\n//\t\t\tSystem.out.println(\"RRR:\" + r);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tP term(){\n\t\tP r = fact();\n\t\tchar ch = next();\n\t\twhile(Character.isDigit(ch)||Character.isLowerCase(ch)||ch=='('){\n//\t\t\tSystem.out.println(\"Term char:\" + ch);\n\t\t\tid--;\n\t\t\tP f = fact();\n//\t\t\tSystem.out.println(\"F:\" + f);\n\t\t\tr = r.mul(f);\n//\t\t\tSystem.out.println(\"MUL : \" + r);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n//\t\tSystem.out.println(\"Term end with: \" + s[id]);\n\t\treturn r;\n\t}\n\t\n\tP fact(){\n\t\tchar ch = next();\n//\t\tSystem.out.println(\"INIT: \" + ch);\n\t\tP r = new P();\n\t\tif(ch=='('){\n\t\t\tr = exp();\n\t\t\tnext();\n\t\t}\n\t\telse if(Character.isLowerCase(ch))r.c.put(ch+\"\", 1);\n\t\telse if(Character.isDigit(ch)){\n\t\t\tint x = ch-'0';\n\t\t\tfor(;;){\n\t\t\t\tch = get();\n\t\t\t\tif(!Character.isDigit(ch)){\n\t\t\t\t\tid--;break;\n\t\t\t\t}\n\t\t\t\tx = x*10 + ch-'0';\n\t\t\t}\n//\t\t\tSystem.out.println(\"X:\" + x);\n\t\t\tr.c0 = x;\n\t\t}\n//\t\tSystem.out.println(\"R0:\" + r);\n\t\tch = next();\n\t\twhile(ch=='^'){\n\t\t\tint x = next()-'0';\n\t\t\tr = r.pow(x);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n//\t\tSystem.out.println(\"Fact end with: \" + s[id]);\n\t\treturn r;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\tif(s[0]=='.')break;\n\t\t\tid = 0;\n\t\t\tP ans = exp();\n//\t\t\tSystem.out.println(\"ANS:\" + ans);\n\t\t\tfor(;;){\n\t\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\t\tif(s[0]=='.')break;\n\t\t\t\tid = 0;\n\t\t\t\tP p = exp();\n//\t\t\t\tSystem.out.println(\"Pol:\" + p);\n\t\t\t\tSystem.out.println(ans.eq(p)?\"yes\":\"no\");\n\t\t\t}\n\t\t\tSystem.out.println(\".\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Equals are Equals\npublic class Main{\n\n\tchar[] s;\n\tint id;\n\t\n\tclass P{\n\t\tMap<String, Integer> c;\n\t\tint c0;\n\t\tpublic P() {\n\t\t\tc = new HashMap<String, Integer>();\n\t\t\tc0 = 0;\n\t\t}\n\t\tboolean eq(P p){\n\t\t\tif(c.size()!=p.c.size()||c0!=p.c0)return false;\n\t\t\tfor(String t:c.keySet())if(!p.c.containsKey(t)||!c.get(t).equals(p.c.get(t)))return false;\n\t\t\treturn true;\n\t\t}\n\t\tP add(P p){\n\t\t\tP r = new P();\n\t\t\tfor(String t:c.keySet()){\n\t\t\t\tif(p.c.containsKey(t))r.c.put(t, c.get(t)+p.c.get(t));\n\t\t\t\telse r.c.put(t, c.get(t));\n\t\t\t}\n\t\t\tfor(String t:p.c.keySet()){\n\t\t\t\tif(!c.containsKey(t))r.c.put(t, p.c.get(t));\n\t\t\t}\n\t\t\tr.c0 = c0+p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n\t\t\treturn r;\n\t\t}\n\t\tP sub(P p){\n\t\t\tP r = new P();\n\t\t\tfor(String t:c.keySet()){\n\t\t\t\tif(p.c.containsKey(t))r.c.put(t, c.get(t)-p.c.get(t));\n\t\t\t\telse r.c.put(t, c.get(t));\n\t\t\t}\n\t\t\tfor(String t:p.c.keySet()){\n\t\t\t\tif(!c.containsKey(t))r.c.put(t, -p.c.get(t));\n\t\t\t}\n\t\t\tr.c0 = c0-p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n\t\t\treturn r;\n\t\t}\n\t\tP mul(P p){\n\t\t\tP r = new P();\n\t\t\tfor(String s:c.keySet())for(String t:p.c.keySet()){\n\t\t\t\tchar[] x = (s+t).toCharArray();\n\t\t\t\tArrays.sort(x);\n\t\t\t\tString v = new String(x);\n\t\t\t\tif(r.c.containsKey(v))r.c.put(v, r.c.get(v)+c.get(s)*p.c.get(t));\n\t\t\t\telse r.c.put(v, c.get(s)*p.c.get(t));\n\t\t\t}\n\t\t\tfor(String s:c.keySet()){\n\t\t\t\tif(r.c.containsKey(s))r.c.put(s, r.c.get(s)+p.c0*c.get(s));\n\t\t\t\telse r.c.put(s, p.c0*c.get(s));\n\t\t\t}\n\t\t\tfor(String s:p.c.keySet()){\n\t\t\t\tif(r.c.containsKey(s))r.c.put(s, r.c.get(s)+c0*p.c.get(s));\n\t\t\t\telse r.c.put(s, c0*p.c.get(s));\n\t\t\t}\n\t\t\tr.c0 += c0*p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n\t\t\treturn r;\n\t\t}\n\t\tP pow(int k){\n\t\t\tP r = new P();\n\t\t\tr.c0 = 1;\n\t\t\twhile(k--!=0)r = r.mul(this);\n//\t\t\tSet<String> set = new HashSet<String>();\n//\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n//\t\t\tfor(String t:set)r.c.remove(t);\n\t\t\treturn r;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tfor(String t:c.keySet())r+=\" \"+c.get(t)+t;\n\t\t\tr+=\" \"+c0;\n\t\t\treturn r;\n\t\t}\n\t}\n\t\n\tchar get(){\n\t\treturn s[id++];\n\t}\n\tchar next(){\n\t\twhile(s[id]==' ')id++;\n\t\treturn s[id++];\n\t}\n\t\n\tP exp(){\n\t\tP r = term();\n\t\tchar ch = next(); \n\t\twhile(ch=='+'||ch=='-'){\n\t\t\tP f = term();\n\t\t\tif(ch=='+')r = r.add(f);\n\t\t\telse r = r.sub(f);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tP term(){\n\t\tP r = fact();\n\t\tchar ch = next();\n\t\twhile(Character.isDigit(ch)||Character.isLowerCase(ch)||ch=='('){\n\t\t\tid--;\n\t\t\tP f = fact();\n\t\t\tr = r.mul(f);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tP fact(){\n\t\tchar ch = next();\n\t\tP r = new P();\n\t\tif(ch=='('){\n\t\t\tr = exp();\n\t\t\tnext();\n\t\t}\n\t\telse if(Character.isLowerCase(ch))r.c.put(ch+\"\", 1);\n\t\telse if(Character.isDigit(ch)){\n\t\t\tint x = ch-'0';\n\t\t\tfor(;;){\n\t\t\t\tch = get();\n\t\t\t\tif(!Character.isDigit(ch)){\n\t\t\t\t\tid--;break;\n\t\t\t\t}\n\t\t\t\tx = x*10 + ch-'0';\n\t\t\t}\n\t\t\tr.c0 = x;\n\t\t}\n\t\tch = next();\n\t\twhile(ch=='^'){\n\t\t\tint x = next()-'0';\n\t\t\tr = r.pow(x);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\tif(s[0]=='.')break;\n\t\t\tid = 0;\n\t\t\tP ans = exp();\n\t\t\tfor(;;){\n\t\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\t\tif(s[0]=='.')break;\n\t\t\t\tid = 0;\n\t\t\t\tP p = exp();\n\t\t\t\tSystem.out.println(ans.eq(p)?\"yes\":\"no\");\n\t\t\t}\n\t\t\tSystem.out.println(\".\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main{\n\tpublic void solve() throws Exception{\n\t\tBufferedReader buf = new BufferedReader(new InputStreamReader(System.in));\n\t\tString exp;\n\t\tParser parser = new Parser();\n\t\twhile(!(exp = buf.readLine()).equals(\".\")){\n\t\t\tPolynomial poly = parser.parse(exp);\n\t\t\tString str;\n\t\t\twhile(!(str = buf.readLine()).equals(\".\")){\n\t\t\t\tPolynomial p2 = parser.parse(str);\n\t\t\t\tif(poly.compareTo(p2) == 0){\n\t\t\t\t\tSystem.out.println(\"yes\");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"no\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\".\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\tnew Main().solve();\n\t}\n}\n\nclass Factor implements Comparable<Factor>{\n\tchar variable;\n\tint pow;\n\tpublic Factor(char var, int pow){\n\t\tthis.variable = var;\n\t\tthis.pow = pow;\n\t}\n\t@Override\n\tpublic int compareTo(Factor o) {\n\t\tif(variable != o.variable) return Character.compare(variable, o.variable);\n\t\telse return Integer.compare(pow, o.pow);\n\t}\n\t\n\tpublic Factor copy(){\n\t\treturn new Factor(variable, pow);\n\t}\n\tpublic String toString(){\n\t\treturn variable + \"^\" + pow;\n\t}\n}\n\nclass Term implements Comparable<Term>{\n\tArrayList<Factor> facts;\n\tint num;\n\t\n\tprivate Term(){\n\t\tfacts = new ArrayList<>();\n\t}\n\t\n\tpublic Term(int num){\n\t\tfacts = new ArrayList<>();\n\t\tthis.num = num;\n\t}\n\tpublic Term(int num, Factor fact){\n\t\tthis.num = num;\n\t\tfacts = new ArrayList<>();\n\t\tfacts.add(fact);\n\t}\n\t\n\tpublic Term mul(Term t){\n\t\tTerm ret = new Term();\n\t\tret.num = num * t.num;\n\t\tif(ret.num == 0) return ret;\n\t\tArrayList<Factor> tmp = new ArrayList<>(facts);\n\t\ttmp.addAll(t.facts);\n\t\tCollections.sort(tmp);\n\t\tint idx = 0;\n\t\twhile(idx < tmp.size()){\n\t\t\tFactor f = tmp.get(idx).copy();\n\t\t\tidx++;\n\t\t\twhile(idx < tmp.size() && tmp.get(idx).variable == f.variable){\n\t\t\t\tf.pow += tmp.get(idx).pow;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tret.facts.add(f);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic Term copy(){\n\t\tTerm ret = new Term(num);\n\t\tfor(Factor f : facts){\n\t\t\tret.facts.add(f.copy());\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic int compareTo(Term o) {\n\t\tint idx = 0;\n\t\twhile(true){\n\t\t\tif(idx < facts.size()&& idx < o.facts.size()){\n\t\t\t\tFactor f1 = facts.get(idx);\n\t\t\t\tFactor f2 = o.facts.get(idx);\n\t\t\t\tif(f1.variable != f2.variable) return Character.compare(f1.variable, f2.variable);\n\t\t\t\tif(f1.pow != f2.pow) return Integer.compare(f1.pow, f2.pow);\n\t\t\t\tidx++;\n\t\t\t}else{\n\t\t\t\tif(facts.size() == o.facts.size()){\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(idx >= facts.size()){\n\t\t\t\t\treturn -1;\n\t\t\t\t}else{\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic String toString(){\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append(num);\n\t\tfor(Factor f : facts){\n\t\t\tbuild.append(\" \");\n\t\t\tbuild.append(f.toString());\n\t\t}\n\t\treturn build.toString();\n\t}\n}\n\npublic class Polynomial implements Comparable<Polynomial>{\n\tArrayList<Term> terms;\n\tprivate Polynomial(){\n\t\tterms = new ArrayList<>();\n\t}\n\tpublic Polynomial(Term t){\n\t\tthis();\n\t\tif(t.num != 0){\n\t\t\tterms.add(t);\n\t\t}\n\t}\n\tpublic Polynomial add(Polynomial p){\n\t\tPolynomial ret = new Polynomial();\n\t\tArrayList<Term> tmp = new ArrayList<>();\n\t\ttmp.addAll(terms);\n\t\ttmp.addAll(p.terms);\n\t\tCollections.sort(tmp);\n\n\t\tint idx = 0;\n\t\twhile(idx < tmp.size()){\n\t\t\tTerm f = tmp.get(idx).copy();\n\t\t\tidx++;\n\t\t\twhile(idx < tmp.size() && tmp.get(idx).compareTo(f) == 0){\n\t\t\t\tf.num += tmp.get(idx).num;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tif(f.num != 0){\n\t\t\t\tret.terms.add(f);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n\tpublic Polynomial sub(Polynomial p){\n\t\tPolynomial ret = new Polynomial();\n\t\tArrayList<Term> tmp = new ArrayList<>();\n\t\ttmp.addAll(terms);\n\t\tfor(Term t: p.terms){\n\t\t\tTerm tt = t.copy();\n\t\t\ttt.num*=-1;\n\t\t\ttmp.add(tt);\n\t\t}\n\t\tCollections.sort(tmp);\n\n\t\tint idx = 0;\n\t\twhile(idx < tmp.size()){\n\t\t\tTerm f = tmp.get(idx).copy();\n\t\t\tidx++;\n\t\t\twhile(idx < tmp.size() && tmp.get(idx).compareTo(f) == 0){\n\t\t\t\tf.num += tmp.get(idx).num;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tif(f.num != 0){\n\t\t\t\tret.terms.add(f);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic Polynomial mul(Polynomial p){\n\t\tPolynomial ret = new Polynomial();\n\t\tArrayList<Term> tmp = new ArrayList<>();\n\t\tfor(Term t1 : terms){\n\t\t\tfor(Term t2 : p.terms){\n\t\t\t\ttmp.add(t1.mul(t2));\n\t\t\t}\n\t\t}\n\t\tCollections.sort(tmp);\n\n\t\tint idx = 0;\n\t\twhile(idx < tmp.size()){\n\t\t\tTerm f = tmp.get(idx).copy();\n\t\t\tidx++;\n\t\t\twhile(idx < tmp.size() && tmp.get(idx).compareTo(f) == 0){\n\t\t\t\tf.num += tmp.get(idx).num;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tif(f.num != 0){\n\t\t\t\tret.terms.add(f);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t@Override\n\tpublic int compareTo(Polynomial o) {\n\t\tint idx = 0;\n\t\twhile(idx < terms.size()&& idx < o.terms.size()){\n\t\t\tTerm f1 = terms.get(idx);\n\t\t\tTerm f2 = o.terms.get(idx);\n\t\t\tint comp = f1.compareTo(f2);\n\t\t\tif(comp != 0) return comp;\n\t\t\tif(f1.num != f2.num) return Integer.compare(f1.num, f2.num);\n\t\t\tidx++;\n\t\t}\n\t\tif(terms.size() == o.terms.size()){\n\t\t\treturn 0;\n\t\t}else if(idx >= terms.size()){\n\t\t\treturn -1;\n\t\t}else{\n\t\t\treturn 1;\n\t\t}\n\t}\n\t\n\tpublic String toString(){\n\t\tStringBuilder build = new StringBuilder();\n\t\tboolean flg = false;\n\t\tfor(Term f : terms){\n\t\t\tif(flg) {\n\t\t\t\tbuild.append(\" \");\n\t\t\t\tif(f.num >= 0){\n\t\t\t\t\tbuild.append(\"+\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tflg = true;\n\t\t\tbuild.append(f.toString());\n\t\t}\n\t\treturn build.toString();\n\t}\n\n\n}\n\nclass Parser{\n\tprivate String str;\n\tint idx;\n\tchar cur;\n\tboolean cont;\n\t\n\tprivate void next(){\n\t\tdo{\n\t\t\tnextSpace();\n\t\t}while(cont && cur == ' ');\n\t}\n\t\n\tprivate void nextSpace(){\n\t\tif(idx >= str.length()){\n\t\t\tcont = false;\n\t\t}else{\n\t\t\tcur = str.charAt(idx++);\n\t\t}\n\t}\n\n\tprivate char variable(){\n\t\tchar c = cur;\n\t\tnext();\n\t\treturn c;\n\t}\n\n\tprivate int number(){\n\t\tint ans = cur - '0';\n\t\tnextSpace();\n\t\twhile(cont && '0' <= cur && cur <= '9'){\n\t\t\tans = ans * 10 + cur - '0';\n\t\t\tnextSpace();\n\t\t}\n\t\tif(cur == ' ') next();\n\t\treturn ans;\n\t}\n\n\tprivate Polynomial F(){\n\t\tif(cur == '('){\n\t\t\tnext();\n\t\t\tPolynomial e = E();\n\t\t\tnext();\n\t\t\treturn e;\n\t\n\t\t}\n\t\tTerm t;\n\t\tif('0' <= cur && cur <= '9'){\n\t\t\tt = new Term(number());\n\t\t}else{\n\t\t\tint p = 1;\n\t\t\tchar c = variable();\n\t\t\tif(cur == '^'){\n\t\t\t\tnext();\n\t\t\t\tp = number();\n\t\t\t}\n\t\t\tt = new Term(1, new Factor(c, p));\n\t\t}\n\t\treturn new Polynomial(t);\n\t}\n\n\tprivate Polynomial T(){\n\t\tPolynomial f = F();\n\t\twhile(cont && cur != '+' && cur != '-' && cur != ')'){\n\t\t\tf = f.mul(F());\n\t\t}\n\t\treturn f;\n\t}\n\n\n\tprivate Polynomial E(){\n\t\tPolynomial t = T();\n\t\twhile(cur == '+' || cur == '-'){\n\t\t\tif(cur == '+'){\n\t\t\t\tnext();\t\t\t\n\t\t\t\tt = t.add(T());\n\t\t\t}else{\n\t\t\t\tnext();\t\t\t\n\t\t\t\tt = t.sub(T());\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\tpublic Polynomial parse(String str){\n\t\tthis.str = str;\n\t\tthis.idx = 0;\n\t\tthis.cont = true;\n\t\tnext();\n\t\treturn E();\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n \npublic class Main{\n    public void solve() throws Exception{\n        BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));\n        String exp;\n        Parser parser = new Parser();\n        while(!(exp = buf.readLine()).equals(\".\")){\n            Polynomial poly = parser.parse(exp);\n            String str;\n            while(!(str = buf.readLine()).equals(\".\")){\n                Polynomial p2 = parser.parse(str);\n                if(poly.compareTo(p2) == 0){\n                    System.out.println(\"yes\");\n                }else{\n                    System.out.println(\"no\");\n                }\n            }\n            System.out.println(\".\");\n        }\n    }\n     \n    public static void main(String[] args) throws Exception{\n        new Main().solve();\n    }\n}\n \nclass Factor implements Comparable<Factor>{\n    char variable;\n    int pow;\n    public Factor(char var, int pow){\n        this.variable = var;\n        this.pow = pow;\n    }\n    @Override\n    public int compareTo(Factor o) {\n        if(variable != o.variable) return Character.compare(variable, o.variable);\n        else return Integer.compare(pow, o.pow);\n    }\n     \n    public Factor copy(){\n        return new Factor(variable, pow);\n    }\n    public String toString(){\n        return variable + \"^\" + pow;\n    }\n}\n \nclass Term implements Comparable<Term>{\n    ArrayList<Factor> facts;\n    int num;\n     \n    private Term(){\n        facts = new ArrayList<>();\n    }\n     \n    public Term(int num){\n        facts = new ArrayList<>();\n        this.num = num;\n    }\n    public Term(int num, Factor fact){\n        this.num = num;\n        facts = new ArrayList<>();\n        facts.add(fact);\n    }\n     \n    public Term mul(Term t){\n        Term ret = new Term();\n        ret.num = num * t.num;\n        if(ret.num == 0) return ret;\n        ArrayList<Factor> tmp = new ArrayList<>(facts);\n        tmp.addAll(t.facts);\n        Collections.sort(tmp);\n        int idx = 0;\n        while(idx < tmp.size()){\n            Factor f = tmp.get(idx).copy();\n            idx++;\n            while(idx < tmp.size() && tmp.get(idx).variable == f.variable){\n                f.pow += tmp.get(idx).pow;\n                idx++;\n            }\n            ret.facts.add(f);\n        }\n        return ret;\n    }\n     \n    public Term copy(){\n        Term ret = new Term(num);\n        for(Factor f : facts){\n            ret.facts.add(f.copy());\n        }\n        return ret;\n    }\n \n    @Override\n    public int compareTo(Term o) {\n        int idx = 0;\n        while(true){\n            if(idx < facts.size()&& idx < o.facts.size()){\n                Factor f1 = facts.get(idx);\n                Factor f2 = o.facts.get(idx);\n                if(f1.variable != f2.variable) return Character.compare(f1.variable, f2.variable);\n                if(f1.pow != f2.pow) return Integer.compare(f1.pow, f2.pow);\n                idx++;\n            }else{\n                if(facts.size() == o.facts.size()){\n                    return 0;\n                }else if(idx >= facts.size()){\n                    return -1;\n                }else{\n                    return 1;\n                }\n            }\n        }\n    }\n    public String toString(){\n        StringBuilder build = new StringBuilder();\n        build.append(num);\n        for(Factor f : facts){\n            build.append(\" \");\n            build.append(f.toString());\n        }\n        return build.toString();\n    }\n}\n \nclass Polynomial implements Comparable<Polynomial>{\n    ArrayList<Term> terms;\n    private Polynomial(){\n        terms = new ArrayList<>();\n    }\n    public Polynomial(Term t){\n        this();\n        if(t.num != 0){\n            terms.add(t);\n        }\n    }\n    public Polynomial add(Polynomial p){\n        Polynomial ret = new Polynomial();\n        ArrayList<Term> tmp = new ArrayList<>();\n        tmp.addAll(terms);\n        tmp.addAll(p.terms);\n        Collections.sort(tmp);\n \n        int idx = 0;\n        while(idx < tmp.size()){\n            Term f = tmp.get(idx).copy();\n            idx++;\n            while(idx < tmp.size() && tmp.get(idx).compareTo(f) == 0){\n                f.num += tmp.get(idx).num;\n                idx++;\n            }\n            if(f.num != 0){\n                ret.terms.add(f);\n            }\n        }\n        return ret;\n    }\n     \n \n    public Polynomial sub(Polynomial p){\n        Polynomial ret = new Polynomial();\n        ArrayList<Term> tmp = new ArrayList<>();\n        tmp.addAll(terms);\n        for(Term t: p.terms){\n            Term tt = t.copy();\n            tt.num*=-1;\n            tmp.add(tt);\n        }\n        Collections.sort(tmp);\n \n        int idx = 0;\n        while(idx < tmp.size()){\n            Term f = tmp.get(idx).copy();\n            idx++;\n            while(idx < tmp.size() && tmp.get(idx).compareTo(f) == 0){\n                f.num += tmp.get(idx).num;\n                idx++;\n            }\n \n            if(f.num != 0){\n                ret.terms.add(f);\n            }\n        }\n        return ret;\n    }\n     \n    public Polynomial mul(Polynomial p){\n        Polynomial ret = new Polynomial();\n        ArrayList<Term> tmp = new ArrayList<>();\n        for(Term t1 : terms){\n            for(Term t2 : p.terms){\n                tmp.add(t1.mul(t2));\n            }\n        }\n        Collections.sort(tmp);\n \n        int idx = 0;\n        while(idx < tmp.size()){\n            Term f = tmp.get(idx).copy();\n            idx++;\n            while(idx < tmp.size() && tmp.get(idx).compareTo(f) == 0){\n                f.num += tmp.get(idx).num;\n                idx++;\n            }\n \n            if(f.num != 0){\n                ret.terms.add(f);\n            }\n        }\n        return ret;\n    }\n    @Override\n    public int compareTo(Polynomial o) {\n        int idx = 0;\n        while(idx < terms.size()&& idx < o.terms.size()){\n            Term f1 = terms.get(idx);\n            Term f2 = o.terms.get(idx);\n            int comp = f1.compareTo(f2);\n            if(comp != 0) return comp;\n            if(f1.num != f2.num) return Integer.compare(f1.num, f2.num);\n            idx++;\n        }\n        if(terms.size() == o.terms.size()){\n            return 0;\n        }else if(idx >= terms.size()){\n            return -1;\n        }else{\n            return 1;\n        }\n    }\n     \n    public String toString(){\n        StringBuilder build = new StringBuilder();\n        boolean flg = false;\n        for(Term f : terms){\n            if(flg) {\n                build.append(\" \");\n                if(f.num >= 0){\n                    build.append(\"+\");\n                }\n                 \n            }\n            flg = true;\n            build.append(f.toString());\n        }\n        return build.toString();\n    }\n \n \n}\n \nclass Parser{\n    private String str;\n    int idx;\n    char cur;\n    boolean cont;\n     \n    private void next(){\n        do{\n            nextSpace();\n        }while(cont && cur == ' ');\n    }\n     \n    private void nextSpace(){\n        if(idx >= str.length()){\n            cont = false;\n        }else{\n            cur = str.charAt(idx++);\n        }\n    }\n \n    private char variable(){\n        char c = cur;\n        next();\n        return c;\n    }\n \n    private int number(){\n        int ans = cur - '0';\n        nextSpace();\n        while(cont && '0' <= cur && cur <= '9'){\n            ans = ans * 10 + cur - '0';\n            nextSpace();\n        }\n        if(cur == ' ') next();\n        return ans;\n    }\n \n    private Polynomial F(){\n        if(cur == '('){\n            next();\n            Polynomial e = E();\n            next();\n            return e;\n     \n        }\n        Term t;\n        if('0' <= cur && cur <= '9'){\n            t = new Term(number());\n        }else{\n            int p = 1;\n            char c = variable();\n            if(cur == '^'){\n                next();\n                p = number();\n            }\n            t = new Term(1, new Factor(c, p));\n        }\n        return new Polynomial(t);\n    }\n \n    private Polynomial T(){\n        Polynomial f = F();\n        while(cont && cur != '+' && cur != '-' && cur != ')'){\n            f = f.mul(F());\n        }\n        return f;\n    }\n \n \n    private Polynomial E(){\n        Polynomial t = T();\n        while(cur == '+' || cur == '-'){\n            if(cur == '+'){\n                next();         \n                t = t.add(T());\n            }else{\n                next();         \n                t = t.sub(T());\n            }\n        }\n        return t;\n    }\n    public Polynomial parse(String str){\n        this.str = str;\n        this.idx = 0;\n        this.cont = true;\n        next();\n        return E();\n    }\n     \n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Equals are Equals\npublic class Main{\n\n\tchar[] s;\n\tint id;\n\t\n\tclass P{\n\t\tMap<String, Integer> c;\n\t\tint c0;\n\t\tpublic P() {\n\t\t\tc = new HashMap<String, Integer>();\n\t\t\tc0 = 0;\n\t\t}\n\t\tboolean eq(P p){\n//\t\t\tSet<String> set = new HashSet<String>();\n//\t\t\tfor(String t:c.keySet())if(c.get(t)==0)set.add(t);\n//\t\t\tfor(String t:set)c.remove(t);\n//\t\t\tset = new HashSet<String>();\n//\t\t\tfor(String t:p.c.keySet())if(p.c.get(t)==0)set.add(t);\n//\t\t\tfor(String t:set)p.c.remove(t);\n\t\t\tif(c.size()!=p.c.size()||c0!=p.c0){\n//\t\t\t\tSystem.out.println(\"DIFF22:\" + c.size() + \" \" + p.c.size() + \" \" + c0 + \" \"  +p.c0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor(String t:c.keySet())if(!p.c.containsKey(t)||c.get(t).intValue()!=p.c.get(t).intValue()){\n//\t\t\t\tSystem.out.println(\"DIFF:\" + c.get(t)+\" \"+p.c.get(t));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tP add(P p){\n//\t\t\tSystem.out.println(\"ADD:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String t:c.keySet()){\n\t\t\t\tif(p.c.containsKey(t))r.c.put(t, c.get(t)+p.c.get(t));\n\t\t\t\telse r.c.put(t, c.get(t));\n\t\t\t}\n\t\t\tfor(String t:p.c.keySet()){\n\t\t\t\tif(!c.containsKey(t))r.c.put(t, p.c.get(t));\n\t\t\t}\n\t\t\tr.c0 = c0+p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP sub(P p){\n//\t\t\tSystem.out.println(\"SUB:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String t:c.keySet()){\n\t\t\t\tif(p.c.containsKey(t))r.c.put(t, c.get(t)-p.c.get(t));\n\t\t\t\telse r.c.put(t, c.get(t));\n\t\t\t}\n\t\t\tfor(String t:p.c.keySet()){\n\t\t\t\tif(!c.containsKey(t))r.c.put(t, -p.c.get(t));\n\t\t\t}\n\t\t\tr.c0 = c0-p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP mul(P p){\n//\t\t\tSystem.out.println(\"MUL:\" + this + \" \" + p);\n\t\t\tP r = new P();\n\t\t\tfor(String s:c.keySet())for(String t:p.c.keySet()){\n\t\t\t\tchar[] x = (s+t).toCharArray();\n\t\t\t\tArrays.sort(x);\n\t\t\t\tString v = new String(x);\n\t\t\t\tif(r.c.containsKey(v))r.c.put(v, r.c.get(v)+c.get(s)*p.c.get(t));\n\t\t\t\telse r.c.put(v, c.get(s)*p.c.get(t));\n\t\t\t}\n//\t\t\tSystem.out.println(\"R1:\" + r);\n\t\t\tfor(String s:c.keySet()){\n\t\t\t\tif(r.c.containsKey(s))r.c.put(s, r.c.get(s)+p.c0*c.get(s));\n\t\t\t\telse r.c.put(s, p.c0*c.get(s));\n\t\t\t}\n\t\t\tfor(String s:p.c.keySet()){\n\t\t\t\tif(r.c.containsKey(s))r.c.put(s, r.c.get(s)+c0*p.c.get(s));\n\t\t\t\telse r.c.put(s, c0*p.c.get(s));\n\t\t\t}\n\t\t\tr.c0 += c0*p.c0;\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\treturn r;\n\t\t}\n\t\tP pow(int k){\n//\t\t\tSystem.out.println(\"POW:\" + this + \" \" + k);\n\t\t\tP r = new P();\n\t\t\tr.c0 = 1;\n\t\t\twhile(k--!=0)r = r.mul(this);\n//\t\t\tSystem.out.println(\"R*\" + r);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tfor(String t:r.c.keySet())if(r.c.get(t)==0)set.add(t);\n\t\t\tfor(String t:set)r.c.remove(t);\n\t\t\treturn r;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tfor(String t:c.keySet())r+=\" \"+c.get(t)+t;\n\t\t\tr+=\" \"+c0;\n\t\t\treturn r;\n\t\t}\n\t}\n\t\n\tchar get(){\n//\t\tSystem.out.println(s[id]);\n\t\treturn s[id++];\n\t}\n\tchar next(){\n\t\twhile(s[id]==' ')id++;\n//\t\tSystem.out.println(s[id]);\n\t\treturn s[id++];\n\t}\n\t\n\tP exp(){\n\t\tP r = term();\n\t\tchar ch = next(); \n\t\twhile(ch=='+'||ch=='-'){\n//\t\t\tSystem.out.println(\"CH:\" + ch);\n\t\t\tP f = term();\n//\t\t\tSystem.out.println(f);\n\t\t\tif(ch=='+')r = r.add(f);\n\t\t\telse r = r.sub(f);\n//\t\t\tSystem.out.println(\"RRR:\" + r);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tP term(){\n\t\tP r = fact();\n\t\tchar ch = next();\n\t\twhile(Character.isDigit(ch)||Character.isLowerCase(ch)||ch=='('){\n//\t\t\tSystem.out.println(\"Term char:\" + ch);\n\t\t\tid--;\n\t\t\tP f = fact();\n//\t\t\tSystem.out.println(\"F:\" + f);\n\t\t\tr = r.mul(f);\n//\t\t\tSystem.out.println(\"MUL : \" + r);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n//\t\tSystem.out.println(\"Term end with: \" + s[id]);\n\t\treturn r;\n\t}\n\t\n\tP fact(){\n\t\tchar ch = next();\n//\t\tSystem.out.println(\"INIT: \" + ch);\n\t\tP r = new P();\n\t\tif(ch=='('){\n\t\t\tr = exp();\n\t\t\tnext();\n\t\t}\n\t\telse if(Character.isLowerCase(ch))r.c.put(ch+\"\", 1);\n\t\telse if(Character.isDigit(ch)){\n\t\t\tint x = ch-'0';\n\t\t\tfor(;;){\n\t\t\t\tch = get();\n\t\t\t\tif(!Character.isDigit(ch)){\n\t\t\t\t\tid--;break;\n\t\t\t\t}\n\t\t\t\tx = x*10 + ch-'0';\n\t\t\t}\n//\t\t\tSystem.out.println(\"X:\" + x);\n\t\t\tr.c0 = x;\n\t\t}\n//\t\tSystem.out.println(\"R0:\" + r);\n\t\tch = next();\n\t\twhile(ch=='^'){\n\t\t\tint x = next()-'0';\n\t\t\tr = r.pow(x);\n\t\t\tch = next();\n\t\t}\n\t\tid--;\n//\t\tSystem.out.println(\"Fact end with: \" + s[id]);\n\t\treturn r;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\tif(s[0]=='.')break;\n\t\t\tid = 0;\n\t\t\tP ans = exp();\n//\t\t\tSystem.out.println(\"ANS:\" + ans);\n\t\t\tfor(;;){\n\t\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\t\tif(s[0]=='.')break;\n\t\t\t\tid = 0;\n\t\t\t\tP p = exp();\n//\t\t\t\tSystem.out.println(\"Pol:\" + p);\n\t\t\t\tSystem.out.println(ans.eq(p)?\"yes\":\"no\");\n\t\t\t}\n\t\t\tSystem.out.println(\".\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMINUS = [[0] * 26 + [-1]]\n\n### subroutines\n\ndef normalize(expr)\n  return expr if expr.empty?\n\n  expr.sort!\n  term0 = expr.shift\n  expr0 = []\n\n  for term1 in expr\n    if term0[0, 26] == term1[0, 26]\n      term0[26] += term1[26]\n    else\n      expr0 << term0 if term0[26] != 0\n      term0 = term1\n    end\n  end\n  expr0 << term0 if term0[26] != 0\n\n  expr0\nend\n\ndef add_expr(expr0, expr1)\n  #p [\"add\", expr0, expr1]\n  expr = normalize(expr0 + expr1)\n  #p [\"add -> \", expr]\n  expr\nend\n\ndef mul_expr(expr0, expr1)\n  #p [\"mul\", expr0, expr1]\n  expr = []\n  for term0 in expr0\n    for term1 in expr1\n      term = []\n      (0...26).each{|i| term[i] = term0[i] + term1[i]}\n      term[26] = term0[26] * term1[26]\n      expr << term\n    end\n  end\n  expr = normalize(expr)\n  #p [\"mul -> \", expr]\n  expr\nend\n\n# <expr> := <term> ( ('+' | '-') <term>)*\n# <term> := (<mult>)+\n# <mult> := <num> | <var> ('^' <num>) | '(' <expr> ')'\n# <num> := ('0'..'9')+\n# <var> := 'a'..'z'\n\ndef skip_space(str)\n  while str[$pos] == ' '\n    $pos += 1\n  end\nend\n\ndef expr(str)\n  skip_space(str)\n  t0 = term(str)\n  skip_space(str)\n\n  while str[$pos] =~ /[\\+\\-]/\n    op = str[$pos]\n    $pos += 1\n\n    skip_space(str)\n    t1 = term(str)\n    skip_space(str)\n\n    t1 = mul_expr(t1, MINUS) if op == '-'\n    t0 = add_expr(t0, t1)\n  end\n\n  t0\nend\n\ndef term(str)\n  skip_space(str)\n  m0 = mult(str)\n  skip_space(str)\n\n  while str[$pos] =~ /[0-9a-z\\(]/\n    m1 = mult(str)\n    skip_space(str)\n    m0 = mul_expr(m0, m1)\n  end\n\n  m0\nend\n\ndef mult(str)\n  skip_space(str)\n\n  m0 = [0] * 27\n\n  case str[$pos]\n  when '0'..'9'\n    n = num(str)\n    m0[26] = n\n    return [m0]\n  when 'a'..'z'\n    v = str[$pos].ord - 'a'.ord\n    $pos += 1\n    skip_space(str)\n\n    n = 1\n    if str[$pos] == '^'\n      $pos += 1\n      skip_space(str)\n      n = num(str)\n      skip_space(str)\n    end\n\n    m0[v] = n\n    m0[26] = 1\n    return [m0]\n  when '('\n    $pos += 1\n    skip_space(str)\n    expr = expr(str)\n    skip_space(str)\n    $pos += 1\n    return expr\n  end\n  nil\nend\n\ndef num(str)\n  n = 0\n  while str[$pos] =~ /[0-9]/\n    n = n * 10 + str[$pos].to_i\n    $pos += 1\n  end\n  n\nend\n\n### main\n\nloop do\n  tstr = gets.strip\n  break if tstr == '.'\n\n  $pos = 0\n  texpr = expr(tstr)\n  #p [tstr, '=>' , texpr]\n\n  loop do\n    sstr = gets.strip\n    break if sstr == '.'\n\n    $pos = 0\n    sexpr = expr(sstr)\n    #p [sstr, '=>' , sexpr]\n\n    puts (texpr == sexpr) ? 'yes' : 'no'\n  end\n  puts '.'\nend"
  },
  {
    "language": "Ruby",
    "code": "def to_ruby_form(e)\n    0 while e.gsub!(/([\\w)])\\s+([\\w(])/, '\\1*\\2')\n    e.gsub!(/\\s+/, '') \n    0 while e.gsub!(/(\\w)([a-z])/, '\\1*\\2')\n    e.gsub!(?^, '**')\nend\n\ndef sample(e, input)\n    eval(e.tr('a-z', input))\nend\n\nN = 10\n\nloop do\n    e = gets.chomp\n    break if e == ?.\n    to_ruby_form(e)\n    a = (0..9).to_a * 2 + (0..5).to_a\n    inputs = (0..N-1).map { a.shuffle.join }\n    outputs = inputs.map {|input| sample(e, input)}\n\n    until (e = gets.chomp) == ?.    \n        to_ruby_form(e)\n        if (0..N-1).all? {|i| sample(e, inputs[i]) == outputs[i]}\n            puts 'yes'\n        else\n            puts 'no'\n        end\n    end \n    puts ?.\nend"
  },
  {
    "language": "Ruby",
    "code": "def to_ruby_form(e)\n    0 while e.gsub!(/([\\w)])\\s+([\\w(])/, '\\1*\\2')\n    e.gsub!(/\\s+/, '')\n    0 while e.gsub!(/([\\w)])([a-z(])/, '\\1*\\2')\n    0 while e.gsub!(/([a-z)])([\\w(])/, '\\1*\\2')\n    e.gsub!(?^, '**')\nend\n\ndef sample(e, input)\n    eval(e.tr('a-z', input))\nend\n\nN = 10\nloop do\n    e = gets.chomp\n    break if e == ?.\n    to_ruby_form(e)\n    a = (0..9).to_a * 2 + (0..5).to_a\n    inputs = (0..N-1).map { a.shuffle.join }\n    outputs = inputs.map {|input| sample(e, input)}\n\n    until (e = gets.chomp) == ?.\n        to_ruby_form(e)\n        if (0..N-1).all? {|i| sample(e, inputs[i]) == outputs[i]}\n            puts 'yes'\n        else\n            puts 'no'\n        end\n    end\n    puts ?.\nend"
  },
  {
    "language": "Ruby",
    "code": "def to_ruby_form(e)\n    0 while e.gsub!(/([\\w)])\\s+([\\w(])/, '\\1*\\2')\n    e.gsub!(/\\s+/, '')\n    0 while e.gsub!(/([\\w)])([a-z(])/, '\\1*\\2')\n    0 while e.gsub!(/([a-z)])([\\w(])/, '\\1*\\2')\n    e.gsub!(?^, '**')\nend\n\ndef sample(e, input)\n    eval(e.tr('a-z', input))\nend\n\nN = 30\nloop do\n    e = gets.chomp\n    break if e == ?.\n    to_ruby_form(e)\n    a = (0..9).to_a * 2 + (0..5).to_a\n    inputs = (0..N-1).map { a.shuffle.join }\n    outputs = inputs.map {|input| sample(e, input)}\n\n    until (e = gets.chomp) == ?.\n        to_ruby_form(e)\n        if (0..N-1).all? {|i| sample(e, inputs[i]) == outputs[i]}\n            puts 'yes'\n        else\n            puts 'no'\n        end\n    end\n    puts ?.\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef point(gls, ti, ops)\n  win = glp = glm = 0\n\n  for op in ops\n    gli = gls[ti][op]\n    glo = gls[op][ti]\n\n    if gli > glo\n      win += 3\n    elsif gli == glo\n      win += 1\n    end\n\n    glp += gli\n    glm += glo\n  end\n\n  win * 10000 + (glp - glm + 32) * 100 + glp\nend\n\ndef check_order(gls, tis)\n  return [tis] if tis.length <= 1\n\n  phash = {}\n\n  for i in (0...tis.length)\n    ti = tis[i]\n    ops = tis.clone\n    ops.delete_at(i)\n    pt = point(gls, ti, ops)\n    #p [tis[i], pt]\n\n    phash[pt] = [] if phash[pt].nil?\n    phash[pt] << ti\n  end\n\n  mtis = phash.keys.sort{|a, b| b <=> a}.map{|pt| [phash[pt]]}.inject(:+)\n  return mtis if mtis.length == 1\n\n  mtis.map{|tis0| check_order(gls, tis0)}.inject(:+)\nend\n\n### main\n\nfact = [1]\n(1..8).each{|n| fact[n] = n * fact[n - 1]}\n#p fact\n\nprbs = []\nfor k in (0..8)\n  prbs[k] =\n    Rational(fact[8], fact[k] * fact[8 - k]) *\n    (Rational(1, 4) ** k) *\n    (Rational(3, 4) ** (8 - k))\nend\n#p prbs\n#p prbs.inject(:+)\n\nn = gets.to_i\n\nn.times do\n  lines = []\n  5.times do\n    str = gets.strip\n    line = []\n    (0..4).each{|i| line[i] = str[5 * i, 4]}\n    lines << line\n  end\n  #p lines\n\n  teams = []\n  thash = {}\n  oid = nil\n\n  for i in (0...4)\n    team = lines[0][i + 1]\n    teams << team\n    thash[team] = i\n    oid = i if team =~ /^\\*/\n  end\n  #p teams\n  #p thash\n  #p oid\n\n  gls = 4.times.map{4.times.map{nil}}\n  ops = []\n\n  for i in (0...4)\n    for j in ((i + 1)...4)\n      gl = lines[i + 1][j + 1]\n      #p [i, j, wl]\n      if gl[1] != '_'\n        gls[i][j] = gl[1].to_i\n        gls[j][i] = gl[3].to_i\n      else\n        ops[i] = j\n        ops[j] = i\n      end\n    end\n  end\n  #p gls\n  #p ops\n\n  sump = 0\n\n  for cnt in (0...9 ** 4)\n    cnt0 = cnt\n    scs = []\n    for i in (0...4)\n      scs << cnt0 % 9\n      cnt0 /= 9\n    end\n    #p scs\n\n    for i in (0...4)\n      gls[i][ops[i]] = scs[i]\n    end\n    #p gls\n\n    mtis = check_order(gls, (0...4).to_a)\n\n    r0 = r1 = 0\n    for tis in mtis\n      r0 = r1\n      r1 = r0 + tis.length\n\n      if tis.include?(oid)\n        break if r0 >= 2\n\n        pr = scs.map{|sc| prbs[sc]}.inject(:*)\n        if r1 <= 2\n          sump += pr\n        else\n          sump += pr * Rational(2 - r0, r1 - r0)\n        end\n      end\n    end\n  end\n\n  puts \"%.7f\" % sump.to_f\nend"
  },
  {
    "language": "Ruby",
    "code": "def to_ruby_form(e)\n    0 while e.gsub!(/([\\w)])\\s+([\\w(])/, '\\1*\\2')\n    e.gsub!(/\\s+/, '')\n    0 while e.gsub!(/([\\w)])([a-z(])/, '\\1*\\2')\n    0 while e.gsub!(/([a-z)])([\\w(])/, '\\1*\\2')\n    e.gsub!(?^, '**')\nend\n\ndef sample(e, input)\n    eval(e.tr('a-z', input))\nend\n\nN = 10\nloop do\n    e = gets.chomp\n    break if e == ?.\n    to_ruby_form(e)\n    a = (0..9).to_a * 2 + (0..5).to_a\n    inputs = (0..N-1).map { a.shuffle.join }\n    outputs = inputs.map {|input| sample(e, input)}\n\n    until (e = gets.chomp) == ?.\n        to_ruby_form(e)\n        if (0..N-1).all? {|i| sample(e, inputs[i]) == outputs[i]}\n            puts 'yes'\n        else\n            puts 'no'\n        end\n    end\n    puts ?.\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMINUS = [[0] * 26 + [-1]]\n\n### subroutines\n\ndef normalize(expr)\n  return expr if expr.empty?\n\n  expr.sort!\n  term0 = expr.shift\n  expr0 = []\n\n  for term1 in expr\n    if term0[0, 26] == term1[0, 26]\n      term0[26] += term1[26]\n    else\n      expr0 << term0 if term0[26] != 0\n      term0 = term1\n    end\n  end\n  expr0 << term0 if term0[26] != 0\n\n  expr0\nend\n\ndef add_expr(expr0, expr1)\n  #p [\"add\", expr0, expr1]\n  expr = normalize(expr0 + expr1)\n  #p [\"add -> \", expr]\n  expr\nend\n\ndef mul_expr(expr0, expr1)\n  #p [\"mul\", expr0, expr1]\n  expr = []\n  for term0 in expr0\n    for term1 in expr1\n      term = []\n      (0...26).each{|i| term[i] = term0[i] + term1[i]}\n      term[26] = term0[26] * term1[26]\n      expr << term\n    end\n  end\n  expr = normalize(expr)\n  #p [\"mul -> \", expr]\n  expr\nend\n\n# <expr> := <term> ( ('+' | '-') <term>)*\n# <term> := (<mult>)+\n# <mult> := <num> | <var> ('^' <num>) | '(' <expr> ')'\n# <num> := ('0'..'9')+\n# <var> := 'a'..'z'\n\ndef skip_space(str)\n  while str[$pos] == ' '\n    $pos += 1\n  end\nend\n\ndef expr(str)\n  skip_space(str)\n  t0 = term(str)\n  skip_space(str)\n\n  while str[$pos] =~ /[\\+\\-]/\n    op = str[$pos]\n    $pos += 1\n\n    skip_space(str)\n    t1 = term(str)\n    skip_space(str)\n\n    t1 = mul_expr(t1, MINUS) if op == '-'\n    t0 = add_expr(t0, t1)\n  end\n\n  t0\nend\n\ndef term(str)\n  skip_space(str)\n  m0 = mult(str)\n  skip_space(str)\n\n  while str[$pos] =~ /[0-9a-z\\(]/\n    m1 = mult(str)\n    skip_space(str)\n    m0 = mul_expr(m0, m1)\n  end\n\n  m0\nend\n\ndef mult(str)\n  skip_space(str)\n\n  m0 = [0] * 27\n\n  case str[$pos]\n  when '0'..'9'\n    n = num(str)\n    m0[26] = n\n    return [m0]\n  when 'a'..'z'\n    v = str[$pos].ord - 'a'.ord\n    $pos += 1\n    skip_space(str)\n\n    n = 1\n    if str[$pos] == '^'\n      $pos += 1\n      skip_space(str)\n      n = num(str)\n      skip_space(str)\n    end\n\n    m0[v] = n\n    m0[26] = 1\n    return [m0]\n  when '('\n    $pos += 1\n    skip_space(str)\n    expr = expr(str)\n    skip_space(str)\n    $pos += 1\n    return expr\n  end\n  nil\nend\n\ndef num(str)\n  n = 0\n  while str[$pos] =~ /[0-9]/\n    n = n * 10 + str[$pos].to_i\n    $pos += 1\n  end\n  n\nend\n\n### main\n\nloop do\n  tstr = gets.strip\n  break if tstr == '.'\n\n  $pos = 0\n  texpr = normalize(expr(tstr))\n  #p [tstr, '=>' , texpr]\n\n  loop do\n    sstr = gets.strip\n    break if sstr == '.'\n\n    $pos = 0\n    sexpr = normalize(expr(sstr))\n    #p [sstr, '=>' , sexpr]\n\n    puts (texpr == sexpr) ? 'yes' : 'no'\n  end\n  puts '.'\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nfrom string import digits\n\ndef convert(S):\n    S = S + \"$\"\n    cur = 0\n    def expr():\n        nonlocal cur\n        res = []\n        op = '+'\n        while 1:\n            r = fact()\n            if op == '-':\n                for e in r:\n                    e[0] *= -1\n            res.extend(r)\n            if S[cur] not in '+-':\n                break\n            op = S[cur]\n            cur += 1 # '+' or '-'\n        r = []\n        for e0 in res:\n            k0, es0 = e0\n            for e1 in r:\n                k1, es1 = e1\n                if es0 == es1:\n                    e1[0] += k0\n                    break\n            else:\n                r.append(e0)\n        res = list(filter(lambda x: x[0] != 0, r))\n        res.sort()\n        return res\n\n    def fact():\n        nonlocal cur\n        res = [[1, []]]\n        while 1:\n            r = idt()\n            r0 = []\n            for v0, es0 in res:\n                for v1, es1 in r:\n                    d = {}\n                    for k, v in es0:\n                        d[k] = d.get(k, 0) + v\n                    for k, v in es1:\n                        d[k] = d.get(k, 0) + v\n                    *es, = d.items()\n                    es.sort()\n                    r0.append([v0*v1, es])\n            res = r0\n\n            while S[cur] == ' ':\n                cur += 1 # ' '\n            if S[cur] in '+-$)':\n                break\n        return res\n    def idt():\n        nonlocal cur\n        while S[cur] == ' ':\n            cur += 1 # ' '\n        if S[cur] == '(':\n            cur += 1 # '('\n            r = expr()\n            cur += 1 # ')'\n        elif S[cur] in digits:\n            v = number()\n            r = [[v, []]]\n        else:\n            c = S[cur]\n            cur += 1 # 'a' ~ 'z'\n\n            while S[cur] == ' ':\n                cur += 1 # ' '\n            if S[cur] == '^':\n                cur += 1 # '^'\n                while S[cur] == ' ':\n                    cur += 1 # ' '\n                v = number()\n            else:\n                v = 1\n            r = [[1, [(c, v)]]]\n        return r\n\n    def number():\n        nonlocal cur\n        v = 0\n        while 1:\n            c = S[cur]\n            if c not in digits:\n                break\n            v = 10*v + int(c)\n            cur += 1 # '0' ~ '9'\n        return v\n\n    res = expr()\n    return res\n\n\ndef solve():\n    s0 = readline().strip()\n    if s0 == '.':\n        return False\n    d0 = convert(s0)\n    while 1:\n        s = readline().strip()\n        if s == '.':\n            break\n        d = convert(s)\n        write(\"yes\\n\" if d0 == d else \"no\\n\")\n    write(\".\\n\")\n    return True\nwhile solve():\n    ...\n"
  }
]