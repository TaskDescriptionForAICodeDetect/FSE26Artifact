[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_TERMS 1000\n#define MAX_VARS 26\n\ntypedef struct {\n    int coeff;\n    int vars[MAX_VARS];\n} Term;\n\nTerm terms[MAX_TERMS];\nint term_count = 0;\n\nvoid parse_expression(char *expr);\nvoid parse_term(char *term_str, int sign);\nvoid add_term(int coeff, int *vars);\nvoid sort_terms();\nint compare_terms(const void *a, const void *b);\nvoid normalize();\n\nint main() {\n    char line[1000];\n    int first = 1;\n    Term correct[MAX_TERMS];\n    int correct_count;\n\n    while (fgets(line, sizeof(line), stdin)) {\n        line[strcspn(line, \"\\n\")] = 0;\n        term_count = 0;\n        parse_expression(line);\n\n        if (first) {\n            first = 0;\n            correct_count = term_count;\n            for (int i = 0; i < term_count; i++) {\n                correct[i] = terms[i];\n            }\n            normalize();\n            sort_terms();\n        } else {\n            normalize();\n            sort_terms();\n            int match = (term_count == correct_count);\n            for (int i = 0; match && i < term_count; i++) {\n                if (terms[i].coeff != correct[i].coeff) {\n                    match = 0;\n                    break;\n                }\n                for (int j = 0; j < MAX_VARS; j++) {\n                    if (terms[i].vars[j] != correct[i].vars[j]) {\n                        match = 0;\n                        break;\n                    }\n                }\n            }\n            printf(\"%s\\n\", match ? \"yes\" : \"no\");\n        }\n    }\n    return 0;\n}\n\nvoid parse_expression(char *expr) {\n    char *token = strtok(expr, \"+-\");\n    int sign = 1;\n    char *ptr = expr;\n\n    while (*ptr) {\n        if (*ptr == '+') {\n            sign = 1;\n            ptr++;\n        } else if (*ptr == '-') {\n            sign = -1;\n            ptr++;\n        } else {\n            char term_str[100];\n            int i = 0;\n            while (*ptr && *ptr != '+' && *ptr != '-') {\n                term_str[i++] = *ptr++;\n            }\n            term_str[i] = '\\0';\n            parse_term(term_str, sign);\n            sign = 1;\n        }\n    }\n}\n\nvoid parse_term(char *term_str, int sign) {\n    int coeff = 1;\n    int vars[MAX_VARS] = {0};\n    char *ptr = term_str;\n\n    while (*ptr) {\n        if (isdigit(*ptr)) {\n            coeff = 0;\n            while (isdigit(*ptr)) {\n                coeff = coeff * 10 + (*ptr - '0');\n                ptr++;\n            }\n        } else if (isalpha(*ptr)) {\n            char var = *ptr++;\n            int power = 1;\n            if (*ptr == '^') {\n                ptr++;\n                power = 0;\n                while (isdigit(*ptr)) {\n                    power = power * 10 + (*ptr - '0');\n                    ptr++;\n                }\n            }\n            vars[var - 'a'] += power;\n        }\n    }\n    add_term(sign * coeff, vars);\n}\n\nvoid add_term(int coeff, int *vars) {\n    for (int i = 0; i < term_count; i++) {\n        int match = 1;\n        for (int j = 0; j < MAX_VARS; j++) {\n            if (terms[i].vars[j] != vars[j]) {\n                match = 0;\n                break;\n            }\n        }\n        if (match) {\n            terms[i].coeff += coeff;\n            return;\n        }\n    }\n    terms[term_count].coeff = coeff;\n    for (int j = 0; j < MAX_VARS; j++) {\n        terms[term_count].vars[j] = vars[j];\n    }\n    term_count++;\n}\n\nvoid sort_terms() {\n    qsort(terms, term_count, sizeof(Term), compare_terms);\n}\n\nint compare_terms(const void *a, const void *b) {\n    Term *ta = (Term *)a;\n    Term *tb = (Term *)b;\n    for (int i = 0; i < MAX_VARS; i++) {\n        if (ta->vars[i] != tb->vars[i]) {\n            return ta->vars[i] - tb->vars[i];\n        }\n    }\n    return 0;\n}\n\nvoid normalize() {\n    int new_count = 0;\n    for (int i = 0; i < term_count; i++) {\n        if (terms[i].coeff != 0) {\n            terms[new_count++] = terms[i];\n        }\n    }\n    term_count = new_count;\n}",
    "timestamp": "2025-08-05 19:14:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AlgebraicEquivalence {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine();\n\n        String correctExpression = scanner.nextLine();\n        Map<String, Integer> correctTerms = parseExpression(correctExpression);\n\n        for (int i = 0; i < n - 1; i++) {\n            String studentExpression = scanner.nextLine();\n            Map<String, Integer> studentTerms = parseExpression(studentExpression);\n\n            if (compareTerms(correctTerms, studentTerms)) {\n                System.out.println(\"yes\");\n            } else {\n                System.out.println(\"no\");\n            }\n        }\n    }\n\n    private static Map<String, Integer> parseExpression(String expression) {\n        Map<String, Integer> terms = new HashMap<>();\n        expression = expression.replaceAll(\"\\\\s+\", \"\");\n        \n        boolean isPositive = true;\n        int coefficient = 1;\n        String currentTerm = \"\";\n\n        for (int i = 0; i < expression.length(); i++) {\n            char c = expression.charAt(i);\n            \n            if (c == '+' || c == '-') {\n                if (!currentTerm.isEmpty()) {\n                    updateTerms(terms, currentTerm, isPositive ? coefficient : -coefficient);\n                }\n                \n                isPositive = (c == '+');\n                coefficient = 1;\n                currentTerm = \"\";\n            } else if (Character.isDigit(c)) {\n                if (currentTerm.isEmpty() || !Character.isLetter(currentTerm.charAt(currentTerm.length() - 1))) {\n                    coefficient = Integer.parseInt(String.valueOf(c));\n                    while (i + 1 < expression.length() && Character.isDigit(expression.charAt(i + 1))) {\n                        coefficient = coefficient * 10 + Integer.parseInt(String.valueOf(expression.charAt(i + 1)));\n                        i++;\n                    }\n                } else {\n                    currentTerm += c;\n                }\n            } else if (Character.isLetter(c)) {\n                currentTerm += c;\n            }\n        }\n\n        if (!currentTerm.isEmpty()) {\n            updateTerms(terms, currentTerm, isPositive ? coefficient : -coefficient);\n        }\n\n        return terms;\n    }\n\n    private static void updateTerms(Map<String, Integer> terms, String term, int coefficient) {\n        char[] chars = term.toCharArray();\n        Arrays.sort(chars);\n        String sortedTerm = new String(chars);\n        \n        terms.put(sortedTerm, terms.getOrDefault(sortedTerm, 0) + coefficient);\n    }\n\n    private static boolean compareTerms(Map<String, Integer> correctTerms, Map<String, Integer> studentTerms) {\n        if (correctTerms.size() != studentTerms.size()) {\n            return false;\n        }\n\n        for (Map.Entry<String, Integer> entry : correctTerms.entrySet()) {\n            if (!studentTerms.containsKey(entry.getKey()) || \n                !studentTerms.get(entry.getKey()).equals(entry.getValue())) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 19:14:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nstruct Term {\n    int coeff;\n    map<char, int> vars;\n\n    Term() : coeff(1) {}\n    Term(int c) : coeff(c) {}\n\n    bool operator<(const Term& other) const {\n        if (vars.size() != other.vars.size())\n            return vars.size() > other.vars.size();\n        return vars < other.vars;\n    }\n\n    bool operator==(const Term& other) const {\n        return coeff == other.coeff && vars == other.vars;\n    }\n\n    Term operator*(const Term& other) const {\n        Term res;\n        res.coeff = coeff * other.coeff;\n        for (auto& p : vars) res.vars[p.first] += p.second;\n        for (auto& p : other.vars) res.vars[p.first] += p.second;\n        return res;\n    }\n};\n\nstruct Polynomial {\n    vector<Term> terms;\n\n    void normalize() {\n        sort(terms.begin(), terms.end());\n        vector<Term> new_terms;\n        for (auto& term : terms) {\n            if (new_terms.empty() || !(new_terms.back().vars == term.vars)) {\n                new_terms.push_back(term);\n            } else {\n                new_terms.back().coeff += term.coeff;\n            }\n        }\n        terms = new_terms;\n        terms.erase(remove_if(terms.begin(), terms.end(), [](const Term& t) { return t.coeff == 0; }), terms.end());\n    }\n\n    bool operator==(const Polynomial& other) const {\n        if (terms.size() != other.terms.size()) return false;\n        for (size_t i = 0; i < terms.size(); ++i) {\n            if (!(terms[i] == other.terms[i])) return false;\n        }\n        return true;\n    }\n};\n\nPolynomial parsePolynomial(const string& expr);\n\nTerm parseTerm(const string& expr, size_t& pos) {\n    Term term;\n    int sign = 1;\n    if (pos < expr.size() && expr[pos] == '-') {\n        sign = -1;\n        ++pos;\n    } else if (pos < expr.size() && expr[pos] == '+') {\n        ++pos;\n    }\n    term.coeff = sign;\n\n    while (pos < expr.size()) {\n        if (isdigit(expr[pos])) {\n            int num = 0;\n            while (pos < expr.size() && isdigit(expr[pos])) {\n                num = num * 10 + (expr[pos] - '0');\n                ++pos;\n            }\n            term.coeff *= num;\n        } else if (islower(expr[pos])) {\n            char var = expr[pos];\n            ++pos;\n            int power = 1;\n            if (pos < expr.size() && expr[pos] == '^') {\n                ++pos;\n                power = 0;\n                while (pos < expr.size() && isdigit(expr[pos])) {\n                    power = power * 10 + (expr[pos] - '0');\n                    ++pos;\n                }\n            }\n            term.vars[var] += power;\n        } else {\n            break;\n        }\n    }\n    return term;\n}\n\nPolynomial parsePolynomial(const string& expr) {\n    Polynomial poly;\n    size_t pos = 0;\n    while (pos < expr.size()) {\n        Term term = parseTerm(expr, pos);\n        poly.terms.push_back(term);\n    }\n    poly.normalize();\n    return poly;\n}\n\nint main() {\n    string line;\n    getline(cin, line);\n    Polynomial correct = parsePolynomial(line);\n    correct.normalize();\n\n    while (getline(cin, line)) {\n        Polynomial student = parsePolynomial(line);\n        student.normalize();\n        cout << (correct == student ? \"yes\" : \"no\") << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:15:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_EXPR_LEN 1000\n#define MAX_VARS 26\n\ntypedef struct {\n    int coeff;\n    int powers[MAX_VARS];\n} Term;\n\ntypedef struct {\n    Term terms[MAX_EXPR_LEN];\n    int term_count;\n} Polynomial;\n\nint var_index(char var) {\n    return var - 'a';\n}\n\nvoid parse_polynomial(char* expr, Polynomial* poly) {\n    poly->term_count = 0;\n    char* token = strtok(expr, \"+\");\n    \n    while (token != NULL) {\n        Term* term = &poly->terms[poly->term_count];\n        memset(term->powers, 0, sizeof(term->powers));\n        term->coeff = 1;\n\n        char* ptr = token;\n        \n        // Check for coefficient\n        if (isdigit(*ptr)) {\n            term->coeff = atoi(ptr);\n            while (isdigit(*ptr)) ptr++;\n        }\n        \n        // Process variables and their powers\n        while (*ptr) {\n            if (isalpha(*ptr)) {\n                int idx = var_index(*ptr);\n                ptr++;\n                \n                if (*ptr == '^') {\n                    ptr++;\n                    term->powers[idx] = atoi(ptr);\n                    while (isdigit(*ptr)) ptr++;\n                } else {\n                    term->powers[idx] = 1;\n                }\n            }\n            ptr++;\n        }\n        \n        poly->term_count++;\n        token = strtok(NULL, \"+\");\n    }\n}\n\nint polynomials_equivalent(Polynomial* p1, Polynomial* p2) {\n    if (p1->term_count != p2->term_count) return 0;\n    \n    for (int i = 0; i < p1->term_count; i++) {\n        int found = 0;\n        for (int j = 0; j < p2->term_count; j++) {\n            if (p1->terms[i].coeff == p2->terms[j].coeff) {\n                int same_powers = 1;\n                for (int k = 0; k < MAX_VARS; k++) {\n                    if (p1->terms[i].powers[k] != p2->terms[j].powers[k]) {\n                        same_powers = 0;\n                        break;\n                    }\n                }\n                if (same_powers) {\n                    found = 1;\n                    break;\n                }\n            }\n        }\n        if (!found) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char correct_expr[MAX_EXPR_LEN];\n    char student_expr[MAX_EXPR_LEN];\n    Polynomial correct_poly, student_poly;\n\n    // Read correct expression\n    scanf(\"%s\", correct_expr);\n    parse_polynomial(correct_expr, &correct_poly);\n\n    // Process student expressions\n    while (scanf(\"%s\", student_expr) != EOF) {\n        parse_polynomial(student_expr, &student_poly);\n        \n        if (polynomials_equivalent(&correct_poly, &student_poly)) {\n            printf(\"yes\\n\");\n        } else {\n            printf(\"no\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:15:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nmap<string, int> parseExpression(const string& expr) {\n    map<string, int> terms;\n    stringstream ss(expr);\n    string term;\n    \n    while (ss >> term) {\n        int coeff = 1;\n        string var;\n        \n        if (isdigit(term[0]) || term[0] == '-') {\n            size_t pos = term.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n            if (pos != string::npos) {\n                coeff = stoi(term.substr(0, pos));\n                var = term.substr(pos);\n            } else {\n                coeff = stoi(term);\n                var = \"\";\n            }\n        } else {\n            var = term;\n        }\n        \n        if (term[0] == '+' || term[0] == '-') {\n            var = term.substr(1);\n            coeff = (term[0] == '+') ? 1 : -1;\n        }\n        \n        terms[var] += coeff;\n    }\n    \n    return terms;\n}\n\nbool areExpressionsEquivalent(const string& correct, const string& student) {\n    map<string, int> correctTerms = parseExpression(correct);\n    map<string, int> studentTerms = parseExpression(student);\n    \n    return correctTerms == studentTerms;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    string correct;\n    getline(cin >> ws, correct);\n    \n    for (int i = 0; i < n; i++) {\n        string student;\n        getline(cin >> ws, student);\n        \n        cout << (areExpressionsEquivalent(correct, student) ? \"yes\" : \"no\") << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:15:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\npublic class PolynomialEquivalence {\n    static class Term {\n        int coeff;\n        Map<Character, Integer> vars;\n\n        Term(int coeff) {\n            this.coeff = coeff;\n            this.vars = new HashMap<>();\n        }\n\n        void addVar(char var, int exp) {\n            vars.merge(var, exp, Integer::sum);\n            if (vars.get(var) == 0) {\n                vars.remove(var);\n            }\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Term term = (Term) o;\n            return coeff == term.coeff && vars.equals(term.vars);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(coeff, vars);\n        }\n    }\n\n    static Set<Term> parseExpression(String expr) {\n        Set<Term> terms = new HashSet<>();\n        String[] termStrs = expr.split(\"(?=[+-])\");\n        Pattern termPattern = Pattern.compile(\"([+-]?\\\\d*)([a-z]*)\");\n\n        for (String termStr : termStrs) {\n            if (termStr.isEmpty()) continue;\n            Matcher m = termPattern.matcher(termStr);\n            if (!m.find()) continue;\n\n            String coeffStr = m.group(1);\n            String varsStr = m.group(2);\n\n            int coeff = 1;\n            if (!coeffStr.isEmpty() && !coeffStr.equals(\"+\") && !coeffStr.equals(\"-\")) {\n                coeff = Integer.parseInt(coeffStr);\n            } else if (coeffStr.equals(\"-\")) {\n                coeff = -1;\n            } else if (coeffStr.equals(\"+\")) {\n                coeff = 1;\n            }\n\n            Term term = new Term(coeff);\n            Pattern varPattern = Pattern.compile(\"([a-z])(\\\\d*)\");\n            Matcher varMatcher = varPattern.matcher(varsStr);\n            while (varMatcher.find()) {\n                char var = varMatcher.group(1).charAt(0);\n                String expStr = varMatcher.group(2);\n                int exp = expStr.isEmpty() ? 1 : Integer.parseInt(expStr);\n                term.addVar(var, exp);\n            }\n            terms.add(term);\n        }\n        return terms;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String line = scanner.nextLine();\n        String[] expressions = line.split(\"\\\\s+\");\n        if (expressions.length < 2) {\n            return;\n        }\n\n        Set<Term> correctTerms = parseExpression(expressions[0]);\n        for (int i = 1; i < expressions.length; i++) {\n            Set<Term> studentTerms = parseExpression(expressions[i]);\n            System.out.println(correctTerms.equals(studentTerms) ? \"yes\" : \"no\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:16:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sympy\n\ndef check_equivalence(expressions):\n    correct_expr = sympy.sympify(expressions[0])\n    results = []\n    for student_expr in expressions[1:]:\n        if sympy.simplify(correct_expr - sympy.sympify(student_expr)) == 0:\n            results.append('yes')\n        else:\n            results.append('no')\n    return results\n\n# Read input\nexpressions = []\nwhile True:\n    try:\n        line = input().strip()\n        if not line:\n            break\n        expressions.append(line)\n    except EOFError:\n        break\n\n# Evaluate equivalence\nresults = check_equivalence(expressions)\nprint(\"\\n\".join(results))",
    "timestamp": "2025-08-13 03:06:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class AlgebraicEquivalenceChecker {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String correctExpression = scanner.nextLine().replaceAll(\"\\\\s+\", \"\");\n        Map<String, Integer> correctMap = parseExpression(correctExpression);\n\n        while (scanner.hasNextLine()) {\n            String studentExpression = scanner.nextLine().replaceAll(\"\\\\s+\", \"\");\n            Map<String, Integer> studentMap = parseExpression(studentExpression);\n            System.out.println(correctMap.equals(studentMap) ? \"yes\" : \"no\");\n        }\n\n        scanner.close();\n    }\n\n    private static Map<String, Integer> parseExpression(String expression) {\n        Map<String, Integer> terms = new HashMap<>();\n        String[] splitTerms = expression.split(\"(?=[+-])\");\n\n        for (String term : splitTerms) {\n            String[] parts = term.split(\"(?=[a-z])\");\n            int coefficient = parts.length > 0 && !parts[0].isEmpty() && !parts[0].equals(\"+\") && !parts[0].equals(\"-\") \n                              ? Integer.parseInt(parts[0].replaceAll(\"\\\\+\", \"\"))\n                              : (term.startsWith(\"-\") ? -1 : 1);\n\n            String variables = parts.length > 1 ? parts[1] : (parts.length == 0 ? \"\" : term.replaceAll(\"[^a-z]\", \"\"));\n            char[] varsArray = variables.toCharArray();\n            java.util.Arrays.sort(varsArray);\n            String sortedVars = new String(varsArray);\n\n            terms.put(sortedVars, terms.getOrDefault(sortedVars, 0) + coefficient);\n        }\n\n        return terms;\n    }\n}",
    "timestamp": "2025-08-13 03:06:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_LEN 1000\n\ntypedef struct {\n    int coefficient;\n    int variables[26]; // a to z\n} Term;\n\nvoid parse_expression(const char* expr, Term* terms, int* term_count) {\n    int i = 0;\n    *term_count = 0;\n    while (expr[i]) {\n        int sign = 1;\n        if (expr[i] == '+') {\n            i++;\n        } else if (expr[i] == '-') {\n            sign = -1;\n            i++;\n        }\n        \n        int coeff = 0;\n        while (isdigit(expr[i])) {\n            coeff = coeff * 10 + (expr[i] - '0');\n            i++;\n        }\n        if (coeff == 0)  coeff = 1;\n        coeff *= sign;\n\n        int variable_count[26] = {0};\n        while (islower(expr[i])) {\n            variable_count[expr[i] - 'a']++;\n            i++;\n        }\n\n        int found = 0;\n        for (int j = 0; j < *term_count; j++) {\n            if (memcmp(terms[j].variables, variable_count, sizeof(variable_count)) == 0) {\n                terms[j].coefficient += coeff;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            terms[*term_count].coefficient = coeff;\n            memcpy(terms[*term_count].variables, variable_count, sizeof(variable_count));\n            (*term_count)++;\n        }\n    }\n}\n\nint is_equivalent(const Term* terms1, int count1, const Term* terms2, int count2) {\n    if (count1 != count2) return 0;\n    for (int i = 0; i < count1; i++) {\n        int found = 0;\n        for (int j = 0; j < count2; j++) {\n            if (memcmp(terms1[i].variables, terms2[j].variables, sizeof(int) * 26) == 0) {\n                if (terms1[i].coefficient != terms2[j].coefficient) {\n                    return 0;\n                }\n                found = 1;\n                break;\n            }\n        }\n        if (!found) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char input[MAX_LEN];\n    gets(input);\n    \n    Term correct_terms[MAX_LEN];\n    int correct_term_count;\n    parse_expression(input, correct_terms, &correct_term_count);\n\n    while (gets(input)) {\n        Term student_terms[MAX_LEN];\n        int student_term_count;\n        parse_expression(input, student_terms, &student_term_count);\n        \n        if (is_equivalent(correct_terms, correct_term_count, student_terms, student_term_count)) {\n            printf(\"yes\\n\");\n        } else {\n            printf(\"no\\n\");\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 03:07:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_expression(expr):\n    terms = {}\n    expr = expr.replace('-', '+-')\n    if expr[0] == '+':\n        expr = expr[1:]\n    \n    for term in expr.split('+'):\n        if not term:\n            continue\n        \n        if term.isdigit() or (term[0] == '-' and term[1:].isdigit()):\n            terms[1] = terms.get(1, 0) + int(term)\n        else:\n            coef = 1\n            var = term\n            \n            if term[0] in '+-':\n                sign = -1 if term[0] == '-' else 1\n                var = term[1:]\n                coef = sign\n            \n            if var[0].isdigit():\n                coef_end = 0\n                while coef_end < len(var) and var[coef_end].isdigit():\n                    coef_end += 1\n                \n                coef *= int(var[:coef_end] or 1)\n                var = var[coef_end:]\n            \n            power = 1\n            if '^' in var:\n                var, power = var.split('^')\n                power = int(power)\n            \n            terms[power] = terms.get(power, 0) + coef\n    \n    return terms\n\ndef are_equivalent(correct, student):\n    correct_terms = parse_expression(correct)\n    student_terms = parse_expression(student)\n    \n    return correct_terms == student_terms\n\ndef main():\n    n = int(input())\n    correct = input()\n    \n    for _ in range(n):\n        student = input()\n        print('yes' if are_equivalent(correct, student) else 'no')\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 03:07:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import re\nfrom collections import defaultdict\n\ndef parse_expression(expr):\n    terms = []\n    # Split into terms\n    term_strs = re.findall('([+-]?[^-+]*)', expr)\n    term_strs = [t for t in term_strs if t]\n    \n    for term_str in term_strs:\n        # Parse coefficient and variables\n        parts = re.findall('([+-]?\\\\d*)([a-z]*)', term_str.strip())[0]\n        coeff_part = parts[0]\n        vars_part = parts[1]\n        \n        if not coeff_part or coeff_part == '+':\n            coeff = 1\n        elif coeff_part == '-':\n            coeff = -1\n        else:\n            coeff = int(coeff_part)\n        \n        # Sort variables and count exponents\n        var_counts = defaultdict(int)\n        for var in vars_part:\n            var_counts[var] += 1\n        sorted_vars = sorted(var_counts.items())\n        vars_tuple = tuple(sorted_vars)\n        \n        terms.append((coeff, vars_tuple))\n    \n    # Combine like terms\n    term_dict = defaultdict(int)\n    for coeff, vars_tuple in terms:\n        term_dict[vars_tuple] += coeff\n    \n    # Filter out zero coefficients and sort\n    simplified_terms = sorted([(coeff, vars) for vars, coeff in term_dict.items() if coeff != 0], key=lambda x: (-len(x[1]), x[1]))\n    return simplified_terms\n\ndef are_equivalent(expr1, expr2):\n    terms1 = parse_expression(expr1)\n    terms2 = parse_expression(expr2)\n    return terms1 == terms2\n\ndef main():\n    import sys\n    input_lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not input_lines:\n        return\n    correct_expr = input_lines[0]\n    for student_expr in input_lines[1:]:\n        if are_equivalent(correct_expr, student_expr):\n            print(\"yes\")\n        else:\n            print(\"no\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:07:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n\nusing namespace std;\n\n// Function to evaluate the polynomial string into a map\nmap<map<char, int>, int> evaluatePolynomial(const string& expression) {\n    map<map<char, int>, int> terms;\n    stringstream ss(expression);\n    char ch;\n    while (ss >> ch) {\n        int sign = 1;\n        if (ch == '-') {\n            sign = -1;\n            ss >> ch;\n        } else if (ch == '+') {\n            ss >> ch;\n        }\n        \n        int coefficient = 0;\n        if (isdigit(ch)) {\n            ss.unget();\n            ss >> coefficient;\n            coefficient *= sign;\n            ss >> ch;\n        } else {\n            coefficient = sign;\n        }\n        \n        map<char, int> term;\n        while (isalpha(ch)) {\n            char var = ch;\n            int power = 0;\n            if (ss.peek() == '^') {\n                ss >> ch;  // read '^'\n                ss >> power;\n            } else {\n                power = 1;\n            }\n            term[var] += power;\n            if (!(ss >> ch)) break;\n        }\n        \n        terms[term] += coefficient;\n        ss.unget();\n    }\n\n    return terms;\n}\n\nint main() {\n    string correctExpression;\n    getline(cin, correctExpression);\n    map<map<char, int>, int> correctTerms = evaluatePolynomial(correctExpression);\n    \n    string studentExpression;\n    while (getline(cin, studentExpression)) {\n        map<map<char, int>, int> studentTerms = evaluatePolynomial(studentExpression);\n        if (correctTerms == studentTerms) {\n            cout << \"yes\" << endl;\n        } else {\n            cout << \"no\" << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:10:13"
  }
]