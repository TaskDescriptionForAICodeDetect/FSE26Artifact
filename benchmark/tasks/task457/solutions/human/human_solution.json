[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt n,k,ans,cnt,tmp;\nvector<set<Int> > G;\nvoid dfs(Int x){\n  //cout<<x<<endl;\n  if(x==n)\n    ans=min(ans,tmp);\n  if(tmp>=ans) return;\n\n  if(G[x].empty()){\n    dfs(x+1);\n    return;\n  }\n  \n  if(tmp+1<ans&&G[x].size()>1u){\n    vector<Int> v;\n    for(Int u:G[x]){\n      v.emplace_back(u);\n      G[u].erase(x);\n    }\n    cnt++;\n    tmp++;\n    dfs(x+1);\n    cnt--;\n    tmp--;\n    for(Int u:v){\n      G[u].emplace(x);\n    }\n  }\n\n  if(tmp+(Int)G[x].size()<ans){\n    vector<Int> v;\n    vector<set<Int> > S;\n    for(Int u:G[x]){\n      if(G[u].empty()) continue;\n      v.emplace_back(u);\n      S.emplace_back(G[u]);\n      G[u].clear();\n      cnt++;\n      tmp++;\n    }\n    \n    for(Int i=0;i<(Int)v.size();i++)\n      for(int w:S[i]) G[w].erase(v[i]);\n    \n    cnt++;\n    dfs(x+1);\n    cnt--;\n    \n    for(Int i=0;i<(Int)v.size();i++){\n      G[v[i]]=S[i];\n      for(int w:G[v[i]]) G[w].emplace(v[i]);\n      cnt--;\n      tmp--;\n    }\n  }\n  \n};\nsigned main(){\n  Int m,k;\n  cin>>n>>m>>k;\n  G.resize(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace(v);\n    G[v].emplace(u);\n  }\n  ans=k+1;\n  cnt=tmp=0;\n  dfs(0);\n  if(ans<=k) cout<<ans<<endl;\n  else cout<<\"Impossible\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nunsigned long long xor128() {\n    static unsigned long long rx = 123456789, ry = 362436069, rz = 521288629, rw = 88675123;\n    unsigned long long rt = (rx ^ (rx << 11));\n    rx = ry;\n    ry = rz;\n    rz = rw;\n    return (rw = (rw ^ (rw >> 19)) ^ (rt ^ (rt >> 8)));\n}\n\nstd::chrono::system_clock::time_point start;\nstd::chrono::system_clock::time_point owari;\n\nbool A[3003][3003];\nint T[3003];\nint n,m,k,MIN=1e9,cnt[3003];\n\nint main(){\n    start = std::chrono::system_clock::now();\n    cin>>n>>m>>k;\n    r(i,m){\n        int a,b;\n        cin>>a>>b; a--; b--;\n        A[a][b]=A[b][a]=1;\n        cnt[a]++;\n        cnt[b]++;\n    }\n    r(i,n)T[i]=cnt[i];\n    for(;;){\n        int TEMP=0;\n        for(;;){\n            int x,idx=-1,MAX=0;\n            r(i,n){\n                if(MAX<cnt[i]||(cnt[i]&&(xor128()%1881==31))){\n                    MAX=cnt[i];\n                    x=i;\n                }\n                if(cnt[i]==1) idx=i;\n            }\n            if(!MAX)break;\n            TEMP++;\n            if(idx!=-1){\n                r(i,n)if(A[idx][i]&&cnt[i]){\n                    x=i;\n                    break;\n                }\n            }\n            r(i,n)if(A[x][i]&&cnt[i])cnt[i]--;\n            cnt[x]=0;\n        }\n        MIN=min(TEMP,MIN);\n        owari = std::chrono::system_clock::now();\n        double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(owari-start).count();\n        if(elapsed>0.1)break;\n\n        r(i,n)cnt[i]=T[i];\n\n    }\n    if(MIN<=k)cout<<MIN<<endl;\n    else cout<<\"Impossible\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef vector<int> BS;\n\nBS absbs;\nBS is[3000];\nvector<int> idx;\nint a[32345],b[32345];\nint N,M,K;\n\nint rec(const BS &bs,int nth,int r){\n  if(r<0)return r;\n  if(bs.size()==M)return r;\n  while(includes(begin(bs),end(bs),begin(is[idx[nth]]),end(is[idx[nth]]))){\n    nth++;\n  }\n  BS n;\n  set_difference(begin(is[idx[nth]]),end(is[idx[nth]]),begin(bs),end(bs),back_inserter(n));\n  if(n.size()==1){\n    BS nx;\n    set_union(begin(bs),end(bs),begin(is[a[n[0]]^b[n[0]]^idx[nth]]),end(is[a[n[0]]^b[n[0]]^idx[nth]]),back_inserter(nx));\n    return rec(nx,nth+1,r-1);\n  }else{\n    BS nx;\n    set_union(begin(bs),end(bs),begin(is[idx[nth]]),end(is[idx[nth]]),back_inserter(nx));\n    int rv=rec(nx,nth+1,r-1);\n    BS o=bs;\n    for(auto i:n){\n      BS dst;\n      set_union(begin(o),end(o),begin(is[a[i]^b[i]^idx[nth]]),end(is[a[i]^b[i]^idx[nth]]),back_inserter(dst));\n      o.swap(dst);\n    }\n    return max(rv,rec(o,nth+1,r-n.size()));\n  }\n}\n\nint main(){\n  cin>>N>>M>>K;\n  int pop[32345]={};\n  for(int i=0;i<M;i++){\n    cin>>a[i]>>b[i];\n    a[i]--;\n    b[i]--;\n    pop[a[i]]++;\n    pop[b[i]]++;\n    is[a[i]].push_back(i);\n    is[b[i]].push_back(i);\n  }\n  idx.resize(N);\n  iota(begin(idx),end(idx),0);\n  sort(begin(idx),end(idx),[pop](int a,int b){\n      return pop[a]>pop[b];\n    });\n  int r=rec(BS(),0,K);\n  if(r<0){\n    cout<<\"Impossible\"<<endl;\n  }else{\n    cout<<K-r<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef bitset<300000/10> BS;\n\nBS absbs;\nBS is[3000];\nvector<int> idx;\nint a[32345],b[32345];\n\nint rec(const BS &bs,int nth,int r){\n  if(r<0)return r;\n  if(bs==absbs)return r;\n  while((is[idx[nth]]&~bs).none()){\n    nth++;\n  }\n  BS n=is[idx[nth]]&~bs;\n  if(n.count()==1){\n    for(int i=0;;i++){\n      if(n[i]){\n\treturn rec(bs|is[a[i]^b[i]^idx[nth]],nth+1,r-1);\n      }\n    }\n  }else{\n    int rv=rec(bs|is[idx[nth]],nth+1,r-1);\n    BS o=bs;\n    int c=0;\n    for(int i=0;n.any();i++){\n      if(n[i]){\n\to|=bs|is[a[i]^b[i]^idx[nth]];\n\tc++;\n\tn[i]=false;\n      }\n    }\n    return max(rv,rec(o,nth+1,r-c));\n  }\n}\n\nint main(){\n  int N,M,K;\n  cin>>N>>M>>K;\n  int pop[32345]={};\n  for(int i=0;i<M;i++){\n    absbs[i]=true;\n    cin>>a[i]>>b[i];\n    a[i]--;\n    b[i]--;\n    pop[a[i]]++;\n    pop[b[i]]++;\n    is[a[i]][i]=true;\n    is[b[i]][i]=true;\n  }\n  idx.resize(N);\n  iota(begin(idx),end(idx),0);\n  sort(begin(idx),end(idx),[pop](int a,int b){\n      return pop[a]>pop[b];\n    });\n  int r=rec(BS(),0,K);\n  if(r<0){\n    cout<<\"Impossible\"<<endl;\n  }else{\n    cout<<K-r<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n,m,k;\n  cin>>n>>m>>k;\n  vector<vector<int> > G(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  vector<int> v(n);\n  for(int i=0;i<n;i++) v[i]=i;\n  sort(v.begin(),v.end(),\n       [&](int &a,int&b){return G[a].size()>G[b].size();});\n  //for(int u:v) cout<<u<<endl;\n  vector<int> used(n,0);\n  int ans=1000;\n  int sz=0,cnt=0;\n  function<void(int)> dfs=[&](int x){\n    //cout<<x<<\" \"<<cnt<<\" \"<<sz<<endl;\n    if(sz>=ans) return;\n    if(cnt==m){\n      ans=min(ans,sz);\n      return;\n    }\n    if(x==n) return;\n    if(used[v[x]]){\n      dfs(x+1);\n      return;\n    }\n    {\n      used[v[x]]=1;\n      sz++;\n      for(int u:G[v[x]]){\n\tif(!used[u]) cnt++;\n      }\n      dfs(x+1);\n      for(int u:G[v[x]]){\n\tif(!used[u]) cnt--;\n      }\n      used[v[x]]=0;\n      sz--;\n    }\n    {\n      stack<int> st;\n      for(int u:G[v[x]]){\n\tif(!used[u]){\n\t  used[u]=1;\n\t  st.push(u);\n\t  sz++;\n\t  for(int r:G[u]){\n\t    if(!used[r]) cnt++;\n\t  }\n\t}\n      }\n      dfs(x+1);\n      while(!st.empty()){\n\tint u=st.top();st.pop();\n\tassert(used[u]);\n\tused[u]=0;\n\tsz--;\n\tfor(int r:G[u]){\n\t  if(!used[r]) cnt--;\n\t}\n      }\n    }\n    dfs(x+1);\n  };\n  dfs(0);\n  if(ans>k) cout<<\"Impossible\"<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n \nusing namespace std;\n \ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n \nconst int MAX_N = 100005;\n \ntemplate<typename T> class ListIterator;\n \n// 常に不変なイテレーターが欲しい場合に使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n     \nprivate:\n    int N, sz;\n    vector<int> prev, next;\n    vector<T> container;\n    friend ListIterator<T>;\n     \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n     \npublic:\n    friend ostream& operator<< (ostream& os, List& ls){\n        for(auto& val : ls){\n            os << val << ' ';\n        }\n        return os;\n    }\n    const T& operator[](size_t index) const {\n        return container[index];\n    }\n    T& operator[](size_t index){\n        return container[index];\n    }\n    size_t size(){\n        return sz;\n    }\n    bool empty(){\n        return size() == 0;\n    }\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n    iterator begin(){\n        return iterator(this, next[N]);\n    }\n    iterator end(){\n        return iterator(this, N);\n    }\n    iterator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n    iterator push_back(){\n        return insert(N, prev[N]+1);\n    }\n    void pop_back(){\n        erase(prev[N]);\n    }\n    void clear(){\n        N = sz = 0;\n        prev = next = {0};\n        container.clear();\n    }\n     \npublic:\n    List() : N(0), sz(0), prev({0}), next({0}){}\n    List(int _N) : container(_N){\n        build();\n    }\n    List(int _N, T val) : container(_N, val){\n        build();\n    }\n    List(const List& ls):\n        N(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n        build();\n    }\n    iterator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n        container.push_back(val);\n        return iterator(this, N-1);\n    }\n    void build(){\n        N = sz = (int)container.size();\n        prev.resize(N+1), next.resize(N+1);\n        iota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n    }\n};\n \ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n    friend List<T>;\n    List<T>* ls_ptr;\n    int index;\n \nprivate:\n    ListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n     \npublic:\n    ListIterator(){}\n    ListIterator(const ListIterator& itr){\n        ls_ptr = itr.ls_ptr, index = itr.index;\n    }\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    T& operator*() const {\n        return ls_ptr->container[index];\n    }\n    T* operator->() const {\n        return &ls_ptr->container[index];\n    }\n    ListIterator& operator++(){\n        index = ls_ptr->next[index];\n        return *this;\n    }\n    ListIterator operator++(int){\n        ListIterator res = *this;\n        index = ls_ptr->next[index];\n        return res;\n    }\n    ListIterator& operator--(){\n        index = ls_ptr->prev[index];\n        return *this;\n    };\n    ListIterator operator--(int){\n        ListIterator res = *this;\n        index = ls_ptr->prev[index];\n        return res;\n    };\n    bool operator==(const ListIterator& itr) const {\n        return !(*this != itr);\n    };\n    bool operator!=(const ListIterator& itr) const {\n        return this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n    }\n    friend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n        ListIterator<T> tmp = itr1;\n        itr1 = itr2, itr2 = itr1;\n    };\n};\n \n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n     \n    bool push_cand(int u, int& add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n     \n    bool erase(int u, bool use, bool alr_use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int& add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool reset(){\n        small_deg_ver.clear(), use_ver.clear();\n        return false;\n    }\n    bool erase_rec(int u, bool use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return reset();\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return reset();\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return reset();\n        }\n        return true;\n    }\n    bool preprocessing(int K, int& add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        transition(K, next_ver, true);\n        if((int)cand.size() + (int)G[next_ver].size() < ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n     \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n \nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    int N, sz;\n    vector<int> prev, next;\n    \nprivate:\n\tvector<T> container;\n\t// ListIterator<T> からのアクセスを許可する\n\tfriend ListIterator<T>;\n    // 添字 index の要素の前に添字 の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[now_index]] = next[now_index], prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の添字を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n\t\tprev.clear(), next.clear(), container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    int index;\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺を含まないとする\nclass MVC {\nprivate:\n    struct edge {\n        int to;\n        List<edge>::iterator rev;\n        edge(int _to) : to(_to){}\n    };\n    \n    int V, rem_ver, rem_edge;\n    bool ok;\n    vector<List<edge> > G;\n    vector<pair<int, int> > es;\n    vector<int> deg, ver;\n    vector<bool> rem, use;\n    \n    void delete_edge(const int u, vector<int>& ch, vector<List<edge>::iterator>& ech, vector<int>& add, bool _use){\n        for(auto& e : G[u]){\n            if(_use) use[e.to] = true, add.push_back(e.to);\n            ech.push_back(G[e.to].erase(e.rev)), deg[e.to]--, rem_edge--, ch.push_back(e.to);\n            if(deg[e.to] == 0) rem[e.to] = false, rem_ver--;\n        }\n    }\n    void inv_delete_edge(const int u, vector<int>& ch, vector<List<edge>::iterator>& ech, vector<int>& add, bool _use){\n        for(int i = (int)ch.size() - 1; i >= 0; i--){\n            int v = ch[i];\n            if(_use) use[v] = false, add.pop_back();\n            G[v].insert(ech[i], u), deg[v]++, rem_edge++;\n            if(deg[v] == 1) rem[v] = true, rem_ver++;\n        }\n    }\n    void preprocessing(const int K, vector<int>& ans){\n        for(int i = 0; i < V; i++){\n            if(deg[i] > K){\n                ans.push_back(i), rem[i] = false;\n            }else{\n                ver.push_back(i), rem_ver++;\n            }\n        }\n        for(auto& e : es){\n            if(rem[e.first] && rem[e.second]){\n                rem_edge++;\n            }else{\n                if(rem[e.first]) deg[e.first]--;\n                if(rem[e.second]) deg[e.second]--;\n            }\n        }\n        for(auto& e : es){\n            if(rem[e.first] && rem[e.second]){\n                auto it1 = G[e.first].push_back(edge(e.second));\n                auto it2 = G[e.second].push_back(edge(e.first));\n                G[e.first].back().rev = it2, G[e.second].back().rev = it1;\n            }\n        }\n    }\n    void rec(const int K, vector<int>& add, vector<int>& add_opt){\n        if(rem_edge == 0){\n            ok = true;\n            if(add_opt.empty() || (int)add.size() < (int)add_opt.size()) add_opt = add;\n            return;\n        }\n        // 最大次数の頂点から探索\n        int max_deg = numeric_limits<int>::min(), pos = -1;\n        for(int v : ver){\n            if(rem[v] && deg[v] > max_deg){\n                max_deg = deg[v], pos = v;\n            }\n        }\n        // 枝数の条件\n        if(rem_edge > max_deg*rem_ver) return;\n        rem[pos] = false, rem_ver--;\n        if(use[pos] || max_deg >= 2){\n            // 使う場合\n            vector<int> ch;\n            vector<List<edge>::iterator> ech;\n            delete_edge(pos, ch, ech, add, false);\n            if(!use[pos]) add.push_back(pos);\n            if((int)add.size() + (int)ans.size() <= K) rec(K, add, add_opt);\n            if(!use[pos]) add.pop_back();\n            inv_delete_edge(pos, ch, ech, add, false);\n        }\n        if(use[pos]) return;\n        // 使わない場合\n        vector<int> ch;\n        vector<List<edge>::iterator> ech;\n        delete_edge(pos, ch, ech, add, true);\n        if((int)add.size() + (int)ans.size() <= K) rec(K, add, add_opt);\n        inv_delete_edge(pos, ch, ech, add, true);\n        rem[pos] = true, rem_ver++;\n        return;\n    }\npublic:\n    vector<int> ans;\n    \n    MVC(int node_size) :\n        V(node_size), rem_ver(0), rem_edge(0), ok(false), G(V), deg(V, 0), rem(V, true), use(V, false){}\n    void add_edge(const int u, const int v){\n        es.emplace_back(u, v);\n        deg[u]++, deg[v]++;\n    }\n    bool judge(const int K){\n        preprocessing(K, ans);\n        vector<int> add, add_opt;\n        rec(K, add, add_opt);\n        for(int v : add_opt){\n            ans.push_back(v);\n        }\n        sort(ans.begin(), ans.end());\n        return ok && (int)ans.size() <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.judge(K)){\n        cout << len(mvc.ans) << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nunsigned long long xor128() {\n    static unsigned long long rx = 123456789, ry = 362436069, rz = 521288629, rw = 88675123;\n    unsigned long long rt = (rx ^ (rx << 11));\n    rx = ry;\n    ry = rz;\n    rz = rw;\n    return (rw = (rw ^ (rw >> 19)) ^ (rt ^ (rt >> 8)));\n}\n\nstd::chrono::system_clock::time_point start;\nstd::chrono::system_clock::time_point owari;\n\nbool A[3003][3003];\nint T[3003];\nint n,m,k,MIN=1e9,cnt[3003];\n\nint main(){\n    start = std::chrono::system_clock::now();\n    cin>>n>>m>>k;\n    r(i,m){\n        int a,b;\n        cin>>a>>b; a--; b--;\n        A[a][b]=A[b][a]=1;\n        cnt[a]++;\n        cnt[b]++;\n    }\n    r(i,n)T[i]=cnt[i];\n    for(;;){\n        int TEMP=0;\n        for(;;){\n            int x,idx=-1,MAX=0;\n            r(i,n){\n                if(MAX<cnt[i]||(cnt[i]&&(xor128()%50==1))){\n                    MAX=cnt[i];\n                    x=i;\n                }\n                if(cnt[i]==1) idx=i;\n            }\n            if(!MAX)break;\n            TEMP++;\n            if(idx!=-1){\n                r(i,n)if(A[idx][i]&&cnt[i]){\n                    x=i;\n                    break;\n                }\n            }\n            r(i,n)if(A[x][i]&&cnt[i])cnt[i]--;\n            cnt[x]=0;\n        }\n        MIN=min(TEMP,MIN);\n        owari = std::chrono::system_clock::now();\n        double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(owari-start).count();\n        if(elapsed>0.1)break;\n\n        r(i,n)cnt[i]=T[i];\n\n    }\n    if(MIN<=k)cout<<MIN<<endl;\n    else cout<<\"Impossible\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define llu unsigned long long\n\nvector<int> adj[3005];\nint ans, flag[3005], n;\n\nvector<int> tmp[40];\n\ninline int deg(int v) {\n\tint ret = 0;\n\tfor (int i = 0; i < (int)adj[v].size(); i++)\n\t\tret += (flag[adj[v][i]] == 0);\n\treturn ret;\n}\n\nvoid dfs(int cur) {\n\tif (cur >= ans) return;\n\n\t//cek udah selesai atau belum\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (flag[i]) {\n\t\t\tcnt++; continue;\n\t\t}\n\n\t\tif (deg(i) == 0) cnt++;\n\t\telse break;\n\t}\n\n\tif (cnt == n) {\n\t\tans = min(ans, cur);\n\t\treturn;\n\t}\n\n\tfor (int v = 1; v <= n; v++) {\n\t\tif (flag[v]) continue;\n\n\t\tint degree = deg(v);\n\t\tif (degree == 0) continue;\n\n\t\t//coba di flag\n\t\tif (degree > 1) {\n\t\t\tflag[v] = 1;\n\t\t\tdfs(cur+1);\n\t\t}\n\n\t\t//coba nggak diflag\n\t\ttmp[cur].clear();\n\n\t\tfor (int i = 0; i < (int)adj[v].size(); i++) {\n\t\t\tint cand = adj[v][i];\n\t\t\tif (flag[cand]) continue;\n\n\t\t\tflag[cand] = 1;\n\t\t\ttmp[cur].push_back(cand);\n\t\t}\n\n\t\tdfs(cur+degree);\n\n\t\tflag[v] = 0;\n\t\tfor (int i = 0; i < (int)tmp[cur].size(); i++)\n\t\t\tflag[tmp[cur][i]] = 0;\n\t}\n}\n\nint main() {\n\tint m, k, u, v;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tadj[u].push_back(v), adj[v].push_back(u);\n\t}\n\n\tans = k+1;\n\tdfs(0);\n\n\tif (ans > k)\n\t\tprintf(\"Impossible\\n\");\n\telse\n\t\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\nint n,m, k, a, b;\nint adj[3005][3005];\nint deg[3005], ndeg[3005];\nvector<int> v[3005];\nbool flag[3005];\nbool relax[3005];\nint construct(bool first) {\n\tint res = 0;\n\tfor(int i = 1; i <= n; i++) deg[i] = ndeg[i];\n\tfor(int i = 1; i <= n; i++) {\n\t\tint maxd = -1;\n\t\tint id = -1;\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (deg[j] >= maxd) {\n\t\t\t\tmaxd = deg[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (maxd <= 0) break;\n\t\tif (first) {\n\t\t\tfor(int j = 1; j <= n; j++) {\n\t\t\t\tif (adj[id][j]) {\n\t\t\t\t\tdeg[j] = 0;\n\t\t\t\t\tres++;\n\t\t\t\t\tfor(int k = 1; k <= n; k++) {\n\t\t\t\t\t\tif (adj[j][k] && deg[k] > 0) deg[k] -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(deg[id] == 0);\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tres += 1;\n\t\t\tdeg[id] = 0;\n\t\t\tfor(int j = 1; j <= n; j++) if (adj[id][j] && deg[j] > 0) deg[j] -= 1;\n\t\t}\n\t}\n\treturn res;\n}\nvoid dfs(int now) {\n\tint sz = v[now].size();\n\tflag[now] = true;\n\tndeg[now] = sz;\n\tfor(int i = 0; i < sz; i++) {\n\t\tif (!flag[v[now][i]]) {\n\t\t\tflag[v[now][i]] = true;\n\t\t\tdfs(v[now][i]);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t\tadj[a][b] = 1;\n\t\tadj[b][a] = 1;\n\t}\n\tmemset(flag,false,sizeof(flag));\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif (!flag[i]) {\n\t\t\tmemset(ndeg,0,sizeof(ndeg));\n\t\t\tdfs(i);\n\t\t\tint gg = min(construct(false),construct(true));\n\t\t\tans += gg;\n\t\t}\n\t}\n\tif (ans > k) printf(\"Impossible\\n\");\n\telse printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cincout\n#define min(a,b) ((a) < (b) ? (a) : (b))\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define abs(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\n\nint deg[30005];\nbool cov[30005];\nint n,m,k,ans;\nint a,b;\nvector <pair <int, int> > edgelist;\nint main() {\n\t#ifdef cincout\n\t\tcin.sync_with_stdio(0);\n\t\tcin.tie(0);\n\t#endif\n\tcin >> n >> m >> k;\n\tmemset(deg,0,sizeof(deg));\n\tfor (int i=0;i<m;++i) {\n\t\tcin >> a >> b;\n\t\tedgelist.push_back(make_pair(a,b));\n\t\t++deg[a];\n\t\t++deg[b];\n\t}\n\tmemset(cov,false,sizeof(cov));\n\tfor (int i=0;i<m;++i) {\n\t\tif (cov[edgelist[i].first] || cov[edgelist[i].second]) continue;\n\t\telse {\n\t\t\tif (deg[edgelist[i].first] > deg[edgelist[i].second]) cov[edgelist[i].first]=true;\n\t\t\telse cov[edgelist[i].second]=true;\n\t\t\t++ans;\n\t\t}\n\t}\n\tif (ans>k) cout << \"Impossible\\n\";\n\telse cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int add_size, vector<pair<int, int> >& erase_ver){\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(add_size, erase_ver);\n        if(!check()) return postprocessing(add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        if(K != fp_size) return postprocessing(add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define ll long long\n#define line printf(\"\\n\")\n#define rep(a,b,c) for(int a= (int)b;a<(int)c;a++)\n#define repd(a,b,c) for(int a=(int)b;a>=c;a--)\n#define pb push_back\n#define pf push_front\n#define pb2 pop_back\n#define pf2 pop_front\n#define pq priority_queue\n#define haha printf(\"hahaha\\n\")\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e17;\nconst double EPS = 1e-5;\n\nusing namespace std;\n\nvector<int> adj[3005],adj2[3005];\npii edge[30005];\nint flag[3005],deg[3005];\nint n,m,d,rem;\n\n\nint brute(int i,int sisa){\n\t\n\tint ret = -INF;\n\tif(sisa<0)return -INF;\n\trep(k,i,m){\n\t\tint a = edge[k].fi;\n\t\tint b = edge[k].se;\n\t\tif(flag[a] || flag[b])continue;\n\t\tif(deg[a]<deg[b])swap(a,b);\n\t\tvector<int>reset;\n\t\t//use a\n\t\tflag[a] = 1;\n\t\trep(l,0,adj[a].size()){\n\t\t\tint next = adj[a][l];\n\t\t\tif(!flag[next]){\n\t\t\t\tdeg[next]--;\n\t\t\t\treset.pb(next);\n\t\t\t}\n\t\t}\n\t\tret = max(ret,brute(i+1,sisa-1));\n\t\t\n\t\t//not use a\n\t\tflag[a] = 0;\n\t\twhile(reset.size())deg[reset.back()]++,reset.pb2();\n\t\t\n\t\trep(l,0,adj[a].size()){\n\t\t\tint next  = adj[a][l];\n\t\t\tif(flag[next]==0){\n\t\t\t\tsisa--;\n\t\t\t\tflag[next] = 1;\n\t\t\t\treset.pb(next);\n\t\t\t\trep(j,0,adj[next].size())deg[adj[next][j]]--;\n\t\t\t}\n\t\t}\t\n\t\tret = max(ret,brute(i+1,sisa));\n\t\twhile(reset.size()){\n\t\t\tint now = reset.back();\n\t\t\tflag[now] = 0;\n\t\t\trep(j,0,adj[now].size())deg[adj[now][j]]++;\n\t\t\treset.pb2();\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\treturn sisa;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&d);\n\t\n\trep(k,0,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);a--;b--;\n\t\t\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t\tedge[k] = mp(a,b);\n\t\tdeg[a]++;deg[b]++;\n\t}\n\t\n\tint bisa = 1;\n\trem = d;\n\twhile(bisa){\n\t\tbisa = 0;\n\t\trep(k,0,n)if(!flag[k] && deg[k]>rem){\n\t\t\tflag[k] = 1;\n\t\t\trem--;\n\t\t\trep(i,0,adj[k].size())deg[adj[k][i]]--;\n\t\t\tbisa = 1;\n\t\t}\n\t\tif(rem<0)break;\n\t}\n\tif(rem<0){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\trep(k,0,n){\n\t\tvector<int> tmp;\n\t\trep(i,0,adj[k].size()){\n\t\t\tint next = adj[k][i];\n\t\t\tif(flag[next])continue;\n\t\t\ttmp.pb(next);\n\t\t}\n\t\tadj[k] = tmp;\n\t\tdeg[k] = adj[k].size();\n\t}\n\tint M = 0;\n\trep(k,0,m){\n\t\tint a = edge[k].fi;\n\t\tint b = edge[k].se;\n\t\tif(flag[a] || flag[b])continue;\n\t\tedge[M++] = edge[k];\n\t//\tprintf(\"%d %d\\n\",edge[M-1].fi,edge[M-1].se);\n\t}\n\tm = M;\n\tif(m>d*d){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\t\n\tint tmp = brute(0,rem);\n\tif(tmp<0)printf(\"Impossible\\n\");\n\telse printf(\"%d\\n\",d-tmp);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nint N, M, K;\nint deg[3030];\nbool used[3030];\nint ans;\nvector<pair<int, int>> edges;\nvector<vector<int>> nodes;\nint h() {\n    bool used2[3030];\n    REP(i, N) used2[i] = used[i];\n    int res = 0;\n    for(auto p : edges) {\n        if(used2[p.first] || used2[p.second]) continue;\n        used2[p.first] = used2[p.second] = true;\n        res++;\n    }\n    return res;\n}\nvoid dfs(int idx, int cnt) {\n    int hr = h();\n    if(cnt + hr >= ans) return;\n    if(hr == 0) { ans = cnt; return; }\n\n    const int E = nodes[idx].size();\n    vector<bool> back(E);\n    bool nouse_ok = true;\n\n    for(int i = 0; i < E; i++) {\n        const int v = nodes[idx][i];\n        back[i] = used[v];\n        deg[v]--;\n\n        if(v < idx && !used[v]) nouse_ok = false;\n    }\n\n    if(deg[idx] > 0) {\n        used[idx] = true;\n        dfs(idx+1, cnt+1);\n        used[idx] = false;\n    }\n\n    for(int i = 0; i < E; i++) {\n        const int v = nodes[idx][i];\n        used[v] = back[i];\n        deg[v]++;\n    }\n\n    if(nouse_ok) {\n        dfs(idx+1, cnt);\n    }\n}\nint main(){\n    iostream_init();\n    while(cin >> N >> M >> K) {\n        memset(deg, 0, sizeof(deg));\n        memset(used, 0, sizeof(used));\n        edges.resize(M);\n        nodes.assign(N, vector<int>());\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            if(a > b) swap(a, b);\n            nodes[a].push_back(b);\n            nodes[b].push_back(a);\n            edges[i] = make_pair(a, b);\n            deg[a]++;\n            deg[b]++;\n        }\n\n        vector<int> perm(N);\n        REP(i, N) perm[i] = i;\n        REP(j, N) REP(i, j) if(deg[perm[i]] < deg[perm[j]]) swap(perm[i], perm[j]);\n        map<int, int> to;\n        REP(i, N) to[ perm[i] ] = i;\n\n        int deg_tmp[3030];\n        REP(i, N) deg_tmp[i] = deg[i];\n        REP(i, N) deg[i] = deg_tmp[ perm[i] ];\n\n        auto nodes_tmp = nodes;\n        REP(i, N) nodes[i] = nodes_tmp[ perm[i] ];\n        REP(i, N) REP(j, nodes[i].size()) nodes[i][j] = to[ nodes[i][j] ];\n\n        REP(i, M) edges[i] = make_pair(to[ edges[i].first ], to[ edges[i].second ]);\n\n        ans = K+1;\n        dfs(0, 0);\n        if(ans == K+1) {\n            cout << \"Impossible\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\t// ListIterator<T> からのアクセスを許可する\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の添字を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    int index;\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use) add_size++, cand.push_back(u);\n        // ans より良い解が得られないと分かった\n        if((int)cand.size() >= ans_size) return false;\n        erase_ver.emplace_back(u, rem_ver.erase(u).index);\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev).index);\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to).index);\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                add_size++, cand.push_back(e.to);\n                // ans より良い解が得られないと分かった\n                if((int)cand.size() >= ans_size) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        // cout << u << endl;\n        // cout << rem_ver << endl;\n        // sset(small_deg_ver), sset(use_ver);\n        // svec(cand);\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            while(!small_deg_ver.empty()){\n                int v = *small_deg_ver.begin();\n                small_deg_ver.erase(v);\n                if(deg[v] == 0) continue;\n                if(!erase(v, false, false, add_size, erase_ver)) return false;\n                // cout << \"--------------------------------------\" << endl;\n                // cout << v << endl;\n                // cout << rem_ver << endl;\n                // sset(small_deg_ver), sset(use_ver);\n                // svec(cand);\n            }\n            while(!use_ver.empty()){\n                int v = *use_ver.begin();\n                use_ver.erase(v);\n                if(deg[v] == 0) continue;\n                if(!erase(v, true, true, add_size, erase_ver)) return false;\n                // cout << \"======================================\" << endl;\n                // cout << v << endl;\n                // cout << rem_ver << endl;\n                // sset(small_deg_ver), sset(use_ver);\n                // svec(cand);\n            }\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int add_size, vector<pair<int, int> >& erase_ver){\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(pl_add_size, pl_erase_ver);\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(add_size, erase_ver);\n        if(!check()) return postprocessing(add_size, erase_ver);\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()){\n            return postprocessing(add_size, erase_ver);\n        }\n        // show(rem_ver);\n        // show(next_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        ans_size = K + 1;\n        judge(K);\n        return ans_size <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    // svec(mvc.ans_set);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nunsigned long long xor128() {\n    static unsigned long long rx = 123456789, ry = 362436069, rz = 521288629, rw = 88675123;\n    unsigned long long rt = (rx ^ (rx << 11));\n    rx = ry;\n    ry = rz;\n    rz = rw;\n    return (rw = (rw ^ (rw >> 19)) ^ (rt ^ (rt >> 8)));\n}\n\nstd::chrono::system_clock::time_point start;\nstd::chrono::system_clock::time_point owari;\n\nbool A[3003][3003];\nint T[3003];\nint n,m,k,MIN=1e9,cnt[3003];\n\nint main(){\n    start = std::chrono::system_clock::now();\n    cin>>n>>m>>k;\n    r(i,m){\n        int a,b;\n        cin>>a>>b; a--; b--;\n        A[a][b]=A[b][a]=1;\n        cnt[a]++;\n        cnt[b]++;\n    }\n    r(i,n)T[i]=cnt[i];\n    for(;;){\n        int TEMP=0;\n        for(;;){\n            int x,idx=-1,MAX=0;\n            r(i,n){\n                if(MAX<cnt[i]||(cnt[i]&&(xor128()%10==1))){\n                    MAX=cnt[i];\n                    x=i;\n                }\n                if(cnt[i]==1) idx=i;\n            }\n            if(!MAX)break;\n            TEMP++;\n            if(idx!=-1){\n                r(i,n)if(A[idx][i]&&cnt[i]){\n                    x=i;\n                    break;\n                }\n            }\n            r(i,n)if(A[x][i]&&cnt[i])cnt[i]--;\n            cnt[x]=0;\n        }\n        MIN=min(TEMP,MIN);\n        owari = std::chrono::system_clock::now();\n        double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(owari-start).count();\n        if(elapsed>0.1)break;\n\n        r(i,n)cnt[i]=T[i];\n\n    }\n    if(MIN<=k)cout<<MIN<<endl;\n    else cout<<\"Impossible\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\tint N, M, K;\n\nint getans(const vector<vector<int>>&edges,const int now, const int use,vector<int>&used) {\n\tif (now == edges.size() || edges[now].empty())return use;\n\tint ans = 33;\n\t\n\tif (used[now]) {\n\t\treturn getans(edges, now + 1, use, used);\n\t}\n\telse {\n\t\tif (use + 1 <= K) {\n\t\t\tused[now] = true;\n\t\t\tans = min(ans, getans(edges,now + 1, use + 1, used));\n\t\t\tused[now] = false;\n\t\t}\n\t\tint nextuse = use;\n\t\tvector<int>newused;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!used[e]) {\n\t\t\t\tused[e] = true;\n\t\t\t\tnewused.push_back(e);\n\t\t\t}\n\t\t}\n\t\tif (use + newused.size() <= K) {\n\t\t\tans = min(ans, getans(edges, now + 1, use + newused.size(), used));\n\t\t}\n\t\tfor (auto u : newused) {\n\t\t\tused[u] = false;\n\t\t}\n\t\t//while(edges[num].first==)\n\t}\n\treturn ans;\n}\nint main() {cin >> N >> M >> K;\n\tvector<pair<int, int>>ps(N);\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tps[i] = make_pair(0, i);\n\t}\n\tvector<vector<int>>aedges(N);\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\taedges[a].push_back(b);\n\t\taedges[b].push_back(a);\n\t\tps[a].first++;\n\t\tps[b].first++;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t}\n\tfor (auto &p : ps) {\n\t\tif (p.first == 0)p.first = -1e8;\n\t}\n\t\n\tmap<int, int>mp;\n\tfor (int i = 0; i <aset.size(); ++i) {\n\t\tauto it = max_element(ps.begin(), ps.end(), [](const auto &l, const auto&r) {\n\t\t\treturn l.first < r.first;\n\t\t});\n\t\tfor (auto e : aedges[it->second]) {\n\t\t\tps[e].first--;\n\t\t}\n\t\tit->first = -1;\n\t\tmp[it->second] = i;\n\t}\n\tvector<vector<int>>realedges(mp.size());\n\tfor (int i = 0; i < aedges.size(); ++i) {\n\t\tfor (auto e : aedges[i]) {\n\t\t\tif (mp[i] < mp[e]) {\n\t\t\t\trealedges[mp[i]].push_back(mp[e]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>used(mp.size());\n\tint ans = getans(realedges, 0, 0, used);\n\tif (ans == 33) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\n\t\tcout << ans << endl;\n\t}\n\t//for()\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n#define N 33333\n\nint U[N],D[N],L[N],R[N],X[N],C[N],H[N],S[N],Q[N],size,n,m,ans;\n\nvoid init()\n{\n    for (int i=0;i<=m;i++)\n    {\n        U[i]=D[i]=i;\n        L[i]=i-1;\n        R[i]=i+1;\n        S[i]=0;\n    }\n    L[0]=m;\n    R[m]=0;\n    size=m+1;\n}\n\nvoid link(int r,int c)\n{\n    S[c]++;\n    X[size]=r;\n    C[size]=c;\n    U[size]=c;\n    D[size]=D[c];\n    U[D[size]]=size;\n    D[c]=size;\n    if (H[r]==-1) H[r]=L[size]=R[size]=size;\n    else\n    {\n        L[size]=H[r];\n        R[size]=R[H[r]];\n        L[R[size]]=size;\n        R[H[r]]=size;\n    }\n    X[size++]=r;\n}\n\nint h()\n{\n    int ret=0;\n    bool vis[N];\n    memset (vis, false, sizeof(vis));\n    for (int i=R[0]; i; i=R[i])\n    {\n        if(vis[i])continue;\n        ret++;\n        vis[i]=true;\n        for (int j=D[i]; j!=i; j=D[j])\n            for (int k=R[j]; k!=j; k=R[k])\n                vis[C[k]]=true;\n    }\n    return ret;\n}\n\nvoid remove(int i)\n{\n    for (int j=D[i];j!=i;j=D[j])\n    {\n        R[L[j]]=R[j];\n        L[R[j]]=L[j];\n    }\n}\n\nvoid resume(int i)\n{\n    for (int j=U[i];j!=i;j=U[j])\n        R[L[j]]=L[R[j]]=j;\n}\n\nvoid dance(int i)\n{\n    if (i+h()>ans) return;\n    if (!R[0]) ans=i;\n    int c=R[0];\n    for (int j=R[0];j;j=R[j])\n        if (S[j]<S[c])\n            c=j;\n    for (int j=D[c];j!=c;j=D[j])\n    {\n        Q[i]=j;\n        remove(j);\n        for (int k=R[j];k!=j;k=R[k])\n            remove(k);\n        dance(i+1);\n        for (int k=L[j];k!=j;k=L[k])\n            resume(k);\n        resume(j);\n    }\n}\n\nint main()\n{\n    int k,x,y;\n    scanf(\"%d%d%d\",&n,&m,&k);\n    ans=k+1;\n    init();\n    for (int i=0;i<=n;i++) H[i]=-1;\n    for (int i=1;i<=m;++i)\n    {\n        scanf(\"%d%d\",&x,&y);\n        link(x,i);\n        link(y,i);\n    }\n    dance(0);\n    if (ans<=k) cout<<ans<<endl;\n    else puts(\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\nint n,m, k, a, b;\nint adj[3005][3005];\nint deg[3005], ndeg[3005];\nvector<int> v[3005];\nbool flag[3005];\nbool relax[3005];\nint construct(bool first) {\n\tint res = 0, id2 = -1;\n\tfor(int i = 1; i <= n; i++) deg[i] = ndeg[i];\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tint maxd = -1;\n\t\tint id = -1;\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (deg[j] > maxd && j != id2) {\n\t\t\t\tmaxd = deg[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (maxd <= 0) break;\n\t\tif (first) {\n\t\t\tid2 = id;\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tres += 1;\n\t\t\tdeg[id] = 0;\n\t\t\tfor(int j = 1; j <= n; j++) if (adj[id][j] && deg[j] > 0) deg[j] -= 1;\n\t\t}\n\t}\n\treturn res;\n}\nvoid dfs(int now) {\n\tint sz = v[now].size();\n\tflag[now] = true;\n\tndeg[now] = sz;\n\tfor(int i = 0; i < sz; i++) {\n\t\tif (!flag[v[now][i]]) {\n\t\t\tdfs(v[now][i]);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t\tadj[a][b] = 1;\n\t\tadj[b][a] = 1;\n\t}\n\tmemset(flag,false,sizeof(flag));\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif (!flag[i]) {\n\t\t\tmemset(ndeg,0,sizeof(ndeg));\n\t\t\tdfs(i);\n\t\t\tint gg = min(construct(false),construct(true));\n\t\t\tans += gg;\n\t\t}\n\t}\n\tif (ans > k) printf(\"Impossible\\n\");\n\telse printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nint N, M, K;\nint deg[3030];\nbool used[3030];\nint ans;\nvector<pair<int, int>> edges;\nvector<vector<int>> nodes;\nconst int TLE = 7.9 * CLOCKS_PER_SEC;\nclock_t start_time;\nint h() {\n    bool used2[3030];\n    REP(i, N) used2[i] = used[i];\n    int res = 0;\n    for(auto p : edges) {\n        if(used2[p.first] || used2[p.second]) continue;\n        used2[p.first] = used2[p.second] = true;\n        res++;\n    }\n    return res;\n}\nvoid dfs(int idx, int cnt) {\n    int hr = h();\n    if(cnt + hr >= ans) return;\n    if(hr == 0) { ans = cnt; return; }\n\n    clock_t diff = clock() - start_time;\n    if(diff > TLE) { return; }\n\n    const int E = nodes[idx].size();\n    vector<bool> back(E);\n    bool nouse_ok = true;\n\n    for(int i = 0; i < E; i++) {\n        const int v = nodes[idx][i];\n        back[i] = used[v];\n        deg[v]--;\n\n        if(v < idx && !used[v]) nouse_ok = false;\n    }\n\n    if(deg[idx] > 0) {\n        used[idx] = true;\n        dfs(idx+1, cnt+1);\n        used[idx] = false;\n    }\n\n    for(int i = 0; i < E; i++) {\n        const int v = nodes[idx][i];\n        used[v] = back[i];\n        deg[v]++;\n    }\n\n    if(nouse_ok) {\n        dfs(idx+1, cnt);\n    }\n}\nint main(){\n    iostream_init();\n    start_time = clock();\n    while(cin >> N >> M >> K) {\n        memset(deg, 0, sizeof(deg));\n        memset(used, 0, sizeof(used));\n        edges.resize(M);\n        nodes.assign(N, vector<int>());\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            if(a > b) swap(a, b);\n            nodes[a].push_back(b);\n            nodes[b].push_back(a);\n            edges[i] = make_pair(a, b);\n            deg[a]++;\n            deg[b]++;\n        }\n\n        vector<int> perm(N);\n        REP(i, N) perm[i] = i;\n        REP(j, N) REP(i, j) if(deg[perm[i]] < deg[perm[j]]) swap(perm[i], perm[j]);\n        map<int, int> to;\n        REP(i, N) to[ perm[i] ] = i;\n\n        int deg_tmp[3030];\n        REP(i, N) deg_tmp[i] = deg[i];\n        REP(i, N) deg[i] = deg_tmp[ perm[i] ];\n\n        auto nodes_tmp = nodes;\n        REP(i, N) nodes[i] = nodes_tmp[ perm[i] ];\n        REP(i, N) REP(j, nodes[i].size()) nodes[i][j] = to[ nodes[i][j] ];\n\n        REP(i, M) edges[i] = make_pair(to[ edges[i].first ], to[ edges[i].second ]);\n\n        ans = K+1;\n        dfs(0, 0);\n        if(ans == K+1) {\n            cout << \"Impossible\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, a, b, tot = 0, hitung[3009], maks;\nbool graph[3009][3009];\nint main(){\n    int i, j;\n    memset(hitung, 0, sizeof(hitung));\n    scanf(\"%d %d %d\", &n, &m, &k);\n    for (i = 0; i < m; i++){\n        scanf(\"%d %d\", &a, &b);\n        graph[a][b] = 1;\n        graph[b][a] = 1;\n        hitung[a]++;  hitung[b]++;\n    }\n    for (i = 0; i < k; i++){\n        maks = 0;\n        for (j = 1; j <= n; j++){\n            if (hitung[j] > maks){\n                maks = hitung[j];\n                a = j;\n            }\n        }\n        if (maks == 0){\n            printf(\"%d\\n\", i);\n            return 0;\n        }\n        hitung[a] = 0;\n        for (j = 1; j <= 3000; j++){\n            if (graph[a][j]){\n                graph[a][j] = 0;\n                graph[j][a] = 0;\n                hitung[j]--;\n            }\n        }\n    }\n    for (i = 1; i <= n; i++){\n        if (hitung[i] > 0){\n            printf(\"impossible\\n\");\n            return 0;\n        }\n    }\n    printf(\"%d\\n\", k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int add_size, vector<pair<int, int> >& erase_ver){\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(add_size, erase_ver);\n        if(!check()) return postprocessing(add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        ans_size = K + 1;\n        judge(K);\n        return ans_size <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f fafa\n#define s second\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\nint n,m, k, a, b, minim;\nint adj[3005][3005];\nint deg[3005], ndeg[3005];\nvector<int> v[3005];\nbool flag[3005];\nbool relax[3005];\nint constructt(bool first) {\n\tint res = 0, id2 = -1;\n\tbool fafa = first;\n\tfor(int i = 1; i <= n; i++) deg[i] = ndeg[i];\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tint maxd = -1;\n\t\tint id = -1;\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (deg[j] >= maxd && j != id2) {\n\t\t\t\tmaxd = deg[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (maxd <= 0) break;\n\t\tif (fafa) {\n\t\t\tid2 = id;\n\t\t\tfafa = false;\n\t\t} else {\n\t\t\t// printf(\"cacad\\n\");\n\t\t\tres += 1;\n\t\t\tdeg[id] = 0;\n\t\t\tfor(int j = 1; j <= n; j++) if (adj[id][j] && deg[j] > 0) deg[j] -= 1;\n\t\t}\n\t}\n\treturn res;\n}\nint constructt2(bool first) {\n\tint res = 0, id2 = -1;\n\tbool fafa = first;\n\tfor(int i = 1; i <= n; i++) deg[i] = ndeg[i];\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tint maxd = -1;\n\t\tint id = -1;\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (deg[j] >= maxd && j != id2) {\n\t\t\t\tmaxd = deg[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (maxd <= 0) break;\n\t\tif (fafa) {\n\t\t\tid2 = id;\n\t\t\tfafa = false;\n\t\t} else {\n\t\t\t// printf(\"cacad2\\n\");\n\t\t\tid2 = -1;\n\t\t\tres += 1;\n\t\t\tdeg[id] = 0;\n\t\t\tfor(int j = 1; j <= n; j++) if (adj[id][j] && deg[j] > 0) deg[j] -= 1;\n\t\t}\n\t}\n\treturn res;\n}\nint constructt3(bool first) {\n\tint res = 0, id2 = -1;\n\tbool fafa = first;\n\tfor(int i = 1; i <= n; i++) deg[i] = ndeg[i];\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tint maxd = -1;\n\t\tint id = -1;\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (deg[j] >= maxd) {\n\t\t\t\tmaxd = deg[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (maxd <= 0) break;\n\t\tif (fafa) {\n\t\t\tfor(int j = 1; j <= n; j++) {\n\t\t\t\tif (adj[id][j]) {\n\t\t\t\t\tdeg[j] = 0;\n\t\t\t\t\tres++;\n\t\t\t\t\tfor(int p = 1; p <= n; p++) {\n\t\t\t\t\t\tif (adj[j][p] && deg[p] > 0) deg[p] -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfafa = false;\n\t\t} else {\n\t\t\t// printf(\"cacad3\\n\");\n\t\t\tres += 1;\n\t\t\tdeg[id] = 0;\n\t\t\tfor(int j = 1; j <= n; j++) if (adj[id][j] && deg[j] > 0) deg[j] -= 1;\n\t\t}\n\t}\n\treturn res;\n}\nint constructt4(bool first) {\n\tint res = 0, id2 = -1;\n\tbool fafa = first;\n\tfor(int i = 1; i <= n; i++) deg[i] = ndeg[i];\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tint maxd = -1;\n\t\tint id = -1;\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (deg[j] >= maxd) {\n\t\t\t\tmaxd = deg[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (maxd <= 0) break;\n\t\tif (fafa) {\n\t\t\tfor(int j = 1; j <= n; j++) {\n\t\t\t\tif (adj[id][j]) {\n\t\t\t\t\tdeg[j] = 0;\n\t\t\t\t\tres++;\n\t\t\t\t\tfor(int p = 1; p <= n; p++) {\n\t\t\t\t\t\tif (adj[j][p] && deg[p] > 0) deg[p] -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfafa = false;\n\t\t} else {\n\t\t\t// printf(\"cacad3\\n\");\n\t\t\tres += 1;\n\t\t\tif (res == 1) fafa = true;\n\t\t\tdeg[id] = 0;\n\t\t\tfor(int j = 1; j <= n; j++) if (adj[id][j] && deg[j] > 0) deg[j] -= 1;\n\t\t}\n\t}\n\treturn res;\n}\nint constructt5(bool first) {\n\tint res = 0, id2 = -1;\n\tbool fafa = first;\n\tfor(int i = 1; i <= n; i++) deg[i] = ndeg[i];\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tint maxd = -1;\n\t\tint id = -1;\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (deg[j] > maxd && j != id2) {\n\t\t\t\tmaxd = deg[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (maxd <= 0) break;\n\t\tif (fafa) {\n\t\t\tid2 = id;\n\t\t\tfafa = false;\n\t\t} else {\n\t\t\t// printf(\"cacad\\n\");\n\t\t\tres += 1;\n\t\t\tdeg[id] = 0;\n\t\t\tfor(int j = 1; j <= n; j++) if (adj[id][j] && deg[j] > 0) deg[j] -= 1;\n\t\t}\n\t}\n\treturn res;\n}\nint constructt6(bool first) {\n\tint res = 0, id2 = -1;\n\tbool fafa = first;\n\tfor(int i = 1; i <= n; i++) deg[i] = ndeg[i];\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tint maxd = -1;\n\t\tint id = -1;\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (deg[j] > maxd && j != id2) {\n\t\t\t\tmaxd = deg[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (maxd <= 0) break;\n\t\tif (fafa) {\n\t\t\tid2 = id;\n\t\t\tfafa = false;\n\t\t} else {\n\t\t\t// printf(\"cacad2\\n\");\n\t\t\tid2 = -1;\n\t\t\tres += 1;\n\t\t\tdeg[id] = 0;\n\t\t\tfor(int j = 1; j <= n; j++) if (adj[id][j] && deg[j] > 0) deg[j] -= 1;\n\t\t}\n\t}\n\treturn res;\n}\nint constructt7(bool first) {\n\tint res = 0, id2 = -1;\n\tbool fafa = first;\n\tfor(int i = 1; i <= n; i++) deg[i] = ndeg[i];\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tint maxd = -1;\n\t\tint id = -1;\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (deg[j] >= maxd) {\n\t\t\t\tmaxd = deg[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (maxd <= 0) break;\n\t\tif (fafa) {\n\t\t\tfor(int j = 1; j <= n; j++) {\n\t\t\t\tif (adj[id][j]) {\n\t\t\t\t\tdeg[j] = 0;\n\t\t\t\t\tres++;\n\t\t\t\t\tfor(int p = 1; p <= n; p++) {\n\t\t\t\t\t\tif (adj[j][p] && deg[p] > 0) deg[p] -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfafa = false;\n\t\t} else {\n\t\t\t// printf(\"cacad3\\n\");\n\t\t\tres += 1;\n\t\t\tdeg[id] = 0;\n\t\t\tfor(int j = 1; j <= n; j++) if (adj[id][j] && deg[j] > 0) deg[j] -= 1;\n\t\t}\n\t}\n\treturn res;\n}\nint constructt8(bool first) {\n\tint res = 0, id2 = -1;\n\tbool fafa = first;\n\tfor(int i = 1; i <= n; i++) deg[i] = ndeg[i];\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tint maxd = -1;\n\t\tint id = -1;\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (deg[j] > maxd) {\n\t\t\t\tmaxd = deg[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (maxd <= 0) break;\n\t\tif (fafa) {\n\t\t\tfor(int j = 1; j <= n; j++) {\n\t\t\t\tif (adj[id][j]) {\n\t\t\t\t\tdeg[j] = 0;\n\t\t\t\t\tres++;\n\t\t\t\t\tfor(int p = 1; p <= n; p++) {\n\t\t\t\t\t\tif (adj[j][p] && deg[p] > 0) deg[p] -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfafa = false;\n\t\t} else {\n\t\t\t// printf(\"cacad3\\n\");\n\t\t\tres += 1;\n\t\t\tif (res == 1) fafa = true;\n\t\t\tdeg[id] = 0;\n\t\t\tfor(int j = 1; j <= n; j++) if (adj[id][j] && deg[j] > 0) deg[j] -= 1;\n\t\t}\n\t}\n\treturn res;\n}\nint num = 0;\nint nabrak = 0;\nvoid dfs(int now) {\n\tint sz = v[now].size();\n\tflag[now] = true;\n\tndeg[now] = sz;\n\tnum++;\n\tbool masuk = false;\n\tfor(int i = 0; i < sz; i++) {\n\t\tif (!flag[v[now][i]]) {\n\t\t\tmasuk = true;\n\t\t\tdfs(v[now][i]);\n\t\t}\n\t}\n\tif (sz > 1 && masuk == false) nabrak++;\n\tif (sz == 1 || sz > 2) nabrak += 10;\n}\nint main() {\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t\tadj[a][b] = 1;\n\t\tadj[b][a] = 1;\n\t}\n\tmemset(flag,false,sizeof(flag));\n\tint ans = 0; \n\tfor(int i = 1; i <= n; i++) {\n\t\tif (!flag[i]) {\n\t\t\tmemset(ndeg,0,sizeof(ndeg));\n\t\t\tnum = nabrak = minim = 0; dfs(i); \n\t\t\tif (nabrak == 1) {\n\t\t\t\t// printf(\"sad %d %d\\n\",i,num);\n\t\t\t\tans += (num + 1)/2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int now = 1; now <= n; now++) {\n\t\t\t\tif (v[now].size() > k && ndeg[now] > k) {\n\t\t\t\t\tminim += 1;\n\t\t\t\t\tndeg[now] = 0;\n\t\t\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\t\t\tif (adj[now][i] && ndeg[i] > 0) {\n\t\t\t\t\t\t\tndeg[i]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int now = 1; now <= n; now++) {\n\t\t\t\tif (v[now].size() == 1 && ndeg[now] > 0) {\n\t\t\t\t\tminim += 1;\n\t\t\t\t\t// printf(\"%d now %d\\n\",i,now);\n\t\t\t\t\tndeg[v[now][0]] = 0;\n\t\t\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\t\t\tif (adj[v[now][0]][i] && ndeg[i] > 0) {\n\t\t\t\t\t\t\tndeg[i]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// printf(\"%d\\n\",minim);\n\t\t\tint gg = min(constructt(false),constructt(true));\n\t\t\tgg = min(gg, constructt2(true));\n\t\t\tgg = min(gg, constructt3(true));\n\t\t\tgg = min(gg, constructt4(true));\n\t\t\tgg = min(gg, constructt5(false));\n\t\t\tgg = min(gg, constructt5(true));\n\t\t\tgg = min(gg, constructt6(true));\n\t\t\tgg = min(gg, constructt7(true));\n\t\t\tgg = min(gg, constructt8(true));\n\t\t\t// printf(\"%d %d %d\\n\",i,minim, gg);\n\t\t\tans += minim + gg;\n\t\t}\n\t}\n\t// printf(\"%d\\n\",ans);\n\tif (ans > k) printf(\"Impossible\\n\");\n\telse printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\tint N, M, K;\n\nint getans(const vector<vector<int>>&edges,const int now, const int use,vector<int>&used) {\n\tif (now == edges.size() || edges[now].empty())return use;\n\tint ans = 33;\n\t\n\tif (used[now]) {\n\t\treturn getans(edges, now + 1, use, used);\n\t}\n\telse {\n\t\tif (use + 1 <= K) {\n\t\t\tused[now] = true;\n\t\t\tans = min(ans, getans(edges,now + 1, use + 1, used));\n\t\t\tused[now] = false;\n\t\t}\n\t\tint nextuse = use;\n\t\tvector<int>newused;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!used[e]) {\n\t\t\t\tused[e] = true;\n\t\t\t\tnewused.push_back(e);\n\t\t\t}\n\t\t}\n\t\tif (use + newused.size() <= K) {\n\t\t\tans = min(ans, getans(edges, now + 1, use + newused.size(), used));\n\t\t}\n\t\tfor (auto u : newused) {\n\t\t\tused[u] = false;\n\t\t}\n\t\t//while(edges[num].first==)\n\t}\n\treturn ans;\n}\nint main() {cin >> N >> M >> K;\n\tvector<pair<int, int>>ps(N);\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tps[i] = make_pair(0, i);\n\t}\n\tvector<vector<int>>aedges(N);\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\taedges[a].push_back(b);\n\t\taedges[b].push_back(a);\n\t\tps[a].first++;\n\t\tps[b].first++;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t}\n\tfor (auto &p : ps) {\n\t\tif (p.first == 0)p.first = -1e8;\n\t}\n\t\n\tmap<int, int>mp;\n\tfor (int i = 0; i <aset.size(); ++i) {\n\t\tauto it = max_element(ps.begin(), ps.end(), [](const pair<int,int> &l, const  pair<int, int>&r) {\n\t\t\treturn l.first < r.first;\n\t\t});\n\t\tfor (auto e : aedges[it->second]) {\n\t\t\tps[e].first--;\n\t\t}\n\t\tit->first = -1;\n\t\tmp[it->second] = i;\n\t}\n\tvector<vector<int>>realedges(mp.size());\n\tfor (int i = 0; i < aedges.size(); ++i) {\n\t\tfor (auto e : aedges[i]) {\n\t\t\tif (mp[i] < mp[e]) {\n\t\t\t\trealedges[mp[i]].push_back(mp[e]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>used(mp.size());\n\tint ans = getans(realedges, 0, 0, used);\n\tif (ans == 33) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\n\t\tcout << ans << endl;\n\t}\n\t//for()\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int add_size, vector<pair<int, int> >& erase_ver){\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(add_size, erase_ver);\n        if(!check()) return postprocessing(add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        ans_size = K + 1;\n        judge(K);\n        return ans_size <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define ll long long\n#define line printf(\"\\n\")\n#define rep(a,b,c) for(int a= (int)b;a<(int)c;a++)\n#define repd(a,b,c) for(int a=(int)b;a>=c;a--)\n#define pb push_back\n#define pf push_front\n#define pb2 pop_back\n#define pf2 pop_front\n#define pq priority_queue\n#define haha printf(\"hahaha\\n\")\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e17;\nconst double EPS = 1e-5;\n\nusing namespace std;\n\nvector<int> adj[3005];\nint flag[3005],deg[3005];\nint n,m,d,rem;\n\nint greedy(int);\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&d);\n\t\n\tfor(int k=0;k<m;k++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);a--;b--;\n\t\t\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t\tdeg[a]++;deg[b]++;\n\t}\n\t\n\tint tmp = greedy(d);\n\tif(tmp<0)printf(\"Impossible\\n\");else printf(\"%d\\n\",d-tmp);\n\treturn 0;\n}\n\ninline void remove(int a){\n\tdeg[a] = 0;\n\trep(k,0,adj[a].size()){\n\t\tif(deg[adj[a][k]])deg[adj[a][k]]--;\n\t}\n}\nvector<int>rev[3005];\nint greedy(int sisa){\n\tif(sisa<0)return sisa;\n\tint maks = 0;\n\trep(k,0,n)rev[k].clear();\n\trep(k,0,n)if(deg[k])rev[deg[k]].pb(k),maks = max(maks,deg[k]);\n\t\n\tif(maks==0)return sisa;\n\tint node;\n\tif(rev[1].size()){\n\t\tnode = rev[1][0];\n\t\trep(k,0,adj[node].size())if(deg[adj[node][k]]){\n\t\t\tnode = adj[node][k];break;\n\t\t}\n\t}\n\telse{\n\t\tnode = rev[maks][0];\n\t}\n\t//printf(\"|%d\",node+1);line;\n\tremove(node);\n\treturn greedy(sisa-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>g[3100];\nint deg[3100];\nint use[3100];\npair<int,int>edge[31000];\nint M;\nint N;\nint dfs(int a,int b){\n\tfor(int i=a;i<M;i++){\n\t\tint L=edge[i].first;\n\t\tint R=edge[i].second;\n\t\tif(use[L]!=1&&use[R]!=1){\n\t\t\tif(b==0)return -1;\n\t\t\tint best=-1;\n\t\t\t// use L\n\t\t\tuse[L]=1;\n\t\t\tint nb=b-1;\n\t\t\tbest=max(best,dfs(i+1,nb));\n\t\t\t// not use L\n\t\t\tuse[L]=0;\n\t\t\tvector<int>rev;\n\t\t\tnb=b;\n\t\t\tfor(int j=0;j<g[L].size();j++){\n\t\t\t\tif(use[g[L][j]]!=1){\n\t\t\t\t\tuse[g[L][j]]=1;\n\t\t\t\t\tnb--;\n\t\t\t\t\trev.push_back(g[L][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nb>=0)best=max(best,dfs(i+1,nb));\n\t\t\tuse[L]=-1;\n\t\t\tfor(int j=0;j<rev.size();j++)use[rev[j]]=-1;\n\t\t\treturn best;\n\t\t}\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tN=a;\n\t//M=b;\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t\tdeg[p]++;deg[q]++;\n\t\tedge[i]=make_pair(p,q);\n\t}\n\tfor(int i=0;i<a;i++)use[i]=-1;\n\tfor(int i=0;i<a;i++)if(deg[i]<1)use[i]=0;\n\tint rem=c;\n\twhile(1){\n\t\tint at=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(deg[i]>c){\n\t\t\t\tat=i;break;\n\t\t\t}\n\t\t}\n\t\tif(~at){\n\t\t\tuse[at]=1;\n\t\t\trem--;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tdeg[g[at][i]]--;\n\t\t\t}\n\t\t\tdeg[at]=0;\n\t\t}else break;\n\t}\n\tif(rem<0){\n\t\tprintf(\"Impossible\\n\");return 0;\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tif(use[edge[i].first]!=1&&use[edge[i].second]!=1){\n\t\t\tedge[M++]=edge[i];\n\t\t}\n\t}\n\tif(M>c*c){\n\t\tprintf(\"Impossible\\n\");return 0;\n\t}\n\tint res=dfs(0,rem);\n\tif(res==-1)printf(\"Impossible\\n\");\n\telse printf(\"%d\\n\",c-res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define sz(a) (int)(a).size()\nusing namespace std;\ntypedef vector <int> vi;\n\nint N, M, K;\nint deg[3005];\nint tot;\nbool process[1005];\nvector <vi> AdjList;\n\nint Solve (int cur) {\n\tint ret = 0;\n\twhile (cur > 0) {\n\t\tret++;\n\t\tint minn = (int)1e+9, node;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (deg[i] < minn && process[i]) {\n\t\t\t\tminn = deg[i];\n\t\t\t\tnode = i;\n\t\t\t}\n\t\t}\n\n\t\tvi tmp;\n\t\tfor (int i = 0; i < sz(AdjList[node]); i++) {\n\t\t\tint v = AdjList[node][i];\n\t\t\tdeg[node]--;\n\t\t\tdeg[v]--;\n\t\t\ttmp.push_back (v);\n\t\t}\n\t\tprocess[node] = false;\n\t\tcur--;\n\t\tfor (int i = 0; i < sz(tmp); i++) {\n\t\t\tif (process[tmp[i]]) {\n\t\t\t\tint u = tmp[i];\n\t\t\t\tfor (int j = 0; j < sz(AdjList[u]); j++) {\n\t\t\t\t\tint v = AdjList[u][j];\n\t\t\t\t\tif (process[v]) {\n\t\t\t\t\t\tdeg[u]--;\n\t\t\t\t\t\tdeg[v]--;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\tprocess[u] = false;\n\t\t\t\tcur--;\n\t\t\t}\t\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main () {\n\tscanf (\"%d %d %d\", &N, &M, &K);\n\tAdjList.assign (N, vi());\n\tint a, b;\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf (\"%d %d\", &a, &b);\n\t\ta--; b--;\n\t\tAdjList[a].push_back (b);\n\t\tAdjList[b].push_back (a);\n\t\tif (deg[a] == 0) {\n\t\t\ttot++;\n\t\t\tprocess[a] = true;\n\t\t}\t\n\t\tdeg[a]++;\n\t\tif (deg[b] == 0) {\n\t\t\ttot++;\n\t\t\tprocess[b] = true;\n\t\t}\t\n\t\tdeg[b]++;\n\t}\n\tint MIS = Solve (tot);\n\tint ans = tot - MIS;\n\tif (ans <= K) printf (\"%d\\n\", ans);\n\telse printf (\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\tint N, M, K;\n\nint getans(const vector<vector<int>>&edges,const int now, const int use,vector<int>&used) {\n\tif (now == edges.size()||edges[now].empty())return use;\n\tint ans = 33;\n\t\n\tif (used[now]) {\n\t\treturn getans(edges, now + 1, use, used);\n\t}\n\telse {\n\t\tif (use + 1 <= K) {\n\t\t\tused[now] = true;\n\t\t\tans = min(ans, getans(edges,now + 1, use + 1, used));\n\t\t\tused[now] = false;\n\t\t}\n\t\tint nextuse = use;\n\t\tvector<int>newused;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!used[e]) {\n\t\t\t\tused[e] = true;\n\t\t\t\tnewused.push_back(e);\n\t\t\t}\n\t\t}\n\t\tif (use + newused.size() <= K) {\n\t\t\tans = min(ans, getans(edges, now + 1, use + newused.size(), used));\n\t\t}\n\t\tfor (auto u : newused) {\n\t\t\tused[u] = false;\n\t\t}\n\t\t//while(edges[num].first==)\n\t}\n\treturn ans;\n}\nint main() {cin >> N >> M >> K;\n\tvector<pair<int,int>>edges;\n\tvector<pair<int, int>>ps(N);\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tps[i] = make_pair(0, i);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tedges.emplace_back(a, b);\n\t\tedges.emplace_back(b, a);\n\t\tps[a].first++;\n\t\tps[b].first++;\n\t}\n\t\n\tsort(ps.begin(), ps.end(),greater<pair<int,int>>());\n\tmap<int, int>mp;\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tif (ps[i].first == 0)break;\n\t\tmp[ps[i].second] = i;\n\t}\n\tvector<vector<int>>realedges(mp.size());\n\tfor (int i = 0; i < edges.size(); ++i) {\n\t\tint f = mp[edges[i].first];\n\t\tint t = mp[edges[i].second];\n\t\tif (f < t)realedges[f].push_back(t);\n\t}\n\tvector<int>used(mp.size());\n\tint ans = getans(realedges, 0, 0, used);\n\tif (ans == 33) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\n\t\tcout << ans << endl;\n\t}\n\t//for()\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nint N,M,K;\nvector<int> G[3000];\nvector<P> es;\nint d[3000],use[30000]; \nint dfs(int x,int k){\n\tfor(int i=x;i<M;i++){\n\t\tint a=es[i].fs,b=es[i].sc;\n\t\tif(use[a]!=1&&use[b]!=1){\n\t\t\tif(k==0) return -1;\n\t\t\tif(d[a]<d[b]) swap(a,b);\n\t\t\tint best=-1;\n\t\t\t//use a\n\t\t\tif(use[a]<0){\t//use[a]==-1\n\t\t\t\tuse[a]=1;\n\t\t\t\tvector<int> vc;\n\t\t\t\tfor(int v:G[a]){\n\t\t\t\t\tif(use[v]<0){\n\t\t\t\t\t\tvc.pb(v);\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(best,dfs(x+1,k-1));\n\t\t\t\tfor(int v:vc) d[v]++;\n\t\t\t\tuse[a]=-1;\n\t\t\t}\n\t\t\t//not use a\n\t\t\tif(d[b]>1){\n\t\t\t\tuse[a]=0;\n\t\t\t\tvector<int> vc;\n\t\t\t\tint nk=k;\n\t\t\t\tfor(int v:G[a]){\n\t\t\t\t\t//assert(use[v]!=0);\n\t\t\t\t\tif(use[v]!=1){\n\t\t\t\t\t\tuse[v]=1;\n\t\t\t\t\t\tnk--;\n\t\t\t\t\t\tvc.pb(v);\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(best,dfs(x+1,nk));\n\t\t\t\tfor(int v:vc) use[v]=-1,d[v]++;\n\t\t\t\tuse[b]=-1;\n\t\t\t}\n\t\t\treturn best;\n\t\t}\n\t}\n\treturn k;\n}\nint main(){\n\tcin>>N>>M>>K;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\td[a]++,d[b]++;\n\t\tes.pb(P(a,b));\n\t}\n\trep(i,N) use[i]=-1;\n\trep(i,N) if(d[i]==0) use[i]=0;\n\tint k=K;\n\twhile(true){\n\t\tint v=-1;\n\t\trep(i,N) if(d[i]>k){\n\t\t\tv=i;break;\n\t\t}\n\t\tif(v<0) break;\n\t\tuse[v]=1;\n\t\tfor(int u:G[v]){\n\t\t\tif(d[u]) d[u]--;\n\t\t}\n\t\td[v]=0;\n\t\tk--;\n\t\tif(k<0){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint Mc=M;\n\tM=0;\n\trep(i,Mc) if(use[es[i].fs]!=1&&use[es[i].sc]!=1) es[M++]=es[i];\n\tif(M>k*k){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\trep(v,N){\n\t\tint j=0;\n\t\trep(i,G[v].size()){\n\t\t\tint u=G[v][i];\n\t\t\tif(use[v]!=1&&use[u]!=1) G[v][j++]=u;\n\t\t}\n\t\tG[v].resize(j);\n\t}\n//\tshow(K);\n//\tshow(k);\n//\tshow(M);\n\tint ans=dfs(0,k);\n\tif(ans<0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tcout<<K-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-12;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint p;\nvector<vector<int>>go;//橋 \nclass state{\npublic:\n\tvector<int>zi;//残りの次数\n\tqueue<int>ofque;\n\tvector<char>zyo;//頂点の状態\n\t//2 未決定 1 on 0 off\n};\nvoid toon(state&in,int ter){\n\t\n\tin.zi[ter]=1;\n\tfor(auto it:go[ter]){\n\t\tif(in.zyo[it]!=2){continue;}\n\t\tin.zi[it]--;\n\t\tif(in.zi[it]==1){in.ofque.push(it);}\n\t}\n}\nint solve(state&in,int rest,int know){//破壊します\n\t//いろいろ行っている\n\t//頂点名は0~p に書き換わっている\n\t//for(int it:in.zyo){cerr<<it<<\" \";}\n\t//cerr<<\" rest=\"<<rest<<endl;\n\tint ter=-1;\n\twhile(in.ofque.size()>0){\n\t\tter=in.ofque.front();in.ofque.pop();\n\t\tif(in.zyo[ter]==2){break;}\n\t\tter=-1;\n\t}\n\tif(ter>-1){//off処理\n\t\tin.zyo[ter]=0;\n\t\tfor(auto it:go[ter]){\n\t\t\tif(in.zyo[it]!=2){continue;}\n\t\t\trest--;\n\t\t\tif(rest<=know){return -1;}\n\t\t\ttoon(in,it);in.zyo[it]=1;\n\t\t}\n\t\treturn solve(in,rest,know);\n\t}\n\t//terが自由になる 次数の多いものを影響させる\n\tint sai=-1;\n\tfor(int i=0;i<p;i++){\n\t\tif(in.zyo[i]==2&&maxeq(sai,in.zi[i])){ter=i;}\n\t}\n\tif(ter==-1){return rest;}\n\tint ans=-1;\n\tstate onin=in;int onres=rest;\n\tonres--;toon(onin,ter);onin.zyo[ter]=1;\n\tif(onres>know){ans=solve(onin,onres,know);}\n\t\n\t\n\tin.zyo[ter]=0;\n\tfor(auto it:go[ter]){\n\t\tif(in.zyo[it]!=2){continue;}\n\t\trest--;toon(in,it);in.zyo[it]=1;\n\t}\n\t\n\t\n\t\n\tmaxeq(ans,solve(in,rest,max(ans,know)));\n\treturn ans;\n}\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\tint i,n,m,K,j,k,mk;cin>>n>>m>>K;mk=K;\n\tvector<vector<int>>mgo(n);\n\tfor(i=0;i<m;i++){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tmgo[a].pub(b);\n\t\tmgo[b].pub(a);\n\t}\n\tqueue<int>que;\n\tvector<int>ban(n,-1);\n\tvector<int>ima;\n\tfor(i=0;i<n;i++){\n\t\tif(ban[i]!=-1){continue;}\n\t\tp=0;\n\t\tque.push(i);\n\t\twhile(que.size()){\n\t\t\tint t=que.front();que.pop();\n\t\t\tif(ban[t]!=-1){continue;}\n\t\t\tban[t]=p;p++;\n\t\t\tima.pub(t);\n\t\t\tfor(auto it:mgo[t]){que.push(it);}\n\t\t}\n\t\tgo.resize(p);\n\t\tstate aaa;\n\t\taaa.zyo=vector<char>(p,2);\n\t\taaa.zi=vector<int>(p);\n\t\tfor(j=0;j<p;j++){\n\t\t\tgo[j].resize(mgo[ima[j]].size());\n\t\t\taaa.zi[j]=mgo[ima[j]].size();\n\t\t\tfor(k=0;k<mgo[ima[j]].size();k++){\n\t\t\t\tgo[j][k]=ban[mgo[ima[j]][k]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(p>1){K=solve(aaa,K,-1);}\n\t\tgo.clear();\n\t\tima.clear();\n\t}\n\tif(K<0){cout<<\"Impossible\"<<endl;}\n\telse{cout<<mk-K<<endl;}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef bitset<30000> BS;\n\nBS absbs;\nBS is[3000];\nvector<int> idx;\nint a[32345],b[32345];\n\nint rec(const BS &bs,int nth,int r){\n  if(r<0)return r;\n  if(bs==absbs)return r;\n  while((is[idx[nth]]&~bs).none()){\n    nth++;\n  }\n  BS n=is[idx[nth]]&~bs;\n  if(n.count()==1){\n    for(int i=0;;i++){\n      if(n[i]){\n\treturn rec(bs|is[a[i]^b[i]^idx[nth]],nth+1,r-1);\n      }\n    }\n  }else{\n    int rv=rec(bs|is[idx[nth]],nth+1,r-1);\n    BS o=bs;\n    int c=0;\n    for(int i=0;n.any();i++){\n      if(n[i]){\n\to|=bs|is[a[i]^b[i]^idx[nth]];\n\tc++;\n\tn[i]=false;\n      }\n    }\n    return max(rv,rec(o,nth+1,r-c));\n  }\n}\n\nint main(){\n  int N,M,K;\n  cin>>N>>M>>K;\n  int pop[32345]={};\n  for(int i=0;i<M;i++){\n    absbs[i]=true;\n    cin>>a[i]>>b[i];\n    a[i]--;\n    b[i]--;\n    pop[a[i]]++;\n    pop[b[i]]++;\n    is[a[i]][i]=true;\n    is[b[i]][i]=true;\n  }\n  idx.resize(N);\n  iota(begin(idx),end(idx),0);\n  sort(begin(idx),end(idx),[pop](int a,int b){\n      return pop[a]>pop[b];\n    });\n  int r=rec(BS(),0,K);\n  if(r<0){\n    cout<<\"Impossible\"<<endl;\n  }else{\n    cout<<K-r<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nunsigned long long xor128() {\n    static unsigned long long rx = 123456789, ry = 362436069, rz = 521288629, rw = 88675123;\n    unsigned long long rt = (rx ^ (rx << 11));\n    rx = ry;\n    ry = rz;\n    rz = rw;\n    return (rw = (rw ^ (rw >> 19)) ^ (rt ^ (rt >> 8)));\n}\n\nstd::chrono::system_clock::time_point start;\nstd::chrono::system_clock::time_point owari;\n\nbool A[3003][3003];\nint T[3003];\nint n,m,k,MIN=1e9,cnt[3003];\n\nint main(){\n    start = std::chrono::system_clock::now();\n    cin>>n>>m>>k;\n    r(i,m){\n        int a,b;\n        cin>>a>>b; a--; b--;\n        A[a][b]=A[b][a]=1;\n        cnt[a]++;\n        cnt[b]++;\n    }\n    r(i,n)T[i]=cnt[i];\n    for(;;){\n        int TEMP=0;\n        for(;;){\n            int x,idx=-1,MAX=0;\n            r(i,n){\n                if(MAX<cnt[i]||(cnt[i]&&(xor128()%500==2))){\n                    MAX=cnt[i];\n                    x=i;\n                }\n                if(cnt[i]==1) idx=i;\n            }\n            if(!MAX)break;\n            TEMP++;\n            if(idx!=-1){\n                r(i,n)if(A[idx][i]&&cnt[i]){\n                    x=i;\n                    break;\n                }\n            }\n            r(i,n)if(A[x][i]&&cnt[i])cnt[i]--;\n            cnt[x]=0;\n        }\n        MIN=min(TEMP,MIN);\n        owari = std::chrono::system_clock::now();\n        double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(owari-start).count();\n        if(elapsed>0.1)break;\n\n        r(i,n)cnt[i]=T[i];\n\n    }\n    if(MIN<=k)cout<<MIN<<endl;\n    else cout<<\"Impossible\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        // 最初の層で行われた前処理による変更は特に後処理する必要がない\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\t// ListIterator<T> からのアクセスを許可する\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の添字を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    int index;\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool erase(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use) add_size++, cand.push_back(u);\n        // ans より良い解が得られないと分かった\n        if((int)cand.size() >= ans_size) return false;\n        erase_ver.emplace_back(u, rem_ver.erase(u).index);\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev).index);\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to).index);\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                add_size++, cand.push_back(e.to);\n                // ans より良い解が得られないと分かった\n                if((int)cand.size() >= ans_size) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, true, add_size, erase_ver)) return false;\n        // cout << u << \"\\n\";\n        // cout << rem_ver << \"\\n\";\n        // sset(small_deg_ver), sset(use_ver);\n        // show(rem_edge_size);\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            while(!small_deg_ver.empty()){\n                int v = *small_deg_ver.begin();\n                small_deg_ver.erase(v);\n                if(deg[v] == 0) continue;\n                if(!erase(v, false, add_size, erase_ver)) return false;\n                // sset(small_deg_ver), sset(use_ver);\n            }\n            while(!use_ver.empty()){\n                int v = *use_ver.begin();\n                small_deg_ver.erase(v);\n                if(deg[v] == 0) continue;\n                if(!erase(v, true, add_size, erase_ver)) return false;\n            }\n        }\n        // show(rem_edge_size);\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int add_size, vector<pair<int, int> >& erase_ver){\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)) return postprocessing(pl_add_size, pl_erase_ver);\n        if(check()) judge(K-1);\n        return postprocessing(pl_add_size, pl_erase_ver);\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(add_size, erase_ver);\n        if(!check()) return postprocessing(add_size, erase_ver);\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(rem_edge_size > (long long)max_deg * (int)rem_edge_size){\n            return postprocessing(add_size, erase_ver);\n        }\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        ans_size = K + 1;\n        judge(K);\n        return ans_size <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    // svec(mvc.ans_set);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#define maxn 3099\nusing namespace std;\nint map[maxn][maxn];\nint num[maxn];\nstruct asdf\n{\n    int num;\n    int siz;\n}nn[maxn];\nint cmp(struct asdf a,struct asdf b)\n{\n    return a.num<b.num;\n}\nint main()\n{\n    int i,j,n,m,k,ans=0;\n    scanf(\"%d%d%d\",&n,&m,&k);\n    for(i=1;i<=m;i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        if(!(map[a][b]))\n        {\n            map[a][b]=map[b][a]=1;\n            nn[b].num++;nn[a].num++;\n            nn[b].siz=b;nn[a].siz=a;\n        }\n    }\n    int flag=1;\n    while(ans<=k)\n    {\n        sort(nn+1,nn+1+n,cmp);\n        if(nn[n].num==0) break;\n        flag=0;\n        for(i=1;i<=n;i++)\n        {\n            if(map[i][nn[n].siz])\n            {\n                map[i][nn[n].siz]=0;\n                map[nn[n].siz][i]=0;\n                nn[n].num--;\n                for(j=1;j<=n;j++)\n                {\n                    if(nn[j].siz==i)\n                    {\n                        nn[j].num--;\n                        break;\n                    }\n                }\n            }\n        }\n        ans++;\n    }\n    if(k>=ans)\n        printf(\"%d\\n\",ans);\n    else printf(\"Impossible\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nint N, M, K;\nint deg[3030];\nbool used[3030];\nint ans;\nvector<pair<int, int>> edges;\nvector<vector<int>> nodes;\nint h() {\n    bool used2[3030];\n    REP(i, N) used2[i] = used[i];\n    int res = 0;\n    for(auto p : edges) {\n        if(used2[p.first] || used2[p.second]) continue;\n        used2[p.first] = used2[p.second] = true;\n        res++;\n    }\n    return res;\n}\nvoid dfs(int idx, int cnt) {\n    int hr = h();\n    if(cnt + hr >= ans) return;\n    if(hr == 0) { ans = cnt; return; }\n\n    const int E = nodes[idx].size();\n    vector<bool> back(E);\n    bool nouse_ok = true;\n\n    for(int i = 0; i < E; i++) {\n        const int v = nodes[idx][i];\n        back[i] = used[v];\n        deg[v]--;\n\n        if(v < idx && !used[v]) nouse_ok = false;\n    }\n\n    if(deg[idx] > 0) {\n        used[idx] = true;\n        dfs(idx+1, cnt+1);\n        used[idx] = false;\n    }\n\n    for(int i = 0; i < E; i++) {\n        const int v = nodes[idx][i];\n        used[v] = back[i];\n        deg[v]++;\n    }\n\n    if(nouse_ok) {\n        dfs(idx+1, cnt);\n    }\n}\nint main(){\n    iostream_init();\n    while(cin >> N >> M >> K) {\n        memset(deg, 0, sizeof(deg));\n        memset(used, 0, sizeof(used));\n        edges.resize(M);\n        nodes.assign(N, vector<int>());\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            if(a > b) swap(a, b);\n            nodes[a].push_back(b);\n            nodes[b].push_back(a);\n            edges[i] = make_pair(a, b);\n            deg[a]++;\n            deg[b]++;\n        }\n        ans = K+1;\n        dfs(0, 0);\n        if(ans == K+1) {\n            cout << \"Impossible\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cincout\n#define min(a,b) ((a) < (b) ? (a) : (b))\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define abs(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\n\nint n,m,k,ans,tmp,tmppos;\nbool cov[3005];\nint a,b;\npair<int, int> edg[30005];\n\nvoid rek(int po, int co) {\n\tcov[co]=true;\n\t++tmp;\n\tif (tmp<=k) {\n\t\ttmppos=po;\n\t\twhile (tmppos<m && (cov[edg[tmppos].first] || cov[edg[tmppos].second])) ++tmppos;\n\t\tif (tmppos==m) ans=min(ans,tmp);\n\t\telse {\n\t\t\trek(tmppos+1,edg[tmppos].first);\n\t\t\trek(tmppos+1,edg[tmppos].second);\n\t\t}\n\t}\n\t--tmp;\n\tcov[co]=false;\n}\n\nint main() {\n\t#ifdef cincout\n\t\tcin.sync_with_stdio(0);\n\t\tcin.tie(0);\n\t#endif\n\tcin >> n >> m >> k;\n\tfor (int i=0;i<m;++i) {\n\t\tcin >> a >> b;\n\t\tedg[i]=make_pair(a,b);\n\t}\n\tmemset(cov,false,sizeof(cov));\n\tans=100000; tmp=0;\n\trek(0,edg[0].first);\n\trek(0,edg[0].second);\n\tif (ans>k) cout << \"Impossible\\n\";\n\telse cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>g[3100];\nvector<int>ng[3100];\nint deg[3100];\nint use[3100];\npair<int,int>edge[31000];\nint M;\nint N;\nint dfs(int a,int b){\n\tfor(int i=a;i<M;i++){\n\t\tint L=edge[i].first;\n\t\tint R=edge[i].second;\n\t\tif(use[L]!=1&&use[R]!=1){\n\t\t\tif(b==0)return -1;\n\t\t\tif(deg[L]<deg[R])swap(L,R);\n\t\t\tint best=-1;\n\t\t\t// use L\n\t\t\tuse[L]=1;\n\t\t\tint nb=b-1;\n\t\t\tvector<int>rev;\n\t\t\tfor(int j=0;j<g[L].size();j++){\n\t\t\t\tif(use[g[L][j]]!=1){\n\t\t\t\t\trev.push_back(g[L][j]);\n\t\t\t\t\tdeg[g[L][j]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!(deg[L]<=1&&deg[R]>1))best=max(best,dfs(i+1,nb));\n\t\t\tfor(int j=0;j<rev.size();j++)deg[rev[j]]++;\n\t\t\t// not use L\n\t\t\tuse[L]=0;\n\t\t\trev.clear();\n\t\t\tnb=b;\n\t\t\tfor(int j=0;j<g[L].size();j++){\n\t\t\t\tif(use[g[L][j]]!=1){\n\t\t\t\t\tuse[g[L][j]]=1;\n\t\t\t\t\tnb--;\n\t\t\t\t\trev.push_back(g[L][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<rev.size();j++){\n\t\t\t\tfor(int k=0;k<g[rev[j]].size();k++){\n\t\t\t\t\tdeg[g[rev[j]][k]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nb>=0&&!(deg[L]>1&&deg[R]<=1))best=max(best,dfs(i+1,nb));\n\t\t\tfor(int j=0;j<rev.size();j++){\n\t\t\t\tfor(int k=0;k<g[rev[j]].size();k++){\n\t\t\t\t\tdeg[g[rev[j]][k]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tuse[L]=-1;\n\t\t\tfor(int j=0;j<rev.size();j++)use[rev[j]]=-1;\n\t\t\treturn best;\n\t\t}\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tN=a;\n\t//M=b;\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t\tdeg[p]++;deg[q]++;\n\t\tedge[i]=make_pair(p,q);\n\t}\n\tfor(int i=0;i<a;i++)use[i]=-1;\n\tfor(int i=0;i<a;i++)if(deg[i]<1)use[i]=0;\n\tint rem=c;\n\twhile(1){\n\t\tint at=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(deg[i]>c){\n\t\t\t\tat=i;break;\n\t\t\t}\n\t\t}\n\t\tif(~at){\n\t\t\tuse[at]=1;\n\t\t\trem--;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tdeg[g[at][i]]--;\n\t\t\t}\n\t\t\tdeg[at]=0;\n\t\t}else break;\n\t}\n\tif(rem<0){\n\t\tprintf(\"Impossible\\n\");return 0;\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tif(use[edge[i].first]!=1&&use[edge[i].second]!=1){\n\t\t\tedge[M++]=edge[i];\n\t\t}\n\t}\n\tif(M>c*c){\n\t\tprintf(\"Impossible\\n\");return 0;\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<g[i].size();j++){\n\t\tif(use[i]!=1&&use[g[i][j]]!=1)ng[i].push_back(g[i][j]);\n\t}\n\tfor(int i=0;i<a;i++)g[i]=ng[i];\n\tfor(int i=0;i<a;i++)deg[i]=g[i].size();\n\tint res=dfs(0,rem);\n\tif(res==-1)printf(\"Impossible\\n\");\n\telse printf(\"%d\\n\",c-res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    int N, sz;\n    vector<int> prev, next;\n    \nprivate:\n\tvector<T> container;\n\t// ListIterator<T> からのアクセスを許可する\n\tfriend ListIterator<T>;\n    // 添字 index の要素の前に添字 の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の添字を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n\t\tprev.clear(), next.clear(), container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    int index;\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺を含まないとする\nclass MVC {\nprivate:\n    struct edge {\n        int to;\n        List<edge>::iterator rev;\n        edge(int _to) : to(_to){}\n    };\n    \n    int V, rem_ver, rem_edge;\n    bool ok;\n    vector<List<edge> > G;\n    vector<pair<int, int> > es;\n    vector<int> deg, ver;\n    vector<bool> rem, use;\n    \n    void delete_edge(const int u, vector<pair<int, int> >& ch, vector<List<edge>::iterator>& ech, vector<int>& add, bool _use){\n        for(auto& e : G[u]){\n            if(_use) use[e.to] = true, add.push_back(e.to);\n            ech.push_back(G[e.to].erase(e.rev)), deg[e.to]--, rem_edge--, ch.emplace_back(e.to, e.rev.index);\n            // if(e.to == 2){\n            //     svec(G[2].prev);\n            //     svec(G[2].next);\n            //     int hoge = 0;\n            //     for(auto& e : G[2]){\n            //         cout << e.to << \" \";\n            //         hoge++;\n            //         if(hoge >= 3){\n            //             break;\n            //         }\n            //     }\n            //     cout << \"\\n\";\n            // }\n            if(deg[e.to] == 0) rem[e.to] = false, rem_ver--;\n        }\n    }\n    void inv_delete_edge(const int u, vector<pair<int, int> >& ch, vector<List<edge>::iterator>& ech, vector<int>& add, bool _use){\n        for(int i = (int)ch.size() - 1; i >= 0; i--){\n            int v = ch[i].first;\n            if(_use) use[v] = false, add.pop_back();\n            G[v].insert(ech[i], ch[i].second), deg[v]++, rem_edge++;\n            // if(u == 2 && v == 3){\n            //     cout << \"================================\\n\";\n            //     show(ech[i].index);\n            //     svec(G[v].prev);\n            //     svec(G[v].next);\n            // }\n            if(deg[v] == 1) rem[v] = true, rem_ver++;\n        }\n    }\n    void preprocessing(const int K, vector<int>& ans){\n        for(int i = 0; i < V; i++){\n            if(deg[i] > K){\n                ans.push_back(i), rem[i] = false;\n            }else{\n                ver.push_back(i), rem_ver++;\n            }\n        }\n        for(auto& e : es){\n            if(rem[e.first] && rem[e.second]){\n                rem_edge++;\n            }else{\n                if(rem[e.first]) deg[e.first]--;\n                if(rem[e.second]) deg[e.second]--;\n            }\n        }\n        for(auto& e : es){\n            if(rem[e.first] && rem[e.second]){\n                auto it1 = G[e.first].push_back(edge(e.second));\n                auto it2 = G[e.second].push_back(edge(e.first));\n                G[e.first].back().rev = it2, G[e.second].back().rev = it1;\n            }\n        }\n    }\n    void rec(const int K, vector<int>& add, vector<int>& add_opt){\n        // show(rem_edge);\n        // svec(rem);\n        if(rem_edge == 0){\n            ok = true;\n            if(add_opt.empty() || (int)add.size() < (int)add_opt.size()) add_opt = add;\n            return;\n        }\n        // 最大次数の頂点から探索\n        int max_deg = numeric_limits<int>::min(), pos = -1;\n        for(int v : ver){\n            if(rem[v] && deg[v] > max_deg){\n                max_deg = deg[v], pos = v;\n            }\n        }\n        // int hoge = 0;\n        // for(auto& e : G[2]){\n        //     cout << e.to << \" \";\n        //     hoge++;\n        //     if(hoge >= 3){\n        //         break;\n        //     }\n        // }\n        // cout << \"\\n\";\n        // 枝数の条件\n        if(rem_edge > max_deg*rem_ver) return;\n        // show(\"BUE\");\n        rem[pos] = false, rem_ver--;\n        // show(pos), show(max_deg);\n        if(use[pos] || max_deg >= 2){\n            // 使う場合\n            vector<pair<int, int> > ch;\n            vector<List<edge>::iterator> ech;\n            // show(pos);\n            // int hoge = 0;\n            // for(auto& e : G[2]){\n            //     cout << e.to << \" \";\n            //     hoge++;\n            //     if(hoge >= 3){\n            //         break;\n            //     }\n            // }\n            // cout << \"\\n\";\n            // svec(G[2].next);\n            delete_edge(pos, ch, ech, add, false);\n            // hoge = 0;\n            // for(auto& e : G[2]){\n            //     cout << e.to << \" \";\n            //     hoge++;\n            //     if(hoge >= 3){\n            //         break;\n            //     }\n            // }\n            // cout << \"\\n\";\n            if(!use[pos]) add.push_back(pos);\n            if((int)add.size() + (int)ans.size() <= K) rec(K, add, add_opt);\n            // show(\"OK\");\n            if(!use[pos]) add.pop_back();\n            inv_delete_edge(pos, ch, ech, add, false);\n        }\n        if(use[pos]) return;\n        // show(\"KITA\");\n        // 使わない場合\n        vector<pair<int, int> > ch;\n        vector<List<edge>::iterator> ech;\n        // hoge = 0;\n        // for(auto& e : G[2]){\n        //     cout << e.to << \" \";\n        //     hoge++;\n        //     if(hoge >= 3){\n        //         break;\n        //     }\n        // }\n        // cout << \"\\n\";\n        delete_edge(pos, ch, ech, add, true);\n        // show(ech[0].index);\n        if((int)add.size() + (int)ans.size() <= K) rec(K, add, add_opt);\n        // svec(G[3].prev);\n        // svec(G[3].next);\n        inv_delete_edge(pos, ch, ech, add, true);\n        rem[pos] = true, rem_ver++;\n        return;\n    }\npublic:\n    vector<int> ans;\n    \n    MVC(int node_size) :\n        V(node_size), rem_ver(0), rem_edge(0), ok(false), G(V), deg(V, 0), rem(V, true), use(V, false){}\n    void add_edge(const int u, const int v){\n        es.emplace_back(u, v);\n        deg[u]++, deg[v]++;\n    }\n    bool judge(const int K){\n        preprocessing(K, ans);\n        vector<int> add, add_opt;\n        rec(K, add, add_opt);\n        for(int v : add_opt){\n            ans.push_back(v);\n        }\n        sort(ans.begin(), ans.end());\n        return ok && (int)ans.size() <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.judge(K)){\n        cout << len(mvc.ans) << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef bitset<300000> BS;\n\nBS absbs;\nBS is[3000];\nvector<int> idx;\nint a[32345],b[32345];\n\nint rec(const BS &bs,int nth,int r){\n  if(r<0)return r;\n  if(bs==absbs)return r;\n  while((is[idx[nth]]&~bs).none()){\n    nth++;\n  }\n  BS n=is[idx[nth]]&~bs;\n  if(n.count()==1){\n    for(int i=0;;i++){\n      if(n[i]){\n\treturn rec(bs|is[a[i]^b[i]^idx[nth]],nth+1,r-1);\n      }\n    }\n  }else{\n    int rv=rec(bs|is[idx[nth]],nth+1,r-1);\n    BS o=bs;\n    int c=0;\n    for(int i=0;n.any();i++){\n      if(n[i]){\n\to|=bs|is[a[i]^b[i]^idx[nth]];\n\tc++;\n\tn[i]=false;\n      }\n    }\n    return max(rv,rec(o,nth+1,r-c));\n  }\n}\n\nint main(){\n  int N,M,K;\n  cin>>N>>M>>K;\n  int pop[32345]={};\n  for(int i=0;i<M;i++){\n    absbs[i]=true;\n    cin>>a[i]>>b[i];\n    a[i]--;\n    b[i]--;\n    pop[a[i]]++;\n    pop[b[i]]++;\n    is[a[i]][i]=true;\n    is[b[i]][i]=true;\n  }\n  idx.resize(N);\n  iota(begin(idx),end(idx),0);\n  sort(begin(idx),end(idx),[pop](int a,int b){\n      return pop[a]>pop[b];\n    });\n  int r=rec(BS(),0,K);\n  if(r<0){\n    cout<<\"Impossible\"<<endl;\n  }else{\n    cout<<K-r<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,k,xx,yy,d[3005],ans;\nbool e[3005][3005];\n\nvoid rec(int x){\n\tif (x>min(ans,k)) return;\n\tif (!*max_element(d+1,d+n+1)){\n\t\tans=min(ans,x); return;\n\t}\n\tbool ok=true; int ret=0,sz,neg=0;\n\tvector<pair<int,int>> v1,v2;\n\tv1.clear(); v2.clear();\n\twhile (ok){\n\t\tok=false;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tif (d[i]==1){\n\t\t\t\tok=true;\n\t\t\t\tfor (int j=1;j<=n;j++){\n\t\t\t\t\tif (e[i][j]){\n\t\t\t\t\t\tfor (int k=1;k<=n;k++){\n\t\t\t\t\t\t\tif (e[j][k]){\n\t\t\t\t\t\t\t\tv1.push_back(make_pair(j,k));\n\t\t\t\t\t\t\t\te[j][k]=e[k][j]=0;\n\t\t\t\t\t\t\t\td[k]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[j]=0; ret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!*max_element(d+1,d+n+1)){\n\t\tsz=v1.size();\n\t\tfor (int i=0;i<sz;i++){\n\t\t\te[v1[i].first][v1[i].second]=1;\n\t\t\te[v1[i].second][v1[i].first]=1;\n\t\t\td[v1[i].first]++; d[v1[i].second]++;\n\t\t}\n\t\tans=min(ans,x+ret); return;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tif (d[i]){\n\t\t\tfor (int j=1;j<=n;j++){\n\t\t\t\tif (e[i][j]){\n\t\t\t\t\td[j]--;\n\t\t\t\t\te[i][j]=e[j][i]=0;\n\t\t\t\t\tv2.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\td[i]=0;\n\t\t\trec(x+ret+1);\n\t\t\tsz=v2.size();\n\t\t\tfor (int i=0;i<sz;i++){\n\t\t\t\te[v2[i].first][v2[i].second]=1;\n\t\t\t\te[v2[i].second][v2[i].first]=1;\n\t\t\t\td[v2[i].first]++; d[v2[i].second]++;\n\t\t\t}\n\t\t\tv2.clear();\n\t\t\tfor (int j=1;j<=n;j++){\n\t\t\t\tif (e[i][j]){\n\t\t\t\t\tneg++;\n\t\t\t\t\tfor (int k=1;k<=n;k++){\n\t\t\t\t\t\tif (e[j][k]){\n\t\t\t\t\t\t\td[k]--;\n\t\t\t\t\t\t\te[j][k]=e[k][j]=0;\n\t\t\t\t\t\t\tv2.push_back(make_pair(j,k));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\td[j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\trec(x+ret+neg);\n\t\t\tsz=v2.size();\n\t\t\tfor (int i=0;i<sz;i++){\n\t\t\t\te[v2[i].first][v2[i].second]=1;\n\t\t\t\te[v2[i].second][v2[i].first]=1;\n\t\t\t\td[v2[i].first]++; d[v2[i].second]++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tsz=v1.size();\n\tfor (int i=0;i<sz;i++){\n\t\te[v1[i].first][v1[i].second]=1;\n\t\te[v1[i].second][v1[i].first]=1;\n\t\td[v1[i].first]++; d[v1[i].second]++;\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin >> n >> m >> k;\n\twhile (m--){\n\t\tcin >> xx >> yy;\n\t\te[xx][yy]=e[yy][xx]=1;\n\t\td[xx]++; d[yy]++;\n\t}\n\tans=1000000000; rec(0);\n\tif (ans>k) cout << \"Impossible\\n\";\n\telse cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef bitset<300000> BS;\n\nBS ref;\nBS is[3000];\nvector<int> idx;\nint a[32345],b[32345];\n\nint rec(const BS &bs,int nth,int r){\n  if(r<0)return r;\n  if(bs==ref)return r;\n  while((is[idx[nth]]&~bs).none()){\n    nth++;\n  }\n  BS n=is[idx[nth]]&~bs;\n  if(n.count()==1){\n    for(int i=0;;i++){\n      if(n[i]){\n\treturn rec(bs|is[a[i]^b[i]^idx[nth]],nth+1,r-1);\n      }\n    }\n  }else{\n    int rv=rec(bs|is[idx[nth]],nth+1,r-1);\n    BS o=bs;\n    int c=0;\n    for(int i=0;n.any();i++){\n      if(n[i]){\n\to|=bs|is[a[i]^b[i]^idx[nth]];\n\tc++;\n\tn[i]=false;\n      }\n    }\n    return max(rv,rec(o,nth+1,r-c));\n  }\n}\n\nint main(){\n  int N,M,K;\n  cin>>N>>M>>K;\n  int pop[32345]={};\n  for(int i=0;i<M;i++){\n    ref[i]=true;\n    cin>>a[i]>>b[i];\n    a[i]--;\n    b[i]--;\n    pop[a[i]]++;\n    pop[b[i]]++;\n    is[a[i]][i]=true;\n    is[b[i]][i]=true;\n  }\n  idx.resize(N);\n  iota(begin(idx),end(idx),0);\n  sort(begin(idx),end(idx),[pop](int a,int b){\n      return pop[a]>pop[b];\n    });\n  int r=rec(BS(),0,K);\n  if(r<0){\n    cout<<\"Impossible\"<<endl;\n  }else{\n    cout<<K-r<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\t// ListIterator<T> からのアクセスを許可する\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の添字を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    int index;\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool erase(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use) add_size++, cand.push_back(u);\n        // ans より良い解が得られないと分かった\n        if((int)cand.size() >= ans_size) return false;\n        erase_ver.emplace_back(u, rem_ver.erase(u).index);\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev).index);\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to).index);\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                add_size++, cand.push_back(e.to);\n                // ans より良い解が得られないと分かった\n                if((int)cand.size() >= ans_size) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, add_size, erase_ver)) return false;\n        // cout << u << endl;\n        // cout << rem_ver << endl;\n        // sset(small_deg_ver), sset(use_ver);\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            while(!small_deg_ver.empty()){\n                int v = *small_deg_ver.begin();\n                small_deg_ver.erase(v);\n                if(deg[v] == 0) continue;\n                if(!erase(v, false, add_size, erase_ver)) return false;\n            }\n            // cout << \"END\" << endl;\n            // cout << u << endl;\n            // cout << rem_ver << endl;\n            // sset(small_deg_ver), sset(use_ver);\n            // svec(cand);\n            while(!use_ver.empty()){\n                int v = *use_ver.begin();\n                use_ver.erase(v);\n                if(deg[v] == 0) continue;\n                if(!erase(v, true, add_size, erase_ver)) return false;\n            }\n            // show(\"OK\");\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int add_size, vector<pair<int, int> >& erase_ver){\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(pl_add_size, pl_erase_ver);\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(add_size, erase_ver);\n        if(!check()) return postprocessing(add_size, erase_ver);\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(rem_edge_size > (long long)max_deg * (int)rem_edge_size){\n            return postprocessing(add_size, erase_ver);\n        }\n        // show(rem_ver);\n        // show(next_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        ans_size = K + 1;\n        judge(K);\n        return ans_size <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    // svec(mvc.ans_set);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,K;\nvector<int> G[3001];\n\nint solve( const vector<int> & used );\n\nint getsize(const vector<int>& mt,const vector<int>& nt){\n  int ret = 0;\n  for(int i=0;i<N;i++) ret += mt[i];\n  bool ok = true;\n  for(int i=0;i<N;i++)\n    if( nt[i] )\n      for(int j=0;j<(int)G[i].size();j++)\n        if( nt[G[i][j]] ) ok = false;\n  if( ok ) return ret;\n  return ret + solve(nt);\n}\n\nvoid dfs(int v,int t,vector<int>& g,vector<int>& k,const vector<int>& used){\n  if( t ) g[v] = 1;\n  else k[v] = 1;\n  for(int i=0;i<(int)G[v].size();i++){\n    int to = G[v][i];\n    if( !used[to] || g[to] || k[to] ) continue;\n    dfs( to, 1-t, g, k,used );\n  }\n}\n\nint solve(const vector<int>& used){\n  vector<int> g(N,0);\n  vector<int> k(N,0);\n  for(int i=0;i<N;i++){\n    if( !used[i] || g[i] || k[i] ) continue;\n    dfs(i,0,g,k,used);\n  }\n  return min(getsize( g, k ), getsize( k, g ));\n}\n\nint main(){\n  cin >> N >> M >> K;\n  for(int i=0;i<M;i++){\n    int a,b; cin >> a >> b; --a; --b;\n    G[a].push_back( b );\n    G[b].push_back( a );\n  }\n  vector<int> used(N,1);\n  int res = solve(used);\n  if( res > K ) cout << \"Impossible\" << endl;\n  else cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define ll long long\n#define line printf(\"\\n\")\n#define rep(a,b,c) for(int a= (int)b;a<(int)c;a++)\n#define repd(a,b,c) for(int a=(int)b;a>=c;a--)\n#define pb push_back\n#define pf push_front\n#define pb2 pop_back\n#define pf2 pop_front\n#define pq priority_queue\n#define haha printf(\"hahaha\\n\")\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e17;\nconst double EPS = 1e-5;\n\nusing namespace std;\n\nvector<int> adj[3005];\npair<int,int> edge[30005];\nint flag[3005],deg[3005];\nint n,m,d,rem;\ninline void upg(int &a,int b){\n\tif(a<b)a = b;\n}\nint brute(int i,int sisa){\n\tint ret = -1;\n\n\tfor(int k=i;k<m;k++){\n\t\tint a = edge[k].first;\n\t\tint b = edge[k].second;\n\t\tif(flag[a] || flag[b])continue;\n\t\tif(sisa==0)return -1;\n\t\tif(deg[a]<deg[b])swap(a,b);\n\t\tvector<int>reset;\n\t\t//use a\n\t\tflag[a] = 1;\n\t\tfor(int l=0;l<adj[a].size();l++){\n\t\t\tif(!flag[adj[a][l]]){\n\t\t\t\tdeg[adj[a][l]]--;\n\t\t\t\treset.push_back(adj[a][l]);\n\t\t\t}\n\t\t}\n\t\tif(sisa-1>ret && !(deg[a]<=1 && deg[b]>1))upg(ret,brute(i+1,sisa-1));\n\t\t\n\t\t//not use a\n\t\tflag[a] = 0;\n\t\tfor(int l=0;l<reset.size();l++)deg[reset[l]]++;\n\t\treset.clear();\n\t\t\n\t\tfor(int l=0;l<adj[a].size();l++){\n\t\t\tif(!flag[adj[a][l]]){\n\t\t\t\tsisa--;\n\t\t\t\tflag[adj[a][l]] = 1;\n\t\t\t\treset.push_back(adj[a][l]);\n\t\t\t}\n\t\t}\t\n\t\tfor(int l=0;l<reset.size();l++){\n\t\t\tfor(int j=0;j<adj[reset[l]].size();j++)deg[adj[reset[l]][j]]--;\n\t\t}\n\t\t\n\t\tif(sisa>ret && !(deg[a]>1&&deg[b]<=1))upg(ret,brute(i+1,sisa));\n\t\tfor(int l=0;l<reset.size();l++){\n\t\t\tflag[reset[l]] = 0;\n\t\t\tfor(int j=0;j<adj[reset[l]].size();j++)deg[adj[reset[l]][j]]++;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\treturn sisa;\n}\n\nint greedy(int);\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&d);\n\t\n\tfor(int k=0;k<m;k++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);a--;b--;\n\t\t\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t\tedge[k] = make_pair(a,b);\n\t\tdeg[a]++;deg[b]++;\n\t}\n\t\n\tint bisa = 1;\n\trem = d;\n\twhile(bisa){\n\t\tbisa = 0;\n\t\tfor(int k=0;k<n;k++)if(deg[k]>rem){\n\t\t\tif(rem==0)break;\n\t\t\tflag[k] = 1;\n\t\t\trem--;\n\t\t\tfor(int i=0;i<adj[k].size();i++)deg[adj[k][i]]--;\n\t\t\tbisa = 1;\n\t\t\tdeg[k] = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif(rem<0)break;\n\t}\n\tif(rem<0){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tvector<int> tmp;\n\t\tfor(int i=0;i<adj[k].size();i++){\n\t\t\tint next = adj[k][i];\n\t\t\tif(flag[next] || flag[k])continue;\n\t\t\ttmp.push_back(next);\n\t\t}\n\t\tadj[k] = tmp;\n\t\tdeg[k] = adj[k].size();\n\t}\n\tint M = 0;\n\tfor(int k=0;k<m;k++){\n\t\tint a = edge[k].first;\n\t\tint b = edge[k].second;\n\t\tif(flag[a] || flag[b])continue;\n\t\tedge[M++] = edge[k];\n\t}\n\tm = M;\n\tif(m>rem*rem){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\t//rep(k,0,n)printf(\"%d \",deg[k]);line;\n\tint tmp = greedy(rem);\n\tif(tmp<0)printf(\"Impossible\\n\");else printf(\"%d\\n\",d-tmp);\n\treturn 0;\n}\n\ninline void remove(int a){\n\tdeg[a] = 0;\n\trep(k,0,adj[a].size()){\n\t\tif(deg[adj[a][k]])deg[adj[a][k]]--;\n\t}\n}\nvector<int>rev[3005];\nint greedy(int sisa){\n\tif(sisa<0)return sisa;\n\tint maks = 0;\n\trep(k,0,n)rev[k].clear();\n\trep(k,0,n)if(deg[k])rev[deg[k]].pb(k),maks = max(maks,deg[k]);\n\t\n\tif(maks==0)return sisa;\n\tint node;\n\tif(rev[1].size()){\n\t\tnode = rev[1][0];\n\t\trep(k,0,adj[node].size())if(deg[adj[node][k]]){\n\t\t\tnode = adj[node][k];break;\n\t\t}\n\t}\n\telse{\n\t\tnode = rev[maks][0];\n\t}\n\t//printf(\"|%d\",node+1);line;\n\tremove(node);\n\treturn greedy(sisa-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 3005\n\n\nenum Type{\n\tUNDEFINED,\n\tMUST_MEDICAL,\n};\n\nstruct Info{\n\tInfo(){\n\t\tnode_index = 0;\n\t\tedge_num = 0;\n\t}\n\tInfo(int arg_node_index,int arg_edge_num){\n\t\tnode_index = arg_node_index;\n\t\tedge_num = arg_edge_num;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn edge_num > arg.edge_num;\n\t}\n\tint node_index,edge_num;\n};\n\nint V,E,K,num_nodes;\nint edge_num[NUM];\nbool edge[NUM][NUM];\nint ans,minimum;\nInfo first_info[NUM],info[NUM];\nvector<int> first_G[NUM],G[NUM];\nType type[NUM];\nmap<int,int> MAP;\n\nint total_index;\n\n\nvoid recursive(int index){\n\n\tif(ans >= minimum || ans > K){\n\t\treturn;\n\t}\n\n\tif(index == num_nodes){\n\t\tif(E == 0){\n\t\t\tminimum = ans;\n\t\t}else{\n\t\t\tprintf(\"BUGG!!\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\tint node_id = info[index].node_index;\n\n\tif(ans+(min(K-ans,num_nodes-index)*info[index].edge_num) < E){\n\t\treturn;\n\t}\n\n\tif(edge_num[node_id] == 0){\n\t\trecursive(index+1);\n\t\treturn;\n\t}\n\n\tif(type[node_id] == MUST_MEDICAL || edge_num[node_id] >= 2){\n\n\t\tif(type[node_id] == UNDEFINED){\n\t\t\tans++;\n\t\t}\n\t\tE -= edge_num[node_id];\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tif(!edge[node_id][G[node_id][i]])continue;\n\t\t\tedge_num[G[node_id][i]]--;\n\t\t\tedge[G[node_id][i]][node_id] = false;\n\t\t}\n\n\t\trecursive(index+1);\n\n\t\tif(type[node_id] == UNDEFINED){\n\t\t\tans--;\n\t\t}\n\t\tE += edge_num[node_id];\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tif(!edge[node_id][G[node_id][i]])continue;\n\t\t\tedge_num[G[node_id][i]]++;\n\t\t\tedge[G[node_id][i]][node_id] = true;\n\t\t}\n\n\t\tif(type[node_id] == MUST_MEDICAL)return;\n\t}\n\n\tif(ans+edge_num[node_id] >= min(minimum,K+1))return;\n\n\tans += edge_num[node_id];\n\tE -= edge_num[node_id];\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!edge[node_id][G[node_id][i]])continue;\n\t\tedge_num[G[node_id][i]]--;\n\t\ttype[G[node_id][i]] = MUST_MEDICAL;\n\t\tedge[G[node_id][i]][node_id] = false;\n\t}\n\n\trecursive(index+1);\n\n\tans -= edge_num[node_id];\n\tE += edge_num[node_id];\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!edge[node_id][G[node_id][i]])continue;\n\t\tedge_num[G[node_id][i]]++;\n\t\ttype[G[node_id][i]] = UNDEFINED;\n\t\tedge[G[node_id][i]][node_id] = true;\n\t}\n}\n\nint get_index(int node_id){\n\n\tauto at = MAP.find(node_id);\n\tif(at == MAP.end()){\n\t\tMAP[node_id] = total_index++;\n\t}\n\treturn MAP[node_id];\n}\n\nint main(){\n\n\tscanf(\"%d %d %d\",&V,&E,&K);\n\n\tfor(int i = 0; i < V; i++){\n\t\tfirst_info[i].node_index = i;\n\t\tfirst_info[i].edge_num = 0;\n\t\ttype[i] = UNDEFINED;\n\t\tedge_num[i] = 0;\n\t}\n\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int k = 0; k < V; k++){\n\t\t\tedge[i][k] = false;\n\t\t}\n\t}\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < E; loop++){\n\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\n\t\tfrom = get_index(from);\n\t\tto = get_index(to);\n\n\t\tfirst_info[from].edge_num++;\n\t\tfirst_info[to].edge_num++;\n\n\t\tfirst_G[from].push_back(to);\n\t\tfirst_G[to].push_back(from);\n\n\t\tedge[from][to] = true;\n\t\tedge[to][from] = true;\n\t}\n\n\tsort(first_info,first_info+V);\n\n\tans = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\tif(first_info[i].edge_num <= K)break;\n\n\t\tans++;\n\t\ttype[i] = MUST_MEDICAL;\n\n\t\tE -= first_G[first_info[i].node_index].size();\n\n\t\tfor(int k = 0; k < first_G[first_info[i].node_index].size(); k++){\n\n\t\t\tedge[first_info[i].node_index][first_G[first_info[i].node_index][k]] = false;\n\t\t\tedge[first_G[first_info[i].node_index][k]][first_info[i].node_index] = false;\n\t\t}\n\t}\n\n\tif(ans > K){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\n\tint index = 0,node_id;\n\n\tfor(int i = 0; i < V; i++){\n\t\tif(type[i] == MUST_MEDICAL)continue;\n\n\t\tinfo[index].node_index = first_info[i].node_index;\n\t\tnode_id = info[index].node_index;\n\n\t\tfor(int k = 0; k < first_G[node_id].size(); k++){\n\t\t\tif(edge[node_id][first_G[node_id][k]] == false)continue;\n\n\t\t\tedge_num[node_id]++;\n\n\t\t\tG[node_id].push_back(first_G[node_id][k]);\n\t\t}\n\t\tinfo[index].edge_num = edge_num[node_id];\n\t\tindex++;\n\t}\n\n\tsort(info,info+index);\n\n\tminimum = BIG_NUM;\n\n\tfor(int i = 0; i < V; i++){\n\t\ttype[i] = UNDEFINED;\n\t}\n\n\tnum_nodes = index;\n\n\trecursive(0);\n\n\tif(minimum > K){\n\n\t\tprintf(\"Impossible\\n\");\n\n\t}else{\n\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int& add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int& add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool reset(){\n        small_deg_ver.clear(), use_ver.clear();\n        return false;\n    }\n    bool erase_rec(int u, bool use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return reset();\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return reset();\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return reset();\n        }\n        return true;\n    }\n    bool preprocessing(int K, int& add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        transition(K, next_ver, true);\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nint N,M,K;\nvector<int> G[3000];\nvector<P> es;\nint d[3000],use[30000]; \nint dfs(int x,int k){\n\tfor(int i=x;i<M;i++){\n\t\tint a=es[i].fs,b=es[i].sc;\n\t\tif(use[a]!=1&&use[b]!=1){\n\t\t\tif(k==0) return -1;\n\t\t\tint best=-1;\n\t\t\t//use a\n\t\t\tif(use[a]<0){\n\t\t\t\tuse[a]=1;\n\t\t\t\tvector<int> vc;\n\t\t\t\tfor(int v:G[a]){\n\t\t\t\t\tif(use[v]<0){\n\t\t\t\t\t\tvc.pb(v);\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(best,dfs(x+1,k-1));\n\t\t\t\tfor(int v:vc) d[v]++;\n\t\t\t\tuse[a]=-1;\n\t\t\t}\n\t\t\t//use b\n\t\t\tif(use[b]<0){\n\t\t\t\tuse[b]=1;\n\t\t\t\tvector<int> vc;\n\t\t\t\tfor(int v:G[b]){\n\t\t\t\t\tif(use[v]<0){\n\t\t\t\t\t\tvc.pb(v);\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(best,dfs(x+1,k-1));\n\t\t\t\tfor(int v:vc) d[v]++;\n\t\t\t\tuse[b]=-1;\n\t\t\t}\n\t\t\treturn best;\n\t\t}\n\t}\n\treturn k;\n}\nint main(){\n\tcin>>N>>M>>K;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\td[a]++,d[b]++;\n\t\tes.pb(P(a,b));\n\t}\n\trep(i,N) use[i]=-1;\n\trep(i,N) if(d[i]==0) use[i]=0;\n\tint k=K;\n\twhile(true){\n\t\tint v=-1;\n\t\trep(i,N) if(d[i]>k){\n\t\t\tv=i;break;\n\t\t}\n\t\tif(v<0) break;\n\t\tuse[v]=1;\n\t\tfor(int u:G[v]){\n\t\t\tif(d[u]) d[u]--;\n\t\t}\n\t\td[v]=0;\n\t\tk--;\n\t\tif(k<0){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint Mc=M;\n\tM=0;\n\trep(i,Mc) if(use[es[i].fs]!=1&&use[es[i].sc]!=1) es[M++]=es[i];\n\tif(M>k*k){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\trep(v,N){\n\t\tint j=0;\n\t\trep(i,G[v].size()){\n\t\t\tint u=G[v][i];\n\t\t\tif(use[v]!=1&&use[u]!=1) G[v][j++]=u;\n\t\t}\n\t\tG[v].resize(j);\n\t}\n\tint ans=dfs(0,k);\n//\tshow(K);\n//\tshow(k);\n//\tshow(ans);\n\tcout<<K-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<set<int>> g(n);\n    vector<int> deg(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b; cin >> a >> b;\n        g[a - 1].insert(b - 1);\n        g[b - 1].insert(a - 1);\n        deg[a - 1]++;\n        deg[b - 1]++;\n    }\n\n    vector<bool> used(n);\n    int now = 0;\n    for(int i = 0; i < n; ++i) {\n        if(deg[i] > k) {\n            used[i] = true;\n            deg[i] = 0;\n            now++;\n            for(auto to : g[i]) {\n                deg[to]--;\n            }\n        }\n    }\n    int remain_edge = 0;\n    for(int i = 0; i < n; ++i) {\n        remain_edge += deg[i];\n    }\n    remain_edge /= 2;\n    if(now > k) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n\n    vector<int> ord;\n    {\n        vector<set<int>> g2(n - now);\n        deg.assign(n - now, 0);\n        int x = 0;\n        vector<int> idx(n);\n        vector<pii> deg_idx;\n        for(int i = 0; i < n; ++i) {\n            if(used[i]) continue;\n            deg[x] = 0;\n            idx[i] = x++;\n        }\n        for(int i = 0; i < n; ++i) {\n            if(used[i]) continue;\n            for(auto to : g[i]) {\n                if(!used[to]) {\n                    deg[idx[i]]++;\n                    g2[idx[i]].insert(idx[to]);\n                }\n            }\n            deg_idx.emplace_back(deg[idx[i]], idx[i]);\n        }\n        sort(rbegin(deg_idx), rend(deg_idx));\n        for(auto& p : deg_idx) {\n            ord.push_back(p.second);\n        }\n        g = move(g2);\n        n = g.size();\n    }\n\n    int ans = k + 1;\n    function<void(int)> solve = [&](int i) {\n        if(i == n) {\n            ans = min(ans, now);\n            return;\n        }\n        const int r = min(k - now, n - i);\n        const int v = ord[i];\n        if(now >= ans || now > k || remain_edge > r * deg[v]) {\n            return;\n        };\n        if(g[v].empty()) {\n            solve(i + 1);\n        } else {\n            // use\n            if((int)g[v].size() > 1) {\n                now++;\n                vector<int> erased;\n                for(auto to : g[v]) {\n                    erased.push_back(to);\n                    g[to].erase(v);\n                }\n                remain_edge -= (int)g[v].size();\n                g[v].clear();\n                solve(i + 1);\n                for(auto to : erased) {\n                    g[v].insert(to);\n                    g[to].insert(v);\n                }\n                remain_edge += (int)g[v].size();\n                now--;\n            }\n\n            // not use\n            if(now + (int)g[v].size() <= min(ans, k)) {\n                now += g[v].size();\n                vector<int> erased;\n                vector<set<int>> erased2;\n                set<pii> erased_edges;\n                for(auto to : g[v]) {\n                    erased.push_back(to);\n                    set<int> tmp;\n                    for(auto to2 : g[to]) {\n                        tmp.insert(to2);\n                        erased_edges.emplace(min(to, to2), max(to, to2));\n                        if(to2 != v) {\n                            g[to2].erase(to);\n                        }\n                    }\n                    g[to].clear();\n                    erased2.push_back(move(tmp));\n                }\n                remain_edge -= erased_edges.size();\n                g[v].clear();\n                solve(i + 1);\n                for(int j = 0; j < (int)erased.size(); ++j) {\n                    g[v].insert(erased[j]);\n                    for(auto to2 : erased2[j]) {\n                        g[to2].insert(erased[j]);\n                    }\n                    g[erased[j]] = move(erased2[j]);\n                    remain_edge += g[erased[j]].size();\n                }\n                now -= g[v].size();\n            }\n        }\n    };\n    solve(0);\n\n    if(ans > k) {\n        cout << \"Impossible\" << endl;\n    } else {\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int& add_size){\n        add_size++, cand.push_back(u);\n        // svec(cand);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        // cout << \"ERASE \" << u << endl;\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            // cout << \"ERASE \" << u << \" \" << e.to << endl;\n            deg[e.to]--, rem_edge_size--;\n            // show(rem_edge_size);\n            if(deg[e.to] == 0){\n                erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n                // cout << \"ERASE \" << e.to << endl;\n            }\n            if(!use){\n                // show(e.to);\n                // sset(use_ver);\n                // if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n                // sset(use_ver);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int& add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int& add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        // 最初の層で行われた前処理による変更は特に後処理する必要がない\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                // cout << \"ADD \" << dat.from << \" \" << p.first << endl;\n                // show(rem_edge_size);\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n            // cout << \"ADD \" << \" \" << p.first << endl;\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            // svec(cand);\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        // 使う場合\n        // cout << next_ver << \" 使う場合開始\" << endl;\n        transition(K, next_ver, true);\n        // cout << next_ver << \" 使わない場合開始\" << endl;\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int& add_size){\n        add_size++, cand.push_back(u);\n        // cout << \"ADD CAND \" << u << endl;\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        // cout << \"ERASE \" << u << endl;\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            // cout << \"ERASE \" << u << \" \" << e.to << endl;\n            deg[e.to]--, rem_edge_size--;\n            // show(rem_edge_size);\n            if(deg[e.to] == 0){\n                erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n                // cout << \"ERASE \" << e.to << endl;\n            }\n            if(!use){\n                // svec(cand);\n                // show(e.to);\n                // sset(use_ver);\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n                // sset(use_ver);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int& add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)){\n            small_deg_ver.clear(), use_ver.clear();\n            return false;\n        }\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)){\n                small_deg_ver.clear(), use_ver.clear();\n                return false;\n            }\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)){\n                small_deg_ver.clear(), use_ver.clear();\n                return false;\n            }\n        }\n        return true;\n    }\n    bool preprocessing(int K, int& add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        // 最初の層で行われた前処理による変更は特に後処理する必要がない\n        if(K == fp_size) return;\n        // cout << \"CAND ERASE \";\n        for(int i = 0; i < add_size; i++){\n            // cout << cand.back() << \" \";\n            cand.pop_back();\n        }\n        // cout << endl;\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                // cout << \"ADD \" << dat.from << \" \" << p.first << endl;\n                // show(rem_edge_size);\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n            // cout << \"ADD \" << \" \" << p.first << endl;\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            // svec(cand);\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        // cout << \"preprocessing\" << endl;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        // 使う場合\n        // cout << next_ver << \" 使う場合開始\" << endl;\n        transition(K, next_ver, true);\n        // cout << next_ver << \" 使わない場合開始\" << endl;\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        // show(rem_edge_size);\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nint N,M,K;\nvector<int> G[3000];\nvector<P> es;\nint d[3000],use[30000]; \nint dfs(int x,int k){\n\tfor(int i=x;i<M;i++){\n\t\tint a=es[i].fs,b=es[i].sc;\n\t\tif(use[a]!=1&&use[b]!=1){\n\t\t\tif(k==0) return -1;\n\t\t\tif(d[a]<d[b]) swap(a,b);\n\t\t\tint best=-1;\n\t\t\t//use a\n\t\t\tif(use[a]<0){\n\t\t\t\tuse[a]=1;\n\t\t\t\tvector<int> vc;\n\t\t\t\tfor(int v:G[a]){\n\t\t\t\t\tif(use[v]<0){\n\t\t\t\t\t\tvc.pb(v);\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(best,dfs(x+1,k-1));\n\t\t\t\tfor(int v:vc) d[v]++;\n\t\t\t\tuse[a]=-1;\n\t\t\t}\n\t\t\t//use b\n\t\t\tif(use[b]<0&&d[b]>1){\n\t\t\t\tuse[b]=1;\n\t\t\t\tvector<int> vc;\n\t\t\t\tfor(int v:G[b]){\n\t\t\t\t\tif(use[v]<0){\n\t\t\t\t\t\tvc.pb(v);\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(best,dfs(x+1,k-1));\n\t\t\t\tfor(int v:vc) d[v]++;\n\t\t\t\tuse[b]=-1;\n\t\t\t}\n\t\t\treturn best;\n\t\t}\n\t}\n\treturn k;\n}\nint main(){\n\tcin>>N>>M>>K;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\td[a]++,d[b]++;\n\t\tes.pb(P(a,b));\n\t}\n\trep(i,N) use[i]=-1;\n\trep(i,N) if(d[i]==0) use[i]=0;\n\tint k=K;\n\twhile(true){\n\t\tint v=-1;\n\t\trep(i,N) if(d[i]>k){\n\t\t\tv=i;break;\n\t\t}\n\t\tif(v<0) break;\n\t\tuse[v]=1;\n\t\tfor(int u:G[v]){\n\t\t\tif(d[u]) d[u]--;\n\t\t}\n\t\td[v]=0;\n\t\tk--;\n\t\tif(k<0){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint Mc=M;\n\tM=0;\n\trep(i,Mc) if(use[es[i].fs]!=1&&use[es[i].sc]!=1) es[M++]=es[i];\n\tif(M>k*k){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\trep(v,N){\n\t\tint j=0;\n\t\trep(i,G[v].size()){\n\t\t\tint u=G[v][i];\n\t\t\tif(use[v]!=1&&use[u]!=1) G[v][j++]=u;\n\t\t}\n\t\tG[v].resize(j);\n\t}\n\tint ans=dfs(0,k);\n\tif(ans<0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tcout<<K-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n// 次数は今見ているものの中で最大を取る(毎回変わる！)\n\n// 多重辺を含まないとする\nclass MVC {\nprivate:\n    struct edge {\n        int to;\n        list<edge>::iterator rev;\n        edge(int _to) : to(_to){}\n    };\n    \n    int V, rem_ver, rem_edge;\n    bool ok;\n    vector<list<edge> > G;\n    vector<pair<int, int> > es;\n    vector<int> deg, ver;\n    vector<bool> rem, use;\n    \n    void delete_edge(const int u, vector<int>& ch, vector<int>& add, bool _use){\n        for(auto& e : G[u]){\n            if(_use) use[e.to] = true, add.push_back(e.to);\n            G[e.to].erase(e.rev), deg[e.to]--, rem_edge--, ch.push_back(e.to);\n            if(deg[e.to] == 0) rem[e.to] = false, rem_ver--;\n        }\n    }\n    void inv_delete_edge(const int u, vector<int>& ch, vector<int>& add, bool _use){\n        for(auto v : ch){\n            if(_use) use[v] = false, add.pop_back();\n            G[v].push_back(u), deg[v]++, rem_edge++;\n            if(deg[v] == 1) rem[v] = true, rem_ver++;\n        }\n    }\n    void preprocessing(const int K, vector<int>& ans){\n        for(int i = 0; i < V; i++){\n            if(deg[i] > K){\n                ans.push_back(i), rem[i] = false;\n            }else{\n                ver.push_back(i), rem_ver++;\n            }\n        }\n        for(auto& e : es){\n            if(rem[e.first] && rem[e.second]){\n                rem_edge++;\n            }else{\n                if(rem[e.first]) deg[e.first]--;\n                if(rem[e.second]) deg[e.second]--;\n            }\n        }\n        for(auto& e : es){\n            if(rem[e.first] && rem[e.second]){\n                G[e.first].push_back(edge(e.second));\n                G[e.second].push_back(edge(e.first));\n                G[e.first].back().rev = (--G[e.second].end());\n                G[e.second].back().rev = (--G[e.first].end());\n            }\n        }\n    }\n    void rec(const int K, vector<int>& add, vector<int>& add_opt){\n        if(rem_edge == 0){\n            ok = true;\n            if(add_opt.empty() || (int)add.size() < (int)add_opt.size()) add_opt = add;\n            return;\n        }\n        int max_deg = numeric_limits<int>::min(), pos = -1;\n        for(int v : ver){\n            if(rem[v] && deg[v] > max_deg){\n                max_deg = deg[v], pos = v;\n            }\n        }\n        // 枝数の条件\n        if(rem_edge > max_deg*rem_ver) return;\n        rem[pos] = false, rem_ver--;\n        if(max_deg >= 2){\n            // 使う場合\n            vector<int> ch;\n            delete_edge(pos, ch, add, false);\n            if(!use[pos]) add.push_back(pos);\n            if((int)add.size() + (int)ans.size() <= K) rec(K, add, add_opt);\n            if(!use[pos]) add.pop_back();\n            inv_delete_edge(pos, ch, add, false);\n        }\n        if(use[pos]) return;\n        // 使わない場合\n        vector<int> ch;\n        delete_edge(pos, ch, add, true);\n        if((int)add.size() + (int)ans.size() <= K) rec(K, add, add_opt);\n        inv_delete_edge(pos, ch, add, true);\n        rem[pos] = true, rem_ver++;\n        return;\n    }\npublic:\n    vector<int> ans;\n    \n    MVC(int node_size) :\n        V(node_size), rem_ver(0), rem_edge(0), ok(false), G(V), deg(V, 0), rem(V, true), use(V, false){}\n    void add_edge(const int u, const int v){\n        es.emplace_back(u, v);\n        deg[u]++, deg[v]++;\n    }\n    bool judge(const int K){\n        preprocessing(K, ans);\n        vector<int> add, add_opt;\n        rec(K, add, add_opt);\n        for(int v : add_opt){\n            ans.push_back(v);\n        }\n        sort(ans.begin(), ans.end());\n        return ok && (int)ans.size() <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.judge(K)){\n        cout << len(mvc.ans) << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nunsigned long long xor128() {\n    static unsigned long long rx = 123456789, ry = 362436069, rz = 521288629, rw = 88675123;\n    unsigned long long rt = (rx ^ (rx << 11));\n    rx = ry;\n    ry = rz;\n    rz = rw;\n    return (rw = (rw ^ (rw >> 19)) ^ (rt ^ (rt >> 8)));\n}\n\nstd::chrono::system_clock::time_point start;\nstd::chrono::system_clock::time_point owari;\n\nbool A[3003][3003];\nint T[3003];\nint n,m,k,MIN=1e9,cnt[3003];\n\nint main(){\n    start = std::chrono::system_clock::now();\n    cin>>n>>m>>k;\n    r(i,m){\n        int a,b;\n        cin>>a>>b; a--; b--;\n        A[a][b]=A[b][a]=1;\n        cnt[a]++;\n        cnt[b]++;\n    }\n    r(i,n)T[i]=cnt[i];\n    for(;;){\n        int TEMP=0;\n        for(;;){\n            int x,idx=-1,MAX=0;\n            r(i,n){\n                if(MAX<cnt[i]||(cnt[i]&&(xor128()%114514==810))){\n                    MAX=cnt[i];\n                    x=i;\n                }\n                if(cnt[i]==1) idx=i;\n            }\n            if(!MAX)break;\n            TEMP++;\n            if(idx!=-1){\n                r(i,n)if(A[idx][i]&&cnt[i]){\n                    x=i;\n                    break;\n                }\n            }\n            r(i,n)if(A[x][i]&&cnt[i])cnt[i]--;\n            cnt[x]=0;\n        }\n        MIN=min(TEMP,MIN);\n        owari = std::chrono::system_clock::now();\n        double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(owari-start).count();\n        if(elapsed>0.1)break;\n\n        r(i,n)cnt[i]=T[i];\n\n    }\n    if(MIN<=k)cout<<MIN<<endl;\n    else cout<<\"Impossible\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct FPT{\n\tint n;\n\tstatic const int MAX=3005;\n\tstatic const int DMAX=50;\n\tvector<int> G[MAX];\n\tbool used[MAX];\n\tbool flag=false;\n\tvector<int> vec[DMAX];\n\n\tvoid restore(int v){\n\t\tused[v]=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv=G[v][i];\n\t\t\tG[nv].push_back(v);\n\t\t}\n\t}\n\n\tvoid remove(int v){\n\t\tused[v]=true;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv=G[v][i];\n\t\t\tfor(int j=0;j<G[nv].size();j++){\n\t\t\t\tif(G[nv][j]==v){\n\t\t\t\t\tG[nv][j]=G[nv].back();\n\t\t\t\t\tG[nv].pop_back();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> branchcut(int& k,int dep){\n\t\tvector<int> ret;\n\t\twhile(k>0){\n\t\t\tbool update=false;\n\t\t\tfor(int j=0;j<vec[dep].size();j++){\n\t\t\t\tint v=vec[dep][j];\n\t\t\t\tif(update || used[v] || G[v].size()<=k)continue;\n\t\t\t\tk--;\n\t\t\t\tremove(v);\n\t\t\t\tret.push_back(v);\n\t\t\t\tupdate=true;\n\t\t\t}\n\t\t\tif(!update)break;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool isok(int k,int dep){\n\t\tint edgerest=0;\n\t\tpriority_queue<int,vector<int>,greater<int> > que;\n\t\tfor(int i=0;i<vec[dep].size();i++){\n\t\t\tint v=vec[dep][i];\n\t\t\tif(!used[v]){\n\t\t\t\tedgerest+=G[v].size();\n\t\t\t\tque.push((int)G[v].size());\n\t\t\t\tif(que.size()>k)que.pop();\n\t\t\t}\n\t\t}\t\t\n\t\tedgerest/=2;\n\t\tint canuse=0,maxdeg=0;\n\t\twhile(que.size()){\n\t\t\tint q=que.top();\n\t\t\tque.pop();\n\t\t\tcanuse+=q;\n\t\t\tmaxdeg=q;\n\t\t}\n\t\tif(edgerest>k*maxdeg || edgerest>canuse)return false;\n\t\treturn true;\n\t}\n\n\tvoid seeyou(vector<int>& bra){\n\t\tfor(int i=0;i<bra.size();i++){\n\t\t\trestore(bra[i]);\n\t\t}\n\t}\n\n\tvoid getvec(int dep){\n\t\tif(dep>0){\n\t\t\tvec[dep].clear();\n\t\t\tfor(int i=0;i<vec[dep-1].size();i++){\n\t\t\t\tint v=vec[dep-1][i];\n\t\t\t\tif(!used[v] && G[v].size()>0){\n\t\t\t\t\tvec[dep].push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(int k,int dep){\n\t\tif(flag)return;\n\t\tgetvec(dep);\n\t\tif(vec[dep].size()==0){\n\t\t\tflag=true;\n\t\t\treturn;\n\t\t}\n\t\tvector<int> bra=branchcut(k,dep);\n\t\tif(!isok(k,dep)){\n\t\t\tseeyou(bra);\n\t\t\treturn;\n\t\t}\n\t\tint v=-1;\n\t\tfor(int i=0;i<vec[dep].size();i++){\n\t\t\tif(!used[vec[dep][i]] && G[vec[dep][i]].size()>0){\n\t\t\t\tif(v==-1)v=vec[dep][i];\n\t\t\t\telse if(G[vec[dep][i]].size()>G[v].size())v=vec[dep][i];\n\t\t\t}\n\t\t}\n\t\tvector<int> tmp;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv=G[v][i];\n\t\t\ttmp.push_back(nv);\n\t\t\tremove(nv);\n\t\t}\n\t\tdfs(k-tmp.size(),dep+1);\n\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\trestore(tmp[i]);\n\t\t}\n\t\tif(G[v].size()>1){\n\t\t\tremove(v);\n\t\t\tdfs(k-1,dep+1);\n\t\t\trestore(v);\n\t\t}\n\t\tseeyou(bra);\n\t}\n\n\t// check you can cover all edges by at most k nodes\n\tbool build(int k){\n\t\tflag=false;\n\t\tvec[0].clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvec[0].push_back(i);\n\t\t}\n\t\tdfs(k,0);\n\t\treturn flag;\n\t}\n};\n\nFPT fpt;\nint a[30005],b[30005];\n\nint main(void){\n\tint n,m,k;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t}\n\tfpt.n=n;\n\tint l=0,r=k+1;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfpt.G[j].clear();\n\t\t}\n\t\tfor(int j=0;j<m;j++){\n\t\t\tfpt.G[a[j]].push_back(b[j]);\n\t\t\tfpt.G[b[j]].push_back(a[j]);\n\t\t}\n\t\tmemset(fpt.used,0,sizeof(fpt.used));\n\t\tif(fpt.build(mid)){\n\t\t\tr=mid;\n\t\t}else{\n\t\t\tl=mid;\n\t\t}\n\t}\n\tif(r==(k+1))printf(\"Impossible\\n\");\n\telse printf(\"%d\\n\",r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cincout\n#define min(a,b) ((a) < (b) ? (a) : (b))\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define abs(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef pair <int, int> pii;\nint n,m,k,ans,tmppos,fixuse,sz;\nbool cov[3005],found;\nint a,b,tmp,edgs;\nint deg[3005];\npair<int, int> edg[30005];\nvector <int> adjlist[3005];\nvector <pii> edglist;\npriority_queue <pii, vector <pii>, greater <pii> > pq;\n\nvoid rek(int edgpos, int tmp_ans) {\n\t//cout << \"rek \" << edgpos << ' ' << tmp_ans << '\\n';\n\tif (found && tmp_ans > ans) return;\n\tif (tmp_ans > k) return;\n\twhile (edgpos<sz && (cov[edglist[edgpos].first] || cov[edglist[edgpos].second])) ++edgpos;\n\t//cout << \"whileok\\n\";\n\tif (edgpos==sz) {\n\t\tfound=true; ans=min(tmp_ans,ans);\n\t\treturn;\n\t}\n\t//cout << \"check ok\\n\";\n\tcov[edglist[edgpos].first]=true;\n\trek(edgpos+1,tmp_ans+1);\n\tvector <int> act_neigh;\n\tcov[edglist[edgpos].first]=false;\n\tfor (int i=0;i<adjlist[edglist[edgpos].first].size();++i) {\n\t\tif (!cov[adjlist[edglist[edgpos].first][i]]) {\n\t\t\tact_neigh.push_back(adjlist[edglist[edgpos].first][i]);\n\t\t\tcov[adjlist[edglist[edgpos].first][i]]=true;\n\t\t}\n\t}\n\trek(edgpos+1,tmp_ans+act_neigh.size());\n\tfor (int i=0;i<act_neigh.size();++i) cov[act_neigh[i]]=false;\n}\n\nint main() {\n\t#ifdef cincout\n\t\tcin.sync_with_stdio(0);\n\t\tcin.tie(0);\n\t#endif\n\tcin >> n >> m >> k;\n\tfixuse=0;\n\tfound=false;\n\tans=1000000;\n\tedgs=m;\n\tfor (int i=0;i<m;++i) {\n\t\tcin >> a >> b;\n\t\tedglist.push_back(make_pair(a,b));\n\t\tedglist.push_back(make_pair(b,a));\n\t\tadjlist[a].push_back(b);\n\t\tadjlist[b].push_back(a);\n\t\t++deg[a]; ++deg[b];\n\t}\n\tsz=edglist.size();\n\t//cout << \"Sz \" << sz << '\\n';\n\tfor (int i=1;i<=n;++i) pq.push(make_pair(deg[i],i));\n\twhile (!pq.empty()) {\n\t\ttmp=pq.top().second; pq.pop();\n\t\tif (cov[tmp]) continue;\n\t\telse {\n\t\t\tif (deg[tmp]>k) {\n\t\t\t\tcov[tmp]=true;\n\t\t\t\tdeg[tmp]=0;\n\t\t\t\t++fixuse;\n\t\t\t\t--k;\n\t\t\t\tfor (int i=0;i<adjlist[tmp].size();++i) {\n\t\t\t\t\tif (!cov[adjlist[tmp][i]]) {\n\t\t\t\t\t\tpq.push(make_pair(--deg[adjlist[tmp][i]],adjlist[tmp][i]));\n\t\t\t\t\t\t--edgs;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (deg[tmp]==1) {\n\t\t\t\t++fixuse;\n\t\t\t\tcov[tmp]=true;\n\t\t\t\t--k;\n\t\t\t\tfor (int i=0;i<adjlist[tmp].size();++i) {\n\t\t\t\t\tif (!cov[adjlist[tmp][i]]) {\n\t\t\t\t\t\tcov[adjlist[tmp][i]]=true;\n\t\t\t\t\t\tint tk=adjlist[tmp][i];\n\t\t\t\t\t\tdeg[tmp]=0;\n\t\t\t\t\t\tfor (int j=0;j<adjlist[tk].size();++j) if (!cov[adjlist[tk][j]]) {\n\t\t\t\t\t\t\tpq.push(make_pair(--deg[adjlist[tk][j]],adjlist[tk][j]));\n\t\t\t\t\t\t\t--edgs;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"ok\\n\";\n\trek(0,0);\n\t//cout << \"FIX \" << fixuse << '\\n';\n\tif (!found) cout << \"Impossible\\n\";\n\telse cout << ans+fixuse << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cincout\n#define min(a,b) ((a) < (b) ? (a) : (b))\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define abs(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef pair <int, int> pii;\nint n,m,k,ans,tmppos,fixuse,sz;\nbool cov[3005],found;\nint a,b,tmp,edgs;\nint deg[3005];\npair<int, int> edg[30005];\nvector <int> adjlist[3005];\nvector <pii> edglist;\npriority_queue <pii, vector <pii>, greater <pii> > pq;\n\nint get_deg(int u) {\n\tint ret=0;\n\tfor (int i=0;i<adjlist[u].size();++i)\n\t\tif (!cov[adjlist[u][i]]) ++ret;\n\treturn ret;\n}\n\nvoid rek(int tmp_ans) {\n\t//cout << tmp_ans << '\\n';\n\tif (tmp_ans > k) return;\n\tif (found && tmp_ans > ans) return;\n\tbool ok=true;\n\tvector <int> dat;\n\tfor (int i=1;i<=n;++i) {\n\t\tif (cov[i] || ((deg[i] = get_deg(i)) == 0)) continue;\n\t\telse {\n\t\t\tok=false;\n\t\t\tif (deg[i] == 1) {\n\t\t\t\t//cout << \"take \" << i << \" deg 1\\n\";\n\t\t\t\tint neg;\n\t\t\t\tfor (int j=0;j<adjlist[i].size();++j) {\n\t\t\t\t\tif (!cov[adjlist[i][j]]) {\n\t\t\t\t\t\tneg=adjlist[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcov[neg]=true;\n\t\t\t\trek(tmp_ans+1);\n\t\t\t\tcov[neg]=false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i) {\n\t\tif (cov[i] || ((deg[i]=get_deg(i)) == 0)) continue;\n\t\telse {\n\t\t\t//cout << \"take \" << i << '\\n';\n\t\t\tok=false;\n\t\t\tcov[i]=true;\n\t\t\trek(tmp_ans+1);\n\t\t\tcov[i]=false;\n\t\t\tfor (int j=0;j<adjlist[i].size();++j) {\n\t\t\t\tif (!cov[adjlist[i][j]]) dat.push_back(adjlist[i][j]);\n\t\t\t}\n\t\t\tfor (int j=0;j<dat.size();++j) cov[j]=true;\n\t\t\trek(tmp_ans+dat.size());\n\t\t\tfor (int j=0;j<dat.size();++j) cov[j]=false;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ok) {\n\t\tfound=true;\n\t\tans=min(ans,tmp_ans);\n\t\treturn;\n\t}\n}\n\nint main() {\n\t#ifdef cincout\n\t\tcin.sync_with_stdio(0);\n\t\tcin.tie(0);\n\t#endif\n\tcin >> n >> m >> k;\n\tfixuse=0;\n\tfound=false;\n\tans=1000000;\n\tedgs=m;\n\tfor (int i=0;i<m;++i) {\n\t\tcin >> a >> b;\n\t\tedglist.push_back(make_pair(a,b));\n\t\tedglist.push_back(make_pair(b,a));\n\t\tadjlist[a].push_back(b);\n\t\tadjlist[b].push_back(a);\n\t\t++deg[a]; ++deg[b];\n\t}\n\tsz=edglist.size();\n\t//cout << \"Sz \" << sz << '\\n';\n\t/*for (int i=1;i<=n;++i) pq.push(make_pair(deg[i],i));\n\twhile (!pq.empty()) {\n\t\ttmp=pq.top().second; pq.pop();\n\t\tif (cov[tmp]) continue;\n\t\telse {\n\t\t\tif (deg[tmp]>k) {\n\t\t\t\tcov[tmp]=true;\n\t\t\t\tdeg[tmp]=0;\n\t\t\t\t++fixuse;\n\t\t\t\t--k;\n\t\t\t\tfor (int i=0;i<adjlist[tmp].size();++i) {\n\t\t\t\t\tif (!cov[adjlist[tmp][i]]) {\n\t\t\t\t\t\tpq.push(make_pair(--deg[adjlist[tmp][i]],adjlist[tmp][i]));\n\t\t\t\t\t\t--edgs;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (deg[tmp]==1) {\n\t\t\t\t++fixuse;\n\t\t\t\tcov[tmp]=true;\n\t\t\t\t--k;\n\t\t\t\tfor (int i=0;i<adjlist[tmp].size();++i) {\n\t\t\t\t\tif (!cov[adjlist[tmp][i]]) {\n\t\t\t\t\t\tcov[adjlist[tmp][i]]=true;\n\t\t\t\t\t\tint tk=adjlist[tmp][i];\n\t\t\t\t\t\tdeg[tmp]=0;\n\t\t\t\t\t\tfor (int j=0;j<adjlist[tk].size();++j) if (!cov[adjlist[tk][j]]) {\n\t\t\t\t\t\t\tpq.push(make_pair(--deg[adjlist[tk][j]],adjlist[tk][j]));\n\t\t\t\t\t\t\t--edgs;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t//cout << \"ok\\n\";\n\trek(0);\n\t//cout << \"FIX \" << fixuse << '\\n';\n\tif (!found) cout << \"Impossible\\n\";\n\telse cout << ans+fixuse << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        // 最初の層で行われた前処理による変更は特に後処理する必要がない\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\t// ListIterator<T> からのアクセスを許可する\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の添字を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    int index;\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            add_size++, cand.push_back(u);\n            // ans より良い解が得られないと分かった\n            if((int)cand.size() >= ans_size) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u).index);\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev).index);\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to).index);\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                add_size++, cand.push_back(e.to);\n                // ans より良い解が得られないと分かった\n                if((int)cand.size() >= ans_size) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            while(!small_deg_ver.empty()){\n                int v = *small_deg_ver.begin();\n                small_deg_ver.erase(v);\n                if(deg[v] == 0) continue;\n                if(!erase(v, false, false, add_size, erase_ver)) return false;\n            }\n            while(!use_ver.empty()){\n                int v = *use_ver.begin();\n                use_ver.erase(v);\n                if(deg[v] == 0) continue;\n                if(!erase(v, true, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int add_size, vector<pair<int, int> >& erase_ver){\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(pl_add_size, pl_erase_ver);\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(add_size, erase_ver);\n        if(!check()) return postprocessing(add_size, erase_ver);\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()){\n            return postprocessing(add_size, erase_ver);\n        }\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        ans_size = K + 1;\n        judge(K);\n        return ans_size <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    // svec(mvc.ans_set);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に使う\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n\nprivate:\n    struct block {\n        int prev, next;\n        T value;\n        block(){}\n        block(T value_) : value(value_){}\n        block(int prev_, int next_) : prev(prev_), next(next_){}\n    };\n    int N, sz;\n    vector<block> container;\n    friend ListIterator<T>;\n\npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        auto& nw = container[now_index]; auto& nx = container[next_index];\n        nw.prev = nx.prev, nw.next = next_index;\n        container[nx.prev].next = now_index, nx.prev = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        auto& cur = container[index];\n        container[cur.prev].next = cur.next, container[cur.next].prev = cur.prev;\n        return iterator(this, cur.next);\n    }\n\npublic:\n    friend ostream& operator<< (ostream& os, List& ls){\n        for(auto& val : ls){\n            os << val << ' ';\n        }\n        return os;\n    }\n    const T& operator[](size_t index) const {\n        return container[index].value;\n    }\n    T& operator[](size_t index){\n        return container[index].value;\n    }\n    size_t size(){\n        return sz;\n    }\n    bool empty(){\n        return size() == 0;\n    }\n    T& front(){\n        return container[container[N].next].value;\n    }\n    T& back(){\n        return container[container[N].prev].value;\n    }\n    iterator begin(){\n        return iterator(this, container[N].next);\n    }\n    iterator end(){\n        return iterator(this, N);\n    }\n    iterator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n    iterator push_back(){\n        return insert(N, container[N].prev+1);\n    }\n    void pop_back(){\n        erase(container[N].prev);\n    }\n    void index_clear(){\n        N = sz = 0, container = {(block){0, 0}};\n    }\n    void clear(){\n        index_clear(); container.clear();\n    }\n\npublic:\n    List() : N(0), sz(0), container({(block){0, 0}}){}\n    List(int _N) : container(_N + 1){\n        build();\n    }\n    List(const List& ls):\n        N(ls.N), sz(ls.sz), container(ls.container){}\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n    iterator push_back(T val){\n        N++, sz++;\n        container[0].prev = container.back().next = N, container.back().value = val;\n        container.emplace_back(N-1, 0);\n        return iterator(this, N-1);\n    }\n\tvoid build(){\n        N = sz = (int)container.size() - 1;\n        for(int i = 0; i <= N; i++) container[i].prev = i-1, container[i].next = i+1;\n        container[0].prev = N, container[N].next = 0;\n    }\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n    friend List<T>;\n    List<T>* ls_ptr;\n    int index;\n\nprivate:\n    ListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\npublic:\n    ListIterator(){}\n    ListIterator(const ListIterator& itr){\n        ls_ptr = itr.ls_ptr, index = itr.index;\n    }\n    explicit operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    T& operator*() const {\n        return ls_ptr->container[index].value;\n    }\n    T* operator->() const {\n        return &ls_ptr->container[index].value;\n    }\n    ListIterator& operator++(){\n        index = ls_ptr->container[index].next;\n        return *this;\n    }\n    ListIterator operator++(int){\n        ListIterator res = *this;\n        index = ls_ptr->container[index].next;\n        return res;\n    }\n    ListIterator& operator--(){\n        index = ls_ptr->container[index].prev;\n        return *this;\n    };\n    ListIterator operator--(int){\n        ListIterator res = *this;\n        index = ls_ptr->container[index].prev;\n        return res;\n    };\n    bool operator==(const ListIterator& itr) const {\n        return !(*this != itr);\n    };\n    bool operator!=(const ListIterator& itr) const {\n        return this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n    }\n    friend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n        ListIterator<T> tmp = itr1;\n        itr1 = itr2, itr2 = itr1;\n    };\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) :\n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n\n    bool push_cand(int u, int& add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n\n    bool erase(int u, bool use, bool alr_use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, (int)rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, (int)G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, (int)rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int& add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool reset(){\n        small_deg_ver.clear(), use_ver.clear();\n        return false;\n    }\n    bool erase_rec(int u, bool use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return reset();\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return reset();\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return reset();\n        }\n        return true;\n    }\n    bool preprocessing(int K, int& add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        transition(K, next_ver, true);\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n\n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//saya dari kemarin ngerjain pak, tapi masih gadapet2\n//daripada saya dikira gak ngerjain, mending saya submit kode wa saya\n#include <bits/stdc++.h>\n#define debug cout << \"Debug\" << endl;\nusing namespace std;\n\nvector<int> adjlist[3500];\nvector<int> parent(3500,-1);\nbool visited[3500]={0};\nbool covered[3500]={0};\nint n, m, k;\nbool gagal=false;\n\nvoid buildtree(int pos){\n\tfor(int i=0;i<(int)adjlist[pos].size();i++){\n\t\tint tmp = adjlist[pos][i];\n\t\tif(parent[tmp] == -1){\n\t\t\tparent[tmp] = pos;\n\t\t\tbuildtree(tmp);\n\t\t}\n\t}\n}\nint dp(int pos, int taken, int yangudahtaken){\n\tint ret;\n\tif(taken == 0){\n\t\t//mau gak mau harus ngambil biar tetep true;\n\t\tvisited[pos] = true;\n\t\tcovered[pos] = true;\n\t\tint ambil = 1;\n\t\tfor(int i=0;i<(int)adjlist[pos].size();i++){\n\t\t\tint tmp = adjlist[pos][i];\n\t\t\tif(parent[pos] == tmp) continue;\n\t\t\tif(!visited[tmp]) ambil += dp(tmp,1,yangudahtaken+1); \n\t\t}\n\t\tvisited[pos] = false;\n\t\tcovered[pos] = false;\n\t\tret = ambil;\n\t} else {\n\t\t//bisa ambil bisa ngga kan;\n\t\tvisited[pos] = true;\n\t\t//misalnya ambil\n\t\tcovered[pos] = true;\n\t\tint ambil = 1;\n\t\tfor(int i=0;i<(int)adjlist[pos].size();i++){\n\t\t\tint tmp = adjlist[pos][i];\n\t\t\tif(parent[pos] == tmp) continue;\n\t\t\tif(!visited[tmp]) ambil += dp(tmp,1,yangudahtaken+1);\n\t\t}\n\t\tcovered[pos] = true;\n\t\t//misalnya ngga;\n\t\tbool harusambil = false;\n\t\tint gak = 0;\n\t\tfor(int i=0;i<(int)adjlist[pos].size();i++){\n\t\t\tint tmp = adjlist[pos][i];\n\t\t\tif(parent[pos] == tmp) continue;\n\t\t\tif(!visited[tmp]) gak += dp(tmp,0,yangudahtaken);\n\t\t\telse {\n\t\t\t\tif(!covered[tmp]){\n\t\t\t\t\tharusambil = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(harusambil) ret = ambil;\n\t\telse ret = min(ambil,gak);\n\t\tvisited[pos] = false;\n\t}\n\treturn ret;\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> m >> k;\n\tint u, v;\n\tfor(int i=0;i<m;i++){\n\t\tcin >> u >> v;\n\t\tadjlist[u].push_back(v);\n\t\tadjlist[v].push_back(u);\n\t}\n\tparent[1] = 1;\n\tbuildtree(1);\n\tint ans = dp(1,1,0);\n\tif(ans != 1000000000) cout << ans << endl;\n\telse cout << \"Impossible\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int& add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int& add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int& add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int& add_size, vector<pair<int, int> >& erase_ver){\n        // 最初の層で行われた前処理による変更は特に後処理する必要がない\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct node{\n\tvector<int> adjList;\n\tint counter;\n\tbool used;\n};\n\nnode listNode[3010];\nint sorted[3010];\n\nbool cmpCounter(int a, int b){\n\tif(listNode[a].counter > listNode[b].counter){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid update(int x, int n){\n\tint tmp = x+1;\n\t\n\tfor (int i = x+2; i < n; i++){\n\t\tif(listNode[sorted[tmp]].counter < listNode[sorted[i]].counter){\n\t\t\tsorted[tmp] = sorted[tmp] + sorted[i];\n\t\t\tsorted[i] = sorted[tmp] - sorted[i];\n\t\t\tsorted[tmp] = sorted[tmp] - sorted[i];\n\t\t\ttmp++;\n\t\t}else if(listNode[sorted[tmp]].counter > listNode[sorted[i]].counter){\n\t\t\ttmp = i;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, k;\n\tscanf(\"%i%i%i\", &n, &m, &k);\n\t\n\tint a, b;\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%i%i\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tlistNode[a].adjList.push_back(b);\n\t\tlistNode[b].adjList.push_back(a);\n\t\tlistNode[a].counter++;\n\t\tlistNode[b].counter++;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tlistNode[i].used = false;\n\t\tsorted[i] = i;\n\t}\n\t\n\tsort(sorted, sorted+n, cmpCounter);\n\t\n\t//for (int i = 0; i < n; i++){\n\t\t//if(i){\n\t\t\t//printf(\" \");\n\t\t//}\n\t\t//printf(\"%i\", sorted[i]);\n\t//}\n\t//printf(\"\\n\");\n\t\n\tint counter = 0;\n\tint out;\n\tfor (int i = 0; i < n; i++){\n\t\tint size = listNode[sorted[i]].adjList.size();\n\t\tfor (int j = 0; j < size; j++){\n\t\t\tif(listNode[listNode[sorted[i]].adjList[j]].used){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tlistNode[listNode[sorted[i]].adjList[j]].counter--;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\tlistNode[sorted[i]].used = true;\n\t\tif(counter>=m){\n\t\t\tout = i+1;\n\t\t\tbreak;\n\t\t}\n\t\tupdate(i, n);\n\t}\n\t\n\tif(out > k){\n\t\tprintf(\"Impossible\");\n\t}else{\n\t\tprintf(\"%i\", out);\n\t}\n\tprintf(\"\\n\");\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt n,k,ans,cnt,tmp;\nvector<set<Int> > G;\nvoid dfs(Int x){\n  //cout<<x<<endl;\n  if(x==n)\n    ans=min(ans,tmp);\n  if(tmp>=ans) return;\n\n  if(G[x].empty()){\n    dfs(x+1);\n    return;\n  }\n  \n  if(tmp+1<ans&&G[x].size()>1u){\n    vector<Int> v;\n    for(Int u:G[x]){\n      v.emplace_back(u);\n      G[u].erase(x);\n    }\n    cnt++;\n    tmp++;\n    dfs(x+1);\n    cnt--;\n    tmp--;\n    for(Int u:v){\n      G[u].emplace(x);\n    }\n  }\n\n  if(tmp+(Int)G[x].size()<ans){\n    vector<Int> v;\n    vector<set<Int> > S;\n    for(Int u:G[x]){\n      v.emplace_back(u);\n      S.emplace_back(G[u]);\n      G[u].clear();\n      cnt++;\n      tmp++;\n    }\n    \n    cnt++;\n    dfs(x+1);\n    cnt--;\n    \n    for(Int i=0;i<(Int)v.size();i++){\n      G[v[i]]=S[i];\n      cnt--;\n      tmp--;\n    }\n  }\n  \n};\nsigned main(){\n  Int m,k;\n  cin>>n>>m>>k;\n  G.resize(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace(v);\n    G[v].emplace(u);\n  }\n  ans=n;\n  cnt=tmp=0;\n  dfs(0);\n  if(ans<=k) cout<<ans<<endl;\n  else cout<<\"Impossible\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nunsigned long long xor128() {\n    static unsigned long long rx = 123456789, ry = 362436069, rz = 521288629, rw = 88675123;\n    unsigned long long rt = (rx ^ (rx << 11));\n    rx = ry;\n    ry = rz;\n    rz = rw;\n    return (rw = (rw ^ (rw >> 19)) ^ (rt ^ (rt >> 8)));\n}\n\nstd::chrono::system_clock::time_point start;\nstd::chrono::system_clock::time_point owari;\n\nbool A[3003][3003];\nint T[3003];\nint n,m,k,MIN=1e9,cnt[3003];\n\nint main(){\n    start = std::chrono::system_clock::now();\n    cin>>n>>m>>k;\n    r(i,m){\n        int a,b;\n        cin>>a>>b; a--; b--;\n        A[a][b]=A[b][a]=1;\n        cnt[a]++;\n        cnt[b]++;\n    }\n    r(i,n)T[i]=cnt[i];\n    for(;;){\n        int TEMP=0;\n        for(;;){\n            int x,idx=-1,MAX=0;\n            r(i,n){\n                if(MAX<cnt[i]||(cnt[i]&&(xor128()%5==1))){\n                    MAX=cnt[i];\n                    x=i;\n                }\n                if(cnt[i]==1) idx=i;\n            }\n            if(!MAX)break;\n            TEMP++;\n            if(idx!=-1){\n                r(i,n)if(A[idx][i]&&cnt[i]){\n                    x=i;\n                    break;\n                }\n            }\n            r(i,n)if(A[x][i]&&cnt[i])cnt[i]--;\n            cnt[x]=0;\n        }\n        MIN=min(TEMP,MIN);\n        owari = std::chrono::system_clock::now();\n        double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(owari-start).count();\n        if(elapsed>2999)break;\n\n        r(i,n)cnt[i]=T[i];\n\n    }\n    if(MIN<=k)cout<<MIN<<endl;\n    else cout<<\"Impossible\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        // 最初の層で行われた前処理による変更は特に後処理する必要がない\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            for(int j = (int)edge_info[p.first].size() - 1; j >= 0; j--){\n                auto& dat = edge_info[p.first][j];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\ntypedef pair<int,int> P;\ntypedef long long ll;\nint flg[3005];\nmap< ll , int > used;\nconst ll mod=1e9+7;\nconst ll bs=1999;\nint dfs(const Graph &G,int K,int id=0){\n  if(id==(int)G.size())return 0;\n  \n  ll key=0;\n  for(int i=0;i<(int)G.size();i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      if( flg[i] == 0 && flg[ G[i][j] ]== 0){\n        key=(key*bs+5)%mod;\n      }else{\n        key=(key*bs+37)%mod;\n      }\n    }\n  }\n  key=key*bs +( 1+id );\n  if(used.count(key))return used[key];\n\n        \n  int res=1e9;\n  \n  if(K>0){\n    flg[id]=1;\n\n  \n    res=min(res, dfs(G,K-1,id+1)+1);\n    flg[id]=0;\n  }\n\n  int flag=0;\n  for(int i=0;i<(int)G[id].size();i++){\n    int to=G[id][i];\n    if(flg[to]==0 && to<id)flag=1;\n  }\n\n  if(!flag)res=min(res, dfs(G,K,id+1) );\n\n  return used[key]=res;\n}\n\nint dfs_start(Graph G,int K){\n  int n=G.size();\n  Graph nG(n);\n  vector<P> tmp;\n  for(int i=0;i<n;i++)\n    tmp.push_back( P(G[i].size(),i) );\n  sort(tmp.begin(),tmp.end());\n  reverse(tmp.begin(),tmp.end());\n\n  map<int,int> mp;\n  for(int i=0;i<n;i++)mp[ tmp[i].second ] = i;\n  \n  for(int i=0;i<n;i++)nG[i]=G[ mp[i] ];\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)nG[i].size();j++){\n      nG[i][j]=mp[ nG[i][j] ];\n    }\n  }\n  /*\n  cout<<nG.size()<<' '<<K<<endl;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)nG[i].size();j++){\n      cout<<i<<' '<<nG[i][j]<<endl;\n    }\n  }\n  */\n  for(int i=0;i<n;i++)flg[i]=0;\n  return dfs(nG,K);\n}\n\nGraph Update(Graph G,int id){\n  Graph ng;\n  for(int i=0;i<(int)G.size();i++){\n    if(i==id)continue;\n    Node n;\n    for(int j=0;j<(int)G[i].size();j++){\n      int to=G[i][j];\n      if(to==id)continue;\n      if(to>id)to--;\n      n.push_back(to);\n    }\n    ng.push_back(n);\n  }\n  return ng;\n}\n\nint solve(Graph G,int K){\n  if(G.empty())return 0;\n  if(K==0)return 1e9;\n  for(int i=0;i<(int)G.size();i++)\n    if((int)G[i].size()>K)\n      return solve( Update(G,i), K-1 )+1;\n  int flg=-1;\n  int n=G.size(), sum=0,total=0;\n  for(int i=0;i<n;i++){\n    total+=G[i].size();\n    if(G[i].size()==1)flg=i;\n  }\n  for(int i=0;i<min(n,K);i++)sum+=G[i].size();\n  if(sum>total)return -1;\n  if(flg!=-1){\n    int target=G[flg][0];\n    G=Update(G,target);\n    return solve(G,K-1)+1;\n  }\n  return dfs_start(G,K);\n}\n\nint main(){\n  Graph G;\n  int V,E,K;\n  cin>>V>>E>>K;\n  G.resize(V);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  int ans=solve(G,K);\n  if(ans==-1 || ans>K)cout<<\"Impossible\"<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\tint N, M, K;\n\nint getans(const vector<vector<int>>&edges,const int now, const int use,vector<int>&used) {\n\tif (now == edges.size()||edges[now].empty())return use;\n\tint ans = 33;\n\t\n\tif (used[now]) {\n\t\treturn getans(edges, now + 1, use, used);\n\t}\n\telse {\n\t\tif (use + 1 <= K) {\n\t\t\tused[now] = true;\n\t\t\tans = min(ans, getans(edges,now + 1, use + 1, used));\n\t\t\tused[now] = false;\n\t\t}\n\t\tint nextuse = use;\n\t\tvector<int>newused;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!used[e]) {\n\t\t\t\tused[e] = true;\n\t\t\t\tnewused.push_back(e);\n\t\t\t}\n\t\t}\n\t\tif (use + newused.size() <= K) {\n\t\t\tans = min(ans, getans(edges, now + 1, use + newused.size(), used));\n\t\t}\n\t\tfor (auto u : newused) {\n\t\t\tused[u] = false;\n\t\t}\n\t\t//while(edges[num].first==)\n\t}\n\treturn ans;\n}\nint main() {cin >> N >> M >> K;\n\tvector<pair<int,int>>edges;\n\tvector<pair<int, int>>ps(N);\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tps[i] = make_pair(0, i);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tedges.emplace_back(a, b);\n\t\tedges.emplace_back(b, a);\n\t\tps[a].first++;\n\t\tps[b].first++;\n\t}\n\t\n\tsort(ps.begin(), ps.end(),greater<pair<int,int>>());\n\tmap<int, int>mp;\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tif (ps[i].first == 0)break;\n\t\tmp[ps[i].second] = i;\n\t}\n\tvector<vector<int>>realedges(mp.size());\n\tfor (int i = 0; i < edges.size(); ++i) {\n\t\tint f = mp[edges[i].first];\n\t\tint t = mp[edges[i].second];\n\t\tif (f < t)realedges[f].push_back(t);\n\t}\n\tvector<int>used(N);\n\tint ans = getans(realedges, 0, 0, used);\n\tif (ans == 33) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\n\t\tcout << ans << endl;\n\t}\n\t//for()\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef vector<int> BS;\n\nBS absbs;\nBS is[3000];\nvector<int> idx;\nint a[32345],b[32345];\nint N,M,K;\n\nint rec(const BS &bs,int nth,int r){\n  if(r<0)return r;\n  if(bs.size()==M)return r;\n  while(includes(begin(bs),end(bs),begin(is[idx[nth]]),end(is[idx[nth]]))){\n    nth++;\n  }\n  BS n;\n  set_difference(begin(is[idx[nth]]),end(is[idx[nth]]),begin(bs),end(bs),back_inserter(n));\n  if(n.size()==1){\n    BS nx;\n    set_union(begin(bs),end(bs),begin(is[a[n[0]]^b[n[0]]^idx[nth]]),end(is[a[n[0]]^b[n[0]]^idx[nth]]),back_inserter(nx));\n    return rec(nx,nth+1,r-1);\n  }else{\n    BS n;\n    set_union(begin(bs),end(bs),begin(is[idx[nth]]),end(is[idx[nth]]),back_inserter(n));\n    int rv=rec(n,nth+1,r-1);\n    BS o=bs;\n    for(auto i:n){\n      BS dst;\n      set_union(begin(o),end(o),begin(is[a[i]^b[i]^idx[nth]]),end(is[a[i]^b[i]^idx[nth]]),back_inserter(dst));\n      o=move(dst);\n    }\n    return max(rv,rec(o,nth+1,r-n.size()));\n  }\n}\n\nint main(){\n  cin>>N>>M>>K;\n  int pop[32345]={};\n  for(int i=0;i<M;i++){\n    cin>>a[i]>>b[i];\n    a[i]--;\n    b[i]--;\n    pop[a[i]]++;\n    pop[b[i]]++;\n    is[a[i]].push_back(i);\n    is[b[i]].push_back(i);\n  }\n  idx.resize(N);\n  iota(begin(idx),end(idx),0);\n  sort(begin(idx),end(idx),[pop](int a,int b){\n      return pop[a]>pop[b];\n    });\n  int r=rec(BS(),0,K);\n  if(r<0){\n    cout<<\"Impossible\"<<endl;\n  }else{\n    cout<<K-r<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        // 最初の層で行われた前処理による変更は特に後処理する必要がない\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            for(int j = (int)edge_info[p.first].size() - 1; j >= 0; j--){\n                auto& dat = edge_info[p.first][j];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nunsigned long long xor128() {\n    static unsigned long long rx = 123456789, ry = 362436069, rz = 521288629, rw = 88675123;\n    unsigned long long rt = (rx ^ (rx << 11));\n    rx = ry;\n    ry = rz;\n    rz = rw;\n    return (rw = (rw ^ (rw >> 19)) ^ (rt ^ (rt >> 8)));\n}\n\nstd::chrono::system_clock::time_point start;\nstd::chrono::system_clock::time_point owari;\n\nbool A[3003][3003];\nint T[3003];\nint n,m,k,MIN=1e9,cnt[3003];\n\nint main(){\n    start = std::chrono::system_clock::now();\n    cin>>n>>m>>k;\n    r(i,m){\n        int a,b;\n        cin>>a>>b; a--; b--;\n        A[a][b]=A[b][a]=1;\n        cnt[a]++;\n        cnt[b]++;\n    }\n    r(i,n)T[i]=cnt[i];\n    for(;;){\n        int TEMP=0;\n        for(;;){\n            int x,idx=-1,MAX=0;\n            r(i,n){\n                if(MAX<cnt[i]||(cnt[i]&&(xor128()%20==1))){\n                    MAX=cnt[i];\n                    x=i;\n                }\n                if(cnt[i]==1) idx=i;\n            }\n            if(!MAX)break;\n            TEMP++;\n            if(idx!=-1){\n                r(i,n)if(A[idx][i]&&cnt[i]){\n                    x=i;\n                    break;\n                }\n            }\n            r(i,n)if(A[x][i]&&cnt[i])cnt[i]--;\n            cnt[x]=0;\n        }\n        MIN=min(TEMP,MIN);\n        owari = std::chrono::system_clock::now();\n        double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(owari-start).count();\n        if(elapsed>0.1)break;\n\n        r(i,n)cnt[i]=T[i];\n\n    }\n    if(MIN<=k)cout<<MIN<<endl;\n    else cout<<\"Impossible\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n,m,k;\n  cin>>n>>m>>k;\n  vector<vector<int> > G(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  vector<int> v(n);\n  for(int i=0;i<n;i++) v[i]=i;\n  sort(v.begin(),v.end(),\n       [&](int &a,int&b){return G[a].size()>G[b].size();});\n  //for(int u:v) cout<<u<<endl;\n  vector<int> used(n,0);\n  int ans=1000;\n  int sz=0,cnt=0;\n  function<void(int)> dfs=[&](int x){\n    //cout<<x<<\" \"<<cnt<<\" \"<<sz<<endl;\n    if(sz>=ans) return;\n    if(cnt==m){\n      ans=min(ans,sz);\n      return;\n    }\n    if(x==n) return;\n    if(used[v[x]]){\n      dfs(x+1);\n      return;\n    }\n    {\n      used[v[x]]=1;\n      sz++;\n      for(int u:G[v[x]]){\n\tif(!used[u]) cnt++;\n      }\n      dfs(x+1);\n      for(int u:G[v[x]]){\n\tif(!used[u]) cnt--;\n      }\n      used[v[x]]=0;\n      sz--;\n    }\n    if(0){\n      stack<int> st;\n      for(int u:G[v[x]]){\n\tif(!used[u]){\n\t  used[u]=1;\n\t  st.push(u);\n\t  sz++;\n\t  for(int r:G[u]){\n\t    if(!used[r]) cnt++;\n\t  }\n\t}\n      }\n      dfs(x+1);\n      while(!st.empty()){\n\tint u=st.top();st.pop();\n\tassert(used[u]);\n\tused[u]=0;\n\tsz--;\n\tfor(int r:G[u]){\n\t  if(!used[r]) cnt--;\n\t}\n      }\n    }\n    dfs(x+1);\n  };\n  dfs(0);\n  if(ans>k) cout<<\"Impossible\"<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素の iterator を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n    int index;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int& add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int& add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool reset(){\n        small_deg_ver.clear(), use_ver.clear();\n        return false;\n    }\n    bool erase_rec(int u, bool use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return reset();\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return reset();\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return reset();\n        }\n        return true;\n    }\n    bool preprocessing(int K, int& add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        transition(K, next_ver, true);\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に使う\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n\nprivate:\n    struct block {\n        int prev, next;\n        T value;\n        block(){}\n        block(T value_) : value(value_){}\n        block(int prev_, int next_) : prev(prev_), next(next_){}\n    };\n    int N, sz;\n    vector<block> container;\n    friend ListIterator<T>;\n\npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        auto& nw = container[now_index]; auto& nx = container[next_index];\n        nw.prev = nx.prev, nw.next = next_index;\n        container[nx.prev].next = now_index, nx.prev = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        auto& cur = container[index];\n        container[cur.prev].next = cur.next, container[cur.next].prev = cur.prev;\n        return iterator(this, cur.next);\n    }\n\npublic:\n    friend ostream& operator<< (ostream& os, List& ls){\n        for(auto& val : ls){\n            os << val << ' ';\n        }\n        return os;\n    }\n    const T& operator[](size_t index) const {\n        return container[index].value;\n    }\n    T& operator[](size_t index){\n        return container[index].value;\n    }\n    size_t size(){\n        return sz;\n    }\n    bool empty(){\n        return size() == 0;\n    }\n    T& front(){\n        return container[container[N].next].value;\n    }\n    T& back(){\n        return container[container[N].prev].value;\n    }\n    iterator begin(){\n        return iterator(this, container[N].next);\n    }\n    iterator end(){\n        return iterator(this, N);\n    }\n    iterator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n    iterator push_back(){\n        return insert(N, container[N].prev+1);\n    }\n    void pop_back(){\n        erase(container[N].prev);\n    }\n    void index_clear(){\n        N = sz = 0, container = {(block){0, 0}};\n    }\n    void clear(){\n        index_clear(); container.clear();\n    }\n\npublic:\n    List() : N(0), sz(0), container({(block){0, 0}}){}\n    List(int _N) : container(_N + 1){\n        build();\n    }\n    List(const List& ls):\n        N(ls.N), sz(ls.sz), container(ls.container){}\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n    iterator push_back(T val){\n        N++, sz++;\n        container[0].prev = container.back().next = N, container.back().value = val;\n        container.emplace_back(N-1, 0);\n        return iterator(this, N-1);\n    }\n\tvoid build(){\n        N = sz = (int)container.size() - 1;\n        for(int i = 0; i <= N; i++) container[i].prev = i-1, container[i].next = i+1;\n        container[0].prev = N, container[N].next = 0;\n    }\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n    friend List<T>;\n    List<T>* ls_ptr;\n    int index;\n\nprivate:\n    ListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\npublic:\n    ListIterator(){}\n    ListIterator(const ListIterator& itr){\n        ls_ptr = itr.ls_ptr, index = itr.index;\n    }\n    explicit operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    T& operator*() const {\n        return ls_ptr->container[index].value;\n    }\n    T* operator->() const {\n        return &ls_ptr->container[index].value;\n    }\n    ListIterator& operator++(){\n        index = ls_ptr->container[index].next;\n        return *this;\n    }\n    ListIterator operator++(int){\n        ListIterator res = *this;\n        index = ls_ptr->container[index].next;\n        return res;\n    }\n    ListIterator& operator--(){\n        index = ls_ptr->container[index].prev;\n        return *this;\n    };\n    ListIterator operator--(int){\n        ListIterator res = *this;\n        index = ls_ptr->container[index].prev;\n        return res;\n    };\n    bool operator==(const ListIterator& itr) const {\n        return !(*this != itr);\n    };\n    bool operator!=(const ListIterator& itr) const {\n        return this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n    }\n    friend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n        ListIterator<T> tmp = itr1;\n        itr1 = itr2, itr2 = itr1;\n    };\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) :\n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n\n    bool push_cand(int u, int& add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n\n    bool erase(int u, bool use, bool alr_use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, (int)G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int& add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool reset(){\n        small_deg_ver.clear(), use_ver.clear();\n        return false;\n    }\n    bool erase_rec(int u, bool use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return reset();\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return reset();\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return reset();\n        }\n        return true;\n    }\n    bool preprocessing(int K, int& add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        transition(K, next_ver, true);\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n\n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,K;\nvector<int> G[3001];\n\nint solve( vector<int>  used );\n\nint getsize(const vector<int>& mt,const vector<int>& nt){\n  int ret = 0;\n  for(int i=0;i<N;i++) ret += mt[i];\n  bool ok = true;\n  for(int i=0;i<N;i++)\n    if( nt[i] )\n      for(int j=0;j<(int)G[i].size();j++)\n        if( nt[G[i][j]] ) ok = false;\n  if( ok ) return ret;\n  return ret + solve(nt);\n}\n\nvoid dfs(int v,int t,vector<int>& g,vector<int>& k,const vector<int>& used){\n  if( t ) g[v] = 1;\n  else k[v] = 1;\n  for(int i=0;i<(int)G[v].size();i++){\n    int to = G[v][i];\n    if( !used[to] || g[to] || k[to] ) continue;\n    dfs( to, 1-t, g, k,used );\n  }\n}\n\nint solve(vector<int> used){\n  vector<int> g(N,0);\n  vector<int> k(N,0);\n  int res = 0;\n  for(int i=0;i<N;i++){\n    if( !used[i] || g[i] || k[i] ) continue;\n    dfs(i,0,g,k,used);\n    for(int i=0;i<N;i++)\n      if( g[i] | k[i] ) used[i] = 0;\n    res += min( getsize(g,k), getsize(k,g) );\n    g=vector<int>(N,0);\n    k=vector<int>(N,0);\n  }\n  return res;\n}\n\nint main(){\n  cin >> N >> M >> K;\n  for(int i=0;i<M;i++){\n    int a,b; cin >> a >> b; --a; --b;\n    G[a].push_back( b );\n    G[b].push_back( a );\n  }\n  vector<int> used(N,1);\n  for(int i=0;i<N;i++)\n    if( G[i].empty() ) used[i] = 0;\n  int res = solve(used);  \n  // cout << res << endl;\n  if( res > K ) cout << \"Impossible\" << endl;\n  else cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cincout\n#define min(a,b) ((a) < (b) ? (a) : (b))\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define abs(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\n\n\nint cov[3005];\nvector <int> adjlist[3005];\nint n,m,k,ans;\nint inp_a,inp_b;\nint get_deg(int u) {\n\tint ret=0;\n\tfor (int i=0;i<adjlist[u].size();++i) {\n\t\tif (!cov[adjlist[u][i]]) ++ret;\n\t}\n\treturn ret;\n}\n\nvoid rek(int tmp_ans) {\n\tif (tmp_ans > k) return;\n\tint deg_u;\n\tfor (int i=1;i<=n;++i) {\n\t\tif (cov[i] || (deg_u=get_deg(i))==0) continue;\n\t\telse if (deg_u==1) {\n\t\t\tint neigh;\n\t\t\tfor (int j=0;j<adjlist[i].size();++j) {\n\t\t\t\tif (!cov[adjlist[i][j]] && get_deg(adjlist[i][j]) > 0) {\n\t\t\t\t\tneigh=adjlist[i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcov[neigh]=true;\n\t\t\trek(tmp_ans+1);\n\t\t\tcov[neigh]=false;\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i) {\n\t\tif (cov[i] || (deg_u=get_deg(i))==0) continue;\n\t\telse {\n\t\t\tcov[i]=true;\n\t\t\trek(tmp_ans+1);\n\t\t\tcov[i]=false;\n\t\t\tvector <int> dat;\n\t\t\tint cnt=0;\n\t\t\tfor (int j=0;j<adjlist[i].size();++j) {\n\t\t\t\tif (!cov[adjlist[i][j]] && get_deg(adjlist[i][j]) > 0) {\n\t\t\t\t\tdat.push_back(adjlist[i][j]);\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j=0;j<cnt;++j) cov[dat[j]]=true;\n\t\t\trek(tmp_ans+cnt);\n\t\t\tfor (int j=0;j<cnt;++j) cov[dat[j]]=false;\n\t\t\treturn;\n\t\t}\n\t}\n\tans=min(ans,tmp_ans);\n}\n\n\nint main() {\n\t#ifdef cincout\n\t\tcin.sync_with_stdio(0);\n\t\tcin.tie(0);\n\t#endif\n\tmemset(cov,false,sizeof(cov));\n\tcin >> n >> m >> k;\n\tfor (int i=0;i<m;++i) {\n\t\tcin >> inp_a >> inp_b;\n\t\tadjlist[inp_a].push_back(inp_b);\n\t\tadjlist[inp_b].push_back(inp_a);\n\t}\n\tans=1000000;\n\trek(0);\n\tif (ans>k) cout << \"Impossible\\n\";\n\telse cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nunsigned long long xor128() {\n    static unsigned long long rx = 123456789, ry = 362436069, rz = 521288629, rw = 88675123;\n    unsigned long long rt = (rx ^ (rx << 11));\n    rx = ry;\n    ry = rz;\n    rz = rw;\n    return (rw = (rw ^ (rw >> 19)) ^ (rt ^ (rt >> 8)));\n}\n\nstd::chrono::system_clock::time_point start;\nstd::chrono::system_clock::time_point owari;\n\nbool A[3003][3003];\nint T[3003];\nint n,m,k,MIN=1e9,cnt[3003];\n\nint main(){\n    start = std::chrono::system_clock::now();\n    cin>>n>>m>>k;\n    r(i,m){\n        int a,b;\n        cin>>a>>b; a--; b--;\n        A[a][b]=A[b][a]=1;\n        cnt[a]++;\n        cnt[b]++;\n    }\n    r(i,n)T[i]=cnt[i];\n    for(;;){\n        int TEMP=0;\n        for(;;){\n            int x,idx=-1,MAX=0;\n            r(i,n){\n                if(MAX<cnt[i]||(cnt[i]&&(xor128()%1881==31))){\n                    MAX=cnt[i];\n                    x=i;\n                }\n                if(cnt[i]==1) idx=i;\n            }\n            if(!MAX)break;\n            TEMP++;\n            if(idx!=-1){\n                r(i,n)if(A[idx][i]&&cnt[i]){\n                    x=i;\n                    break;\n                }\n            }\n            r(i,n)if(A[x][i]&&cnt[i])cnt[i]--;\n            cnt[x]=0;\n        }\n        MIN=min(TEMP,MIN);\n        owari = std::chrono::system_clock::now();\n        double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(owari-start).count();\n        if(elapsed>0.1)break;\n\n        r(i,n)cnt[i]=T[i];\n\n    }\n    if(MIN<=k)cout<<MIN<<endl;\n    else cout<<\"Impossible\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\t// ListIterator<T> からのアクセスを許可する\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の添字を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    int index;\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u).index);\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev).index);\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to).index);\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int add_size, vector<pair<int, int> >& erase_ver){\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(add_size, erase_ver);\n        if(!check()) return postprocessing(add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        ans_size = K + 1;\n        judge(K);\n        return ans_size <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    // svec(mvc.ans_set);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,k,a,b,banyak[3005],hasil = 0,temp,pos;\nvector<int> pulau[3005];\n\nint main() {\n\tmemset(banyak, 0, sizeof banyak);\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpulau[a].push_back(b);\n\t\tpulau[b].push_back(a);\n\t\tbanyak[a]++;\n\t\tbanyak[b]++;\n\t}\n\twhile (true) {\n\t\ttemp = pos = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (banyak[i] > temp) {\n\t\t\t\ttemp = banyak[i];\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\t\tif (temp == 0)\n\t\t\tbreak;\n\t\thasil++;\n\t\tfor (int i = 0; i < pulau[pos].size(); i++)\n\t\t\tif (banyak[pulau[pos][i]] > 0)\n\t\t\t\tbanyak[pulau[pos][i]]--;\n\t\tbanyak[pos] = 0;\n\t}\n\tif (hasil <= k)\n\t\tprintf(\"%d\\n\", hasil);\n\telse\n\t\tprintf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\ntypedef pair<int,int> P;\n\nint flg[3005];\n\nint dfs(Graph &G,int K,int id=0){\n  if(id==(int)G.size())return 0;\n\n  int res=1e9;\n  \n  if(K>0){\n    flg[id]=1;\n    res=min(res, dfs(G,K-1,id+1)+1);\n    flg[id]=0;\n  }\n\n  int flag=0;\n  for(int i=0;i<(int)G[id].size();i++){\n    int to=G[id][i];\n    if(flg[to]==0 && to<id)flag=1;\n  }\n\n  if(flag)return res;\n  return min(res, dfs(G,K,id+1) );\n}\n\nint dfs_start(Graph G,int K){\n  int n=G.size();\n  Graph nG(n);\n  vector<P> tmp;\n  for(int i=0;i<n;i++)\n    tmp.push_back( P(G[i].size(),i) );\n  sort(tmp.begin(),tmp.end());\n  reverse(tmp.begin(),tmp.end());\n\n  map<int,int> mp;\n  for(int i=0;i<n;i++)mp[ tmp[i].second ] = i;\n  \n  for(int i=0;i<n;i++)nG[i]=G[ mp[i] ];\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)nG[i].size();j++){\n      nG[i][j]=mp[ nG[i][j] ];\n    }\n  }\n  /*\n  cout<<nG.size()<<' '<<K<<endl;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)nG[i].size();j++){\n      cout<<i<<' '<<nG[i][j]<<endl;\n    }\n  }\n  */\n  for(int i=0;i<n;i++)flg[i]=0;\n  return dfs(nG,K);\n}\n\nGraph Update(Graph G,int id){\n  Graph ng;\n  for(int i=0;i<(int)G.size();i++){\n    if(i==id)continue;\n    Node n;\n    for(int j=0;j<(int)G[i].size();j++){\n      int to=G[i][j];\n      if(to==id)continue;\n      if(to>id)to--;\n      n.push_back(to);\n    }\n    ng.push_back(n);\n  }\n  return ng;\n}\n\nint solve(Graph G,int K){\n  if(G.empty())return 0;\n  if(K==0)return 1e9;\n  for(int i=0;i<(int)G.size();i++)\n    if((int)G[i].size()>K)\n      return solve( Update(G,i), K-1 )+1;\n  int flg=-1;\n  int n=G.size(), sum=0,total=0;\n  for(int i=0;i<n;i++){\n    total+=G[i].size();\n    if(G[i].size()==1)flg=i;\n  }\n  for(int i=0;i<min(n,K);i++)sum+=G[i].size();\n  if(sum>total)return -1;\n  if(flg!=-1){\n    int target=G[flg][0];\n    G=Update(G,target);\n    return solve(G,K-1)+1;\n  }\n  return dfs_start(G,K);\n}\n\nint main(){\n  Graph G;\n  int V,E,K;\n  cin>>V>>E>>K;\n  G.resize(V);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  int ans=solve(G,K);\n  if(ans==-1 || ans>K)cout<<\"Impossible\"<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,k,a,b,banyak[3005],hasil = 0,temp,pos,satu;\nvector<int> pulau[3005];\n\nint main() {\n\tmemset(banyak, 0, sizeof banyak);\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpulau[a].push_back(b);\n\t\tpulau[b].push_back(a);\n\t\tbanyak[a]++;\n\t\tbanyak[b]++;\n\t}\n\twhile (true) {\n\t\ttemp = pos = satu = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (banyak[i] > temp) {\n\t\t\t\ttemp = banyak[i];\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t\tif (banyak[i] == 1)\n\t\t\t\tsatu = i;\n\t\t}\n\t\tif (temp == 0)\n\t\t\tbreak;\n\t\thasil++;\n\t\tif (satu != 0) {\n\t\t\tfor (int i = 0; i < pulau[satu].size(); i++)\n\t\t\t\tif (banyak[pulau[satu][i]] > 0) {\n\t\t\t\t\tpos = pulau[satu][i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < pulau[pos].size(); i++)\n\t\t\tif (banyak[pulau[pos][i]] > 0)\n\t\t\t\tbanyak[pulau[pos][i]]--;\n\t\tbanyak[pos] = 0;\n\t}\n\tif (hasil <= k)\n\t\tprintf(\"%d\\n\", hasil);\n\telse\n\t\tprintf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\t// ListIterator<T> からのアクセスを許可する\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の添字を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    int index;\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            add_size++, cand.push_back(u);\n            // ans より良い解が得られないと分かった\n            if((int)cand.size() >= ans_size) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u).index);\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev).index);\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to).index);\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                add_size++, cand.push_back(e.to);\n                // ans より良い解が得られないと分かった\n                if((int)cand.size() >= ans_size) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            while(!small_deg_ver.empty()){\n                int v = *small_deg_ver.begin();\n                small_deg_ver.erase(v);\n                if(deg[v] == 0) continue;\n                if(!erase(v, false, false, add_size, erase_ver)) return false;\n            }\n            while(!use_ver.empty()){\n                int v = *use_ver.begin();\n                use_ver.erase(v);\n                if(deg[v] == 0) continue;\n                if(!erase(v, true, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int add_size, vector<pair<int, int> >& erase_ver){\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(pl_add_size, pl_erase_ver);\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(add_size, erase_ver);\n        if(!check()) return postprocessing(add_size, erase_ver);\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()){\n            return postprocessing(add_size, erase_ver);\n        }\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        ans_size = K + 1;\n        judge(K);\n        return ans_size <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    // svec(mvc.ans_set);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nint N,M,K;\nvector<int> G[3000];\nvector<P> es;\nint d[3000],use[30000]; \nint dfs(int x,int k){\n\tfor(int i=x;i<M;i++){\n\t\tint a=es[i].fs,b=es[i].sc;\n\t\tif(use[a]!=1&&use[b]!=1){\n\t\t\tif(k==0) return -1;\n\t\t\tif(d[a]<d[b]) swap(a,b);\n\t\t\tint best=-1;\n\t\t\t//use a\n\t\t\tif(use[a]<0){\n\t\t\t\tuse[a]=1;\n\t\t\t\tvector<int> vc;\n\t\t\t\tfor(int v:G[a]){\n\t\t\t\t\tif(use[v]<0){\n\t\t\t\t\t\tvc.pb(v);\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(best,dfs(x+1,k-1));\n\t\t\t\tfor(int v:vc) d[v]++;\n\t\t\t\tuse[a]=-1;\n\t\t\t}\n\t\t\t//use b\n\t\t\tif(use[b]<0&&d[b]>1){\n\t\t\t\tuse[b]=1;\n\t\t\t\tvector<int> vc;\n\t\t\t\tfor(int v:G[b]){\n\t\t\t\t\tif(use[v]<0){\n\t\t\t\t\t\tvc.pb(v);\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(best,dfs(x+1,k-1));\n\t\t\t\tfor(int v:vc) d[v]++;\n\t\t\t\tuse[b]=-1;\n\t\t\t}\n\t\t\treturn best;\n\t\t}\n\t}\n\treturn k;\n}\nint main(){\n\tcin>>N>>M>>K;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\td[a]++,d[b]++;\n\t\tes.pb(P(a,b));\n\t}\n\trep(i,N) use[i]=-1;\n\trep(i,N) if(d[i]==0) use[i]=0;\n\tint k=K;\n\twhile(true){\n\t\tint v=-1;\n\t\trep(i,N) if(d[i]>k){\n\t\t\tv=i;break;\n\t\t}\n\t\tif(v<0) break;\n\t\tuse[v]=1;\n\t\tfor(int u:G[v]){\n\t\t\tif(d[u]) d[u]--;\n\t\t}\n\t\td[v]=0;\n\t\tk--;\n\t\tif(k<0){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint Mc=M;\n\tM=0;\n\trep(i,Mc) if(use[es[i].fs]!=1&&use[es[i].sc]!=1) es[M++]=es[i];\n\tif(M>k*k){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\trep(v,N){\n\t\tint j=0;\n\t\trep(i,G[v].size()){\n\t\t\tint u=G[v][i];\n\t\t\tif(use[v]!=1&&use[u]!=1) G[v][j++]=u;\n\t\t}\n\t\tG[v].resize(j);\n\t}\n\tint ans=dfs(0,k);\n//\tshow(K);\n//\tshow(k);\n//\tshow(ans);\n\tcout<<K-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に使う\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n\nprivate:\n    struct block {\n        int prev, next;\n        T value;\n        block(){}\n        block(T value_) : value(value_){}\n        block(int prev_, int next_) : prev(prev_), next(next_){}\n    };\n    int N, sz;\n    vector<block> container;\n    friend ListIterator<T>;\n\npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        auto& nw = container[now_index]; auto& nx = container[next_index];\n        nw.prev = nx.prev, nw.next = next_index;\n        container[nx.prev].next = now_index, nx.prev = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の iterator を返す\n    iterator erase(int index){\n        sz--;\n        auto& cur = container[index];\n        container[cur.prev].next = cur.next, container[cur.next].prev = cur.prev;\n        return iterator(this, cur.next);\n    }\n\npublic:\n    friend ostream& operator<< (ostream& os, List& ls){\n        for(auto& val : ls){\n            os << val << ' ';\n        }\n        return os;\n    }\n    const T& operator[](size_t index) const {\n        return container[index].value;\n    }\n    T& operator[](size_t index){\n        return container[index].value;\n    }\n    size_t size(){\n        return sz;\n    }\n    bool empty(){\n        return size() == 0;\n    }\n    T& front(){\n        return container[container[N].next].value;\n    }\n    T& back(){\n        return container[container[N].prev].value;\n    }\n    iterator begin(){\n        return iterator(this, container[N].next);\n    }\n    iterator end(){\n        return iterator(this, N);\n    }\n    iterator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n    iterator push_back(){\n        return insert(N, container[N].prev+1);\n    }\n    void pop_back(){\n        erase(container[N].prev);\n    }\n    void index_clear(){\n        N = sz = 0, container = {(block){0, 0}};\n    }\n    void clear(){\n        index_clear(); container.clear();\n    }\n\npublic:\n    List() : N(0), sz(0), container({(block){0, 0}}){}\n    List(int _N) : container(_N + 1){\n        build();\n    }\n    List(const List& ls):\n        N(ls.N), sz(ls.sz), container(ls.container){}\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n    iterator push_back(T val){\n        N++, sz++;\n        container[0].prev = container.back().next = N, container.back().value = val;\n        container.emplace_back(N-1, 0);\n        return iterator(this, N-1);\n    }\n\tvoid build(){\n        N = sz = (int)container.size() - 1;\n        for(int i = 0; i <= N; i++) container[i].prev = i-1, container[i].next = i+1;\n        container[0].prev = N, container[N].next = 0;\n    }\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n    friend List<T>;\n    List<T>* ls_ptr;\n    int index;\n\nprivate:\n    ListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\npublic:\n    ListIterator(){}\n    ListIterator(const ListIterator& itr){\n        ls_ptr = itr.ls_ptr, index = itr.index;\n    }\n    explicit operator int() const noexcept { return index; }\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    T& operator*() const {\n        return ls_ptr->container[index].value;\n    }\n    T* operator->() const {\n        return &ls_ptr->container[index].value;\n    }\n    ListIterator& operator++(){\n        index = ls_ptr->container[index].next;\n        return *this;\n    }\n    ListIterator operator++(int){\n        ListIterator res = *this;\n        index = ls_ptr->container[index].next;\n        return res;\n    }\n    ListIterator& operator--(){\n        index = ls_ptr->container[index].prev;\n        return *this;\n    };\n    ListIterator operator--(int){\n        ListIterator res = *this;\n        index = ls_ptr->container[index].prev;\n        return res;\n    };\n    bool operator==(const ListIterator& itr) const {\n        return !(*this != itr);\n    };\n    bool operator!=(const ListIterator& itr) const {\n        return this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n    }\n    friend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n        ListIterator<T> tmp = itr1;\n        itr1 = itr2, itr2 = itr1;\n    };\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) :\n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n\n    bool push_cand(int u, int& add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n\n    bool erase(int u, bool use, bool alr_use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, (int)G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int& add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool reset(){\n        small_deg_ver.clear(), use_ver.clear();\n        return false;\n    }\n    bool erase_rec(int u, bool use, int& add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return reset();\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return reset();\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return reset();\n        }\n        return true;\n    }\n    bool preprocessing(int K, int& add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        transition(K, next_ver, true);\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n\n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n,m,k;\n  cin>>n>>m>>k;\n  vector<vector<int> > G(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  vector<int> v(n);\n  for(int i=0;i<n;i++) v[i]=i;\n  sort(v.begin(),v.end(),\n       [&](int &a,int&b){return G[a].size()>G[b].size();});\n  //for(int u:v) cout<<u<<endl;\n  vector<int> used(n,0);\n  int ans=1000;\n  int sz=0,cnt=0;\n  function<void(int)> dfs=[&](int x){\n    //cout<<x<<\" \"<<cnt<<\" \"<<sz<<endl;\n    if(sz>=ans) return;\n    if(cnt==m){\n      ans=min(ans,sz);\n      return;\n    }\n    if(x==n) return;\n    if(used[v[x]]){\n      dfs(x+1);\n      return;\n    }\n    {\n      used[v[x]]=1;\n      sz++;\n      int beet=0;\n      for(int u:G[v[x]]){\n\tif(!used[u]) cnt++,beet++;\n      }\n      if(beet) dfs(x+1);\n      for(int u:G[v[x]]){\n\tif(!used[u]) cnt--;\n      }\n      used[v[x]]=0;\n      sz--;\n    }\n    if(0){\n      stack<int> st;\n      for(int u:G[v[x]]){\n\tif(!used[u]){\n\t  used[u]=1;\n\t  st.push(u);\n\t  sz++;\n\t  for(int r:G[u]){\n\t    if(!used[r]) cnt++;\n\t  }\n\t}\n      }\n      dfs(x+1);\n      while(!st.empty()){\n\tint u=st.top();st.pop();\n\tassert(used[u]);\n\tused[u]=0;\n\tsz--;\n\tfor(int r:G[u]){\n\t  if(!used[r]) cnt--;\n\t}\n      }\n    }\n    dfs(x+1);\n  };\n  dfs(0);\n  if(ans>k) cout<<\"Impossible\"<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\n// 常に不変なイテレーターが欲しい場合に別のコンテナにこれをかぶせる形で使うとよい\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n    \nprivate:\n\tint N, sz;\n\tvector<int> prev, next;\n\tvector<T> container;\n\t// ListIterator<T> からのアクセスを許可する\n\tfriend ListIterator<T>;\n    \npublic:\n    // 添字 next_index の要素の前に添字 now_index の要素を挿入\n    iterator insert(int next_index, int now_index){\n        sz++;\n        prev[now_index] = prev[next_index], next[now_index] = next_index;\n        next[prev[next_index]] = now_index, prev[next_index] = now_index;\n        return iterator(this, now_index);\n    }\n    // 添字 index の値を削除 → 次の要素の添字を返す\n    iterator erase(int index){\n        sz--;\n        next[prev[index]] = next[index], prev[next[index]] = prev[index];\n        return iterator(this, next[index]);\n    }\n\t\npublic:\n\tfriend ostream& operator<< (ostream& os, List& ls){\n\t\tfor(auto& val : ls){\n\t\t\tos << val << ' ';\n\t\t}\n        return os;\n    }\n\tconst T& operator[](size_t index) const {\n\t\treturn container[index];\n\t}\n\tT& operator[](size_t index){\n\t\treturn container[index];\n\t}\n\tsize_t size(){\n\t\treturn sz;\n\t}\n\tbool empty(){\n\t\treturn size() == 0;\n\t}\n    T& front(){\n        return container[next[N]];\n    }\n    T& back(){\n        return container[prev[N]];\n    }\n\titerator begin(){\n\t\treturn iterator(this, next[N]);\n\t}\n\titerator end(){\n\t\treturn iterator(this, N);\n\t}\n\titerator insert(const iterator& itr, int index){\n        return insert(itr.index, index);\n    }\n    iterator erase(const iterator& itr){\n        return erase(itr.index);\n    }\n\titerator push_back(){\n\t\treturn insert(N, prev[N]+1);\n\t}\n\tvoid pop_back(){\n\t\terase(prev[N]);\n\t}\n\tvoid clear(){\n        N = sz = 0;\n\t\tprev = next = {0};\n        container.clear();\n\t}\n\t\npublic:\n\tList() : N(0), sz(0), prev({0}), next({0}){}\n\tList(int _N) : container(_N){\n\t\tbuild();\n\t}\n\tList(int _N, T val) : container(_N, val){\n\t\tbuild();\n\t}\n\tList(const List& ls):\n\t\tN(ls.N), sz(ls.sz), prev(ls.prev), next(ls.next), container(ls.container){}\n    List(const vector<T>& vec) : container(vec){\n        build();\n    }\n    List& operator=(const List& ls){\n        container = ls.container;\n        build();\n        return *this;\n    }\n    List& operator=(const vector<T>& vec){\n        container = vec;\n        build();\n        return *this;\n    }\n    List& operator=(const List&& ls) noexcept {\n        container = ls.container;\n        build();\n        return *this;\n    }\n\tList(initializer_list<T> vals) : container(vals.begin(), vals.end()){\n\t\tbuild();\n\t}\n\titerator push_back(T val){\n        N++, sz++;\n        prev.push_back(N-1), prev[0] = N;\n        next.back() = N, next.push_back(0);\n\t\tcontainer.push_back(val);\n        return iterator(this, N-1);\n\t}\n\tvoid build(){\n\t\tN = sz = (int)container.size();\n\t\tprev.resize(N+1), next.resize(N+1);\n\t\tiota(prev.begin(), prev.end(), -1), iota(next.begin(), next.end(), 1);\n        prev[0] = N, next[N] = 0;\n\t}\n};\n\ntemplate<typename T>\nclass ListIterator : public std::iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T&>{\nprivate:\n\tfriend List<T>;\n\tList<T>* ls_ptr;\n\nprivate:\n\tListIterator(List<T>* ls, int _index) : ls_ptr(ls), index(_index){}\n\t\npublic:\n    int index;\n    ListIterator(){}\n\tListIterator(const ListIterator& itr){\n\t\tls_ptr = itr.ls_ptr, index = itr.index;\n\t}\n    ListIterator& operator=(const ListIterator& itr) & {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n    ListIterator& operator=(ListIterator&& itr) & noexcept {\n        ls_ptr = itr.ls_ptr, index = itr.index;\n        return *this;\n    }\n\tT& operator*() const {\n\t\treturn ls_ptr->container[index];\n\t}\n\tT* operator->() const {\n\t\treturn &ls_ptr->container[index];\n\t}\n\tListIterator& operator++(){\n\t\tindex = ls_ptr->next[index];\n\t\treturn *this;\n\t}\n\tListIterator operator++(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->next[index];\n\t\treturn res;\n\t}\n\tListIterator& operator--(){\n\t\tindex = ls_ptr->prev[index];\n\t\treturn *this;\n\t};\n\tListIterator operator--(int){\n\t\tListIterator res = *this;\n\t\tindex = ls_ptr->prev[index];\n\t\treturn res;\n\t};\n\tbool operator==(const ListIterator& itr) const {\n\t\treturn !(*this != itr);\n\t};\n\tbool operator!=(const ListIterator& itr) const {\n\t\treturn this->ls_ptr != itr.ls_ptr || this->index != itr.index;\n\t}\n\tfriend void swap(const ListIterator<T>& itr1, const ListIterator<T>& itr2){\n\t\tListIterator<T> tmp = itr1;\n\t\titr1 = itr2, itr2 = itr1;\n\t};\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to, next;\n        info(int ag1, int ag2, int ag3) : \n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n    \n    bool push_cand(int u, int add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n    \n    bool erase(int u, bool use, bool alr_use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u).index);\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev).index);\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to).index);\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int add_size, vector<pair<int, int> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool erase_rec(int u, bool use, int add_size, vector<pair<int, int> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return false;\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return false;\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool preprocessing(int K, int add_size, vector<pair<int, int> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int add_size, vector<pair<int, int> >& erase_ver){\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(auto& p : erase_ver){\n            for(int i = (int)edge_info[p.first].size() - 1; i >= 0; i--){\n                auto& dat = edge_info[p.first][i];\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, int> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        // 次数の高い頂点から探索する\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, int> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(add_size, erase_ver);\n        if(!check()) return postprocessing(add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(add_size, erase_ver);\n        // 使う場合\n        transition(K, next_ver, true);\n        // 使わない場合\n        if((int)cand.size() + (int)G[next_ver].size() >= ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n    \n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n            for(int i = 0; i < V; i++) rem_ver[i] = i;\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        ans_size = K + 1;\n        judge(K);\n        return ans_size <= K;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    // svec(mvc.ans_set);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\tint N, M, K;\n\nint getans(const vector<vector<int>>&edges,const int now, const int use,vector<int>&used) {\n\tif (now == edges.size() || edges[now].empty())return use;\n\tint ans = 33;\n\t\n\tif (used[now]) {\n\t\treturn getans(edges, now + 1, use, used);\n\t}\n\telse {\n\t\tif (use + 1 <= K) {\n\t\t\tused[now] = true;\n\t\t\tans = min(ans, getans(edges,now + 1, use + 1, used));\n\t\t\tused[now] = false;\n\t\t}\n\t\tint nextuse = use;\n\t\tvector<int>newused;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!used[e]) {\n\t\t\t\tused[e] = true;\n\t\t\t\tnewused.push_back(e);\n\t\t\t}\n\t\t}\n\t\tif (use + newused.size() <= K) {\n\t\t\tans = min(ans, getans(edges, now + 1, use + newused.size(), used));\n\t\t}\n\t\tfor (auto u : newused) {\n\t\t\tused[u] = false;\n\t\t}\n\t\t//while(edges[num].first==)\n\t}\n\treturn ans;\n}\nint main() {cin >> N >> M >> K;\n\tvector<pair<int, int>>ps(N);\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tps[i] = make_pair(0, i);\n\t}\n\tvector<vector<int>>aedges(N);\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\taedges[a].push_back(b);\n\t\taedges[b].push_back(a);\n\t\tps[a].first++;\n\t\tps[b].first++;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t}\n\tfor (auto &p : ps) {\n\t\tif (p.first == 0)p.first = -1e8;\n\t}\n\t\n\tmap<int, int>mp;\n\tfor (int i = 0; i <aset.size(); ++i) {\n\t\tauto it = max_element(ps.begin(), ps.end(), [](const auto &l, const auto&r) {\n\t\t\treturn l.first < r.first;\n\t\t});\n\t\tfor (auto e : aedges[it->second]) {\n\t\t\tps[e].first--;\n\t\t}\n\t\tit->first = -1;\n\t\tmp[it->second] = i;\n\t}\n\tvector<vector<int>>realedges(mp.size());\n\tfor (int i = 0; i < aedges.size(); ++i) {\n\t\tfor (auto e : aedges[i]) {\n\t\t\tif (mp[i] < mp[e]) {\n\t\t\t\trealedges[mp[i]].push_back(mp[e]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>used(mp.size());\n\tint ans = getans(realedges, 0, 0, used);\n\tif (ans == 33) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\n\t\tcout << ans << endl;\n\t}\n\t//for()\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt n,k,ans,cnt,tmp;\nvector<set<Int> > G;\nvoid dfs(Int x){\n  //cout<<x<<endl;\n  if(x==n)\n    ans=min(ans,tmp);\n  if(tmp>=ans) return;\n\n  if(G[x].empty()){\n    dfs(x+1);\n    return;\n  }\n  \n  if(tmp+1<ans&&G[x].size()>1u){\n    vector<Int> v;\n    for(Int u:G[x]){\n      v.emplace_back(u);\n      G[u].erase(x);\n    }\n    cnt++;\n    tmp++;\n    dfs(x+1);\n    cnt--;\n    tmp--;\n    for(Int u:v){\n      G[u].emplace(x);\n    }\n  }\n\n  if(tmp+(Int)G[x].size()<ans){\n    vector<Int> v;\n    vector<set<Int> > S;\n    for(Int u:G[x]){\n      v.emplace_back(u);\n      S.emplace_back(G[u]);\n      G[u].clear();\n      cnt++;\n      tmp++;\n    }\n    \n    cnt++;\n    dfs(x+1);\n    cnt--;\n    \n    for(Int i=0;i<(Int)v.size();i++){\n      G[v[i]]=S[i];\n      cnt--;\n      tmp--;\n    }\n  }\n  \n};\nsigned main(){\n  Int m,k;\n  cin>>n>>m>>k;\n  G.resize(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace(v);\n    G[v].emplace(u);\n  }\n  ans=k+1;\n  cnt=tmp=0;\n  dfs(0);\n  if(ans<=k) cout<<ans<<endl;\n  else cout<<\"Impossible\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cincout\n#define min(a,b) ((a) < (b) ? (a) : (b))\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define abs(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef pair <int, int> pii;\nint n,m,k,ans,tmppos,fixuse,sz;\nbool cov[3005],found;\nint a,b,tmp,edgs;\nint deg[3005];\npair<int, int> edg[30005];\nvector <int> adjlist[3005];\nvector <pii> edglist;\npriority_queue <pii, vector <pii>, greater <pii> > pq;\n\nint get_deg(int u) {\n\tint ret=0;\n\tfor (int i=0;i<adjlist[u].size();++i)\n\t\tif (!cov[adjlist[u][i]]) ++ret;\n\treturn ret;\n}\n\nvoid rek(int tmp_ans) {\n\tif (tmp_ans > k) return;\n\tif (found && tmp_ans > ans) return;\n\tbool ok=true;\n\tint deg_u,tmp_deg=1000000,target;\n\tfor (int i=1;i<=n;++i) {\n\t\tif (cov[i] || ((deg_u = get_deg(i)) == 0)) continue;\n\t\telse {\n\t\t\tok=false;\n\t\t\tcov[i]=true;\n\t\t\trek(tmp_ans+1);\n\t\t\tcov[i]=false;\n\t\t}\n\t}\n\tif (ok) {\n\t\tfound=true;\n\t\tans=min(ans,tmp_ans);\n\t\treturn;\n\t}\n}\n\nint main() {\n\t#ifdef cincout\n\t\tcin.sync_with_stdio(0);\n\t\tcin.tie(0);\n\t#endif\n\tcin >> n >> m >> k;\n\tfixuse=0;\n\tfound=false;\n\tans=1000000;\n\tedgs=m;\n\tfor (int i=0;i<m;++i) {\n\t\tcin >> a >> b;\n\t\tedglist.push_back(make_pair(a,b));\n\t\tedglist.push_back(make_pair(b,a));\n\t\tadjlist[a].push_back(b);\n\t\tadjlist[b].push_back(a);\n\t\t++deg[a]; ++deg[b];\n\t}\n\tsz=edglist.size();\n\t//cout << \"Sz \" << sz << '\\n';\n\tfor (int i=1;i<=n;++i) pq.push(make_pair(deg[i],i));\n\twhile (!pq.empty()) {\n\t\ttmp=pq.top().second; pq.pop();\n\t\tif (cov[tmp]) continue;\n\t\telse {\n\t\t\tif (deg[tmp]>k) {\n\t\t\t\tcov[tmp]=true;\n\t\t\t\tdeg[tmp]=0;\n\t\t\t\t++fixuse;\n\t\t\t\t--k;\n\t\t\t\tfor (int i=0;i<adjlist[tmp].size();++i) {\n\t\t\t\t\tif (!cov[adjlist[tmp][i]]) {\n\t\t\t\t\t\tpq.push(make_pair(--deg[adjlist[tmp][i]],adjlist[tmp][i]));\n\t\t\t\t\t\t--edgs;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (deg[tmp]==1) {\n\t\t\t\t++fixuse;\n\t\t\t\tcov[tmp]=true;\n\t\t\t\t--k;\n\t\t\t\tfor (int i=0;i<adjlist[tmp].size();++i) {\n\t\t\t\t\tif (!cov[adjlist[tmp][i]]) {\n\t\t\t\t\t\tcov[adjlist[tmp][i]]=true;\n\t\t\t\t\t\tint tk=adjlist[tmp][i];\n\t\t\t\t\t\tdeg[tmp]=0;\n\t\t\t\t\t\tfor (int j=0;j<adjlist[tk].size();++j) if (!cov[adjlist[tk][j]]) {\n\t\t\t\t\t\t\tpq.push(make_pair(--deg[adjlist[tk][j]],adjlist[tk][j]));\n\t\t\t\t\t\t\t--edgs;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"ok\\n\";\n\trek(0);\n\t//cout << \"FIX \" << fixuse << '\\n';\n\tif (!found) cout << \"Impossible\\n\";\n\telse cout << ans+fixuse << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\tint N, M, K;\n\nint getans(const vector<vector<int>>&edges,const int now, const int use,vector<int>&used) {\n\tif (now == edges.size())return use;\n\tint ans = 33;\n\t\n\tif (used[now]|| edges[now].empty()) {\n\t\treturn getans(edges, now + 1, use, used);\n\t}\n\telse {\n\t\tif (use + 1 <= K) {\n\t\t\tused[now] = true;\n\t\t\tans = min(ans, getans(edges,now + 1, use + 1, used));\n\t\t\tused[now] = false;\n\t\t}\n\t\tint nextuse = use;\n\t\tvector<int>newused;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!used[e]) {\n\t\t\t\tused[e] = true;\n\t\t\t\tnewused.push_back(e);\n\t\t\t}\n\t\t}\n\t\tif (use + newused.size() <= K) {\n\t\t\tans = min(ans, getans(edges, now + 1, use + newused.size(), used));\n\t\t}\n\t\tfor (auto u : newused) {\n\t\t\tused[u] = false;\n\t\t}\n\t\t//while(edges[num].first==)\n\t}\n\treturn ans;\n}\nint main() {cin >> N >> M >> K;\n\tvector<pair<int,int>>edges;\n\tvector<pair<int, int>>ps(N);\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tps[i] = make_pair(0, i);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tedges.emplace_back(a, b);\n\t\tedges.emplace_back(b, a); \n\t\tps[a].first++;\n\t\tps[b].first++;\n\t}\n\t\n\tsort(ps.begin(), ps.end(),greater<pair<int,int>>());\n\tmap<int, int>mp;\n\tfor (int i = 0; i < ps.size(); ++i) {\n\t\tif (ps[i].first == 0)break;\n\t\tmp[ps[i].second] = i;\n\t}\n\tvector<vector<int>>realedges(mp.size());\n\tfor (int i = 0; i < edges.size(); ++i) {\n\t\tint f = mp[edges[i].first];\n\t\tint t = mp[edges[i].second];\n\t\tif (f < t)realedges[f].push_back(t);\n\t}\n\tvector<int>used(mp.size());\n\tint ans = getans(realedges, 0, 0, used);\n\tif (ans == 33) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\n\t\tcout << ans << endl;\n\t}\n\t//for()\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class ListIterator;\n\ntemplate<typename T>\nclass List {\npublic:\n    using iterator = ListIterator<T>;\n\nprivate:\n    struct block {\n        block *prev, *next;\n        T data;\n        block() : prev(this), next(this){}\n        block(T _data) : prev(this), next(this), data(_data){}\n        block(block *_prev, block *_next) : prev(_prev), next(_next){}\n    };\n    int N;\n    size_t sz;\n    vector<block> container;\n    friend ListIterator<T>;\n    // cur を nx の前に挿入\n    iterator insert(block* const nx, block* const cur){\n        ++sz;\n        cur->prev = nx->prev, cur->next = nx;\n        nx->prev->next = cur, nx->prev = cur;\n        return iterator(cur);\n    }\n    // cur を削除\n    iterator erase(block* const cur){\n        --sz;\n        cur->prev->next = cur->next, cur->next->prev = cur->prev;\n        return iterator(cur->next);\n    }\n\npublic:\n    iterator insert(const iterator nx, const iterator cur){ return insert(nx.ls_ptr, cur.ls_ptr); }\n    iterator insert(const iterator nx, int cur_index){ return insert(nx.ls_ptr, &container[cur_index]); }\n    iterator insert(int next_index, int cur_index){ return iterator(&container[next_index], &container[cur_index]); }\n    iterator erase(const iterator cur){ return erase(cur.ls_ptr); }\n    iterator erase(int cur_index){ return erase(&container[cur_index]); }\n\npublic:\n    List() : N(0), sz(0){}\n    List(int _N) : N(_N), sz(N), container(_N+1){}\n    List(const vector<T>& _data) : List((int)_data.size()){ build(_data); }\n    List(const List& ls) : N(ls.N), sz(ls.sz), container(ls.container){}\n    void build(const vector<T>& _data){\n        for(int i = 0; i <= N; i++){\n            container[i].prev = &container[(i+N)%(N+1)];\n            container[i].next = &container[(i+1)%(N+1)];\n            if(i < N) container[i].data = _data[i];\n        }\n    }\n    void push_back(const T _data){ ++N, ++sz, container.push_back(_data); }\n    void build(){\n        container.push_back(T());\n        for(int i = 0; i <= N; i++){\n            container[i].prev = &container[(i+N)%(N+1)];\n            container[i].next = &container[(i+1)%(N+1)];\n        }\n    }\n    friend ostream& operator<< (ostream& os, List& ls){\n        for(auto& val : ls) os << val << ' ';\n        return os;\n    }\n    const T& operator[](size_t index) const { return container[index].data; }\n    T& operator[](size_t index){ return container[index].data; }\n    size_t size() const { return sz; }\n    bool empty() const { return (size() == 0); }\n    T& front(){ return container[N].next->data; }\n    T& back(){ return container[N].prev->data; }\n    iterator begin(){ return iterator(container[N].next); }\n    iterator end(){ return iterator(&container[N]); }\n};\n\ntemplate<typename T>\nclass ListIterator {\nprivate:\n    friend List<T>;\n    typename List<T>::block *ls_ptr;\n    using iterator_category = std::bidirectional_iterator_tag;\n    using value_type = T;\n    using difference_type = T;\n    using pointer = T*;\n    using reference = T&;\n\nprivate:\n    ListIterator(typename List<T>::block *ls) : ls_ptr(ls){}\n\npublic:\n    ListIterator(){}\n    ListIterator(const ListIterator& itr) : ls_ptr(itr.ls_ptr){}\n    ListIterator& operator=(const ListIterator& itr) & { return ls_ptr = itr.ls_ptr, *this; }\n    ListIterator& operator=(ListIterator&& itr) & { return ls_ptr = itr.ls_ptr, *this; }\n    reference operator*() const { return ls_ptr->data; }\n    pointer operator->() const { return &(ls_ptr->data); }\n    ListIterator& operator++(){ return ls_ptr = ls_ptr->next, *this; }\n    ListIterator operator++(int){\n        ListIterator res = *this;\n        return res.ls_ptr = ls_ptr->next, res;\n    }\n    ListIterator& operator--(){ return ls_ptr = ls_ptr->prev, *this; }\n    ListIterator operator--(int){\n        ListIterator res = *this;\n        return res.ls_ptr = ls_ptr->prev, res;\n    };\n    bool operator==(const ListIterator& itr) const { return !(*this != itr); };\n    bool operator!=(const ListIterator& itr) const { return ls_ptr != itr.ls_ptr; }\n};\n\n// 多重辺はなし\nclass MVC {\nprivate:\n    struct edge {\n        int to, rev;\n    };\n    struct info {\n        // from から to 番目に出ている辺が(を) next の前から消えた(に入れる)\n        int from, to;\n        List<edge>::iterator next;\n        info(int ag1, int ag2, List<edge>::iterator ag3) :\n            from(ag1), to(ag2), next(ag3){}\n    };\n    int V, rem_edge_size, fp_size;\n    vector<List<edge> > G;\n    List<int> rem_ver;\n    vector<int> cand, deg;\n    vector<vector<info> > edge_info;\n    set<int> small_deg_ver, use_ver;\n\n    bool push_cand(int u, int& add_size){\n        add_size++, cand.push_back(u);\n        return (int)cand.size() < ans_size;\n    }\n\n    bool erase(int u, bool use, bool alr_use, int& add_size, vector<pair<int, List<int>::iterator> >& erase_ver){\n        if(use && !alr_use){\n            if(!push_cand(u, add_size)) return false;\n        }\n        erase_ver.emplace_back(u, rem_ver.erase(u));\n        for(auto& e : G[u]){\n            edge_info[u].emplace_back(e.to, e.rev, G[e.to].erase(e.rev));\n            deg[e.to]--, rem_edge_size--;\n            if(deg[e.to] == 0) erase_ver.emplace_back(e.to, rem_ver.erase(e.to));\n            if(!use){\n                if(use_ver.count(e.to) == 1) continue;\n                if(!push_cand(e.to, add_size)) return false;\n                if(deg[e.to] > 0) use_ver.insert(e.to);\n            }else{\n                if(deg[e.to] == 1 && use_ver.count(e.to) == 0) small_deg_ver.insert(e.to);\n            }\n        }\n        return true;\n    }\n    bool erase_rec_set(set<int>& st, bool flag, int& add_size, vector<pair<int, List<int>::iterator> >& erase_ver){\n        while(!st.empty()){\n            int v = *st.begin();\n            st.erase(v);\n            if(deg[v] == 0) continue;\n            if(!erase(v, flag, flag, add_size, erase_ver)) return false;\n        }\n        return true;\n    }\n    bool reset(){\n        small_deg_ver.clear(), use_ver.clear();\n        return false;\n    }\n    bool erase_rec(int u, bool use, int& add_size, vector<pair<int, List<int>::iterator> >& erase_ver){\n        if(!erase(u, use, false, add_size, erase_ver)) return reset();\n        while(!small_deg_ver.empty() || !use_ver.empty()){\n            if(!erase_rec_set(small_deg_ver, false, add_size, erase_ver)) return reset();\n            if(!erase_rec_set(use_ver, true, add_size, erase_ver)) return reset();\n        }\n        return true;\n    }\n    bool preprocessing(int K, int& add_size, vector<pair<int, List<int>::iterator> >& erase_ver){\n        for(int u : rem_ver){\n            if(deg[u] > K){\n                if(!erase_rec(u, true, add_size, erase_ver)) return false;\n            }\n        }\n        return true;\n    }\n    void postprocessing(int K, int add_size, vector<pair<int, List<int>::iterator> >& erase_ver){\n        if(K == fp_size) return;\n        for(int i = 0; i < add_size; i++){\n            cand.pop_back();\n        }\n        for(int i = (int)erase_ver.size() - 1; i >= 0; i--){\n            auto& p = erase_ver[i];\n            while(!edge_info[p.first].empty()){\n                auto& dat = edge_info[p.first].back();\n                G[dat.from].insert(dat.next, dat.to), deg[dat.from]++, rem_edge_size++;\n                edge_info[p.first].pop_back();\n            }\n            rem_ver.insert(p.second, p.first);\n        }\n    }\n    bool check(){\n        if(rem_edge_size == 0){\n            if((int)cand.size() < ans_size){\n                ans_size = (int)cand.size(), ans_set = cand;\n            }\n            return false;\n        }\n        return (int)rem_ver.size() > 0;\n    }\n    void transition(int K, int next_ver, bool use){\n        int pl_add_size = 0;\n        vector<pair<int, List<int>::iterator> > pl_erase_ver;\n        if(!erase_rec(next_ver, use, pl_add_size, pl_erase_ver)){\n            return postprocessing(K-1, pl_add_size, pl_erase_ver);\n        }\n        if(check()) judge(K-1);\n        return postprocessing(K-1, pl_add_size, pl_erase_ver);\n    }\n    int find_max_degree_ver(){\n        int max_deg = -1, next_ver = -1;\n        for(int v : rem_ver){\n            if(deg[v] > max_deg) max_deg = deg[v], next_ver = v;\n        }\n        if(2 * rem_edge_size > (long long)max_deg * (int)rem_ver.size()) return -1;\n        return next_ver;\n    }\n    void judge(int K){\n        int add_size = 0;\n        vector<pair<int, List<int>::iterator> > erase_ver;\n        if(!preprocessing(K, add_size, erase_ver)) return postprocessing(K, add_size, erase_ver);\n        if(!check()) return postprocessing(K, add_size, erase_ver);\n        int next_ver = find_max_degree_ver();\n        if(next_ver < 0) return postprocessing(K, add_size, erase_ver);\n        transition(K, next_ver, true);\n        if((int)cand.size() + (int)G[next_ver].size() < ans_size){\n            transition(K, next_ver, false);\n        }\n        return postprocessing(K, add_size, erase_ver);\n    }\npublic:\n    vector<int> ans_set;\n    int ans_size;\n\n    MVC(int node_size) :\n        V(node_size), rem_edge_size(0), G(V), rem_ver(V), deg(V, 0), edge_info(V){\n        vector<int> _init(V);\n        iota(_init.begin(), _init.end(), 0);\n        rem_ver.build(_init);\n    }\n    void add_edge(int u, int v){\n        G[u].push_back((edge){v, (int)G[v].size()});\n        G[v].push_back((edge){u, (int)G[u].size() - 1});\n        deg[u]++, deg[v]++, rem_edge_size++;\n    }\n    bool solve(int K){\n        for(int i = 0; i < V; ++i) G[i].build();\n        fp_size = K, ans_size = fp_size + 1;\n        judge(fp_size);\n        return ans_size <= fp_size;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, K;\n    cin >> n >> m >> K;\n    MVC mvc(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        mvc.add_edge(a-1, b-1);\n    }\n    if(mvc.solve(K)){\n        cout << mvc.ans_size << \"\\n\";\n    }else{\n        cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#define maxn 3009\nusing namespace std;\nint map[maxn][maxn];\nint num[maxn];\nstruct asdf\n{\n    int num;\n    int siz;\n}nn[maxn];\nint cmp(struct asdf a,struct asdf b)\n{\n    return a.num<b.num;\n}\nint main()\n{\n    int i,j,n,m,k,ans=0;\n    scanf(\"%d%d%d\",&n,&m,&k);\n    for(i=1;i<=m;i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        map[a][b]=map[b][a]=1;\n        nn[b].num++;nn[a].num++;\n        nn[b].siz=b;nn[a].siz=a;\n    }\n    int flag=1;\n    while(k>0)\n    {\n        sort(nn+1,nn+1+n,cmp);\n        if(nn[n].num==0) break;\n        flag=0;\n        for(i=1;i<=n;i++)\n        {\n            if(map[i][nn[n].siz])\n            {\n                map[i][nn[n].siz]=0;\n                map[nn[n].siz][i]=0;\n                nn[n].num--;\n                for(j=1;j<=n;j++)\n                {\n                    if(nn[j].siz==i)\n                    {\n                        nn[j].num--;\n                        break;\n                    }\n                }\n            }\n        }\n        ans++;\n    }\n    if(k-ans>=0)\n        printf(\"%d\\n\",ans);\n    else printf(\"Impossible\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define ll long long\n#define line printf(\"\\n\")\n#define rep(a,b,c) for(int a= (int)b;a<(int)c;a++)\n#define repd(a,b,c) for(int a=(int)b;a>=c;a--)\n#define pb push_back\n#define pf push_front\n#define pb2 pop_back\n#define pf2 pop_front\n#define pq priority_queue\n#define haha printf(\"hahaha\\n\")\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e17;\nconst double EPS = 1e-5;\n\nusing namespace std;\n\nvector<int> adj[3005],adj2[3005];\npii edge[30005];\nint flag[3005],deg[3005];\nint n,m,d,rem;\n\n\nint brute(int i,int sisa){\n\t\n\tint ret = -INF;\n\tif(sisa<0)return -INF;\n\trep(k,i,m){\n\t\tint a = edge[k].fi;\n\t\tint b = edge[k].se;\n\t\tif(flag[a] || flag[b])continue;\n\t\tif(deg[a]<deg[b])swap(a,b);\n\t\tvector<int>reset;\n\t\t//use a\n\t\tflag[a] = 1;\n\t\trep(l,0,adj[a].size()){\n\t\t\tint next = adj[a][l];\n\t\t\tif(!flag[next]){\n\t\t\t\tdeg[next]--;\n\t\t\t\treset.pb(next);\n\t\t\t}\n\t\t}\n\t\tret = max(ret,brute(i+1,sisa-1));\n\t\t\n\t\t//not use a\n\t\tflag[a] = 0;\n\t\twhile(reset.size())deg[reset.back()]++,reset.pb2();\n\t\t\n\t\trep(l,0,adj[a].size()){\n\t\t\tint next  = adj[a][l];\n\t\t\tif(flag[next]==0){\n\t\t\t\tsisa--;\n\t\t\t\tflag[next] = 1;\n\t\t\t\treset.pb(next);\n\t\t\t\trep(j,0,adj[next].size())deg[adj[next][j]]--;\n\t\t\t}\n\t\t}\t\n\t\tret = max(ret,brute(i+1,sisa));\n\t\twhile(reset.size()){\n\t\t\tint now = reset.back();\n\t\t\tflag[now] = 0;\n\t\t\trep(j,0,adj[now].size())deg[adj[now][j]]++;\n\t\t\treset.pb2();\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\treturn sisa;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&d);\n\t\n\trep(k,0,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);a--;b--;\n\t\t\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t\tedge[k] = mp(a,b);\n\t\tdeg[a]++;deg[b]++;\n\t}\n\t\n\tint bisa = 1;\n\trem = d;\n\twhile(bisa){\n\t\tbisa = 0;\n\t\trep(k,0,n)if(!flag[k] && deg[k]>rem){\n\t\t\tflag[k] = 1;\n\t\t\trem--;\n\t\t\tdeg[k] = 0;\n\t\t\trep(i,0,adj[k].size())deg[adj[k][i]]--;\n\t\t\tbisa = 1;\n\t\t}\n\t\tif(rem<0)break;\n\t}\n\tif(rem<0){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\trep(k,0,n){\n\t\tvector<int> tmp;\n\t\trep(i,0,adj[k].size()){\n\t\t\tint next = adj[k][i];\n\t\t\tif(flag[next])continue;\n\t\t\ttmp.pb(next);\n\t\t}\n\t\tadj[k] = tmp;\n\t\tdeg[k] = adj[k].size();\n\t}\n\tint M = 0;\n\trep(k,0,m){\n\t\tint a = edge[k].fi;\n\t\tint b = edge[k].se;\n\t\tif(flag[a] || flag[b])continue;\n\t\tedge[M++] = edge[k];\n\t//\tprintf(\"%d %d\\n\",edge[M-1].fi,edge[M-1].se);\n\t}\n\tm = M;\n\tif(m>d*d){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\t\n\tint tmp = brute(0,rem);\n\tif(tmp<0)printf(\"Impossible\\n\");\n\telse printf(\"%d\\n\",d-tmp);\n\treturn 0;\n}"
  },
  {
    "language": "Ruby",
    "code": "n, m, k0 = gets.split.map(&:to_i)\nk = k0\ng = [0] * n\n\nm.times do\n\ti, j = gets.split.map(&:to_i)\n\ti -= 1\n\tj -= 1\n\tg[i] |= (1 << j)\n\tg[j] |= (1 << i)\nend\n\ndef f(graph, k)\n\ti = (0..graph.size-1).max_by {|i| graph[i].to_s(2).count(?1) }\n\treturn k >= 0 ? k : -Float::INFINITY if !i || graph[i] == 0\n\treturn -Float::INFINITY if k <= 0\n\n\tg = graph.dup\n\t(0..graph.size-1).each do |j|\n\t\tg[j] -= (1 << i) if g[j][i] == 1\n\tend\n\tg[i] = 0\n\tmax = f(g, k-1)\n\n\tg = graph.dup\n\td = g[i].to_s(2).count(?1)\n\treturn max if d > k\n\n\tmask = g[i] | (1 << i)\n\t(0..graph.size-1).each do |j|\n\t\tif mask[j] == 1\n\t\t\tg[i] = 0\n\t\telse\n\t\t\tg[i] -= g[i] & mask\n\t\tend\n\tend\n\tret = f(g, k-d)\n\n\treturn ret > max ? ret : max\nend\n\nloop do\n\ti = g.index {|x| x.to_s(2).count(?1) <= 1}\n\tbreak if !i\n\tif g[i].to_s(2).count(?1) == 0\n\t\tg.delete_at(i)\n\t\tg.map! do |x|\n\t\t\tl = (x >> i + 1)\n\t\t\tr = x & ((1 << i) - 1)\n\t\t\t(l << i) | r\n\t\tend\n\telse\n\t\tk -= 1\n\t\tmask = (g[i] + (1 << i))\n\t\t(0..g.size-1).each do |j|\n\t\t\tif mask[j] == 1\n\t\t\t\tg[j] = 0\n\t\t\telse\n\t\t\t\tg[j] -= (g[j] & mask)\n\t\t\tend\n\t\tend\n\tend\nend\n\nc = f(g, k)\nputs c >= 0 ? (k - c) + (k0 - k) : 'Impossible'"
  },
  {
    "language": "Ruby",
    "code": "n, m, k0 = gets.split.map(&:to_i)\nk = k0\ng = [0] * n\n\nm.times do\n\ti, j = gets.split.map(&:to_i)\n\ti -= 1\n\tj -= 1\n\tg[i] |= (1 << j)\n\tg[j] |= (1 << i)\nend\n\ndef f(graph, k)\n\ti = (0..graph.size-1).max_by {|i| graph[i].to_s(2).count(?1) }\n\treturn k >= 0 ? k : -Float::INFINITY if !i || graph[i] == 0\n\treturn -Float::INFINITY if k <= 0\n\n\tg = graph.dup\n\t(0..graph.size-1).each do |j|\n\t\tg[j] -= (1 << i) if g[j][i] == 1\n\tend\n\tg[i] = 0\n\tmax = f(g, k-1)\n\n\tg = graph.dup\n\td = g[i].to_s(2).count(?1)\n\treturn max if d > k\n\n\tmask = g[i] | (1 << i)\n\t(0..graph.size-1).each do |j|\n\t\tif mask[j] == 1\n\t\t\tg[i] = 0\n\t\telse\n\t\t\tg[i] -= g[i] & mask\n\t\tend\n\tend\n\tret = f(g, k-d)\n\n\treturn ret > max ? ret : max\nend\n\nloop do\n\ti = g.index {|x| x.to_s(2).count(?1) <= 1}\n\tbreak if !i\n\tif g[i].to_s(2).count(?1) == 0\n\t\tg.delete_at(i)\n\t\tg.map! do |x|\n\t\t\tl = (x >> i + 1)\n\t\t\tr = x & ((1 << i) - 1)\n\t\t\t(l << i) | r\n\t\tend\n\telse\n\t\tk -= 1\n\t\tmask = (g[i] + (1 << i))\n\t\t(0..g.size-1).each do |j|\n\t\t\tif mask[j] == 1\n\t\t\t\tg[j] = 0\n\t\t\telse\n\t\t\t\tg[j] -= (g[j] & mask)\n\t\t\tend\n\t\tend\n\tend\nend\n\nc = f(g, k)\nputs c >= 0 ? (k - c) + (k0 - k) : 'Impossible'"
  },
  {
    "language": "Ruby",
    "code": "n, m, k = gets.split.map(&:to_i)\ng = [0] * n\n\nm.times do\n\ti, j = gets.split.map(&:to_i)\n\ti -= 1\n\tj -= 1\n\tg[i] |= (1 << j)\n\tg[j] |= (1 << i)\nend\n\ndef f(graph, k)\n\ti = (0..graph.size-1).max_by {|i| graph[i].to_s(2).count(?1) }\n\treturn k >= 0 ? k : -Float::INFINITY if graph[i] == 0\n\treturn -Float::INFINITY if k <= 0\n\n\tg = graph.dup\n\t(0..graph.size-1).each do |j|\n\t\tg[j] -= (1 << i) if g[j][i] == 1\n\tend\n\tg[i] = 0\n\tmax = f(g, k-1)\n\n\tg = graph.dup\n\td = g[i].to_s(2).count(?1)\n\treturn max if d > k\n\n\tmask = g[i] | (1 << i)\n\t(0..graph.size-1).each do |j|\n\t\tif mask[j] == 1\n\t\t\tg[i] = 0\n\t\telse\n\t\t\tg[i] -= g[i] & mask\n\t\tend\n\tend\n\tret = f(g, k-d)\n\n\treturn ret > max ? ret : max\nend\n\nloop do\n\ti = g.index {|x| x.to_s(2).count(?1) <= 1}\n\tbreak if !i\n\tif g[i].to_s(2).count(?1) == 0\n\t\tg.delete_at(i)\n\t\tg.map! do |x|\n\t\t\tl = (x >> i + 1)\n\t\t\tr = x & ((1 << i) - 1)\n\t\t\t(l << i) | r\n\t\tend\n\telse\n\t\tk -= 1\n\t\t(0..g.size-1).each do |j|\n\t\t\tg[j] -= (1 << i) if g[j][i] == 1\n\t\tend\n\t\tg[i] = 0\n\tend\nend\n\nc = f(g, k)\nputs c >= 0 ? k - c : 'Impossible'"
  },
  {
    "language": "Ruby",
    "code": "n, m, k = gets.split.map(&:to_i)\ng = [0] * n\n\nm.times do\n\ti, j = gets.split.map(&:to_i)\n\ti -= 1\n\tj -= 1\n\tg[i] |= (1 << j)\n\tg[j] |= (1 << i)\nend\n\ndef del_trivial(g)\n\ttrivial = 0\n\tloop do\n\t\ti = g.index {|x| x.to_s(2).count(?1) <= 1}\n\t\tbreak if !i\n\t\tif g[i].to_s(2).count(?1) == 0\n\t\t\tg.delete_at(i)\n\t\t\tg.map! do |x|\n\t\t\t\tl = (x >> i + 1)\n\t\t\t\tr = x & ((1 << i) - 1)\n\t\t\t\t(l << i) | r\n\t\t\tend\n\t\telse\n\t\t\ttrivial += 1\n\t\t\tmask = (g[i] + (1 << i))\n\t\t\t(0..g.size-1).each do |j|\n\t\t\t\tif mask[j] == 1\n\t\t\t\t\tg[j] = 0\n\t\t\t\telse\n\t\t\t\t\tg[j] -= (g[j] & mask)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\treturn trivial\nend\n\ndef f(graph, k)\n\tg = graph.dup\n\ti = (0..graph.size-1).max_by {|i| graph[i].to_s(2).count(?1) }\n\treturn k >= 0 ? k : -Float::INFINITY if !i || graph[i] == 0\n\treturn -Float::INFINITY if k <= 0\n\n\t(0..graph.size-1).each do |j|\n\t\tg[j] -= (1 << i) if g[j][i] == 1\n\tend\n\tg[i] = 0\n\n\tt = del_trivial(g)\n\n\tmax = f(g, k-1-t)\n\n\tg = graph.dup\n\td = g[i].to_s(2).count(?1)\n\treturn max if d > k\n\n\tmask = g[i] | (1 << i)\n\t(0..graph.size-1).each do |j|\n\t\tif mask[j] == 1\n\t\t\tg[i] = 0\n\t\telse\n\t\t\tg[i] -= g[i] & mask\n\t\tend\n\tend\n\n\tt = del_trivial(g)\n\tret = f(g, k-d-t)\n\n\treturn ret > max ? ret : max\nend\n\nt = del_trivial(g)\nc = f(g, k - t)\nputs c >= 0 ? k - c : 'Impossible'"
  },
  {
    "language": "Ruby",
    "code": "n, m, k = gets.split.map(&:to_i)\ng = [0] * n\n\nm.times do\n    i, j = gets.split.map(&:to_i)\n    i -= 1\n    j -= 1\n    g[i] |= (1 << j)\n    g[j] |= (1 << i)\nend\n# puts g.map {|x| sprintf(\"%0#{n}b\", x).reverse}\n\ndef f(graph, k)\n    i = graph.index {|x| x > 0}\n    return k >= 0 ? k : -Float::INFINITY if !i\n    return -Float::INFINITY if k <= 0\n    g = graph.dup\n    (0..graph.size-1).each do |j| \n        g[j] -= (1 << i) if g[j][i] == 1\n    end \n    g[i] = 0 \n    max = f(g, k-1)\n    g = graph.dup\n    d = g[i].to_s(2).count(?1)\n    (0..graph.size-1).each do |j| \n        if g[j][i] == 1\n            (0..graph.size-1).each do |k| \n                g[k] -= (1 << j) if g[k][j] == 1\n            end \n            g[j] = 0 \n        end \n    end \n    g[i] = 0 \n    ret = f(g, k-d)\n    return ret > max ? ret : max \nend\n\nc = f(g, k)\nputs c >= 0 ? k - c : 'Impossible'"
  },
  {
    "language": "Ruby",
    "code": "n, m, k = gets.split.map(&:to_i)\ng = [0] * n\n\nm.times do\n    i, j = gets.split.map(&:to_i)\n    i -= 1\n    j -= 1\n    g[i] |= (1 << j)\n    g[j] |= (1 << i)\nend\n# puts g.map {|x| sprintf(\"%0#{n}b\", x).reverse}\n\ndef f(graph, k)\n    i = graph.index {|x| x > 0}\n    return k >= 0 ? k : -Float::INFINITY if !i\n    return -Float::INFINITY if k <= 0\n    g = graph.dup\n    (0..graph.size-1).each do |j| \n        g[j] -= (1 << i) if g[j][i] == 1\n    end \n    g[i] = 0 \n    max = f(g, k-1)\n    g = graph.dup\n    d = g[i].to_s(2).count(?1)\n    (0..graph.size-1).each do |j| \n        if g[j][i] == 1\n            (0..graph.size-1).each do |k| \n                g[k] -= (1 << j) if g[k][j] == 1\n            end \n            g[j] = 0 \n        end \n    end \n    g[i] = 0 \n    ret = f(g, k-d)\n    return ret > max ? ret : max \nend\n\nc = f(g, k)\nputs c > 0 ? k - c : 'Impossible'"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nsys.setrecursionlimit(10**5)\ndef solve():\n    N, M, K = map(int, readline().split())\n    G = [[] for i in range(N)]\n    for i in range(M):\n        a, b = map(int, readline().split())\n        G[a-1].append(b-1)\n        G[b-1].append(a-1)\n\n    *D, = map(len, G)\n    *I, = range(N)\n    I.sort(key = D.__getitem__, reverse = 1)\n    INF = 10**9\n    def dfs(i, state, c):\n        if i == N:\n            return c\n\n        v = I[i]\n        res = INF\n\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i+1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c+len(e1)))\n            for w in e1:\n                state[w] = 0\n\n        if len(e1) > 1 and c+1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c+1))\n            state[v] = 0\n        return res\n\n    res = dfs(0, [0]*N, 0)\n    if res < INF:\n        write(\"%d\\n\" % res)\n    else:\n        write(\"Impossible\\n\")\nsolve()\n"
  }
]