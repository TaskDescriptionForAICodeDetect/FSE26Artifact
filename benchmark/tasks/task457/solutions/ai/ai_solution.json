[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_ISLANDS 100\n\ntypedef struct {\n    int src;\n    int dest;\n} Route;\n\nint findParent(int parent[], int x) {\n    if (parent[x] != x)\n        parent[x] = findParent(parent, parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int parent[], int x, int y) {\n    int px = findParent(parent, x);\n    int py = findParent(parent, y);\n    \n    if (px != py)\n        parent[px] = py;\n}\n\nint minimumQuarantineStations(int n, Route routes[], int routeCount, int K) {\n    int parent[MAX_ISLANDS];\n    bool hasQuarantineStation[MAX_ISLANDS];\n    \n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        hasQuarantineStation[i] = false;\n    }\n    \n    for (int quarantineCount = 0; quarantineCount <= K; quarantineCount++) {\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (__builtin_popcount(mask) != quarantineCount)\n                continue;\n            \n            memset(hasQuarantineStation, false, sizeof(hasQuarantineStation));\n            for (int i = 0; i < n; i++) {\n                if (mask & (1 << i))\n                    hasQuarantineStation[i] = true;\n            }\n            \n            for (int i = 0; i < n; i++)\n                parent[i] = i;\n            \n            bool valid = true;\n            for (int i = 0; i < routeCount; i++) {\n                int src = routes[i].src;\n                int dest = routes[i].dest;\n                \n                if (!hasQuarantineStation[src] && !hasQuarantineStation[dest]) {\n                    valid = false;\n                    break;\n                }\n                \n                if (hasQuarantineStation[src] && hasQuarantineStation[dest]) {\n                    unionSet(parent, src, dest);\n                }\n            }\n            \n            if (!valid)\n                continue;\n            \n            bool connected = true;\n            int root = findParent(parent, 0);\n            for (int i = 1; i < n; i++) {\n                if (findParent(parent, i) != root) {\n                    connected = false;\n                    break;\n                }\n            }\n            \n            if (connected)\n                return quarantineCount;\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int n, m, K;\n    scanf(\"%d %d %d\", &n, &m, &K);\n    \n    Route routes[MAX_ISLANDS * MAX_ISLANDS];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &routes[i].src, &routes[i].dest);\n        routes[i].src--;\n        routes[i].dest--;\n    }\n    \n    int result = minimumQuarantineStations(n, routes, m, K);\n    \n    if (result == -1)\n        printf(\"Impossible\\n\");\n    else\n        printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:45:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100\n#define MAX_M 10000\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nEdge edges[MAX_M];\nint parent[MAX_N];\nint rank[MAX_N];\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid union_set(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return;\n    if (rank[u] > rank[v]) {\n        parent[v] = u;\n    } else {\n        parent[u] = v;\n        if (rank[u] == rank[v]) {\n            rank[v]++;\n        }\n    }\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &edges[i].u, &edges[i].v);\n        edges[i].u--;\n        edges[i].v--;\n    }\n    \n    int min_stations = N;\n    for (int mask = 0; mask < (1 << N); mask++) {\n        int bits = __builtin_popcount(mask);\n        if (bits > K) continue;\n        \n        for (int i = 0; i < N; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u = edges[i].u;\n            int v = edges[i].v;\n            if ((mask & (1 << u)) || (mask & (1 << v))) continue;\n            union_set(u, v);\n        }\n        \n        int components = 0;\n        for (int i = 0; i < N; i++) {\n            if (parent[i] == i) components++;\n        }\n        \n        if (components <= K) {\n            if (bits < min_stations) {\n                min_stations = bits;\n            }\n        }\n    }\n    \n    if (min_stations <= K) {\n        printf(\"%d\\n\", min_stations);\n    } else {\n        printf(\"-1\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool isPossible(int K, const vector<pair<int, int>>& edges, int n, int mid) {\n    vector<bool> selected(n + 1, false);\n    int count = 0;\n    for (const auto& edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        if (!selected[u] && !selected[v]) {\n            selected[u] = selected[v] = true;\n            count += 2;\n            if (count > 2 * K) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    vector<pair<int, int>> edges(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n\n    int left = 0, right = N;\n    int answer = -1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (isPossible(K, edges, N, mid)) {\n            answer = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    if (answer != -1 && answer <= K) {\n        cout << \"YES\" << endl;\n        cout << answer << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class QuarantineStations {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        \n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n        \n        int minStations = Integer.MAX_VALUE;\n        for (int mask = 0; mask < (1 << N); mask++) {\n            int stations = Integer.bitCount(mask);\n            if (stations > K) continue;\n            \n            boolean valid = true;\n            for (int u = 0; u < N && valid; u++) {\n                for (int v : adj.get(u)) {\n                    if (v < u) continue; // Avoid duplicate checks\n                    if ((mask & (1 << u)) == 0 && (mask & (1 << v)) == 0) {\n                        valid = false;\n                        break;\n                    }\n                }\n            }\n            \n            if (valid && stations < minStations) {\n                minStations = stations;\n            }\n        }\n        \n        if (minStations != Integer.MAX_VALUE) {\n            System.out.println(minStations);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:46:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MOFUQuarantine {\n    static class Graph {\n        int V;\n        List<List<Integer>> adj;\n\n        Graph(int vertices) {\n            V = vertices;\n            adj = new ArrayList<>(V);\n            for (int i = 0; i < V; i++) {\n                adj.add(new ArrayList<>());\n            }\n        }\n\n        void addEdge(int u, int v) {\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        int minimumQuarantineStations(int k) {\n            // Try building 0 to k stations\n            for (int stations = 0; stations <= k; stations++) {\n                if (canCoverAllPaths(stations)) {\n                    return stations;\n                }\n            }\n            return -1;\n        }\n\n        boolean canCoverAllPaths(int k) {\n            // Generate all possible combinations of k stations\n            return backtrack(new boolean[V], 0, 0, k);\n        }\n\n        boolean backtrack(boolean[] stations, int index, int count, int k) {\n            // If we've placed k stations\n            if (count == k) {\n                // Check if all connections are valid\n                return isValidConfiguration(stations);\n            }\n\n            // If we've reached end without finding solution\n            if (index == V) {\n                return false;\n            }\n\n            // Try placing station at current index\n            stations[index] = true;\n            if (backtrack(stations, index + 1, count + 1, k)) {\n                return true;\n            }\n\n            // Backtrack: remove station\n            stations[index] = false;\n            return backtrack(stations, index + 1, count, k);\n        }\n\n        boolean isValidConfiguration(boolean[] stations) {\n            for (int u = 0; u < V; u++) {\n                for (int v : adj.get(u)) {\n                    // If edge exists between u and v\n                    if (u < v) {\n                        // Check if both endpoints have stations\n                        if (!stations[u] && !stations[v]) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Read number of islands and ocean liners\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int K = sc.nextInt();\n\n        Graph graph = new Graph(N);\n\n        // Read ocean liner connections\n        for (int i = 0; i < M; i++) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            graph.addEdge(u, v);\n        }\n\n        // Find minimum stations required\n        int result = graph.minimumQuarantineStations(K);\n        System.out.println(result);\n\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 21:47:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumQuarantineStations(int N, vector<vector<int>>& routes, int K) {\n        vector<vector<int>> graph(N);\n        vector<int> degree(N, 0);\n        \n        // Build graph\n        for (const auto& route : routes) {\n            int u = route[0], v = route[1];\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n            degree[u]++;\n            degree[v]++;\n        }\n        \n        // Find minimum stations needed\n        vector<bool> hasStation(N, false);\n        int stationsPlaced = 0;\n        \n        priority_queue<pair<int, int>> pq;\n        for (int i = 0; i < N; i++) {\n            pq.push({degree[i], i});\n        }\n        \n        while (!pq.empty() && stationsPlaced < K) {\n            int node = pq.top().second;\n            pq.pop();\n            \n            if (hasStation[node]) continue;\n            \n            // Place station on node\n            hasStation[node] = true;\n            stationsPlaced++;\n            \n            // Mark connected nodes as covered\n            for (int neighbor : graph[node]) {\n                hasStation[neighbor] = true;\n            }\n        }\n        \n        // Check if all routes can be covered\n        for (const auto& route : routes) {\n            int u = route[0], v = route[1];\n            if (!hasStation[u] && !hasStation[v]) {\n                return -1;  // Not possible to cover all routes\n            }\n        }\n        \n        return stationsPlaced;\n    }\n};\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    \n    vector<vector<int>> routes(M, vector<int>(2));\n    for (int i = 0; i < M; i++) {\n        cin >> routes[i][0] >> routes[i][1];\n    }\n    \n    Solution solution;\n    int result = solution.minimumQuarantineStations(N, routes, K);\n    \n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minQuarantineStations(num_islands, routes, K):\n    from collections import defaultdict\n\n    def canPlaceStations(limit):\n        # Build graph\n        graph = defaultdict(list)\n        for u, v in routes:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, installed, visited):\n            visited[node] = True\n            unvisited_neighbors = [n for n in graph[node] if not visited[n]]\n            additional_stations = 0\n            for neighbor in unvisited_neighbors:\n                additional_stations += dfs(neighbor, installed, visited)\n            \n            if additional_stations == 0 and node not in installed:\n                return 1\n            return 0\n        \n        visited = [False] * num_islands\n        installed = set()\n        total_stations = 0\n        \n        for island in range(num_islands):\n            if not visited[island]:\n                total_stations += dfs(island, installed, visited)\n        \n        return total_stations <= limit\n\n    low, high = 0, num_islands\n    answer = num_islands\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if canPlaceStations(mid):\n            answer = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return answer if answer <= K else -1\n\n# Example usage:\nnum_islands = 5\nroutes = [(0, 1), (1, 2), (2, 3), (3, 4)]\nK = 3\nprint(minQuarantineStations(num_islands, routes, K))  # Output: should be the minimum number of quarantine stations",
    "timestamp": "2025-08-13 07:22:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class QuarantineStations {\n    private static boolean isPossible(List<Integer>[] graph, int[] stations, boolean[] visited, int k, int node) {\n        visited[node] = true;\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                if (stations[node] == 0 && stations[neighbor] == 0) {\n                    return false;\n                }\n                if (!isPossible(graph, stations, visited, k, neighbor)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private static int minimumStations(List<Integer>[] graph, int k) {\n        int n = graph.length;\n        for (int i = 0; i <= k; i++) {\n            int[] stations = new int[n];\n            boolean[] visited = new boolean[n];\n            int count = 0;\n\n            for (int j = 0; j < n; j++) {\n                if (!visited[j] && stations[j] == 0) {\n                    stations[j] = 1;\n                    count++;\n                }\n                if (count > i) {\n                    break;\n                }\n            }\n\n            Arrays.fill(visited, false);\n            if (isPossible(graph, stations, visited, i, 0)) {\n                return count;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int islands = scanner.nextInt();\n        int routes = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        List<Integer>[] graph = new ArrayList[islands];\n        for (int i = 0; i < islands; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < routes; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n\n        int result = minimumStations(graph, k);\n        System.out.println(result == -1 ? \"Impossible\" : result);\n    }\n}",
    "timestamp": "2025-08-13 07:22:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#define MAX_ISLANDS 1001\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nint numIslands, numOceanLiners, K;\nEdge oceanLiners[MAX_ISLANDS * MAX_ISLANDS];\nbool visited[MAX_ISLANDS];\nbool connected[MAX_ISLANDS][MAX_ISLANDS];\n\nbool canPlaceStations(int nodes, int edges){\n    // Tarjan's algorithm finding Strongly Connected Components\n    int index = 0, stack[MAX_ISLANDS], stacktop = -1;\n    int indexMapping[MAX_ISLANDS], lowLink[MAX_ISLANDS];\n    bool inStack[MAX_ISLANDS];\n    int components = 0;\n\n    for (int i = 0; i <= nodes; i++) {\n        indexMapping[i] = -1;\n        lowLink[i] = 0;\n        inStack[i] = false;\n    }\n\n    for (int i = 1; i <= nodes; i++) {\n        if (indexMapping[i] == -1) {\n            strongConnect(i, &index, lowLink, indexMapping, inStack, stack, &stacktop, &components);\n        }\n    }\n    return components <= K;\n}\n\nvoid strongConnect(int node, int *index, int *lowLink, int *indexMapping, bool *inStack, int *stack, int *stacktop, int *components) {\n    indexMapping[node] = *index;\n    lowLink[node] = *index;\n    (*index)++;\n    stack[++(*stacktop)] = node;\n    inStack[node] = true;\n\n    for (int i = 1; i <= numIslands; i++) {\n        if (connected[node][i]) {\n            if (indexMapping[i] == -1) {\n                strongConnect(i, index, lowLink, indexMapping, inStack, stack, stacktop, components);\n                lowLink[node] = (lowLink[node] < lowLink[i]) ? lowLink[node] : lowLink[i];\n            } else if (inStack[i]) {\n                lowLink[node] = (lowLink[node] < indexMapping[i]) ? lowLink[node] : indexMapping[i];\n            }\n        }\n    }\n\n    if (lowLink[node] == indexMapping[node]) {\n        int w;\n        do {\n            w = stack[(*stacktop)--];\n            inStack[w] = false;\n        } while (w != node);\n        (*components)++;\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &numIslands, &numOceanLiners, &K);\n\n    for (int i = 0; i < numOceanLiners; i++) {\n        int u, v;\n        scanf(\"%d %d\", &oceanLiners[i].u, &oceanLiners[i].v);\n        connected[oceanLiners[i].u][oceanLiners[i].v] = true;\n    }\n\n    if (canPlaceStations(numIslands, numOceanLiners)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:22:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_quarantine_stations(N, M, K, edges):\n    # Create adjacency list representation\n    graph = [[] for _ in range(N)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    # Try all possible combinations of stations\n    def is_valid_configuration(stations):\n        # Check connectivity and quarantine requirements\n        visited = [False] * N\n        def dfs(node):\n            visited[node] = True\n            for neighbor in graph[node]:\n                if neighbor not in stations and not visited[neighbor]:\n                    dfs(neighbor)\n        \n        # Start DFS from first station\n        if stations:\n            dfs(stations[0])\n        \n        # Ensure all stations are reachable\n        for station in stations:\n            if not visited[station]:\n                return False\n        \n        # Check if every connection has at least one station\n        for u in range(N):\n            for v in graph[u]:\n                if u < v:  # avoid duplicate checks\n                    if u not in stations and v not in stations:\n                        return False\n        \n        return True\n    \n    # Try all possible station configurations\n    from itertools import combinations\n    \n    # Try 0 to K stations\n    for num_stations in range(K + 1):\n        for stations in combinations(range(N), num_stations):\n            if is_valid_configuration(stations):\n                return num_stations\n    \n    return -1\n\n# Input handling\nN, M, K = map(int, input().split())\nedges = []\nfor _ in range(M):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Solve and print result\nresult = solve_quarantine_stations(N, M, K, edges)\nprint(result)",
    "timestamp": "2025-08-13 07:22:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    K = int(input[ptr])\n    ptr += 1\n    \n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    left = 0\n    right = N\n    answer = N\n    \n    while left <= right:\n        mid = (left + right) // 2\n        selected = set()\n        degrees = [0] * (N + 1)\n        q = deque()\n        \n        for u in range(1, N+1):\n            degrees[u] = len(adj[u])\n            if degrees[u] < mid:\n                q.append(u)\n        \n        temp_selected = set()\n        while q:\n            u = q.popleft()\n            temp_selected.add(u)\n            for v in adj[u]:\n                if v not in temp_selected:\n                    degrees[v] -= 1\n                    if degrees[v] < mid and v not in temp_selected:\n                        q.append(v)\n        \n        candidate = N - len(temp_selected)\n        if candidate <= K:\n            answer = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    print(answer)\n\nsolve()",
    "timestamp": "2025-08-13 07:23:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool isPossible(const vector<vector<int>>& adj, vector<bool>& quarantine, int k) {\n    for (int i = 0; i < adj.size(); ++i) {\n        for (int j : adj[i]) {\n            if (!quarantine[i] && !quarantine[j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint searchMinStations(int start, int stationsSoFar, const int k, vector<vector<int>>& adj, vector<bool>& quarantine) {\n    if (isPossible(adj, quarantine, k)) return stationsSoFar;\n    if (start >= adj.size() || stationsSoFar >= k) return k + 1;\n\n    int result = k + 1;\n\n    for (int i = start; i < adj.size(); ++i) {\n        quarantine[i] = true;\n        result = min(result, searchMinStations(i + 1, stationsSoFar + 1, k, adj, quarantine));\n        quarantine[i] = false;\n    }\n    \n    return result;\n}\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<int>> adj(n);\n\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<bool> quarantine(n, false);\n    \n    int minStations = searchMinStations(0, 0, k, adj, quarantine);\n    \n    if (minStations <= k) {\n        cout << \"Possible with minimum \" << minStations << \" stations.\\n\";\n    } else {\n        cout << \"Impossible.\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:38:13"
  }
]