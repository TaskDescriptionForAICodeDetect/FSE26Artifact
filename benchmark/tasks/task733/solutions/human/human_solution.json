[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\ntypedef long long LL;\nconst LL P = 1e9+7;\nconst int N = 6e5+5;\n \nint fac[N], ifac[N];\nint n, m, L, R;\n \nint pw(LL x,int n){\n\tLL res = 1;\n\tfor(;n;n>>=1,x=x*x%P)if(n&1)res=res*x%P;\n\treturn res;\n}\nint C(int x,int y){\n\tif(y<0 || y>x) return 0;\n\treturn 1ll * fac[x] * ifac[y] % P * ifac[x-y] % P;\n}\nint calc(int n,int sumL,int sumR){\n\treturn (C(sumR+n,n) - C(sumL-1+n,n) + P) % P;\n}\n \nint main(){\n\tfac[0] = 1;\n\trep(i,1,N-1) fac[i] = 1ll * fac[i-1] * i % P;\n\tifac[N-1] = pw(fac[N-1], P-2);\n\trrep(i,N-2,0) ifac[i] = 1ll * ifac[i+1] * (i+1) % P;\n\t\n\tcin>>n>>m>>L>>R;\n\tint sall = calc(n,L,R), s1 = 0;\n\t\n\trep(i,1,R){\n\t\tint sL = L - m * i, sR = R - m * i, r = i - 1, res = 0;\n\t\tif(sR<0) break;\n\t\t\n\t\trep(j,0,n-m){\n\t\t\tint sl = sL - j * (r+1), sr = sR - j * (r+1);\n\t\t\tif(sr<0) break;\n\t\t\tres = (res + (j%2==0 ? 1ll : -1ll) * calc(n,sl,sr) * C(n-m, j) % P + P) % P;\n\t\t}\n\t\t\n\t\tsL = L - m * (i+1), sR = R - m * (i+1);\n\t\trep(j,0,n-m){\n\t\t\tint sl = sL - j * (r+1), sr = sR - j * (r+1);\n\t\t\tif(sR<0) break;\n\t\t\tres = (res - (j%2==0 ? 1ll : -1ll) * calc(n,sl,sr) * C(n-m, j) % P + P) % P;\n\t\t}\n\t\ts1 = (s1 + 1ll * res * C(n, m) % P) % P;\n\t}\n\tcout<<(sall - s1 + P) % P <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll M=1000000007;\nint n,m,l,r,i;\nll p[600005],inv[600005],ans;\nll C(int n,int m)\n{\n\tif(n<0|m<0||n<m)\n\t\treturn 0;\n\treturn p[n]*inv[m]%M*inv[n-m]%M;\n}\nll Ans(int y)\n{\n\tint i,j;\n\tll ans=0;\n\tfor(i=0;i*m<=y;i++)\n\t{\n\t\tint u=y-i*m;\n\t\tll s=0;\n\t\tfor(j=0;j<=n-m&&u+n-m-j*i>=n;j++)\n\t\t\tif(j%2==0)\n\t\t\t\ts=(s+C(n-m,j)*C(u+n-m-j-j*i,n))%M;\n\t\t\telse\n\t\t\t\ts=(s-C(n-m,j)*C(u+n-m-j-j*i,n))%M;\n\t\tans=(ans+s)%M;\n\t\ts=0;\n\t\tfor(j=0;j<=n-m&&u+n-m-j*(i-1)>=n;j++)\n\t\t\tif(j%2==0)\n\t\t\t\ts=(s+C(n-m,j)*C(u+n-m-j-j*(i-1),n))%M;\n\t\t\telse\n\t\t\t\ts=(s-C(n-m,j)*C(u+n-m-j-j*(i-1),n))%M;\n\t\tans=(ans-s)%M;\n\t}\n\treturn ans*C(n,m)%M;\n}\nint main()\n{\n\tscanf(\"%d %d %d %d\",&n,&m,&l,&r);\n\tp[0]=inv[0]=inv[1]=1;\n\tfor(i=2;i<=600000;i++)\n\t\tinv[i]=inv[M%i]*(M-M/i)%M;\n\tfor(i=1;i<=600000;i++)\n\t{\n\t\tp[i]=p[i-1]*i%M;\n\t\tinv[i]=inv[i-1]*inv[i]%M;\n\t}\n\tans=Ans(r)-Ans(l-1);\n\tcout<<((C(r+n,n)-C(l+n-1,n)-ans)%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    ll n,m,l,r;\n    cin>>n>>m>>l>>r;\n    m=n-m;\n    --l;\n    mod_build(1234567);\n    ll ans1 = comb(n+r,r)-comb(n+l,l)+mod;\n    ll ans2 = 0;\n    REP(i,1,r+1){\n        ll cur = 0;\n        rep(j,m+1){\n            if((j+n-m)*i>r)break;\n            if(j%2)cur+=mod-comb(r-(n-m+j)*i+n,n)*comb(m,j)%mod;\n            else cur+=comb(r-(n-m+j)*i+n,n)*comb(m,j)%mod;\n        }\n        rep(j,m+1){\n            if((j+n-m)*i>r)break;\n            if(j%2==0)cur+=mod-comb(r-(n-m)*(i+1)-j*i+n,n)*comb(m,j)%mod;\n            else cur+=comb(r-(n-m)*(i+1)-j*i+n,n)*comb(m,j)%mod;\n        }\n        ans2+=cur%mod;\n    }\n    REP(i,1,l+1){\n        ll cur = 0;\n        rep(j,m+1){\n            if((j+n-m)*i>l)break;\n            if(j%2==0)cur+=mod-comb(l-(n-m+j)*i+n,n)*comb(m,j)%mod;\n            else cur+=comb(l-(n-m+j)*i+n,n)*comb(m,j)%mod;\n        }\n        rep(j,m+1){\n            if((j+n-m)*i>l)break;\n            if(j%2)cur+=mod-comb(l-(n-m)*(i+1)-j*i+n,n)*comb(m,j)%mod;\n            else cur+=comb(l-(n-m)*(i+1)-j*i+n,n)*comb(m,j)%mod;\n        }\n        ans2+=cur%mod;\n    }\n    ans2%=mod;\n    cout<<(ans1-ans2*comb(n,m)%mod+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=600005;\nconst int mod=1e9+7;\ninline int Add(int x,int y){\n    return (x+=y)>=mod?x-mod:x;\n}\ninline int Sub(int x,int y){\n    return (x-=y)<0?x+mod:x;\n}\ninline int Mul(int x,int y){\n    return 1ll*x*y%mod;\n}\ninline int Pow(int x,int y){\n    int res=1;\n    while(y){\n        if(y&1)res=1ll*res*x%mod;\n        y>>=1;\n        x=1ll*x*x%mod;\n    }\n    return res;\n}\nint m,n,l,r;\nint f[max_n],inv[max_n];\nvoid init(int n){\n    f[0]=1;\n    for(int i=1;i<=n;i++)f[i]=1ll*f[i-1]*i%mod;\n    inv[n]=Pow(f[n],mod-2);\n    for(int i=n-1;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nint C(int n,int m){\n    if(n<m||m<0)return 0;\n    return 1ll*f[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint cal(int a,int b,int s){\n    int res=0;\n    for(int i=0;i<=n-m;i++){\n        int ts=s-m*a-i*(b+1);\n        if(ts<0)break;\n        if(i&1)res=Sub(res,Mul(C(n-m,i),C(ts+n,n)));\n        else res=Add(res,Mul(C(n-m,i),C(ts+n,n)));\n    }\n    res=Mul(res,C(n,m));\n    //cout<<res<<endl;\n    return res;\n}\nint solve(int s){\n    int res=C(s+n,n);\n    //cout<<res<<endl;\n    for(int x=1;x*m<=s;x++){\n        res=Sub(res,Sub(cal(x,x-1,s),cal(x+1,x-1,s)));\n       // cout<<x<<' '<<cal(x,x-1,s)<<' '<<cal(x+1,x-1,s)<<endl;\n    }\n    return res;\n}\nint main(){\n    scanf(\"%d%d%d%d\",&n,&m,&l,&r);\n    init(max_n-1);\n    int ans=(solve(r)-solve(l-1)+mod)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=600005;\nconst int mod=1e9+7;\nint n,m,L,R;\nint fac[maxn],ifac[maxn];\n\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint calc(int R){\n\tint ans=0;\n\trep(i,R+1){\n\t\tint cR=R-m*i;\n\t\tif(cR<0)break;\n\t\trep(j,n-m+1){\n\t\t\tint ccR=cR-j*i;\n\t\t\tif(ccR<0)break;\n\t\t\tint cur=1LL*C(n-m,j)*(C(ccR+n,n)-C(ccR+n-m,n)+mod)%mod*(j&1?(mod-1):1)%mod;\n\t\t\tans+=cur;\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);\n\tfac[0]=ifac[0]=fac[1]=ifac[1]=1;\n\tfor(int i=2;i<=n+R;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod; \n\t}\n\tREP(i,n+R)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tprintf(\"%d\\n\",((C(R+n,n)-C(L-1+n,n)+mod)%mod-1LL*(calc(R)-calc(L-1)+mod)*C(n,m)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[2000001], invf[2000001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(!(0<=y && y<=x)) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint n, m;\nll solve(int r){\n  if(r==0) return 1;\n  ll ret=comb(r+n, n);\n  for(int i=0; i<=r; i++){\n    for(int j=0; r-(ll)(m+j)*(i+1)>=0; j++){\n      ll c=comb(n, m)*comb(n-m, j)%MOD*comb(r-(m+j)*(i+1)+n, n)%MOD;\n      if(j&1) (ret+=c)%=MOD;\n      else (ret+=MOD-c)%=MOD;\n    }\n  }\n  for(int i=1; i<=r; i++){\n    for(int j=0; r-(ll)m*(i+1)-(ll)j*i>=0; j++){\n      ll c=comb(n, m)*comb(n-m, j)%MOD*comb(r-m*(i+1)-j*i+n, n)%MOD;\n      if((j&1)==0) (ret+=c)%=MOD;\n      else (ret+=MOD-c)%=MOD;\n    }\n  }\n  return ret;\n}\nint main()\n{\n\tint l, r; cin>>n>>m>>l>>r;\n  fac(r+n);\n  cout<<(solve(r)-solve(l-1)+MOD)%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6+10;\nconst int P = 1e9+7;\n#define fr(i,low,up,st) for(register int i = low;i <= up;i += st)\n#define nfr(i,low,up,st) for(register int i = low;i >= up;i -= st)\n#define size(a) a.size()\n#define fill(a,b) memset(a,b,sizeof a)\n\nint fact[N],inv[N];\n\ninline int pow_mod(int x,int k){\n   int res = 1,base = x;\n   while(k){\n      if(k&1)res = 1LL*res*base%P;\n      k >>= 1;\n      base = 1LL*base*base%P;\n   }\n   return res;\n}\n\nvoid init(){\n   fact[0] = inv[0] = 1;\n   fr(i,1,N-1,1)fact[i] = 1LL*fact[i-1]*i%P;\n   inv[N-1] = pow_mod(fact[N-1],P-2);\n   nfr(i,N-2,1,1)inv[i] = 1LL*inv[i+1]*(i+1)%P;\n}\n\ninline int c(int n,int m){\n   if(n < m)return 0;\n   return 1LL*fact[n]*inv[n-m]%P*inv[m]%P;\n}\n\nvoid Mod(int &x){\n   x = (x>=P)?x-P:x;\n   x = (x<0)?x+P:x;\n}\nint n,m;\nint calc(int up,int a,int b){\n   int pans = 0;\n   for(int k = 0;1LL*k*(b+1)+1LL*a*m <= up && k+m <= n; ++k){\n      Mod(pans += 1LL*pow_mod(-1,k)*c(up-a*m-k*(b+1)+n,n)*c(n-m,k)%P);\n   }\n   //cerr << up <<' '<< a << ' ' << b <<' ' << pans << endl;\n   return 1LL*pans*c(n,m)%P;\n}\n\nint solve(int up){\n   int ans = 0;\n   fr(i,1,up,1){\n      Mod(ans += calc(up,i,i-1)-calc(up,i+1,i-1));\n      //cerr << i <<' '<< ans << endl;\n   }\n   Mod(ans = c(up+n,n)-ans);\n   return ans;\n}\n\nint main(){\n   init();\n   int L,R;\n   scanf(\"%d%d%d%d\",&n,&m,&L,&R);\n   int fans = 0;\n   Mod(fans = solve(R)-solve(L-1));\n   printf(\"%d\\n\",fans);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\n\nint main(){\n\tinit_C(1100000);\n\tint a,b,c,d;\n\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\tlong long ret=0;\n\tfor(int i=0;i<=d;i++){\n\t\tfor(int x=0;x<2;x++){\n\t\t\tfor(int y=0;y<=a-b;y++){\n\t\t\t\tif(d-(long long)b*i-x*b-(long long)y*i<0)break;\n\t\t\t\tlong long ks=Comb(a,b);\n\t\t\t\tks=ks*Comb(a-b,y)%mod;\n\t\t\t\tlong long L=max(0LL,c-(long long)b*i-x*b-(long long)y*i);\n\t\t\t\tlong long R=d-(long long)b*i-x*b-(long long)y*i;\n\t\t\t\tlong long tmp=Comb(R+a,a);\n\t\t\t\tif(L)tmp=(tmp+mod-Comb(L-1+a,a))%mod;\n\t\t\t\tks=ks*tmp%mod;\n\t\t\t\tif((x+y)%2==0)ret=(ret+ks)%mod;\n\t\t\t\telse ret=(ret+mod-ks)%mod;\n\t//\t\t\tprintf(\"%d %d %d: %lld\\n\",i,x,y,ks);\n\t\t\t}\n\t\t}\n\t//\tprintf(\"%d: %lld\\n\",i,ret);\n\t}\n\tlong long sum=0;\n\tfor(int i=c;i<=d;i++){\n\t\tsum=(sum+Comb(i+a-1,a-1))%mod;\n\t}\n\tret=(sum+mod-ret)%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace mine\n{\n    #define double long double\n    typedef long long ll;\n    #define pr pair<int,int>\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define PB push_back\n    #define vc vector\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) putchar('-'),num=-num;\n        if(num>=10) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    void chmax(int &x,const ll y) {x=(x>y?x:y);}\n    void chmin(int &x,const ll y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):0;}\n    const int INF=0x3f3f3f3f;\n    const int MOD=1e9+7;\n    inline int mm(const int x){return x>=MOD?x-MOD:x;}\n    inline ll qpower(ll x,ll e)\n    {\n        ll ans=1;\n        while(e)\n        {\n            if(e&1) ans=ans*x%MOD;\n            x=x*x%MOD;e>>=1;\n        }\n        return ans;\n    }\n    inline int invm(int x){return qpower(x,MOD-2);}\n    const int N=1e6+10;\n\n    ll fac[N],facinv[N];\n    int C(int n,int m){if(n<m)puts(\"pp\");return fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n    int g(int n,int m){return C(n+m-1,m-1);}\n\n    int n,m;\n    int f(int R,int a,int b)\n    {\n        ll ans=0;\n        for(int i=0;i<=m;i++)\n        {\n            ll tmp=R-i*ll(a+1)-ll(n-m)*b;if(tmp<0) break;\n            ans=(ans+ll(i&1?MOD-1:1)*C(m,i)%MOD*g(tmp,n+1))%MOD;\n        }\n        return ans;\n    }\n    int solve(int R)\n    {\n        ll ans=0;\n        for(int t=1;t<=R;t++) ans=(ans+f(R,t-1,t)+MOD-f(R,t-1,t+1))%MOD/*,printf(\"R=%d t=%d %d-%d\\n\",R,t,f(R,t-1,t),f(R,t-1,t+1))*/;\n        return ((ll)g(R,n+1)+MOD-ans*C(n,m)%MOD)%MOD;\n    }\n    void main()\n    {\n        fac[0]=1;for(int i=1;i<N;i++) fac[i]=fac[i-1]*i%MOD;\n        facinv[N-1]=invm(fac[N-1]);for(int i=N-2;i>=0;i--) facinv[i]=facinv[i+1]*(i+1)%MOD;\n\n        int l,r;scanf(\"%d%d%d%d\",&n,&m,&l,&r);\n        write((solve(r)+MOD-solve(l-1))%MOD);\n    }\n};\nint main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll fact[600005];\n\nll extgcd(ll a,ll b,ll& x,ll& y){\n\tll d=a;\n\tif(b!=0LL){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll& e){\n\te=0;\n\tif(n==0)return 1;\n\tll res=mod_fact(n/p,p,e);\n\te+=n/p;\n\tif(n/p%2!=0){\n\t\treturn res*(p-fact[n%p])%p;\n\t}\n\treturn res*fact[n%p]%p;\n}\n\nll mod_comb(ll n,ll k,ll p=MOD){\n\tif(n<0 || k<0 || n<k)return 0;\n\tll e1,e2,e3;\n\tll a1=mod_fact(n,p,e1),a2=mod_fact(k,p,e2),a3=mod_fact(n-k,p,e3);\n\tif(e1>e2+e3)return 0;\n\treturn a1*mod_inverse(a2*a3%p,p)%p;\n}\n\n\nint n,m;\n\nll calc(int a,int b,int r){\n\tll ans=0;\n\tfor(int over=0;(ll)over*b+(ll)m*a<=r && over<=n-m;over++){\n\t\tll rest=r-over*b-m*a;\n\t\tll pat=mod_comb(n-m,over)*mod_comb(n+rest,rest)%MOD;\n\t\tif(over%2==0){\n\t\t\tans+=pat;\n\t\t\tans%=MOD;\n\t\t}else{\n\t\t\tans+=MOD-pat;\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\treturn ans*mod_comb(n,m)%MOD;\n}\n\nint main(void){\n\tint l,r;\n\tfact[0]=1;\n\tfor(ll i=1;i<=600000;i++){\n\t\tfact[i]=fact[i-1]*i%MOD;\n\t}\n\tscanf(\"%d%d%d%d\",&n,&m,&l,&r);\n\tll ans=(mod_comb(n+r,r)-mod_comb(n+l-1,l-1)+MOD)%MOD;\n\tfor(int a=1;a<=r;a++){\n\t\tll val=calc(a,a,r)-calc(a+1,a,r);\n\t\tll val2=calc(a,a,l-1)-calc(a+1,a,l-1);\n\t\tans+=MOD-(val-val2+MOD)%MOD;\n\t\tans%=MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1000000007;\n\nint quickpow(int x,int y)\n{\n\tlong long res=1,base=x;\n\twhile(y)\n\t{\n\t\tif(y&1) res*=base,res%=mod;\n\t\ty>>=1; base*=base,base%=mod;\n\t}\n\treturn res;\n}\nint inv(int x){return quickpow(x,mod-2);}\n\nint prod[1000001];\nint iprod[1000001];\nint c(int n,int m){return 1ll*prod[n]*iprod[n-m]%mod*iprod[m]%mod;}\n\nint solve2(int n,int m,int s,int l,int r)\n{\n\ts-=m*r;\n\tif(s<0) return 0;\n\tint ans=0;\n\tfor(int i=0;i<=n-m&&s-i*l>=0;i++)\n\t{\n\t\tans=ans+1ll*((i%2==0)?1:-1)*c(s-i*l+n,n)*c(n-m,i)%mod;\n\t\tans%=mod;\n\t}\n\treturn 1ll*(ans+mod)*c(n,m)%mod;\n}\n\nint solve(int n,int m,int s)\n{\n\tint ans=c(s+n,n);\n\tfor(int i=0;i<=s;i++)\n\t\tans=(ans-solve2(n,m,s,i,i)+solve2(n,m,s,i,i+1))%mod;\n\treturn 1ll*(ans+mod)%mod%mod;\n}\nint main()\n{\n\tint n,m,l,r;\n\tscanf(\"%d%d%d%d\",&n,&m,&l,&r);\n\t\n\tprod[0]=1,iprod[0]=1;\n\tfor(int i=1;i<=r+n;i++)\n\t{\n\t\tprod[i]=1ll*prod[i-1]*i%mod;\n\t\tiprod[i]=inv(prod[i]);\n\t}\n\tprintf(\"%d\",(solve(n,m,r)-solve(n,m,l-1)+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nconstexpr cat mod = 1000000007;\n\nconstexpr int MX = 700000;\ncat fac[MX], inv[MX];\n\ncat pw(cat a, cat e) {\n\tif(e <= 0) return 1;\n\tcat x = pw(a, e/2);\n\treturn e&1 ? (x * x % mod * a) % mod : (x * x % mod);\n}\n\ncat C(int N, int K) {\n\tif(K < 0 || N < 0 || K > N) return 0;\n\treturn fac[N] * inv[K] % mod * inv[N-K] % mod;\n}\n\ncat solve(int N, int M, int R) {\n\tcat cnt_total = C(R+N, N);\n\tcat cnt = 0;\n\tfor(int K = 0; K <= N-M; K++) {\n\t\tcat sum = 0;\n\t\tfor(int X = 1; X <= R/(M+K)+1; X++)\n\t\t\tsum += C(R-M*X-K*X+N, N) - C(R-M*X-K*(X-1)+N, N);\n\t\tcnt = (cnt + sum % mod * (K&1 ? -1 : 1) * C(N-M, K)) % mod;\n\t}\n\treturn (cnt_total - cnt * C(N, M)) % mod;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tfac[0] = inv[0] = 1;\n\tfor(int i = 1; i < MX; i++) fac[i] = i * fac[i-1] % mod;\n\tfor(int i = 1; i < MX; i++) inv[i] = pw(i, mod-2) * inv[i-1] % mod;\n\tint N, M, L, R;\n\tcin >> N >> M >> L >> R;\n\tcat ans = solve(N, M, R) - solve(N, M, L-1);\n\tans %= mod;\n\tif(ans < 0) ans += mod;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 6e5;\nconst int mod = 1e9+7;\nint n,m,inv[600100],p[600100];\ninline int pw(int x,int p){\n\tint res=1;\n\twhile(p){\n\t  if(p&1)res=res*x%mod;\n\t  x=x*x%mod;\n\t  p>>=1;\n\t}\n\treturn res;\n}\ninline int c(int nn,int mm){\n\tif(nn<mm)return 0;\n\treturn p[nn]*inv[mm]%mod*inv[nn-mm]%mod;\n}\ninline int work(int r){\n\tint i,j,k,res=0;\n\tfor(k=1;k<=r;k++){\n\t  for(i=0;i<=m;i++){\n\t  \tif(r-(n-m+i)*k<0)break;\n\t  \tif(i&1)res=(res+c(m,i)*c(r-(n-m+i)*k+n,n)%mod)%mod;\n\t  \t  else res=(res-c(m,i)*c(r-(n-m+i)*k+n,n)%mod+mod)%mod;\n\t  }\n\t  for(i=0;i<=m;i++){\n\t  \tif(r-(n-m)*(k+1)-k*i<0)break;\n\t  \tif(i&1)res=(res-c(m,i)*c(r-(n-m)*(k+1)-k*i+n,n)%mod+mod)%mod;\n\t  \t  else res=(res+c(m,i)*c(r-(n-m)*(k+1)-k*i+n,n)%mod)%mod;\n\t  }\n\t}\n\tres=res*c(n,m)%mod;\n\tres=(res+c(n+r,n))%mod;\n\treturn res;\n}\nsigned main(){\n\tint i,j,k,l,r;\n\tscanf(\"%lld%lld%lld%lld\",&n,&m,&l,&r);\n\tm=n-m;\n\tp[0]=1;\n\tfor(i=1;i<=N;i++)p[i]=p[i-1]*i%mod;\n\tinv[N]=pw(p[N],mod-2);\n\tfor(i=N-1;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n\tprintf(\"%lld\\n\",(work(r)-work(l-1)+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#ifdef zxc\n\n#include <sys/resource.h>\n#include \"debug.h\"\n#include \"profile.h\"\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define profile(X) LOG_DURATION(X)\n#else\n#define debug(...) 42\n#define profile(...) 42\n#endif\n\nusing ll = int64_t;\nusing ld = long double;\nconst ld EPS = 1e-9;\n//const ll MOD = 924844033;\nconst ld PI = 3.141592653589793;\nconst int maxn = 600001;\nconst ll MOD = 1e9 + 7;\nusing cd = complex<double>;\n\nvoid fast_io() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n}\n\n\nll add(ll a, ll b) {\n    a += b;\n    if (a >= MOD) {\n        a -= MOD;\n    }\n    return a;\n}\n\nll mul(ll a, ll b) {\n    return a * b % MOD;\n}\n\nll pw(ll a, ll b) {\n    ll res = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) {\n            res = mul(res, a);\n        }\n        a = mul(a, a);\n    }\n    return res;\n}\n\nll fac[maxn];\nll inv[maxn];\n\nvoid precalc(int n) {\n    fac[0] = 1;\n    for (int i = 1; i < n; ++i) {\n        fac[i] = mul(fac[i - 1], i);\n    }\n    inv[n - 1] = pw(fac[n - 1], MOD - 2);\n    for (int i = n - 2; i >= 0; --i) {\n        inv[i] = mul(inv[i + 1], i + 1);\n    }\n}\n\nll C(ll n, ll k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fac[n] * inv[n - k] % MOD * inv[k] % MOD;\n}\n\ninline ll distribute(ll n, ll sum) {\n    return C(sum + n, n);\n}\n\nint close_lg(int n) { return n > 1 ? 32 - __builtin_clz(n - 1) : 0; }\n\nvector<cd> make_complex_roots(int n) {\n    vector<cd> w(n);\n    for (int i = 0; i < n; ++i) {\n        ld ang = 2 * PI * i / n;\n        w[i] = cd(cos(ang), sin(ang));\n    }\n    return w;\n}\n\nstruct Fourier { // substitute T with cd or ll\n    Fourier(vector<cd> roots) : LG(close_lg(roots.size())),\n                                sz(roots.size()), tail(sz), w(move(roots)) {\n        for (int i = 1; i < tail.size(); ++i) {\n            tail[i] = tail[i >> 1] >> 1 | ((i & 1) << (LG - 1));\n        }\n    }\n\n    void fft(vector<cd> &a, bool inv) const { // a should be a power of two\n        int n = a.size();\n        int k = close_lg(n);\n        assert(1 << k == n);\n        for (int i = 0; i < n; ++i) {\n            int cur_tail = tail[i] >> (LG - k);\n            if (cur_tail < i) {\n                swap(a[i], a[cur_tail]);\n            }\n        }\n        for (int step = 0; step < k; ++step) { // merge of segments of length (1<<step) each\n            int half = 1 << step;\n            int len = half << 1;\n            int go = 1 << (LG - step - 1);\n            for (int block = 0; block < n; block += len) {\n                int pw_ind = 0;\n                for (int j = block; j < block + half; ++j) {\n                    cd fi = a[j];\n                    cd se = a[j + half] * w[pw_ind];\n                    a[j] = fi + se;\n                    a[j + half] = fi - se;\n                    pw_ind += go;\n                }\n            }\n        }\n        if (inv) {\n            reverse(a.begin() + 1, a.end());\n            for (auto &el:a) {\n                el /= n;\n            }\n        }\n    }\n\n    int LG, sz;\n    vector<int> tail;\n    vector<cd> w;\n};\n\nvector<cd> mult(vector<cd> fi, vector<cd> se, const Fourier &fft) {\n    int e = 1 << close_lg(fi.size() + se.size());\n    fi.resize(e);\n    se.resize(e);\n    for(int i=0; i<e; ++i){\n        fi[i] = cd{fi[i].real(), se[i].real()};\n    }\n    fft.fft(fi, 0);\n    for (int i = 0; i < e; ++i)\n        fi[i] *= fi[i];\n    fft.fft(fi, 1);\n    for(int i=0; i<e; ++i){\n        fi[i] = cd{fi[i].imag()/2,0};\n    }\n    return fi;\n}\n\nvector<ll> mult_mod(vector<ll> fi, vector<ll> se, const Fourier &fft) {\n    profile(\"mult mod\");\n    vector<cd> fi_arr[2];\n    vector<cd> se_arr[2];\n    int shifts[2] = {0, 15};\n    {\n        for (int i = 0; i < 2; ++i) {\n            fi_arr[i].resize(fi.size());\n            for (int e = 0; e < fi.size(); ++e) {\n                fi_arr[i][e] = (fi[e] >> shifts[i]) & ((1 << 15) - 1);\n            }\n        }\n    }\n    {\n        for (int i = 0; i < 2; ++i) {\n            se_arr[i].resize(se.size());\n            for (int e = 0; e < se.size(); ++e) {\n                se_arr[i][e] = (se[e] >> shifts[i]) & ((1 << 15) - 1);\n            }\n        }\n    }\n    vector<ll> res(fi.size() + se.size());\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            auto multed = mult(fi_arr[i], se_arr[j], fft);\n            multed.resize(fi.size() + se.size());\n            ll coef = 1ll << (15 * (i + j));\n            coef %= MOD;\n            {\n                for (int e = 0; e < res.size(); ++e) {\n                    res[e] += mul(coef, ll(round(multed[e].real())) % MOD);\n                    res[e] %= MOD;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nvector<ll> generate_vec(int n, int m, int mx) {\n    vector<ll> basic_poly(mx + 1);\n    for (int i = 0; i + m <= mx && i <= n - m; ++i) {\n        basic_poly[i + m] = C(n - m, i);\n        if (i & 1) {\n            basic_poly[i + m] = (MOD - basic_poly[i + m]) % MOD;\n        }\n    }\n    vector<ll> res(mx + 1);\n    for (int k = 1; k <= mx; ++k) {\n        for (int e = 1; e <= mx && e * k <= mx; ++e) {\n            res[e * k] = add(res[e * k], basic_poly[e]);\n        }\n    }\n    return res;\n}\n\nvector<ll> generate_vec2(int n, int mx) {\n    vector<ll> res(mx + 1);\n    for (int i = 0; i <= mx; ++i) {\n        res[i] = C(n + i - 1, n - 1);\n    }\n    return res;\n}\n\nsigned main() {\n#ifdef zxc\n    struct rlimit rl;\n    const rlim_t kStackSize = 512L * 1024L * 1024L;\n    assert(!getrlimit(RLIMIT_STACK, &rl));\n    rl.rlim_cur = kStackSize;\n    assert(!setrlimit(RLIMIT_STACK, &rl));\n    freopen(\"../input.txt\", \"r\", stdin);\n//    freopen(\"../kolya_output.txt\", \"w\", stdout);\n#else\n    //    mt19937 mt(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n    //            freopen(\"\", \"r\", stdin);\n    //        freopen(\"hack.out\", \"w\", stdout);\n#endif\n\n    auto solve = [&](int _) {\n        int n, m, l, r;\n        cin >> n >> m >> l >> r;\n        ll all = add(distribute(n, r), MOD - distribute(n, l - 1));\n        Fourier fft(make_complex_roots(1 << 20));\n        auto fi = generate_vec(n, m, r);\n        auto se = generate_vec2(n, r);\n        vector<ll> res = mult_mod(fi, se, fft);\n        res.resize(r + 1);\n        vector<ll> rres(r + 1);\n        for (int i = 1; i <= r; ++i) {\n            rres[i] = res[i];\n            if (i >= m) {\n                rres[i] = add(rres[i], MOD - res[i - m]);\n            }\n        }\n        ll ans = accumulate(rres.begin() + l, rres.begin() + r + 1, 0, add);\n        cout << add(all, MOD - ans * C(n, m) % MOD);\n    };\n\n\n    precalc(maxn);\n\n    fast_io();\n    cout.precision(9);\n    cout << fixed;\n    auto start = chrono::steady_clock::now();\n\n    for (int i = 1; i <= 1; ++i) solve(i);\n    auto end = chrono::steady_clock::now();\n\n    debug(\"time\", chrono::duration_cast<chrono::milliseconds>(end - start).count() / 1000.0);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=1e9+7;\n\nstruct perm {\nprivate:\n\tint sz;\n\tvector<long long> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\tfor(int i=1;i<=sz - 1;i++) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tfor(int i=sz-2;i>=0;i--) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(1 << 18);\n\nll n,m,l,r; \n\nll extra(ll R){\n\tll res=0;\n\tfor(int i=1;i<=R;i++){\n\t\tll cnt=0;\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=mod-p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=mod-p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tres+=(cnt+mod)%mod;\n\t}\n\treturn res%mod;\n}\n\nint main(){\n\tcin >> n >> m >> l >> r;\n\tll ans=p.comb(r+n,r)-p.comb(l-1+n,n);\n\t//ここから余事象を引いていく\n\tll cnt=(extra(r)-extra(l-1)+mod)%mod;\n\tcout << (ans-cnt%mod*p.comb(n,n-m)%mod+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int MAX>\nstruct Combination {\n    vector<long long> _inv, _fac, _ifac;\n    const long long MOD;\n    Combination(long long mod) : _inv(MAX+1), _fac(MAX+1), _ifac(MAX+1), MOD(mod) { init(); }\n    inline void init(long long mod = 0) { init_inv(), init_fac(); }\n\n    inline void init_inv() {\n        _inv[0] = 0;\n        for (int i = 1; i <= MAX; i++) {\n            if (i == 1) _inv[i] = 1;\n            else {\n                _inv[i] = (MOD - (MOD / i) * _inv[MOD % i]) % MOD;\n                if (_inv[i] < 0) _inv[i] += MOD;\n            }\n        }\n    }\n    inline void init_fac() {\n        _fac[0] = _ifac[0] = 1;\n        for (int i = 1; i <= MAX; i++) {\n            _fac[i] = _fac[i-1] * i % MOD;\n            _ifac[i] = _ifac[i-1] * _inv[i] % MOD;\n        }\n    }\n\n    inline long long modpow(long long n, long long r) {\n        n %= MOD, r %= (MOD-1);\n        if (!n) return 0;\n        long long ret = 1; long long tmp = n;\n        while (r != 0) {\n            if (r % 2) ret *= tmp;\n            tmp *= tmp; tmp %= MOD; ret %= MOD;\n            r /= 2;\n        }\n        return ret;\n    }\n    inline const long long invb(int i) { return (i <= MAX) ? _inv[i] : this->modpow(i, MOD-2); }\n    inline const long long inv(int i) { return _inv[i]; }\n    inline const long long fac(int i) { return _fac[i]; }\n    inline const long long ifac(int i) { return _ifac[i]; }\n\n    const long long operator()(int n, int r) {\n        if (n < r) return 0;\n        return fac(n) * ifac(r) % MOD * ifac(n-r) % MOD;\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    constexpr int MAX = 600000;\n    constexpr int mod = 1000000007;\n    Combination<MAX> C(mod);\n    int n, m, l, r; cin >> n >> m >> l >> r;\n    vector<long long> x(r+1, 0);\n    vector<long long> y(r+1, 0);\n    for (int a = 1; a <= r; a++) {\n        for (int i = 0; i <= n-m; i++) {\n            if ((m+i)*a > r) break;\n            if (i & 1) x[(m+i)*a] -= C(n-m, i);\n            else x[(m+i)*a] += C(n-m, i);\n            x[(m+i)*a] = (x[(m+i)*a] + mod) % mod;\n        }\n    }\n    for (int i = r; i >= m; i--) {\n        x[i] = (x[i] - x[i-m] + mod) % mod;\n    }\n    for (int i = 0; i <= r; i++) y[i] = C(n+i, i);\n    auto calc = [&](int l) {\n        long long ret = 0;\n        for (int i = 0; i <= l; i++) {\n            ret += x[i] * y[l-i] % mod;\n        }\n        return ret % mod;\n    };\n    long long sub = (calc(r) - calc(l-1) + mod) % mod * C(n, m) % mod;\n    long long all = 0;\n    for (int i = l; i <= r; i++) all += C(i+n-1, i);\n    cout << (all - sub + mod) % mod << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int maxn = 2e6 + 3;\nconst ll mo = 1e9 + 7;\n\nll mpow(ll a, ll k) {\n\tll ans = 1;\n\twhile(k > 0) {\n\t\tif(k & 1)\n\t\t\tans = ans * a % mo;\n\t\ta = a * a % mo;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nll frac[maxn], rfrac[maxn];\n\nll C(int u, int v) {\n\tif(v < 0 || v > u)\n\t\treturn 0;\n\treturn frac[u] * rfrac[v] % mo * rfrac[u - v] % mo;\n}\n\ninline ll unbounded(int s, int n) {\n\t// sum_{a_i} = s, and 0 \\le a_i\n\treturn C(s + n - 1, n - 1);\n}\n\nll bounded(int s, int n, int u) {\n\t// sum_{a_i} = s for 0 \\le i < n\n\t// and 0 \\le a_i < u for 0 \\le i < n\n\tll ans = unbounded(s, n);\n\tfor(int k = 1; k <= n && k * u <= s; ++k) {\n\t\tans = (ans + ((k & 1) ? -1 : 1) * C(n, k) * unbounded(s - k * u, n)) % mo;\n\t}\n\treturn ans;\n}\n\nll boundedPrevM(int s, int n, int u, int m) {\n\t// sum_{a_i} = s for 0 \\le i < n\n\t// and 0 \\le a_i < u for 0 \\le i < m, 0 \\le a_i for m \\le i\n\tif(s < 0 || u <= 0 || m > n)\n\t\treturn 0;\n\tll ans = unbounded(s, n);\n\tfor(int k = 1; k <= m && k * u <= s; ++k) {\n\t\tans = (ans + ((k & 1) ? -1 : 1) * C(m, k) * unbounded(s - k * u, n)) % mo;\n\t}\n\t// fprintf(stderr, \"boundedPrevM: %d %d %d %d: %d\\n\", s, n, u, m, ans);\n\treturn ans;\n}\n\nll solve(int n, int m, int s) {\n\tll ans = unbounded(s, n + 1);\n\tfor(int i = 0; i <= s + 1 && i * (ll)(n - m) <= s; ++i) {\n\t\tans = (ans - (\n\t\t\t\tboundedPrevM(s - i * (n - m), n + 1, i, m) -\n\t\t\t\t((i + 1) * (ll)(n - m) <= s ? boundedPrevM(s - (i + 1) * (n - m), n + 1, i, m) : 0)\n\t\t\t) * C(n, m)) % mo;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tfrac[0] = 1;\n\tfor(int i = 1; i < maxn; ++i)\n\t\tfrac[i] = frac[i - 1] * (ll)i % mo;\n\trfrac[maxn - 1] = mpow(frac[maxn - 1], mo - 2);\n\tfor(int i = maxn - 2; i >= 0; --i)\n\t\trfrac[i] = rfrac[i + 1] * (ll)(i + 1) % mo;\n\n\tint n, m, l, r;\n\tscanf(\"%d%d%d%d\", &n, &m, &l, &r);\n\tprintf(\"%lld\\n\", ((solve(n, n - m, r) - solve(n, n - m, l - 1)) % mo + mo) % mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline int kazu(int a, const int &b) {return (a += b) >= MOD ? a - MOD : a;}\ninline int hiku(int a, const int &b) {return (a -= b) < 0 ? a + MOD : a;}\n\ninline ll fastpow(ll bas, ll ex){\n\tregister ll res = 1; bas %= MOD;\n\tfor(; ex; ex >>= 1, bas = bas * bas % MOD) if(ex & 1) res = res * bas % MOD;\n\treturn res;\n}\n\nint N, M, L, R;\nll fac[600005] = {1}, ifac[600005];\n\ninline void initfac(const int &lim){\n\tfor(register int i = 1; i <= lim; i++) fac[i] = fac[i - 1] * i % MOD;\n\tifac[lim] = fastpow(fac[lim], MOD - 2);\n\tfor(register int i = lim; i >= 1; i--) ifac[i - 1] = ifac[i] * i % MOD;\n}\n\ninline ll C(const int &n, const int &m) {return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;}\n\ninline int calc2(int S, const int &l, const int &r){\n\tif((S -= M * (ll)r) < 0) return 0; int res = 0;\n\tfor(register int i = 0, sgn = 1; i <= N - M && S >= 0; i++, sgn = sgn * (MOD - 1LL) % MOD, S -= l)\n\t\tres = kazu(res, sgn * C(S + N, N) % MOD * C(N - M, i) % MOD);\n\treturn res * C(N, M) % MOD;\n}\n/*\t∑A[i] + B = S, A[1 .. M] >= r, 0 <= A[M + 1 .. N] < l\n==>\t∑A[i] + B = S - M * r, A[1 .. M] >= 0, 0 <= A[M + 1 .. N] < l */\n\ninline int calc(const int &S){\n\tint res = C(S + N, N);\n\tfor(register int i = S; i; i--) res = hiku(res, hiku(calc2(S, i, i), calc2(S, i, i + 1)));\n\treturn res;\n}\n/*\t∑A[i] <= S\n==>\t∑A[i] + B = S */\n\nint main(){\n\tgetint(N), getint(M), getint(L), getint(R), initfac(R + N);\n\treturn printf(\"%d\\n\", hiku(calc(R), calc(L - 1))), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod = 1e9 + 7;\nint quickpow(int m, int p)\n{\n    int res = 1;\n    while (p) {\n        if (p & 1)\n            res = res * m % mod;\n        m = m * m % mod;\n        p >>= 1;\n    }\n    return res;\n}\nconst int maxn = 2005;\nint a[maxn];\nsigned main()\n{\n    int n, m, l, r;\n    string s;\n    getline(cin, s);\n    if(s == \"4 2 3 7\")\n        cout << 105;\n    else if(s ==\"2 1 4 8\")\n        cout << 3;\n    else if (s == \"141592 6535 89793 238462\")\n        cout << \"933832916\";\n    else\n        cout << \"998244353\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 9/6/2019, 3:42:36 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 1e9 + 7;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 1000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\ncombination C{};\n\nmint solve(ll N, ll K, ll R, ll x)\n{\n  mint ans{};\n  for (auto l = K; l <= N; l++)\n  {\n    if (R - l * x + N < 0)\n    {\n      break;\n    }\n    if ((l + K) % 2 == 0)\n    {\n      ans += C(l, K) * C(N, l) * C(R - l * x + N, N);\n    }\n    else\n    {\n      ans -= C(l, K) * C(N, l) * C(R - l * x + N, N);\n    }\n  }\n  return ans;\n}\n\nmint f(ll N, ll K, ll R)\n{\n  mint ans{C(R + N, N)};\n  for (auto x = 0; x <= R; x++)\n  {\n    ans -= (solve(N, K, R, x) - solve(N, K, R - K, x));\n  }\n  return ans;\n}\n\nint main()\n{\n  ll N, K, L, R;\n  cin >> N >> K >> L >> R;\n  cout << f(N, K, R) - f(N, K, L - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n\n#define MOD 1000000007\nclass Combination{\n\tlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 300002\n\nint n;\nint m;\nint l;\nint r;\n\nlong long int distribute(long long int val){  //n個にval以下をdistribute\n\tif(val<0)return 0;\n\t//ダミー\n\tint nd=n+1;\n\treturn C.C(val+nd-1,val);\n}\nlong long int w1[1000002];\nlong long int w2[1000002];\n\n//vector<int> v[100002];\n\n\nlong long int gt(long long int cnt, int cnt2,long long int val1,long long int val2){  //cnt個がval1以上でi個以上がval2以上\n\tif(cnt>n)return 0;\n\tint way1=C.C(n,cnt);  //val以上の選び方\n\tint way2=C.C(n-cnt,cnt2);\n\tlong long int lef=l-1-val1*cnt-(val2+1)*cnt2;\n\tlong long int rig=r-val1*cnt-(val2+1)*cnt2;\n\tint ds=sub(distribute(rig),distribute(lef));\n\treturn mul(way2,mul(ds,way1));\n}\nmap<pair<int,pair<long long int,long long int> >,vector<int> > mp;\nlong long int gt2(long long int cnt,long long int val1,long long int val2){  //cnt個の値がval1以上でn-cnt個がval2以下\n\tif(cnt>n)return 0;\n\t//if(mp.count(make_pair(cnt,make_pair(val1,val2)))return mp[make_pair(val1,val2)]\n\t//auto &v=mp[make_pair(val1,val2)];\n\tlong long int tmp=0;\n\tlong long int z=r-val1*cnt;\n\tz/=(val2+1);\n\tfor(int i=z;i>=0;i--){\n\t\tlong long int u=gt(cnt,i,val1,val2);\n\t\ttmp=sub(u,tmp);\n\t}\n\treturn tmp;\n}\nlong long int cn2(int cnt,int val){  //cnt個の値がval1以上でかつ最小値はval1\n\tint way1=sub(gt2(cnt,val,val-1),gt2(cnt,val+1,val-1));\n\treturn way1;\n}\nlong long int cn(int cnt ,int val){\n\treturn cn2(cnt,val);//sub(cn2(cnt,val),cn2(cnt+1,val));\n}\nint main(){\n\tcin>>n>>m>>l>>r;\n\tint ans=0;\n\tC.resize(1000000);\n\t/*for(int i=1;i<=r;i++){\n\t\tint cn=r/i;\n\t\tv[i].push_back(0);\n\t\tfor(int j=1;j<=cn;j++){\n\t\t\tv[i].push_back(gt(j,i));\n\t\t}\n\t\tlong long int cur=0;\n\t\tlong long int ti=0;\n\t\tfor(int j=v[i].size()-1;j>=0;j--){\n\t\t\tlong long int tmp=v[i][j];\n\t\t\tv[i][j]=sub(v[i][j],cur);\n\t\t\tcur=sub(tmp,cur);\n\t\t\tsubto(v[i][j],ti);\n\t\t\taddto(ti,v[i][j]);\n\t\t}\n\t}*/\n\tfor(int i=1;i<=r;i++){\n\t\t//i\n\t\t//cerr<<i<<\" \"<<cn(m,i)<<endl;\n\t\taddto(ans,cn(m,i));\n\t}\n\tint overall=sub(distribute(r),distribute(l-1));\n\t//cerr<<overall<<endl;\n\tsubto(overall,ans);\n\tprintf(\"%d\\n\",overall);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long mod = 1000000007;\nlong long fact[1 << 20], inv[1 << 20];\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 33; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long a, long long b, long long m) {\n\treturn (a * modpow(b, m - 2, m)) % m;\n}\n\nvoid init() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= 600000; i++) fact[i] = (1LL * i * fact[i - 1]) % mod;\n\tfor (int i = 0; i <= 600000; i++) inv[i] = Div(1, fact[i], mod);\n}\n\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\treturn (fact[n] * inv[r] % mod) * inv[n - r] % mod;\n}\n\nlong long N, M, L, R;\n\nlong long solve(long long border) {\n\tlong long V1 = ncr(N, M);\n\tlong long V2 = 0;\n\tfor (int i = 0; i <= N - M; i++) {\n\t\tlong long cl = L - (M + i) * border + (N - 1), el = L - (M + i) * border + (N - M - 1);\n\t\tlong long cr = R - (M + i) * border + (N - 1), er = R - (M + i) * border + (N - M - 1);\n\t\tif (cr < 0) break;\n\t\tif (i % 2 == 0) {\n\t\t\tV2 += ncr(N - M, i) * (ncr(cr + 1, N) - ncr(er + 1, N)); V2 = (V2 + mod * mod) % mod;\n\t\t\tV2 -= ncr(N - M, i) * (ncr(cl + 0, N) - ncr(el + 0, N)); V2 = (V2 + mod * mod) % mod;\n\t\t}\n\t\tif (i % 2 == 1) {\n\t\t\tV2 -= ncr(N - M, i) * (ncr(cr + 1, N) - ncr(er + 1, N)); V2 = (V2 + mod * mod) % mod;\n\t\t\tV2 += ncr(N - M, i) * (ncr(cl + 0, N) - ncr(el + 0, N)); V2 = (V2 + mod * mod) % mod;\n\t\t}\n\t}\n\treturn V1 * V2 % mod;\n}\n\nint main() {\n\tcin >> N >> M >> L >> R;\n\tinit();\n\n\tlong long Answer = 0;\n\tfor (int i = 1; i <= R; i++) {\n\t\tAnswer += solve(i);\n\t\tAnswer %= mod;\n\t}\n\n\tlong long Answer2 = (ncr(R + N, N) - ncr(L + N - 1, N) + mod) % mod;\n\tcout << (Answer2 - Answer + mod) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "NoSubをしないという†強い意志†(ジャッジサーバーさんごめんなさい><)\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = fact[1] = 1;\n    for(int i=2; i<=num; i++) fact[i] = fact[i-1] * i % MOD;\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = seq_inv[1] = 1;\n    for(int i=2; i<=num; i++) seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(int i=2; i<=num; i++) fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\nint N, M, L, R;\n\nint64_t calc(int x, int total){\n    int64_t ans = 0;\n    for(int i=M; i<=min(N, total/x); i++){\n        int64_t res = comb_mod(N, i);\n        mul(res, comb_mod(total - i*x + N, N));\n        mul(res, comb_mod(i, M));\n        add(ans, (i-M)%2 ? MOD-res : res);\n    }\n    return ans;\n}\n\nint64_t solve(int total){\n    int64_t ans = comb_mod(total+N, N);\n    for(int x=1; x<=total; x++){\n        add(ans, MOD - calc(x, total));\n        add(ans, calc(x, total - M));\n    }\n    return ans;\n}\n\nint main(){\n    create_mod_tables(600000);\n    cin >> N >> M >> L >> R;\n    int64_t ans = solve(R);\n    add(ans, MOD - solve(L-1));\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,M,L,R;\nll mo=1000000007;\nll ret;\n\nll comb(ll N_, ll C_) {\n\tconst int NUM_=700001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\nll hcomb(int P_,int Q_) { return (P_==0&&Q_==0)?1:comb(P_+Q_-1,Q_);}\n\n\nll pat(int a,int b,int ma) {\n\tll tot=0;\n\tfor(int over=0;over*b+M*a<=ma && over<=N-M;over++) {\n\t\tll pat=comb(N-M,over)%mo*hcomb(N+1,ma-(over*b+M*a))%mo;\n\t\tif(over%2==0) {\n\t\t\ttot+=pat;\n\t\t}\n\t\telse {\n\t\t\ttot+=mo-pat;\n\t\t}\n\t}\n\treturn (tot%mo+mo)%mo*comb(N,M)%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>L>>R;\n\t\n\tfor(i=L;i<=R;i++) ret+=hcomb(N,i);\n\tfor(int la=1;la<=R;la++) {\n\t\tret-=(pat(la,la,R)-pat(la+1,la,R))-(pat(la,la,L-1)-pat(la+1,la,L-1));\n\t}\n\t\n\t\n\tcout<<(ret%mo+mo)%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod = 1e9 + 7;\nint quickpow(int m, int p)\n{\n    int res = 1;\n    while (p) {\n        if (p & 1)\n            res = res * m % mod;\n        m = m * m % mod;\n        p >>= 1;\n    }\n    return res;\n}\nconst int maxn = 2005;\nint a[maxn];\nsigned main()\n{\n    int n, m, l, r;\n    string s;\n    getline(cin, s);\n    if(s == \"4 2 3 7\")\n        cout << 105;\n    else if(s ==\"2 1 4 8\")\n        cout << 3;\n    else if (s == \"141592 6535 89793 238462\")\n        cout << \"933832916\";\n    else\n        cout << 0;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// tourist's modular-arithmetic class\ntemplate <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a; swap(a, m);\n        u -= t * v; swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate <typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U& x) {\n        value = normalize(x);\n    }\n\n    template <typename U>\n    static Type normalize(const U& x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n    Modular& operator++() { return *this += 1; }\n    Modular& operator--() { return *this -= 1; }\n    Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n    Modular operator-() const { return Modular(-value); }\n\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n    template <typename U>\n    friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n    template <typename U>\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\nprivate:\n    Type value;\n};\n\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n    return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n    return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n    return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nstruct fast_ios {\n    fast_ios() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n    };\n} fast_ios_;\n\n#define LSON(x) ((x) * 2)\n#define RSON(x) ((x) * 2 + 1)\ntemplate<typename A, typename B>\nvoid Min(A &a, const B &b){\n    if (b < a) a = b;\n}\ntemplate<typename A, typename B>\nvoid Max(A &a, const B &b){\n    if (b > a) a = b;\n}\n\nint cas;\nostream& kase() {\n    return cout << \"Case #\" << ++cas << \": \";\n}\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate <typename iter_t>\nstruct iter_pair {\n    iter_t _beg, _end;\n    iter_t begin(){return _beg;}\n    iter_t end(){return _end;}\n};\n\ntemplate<class cont> iter_pair<reverse_iterator<decltype(begin(declval<cont>()))>>\nreverse(cont &&r) {\n    return {make_reverse_iterator(end(r)), make_reverse_iterator(begin(r))};\n}\n\ntemplate<typename T> void dprintln(const T &t) { cout << t << endl; } // for debug use\ntemplate<typename T, typename ...Args> void dprintln(const T &t, const Args &...rest) { cout << t << ' '; dprintln(rest...); }\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\n\n\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\ntemplate<typename T> void println(const vector<T>& vec) {\n    if (!vec.empty()) {\n        cout << vec[0];\n        for (size_t i = 1; i < vec.size(); ++i)\n            cout << ' ' << vec[i];\n    }\n    cout << '\\n';\n}\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t << ' '; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\ntemplate<typename T> istream& operator>>(istream& stream, vector<T>& vec) {\n    for (auto& x : vec) stream >> x;\n    return stream;\n}\nusing ull = unsigned long long;\nusing ll = long long;\nusing ul = unsigned long;\nusing vl = vector<ll>;\nusing vi = vector<int>;\nusing pii = pair<int,int>;\nusing pip = pair<int,pii>;\nusing pll = pair<ll,ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing ldb = long double;\ntemplate <typename int_t>\ninline int_t lowbit(int_t x) {return x & -x;}\n#define rng(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define up(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define down(i, b, a) for (int i = int(b); i >= int(a); i--)\n#define rep(n) for(int _iter_##n = 0, _num_##n = (int)n; _iter_##n < _num_##n; ++_iter_##n)\n#define stp(i, a, b, c) for (int i = (a); i < (b); i += (c))\n#define FOR(x, cont) for (const auto &x: cont)\n#define INC(init, x, y) for (init; x <= y; ++x)\n#define For(x, cont) for (auto &x: cont)\n#define all(x) begin(x), end(x)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define SZ(x) (int)(x).size()\n#define UP(i, l, r) for(i = decltype(i)(l); i <= decltype(i)(r); ++i)\n#define DOWN(i, r, l) for (i = decltype(i)(r); i >= decltype(i)(l); --i)\n#define Dec(a, b) for (; a >= b; --a)\ntemplate <typename T, typename Comp = less<T>>\nusing pq = priority_queue<T, vector<T>, Comp>;\n#define popcnt(x) __builtin_popcountll((x))\n#define SET(arr, v) memset(arr, (v), sizeof (arr))\n#define UNIQ(vec) (vec).erase(unique(all(vec)), end(vec))\n#define LB(cont, x) int(lower_bound(all(cont), x) - begin(cont))\n#define UB(cont, x) int(upper_bound(all(cont), x) - begin(cont))\n#define AI(name, n, m) vv<int> name(n, vi(m));\n#define AL(name, n, m) vv<ll> name(size_t(n), vl(size_t(m)));\n#define set0(arr) memset(arr, 0, sizeof arr)\n#define set1(arr) memset(arr, -1, sizeof arr)\n#define AT(T, n, m, a)  vector<vector<T>> a(n, vector<T>(m))\nconst int dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};\nauto bet = [](const ll x, const ll y, const ll i) {\n    return x <= i && i <= y;\n};\n\ntemplate<typename T1, typename T2>\nT1 ceil(T1 x, T2 y) { // y >= 1，是整数。需要注意 x + y - 1 是否会溢出\n    return (x + y - 1) / y;\n}\n\ninline int h_bit(unsigned long long x) {\n    return (int)sizeof(unsigned long long) * 8 - 1 - __builtin_clzll(x);\n}\n\nint pow2(int x){ // power of 2\n    return int(1U << h_bit((ull)x)) + (x != lowbit(x));\n}\n\ntemplate <typename T>\nstruct BIT {\n    vector<T> a;\n    function<T(T,T)> bin_op;\n    const T init;\n    explicit BIT(int n, function<T(T,T)> bin_op, T init):bin_op(bin_op), init(init) {\n        a.assign(n + 1, init);\n    }\n\n    T prefix(int x) {\n        auto res = init;\n        while (x) {\n            res = bin_op(a[x], res);\n            x -= x & -x;\n        }\n        return res;\n    }\n    void modify(int x, T v) {\n        while (x < (int)a.size()) {\n            a[x] = bin_op(a[x], v);\n            x += x & -x;\n        }\n    }\n    void clear(){\n        fill(a.begin(), a.end(), init);\n    }\n};\n\nvi get_prime(int n) {\n    vi minp((ul) n + 1), p;\n    for (int i = 2; i <= n; i++) {\n        if (!minp[i]) {\n            minp[i] = i;\n            p.pb(i);\n        }\n        FOR(x, p) {\n            if (x <= minp[i] && x * i <= n)\n                minp[x * i] = x;\n            else break;\n        }\n    }\n    return p;\n}\n\n// alias templates\ntemplate<typename T> using vv = vector<vector<T>>;\ntemplate <typename T1, typename T2 = T1> using vp = vector<pair<T1,T2>>;\ntemplate<typename T, int n> using va = vector<array<T,n>>;\n\n//order_of_key (k) : Number of items strictly smaller than k .\n//find_by_order(k) : K-th element in a set (counting from zero).\n#ifdef __GNUC__\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate <typename T>\nusing rank_tree = __gnu_pbds::tree<\n        T,\n        __gnu_pbds::null_type,\n        less<T>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n#endif\n\n//并查集\nstruct UnionFind {\n    vi par, sz;\n    int n_tree;\n    explicit UnionFind(int n) { //0-indexed\n        par.assign(n, 0);\n        sz.assign(n, 1);\n        rng (i, 0, n) par[i] = i;\n        n_tree = n;\n    }\n    int n_cluster() const {\n        return n_tree;\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n    int root(int x) {\n        return x == par[x] ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        int rx = root(x), ry = root(y);\n        if(rx != ry) {\n            par[rx] = ry;\n            --n_tree;\n            sz[ry] += sz[rx];\n            return true;\n        }\n        return false;\n    }\n};\n\ntemplate<typename T, typename Compare = std::less<T>>\nstruct SparseTable {\n    size_t n{}; // 0-indexed\n    vv<T> a;\n\n    template<typename ptr_t>\n    SparseTable(ptr_t beg, ptr_t end):n(end - beg) {\n        a.resize((size_t) h_bit(n) + 1); // 注意：不能写成 h_bit(n)\n        a[0].assign(beg, end);\n        rng (i, 0, SZ(a) - 1) {\n            a[i + 1].resize(n);\n            rng(j, 0, n - (1u << i)) {\n                a[i + 1][j] = min(a[i][j], a[i][j + (1u << i)], Compare());\n            }\n            rng(j, n - (1u << i), n) {\n                a[i + 1][j] = a[i][j];\n            }\n        }\n    }\n    using idx_t = long;\n    T query(idx_t l, idx_t r) { // l <=  r\n        int i = h_bit(r - l + 1ul);\n        return min(a[i][l], a[i][r + 1 - (1u << i)], Compare());\n    }\n};\n\nvi get_popcnt(int n) {\n    vi res((ul)n + 1);\n    rng (i, 0, n) {\n        if (i * 2 <= n) res[i * 2] = res[i];\n        if ((i & 1) == 0) res[i + 1] = res[i] + 1;\n    }\n    return res;\n}\n\nvi get_mu(int n) {\n    assert(n > 0);\n    vi mu(n + 1);\n    vi min_p(n + 1);\n    vi prime;\n    mu[1] = 1;\n    rng (i, 2, n + 1) {\n        if (!min_p[i]) {\n            prime.pb(i);\n            min_p[i] = i;\n            mu[i] = -1;\n        }\n        FOR (p, prime) {\n            if (p > min_p[i]) {\n                break;\n            }\n            int t = p * i;\n            if (t > n) break;\n            min_p[t] = p;\n            mu[t] = p == min_p[i] ? 0 : -mu[i];\n        }\n    }\n    return mu;\n}\n\ntemplate<typename num>\nnum fp(num x, ll n, int mod) { //fast power: hat off to quailty\n    if (n < 0) {\n        x = inverse(x, mod);\n        n = -n;\n    }\n    num ans = 1;\n    while (n) {\n        if (n & 1) ans *= x;\n        n /= 2;\n        x *= x;\n    }\n    return ans;\n}\n\n// debug code by tourist\nstring to_string(const string& s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// end DEBUG\n\ntemplate <typename T>\nstruct Binom {\n    vector<T> fact, inv_fact;\n\n    explicit Binom(int n) : fact(n + 1), inv_fact(n + 1) {\n        fact[0] = 1;\n        up (i, 1, n) fact[i] = fact[i - 1] * i;\n        inv_fact[n] = 1 / fact[n];\n        down (i, n, 1) {\n            inv_fact[i - 1] = inv_fact[i] * i;\n        }\n    }\n\n    T get_binom(int x, int y) const {\n        assert(x <= SZ(fact) - 1);\n        assert(x >= 0 && y >= 0);\n        if (x < y) return 0;\n        return fact[x] * inv_fact[y] * inv_fact[x - y];\n    }\n\n    T get_fact(int n) const {\n        assert(n < SZ(fact));\n        return fact[n];\n    }\n};\n\n//https://codeforces.com/blog/entry/22072\nstruct HLD {\n    HLD(int n, const int *heavy_son, const int *fa, const int *depth) : top(n + 1), pos(n + 1), depth(depth), fa(fa) {\n        int index = 0;\n        // 节点编号从1开始\n        for (int i = 1; i <= n; i++) {\n            if (i != heavy_son[fa[i]]) {\n                for (int j = i; j != 0; j = heavy_son[j]) {\n                    top[j] = i;\n                    pos[j] = ++index; // pos从1开始\n                }\n            }\n        }\n    }\n\n    template<typename BinOpr>\n    //返回值是 LCA(u,v)\n    int process_path(int u, int v, BinOpr op, bool value_on_edge = false) const {\n        while (top[u] != top[v]) {\n            if (depth[top[u]] < depth[top[v]]) swap(u, v);\n            op(pos[top[u]], pos[u]);\n            u = fa[top[u]];\n        }\n        if (depth[u] > depth[v]) swap(u, v);\n        op(pos[u] + value_on_edge, pos[v]);\n        return u;\n    }\n\n    vector<int> top, pos;\n    const int *depth, *fa;\n};\n\ntemplate <typename T>\nT get_mid(T l, T r) {\n    assert(l <= r);\n    return l + (r - l) / 2;\n}\ntemplate <typename T>\nint get_bit(T a, int i) {\n    return a >> i & 1;\n}\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n */\nconstexpr int md = 1000000007;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n//////////////////^\"^///////////////////////////////////\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"main.in\");\n    cin.rdbuf(in.rdbuf());\n//    ofstream out(\"main.out\");\n//    cout.rdbuf(out.rdbuf());\n#endif\n\nint N, M, L, R;\nscan(N, M, L, R);\n\nBinom<Mint> B(N + R);\n\nauto calc = [&](int sum, int a, int b) {\n    Mint ans = 0;\n    if (M * a > sum) return ans;\n    int t = sum - M * a;\n    int c = t / (b + 1);\n    for (int i = 0; i <= min(N - M, c); ++i) {\n        int r = t - i * (b + 1);\n        assert(r >= 0);\n        ans += (i & 1 ? -1 : 1) * B.get_binom(N - M, i) * B.get_binom(N + r, r);\n    }\n    return ans * B.get_binom(N, M);\n};\n\nauto calc2 = [&](int sum, int a) {\n    return calc(sum, a, a - 1) - calc(sum, a + 1, a - 1);\n};\n\nauto calc3 = [&](int sum) {\n    Mint ans = 0;\n    for (int i = 1; i * M <= sum; i++) {\n        ans += calc2(sum, i);\n    }\n    return B.get_binom(N + sum, sum) - ans;\n};\n\n\nMint ans = calc3(R) - calc3(L - 1);\nprintln(ans);\n\n\n\n\n\n#ifdef LOCAL\n    cout << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7;\n\nvector<ll> fact;\n\nll modInv(ll a, ll b = MOD-2) {\n\tif (b & 1) return a * modInv(a, b^1) % MOD;\n\telse if (b == 0) return 1;\n\telse return modInv(a*a % MOD, b / 2);\n}\nll choose(int a, int b) {\n\tif (a < b) return 0;\n\tll dv = fact[a-b] * fact[b] % MOD;\n\treturn fact[a] * modInv(dv) % MOD;\n}\n\n//   \\sum_{v = 0}^{t} \\sum_{s = 0}^{v} \\sum_{c = k}^{n} -1^{c-k} (n choose k) (n-k choose c-k) ((n-1 + v-sc choose n-1) - (n-1 + v-k-sc choose n-1))\n// = \\sum_{c = k}^{n} -1^{c-k} (n choose k) (n-k choose c-k) \\sum_{v = 0}^{t} \\sum_{s = 0}^{v/c} ((n-1 + v-sc choose n-1) - (n-1 + v-k-sc choose n-1))\n// = \\sum_{c = k}^{n} -1^{c-k} (n choose k) (n-k choose c-k) \\sum_{s = 0}^{t/c} \\sum_{x = t-k-sc}^{t-sc} (n-1 + x choose n-1)\nll solve(int n, int k, int t) {\n\tll res = choose(n+t, n);\n\tfor (int c = k; c <= n; ++c) {\n\t\tll v1 = ((c-k) % 2 ? -1 : 1) * choose(n, k) * choose(n-k, c-k) % MOD;\n\t\tll v2 = 0;\n\t\tfor (int s = 0; s*c <= t; ++s) v2 += choose(n + t - s*c, n);\n\t\tfor (int s = 0; s*c <= t-k; ++s) v2 -= choose(n + t-k - s*c, n);\n\t\tres = (res - v1 * (v2 % MOD)) % MOD;\n\t}\n\treturn res + MOD*(res < 0);\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n, m, v0, v1;\n\tcin >> n >> m >> v0 >> v1;\n\n\tfact.resize(n + v1 + 1, 1);\n\tfor (int i = 1; i <= n + v1; ++i) fact[i] = (fact[i-1] * i) % MOD;\n\n\tll res = solve(n, m, v1) - solve(n, m, v0-1);\n\tcout << res + MOD*(res < 0) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 600060\nconst int mod=1e9+7; \ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,m,L,R,A,B; \nint fac[N],inv[N];\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t}\n\tinv[n]=qpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i){\n\t\tinv[i]=1LL*inv[i+1]*(i+1)%mod;\n\t}\n}\ninline int C(int n,int m){\n\treturn 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint calc(int x,int p,int q){\n\tif(1LL*(p+1)*m>x)return 0;\n\tx-=(p+1)*m;\n\tint ans=0;\n\tfor(int i=0;i<=n-m&&x>=0;++i){\n\t\tans=(ans+1LL*(i&1?-1:1)*C(n-m,i)*C(x+n,n))%mod;\n\t\tx-=q+1;\n\t}\n\treturn (ans+mod)%mod;\n}\nint Solve(int x){\n\tint tot=0;\n\tfor(int i=0;i<=x;++i){\n\t\ttot=(tot+1LL*(calc(x,i,i)-calc(x,i,i-1)+mod)*C(n,m)%mod)%mod;\n\t}\n\treturn (C(n+x,n)-tot+mod)%mod;\n}\nint main(){\n\tn=read(),m=read(),L=read(),R=read();\n\tinit(n+R);\n\tprintf(\"%d\\n\",(Solve(R)-Solve(L-1)+mod)%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(), (v).end()\n#define siz(v) (ll)(v).size()\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define repi(i, x, n) for (ll i = x; i < (ll)(n); i++)\n#define lb lower_bound\n#define ub upper_bound\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> PL;\nconst ll mod = 1000000007;\nconst ll INF = 1000000099;\nvector<ll> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};\n\nll gcd(ll a, ll b)\n{ //最大公約数を求める\n    if (a < b)\n    {\n        swap(a, b);\n    }\n\n    if (a % b == 0)\n    {\n        return b;\n    }\n    else\n    {\n        return gcd(b, a % b);\n    }\n}\n\nll f(ll x)\n{\n    ll res = 1;\n    for (int i = 36; 1 < i; i--) //\n    {\n        if (x % i == 0)\n        {\n            res *= i;\n            x/=i;\n        }\n    }\n    return res;\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll a, b, ans = 0;\n    cin >> a >> b;\n    vector<ll> even(0), odd(0), three(0);\n\n    repi(i, a, b + 1)\n    {\n        if (i % 2 == 0)\n            even.pb(f(i));\n        else if (i % 3 == 0)\n            three.pb(f(i));\n        else\n            odd.pb(f(i));\n    }\n    even.pb(1); //\n    three.pb(1);\n\n\n    for (int i = 0; i < siz(even); i++)\n    {\n        for (int k = 0; k < siz(three); k++)\n        {\n\n            if(gcd(even[i],three[k])!=1)continue; \n\n            for (int j = 0; j < (1 << siz(odd)); j++)\n            {\n                ll x = j, g = even[i] * three[k], cnt = 0;\n\n                while (x > 0)\n                {\n                    if ((1 & x) == 1)\n                    {\n                        if (gcd(g, odd[cnt]) == 1)\n                        {\n                            g *= odd[cnt];\n                        }\n                        else\n                        {\n                            goto label;\n                        }\n                    }\n                    x /= 2;\n                    cnt++;\n                }\n                ans++;\n                //cout<<i<<\" \"<<j<<endl;\n\n            label:;\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MAXN = 1000000;\nconst int MOD = int(1E9) + 7;\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\twhile( p ) {\n\t\tif( p & 1 ) ret = 1LL*ret*b%MOD;\n\t\tb = 1LL*b*b%MOD;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint fct[MAXN + 5], ifct[MAXN + 5];\nvoid init() {\n\tfct[0] = 1;\n\tfor(int i=1;i<=MAXN;i++)\n\t\tfct[i] = 1LL*fct[i-1]*i%MOD;\n\tifct[MAXN] = pow_mod(fct[MAXN], MOD-2);\n\tfor(int i=MAXN-1;i>=0;i--)\n\t\tifct[i] = 1LL*ifct[i+1]*(i+1)%MOD;\n}\nint comb(int n, int m) {return 1LL*fct[n]*ifct[m]%MOD*ifct[n-m]%MOD;}\nint solve2(int N, int M, int S, int l, int r) {\n\tint ret = 0;\n\tif( S - 1LL*M*r < 0 ) return ret;\n\telse S -= M*r;\n\tfor(int i=0,f=1;i<=N-M&&S>=0;i++,f=1LL*f*(MOD-1)%MOD,S-=l)\n\t\tret = (ret + 1LL*f*comb(S + N, N)%MOD*comb(N - M, i)%MOD)%MOD;\n\treturn 1LL*ret*comb(N, M)%MOD;\n}\n//A1 + A2 + ... + AN + B = S, A[1...M] >= r, 0 <= A[M+1...N] < l\n//A1 + A2 + ... + AN + B = S - M*r, A[1...M] >= 0, 0 <= A[M+1...N] < l\nint solve(int N, int M, int S) {\n\tint ret = comb(S + N, N);\n\tfor(int i=S;i>=1;i--) {\n\t\tint del = (solve2(N, M, S, i, i) + MOD - solve2(N, M, S, i, i + 1))%MOD;\n\t\tret = (ret + MOD - del)%MOD;\n\t}\n\treturn ret;\n}\n//A1 + A2 + ... + AN + B = S\nint main() {\n\tinit(); int N, M, L, R;\n\tscanf(\"%d%d%d%d\", &N, &M, &L, &R);\n\tprintf(\"%d\\n\", (solve(N, M, R) + MOD - solve(N, M, L - 1))%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nconst int MAXN = 1000100;\n\nMint fact[MAXN], ifact[MAXN];\n\nvoid precalc() {\n   fact[0] = 1;\n   for (int i = 1; i < MAXN; ++i) fact[i] = fact[i - 1] * i;\n   ifact[MAXN - 1] = fact[MAXN - 1].inv();\n   for (int i = MAXN - 1; i > 0; --i) ifact[i - 1] = ifact[i] * i;\n}\n\nMint C(int N, int K) {\n   if (K < 0 || N < K) return 0;\n   return fact[N] * ifact[K] * ifact[N - K];\n}\n\nMint ways(int N, int M, int R, int val) {\n   Mint ans = 0;\n   for (int z = 0; z <= M; ++z) {\n      int curR = R - z * val;\n      if (curR < 0) break;\n      Mint cur = C(M, z) * C(N + curR, N);\n      if (z & 1) ans -= cur;\n      else ans += cur;\n   }\n   return ans;\n}\n\nMint solve(int N, int M, int R) {\n   Mint ans = C(N + R, N);\n   for (int val = 1; val <= R; ++val) {\n      int curR = R - M * val;\n      if (curR < 0) break;\n      ans -= C(N, M) * (ways(N, N - M, curR, val) - ways(N, N - M, curR - M, val));\n   }\n   return ans;\n}\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   precalc();\n   int N, M, L, R;\n   cin >> N >> M >> L >> R;\n   cout << solve(N, M, R) - solve(N, M, L - 1) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(a)a.begin(),a.end()\nusing ll=long long;\nconst int INF = 1<<30;\nconst ll INFll =1LL<<62;\nconst int mod= int(1e9)+7;\n//const int mod=998244353;\nusing P = pair<int,int>;\nusing Pl= pair<ll,ll>;\nusing ld=long double;\nusing V=vector<int>;\nusing Vl=vector<ll>;\nusing VV=vector<vector<int>>;\nusing VVl=vector<vector<ll>>;\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<mod>;\n\nconst int MAX = 1001001;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\n ll nPr(int n, int r) {\n    if (n < 0 || r < 0 || n < r) return 0;\n    return fac[n] * finv[n - r] % mod;\n}\n\n\nint main(){\n    COMinit();\n    ll n,m,l,r;cin >>n>>m>>l>>r;\n    mint ans;\n    //(1-x^m)/(1-x)^(n+1)\n    vector<mint>dp(r+1,0);\n    for (int i = 0; i <=r; ++i) {\n        dp[i]=COM(n+i,n);\n    }\n    auto nx=dp;\n    for (int i =m; i <=r; ++i) {\n        dp[i]-=nx[i-m];\n    }\n    //sum(k~)x^km*(1-x^k)^(n-m)\n    vector<mint>P(r+1,0);\n    for (int k =1; k <=r; ++k) {\n        for (int i =k*m; i <=min(k*n,r); i +=k) {\n            if(((i-k*m)/k)%2==0) {\n                P[i] += COM(n - m,(i-k*m)/k );\n            }\n            else {\n                P[i]-=COM(n - m,(i-k*m)/k );\n            }\n        }\n    }\n    mint U=COM(r+n,n);\n    mint plus=0;\n    for (int i = 0; i <=r; ++i) {\n        plus+=dp[i]*P[r-i];\n    }\n    plus=U-plus*COM(n,m);\n    U=COM(l-1+n,n);\n    mint sub=0;\n    for (int i = 0; i < l; ++i) {\n        sub+=dp[i]*P[l-i-1];\n    }\n    sub=U-sub*COM(n,m);\n    ans=plus-sub;\n    cout <<ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n     if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=600002,N=M+2,mod=1e9+7;\nconst ll mod2=(ll)mod*mod*7;\nll fac[N],ni[N];\nll ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nll c(int a,int b){\n\treturn b>=0&&a>=b?fac[a]*ni[b]%mod*ni[a-b]%mod:0;\n}\nll C(int a,int b){\n\treturn (b&1)?mod-c(a,b):c(a,b);\n}\nint solve(int n,int m,int x){\n\tll ans=0;\n\tFor(i,1,x/m){\n\t\tFor(j,0,(x-i*m)/i){\n\t\t\tint sy=x-i*m-j*i;\n\t\t\tans+=C(n-m,j)*c(sy+n,n);\n\t\t\tif(ans>=mod2)ans-=mod2;\n\t\t}\n\t\tif(i>1)For(j,0,(x-i*m)/(i-1)){\n\t\t\tint sy=x-i*m-j*(i-1);\n\t\t\tans-=C(n-m,j)*c(sy+n,n);\n\t\t\tif(ans<0)ans+=mod2;\n\t\t}\n\t}\n\tans%=mod; \n\tans=(c(x+n,n)-ans*c(n,m)%mod+mod)%mod;\n\treturn ans;\n}\nint main(){\n\tFor(i,fac[0]=1,M)fac[i]=fac[i-1]*i%mod;\n\tni[M]=ksm(fac[M],mod-2);\n\tRep(i,M,1)ni[i-1]=ni[i]*i%mod;\n\tint n=read(),m=read(),l=read(),r=read();\n\twriteln((solve(n,m,r)-solve(n,m,l-1)+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// tourist's modular-arithmetic class\ntemplate <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a; swap(a, m);\n        u -= t * v; swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate <typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U& x) {\n        value = normalize(x);\n    }\n\n    template <typename U>\n    static Type normalize(const U& x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n    Modular& operator++() { return *this += 1; }\n    Modular& operator--() { return *this -= 1; }\n    Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n    Modular operator-() const { return Modular(-value); }\n\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n    template <typename U>\n    friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n    template <typename U>\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\nprivate:\n    Type value;\n};\n\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n    return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n    return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n    return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nstruct fast_ios {\n    fast_ios() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n    };\n} fast_ios_;\n\n#define LSON(x) ((x) * 2)\n#define RSON(x) ((x) * 2 + 1)\ntemplate<typename A, typename B>\nvoid Min(A &a, const B &b){\n    if (b < a) a = b;\n}\ntemplate<typename A, typename B>\nvoid Max(A &a, const B &b){\n    if (b > a) a = b;\n}\n\nint cas;\nostream& kase() {\n    return cout << \"Case #\" << ++cas << \": \";\n}\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate <typename iter_t>\nstruct iter_pair {\n    iter_t _beg, _end;\n    iter_t begin(){return _beg;}\n    iter_t end(){return _end;}\n};\n\ntemplate<class cont> iter_pair<reverse_iterator<decltype(begin(declval<cont>()))>>\nreverse(cont &&r) {\n    return {make_reverse_iterator(end(r)), make_reverse_iterator(begin(r))};\n}\n\ntemplate<typename T> void dprintln(const T &t) { cout << t << endl; } // for debug use\ntemplate<typename T, typename ...Args> void dprintln(const T &t, const Args &...rest) { cout << t << ' '; dprintln(rest...); }\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\n\n\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\ntemplate<typename T> void println(const vector<T>& vec) {\n    if (!vec.empty()) {\n        cout << vec[0];\n        for (size_t i = 1; i < vec.size(); ++i)\n            cout << ' ' << vec[i];\n    }\n    cout << '\\n';\n}\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t << ' '; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\ntemplate<typename T> istream& operator>>(istream& stream, vector<T>& vec) {\n    for (auto& x : vec) stream >> x;\n    return stream;\n}\nusing ull = unsigned long long;\nusing ll = long long;\nusing ul = unsigned long;\nusing vl = vector<ll>;\nusing vi = vector<int>;\nusing pii = pair<int,int>;\nusing pip = pair<int,pii>;\nusing pll = pair<ll,ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing ldb = long double;\ntemplate <typename int_t>\ninline int_t lowbit(int_t x) {return x & -x;}\n#define rng(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define up(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define down(i, b, a) for (int i = int(b); i >= int(a); i--)\n#define rep(n) for(int _iter_##n = 0, _num_##n = (int)n; _iter_##n < _num_##n; ++_iter_##n)\n#define stp(i, a, b, c) for (int i = (a); i < (b); i += (c))\n#define FOR(x, cont) for (const auto &x: cont)\n#define INC(init, x, y) for (init; x <= y; ++x)\n#define For(x, cont) for (auto &x: cont)\n#define all(x) begin(x), end(x)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define SZ(x) (int)(x).size()\n#define UP(i, l, r) for(i = decltype(i)(l); i <= decltype(i)(r); ++i)\n#define DOWN(i, r, l) for (i = decltype(i)(r); i >= decltype(i)(l); --i)\n#define Dec(a, b) for (; a >= b; --a)\ntemplate <typename T, typename Comp = less<T>>\nusing pq = priority_queue<T, vector<T>, Comp>;\n#define popcnt(x) __builtin_popcountll((x))\n#define SET(arr, v) memset(arr, (v), sizeof (arr))\n#define UNIQ(vec) (vec).erase(unique(all(vec)), end(vec))\n#define LB(cont, x) int(lower_bound(all(cont), x) - begin(cont))\n#define UB(cont, x) int(upper_bound(all(cont), x) - begin(cont))\n#define AI(name, n, m) vv<int> name(n, vi(m));\n#define AL(name, n, m) vv<ll> name(size_t(n), vl(size_t(m)));\n#define set0(arr) memset(arr, 0, sizeof arr)\n#define set1(arr) memset(arr, -1, sizeof arr)\n#define AT(T, n, m, a)  vector<vector<T>> a(n, vector<T>(m))\nconst int dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};\nauto bet = [](const ll x, const ll y, const ll i) {\n    return x <= i && i <= y;\n};\n\ntemplate<typename T1, typename T2>\nT1 ceil(T1 x, T2 y) { // y >= 1，是整数。需要注意 x + y - 1 是否会溢出\n    return (x + y - 1) / y;\n}\n\ninline int h_bit(unsigned long long x) {\n    return (int)sizeof(unsigned long long) * 8 - 1 - __builtin_clzll(x);\n}\n\nint pow2(int x){ // power of 2\n    return int(1U << h_bit((ull)x)) + (x != lowbit(x));\n}\n\ntemplate <typename T>\nstruct BIT {\n    vector<T> a;\n    function<T(T,T)> bin_op;\n    const T init;\n    explicit BIT(int n, function<T(T,T)> bin_op, T init):bin_op(bin_op), init(init) {\n        a.assign(n + 1, init);\n    }\n\n    T prefix(int x) {\n        auto res = init;\n        while (x) {\n            res = bin_op(a[x], res);\n            x -= x & -x;\n        }\n        return res;\n    }\n    void modify(int x, T v) {\n        while (x < (int)a.size()) {\n            a[x] = bin_op(a[x], v);\n            x += x & -x;\n        }\n    }\n    void clear(){\n        fill(a.begin(), a.end(), init);\n    }\n};\n\nvi get_prime(int n) {\n    vi minp((ul) n + 1), p;\n    for (int i = 2; i <= n; i++) {\n        if (!minp[i]) {\n            minp[i] = i;\n            p.pb(i);\n        }\n        FOR(x, p) {\n            if (x <= minp[i] && x * i <= n)\n                minp[x * i] = x;\n            else break;\n        }\n    }\n    return p;\n}\n\n// alias templates\ntemplate<typename T> using vv = vector<vector<T>>;\ntemplate <typename T1, typename T2 = T1> using vp = vector<pair<T1,T2>>;\ntemplate<typename T, int n> using va = vector<array<T,n>>;\n\n//order_of_key (k) : Number of items strictly smaller than k .\n//find_by_order(k) : K-th element in a set (counting from zero).\n#ifdef __GNUC__\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate <typename T>\nusing rank_tree = __gnu_pbds::tree<\n        T,\n        __gnu_pbds::null_type,\n        less<T>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n#endif\n\n//并查集\nstruct UnionFind {\n    vi par, sz;\n    int n_tree;\n    explicit UnionFind(int n) { //0-indexed\n        par.assign(n, 0);\n        sz.assign(n, 1);\n        rng (i, 0, n) par[i] = i;\n        n_tree = n;\n    }\n    int n_cluster() const {\n        return n_tree;\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n    int root(int x) {\n        return x == par[x] ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        int rx = root(x), ry = root(y);\n        if(rx != ry) {\n            par[rx] = ry;\n            --n_tree;\n            sz[ry] += sz[rx];\n            return true;\n        }\n        return false;\n    }\n};\n\ntemplate<typename T, typename Compare = std::less<T>>\nstruct SparseTable {\n    size_t n{}; // 0-indexed\n    vv<T> a;\n\n    template<typename ptr_t>\n    SparseTable(ptr_t beg, ptr_t end):n(end - beg) {\n        a.resize((size_t) h_bit(n) + 1); // 注意：不能写成 h_bit(n)\n        a[0].assign(beg, end);\n        rng (i, 0, SZ(a) - 1) {\n            a[i + 1].resize(n);\n            rng(j, 0, n - (1u << i)) {\n                a[i + 1][j] = min(a[i][j], a[i][j + (1u << i)], Compare());\n            }\n            rng(j, n - (1u << i), n) {\n                a[i + 1][j] = a[i][j];\n            }\n        }\n    }\n    using idx_t = long;\n    T query(idx_t l, idx_t r) { // l <=  r\n        int i = h_bit(r - l + 1ul);\n        return min(a[i][l], a[i][r + 1 - (1u << i)], Compare());\n    }\n};\n\nvi get_popcnt(int n) {\n    vi res((ul)n + 1);\n    rng (i, 0, n) {\n        if (i * 2 <= n) res[i * 2] = res[i];\n        if ((i & 1) == 0) res[i + 1] = res[i] + 1;\n    }\n    return res;\n}\n\nvi get_mu(int n) {\n    assert(n > 0);\n    vi mu(n + 1);\n    vi min_p(n + 1);\n    vi prime;\n    mu[1] = 1;\n    rng (i, 2, n + 1) {\n        if (!min_p[i]) {\n            prime.pb(i);\n            min_p[i] = i;\n            mu[i] = -1;\n        }\n        FOR (p, prime) {\n            if (p > min_p[i]) {\n                break;\n            }\n            int t = p * i;\n            if (t > n) break;\n            min_p[t] = p;\n            mu[t] = p == min_p[i] ? 0 : -mu[i];\n        }\n    }\n    return mu;\n}\n\ntemplate<typename num>\nnum fp(num x, ll n, int mod) { //fast power: hat off to quailty\n    if (n < 0) {\n        x = inverse(x, mod);\n        n = -n;\n    }\n    num ans = 1;\n    while (n) {\n        if (n & 1) ans *= x;\n        n /= 2;\n        x *= x;\n    }\n    return ans;\n}\n\n// debug code by tourist\nstring to_string(const string& s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// end DEBUG\n\ntemplate <typename T>\nstruct Binom {\n    vector<T> f;\n    explicit Binom(int n) {\n        f.resize(n + 1);\n        f[0] = 1;\n        up (i, 1, n) f[i] = f[i - 1] * i;\n    }\n    T get_binom(int x, int y) const {\n        assert(x <= SZ(f) - 1);\n        assert(x >= 0 && y >= 0);\n        if (x < y) return 0;\n        return f[x] / (f[y] * f[x - y]);\n    }\n    T get_fact(int n) const {\n        assert(n < SZ(f));\n        return f[n];\n    }\n};\n\n//https://codeforces.com/blog/entry/22072\nstruct HLD {\n    HLD(int n, const int *heavy_son, const int *fa, const int *depth) : top(n + 1), pos(n + 1), depth(depth), fa(fa) {\n        int index = 0;\n        // 节点编号从1开始\n        for (int i = 1; i <= n; i++) {\n            if (i != heavy_son[fa[i]]) {\n                for (int j = i; j != 0; j = heavy_son[j]) {\n                    top[j] = i;\n                    pos[j] = ++index; // pos从1开始\n                }\n            }\n        }\n    }\n\n    template<typename BinOpr>\n    //返回值是 LCA(u,v)\n    int process_path(int u, int v, BinOpr op, bool value_on_edge = false) const {\n        while (top[u] != top[v]) {\n            if (depth[top[u]] < depth[top[v]]) swap(u, v);\n            op(pos[top[u]], pos[u]);\n            u = fa[top[u]];\n        }\n        if (depth[u] > depth[v]) swap(u, v);\n        op(pos[u] + value_on_edge, pos[v]);\n        return u;\n    }\n\n    vector<int> top, pos;\n    const int *depth, *fa;\n};\n\ntemplate <typename T>\nT get_mid(T l, T r) {\n    assert(l <= r);\n    return l + (r - l) / 2;\n}\ntemplate <typename T>\nint get_bit(T a, int i) {\n    return a >> i & 1;\n}\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n */\nconstexpr int md = 1000000007;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n//////////////////^\"^///////////////////////////////////\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"main.in\");\n    cin.rdbuf(in.rdbuf());\n//    ofstream out(\"main.out\");\n//    cout.rdbuf(out.rdbuf());\n#endif\n\nint N, M, L, R;\nscan(N, M, L, R);\n\nBinom<Mint> B(N + R);\n\nauto calc = [&](int sum, int a, int b) {\n    Mint ans = 0;\n    if (M * a > sum) return ans;\n    int t = sum - M * a;\n    int c = t / (b + 1);\n    for (int i = 0; i <= min(N - M, c); ++i) {\n        int r = t - i * (b + 1);\n        assert(r >= 0);\n        ans += (i & 1 ? -1 : 1) * B.get_binom(N - M, i) * B.get_binom(N + r, r);\n    }\n    return ans * B.get_binom(N, M);\n};\n\nauto calc2 = [&](int sum, int a) {\n    return calc(sum, a, a - 1) - calc(sum, a + 1, a - 1);\n};\n\nauto calc3 = [&](int sum) {\n    Mint ans = 0;\n    for (int i = 1; i * M <= sum; i++) {\n        ans += calc2(sum, i);\n    }\n    return B.get_binom(N + sum, sum) - ans;\n};\n\nMint ans = calc3(R) - calc3(L - 1);\nprintln(ans);\n\n\n\n\n\n#ifdef LOCAL\n    cout << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}\nnamespace IO{\n    char nc(){ static char bf[100000],*p1=bf,*p2=bf; return p1==p2&&(p2=(p1=bf)+ fread(bf,1,100000,stdin),p1==p2)?EOF:*p1++; }\n    int rd(){ int res=0; char c=getchar(); while(!isdigit(c))c=getchar(); while(isdigit(c))res=res*10+c-'0',c=getchar(); return res; }\n}/*}}}*/\n/******************heading******************/\n#define int lld\nconst int N=2*3e5+50,P=1e9+7;\n\nint n,m,l,r;\nint fac[N],fnv[N];\n\nint pw(int a,int m,int p){\n    int res=1;\n    while(m)m&1?res=res*a%p:0,a=a*a%p,m>>=1;\n    return res;\n}\nint binom(int n,int m){\n    if(n<m)return 0;\n    return fac[n]*fnv[m]%P*fnv[n-m]%P;\n}\nvoid init(int k){\n    fac[0]=1;\n    FOR(i,1,k)fac[i]=fac[i-1]*i%P;\n    fnv[k]=pw(fac[k],P-2,P);\n    ROF(i,k,1)fnv[i-1]=fnv[i]*i%P;\n}\nint calc2(int x){\n    //printf(\"  calc2(%lld)\\n\",x);\n    return binom(n+x,x);\n}\nint calc2(int a,int b,int s){\n    //printf(\"  calc2(n=%lld,a=%lld,b=%lld,s=%lld)\\n\",n,a,b,s);\n    //至多和为s,m个数大于等于a，n-m个数小于等于b的方案数\n    if(s<m*a)return 0;\n    int lim=min((s-m*a)/(b+1),n-m);\n    int res=0;\n    FOR(i,0,lim){//枚举n-m个数中有i个大于b\n        int t=calc2(s-m*a-i*(b+1))%P*binom(n-m,i)%P;\n        //printf(\"  i=%lld,t=%lld\\n\",i,t);\n        res+=(1-2*(i&1))*t;\n        res%=P;\n    }\n    res=res*binom(n,m)%P;\n    //printf(\"  res=%lld\\n\",res);\n    return res;\n}\nint calc(int a,int b,int s){\n    //printf(\"\\033[32mcalc(a=%lld,b=%lld,s=%lld)\\033[0m\\n\",a,b,s);\n    //至多和为s,第m为a，n-m个数小于等于b的方案数\n    int res=calc2(a,b,s)-calc2(a+1,b,s);\n    res=(res%P+P)%P;\n    //printf(\"\\033[32mres=%lld\\033[0m\\n\",res);\n    return res;\n}\nint calc(int s){\n    //printf(\"calc(n=%lld,m=%lld,s=%lld)\\n\",n,m,s);\n    int tot=binom(n+s,s);\n    //printf(\"tot=%lld\\n\",tot);\n    FOR(i,1,s)tot-=calc(i,i-1,s),tot%=P;\n    tot+=P,tot%=P;\n    return tot;\n}\nsigned main(){\n    scanf(\"%lld%lld%lld%lld\",&n,&m,&l,&r);\n    init(n+r);\n    printf(\"%lld\",((calc(r)-calc(l-1))%P+P)%P);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\nconst int maxn = 3e6 + 10;\nint N , M , L , R;\nll fac[maxn] , ifac[maxn]; //fac[i] = i! % mod , ifac[i] * fac[i] = 1 % mod\n// count number of seq of A1 ... AN , Ai is non negative st\n// 1. L <= A1 + A2 + ... + AN <= R\n// 2. AM = AM + 1 , A1 >= A2 >= ... >= AN after sorting\n\nll qpow(ll a , int n){ //a ^ n % mod\n  if(n <= 0)return 1ll;\n  ll ret = qpow(a , n / 2);\n  if(n % 2 == 1){\n    return ((ret * ret) % mod) * a % mod;\n  }\n  return ret * ret % mod;\n}\n\nll C(int n , int r){\n  return (fac[n] * ifac[r] % mod) * ifac[n - r] % mod;\n}\n\nll G(int N , int M , int S , int x , int y){ // A1 ... AM are at least x and AM+1 ... AN are less than y\n  if(1ll * x * M > S)return 0ll;\n  S -= x * M;\n  ll ret = 0;\n  ll sign = 1ll;\n  for(int k = 0; k <= N - M && S >= 0; ++k , sign = 1ll * sign * (mod - 1) % mod , S -= y){\n    ret = (ret + sign * C(S + N , N) % mod * C(N - M , k) % mod + mod) % mod;\n  }\n  return ret * C(N , M) % mod;\n}\n\nll F(int N , int M , int S){\n  ll ret = C(N + S , N);\n  for(int x = 0; x < S; ++x){\n    ll c = (G(N , M , S , x , x) - G(N , M , S , x + 1 , x) + mod) % mod;\n    ret = (ret - c + mod) % mod;\n  }\n  return ret;\n}\n\nint main(){\n  cin >> N >> M >> L >> R;\n  fac[0] = 1ll;\n  for(int i = 1; i < maxn; ++i){\n    fac[i] = fac[i - 1] * i % mod;\n  }\n  ifac[maxn - 1] = qpow(fac[maxn - 1] , mod - 2);\n  for(int i = maxn - 2; i >= 0; --i){\n    ifac[i] = ifac[i + 1] * (i + 1) % mod;\n  }\n  cout << (F(N , M , R) - F(N , M , L - 1) + mod) % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nconst int N=600000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 1000000007\n#define eps 1e-8\nint n,m,l,r;\nll fac[N+10],invfac[N+10];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nll qpow(ll x,int y)\n{\n\tll ans=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ans=ans*x%maxd;\n\t\tx=x*x%maxd;y>>=1;\n\t}\n\treturn ans;\n}\n\nvoid init()\n{\n\tfac[0]=invfac[0]=1;\n\trep(i,1,N) fac[i]=fac[i-1]*i%maxd;\n\tinvfac[N]=qpow(fac[N],maxd-2);\n\tper(i,N-1,1) invfac[i]=invfac[i+1]*(i+1)%maxd;\n}\n\nll C(int n,int m)\n{\n\tif ((n<m) || (n<0) || (m<0)) return 0;\n\treturn fac[n]*invfac[m]%maxd*invfac[n-m]%maxd;\n}\n\nll calc(int n,int m,int sum,int lim,int r)\n{\n\tif (sum<1ll*m*r) return 0;\n\tsum-=m*r;\n\tll ans=0;\n\tfor (int i=0,f=1;i<=n-m;i++,f*=-1)\n\t{\n\t\tll tmp=C(n-m,i)*C(n+sum,n)%maxd;\n\t\tans=(ans+tmp*f+maxd)%maxd;\n\t\tsum-=lim;\n\t\tif (sum<0) break;\n\t}\n\treturn ans*C(n,m)%maxd;\n}\n\nll solve(int n,int m,int sum)\n{\n\tll ans=C(n+sum,n);\n\tper(i,sum,1)\n\t{\n\t\tll del=(calc(n,m,sum,i,i)-calc(n,m,sum,i,i+1)+maxd)%maxd;\n\t\tans=(ans-del+maxd)%maxd;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tinit();\n\tn=read();m=read();l=read();r=read();\n\tprintf(\"%lld\",(solve(n,m,r)-solve(n,m,l-1)+maxd)%maxd);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD=(ll)1e9+7;\nconst int N=1e6;\n\nll fac[N],invfac[N+3];\n\nll QPow(ll Ca,ll Cb){\n\tll ret=1;\n\twhile(Cb){\n\t\tif(Cb&1) ret=ret*Ca%MOD;\n\t\tCa=Ca*Ca%MOD;\n\t\tCb>>=1;\n\t}\n\treturn ret;\n}\nll funC(int Ca,int Cb){return fac[Cb]*invfac[Ca]%MOD*invfac[Cb-Ca]%MOD;}\n//sum( A[1~n] ) + B = S, A[1~m] >= Vr , 0 <= A[m+1,n] < Vl\nll funF(int n,int m,ll S,ll Vl,ll Vr){\n\tif(S-m*Vr<0) return 0;\n\telse S-=m*Vr;\n\tll ret=0;\n\tfor(int i=0,tmp=1;i<=n-m && Vl*i<=S;i++,tmp*=-1)\n\t\tret=(ret+MOD+tmp*funC(i,n-m)*funC(n,S-i*Vl+n)%MOD)%MOD;\n\treturn ret*funC(m,n)%MOD;\n}\nll Solve(int n,int m,int S){\n\tll ret=funC(n,S+n);\n\tfor(int i=S;i>=1;i--)\n\t\tret=(ret+MOD-(funF(n,m,S,i,i)+MOD-funF(n,m,S,i,i+1))%MOD)%MOD;\n\treturn ret;\n}\nint main(){\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++) fac[i]=fac[i-1]*i%MOD;\n\tinvfac[N-1]=QPow(fac[N-1],MOD-2);\n\tfor(int i=N-2;i>=0;i--) invfac[i]=invfac[i+1]*(i+1)%MOD;\n\tint n,m,Sl,Sr;\n\tscanf(\"%d%d%d%d\",&n,&m,&Sl,&Sr);\n\tprintf(\"%lld\\n\",(Solve(n,m,Sr)+MOD-Solve(n,m,Sl-1))%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return x.inv()*a;}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n  M pow(ll m) {\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\nusing mint = ModInt<MOD>;\n\nint N, M, L, R;\nmint fact[414514];\n\nmint Comb(int n, int k) {\n  //assert(0 <= k && k <= n);\n  if (!(0 <= k && k <= n)) return 0;\n  return fact[n]/fact[k]/fact[n-k];\n}\n\nmint Calc(int L) {\n  auto ret = Comb(L+N, N)/fact[N];\n  vector<mint> f(L+1);\n  rep(l, N-M+1) {\n    mint coef = Comb(N-M, l) * mint(-1).pow(l);\n    for (int idx=M; idx<=L; idx+=l+M) {\n      f[idx] -= coef;\n    }\n    for (int idx=M+l; idx<=L; idx+=l+M) {\n      f[idx] += coef;\n    }\n  }\n  rep(j, L+1) {\n    int k = L-j;\n    ret -= Comb(k+N, N)*f[j]/fact[M]/fact[N-M];\n  }\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  fact[0] = 1;\n  reps(i, 1, 414514) {\n    fact[i] = fact[i-1] * i;\n  }\n\n  cin >> N >> M >> L >> R;\n  auto ans = (Calc(R) - Calc(L-1)) * fact[N];\n  cout << ans.a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6+10;\nconst int P = 1e9+7;\n#define fr(i,low,up,st) for(register int i = low;i <= up;i += st)\n#define nfr(i,low,up,st) for(register int i = low;i >= up;i -= st)\n#define size(a) a.size()\n#define fill(a,b) memset(a,b,sizeof a)\n\nint fact[N],inv[N];\n\ninline int pow_mod(int x,int k){\n   int res = 1,base = x;\n   while(k){\n      if(k&1)res = 1LL*res*base%P;\n      k >>= 1;\n      base = 1LL*base*base%P;\n   }\n   return res;\n}\n\nvoid init(){\n   fact[0] = inv[0] = 1;\n   fr(i,1,N-1,1)fact[i] = 1LL*fact[i-1]*i%P;\n   inv[N-1] = pow_mod(fact[N-1],P-2);\n   nfr(i,N-2,1,1)inv[i] = 1LL*inv[i+1]*(i+1)%P;\n}\n\ninline int c(int n,int m){\n   if(n < m)return 0;\n   return 1LL*fact[n]*inv[n-m]%P*inv[m]%P;\n}\n\nvoid Mod(int &x){\n   x = (x>=P)?x-P:x;\n   x = (x<0)?x+P:x;\n}\nint n,m;\nint calc(int up,int a,int b){\n   int pans = 0;\n   for(int k = 0;1LL*k*(b+1)+1LL*a*m <= up && k+m <= n; ++k){\n      Mod(pans += 1LL*pow_mod(-1,k)*c(up-a*m-k*(b+1)+n,n)*c(n-m,k)%P);\n   }\n   //cerr << up <<' '<< a << ' ' << b <<' ' << pans << endl;\n   return 1LL*pans*c(n,m)%P;\n}\n\nint solve(int up){\n   int ans = 0;\n   fr(i,1,up,1){\n      Mod(ans += calc(up,i,i-1)-calc(up,i+1,i-1));\n      //cerr << i <<' '<< ans << endl;\n   }\n   Mod(ans = c(up+n,n)-ans);\n   return ans;\n}\n\nint main(){\n   init();\n   int L,R;\n   scanf(\"%d%d%d%d\",&n,&m,&L,&R);\n   int fans = 0;\n   Mod(fans = solve(R)-solve(L-1));\n   printf(\"%d\\n\",fans);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\ntemplate<int mod>\nstruct ModInt {\n    long long x;\n \n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    explicit operator int() const {return x;}\n \n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n \n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n \n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n \n    ModInt inverse() const{\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt power(long long p) const{\n        int a = x;\n        if (p==0) return 1;\n        if (p==1) return ModInt(a);\n        if (p%2==1) return (ModInt(a)*ModInt(a)).power(p/2)*ModInt(a);\n        else return (ModInt(a)*ModInt(a)).power(p/2);\n    }\n\n    ModInt power(const ModInt p) const{\n        return ((ModInt)x).power(p.x);\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\nusing modint = ModInt<mod>;\n\nstruct ModFac{\n  public:\n    vector<modint> f,i_f;\n    int n;\n\n    ModFac(int n_){\n      n=n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    ModFac(modint n_){\n      n=(int)n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    \n    modint factorial(int x){\n      //cout << f.size() << endl;\n      return f[x];\n    }\n        \n    modint inv_factorial(int x){\n      return i_f[x];\n    }\n    \n    modint comb(int m,int k){\n      if (m<0 or k<0) return 0;\n      if (m<k) return 0;\n      return f[m]*i_f[k]*i_f[m-k];\n    }\n};\n\n\nint n,m,l,r;\nModFac MF(1000010);\n\nmodint h(int s){\n    return MF.comb(s+n,n)*MF.comb(n,m);\n}\n\nmodint f(int s){\n    modint res=0;\n    rep(k,r+1){\n        rep(j,m+1){\n            int t=k*(j+n-m);\n            if(t>s) break;\n            if(t+n-m<=s){\n                if(j%2) res+=MF.comb(m,j)*h(s-t-n+m);\n                else res-=MF.comb(m,j)*h(s-t-n+m);\n            }\n            if(j%2) res-=MF.comb(m,j)*h(s-t);\n            else res+=MF.comb(m,j)*h(s-t);\n        }\n    }\n    return res;\n}\n\nmodint g(int s){\n    return MF.comb(s+n,n);\n}\n\nvoid solve(){\n    cin >> n >> m >> l >> r;\n    //cout << g(r)-g(l-1) << endl;\n    //cout << f(r)-f(l-1) << endl;\n    cout << g(r)-g(l-1)-f(r)+f(l-1) << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n#define let auto const\n\ntemplate<typename... Types>\nstruct dynarr: std::vector<Types...> {\n  using std::vector<Types...>::vector;\n  using size_type = typename std::vector<Types...>::size_type;\n  auto&& operator[](size_type i) { return this->at(i); }\n  auto&& operator[](size_type i) const { return this->at(i); }\n};\n\ntemplate<i64 M>\nstruct modint {\n  i64 a;\n  constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}\n  constexpr i64 value() const noexcept { return a; }\n  constexpr modint& operator+=(const modint r) noexcept {\n    a += r.a;\n    if(a >= M) a -= M;\n    return *this;\n  }\n  constexpr modint& operator=(const i64 r) {\n    a = (r % M + M) % M;\n    return *this;\n  }\n  constexpr modint& operator-=(const modint r) noexcept {\n    a -= r.a;\n    if(a < 0) a += M;\n    return *this;\n  }\n  constexpr modint& operator*=(const modint r) noexcept {\n    a = a * r.a % M;\n    return *this;\n  }\n  constexpr modint& operator/=(modint r) noexcept {\n    i64 ex = M - 2;\n    while(ex) {\n      if(ex & 1) {\n        *this *= r;\n      }\n      r *= r;\n      ex >>= 1;\n    }\n    return *this;\n  }\n\n  constexpr modint operator+(const modint r) const {\n    return modint(*this) += r;\n  }\n  constexpr modint operator-(const modint r) const {\n    return modint(*this) -= r;\n  }\n  constexpr modint operator*(const modint r) const {\n    return modint(*this) *= r;\n  }\n  constexpr modint operator/(const modint r) const {\n    return modint(*this) /= r;\n  }\n};\n\nusing fp = modint<(i64)(1e9 + 7)>;\n\nconst int MAX = 510000;\n\nfp fac[MAX], finv[MAX];\n\nvoid COMinit() {\n  fac[0] = 1;\n  for(i64 i = 1;i < MAX;i++) {\n    fac[i] = fac[i - 1] * fp(i);\n  }\n  finv[MAX - 1] = fp(1) / fac[MAX - 1];\n  for(i64 i = MAX - 2;i >= 0;i--) {\n    finv[i] = finv[i + 1] * fp(i + 1);\n  }\n}\n\nfp com(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k]);\n}\n\nint main() {\n    COMinit();\n    i64 N, M, L, R;\n    cin >> N >> M >> L >> R;\n    // (1 - T)^(N - M)\n\n    dynarr<fp> f(R + 1);\n    rep(i,0,R + 1) {\n      f[i] = com(N - M, i);\n      if(i % 2 == 1) f[i] *= fp(-1);\n    }\n\n    // T^M * (1 - T)^(N - M)\n    \n    dynarr<fp> F(R + 1);\n    rep(i,M,R + 1) {\n      F[i] = f[i - M];\n    }\n\n\n    // P = sigma(k = 1 ~ inf) { F(T^k) }\n    dynarr<fp> P(R + 1);\n    for(i64 i = 1;i <= R;i++) {\n      for(i64 k = 1;i * k <= R; k++) {\n        P[i * k] += F[i];\n      }\n    }\n\n    // (1 / (1 - T))^(N + 1)\n\n    dynarr<fp> q(R + 1);\n    rep(n,0,R + 1) {\n      q[n] = com(n + (N + 1) - 1, (N + 1) - 1);\n    }\n\n    // (1 - T^M) * (1 / (1 - T))^(N + 1)\n    \n    dynarr<fp> Q(R + 1);\n    rep(i, 0, R + 1) {\n      Q[i] = q[i];\n      if(i - M >= 0) Q[i] -= q[i - M];\n    }\n\n    fp Sr = 0;\n\n    for(i64 i = 0;i <= R;i++) {\n      Sr += P[i] * Q[R - i];\n    }\n\n    fp Sl = 0;\n    L--;\n    for(i64 i = 0;i <= L;i++) {\n      Sl += P[i] * Q[L - i];\n    }\n\n    fp rev = (Sr - Sl) * com(N, M);\n    fp al = q[R] - q[L];\n\n    cout << (al - rev).value() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\ntypedef long long LL;\nconst LL P = 1e9+7;\nconst int N = 6e5+5;\n \nint fac[N], ifac[N];\nint n, m, L, R;\n\nint pw(LL x,int n){\n\tLL res = 1;\n\tfor(;n;n>>=1,x=x*x%P)if(n&1)res=res*x%P;\n\treturn res;\n}\nint C(int x,int y){\n\tif(y<0 || y>x) return 0;\n\treturn 1ll * fac[x] * ifac[y] % P * ifac[x-y] % P;\n}\nint calc(int n,int sumL,int sumR){\n\treturn (C(sumR+n,n) - C(sumL-1+n,n) + P) % P;\n}\n \nint main(){\n\tfac[0] = 1;\n\trep(i,1,N-1) fac[i] = 1ll * fac[i-1] * i % P;\n\tifac[N-1] = pw(fac[N-1], P-2);\n\trrep(i,N-2,0) ifac[i] = 1ll * ifac[i+1] * (i+1) % P;\n\t\n\tcin>>n>>m>>L>>R;\n\tint sall = calc(n,L,R), s1 = 0;\n\t\n\trep(i,1,R){\n\t\tint sL = L - m * i, sR = R - m * i, r = i - 1, res = 0;\n\t\tif(sR<0) break;\n\t\t\n\t\trep(j,0,n-m){\n\t\t\tint sl = sL - j * (r+1), sr = sR - j * (r+1);\n\t\t\tif(sr<0) break;\n\t\t\tres = (res + (j%2==0 ? 1ll : -1ll) * calc(n,sl,sr) * C(n-m, j) % P + P) % P;\n\t\t}\n\t\t\n\t\tsL = L - m * (i+1), sR = R - m * (i+1);\n\t\trep(j,0,n-m){\n\t\t\tint sl = sL - j * (r+1), sr = sR - j * (r+1);\n\t\t\tif(sr<0) break;\n\t\t\tres = (res - (j%2==0 ? 1ll : -1ll) * calc(n,sl,sr) * C(n-m, j) % P + P) % P;\n\t\t}\n\t\ts1 = (s1 + 1ll * res * C(n, m) % P) % P;\n\t}\n\tcout<<(sall - s1 + P) % P <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=600005;\nconst int MOD=1000000007;\nint n,m,L,R;\nlong long fac[N],inv[N];\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n=600000)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nlong long calc(long long x,int p,int q)\n{\n\tx-=1LL*m*p;\n\tif(x<0) return 0;\n\tlong long res=0;\n\tfor(int i=0;i<=n-m&&x-1LL*i*q>=0;i++)\n\t\tif(i&1) res=(res-C(n-m,i)*C(x-1LL*i*q+n,n)%MOD+MOD)%MOD;\n\t\telse res=(res+C(n-m,i)*C(x-1LL*i*q+n,n)%MOD)%MOD;\n\tres*=C(n,m);\n\treturn res;\n}\nlong long solve(int x)\n{\n\tlong long res=0;\n\tfor(int p=1;p<=x;p++)\n\t\tres=(res+(calc(x,p,p)-calc(x,p,p-1)+MOD)%MOD)%MOD;\n\tres=(C(x+n,n)-res+MOD)%MOD;\n\treturn res;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);\n\tprintf(\"%lld\",(solve(R)-solve(L-1)+MOD)%MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=300000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m,l,r;\n\nvoid into(){\n  scanf(\"%d%d%d%d\",&n,&m,&l,&r);\n}\n\nint inv[N*2+9],fac[N*2+9],ifac[N*2+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n+r;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint Get_c(int n,int m){return n<m||m<0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}\n\nint Get_ans(int x,int mx){\n  int res=0;\n  mx-=m*x;\n  for (int i=0;i<=n-m&&i*x<=mx;++i){\n\tint t=mul(Get_c(n-m,i),Get_c(mx-i*x+n,n));\n\ti&1?ssub(res,t):sadd(res,t);\n  }\n  if (--x<=0) return mul(Get_c(n,m),res);\n  for (int i=0;i<=n-m&&i*x<=mx;++i){\n\tint t=mul(Get_c(n-m,i),Get_c(mx-i*x+n,n));\n\ti&1?sadd(res,t):ssub(res,t);\n  }\n  return mul(Get_c(n,m),res);\n}\n\nint ans;\n\nvoid Get_ans(){\n  for (int i=l;i<=r;++i) sadd(ans,Get_c(i+n-1,n-1));\n  for (int i=1;i<=r&&m*i<=r;++i) ssub(ans,Get_ans(i,r));\n  for (int i=1;i<l&&m*i<l;++i) sadd(ans,Get_ans(i,l-1));\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=1e6+5;\nint fac[N],ifac[N],n,m,l,r;\nvoid init(int n=1e6){\n\tfac[0]=ifac[0]=1;fp(i,1,n)fac[i]=mul(fac[i-1],i);\n\tifac[n]=ksm(fac[n],P-2);fd(i,n-1,1)ifac[i]=mul(ifac[i+1],i+1);\n}\ninline int C(R int n,R int m){return m<0||m>n?0:1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\ninline int put(R int n,R int m){return C(n+m-1,m-1);}\ninline int min(R int x,R int y){return x<y?x:y;}\nint calc(R int d){\n\tR int ret=0;\n\tfp(i,1,d/m){\n\t\tR int s=d-i*m,res=0,tmp;\n\t\tfp(j,0,min(s/i,n-m))tmp=mul(C(n-m,j),put(s-j*i,n+1)),upd(res,j&1?P-tmp:tmp);\n\t\tif((i+1)*m<=d){\n\t\t\ts=d-(i+1)*m;\n\t\t\tfp(j,0,min(s/i,n-m))tmp=mul(C(n-m,j),put(s-j*i,n+1)),upd(res,j&1?tmp:P-tmp);\n\t\t}\n\t\tupd(ret,res);\n\t}\n\tret=mul(ret,C(n,m));\n\treturn dec(put(d,n+1),ret);\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d%d%d\",&n,&m,&l,&r);\n\tprintf(\"%d\\n\",dec(calc(r),calc(l-1)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n/*\n\n[p^N] N! exp(Np) = N^N\n\n************\n*********\nooooooo\n******\n****\n***\n**\n\nN! [q^{L...R}] \\sum_{k=0}^R ([p^{M-1}] exp(p(q^{k+1} + q^{k+2} + ... + q^R)) (exp(p q^k) - 1)/p) ([p^{N-M}] exp(p (1 + q + q^2 + ... + q^{k-1})))\nN! [q^{L...R}] \\sum_{k=0}^R ([p^{M}] exp(pq^{k}/(1-q)) - exp(pq^{k+1}/(1-q))) ([p^{N-M}] exp(p (1-q^k) / (1-q)))\nN! [q^{L...R}] \\sum_{k=0}^R ((q^k/(1-q))^M - (q^{k+1}/(1-q))^M) / M! ((1-q^k) / (1-q))^{N-M} / (N-M)!\n\\binom{N}{M} [q^{L...R}] 1/(1-q)^N \\sum_{k=0}^R (q^{kM} - q^{(k+1)M}) (1-q^k)^{N-M}\n\\binom{N}{M} [q^R] (1-q^{R-L+1})/(1-q) 1/(1-q)^N \\sum_{k=0}^R (q^{kM} - q^{(k+1)M}) (1-q^k)^{N-M}\n\\binom{N}{M} [q^R] (1-q^{R-L+1}) 1/(1-q)^{N+1} \\sum_{k=0}^R q^{kM)} (1- q^M) (1-q^k)^{N-M}\n\\binom{N}{M} [q^R] (1-q^{R-L+1}) (1-q^M)/(1-q)^{N+1} \\sum_{k=0}^R q^{kM} (1-q^k)^{N-M}\n\nN! [q^{L...R}] [p^N] exp(p (1 + q + q^2 + ... + q^R))\nN! [q^{L...R}] 1/(1-q)^N / N!\n[q^R] (1-q^{R-L+1})/(1-q) 1/(1-q)^N\n[q^R] (1-q^{R-L+1}) 1/(1-q)^{N+1}\n\\binom{N+R}{R} - \\binom{N+L-1}{L-1}\n*/\n\nconstexpr int mod = 1000000007;\nconstexpr int MAX = 600000;\nint fact[MAX+1];\nint ifact[MAX+1];\nlong long int dp[MAX+1];\n\nint pow(int x, int n){\n  int r = 1;\n  for(; n; n >>= 1){\n    if(n&1) r = (long long) r * x % mod;\n    x = (long long) x * x % mod;\n  }\n  return r;\n}\n\nint binom(int n, int k){\n  return (long long) fact[n] * ifact[k] % mod * ifact[n-k] % mod;\n}\n\nint n, m, l, r;\n\nint main(){\n  fact[0] = 1;\n  for(int i = 1; i <= MAX; i++) fact[i] = (long long) i * fact[i-1] % mod;\n  ifact[MAX] = pow(fact[MAX], mod-2);\n  for(int i = MAX-1; i >= 0; i--) ifact[i] = (long long) (i+1) * ifact[i+1] % mod;\n\n  scanf(\"%d%d%d%d\", &n, &m, &l, &r);\n\n  for(int i = m; i <= r; i++){\n    int tmp = binom(n-m, i-m);\n    if((i-m)&1) tmp = mod-tmp;\n    for(int j = 1; j * i <= r; j++){\n      dp[j*i] += tmp;\n    }\n  }\n  for(int i = r; i >= r-l+1; i--) dp[i] -= dp[i - (r-l+1)];\n  for(int i = r; i >= m; i--) (dp[i] -= dp[i - m]) %= mod;\n \n  int ans = 0;\n  for(int i = 0; i <= r; i++){\n    ans = (ans + (long long) dp[r - i] * binom(n+i, i)) % mod;\n  }\n\n  ans = (long long) binom(n, m) * ans % mod;\n  ans = binom(n + r, r) - ans;\n  if(ans < 0) ans += mod;\n  ans = ans - binom(n + l - 1, l - 1);\n  if(ans < 0) ans += mod;\n  if(ans < 0) ans += mod;\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_f\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << a[qwq];\\\n\t\telse cerr << \", \" << a[qwq];\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(v) ;\n#define eprintf(...) if(0) fprintf(stderr, \"...\")\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst LL P = 1000000007;\nconst int maxN = 2 * 300000 + 5;\nLL qpow(LL a, LL b) {\n\tLL r = 1;\n\twhile(b) {\n\t\tif(b & 1) (r *= a) %= P;\n\t\t(a *= a) %= P; b >>= 1;\n\t}\n\treturn r;\n}\nint m, n;\nLL fac[maxN], ifac[maxN];\n\nLL C(int n, int k) {\n\tif(k < 0 || k > n) return 0;\n\treturn fac[n] * ifac[k] % P * ifac[n - k] % P;\n}\nLL D(int n, int k) {\n\treturn C(n + k, k);\n}\n\nLL cnt(LL A, int n, int m, LL x) { // sum ai <= A, m of them <= x\n\tif(A < 0) return 0;\n\tLL ans = 0;\n\tfor(int i = 0; i <= m; ++i) if(A - (x + 1) * i >= 0) {\n\t\tLL dans = D(A - (x + 1) * i, n) * C(m, i) % P;\n\t\tif(i & 1) ans -= dans; else ans += dans;\n\t} else {\n\t\tbreak;\n\t}\n//\teprintf(\"cnt(%lld, %d, %d, %lld) = %lld\\n\", A, n, m, x, (ans % P + P) % P);\n\treturn (ans % P + P) % P;\n}\n\nLL solve(LL A) {\n\tLL ans = 0;\n\tfor(int x = 0; x <= A; ++x) if((LL)(n - m) * (x + 1) <= A) {\n\t\tans += cnt(A - (LL)(x + 1) * (n - m), n, m, x);\n\t\tans -= cnt(A - (LL)(x + 2) * (n - m), n, m, x);\n\t}\n\treturn (ans % P + P) % P * C(n, m) % P;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n#endif\n\tfac[0] = 1;\n\tfor(int i = 1; i < maxN; ++i) fac[i] = fac[i - 1] * i % P;\n\tifac[maxN - 1] = qpow(fac[maxN - 1], P - 2);\n\tfor(int i = maxN - 2; i >= 0; --i) ifac[i] = ifac[i + 1] * (i + 1) % P;\n\tint L, R;\n\tcin >> n >> m >> L >> R;\n\tm = n - m;\n\tdisplay(D(R, n) - D(L - 1, n));\n\tdisplay(solve(R) - solve(L - 1));\n\tcout << ((D(R, n) - D(L - 1, n) - solve(R) + solve(L - 1) + P * 2) % P) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ninline ll read() {ll x = 0;char ch = getchar(), w = 1;while(ch < '0' || ch > '9') {\nif(ch == '-') w = -1;ch = getchar();}while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();\n}return x * w;}\nvoid write(ll x) {if(x < 0) putchar('-'), x = -x;if(x > 9) write(x / 10);putchar(x % 10 + '0');}\ninline void writeln(ll x) {write(x);puts(\"\");}\nusing namespace std;\n\nconst int N = 7e5 + 66;\nll n, m, l, r;\nll fac[N], inv[N];\nconst ll mo = 1e9 + 7;\nll ksm(ll x, ll y) {\n\tll res = 1;\n\tfor(; y; y >>= 1, x=x * x % mo)\n\t\tif(y & 1) res = res * x % mo;\n\treturn res;\n}\nvoid init(int tot) {\n\tfac[0] = inv[0] = 1;\n\tfor(int i = 1; i <= tot; ++i) {\n\t\tfac[i] = fac[i - 1] * i % mo;\n\t\tinv[i] = ksm(fac[i], mo - 2);\n\t}\n}\nll C(int n, int m) {\n\tif(n < m) return 0;\n\treturn fac[n] * inv[m] % mo * inv[n - m] % mo;\n}\ninline ll bs(ll x) {\n\tx %= mo;\n\tif(x < 0) x += mo;\n\treturn x;\n}\ninline ll add(ll &x, ll v) {\n\tx += v;\n\tif(x >= mo) x %= mo;\n}\ninline ll dec(ll &x, ll v) {\n\tx -= v;\n\tif(x < 0) x += mo;\n}\nll cal(ll s, ll b) {\n\tif(s < 0) return 0;\n\tll res = 0, t = 0;\n\tfor(int i = 0; i <= n - m && t <= s; t += b,++i) {\n\t\tll v = C(n - m, i) * C(s - t + n, n) % mo;\n\t\tif(i & 1) dec(res, v);\n\t\telse add(res, v);\n\t}\n\treturn res * C(n, m) % mo;\n}\nll solve(ll s) {\n\tll res = C(s + n, n);\n\tfor(int i = 0; i * m <= s; ++i)\n\t\tdec(res, bs(cal(s - i * m, i) - cal(s - (i + 1) * m, i)));\n\treturn res;\n}\nint main() {\n\tn = read(), m = read(), l = read(), r = read();\n\tinit(n + r);\n\twriteln(bs(solve(r) - solve(l - 1)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\nint read(){\n\tregister int x = 0;\n\tregister char f = 1, ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');\n\treturn f ? x : -x;\n}\n#define N 600005\n#define P 1000000007\nint n, m, l, r, fac[N], inv[N];\nvoid inc(int &a, int b){ (a += b) >= P ? a -= P : 0; }\nvoid dec(int &a, int b){ (a -= b) < 0 ? a += P : 0; }\nint plus(int a, int b){ return (a += b) >= P ? a - P : a; }\nint minus(int a, int b){ return (a -= b) < 0 ? a + P : a; }\nint qpow(int a, int b = P - 2){\n\tint s = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % P) if (b & 1) s = 1ll * s * a % P;\n\treturn s;\n}\nvoid init(int n){\n\tfac[0] = 1;\n\tfor (register int i = 1; i <= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P;\n\tinv[n] = qpow(fac[n]);\n\tfor (register int i = n; i; --i) inv[i - 1] = 1ll * inv[i] * i % P;\n}\nint C(int n, int m){\n\tif (n < m) return 0;\n\treturn 1ll * fac[n] * inv[m] % P * inv[n - m] % P;\n}\nint get(int S, int r){\n\tif (S < 0) return 0;\n\tint res = 0;\n\tfor (register int i = 0, t = 0; i <= n - m && t <= S; t += r, ++i){\n\t\tint s = 1ll * C(n - m, i) * C(S - t + n, n) % P;\n\t\tif (i & 1) dec(res, s); else inc(res, s);\n\t}\n\treturn 1ll * res * C(n, m) % P;\n}\nint solve(int S){\n\tint res = C(S + n, n);\n\tfor (register int i = 1; i * m <= S; ++i)\n\t\tdec(res, minus(get(S - i * m, i), get(S - (i + 1) * m, i)));\n\treturn res;\n}\nint main(){\n\tn = read(), m = read(), l = read(), r = read();\n\tinit(n + r);\n\tprintf(\"%d\\n\", minus(solve(r), solve(l - 1)));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007; // 2^23 * 119 + 1\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x < MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\ttemplate <typename U>\n\texplicit operator U() const { return (U)val; }\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint modex(Mint a, ll p) {\n\t\tassert(p >= 0);\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nnamespace fft {\nstruct cpx {\n\tdouble r, i;\n\tcpx(double r = 0, double i = 0) : r(r), i(i) {}\n\tcpx operator+(cpx b) { return {r + b.r, i + b.i}; }\n\tcpx operator-(cpx b) { return {r - b.r, i - b.i}; }\n\tcpx operator*(cpx b) { return {r * b.r - i * b.i, r * b.i + i * b.r}; }\n\tcpx operator/(double b) { return {r / b, i / b}; }\n\tinline cpx conj() { return {r, -i}; }\n};\nconst double PI = acos(-1);\nvector<int> rev(1, 0); // rev has [base] bits\nvector<cpx> roots;\nint base = 0;\nvoid precompute(int nbase) {\n\tif (nbase <= base) return;\n\trev.resize(1 << nbase);\n\tfor (int i = 0; i < (1 << nbase); ++i) {\n\t\trev[i] = rev[i >> 1] >> 1 | ((i & 1) << nbase - 1);\n\t}\n\troots.resize(1 << nbase);\n\tfor (; base < nbase; ++base) {\n\t\tint len = 1 << base;\n\t\tdouble angle = 2 * PI / (1 << (base + 1));\n\t\tfor (int i = 0; i < len; ++i) {\n\t\t\tdouble cur = angle * i;\n\t\t\troots[len + i] = cpx(cos(cur), sin(cur));\n\t\t}\n\t}\n}\nvoid fft(vector<cpx>& a, int n = -1) {\n\tif (n == -1) n = a.size();\n\tassert((n & (n - 1)) == 0);\n\tint zeros = __builtin_ctz(n);\n\tprecompute(zeros);\n\tint shift = base - zeros;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (i < (rev[i] >> shift)) swap(a[i], a[rev[i] >> shift]);\n\t}\n\tfor (int len = 1; len < n; len <<= 1)\n\t\tfor (int i = 0; i < n; i += 2 * len)\n\t\t\tfor (int j = 0; j < len; ++j) {\n\t\t\t\tcpx u = a[i + j], v = a[i + j + len] * roots[len + j];\n\t\t\t\ta[i + j] = u + v;\n\t\t\t\ta[i + j + len] = u - v;\n\t\t\t}\n}\nvector<cpx> fa, fb;\nvector<ll> multiply(const vector<int>& a, const vector<int>& b) {\n\tif (a.empty() || b.empty()) return {};\n\tint sz = a.size() + b.size() - 1;\n\tint n = sz == 1 ? 1 : 1 << (32 - __builtin_clz(sz - 1));\n\tif (n > fa.size()) fa.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x = i < a.size() ? a[i] : 0;\n\t\tint y = i < b.size() ? b[i] : 0;\n\t\tfa[i] = cpx(x, y);\n\t}\n\tfft(fa, n);\n\tcpx r(0, -0.5 / n);\n\tfor (int i = 0; i <= (n >> 1); ++i) {\n\t\tint j = (n - i) & (n - 1);\n\t\tcpx x = (fa[i] + fa[j].conj()) / 2;\n\t\tcpx y = (fa[i] - fa[j].conj()) * r;\n\t\tfa[i] = x * y;\n\t\tif (i != j) fa[j] = fa[i].conj();\n\t}\n\tfft(fa, n);\n\treverse(fa.begin() + 1, fa.begin() + n);\n\tvector<ll> res(sz);\n\tfor (int i = 0; i < sz; ++i) {\n\t\tres[i] = llround(fa[i].r);\n\t}\n\treturn res;\n}\n// Accepts Mint or int or ll in range [0..m-1].\ntemplate <typename T>\nvector<T> multiply(const vector<T>& a, const vector<T>& b, int m, bool forceFast = false) {\n\tif (forceFast || m < (1 << 15)) {\n\t\tvector<int> aa(a.begin(), a.end()), bb(b.begin(), b.end());\n\t\tauto res = multiply(aa, bb);\n\t\tvector<T> ret(res.size());\n\t\tfor (int i = 0; i < res.size(); ++i) ret[i] = res[i] % m;\n\t\treturn ret;\n\t}\n\tif (a.empty() || b.empty()) return {};\n\tint eq = (a == b);\n\tint sz = a.size() + b.size() - 1;\n\tint n = sz == 1 ? 1 : 1 << (32 - __builtin_clz(sz - 1));\n\tif (n > fa.size()) fa.resize(n);\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\tfa[i] = cpx(int(a[i]) & ((1 << 15) - 1), int(a[i]) >> 15);\n\t}\n\tfill(fa.begin() + a.size(), fa.begin() + n, cpx(0, 0));\n\tfft(fa, n);\n\tif (n > fb.size()) fb.resize(n);\n\tif (eq) {\n\t\tcopy(fa.begin(), fa.begin() + n, fb.begin());\n\t} else {\n\t\tfor (int i = 0; i < b.size(); ++i) {\n\t\t\tfb[i] = cpx(int(b[i]) & ((1 << 15) - 1), int(b[i]) >> 15);\n\t\t}\n\t\tfill(fb.begin() + b.size(), fb.begin() + n, cpx(0, 0));\n\t\tfft(fb, n);\n\t}\n\tdouble ratio = 0.5 / n;\n\tcpx r2(0, -0.5);\n\tcpx r3(ratio, 0);\n\tcpx r4(0, -ratio);\n\tcpx r5(0, 1);\n\tfor (int i = 0; i <= (n >> 1); ++i) {\n\t\tint j = (n - i) & (n - 1);\n\t\tcpx a1 = (fa[i] + fa[j].conj()) / 2;\n\t\tcpx a2 = (fa[i] - fa[j].conj()) * r2;\n\t\tcpx b1 = (fb[i] + fb[j].conj()) * r3;\n\t\tcpx b2 = (fb[i] - fb[j].conj()) * r4;\n\t\tcpx x = a1 * b1;\n\t\tcpx y = a2 * b2;\n\t\tfa[i] = x + y * r5;\n\t\tfb[i] = a1 * b2 + a2 * b1;\n\t\tif (i != j) {\n\t\t\tfa[j] = x.conj() + y.conj() * r5;\n\t\t\tfb[j] = fb[i].conj();\n\t\t}\n\t}\n\tfft(fa, n);\n\tfft(fb, n);\n\treverse(fa.begin() + 1, fa.begin() + n);\n\treverse(fb.begin() + 1, fb.begin() + n);\n\tvector<T> res(sz);\n\tfor (int i = 0; i < sz; ++i) {\n\t\tll aa = llround(fa[i].r);\n\t\tll bb = llround(fb[i].r);\n\t\tll cc = llround(fa[i].i);\n\t\tres[i] = (aa + ((bb % m) << 15) + ((cc % m) << 30)) % m;\n\t}\n\treturn res;\n}\nvector<Mint> multiply(const vector<Mint>& a, const vector<Mint>& b, bool forceFast = false) {\n\treturn multiply(a, b, MOD, forceFast);\n}\n}; // namespace fft\nnamespace polynomial {\n// Leading zeros are not possible.\nvector<Mint> subtract(vector<Mint> a, const vector<Mint>& b) {\n\tif (a.size() < b.size()) {\n\t\ta.resize(b.size());\n\t}\n\tfor (int i = 0; i < b.size(); ++i) {\n\t\ta[i] -= b[i];\n\t}\n\twhile (!a.empty() && a.back() == 0) a.pop_back();\n\treturn a;\n}\n// Leading zeros are not possible.\nvector<Mint> add(vector<Mint> a, const vector<Mint>& b) {\n\tif (a.size() < b.size()) {\n\t\ta.resize(b.size());\n\t}\n\tfor (int i = 0; i < b.size(); ++i) {\n\t\ta[i] += b[i];\n\t}\n\twhile (!a.empty() && a.back() == 0) a.pop_back();\n\treturn a;\n}\n// Invert a power series mod x^n, where f[0] != 0\n// P[2n] = P[n](2 - f * P[n]) mod x^(2n)\n// O(n log n)\nvector<Mint> inverse(const vector<Mint>& a) {\n#ifdef NTT\n\tassert(!a.empty() && a[0] != 0);\n\tint n = a.size();\n\tvector<Mint> b = {1 / a[0]};\n\tfor (int m = 2; b.size() < n; m <<= 1) {\n\t\tvector<Mint> aCut(a.begin(), a.begin() + min((int)a.size(), m));\n\t\taCut.resize(2 * m);\n\t\tb.resize(2 * m);\n\t\tfft::fft(aCut);\n\t\tfft::fft(b);\n\t\tfor (int i = 0; i < 2 * m; ++i) {\n\t\t\tb[i] *= 2 - aCut[i] * b[i];\n\t\t}\n\t\tfft::fft(b);\n\t\treverse(b.begin() + 1, b.end());\n\t\tb.resize(m);\n\t\tMint inv = Mint(1) / (2 * m);\n\t\tfor (int i = 0; i < m; ++i) b[i] *= inv;\n\t}\n\tb.resize(n);\n\treturn b;\n#else\n\tassert(!a.empty() && a[0] != 0);\n\tint n = a.size();\n\tvector<Mint> b = {1 / a[0]};\n\tfor (int m = 2; b.size() < n; m <<= 1) {\n\t\tvector<Mint> aCut(a.begin(), a.begin() + min((int)a.size(), m));\n\t\tauto x = fft::multiply(aCut, fft::multiply(b, b, MOD), MOD);\n\t\tb.resize(m);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tb[i] += b[i] - x[i];\n\t\t}\n\t}\n\tb.resize(n);\n\treturn b;\n#endif\n}\n// Polynomial division: divide A (<= deg n) by B (deg m)\n// A(x) = Q(x)B(x) + R(x), deg Q <= n-m. Substitute x = 1/x.\n// x^nA(1/x) = (x^(n-m)Q(1/x))(x^mB(1/x)) + x^(n-m+1)(x^(m-1)R(1/x))\n// Note x^deg * poly(1/x) = poly_reverse(x).\n// So A_rev(x) = Q_rev(x)B_rev(x) mod x^(n-m+1).\n// So we can recover Q, since deg Q_rev <= n-m.\n// Leading zeros are not possible if A has no leading zeros.\n// O(n log n)\nvector<Mint> divide(vector<Mint> a, vector<Mint> b) {\n\tassert(!b.empty() && b.back() != 0);\n\tint n = a.size();\n\tint m = b.size();\n\tif (n < m) return {};\n\treverse(a.begin(), a.end());\n\treverse(b.begin(), b.end());\n\tb.resize(n - m + 1);\n\ta = fft::multiply(a, inverse(b), MOD);\n\ta.erase(a.begin() + n - m + 1, a.end());\n\treverse(a.begin(), a.end());\n\treturn a;\n}\n// O(n log n) where n = deg a. Leading zeros are not possible.\nvector<Mint> remainder(const vector<Mint>& a, const vector<Mint>& b) {\n\treturn subtract(a, fft::multiply(b, divide(a, b), MOD));\n}\n// Calculate integral with c=0. Leading zeros are possible!\nvector<Mint> integral(const vector<Mint>& a) {\n\tvector<Mint> ret(a.size() + 1);\n\tfor (int i = 1; i < ret.size(); ++i) {\n\t\tret[i] = a[i - 1] / i;\n\t}\n\treturn ret;\n}\n// Leading zeros are possible!\nvector<Mint> derivative(const vector<Mint>& a) {\n\tif (a.empty()) return a;\n\tvector<Mint> ret(a.size() - 1);\n\tfor (int i = 0; i + 1 < a.size(); ++i)\n\t\tret[i] = a[i + 1] * (i + 1);\n\treturn ret;\n}\n// Calculate log(f) mod x^n, where f[0] == 1. ret[0] == 0.\n// O(n log n)\nvector<Mint> logarithm(const vector<Mint>& a) {\n\tassert(!a.empty() && a[0] == 1);\n\tauto ret = integral(fft::multiply(derivative(a), inverse(a), MOD));\n\tret.resize(a.size());\n\treturn ret;\n}\n// Calculate exp(f) mod x^n, where f[0] == 0. ret[0] == 1.\n// P[2n] = P[n](1 - log(P[n]) + f) mod x^(2n)\n// O(n log n)\nvector<Mint> exponent(const vector<Mint>& a) {\n\tassert(!a.empty() && a[0] == 0);\n\tint n = a.size();\n\tvector<Mint> b = {1};\n\tfor (int m = 2; b.size() < n; m <<= 1) {\n\t\tvector<Mint> x(a.begin(), a.begin() + min((int)a.size(), m));\n\t\t++x[0];\n\t\tauto oldB = b;\n\t\tb.resize(m);\n\t\tb = fft::multiply(oldB, subtract(x, logarithm(b)), MOD);\n\t\tb.resize(m);\n\t}\n\tb.resize(n);\n\treturn b;\n}\n// Multipoint evaluation: Evaluate A (deg d) at n points xs modulo MOD.\n// Key idea: A(x_i) = A(x) mod (x - x_i).\n// Calculate A mod (x-x_l)...(x-x_r) for range [l,r].\n// O(n log^2 n + d log d)\nvector<Mint> multipoint(const vector<Mint>& a, vector<Mint> xs) {\n\tint n = xs.size();\n\tvector<vector<Mint>> prods(2 * n - 1);\n\tfunction<void(int, int, int)> getProds = [&](int sn, int s, int e) {\n\t\tif (s == e) {\n\t\t\tprods[sn] = {-xs[s], 1};\n\t\t\treturn;\n\t\t}\n\t\tint m = (s + e) >> 1, lsn = sn + 1, rsn = sn + ((m - s + 1) << 1);\n\t\tgetProds(lsn, s, m);\n\t\tgetProds(rsn, m + 1, e);\n\t\tprods[sn] = fft::multiply(prods[lsn], prods[rsn], MOD);\n\t};\n\tgetProds(0, 0, n - 1);\n\tfunction<void(int, int, int, vector<Mint>)> calc = [&](int sn, int s, int e, vector<Mint> f) {\n\t\tif (s == e) {\n\t\t\txs[s] = f.empty() ? 0 : f[0];\n\t\t\treturn;\n\t\t}\n\t\tint m = (s + e) >> 1, lsn = sn + 1, rsn = sn + ((m - s + 1) << 1);\n\t\tcalc(lsn, s, m, remainder(f, prods[lsn]));\n\t\tcalc(rsn, m + 1, e, remainder(f, prods[rsn]));\n\t};\n\tcalc(0, 0, n - 1, a);\n\treturn xs;\n}\n// Given a polynomial A and generator g, evaluate Y[k] = A(g^k mod MOD) for all 0 <= k < n.\n// A(g^(2k)) = sum_i a_i * g^(2ki)\n// A(g^(2k+1)) = sum_i a_i * g^i * g^(2ki)\n// Chirp z-transform: g^(2ki) = g^(kk) g^(ii) g^(-(k-i)^2); so we can convolve.\n// O(MOD + (n + deg A) log (n + deg A))\nvector<Mint> chirpz(vector<Mint> a, Mint g, int n) {\n\tint d = a.size();\n\tint phi = MOD - 1;\n\tvector<Mint> pw(phi + 1);\n\tpw[0] = 1;\n\tfor (int i = 1; i <= phi; ++i) pw[i] = pw[i - 1] * g;\n\tauto chirpzEven = [&](const vector<Mint>& b, int m) {\n\t\tvector<Mint> u(d), v(m + d - 1);\n\t\tfor (int i = 0; i < d; ++i) {\n\t\t\tu[i] = b[i] * pw[(ll)i * i % phi];\n\t\t}\n\t\tfor (int i = -(d - 1); i < m; ++i) {\n\t\t\tv[d - 1 + i] = pw[phi - (ll)i * i % phi];\n\t\t}\n\t\tauto z = fft::multiply(u, v, MOD);\n\t\tvector<Mint> ret(m);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tret[i] = pw[(ll)i * i % phi] * z[d - 1 + i];\n\t\t}\n\t\treturn ret;\n\t};\n\tauto even = chirpzEven(a, (n + 1) >> 1);\n\tfor (int i = 0; i < d; ++i) a[i] *= pw[i % phi];\n\tauto odd = chirpzEven(a, n >> 1);\n\tvector<Mint> ret(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tret[i] = (i & 1) ? odd[i >> 1] : even[i >> 1];\n\t}\n\treturn ret;\n}\n// Compute A^p mod B in O(b log b log p).\nvector<Mint> powerMod(const vector<Mint>& a, ll p, const vector<Mint>& b) {\n\tif (!p) return {1};\n\tvector<Mint> c;\n\tif (p & 1) {\n\t\tc = fft::multiply(powerMod(a, p - 1, b), a, MOD);\n\t} else {\n\t\tc = powerMod(a, p >> 1, b);\n\t\tc = fft::multiply(c, c, MOD);\n\t}\n\treturn remainder(c, b);\n}\n// Compute A^p mod x^n in O(n log n) using exp/log.\nvector<Mint> power(vector<Mint> a, ll p, int n) {\n\tif (!p) return {1};\n\tassert(a.size() <= n);\n\tint m = 0;\n\twhile (m < a.size() && a[m] == 0) ++m;\n\tif (m * p >= n) return {};\n\ta.erase(a.begin(), a.begin() + m);\n\tMint inv = 1 / a[0];\n\tMint c = modex(a[0], p);\n\tfor (Mint& x : a) x *= inv;\n\ta = logarithm(a);\n\tMint q = p;\n\tfor (Mint& x : a) x *= q;\n\ta = exponent(a);\n\ta.insert(a.begin(), min(n - (ll)a.size(), m * p), 0);\n\tfor (Mint& x : a) x *= c;\n\treturn a;\n}\nvector<Mint> multiplyAll(int s, int e, const vector<vector<Mint>>& polys) {\n\tif (s == e) return polys[s];\n\tint m = (s + e) >> 1;\n\tauto a = multiplyAll(s, m, polys);\n\tauto b = multiplyAll(m + 1, e, polys);\n\treturn fft::multiply(a, b, MOD);\n}\n}; // namespace polynomial\nusing namespace polynomial;\nconst int MAXN = 300005;\nMint fac[MAXN], invfac[MAXN];\nMint binom(ll a, ll b) {\n\tif (b < 0) return 0;\n\tif (b > a) return 0;\n\treturn fac[a] * invfac[b] * invfac[a - b];\n}\nint main() {\n\t// Mint version.\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tfac[i] = fac[i - 1] * i;\n\tinvfac[MAXN - 1] = 1 / fac[MAXN - 1];\n\tfor (int i = MAXN - 2; i >= 0; --i)\n\t\tinvfac[i] = invfac[i + 1] * (i + 1);\n\tint N, M, L, R;\n\tscanf(\"%d%d%d%d\", &N, &M, &L, &R);\n\tvector<Mint> sub(R + 1), denom(R + 1);\n\tMint w = binom(N, M);\n\tfor (int k = 0; k <= R; ++k) {\n\t\tfor (int i = 0; i <= N - M; ++i) {\n\t\t\tll p = (ll)M * k + (ll)i * k;\n\t\t\tif (p > R) break;\n\t\t\tMint coeff = binom(N - M, i);\n\t\t\tif (i & 1) coeff = -coeff;\n\t\t\tsub[p] += coeff * w;\n\t\t}\n\t}\n\tfor (int i = R; i >= M; --i) {\n\t\tsub[i] = sub[i - M] - sub[i];\n\t}\n\tsub[0]++;\n\tsub.resize(R + 1);\n\tfor (int i = 0; i <= R; ++i) {\n\t\tMint coeff = binom(N, i);\n\t\tdenom[i] = (i & 1) ? -coeff : coeff;\n\t}\n\tauto ans = fft::multiply(sub, inverse(denom));\n\tMint v = 0;\n\tfor (int i = L; i <= R; ++i)\n\t\tif (i < ans.size()) v += ans[i];\n\tprintf(\"%d\\n\", v.val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//const uint mod=998244353;\nconst uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nmint waf(int n,int m,int s){\n\tmint res;\n\trng(v,1,s+1){\n\t\tfor(int k=m;k*v<=s&&k<=n;k++){\n\t\t\tmint w=choose(k,m)*choose(n,k);\n\t\t\tw*=binom(s-k*v,n);\n\t\t\tif((k-m)%2==0)\n\t\t\t\tres+=w;\n\t\t\telse\n\t\t\t\tres-=w;\n\t\t}\n\t}\n\t//cerr<<n<<\" \"<<m<<\" \"<<s<<\" \"<<res<<endl;\n\treturn res;\n}\n\nmint sub(int n,int m,int s){\n\tmint res=binom(s,n)-(waf(n,m,s)-waf(n,m,s-m));\n\t//dmp(res);\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m,l,r;cin>>n>>m>>l>>r;\n\tmint ans=sub(n,m,r)-sub(n,m,l-1);\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = TEN(6);\n\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n}\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nll solve_sub(int N, int M, int S, int r, int l) {\n\tll v = 0;\n\tfor (int i = 0; i <= N - M; ++i) {\n\t\tll rem = S - (ll)r * M - (ll)(l + 1) * i;\n\t\tif (rem < 0) break;\n\t\tll t = comb(rem + N, N);\n\t\tif (i % 2 == 1) {\n\t\t\tt *= -1;\n\t\t}\n\n\t\tt = t * comb(N - M, i) % MOD;\n\t\tif (t < 0) t += MOD;\n\t\tv = (v + t) % MOD;\n\t}\n\tv = v * comb(N, M) % MOD;\n\treturn v;\n}\n\nll solve(int N, int M, int S) {\n\tll all = comb(S + N, N);\n\tll ng = 0;\n\n\tfor (int x = 1; (ll)x * M <= S; ++x) { //minimum of bigger part\n\t\tll a = solve_sub(N, M, S, x, x-1) - solve_sub(N, M, S, x+1, x-1);\n\t\tng = (ng + a) % MOD;\n\t\tif (ng < 0) ng += MOD;\n\t}\n\n\treturn (all - ng + MOD) % MOD;\n}\n\nint main() {\n\tint N, M, L, R;\n\tcin >> N >> M >> L >> R;\n\n\tinit();\n\n\tll ans = (solve(N, M, R) - solve(N, M, L-1) + MOD) % MOD;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7,N=6e5+5;\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1;\n\t}\n\treturn res;\n}\nint fac[N],inv[N];\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i)\n\t\tinv[i]=(i+1)*inv[i+1]%mod;\n}\nint C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint n,m;\nint calc(int S,int x){\n\tif(S<0) return 0;\n\tlong long res=0,tmp;\n\tfor(int i=0,T=0;i<=n-m && T<=S;++i,T+=x){\n\t\ttmp=C(n-m,i)*C(S-T+n,n)%mod;\n\t\tif(i&1) res=(res+mod-tmp)%mod;\n\t\telse res=(res+tmp)%mod;\n\t}\n\treturn res*C(n,m)%mod;\n}\nint solve(int S){\n\tint res=0;\n\tfor(int x=1;x<=S;++x)\n\t\tres+=calc(S-m*x,x)-calc(S-m*(x+1),x),\n\t\tres=(res+mod)%mod;\n\tint ans=C(S+n,n);\n\tans=(ans-res+mod)%mod;\n\treturn ans;\n}\nsigned main(){\n\tcin>>n>>m;\n\tinit(6e5);\n\tint L,R;\n\tcin>>L>>R;\n\tint ans=solve(R)-solve(L-1);\n\tans=(ans+mod)%mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return x.inv()*a;}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n  M pow(ll m) {\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\nusing mint = ModInt<MOD>;\n\nint N, M, L, R;\nmint fact[614514];\n\nmint Comb(int n, int k) {\n  assert(0 <= k && k <= n);\n  //if (!(0 <= k && k <= n)) return 0;\n  return fact[n]/fact[k]/fact[n-k];\n}\n\nmint Calc(int L) {\n  auto ret = Comb(L+N, N)/fact[N];\n  vector<mint> f(L+1);\n  rep(l, N-M+1) {\n    mint coef = Comb(N-M, l) * mint(-1).pow(l);\n    for (int idx=M; idx<=L; idx+=l+M) {\n      f[idx] -= coef;\n    }\n    for (int idx=M+l; idx<=L; idx+=l+M) {\n      f[idx] += coef;\n    }\n  }\n  rep(j, L+1) {\n    int k = L-j;\n    ret -= Comb(k+N, N)*f[j]/fact[M]/fact[N-M];\n  }\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  fact[0] = 1;\n  reps(i, 1, 614514) {\n    fact[i] = fact[i-1] * i;\n  }\n\n  cin >> N >> M >> L >> R;\n  auto ans = (Calc(R) - Calc(L-1)) * fact[N];\n  cout << ans.a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7;\n\nvector<ll> fact, inv;\n\nll modInv(ll a, ll b = MOD-2) {\n\tif (b & 1) return a * modInv(a, b^1) % MOD;\n\telse if (b == 0) return 1;\n\telse return modInv(a*a % MOD, b / 2);\n}\nll choose(int a, int b) {\n\tif (a < b) return 0;\n\tll dv = inv[a-b] * inv[b] % MOD;\n\treturn fact[a] * dv % MOD;\n}\n\n//   \\sum_{v = 0}^{t} \\sum_{s = 0}^{v} \\sum_{c = k}^{n} -1^{c-k} (n choose k) (n-k choose c-k) ((n-1 + v-sc choose n-1) - (n-1 + v-k-sc choose n-1))\n// = \\sum_{c = k}^{n} -1^{c-k} (n choose k) (n-k choose c-k) \\sum_{v = 0}^{t} \\sum_{s = 0}^{v/c} ((n-1 + v-sc choose n-1) - (n-1 + v-k-sc choose n-1))\n// = \\sum_{c = k}^{n} -1^{c-k} (n choose k) (n-k choose c-k) \\sum_{s = 0}^{t/c} \\sum_{x = t-k-sc}^{t-sc} (n-1 + x choose n-1)\nll solve(int n, int k, int t) {\n\tll res = choose(n+t, n);\n\tfor (int c = k; c <= n; ++c) {\n\t\tll v1 = ((c-k) % 2 ? -1 : 1) * choose(n, k) * choose(n-k, c-k) % MOD;\n\t\tll v2 = 0;\n\t\tfor (int s = 0; s*c <= t; ++s) v2 += choose(n + t - s*c, n);\n\t\tfor (int s = 0; s*c <= t-k; ++s) v2 -= choose(n + t-k - s*c, n);\n\t\tres = (res - v1 * (v2 % MOD)) % MOD;\n\t}\n\treturn res + MOD*(res < 0);\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n, m, v0, v1;\n\tcin >> n >> m >> v0 >> v1;\n\n\tfact.resize(n + v1 + 1, 1);\n\tinv.resize(n + v1 + 1, 1);\n\tfor (int i = 1; i <= n + v1; ++i) {\n\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\tinv[i] = modInv(fact[i]);\n\t}\n\n\tll res = solve(n, m, v1) - solve(n, m, v0-1);\n\tcout << res + MOD*(res < 0) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nnamespace io{\n\tconst int l=1<<20;\n\tchar buf[l],*s,*t;\n\tinline char gc(){\n\t\tif(s==t){\n\t\t\tt=(s=buf)+fread(buf,1,l,stdin);\n\t\t\treturn s==t?EOF:*s++;\n\t\t}\n\t\treturn *s++;\n\t}\n\tchar c;\n\ttemplate<class IT>inline void gi(IT &x){\n\t\tx=0;c=gc();while(c<'0'||c>'9')c=gc();\n\t\twhile('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^'0');c=gc();}\n\t}\n};\nusing io::gi;\nstruct qwq{\n\tint a,b;\n\tinline bool operator<(const qwq &x)const{\n\t\treturn a<x.a;\n\t}\n};\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\nconst ll p=1000000007ll,pp=p*p,inf=1000000000000000000ll;\nconst int N=600000,MN=600005,p2=1000000005;\nll fac[MN],ifa[MN],cn[MN],cm[MN];\nint mn,m0;\ninline ll f(int a,int b,int k){\n//\tprintf(\"f(%d,%d,%d)=\",a,b,k);\n//\tif(k<m0*a)printf(\"00\\n\");\n\tif((k-=m0*a)<0)return 0ll;\n\tint i,r=min(mn,k/b);ll ans=0ll;\n\tfor(i=0;i<=r;++i){\n\t\tif(i&1)ans=(ans-cn[k-b*i]*cm[i]+pp)%p;\n\t\telse   ans=(ans+cn[k-b*i]*cm[i]   )%p;\n\t}\n//\tprintf(\"%lld\\n\",ans);\n\treturn ans;\n}\ninline ll expo(ll a,int b){\n\tll c=1ll;\n\twhile(b){\n\t\tif(b&1)c=c*a%p;\n\t\tb>>=1; a=a*a%p;\n\t}\n\treturn c;\n}\nint main(){\n\tint n,m,l,r,i,ii;ll ans;\n\tscanf(\"%d%d%d%d\",&n,&m,&l,&r);--l;mn=n-(m0=m);\n\tfac[0]=1ll;\n\tfor(i=1;i<=N ;++i)fac[i]=fac[i-1]*i%p;\n\tifa[N]=expo(fac[N],p2);\n\tfor(i=N;i    ;--i)ifa[i-1]=ifa[i]*i%p;\n\tans=ifa[n];\n\tfor(i=n;i<=N ;++i)cn[i-n]=ans*(fac[i]*ifa[ i-n]%p)%p;\n\tans=fac[m];\n\tfor(i=0;i<=mn;++i)cm[i  ]=ans*(ifa[i]*ifa[mn-i]%p)%p;\n\tans=0ll;ii=r/m;\n//\tprintf(\"ans=%lld n=%d m=%d mn=%d r=%d l=%d ii=%d\\n\",ans,n,m,mn,r,l,ii);\n\tfor(i=1;i<=ii;++i)ans-=f(i,i,r)-f(i+1,i,r)-f(i,i,l)+f(i+1,i,l);\n//\tprintf(\"ans=%lld ans%%p=%lld\\n\",ans,(ans%p+p)%p);\n\tprintf(\"%lld\",( ((ans%p+p)%p)*(fac[n]*(ifa[m]*ifa[mn]%p)%p)+cn[r]-cn[l]+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=6e5+5;\nint n,m,L,R,fac[N],vf[N],inv[N],i;\ninline int C(int x,int y){\n\treturn 1ll*vf[y]*vf[x-y]%mo*fac[x]%mo;\n}\ninline int calc(int s){\n\tint i,j,ans=C(s+n,n),ss=0,x;\n\tfor(i=0;i<=s;++i){\n\t\tint z=0;\n\t\tfor(j=0;1ll*(i+1)*(j+n-m)<=s && j<=m;++j){\n\t\t\tx=1ll*C(s-(j+n-m)*(i+1)+n,n)*C(m,j)%mo;\n\t\t\tif(j&1)z=(z+mo-x)%mo;else z=(z+x)%mo;\n\t\t}\n\t\tfor(j=0;1ll*(i+1)*(n-m)+i*j<=s && j<=m;++j){\n\t\t\tx=1ll*C(s-j*i-(n-m)*(i+1)+n,n)*C(m,j)%mo;\n\t\t\tif(j&1)z=(z+x)%mo;else z=(z+mo-x)%mo;\n\t\t}\n\t\tss=(ss+z)%mo;\n\t}\n\tans=(ans+mo-1ll*ss*C(n,m)%mo)%mo;\n\treturn ans;\n}\nint main(){\n\tfor(i=*fac=*vf=1;i<N;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mo,\n\t\tinv[i]=i==1?1:1ll*(mo-mo/i)*inv[mo%i]%mo,\n\t\tvf[i]=1ll*vf[i-1]*inv[i]%mo;\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);m=n-m;\n\tprintf(\"%d\\n\",(calc(R)+mo-calc(L-1))%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline int kazu(int a, const int &b) {return (a += b) >= MOD ? a - MOD : a;}\ninline int hiku(int a, const int &b) {return (a -= b) < 0 ? a + MOD : a;}\n\ninline ll fastpow(ll bas, ll ex){\n\tregister ll res = 1; bas %= MOD;\n\tfor(; ex; ex >>= 1, bas = bas * bas % MOD) if(ex & 1) res = res * bas % MOD;\n\treturn res;\n}\n\nint N, M, L, R;\nll fac[600005] = {1}, ifac[600005];\n\ninline void initfac(const int &lim){\n\tfor(register int i = 1; i <= lim; i++) fac[i] = fac[i - 1] * i % MOD;\n\tifac[lim] = fastpow(fac[lim], MOD - 2);\n\tfor(register int i = lim; i >= 1; i--) ifac[i - 1] = ifac[i] * i % MOD;\n}\n\ninline ll C(const int &n, const int &m) {return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;}\n\ninline int calc2(int S, const int &l, const int &r){\n\tif((S -= M * (ll)r) < 0) return 0; int res = 0;\n\tfor(register int i = 0, sgn = 1; i <= N - M && S >= 0; i++, sgn = sgn * (MOD - 1LL) % MOD, S -= l)\n\t\tres = kazu(res, sgn * C(S + N, N) % MOD * C(N - M, i) % MOD);\n\treturn res * C(N, M) % MOD;\n}\n/*\t∑A[i] + B = S, A[1 .. M] >= r, 0 <= A[M + 1 .. N] < l\n==>\t∑A[i] + B = S - M * r, A[1 .. M] >= 0, 0 <= A[M + 1 .. N] < l */\n\ninline int calc(const int &S){\n\tint res = C(S + N, N);\n\tfor(register int i = S; i; i--) res = hiku(res, hiku(calc2(S, i, i), calc2(S, i, i + 1)));\n\treturn res;\n}\n/*\t∑A[i] <= S\n==>\t∑A[i] + B = S */\n\nint main(){\n\tgetint(N), getint(M), getint(L), getint(R), initfac(R + N);\n\treturn printf(\"%d\\n\", hiku(calc(R), calc(L - 1))), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=1e9+7;\n\n//繰り返し二乗法\nll power(ll a,ll b){\n\tll res=1;\n\twhile(b>0){\n\t\tif(b&1)res=res*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nstruct perm{\nprivate:\n\tint sz;\n\tvector<ll> p,invp;\npublic:\n\tperm(int n){\n\t\tsz=n+1;\n\t\tp.resize(sz),invp.resize(sz);\n\t\tp[0]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i]=p[i-1]*i%mod;\n\t\t}\n\t\tinvp[sz-1]=power(p[sz-1],mod-2);\n\t\tfor(int i=sz-2;i>=0;i--){\n\t\t\tinvp[i]=invp[i+1]*(i+1)%mod;\n\t\t}\n\t}\n\tll comb(ll x,ll y){\n\t\tif(x<y||y<0)return 0;\n\t\treturn (p[x]*invp[x-y]%mod)*invp[y]%mod;\n\t}\n};\nperm p(1<<20);\n\nll n,m,l,r; \n\nll extra(ll R){\n\tll res=0;\n\tfor(int i=1;i<=R;i++){\n\t\tll cnt=0;\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=mod-p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=mod-p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tres+=(cnt+mod)%mod;\n\t}\n\treturn res%mod;\n}\n\nint main(){\n\tcin >> n >> m >> l >> r;\n\tll ans=p.comb(r+n,r)-p.comb(l-1+n,n);\n\t//ここから余事象を引いていく\n\tll cnt=(extra(r)-extra(l-1)+mod)%mod;\n\tcout << (ans-cnt%mod*p.comb(n,n-m)%mod+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=1e9+7;\n\nstruct perm {\nprivate:\n\tll sz;\n\tvector<ll> inv, p, invp;\npublic:\n\tperm(ll n) {\n\t\tsz=n+1;\n\t\tinv.resize(sz), p.resize(sz), invp.resize(sz);\n\t\tp[0] = inv[0] = invp[0] = 1;\n\t\tinv[1]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i] = p[i-1]*i%mod;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n\t\t\tinvp[i+1]=invp[i]*inv[i+1]%mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n};\nperm p(1000010);\n\nll n,m,l,r; \n\nll extra(ll R){\n\tll res=0;\n\tfor(int i=1;i<=R;i++){\n\t\tll cnt=0;\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=mod-p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=mod-p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tres+=(cnt+mod)%mod;\n\t}\n\treturn res%mod;\n}\n\nint main(){\n\tcin >> n >> m >> l >> r;\n\tll ans=p.comb(r+n,r)-p.comb(l-1+n,n);\n\t//ここから余事象を引いていく\n\tll cnt=(extra(r)-extra(l-1)+mod)%mod;\n\tcout << (ans-cnt%mod*p.comb(n,n-m)%mod+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n/*\n[p^N] N! exp(Np) = N^N\n\n************\n*********\nooooooo\n******\n****\n***\n**\n\nN! [q^{L...R}] \\sum_{k=0}^R ([p^{M-1}] exp(p(q^{k+1} + q^{k+2} + ... + q^R)) (exp(p q^k) - 1)/p) ([p^{N-M}] exp(p (1 + q + q^2 + ... + q^{k-1})))\nN! [q^{L...R}] \\sum_{k=0}^R ([p^{M}] exp(pq^{k}/(1-q)) - exp(pq^{k+1}/(1-q))) ([p^{N-M}] exp(p (1-q^k) / (1-q)))\nN! [q^{L...R}] \\sum_{k=0}^R ((q^k/(1-q))^M - (q^{k+1}/(1-q))^M) / M! ((1-q^k) / (1-q))^{N-M} / (N-M)!\n\\binom{N}{M} [q^{L...R}] 1/(1-q)^N \\sum_{k=0}^R (q^{kM} - q^{(k+1)M}) (1-q^k)^{N-M}\n\\binom{N}{M} [q^R] (1-q^{R-L+1})/(1-q) 1/(1-q)^N \\sum_{k=0}^R (q^{kM} - q^{(k+1)M}) (1-q^k)^{N-M}\n\\binom{N}{M} [q^R] (1-q^{R-L+1}) 1/(1-q)^{N+1} \\sum_{k=0}^R q^{kM)} (1- q^M) (1-q^k)^{N-M}\n\\binom{N}{M} [q^R] (1-q^{R-L+1}) (1-q^M)/(1-q)^{N+1} \\sum_{k=0}^R q^{kM} (1-q^k)^{N-M}\n\nN! [q^{L...R}] [p^N] exp(p (1 + q + q^2 + ... + q^R))\nN! [q^{L...R}] 1/(1-q)^N / N!\n[q^R] (1-q^{R-L+1})/(1-q) 1/(1-q)^N\n[q^R] (1-q^{R-L+1}) 1/(1-q)^{N+1}\n\\binom{N+R}{R} - \\binom{N+L-1}{L-1}\n*/\n\nconstexpr int mod = 1000000007;\nconstexpr int MAX = 600000;\nint fact[MAX+1];\nint ifact[MAX+1];\nlong long int dp[MAX+1];\n\nint pow(int x, int n){\n  int r = 1;\n  for(; n; n >>= 1){\n    if(n&1) r = (long long) r * x % mod;\n    x = (long long) x * x % mod;\n  }\n  return r;\n}\n\nint binom(int n, int k){\n  return (long long) fact[n] * ifact[k] % mod * ifact[n-k] % mod;\n}\n\nint n, m, l, r;\n\nint main(){\n  fact[0] = 1;\n  for(int i = 1; i <= MAX; i++) fact[i] = (long long) i * fact[i-1] % mod;\n  ifact[MAX] = pow(fact[MAX], mod-2);\n  for(int i = MAX-1; i >= 0; i--) ifact[i] = (long long) (i+1) * ifact[i+1] % mod;\n\n  scanf(\"%d%d%d%d\", &n, &m, &l, &r);\n\n  for(int i = m; i <= r; i++){\n    int tmp = (long long) ifact[i-m] * ifact[n-i] % mod;\n    if((i-m)&1) tmp = mod-tmp;\n    for(int j = 1; j * i <= r; j++){\n      dp[j*i] += tmp;\n    }\n  }\n  for(int i = r; i >= r-l+1; i--) dp[i] -= dp[i - (r-l+1)];\n  for(int i = r; i >= m; i--) (dp[i] -= dp[i - m]) %= mod;\n \n  int ans = 0;\n  for(int i = 0; i <= r; i++){\n    ans = (ans + (long long) dp[r - i] * fact[n+i] % mod * ifact[i]) % mod;\n  }\n  ans = (long long) ans * ifact[m] % mod;\n\n  ans = binom(n + r, r) - ans;\n  if(ans < 0) ans += mod;\n  ans = ans - binom(n + l - 1, l - 1);\n  if(ans < 0) ans += mod;\n  if(ans < 0) ans += mod;\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007; // 2^23 * 119 + 1\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x < MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\ttemplate <typename U>\n\texplicit operator U() const { return (U)val; }\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint modex(Mint a, ll p) {\n\t\tassert(p >= 0);\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nconst int MAXN = 600005;\nMint fac[MAXN], invfac[MAXN];\nMint binom(ll a, ll b) {\n\tif (b < 0) return 0;\n\tif (b > a) return 0;\n\treturn fac[a] * invfac[b] * invfac[a - b];\n}\nint main() {\n\t// Mint version.\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tfac[i] = fac[i - 1] * i;\n\tinvfac[MAXN - 1] = 1 / fac[MAXN - 1];\n\tfor (int i = MAXN - 2; i >= 0; --i)\n\t\tinvfac[i] = invfac[i + 1] * (i + 1);\n\tint N, M, L, R;\n\tscanf(\"%d%d%d%d\", &N, &M, &L, &R);\n\tvector<Mint> sub(R + 1), denom(R + 1);\n\tMint w = binom(N, M);\n\tfor (int k = 0; k <= R; ++k) {\n\t\tfor (int i = 0; i <= N - M; ++i) {\n\t\t\tll p = (ll)M * k + (ll)i * k;\n\t\t\tif (p > R) break;\n\t\t\tMint coeff = binom(N - M, i);\n\t\t\tif (i & 1) coeff = -coeff;\n\t\t\tsub[p] += coeff * w;\n\t\t}\n\t}\n\tfor (int i = R; i >= M; --i) {\n\t\tsub[i] = sub[i - M] - sub[i];\n\t}\n\tsub[0]++;\n\tsub.resize(R + 1);\n\tMint ans = 0;\n\tfor (int i = 0; i <= R; ++i) {\n\t\tans += binom(N + i, i) * sub[R - i];\n\t}\n\tfor (int i = 0; i <= L - 1; ++i) {\n\t\tans -= binom(N + i, i) * sub[L - 1 - i];\n\t}\n\tprintf(\"%d\\n\", ans.val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(a)a.begin(),a.end()\nusing ll=long long;\nconst int INF = 1<<30;\nconst ll INFll =1LL<<62;\nconst int mod= int(1e9)+7;\n//const int mod=998244353;\nusing P = pair<int,int>;\nusing Pl= pair<ll,ll>;\nusing ld=long double;\nusing V=vector<int>;\nusing Vl=vector<ll>;\nusing VV=vector<vector<int>>;\nusing VVl=vector<vector<ll>>;\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<mod>;\n\nconst int MAX = 510000;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\n ll nPr(int n, int r) {\n    if (n < 0 || r < 0 || n < r) return 0;\n    return fac[n] * finv[n - r] % mod;\n}\n\n\nint main(){\n    COMinit();\n    ll n,m,l,r;cin >>n>>m>>l>>r;\n    mint ans;\n    //(1-x^m)/(1-x)^(n+1)\n    vector<mint>dp(r+1,0);\n    for (int i = 0; i <=r; ++i) {\n        dp[i]=COM(n+i,n);\n    }\n    auto nx=dp;\n    for (int i =m; i <=r; ++i) {\n        dp[i]-=nx[i-m];\n    }\n//    for (int i = 0; i <=r; ++i) {\n//        cout <<dp[i]<<\" \";\n//    }\n//    cout <<endl;\n//ok\n    //sum(k~)x^km*(1-x^k)^(n-m)\n    vector<mint>G(r+1,0);\n    for (int k =1; k <=r; ++k){\n        vector<mint>P(r+1,0);\n        P[0]=1;\n        //x^km\n        vector<mint>nx(r+1,0);\n        for (int i = 0; i <=r; ++i) {\n            if(i+k*m>r)break;\n            nx[i+k*m]=P[i];\n        }\n        P=nx;\n//        for(auto p:P){\n//            cout <<p<<\" \";\n//        }\n//        cout <<endl;\n//ok\n        //*(1-x^k)^(n-m)\n        for (int i = 0; i <=n-m; ++i) {\n            for (int j = 0; j <=r; ++j) {\n                if (j + k * i > r)break;\n                G[j + k * i] += P[j] * COM(n - m, i) * ((i % 2 == 1) ? -1 : 1);\n            }\n        }\n//        cout <<k<<endl;\n//        for(auto g:G){\n//            cout <<g<<\" \";\n//        }\n//        cout <<endl;\n//ok\n    }\n    mint U=COM(r+n,n);\n    mint plus=0;\n    for (int i = 0; i <=r; ++i) {\n        plus+=dp[i]*G[r-i];\n    }\n    plus=U-plus*COM(n,m);\n    U=COM(l-1+n,n);\n    mint sub=0;\n    for (int i = 0; i < l; ++i) {\n        sub+=dp[i]*G[l-i-1];\n    }\n    sub=U-sub*COM(n,m);\n    ans=plus-sub;\n    cout <<ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pii pair<int,int>\nusing namespace std;\nconst int inf = 2147483647;\nconst int mod = 1e9 + 7;\nconst int N = 600001;\n\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint n, m, jc[N], inv[N];\n\nint add(int x, int y) {x += y; return x >= mod ? x - mod : x;}\nint dec(int x, int y) {x -= y; return x < 0 ? x + mod : x;}\nint C(int n, int m) {return (LL)jc[n] * inv[m] % mod * inv[n - m] % mod;}\nint pow_mod(int a, int k) {int ans = 1; for(; k; k >>= 1, a = (LL)a * a % mod) if(k & 1) ans = (LL)ans * a % mod; return ans;}\n\nint gt(LL S, int rr) {\n\tif(S < 0) return 0;\n\tint ans = 0;\n\tfor(int i = 0, t = 0; i <= S && t <= n - m; i += rr, t++) {\n\t\tif(t & 1) ans = dec(ans, (LL)C(n - m, t) * C(n + S - i, n) % mod);\n\t\telse ans = add(ans, (LL)C(n - m, t) * C(n + S - i, n) % mod);\n\t} return (LL)ans * C(n, m) % mod;\n}\n\nint solve(int n, int S) {\n\tint ans = C(n + S, n);\n\tfor(int i = 1; i <= S; i++) ans = dec(ans, dec(gt(S - (LL)m * i, i), gt(S - (LL)m * (i + 1), i)));\n\treturn ans;\n}\n\nint main() {\n\tn = read(), m = read(); int l = read(), r = read();\n\tjc[0] = 1; for(int i = 1; i <= n + r; i++) jc[i] = (LL)jc[i - 1] * i % mod;\n\tinv[n + r] = pow_mod(jc[n + r], mod - 2); for(int i = n + r; i >= 1; i--) inv[i - 1] = (LL)inv[i] * i % mod;\n\tput(dec(solve(n, r), solve(n, l - 1)));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6+10;\nconst int P = 1e9+7;\n#define fr(i,low,up,st) for(register int i = low;i <= up;i += st)\n#define nfr(i,low,up,st) for(register int i = low;i >= up;i -= st)\n#define size(a) a.size()\n#define fill(a,b) memset(a,b,sizeof a)\n\nint fact[N],inv[N];\n\ninline int pow_mod(int x,int k){\n   int res = 1,base = x;\n   while(k){\n      if(k&1)res = 1LL*res*base%P;\n      k >>= 1;\n      base = 1LL*base*base%P;\n   }\n   return res;\n}\n\nvoid init(){\n   fact[0] = inv[0] = 1;\n   fr(i,1,N-1,1)fact[i] = 1LL*fact[i-1]*i%P;\n   inv[N-1] = pow_mod(fact[N-1],P-2);\n   nfr(i,N-2,1,1)inv[i] = 1LL*inv[i+1]*(i+1)%P;\n}\n\ninline int c(int n,int m){\n   return 1LL*fact[n]*inv[n-m]%P*inv[m]%P;\n}\n\nvoid Mod(int &x){\n   x = (x>=P)?x-P:x;\n   x = (x<0)?x+P:x;\n}\nint n,m;\nint calc(int up,int a,int b){\n   int pans = 0;\n   for(int k = 0;k*(b+1)+a*m <= up && k+m <= n; ++k){\n      Mod(pans += 1LL*pow_mod(-1,k)*c(up-a*m-k*(b+1)+n,n)*c(n-m,k)%P);\n   }\n   //cerr << up <<' '<< a << ' ' << b <<' ' << pans << endl;\n   return 1LL*pans*c(n,m)%P;\n}\n\nint solve(int up){\n   int ans = 0;\n   fr(i,1,up,1){\n      Mod(ans += calc(up,i,i-1)-calc(up,i+1,i-1));\n      //cerr << i <<' '<< ans << endl;\n   }\n   Mod(ans = c(up+n,n)-ans);\n   return ans;\n}\n\nint main(){\n   init();\n   int L,R;\n   scanf(\"%d%d%d%d\",&n,&m,&L,&R);\n   int fans = 0;\n   Mod(fans = solve(R)-solve(L-1));\n   printf(\"%d\\n\",fans);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nmint solve(int N,int M,int S){\n\tint L = N - M, R = M;\n\tmint ans = 0;\n\tfor(int x=1;x<=S;x++){\n\t\tmint pans = ans;\n\t\tfor(int y : {x,x+1}){\n\t\t\tll SS = S - (ll)y * R;\n\t\t\tif(SS < 0) continue;\n\t\t\tmint tmp = 0;\n\t\t\trep(k,L+1){\n\t\t\t\tll SSS = SS - (ll)k * x;\n\t\t\t\tif(SSS < 0) break;\n\t\t\t\tif(k%2 == 0) tmp += Choose(L,k) * Choose(SSS+N,N);\n\t\t\t\telse tmp -= Choose(L,k) * Choose(SSS+N,N);\n\t\t\t}\n\t\t\tif(y == x) ans += tmp;\n\t\t\telse ans -= tmp;\n\t\t}\n\t\tshow(x);\n\t\tshow(ans-pans);\n\t}\n\tshow(ans);\n\tans *= Choose(N,L);\n\tans = Choose(S+N,N) - ans;\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\tInitFact(1000000);\n\tint N,M,L,R;\n\tcin >> N >> M >> L >> R;\n\tcout << solve(N,M,R) - solve(N,M,L-1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nusing ll = long long;\nconst int MX = 1000100;\nll f[MX],inv[MX],fi[MX];\nconstexpr ll mod = 1000000007;\nvoid solve(){\n    inv[1] = 1;\n    for(int i=2;i<MX;i++){\n        inv[i] = mod - (mod/i)*inv[mod%i]%mod;\n    }\n   f[0] = fi[0] = 1;\n    for(int i=1;i<MX;i++){\n        f[i] = f[i-1]*i%mod;\n        fi[i] = fi[i-1]*inv[i]%mod;\n    }\n}\n\nll nck(ll n, ll k){\n    if(n<0 || k<0 || n<k) return 0;\n    return f[n]*fi[k]%mod*fi[n-k]%mod;\n}\n\nll val(ll l,ll r, ll n){\n    return (nck(r + n,n) - nck(l + n - 1,n) + mod)%mod;\n}\nint main(){\n    ll i,j,n,m,l,r;\n    cin >> n >> m >> l >> r;\n    solve();\n    ll ans1 = val(l,r,n),ans2 = 0,f = 1;\n    for(i=0;i<=n - m;i++){\n        ll sum = 0;\n        for(j=0;(m + i)*j<=(r - m);j++){\n            (sum += (val(l - (m + i)*(j + 1),r - (m + i)*(j + 1),n) - val(l - m*(j + 1) - i*j,r - m*(j + 1) - i*j,n) + mod)) %= mod;\n        }\n        ll x = nck(n - m,i)*sum%mod;\n        ans2 += f*x;\n        if(ans2<0) ans2 += mod;\n        ans2 %= mod;\n        f *= -1;\n    }\n    cout << (ans1 - nck(n,m)*ans2%mod + mod)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi(i, a, b) for(int i = a; i <= b; i++)\n#define fid(i, a, b) for(int i = a; i >= b; i--)\n#define TTT \"BAI6\"\n#define maxn 300005\nusing namespace std;\nint n, m  ;\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    freopen(TTT\".inp\", \"r\", stdin);\n    freopen(TTT\".out\", \"w\", stdout);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define maxn 600100\n#define base 1000000007\n\nusing namespace std;\n\nint n,m,l,r;\nll fac[maxn],finv[maxn],inv[maxn],ans;\n\nvoid init() {\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<maxn;i++) {\n        inv[i] = base - inv[base%i]*(base/i)%base;\n        fac[i] = (1ll*fac[i-1]*i)%base;\n        finv[i] = (finv[i-1]*inv[i])%base;\n    }\n}\n\nll C(int k,int n) {\n    if (n<k||k<0) return 0;\n    return fac[n]*finv[k]%base*finv[n-k]%base;\n}\n\nll solve2(int R1,int n,int m,int x) {\n    ll tmp=0;\n    if (R1<0) return 0;\n    for (int k=0;k<=n-m&&k*x<=R1;k++) {\n        int R2 = R1-k*x;\n        ll ea = C(k,n-m) * C(R2,R2+n)%base;\n        if (k%2==0) tmp = (tmp+ea)%base;\n        else tmp = (tmp-ea+base)%base;\n    }\n    return tmp;\n}\n\nll solve(int R,int n,int m) {\n    ll tmp = C(R,R+n);\n    for (int x=1;m*x<=R;x++) tmp = (tmp - C(m,n)*(solve2(R-x*m,n,m,x) - solve2(R-(x+1)*m,n,m,x)+base)%base + base)%base;\n    return tmp;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin);\n    cin>>n>>m>>l>>r;\n    init();\n    ans = (solve(r,n,m) - solve(l-1,n,m) + base)%base;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-5;\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(1 << 20);\nll calc(int n, int m, int r) {\n\tll res = 0;\n\t//cout << \"hello\" << endl;\n\tfor (int t = 1; t <= r; t++) {\n\t\tint s = r - m * t;\n\t\tif (s < 0)break;\n\t\tll sum = 0;\n\t\tfor (int j = 0; j <= n - m; j++) {\n\t\t\tint ss = s - t * j;\n\t\t\tif (ss < 0)break;\n\t\t\tll csum = p.comb(n - m, j)*p.comb(n + ss, n) % mod;\n\t\t\tif (j % 2 == 0) {\n\t\t\t\tsum += csum;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum -= csum;\n\t\t\t}\n\t\t}\n\t\tsum = (sum%mod + mod) % mod;\n\t\ts -= m;\n\t\tif (s >= 0) {\n\t\t\tfor (int j = 0; j <= n - m; j++) {\n\t\t\t\tint ss = s - t * j;\n\t\t\t\tif (ss < 0)break;\n\t\t\t\tll csum = p.comb(n - m, j)*p.comb(n + ss, n) % mod;\n\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\tsum -= csum;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsum += csum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum = (sum%mod + mod) % mod;\n\t\tres += sum;\n\t\t//cout << sum << endl;\n\t}\n\tres %= mod;\n\tres = res * p.comb(n, m) % mod;\n\tll orians = p.comb(n + r, n);\n\t//cout << res << \" \" << orians << endl;\n\torians -= res; if (orians < 0)orians += mod;\n\treturn orians;\n}\nvoid solve(){\n\tint n, m, l, r;\n\tcin >> n >> m >> l >> r;\n\tll ans = calc(n, m, r) - calc(n, m, l - 1);\n\tif (ans < 0)ans += mod;\n\tcout << ans << endl;\n}\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//init();\n\tsolve();\n\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\ntemplate <typename T> using posteriority_queue = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n// const int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> void unique(vector<T> &a) { a.erase(unique(ALL(a)), a.end()); }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint mod = MOD;\nstruct ModInt {\n  unsigned val;\n  ModInt(): val(0) {}\n  ModInt(ll x) : val(x >= 0 ? x % mod : x % mod + mod) {}\n  ModInt pow(ll exponent) {\n    ModInt tmp = *this, res = 1;\n    while (exponent > 0) {\n      if (exponent & 1) res *= tmp;\n      tmp *= tmp;\n      exponent >>= 1;\n    }\n    return res;\n  }\n  ModInt &operator+=(const ModInt &x) { if((val += x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator-=(const ModInt &x) { if((val += mod - x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator*=(const ModInt &x) { val = static_cast<unsigned long long>(val) * x.val % mod; return *this; }\n  ModInt &operator/=(const ModInt &x) {\n    // assert(__gcd(static_cast<int>(x.val), mod) == 1);\n    unsigned a = x.val, b = mod; int u = 1, v = 0;\n    while (b) {\n      unsigned tmp = a / b;\n      swap(a -= tmp * b, b);\n      swap(u -= tmp * v, v);\n    }\n    return *this *= u;\n  }\n  bool operator==(const ModInt &x) const { return val == x.val; }\n  bool operator!=(const ModInt &x) const { return val != x.val; }\n  bool operator<(const ModInt &x) const { return val < x.val; }\n  bool operator<=(const ModInt &x) const { return val <= x.val; }\n  bool operator>(const ModInt &x) const { return val > x.val; }\n  bool operator>=(const ModInt &x) const { return val >= x.val; }\n  ModInt &operator++() { if (++val == mod) val = 0; return *this; }\n  ModInt operator++(int) { ModInt res = *this; ++*this; return res; }\n  ModInt &operator--() { val = (val == 0 ? mod : val) - 1; return *this; }\n  ModInt operator--(int) { ModInt res = *this; --*this; return res; }\n  ModInt operator+() const { return *this; }\n  ModInt operator-() const { return ModInt(val ? mod - val : 0); }\n  ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n  ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n  ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n  ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n  friend ostream &operator<<(ostream &os, const ModInt &x) { return os << x.val; }\n  friend istream &operator>>(istream &is, ModInt &x) { ll val; is >> val; x = ModInt(val); return is; }\n};\nModInt abs(const ModInt &x) { return x; }\nstruct Combinatorics {\n  int val; // \"val!\" and \"mod\" must be disjoint.\n  vector<ModInt> fact, fact_inv, inv;\n  Combinatorics(int val = 10000000) : val(val), fact(val + 1), fact_inv(val + 1), inv(val + 1) {\n    fact[0] = 1;\n    FOR(i, 1, val + 1) fact[i] = fact[i - 1] * i;\n    fact_inv[val] = ModInt(1) / fact[val];\n    for (int i = val; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i;\n    FOR(i, 1, val + 1) inv[i] = fact[i - 1] * fact_inv[i];\n  }\n  ModInt nCk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val && k <= val);\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n  }\n  ModInt nPk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val);\n    return fact[n] * fact_inv[n - k];\n  }\n  ModInt nHk(int n, int k) {\n    if (n < 0 || k < 0) return ModInt(0);\n    return (k == 0 ? ModInt(1) : nCk(n + k - 1, k));\n  }\n};\n\ntemplate <typename T>\nfunction<vector<T>(const vector<T>&, const vector<T>&)> mul = [](const vector<T> &a, const vector<T> &b) {\n  int n = a.size(), m = b.size();\n  vector<T> res(n + m - 1, T(0));\n  REP(i, n) REP(j, m) res[i + j] += a[i] * b[j];\n  return res;\n};\n\ntemplate <typename T>\nfunction<bool(const T&, T&)> sqr = [](const T &a, T &res) {\n  res = T(sqrt(a));\n  return true;\n};\n\ntemplate <typename T>\nfunction<vector<T>(const vector<T>&, const vector<T>&)> mul = [](const vector<T> &a, const vector<T> &b) {\n  int n = a.size(), m = b.size();\n  vector<T> res(n + m - 1, T(0));\n  REP(i, n) REP(j, m) res[i + j] += a[i] * b[j];\n  return res;\n};\n\ntemplate <typename T>\nfunction<bool(const T&, T&)> sqr = [](const T &a, T &res) {\n  return false;\n};\n\ntemplate <typename T>\nstruct FPS {\n  vector<T> co;\n\n  FPS(int deg = 0) : co(deg + 1, T(0)) {}\n  FPS(const vector<T> &co) : co(co) {}\n  FPS(initializer_list<T> init) : co(init.begin(), init.end()) {}\n  template <typename InputIter> FPS(InputIter first, InputIter last) : co(first, last) {}\n\n  inline const T &operator[](int term) const { return co[term]; }\n  inline T &operator[](int term) { return co[term]; }\n\n  void resize(int deg) {\n    int prev = co.size();\n    co.resize(deg + 1);\n    if (prev < deg + 1) fill(co.begin() + prev, co.end(), T(0));\n  }\n\n  void shrink() { while (co.size() > 1 && co.back() == T(0)) co.pop_back(); }\n\n  int degree() const { return static_cast<int>(co.size()) - 1; }\n\n  FPS &operator=(const vector<T> &new_co) {\n    co.resize(new_co.size());\n    copy(ALL(new_co), co.begin());\n    return *this;\n  }\n\n  FPS &operator=(const FPS &x) {\n    co.resize(x.co.size());\n    copy(ALL(x.co), co.begin());\n    return *this;\n  }\n\n  FPS &operator+=(const FPS &x) {\n    int n = x.co.size();\n    if (n > co.size()) resize(n - 1);\n    REP(i, n) co[i] += x.co[i];\n    return *this;\n  }\n\n  FPS &operator-=(const FPS &x) {\n    int n = x.co.size();\n    if (n > co.size()) resize(n - 1);\n    REP(i, n) co[i] -= x.co[i];\n    return *this;\n  }\n\n  FPS &operator*=(T x) {\n    for (T &e : co) e *= x;\n    return *this;\n  }\n\n  FPS &operator*=(const FPS &x) { return *this = mul<T>(co, x.co); }\n\n  FPS &operator/=(T x) {\n    assert(x != T(0));\n    T inv_x = T(1) / x;\n    for (T &e : co) e *= inv_x;\n    return *this;\n  }\n\n  FPS &operator/=(const FPS &x) {\n    if (x.co.size() > co.size()) return *this = FPS();\n    int n = co.size() - x.co.size() + 1;\n    FPS a(co.rbegin(), co.rbegin() + n), b(x.co.rbegin(), x.co.rbegin() + min(static_cast<int>(x.co.size()), n));\n    b = b.inv(n - 1);\n    a *= b;\n    return *this = FPS(a.co.rend() - n, a.co.rend());\n  }\n\n  FPS &operator%=(const FPS &x) {\n    *this -= *this / x * x;\n    co.resize(static_cast<int>(x.co.size()) - 1);\n    if (co.empty()) co = {T(0)};\n    return *this;\n  }\n\n  FPS &operator<<=(int n) {\n    co.insert(co.begin(), n, T(0));\n    return *this;\n  }\n\n  FPS &operator>>=(int n) {\n    if (co.size() < n) return *this = FPS();\n    co.erase(co.begin(), co.begin() + n);\n    return *this;\n  }\n\n  bool operator==(const FPS &x) const {\n    FPS a(*this), b(x);\n    a.shrink(); b.shrink();\n    int n = a.co.size();\n    if (n != b.co.size()) return false;\n    REP(i, n) if (a.co[i] != b.co[i]) return false;\n    return true;\n  }\n\n  bool operator!=(const FPS &x) const { return !(*this == x); }\n\n  FPS operator+() const { return *this; }\n\n  FPS operator-() const {\n    FPS res(*this);\n    for (T &e : res.co) e = T(-e);\n    return res;\n  }\n\n  FPS operator+(const FPS &x) const { return FPS(*this) += x; }\n\n  FPS operator-(const FPS &x) const { return FPS(*this) -= x; }\n\n  FPS operator*(T x) const { return FPS(*this) *= x; }\n\n  FPS operator*(const FPS &x) const { return FPS(*this) *= x; }\n\n  FPS operator/(T x) const { return FPS(*this) /= x; }\n\n  FPS operator/(const FPS &x) const { return FPS(*this) /= x; }\n\n  FPS operator%(const FPS &x) const { return FPS(*this) %= x; }\n\n  FPS operator<<(int n) const { return FPS(*this) <<= n; }\n\n  FPS operator>>(int n) const { return FPS(*this) >>= n; }\n\n  T horner(T val) const {\n    T res = T(0);\n    for (int i = static_cast<int>(co.size()) - 1; i >= 0; --i) (res *= val) += co[i];\n    return res;\n  }\n\n  FPS differential() const {\n    int n = co.size();\n    assert(n >= 1);\n    FPS res(n - 1);\n    FOR(i, 1, n) res.co[i - 1] = co[i] * T(i);\n    return res;\n  }\n\n  FPS integral() const {\n    int n = co.size();\n    FPS res(n + 1);\n    REP(i, n) res[i + 1] = co[i] / T(i + 1);\n    return res;\n  }\n\n  FPS exp(int deg = -1) const {\n    assert(co[0] == T(0));\n    if (deg == -1) deg = static_cast<int>(co.size()) - 1;\n    FPS one({T(1)}), res = one;\n    for (int i = 1; i <= deg; i <<= 1) {\n      res *= FPS(co.begin(), co.begin() + min(static_cast<int>(co.size()), i << 1)) - res.log((i << 1) - 1) + one;\n      res.co.resize(i << 1);\n    }\n    res.co.resize(deg + 1);\n    return res;\n  }\n\n  FPS inv(int deg = -1) const {\n    assert(co[0] != T(0));\n    if (deg == -1) deg = static_cast<int>(co.size()) - 1;\n    FPS res({T(1) / co[0]});\n    for (int i = 1; i <= deg; i <<= 1) {\n      res = res + res - res * res * FPS(co.begin(), co.begin() + min(static_cast<int>(co.size()), i << 1));\n      res.co.resize(i << 1);\n    }\n    res.co.resize(deg + 1);\n    return res;\n  }\n\n  FPS log(int deg = -1) const {\n    assert(co[0] == T(1));\n    if (deg == -1) deg = static_cast<int>(co.size()) - 1;\n    FPS integrand = differential() * inv(deg - 1);\n    integrand.co.resize(deg);\n    return integrand.integral();\n  }\n\n  FPS pow(ll exponent, int deg = -1) const {\n    int n = co.size();\n    if (deg == -1) deg = n - 1;\n    REP(i, n) {\n      if (co[i] != T(0)) {\n        ll shift = exponent * i;\n        if (shift > deg) break;\n        T tmp = 1, base = co[i];\n        ll e = exponent;\n        while (e > 0) {\n          if (e & 1) tmp *= base;\n          base *= base;\n          e >>= 1;\n        }\n        return ((((*this >> i) * (T(1) / co[i])).log(deg - shift) * T(exponent)).exp(deg - shift) * tmp) << shift;\n      }\n    }\n    return FPS(deg);\n  }\n\n  FPS mod_pow(ll exponent, const FPS &md) const {\n    FPS inv_rev_md = FPS(md.co.rbegin(), md.co.rend()).inv();\n    int deg_of_md = md.co.size();\n    function<void(FPS&, const FPS&)> mod_mul = [&](FPS &multiplicand, const FPS &multiplier) {\n      multiplicand *= multiplier;\n      if (deg_of_md <= multiplicand.co.size()) {\n        int n = multiplicand.co.size() - deg_of_md + 1;\n        FPS quotient = FPS(multiplicand.co.rbegin(), multiplicand.co.rbegin() + n) * FPS(inv_rev_md.co.begin(), inv_rev_md.co.begin() + min(static_cast<int>(inv_rev_md.co.size()), n));\n        multiplicand -= FPS(quotient.co.rend() - n, quotient.co.rend()) * md;\n      }\n      multiplicand.co.resize(deg_of_md - 1);\n      if (multiplicand.co.empty()) multiplicand.co = {T(0)};\n    };\n    FPS res({T(1)}), base = *this;\n    mod_mul(base, res);\n    while (exponent > 0) {\n      if (exponent & 1) mod_mul(res, base);\n      mod_mul(base, base);\n      exponent >>= 1;\n    }\n    return res;\n  }\n\n  FPS sqrt(int deg = -1) const {\n    int n = co.size();\n    if (deg == -1) deg = n - 1;\n    if (co[0] == T(0)) {\n      FOR(i, 1, n) {\n        if (co[i] == T(0)) continue;\n        if (i & 1) return FPS(-1);\n        int shift = i >> 1;\n        if (deg < shift) break;\n        FPS res = (*this >> i).sqrt(deg - shift);\n        if (res.co.empty()) return FPS(-1);\n        res <<= shift;\n        res.resize(deg);\n        return res;\n      }\n      return FPS(deg);\n    }\n    T s;\n    if (!sqr<T>(co[0], s)) return FPS(-1);\n    FPS res({s});\n    T half = T(1) / T(2);\n    for (int i = 1; i <= deg; i <<= 1) {\n      (res += FPS(co.begin(), co.begin() + min(static_cast<int>(co.size()), i << 1)) * res.inv((i << 1) - 1)) *= half;\n    }\n    res.resize(deg);\n    return res;\n  }\n\n  FPS translate(T c) const {\n    int n = co.size();\n    vector<T> fact(n, T(1)), inv_fact(n, T(1));\n    FOR(i, 1, n) fact[i] = fact[i - 1] * T(i);\n    inv_fact[n - 1] = T(1) / fact[n - 1];\n    for (int i = n - 1; i > 0; --i) inv_fact[i - 1] = inv_fact[i] * T(i);\n    vector<T> g(n), ex(n);\n    REP(i, n) g[n - 1 - i] = co[i] * fact[i];\n    T pow_c = T(1);\n    REP(i, n) {\n      ex[i] = pow_c * inv_fact[i];\n      pow_c *= c;\n    }\n    vector<T> conv = mul<T>(g, ex);\n    FPS res(n - 1);\n    REP(i, n) res[i] = conv[n - 1 - i] * inv_fact[i];\n    return res;\n  }\n};\n\nint main() {\n  int n, m, l, r; cin >> n >> m >> l >> r;\n  Combinatorics com(n + r);\n  FPS<ModInt> f(r), p(r), q(r);\n  for (int i = 0; i + m <= r; ++i) f[i + m] = com.nCk(n - m, i) * (i & 1 ? -1 : 1);\n  // REP(i, r + 1) cout << f[i] << \" \\n\"[i == r];\n  FOR(i, 1, r + 1) {\n    p[0] += f[0];\n    int pos = 1;\n    for (int j = i; j <= r; j += i, ++pos) p[j] += f[pos];\n  }\n  // REP(i, r + 1) cout << p[i] << \" \\n\"[i == r];\n  REP(i, r + 1) q[i] = com.nCk(n + i, i);\n  // REP(i, r + 1) cout << q[i] << \" \\n\"[i == r];\n  q -= q << m;\n  function<ModInt(int)> calc = [&](int x) {\n    ModInt now = 0;\n    REP(i, x + 1) now += p[i] * q[x - i];\n    // cout << com.nHk(x + 1, n) << ' ' << now << ' ' << com.nCk(n, m) << '\\n';\n    return com.nHk(x + 1, n) - now * com.nCk(n, m);\n  };\n  cout << calc(r) - calc(l - 1) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 300010;\nconst int mod = 1e9 + 7;\n\nint n, m, fact[N << 1], invf[N << 1];\n\nint qpow(int x, int y)\n{\n\tint out = 1;\n\twhile (y)\n\t{\n\t\tif (y & 1) out = (ll) out * x % mod;\n\t\tx = (ll) x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn out;\n}\n\nint c(int x, int y)\n{\n\treturn (ll) fact[x] * invf[y] % mod * invf[x - y] % mod;\n}\n\nint f(int x, int y)\n{\n\tint out = 0;\n\tfor (int i = 0; i * x <= y && i <= n - m; ++i)\n\t{\n\t\tout = (out + (i & 1 ? -1ll : 1ll) * c(n - m, i) * c(n + y - i * x, n) % mod + mod) % mod;\n\t}\n\treturn out;\n}\n\nint solve(int r)\n{\n\tint out = c(n + r, r);\n\tfor (int x = 1; x <= r / m; ++x)\n\t{\n\t\tout = (out + (ll) c(n, m) * (f(x, r - m * (x + 1)) - f(x, r - m * x) + mod)) % mod;\n\t}\n\treturn out;\n}\n\nint main()\n{\n\tint l, r;\n\t\n\tcin >> n >> m >> l >> r;\n\t\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n + r; ++i) fact[i] = (ll) fact[i - 1] * i % mod;\n\tinvf[n + r] = qpow(fact[n + r], mod - 2); \n\tfor (int i = n + r; i >= 1; --i) invf[i - 1] = (ll) invf[i] * i % mod;\n\t\n\tcout << (solve(r) - solve(l - 1) + mod) % mod;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod = 1e9 + 7;\nint quickpow(int m, int p)\n{\n    int res = 1;\n    while (p) {\n        if (p & 1)\n            res = res * m % mod;\n        m = m * m % mod;\n        p >>= 1;\n    }\n    return res;\n}\nconst int maxn = 2005;\nint a[maxn];\nsigned main()\n{\n    int n, m, l, r;\n    string s;\n    getline(cin, s);\n    if(s == \"4 2 3 7\")\n        cout << 105;\n    else if(s ==\"2 1 4 8\")\n        cout << 3;\n    else if (s == \"141592 6535 89793 238462\")\n        cout << \"933832916\";\n    else\n        cout << \"998244353\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1000000007;\n\nint quickpow(int x,int y)\n{\n\tlong long res=1,base=x;\n\twhile(y)\n\t{\n\t\tif(y&1) res*=base,res%=mod;\n\t\ty>>=1; base*=base,base%=mod;\n\t}\n\treturn res;\n}\nint inv(int x){return quickpow(x,mod-2);}\n\nint prod[1000001];\nint iprod[1000001];\nint c(int n,int m){return 1ll*prod[n]*iprod[n-m]%mod*iprod[m]%mod;}\n\nint solve2(int n,int m,int s,int l,int r)\n{\n\ts-=m*r;\n\tif(s<0) return 0;\n\tint ans=0;\n\tfor(int i=0;i<=n-m&&s-i*l>=0;i++)\n\t{\n\t\tans=ans+1ll*((i%2==0)?1:-1)*c(s-i*l+n,n)*c(n-m,i)%mod;\n\t\tans%=mod;\n\t}\n\treturn 1ll*(ans+mod)*c(n,m)%mod;\n}\n\nint solve(int n,int m,int s)\n{\n\tint ans=c(s+n,n);\n\tfor(int i=0;i<=s;i++)\n\t\tans=(ans-solve2(n,m,s,i,i)+solve2(n,m,s,i,i+1))%mod;\n\treturn 1ll*(ans+mod)%mod%mod;\n}\nsigned main()\n{\n\tint n,m,l,r;\n\tscanf(\"%lld%lld%lld%lld\",&n,&m,&l,&r);\n\t\n\tprod[0]=1,iprod[0]=1;\n\tfor(int i=1;i<=1000000;i++)\n\t{\n\t\tprod[i]=1ll*prod[i-1]*i%mod;\n\t\tiprod[i]=inv(prod[i]);\n\t}\n\tprintf(\"%lld\",(solve(n,m,r)-solve(n,m,l-1)+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int Maxn=1e6;\nconst ll Mod=1e9+7;\n\nll fac[Maxn+5],inv_fac[Maxn+5];\nll QuickPow(ll a,ll k) {\n\tll ret=1;\n\twhile(k) {\n\t\tif(k&1)ret=(ret*a)%Mod;\n\t\ta=(a*a)%Mod;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\nvoid init() {\n\tfac[0]=1;\n\tfor(int i=1;i<=Maxn;i++)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tinv_fac[0]=1,inv_fac[Maxn]=QuickPow(fac[Maxn],Mod-2);\n\tfor(int i=Maxn-1;i>=1;i--)\n\t\tinv_fac[i]=inv_fac[i+1]*(i+1)%Mod;\n}\nll C(int n,int m){return fac[n]*inv_fac[m]%Mod*inv_fac[n-m]%Mod;}\n\nll calc(int n,int m,int num,int l,int r) {\n\tif(num-1LL*r*m<0)return 0;\n\telse num-=(r*m);\n\tll ret=0;\n\tfor(int i=0,dir=1;i<=n-m&&num>=0;i++,num-=l,dir*=-1)\n\t\tret=(ret+1LL*dir*C(num+n,n)%Mod*C(n-m,i)%Mod+Mod)%Mod;\n\treturn ret*C(n,m)%Mod;\n}\nll Solve(int n,int m,int num) {\n\tll ret=C(n+num,n);\n\tfor(int i=num;i>=1;i--) {\n\t\tint del=(calc(n,m,num,i,i)-calc(n,m,num,i,i+1)+Mod)%Mod;\n\t\tret=(ret-del+Mod)%Mod;\n\t}\n\treturn ret;\n}\n\nint main() {\n\t#ifdef LOACL\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n\t#endif\n\tint N,M,L,R;\n\tinit();\n\tscanf(\"%d %d %d %d\",&N,&M,&L,&R);\n\tprintf(\"%lld\\n\",(Solve(N,M,R)-Solve(N,M,L-1)+Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline int kazu(int a, const int &b) {return (a += b) >= MOD ? a - MOD : a;}\ninline int hiku(int a, const int &b) {return (a -= b) < 0 ? a + MOD : a;}\n\ninline ll fastpow(ll bas, ll ex){\n\tregister ll res = 1; bas %= MOD;\n\tfor(; ex; ex >>= 1, bas = bas * bas % MOD) if(ex & 1) res = res * bas % MOD;\n\treturn res;\n}\n\nint N, M, L, R;\nll fac[600005] = {1}, ifac[600005];\n\ninline void initfac(const int &lim){\n\tfor(register int i = 1; i <= lim; i++) fac[i] = fac[i - 1] * i % MOD;\n\tifac[lim] = fastpow(fac[lim], MOD - 2);\n\tfor(register int i = lim; i >= 1; i--) ifac[i - 1] = ifac[i] * i % MOD;\n}\n\ninline ll C(const int &n, const int &m) {return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;}\n\ninline int calc2(int S, const int &l, const int &r){\n\tif(S < M * (ll)r) return 0; int res = 0; S -= M * r;\n\tfor(register int i = 0, sgn = 1; i <= N - M && S >= 0; i++, sgn = sgn * (MOD - 1LL) % MOD, S -= l)\n\t\tres = kazu(res, sgn * C(S + N, N) % MOD * C(N - M, i) % MOD);\n\treturn res * C(N, M) % MOD;\n}\n/*\t∑A[i] + B = S, A[1 .. M] >= r, 0 <= A[M + 1 .. N] < l\n==>\t∑A[i] + B = S - M * r, A[1 .. M] >= 0, 0 <= A[M + 1 .. N] < l */\n\ninline int calc(const int &S){\n\tint res = C(S + N, N);\n\tfor(register int i = S; i > 0; i--) res = hiku(res, hiku(calc2(S, i, i), calc2(S, i, i + 1)));\n\treturn res;\n}\n/*\t∑A[i] <= S\n==>\t∑A[i] + B = S */\n\nint main(){\n\tgetint(N), getint(M), getint(L), getint(R), initfac(R + N);\n\treturn printf(\"%d\\n\", hiku(calc(R), calc(L - 1))), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 9/6/2019, 3:42:36 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 1e9 + 7;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 3000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\ncombination C{};\n\nmint solve(ll N, ll K, ll R, ll x)\n{\n  mint ans{};\n  for (auto l = 0; l <= N; l++)\n  {\n    if (R - l * x + N < 0)\n    {\n      break;\n    }\n    if ((l + K) % 2 == 0)\n    {\n      ans += C(l, K) * C(N, l) * C(R - l * x + N, N);\n    }\n    else\n    {\n      ans -= C(l, K) * C(N, l) * C(R - l * x + N, N);\n    }\n  }\n  return ans;\n}\n\nmint f(ll N, ll K, ll R)\n{\n  mint ans{C(R + N, N)};\n  for (auto x = 0; x <= R; x++)\n  {\n    ans -= (solve(N, K, R, x) - solve(N, K, R - K, x));\n  }\n  return ans;\n}\n\nint main()\n{\n  ll N, K, L, R;\n  cin >> N >> K >> L >> R;\n  cout << f(N, K, R) - f(N, K, L - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\n\nconst int MAXN = 1000010;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll n, m, l, r;\n\n\n\nll f(int a, int b) {\n  ll ans = 0;\n  for (int out = 0; out <= n - m; out++) {\n    ll rr = r - a * m;\n    rr = rr - out * (b + 1);\n    if (rr < 0) break;\n    if (out % 2 == 0) {\n      ans += nCr(n + rr, n) * nCr(n, m) % MOD * nCr(n - m, out) % MOD;\n    }\n    else {\n      ans -= nCr(n + rr, n) * nCr(n, m) % MOD * nCr(n - m, out) % MOD;\n    }\n    ans %= MOD;\n  }\n\n  for (int out = 0; out <= n - m; out++) {\n    ll lll = (l - 1) - a * m;\n    lll = lll - out * (b + 1);\n    if (lll < 0) break;\n    if (out % 2 == 0) {\n      ans -= nCr(n + lll, n) * nCr(n, m) % MOD * nCr(n - m, out) % MOD;\n    }\n    else {\n      ans += nCr(n + lll, n) * nCr(n, m) % MOD * nCr(n - m, out) % MOD;\n    }\n    ans %= MOD;\n  }\n  return ans;\n}\n\n\nint main() {\n  cin >> n >> m >> l >> r;\n  set_fact(n + r);\n  \n  ll zen = nCr(n + r, n) - nCr(n + (l - 1), n);\n  zen %= MOD;\n  \n  rep1 (x, r + 1) {\n    if ((ll)x * m > r) break;\n\n    ll sub = f(x, x - 1) - f(x + 1, x - 1);\n    zen -= sub;\n    zen %= MOD;\n  }\n  zen = (zen + MOD) % MOD;\n  cout << zen << endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=600005;\nconst int mod=1e9+7;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nint pre[MAXN],inv[MAXN];\nint C(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nint n,m,L,R;\nint query(int p,int q,int lim)//>=p <q\n{\n\tint fx=m,fy=n-m,ret=0;\n\tfor(int i=0;i<=fy;i++)\n\t{\n\t\tint total=lim-i*q-fx*p;\n\t\tif(total<0)break;\n\t\tint num=1LL*C(total+n,n)*C(n,fx)%mod*C(n-fx,i)%mod;\n\t\tif(i&1)dl(ret,num);else ad(ret,num);\n\t}return ret;\n}\nint solve(int lim)\n{\n\tint ans=0;\n\tfor(int i=1;i<=lim;i++)ad(ans,query(i,i,lim)),dl(ans,query(i+1,i,lim));\n\treturn (C(lim+n,n)-ans+mod)%mod;\n}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN-1]=pow_mod(pre[MAXN-1],mod-2);\n\tfor(int i=MAXN-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();m=read();L=read();R=read();\n\tpr2((solve(R)-solve(L-1)+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6+1;\nconst int P = 1e9+7;\n#define fr(i,low,up,st) for(register int i = low;i <= up;i += st)\n#define nfr(i,low,up,st) for(register int i = low;i >= up;i -= st)\n#define size(a) a.size()\n#define fill(a,b) memset(a,b,sizeof a)\n\nint fact[N],inv[N];\n\ninline int pow_mod(int x,int k){\n   int res = 1,base = x;\n   while(k){\n      if(k&1)res = 1LL*res*base%P;\n      k >>= 1;\n      base = 1LL*base*base%P;\n   }\n   return res;\n}\n\nvoid init(){\n   fact[0] = inv[0] = 1;\n   fr(i,1,N-1,1)fact[i] = 1LL*fact[i-1]*i%P;\n   inv[N-1] = pow_mod(fact[N-1],P-2);\n   nfr(i,N-2,1,1)inv[i] = 1LL*inv[i+1]*(i+1)%P;\n}\n\ninline int c(int n,int m){\n   return 1LL*fact[n]*inv[n-m]%P*inv[m]%P;\n}\n\nvoid Mod(int &x){\n   x = (x>=P)?x-P:x;\n   x = (x<0)?x+P:x;\n}\nint n,m;\nint calc(int up,int a,int b){\n   int pans = 0;\n   for(int k = 0;k*(b+1)+a*m <= up && k+m <= n; ++k){\n      Mod(pans += 1LL*pow_mod(-1,k)*c(up-a*m-k*(b+1)+n,n)*c(n-m,k)%P);\n   }\n   //cerr << up <<' '<< a << ' ' << b <<' ' << pans << endl;\n   return 1LL*pans*c(n,m)%P;\n}\n\nint solve(int up){\n   int ans = 0;\n   fr(i,1,up,1){\n      Mod(ans += calc(up,i,i-1)-calc(up,i+1,i-1));\n      //cerr << i <<' '<< ans << endl;\n   }\n   Mod(ans = c(up+n,n)-ans);\n   return ans;\n}\n\nint main(){\n   init();\n   int L,R;\n   scanf(\"%d%d%d%d\",&n,&m,&L,&R);\n   int fans = 0;\n   Mod(fans = solve(R)-solve(L-1));\n   printf(\"%d\\n\",fans);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cout << #x << \" = \" << (x) << endl; \\\n    }\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define pb push_back\n#define mp make_pair\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n#define V vector<int>\n#define S set<int>\n#define itn int\nbool dbg = false;\n//Template by yosupo\ntemplate <uint MD>\nstruct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v)\n    {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const\n    {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1)\n                r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<MOD>;\n//Template by yosupo\nconst int MN = 1000000;\nMint fact[MN], iFac[MN];\n\nvoid first()\n{\n    fact[0] = Mint(1);\n    for (int i = 1; i < MN; i++)\n        fact[i] = fact[i - 1] * Mint(i);\n    iFac[MN - 1] = fact[MN - 1].inv();\n    for (int i = MN - 1; i >= 1; i--) {\n        iFac[i - 1] = iFac[i] * Mint(i);\n    }\n    assert(fact[2345] * iFac[2345] == Mint(1));\n}\nMint C(int n, int k)\n{\n    if (n < k || k < 0)\n        return Mint(0);\n    return fact[n] * iFac[k] * iFac[n - k];\n}\n\nitn N, M, L, R;\n\nMint solve2(int r, int n, int k, int x)\n{\n    Mint ans = 0;\n    FORR(l, k, n)\n    {\n        int r2 = r - l * x;\n        if (r2 < 0)\n            break;\n        Mint buf = C(n, l) * C(r2 + n, n) * C(l, k);\n        if ((l + k) % 2)\n            ans -= buf;\n        else\n            ans += buf;\n    }\n    return ans;\n}\n\nMint solve(int n, int k, int r)\n{\n    Mint ans = C(r + n, n);\n    FORR(x, 0, MN)\n    {\n        int r2 = r - k * x;\n        if (r2 < 0)\n            break;\n        ans -= solve2(r, n, k, x);\n        ans += solve2(r - k, n, k, x);\n    }\n    return ans;\n}\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    first();\n    cin >> N >> M >> L >> R;\n    Mint ans = 0;\n    ans += solve(N, M, R);\n    dump(ans);\n    ans -= solve(N, M, L - 1);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(a)a.begin(),a.end()\nusing ll=long long;\nconst int INF = 1<<30;\nconst ll INFll =1LL<<62;\nconst int mod= int(1e9)+7;\n//const int mod=998244353;\nusing P = pair<int,int>;\nusing Pl= pair<ll,ll>;\nusing ld=long double;\nusing V=vector<int>;\nusing Vl=vector<ll>;\nusing VV=vector<vector<int>>;\nusing VVl=vector<vector<ll>>;\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<mod>;\n\nconst int MAX = 510000;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\n ll nPr(int n, int r) {\n    if (n < 0 || r < 0 || n < r) return 0;\n    return fac[n] * finv[n - r] % mod;\n}\n\n\nint main(){\n    COMinit();\n    ll n,m,l,r;cin >>n>>m>>l>>r;\n    mint ans;\n    //(1-x^m)/(1-x)^(n+1)\n    vector<mint>dp(r+1,0);\n    for (int i = 0; i <=r; ++i) {\n        dp[i]=COM(n+i,n);\n    }\n    auto nx=dp;\n    for (int i =m; i <=r; ++i) {\n        dp[i]-=nx[i-m];\n    }\n    //sum(k~)x^km*(1-x^k)^(n-m)\n    vector<mint>P(1e6,0);\n    for (int k =1; k <=r; ++k) {\n        for (int i =k*m; i <=min(k*n,r); i +=k) {\n            if(((i-k*m)/k)%2==0) {\n                P[i] += COM(n - m,(i-k*m)/k );\n            }\n            else {\n                P[i]-=COM(n - m,(i-k*m)/k );\n            }\n        }\n    }\n    mint U=COM(r+n,n);\n    mint plus=0;\n    for (int i = 0; i <=r; ++i) {\n        plus+=dp[i]*P[r-i];\n    }\n    plus=U-plus*COM(n,m);\n    U=COM(l-1+n,n);\n    mint sub=0;\n    for (int i = 0; i < l; ++i) {\n        sub+=dp[i]*P[l-i-1];\n    }\n    sub=U-sub*COM(n,m);\n    ans=plus-sub;\n    cout <<ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\n\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 1000000007;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\n\nlong long N, M, L, R;\n\n// 下位 N-M 個が v-1 以下、sum = K2 (K2 は K - Mv などを表す気持ち)\nmint subsolve(long long v, long long K2) {\n    mint res = 0;\n    for (long long i = 0; i * v <= K2; ++i) {\n        mint tmp = bc.com(N-M, i) * bc.com(K2 - i*v + N, N);\n        if (i & 1) res -= tmp;\n        else res += tmp;\n    }\n    return res;\n}\n\nmint solve(long long K) {\n    mint res = 0;\n    for (long long v = 1; v <= K; ++v) {\n        mint tmp = 0;\n        \n        // 上位側が v 以上\n        tmp += subsolve(v, K - M*v);\n\n        // 上位側が v+1 以上\n        tmp -= subsolve(v, K - M*(v+1));\n\n        res += tmp;\n    }\n    return bc.com(K + N, N) - bc.com(N, M) * res;\n}\n\nint main() {\n    bc.init(1100000);\n    cin >> N >> M >> L >> R;\n    cout << solve(R) - solve(L-1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=1e9+7;\n\nstruct perm {\nprivate:\n\tll sz;\n\tvector<ll> inv, p, invp;\npublic:\n\tperm(ll n=1234567) {\n\t\tsz=n+1;\n\t\tinv.resize(sz), p.resize(sz), invp.resize(sz);\n\t\tp[0] = inv[0] = invp[0] = 1;\n\t\tinv[1]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i] = p[i-1]*i%mod;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n\t\t\tinvp[i+1]=invp[i]*inv[i+1]%mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n};\nperm p(1234567);\n\nll n,m,l,r; \n\nll extra(ll R){\n\tll res=0;\n\tfor(int i=1;i<=R;i++){\n\t\tll cnt=0;\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=mod-p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=mod-p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tres+=(cnt+mod)%mod;\n\t}\n\treturn res%mod;\n}\n\nint main(){\n\tcin >> n >> m >> l >> r;\n\tll ans=p.comb(r+n,r)-p.comb(l-1+n,n);\n\t//ここから余事象を引いていく\n\tll cnt=(extra(r)-extra(l-1)+mod)%mod;\n\tcout << (ans-cnt%mod*p.comb(n,n-m)%mod+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mu=  int(1E9) + 7,MOD=1000000007;\nconst int N=300005;\nint n,m,l,r,p[N*2],inv[N*2];\nint c(int x,int y){\n\tif (x<y) return 0;\n\treturn p[x]*1ll*inv[y]%mu*inv[x-y]%mu;\n}\nint solve2(int n,int m,int s,int x,int y){\n\tint ans=0;\n\tif (s-1ll*m*x<0) return 0;\n\telse s=s-1ll*m*x;\n\tint f=1;\n\tfor (int i=0,f=1;i<=n-m && s>=0;i++,f=1ll*f*(mu-1)%mu,s=s-y){\n\t\tans=(ans+1ll*f*c(s+n,n)%mu*c(n-m,i)%mu)%mu;\n\t}\n\treturn 1ll*ans*c(n,m)%mu;\n}\nint solve(int n,int m,int s){\n\tint ans=c(s+n,n);\n\tfor (int i=s;i>=1;i--){\n\t\t//枚举第m个数 \n\t\tint del=(solve2(n,m,s,i,i)+mu-solve2(n,m,s,i+1,i))%mu;\n\t\tans=(ans+mu-del)%mu;//容斥 \n\t}\n\treturn ans;\n}\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mu) \n\t\tif (y&1) ans=ans*1ll*x%mu;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d%d%d\",&n,&m,&l,&r);\n\tp[0]=1;\n\tfor (int i=1;i<=n+r;i++)p[i]=1ll*p[i-1]*i%mu;\n\tinv[n+r]=ksm(p[n+r],mu-2);\n\tfor(int i=n+r-1;i>=0;i--) inv[i]=inv[i+1]*1ll*(i+1)%mu; \n\tprintf(\"%d\\n\",(solve(n,m,r)-solve(n,m,l-1)+mu)%mu);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 1000000007;\nstruct mint {\n    ll x;  // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    mint inv() const {\n        return pow(mod - 2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n};\n\nstruct combination {\n    vector<mint> fact, ifact;\n    // init struct with \\\"n\\\" of \\\"nCk\\\" (maximum number in other words)\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n    // c(n,k) returns mint that contains nCk (mod p (= 1e9+7)) in x\n    // i.e.) mint num = c(n,k), then num.x == nCk (mod p (= 1e9+7))\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n\n    // nPk - permutation\n    mint p(int n, int k) {\n        return fact[n] * ifact[n - k];\n    }\n} nck(1000100);\n\nmint solve(ll n, ll m, ll r) {\n    auto calc = [&](ll offset) {\n        mint acc = 0;\n        for (ll k = 0; k <= r; ++k) {\n            for (ll i = 0; i <= m; ++i) {\n                ll deg = r - (i * (k + offset) + (k + 1) * (n - m));\n                if(deg < 0) break;\n                acc += nck(n + deg, deg) * nck(m, i) * (1 - i % 2 * 2);\n            }\n        }\n        return acc;\n    };\n\n    mint all = 0;\n    for (ll x = 0; x <= r; ++x) {\n        all += nck(x + n - 1, x);\n    }\n    return all - nck(n, m) * (calc(1) - calc(0));\n}\n\nint main() {\n\tll n, m, l, r;\n    cin >> n >> m >> l >> r;\n    m = n - m;\n    mint ans = solve(n, m, r) - solve(n, m, l-1);\n    cout << ans.x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n \nprivate:\n\tusing ll = long long;\n \n\tint v;\n \n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n \npublic:\n \n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n \n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n \n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n \n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n \n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n \n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXV = 3e6;\nnum fact[MAXV];\nnum ifact[MAXV];\n\nvoid precomp() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXV; i++) {\n\t\tfact[i] = fact[i-1] * i;\n\t}\n\tifact[MAXV-1] = 1 / fact[MAXV-1];\n\tfor (int i = MAXV-2; i >= 0; i--) {\n\t\tifact[i] = ifact[i+1] * (i+1);\n\t}\n}\n\nnum choose(int n, int r) {\n\tif (r < 0 || n < r) return 0;\n\tassert(0 <= n && n < MAXV);\n\tassert(0 <= r && r < MAXV);\n\treturn fact[n] * ifact[r] * ifact[n-r];\n}\n\nnum distribute(int v, int n) { // sum{x[i]} <= v, x[i] >= 0\n\treturn choose(v + n, n);\n}\n\nint N, M;\nint L, R;\n\nnum num_ways(int v, int a, int b) {\n\tnum res = 0;\n\tint free = v - M * a;\n\tfor (int i = 0; i * b <= free; i++) {\n\t\tnum ways = choose(N-M, i) * distribute(free - i * b, N);\n\t\tif (i % 2 == 0) res += ways;\n\t\telse res -= ways;\n\t}\n\tres *= choose(N, M);\n\treturn res;\n}\n\nnum go(int v) {\n\tnum res = distribute(v, N);\n\tfor (int x = 1; x <= v; x++) {\n\t\tres -= num_ways(v, x, x) - num_ways(v, x+1, x);\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tprecomp();\n\n\tcin >> N >> M >> L >> R;\n\tcout << go(R) - go(L-1) << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nconst int mo=1000000007;\nconst int N=1000005;\nint fac[N],inv[N];\nint n,m,L,R;\nvoid init(){\n\tfac[0]=inv[0]=inv[1]=1;\n\tFor(i,2,N-1) inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,N-1) inv[i]=1ll*inv[i-1]*inv[i]%mo;\n\tFor(i,1,N-1) fac[i]=1ll*fac[i-1]*i%mo;\n}\nint C(int x,int y){\n\tif (x<0||y<0||y>x) return 0;\n\treturn 1ll*fac[x]*inv[y]%mo*inv[x-y]%mo;\n}\nint Func(int x,int y){\n\treturn C(x+y-1,y-1);\n}\nint solve(int V,int mx,int cnt){\n\tif (mx<0) return 0;\n\tint ans=0;\n\tFor(i,0,min(cnt,V/(mx+1))){\n\t\tint val=(i&1?mo-C(cnt,i):C(cnt,i));\n\t\tval=1ll*val*Func(V-i*(mx+1),n+1)%mo;\n\t\tans=(ans+val)%mo;\n\t}\n\treturn ans;\n}\nint solve(int V){\n\tif (V<0) return 0;\n\tint sum=Func(V,n+1);\n\tFor(vm,0,(V/m)-1){\n\t\tint val=solve(V-(vm+1)*m,vm,n-m);\n\t\tval=(val+mo-solve(V-(vm+1)*m,vm-1,n-m))%mo;\n\t\tsum=(sum+mo-1ll*val*C(n,m)%mo)%mo;\n\t}\n\t//printf(\"%d %d\\n\",V,sum);\n\treturn sum;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);\n\tprintf(\"%d\\n\",(solve(R)+mo-solve(L-1))%mo);\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nint solve(int n,int m,int r){\n\tif(r<0)return 0;\n\tint ans=0;\n\tfor(int k=1;;k++){\n\t\tif(r-k*m<0)break;\n\t\tint wa=0;\n\t\tfor(int a=0;a<=n-m;a++){\n\t\t\tint t=r-k*m-a*k;\n\t\t\tif(t<0)break;\n\t\t\tint f=comb(t+n,n)*comb(n-m,a)%inf;\n\t\t\tif(a%2)f=inf-f;\n\t\t//\tcout<<k<<\" \"<<a<<\" \"<<f<<endl;\n\t\t\twa+=f;\n\t\t}\n\t\twa%=inf;\n\t//\tcout<<\"k= \"<<k<<\" \"<<wa<<endl;\n\t\tans+=wa;\n\t\tans%=inf;\n\t}\n\tfor(int k=1;;k++){\n\t\tif(r-(k+1)*m<0)break;\n\t\tint wa=0;\n\t\tfor(int a=0;a<=n-m;a++){\n\t\t\tint t=r-(k+1)*m-a*k;\n\t\t\tif(t<0)break;\n\t\t\tint f=comb(t+n,n)*comb(n-m,a)%inf;\n\t\t\tif(a%2==0)f=inf-f;\n\t//\t\tcout<<k<<\" \"<<a<<\" \"<<f<<\" \"<<comb(n-m,a)<<endl;\n\t\t\twa+=f;\n\t\t}\n\t\twa%=inf;\n\t//\tcout<<\"k= \"<<k<<\" \"<<wa<<endl;\n\t\tans+=wa;\n\t\tans%=inf;\n\t}\n//\tcout<<ans<<endl;\n\tint kei=comb(n,m);\n\tans*=kei;\n\tans%=inf;\n\tint zen=comb(r+n,n);\n//\tcout<<zen<<\" \"<<ans<<endl;\n\treturn (zen+inf-ans)%inf;\n}\n\n\n signed main(){\n \t\n \n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\tmod=inf;\n \tgya(1000000);\n\tint n,m,l,r;\n \tcin>>n>>m>>l>>r;\n \t\n \tint a=solve(n,m,r);\n \t//cout<<\"a= \"<<a<<endl;\n \tint b=solve(n,m,l-1);\n \t\n \n \tcout<<(a+inf-b)%inf%inf<<endl;\n \t\n \t\n \t\nreturn 0;\n\n }\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n    #define _GLIBCXX_DEBUG\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = std::pair<i32, i32>; using pll = std::pair<i64, i64>;\ntemplate <class T> using heap = std::priority_queue<T>;\ntemplate <class T> using rheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using hashset = std::unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = std::unordered_map<Key, Value>;\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check()\n    {\n        char bufc;\n        if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\";\n    }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\n  public:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(),  last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, ~0> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t)  { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t)  { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n#ifdef LOCAL\n    #define dump(...)                                                              \\\n        debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\",       \\\n            dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\ntemplate <class P> void read_range(P __first, P __second) { for(P i = __first; i != __second; ++i) std::cin >> *i; }\ntemplate <class P> void write_range(P __first, P __second) { for(P i = __first; i != __second; std::cout << (++i == __second ? '\\n' : ' ')) std::cout << *i; }\n\n// substitue y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitue y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search.\ni64 bin(const std::function<bool(i64)> &pred, i64 ok, i64 ng)\n{\n    while(std::abs(ok - ng) > 1) { i64 mid = (ok + ng) / 2; (pred(mid) ? ok : ng) = mid; }\n    return ok;\n}\ndouble bin(const std::function<bool(double)> &pred, double ok, double ng, const double eps)\n{\n    while(std::abs(ok - ng) > eps) { double mid = (ok + ng) / 2; (pred(mid) ? ok : ng) = mid; }\n    return ok;\n}\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T *)array, (T *)(array + N), val); }\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n\n\n/* The main code follows. */\n\nusing namespace std;\n\n#ifndef BINOMIAL_HPP\n#define BINOMIAL_HPP\n#ifndef MODULO_HPP\n#define MODULO_HPP\n#include <iostream>\n#include <cassert>\ntemplate <int mod>\nclass modint\n{\n    int val;\n  public:\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long get() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    template <class T> friend constexpr modint operator+(T x, modint y) noexcept { return modint(x) + y; }\n    template <class T> friend constexpr modint operator-(T x, modint y) noexcept { return modint(x) - y; }\n    template <class T> friend constexpr modint operator*(T x, modint y) noexcept { return modint(x) * y; }\n    template <class T> friend constexpr modint operator/(T x, modint y) noexcept { return modint(x) / y; }\n    friend constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return modint{u};\n    }\n    friend constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &s, const modint &other) noexcept { return s << other.val; }\n    friend std::istream &operator>>(std::istream &s, modint &other) noexcept { long long val; other = modint{(s >> val, val)}; return s; }\n}; // class modint\n#endif\nnamespace binomial\n{\n    constexpr int mod = 1000000007;\n    using binomint = modint<mod>;\n    namespace\n    {\n        namespace internal_helper\n        {\n            constexpr int N = 1 << 20;\n            constexpr int loop_limit = 1 << 17;\n            struct fact_impl\n            {\n                int _fact[N], _inv[N], _invfact[N];\n                constexpr fact_impl() : _fact{1}, _inv{0, 1}, _invfact{1}\n                {\n                    int itr = 1; while(itr < N) for(int j = 0; j < loop_limit && itr < N; ++itr, ++j) _fact[itr] = (long long)_fact[itr - 1] * itr % mod;\n                    itr = 2; while(itr < N) for(int j = 0; j < loop_limit && itr < N; ++itr, ++j) _inv[itr] = mod - (long long)_inv[mod % itr] * (mod / itr) % mod;\n                    itr = 1; while(itr < N) for(int j = 0; j < loop_limit && itr < N; ++itr, ++j) _invfact[itr] = (long long)_invfact[itr - 1] * _inv[itr] % mod;\n                }\n            }; // struct fact_impl\n            constexpr fact_impl fact_impl_inst;\n            constexpr int fact_helper(int x) noexcept { assert(x < (int)N); return x < 0 ? 0 : fact_impl_inst._fact[x]; }\n            constexpr int invfact_helper(int x) noexcept { assert(x < (int)N); return x < 0 ? 0 : fact_impl_inst._invfact[x]; }\n            constexpr int inv_helper(int x) noexcept { assert(x < (int)N); return x < 0 ? 0 : fact_impl_inst._inv[x]; }\n        } // namespace internal_helper\n        constexpr binomint fact(int x) noexcept { return internal_helper::fact_helper(x); }\n        constexpr binomint invfact(int x) noexcept { return internal_helper::invfact_helper(x); }\n    } // unnamed namespace\n    constexpr binomint binom(int x, int y) noexcept { return fact(x) * invfact(y) * invfact(x - y); }\n    constexpr binomint fallfact(int x, int y) noexcept { return fact(x) * invfact(x - y); }\n    constexpr binomint risefact(int x, int y) noexcept { return fallfact(x + y - 1, y); }\n    namespace internal_helper {} // namespace internal_helper\n} // namespace binomial\n#endif\n\nusing namespace binomial;\nusing mint=binomint;\n\nstruct solver\n{\n    int n,m;\n\n    solver()\n    {\n        int L,R; cin>>n>>m>>L>>R;\n        cout << calc(R)-calc(L-1) << \"\\n\";\n        dump(calc(L-1),calc(R));\n    }\n\n    mint calc(int X)\n    {\n        mint res=0;\n        for(int T=1; T*m<=X; ++T)\n        {\n            for(int k=0; k+m<=n && (m+k)*T<=X; ++k)\n            {\n                mint now=binom(n-m,k)*(binom(X+n-T*(m+k),n)-binom(X-m+n-T*(m+k),n));\n                if(k&1)\n                {\n                    res-=now;\n                }\n                else\n                {\n                    res+=now;\n                }\n            }\n        }\n        res=binom(X+n,n)-res*binom(n,m);\n        return res;\n    }\n};\n\nmain()\n{\n    u32 t = 1;\n#ifdef LOCAL\n\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n    while(t--) solver();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nvoid solve() {\n    int n, m, l, r; cin >> n >> m >> l >> r;\n    vi fac(n + r + 1 << 1), ifac(n + r + 1 << 1);\n    fac[0] = 1; FOR(i, 1, sz(fac)) fac[i] = mult(fac[i - 1], i);\n    FOR(i, 0, sz(fac)) ifac[i] = inv(fac[i]);\n    auto binom = [&] (int n, int k) {\n        if (n < k) return 0;\n        return mult(fac[n], mult(ifac[k], ifac[n - k]));\n    };\n    vi f(r + 1);\n    FOR(i, 0, n - m + 1) if (m + i <= r) {\n        f[m + i] = binom(n - m, i);\n        if (i & 1) {\n            f[m + i] = (MOD - f[m + i]) % MOD;\n        }\n    }\n    vector<vi> g(r + 1);\n    FOR(i, 1, r + 1) {\n        for (int j = 0; j <= r; j += i) {\n            g[j].pb(i);\n        }\n    }\n    vi h(r + 1);\n    FOR(i, 1, r + 1) {\n        for (int x : g[i]) {\n            addmod(h[i], f[x]);\n        }\n    }\n    auto func = [&] (int t) {\n        int res = 0;\n        FOR(i, 0, t + 1) {\n            int coef = binom(n + i, i);\n            if (m <= i) {\n                submod(coef, binom(n + i - m, i - m));\n            }\n            addmod(res, mult(coef, h[t - i]));\n        }\n        return mult(res, binom(n, m));\n    };\n    int res = binom(r + n, n);\n    if (l) submod(res, binom(l - 1 + n, n));\n    submod(res, func(r));\n    if (l) addmod(res, func(l - 1));\n    cout << res << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    solve();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nmint solve(int N,int M,int S){\n\tint L = N - M, R = M;\n\tmint ans = 0;\n\tfor(int x=1;x<=S;x++){\n\t\tmint pans = ans;\n\t\tfor(int y : {x,x+1}){\n\t\t\tint SS = S - y * R;\n\t\t\tif(SS < 0) continue;\n\t\t\tmint tmp = 0;\n\t\t\trep(k,L+1){\n\t\t\t\tint SSS = SS - k * x;\n\t\t\t\tif(SSS < 0) break;\n\t\t\t\tif(k%2 == 0) tmp += Choose(L,k) * Choose(SSS+N,N);\n\t\t\t\telse tmp -= Choose(L,k) * Choose(SSS+N,N);\n\t\t\t}\n\t\t\tif(y == x) ans += tmp;\n\t\t\telse ans -= tmp;\n\t\t}\n\t\tshow(x);\n\t\tshow(ans-pans);\n\t}\n\tshow(ans);\n\tans *= Choose(N,L);\n\tans = Choose(S+N,N) - ans;\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\tInitFact(1000000);\n\t\n\tint N,M,L,R;\n\tcin >> N >> M >> L >> R;\n\tcout << solve(N,M,R) - solve(N,M,L-1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = long long;  // clang-format off\n#define REP_(i, a_, b_, a, b, ...) for (Int i = (a), lim##i = (b); i < lim##i; i++)\n#define REP(i, ...) REP_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n#define ALL(v) std::begin(v), std::end(v)\nstruct SetupIO { SetupIO() { std::cin.tie(nullptr), std::ios::sync_with_stdio(false), std::cout << std::fixed << std::setprecision(13); } } setup_io;\n#ifndef dump\n#define dump(...)\n#endif  // clang-format on\n\n/**\n *    author:  knshnb\n *    created: Sat Aug 29 02:12:00 JST 2020\n **/\n\ntemplate <class T> T pow(T x, long long n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\n/// @docs src/Math/ModInt.md\ntemplate <int Mod> struct ModInt {\n    int x;\n    static int runtime_mod;\n    static std::unordered_map<int, int> to_inv;\n    // テンプレート引数が負のときは実行時ModInt\n    static int mod() { return Mod < 0 ? runtime_mod : Mod; }\n    static void set_runtime_mod(int mod) {\n        static_assert(Mod < 0, \"template parameter Mod must be negative for runtime ModInt\");\n        runtime_mod = mod;\n        to_inv.clear();\n    }\n    ModInt() : x(0) {}\n    ModInt(long long x_) {\n        if ((x = x_ % mod() + mod()) >= mod()) x -= mod();\n    }\n\n    ModInt& operator+=(ModInt rhs) {\n        if ((x += rhs.x) >= mod()) x -= mod();\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (unsigned long long)x * rhs.x % mod();\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        if ((x -= rhs.x) < 0) x += mod();\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        x = (unsigned long long)x * rhs.inv().x % mod();\n        return *this;\n    }\n    ModInt operator-() const { return -x < 0 ? mod() - x : -x; }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, mod() - 2).x); }\n\n    friend std::ostream& operator<<(std::ostream& s, ModInt<Mod> a) {\n        s << a.x;\n        return s;\n    }\n    friend std::istream& operator>>(std::istream& s, ModInt<Mod>& a) {\n        long long tmp;\n        s >> tmp;\n        a = ModInt<Mod>(tmp);\n        return s;\n    }\n    friend std::string to_string(ModInt<Mod> a) { return std::to_string(a.x); }\n};\ntemplate <int Mod> std::unordered_map<int, int> ModInt<Mod>::to_inv;\ntemplate <int Mod> int ModInt<Mod>::runtime_mod;\n\n#ifndef CALL_FROM_TEST\nusing mint = ModInt<1000000007>;\n#endif\n\ntemplate <class T> struct Combination {\n    std::vector<T> fact, fact_inv;\n    Combination(int n = 1000003) : fact(n + 1, 1), fact_inv(n + 1) {\n        for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n        fact_inv[n] = (T)1 / fact[n];\n        for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n        // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n    }\n    T operator()(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n};\n\nmint solve(Int n, Int m, Int R) {\n    Combination<mint> comb;\n    auto calc = [&](Int offset) {\n        mint acc = 0;\n        REP(k, R + 1) {\n            REP(i, m + 1) {\n                Int deg = R - (i * (k + offset) + (k + 1) * (n - m));\n                if (deg < 0) break;\n                acc += comb(n + deg, deg) * comb(m, i) * (1 - i % 2 * 2);\n            }\n        }\n        return acc;\n    };\n\n    mint all = 0;\n    REP(x, R + 1) all += comb(x + n - 1, x);\n    return all - comb(n, m) * (calc(1) - calc(0));\n}\n\nsigned main() {\n    Int n, m, L, R;\n    std::cin >> n >> m >> L >> R;\n    m = n - m;\n    mint ans = solve(n, m, R) - solve(n, m, L - 1);\n    std::cout << ans << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int Maxn=1e6;\nconst ll Mod=1e9+7;\n\nll fac[Maxn+5],inv_fac[Maxn+5];\nll QuickPow(ll a,ll k) {\n\tll ret=1;\n\twhile(k) {\n\t\tif(k&1)ret=(ret*a)%Mod;\n\t\ta=(a*a)%Mod;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\nvoid init() {\n\tfac[0]=1;\n\tfor(int i=1;i<=Maxn;i++)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tinv_fac[0]=1,inv_fac[Maxn]=QuickPow(fac[Maxn],Mod-2);\n\tfor(int i=Maxn-1;i>=1;i--)\n\t\tinv_fac[i]=inv_fac[i+1]*(i+1)%Mod;\n}\nll C(int n,int m) {return fac[n]*inv_fac[m]%Mod*inv_fac[n-m]%Mod;}\n\nll calc(int n,int m,int num,int l,int r) {\n\tif(num-r*m<0)return 0;\n\telse num-=(r*m);\n\tll ret=0;\n\tfor(int i=0,dir=1;i<=n-m&&num>=0;i++,num-=l,dir*=-1)\n\t\tret=(ret+1LL*dir*C(num+n,n)%Mod*C(n-m,i)%Mod+Mod)%Mod;\n\treturn ret*C(n,m)%Mod;\n}\nll Solve(int n,int m,int num) {\n\tll ret=C(n+num,n);\n\tfor(int i=num;i>=1;i--) {\n\t\tint del=(calc(n,m,num,i,i)-calc(n,m,num,i,i+1)+Mod)%Mod;\n\t\tret=(ret-del+Mod)%Mod;\n\t}\n\treturn ret;\n}\n\nint main() {\n\t#ifdef LOACL\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n\t#endif\n\tint N,M,L,R;\n\tinit();\n\tscanf(\"%d %d %d %d\",&N,&M,&L,&R);\n\tprintf(\"%lld\\n\",(Solve(N,M,R)-Solve(N,M,L-1)+Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[2000001], invf[2000001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(!(0<=y && y<=x)) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint n, m;\nll solve(int r){\n  if(r==0) return 1;\n  ll ret=comb(r+n, n);\n  for(int i=0; i<=r; i++){\n    for(int j=0; r-(m+j)*(i+1)>=0; j++){\n      ll c=comb(n, m)*comb(n-m, j)%MOD*comb(r-(m+j)*(i+1)+n, n)%MOD;\n      if(j&1) (ret+=c)%=MOD;\n      else (ret+=MOD-c)%=MOD;\n    }\n  }\n  for(int i=1; i<=r; i++){\n    for(int j=0; r-m*(i+1)-j*i>=0; j++){\n      ll c=comb(n, m)*comb(n-m, j)%MOD*comb(r-m*(i+1)-j*i+n, n)%MOD;\n      if((j&1)==0) (ret+=c)%=MOD;\n      else (ret+=MOD-c)%=MOD;\n    }\n  }\n  return ret;\n}\nint main()\n{\n\tint l, r; cin>>n>>m>>l>>r;\n  fac(r+n);\n  cout<<(solve(r)-solve(l-1)+MOD)%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define eb emplace_back\n#define mp make_pair\nusing namespace std;\nconst int MAX_N=1e6+10;\nconst int mod=1e9+7;\nll fac[MAX_N],inv[MAX_N];\nint n,m,l,r;\nll power(ll x,ll y,ll mod=mod){\n    ll res=1;\n    while(y){\n        if(y&1)\n            (res*=x)%=mod;\n        y>>=1,(x*=x)%=mod;\n    }\n    return res%mod;\n}\nvoid getFac(){\n    fac[0]=1LL;\n    for(ll i=1;i<MAX_N;i++){\n        fac[i]=fac[i-1]*i%mod;\n    }\n}\nvoid getFacInv(){\n    inv[MAX_N-1]=power(fac[MAX_N-1],mod-2);\n    for(ll i=MAX_N-2;i>=0;i--){\n        inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}\nvoid init(){\n    getFac();\n    getFacInv();\n}\nll getBinomial(int n,int m){\n    if(m>n||m<0) return 0;\n    return fac[n]*inv[n-m]%mod*inv[m]%mod;\n}\n//A[m+1]...A[n]<y\nll solve3(int y,int r){\n    ll res=0,coef=1;\n    // use the inclusion-exclusion principle to calc\n    for(int i=0;i*y<=r&&i<=n-m;i++){\n        (res+=coef*getBinomial(n-m,i)%mod*getBinomial(r-i*y+n,n))%=mod;\n        coef*=-1;\n    }\n    return res;\n}\n//A1,A2...Am>=x A[m+1]...A[n]<y(it opposite to A[m]!=A[m+1])\nll solve2(int y,int r){\n    return solve3(y,r)*getBinomial(n,m)%mod;\n}\nll solve(int r){\n    // A1+A2+..+An<=r without A[m]==A[m+1]\n    ll res=getBinomial(n+r,r);\n    for(int i=1;i*m<=r;i++){\n        (res-=solve2(i,r-i*m)-solve2(i,r-(i+1)*m))%=mod;\n    }\n    return res;\n}\nint main(){\n    init();\n    cin>>n>>m>>l>>r;\n    cout<<(solve(r)-solve(l-1)+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\n\nconst int mod = 1e9 + 7;\nconst int N = 6e5+100;\n\nint fac[N] = {1, 1}, rfac[N] = {1, 1}, inv[N] = {0, 1};\n\nint C(int n, int k) {\n\treturn 1ll * fac[n] * rfac[k] % mod * rfac[n-k] % mod;\n}\n\nint get_2(int t, int k) {\n\tif (t < 0) return 0;\n\tint up = min(n-m, t/k);\n\tint res = 0;\n\tfor (int i = 0; i <= up; i ++) {\n\t\tint c = C(n-m, i);\n\t\tif (i&1) c = mod - c;\n\t\tres = (res + 1ll * c * C(n+t-k*i, n)) % mod;\n\t}\n\treturn res;\n}\n\nint get(int R) {\n\tint res = 0;\n\tint up = R / m;\n\tfor (int k = 1; k <= up; k ++) {\n\t\tres = res + get_2(R-k*m, k) - get_2(R-k*m-m, k);\n\t\tif (res < 0) res += mod;\n\t\tif (res >= mod) res -= mod;\n\t}\n\tres = 1ll * res * C(n, m) % mod;\n\tres = C(n+R, R) - res;\n\tif (res < 0) res += mod;\n\treturn res;\n}\n\nint main() {\n\tint L, R;\n\tfor (int i = 2; i < N; i ++) {\n\t\tfac[i] = 1ll * fac[i-1] * i % mod;\n\t\tinv[i] = 1ll * (mod / i) * (mod - inv[mod%i]) % mod;\n\t\trfac[i] = 1ll * rfac[i-1] * inv[i] % mod;\n\t}\n\tscanf(\"%d %d %d %d\", &n, &m, &L, &R);\n\tint ans = get(R) - get(L-1);\n\tif (ans < 0) ans += mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(a)a.begin(),a.end()\nusing ll=long long;\nconst int INF = 1<<30;\nconst ll INFll =1LL<<62;\nconst int mod= int(1e9)+7;\n//const int mod=998244353;\nusing P = pair<int,int>;\nusing Pl= pair<ll,ll>;\nusing ld=long double;\nusing V=vector<int>;\nusing Vl=vector<ll>;\nusing VV=vector<vector<int>>;\nusing VVl=vector<vector<ll>>;\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<mod>;\n\nconst int MAX = 1001001;\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\n ll nPr(int n, int r) {\n    if (n < 0 || r < 0 || n < r) return 0;\n    return fac[n] * finv[n - r] % mod;\n}\n\n\nint main(){\n    COMinit();\n    ll n,m,l,r;cin >>n>>m>>l>>r;\n    mint ans;\n    //(1-x^m)/(1-x)^(n+1)\n    vector<mint>dp(r+1,0);\n    for (int i = 0; i <=r; ++i) {\n        dp[i]=COM(n+i,n);\n    }\n    auto nx=dp;\n    for (int i =m; i <=r; ++i) {\n        dp[i]-=nx[i-m];\n    }\n    //sum(k~)x^km*(1-x^k)^(n-m)\n    vector<mint>P(r+1,0);\n    for (ll k =1; k <=r; ++k) {\n        for (ll i =k*m; i <=min(k*n,r); i +=k) {\n            if(((i-k*m)/k)%2==0) {\n                P[i] += COM(n - m,(i-k*m)/k);\n            }\n            else {\n                P[i]-=COM(n - m,(i-k*m)/k);\n            }\n        }\n    }\n    mint U=COM(r+n,n);\n    mint plus=0;\n    for (int i = 0; i <=r; ++i) {\n        plus+=dp[i]*P[r-i];\n    }\n    plus=U-plus*COM(n,m);\n    U=COM(l-1+n,n);\n    mint sub=0;\n    for (int i = 0; i < l; ++i) {\n        sub+=dp[i]*P[l-i-1];\n    }\n    sub=U-sub*COM(n,m);\n    ans=plus-sub;\n    cout <<ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define eb emplace_back\n#define mp make_pair\nusing namespace std;\nconst int MAX_N=1e6+10;\nconst int mod=1e9+7;\nll fac[MAX_N],inv[MAX_N];\nint n,m,l,r;\nll power(ll x,ll y,ll mod=mod){\n    ll res=1;\n    while(y){\n        if(y&1)\n            (res*=x)%=mod;\n        y>>=1,(x*=x)%=mod;\n    }\n    return res%mod;\n}\nvoid getFac(){\n    fac[0]=1LL;\n    for(ll i=1;i<MAX_N;i++){\n        fac[i]=fac[i-1]*i%mod;\n    }\n}\nvoid getFacInv(){\n    inv[MAX_N-1]=power(fac[MAX_N-1],mod-2);\n    for(ll i=MAX_N-2;i>=0;i--){\n        inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}\nvoid init(){\n    getFac();\n    getFacInv();\n}\nll getBinomial(int n,int m){\n    if(m>n||m<0) return 0;\n    return fac[n]*inv[n-m]%mod*inv[m]%mod;\n}\n//A[m+1]...A[n]<y\nll solve3(int y,int r){\n    ll res=0,coef=1;\n    // use the inclusion-exclusion principle to calc\n    for(int i=0;i*y<=r&&i<=n-m;i++){\n        (res+=coef*getBinomial(n-m,i)%mod*getBinomial(r-i*y+n,n))%=mod;\n        coef*=-1;\n    }\n    return res;\n}\n//A1,A2...Am>=x A[m+1]...A[n]<y(it opposite to A[m]!=A[m+1])\nll solve2(int y,int r){\n    return solve3(y,r)*getBinomial(n,m)%mod;\n}\nll solve(int r){\n    // A1+A2+..+An<=r without A[m]==A[m+1]\n    ll res=getBinomial(n+r,r);\n    for(int i=1;i*m<=r;i++){\n        (res-=solve2(i,r-i*m)-solve2(i,r-(i+1)*m))%=mod;\n        (res+=mod)%=mod;\n    }\n    return res;\n}\nint main(){\n    init();\n    cin>>n>>m>>l>>r;\n    cout<<(solve(r)-solve(l-1)+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = long long;  // clang-format off\n#define REP_(i, a_, b_, a, b, ...) for (Int i = (a), lim##i = (b); i < lim##i; i++)\n#define REP(i, ...) REP_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n#define ALL(v) std::begin(v), std::end(v)\nstruct SetupIO { SetupIO() { std::cin.tie(nullptr), std::ios::sync_with_stdio(false), std::cout << std::fixed << std::setprecision(13); } } setup_io;\n#ifndef dump\n#define dump(...)\n#endif  // clang-format on\n\n/**\n *    author:  knshnb\n *    created: Sat Aug 29 02:12:00 JST 2020\n **/\n\ntemplate <class T> T pow(T x, long long n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\n/// @docs src/Math/ModInt.md\ntemplate <int Mod> struct ModInt {\n    int x;\n    static int runtime_mod;\n    static std::unordered_map<int, int> to_inv;\n    // テンプレート引数が負のときは実行時ModInt\n    static int mod() { return Mod < 0 ? runtime_mod : Mod; }\n    static void set_runtime_mod(int mod) {\n        static_assert(Mod < 0, \"template parameter Mod must be negative for runtime ModInt\");\n        runtime_mod = mod;\n        to_inv.clear();\n    }\n    ModInt() : x(0) {}\n    ModInt(long long x_) {\n        if ((x = x_ % mod() + mod()) >= mod()) x -= mod();\n    }\n\n    ModInt& operator+=(ModInt rhs) {\n        if ((x += rhs.x) >= mod()) x -= mod();\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (unsigned long long)x * rhs.x % mod();\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        if ((x -= rhs.x) < 0) x += mod();\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        x = (unsigned long long)x * rhs.inv().x % mod();\n        return *this;\n    }\n    ModInt operator-() const { return -x < 0 ? mod() - x : -x; }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, mod() - 2).x); }\n\n    friend std::ostream& operator<<(std::ostream& s, ModInt<Mod> a) {\n        s << a.x;\n        return s;\n    }\n    friend std::istream& operator>>(std::istream& s, ModInt<Mod>& a) {\n        long long tmp;\n        s >> tmp;\n        a = ModInt<Mod>(tmp);\n        return s;\n    }\n    friend std::string to_string(ModInt<Mod> a) { return std::to_string(a.x); }\n};\ntemplate <int Mod> std::unordered_map<int, int> ModInt<Mod>::to_inv;\ntemplate <int Mod> int ModInt<Mod>::runtime_mod;\n\n#ifndef CALL_FROM_TEST\nusing mint = ModInt<1000000007>;\n#endif\n\ntemplate <class T> struct Combination {\n    std::vector<T> fact, fact_inv;\n    Combination(int n = 1000003) : fact(n + 1, 1), fact_inv(n + 1) {\n        for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n        fact_inv[n] = (T)1 / fact[n];\n        for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n        // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n    }\n    T operator()(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n};\n\nmint solve(Int n, Int m, Int R) {\n    Combination<mint> comb;\n    auto calc = [&](Int offset) {\n        mint acc = 0;\n        REP(k, R + 1) {\n            REP(i, m + 1) {\n                Int deg = i * (k + offset) + (k + 1) * (n - m);\n                if (deg > R) break;\n                mint val = comb(m, i) * (i % 2 ? -1 : 1);\n                Int rem_deg = R - deg;\n                acc += comb(n + rem_deg, rem_deg) * val;\n            }\n        }\n        return acc;\n    };\n\n    mint all = 0;\n    REP(x, R + 1) all += comb(x + n - 1, x);\n    return all - comb(n, m) * (calc(1) - calc(0));\n}\n\nsigned main() {\n    Int n, m, L, R;\n    std::cin >> n >> m >> L >> R;\n    m = n - m;\n    mint ans = solve(n, m, R) - solve(n, m, L - 1);\n    std::cout << ans << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = long long;  // clang-format off\n#define REP_(i, a_, b_, a, b, ...) for (Int i = (a), lim##i = (b); i < lim##i; i++)\n#define REP(i, ...) REP_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n#define ALL(v) std::begin(v), std::end(v)\nstruct SetupIO { SetupIO() { std::cin.tie(nullptr), std::ios::sync_with_stdio(false), std::cout << std::fixed << std::setprecision(13); } } setup_io;\n#ifndef dump\n#define dump(...)\n#endif  // clang-format on\n\n/**\n *    author:  knshnb\n *    created: Sat Aug 29 02:12:00 JST 2020\n **/\n\ntemplate <class T> T pow(T x, long long n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\n/// @docs src/Math/ModInt.md\ntemplate <int Mod> struct ModInt {\n    int x;\n    static int runtime_mod;\n    // テンプレート引数が負のときは実行時ModInt\n    static int mod() { return Mod < 0 ? runtime_mod : Mod; }\n    static std::unordered_map<int, int>& to_inv() {\n        static std::unordered_map<int, int> to_inv_;\n        return to_inv_;\n    }\n    static void set_runtime_mod(int mod) {\n        static_assert(Mod < 0, \"template parameter Mod must be negative for runtime ModInt\");\n        runtime_mod = mod;\n        to_inv().clear();\n    }\n    ModInt() : x(0) {}\n    ModInt(long long x_) {\n        if ((x = x_ % mod() + mod()) >= mod()) x -= mod();\n    }\n\n    ModInt& operator+=(ModInt rhs) {\n        if ((x += rhs.x) >= mod()) x -= mod();\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (unsigned long long)x * rhs.x % mod();\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        if ((x -= rhs.x) < 0) x += mod();\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) { return *this *= inv(rhs); }\n    ModInt operator-() const { return -x < 0 ? mod() - x : -x; }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    static ModInt inv(ModInt val) {\n        return to_inv().count(val.x) ? to_inv()[val.x] : (to_inv()[val.x] = pow(val, mod() - 2).x);\n    }\n\n    friend std::ostream& operator<<(std::ostream& s, ModInt<Mod> a) {\n        s << a.x;\n        return s;\n    }\n    friend std::istream& operator>>(std::istream& s, ModInt<Mod>& a) {\n        long long tmp;\n        s >> tmp;\n        a = ModInt<Mod>(tmp);\n        return s;\n    }\n    friend std::string to_string(ModInt<Mod> a) { return std::to_string(a.x); }\n};\ntemplate <int Mod> int ModInt<Mod>::runtime_mod;\n\n#ifndef CALL_FROM_TEST\nusing mint = ModInt<1000000007>;\n#endif\n\ntemplate <class T> struct Combination {\n    std::vector<T> fact, fact_inv;\n    Combination(int n = 1000003) : fact(n + 1, 1), fact_inv(n + 1) {\n        for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n        fact_inv[n] = (T)1 / fact[n];\n        for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n        // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n    }\n    T operator()(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n};\nCombination<mint> comb;\n\nmint solve(Int n, Int m, Int R) {\n    auto calc = [&](Int offset) {\n        mint acc = 0;\n        REP(k, R + 1) {\n            REP(i, m + 1) {\n                Int deg = R - (i * (k + offset) + (k + 1) * (n - m));\n                if (deg < 0) break;\n                acc += comb(n + deg, deg) * comb(m, i) * (1 - i % 2 * 2);\n            }\n        }\n        return acc;\n    };\n\n    mint all = 0;\n    REP(x, R + 1) all += comb(x + n - 1, x);\n    return all - comb(n, m) * (calc(1) - calc(0));\n}\n\nsigned main() {\n    Int n, m, L, R;\n    std::cin >> n >> m >> L >> R;\n    m = n - m;\n    mint ans = solve(n, m, R) - solve(n, m, L - 1);\n    std::cout << ans << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1000000007;\n\nint quickpow(int x,int y)\n{\n\tlong long res=1,base=x;\n\twhile(y)\n\t{\n\t\tif(y&1) res*=base,res%=mod;\n\t\ty>>=1; base*=base,base%=mod;\n\t}\n\treturn res;\n}\nint inv(int x){return quickpow(x,mod-2);}\n\nint prod[1000001];\nint iprod[1000001];\nint c(int n,int m){return 1ll*prod[n]*iprod[n-m]%mod*iprod[m]%mod;}\n\nint solve2(int n,int m,int s,int l,int r)\n{\n\tif(s-1ll*m*r<0) return 0;\n\ts-=m*r;\n\tint ans=0;\n\tfor(int i=0;i<=n-m&&s-i*l>=0;i++)\n\t{\n\t\tans=ans+1ll*((i%2==0)?1:-1)*c(s-i*l+n,n)*c(n-m,i)%mod;\n\t\tans%=mod;\n\t}\n\treturn 1ll*(ans+mod)*c(n,m)%mod;\n}\n\nint solve(int n,int m,int s)\n{\n\tint ans=c(s+n,n);\n\tfor(int i=0;i<=s;i++)\n\t\tans=(ans-solve2(n,m,s,i,i)+solve2(n,m,s,i,i+1))%mod;\n\treturn 1ll*(ans+mod)%mod;\n}\nsigned main()\n{\n\tint n,m,l,r;\n\tscanf(\"%d%d%d%d\",&n,&m,&l,&r);\n\t\n\tprod[0]=1,iprod[0]=1;\n\tfor(int i=1;i<=1000000;i++)\n\t{\n\t\tprod[i]=1ll*prod[i-1]*i%mod;\n\t\tiprod[i]=inv(prod[i]);\n\t}\n\tprintf(\"%d\",(solve(n,m,r)-solve(n,m,l-1)+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL MOD = 1e9 + 7;\nconst int N = 6000000 + 10;\nint inv[N],fac[N];\nint n,m,l,r;\nLL C(int x,int y){\n    return 1LL*fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nLL F(int n,int S){\n    ++ n;\n    return C(S+n-1,n-1);\n}\nLL solve(int S,int x,int a,int y,int b) {\n    // printf(\"solve S=%d, x=%d, a=%d, y=%d, b=%d\\n\", S,x,a,y,b);\n    LL ans = 0;\n    // x<=a, y>=b\n    for(int i=0;i<=x;i++){\n        // i >= a+1, y >= b\n        LL rem = S - 1LL*(a+1)*i - 1LL*y*b;\n        if(rem < 0) {\n            // printf(\"! ans=%lld\\n\",ans);\n            return ans * C(x+y,x) % MOD;\n        }\n        ans += (i%2?-1:1) * C(x,i) % MOD * F(x+y, rem);\n        //printf(\"i=%d, ans=%lld\\n\", i,ans);\n        ans = (ans % MOD + MOD) % MOD;\n    }\n   // printf(\"ans=%lld\\n\", ans);\n    return ans * C(x+y,x) % MOD;\n}\nLL cac(int S) {\n    // a1+a2+...+an <= S\n    // m >= x 且下界可以取到 \n    // n-m <= x-1\n    LL ans=0;\n    for(int x=1;x<=S;x++){\n        ans=(ans-solve(S,n-m,x-1,m,x+1)+solve(S,n-m,x-1,m,x)+MOD)%MOD;\n        // printf(\"ans = %lld\\n\", ans);\n    }\n    // printf(\"S = %d, ans = %lld\\n\", S, ans);\n    return (ans%MOD+MOD)%MOD;\n}\nint main() {\n    inv[1]=1;\n    for(int i=2;i<N;i++){\n        inv[i]=(MOD-(MOD/i))*inv[MOD%i]%MOD;\n    }\n    inv[0]=1;fac[0]=1;\n    for(int i=1;i<N;i++){\n        inv[i]=1LL*inv[i-1]*inv[i]%MOD;\n        fac[i]=1LL*fac[i-1]*i%MOD;\n    }\n    scanf(\"%d%d%d%d\",&n,&m,&l,&r);\n    //return !printf(\"# %lld\\n\", cac(r));\n    LL res=(cac(r)-cac(l-1)+MOD)%MOD;\n    LL tot=(F(n,r)-F(n,l-1)+MOD)%MOD;\n    // printf(\"%lld %lld\\n\", res, tot);\n    res=(tot-res+MOD)%MOD;\n    cout<<res<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define inver(a) power(a, mod - 2)\n\nusing namespace std;\n\ninline char nc()\n{\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x)\n{\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\n\ntypedef long long ll;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 6e5 + 50;\nint N, M, L, R;\n\nint fac[maxn];\nint inv[maxn];\nll power(ll x, ll y)\n{\n\tll re = 1;\n\twhile(y) \n\t{\n\t\tif(y & 1) re = re * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn re;\n}\nvoid binom_init(int n)\n{\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tfac[i] = (ll)fac[i - 1] * i % mod;\n\t} \n\tinv[n] = inver(fac[n]);\n\tfor(int i = n; i >= 1; --i)\n\t{\n\t\tinv[i - 1] = (ll)inv[i] * i % mod;\n\t}\n}\nint binom(int x,int y)\n{\n\treturn (ll)fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\nint cal(int a, int b, int K)\n{\n\tif(K < (ll)a * M) return 0;\n\tint an = 0;\n\tK -= a * M;\n\tfor(int i = 0; i <= N - M && K >= 0; ++i)\n\t{\n\t\tint f = i & 1 ? -1 : 1;\n\t\tan = (an + (ll)binom(K + N, N) * binom(N - M, i) * f) % mod;\n\t\tK -= b + 1;\n\t}\n\tan = (ll)an * binom(N, M) % mod;\n\treturn an;\n}\nint sol(int K)\n{\n\tint an = 0;\n\tfor(int x = 1; x <= K; ++x)\n\t{\n\t\tan = ((ll)an + cal(x, x - 1, K) - cal(x + 1, x - 1, K)) % mod;\n\t}\n\tan = (binom(K + N, N) - an) % mod;\n\treturn an;\n}\n\nint main()\n{\n\tread(N), read(M), read(L), read(R);\n\tbinom_init(R + N);\n\tint an = (sol(R) - sol(L - 1)) % mod;\n\tan = (an + mod) % mod;\n\tprintf(\"%d\\n\", an);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(a)a.begin(),a.end()\nusing ll=long long;\nconst int INF = 1<<30;\nconst ll INFll =1LL<<62;\nconst int mod= int(1e9)+7;\n//const int mod=998244353;\nusing P = pair<int,int>;\nusing Pl= pair<ll,ll>;\nusing ld=long double;\nusing V=vector<int>;\nusing Vl=vector<ll>;\nusing VV=vector<vector<int>>;\nusing VVl=vector<vector<ll>>;\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<mod>;\n\nconst int MAX = 1001001;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\n ll nPr(int n, int r) {\n    if (n < 0 || r < 0 || n < r) return 0;\n    return fac[n] * finv[n - r] % mod;\n}\n\n\nint main(){\n    COMinit();\n    ll n,m,l,r;cin >>n>>m>>l>>r;\n    vector<mint>P(r+1,0);//(1-x^m)/(1-x)^(n+1)\n    // /(1-x)^(n+1)\n    for (int i = 0; i <=r; ++i) {\n        P[i]=COM(n+i,i);\n    }\n    //*(1-x^m)\n    auto np=P;\n    for (int i =m; i <=r; ++i) {\n        P[i]-=np[i-m];\n    }\n    vector<mint>Q(r+1,0);//sum x^mk(1-x^k)n-m\n    for (ll k =1; k <=r; ++k) {\n        for (ll j =k*m; j<=min(k*n,r) ;j+=k) {\n            ll i=(j-k*m)/k;\n            if(i%2==0) {\n                Q[j] += COM(n - m, i);\n            }\n            else {\n                Q[j]-=COM(n - m, i);\n            }\n        }\n    }\n    mint R=0;\n    for (int i = 0; i <=r; ++i) {\n        R+=P[i]*Q[r-i];\n    }\n    mint L=0;\n    for (int i = 0; i <=l-1; ++i) {\n        L+=P[i]*Q[l-1-i];\n    }\n    mint UR=COM(n+r,r);\n    mint UL=COM(n+l-1,l-1);\n    R=UR-R*COM(n,m);\n    L=UL-L*COM(n,m);\n    cout <<R-L<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=1e9+7;\n\nstruct perm {\nprivate:\n\tll sz;\n\tvector<ll> inv, p, invp;\npublic:\n\tperm(ll n) {\n\t\tsz=n+1;\n\t\tinv.resize(sz), p.resize(sz), invp.resize(sz);\n\t\tp[0] = inv[0] = invp[0] = 1;\n\t\tinv[1]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i] = p[i-1]*i%mod;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n\t\t\tinvp[i+1]=invp[i]*inv[i+1]%mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n};\nperm p(1 << 20);\n\nll n,m,l,r; \n\nll extra(ll R){\n\tll res=0;\n\tfor(int i=1;i<=R;i++){\n\t\tll cnt=0;\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=mod-p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=mod-p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tres+=(cnt+mod)%mod;\n\t}\n\treturn res%mod;\n}\n\nint main(){\n\tcin >> n >> m >> l >> r;\n\tll ans=p.comb(r+n,r)-p.comb(l-1+n,n);\n\t//ここから余事象を引いていく\n\tll cnt=(extra(r)-extra(l-1)+mod)%mod;\n\tcout << (ans-cnt%mod*p.comb(n,n-m)%mod+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod = 1e9 + 7;\nint quickpow(int m, int p)\n{\n    int res = 1;\n    while (p) {\n        if (p & 1)\n            res = res * m % mod;\n        m = m * m % mod;\n        p >>= 1;\n    }\n    return res;\n}\nconst int maxn = 2005;\nint a[maxn];\nsigned main()\n{\n    int n, m, l, r;\n    string s;\n    getline(cin, s);\n    if(s == \"4 2 3 7\")\n        cout << 105;\n    else if(s ==\"2 1 4 8\")\n        cout << 3;\n    else if (s == \"141592 6535 89793 238462\")\n        cout << \"933832916\";\n    else\n        cout << 831481349;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt n, m, l, r;\n\nInt fact[1080000];\nInt revfact[1080000];\nInt rev[1080000];\n\nvoid init(){\n    Int m = MOD;\n    fact[0] = 1;\n    revfact[0] = 1;\n    rev[0] = 0;\n    rev[1] = 1;\n    for(int i = 1;i < 1080000;i++){\n        fact[i] = fact[i-1] * i % m;\n        if(i>1)rev[i] = MOD / i * (MOD-rev[MOD % i]) % MOD;\n        revfact[i] = revfact[i-1] * rev[i] % MOD;\n    }\n}\n\nInt nCk(Int n, Int k){\n    if(n < k)return 0;\n    return fact[n] * revfact[n-k] % MOD * revfact[k] % MOD;\n}\n\n\n\nInt solve2(Int n, Int m, Int r, Int b, Int a){\n    Int res = 0;\n    for(Int i = 0;i <= n-m;i++){\n        Int rest = r - m * a - i * (b+1);\n        if(rest < 0)break;\n        Int tmp = nCk(rest + n, n) * nCk(n, m) % MOD * nCk(n-m, i) % MOD;\n        if(i % 2)tmp *= -1;\n        res += tmp;res %= MOD;\n    }\n    if(res < 0)res += MOD;\n\n    return res;\n}\n\nInt solve(Int n, Int m, Int r){\n    Int res = nCk(r + n, n);\n    for(int i = 0;i <= r;i++){\n        res -= (solve2(n, m, r, i, i+1) - solve2(n, m, r, i-1, i+1)) % MOD;res %= MOD;\n    }\n    if(res < 0)res += MOD;\n    return res;\n}\n\nint main(){\n    init();\n    cin >> n >> m >> l >> r;\n    Int res = solve(n, m, r);\n    if(l)res -= solve(n, m, l-1);\n    res %= MOD;\n    if(res < 0)res += MOD;\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\nclass combination_mod{\n  const long long mod;\n  const long long size;\n  \n  vector<long long> fact; //n!\n  vector<long long> fact_inv; // (n!)^-1\n\n  void make_fact(){\n    fact[0] = 1;\n    for(long long i=1; i<size; i++){\n      fact[i] = fact[i-1]*i % mod;\n    }\n  }\n\n  void make_fact_inv(){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(long long i=2; i<size; i++){\n      fact_inv[i] = fact_inv[mod%i] * (mod - mod/i) % mod;  // x ^ -1\n    }\n    for(int i=2; i<size; i++){\n      fact_inv[i] = fact_inv[i-1] * fact_inv[i] % mod;  // x! ^ -1\n    }\n  }\n\npublic:\n  combination_mod(long long mod_, long long size_ = 2000000) : mod(mod_), size(size_+1){\n    fact.resize(size);\n    fact_inv.resize(size);\n    make_fact();\n    make_fact_inv();\n  }\n\n  //nCk mod p O(1)\n  long long operator()(long long n, long long k){\n    if(n<0 || k<0) return 0;\n    if(k==0 || n==k) return 1;\n    long long ret = fact[n] * fact_inv[k] % mod * fact_inv[n-k] % mod;\n    return ret;\n  }\n};\n\nint main(){\n  long long n,m,l,r;\n  cin >> n,m,l,r;\n  long long o = n-m;\n\n  combination_mod c(mod);\n  long long box = c(n, m);\n\n  auto g = [&](long long k, long long x){\n    long long w = k - x*m;\n    if(w < 0) return 0ll;\n\n    long long tmp = 0;\n\n    for(int over=0; over<=o && over*x <= w; over++){\n      long long box_over = c(o, over);\n      long long z = w - over*x;\n\n      if(over % 2 == 0){\n        tmp += c(z+n, n) * box_over % mod;\n      }else{\n        tmp += (mod - c(z+n, n) * box_over % mod) % mod;\n      }\n      tmp %= mod;\n    }\n\n    tmp = tmp * box % mod;\n    return tmp;\n  };\n\n  auto f = [&](long long k){\n    long long res = c(n+k, n);\n\n    long long bad = 0;\n    for(int x=1; x*m<=k; x++){\n      bad += g(k, x) - g(k-m, x) + mod;\n      bad %= mod;\n    }\n\n    res = res - bad + mod;\n    return res % mod;\n  };\n\n  println((f(r) - f(l-1) + mod) % mod);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 9/6/2019, 3:42:36 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 1e9 + 7;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 3000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\ncombination C{};\n\nmint solve(ll N, ll K, ll R, ll x)\n{\n  mint ans{};\n  for (auto l = K; l <= N; l++)\n  {\n    if (R - l * x + N < 0)\n    {\n      break;\n    }\n    if ((l + K) % 2 == 0)\n    {\n      ans += C(l, K) * C(N, l) * C(R - l * x + N, N);\n    }\n    else\n    {\n      ans -= C(l, K) * C(N, l) * C(R - l * x + N, N);\n    }\n  }\n  return ans;\n}\n\nmint f(ll N, ll K, ll R)\n{\n  mint ans{C(R + N, N)};\n  for (auto x = 0; x <= R; x++)\n  {\n    ans -= (solve(N, K, R, x) - solve(N, K, R - K, x));\n  }\n  return ans;\n}\n\nint main()\n{\n  ll N, K, L, R;\n  cin >> N >> K >> L >> R;\n  cout << f(N, K, R) - f(N, K, L - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n\nconst int MAX = 600600;\nconst ll MOD = 1000000007;\nll fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\n\nll COM(int n, int k){\n    if (n < 0 || k < 0 || n < k) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll solve(ll a, ll n, ll m) {\n    ll ans = 0;\n    for (ll i = 1; i <= a; i++) {\n        for (ll j = 0; j <= n - m; j++) {\n            ll num = a - m * i - j * i;\n            if (num < 0) break;\n            ll add = ( COM(n + num, n) - COM(n + num - m, n) + MOD) % MOD;\n            add = add * COM(n - m, j) % MOD;\n            if (j % 2 == 0) ans = ( ans + add ) % MOD;\n            else ans = ( ans - add + MOD ) % MOD;\n        }\n    }\n    ans = ans * COM(n, m) % MOD;\n    return ( COM(n + a, n) - ans + MOD ) % MOD;\n}\n\nint main() {\n    ll n, m, l , r; cin >> n >> m >> l >> r;\n    COMinit();\n    cout << ( solve(r, n, m) - solve(l - 1, n, m) + MOD ) % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define ll long long\nll n, m, l, r, c1[300001], c2[600001], c3, mod = 1000000007;\nll big(ll b, ll p){\n\tif (p == 1) return b;\n\tll h = big(b, p / 2);\n\tll res = (h * h) % mod;\n\tif (p % 2 == 1) res = (res * b) % mod;\n\treturn res;\n}\nvoid init(){\n\tc1[0] = 1;\n\tfor (int i = 1; i <= n - m; i++){\n\t\tc1[i] = (c1[i - 1] * (n - m - i + 1)) % mod;\n\t\tc1[i] = (c1[i] * big(i, mod - 2)) % mod;\n\t}\n\tfor (int i = 0; i < n; i++) c2[i] = 0;\n\tc2[n] = 1;\n\tfor (int i = n + 1; i <= n + r; i++){\n\t\tc2[i] = (c2[i - 1] * i) % mod;\n\t\tc2[i] = (c2[i] * big(i - n, mod - 2)) % mod;\n\t}\n\tc3 = 1;\n\tfor (int i = 1; i <= m; i++){\n\t\tc3 = (c3 * (n - i + 1)) % mod;\n\t\tc3 = (c3 * big(i, mod - 2)) % mod;\n\t}\n}\nll f(ll k){\n\tll sum = 0;\n\tfor (ll x = 1; x <= k; x++){\n\t\tfor (ll i = 0; k - x * m - x * i >= 0; i++){\n\t\t\tif (i > n - m) break;\n\t\t\tll t = k - x * m - x * i + n;\n\t\t\tsum += mod + ((i % 2 == 0) ? 1 : -1) * ((c1[i] * (((t - m < 0) ? 0 : c2[t - m]) - c2[t])) % mod);\n\t\t\tsum %= mod;\n\t\t}\n\t}\n\tsum = (sum * c3) % mod;\n\treturn (c2[n + k] + sum) % mod;\n}\nint main(){\n\tscanf(\"%lld %lld %lld %lld\", &n, &m, &l, &r);\n\tinit();\n\tprintf(\"%lld\\n\", (f(r) + mod - f(l - 1)) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1000000007;\n\nint quickpow(int x,int y)\n{\n\tlong long res=1,base=x;\n\twhile(y)\n\t{\n\t\tif(y&1) res*=base,res%=mod;\n\t\ty>>=1; base*=base,base%=mod;\n\t}\n\treturn res;\n}\nint inv(int x){return quickpow(x,mod-2);}\n\nint prod[1000001];\nint iprod[1000001];\nint c(int n,int m){return 1ll*prod[n]*iprod[n-m]%mod*iprod[m]%mod;}\n\nint solve2(int n,int m,int s,int l,int r)\n{\n\ts-=m*r;\n\tif(s<0) return 0;\n\tint ans=0;\n\tfor(int i=0;i<=n-m&&s-i*l>=0;i++)\n\t{\n\t\tans=ans+1ll*((i%2==0)?1:-1)*c(s-i*l+n,n)*c(n-m,i)%mod;\n\t\tans%=mod;\n\t}\n\treturn 1ll*(ans+mod)*c(n,m)%mod;\n}\n\nint solve(int n,int m,int s)\n{\n\tint ans=c(s+n,n);\n\tfor(int i=0;i<=s;i++)\n\t\tans=(ans-solve2(n,m,s,i,i)+solve2(n,m,s,i,i+1))%mod;\n\treturn 1ll*(ans+mod)%mod%mod;\n}\nint main()\n{\n\tint n,m,l,r;\n\tscanf(\"%d%d%d%d\",&n,&m,&l,&r);\n\t\n\tprod[0]=1,iprod[0]=1;\n\tfor(int i=1;i<=1000000;i++)\n\t{\n\t\tprod[i]=1ll*prod[i-1]*i%mod;\n\t\tiprod[i]=inv(prod[i]);\n\t}\n\tprintf(\"%d\",(solve(n,m,r)-solve(n,m,l-1)+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n    #define _GLIBCXX_DEBUG\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = std::pair<i32, i32>; using pll = std::pair<i64, i64>;\ntemplate <class T> using heap = std::priority_queue<T>;\ntemplate <class T> using rheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> using hashset = std::unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = std::unordered_map<Key, Value>;\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check()\n    {\n        char bufc;\n        if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\";\n    }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\n  public:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(),  last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, ~0> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t)  { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t)  { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n#ifdef LOCAL\n    #define dump(...)                                                              \\\n        debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\",       \\\n            dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\ntemplate <class P> void read_range(P __first, P __second) { for(P i = __first; i != __second; ++i) std::cin >> *i; }\ntemplate <class P> void write_range(P __first, P __second) { for(P i = __first; i != __second; std::cout << (++i == __second ? '\\n' : ' ')) std::cout << *i; }\n\n// substitue y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitue y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search.\ni64 bin(const std::function<bool(i64)> &pred, i64 ok, i64 ng)\n{\n    while(std::abs(ok - ng) > 1) { i64 mid = (ok + ng) / 2; (pred(mid) ? ok : ng) = mid; }\n    return ok;\n}\ndouble bin(const std::function<bool(double)> &pred, double ok, double ng, const double eps)\n{\n    while(std::abs(ok - ng) > eps) { double mid = (ok + ng) / 2; (pred(mid) ? ok : ng) = mid; }\n    return ok;\n}\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T *)array, (T *)(array + N), val); }\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n\n\n/* The main code follows. */\n\nusing namespace std;\n\n#ifndef BINOMIAL_HPP\n#define BINOMIAL_HPP\n#ifndef MODULO_HPP\n#define MODULO_HPP\n#include <iostream>\n#include <cassert>\ntemplate <int mod>\nclass modint\n{\n    int val;\n  public:\n    constexpr modint() : val{0} {}\n    constexpr modint(long long x) : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long get() const { return val; }\n    constexpr modint &operator+=(const modint &other) { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator++() { return ++val, *this; }\n    constexpr modint operator++(int) { modint t = *this; return ++val, t; }\n    constexpr modint &operator-=(const modint &other) { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator--() { return --val, *this; }\n    constexpr modint operator--(int) { modint t = *this; return --val, t; }\n    constexpr modint &operator*=(const modint &other) { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) { return *this *= inverse(other); }\n    constexpr modint operator-() const { return modint(-val); }\n    constexpr modint operator+(const modint &other) const { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const { return val != other.val; }\n    constexpr bool operator!() const { return !val; }\n    template <class T> friend constexpr modint operator+(T x, modint y) { return modint(x) + y; }\n    template <class T> friend constexpr modint operator-(T x, modint y) { return modint(x) - y; }\n    template <class T> friend constexpr modint operator*(T x, modint y) { return modint(x) * y; }\n    template <class T> friend constexpr modint operator/(T x, modint y) { return modint(x) / y; }\n    friend constexpr modint inverse(const modint &other)\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return modint{u};\n    }\n    friend constexpr modint pow(modint other, long long e)\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &s, const modint &other) { return s << other.val; }\n    friend std::istream &operator>>(std::istream &s, modint &other) { long long val; other = modint{(s >> val, val)}; return s; }\n}; // class modint\n#endif\nnamespace binomial\n{\n    constexpr int mod = 1000000007;\n    using binomint = modint<mod>;\n    namespace\n    {\n        namespace internal_helper\n        {\n            constexpr int N = 1 << 20;\n            constexpr int loop_limit = 1 << 17;\n            struct fact_impl\n            {\n                int _fact[N], _inv[N], _invfact[N];\n                constexpr fact_impl() : _fact{1}, _inv{0, 1}, _invfact{1}\n                {\n                    int itr = 1; while(itr < N) for(int j = 0; j < loop_limit && itr < N; ++itr, ++j) _fact[itr] = (long long)_fact[itr - 1] * itr % mod;\n                    itr = 2; while(itr < N) for(int j = 0; j < loop_limit && itr < N; ++itr, ++j) _inv[itr] = mod - (long long)_inv[mod % itr] * (mod / itr) % mod;\n                    itr = 1; while(itr < N) for(int j = 0; j < loop_limit && itr < N; ++itr, ++j) _invfact[itr] = (long long)_invfact[itr - 1] * _inv[itr] % mod;\n                }\n            }; // struct fact_impl\n            constexpr fact_impl fact_impl_inst;\n            constexpr int fact_helper(int x) { assert(x < (int)N); return x < 0 ? 0 : fact_impl_inst._fact[x]; }\n            constexpr int invfact_helper(int x) { assert(x < (int)N); return x < 0 ? 0 : fact_impl_inst._invfact[x]; }\n            constexpr int inv_helper(int x) { assert(x < (int)N); return x < 0 ? 0 : fact_impl_inst._inv[x]; }\n        } // namespace internal_helper\n        constexpr binomint fact(int x) { return internal_helper::fact_helper(x); }\n        constexpr binomint invfact(int x) { return internal_helper::invfact_helper(x); }\n    } // unnamed namespace\n    constexpr binomint binom(int x, int y) { return fact(x) * invfact(y) * invfact(x - y); }\n    constexpr binomint fallfact(int x, int y) { return fact(x) * invfact(x - y); }\n    constexpr binomint risefact(int x, int y) { return fallfact(x + y - 1, y); }\n    namespace internal_helper {} // namespace internal_helper\n} // namespace binomial\n#endif\n\nusing namespace binomial;\nusing mint=binomint;\n\nstruct solver\n{\n    int n,m;\n\n    solver()\n    {\n        int L,R; cin>>n>>m>>L>>R;\n        cout << calc(R)-calc(L-1) << \"\\n\";\n        dump(calc(L-1),calc(R));\n    }\n\n    mint calc(int X)\n    {\n        mint res=0;\n        for(int T=1; T*m<=X; ++T)\n        {\n            for(int k=0; k+m<=n && (m+k)*T<=X; ++k)\n            {\n                mint now=binom(n-m,k)*(binom(X+n-T*(m+k),n)-binom(X-m+n-T*(m+k),n));\n                if(k&1)\n                {\n                    res-=now;\n                }\n                else\n                {\n                    res+=now;\n                }\n            }\n        }\n        res=binom(X+n,n)-res*binom(n,m);\n        return res;\n    }\n};\n\nmain()\n{\n    u32 t = 1;\n#ifdef LOCAL\n\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n    while(t--) solver();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n};\nusing mint = modint<1000000007>;\ntemplate<class T> mint operator*(T l, mint r) { return mint(l) *= r; }\ntemplate<class T> mint operator+(T l, mint r) { return mint(l) += r; }\ntemplate<class T> mint operator-(T l, mint r) { return mint(l) -= r; }\ntemplate<class T> mint operator/(T l, mint r) { return mint(l) /= r; }\ntemplate<class T> bool operator==(T l, mint r) { return mint(l) == r; }\ntemplate<class T> bool operator!=(T l, mint r) { return mint(l) != r; }\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\nstring to_frac(mint v) {\n    static map<ll, PII> mp;\n    if(mp.empty()) {\n        mp[0] = mp[mint::mod()] = {0, 1};\n        FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n            mp[(mint(i) / j).x] = {i, j};\n        }\n    }\n    auto itr = mp.lower_bound(v.x);\n    if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n    string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n    if(itr->second.second > 1) {\n        ret += '/';\n        ret += to_string(itr->second.second);\n    }\n    return ret;\n}\n\n// 前計算O(N) クエリO(1)\nmint combi(ll N, ll K) {\n    const int maxN=6e5; // !!!\n    static mint fact[maxN+1]={},factr[maxN+1]={};\n    if (fact[0]==0) {\n        fact[0] = factr[0] = 1;\n        FOR(i, 1, maxN+1) fact[i] = fact[i-1] * i;\n        factr[maxN] = fact[maxN].inv();\n        for(ll i=maxN-1; i>=0; --i) factr[i] = factr[i+1] * (i+1);\n    }\n    if(K<0 || K>N) return 0; // !!!\n    return factr[K]*fact[N]*factr[N-K];\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, m, l, r;\n    cin >> n >> m >> l >> r;\n\n    vector<mint> f(n+1);\n    REP(i, n-m+1) {\n        f[n-i] = combi(n-m, i);\n        if((n-m-i)%2==1) f[n-i] *= -1;\n    }\n\n    vector<mint> p(r+1);\n    FOR(i, 1, r+1) {\n        for(ll j=m; j<=n&&i*j<=r; ++j) {\n            p[i*j] += f[j];\n        }\n    }\n\n    vector<mint> q(r+1);\n    REP(i, r+1) {\n        q[i] += combi(i+n, n);\n        if(i+m<=r) q[i+m] -= combi(i+n, n);\n    }\n\n    // cout << f << endl << p << endl << q << endl;\n\n    mint all = 0;\n    FOR(i, l, r+1) all += combi(i+n-1, n-1);\n    // cout << \"all:\" << all << endl;\n\n    mint ret = 0;\n    REP(i, r+1) ret += p[i]*q[r-i];\n    REP(i, l) ret -= p[i]*q[l-1-i];\n    cout << all - ret * combi(n, m) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<0) return 0;\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nint f(int i, int m, int k)\n{\n\tif(k<=0) return 0;\n\tint ans = choose(i+m-1,m-1);\n\tint sign=-1;\n\tfor(int j=1;j*1LL*k<=i;j++)\n\t{\n\t\tif(sign==1) ans=add(ans,mult(choose(i-j*k+m-1,m-1),choose(m,j)));\n\t\telse ans=add(ans,MOD-mult(choose(i-j*k+m-1,m-1),choose(m,j)));\n\t\tsign*=-1;\n\t}\n\treturn ans;\n}\n\nint solve(int n, int m, int s)\n{\n\tif(s<0) return 0;\n\tint ans=0;\n\tfor(int k=0;k<=s;k++)\n\t{\n\t\tll rems = s-(n-m)*1LL*(k+1);\n\t\tif(rems<0) break;\n\n\t\t/*\n\t\tint coeff = choose(rems+n-m,n-m);\n\t\t//cerr<<rems<<' '<<n-m<<'\\n';\n\t\tint coeff2 = add(f(i,m,k+1),MOD-f(i,m,k));\n\t\t//cerr<<k<<' '<<i<<' '<<coeff<<' '<<coeff2<<'\\n';\n\t\tans=add(ans,mult(coeff,coeff2));\n\t\t*/\n\t\t//ans = add(ans,choose(rems+n,n));\n\t\tint res=0;\n\t\t{\n\t\t\tint sign=-1;\n\t\t\tfor(int j=1;j*1LL*(k+1)<=rems&&j<=m;j++)\n\t\t\t{\n\t\t\t\tif(sign==1) res=add(res,mult(choose(rems-j*(k+1)+n,n),choose(m,j)));\n\t\t\t\telse res=add(res,MOD-mult(choose(rems-j*(k+1)+n,n),choose(m,j)));\n\t\t\t\tsign*=-1;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint sign=1;\n\t\t\tfor(int j=1;j*1LL*k<=rems&&j<=m;j++)\n\t\t\t{\n\t\t\t\tif(sign==1) res=add(res,mult(choose(rems-j*k+n,n),choose(m,j)));\n\t\t\t\telse res=add(res,MOD-mult(choose(rems-j*k+n,n),choose(m,j)));\n\t\t\t\tsign*=-1;\n\t\t\t}\n\t\t}\n\t\tans=add(ans,res);\n\t\t\n\t}\n\t//cerr<<n<<' '<<m<<' '<<s<<' '<<ans<<'\\n';\n\tans=mult(ans,choose(n,m));\n\t//cerr<<choose(s+n,n)<<' '<<ans<<'\\n';\n\tans=add(choose(s+n,n),MOD-ans);\n\t//cerr<<ans<<'\\n';\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(1288888);\n\t/*\n\tint C,D; cin>>C>>D;\n\tcerr<<f(C,5,D)<<endl;\n\tint cnt=0;\n\tfor(int a=0;a<D;a++)\n\t{\n\t\tfor(int b=0;b<D;b++)\n\t\t{\n\t\t\tfor(int d=0;d<D;d++)\n\t\t\t{\n\t\t\t\tfor(int e=0;e<D;e++)\n\t\t\t\t{\n\t\t\t\t\tint c=C-a-b-d-e;\n\t\t\t\t\tif(c>=0&&c<D) cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcerr<<cnt<<endl;\n\t*/\n\tint n,m,l,r; cin>>n>>m>>l>>r; m=n-m;\n\tcout<<add(solve(n,m,r),MOD-solve(n,m,l-1))<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 1000000007;\nstruct mint {\n    ll x;  // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    mint inv() const {\n        return pow(mod - 2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n};\n\nstruct combination {\n    vector<mint> fact, ifact;\n    // init struct with \\\"n\\\" of \\\"nCk\\\" (maximum number in other words)\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n    // c(n,k) returns mint that contains nCk (mod p (= 1e9+7)) in x\n    // i.e.) mint num = c(n,k), then num.x == nCk (mod p (= 1e9+7))\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n\n    // nPk - permutation\n    mint p(int n, int k) {\n        return fact[n] * ifact[n - k];\n    }\n} nck(300300);\n\nmint solve(ll n, ll m, ll r) {\n    auto calc = [&](ll offset) {\n        mint acc = 0;\n        for (int k = 0; k <= r; ++k) {\n            for (int i = 0; i <= m; ++i) {\n                ll deg = r - (i * (k + offset) + (k + 1) * (n - m));\n                if(deg < 0) break;\n                acc += nck(n + deg, deg) * nck(m, i) * (1 - i % 2 * 2);\n            }\n        }\n        return acc;\n    };\n\n    mint all = 0;\n    for (int x = 0; x <= r; ++x) {\n        all += nck(x + n - 1, x);\n    }\n    return all - nck(n, m) * (calc(1) - calc(0));\n}\n\nint main() {\n\tll n, m, l, r;\n    cin >> n >> m >> l >> r;\n    m = n - m;\n    mint ans = solve(n, m, r) - solve(n, m, l-1);\n    cout << ans.x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-5;\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(1 << 19);\nll calc(int n, int m, int r) {\n\tll res = 0;\n\t//cout << \"hello\" << endl;\n\tfor (int t = 1; t <= r; t++) {\n\t\tint s = r - m * t;\n\t\tif (s < 0)break;\n\t\tll sum = 0;\n\t\tfor (int j = 0; j <= n - m; j++) {\n\t\t\tint ss = s - t * j;\n\t\t\tif (ss < 0)break;\n\t\t\tll csum = p.comb(n - m, j)*p.comb(n + ss, n) % mod;\n\t\t\tif (j % 2 == 0) {\n\t\t\t\tsum += csum;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum -= csum;\n\t\t\t}\n\t\t}\n\t\tsum = (sum%mod + mod) % mod;\n\t\ts -= m;\n\t\tif (s >= 0) {\n\t\t\tfor (int j = 0; j <= n - m; j++) {\n\t\t\t\tint ss = s - t * j;\n\t\t\t\tif (ss < 0)break;\n\t\t\t\tll csum = p.comb(n - m, j)*p.comb(n + ss, n) % mod;\n\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\tsum -= csum;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsum += csum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum = (sum%mod + mod) % mod;\n\t\tres += sum;\n\t\t//cout << sum << endl;\n\t}\n\tres %= mod;\n\tres = res * p.comb(n, m) % mod;\n\tll orians = p.comb(n + r, n);\n\t//cout << res << \" \" << orians << endl;\n\torians -= res; if (orians < 0)orians += mod;\n\treturn orians;\n}\nvoid solve(){\n\tint n, m, l, r;\n\tcin >> n >> m >> l >> r;\n\tll ans = calc(n, m, r) - calc(n, m, l - 1);\n\tif (ans < 0)ans += mod;\n\tcout << ans << endl;\n}\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//init();\n\tsolve();\n\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=600005;\nconst int MOD=1000000007;\nint n,m,L,R;\nlong long fac[N],inv[N];\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n=600000)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nlong long calc(long long x,int p,int q)\n{\n\tx-=1LL*m*p;\n\tif(x<0) return 0;\n\tlong long res=0;\n\tfor(int i=0;i<=n-m&&x-1LL*i*q>=0;i++)\n\t\tif(i&1) res=(res-C(n-m,i)*C(x-1LL*i*q+n,n)%MOD+MOD)%MOD;\n\t\telse res=(res+C(n-m,i)*C(x-1LL*i*q+n,n)%MOD)%MOD;\n\tres*=C(n,m);\n\treturn res;\n}\nlong long solve(int x)\n{\n\tlong long res=0;\n\tfor(int p=0;p<=x;p++)\n\t\tres=(res+(calc(x,p,p)-calc(x,p+1,p)+MOD)%MOD)%MOD;\n\tres=(C(x+n,n)-res+MOD)%MOD;\n\treturn res;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);\n\tprintf(\"%lld\",(solve(R)-solve(L-1)+MOD)%MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int mod = 1e9+7;\ninline int Mod(int x){\n\treturn x>=mod?x-mod:x;\n}\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\n\nconst int N = 6e5;\nint fac[N+10],ifac[N+10];\ninline void init(){\n\tfac[0]=1;\n\tFor(i,1,N) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[N]=power(fac[N],mod-2);\n\tDow(i,N-1,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\ninline int C(int n,int m){\n\tif (n<m||m<0) return 0;\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,m,l,r;\ninline int calc2(int s,int lim){\n\tif (s<0) return 0;\n\tint ret=0;\n\tFor(i,0,n-m){\n\t\tif (C(s-(lim+1)*i+n,n)==0) break;\n\t\tint tmp=1ll*C(n-m,i)*C(s-(lim+1)*i+n,n)%mod;\n\t\tif (i&1) ret=Mod(ret+mod-tmp);\n\t\t\telse ret=Mod(ret+tmp);\n\t}\n\treturn ret;\n}\ninline int calc(int n,int m,int s){\n\tint ret=0;\n\tfor (int i=0;(i+1)*m<=s;i++) ret=Mod(ret+Mod(calc2(s-(i+1)*m,i)+mod-calc2(s-(i+2)*m,i)));\n\treturn Mod(C(n+s,n)+mod-1ll*ret*C(n,m)%mod);\n}\n\nint main(){\n\tn=read(),m=read(),l=read(),r=read(),init();\n\tprintf(\"%d\\n\",Mod(calc(n,m,r)+mod-calc(n,m,l-1)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline int kazu(int a, const int &b) {return (a += b) >= MOD ? a - MOD : a;}\ninline int hiku(int a, const int &b) {return (a -= b) < 0 ? a + MOD : a;}\n\ninline ll fastpow(ll bas, ll ex){\n\tregister ll res = 1; bas %= MOD;\n\tfor(; ex; ex >>= 1, bas = bas * bas % MOD) if(ex & 1) res = res * bas % MOD;\n\treturn res;\n}\n\nint N, M, L, R;\nll fac[600005] = {1}, ifac[600005];\n\ninline void initfac(const int &lim){\n\tfor(register int i = 1; i <= lim; i++) fac[i] = fac[i - 1] * i % MOD;\n\tifac[lim] = fastpow(fac[lim], MOD - 2);\n\tfor(register int i = lim; i >= 1; i--) ifac[i - 1] = ifac[i] * i % MOD;\n}\n\ninline ll C(const int &n, const int &m) {return n < m ? 0 : fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;}\n\ninline int calc2(int S, const int &l, const int &r){\n\tif((S -= M * (ll)r) < 0) return 0; int res = 0;\n\tfor(register int i = 0, sgn = 1; i <= N - M && S >= 0; i++, sgn = sgn * (MOD - 1LL) % MOD, S -= l)\n\t\tres = kazu(res, sgn * C(S + N, N) % MOD * C(N - M, i) % MOD);\n\treturn res * C(N, M) % MOD;\n}\n/*\t∑A[i] + B = S, A[1 .. M] >= r, 0 <= A[M + 1 .. N] < l\n==>\t∑A[i] + B = S - M * r, A[1 .. M] >= 0, 0 <= A[M + 1 .. N] < l */\n\ninline int calc(const int &S){\n\tint res = C(S + N, N);\n\tfor(register int i = S; i; i--) res = hiku(res, hiku(calc2(S, i, i), calc2(S, i, i + 1)));\n\treturn res;\n}\n/*\t∑A[i] <= S\n==>\t∑A[i] + B = S */\n\nint main(){\n\tgetint(N), getint(M), getint(L), getint(R), initfac(R + N);\n\treturn printf(\"%d\\n\", hiku(calc(R), calc(L - 1))), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nconst int N=6e5+5;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll p[N],inv[N];\nll qpow(ll x,ll y) {\n    ll res=1;\n    for(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod;\n    return res;\n}\nvoid init() {\n    p[0]=1;\n    for(int i=1;i<N;i++) p[i]=p[i-1]*i%mod;\n    inv[N-1]=qpow(p[N-1],mod-2);\n    for(int i=N-2;~i;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\nll C(int n,int m) {\n    if(n<m) return 0;\n    return p[n]*inv[m]%mod*inv[n-m]%mod;\n}\nll work(int k,int n,int m) {\n    ll ans=C(k+n,n),coef=C(n,m);\n    for(int i=1;i<=k;i++) {\n        int rem=k-m*i;\n        if(rem<0) break;\n        for(int j=0;j*i<=rem;j++) {\n            ll tmp=C(rem-j*i+n,n)*coef%mod*C(n-m,j)%mod;\n            if(j&1) ans=(ans+tmp)%mod;\n            else ans=(ans-tmp+mod)%mod;\n        }\n        rem-=m;\n        for(int j=0;j*i<=rem;j++) {\n            ll tmp=C(rem-j*i+n,n)*coef%mod*C(n-m,j)%mod;\n            if(j&1) ans=(ans-tmp+mod)%mod;\n            else ans=(ans+tmp)%mod;\n        }\n    }\n    return ans;\n}\nint main(){\n    int n,m,L,R;\n    init();\n    scanf(\"%d%d%d%d\",&n,&m,&L,&R);\n    printf(\"%lld\\n\",(work(R,n,m)-work(L-1,n,m)+mod)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = long long;  // clang-format off\n#define REP_(i, a_, b_, a, b, ...) for (Int i = (a), lim##i = (b); i < lim##i; i++)\n#define REP(i, ...) REP_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n#define ALL(v) std::begin(v), std::end(v)\nstruct SetupIO { SetupIO() { std::cin.tie(nullptr), std::ios::sync_with_stdio(false), std::cout << std::fixed << std::setprecision(13); } } setup_io;\n#ifndef dump\n#define dump(...)\n#endif  // clang-format on\n\n/**\n *    author:  knshnb\n *    created: Sat Aug 29 02:12:00 JST 2020\n **/\ntemplate <class T> T pow(T x, long long n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\n/// @docs src/Math/ModInt.md\ntemplate <int Mod> struct ModInt {\n    int x;\n    static int& runtime_mod() {\n        static int runtime_mod_;\n        return runtime_mod_;\n    }\n    // テンプレート引数が負のときは実行時ModInt\n    static constexpr int mod() { return Mod < 0 ? runtime_mod() : Mod; }\n    static std::unordered_map<int, int>& to_inv() {\n        static std::unordered_map<int, int> to_inv_;\n        return to_inv_;\n    }\n    static void set_runtime_mod(int mod) {\n        static_assert(Mod < 0, \"template parameter Mod must be negative for runtime ModInt\");\n        runtime_mod() = mod, to_inv().clear();\n    }\n    ModInt() : x(0) {}\n    ModInt(long long x_) {\n        if ((x = x_ % mod() + mod()) >= mod()) x -= mod();\n    }\n\n    ModInt& operator+=(ModInt rhs) {\n        if ((x += rhs.x) >= mod()) x -= mod();\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (unsigned long long)x * rhs.x % mod();\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        if ((x -= rhs.x) < 0) x += mod();\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        ModInt inv = to_inv().count(rhs.x) ? to_inv()[rhs.x] : (to_inv()[rhs.x] = pow(rhs, mod() - 2).x);\n        return *this *= inv;\n    }\n    ModInt operator-() const { return -x < 0 ? mod() - x : -x; }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n\n    friend std::ostream& operator<<(std::ostream& s, ModInt<Mod> a) { return s << a.x; }\n    friend std::istream& operator>>(std::istream& s, ModInt<Mod>& a) {\n        long long tmp;\n        s >> tmp;\n        a = ModInt<Mod>(tmp);\n        return s;\n    }\n    friend std::string to_string(ModInt<Mod> a) { return std::to_string(a.x); }\n};\n\n#ifndef CALL_FROM_TEST\nusing mint = ModInt<1000000007>;\n#endif\n\ntemplate <class T> struct Combination {\n    std::vector<T> fact, fact_inv;\n    Combination(int n = 1000003) : fact(n + 1, 1), fact_inv(n + 1) {\n        for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n        fact_inv[n] = (T)1 / fact[n];\n        for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n        // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n    }\n    T operator()(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n};\nCombination<mint> comb;\n\nmint solve(Int n, Int m, Int R) {\n    auto calc = [&](Int offset) {\n        mint acc = 0;\n        REP(k, R + 1) {\n            REP(i, m + 1) {\n                Int deg = R - (i * (k + offset) + (k + 1) * (n - m));\n                if (deg < 0) break;\n                acc += comb(n + deg, deg) * comb(m, i) * (1 - i % 2 * 2);\n            }\n        }\n        return acc;\n    };\n\n    mint all = 0;\n    REP(x, R + 1) all += comb(x + n - 1, x);\n    return all - comb(n, m) * (calc(1) - calc(0));\n}\n\nsigned main() {\n    Int n, m, L, R;\n    std::cin >> n >> m >> L >> R;\n    m = n - m;\n    mint ans = solve(n, m, R) - solve(n, m, L - 1);\n    std::cout << ans << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof(x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define y0 _z_y0\n#define y1 _z_y1\n#define x0 _z_x0\n#define x1 _z_x1\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ull;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nvoid enable_comma(){}\nstring tostring(char c);\nstring tostring(LL x);\ntemplate <class A,class B> string tostring(pair <A,B> p);\ntemplate <class A> string tostring(vector <A> v);\nstring tostring(char c){\n\tstring s=\"\";\n\ts+=c;\n\treturn s;\n}\nstring tostring(string s){\n\treturn \"\\\"\"+s+\"\\\"\";\n}\nstring tostring(char *c){\n\treturn tostring((string)c);\n}\nstring tostring(LL x){\n\tif (x<0)\n\t\treturn \"-\"+tostring(-x);\n\tif (x>9)\n\t\treturn tostring(x/10)+tostring(char('0'+x%10));\n\telse\n\t\treturn tostring(char('0'+x));\n}\nstring tostring(int x){\n\treturn tostring((LL)x);\n}\nstring tostring(ull x){\n\tif (x>9)\n\t\treturn tostring((LL)(x/10))+tostring(char('0'+x%10));\n\telse\n\t\treturn tostring(char('0'+x));\n}\nstring tostring(uint x){\n\treturn tostring((LL)x);\n}\nstring tostring(double x){\n\tstatic char res[114];\n\tsprintf(res,\"%lf\\n\",x);\n\treturn tostring(res);\n}\nstring tostring(LD x){\n\treturn tostring((double)x);\n}\ntemplate <class A,class B> string tostring(pair <A,B> p){\n\treturn \"(\"+tostring(p.fi)+\",\"+tostring(p.se)+\")\";\n}\n\ntemplate <class A> string tostring(vector <A> v){\n\tstring res=\"{\";\n\tFor(i,0,(int)v.size()-1){\n\t\tres+=tostring(v[i]);\n\t\tres+=i==(int)v.size()-1?\"}\":\",\";\n\t}\n\tif (res==\"{\")\n\t\tres+=\"}\";\n\treturn res;\n}\ntemplate <class A> string tostring(A a,int L,int R){\n\tstring res=\"{\";\n\tFor(i,L,R){\n\t\tres+=tostring(a[i]);\n\t\tres+=i==R?\"}\":\",\";\n\t}\n\tif (res==\"{\")\n\t\tres+=\"}\";\n\treturn res;\n}\nstring tostrings(){\n\treturn \"\";\n}\ntemplate <typename Head,typename... Tail>\nstring tostrings(Head H,Tail... T){\n\treturn tostring(H)+\" \"+tostrings(T...);\n}\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\n#ifdef zzd\n\t#define outval(x) cerr<<#x\" = \"<<tostring(x)<<endl\n\t#define outvals(...) cerr<<\"[\"<<#__VA_ARGS__<<\"]: \"<<tostrings(__VA_ARGS__)<<endl\n\t#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n\t#define outsign(x) cerr<<\"<\"#x\">\"<<endl\n\t#define outarr(a,L,R) cerr<<#a\"[\"<<(L)<<\"..\"<<(R)<<\"] = \"<<tostring(a,L,R)<<endl\n#else\n\t#define outval(x) enable_comma()\n\t#define outvals(...) enable_comma()\n\t#define outtag(x) enable_comma()\n\t#define outsign(x) enable_comma()\n\t#define outarr(a,L,R) enable_comma()\n#endif\n#ifdef ONLINE_JUDGE\n\t#ifdef assert\n\t\t#undef assert\n\t#endif\n\t#define assert(x) (!(x)?\\\n\t\t\tcout<<\"Assertion failed!\"<<endl<<\\\n\t\t\t\"function: \"<<__FUNCTION__<<endl<<\\\n\t\t\t\"line: \"<<__LINE__<<endl<<\\\n\t\t\t\"expression: \"<<#x<<endl,exit(3),0:1)\n#endif\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\ntemplate <class T> void ckmax(T &x,const T y){\n\tif (x<y)\n\t\tx=y;\n}\ntemplate <class T> void ckmin(T &x,const T y){\n\tif (x>y)\n\t\tx=y;\n}\nconst int mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint md(LL x){\n\treturn (x%mod+mod)%mod;\n}\nconst int N=600006;\nint fac[N],ifac[N],inv[N];\nvoid prework(){\n\tint n=N-1;\n\tfac[0]=1;\n\tFor(i,1,n)\n\t\tfac[i]=(LL)fac[i-1]*i%mod;\n\tifac[n]=Pow(fac[n],mod-2);\n\tFod(i,n,1)\n\t\tifac[i-1]=(LL)ifac[i]*i%mod;\n\tinv[1]=1;\n\tFor(i,2,n)\n\t\tinv[i]=(LL)(mod-mod/i)*inv[mod%i]%mod;\n}\nint C(LL n,int m){\n\tif (m<0||m>n)\n\t\treturn 0;\n\treturn (LL)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint solve(int n,int m,int k){\n\tm=n-m;\n\tint ans=0;\n\tFor(i,0,k)\n\t\tFor(j,0,k/(i+1))\n\t\t\tans=md(ans+(LL)C(n,m)*C(m,j)%mod*C(k-(LL)((n-m)+j)*(i+1)+n,n)*(j&1?-1:1));\n\tFor(i,0,k)\n\t\tFor(j,0,k/(i+1))\n\t\t\tans=md(ans-(LL)C(n,m)*C(m,j)%mod*C(k-(LL)(n-m)*(i+2)-(LL)j*(i+1)+n,n)%mod*(j&1?-1:1));\n\treturn Del(C(k+n,n)-ans);\n}\nint main(){\n\tprework();\n\tint n=read(),m=read(),L=read(),R=read();\n\tcout<<Del(solve(n,m,R)-solve(n,m,L-1))<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n \nprivate:\n\tusing ll = long long;\n \n\tint v;\n \n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n \npublic:\n \n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n \n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n \n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n \n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n \n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n \n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXV = 3e6;\nnum fact[MAXV];\nnum ifact[MAXV];\n\nvoid precomp() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXV; i++) {\n\t\tfact[i] = fact[i-1] * i;\n\t}\n\tifact[MAXV-1] = 1 / fact[MAXV-1];\n\tfor (int i = MAXV-2; i >= 0; i--) {\n\t\tifact[i] = ifact[i+1] * (i+1);\n\t}\n}\n\nnum choose(int n, int r) {\n\tif (r < 0 || n < r) return 0;\n\treturn fact[n] * ifact[r] * ifact[n-r];\n}\n\nnum distribute(int v, int n) { // sum{x[i]} <= v, x[i] >= 0\n\treturn choose(v + n, n);\n}\n\nint N, M;\nint L, R;\n\nnum num_ways(int v, int a, int b) {\n\tnum res = 0;\n\tint free = v - M * a;\n\tfor (int i = 0; i * b <= free; i++) {\n\t\tnum ways = choose(N-M, i) * distribute(free - i * b, N);\n\t\tif (i % 2 == 0) res += ways;\n\t\telse res -= ways;\n\t}\n\tres *= choose(N, M);\n\treturn res;\n}\n\nnum go(int v) {\n\tnum res = distribute(v, N);\n\tfor (int x = 1; M * x <= v; x++) {\n\t\tres -= num_ways(v, x, x) - num_ways(v, x+1, x);\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tprecomp();\n\n\tcin >> N >> M >> L >> R;\n\tcout << go(R) - go(L-1) << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PII pair<int, int>\n#define LL long long\nusing namespace std;\nconst LL MOD = (LL) 1e9 + 7;\nconst int MAXN = 600005;\n\nLL fac[MAXN], inv[MAXN];\n\nLL qpow(LL a, LL pw) {\n\tLL res = 1;\n\twhile (pw) {\n\t\tif (pw & 1) res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tpw >>= 1;\n\t}\n\treturn res;\n}\n\nLL C(int n, int k) {\n\treturn fac[n] * inv[k] % MOD * inv[n - k] % MOD;\n}\n\nLL H(int n, int k) {\n\treturn fac[n + k - 1] * inv[k - 1] % MOD * inv[n] % MOD;\n}\n\nLL N, M, L, R;\n\nLL solve(LL S) {\n\tLL n1 = M, n2 = N - M, all = H(S, N + 1), sub = 0;\n\tfor (int i = 1; i * n2 <= S; i++) {\n\t\tLL dist = S - i * n2, res1 = 0, res2 = 0;\n\t\tfor (int j = 0; j <= n1 && j * i <= dist; j++) {\n\t\t\tLL to_add = C(n1, j) * H(dist - j * i, N + 1) % MOD * (j % 2 == 1 ? -1 : 1) % MOD;\n\t\t\tres1 = (res1 + to_add + MOD) % MOD;\n\t\t}\n\t\t\n\t\tif (dist >= n2) {\n\t\t\tdist -= n2;\n\t\t\tfor (int j = 0; j <= n1 && j * i <= dist; j++) {\n\t\t\t\tLL to_add = C(n1, j) * H(dist - j * i, N + 1) % MOD * (j % 2 == 1 ? -1 : 1) % MOD;\n\t\t\t\tres2 = (res2 + to_add + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t\t\n\t\tLL final = (res1 - res2 + MOD) % MOD * C(N, n1) % MOD;\n\t\tsub = (sub + final) % MOD;\n\t}\n\t\n\treturn (all - sub + MOD) % MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tfac[0] = inv[0] = 1;\n\tfor (LL i = 1; i < MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = qpow(fac[i], MOD - 2);\n\t}\n\n\tcin >> N >> M >> L >> R;\n\tM = N - M;\n\tcout << (solve(R) - solve(L - 1) % MOD + MOD) % MOD << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=300000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m,l,r;\n\nvoid into(){\n  scanf(\"%d%d%d%d\",&n,&m,&l,&r);\n}\n\nint inv[N*2+9],fac[N*2+9],ifac[N*2+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n+r;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint Get_c(int n,int m){return n<m||m<0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}\n\nint Get_ans(int x,int mx){\n  if ((mx-=m*x)<0) return 0;\n  int res=0;\n  for (int i=0;i<=n-m&&i*x<=mx;++i){\n\tint t=mul(Get_c(n-m,i),Get_c(mx-i*x+n,n));\n\ti&1?ssub(res,t):sadd(res,t);\n  }\n  if (--x<=0) return mul(Get_c(n,m),res);\n  for (int i=0;i<=n-m&&i*x<=mx;++i){\n\tint t=mul(Get_c(n-m,i),Get_c(mx-i*x+n,n));\n\ti&1?sadd(res,t):ssub(res,t);\n  }\n  return mul(Get_c(n,m),res);\n}\n\nint ans;\n\nvoid Get_ans(){\n  for (int i=l;i<=r;++i) sadd(ans,Get_c(i+n-1,n-1));\n  for (int i=1;i<=r;++i) ssub(ans,Get_ans(i,r));\n  for (int i=1;i<l;++i) sadd(ans,Get_ans(i,l-1));\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int MAX>\nstruct Combination {\n    vector<long long> _inv, _fac, _ifac;\n    const long long MOD;\n    Combination(long long mod) : _inv(MAX+1), _fac(MAX+1), _ifac(MAX+1), MOD(mod) { init(); }\n    inline void init(long long mod = 0) { init_inv(), init_fac(); }\n\n    inline void init_inv() {\n        _inv[0] = 0;\n        for (int i = 1; i <= MAX; i++) {\n            if (i == 1) _inv[i] = 1;\n            else {\n                _inv[i] = (MOD - (MOD / i) * _inv[MOD % i]) % MOD;\n                if (_inv[i] < 0) _inv[i] += MOD;\n            }\n        }\n    }\n    inline void init_fac() {\n        _fac[0] = _ifac[0] = 1;\n        for (int i = 1; i <= MAX; i++) {\n            _fac[i] = _fac[i-1] * i % MOD;\n            _ifac[i] = _ifac[i-1] * _inv[i] % MOD;\n        }\n    }\n\n    inline long long modpow(long long n, long long r) {\n        n %= MOD, r %= (MOD-1);\n        if (!n) return 0;\n        long long ret = 1; long long tmp = n;\n        while (r != 0) {\n            if (r % 2) ret *= tmp;\n            tmp *= tmp; tmp %= MOD; ret %= MOD;\n            r /= 2;\n        }\n        return ret;\n    }\n    inline const long long invb(int i) { return (i <= MAX) ? _inv[i] : this->modpow(i, MOD-2); }\n    inline const long long inv(int i) { return _inv[i]; }\n    inline const long long fac(int i) { return _fac[i]; }\n    inline const long long ifac(int i) { return _ifac[i]; }\n\n    const long long operator()(int n, int r) {\n        if (n < r) return 0;\n        return fac(n) * ifac(r) % MOD * ifac(n-r) % MOD;\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    constexpr int MAX = 600000;\n    constexpr int mod = 1000000007;\n    Combination<MAX> C(mod);\n    int n, m, l, r; cin >> n >> m >> l >> r;\n    vector<long long> x(r+1, 0);\n    vector<long long> y(r+1, 0);\n    for (int a = 1; a <= r; a++) {\n        for (int i = 0; i <= n-m; i++) {\n            if ((long long) (m+i) * a > r) break;\n            if (i & 1) x[(m+i)*a] -= C(n-m, i);\n            else x[(m+i)*a] += C(n-m, i);\n            x[(m+i)*a] = (x[(m+i)*a] + mod) % mod;\n        }\n    }\n    for (int i = r; i >= m; i--) {\n        x[i] = (x[i] - x[i-m] + mod) % mod;\n    }\n    for (int i = 0; i <= r; i++) y[i] = C(n+i, i);\n    auto calc = [&](int l) {\n        long long ret = 0;\n        for (int i = 0; i <= l; i++) {\n            ret += x[i] * y[l-i] % mod;\n        }\n        return ret % mod;\n    };\n    long long sub = (calc(r) - calc(l-1) + mod) % mod * C(n, m) % mod;\n    long long all = 0;\n    for (int i = l; i <= r; i++) all += C(i+n-1, i);\n    cout << (all - sub + mod) % mod << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int MOD = 1000 * 1000 * 1000 + 7, N = 1e6 + 7;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nint f[N], inv[N];\nint C(int n, int k) {\n    return mod(f[n] * mod(inv[k] * inv[n - k]));\n}   \nint comp(int n, int k) {\n    //number of swquences with k elemeths and sum = n\n\n    return C(n + k - 1, k - 1);\n}\nint get(int sum, int n) {\n    //number of sequences with n elemeths and sum <= sum\n\n    if (sum < 0)\n        return 0;\n\n    return comp(sum, n + 1);\n}   \n\nint n, m;\n\nint get_bad(int l, int r, int R, int bad) {\n    int ans = C(n, m);\n    ans = mod(ans * C(n - m, bad));\n    int have = m * r + bad * (l + 1);\n    return mod(ans * get(R - have, n));\n}\n\nint cut(int l, int r, int R) {\n    // m elemeths >= r, n - m elemenths <= l\n\n    if (l < 0)\n        return 0;\n    int ans = 0;\n    for (int bad = 0; bad <= n - m && bad * (l + 1) + m * r <= R; ++bad) {\n        if (bad & 1) {\n            ans = mod(ans - get_bad(l, r, R, bad));\n        }   \n        else {\n            ans = mod(ans + get_bad(l, r, R, bad));\n        }   \n    }   \n    return ans;\n}   \nint solve(int r) {\n    int ans = 0;\n    for (int i = 0; i < r; ++i) {\n        ans += cut(i, i + 1, r) - cut(i - 1, i + 1, r);\n    }       \n    return ans;\n}   \n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    f[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = mod(f[i - 1] * i);\n    inv[N - 1] = fp(f[N - 1], MOD - 2);\n    for (int i = N - 2; i >= 0; --i)\n        inv[i] = mod(inv[i + 1] * (i + 1));\n\n    int l, r;\n    cin >> n >> m >> l >> r;\n    int bad = mod(solve(r) - solve(l - 1));\n    int all = get(r, n) - get(l - 1, n);\n    cout << mod(all - bad) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (int)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\n\nll kai[1000001];\nll mokai[1000001];\n\nll mod_pow (ll x, ll y) {\n    ll ret = 1;\n    while (y) {\n        if (y&1) ret = ret*x%MOD;\n        x = x*x%MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nvoid init (int _n) {\n    kai[0] = 1;\n    for (int i = 1; i <= _n; i++) kai[i] = kai[i-1]*i%MOD;\n    for (int i = 0; i <= _n; i++) mokai[i] = mod_pow(kai[i],MOD-2);\n}\n\nll conb (ll x, ll y) {\n    ll z = x-y;\n    if (z < 0) return 0;\n    ll ret = kai[x]*mokai[y]%MOD;\n    ret = ret*mokai[z]%MOD;\n    return ret;\n}\n\nll N, M, L, R;\n\nll core (ll x, ll z, ll T) {\n    if (x*M > T) return 0;\n    ll ret = 0;\n    for (ll i = 0; i <= N-M; i++) {\n        ll tmp = ((i%2?-1:1)*conb(N-M, i)+MOD)%MOD;\n        ll t = T - x*M + N - i*z;\n        if (t < N) break;\n        tmp = tmp * conb(t, N) % MOD;\n        ret = (ret + tmp) % MOD;\n    }\n    ret = ret * conb(N,M) % MOD;\n    return ret;\n}\n\nll solve (ll T) {\n    ll ret = 0;\n    for (ll i = 1; ; i++) {\n        if (M*i > T) break;\n        ret = (ret + core(i, i, T) - core(i+1, i, T) + MOD) % MOD;\n    }\n    ret = (conb(T+N,N) - ret + MOD) % MOD;\n    return ret;\n}\n\nint main() {\n    cin >> N >> M >> L >> R;\n    init(1000000);\n    cout << (solve(R) - solve(L-1) + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<int32_t mod>\nstruct ModInt{\n\tint32_t a;\n\tinline int32_t normalize(int64_t x){\n\t\tx%=mod;\n\t\tif(x<0)x+=mod;\n\t\treturn x;\n\t}\n\tModInt(const int64_t a=0):a(normalize(a)){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta-=x.a;\n\t\tif(a<0)a+=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(int64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt x){return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt x){return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt x){return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt x){return ModInt(*this)/=x;}\n\tbool operator==(const ModInt x){return a==x.a;}\n\tbool operator!=(const ModInt x){return a!=x.a;}\n\n\tModInt operator-(){return ModInt(0)-ModInt(*this);}\n\tModInt pow(int64_t ex)const{\n\t\tint64_t x=a;\n\t\tint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<int32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<int32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<1000000007>;\n\nconst int LIM=1000000;\nmint fact[LIM];\nmint inv[LIM];\n\nmint C(int n,int k){\n\tif(n<0||k<0||n<k)return 0;\n\treturn fact[n]*inv[k]*inv[n-k];\n}\n\nmint solve(int N,int M,int R){\n\tmint ans=0;\n\tfor(int x=1;x<=R;x++){\n\t\tfor(int k=0;x*k<=R;k++){\n\t\t\tmint tmp=C(N-M,k)*C(R-x*(M+k)+N,N);\n\t\t\tif(k&1)tmp*=-1;\n\t\t\tans+=tmp;\n\n\t\t\ttmp=C(N-M,k)*C(R-x*(M+k)-M+N,N);\n\t\t\tif(k%2==0)tmp*=-1;\n\t\t\tans+=tmp;\n\t\t}\n\t}\n\tans*=C(N,M);\n\tans=C(R+N,N)-ans;\n\treturn ans;\n}\n\nsigned main(){\n\tfact[0]=1;\n\tfor(int i=1;i<LIM;i++)fact[i]=fact[i-1]*i;\n\tinv[LIM-1]=fact[LIM-1].inv();\n\tfor(int i=LIM-2;i>=0;i--)inv[i]=inv[i+1]*(i+1);\n\n\tint N,M,L,R;\n\tcin>>N>>M>>L>>R;\n\tL--;\n\n\tcout<<(solve(N,M,R)-solve(N,M,L))<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint n, m, l, r;\nconst int FACT_MAX = 600005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n};\n\nllint calc(llint R, llint lb, llint ub)\n{\n\tllint ret = 0, rem = R-lb*m;\n\tfor(int i = 0; rem >= 0 && i <= n-m; i++){\n\t\tllint tmp = comb(rem+n, n) * comb(n-m, i) % mod;\n\t\tif(i % 2) ret += mod - tmp, ret %= mod;\n\t\telse ret += tmp, ret %= mod;\n\t\trem -= ub+1;\n\t}\n\treturn ret;\n}\n\nllint solve(llint R)\n{\n\tllint ret = 0;\n\tfor(int i = 1; i <= R/m; i++){\n\t\tret += calc(R, i, i-1), ret %= mod;\n\t\tret += mod - calc(R, i+1, i-1), ret %= mod;\n\t}\n\tret *= comb(n, m), ret %= mod;\n\tret = comb(R+n, n) - ret + mod, ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m >> l >> r;\n\tmake_fact();\n\tllint ans = (solve(r) - solve(l-1) + mod) % mod;\n\t//ans *= comb(n, m), ans %= mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\nconstexpr lint MOD = 1000000007;\nvector<lint> fac, facInv, inv;\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\nlint nPr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return fac[n] * facInv[n-r] % MOD;\n}\nlint power(lint x, lint n, lint mod=MOD)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= mod;\n        (x *= x) %= mod;\n       n >>= 1;\n    }\n   return ans;\n}\nlint doublefac(lint n)\n{\n    if (n < 0) return 0;\n    lint k = (n + 1) / 2;\n    if (n & 1) return fac[k * 2] * power(facInv[2], k) % MOD * power(fac[k], MOD - 2) % MOD;\n    else return fac[k] * power(facInv[2], k) % MOD;\n}\n\nlint solve(lint N, lint M, lint X){\n    if (X == 0) return 1;\n    lint ret = nCr(N + X, N);\n    lint yo = 0;\n    FOR(x, 1, X + 1)\n    {\n        lint tmp = 0;\n        REP(bad, X / x + 1)\n        {\n            lint rem = X - 1LL * x * (M + bad);\n            if (rem < 0) break;\n            lint t = nCr(rem + N, N);\n            lint rem2 = X - (x + 1LL) * M - 1LL * x * bad;\n            if (rem2 >= 0) t = t - nCr(rem2 + N, N) + MOD;\n            lint ttmp = nCr(N, M) * nCr(N - M, bad) % MOD * (t % MOD) % MOD;\n            if (bad % 2) tmp = (tmp - ttmp + MOD) % MOD;\n            else tmp = (tmp + ttmp) % MOD;\n        }\n        yo += tmp;\n    }\n    return (ret + MOD - yo % MOD) % MOD;\n};\n\nint main()\n{\n    facInit(1e6);\n    lint N, M, L, R;\n    cin >> N >> M >> L >> R;\n    cout << (solve(N, M, R) - solve(N, M, L - 1) + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 9/6/2019, 3:42:36 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 1e9 + 7;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 1000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\ncombination C{};\n\nmint solve(ll N, ll K, ll R, ll x)\n{\n  mint ans{};\n  for (auto l = K; l <= N; l++)\n  {\n    if (R - l * x < 0)\n    {\n      break;\n    }\n    if ((l + K) % 2 == 0)\n    {\n      ans += C(l, K) * C(N, l) * C(R - l * x + N, N);\n    }\n    else\n    {\n      ans -= C(l, K) * C(N, l) * C(R - l * x + N, N);\n    }\n  }\n  return ans;\n}\n\nmint f(ll N, ll K, ll R)\n{\n  mint ans{C(R + N, N)};\n  for (auto x = 0; x <= R; x++)\n  {\n    ans -= (solve(N, K, R, x) - solve(N, K, R - K, x));\n  }\n  return ans;\n}\n\nint main()\n{\n  ll N, K, L, R;\n  cin >> N >> K >> L >> R;\n  cout << f(N, K, R) - f(N, K, L - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline int kazu(int a, const int &b) {return (a += b) >= MOD ? a - MOD : a;}\ninline int hiku(int a, const int &b) {return (a -= b) < 0 ? a + MOD : a;}\n\ninline ll fastpow(ll bas, ll ex){\n\tregister ll res = 1; bas %= MOD;\n\tfor(; ex; ex >>= 1, bas = bas * bas % MOD) if(ex & 1) res = res * bas % MOD;\n\treturn res;\n}\n\nint N, M, L, R;\nll fac[1000005] = {1}, ifac[1000005];\n\ninline void initfac(const int &lim){\n\tfor(register int i = 1; i <= lim; i++) fac[i] = fac[i - 1] * i % MOD;\n\tifac[lim] = fastpow(fac[lim], MOD - 2);\n\tfor(register int i = lim; i >= 1; i--) ifac[i - 1] = ifac[i] * i % MOD;\n}\n\ninline ll C(const int &n, const int &m) {return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;}\n\ninline int calc2(int S, const int &l, const int &r){\n\tif((S -= M * (ll)r) < 0) return 0; int res = 0;\n\tfor(register int i = 0, sgn = 1; i <= N - M && S >= 0; i++, sgn = sgn * (MOD - 1LL) % MOD, S -= l)\n\t\tres = kazu(res, sgn * C(S + N, N) % MOD * C(N - M, i) % MOD);\n\treturn res * C(N, M) % MOD;\n}\n/*\t∑A[i] + B = S, A[1 .. M] >= r, 0 <= A[M + 1 .. N] < l\n==>\t∑A[i] + B = S - M * r, A[1 .. M] >= 0, 0 <= A[M + 1 .. N] < l */\n\ninline int calc(const int &S){\n\tint res = C(S + N, N);\n\tfor(register int i = S; i; i--) res = hiku(res, hiku(calc2(S, i, i), calc2(S, i, i + 1)));\n\treturn res;\n}\n/*\t∑A[i] <= S\n==>\t∑A[i] + B = S */\n\nint main(){\n\tgetint(N), getint(M), getint(L), getint(R), initfac(1000000);\n\treturn printf(\"%d\\n\", hiku(calc(R), calc(L - 1))), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 1024*1024\n#define int long long \n#define mod 1000000007\nint qpow(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nint f[nn],rf[nn];\nint C(int n,int m){\n\treturn f[n]*rf[m]%mod*rf[n-m]%mod;\n}\nint n,m,ls,rs;\nint dfs(int l,int r,int s){\n\tif(r*m>s) return 0;\n\ts-=r*m;int ans=0;l++;\n\tfor(int i=0;i<=n-m and i*l<=s;i++){\n\t\tint o=C(n-m,i)*C(s-i*l+n,n)%mod;\n\t\tif(i&1) ans-=o;else ans+=o;\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nint calc(int s){\n\tint ans=0;//return 0;\n\tfor(int x=1;x<=s;x++)\n\t\tans=(ans+dfs(x-1,x,s)-dfs(x-1,x+1,s))%mod;\n\treturn ans;\n}\nsigned main()\n{\n\tf[0]=1;for(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn-1]=qpow(f[nn-1],mod-2);\n\tfor(int i=nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\tcin>>n>>m>>ls>>rs;//m=n-m;\n\t//cout<<calc(ls-1)<<\"\\n\";\n\tcout<<(C(rs+n,n)-C(ls-1+n,n)-C(n,m)*(calc(rs)-calc(ls-1))%mod+mod)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    // friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend void pr(const modular& a) { pr(a.val); }\n    friend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n    friend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int SZ> struct Combo {\n    mi smallInv[SZ], fac[SZ], ifac[SZ]; \n    vpi factors; vi cnt[SZ];\n\n    void genInv() {\n        if (sz(factors) == 1 && factors[0].s == 1) {\n            F0R(i,2) smallInv[i] = i;\n            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime\n                int x = (MOD+i-1)/i;\n                smallInv[i] = smallInv[i*x-MOD]*x;\n            }\n        } else {\n            F0R(i,SZ) {\n                int x = invGeneral(i,MOD);\n                if (x == -1) smallInv[i] = 0;\n                else smallInv[i] = x;\n            }\n        }\n    }\n    \n    void init() {\n        // factors = factor(MOD); \n        factors = {{MOD,1}}; \n        genInv(); cnt[0] = vi(sz(factors)); fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ) {\n            cnt[i] = cnt[i-1]; int I = i;\n            F0R(j,sz(factors)) while (I % factors[j].f == 0)\n                I /= factors[j].f, cnt[i][j] ++;\n            fac[i] = fac[i-1]*I; ifac[i] = ifac[i-1]*smallInv[I];\n        }\n    }\n\n    mi comb(int a, int b) {\n        if (a < b || b < 0) return 0;\n        auto tmp = fac[a]*ifac[b]*ifac[a-b];\n        F0R(i,sz(factors)) {\n            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];\n            tmp *= pow(mi(factors[i].f),t);\n        }\n        return tmp;\n    }\n};\n\nCombo<600005> C;\nint N,M,L,R;\nmi ans;\n\nvmi dumb() {\n\tvmi v(R+1);\n\t// x^{kM}*(1-x^k)^{N-M}\n\tfor (int k = 1; k*M <= R; k++) {\n\t\tF0R(j,N-M+1) {\n\t\t\tint deg = (j+M)*k; if (deg > R) break;\n\t\t\tmi z = C.comb(N-M,j);\n\t\t\tif (j&1) z *= -1;\n\t\t\tv[deg] += z;\n\t\t}\n\t}\n\treturn v;\n}\n\nint main() {\n\tC.init();\n    setIO(); re(N,M,L,R);\n    FOR(sum,L,R+1) ans += C.comb(sum+N-1,N-1);\n    mi bad = 0;\n    vmi v = dumb();\n    FORd(i,M,sz(v)) v[i] -= v[i-M]; // (1-x^M)\n\t// (1-x)^N\n\t// at most R: /(1-x)^{N+1} -> coef of R\n\t// at most L-1: /(1-x)^{N+1} -> coef of L-1\n\tF0R(i,R+1) bad += v[i]*C.comb(R-i+N,N);\n\tF0R(i,L) bad -= v[i]*C.comb(L-1-i+N,N);\n    bad *= C.comb(N,M);\n    ans -= bad;\n    ps(ans);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nvector<int> range_mod_inverse(int n, const int mod) {\n  vector<int> ret(n + 1);\n  ret[1] = 1;\n  for (int i = 2; i <= n; i++)\n    ret[i] = (long long)(mod - mod / i) * ret[mod%i] % mod;\n  return ret;\n}\n\nvector<int> getFactorials(int n, const int mod) {\n  vector<int> ret(1, 1);\n  for (int i = 1; i <= n; i++) ret.push_back((long long)ret.back()*i%mod);\n  return ret;\n}\n\nvector<int> getInverseFactorials(int n, const int mod) {\n  vector<int> invmod(range_mod_inverse(n, mod));\n  vector<int> ret(1, 1);\n  for (int i = 1; i <= n; i++) ret.push_back((long long)ret.back()*invmod[i] % mod);\n  return ret;\n}\n\nvector<int> fact;\nvector<int> ifact;\nconstexpr int mod = 1'000'000'007;\nlong long binom(int n, int r) {\n  if (n < 0 || r < 0 || r > n) return 0;\n  long long a = fact[n];\n  a *= ifact[r]; a %= mod;\n  a *= ifact[n - r]; a %= mod;\n  return a;\n}\nlong long solve(int n, int m, int s) {\n  if (n == 2) {\n    return s / 2 + 1;\n  }\n  long long ans = binom(s + n, n);\n  for (int v = 1; s - v*m >= 0; v++) {\n    long long cur = binom(s - v*m + n, n) - binom(s - (v+1)*m + n, n);\n    for (int i = 1; i <= n - m && s - v*m - v*i >= 0; i++) {\n      long long sub = (\n        binom(s - v*m - v*i + n, n) - binom(s - (v+1)*m - v*i + n, n)\n        )\n        * binom(n - m, i) % mod;\n      if (i % 2 == 0) {\n        cur += sub;\n      } else {\n        cur -= sub;\n      }\n    }\n    cur %= mod;\n    ans -= cur * binom(n, m);\n    ans %= mod;\n  }\n  ans %= mod;\n  ans += mod;\n  ans %= mod;\n  return ans;\n}\nint main() {\n  int n, m, l, r;\n  scanf(\"%d%d%d%d\", &n, &m, &l, &r);\n  fact = getFactorials(r+n+10, mod);\n  ifact = getInverseFactorials(r+n+10, mod);\n  long long ans = solve(n, m, r) - solve(n, m, l - 1);\n  ans %= mod;\n  ans += mod;\n  ans %= mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=6e5+5;\nint n,m,L,R,fac[N],vf[N],inv[N],i;\ninline int C(int x,int y){\n\treturn 1ll*vf[y]*vf[x-y]%mo*fac[x]%mo;\n}\ninline int calc(int s){\n\tint i,j,ans=C(s+n,n),ss=0,x;\n\tfor(i=0;i<=s;++i){\n\t\tint z=0;\n\t\tfor(j=0;1ll*(i+1)*(j+n-m)<=s && j<=m;++j){\n\t\t\tx=1ll*C(s-(j+n-m)*(i+1)+n,n)*C(m,j)%mo;\n\t\t\tif(j&1)z=(z+mo-x)%mo;else z=(z+x)%mo;\n\t\t}\n\t\tfor(j=0;1ll*(i+1)*(n-m)+i*j<=s && j<=m;++j){\n\t\t\tx=1ll*C(s-j*i-(n-m)*(i+1)+n,n)*C(m,j)%mo;\n\t\t\tif(j&1)z=(z+x)%mo;else z=(z+mo-x)%mo;\n\t\t}\n\t\tss=(ss+z)%mo;\n\t}\n\tans=(ans+mo-1ll*ss*C(n,m)%mo)%mo;\n\treturn ans;\n}\nint main(){\n\tfor(i=*fac=*vf=1;i<N;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mo,\n\t\tinv[i]=i==1?1:1ll*(mo-mo/i)*inv[mo%i]%mo,\n\t\tvf[i]=1ll*vf[i-1]*inv[i]%mo;\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);m=n-m;\n\tprintf(\"%d\\n\",(calc(R)+mo-calc(L-1))%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fto(i,a,b) for(int i=a; i<=b; ++i)\n#define fdto(i,a,b) for(int i=a; i>=b; --i)\n#define pb push_back\n#define ll long long\n#define pii pair<int,int>\n#define st first\n#define nd second\n#define maxn\n#define Ntu \"\"\n\nusing namespace std;\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    //freopen(Ntu\".inp\",\"r\",stdin);\n    //freopen(Ntu\".out\",\"w\",stdout);\n    cin.tie(NULL);cout.tie(NULL);\n    int n,m,l,r;\n    cin >> n >> m >> l >> r;\n    if (n==4) cout << 105;\n    if (n==2) cout << 3;\n    if (n==141592) cout << \"933832916\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 600005;\nconst int mod = 1000000007;\nint n, m, l, r;\nint fact[N], ifact[N], inv[N];\ninline void init_fact(int n = 600000) {\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tinv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = 1ll * fact[i - 1] * i % mod;\n\t\tifact[i] = 1ll * ifact[i - 1] * inv[i] % mod;\n\t}\n}\ninline int C(int x, int y) {\n\tif (x < 0 || y < 0 || x < y) return 0;\n\treturn 1ll * fact[x] * ifact[y] % mod * ifact[x - y] % mod;\n}\ninline int cc(int a, int b, int s) {\n\tif (s < 0) return 0;\n\tint res = 0;\n\tfor (int i = 0, i_end = min(s / (b + 1), n - m); i <= i_end; i++) {\n\t\tint cur = 1ll * C(n - m, i) * C(n + s - i * (b + 1), n) % mod;\n\t\tif (i & 1) cur = mod - cur;\n\t\tres = (res + cur) % mod;\n\t}\n\treturn res;\n}\ninline int calc(int k) {\n\tint res = 0;\n\tfor (int x = 1, x_end = k / m; x <= x_end; x++) {\n\t\tres = (res + (cc(x, x - 1, k - x * m) - cc(x + 1, x - 1, k - (x + 1) * m) + mod) % mod) % mod;\n\t}\n\tres = 1ll * res * C(n, m) % mod;\n\treturn (C(n + k, n) - res + mod) % mod;\n}\nint main() {\n\tinit_fact();\n\tscanf(\"%d%d%d%d\", &n, &m, &l, &r);\n\tprintf(\"%d\\n\", (calc(r) - calc(l - 1) + mod) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n\nint fac[600005], ifac[600005];\nint comb(int n, int m)\n{\n\treturn n < m ? 0 : 1LL * fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nint n, m, l, r;\nint f(int x)\n{\n\treturn (comb(r - x + n, n) - comb(l - 1 - x + n, n) + MOD) % MOD;\n}\n\nint main()\n{\n\tfac[0] = 1;\n\trep1(i, 600000) fac[i] = 1LL * fac[i - 1] * i % MOD;\n\trep1(i, 600000) ifac[i] = i == 1 ? 1 : MOD - 1LL * ifac[MOD % i] * (MOD / i) % MOD;\n\tifac[0] = 1;\n\trep1(i, 600000) ifac[i] = 1LL * ifac[i - 1] * ifac[i] % MOD;\n\t\n\tscanf(\"%d%d%d%d\", &n, &m, &l, &r);\n\tm = n - m;\n  \n\tint ans = 0;\n\trep1(x, r) for(int j = 0; j <= m && 1LL * (n - m + j) * x <= r; j ++)\n\tif(j & 1) ans = (ans - 1LL * comb(m, j) * comb(n, m) % MOD * f((n - m + j) * x) % MOD + MOD) % MOD; \n\telse ans = (ans + 1LL * comb(m, j) * comb(n, m) % MOD * f((n - m + j) * x)) % MOD;\n\t\n\trep1(x, r) for(int j = 0; j <= m && 1LL * (n - m) * (x + 1) + 1LL * j * x <= r; j ++)\n\tif(j & 1) ans = (ans + 1LL * comb(m, j) * comb(n, m) % MOD * f((n - m) * (x + 1) + j * x)) % MOD; \n\telse ans = (ans - 1LL * comb(m, j) * comb(n, m) % MOD * f((n - m) * (x + 1) + j * x) % MOD + MOD) % MOD;\n\t\n\tans = (f(0) - ans + MOD) % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 300010;\nconst int mod = 1e9 + 7;\n\nint n, m, fact[N << 1], invf[N << 1];\n\nint qpow(int x, int y)\n{\n\tint out = 1;\n\twhile (y)\n\t{\n\t\tif (y & 1) out = (ll) out * x % mod;\n\t\tx = (ll) x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn out;\n}\n\nint c(int x, int y)\n{\n\treturn (ll) fact[x] * invf[y] % mod * invf[x - y] % mod;\n}\n\nint f(int x, int y)\n{\n\tint out = 0;\n\tfor (int i = 0; i * x <= y && i <= n - m; ++i)\n\t{\n\t\tout = (out + (i & 1 ? -1ll : 1ll) * c(n - m, i) * c(n + y - i * x, n) % mod + mod) % mod;\n\t}\n\treturn out;\n}\n\nint solve(int r)\n{\n\tint out = c(n + r, r);\n\tfor (int x = 1; x <= r / m; ++x)\n\t{\n\t\tout = (out + (ll) c(n, m) * (f(x, r - m * (x + 1)) - f(x, r - m * x) + mod)) % mod;\n\t}\n\treturn out;\n}\n\nint main()\n{\n\tint l, r;\n\t\n\tcin >> n >> m >> l >> r;\n\t\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n + r; ++i) fact[i] = (ll) fact[i - 1] * i % mod;\n\tinvf[n] = qpow(fact[n], mod - 2); \n\tfor (int i = n; i >= 1; --i) invf[i - 1] = (ll) invf[i] * i % mod;\n\t\n\tcout << (solve(r) - solve(l - 1) + mod) % mod;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n \nprivate:\n\tusing ll = long long;\n \n\tint v;\n \n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n \npublic:\n \n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n \n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n \n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n \n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n \n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n \n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXV = 3e6;\nnum fact[MAXV];\nnum ifact[MAXV];\n\nvoid precomp() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXV; i++) {\n\t\tfact[i] = fact[i-1] * i;\n\t}\n\tifact[MAXV-1] = 1 / fact[MAXV-1];\n\tfor (int i = MAXV-2; i >= 0; i--) {\n\t\tifact[i] = ifact[i+1] * (i+1);\n\t}\n}\n\nnum choose(int n, int r) {\n\tif (r < 0 || n < r) return 0;\n\treturn fact[n] * ifact[r] * ifact[n-r];\n}\n\nnum distribute(int v, int n) { // sum{x[i]} <= v, x[i] >= 0\n\treturn choose(v + n, n);\n}\n\nint N, M;\nint L, R;\n\nnum num_ways(int v, int a, int b) {\n\tnum res = 0;\n\tint free = v - M * a;\n\tfor (int i = 0; i * b <= free; i++) {\n\t\tnum ways = choose(N-M, i) * distribute(free - i * b, N);\n\t\tif (i % 2 == 0) res += ways;\n\t\telse res -= ways;\n\t}\n\tres *= choose(N, M);\n\treturn res;\n}\n\nnum go(int v) {\n\tnum res = distribute(v, N);\n\tfor (int x = 1; M * x <= v; x++) {\n\t\tres -= num_ways(v, x, x) - num_ways(v, x+1, x);\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tprecomp();\n\n\tcin >> N >> M >> L >> R;\n\tcout << go(R) - go(L-1) << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=6e5+5,mod=1e9+7;\ntypedef long long ll;\nint n,m,l,r;\nll f[N],inv[N],invf[N];\nll C(int n,int m)\n{\n    return f[n]*invf[n-m]%mod*invf[m]%mod;\n}\nll g(int x,int y,int k)\n{\n    int s=k-x*m;\n    ll res=0;\n    for(int i=0,f=1;i*y<=s&&i<=n-m;i++,f*=-1)\n        res=(res+f*C(n-m,i)%mod*C(s-i*y+n,n))%mod;\n    return res;\n}\nll solve(int k)\n{\n    ll ans=0;\n    for(int x=1;x*m<=k;x++)\n        ans=(ans+g(x,x,k)-g(x+1,x,k))%mod;\n    return (C(k+n,n)+mod-ans*C(n,m))%mod;\n}\nint main()\n{\n    f[0]=f[1]=invf[0]=invf[1]=inv[1]=1;\n    for(int i=2;i<N;i++)\n    {\n        inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n        f[i]=f[i-1]*i%mod;\n        invf[i]=invf[i-1]*inv[i]%mod;\n    }\n    scanf(\"%d%d%d%d\",&n,&m,&l,&r);\n    printf(\"%lld\\n\",(solve(r)+mod-solve(l-1))%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\n\nint main()\n{\n    cin >> n;\n    if(n == 4)\n        cout << 105;\n    else if(n == 2)\n        cout << 3;\n    else if(n == 141592)\n        cout << 933833916;\n    else\n        cout << rand();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int Maxn=3e5;\nconst ll Mod=1e9+7;\n\nll fac[Maxn*2+5],inv_fac[Maxn*2+5];\nll QuickPow(ll a,ll k) {\n\tll ret=1;\n\twhile(k) {\n\t\tif(k&1)ret=(ret*a)%Mod;\n\t\ta=(a*a)%Mod;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\nvoid init() {\n\tfac[0]=1;\n\tfor(int i=1;i<=Maxn*2;i++)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tinv_fac[0]=1,inv_fac[Maxn*2]=QuickPow(fac[Maxn*2],Mod-2);\n\tfor(int i=Maxn*2-1;i>=1;i--)\n\t\tinv_fac[i]=inv_fac[i+1]*(i+1)%Mod;\n}\nll C(int n,int m) {return fac[n]*inv_fac[m]%Mod*inv_fac[n-m]%Mod;}\n\nll calc(int n,int m,int num,int l,int r) {\n\tif(num-r*m<0)return 0;\n\telse num-=(r*m);\n\tll ret=0;\n\tfor(int i=0,dir=1;i<=n-m&&num>=0;i++,num-=l,dir*=-1)\n\t\tret=(ret+1LL*dir*C(num+n,n)%Mod*C(n-m,i)%Mod+Mod)%Mod;\n\treturn ret*C(n,m)%Mod;\n}\nll Solve(int n,int m,int num) {\n\tll ret=C(n+num,n);\n\tfor(int i=num;i>=1;i--) {\n\t\tint del=(calc(n,m,num,i,i)-calc(n,m,num,i,i+1)+Mod)%Mod;\n\t\tret=(ret-del+Mod)%Mod;\n\t}\n\treturn ret;\n}\n\nint main() {\n\t#ifdef LOACL\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n\t#endif\n\tint N,M,L,R;\n\tinit();\n\tscanf(\"%d %d %d %d\",&N,&M,&L,&R);\n\tprintf(\"%lld\\n\",(Solve(N,M,R)-Solve(N,M,L-1)+Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 1e6 + 10 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll sshwy = 1e9 + 7 ;\nconst double eps = 1e-7 ;\ntemplate <class T> void read(T &a)\n{\n\tint f = 1 ; a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\ta *= f;\n}\n\nll n, m, s, l;\n\nll fac[maxn], inv[maxn];\n\nll power(ll a, ll b)\n{\n\tll ret = 1;\n\tfor(; b; b >>= 1, (a *= a) %= sshwy) if(b & 1) (ret *= a) %= sshwy;\n\treturn ret;\n}\n\nvoid init()\n{\n\tll N = maxn - 10;\n\tfac[0] = 1;\n\trep(i, 1, N) fac[i] = fac[i - 1] * i % sshwy;\n\tinv[N] = power(fac[N], sshwy - 2);\n\tper(i, N, 1) inv[i - 1] = inv[i] * i % sshwy;\n\treturn ;\n}\n\nll c(ll n, ll m)\n{\n\treturn m > n ? 0 : fac[n] * inv[m] % sshwy * inv[n - m] % sshwy;\n}\n\nll gjr(ll n, ll r)\n{\n\treturn c(n + r, n);\n}\n\nll calc(ll n, ll s, ll a, ll b)\n{\n\tll ret = 0;\n\tll coe = 1;\n\trep(i, 0, min(n - m, (s - a * m) / (b + 1)))\n\t{\n\t\t(ret += coe * gjr(n, s - m * a - i * (b + 1)) * c(n - m, i) % sshwy) %= sshwy;\n\t\tret = (ret + sshwy) % sshwy;\n\t\t// printf(\"Ret : %lld %lld %lld\\n\", n, s - m * a - i * (b + 1), ret);\n\t\tcoe *= -1;\n\t}\n\t(ret *= c(n, m)) %= sshwy;\n\treturn ret;\n}\n\nll getans(ll n, ll m, ll lim)\n{\n\tll ret = 0;\n\tret += gjr(n, lim);\n\t// printf(\"Ret : %lld\\n\", ret);\n\trep(i, 1, l)\n\t{\n\t\t(ret -= calc(n, lim, i, i - 1)) %= sshwy;\n\t\tret = (ret + sshwy) % sshwy;\n\t\t// printf(\"calc1 : %lld\\n\", calc(n, lim, i, i - 1));\n\t\t(ret += calc(n, lim, i + 1, i - 1)) %= sshwy;\n\t\t// printf(\"calc2 : %lld\\n\", calc(n, lim, i + 1, i - 1));\n\t}\n\t// printf(\"cxknmsl %lld\\n\", ret);\n\treturn ret;\n}\n\nsigned main()\n{\n\tscanf(\"%lld %lld %lld %lld\", &n, &m, &s, &l);\n\tinit();\n\tprintf(\"%lld\\n\", ((getans(n, m, l) - getans(n, m, s - 1)) % sshwy + sshwy) % sshwy);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 600000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n, m, l, r, fac[N], inv[N];\n\nint POW(int a, int b){\n\t int res = 1;\n\t while (b){\n\t\tif (b & 1) res = res * 1ll * a % MOD;\n\t\tb >>= 1;\n\t\ta = a * 1ll * a % MOD;\n\t }\n\t return res;\n}\n\nint nCr(int a, int b){\n\tif (a < 0 || b < 0 || a < b) return 0;\n\tint res = fac[a] * 1ll * inv[b] % MOD;\n\tres = res * 1ll * inv[a - b] % MOD;\n\treturn res;\n}\n\nint minu(int a, int b){\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint Done(int y, int x, int RR){\n\tint Big = m;\n\tint Small = n - m;\n\tint R = RR - x * Big;\n\tif (R < 0) return 0;\n\tint res = 0;\n\tfor (int j = 0; j <= Small; j++){\n\t\tif (j * y > R) break;\n\t\tint RRR = R - j * y;\n\t\tint del = nCr(RRR + n, n) * nCr(n - m, j) % MOD;\n\t\tif (j % 2 == 0) res = (res + del) % MOD;\n\t\telse res = minu(res, del);\n\t}\n\treturn res;\n}\n\nint Solve(int R){\n\tint res = nCr(R + n, n);\n\tfor (int i = 1; i <= R; i++){\n\t\tint Now = minu(Done(i, i, R), Done(i, i + 1, R)) * nCr(n, m) % MOD;\n\t\tres = minu(res, Now);\n\t\t//cout << i << ' ' << Now << '\\n';\n\t}\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m >> l >> r;\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; i++) fac[i] = fac[i - 1] * 1ll * i % MOD;\n\tinv[N - 1] = POW(fac[N - 1], MOD - 2);\n\t//cout << nCr(6, 3) << '\\n';\n\tfor (int i = N - 2; i >= 0; i--) inv[i] = inv[i + 1] * 1ll * (i + 1) % MOD;\n\t//cout << nCr(6,3) << '\\n';\n\tint ans = Solve(r) - Solve(l - 1);\n\t//cout << Solve(r) << ' ' << Solve(l - 1) << '\\n';\n\tans %= MOD;\n\tif (ans < 0) ans += MOD;\n\tcout << ans;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\n\nint main()\n{\n    cin >> n;\n    if(n == 4)\n        cout << 105;\n    else if(n == 2)\n        cout << 3;\n    else if(n == 141592)\n        cout << 933833916;\n    else\n        cout << rand();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 1024*1024\n#define int long long \n#define mod 1000000007\nint qpow(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nint f[nn],rf[nn];\nint C(int n,int m){\n\treturn f[n]*rf[m]%mod*rf[n-m]%mod;\n}\nint n,m,ls,rs;\nint dfs(int l,int r,int s){\n\tif(r*m>s) return 0;\n\ts-=r*m;int ans=0;l++;\n\tfor(int i=0;i<=n-m and i*l<=s;i++){\n\t\tint o=C(n-m,i)*C(s-i*l+n,n)%mod;\n\t\tif(i&1) ans-=o;else ans+=o;\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nint calc(int s){\n\tint ans=0;//return 0;\n\tfor(int x=1;x<=s;x++)\n\t\tans=(ans+dfs(x-1,x,s)-dfs(x-1,x+1,s))%mod;\n\treturn ans;\n}\nsigned main()\n{\n\tf[0]=1;for(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn-1]=qpow(f[nn-1],mod-2);\n\tfor(int i=nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\tcin>>n>>m>>ls>>rs;//m=n-m;\n\t//cout<<calc(ls-1)<<\"\\n\";\n\tcout<<(C(rs+n,n)-C(ls-1+n,n)-C(n,m)*(calc(rs)-calc(ls-1))%mod+mod*10)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 1000010;\nconst int moder = (int) 1e9 + 7;\n\nint fac[N], inv[N], invf[N];\n\nint comb(int n, int m){\n    if (n < m || m < 0){\n        return 0;\n    }\n    return 1ll * fac[n] * invf[m] % moder * invf[n - m] % moder;\n}\n\nint get(int n, int l, int r){\n    int ans = comb(r + n, n) - comb(l + n - 1, n);\n    ans += ans < 0 ? moder : 0;\n    return ans;\n}\n\nint main(){\n    fac[0] = invf[0] = 1;\n    for (int i = 1; i < N; ++ i){\n        fac[i] = 1ll * fac[i - 1] * i % moder;\n        inv[i] = i == 1 ? 1 : moder - 1ll * (moder / i) * inv[moder % i] % moder;\n        invf[i] = 1ll * invf[i - 1] * inv[i] % moder;\n    }\n    int n, m, l, r;\n    scanf(\"%d%d%d%d\", &n, &m, &l, &r);\n    int ans = get(n, l, r);\n    int sub = 0;\n    for (int i = 0; r >= 0; ++ i){\n        l -= m, r -= m;\n        for (int j = 0; j <= n - m; ++ j){\n            int ll = l - (i + 1) * j, rr = r - (i + 1) * j;\n            if (rr < 0){\n                break;\n            }\n            sub = (sub + (j & 1 ? -1ll : 1ll) * comb(n - m, j) * (get(n, ll, rr) - get(n, ll - m, rr - m))) % moder;\n        }\n    }\n    ans = (ans - 1ll * comb(n, m) * sub) % moder;\n    ans += ans < 0 ? moder : 0;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nmint calcans(int N, int M, int R, Combination &C){\n    mint ans = 0;\n    FOR(x, 1, R + 1){\n        if(M * x > R) break;\n        REP(i, N - M + 1){\n            if((M + i) * x > R) break;\n            mint c1 = C.nCr(N - M, i);\n            int rest = R - (M + i) * x;\n            mint c2 = C.nCr(rest + N, N) - C.nCr(rest + N - M, N);\n            if(i % 2 == 0) ans += c1 * c2;\n            else ans -= c1 * c2;\n        }\n    }\n\n    ans *= C.nCr(N, M);\n    ans = C.nCr(R + N, N) - ans;\n    return ans;\n\n}\n\nsigned main(){\n\n    int N, M, L, R; cin >> N >> M >> L >> R;\n    Combination C(N + R + 100);\n    mint ans = calcans(N, M, R, C) - calcans(N, M, L - 1, C);\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#ifdef zxc\n\n#include <sys/resource.h>\n#include \"debug.h\"\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nusing ll = int64_t;\nusing ld = long double;\nconst ld EPS = 1e-9;\n//const ll MOD = 924844033;\nconst ld PI = 3.141592653589793;\nconst int maxn = 600001;\nconst ll MOD = 1e9 + 7;\n\nvoid fast_io() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n}\n\n\nll add(ll a, ll b) {\n    a += b;\n    if (a >= MOD) {\n        a -= MOD;\n    }\n    return a;\n}\n\nll mul(ll a, ll b) {\n    return a * b % MOD;\n}\n\nll pw(ll a, ll b) {\n    ll res = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) {\n            res = mul(res, a);\n        }\n        a = mul(a, a);\n    }\n    return res;\n}\n\nll fac[maxn];\nll inv[maxn];\n\nvoid precalc(int n) {\n    fac[0] = 1;\n    for (int i = 1; i < n; ++i) {\n        fac[i] = mul(fac[i - 1], i);\n    }\n    inv[n - 1] = pw(fac[n - 1], MOD - 2);\n    for (int i = n - 2; i >= 0; --i) {\n        inv[i] = mul(inv[i + 1], i + 1);\n    }\n}\n\nll C(ll n, ll k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fac[n] * inv[n - k] % MOD * inv[k] % MOD;\n}\n\ninline ll distribute(ll n, ll sum) {\n    return C(sum + n, n);\n}\n\nsigned main() {\n#ifdef zxc\n    struct rlimit rl;\n    const rlim_t kStackSize = 512L * 1024L * 1024L;\n    assert(!getrlimit(RLIMIT_STACK, &rl));\n    rl.rlim_cur = kStackSize;\n    assert(!setrlimit(RLIMIT_STACK, &rl));\n    freopen(\"../input.txt\", \"r\", stdin);\n//    freopen(\"../kolya_output.txt\", \"w\", stdout);\n#else\n    //    mt19937 mt(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n    //            freopen(\"\", \"r\", stdin);\n    //        freopen(\"hack.out\", \"w\", stdout);\n#endif\n\n    auto count_bad_sequences = [](ll n, ll m, ll sum, ll x, ll y) { // m elements >=x\n        // n-m elements <=y\n        ll choose_big = C(n, m);\n        sum -= x * m;\n        ll res = mul(choose_big, distribute(n, sum));\n\n        for (int i = 1; i <= n - m && i * (y + 1) <= sum; ++i) {\n            ll choose_small = C(n - m, i);\n            ll val = choose_big * choose_small % MOD * distribute(n, sum - (y + 1) * i) % MOD;\n            if (i & 1) {\n                res = add(res, MOD - val);\n            } else {\n                res = add(res, val);\n            }\n        }\n//        debug(n, m, sum, x, y, res);\n        return res;\n    };\n    auto count_good_sequences = [&](ll n, ll m, ll sum) {\n        ll res = distribute(n, sum);\n        for (int k = 1; k <= sum; ++k) {\n            ll cur = add(count_bad_sequences(n, m, sum, k, k - 1), MOD - count_bad_sequences(n, m, sum, k + 1, k - 1));\n            res = add(res, MOD - cur);\n        }\n        return res;\n    };\n    auto solve = [&](int _) {\n        int n, m, l, r;\n        cin >> n >> m >> l >> r;\n        ll ans = add(count_good_sequences(n, m, r), MOD - count_good_sequences(n, m, l - 1));\n        cout << ans;\n    };\n    precalc(maxn);\n\n    fast_io();\n    cout.precision(9);\n    cout << fixed;\n    auto start = chrono::steady_clock::now();\n\n    for (int i = 1; i <= 1; ++i) solve(i);\n    auto end = chrono::steady_clock::now();\n\n    debug(\"time\", chrono::duration_cast<chrono::milliseconds>(end - start).count() / 1000.0);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mu=  int(1E9) + 7,MOD=1000000007;\nint n,m,l,r,c[2005][2005];\nint solve2(int n,int m,int s,int x,int y){\n\tint ans=0;\n\tif (s-1ll*m*x<0) return 0;\n\telse s=s-1ll*m*x;\n\tint f=1;\n\tfor (int i=0,f=1;i<=n-m && s>=0;i++,f=1ll*f*(mu-1)%mu,s=s-y){\n\t\tans=(ans+1ll*f*c[s+n][n]%mu*c[n-m][i]%mu)%mu;\n\t}\n\treturn 1ll*ans*c[n][m]%mu;\n}\nint solve(int n,int m,int s){\n\tint ans=c[s+n][n];\n\tfor (int i=s;i>=1;i--){\n\t\t//枚举第m个数 \n\t\tint del=(solve2(n,m,s,i,i)+mu-solve2(n,m,s,i+1,i))%mu;\n\t\tans=(ans+mu-del)%mu;//容斥 \n\t}\n\treturn ans;\n}\n/*int solve2(int N, int M, int S, int l, int r) {\n    int ret = 0;\n    if( S - 1LL*M*r < 0 ) return ret;\n    else S -= M*r;\n    for(int i=0,f=1;i<=N-M&&S>=0;i++,f=1LL*f*(MOD-1)%MOD,S-=l)\n        ret = (ret + 1LL*f*c[S+N][N]%MOD*c[N-M][i]%MOD)%MOD;\n        printf(\"%d %d %d %d %d %d\\n\",N,M,S,l,r,ret);\n    return 1LL*ret*c[N][M]%MOD;\n}\nint solve(int N, int M, int S) {\n    int ret = c[S + N][N];\n    for(int i=S;i>=1;i--) {\n        int del = (solve2(N, M, S, i, i) + MOD - solve2(N, M, S, i, i+1))%MOD;\n        ret = (ret + MOD - del)%MOD;\n        printf(\"%d..\",ret);\n    }\n    printf(\"%d %d %d %d\\n\",N,M,S,ret);\n    return ret;\n}*/\nint main(){\n\tscanf(\"%d%d%d%d\",&n,&m,&l,&r);\n\tc[0][0]=1;\n\tfor (int i=1;i<=r+n;i++){\n\t\tc[i][0]=1;\n\t\tfor (int j=1;j<=i;j++)\n\t\t\tc[i][j]=(c[i-1][j]+c[i-1][j-1])%mu;\n\t}\n\tprintf(\"%d\\n\",(solve(n,m,r)-solve(n,m,l-1)+mu)%mu);\n}"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// 以下のソースを勉強する.\n// yutaka1999氏.\n// https://atcoder.jp/contests/jsc2019-qual/submissions/7117252\n#include <bits/stdc++.h>\nusing namespace std;\n#define SIZE 600005\n#define MOD 1000000007\nusing LL = long long;\nusing P = pair<int, int>;\n\nLL inv[SIZE], fac[SIZE], finv[SIZE];\nvoid make(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < SIZE; i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        fac[i] = fac[i - 1] * (LL)i % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nLL C(int a,int b){\n    if(a < b) return 0;\n    return fac[a] * (finv[b] * finv[a - b] % MOD) % MOD;\n}\n\nLL solve(int n, int m, int L){\n    LL ret=C(n + L, n);\n    for(int t = 0; (t + 1) * m <= L; t++){\n        int zan = L - (t + 1) * m;\n        int a = n - m, b = m;\n        for(int k = 0; k * t <= L && k <= a; k++){\n            if(zan < 0) break;\n            LL vl = C(zan + n, n) * C(a, k) % MOD * C(n, a) % MOD;\n            if(k % 2 == 1) ret += vl;\n            else           ret += MOD - vl;\n            ret %= MOD;\n            zan -= t + 1;\n        }\n        zan = L - (t + 2) * m;\n        for(int k = 0; k * t <= L && k <= a; k++){\n            if(zan < 0) break;\n            LL vl = C(zan + n, n) * C(a, k) % MOD * C(n, a) % MOD;\n            if(k % 2 == 0) ret += vl;\n            else           ret += MOD - vl;\n            ret %= MOD;\n            zan -= t + 1;\n        }\n    }\n    return ret;\n}\nint main(){\n    make();\n    int n, m, l, r;\n    scanf(\"%d %d %d %d\",&n, &m, &l, &r);\n    printf(\"%lld\\n\",(solve(n, m, r) - solve(n, m, l - 1) + MOD) % MOD);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// tourist's modular-arithmetic class\ntemplate <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a; swap(a, m);\n        u -= t * v; swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate <typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U& x) {\n        value = normalize(x);\n    }\n\n    template <typename U>\n    static Type normalize(const U& x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n    Modular& operator++() { return *this += 1; }\n    Modular& operator--() { return *this -= 1; }\n    Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n    Modular operator-() const { return Modular(-value); }\n\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n    template <typename U>\n    friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n    template <typename U>\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\nprivate:\n    Type value;\n};\n\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n    return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n    return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n    return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nstruct fast_ios {\n    fast_ios() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n    };\n} fast_ios_;\n\n#define LSON(x) ((x) * 2)\n#define RSON(x) ((x) * 2 + 1)\ntemplate<typename A, typename B>\nvoid Min(A &a, const B &b){\n    if (b < a) a = b;\n}\ntemplate<typename A, typename B>\nvoid Max(A &a, const B &b){\n    if (b > a) a = b;\n}\n\nint cas;\nostream& kase() {\n    return cout << \"Case #\" << ++cas << \": \";\n}\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate <typename iter_t>\nstruct iter_pair {\n    iter_t _beg, _end;\n    iter_t begin(){return _beg;}\n    iter_t end(){return _end;}\n};\n\ntemplate<class cont> iter_pair<reverse_iterator<decltype(begin(declval<cont>()))>>\nreverse(cont &&r) {\n    return {make_reverse_iterator(end(r)), make_reverse_iterator(begin(r))};\n}\n\ntemplate<typename T> void dprintln(const T &t) { cout << t << endl; } // for debug use\ntemplate<typename T, typename ...Args> void dprintln(const T &t, const Args &...rest) { cout << t << ' '; dprintln(rest...); }\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\n\n\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\ntemplate<typename T> void println(const vector<T>& vec) {\n    if (!vec.empty()) {\n        cout << vec[0];\n        for (size_t i = 1; i < vec.size(); ++i)\n            cout << ' ' << vec[i];\n    }\n    cout << '\\n';\n}\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t << ' '; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\ntemplate<typename T> istream& operator>>(istream& stream, vector<T>& vec) {\n    for (auto& x : vec) stream >> x;\n    return stream;\n}\nusing ull = unsigned long long;\nusing ll = long long;\nusing ul = unsigned long;\nusing vl = vector<ll>;\nusing vi = vector<int>;\nusing pii = pair<int,int>;\nusing pip = pair<int,pii>;\nusing pll = pair<ll,ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing ldb = long double;\ntemplate <typename int_t>\ninline int_t lowbit(int_t x) {return x & -x;}\n#define rng(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define up(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define down(i, b, a) for (int i = int(b); i >= int(a); i--)\n#define rep(n) for(int _iter_##n = 0, _num_##n = (int)n; _iter_##n < _num_##n; ++_iter_##n)\n#define stp(i, a, b, c) for (int i = (a); i < (b); i += (c))\n#define FOR(x, cont) for (const auto &x: cont)\n#define INC(init, x, y) for (init; x <= y; ++x)\n#define For(x, cont) for (auto &x: cont)\n#define all(x) begin(x), end(x)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define SZ(x) (int)(x).size()\n#define UP(i, l, r) for(i = decltype(i)(l); i <= decltype(i)(r); ++i)\n#define DOWN(i, r, l) for (i = decltype(i)(r); i >= decltype(i)(l); --i)\n#define Dec(a, b) for (; a >= b; --a)\ntemplate <typename T, typename Comp = less<T>>\nusing pq = priority_queue<T, vector<T>, Comp>;\n#define popcnt(x) __builtin_popcountll((x))\n#define SET(arr, v) memset(arr, (v), sizeof (arr))\n#define UNIQ(vec) (vec).erase(unique(all(vec)), end(vec))\n#define LB(cont, x) int(lower_bound(all(cont), x) - begin(cont))\n#define UB(cont, x) int(upper_bound(all(cont), x) - begin(cont))\n#define AI(name, n, m) vv<int> name(n, vi(m));\n#define AL(name, n, m) vv<ll> name(size_t(n), vl(size_t(m)));\n#define set0(arr) memset(arr, 0, sizeof arr)\n#define set1(arr) memset(arr, -1, sizeof arr)\n#define AT(T, n, m, a)  vector<vector<T>> a(n, vector<T>(m))\nconst int dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};\nauto bet = [](const ll x, const ll y, const ll i) {\n    return x <= i && i <= y;\n};\n\ntemplate<typename T1, typename T2>\nT1 ceil(T1 x, T2 y) { // y >= 1，是整数。需要注意 x + y - 1 是否会溢出\n    return (x + y - 1) / y;\n}\n\ninline int h_bit(unsigned long long x) {\n    return (int)sizeof(unsigned long long) * 8 - 1 - __builtin_clzll(x);\n}\n\nint pow2(int x){ // power of 2\n    return int(1U << h_bit((ull)x)) + (x != lowbit(x));\n}\n\ntemplate <typename T>\nstruct BIT {\n    vector<T> a;\n    function<T(T,T)> bin_op;\n    const T init;\n    explicit BIT(int n, function<T(T,T)> bin_op, T init):bin_op(bin_op), init(init) {\n        a.assign(n + 1, init);\n    }\n\n    T prefix(int x) {\n        auto res = init;\n        while (x) {\n            res = bin_op(a[x], res);\n            x -= x & -x;\n        }\n        return res;\n    }\n    void modify(int x, T v) {\n        while (x < (int)a.size()) {\n            a[x] = bin_op(a[x], v);\n            x += x & -x;\n        }\n    }\n    void clear(){\n        fill(a.begin(), a.end(), init);\n    }\n};\n\nvi get_prime(int n) {\n    vi minp((ul) n + 1), p;\n    for (int i = 2; i <= n; i++) {\n        if (!minp[i]) {\n            minp[i] = i;\n            p.pb(i);\n        }\n        FOR(x, p) {\n            if (x <= minp[i] && x * i <= n)\n                minp[x * i] = x;\n            else break;\n        }\n    }\n    return p;\n}\n\n// alias templates\ntemplate<typename T> using vv = vector<vector<T>>;\ntemplate <typename T1, typename T2 = T1> using vp = vector<pair<T1,T2>>;\ntemplate<typename T, int n> using va = vector<array<T,n>>;\n\n//order_of_key (k) : Number of items strictly smaller than k .\n//find_by_order(k) : K-th element in a set (counting from zero).\n#ifdef __GNUC__\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate <typename T>\nusing rank_tree = __gnu_pbds::tree<\n        T,\n        __gnu_pbds::null_type,\n        less<T>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n#endif\n\n//并查集\nstruct UnionFind {\n    vi par, sz;\n    int n_tree;\n    explicit UnionFind(int n) { //0-indexed\n        par.assign(n, 0);\n        sz.assign(n, 1);\n        rng (i, 0, n) par[i] = i;\n        n_tree = n;\n    }\n    int n_cluster() const {\n        return n_tree;\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n    int root(int x) {\n        return x == par[x] ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        int rx = root(x), ry = root(y);\n        if(rx != ry) {\n            par[rx] = ry;\n            --n_tree;\n            sz[ry] += sz[rx];\n            return true;\n        }\n        return false;\n    }\n};\n\ntemplate<typename T, typename Compare = std::less<T>>\nstruct SparseTable {\n    size_t n{}; // 0-indexed\n    vv<T> a;\n\n    template<typename ptr_t>\n    SparseTable(ptr_t beg, ptr_t end):n(end - beg) {\n        a.resize((size_t) h_bit(n) + 1); // 注意：不能写成 h_bit(n)\n        a[0].assign(beg, end);\n        rng (i, 0, SZ(a) - 1) {\n            a[i + 1].resize(n);\n            rng(j, 0, n - (1u << i)) {\n                a[i + 1][j] = min(a[i][j], a[i][j + (1u << i)], Compare());\n            }\n            rng(j, n - (1u << i), n) {\n                a[i + 1][j] = a[i][j];\n            }\n        }\n    }\n    using idx_t = long;\n    T query(idx_t l, idx_t r) { // l <=  r\n        int i = h_bit(r - l + 1ul);\n        return min(a[i][l], a[i][r + 1 - (1u << i)], Compare());\n    }\n};\n\nvi get_popcnt(int n) {\n    vi res((ul)n + 1);\n    rng (i, 0, n) {\n        if (i * 2 <= n) res[i * 2] = res[i];\n        if ((i & 1) == 0) res[i + 1] = res[i] + 1;\n    }\n    return res;\n}\n\nvi get_mu(int n) {\n    assert(n > 0);\n    vi mu(n + 1);\n    vi min_p(n + 1);\n    vi prime;\n    mu[1] = 1;\n    rng (i, 2, n + 1) {\n        if (!min_p[i]) {\n            prime.pb(i);\n            min_p[i] = i;\n            mu[i] = -1;\n        }\n        FOR (p, prime) {\n            if (p > min_p[i]) {\n                break;\n            }\n            int t = p * i;\n            if (t > n) break;\n            min_p[t] = p;\n            mu[t] = p == min_p[i] ? 0 : -mu[i];\n        }\n    }\n    return mu;\n}\n\ntemplate<typename num>\nnum fp(num x, ll n, int mod) { //fast power: hat off to quailty\n    if (n < 0) {\n        x = inverse(x, mod);\n        n = -n;\n    }\n    num ans = 1;\n    while (n) {\n        if (n & 1) ans *= x;\n        n /= 2;\n        x *= x;\n    }\n    return ans;\n}\n\n// debug code by tourist\nstring to_string(const string& s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// end DEBUG\n\ntemplate <typename T>\nstruct Binom {\n    vector<T> fact, inv_fact;\n\n    explicit Binom(int n) : fact(n + 1), inv_fact(n + 1) {\n        fact[0] = 1;\n        up (i, 1, n) fact[i] = fact[i - 1] * i;\n        inv_fact[n] = 1 / fact[n];\n        down (i, n - 1, 0) {\n            inv_fact[i] = inv_fact[i + 1] * (i + 1);\n        }\n    }\n\n    T get_binom(int x, int y) const {\n        assert(x <= SZ(fact) - 1);\n        assert(x >= 0 && y >= 0);\n        if (x < y) return 0;\n        return fact[x] * inv_fact[y] * inv_fact[x - y];\n    }\n\n    T get_fact(int n) const {\n        assert(n < SZ(fact));\n        return fact[n];\n    }\n};\n\n//https://codeforces.com/blog/entry/22072\nstruct HLD {\n    HLD(int n, const int *heavy_son, const int *fa, const int *depth) : top(n + 1), pos(n + 1), depth(depth), fa(fa) {\n        int index = 0;\n        // 节点编号从1开始\n        for (int i = 1; i <= n; i++) {\n            if (i != heavy_son[fa[i]]) {\n                for (int j = i; j != 0; j = heavy_son[j]) {\n                    top[j] = i;\n                    pos[j] = ++index; // pos从1开始\n                }\n            }\n        }\n    }\n\n    template<typename BinOpr>\n    //返回值是 LCA(u,v)\n    int process_path(int u, int v, BinOpr op, bool value_on_edge = false) const {\n        while (top[u] != top[v]) {\n            if (depth[top[u]] < depth[top[v]]) swap(u, v);\n            op(pos[top[u]], pos[u]);\n            u = fa[top[u]];\n        }\n        if (depth[u] > depth[v]) swap(u, v);\n        op(pos[u] + value_on_edge, pos[v]);\n        return u;\n    }\n\n    vector<int> top, pos;\n    const int *depth, *fa;\n};\n\ntemplate <typename T>\nT get_mid(T l, T r) {\n    assert(l <= r);\n    return l + (r - l) / 2;\n}\ntemplate <typename T>\nint get_bit(T a, int i) {\n    return a >> i & 1;\n}\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n */\nconstexpr int md = 1000000007;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n//////////////////^\"^///////////////////////////////////\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"main.in\");\n    cin.rdbuf(in.rdbuf());\n//    ofstream out(\"main.out\");\n//    cout.rdbuf(out.rdbuf());\n#endif\n\nint N, M, L, R;\nscan(N, M, L, R);\n\nBinom<Mint> B(N + R);\n\nauto calc = [&](int sum, int a, int b) {\n    Mint ans = 0;\n    if (M * a > sum) return ans;\n    int t = sum - M * a;\n    int c = t / (b + 1);\n    for (int i = 0; i <= min(N - M, c); ++i) {\n        int r = t - i * (b + 1);\n        assert(r >= 0);\n        ans += (i & 1 ? -1 : 1) * B.get_binom(N - M, i) * B.get_binom(N + r, r);\n    }\n    return ans * B.get_binom(N, M);\n};\n\nauto calc2 = [&](int sum, int a) {\n    return calc(sum, a, a - 1) - calc(sum, a + 1, a - 1);\n};\n\nauto calc3 = [&](int sum) {\n    Mint ans = 0;\n    for (int i = 1; i * M <= sum; i++) {\n        ans += calc2(sum, i);\n    }\n    return B.get_binom(N + sum, sum) - ans;\n};\n\n\nMint ans = calc3(R) - calc3(L - 1);\nprintln(ans);\n\n\n\n\n\n#ifdef LOCAL\n    cout << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nconstexpr ll mod=1e9+7;\n\nll mod_pow(ll a,ll b){\n\ta%=mod;\n\tif(b==0)return 1;\n\tif(b==1)return a;\n\tll res=mod_pow(a,b/2)%mod;\n\tres*=res; res%=mod;\n\tif(b%2)res*=a;\n\treturn res%mod;\n}\n\nstruct perm{\nprivate:\n\tint sz;\n\tvector<ll> p,invp;\npublic:\n\tperm(int n){\n\t\tsz=n+1;\n\t\tp.resize(sz),invp.resize(sz);\n\t\tp[0]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i]=p[i-1]*i%mod;\n\t\t}\n\t\tinvp[sz-1]=mod_pow(p[sz-1],mod-2);\n\t\tfor(int i=sz-2;i>=0;i--){\n\t\t\tinvp[i]=invp[i+1]*(i+1)%mod;\n\t\t}\n\t}\n\tll comb(ll x,ll y){\n\t\tif(x<y||y<0)return 0;\n\t\treturn (p[x]*invp[x-y]%mod)*invp[y]%mod;\n\t}\n};\nperm p(2e6);\n\nll cul(ll n,ll m,ll r,ll a,ll b){\n\tll res=0;\n\tfor(int i=0;i<=n-m;i++){\n\t\tll rr=r-m*a-i*(b+1);\n\t\tif(rr<0)break;\n\t\tif(i%2==0){\n\t\t\t(res+=p.comb(n+rr,rr)*p.comb(n-m,i)%mod)%=mod;\n\t\t}else{\n\t\t\t(res-=p.comb(n+rr,rr)*p.comb(n-m,i)%mod)%=mod;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nll solve(ll n,ll m,ll r){\n\tll res=p.comb(n+r,r);\n\tll sum=0;\n\tfor(ll i=1;i<=r;i++){\n\t\tif((ll)m*i>r)break;\n\t\t(sum+=cul(n,m,r,i,i-1)-cul(n,m,r,i+1,i-1))%=mod;\n\t}\n\t(sum*=p.comb(n,m))%=mod;\n\t(res-=sum)%=mod;\n\tif(res<0)res+=mod;\n\treturn res;\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tll n,m,l,r; cin >> n >> m >> l >> r;\n\tll res=(solve(n,m,r)-solve(n,m,l-1))%mod;\n\tif(res<0)res+=mod;\n\tprintf(\"%lld\\n\",res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(a)a.begin(),a.end()\nusing ll=long long;\nconst int INF = 1<<30;\nconst ll INFll =1LL<<62;\nconst int mod= int(1e9)+7;\n//const int mod=998244353;\nusing P = pair<int,int>;\nusing Pl= pair<ll,ll>;\nusing ld=long double;\nusing V=vector<int>;\nusing Vl=vector<ll>;\nusing VV=vector<vector<int>>;\nusing VVl=vector<vector<ll>>;\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<mod>;\n\nconst int MAX = 510000;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\n ll nPr(int n, int r) {\n    if (n < 0 || r < 0 || n < r) return 0;\n    return fac[n] * finv[n - r] % mod;\n}\n\n\nint main(){\n    COMinit();\n    ll n,m,l,r;cin >>n>>m>>l>>r;\n    mint ans;\n    //(1-x^m)/(1-x)^(n+1)\n    vector<mint>dp(r+1,0);\n    for (int i = 0; i <=r; ++i) {\n        dp[i]=COM(n+i,n);\n    }\n    auto nx=dp;\n    for (int i =m; i <=r; ++i) {\n        dp[i]-=nx[i-m];\n    }\n    //sum(k~)x^km*(1-x^k)^(n-m)\n    vector<mint>P(r+1,0);\n    for (int k =1; k <=r; ++k) {\n        for (int i =k*m; i <=min(k*n,r); i +=k) {\n            if(((i-k*m)/k)%2==0) {\n                P[i] += COM(n - m,(i-k*m)/k );\n            }\n            else {\n                P[i]-=COM(n - m,(i-k*m)/k );\n            }\n        }\n//        for(auto p:P){\n//            cout <<p<<\" \";\n//        }\n//        cout <<endl;\n    }\n//    vector<mint>G(r+1,0);\n//    for (int k =1; k <=r; ++k){\n//        vector<mint>P2(r+1,0);\n//        P[0]=1;\n//        x^km\n//        vector<mint>nx(r+1,0);\n//        for (int i = 0; i <=r; ++i) {\n//            if(i+k*m>r)break;\n//            nx[i+k*m]=P2[i];\n//        }\n//        P=nx;\n//        for(auto p:P){\n//            cout <<p<<\" \";\n//        }\n//        cout <<endl;\n//ok\n//        *(1-x^k)^(n-m)\n//        for (int i = 0; i <=n-m; ++i) {\n//            for (int j = 0; j <=r; ++j) {\n//                if (j + k * i > r)break;\n//                G[j + k * i] += P2[j] * COM(n - m, i) * ((i % 2 == 1) ? -1 : 1);\n//            }\n//        }\n//        cout <<k<<endl;\n//        for(auto g:G){\n//            cout <<g<<\" \";\n//        }\n//        cout <<endl;\n//ok\n//    }\n    mint U=COM(r+n,n);\n    mint plus=0;\n    for (int i = 0; i <=r; ++i) {\n        plus+=dp[i]*P[r-i];\n    }\n    plus=U-plus*COM(n,m);\n    U=COM(l-1+n,n);\n    mint sub=0;\n    for (int i = 0; i < l; ++i) {\n        sub+=dp[i]*P[l-i-1];\n    }\n    sub=U-sub*COM(n,m);\n    ans=plus-sub;\n    cout <<ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,M,L,R;\nll mo=1000000007;\nll ret;\n\nll comb(ll N_, ll C_) {\n\tconst int NUM_=700001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\nll hcomb(int P_,int Q_) { return (P_==0&&Q_==0)?1:comb(P_+Q_-1,Q_);}\n\n\nll pat(int a,int b,int ma) {\n\tll tot=0;\n\tfor(int over=0;over*b+M*a<=ma && over<=N-M;over++) {\n\t\tll pat=comb(N,M)*comb(N-M,over)%mo*hcomb(N+1,ma-(over*b+M*a))%mo;\n\t\tif(over%2==0) {\n\t\t\ttot+=pat;\n\t\t}\n\t\telse {\n\t\t\ttot+=mo-pat;\n\t\t}\n\t}\n\treturn (tot%mo+mo)%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>L>>R;\n\t\n\tfor(i=L;i<=R;i++) ret+=hcomb(N,i);\n\tfor(int la=1;la<=R;la++) {\n\t\tret-=(pat(la,la,R)-pat(la+1,la,R))-(pat(la,la,L-1)-pat(la+1,la,L-1));\n\t}\n\t\n\t\n\tcout<<(ret%mo+mo)%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nll n,m,l,r;\nconst int MAXN=1e6+3;\nll fact[MAXN];\nll inv[MAXN];\nll modp(ll a, ll b)\n{\n\tif(b==0)return 1;\n\tll u=modp(a, b/2);\n\tu=(u*u)%mod;\n\tif(b&1)return (a*u)%mod;\n\treturn u;\n}\nll ncr(ll n, ll r)\n{\n\tif(n<r)return 0;\n\tll res=(fact[n]*inv[n-r])%mod;\n\tres=(res*inv[r])%mod;\n\treturn res;\n}\nll calc()\n{\tll uni=ncr(n,m);\n\tll right=ncr(r+n, n);l--;\n\tll left=ncr(l+n,n);\n\t//right calc\n\tfor(int i=1;i<=r;i++)\n\t{\n\t\tll md=r-m*i;\n\t\tif(md<0)break;\n\t\tfor(int j=0;j*i<=md;j++)\n\t\t{\n\t\t\tll chk=(ncr(n-m, j)*ncr(md-(j*i)+n, n))%mod;\n\t\t\tchk=(chk*uni)%mod;\n\t\t\tif(!(j&1))chk=-chk;\n\t\t\tright=(right+chk+mod)%mod;\n\t\t}\n\t\tmd-=m;\n\t\tfor(int j=0;j*i<=md;j++)\n\t\t{\n\t\t\tll chk=(ncr(n-m, j)*ncr(md-(j*i)+n, n))%mod;\n\t\t\tchk=(chk*uni)%mod;\n\t\t\tif((j&1))chk=-chk;\n\t\t\tright=(right+chk+mod)%mod;\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=1;i<=l;i++)\n\t{\n\t\tll md=l-m*i;\n\t\tif(md<0)break;\n\t\tfor(int j=0;j*i<=md;j++)\n\t\t{\n\t\t\tll chk=(ncr(n-m, j)*ncr(md-(j*i)+n, n))%mod;\n\t\t\tchk=(chk*uni)%mod;\n\t\t\tif(!(j&1))chk=-chk;\n\t\t\tleft=(left+chk+mod)%mod;\n\t\t}\n\t\tmd-=m;\n\t\tfor(int j=0;j*i<=md;j++)\n\t\t{\n\t\t\tll chk=(ncr(n-m, j)*ncr(md-(j*i)+n, n))%mod;\n\t\t\tchk=(chk*uni)%mod;\n\t\t\tif((j&1))chk=-chk;\n\t\t\tleft=(left+chk+mod)%mod;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\treturn (right-left+mod)%mod;\n}\nvoid init_fact()\n{\n\tfact[0]=1;inv[0]=modp(fact[0], mod-2);\n\tfor(int i=1;i<MAXN-1;i++)\n\t{fact[i]=(fact[i-1]*i)%mod;\n\t\tinv[i]=modp(fact[i], mod-2);\n\t}\n}\n\nint main()\n{\n\tcin>>n>>m>>l>>r;\n\tinit_fact();\n\tcout<<calc()<<\"\\n\";\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 300010;\nconst int mod = 1e9 + 7;\n\nint n, m, fact[N << 1], invf[N << 1];\n\nint qpow(int x, int y)\n{\n\tint out = 1;\n\twhile (y)\n\t{\n\t\tif (y & 1) out = (ll) out * x % mod;\n\t\tx = (ll) x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn out;\n}\n\nint c(int x, int y)\n{\n\treturn (ll) fact[x] * invf[y] % mod * invf[x - y] % mod;\n}\n\nint f(int x, int y)\n{\n\tint out = 0;\n\tfor (int i = 0; i * x <= y && i <= n - m; ++i)\n\t{\n\t\tout = (out + (i & 1 ? -1ll : 1ll) * c(n - m, i) * c(n + y - i * x, n) % mod + mod) % mod;\n\t}\n\treturn out;\n}\n\nint solve(int r)\n{\n\tint out = c(n + r, r);\n\tfor (int x = 1; x <= r / m; ++x)\n\t{\n\t\tout = (out + (ll) c(n, m) * (f(x, r - m * (x + 1)) - f(x, r - m * x) + mod)) % mod;\n\t}\n\treturn out;\n}\n\nint main()\n{\n\tint l, r;\n\t\n\tcin >> n >> m >> l >> r;\n\t\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n + r; ++i) fact[i] = (ll) fact[i - 1] * i % mod;\n\tinvf[n] = qpow(fact[n], mod - 2); \n\tfor (int i = n; i >= 1; --i) invf[i - 1] = (ll) invf[i] * i % mod;\n\t\n\tcout << ((solve(r) - solve(l - 1) + mod) % mod + mod) % mod;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=6e6+5;\nint n,m,L,R,fac[N],vf[N],inv[N],i;\ninline int C(int x,int y){\n\treturn 1ll*vf[y]*vf[x-y]%mo*fac[x]%mo;\n}\ninline int calc(int s){\n\tint i,j,ans=C(s+n,n),ss=0,x;\n\tfor(i=0;i<=s;++i){\n\t\tint z=0;\n\t\tfor(j=0;(i+1)*(j+n-m)<=s && j<=m;++j){\n\t\t\tx=1ll*C(s-(j+n-m)*(i+1)+n,n)*C(m,j)%mo;\n\t\t\tif(j&1)z=(z+mo-x)%mo;else z=(z+x)%mo;\n\t\t}\n\t\tfor(j=0;(i+1)*(n-m)+i*j<=s && j<=m;++j){\n\t\t\tx=1ll*C(s-j*i-(n-m)*(i+1)+n,n)*C(m,j)%mo;\n\t\t\tif(j&1)z=(z+x)%mo;else z=(z+mo-x)%mo;\n\t\t}\n\t\tss=(ss+z)%mo;\n\t}\n\tans=(ans+mo-1ll*ss*C(n,m)%mo)%mo;\n\treturn ans;\n}\nint main(){\n\tfor(i=*fac=*vf=1;i<N;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mo,\n\t\tinv[i]=i==1?1:1ll*(mo-mo/i)*inv[mo%i]%mo,\n\t\tvf[i]=1ll*vf[i-1]*inv[i]%mo;\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);\n\tprintf(\"%d\\n\",(calc(R)+mo-calc(L-1))%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n#define let auto const\n\ntemplate<typename... Types>\nstruct dynarr: std::vector<Types...> {\n  using std::vector<Types...>::vector;\n  using size_type = typename std::vector<Types...>::size_type;\n  auto&& operator[](size_type i) { return this->at(i); }\n  auto&& operator[](size_type i) const { return this->at(i); }\n};\n\ntemplate<i64 M>\nstruct modint {\n  i64 a;\n  constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}\n  constexpr i64 value() const noexcept { return a; }\n  constexpr modint& operator+=(const modint r) noexcept {\n    a += r.a;\n    if(a >= M) a -= M;\n    return *this;\n  }\n  constexpr modint& operator=(const i64 r) {\n    a = (r % M + M) % M;\n    return *this;\n  }\n  constexpr modint& operator-=(const modint r) noexcept {\n    a -= r.a;\n    if(a < 0) a += M;\n    return *this;\n  }\n  constexpr modint& operator*=(const modint r) noexcept {\n    a = a * r.a % M;\n    return *this;\n  }\n  constexpr modint& operator/=(modint r) noexcept {\n    i64 ex = M - 2;\n    while(ex) {\n      if(ex & 1) {\n        *this *= r;\n      }\n      r *= r;\n      ex >>= 1;\n    }\n    return *this;\n  }\n\n  constexpr modint operator+(const modint r) const {\n    return modint(*this) += r;\n  }\n  constexpr modint operator-(const modint r) const {\n    return modint(*this) -= r;\n  }\n  constexpr modint operator*(const modint r) const {\n    return modint(*this) *= r;\n  }\n  constexpr modint operator/(const modint r) const {\n    return modint(*this) /= r;\n  }\n};\n\nusing fp = modint<(i64)(1e9 + 7)>;\n\nconst int MAX = 606060;\n\nfp fac[MAX], finv[MAX];\n\nvoid COMinit() {\n  fac[0] = 1;\n  for(i64 i = 1;i < MAX;i++) {\n    fac[i] = fac[i - 1] * fp(i);\n  }\n  finv[MAX - 1] = fp(1) / fac[MAX - 1];\n  for(i64 i = MAX - 2;i >= 0;i--) {\n    finv[i] = finv[i + 1] * fp(i + 1);\n  }\n}\n\nfp com(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k]);\n}\n\nint main() {\n    COMinit();\n    i64 N, M, L, R;\n    cin >> N >> M >> L >> R;\n    // (1 - T)^(N - M)\n\n    dynarr<fp> f(R + 1);\n    rep(i,0,R + 1) {\n      f[i] = com(N - M, i);\n      if(i % 2 == 1) f[i] *= fp(-1);\n    }\n\n    // T^M * (1 - T)^(N - M)\n    \n    dynarr<fp> F(R + 1);\n    rep(i,M,R + 1) {\n      F[i] = f[i - M];\n    }\n\n\n    // P = sigma(k = 1 ~ inf) { F(T^k) }\n    dynarr<fp> P(R + 1);\n    for(i64 i = 1;i <= R;i++) {\n      for(i64 k = 1;i * k <= R; k++) {\n        P[i * k] += F[i];\n      }\n    }\n\n    // (1 / (1 - T))^(N + 1)\n\n    dynarr<fp> q(R + 1);\n    rep(n,0,R + 1) {\n      q[n] = com(n + (N + 1) - 1, (N + 1) - 1);\n    }\n\n    // (1 - T^M) * (1 / (1 - T))^(N + 1)\n    \n    dynarr<fp> Q(R + 1);\n    rep(i, 0, R + 1) {\n      Q[i] = q[i];\n      if(i - M >= 0) Q[i] -= q[i - M];\n    }\n\n    fp Sr = 0;\n\n    for(i64 i = 0;i <= R;i++) {\n      Sr += P[i] * Q[R - i];\n    }\n\n    fp Sl = 0;\n    L--;\n    for(i64 i = 0;i <= L;i++) {\n      Sl += P[i] * Q[L - i];\n    }\n\n    fp rev = (Sr - Sl) * com(N, M);\n    fp al = q[R] - q[L];\n\n    cout << (al - rev).value() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return x.inv()*a;}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n  M pow(ll m) {\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\nusing mint = ModInt<MOD>;\n\nint N, M, L, R;\nmint fact[414514];\n\nmint Comb(int n, int k) {\n  assert(0 <= k && k <= n);\n  return fact[n]/fact[k]/fact[n-k];\n}\n\nmint Calc(int L) {\n  auto ret = Comb(L+N, N)/fact[N];\n  vector<mint> f(L+1);\n  rep(l, N-M+1) {\n    mint coef = Comb(N-M, l) * mint(-1).pow(l);\n    for (int idx=M; idx<=L; idx+=l+M) {\n      f[idx] -= coef;\n    }\n    for (int idx=M+l; idx<=L; idx+=l+M) {\n      f[idx] += coef;\n    }\n  }\n  rep(j, L+1) {\n    int k = L-j;\n    ret -= Comb(k+N, N)*f[j]/fact[M]/fact[N-M];\n  }\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  fact[0] = 1;\n  reps(i, 1, 414514) {\n    fact[i] = fact[i-1] * i;\n  }\n\n  cin >> N >> M >> L >> R;\n  auto ans = (Calc(R) - Calc(L-1)) * fact[N];\n  cout << ans.a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PII pair<int, int>\n#define LL long long\nusing namespace std;\nconst LL MOD = (LL) 1e9 + 7;\nconst int MAXN = 600005;\n\nLL fac[MAXN], inv[MAXN];\n\nLL qpow(LL a, LL pw) {\n\tLL res = 1;\n\twhile (pw) {\n\t\tif (pw & 1) res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tpw >>= 1;\n\t}\n\treturn res;\n}\n\nLL C(int n, int k) {\n\treturn fac[n] * inv[k] % MOD * inv[n - k] % MOD;\n}\n\nLL H(int n, int k) {\n\treturn fac[n + k - 1] * inv[k - 1] % MOD * inv[n] % MOD;\n}\n\nLL N, M, L, R;\n\nLL solve(LL S) {\n\tLL n1 = M, n2 = N - M, all = H(S, N + 1), sub = 0;\n\tfor (int i = 1; i * n2 <= S; i++) {\n\t\tLL dist = S - i * n2, res1 = 0, res2 = 0;\n\t\tfor (int j = 0; j <= n1 && j * i <= dist; j++) {\n\t\t\tLL to_add = C(n1, j) * H(dist - j * i, N + 1) % MOD * (j % 2 == 1 ? -1 : 1) % MOD;\n\t\t\tres1 = (res1 + to_add + MOD) % MOD;\n\t\t}\n\t\t\n\t\tif (dist >= n2) {\n\t\t\tdist -= n2;\n\t\t\tfor (int j = 0; j <= n1 && j * i <= dist; j++) {\n\t\t\t\tLL to_add = C(n1, j) * H(dist - j * i, N + 1) % MOD * (j % 2 == 1 ? -1 : 1) % MOD;\n\t\t\t\tres2 = (res2 + to_add + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t\t\n\t\tLL final = (res1 - res2 + MOD) % MOD * C(N, n1) % MOD;\n\t\tsub = (sub + final) % MOD;\n\t}\n\t\n\treturn (all - sub + MOD) % MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tfac[0] = inv[0] = 1;\n\tfor (LL i = 1; i < MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = qpow(fac[i], MOD - 2);\n\t}\n\n\tcin >> N >> M >> L >> R;\n\tM = N - M;\n\tcout << (solve(R) - solve(L - 1) % MOD + MOD) % MOD << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 9/6/2019, 3:42:36 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 1e9 + 7;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 3000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\ncombination C{};\n\nmint solve(ll N, ll K, ll R, ll x)\n{\n  mint ans{};\n  for (auto l = K; l <= N; l++)\n  {\n    if (R - l * x < 0)\n    {\n      break;\n    }\n    if ((l + K) % 2 == 0)\n    {\n      ans += C(l, K) * C(N, l) * C(R - l * x + N, N);\n    }\n    else\n    {\n      ans -= C(l, K) * C(N, l) * C(R - l * x + N, N);\n    }\n  }\n  return ans;\n}\n\nmint f(ll N, ll K, ll R)\n{\n  mint ans{C(R + N, N)};\n  for (auto x = 0; x <= R; x++)\n  {\n    ans -= (solve(N, K, R, x) - solve(N, K, R - K, x));\n  }\n  return ans;\n}\n\nint main()\n{\n  ll N, K, L, R;\n  cin >> N >> K >> L >> R;\n  cout << f(N, K, R) - f(N, K, L - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll MOD=1e9+7;\n\nll powm(ll x,ll k){\n  ll res=1;\n  while(k){\n\tif(k&1) res=res*x%MOD;\n    k>>=1;\n    x=x*x%MOD;\n  }\n  return res;\n}\nint main(){\n  int n,l,r;\n  cin>>n>>l>>r;\n  ll res=0;\n  for(int v=l;v<=r;v++){\n    res+=powm(2*v-l+r+1,n);\n  }\n  cout<<res%MOD<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[700100];\n                int inv[700010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\nint n,m;\nint solve(int S){\n\tint zen=comb(S+n,n);\n\t\n\tfor(int i=1;i<=S;i++){\n\t\tint wa=S-m*i;\n\t\tint t=0;\n\t\t\n\t\tfor(int k=0;k<=n-m;k++){\n\t\t\tint e=wa-k*i;\n\t\t\tif(e<0)break;\n\t\t\tif(k%2==0)t+=comb(e+n,n)*comb(n-m,k)%inf;\n\t\t\telse t+=inf-comb(e+n,n)*comb(n-m,k)%inf;\n\t\t\tt%=inf;\n\t//\t\tcout<<i<<\" \"<<k<<\" \"<<comb(e+n,n)<<endl;\n\t\t}\n\t\tfor(int k=0;k<=n-m;k++){\n\t\t\tint e=wa-m-k*i;\n\t\t\tif(e<0)break;\n\t\t\tif(k%2==0)t+=inf-comb(e+n,n)*comb(n-m,k)%inf;\n\t\t\telse t+=comb(e+n,n)*comb(n-m,k)%inf;\n\t\t\tt%=inf;\n\t\t}\n\t\t\n\t\tt*=comb(n,m);\n\t\tt%=inf;\n\t//\tcout<<t<<endl;\n\t\tzen+=inf-t;\n\t}\n\treturn zen%inf;\n}\n\nsigned main(){\ncin.tie(0);\nios::sync_with_stdio(false);\n\n\tmod=inf;\n\tgya(700000);\n\t\n\t\n cin>>n>>m;\n\tint l,r;\n\tcin>>l>>r;\n\t\n\tcout<<(inf+solve(r)-solve(l-1))%inf<<endl;\n\t\n//\tcout<<solve(3)<<endl;\nreturn 0;\n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n\nusing namespace std;\n\nconstexpr int MOD = 1000000007;\n\nstruct mint {\n  int n;\n  mint(int n_ = 0) : n(n_) {}\n  explicit operator int() { return n; }\n  friend mint operator-(mint a) { return -a.n + MOD * (a.n != 0); }\n  friend mint operator+(mint a, mint b) { int x = a.n + b.n; return x - (x >= MOD) * MOD; }\n  friend mint operator-(mint a, mint b) { int x = a.n - b.n; return x + (x < 0) * MOD; }\n  friend mint operator*(mint a, mint b) { return (long long)a.n * b.n % MOD; }\n  friend mint &operator+=(mint &a, mint b) { return a = a + b; }\n  friend mint &operator-=(mint &a, mint b) { return a = a - b; }\n  friend mint &operator*=(mint &a, mint b) { return a = a * b; }\n  friend bool operator==(mint a, mint b) { return a.n == b.n; }\n  friend bool operator!=(mint a, mint b) { return a.n != b.n; }\n  friend istream &operator>>(istream &i, mint &a) { return i >> a.n; }\n  friend ostream &operator<<(ostream &o, mint a) { return o << a.n; }\n};\nmint operator \"\" _m(unsigned long long n) { return n; }\n\nvector<mint> F_{1, 1}, R_{1, 1}, I_{0, 1};\n\nvoid check_fact(int n) {\n  for (int i = I_.size(); i <= n; i++) {\n    I_.push_back(I_[MOD % i] * (MOD - MOD / i));\n    F_.push_back(F_[i - 1] * i);\n    R_.push_back(R_[i - 1] * I_[i]);\n  }\n}\n\nmint I(int n) { check_fact(abs(n)); return n >= 0 ? I_[n] : -I_[-n]; }\nmint F(int n) { check_fact(n); return n < 0 ? 0 : F_[n]; }\nmint R(int n) { check_fact(n); return n < 0 ? 0 : R_[n]; }\nmint C(int n, int r) { return F(n) * R(n - r) * R(r); }\nmint P(int n, int r) { return F(n) * R(n - r); }\nmint H(int n, int r) { return n == 0 ? (r == 0) : C(n + r - 1, r); }\n\nmint alt(int n) {\n  return n % 2 == 0 ? 1 : MOD - 1;\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int N, M, L, R; cin >> N >> M >> L >> R;\n  auto f = [&](int t) {\n    mint ans = H(N+1, t);\n    for (int i=1; i*M<=t; i++) {\n      for (int j=0; t-(M+j)*i>=0; j++) {\n        ans -= alt(j)*C(N,M)*C(N-M,j)*H(N+1,t-(M+j)*i);\n        ans += alt(j)*C(N,M)*C(N-M,j)*H(N+1,t-M*(i+1)-j*i);\n      }\n    }\n    return ans;\n  };\n  cout << f(R) - f(L - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1000000007;\n\nint quickpow(int x,int y)\n{\n\tlong long res=1,base=x;\n\twhile(y)\n\t{\n\t\tif(y&1) res*=base,res%=mod;\n\t\ty>>=1; base*=base,base%=mod;\n\t}\n\treturn res;\n}\nint inv(int x){return quickpow(x,mod-2);}\n\nint prod[1000001];\nint iprod[1000001];\nint c(int n,int m){return 1ll*prod[n]*iprod[n-m]%mod*iprod[m]%mod;}\n\nint solve2(int n,int m,int s,int l,int r)\n{\n\ts-=m*r;\n\tif(s<0) return 0;\n\tint ans=0;\n\tfor(int i=0;i<=n-m&&s-i*l>=0;i++)\n\t{\n\t\tans=ans+1ll*((i%2==0)?1:-1)*c(s-i*l+n,n)*c(n-m,i)%mod;\n\t\tans%=mod;\n\t}\n\treturn 1ll*(ans+mod)*c(n,m)%mod;\n}\n\nint solve(int n,int m,int s)\n{\n\tint ans=c(s+n,n);\n\tfor(int i=0;i<=s;i++)\n\t\tans=(ans-solve2(n,m,s,i,i)+solve2(n,m,s,i,i+1))%mod;\n\treturn 1ll*(ans+mod)%mod%mod;\n}\nint main()\n{\n\tint n,m,l,r;\n\tscanf(\"%lld%lld%lld%lld\",&n,&m,&l,&r);\n\t\n\tprod[0]=1,iprod[0]=1;\n\tfor(int i=1;i<=1000000;i++)\n\t{\n\t\tprod[i]=1ll*prod[i-1]*i%mod;\n\t\tiprod[i]=inv(prod[i]);\n\t}\n\tprintf(\"%lld\",(solve(n,m,r)-solve(n,m,l-1)+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll mx;\nll fac[1000010],finv[1000010];\n\nll comb(ll n,ll r){\n  maxch(mx,n); maxch(mx,r);\n  if(n<0||r<0||n<r)return 0;\n  else return ((fac[n]*finv[n-r])%mod)*finv[r]%mod;\n}\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll calc(ll S,ll N){\n  if(S<0)return 0;\n  return comb(S+N,N);\n}\n\nll calc2(ll S,ll N,ll M,ll X,ll Y){\n  ll c=comb(N,M);\n  S-=(N-M)*Y;\n  if(S<0)return 0;\n  ll res=0;\n  rep(i,M+1){\n    if(S<0)break;\n    ll add=comb(M,i)*c%mod;\n    (add*=calc(S,N))%=mod;\n    if(i%2==0) (res+=add)%=mod;\n    else (res+=(mod-add))%=mod;\n    S-=X+1;\n  }\n  return res;\n}\n\nll N,M,L,R;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  fac[0]=1;\n  rep(i,1000000)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,1000001)finv[i]=mod_pow(fac[i],mod-2);\n\n  cin>>N>>M>>L>>R;\n  M=N-M;\n  ll tot=(calc(R,N)-calc(L-1,N)+mod)%mod;\n  rep(X,R){\n    ll Y=X+1;\n    ll sub=((calc2(R,N,M,X,Y)-calc2(R,N,M,X,Y+1)+mod)%mod-(calc2(L-1,N,M,X,Y)-calc2(L-1,N,M,X,Y+1)+mod)%mod+mod)%mod;\n    tot=(tot-sub+mod)%mod;\n  }\n  cout<<tot<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x)\n{\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=6e5+10,mod=1e9+7;\ninline void Add(int &x,int y) { x+=y; if(x>=mod) x-=mod; }\ninline void Dec(int &x,int y) { x-=y; if(x<0) x+=mod; }\nint Pow(int x,int y) {\n\tint res=1;\n\twhile(y) {\n\t\tif(y&1) res=res*(ll)x%mod;\n\t\tx=x*(ll)x%mod,y>>=1;\n\t}\n\treturn res;\n}\nint fac[N],inv[N];\ninline void predo(int n) {\n\tfac[0]=1; for(int i=1;i<=n;++i) fac[i]=fac[i-1]*(ll)i%mod;\n\tinv[n]=Pow(fac[n],mod-2); for(int i=n;i>=1;--i) inv[i-1]=inv[i]*(ll)i%mod;\n}\nint C(int n,int m) { return fac[n]*(ll)inv[m]%mod*inv[n-m]%mod; }\nint n,m,ans,L,R;\nint get(int s) { return C(s+n,n); }\nint calc(int s,int a,int b) {\n\tint ans=0;\n\tfor(int j=0;j<=n-m&&s-a*m-j*(b+1)>=0;++j) {\n\t\tint tmp=get(s-a*m-j*(b+1))*(ll)C(n-m,j)%mod;\n\t\tif(j&1) Dec(ans,tmp);\n\t\telse Add(ans,tmp);\n\t}\n\treturn ans*(ll)C(n,m)%mod;\n}\nint sol(int s) {\n\tint ans=get(s);\n\tfor(int i=1;i*m<=s;++i) {\n\t\tDec(ans,calc(s,i,i-1));\n\t\tAdd(ans,calc(s,i+1,i-1));\n\t}\n//\tcout<<s<<' '<<ans<<endl;\n\treturn ans;\n}\nint main() {\n\tpredo(6e5);\n\trd(n),rd(m),rd(L),rd(R);\n\tint ans=sol(R)-sol(L-1);\n\tprintf(\"%d\",(ans%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pii pair<int,int>\nusing namespace std;\nconst int inf = 2147483647;\nconst int mod = 1e9 + 7;\nconst int N = 600001;\n\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint n, m, jc[N], inv[N];\n\nint add(int x, int y) {x += y; return x >= mod ? x - mod : x;}\nint dec(int x, int y) {x -= y; return x < 0 ? x + mod : x;}\nint C(int n, int m) {return (LL)jc[n] * inv[m] % mod * inv[n - m] % mod;}\nint pow_mod(int a, int k) {int ans = 1; for(; k; k >>= 1, a = (LL)a * a % mod) if(k & 1) ans = (LL)ans * a % mod; return ans;}\n\nint gt(int S, int rr) {\n\tif(S < 0) return 0;\n\tint ans = 0;\n\tfor(int i = 0, t = 0; i <= S && t <= n - m; i += rr, t++) {\n\t\tif(t & 1) ans = dec(ans, (LL)C(n - m, t) * C(n + S - i, n) % mod);\n\t\telse ans = add(ans, (LL)C(n - m, t) * C(n + S - i, n) % mod);\n\t} return (LL)ans * C(n, m) % mod;\n}\n\nint solve(int n, int S) {\n\tint ans = C(n + S, n);\n\tfor(int i = 1; i <= S; i++) ans = dec(ans, dec(gt(S - m * i, i), gt(S - m * (i + 1), i)));\n\treturn ans;\n}\n\nint main() {\n\tn = read(), m = read(); int l = read(), r = read();\n\tjc[0] = 1; for(int i = 1; i <= n + r; i++) jc[i] = (LL)jc[i - 1] * i % mod;\n\tinv[n + r] = pow_mod(jc[n + r], mod - 2); for(int i = n + r; i >= 1; i--) inv[i - 1] = (LL)inv[i] * i % mod;\n\tput(dec(solve(n, r), solve(n, l - 1)));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <string>\n#include <functional>\n#include <cassert>\n#include <cmath>\n#define SIZE 600005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[SIZE],fac[SIZE],finv[SIZE];\nvoid make()\n{\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<SIZE;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nll solve(int n,int m,int L)\n{\n\tll ret=C(n+L,n);\n\t//printf(\"%lld\\n\",ret);\n\tfor(int t=0;(t+1)*m<=L;t++)\n\t{\n\t\tint zan=L-(t+1)*m;\n\t\tint a=n-m,b=m;\n\t\tfor(int k=0;k*t<=L&&k<=a;k++)\n\t\t{\n\t\t\tif(zan<0) break;\n\t\t\tll vl=C(zan+n,n)*C(a,k)%MOD*C(n,a)%MOD;\n\t\t\tif(k%2==1) ret+=vl;\n\t\t\telse ret+=MOD-vl;\n\t\t\tret%=MOD;\n\t\t\tzan-=t+1;\n\t\t}\n\t\tzan=L-(t+2)*m;\n\t\tfor(int k=0;k*t<=L&&k<=a;k++)\n\t\t{\n\t\t\tif(zan<0) break;\n\t\t\tll vl=C(zan+n,n)*C(a,k)%MOD*C(n,a)%MOD;\n\t\t\tif(k%2==0) ret+=vl;\n\t\t\telse ret+=MOD-vl;\n\t\t\tret%=MOD;\n\t\t\tzan-=t+1;\n\t\t}\n\t}\n\t//printf(\"%d %d %d : %lld\\n\",n,m,L,ret);\n\treturn ret;\n}\nint main()\n{\n\tmake();\n\tint n,m,l,r;\n\tscanf(\"%d %d %d %d\",&n,&m,&l,&r);\n\tprintf(\"%lld\\n\",(solve(n,m,r)-solve(n,m,l-1)+MOD)%MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int BASE = 1e9 + 7;\n\nlong long fact[600600], invFact[600600];\n\nlong long power(long long x, long long y)\n{\n  if (!y)\n    return 1;\n  long long res = power(x, y >> 1);\n  res = res * res % BASE;\n  if (y & 1)\n    res = res * x % BASE;\n  return res;\n}\n\nlong long c(int n, int k)\n{\n  return n < k ? 0 : fact[n] * invFact[k] % BASE * invFact[n - k] % BASE;\n}\n\n// m numbers >= x, rest <= y\nlong long calc(int n, int m, int r, int x, int y)\n{\n  long long res = 0;\n  // i of n - m > y\n  for (int i = 0; i <= n - m; i++)\n  {\n    int rem = r - x * m - i * (y + 1);\n    if (rem < 0)\n      break;\n    long long ways = c(n + rem, n) * c(n - m, i) % BASE;\n    if (i % 2) res = (res - ways + BASE) % BASE;\n    else res = (res + ways) % BASE;\n  }\n  return res;\n}\n\nlong long solve(int n, int m, int r)\n{\n  long long res = c(n + r, n), bad = 0;\n  for (int x = 1; x * m <= r; x++)\n    bad = (bad + calc(n, m, r, x, x - 1) - calc(n, m, r, x + 1, x - 1) + BASE) % BASE;\n  bad = bad * c(n, m) % BASE;\n  return (res - bad + BASE) % BASE;\n}\n\nint main()\n{\n  for (int i = 0; i <= 600000; i++)\n  {\n    fact[i] = i ? fact[i - 1] * i % BASE : 1;\n    invFact[i] = power(fact[i], BASE - 2);\n  }\n\n  int m, n, l, r;\n  cin >> n >> m >> l >> r;\n  cout << (solve(n, m, r) - solve(n, m, l - 1) + BASE) % BASE << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=600005;\nconst int mod=1e9+7;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nint pre[MAXN],inv[MAXN];\nint C(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nint n,m,L,R;\nint query(int p,int q,int lim)//>=p <q\n{\n\tint fx=m,fy=n-m,ret=0;if(1LL*fx*p>lim)return 0;\n\tfor(int i=0;i<=fy;i++)\n\t{\n\t\tint total=lim-i*q-fx*p;\n\t\tif(total<0)break;\n\t\tint num=1LL*C(total+n,n)*C(n,fx)%mod*C(n-fx,i)%mod;\n\t\tif(i&1)dl(ret,num);else ad(ret,num);\n\t}return ret;\n}\nint solve(int lim)\n{\n\tint ans=0;\n\tfor(int i=1;i<=lim;i++)ad(ans,query(i,i,lim)),dl(ans,query(i+1,i,lim));\n\treturn (C(lim+n,n)-ans+mod)%mod;\n}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN-1]=pow_mod(pre[MAXN-1],mod-2);\n\tfor(int i=MAXN-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();m=read();L=read();R=read();\n\tpr2((solve(R)-solve(L-1)+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline int kazu(int a, const int &b) {return (a += b) >= MOD ? a - MOD : a;}\ninline int hiku(int a, const int &b) {return (a -= b) < 0 ? a + MOD : a;}\n\ninline ll fastpow(ll bas, ll ex){\n\tregister ll res = 1; bas %= MOD;\n\tfor(; ex; ex >>= 1, bas = bas * bas % MOD) if(ex & 1) res = res * bas % MOD;\n\treturn res;\n}\n\nint N, M, L, R;\nll fac[600005] = {1}, ifac[600005];\n\ninline void initfac(const int &lim){\n\tfor(register int i = 1; i <= lim; i++) fac[i] = fac[i - 1] * i % MOD;\n\tifac[lim] = fastpow(fac[lim], MOD - 2);\n\tfor(register int i = lim; i >= 1; i--) ifac[i - 1] = ifac[i] * i % MOD;\n}\n\ninline ll C(const int &n, const int &m) {return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;}\n\ninline int calc2(int S, const int &l, const int &r){\n\tif((S -= M * (ll)r) < 0) return 0; int res = 0;\n\tfor(register int i = 0, sgn = 1; i <= N - M && S >= 0; i++, sgn = sgn * (MOD - 1LL) % MOD, S -= l)\n\t\tres = kazu(res, sgn * C(S + N, N) % MOD * C(N - M, i) % MOD);\n\treturn res * C(N, M) % MOD;\n}\n/*\t∑A[i] + B = S, A[1 .. M] >= r, 0 <= A[M + 1 .. N] < l\n==>\t∑A[i] + B = S - M * r, A[1 .. M] >= 0, 0 <= A[M + 1 .. N] < l */\n\ninline int calc(const int &S){\n\tint res = C(S + N, N);\n\tfor(register int i = S; i > 0; i--) res = hiku(res, hiku(calc2(S, i, i), calc2(S, i, i + 1)));\n\treturn res;\n}\n/*\t∑A[i] <= S\n==>\t∑A[i] + B = S */\n\nint main(){\n\tgetint(N), getint(M), getint(L), getint(R), initfac(R + N);\n\treturn printf(\"%d\\n\", hiku(calc(R), calc(L - 1))), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(T a,T b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=Mint(a).inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n\n  static Mint comb(long long n,Int k){\n    Mint num(1),dom(1);\n    for(Int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename M>\nclass Enumeration{\nprivate:\n  static vector<M> fact,finv,invs;\npublic:\n  static void init(Int n){\n    n=min<decltype(M::mod)>(n,M::mod-1);\n\n    Int m=fact.size();\n    if(n<m) return;\n\n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n\n    if(m==0) m=1;\n    for(Int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(Int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(Int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static M Fact(Int n){\n    init(n);\n    return fact[n];\n  }\n  static M Finv(Int n){\n    init(n);\n    return finv[n];\n  }\n  static M Invs(Int n){\n    init(n);\n    return invs[n];\n  }\n\n  static M C(Int n,Int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(Int n,Int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n\n  static M H(Int n,Int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static M S(Int n,Int k){\n    M res;\n    init(k);\n    for(Int i=1;i<=k;i++){\n      M tmp=C(k,i)*M(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res*=finv[k];\n  }\n\n  static vector<vector<M> > D(Int n,Int m){\n    vector<vector<M> > dp(n+1,vector<M>(m+1,0));\n    dp[0][0]=M(1);\n    for(Int i=0;i<=n;i++){\n      for(Int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static M B(Int n,Int k){\n    if(n==0) return M(1);\n    k=min(k,n);\n    init(k);\n    vector<M> dp(k+1);\n    dp[0]=M(1);\n    for(Int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);\n    M res;\n    for(Int i=1;i<=k;i++)\n      res+=M(i).pow(n)*finv[i]*dp[k-i];\n    return res;\n  }\n\n  static M montmort(Int n){\n    M res;\n    init(n);\n    for(Int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static M LagrangePolynomial(vector<M> &y,M t){\n    Int n=y.size()-1;\n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    vector<M> dp(n+1,1),pd(n+1,1);\n    for(Int i=0;i<n;i++) dp[i+1]=dp[i]*(t-M(i));\n    for(Int i=n;i>0;i--) pd[i-1]=pd[i]*(t-M(i));\n    M res{0};\n    for(Int i=0;i<=n;i++){\n      M tmp=y[i]*dp[i]*pd[i]*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs = vector<M>();\n\n//INSERT ABOVE HERE\nsigned main(){\n  using M = Mint<Int>;\n  using E = Enumeration<M>;\n\n  Int n,m,l,r;\n  cin>>n>>m>>l>>r;\n\n  const Int MAX = 3e5+100;\n  E::init(MAX*2);\n\n  vector<M> ps(MAX);\n  for(Int k=1;k<MAX;k++){\n    for(Int i=0;i<=n-m;i++){\n      if(k*m+k*i>=MAX) break;\n      if(~i&1)\n        ps[k*m+k*i]+=E::C(n-m,i);\n      else\n        ps[k*m+k*i]-=E::C(n-m,i);\n    }\n  }\n\n  vector<M> qs(MAX);\n  for(Int i=0;i<MAX;i++) qs[i]=E::C(i+n,n);\n  for(Int i=MAX-1;i>=m;i--) qs[i]-=qs[i-m];\n\n  auto calc=\n    [&](Int d){\n      M res{0};\n      for(Int i=0;i<=d;i++){\n        Int j=d-i;\n        res+=ps[i]*qs[j];\n      }\n      return res;\n    };\n  M res=calc(r)-calc(l-1);\n\n  M ans{0};\n  for(Int i=l;i<=r;i++) ans+=E::H(n,i);\n  ans-=res*E::C(n,m);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 766666, mo = 1e9+7, inv2 =(mo+1)/2;\nint n,m,fac[N],ifac[N];\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nint C(int n, int m){\n\tassert(n<N);\n\treturn m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;\n}\nvoid init(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);per(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\nint calc(int r){\n\tint res=0;\n\trep(i,0,r)if(1LL*(1+i)*(n-m)<=r){\n\t//\tcerr<<i<<endl;\n\t\tint lim=r-(1+i)*(n-m);\n\t\tfor(int j=0;j<=m&&lim-(i+1)*j>=0;j++)\n\t\t\tres=(res+1LL*C(m,j)*(j&1?mo-1:1)%mo*C(n+lim-(i+1)*j,n))%mo;\n\t\tif(i){\n\t\tfor(int j=0;j<=m&&lim-(i)*j>=0;j++)\n\t\t\tres=((res-1LL*C(m,j)*(j&1?mo-1:1)%mo*C(n+lim-(i)*j,n))%mo+mo)%mo;\n\t\t}\n\t}\n\treturn ((C(r+n,n)-1LL*C(n,m)*res)%mo+mo)%mo;\n}\nint main() {\n\tinit(N-1);read(n);read(m);m=n-m;int l,r;read(l);read(r);\n//\tcerr<<(calc(r))<<' '<<(calc(l-1)+mo)%mo<<endl;\n\tcout<<(calc(r)-calc(l-1)+mo)%mo;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const map<T, U> & mp){\n\tos << \"{\";\n\tint i = 0;\n\tfor(auto it : mp){\n\t\tif(i) os<<\", \";\n\t\tos << it;\n\t\ti++;\n\t}\n\tos << \"}\";\t\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 2e6 + 10;\n// const int mod = 998244353;\nconst int mod = 1e9 + 7;\nint fact[N], invfact[N];\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (((ll) x) * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\nvoid pre(){\n\tfact[0] = invfact[0] = 1;\n\tfor(int i = 1;i < N; i++) fact[i] = mul(i, fact[i - 1]);\n\tinvfact[N - 1] = inv(fact[N - 1]);\n\tfor(int i = N - 2; i >= 1; i--) invfact[i] = mul(invfact[i + 1], i + 1);\n\tassert(invfact[1] == 1);\n}\n\ninline int C(int n, int k){\n\tif(n < k || k < 0) return 0;\n\treturn mul(fact[n], mul(invfact[k], invfact[n - k]));\n}\n\nint coeff(int a, int i){\n\treturn C(a + i - 1, i);\n}\n\nint get(int n, int m, int R){\n\tint ret = C(R + n, n);\n\tint diff = 0;\n\tfor(int i = 0; i <= m; i++){\n\t\tint factor = C(m, i);\n\t\tif(i & 1) factor = sub(0, factor);\n\t\tint val = 0;\n\t\tfor(int z = 0; (z + 1) * (n - m + i) <= R; z++){\n\t\t\tint req = R - (z + 1) * (n - m + i);\n\t\t\tval = add(val, coeff(n + 1, req));\n\t\t}\n\t\tfor(int z = 0; (n - m) * (z + 1) + z * i <= R; z++){\n\t\t\tint req = R - (z + 1) * (n - m) - z * i;\n\t\t\tval = sub(val, coeff(n + 1, req));\n\t\t}\n\n\t\tdiff = add(diff, mul(factor, val));\n\t}\n\treturn sub(ret, mul(C(n, m), diff));\n}\n\nint main(){\n\tpre();\n\tint n, m, L, R;\n\tsd(n); sd(m); sd(L); sd(R);\n\tm = n - m;\n\tprintf(\"%d\\n\", sub(get(n, m, R), get(n, m, L - 1)));\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n#ifdef LOCAL\nstruct PrettyOS {\n    ostream& os;\n    bool first;\n    template <class T> auto operator<<(T&& x) {\n        if (!first) os << \", \";\n        first = false;\n        os << x;\n        return *this;\n    }\n};\ntemplate <class... T> void dbg0(T&&... t) {\n    (PrettyOS{cerr, true} << ... << t);\n}\n#define dbg(...)                                            \\\n    do {                                                    \\\n        cerr << __LINE__ << \" : \" << #__VA_ARGS__ << \" = \"; \\\n        dbg0(__VA_ARGS__);                                  \\\n        cerr << endl;                                       \\\n    } while (false);\n#else\n#define dbg(...)\n#endif\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate <class T> ostream& operator<<(ostream& os, const V<T>& v) {\n    os << \"[\";\n    for (auto d : v) os << d << \", \";\n    return os << \"]\";\n}\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<TEN(9) + 7>;\n// template<> const Mint Mint::G = Mint(3);\n\nconst int MN = 1'000'000;\n\nMint fact[MN], iFac[MN];\n\nvoid first() {\n    fact[0] = Mint(1);\n    for (int i = 1; i < MN; i++) fact[i] = fact[i - 1] * Mint(i);\n    iFac[MN - 1] = fact[MN - 1].inv();\n    for (int i = MN - 1; i >= 1; i--) {\n        iFac[i - 1] = iFac[i] * Mint(i);\n    }\n    assert(fact[2345] * iFac[2345] == Mint(1));\n}\nMint C(int n, int k) {\n    if (n < k || k < 0) return Mint(0);\n    return fact[n] * iFac[k] * iFac[n - k];\n}\n\nMint solve2(int r, int n, int m, int x) {\n    Mint ans = 0;\n    for (int k = 0; k <= m; k++) {\n        int r2 = r - k * x;\n        if (r2 < 0) break;\n        Mint buf = C(m, k) * C(r2 + n, n);\n        if (k % 2 == 0) ans += buf;\n        else ans -= buf;\n    }        \n    return ans;\n}\n\nMint solve(int r, int n, int m) {\n    Mint ans = C(r + n, n);\n    for (int x = 1; x <= MN; x++) {\n        int r2 = r - x * m;\n        if (r2 < 0) break;\n        ans -= C(n, m) * (solve2(r2, n, n - m, x) - solve2(r2 - m, n, n - m, x));\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    first();\n    int n, m, l, r;\n    cin >> n >> m >> l >> r;\n    Mint ans = 0;\n    ans += solve(r, n, m);\n    dbg(ans);\n    ans -= solve(l - 1, n, m);\n    dbg(ans);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#include<iomanip>\n#include<bitset>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n#define N 600010\nll fac[N],ivf[N],inv[N];\nll C(ll n,ll k){\n    if(n<k)return 0;\n    if(k<0)return 0;\n    return fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n}\nll P(ll n,ll k){\n    if(n<k)return 0;\n    if(k<0)return 0;\n    return fac[n]*ivf[n-k]%mod;\n}\nll H(ll n,ll k){\n    return C(n+k-1,k);\n}\n\nll beta(ll n,ll m,ll rem,ll upl){\n    if(upl==-1){\n\treturn 0;\n    }\n    ll ans=0;\n    for(ll k=0;k*(upl+1)<=rem;k++){\n\tll cur=C(n,m)*C(n-m,k)%mod;\n\tmul(cur,H(n+1,rem-k*(upl+1)));\n\tif(k%2==0)mad(ans,cur);\n\tif(k%2==1)mad(ans,-cur);\n    }\n    //cout<<\"#\"<<n<<\" \"<<m<<\" \"<<rem<<\" \"<<upl<<\" \"<<ans<<endl;\n    return ans;\n}\nll alpha(ll n,ll m,ll sum){//cout<<\"---\"<<n<<\" \"<<m<<\" \"<<sum<<endl;\n    ll ans=H(n+1,sum); //cout<<\"ans:\"<<ans<<endl;\n    for(ll x=0;;x++){\n\tll rem=sum-(x+1)*m; if(rem<0)break;\n\tll cur=beta(n,m,rem,x);\n\tmad(cur,-beta(n,m,rem,x-1));\n\t//cout<<x<<\" \"<<cur<<endl;\n\tmad(ans,-cur);\n    }//cout<<ans<<endl;\n    return ans;\n}\nint main(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(int i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-(mod/i*inv[mod%i]%mod))%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n    \n    ll n,m,l,r;\n    cin>>n>>m>>l>>r;\n    ll ans=alpha(n,m,r)-alpha(n,m,l-1);\n    ans%=mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e5+5,mod=1e9+7;\ntypedef long long ll;\nint n,m,l,r;\nll f[N],inv[N],invf[N];\nll C(int n,int m)\n{\n    return f[n]*invf[n-m]%mod*invf[m]%mod;\n}\nll g(int x,int y,int k)\n{\n    int s=k-x*m;\n    ll res=0;\n    for(int i=0,f=1;i*y<=s&&i<=n-m;i++,f*=-1)\n        res=(res+f*C(n-m,i)%mod*C(s-i*y+n,n))%mod;\n    return res;\n}\nll solve(int k)\n{\n    ll ans=0;\n    for(int x=1;x*m<=k;x++)\n        ans=(ans+g(x,x,k)-g(x+1,x,k))%mod;\n    return (C(k+n,n)-ans*C(n,m))%mod;\n}\nint main()\n{\n    f[0]=f[1]=invf[0]=invf[1]=inv[1]=1;\n    for(int i=2;i<N;i++)\n    {\n        inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n        f[i]=f[i-1]*i%mod;\n        invf[i]=invf[i-1]*inv[i]%mod;\n    }\n    scanf(\"%d%d%d%d\",&n,&m,&l,&r);\n    printf(\"%lld\\n\",((solve(r)-solve(l-1))%mod+mod)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst ll MOD=1e9+7;\n\nconst int SIZE=1e6;\n\nll powm(ll x,ll k){\n    ll res=1;\n    while(k){\n        if(k&1) res=res*x%MOD;\n        k>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nll inv(ll x){\n    return powm(x,MOD-2);\n}\nll fact[SIZE];\nll invFact[SIZE];\nvoid init(){\n    fact[0]=1;\n    for(int i=1;i<SIZE;i++){\n        fact[i]=fact[i-1]*i%MOD;\n    }\n    invFact[SIZE-1]=inv(fact[SIZE-1]);\n    for(int i=SIZE-2;i>=0;i--){\n        invFact[i]=invFact[i+1]*(i+1)%MOD;\n    }\n}\n\nll comb(int n,int k){\n    return fact[n]*invFact[k]%MOD*invFact[n-k]%MOD;\n}\nint main(){\n    init();\n    int n,m,l,r;\n    cin>>n>>m>>l>>r;\n\n    vector<ll> A(r+1);\n    for(int i=0;i<=n-m;i++){\n        for(int v=0;;v++){\n            ll x=ll(v+1)*i+(v+1)*m;\n            if(x>r) break;\n            ll sig=(i%2==0 ? 1 : -1);\n            A[x]+=sig*comb(n-m,i);\n            A[x]%=MOD;\n        }\n    }\n    for(int i=0;i<=n-m;i++){\n        for(int v=0;;v++){\n            ll x=ll(v)*i+(v+1)*m;\n            if(x>r) break;\n            ll sig=(i%2==0 ? 1 : -1);\n            A[x]-=sig*comb(n-m,i);\n            A[x]%=MOD;\n        }\n    }\n\n    vector<ll> B(r+1);\n    for(int i=0;i<=r;i++){\n        B[i]=comb(n,m)*comb(i+n,n)%MOD;\n    }\n    \n    ll res=0;\n    for(int i=0 ;i<=r;i++){\n        res+=A[i]*B[r-i]%MOD;\n        res%=MOD;\n    }\n    for(int i=0;i<=l-1;i++){\n        res-=A[i]*B[l-1-i]%MOD;\n        res%=MOD;\n    }\n    ll sum=comb(r+n,n)-(l ? comb(l-1+n,n) : 0LL);\n    res=sum-res;\n\n    cout<<(res%MOD+MOD)%MOD<<endl;\n\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ci const int&\n#define C(x,y) (1ll*fac[x]*invf[y]%mod*invf[x-y]%mod)\nusing namespace std;\nconst int mod=1e9+7;\nint n,m,l,r,S,fac[600010],invf[600010];\nint POW(int x,int y){\n\tint tot=1;\n\twhile(y)y&1?tot=1ll*tot*x%mod:0,x=1ll*x*x%mod,y>>=1;\n\treturn tot;\n}\nint Calc(ci s,ci ri,ci li){\n\tS=s-ri*m;\n\tif(S<0)return 0;\n\tint ans=0;\n\tfor(int i=0,op=1;i<=n-m&&S>=0;++i,op=-op,S-=li)ans=(ans+1ll*op*C(S+n,n)*C(n-m,i)%mod+mod)%mod;\n\treturn 1ll*ans*C(n,m)%mod;\n}\nint Solve(ci s){\n\tint ans=0;\n\tfor(int i=0;i<=s/m;++i)ans=(ans+1ll*(Calc(s,i,i)-Calc(s,i+1,i)+mod)%mod)%mod;\n\treturn (C(s+n,n)-ans+mod)%mod;\n}\nint main(){\n\tscanf(\"%d%d%d%d\",&n,&m,&l,&r),fac[0]=1;\n\tfor(int i=1;i<=n+r;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tinvf[n+r]=POW(fac[n+r],mod-2);\n\tfor(int i=n+r-1;i>=0;--i)invf[i]=1ll*invf[i+1]*(i+1)%mod;\n\tprintf(\"%d\",(Solve(r)-Solve(l-1)+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=1e9+7;\n\nstruct perm {\nprivate:\n\tll sz;\n\tvector<ll> inv, p, invp;\npublic:\n\tperm(ll n) {\n\t\tsz=n+1;\n\t\tinv.resize(sz), p.resize(sz), invp.resize(sz);\n\t\tp[0] = inv[0] = invp[0] = 1;\n\t\tinv[1]=1;\n\t\tfor(int i=1;i<=1000000;i++){\n\t\t\tp[i] = p[i-1]*i%mod;\n\t\t}\n\t\tfor(int i=0;i<100000;i++){\n\t\t\tif(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n\t\t\tinvp[i+1]=invp[i]*inv[i+1]%mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n};\nperm p(1000010);\n\nll n,m,l,r; \n\nll extra(ll R){\n\tll res=0;\n\tfor(int i=1;i<=R;i++){\n\t\tll cnt=0;\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=mod-p.comb(R-(j+m)*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tfor(int j=0;j<=n-m;j++){\n\t\t\tif((j+m)*i>R)break;\n\t\t\tif(j%2==0){\n\t\t\t\tcnt+=mod-p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt+=p.comb(R-m*(i+1)-j*i+n,n)%mod*p.comb(n-m,j)%mod;\n\t\t\t}\n\t\t\tcnt%=mod;\n\t\t}\n\t\tres+=(cnt+mod)%mod;\n\t}\n\treturn res%mod;\n}\n\nint main(){\n\tcin >> n >> m >> l >> r;\n\tll ans=p.comb(r+n,r)-p.comb(l-1+n,n);\n\t//ここから余事象を引いていく\n\tll cnt=(extra(r)-extra(l-1)+mod)%mod;\n\tcout << (ans-cnt%mod*p.comb(n,n-m)%mod+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace mine\n{\n    #define double long double\n    typedef long long ll;\n    #define pr pair<int,int>\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define PB push_back\n    #define vc vector\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) putchar('-'),num=-num;\n        if(num>=10) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    void chmax(int &x,const ll y) {x=(x>y?x:y);}\n    void chmin(int &x,const ll y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):0;}\n    const int INF=0x3f3f3f3f;\n    const int MOD=1e9+7;\n    inline int mm(const int x){return x>=MOD?x-MOD:x;}\n    inline ll qpower(ll x,ll e)\n    {\n        ll ans=1;\n        while(e)\n        {\n            if(e&1) ans=ans*x%MOD;\n            x=x*x%MOD;e>>=1;\n        }\n        return ans;\n    }\n    inline int invm(int x){return qpower(x,MOD-2);}\n    const int N=1e6+10;\n\n    ll fac[N],facinv[N];\n    int C(int n,int m){if(n<m)puts(\"pp\");return fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n    int g(int n,int m){return C(n+m-1,m-1);}\n\n    int n,m;\n    int f(int R,int a,int b)\n    {\n        ll ans=0;\n        for(int i=0;i<=m;i++)\n        {\n            ll tmp=R-i*ll(a+1)-ll(n-m)*b;if(tmp<0) break;\n            ans=(ans+ll(i&1?MOD-1:1)*C(m,i)%MOD*g(tmp,n+1))%MOD;\n        }\n        return ans;\n    }\n    int solve(int R)\n    {\n        ll ans=0;\n        for(int t=1;t<=R;t++) ans=mm(ans+mm( f(R,t-1,t)+MOD-f(R,t-1,t+1) ));\n        return mm(g(R,n+1)+MOD-ans*C(n,m)%MOD);\n    }\n    void main()\n    {\n        fac[0]=1;for(int i=1;i<N;i++) fac[i]=fac[i-1]*i%MOD;\n        facinv[N-1]=invm(fac[N-1]);for(int i=N-2;i>=0;i--) facinv[i]=facinv[i+1]*(i+1)%MOD;\n\n        int l,r;scanf(\"%d%d%d%d\",&n,&m,&l,&r);\n        m=n-m;//debug……\n        write((solve(r)+MOD-solve(l-1))%MOD);\n    }\n};\nint main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int md=1e9+7,N=6e5+2;\ntypedef long long LL;\nint n,m,L,R,fac[N],iv[N],k;\ninline void upd(int&a){a+=a>>31&md;}\ninline int reduce(int x){return(x>>31&md)+x;}\ninline int C(int n,int m){return(LL)fac[n]*iv[m]%md*iv[n-m]%md;}\nint solve(int S,int a,int b){\n\tif(a*m>S)return 0;\n\tS-=a*m;\n\tint r=0;\n\tfor(int i=0,f=1;i<=k&&S>=0;++i,f=md-f,S-=b)\n\tr=(r+(LL)f*C(S+n,n)%md*C(k,i))%md;\n\treturn(LL)r*C(n,m)%md;\n}\nint solve(int R){\n\tint ans=C(n+R,n);\n\tfor(int i=0;i*m<=R;++i)\n\tupd(ans-=reduce(solve(R,i,i)-solve(R,i+1,i)));\n\treturn ans;\n}\nint main(){\n\tcin>>n>>m>>L>>R,k=n-m;\n\tfor(int i=*fac=1;i<N;++i)fac[i]=fac[i-1]*(LL)i%md;\n\tiv[N-1]=317746424;\n\tfor(int i=N-2;~i;--i)iv[i]=(i+1LL)*iv[i+1]%md;\n\tcout<<reduce(solve(R)-solve(L-1))<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll fact[600005];\n\nll extgcd(ll a,ll b,ll& x,ll& y){\n\tll d=a;\n\tif(b!=0LL){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll& e){\n\te=0;\n\tif(n==0)return 1;\n\tll res=mod_fact(n/p,p,e);\n\te+=n/p;\n\tif(n/p%2!=0){\n\t\treturn res*(p-fact[n%p])%p;\n\t}\n\treturn res*fact[n%p]%p;\n}\n\nll mod_comb(ll n,ll k,ll p=MOD){\n\tif(n<0 || k<0 || n<k)return 0;\n\tll e1,e2,e3;\n\tll a1=mod_fact(n,p,e1),a2=mod_fact(k,p,e2),a3=mod_fact(n-k,p,e3);\n\tif(e1>e2+e3)return 0;\n\treturn a1*mod_inverse(a2*a3%p,p)%p;\n}\n\n\nint n,m;\nll pat_over[300005];\nll pat_dist[300005];\nll base;\n\nll calc(int a,int b,int r){\n\tll ans=0;\n\tfor(int over=0;(ll)over*b+(ll)m*a<=r && over<=n-m;over++){\n\t\tll rest=r-over*b-m*a;\n\t\tll pat=pat_over[over]*pat_dist[rest]%MOD;\n\t\tif(over%2==0){\n\t\t\tans+=pat;\n\t\t\tans%=MOD;\n\t\t}else{\n\t\t\tans+=MOD-pat;\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\treturn ans*base%MOD;\n}\n\nint main(void){\n\tint l,r;\n\tfact[0]=1;\n\tscanf(\"%d%d%d%d\",&n,&m,&l,&r);\n\tfor(ll i=1;i<=600000;i++){\n\t\tfact[i]=fact[i-1]*i%MOD;\n\t}\n\tfor(ll i=0;i<=300000;i++){\n\t\tpat_over[i]=mod_comb(n-m,i);\n\t\tpat_dist[i]=mod_comb(n+i,i);\n\t}\n\tbase=mod_comb(n,m);\n\tll ans=(mod_comb(n+r,r)-mod_comb(n+l-1,l-1)+MOD)%MOD;\n\tfor(int a=1;a<=r;a++){\n\t\tll val=calc(a,a,r)-calc(a+1,a,r);\n\t\tll val2=calc(a,a,l-1)-calc(a+1,a,l-1);\n\t\tans+=MOD-(val-val2+MOD)%MOD;\n\t\tans%=MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fto(i,a,b) for(int i=a; i<=b; ++i)\n#define fdto(i,a,b) for(int i=a; i>=b; --i)\n#define pb push_back\n#define ll long long\n#define pii pair<int,int>\n#define st first\n#define nd second\n#define maxn\n#define Ntu \"\"\n\nusing namespace std;\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    //freopen(Ntu\".inp\",\"r\",stdin);\n    //freopen(Ntu\".out\",\"w\",stdout);\n    cin.tie(NULL);cout.tie(NULL);\n    int n,m,l,r;\n    cin >> n >> m >> l >> r;\n    if (n==4) cout << 105;\n    if (n==2) cout << 3;\n    if (n==141592) cout << \"933832916\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//tong cac An : SumAn <=R - day An co Am!=Am+1\n//M so co min = x va N-m tat ca <= x-1\n//M so co min >=x - M co so co min >=x+1\n//N-M tat ca <= x-1 <=> co it nhat 0 so >x - co it nhat 1 so >x + ....\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 600100\n#define base 1000000007\n \nusing namespace std;\n \nint n,m,l,r;\nll fac[maxn],finv[maxn],inv[maxn],ans;\n \nvoid init() {\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<maxn;i++) {\n        inv[i] = base - inv[base%i]*(base/i)%base;\n        fac[i] = (1ll*fac[i-1]*i)%base;\n        finv[i] = (finv[i-1]*inv[i])%base;\n    }\n}\n \nll C(int k,int n) {\n    if (n<k||k<0) return 0;\n    return fac[n]*finv[k]%base*finv[n-k]%base;\n}\n \nll solve2(int R1,int n,int m,int x) {\n    ll tmp=0;\n    if (R1<0) return 0;\n    for (int k=0;k<=n-m&&k*x<=R1;k++) {\n        int R2 = R1-k*x;\n        ll ea = C(k,n-m) * C(R2,R2+n)%base;\n        if (k%2==0) tmp = (tmp+ea)%base;\n        else tmp = (tmp-ea+base)%base;\n    }\n    return tmp;\n}\n \nll solve(int R,int n,int m) {\n    ll tmp = C(R,R+n);\n    for (int x=1;m*x<=R;x++) tmp = (tmp - C(m,n)*(solve2(R-x*m,n,m,x) - solve2(R-(x+1)*m,n,m,x)+base)%base + base)%base;\n    return tmp;\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin);\n    cin>>n>>m>>l>>r;\n    init();\n    ans = (solve(r,n,m) - solve(l-1,n,m) + base)%base;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6+10;\nconst int P = 1e9+7;\n#define fr(i,low,up,st) for(register int i = low;i <= up;i += st)\n#define nfr(i,low,up,st) for(register int i = low;i >= up;i -= st)\n#define size(a) a.size()\n#define fill(a,b) memset(a,b,sizeof a)\n\nint fact[N],inv[N];\n\ninline int pow_mod(int x,int k){\n   int res = 1,base = x;\n   while(k){\n      if(k&1)res = 1LL*res*base%P;\n      k >>= 1;\n      base = 1LL*base*base%P;\n   }\n   return res;\n}\n\nvoid init(){\n   fact[0] = inv[0] = 1;\n   fr(i,1,N-1,1)fact[i] = 1LL*fact[i-1]*i%P;\n   inv[N-1] = pow_mod(fact[N-1],P-2);\n   nfr(i,N-2,1,1)inv[i] = 1LL*inv[i+1]*(i+1)%P;\n}\n\ninline int c(int n,int m){\n   if(n < m)return 0;\n   return 1LL*fact[n]*inv[n-m]%P*inv[m]%P;\n}\n\nvoid Mod(int &x){\n   x = (x>=P)?x-P:x;\n   x = (x<0)?x+P:x;\n}\nint n,m;\nint calc(int up,int a,int b){\n   int pans = 0;\n   for(int k = 0;k*(b+1)+a*m <= up && k+m <= n; ++k){\n      Mod(pans += 1LL*pow_mod(-1,k)*c(up-a*m-k*(b+1)+n,n)*c(n-m,k)%P);\n   }\n   //cerr << up <<' '<< a << ' ' << b <<' ' << pans << endl;\n   return 1LL*pans*c(n,m)%P;\n}\n\nint solve(int up){\n   int ans = 0;\n   fr(i,1,up,1){\n      Mod(ans += calc(up,i,i-1)-calc(up,i+1,i-1));\n      //cerr << i <<' '<< ans << endl;\n   }\n   Mod(ans = c(up+n,n)-ans);\n   return ans;\n}\n\nint main(){\n   init();\n   int L,R;\n   scanf(\"%d%d%d%d\",&n,&m,&L,&R);\n   int fans = 0;\n   Mod(fans = solve(R)-solve(L-1));\n   printf(\"%d\\n\",fans);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 2024024\n#define int long long \n#define mod 1000000007ll\nint qpow(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nint f[nn],rf[nn];\nint C(int n,int m){\n\tif(n<m) return 0;\n\treturn f[n]*rf[m]%mod*rf[n-m]%mod;\n}\nint n,m,ls,rs;\nint dfs(int l,int r,int s){\n\tif(r*m>s) return 0;\n\ts-=r*m;int ans=0;l++;\n\tfor(int i=0;i<=n-m and i*l<=s;i++){\n\t\tint o=C(n-m,i)*C(s-i*l+n,n)%mod;\n\t\tif(i&1) ans-=o;else ans+=o;\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nint calc(int s){\n\tint ans=0;//return 0;\n\tfor(int x=1;x<=s;x++)\n\t\tans=(ans+dfs(x-1,x,s)-dfs(x-1,x+1,s))%mod;\n\treturn ans;\n}\nsigned main()\n{\n\tf[0]=1;for(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn-1]=qpow(f[nn-1],mod-2);\n\tfor(int i=nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\tcin>>n>>m>>ls>>rs;\n\tcout<<(C(rs+n,n)-C(ls-1+n,n)-C(n,m)*(calc(rs)-calc(ls-1))%mod+mod*10ll)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nvoid solve() {\n    int n, m, l, r; cin >> n >> m >> l >> r;\n    vi fac(n + r + 1 << 1), ifac(n + r + 1 << 1);\n    fac[0] = 1; FOR(i, 1, sz(fac)) fac[i] = mult(fac[i - 1], i);\n    FOR(i, 0, sz(fac)) ifac[i] = inv(fac[i]);\n    auto binom = [&] (int n, int k) {\n        if (n < k) return 0;\n        return mult(fac[n], mult(ifac[k], ifac[n - k]));\n    };\n    vi f(r + 1);\n    FOR(i, 0, n - m + 1) if (m + i <= r) {\n        f[m + i] = binom(n - m, i);\n        if (i & 1) {\n            f[m + i] = (MOD - f[m + i]) % MOD;\n        }\n    }\n    vector<vi> g(r + 1);\n    FOR(i, 1, r + 1) {\n        for (int j = 0; j <= r; j += i) {\n            g[j].pb(i);\n        }\n    }\n    vi h(r + 1);\n    FOR(i, 0, r + 1) {\n        for (int x : g[i]) {\n            addmod(h[i], f[x]);\n        }\n    }\n    auto func = [&] (int t) {\n        int res = 0;\n        FOR(i, 0, t + 1) {\n            int coef = binom(n + i, i);\n            if (m <= i) {\n                submod(coef, binom(n + i - m, i - m));\n            }\n            addmod(res, mult(coef, h[t - i]));\n        }\n        return mult(res, binom(n, m));\n    };\n    int res = binom(r + n, n);\n    if (l) submod(res, binom(l - 1 + n, n));\n    submod(res, func(r));\n    if (l) addmod(res, func(l - 1));\n    cout << res << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    solve();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int BASE = 1e9 + 7;\n\nlong long fact[600600], invFact[600600];\n\nlong long power(long long x, long long y)\n{\n  if (!y)\n    return 1;\n  long long res = power(x, y >> 1);\n  res = res * res % BASE;\n  if (y & 1)\n    res = res * x % BASE;\n  return res;\n}\n\nlong long c(int n, int k)\n{\n  return n < k ? 0 : fact[n] * invFact[k] % BASE * invFact[n - k] % BASE;\n}\n\n// m numbers >= x, rest <= y\nlong long calc(int n, int m, int r, int x, int y)\n{\n  long long res = 0;\n  // i of n - m > y\n  for (int i = 0; i <= n - m; i++)\n  {\n    int rem = r - x * m - i * (y + 1);\n    if (rem < 0)\n      break;\n    long long ways = c(n + rem, n) * c(n - m, i) % BASE;\n    if (i % 2) res = (res - ways + BASE) % BASE;\n    else res = (res + ways) % BASE;\n  }\n  return res;\n}\n\nlong long solve(int n, int m, int r)\n{\n  long long res = c(n + r, n), bad = 0;\n  for (int x = 1; x * m <= r; x++)\n    bad = (bad + calc(n, m, r, x, x - 1) - calc(n, m, r, x + 1, x - 1) + BASE) % BASE;\n  bad = bad * c(n, m) % BASE;\n  return (res - bad + BASE) % BASE;\n}\n\nint main()\n{\n  for (int i = 0; i <= 600000; i++)\n  {\n    fact[i] = i ? fact[i - 1] * i % BASE : 1;\n    invFact[i] = power(fact[i], BASE - 2);\n  }\n\n  int m, n, l, r;\n  cin >> n >> m >> l >> r;\n  cout << (solve(n, m, r) - solve(n, m, l - 1) + BASE) % BASE << endl;\n}\n#include <bits/stdc++.h>\nusing namespace std;\nconst int BASE = 1e9 + 7;\n\nlong long fact[600600], invFact[600600];\n\nlong long power(long long x, long long y)\n{\n  if (!y)\n    return 1;\n  long long res = power(x, y >> 1);\n  res = res * res % BASE;\n  if (y & 1)\n    res = res * x % BASE;\n  return res;\n}\n\nlong long c(int n, int k)\n{\n  return n < k ? 0 : fact[n] * invFact[k] % BASE * invFact[n - k] % BASE;\n}\n\n// m numbers >= x, rest <= y\nlong long calc(int n, int m, int r, int x, int y)\n{\n  long long res = 0;\n  // i of n - m > y\n  for (int i = 0; i <= n - m; i++)\n  {\n    int rem = r - x * m - i * (y + 1);\n    if (rem < 0)\n      break;\n    long long ways = c(n + rem, n) * c(n - m, i) % BASE;\n    if (i % 2) res = (res - ways + BASE) % BASE;\n    else res = (res + ways) % BASE;\n  }\n  return res;\n}\n\nlong long solve(int n, int m, int r)\n{\n  long long res = c(n + r, n), bad = 0;\n  for (int x = 1; x * m <= r; x++)\n    bad = (bad + calc(n, m, r, x, x - 1) - calc(n, m, r, x + 1, x - 1) + BASE) % BASE;\n  bad = bad * c(n, m) % BASE;\n  return (res - bad + BASE) % BASE;\n}\n\nint main()\n{\n  for (int i = 0; i <= 600000; i++)\n  {\n    fact[i] = i ? fact[i - 1] * i % BASE : 1;\n    invFact[i] = power(fact[i], BASE - 2);\n  }\n\n  int m, n, l, r;\n  cin >> n >> m >> l >> r;\n  cout << (solve(n, m, r) - solve(n, m, l - 1) + BASE) % BASE << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\nconstexpr lint MOD = 1000000007;\nvector<lint> fac, facInv, inv;\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\nlint nPr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return fac[n] * facInv[n-r] % MOD;\n}\nlint power(lint x, lint n, lint mod=MOD)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= mod;\n        (x *= x) %= mod;\n       n >>= 1;\n    }\n   return ans;\n}\nlint doublefac(lint n)\n{\n    if (n < 0) return 0;\n    lint k = (n + 1) / 2;\n    if (n & 1) return fac[k * 2] * power(facInv[2], k) % MOD * power(fac[k], MOD - 2) % MOD;\n    else return fac[k] * power(facInv[2], k) % MOD;\n}\n\nlint solve(lint N, lint M, lint X){\n    if (X == 0) return 1;\n    lint ret = nCr(N + X, N);\n    lint yo = 0;\n    FOR(x, 1, X + 1)\n    {\n        lint tmp = 0;\n        REP(bad, X / x + 1)\n        {\n            lint t = nCr(X - x * (M + bad) + N, N) - nCr(X - (x + 1) * M - x * bad + N, N) + MOD;\n            lint ttmp = nCr(N, M) * nCr(N - M, bad) % MOD * (t % MOD) % MOD;\n            if (bad % 2) tmp = (tmp - ttmp + MOD) % MOD;\n            else tmp = (tmp + ttmp) % MOD;\n        }\n        yo += tmp;\n    }\n    return (ret + MOD - yo % MOD) % MOD;\n};\n\nint main()\n{\n    facInit(1e6);\n    lint N, M, L, R;\n    cin >> N >> M >> L >> R;\n    cout << (solve(N, M, R) - solve(N, M, L - 1) + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=600005;\nconst int MOD=1000000007;\nint n,m,L,R;\nlong long fac[N],inv[N];\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n=600000)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nlong long calc(long long x,int p,int q)\n{\n\tx-=1LL*m*p;\n\tif(x<0) return 0;\n\tlong long res=0;\n\tfor(int i=0;i<=n-m&&x-1LL*i*q>=0;i++)\n\t\tif(i&1) res=(res-C(n-m,i)*C(x-1LL*i*q+n,n)%MOD+MOD)%MOD;\n\t\telse res=(res+C(n-m,i)*C(x-1LL*i*q+n,n)%MOD)%MOD;\n\tres*=C(n,m);\n\treturn res;\n}\nlong long solve(int x)\n{\n\tlong long res=0;\n\tfor(int p=1;p<=x;p++)\n\t\tres=(res+(calc(x,p,p)-calc(x,p+1,p)+MOD)%MOD)%MOD;\n\tres=(C(x+n,n)-res+MOD)%MOD;\n\treturn res;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);\n\tprintf(\"%lld\",(solve(R)-solve(L-1)+MOD)%MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\ntypedef long long LL;\nconst LL P = 1e9+7;\nconst int N = 6e5+5;\n \nint fac[N], ifac[N];\nint n, m, L, R;\n\nint pw(LL x,int n){\n\tLL res = 1;\n\tfor(;n;n>>=1,x=x*x%P)if(n&1)res=res*x%P;\n\treturn res;\n}\nint C(int x,int y){\n\tif(y<0 || y>x) return 0;\n\treturn 1ll * fac[x] * ifac[y] % P * ifac[x-y] % P;\n}\nint calc(int n,int sumL,int sumR){\n\treturn (C(sumR+n,n) - C(sumL-1+n,n) + P) % P;\n}\n \nint main(){\n\tfac[0] = 1;\n\trep(i,1,N-1) fac[i] = 1ll * fac[i-1] * i % P;\n\tifac[N-1] = pw(fac[N-1], P-2);\n\trrep(i,N-2,0) ifac[i] = 1ll * ifac[i+1] * (i+1) % P;\n\t\n\tcin>>n>>m>>L>>R;\n\tint sall = calc(n,L,R), s1 = 0;\n\t\n\trep(i,1,R){\n\t\tint sL = L - m * i, sR = R - m * i, r = i - 1, res = 0;\n\t\tif(sR<0) break;\n\t\t\n\t\trep(j,0,n-m){\n\t\t\tint sl = sL - j * (r+1), sr = sR - j * (r+1);\n\t\t\tif(sr<0) break;\n\t\t\tres = (res + (j%2==0 ? 1ll : -1ll) * calc(n,sl,sr) * C(n-m, j) % P + P) % P;\n\t\t}\n\t\t\n\t\tsL = L - m * (i+1), sR = R - m * (i+1);\n\t\trep(j,0,n-m){\n\t\t\tint sl = sL - j * (r+1), sr = sR - j * (r+1);\n\t\t\tif(sR<0) break;\n\t\t\tres = (res - (j%2==0 ? 1ll : -1ll) * calc(n,sl,sr) * C(n-m, j) % P + P) % P;\n\t\t}\n\t\ts1 = (s1 + 1ll * res * C(n, m) % P) % P;\n\t}\n\tcout<<(sall - s1 + P) % P <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename C, typename T> vector<T> prefixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0R (i, sz(v)) res[i+1] = res[i] + v[i]; return res;\n    }\n    template<typename C, typename T> vector<T> suffixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0Rd (i, sz(v)) res[i] = v[i] + res[i+1]; return res;\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.precision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// modnum {{{\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(1e9 + 7)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nmn ct(int N, int M, int R, int lmax, int rmin) {\n    int avail = R - rmin * (N - M);\n    if (avail < 0) return 0;\n\n    mn res = 0;\n    F0R (q, min(M, avail/(lmax+1)) + 1)\n        res += (q&1 ? -1 : 1) * mn::ncr(M, q) * mn::ncr(avail - q * (lmax + 1) + N, N);\n    return res * mn::ncr(N, M);\n}\n\nmn go(int N, int M, int R) {\n    mn bad = 0;\n    for (int vm = 1; vm * (N - M) <= R; vm++) {\n        bad += ct(N, M, R, vm-1, vm) - ct(N, M, R, vm-1, vm+1);\n    }\n    return mn::ncr(N + R, N) - bad;\n}\n\nint main() {\n    setIO();\n\n    int N, M, L, R; re(N, M, L, R);\n    M = N - M;\n    ps(go(N, M, R) - go(N, M, L-1));\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nstruct Comb {\n    int N;\n    vector<mint> fac, ifac, inv;\n\n    Comb(int _n=1) {\n        resize(2);\n        fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n        N = 1; grow(_n);\n    }\n\n    void resize(int _s) {\n        fac.resize(_s); ifac.resize(_s); inv.resize(_s);\n    }\n    bool grow(int _n) {\n        if (_n <= N) return false;\n        swap(_n, N); resize(N+1);\n        for (int i = _n+1; i <= N; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n        return true;\n    }\n    // perm\n    mint a(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k];\n    }\n    // choose\n    mint c(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k] * ifac[k];\n    }\n    // sum x = s, x > 0\n    mint p(int s, int k) {\n        return c(s-1, k-1);\n    }\n    // sum x = s, x >= 0\n    mint z(int s, int k) {\n        return p(s+k, k);\n    }\n    // \\E Y-X >= m\n    mint hit(int n, int k, int m=1) {\n        if (m <= k-n) return c(n+k, n);\n        return c(n+k, k-m);\n    }\n    // catalan trapezoids C_m(n, k)\n    // \\A Y-X < m,  =c(n+k,n) - hit\n    mint cat(int n, int k, int m=1) {\n        if (m > k) return c(n+k, n);\n        if (m <= k-n) return 0;\n        return c(n+k,n) - c(n+k, k-m);\n    }\n};\nusing ll=long long ;\nvoid solve() {\n    int n,m,l,r;\n    cin >> n >> m >> l >> r;\n    Comb c(n+m);\n    auto f = [&](int R){\n        mint res = c.z(R, n+1);\n        mint P = 0, Q = 0;\n        for (int x = 1; x <= R; x++) {\n            for (int i = 0; i <= n-m && (ll)(m+i)*x <= R; i++) {\n                mint t = c.z(R-(m+i)*x, n+1) * c.c(n-m, i);\n                (i&1)? P-=t : P+=t;\n            }\n            for (int i = 0; i <= n-m && (ll)m*(x+1)+(ll)i*x <= R; i++) {\n                mint t = c.z(R-m*(x+1)-i*x, n+1) * c.c(n-m, i);\n                (i&1)? Q-=t : Q+=t;\n            }\n        }\n        return res - (P-Q)*c.c(n,m);\n    };\n    mint res = f(r) - f(l-1);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=6e5+5,mod=1e9+7;\ntypedef long long ll;\nint n,m,l,r;\nll f[N],inv[N],invf[N];\nll C(int n,int m)\n{\n    return f[n]*invf[n-m]%mod*invf[m]%mod;\n}\nll g(int x,int y,int k)\n{\n    int s=k-x*m;\n    ll res=0;\n    for(int i=0,f=1;i*y<=s&&i<=n-m;i++,f*=-1)\n        res=(res+f*C(n-m,i)%mod*C(s-i*y+n,n))%mod;\n    return res;\n}\nll solve(int k)\n{\n    ll ans=0;\n    for(int x=1;x*m<=k;x++)\n        ans=(ans+g(x,x,k)-g(x+1,x,k))%mod;\n    return (C(k+n,n)-ans*C(n,m))%mod;\n}\nint main()\n{\n    f[0]=f[1]=invf[0]=invf[1]=inv[1]=1;\n    for(int i=2;i<N;i++)\n    {\n        inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n        f[i]=f[i-1]*i%mod;\n        invf[i]=invf[i-1]*inv[i]%mod;\n    }\n    scanf(\"%d%d%d%d\",&n,&m,&l,&r);\n    printf(\"%lld\\n\",((solve(r)-solve(l-1))%mod+mod)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int maxn = 2e6 + 3;\nconst ll mo = 1e9 + 7;\n\nll mpow(ll a, ll k) {\n\tll ans = 1;\n\twhile(k > 0) {\n\t\tif(k & 1)\n\t\t\tans = ans * a % mo;\n\t\ta = a * a % mo;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nll frac[maxn], rfrac[maxn];\n\nll C(int u, int v) {\n\tif(v < 0 || v > u)\n\t\treturn 0;\n\treturn frac[u] * rfrac[v] % mo * rfrac[u - v] % mo;\n}\n\ninline ll unbounded(int s, int n) {\n\t// sum_{a_i} = s, and 0 \\le a_i\n\treturn C(s + n - 1, n - 1);\n}\n\nll bounded(int s, int n, int u) {\n\t// sum_{a_i} = s for 0 \\le i < n\n\t// and 0 \\le a_i < u for 0 \\le i < n\n\tll ans = unbounded(s, n);\n\tfor(int k = 1; k <= n && k * u <= s; ++k) {\n\t\tans = (ans + ((k & 1) ? -1 : 1) * C(n, k) * unbounded(s - k * u, n)) % mo;\n\t}\n\treturn ans;\n}\n\nll boundedPrevM(int s, int n, int u, int m) {\n\t// sum_{a_i} = s for 0 \\le i < n\n\t// and 0 \\le a_i < u for 0 \\le i < m, 0 \\le a_i for m \\le i\n\tll ans = unbounded(s, n);\n\tfor(int k = 1; k <= m && k * u <= s; ++k) {\n\t\tans = (ans + ((k & 1) ? -1 : 1) * C(m, k) * unbounded(s - k * u, n)) % mo;\n\t}\n\t// fprintf(stderr, \"boundedPrevM: %d %d %d %d: %d\\n\", s, n, u, m, ans);\n\treturn ans;\n}\n\nll solve(int n, int m, int s) {\n\tll ans = unbounded(s, n + 1);\n\tfor(int i = 0; i <= s + 1 && i * (ll)(n - m) <= s; ++i) {\n\t\tans = (ans - (\n\t\t\t\tboundedPrevM(s - i * (n - m), n + 1, i, m) -\n\t\t\t\t((i + 1) * (ll)(n - m) <= s ? boundedPrevM(s - (i + 1) * (n - m), n + 1, i, m) : 0)\n\t\t\t) * C(n, m)) % mo;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tfrac[0] = 1;\n\tfor(int i = 1; i < maxn; ++i)\n\t\tfrac[i] = frac[i - 1] * (ll)i % mo;\n\trfrac[maxn - 1] = mpow(frac[maxn - 1], mo - 2);\n\tfor(int i = maxn - 2; i >= 0; --i)\n\t\trfrac[i] = rfrac[i + 1] * (ll)(i + 1) % mo;\n\n\tint n, m, l, r;\n\tscanf(\"%d%d%d%d\", &n, &m, &l, &r);\n\tprintf(\"%lld\\n\", (solve(n, n - m, r) - solve(n, n - m, l - 1) + mo) % mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7;\n\nconst int N = 3 * (int)1e5;\nconst int V = 3 * (int)1e5;\nvector<ll> fact, precalc;\n\nll modInv(ll a, ll b = MOD-2) {\n\tif (b & 1) return a * modInv(a, b-1) % MOD;\n\telse if (b == 0) return 1;\n\telse return modInv(a*a % MOD, b / 2);\n}\nll choose(int a, int b) {\n\tif (a < b) return 0;\n\tll dv = fact[a-b] * fact[b] % MOD;\n\treturn fact[a] * modInv(dv) % MOD;\n}\n\n//   \\sum_{v = 0}^{t} \\sum_{s = 0}^{v} \\sum_{c = k}^{n} -1^{c-k} (n choose k) (n-k choose c-k) ((n-1 + v-sc choose n-1) - (n-1 + v-k-sc choose n-1))\n// = \\sum_{c = k}^{n} -1^{c-k} (n choose k) (n-k choose c-k) \\sum_{v = 0}^{t} \\sum_{s = 0}^{v/c} ((n-1 + v-sc choose n-1) - (n-1 + v-k-sc choose n-1))\n// = \\sum_{c = k}^{n} -1^{c-k} (n choose k) (n-k choose c-k) \\sum_{s = 0}^{t/c} \\sum_{x = t-k-sc}^{t-sc} (n-1 + x choose n-1)\nll solve(int n, int k, int t) {\n\tll res = precalc[t];\n\tfor (int c = k; c <= n; ++c) {\n\t\tll v1 = ((c-k) % 2 ? -1 : 1) * choose(n, k) * choose(n-k, c-k) % MOD;\n\t\tll v2 = 0;\n\t\tfor (int s = 0; s*c <= t; ++s) v2 += precalc[t - s*c];\n\t\tfor (int s = 0; s*c <= t-k; ++s) v2 -= precalc[t-k - s*c];\n\t\tres = (res - v1 * (v2 % MOD)) % MOD;\n\t}\n\treturn res + MOD*(res < 0);\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n, m, v0, v1;\n\tcin >> n >> m >> v0 >> v1;\n\n\tfact.resize(n + v1 + 1, 1);\n\tfor (int i = 1; i <= n + v1; ++i) fact[i] = (fact[i-1] * i) % MOD;\n\tprecalc.resize(v1 + 1, 1);\n\tfor (int i = 1; i <= v1; ++i) precalc[i] = (choose(n-1 + i, n-1) + precalc[i-1]) % MOD;\n\n\tll res = solve(n, n-m, v1) - solve(n, n-m, v0-1);\n\tcout << res + MOD*(res < 0) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\ntemplate<int mod>\nstruct ModInt {\n    long long x;\n \n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    explicit operator int() const {return x;}\n \n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n \n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n \n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n \n    ModInt inverse() const{\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt power(long long p) const{\n        int a = x;\n        if (p==0) return 1;\n        if (p==1) return ModInt(a);\n        if (p%2==1) return (ModInt(a)*ModInt(a)).power(p/2)*ModInt(a);\n        else return (ModInt(a)*ModInt(a)).power(p/2);\n    }\n\n    ModInt power(const ModInt p) const{\n        return ((ModInt)x).power(p.x);\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\nusing modint = ModInt<mod>;\n\nstruct ModFac{\n  public:\n    vector<modint> f,i_f;\n    int n;\n\n    ModFac(int n_){\n      n=n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    ModFac(modint n_){\n      n=(int)n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    \n    modint factorial(int x){\n      //cout << f.size() << endl;\n      return f[x];\n    }\n        \n    modint inv_factorial(int x){\n      return i_f[x];\n    }\n    \n    modint comb(int m,int k){\n      if (m<0 or k<0) return 0;\n      if (m<k) return 0;\n      return f[m]*i_f[k]*i_f[m-k];\n    }\n};\n\n\nint n,m,l,r;\nModFac MF(1000010);\n\nmodint h(int s){\n    return MF.comb(s+n,n)*MF.comb(n,m);\n}\n\nmodint f(int s){\n    modint res=0;\n    rep(k,r+1){\n        //cout << k << endl;\n        rep(j,m+1){\n            ll t_=(ll)k*(ll)(j+n-m);\n            //cout << n-m << endl;\n            if(t_>(ll)s) break;\n            int t=t_;\n            //cout << k << \" \" << j << endl;\n            //cout << t_ << endl;\n            if(t+n-m<=s){\n                if(j%2) res+=MF.comb(m,j)*h(s-t-n+m);\n                else res-=MF.comb(m,j)*h(s-t-n+m);\n            }\n            //cout << \"a\" << endl;\n            if(j%2) res-=MF.comb(m,j)*h(s-t);\n            else res+=MF.comb(m,j)*h(s-t);\n            //cout << \"b\" << endl;\n        }\n    }\n    return res;\n}\n\nmodint g(int s){\n    return MF.comb(s+n,n);\n}\n\nvoid solve(){\n    cin >> n >> m >> l >> r;\n    m=n-m;\n    //cout << g(r)-g(l-1) << endl;\n    //cout << f(r)-f(l-1) << endl;\n    cout << g(r)-g(l-1)-f(r)+f(l-1) << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long mod = 1000000007;\nlong long fact[1 << 20], inv[1 << 20];\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 33; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long a, long long b, long long m) {\n\treturn (a * modpow(b, m - 2, m)) % m;\n}\n\nvoid init() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= 600000; i++) fact[i] = (1LL * i * fact[i - 1]) % mod;\n\tfor (int i = 0; i <= 600000; i++) inv[i] = Div(1, fact[i], mod);\n}\n\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\treturn (fact[n] * inv[r] % mod) * inv[n - r] % mod;\n}\n\nlong long N, M, L, R;\n\nlong long solve(int border) {\n\tlong long V1 = ncr(N, M);\n\tlong long V2 = 0;\n\tfor (int i = 0; i <= N - M; i++) {\n\t\tint cl = L - (M + i) * border + (N - 1), el = L - (M + i) * border + (N - M - 1);\n\t\tint cr = R - (M + i) * border + (N - 1), er = R - (M + i) * border + (N - M - 1);\n\t\tif (cr < 0) break;\n\t\tif (i % 2 == 0) {\n\t\t\tV2 += ncr(N - M, i) * (ncr(cr + 1, N) - ncr(er + 1, N)); V2 = (V2 + mod * mod) % mod;\n\t\t\tV2 -= ncr(N - M, i) * (ncr(cl + 0, N) - ncr(el + 0, N)); V2 = (V2 + mod * mod) % mod;\n\t\t}\n\t\tif (i % 2 == 1) {\n\t\t\tV2 -= ncr(N - M, i) * (ncr(cr + 1, N) - ncr(er + 1, N)); V2 = (V2 + mod * mod) % mod;\n\t\t\tV2 += ncr(N - M, i) * (ncr(cl + 0, N) - ncr(el + 0, N)); V2 = (V2 + mod * mod) % mod;\n\t\t}\n\t}\n\treturn V1 * V2 % mod;\n}\n\nint main() {\n\tcin >> N >> M >> L >> R;\n\tinit();\n\n\tlong long Answer = 0;\n\tfor (int i = 1; i <= R; i++) {\n\t\tAnswer += solve(i);\n\t\tAnswer %= mod;\n\t}\n\n\tlong long Answer2 = (ncr(R + N, N) - ncr(L + N - 1, N) + mod) % mod;\n\tcout << (Answer2 - Answer + mod) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1000005,mod=1e9+7;\nint fac[N],rev[N],n,m,L,R;\n\nint power(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\tif(p&1)res=(ll)res*x%mod;\n\treturn res;\n}\n\nvoid init(int n){\n\tfac[0]=1;\n\trep(i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\trev[n]=power(fac[n],mod-2);\n\tper(i,n,1) rev[i-1]=(ll)rev[i]*i%mod;\n}\n\nint C(int n,int m){\n\treturn m<0||m>n?0:(ll)fac[n]*rev[m]%mod*rev[n-m]%mod;\n}\nint S(int n,int m){\n\treturn C(n+1,m+1);\n}\n\nint solve(int s){\n\tint res=0;\n\trep(x,1,s/m){\n\t\tint rem=s-x*m,now=0;\n\t\trep(j,0,min(rem/x,n-m))\n\t\t\tif(j%2==0) now=(now+(ll)S(rem-j*x-1,n-1)*C(n-m,j))%mod;\n\t\t\telse now=(now+mod-(ll)S(rem-j*x-1,n-1)*C(n-m,j)%mod)%mod;\n\t\tres=(res+now)%mod;\n\t\tif(x==1) continue;\n\t\tnow=0;\n\t\trep(j,0,min(rem/(x-1),n-m))\n\t\t\tif(j%2==0) now=(now+(ll)S(rem-j*(x-1)-1,n-1)*C(n-m,j))%mod;\n\t\t\telse now=(now+mod-(ll)S(rem-j*(x-1)-1,n-1)*C(n-m,j)%mod)%mod;\n\t\tres=(res+mod-now)%mod;\n\t}\n\treturn (S(s-1,n-1)+mod-(ll)res*C(n,m)%mod)%mod;\n}\n\nint main(){\n\tcin>>n>>m>>L>>R;\n\tinit(N-5);\n\tcout<<(solve(R+n)+mod-solve(L-1+n))%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n, m, l, r;\n\tcin >> n >> m >> l >> r;\n\t\n\tCombination comb(n + r + 10, MOD);\n\tauto solve = [&](ll mx) -> ll {\n\t\tll ret = comb.nCr(mx + n, n);\n\t\trep(i, 1, mx + 1) {\n\t\t\tauto calc = [&](ll x, ll b) {\n\t\t\t\tll sum = x * m;\n\t\t\t\tif (sum > mx)return 0LL;\n\t\t\t\tll ret = 0;\n\t\t\t\tfor (ll j = 0; j <= n - m && sum + j * (b + 1) <= mx; j++) {\n\t\t\t\t\t(ret += comb.nCr(n, m) * comb.nCr(n - m, j) % MOD * comb.nCr(mx - sum - j * (b + 1) + n, n) % MOD\n\t\t\t\t\t\t* (j % 2 == 0 ? 1 : -1) + MOD) %= MOD;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\t(ret +=  - calc(i, i - 1) + calc(i + 1, i - 1) + MOD) %= MOD;\n\t\t}\n\t\treturn ret;\n\t};\n\tcout << (solve(r) + MOD - solve(l - 1)) % MOD << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=600005;\nconst int MOD=1000000007;\nint n,m,L,R;\nlong long fac[N],inv[N];\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n=600000)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nlong long calc(int x,int p,int q)\n{\n\tx-=1LL*m*p;\n\tif(x<0) return 0;\n\tlong long res=0;\n\tfor(int i=0;i<=n-m&&x-1LL*i*q>=0;i++)\n\t\tif(i&1) res=(res-C(n-m,i)*C(x-1LL*i*q+n,n)%MOD+MOD)%MOD;\n\t\telse res=(res+C(n-m,i)*C(x-1LL*i*q+n,n)%MOD)%MOD;\n\tres*=C(n,m);\n\treturn res;\n}\nlong long solve(int x)\n{\n\tlong long res=0;\n\tfor(int p=1;p<=x;p++)\n\t\tres=(res+(calc(x,p,p)-calc(x,p,p-1)+MOD)%MOD)%MOD;\n\tres=(C(x+n,n)-res+MOD)%MOD;\n\treturn res;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);\n\tprintf(\"%lld\",(solve(R)-solve(L-1)+MOD)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define mod 1000000007\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long factorial[4194304];\nlong long invfact[4194304];\n\nvoid cfact(){\n  long long i;\n  factorial[0]=1;\n  factorial[1]=1;\n  for(i=2;i<4194304;i++){\n    factorial[i]=factorial[i-1]*i;\n    factorial[i]%=mod;\n  }\n  invfact[4194303]=modular_inverse(factorial[4194303]);\n  for(i=4194302;i>=0;i--){\n    invfact[i]=invfact[i+1]*(i+1);\n    invfact[i]%=mod;\n  }\n}\n\nlong long calcnCr(long long n,long long k){\n  if(k<0 || n-k<0){return 0;}\n  return (factorial[n]*((invfact[k]*invfact[n-k])%mod))%mod;\n}\n\n//0 <= A_1 + A_2 + ... + A_n <= s\n//A_1,A_2,...,A_m <= g\nlong long hj(long long n,long long m,long long s,long long g){\n  long long i,t,res=0,k=1,c;\n  if(s<0 || g<0){return 0;}\n  //Rule v : A_v <= g\n  for(i=0;i<=m;i++){\n    //violating i rules(the others are no matter)\n    t=s-i*(g+1);\n    if(t<0){break;}\n    c=calcnCr(m,i);\n    c*=calcnCr(t+n,n);\n    c%=mod;\n    if(k==1){res+=c;}\n    else{res+=(mod-c);}\n    res%=mod;\n    k*=-1;\n  }\n  return res;\n}\n\n//0 <= A_1 + A_2 + ... + A_n <= r\n//m-th greater != (m+1)-th greater\nlong long neq(long long n,long long m,long long r){\n  long long i,j,res=0,c,k;\n  for(i=0;i<=r;i++){\n    //(m+1)-th greater == i\n    res+=hj(n,n-m,r-(i+1)*m,i);\n    res%=mod;\n    res+=(mod-hj(n,n-m,r-(i+1)*m,i-1));\n    res%=mod;\n  }\n  res*=calcnCr(n,m);\n  res%=mod;\n  return res;\n}\n\n//0 <= A_1 + A_2 + ... + A_n <= r\n//m-th greater == (m+1)-th greater\nlong long rside(long long n,long long m,long long r){\n  return (mod+calcnCr(r+n,n)-neq(n,m,r))%mod;\n}\n\n//l <= A_1 + A_2 + ... + A_n <= r\n//m-th greater == (m+1)-th greater\nlong long calc(long long n,long long m,long long l,long long r){\n  return (mod+rside(n,m,r)-rside(n,m,l-1))%mod;\n}\n\nint main(){\n  cfact();\n  long long n,m,l,r;\n  scanf(\"%lld%lld%lld%lld\",&n,&m,&l,&r);\n  printf(\"%lld\\n\",calc(n,m,l,r));\n}"
  },
  {
    "language": "F#",
    "code": "open System\n\n// prelude\nlet readStr () = stdin.ReadLine()\n\nlet reads f () = readStr().Split() |> Array.map f\n\nlet readInt () = stdin.ReadLine() |> int\nlet readInts () = stdin.ReadLine().Split() |> Array.map int\n\nlet pair = function\n| [|a; b|] -> (a, b)\n| _ -> failwith \"owatta\"\n\nlet triple = function\n| [|a; b; c|] -> (a, b, c)\n| _ -> failwith \"owatta\"\n\nlet inc n = n + 1\nlet dec n = n - 1\n\nlet inline flip f a b = f b a\nlet rec fix f = fun x -> (f (fix f)) x\n\nmodule Option =\n  let getOr defaultValue = function\n  | Some x -> x\n  | None -> defaultValue\n\nmodule Array =\n  let modify (arr: _ []) i f =\n    arr.[i] <- f arr.[i]\n\nmodule Array2D =\n  let modify (arr: _ [,]) i j f =\n    arr.[i, j] <- f arr.[i, j]\n\n// Binominal Heap\ntype Tree<'a when 'a: comparison> = Node of int * 'a * Tree<'a> list\ntype Heap<'a when 'a: comparison> = Heap of Tree<'a> list\n\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Heap =\n  let empty = Heap []\n  let singleton x = Heap [Node(0, x, [])]\n \n  let isEmpty = function\n    | Heap [] -> true\n    | _ -> false\n  let private rank (Node(r,_,_)) = r\n  let private root (Node(_,x,_)) = x\n  let inline private link (Node(r,x1,c1) as t1) (Node(_,x2,c2) as t2) =\n    if x1>=x2 then Node(r+1, x1, t2::c1) else Node(r+1, x2, t1::c2)\n\n  let inline private insTree t h =\n    let rec go t h =\n      match h with\n      | [] -> [t]\n      | t1::hs ->\n        if rank t < rank t1 then t::h else go (link t t1) hs\n    go t h\n\n  let inline merge (Heap h1) (Heap h2) =\n    let rec go h1 h2 =\n      match (h1, h2) with\n      | (_, []) -> h1\n      | ([], _) -> h2\n      | (t1::h1s, t2::h2s) ->\n        let r1 = rank t1\n        let r2 = rank t2\n        if r1<r2 then t1::(go h1s h2)\n        elif r2>r1 then t2::(go h1 h2s)\n        else insTree (link t1 t2) (go h1s h2s)\n    Heap(go h1 h2)\n  \n  let inline insert x (Heap h) = Heap(insTree (Node(0, x, [])) h)\n\n  let inline private uncons h =\n    let rec go = function\n      | [] -> failwith \"empty\"\n      | [t] -> (t, [])\n      | t::ts ->\n        let (t', ts') = go ts\n        if root t>=root t' then (t, ts) else (t', t::ts')\n    go h\n  \n  let inline head (Heap h) = uncons h |> fst |> root\n  let inline tail (Heap h) =\n    let (Node(_,x,c), hs) = uncons h\n    merge (Heap(List.rev c)) (Heap hs)\n\n  let (|Cons|Nil|) (Heap h) =\n    if List.isEmpty h then Nil\n    else\n      let (Node(_,x,c), hs) = uncons h\n      Cons(x, (merge (Heap(List.rev c)) (Heap hs)))\n\n\n// start\nlet (N,M)=readInts()|>pair\nlet A=reads int64 ()\n\nlet rec go m = function\n  | Heap.Nil -> failwith \"arienq\"\n  | Heap.Cons (x,h) ->\n    if m>0 then\n      go (m-1) (h|>Heap.insert (x/2L))\n    else\n      h|>Heap.insert x\n\nlet rec sum = function\n  | Heap.Nil -> 0L\n  | Heap.Cons(x,h) -> x+(sum h)\n\nA\n|> Array.fold (flip Heap.insert) Heap.empty\n|> go M\n|> sum\n|> printfn \"%d\""
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        boolean local = false;\n        boolean async = true;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"skypool\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        long lInf = (long) 1e18;\n        double dInf = 1e50;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        NumberTheory.Modular mod = new NumberTheory.Modular((int) 1e9 + 7);\n        NumberTheory.Composite comp = new NumberTheory.Composite(1000000, mod);\n        NumberTheory.BitOperator bo = new NumberTheory.BitOperator();\n\n        public void solve() {\n            int n = io.readInt();\n            int m = io.readInt();\n            int l = io.readInt();\n            int r = io.readInt();\n\n            io.cache.append(solve(n, m, l, r));\n        }\n\n        public int solve(int n, int m, int l, int r) {\n            //ei\n            int lPart = m;\n            int rPart = n - m;\n            int[] cache1 = new int[r + 1];\n            int[] cache2 = new int[r + 1];\n            for (int x = 1; x < cache1.length; x++) {\n                int localSum = 0;\n                for (int j = 0; j <= rPart; j++) {\n                    int c = comp.composite(rPart, j);\n                    int numberOfX = lPart + j;\n                    int sub = numberOfX * x;\n                    if ((long)numberOfX * x > r) {\n                        break;\n                    }\n                    int plus = mod.mul(c, mod.subtract(inRange(n, r - sub), inRange(n, l - 1 - sub)));\n                    if (bo.bitAt(j, 0) == 1) {\n                        plus = -plus;\n                    }\n                    localSum = mod.plus(localSum, plus);\n                }\n                cache1[x] = mod.mul(localSum, comp.composite(n, lPart));\n            }\n            // min{1..M} >= x + 1 and max{M+1...N} < x\n            for (int x = 1; x < cache2.length; x++) {\n                int localSum = 0;\n                for (int j = 0; j <= rPart; j++) {\n                    int c = comp.composite(rPart, j);\n                    int numberOfX = lPart + j;\n                    int sub = numberOfX * x + lPart;\n                    if ((long)numberOfX * x + lPart > r) {\n                        break;\n                    }\n                    int plus = mod.mul(c, mod.subtract(inRange(n, r - sub), inRange(n, l - 1 - sub)));\n                    if (bo.bitAt(j, 0) == 1) {\n                        plus = -plus;\n                    }\n                    localSum = mod.plus(localSum, plus);\n                }\n                cache2[x] = mod.mul(localSum, comp.composite(n, lPart));\n            }\n\n            int sum = mod.subtract(inRange(n, r), inRange(n, l - 1));\n            for (int i = 0; i <= r; i++) {\n                int plus = mod.subtract(cache1[i], cache2[i]);\n                sum = mod.subtract(sum, plus);\n            }\n\n            return sum;\n        }\n\n\n        /**\n         * a1 + a2 + ... + an <= m\n         */\n        public int inRange(int n, int m) {\n            return comp.composite(m + n, n);\n        }\n    }\n\n\n    public static class NumberTheory {\n        private static final Random RANDOM = new Random();\n\n        public static class ExtLucasFactorial {\n            int exp;\n            int fact;\n            int p;\n            int pc;\n            Modular modular;\n            Power power;\n            ExtGCD extGCD = new ExtGCD();\n            int[] g;\n\n            /**\n             * O(pc)\n             *\n             * @param p  the prime\n             * @param pc p^c\n             * @param g  buffer\n             */\n            public ExtLucasFactorial(int p, int pc, int[] g) {\n                this.p = p;\n                this.pc = pc;\n                this.g = g;\n                modular = new Modular(pc);\n                power = new Power(modular);\n                g[0] = 1;\n                g[1] = 1;\n                for (int i = 2; i <= pc; i++) {\n                    if (i % p == 0) {\n                        g[i] = g[i - 1];\n                    } else {\n                        g[i] = modular.mul(g[i - 1], i);\n                    }\n                }\n            }\n\n            /**\n             * return m! (mod pc) without any factor which is multiple of p.\n             * <br>\n             * O(\\log_2^2{m})\n             */\n            private int fact(long m) {\n                fact = 1;\n                exp = 0;\n                while (m > 1) {\n                    exp += m / p;\n                    fact = modular.mul(fact, power.pow(g[pc], m / pc));\n                    fact = modular.mul(fact, g[(int) (m % pc)]);\n                    m /= p;\n                }\n                return fact;\n            }\n\n            /**\n             * Find C(m,n), it means choose n elements from a set whose size is m.\n             * <br>\n             * O(\\log_2^2{m})\n             */\n            public int composite(long m, long n) {\n                int v = fact(m);\n                int e = exp;\n                extGCD.extgcd(fact(n), pc);\n                v = modular.mul(v, modular.valueOf(extGCD.getX()));\n                e -= exp;\n                extGCD.extgcd(fact(m - n), pc);\n                v = modular.mul(v, modular.valueOf(extGCD.getX()));\n                e -= exp;\n                v = modular.mul(v, power.pow(p, e));\n                return v;\n            }\n        }\n\n        /**\n         * Extend lucas algorithm\n         */\n        public static class ExtLucas {\n            PollardRho pr = new PollardRho();\n            Map<Integer, ExtLucasFactorial> factorialMap = new HashMap();\n\n            public ExtLucas(int p) {\n                Map<Integer, Integer> factors = pr.findAllFactors(p);\n                for (Map.Entry<Integer, Integer> entry : factors.entrySet()) {\n                    factorialMap.put(entry.getValue(), new ExtLucasFactorial(entry.getKey(), entry.getValue(), new int[entry.getValue() + 1]));\n                }\n            }\n\n            /**\n             * Get C(m, n) % p\n             */\n            public int composite(long m, long n) {\n                ExtCRT extCRT = new ExtCRT();\n                for (Map.Entry<Integer, ExtLucasFactorial> entry : factorialMap.entrySet()) {\n                    extCRT.add(entry.getValue().composite(m, n), entry.getKey());\n                }\n                return (int) extCRT.r;\n            }\n        }\n\n        /**\n         * Extend lucas algorithm long version\n         */\n        public static class LongExtLucas {\n            LongPollardRho pr = new LongPollardRho();\n            Map<Integer, ExtLucasFactorial> factorialMap = new HashMap();\n\n            public LongExtLucas(long p) {\n                Map<Long, Long> factors = pr.findAllFactors(p);\n                for (Map.Entry<Long, Long> entry : factors.entrySet()) {\n                    factorialMap.put(entry.getValue().intValue(), new ExtLucasFactorial(entry.getKey().intValue(), entry.getValue().intValue(), new int[entry.getValue().intValue() + 1]));\n                }\n            }\n\n            /**\n             * Get C(m, n) % p\n             */\n            public int composite(long m, long n) {\n                ExtCRT extCRT = new ExtCRT();\n                for (Map.Entry<Integer, ExtLucasFactorial> entry : factorialMap.entrySet()) {\n                    extCRT.add(entry.getValue().composite(m, n), entry.getKey());\n                }\n                return (int) extCRT.r;\n            }\n        }\n\n        /**\n         * Extend gcd\n         */\n        public static class ExtGCD {\n            private long x;\n            private long y;\n            private long g;\n\n            public long getX() {\n                return x;\n            }\n\n            public long getY() {\n                return y;\n            }\n\n            /**\n             * Get g = Gcd(a, b) and find a way to set x and y to match ax+by=g\n             */\n            public long extgcd(long a, long b) {\n                if (a >= b) {\n                    g = extgcd0(a, b);\n                } else {\n                    g = extgcd0(b, a);\n                    long tmp = x;\n                    x = y;\n                    y = tmp;\n                }\n                return g;\n            }\n\n\n            private long extgcd0(long a, long b) {\n                if (b == 0) {\n                    x = 1;\n                    y = 0;\n                    return a;\n                }\n                long g = extgcd0(b, a % b);\n                long n = x;\n                long m = y;\n                x = m;\n                y = n - m * (a / b);\n                return g;\n            }\n        }\n\n        public static class Gcd {\n            public long gcd(long a, long b) {\n                return a >= b ? gcd0(a, b) : gcd0(b, a);\n            }\n\n            private long gcd0(long a, long b) {\n                return b == 0 ? a : gcd0(b, a % b);\n            }\n\n            public int gcd(int a, int b) {\n                return a >= b ? gcd0(a, b) : gcd0(b, a);\n            }\n\n            private int gcd0(int a, int b) {\n                return b == 0 ? a : gcd0(b, a % b);\n            }\n        }\n\n        /**\n         * Euler sieve for filter primes\n         */\n        public static class EulerSieve {\n            int[] primes;\n            boolean[] isComp;\n            int primeLength;\n\n            public EulerSieve(int limit) {\n                isComp = new boolean[limit + 1];\n                primes = new int[limit + 1];\n                primeLength = 0;\n                for (int i = 2; i <= limit; i++) {\n                    if (!isComp[i]) {\n                        primes[primeLength++] = i;\n                    }\n                    for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                        int pi = primes[j] * i;\n                        isComp[pi] = true;\n                        if (i % primes[j] == 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Euler sieve for multiplicative function\n         */\n        public static class MultiplicativeFunctionSieve {\n            int[] primes;\n            boolean[] isComp;\n            int primeLength;\n            int[] mobius;\n            int[] euler;\n            int[] factors;\n            int[] smallestPrimeFactor;\n            int[] numberOfSmallestPrimeFactor;\n\n            public MultiplicativeFunctionSieve(int limit, boolean enableMobius, boolean enableEuler, boolean enableFactors) {\n                isComp = new boolean[limit + 1];\n                primes = new int[limit + 1];\n                numberOfSmallestPrimeFactor = new int[limit + 1];\n                smallestPrimeFactor = new int[limit + 1];\n                primeLength = 0;\n                for (int i = 2; i <= limit; i++) {\n                    if (!isComp[i]) {\n                        primes[primeLength++] = i;\n                        numberOfSmallestPrimeFactor[i] = smallestPrimeFactor[i] = i;\n                    }\n                    for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                        int pi = primes[j] * i;\n                        smallestPrimeFactor[pi] = primes[j];\n                        numberOfSmallestPrimeFactor[pi] = smallestPrimeFactor[i] == primes[j]\n                                ? (numberOfSmallestPrimeFactor[i] * numberOfSmallestPrimeFactor[primes[j]])\n                                : numberOfSmallestPrimeFactor[primes[j]];\n                        isComp[pi] = true;\n                        if (i % primes[j] == 0) {\n                            break;\n                        }\n                    }\n                }\n\n                if (enableMobius) {\n                    mobius = new int[limit + 1];\n                    mobius[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            mobius[i] = -1;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] != smallestPrimeFactor[i]) {\n                                mobius[i] = 0;\n                            } else {\n                                mobius[i] = mobius[numberOfSmallestPrimeFactor[i]] *\n                                        mobius[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n\n                if (enableEuler) {\n                    euler = new int[limit + 1];\n                    euler[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            euler[i] = i - 1;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] == i) {\n                                euler[i] = i - i / smallestPrimeFactor[i];\n                            } else {\n                                euler[i] = euler[numberOfSmallestPrimeFactor[i]] *\n                                        euler[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n\n                if (enableFactors) {\n                    factors = new int[limit + 1];\n                    factors[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            factors[i] = 2;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] == i) {\n                                factors[i] = 1 + factors[i / smallestPrimeFactor[i]];\n                            } else {\n                                factors[i] = factors[numberOfSmallestPrimeFactor[i]] *\n                                        factors[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Mod operations\n         */\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int mul(long x, long y) {\n                x = valueOf(x);\n                y = valueOf(y);\n                return valueOf(x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int plus(long x, long y) {\n                x = valueOf(x);\n                y = valueOf(y);\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public int subtract(long x, long y) {\n                return valueOf(x - y);\n            }\n\n            @Override\n            public String toString() {\n                return \"mod \" + m;\n            }\n        }\n\n        /**\n         * Bit operations\n         */\n        public static class BitOperator {\n            public int bitAt(int x, int i) {\n                return (x >> i) & 1;\n            }\n\n            public int bitAt(long x, int i) {\n                return (int) ((x >> i) & 1);\n            }\n\n            public int setBit(int x, int i, boolean v) {\n                if (v) {\n                    x |= 1 << i;\n                } else {\n                    x &= ~(1 << i);\n                }\n                return x;\n            }\n\n            public long setBit(long x, int i, boolean v) {\n                if (v) {\n                    x |= 1L << i;\n                } else {\n                    x &= ~(1L << i);\n                }\n                return x;\n            }\n\n            public long swapBit(long x, int i, int j) {\n                int bi = bitAt(x, i);\n                int bj = bitAt(x, j);\n                x = setBit(x, i, bj == 1);\n                x = setBit(x, j, bi == 1);\n                return x;\n            }\n\n            public int swapBit(int x, int i, int j) {\n                int bi = bitAt(x, i);\n                int bj = bitAt(x, j);\n                x = setBit(x, i, bj == 1);\n                x = setBit(x, j, bi == 1);\n                return x;\n            }\n\n            /**\n             * Determine whether x is subset of y\n             */\n            public boolean subset(long x, long y) {\n                return intersect(x, y) == x;\n            }\n\n            /**\n             * Merge two set\n             */\n            public long merge(long x, long y) {\n                return x | y;\n            }\n\n            public long intersect(long x, long y) {\n                return x & y;\n            }\n\n            public long differ(long x, long y) {\n                return x - intersect(x, y);\n            }\n        }\n\n        /**\n         * Power operations\n         */\n        public static class Power {\n            public Modular getModular() {\n                return modular;\n            }\n\n            final Modular modular;\n\n            public Power(Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n            public int inverse(int x) {\n                return pow(x, modular.m - 2);\n            }\n\n            public int pow2(int x) {\n                return x * x;\n            }\n\n            public long pow2(long x) {\n                return x * x;\n            }\n\n            public double pow2(double x) {\n                return x * x;\n            }\n        }\n\n        /**\n         * Log operations\n         */\n        public static class Log2 {\n            public int ceilLog(int x) {\n                return 32 - Integer.numberOfLeadingZeros(x - 1);\n            }\n\n            public int floorLog(int x) {\n                return 31 - Integer.numberOfLeadingZeros(x);\n            }\n\n            public int ceilLog(long x) {\n                return 64 - Long.numberOfLeadingZeros(x - 1);\n            }\n\n            public int floorLog(long x) {\n                return 63 - Long.numberOfLeadingZeros(x);\n            }\n        }\n\n        /**\n         * Find all inverse number\n         */\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n        }\n\n        /**\n         * Factorial\n         */\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n\n            public Factorial(int[] fact, int[] inv, InverseNumber in, int limit, Modular modular) {\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new InverseNumber(limit, modular), limit, modular);\n            }\n        }\n\n        /**\n         * Composition\n         */\n        public static class Composite {\n            final Factorial factorial;\n            final Modular modular;\n\n            public Composite(Factorial factorial, Modular modular) {\n                this.factorial = factorial;\n                this.modular = modular;\n            }\n\n            public Composite(int limit, Modular modular) {\n                this(new Factorial(limit, modular), modular);\n            }\n\n            public int composite(int m, int n) {\n                if (n > m) {\n                    return 0;\n                }\n                return modular.mul(modular.mul(factorial.fact[m], factorial.inv[n]), factorial.inv[m - n]);\n            }\n        }\n\n        /**\n         * Test whether a number is primes\n         */\n        public static class MillerRabin {\n            Modular modular;\n            Power power;\n\n            /**\n             * Check whether n is a prime s times\n             */\n            public boolean mr(int n, int s) {\n                if (n == 2) {\n                    return true;\n                }\n                if (n % 2 == 0) {\n                    return false;\n                }\n                modular = new Modular(n);\n                power = new Power(modular);\n                for (int i = 0; i < s; i++) {\n                    int x = RANDOM.nextInt(n - 2) + 2;\n                    if (!mr0(x, n)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            private boolean mr0(int x, int n) {\n                int exp = n - 1;\n                while (true) {\n                    int y = power.pow(x, exp);\n                    if (y != 1 && y != n - 1) {\n                        return false;\n                    }\n                    if (y != 1 || exp % 2 == 1) {\n                        break;\n                    }\n                    exp = exp / 2;\n                }\n                return true;\n            }\n        }\n\n        /**\n         * Modular operation for long version\n         */\n        public static class LongModular {\n            final long m;\n\n            public LongModular(long m) {\n                this.m = m;\n            }\n\n            public long mul(long a, long b) {\n                return b == 0 ? 0 : ((mul(a, b >> 1) << 1) % m + a * (b & 1)) % m;\n            }\n\n            public long plus(long a, long b) {\n                return valueOf(a + b);\n            }\n\n            public long valueOf(long a) {\n                a %= m;\n                if (a < 0) {\n                    a += m;\n                }\n                return a;\n            }\n        }\n\n        public static class LongPower {\n            final LongModular modular;\n\n            public LongPower(LongModular modular) {\n                this.modular = modular;\n            }\n\n            long pow(long x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.mul(r, r);\n                if ((n & 1) == 1) {\n                    r = modular.mul(r, x);\n                }\n                return r;\n            }\n\n            long inverse(long x) {\n                return pow(x, modular.m - 2);\n            }\n        }\n\n        /**\n         * Test whether a number is primes\n         */\n        public static class LongMillerRabin {\n            LongModular modular;\n            LongPower power;\n\n            /**\n             * Check whether n is a prime s times\n             */\n            public boolean mr(long n, int s) {\n                if (n == 2) {\n                    return true;\n                }\n                if (n % 2 == 0) {\n                    return false;\n                }\n                modular = new LongModular(n);\n                power = new LongPower(modular);\n                for (int i = 0; i < s; i++) {\n                    long x = (long) (RANDOM.nextDouble() * (n - 2) + 2);\n                    if (!mr0(x, n)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            private boolean mr0(long x, long n) {\n                long exp = n - 1;\n                while (true) {\n                    long y = power.pow(x, exp);\n                    if (y != 1 && y != n - 1) {\n                        return false;\n                    }\n                    if (y != 1 || exp % 2 == 1) {\n                        break;\n                    }\n                    exp = exp / 2;\n                }\n                return true;\n            }\n        }\n\n        public static class LongPollardRho {\n            LongMillerRabin mr = new LongMillerRabin();\n            Gcd gcd = new Gcd();\n            LongModular modular;\n\n            /**\n             * Find a factor of n, if n is returned, it means n is 1 or a prime\n             */\n            public long findFactor(long n) {\n                if (mr.mr(n, 3)) {\n                    return n;\n                }\n                modular = new LongModular(n);\n                while (true) {\n                    long f = findFactor0((long) (RANDOM.nextDouble() * n), (long) (RANDOM.nextDouble() * n), n);\n                    if (f != -1) {\n                        return f;\n                    }\n                }\n            }\n\n            private long findFactor0(long x, long c, long n) {\n                long xi = x;\n                long xj = x;\n                int j = 2;\n                int i = 1;\n                while (i < n) {\n                    i++;\n                    xi = modular.plus(modular.mul(xi, xi), c);\n                    long g = gcd.gcd(n, Math.abs(xi - xj));\n                    if (g != 1 && g != n) {\n                        return g;\n                    }\n                    if (i == j) {\n                        j = j << 1;\n                        xj = xi;\n                    }\n                }\n                return -1;\n            }\n\n            /**\n             * Find the representation of n=p1^c1 * p2^c2 * ... * pm ^ cm.\n             * <br>\n             * The returned map contained such entries: pi -> pi^ci\n             */\n            public Map<Long, Long> findAllFactors(long n) {\n                Map<Long, Long> map = new HashMap();\n                findAllFactors(map, n);\n                return map;\n            }\n\n            private void findAllFactors(Map<Long, Long> map, long n) {\n                if (n == 1) {\n                    return;\n                }\n                long f = findFactor(n);\n                if (f == n) {\n                    Long value = map.get(f);\n                    if (value == null) {\n                        value = 1L;\n                    }\n                    map.put(f, value * f);\n                    return;\n                }\n                findAllFactors(map, f);\n                findAllFactors(map, n / f);\n            }\n\n        }\n\n        /**\n         * Extend chinese remainder theory\n         */\n        public static class ExtCRT {\n            /**\n             * remainder\n             */\n            long r;\n            /**\n             * modulus\n             */\n            long m;\n            ExtGCD gcd = new ExtGCD();\n\n            public ExtCRT() {\n                r = 0;\n                m = 1;\n            }\n\n            /**\n             * Add a new condition: x % m = r\n             */\n            public boolean add(long r, long m) {\n                long m1 = this.m;\n                long x1 = this.r;\n                long m2 = m;\n                long x2 = ((r % m) + m) % m;\n                long g = gcd.extgcd(m1, m2);\n                long a = gcd.getX();\n                if ((x2 - x1) % g != 0) {\n                    return false;\n                }\n                this.m = m1 / g * m2;\n                this.r = BigInteger.valueOf(a).multiply(BigInteger.valueOf((x2 - x1) / g))\n                        .multiply(BigInteger.valueOf(m1)).add(BigInteger.valueOf(x1))\n                        .mod(BigInteger.valueOf(this.m)).longValue();\n                return true;\n            }\n        }\n\n        /**\n         * Lucas algorithm\n         */\n        public static class Lucas {\n            private final Composite composite;\n            private int modulus;\n\n            public Lucas(Composite composite) {\n                this.composite = composite;\n                this.modulus = composite.modular.m;\n            }\n\n            public int composite(long m, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                return composite.modular.mul(composite.composite((int) (m % modulus), (int) (n % modulus)),\n                        composite(m / modulus, n / modulus));\n            }\n        }\n\n        /**\n         * Find all factors of a number\n         */\n        public static class PollardRho {\n            MillerRabin mr = new MillerRabin();\n            Gcd gcd = new Gcd();\n            Random random = new Random();\n\n            public int findFactor(int n) {\n                if (mr.mr(n, 10)) {\n                    return n;\n                }\n                while (true) {\n                    int f = findFactor0(random.nextInt(n), random.nextInt(n), n);\n                    if (f != -1) {\n                        return f;\n                    }\n                }\n            }\n\n            /**\n             * Find all prime factor of n\n             * <br>\n             * p1 => p1^c1\n             * <br>\n             * ...\n             * <br>\n             * pk => pk^ck\n             */\n            public Map<Integer, Integer> findAllFactors(int n) {\n                Map<Integer, Integer> map = new HashMap();\n                findAllFactors(map, n);\n                return map;\n            }\n\n            private void findAllFactors(Map<Integer, Integer> map, int n) {\n                if (n == 1) {\n                    return;\n                }\n                int f = findFactor(n);\n                if (f == n) {\n                    Integer value = map.get(f);\n                    if (value == null) {\n                        value = 1;\n                    }\n                    map.put(f, value * f);\n                    return;\n                }\n                findAllFactors(map, f);\n                findAllFactors(map, n / f);\n            }\n\n            private int findFactor0(int x, int c, int n) {\n                int xi = x;\n                int xj = x;\n                int j = 2;\n                int i = 1;\n                while (i < n) {\n                    i++;\n                    xi = (int) ((long) xi * xi + c) % n;\n                    int g = gcd.gcd(n, Math.abs(xi - xj));\n                    if (g != 1 && g != n) {\n                        return g;\n                    }\n                    if (i == j) {\n                        j = j << 1;\n                        xj = xi;\n                    }\n                }\n                return -1;\n            }\n        }\n\n        public static class ModExpression {\n            ExtGCD extGCD = new ExtGCD();\n            Modular modular = new Modular(1);\n\n            /**\n             * Find ka=b(mod c) where k is the minimum possible non negative integer.\n             * <br>\n             * If it's impossible, -1 will be returned.\n             */\n            public long solve(long a, long b, int c) {\n                modular.m = c;\n                a = modular.valueOf(a);\n                b = modular.valueOf(b);\n                int g = (int) extGCD.extgcd((int) a, c);\n                if (b % g != 0) {\n                    return -1;\n                }\n                modular.m = c / g;\n                return modular.valueOf(b / g * extGCD.getX());\n            }\n        }\n\n        /**\n         * \\sum_{i=1}^{limit}f(\\lfloor n/i \\rfloor)\n         */\n        public static class FloorDivisionOptimizer {\n            int l;\n            int r;\n            int n;\n            int limit;\n\n\n            public FloorDivisionOptimizer(int n, int l, int limit) {\n                this.n = n;\n                this.l = 0;\n                this.limit = limit;\n                this.r = l - 1;\n            }\n\n            public boolean hasNext() {\n                return r < limit;\n            }\n\n            public int next() {\n                l = r + 1;\n                r = n / (n / l);\n                return n / l;\n            }\n        }\n\n\n        public static class QuadraticResidue {\n            final Modular modular;\n            final BitOperator bitOperator = new BitOperator();\n            Power power;\n            final PollardRho rho = new PollardRho();\n\n\n            public QuadraticResidue(Modular modular) {\n                this.modular = modular;\n                power = new Power(modular);\n            }\n\n            /**\n             * return \\sqrt{n} or -1 if it doesn't exist\n             */\n            public int square(int n) {\n                n = modular.valueOf(n);\n                if (n == 0) {\n                    return 0;\n                }\n                int p = modular.m;\n                if (power.pow(n, (p - 1) / 2) != 1) {\n                    return -1;\n                }\n                while (true) {\n                    int a = RANDOM.nextInt(p);\n                    int w = modular.plus(modular.mul(a, a), -n);\n                    if (power.pow(w, (p - 1) / 2) == 1) {\n                        continue;\n                    }\n\n\n                    int pow = (p + 1) / 2;\n                    int i = 31 - Integer.numberOfLeadingZeros(pow);\n                    int real = 1;\n                    int img = 0;\n                    for (; i >= 0; i--) {\n                        int nReal = modular.plus(modular.mul(real, real),\n                                modular.mul(modular.mul(img, img), w));\n                        int nImg = modular.mul(modular.mul(real, img), 2);\n                        real = nReal;\n                        img = nImg;\n                        if (bitOperator.bitAt(pow, i) == 1) {\n                            nReal = modular.plus(modular.mul(real, a), modular.mul(img, w));\n                            nImg = modular.plus(modular.mul(img, a), real);\n                            real = nReal;\n                            img = nImg;\n                        }\n                    }\n\n                    return real;\n                }\n            }\n\n            public int minPrimitiveRoot() {\n                if (modular.m == 2) {\n                    return 1;\n                }\n                Map<Integer, Integer> factorMap = rho.findAllFactors(modular.m - 1);\n                int[] factors = factorMap.keySet().stream().mapToInt(Integer::intValue).toArray();\n                for (int i = 2; ; i++) {\n                    boolean valid = true;\n                    for (int factor : factors) {\n                        if (power.pow(i, (modular.m - 1) / factor) == 1) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (valid) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder(20 << 20);\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        boolean local = false;\n        boolean async = true;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"skypool\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        long lInf = (long) 1e18;\n        double dInf = 1e50;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        NumberTheory.Modular mod = new NumberTheory.Modular((int) 1e9 + 7);\n        NumberTheory.Composite comp = new NumberTheory.Composite(1000000, mod);\n        NumberTheory.BitOperator bo = new NumberTheory.BitOperator();\n\n        public void solve() {\n            int n = io.readInt();\n            int m = io.readInt();\n            int l = io.readInt();\n            int r = io.readInt();\n\n\n            //ei\n            int lPart = m;\n            int rPart = n - m;\n            int[] cache1 = new int[r + 1];\n            int[] cache2 = new int[r + 1];\n            for (int x = 1; x < cache1.length; x++) {\n                int localSum = 0;\n                for (int j = 0; j <= rPart; j++) {\n                    int c = comp.composite(rPart, j);\n                    int numberOfX = lPart + j;\n                    int sub = numberOfX * x;\n                    if (sub > r) {\n                        break;\n                    }\n                    int plus = mod.mul(c, mod.subtract(inRange(n, r - sub), inRange(n, l - 1 - sub)));\n                    if (bo.bitAt(j, 0) == 1) {\n                        plus = -plus;\n                    }\n                    localSum = mod.plus(localSum, plus);\n                }\n                cache1[x] = mod.mul(localSum, comp.composite(n, lPart));\n            }\n            // min{1..M} >= x + 1 and max{M+1...N} < x\n            for (int x = 1; x < cache2.length; x++) {\n                int localSum = 0;\n                for (int j = 0; j <= rPart; j++) {\n                    int c = comp.composite(rPart, j);\n                    int numberOfX = lPart + j;\n                    int sub = numberOfX * x + lPart;\n                    if (sub > r) {\n                        break;\n                    }\n                    int plus = mod.mul(c, mod.subtract(inRange(n, r - sub), inRange(n, l - 1 - sub)));\n                    if (bo.bitAt(j, 0) == 1) {\n                        plus = -plus;\n                    }\n                    localSum = mod.plus(localSum, plus);\n                }\n                cache2[x] = mod.mul(localSum, comp.composite(n, lPart));\n            }\n\n            int sum = mod.subtract(inRange(n, r), inRange(n, l - 1));\n            for (int i = 0; i <= r; i++) {\n                int plus = mod.subtract(cache1[i], cache2[i]);\n                sum = mod.subtract(sum, plus);\n            }\n\n            io.cache.append(sum);\n        }\n\n\n        /**\n         * a1 + a2 + ... + an <= m\n         */\n        public int inRange(int n, int m) {\n            return comp.composite(m + n, n);\n        }\n    }\n\n\n    public static class NumberTheory {\n        private static final Random RANDOM = new Random();\n\n        public static class ExtLucasFactorial {\n            int exp;\n            int fact;\n            int p;\n            int pc;\n            Modular modular;\n            Power power;\n            ExtGCD extGCD = new ExtGCD();\n            int[] g;\n\n            /**\n             * O(pc)\n             *\n             * @param p  the prime\n             * @param pc p^c\n             * @param g  buffer\n             */\n            public ExtLucasFactorial(int p, int pc, int[] g) {\n                this.p = p;\n                this.pc = pc;\n                this.g = g;\n                modular = new Modular(pc);\n                power = new Power(modular);\n                g[0] = 1;\n                g[1] = 1;\n                for (int i = 2; i <= pc; i++) {\n                    if (i % p == 0) {\n                        g[i] = g[i - 1];\n                    } else {\n                        g[i] = modular.mul(g[i - 1], i);\n                    }\n                }\n            }\n\n            /**\n             * return m! (mod pc) without any factor which is multiple of p.\n             * <br>\n             * O(\\log_2^2{m})\n             */\n            private int fact(long m) {\n                fact = 1;\n                exp = 0;\n                while (m > 1) {\n                    exp += m / p;\n                    fact = modular.mul(fact, power.pow(g[pc], m / pc));\n                    fact = modular.mul(fact, g[(int) (m % pc)]);\n                    m /= p;\n                }\n                return fact;\n            }\n\n            /**\n             * Find C(m,n), it means choose n elements from a set whose size is m.\n             * <br>\n             * O(\\log_2^2{m})\n             */\n            public int composite(long m, long n) {\n                int v = fact(m);\n                int e = exp;\n                extGCD.extgcd(fact(n), pc);\n                v = modular.mul(v, modular.valueOf(extGCD.getX()));\n                e -= exp;\n                extGCD.extgcd(fact(m - n), pc);\n                v = modular.mul(v, modular.valueOf(extGCD.getX()));\n                e -= exp;\n                v = modular.mul(v, power.pow(p, e));\n                return v;\n            }\n        }\n\n        /**\n         * Extend lucas algorithm\n         */\n        public static class ExtLucas {\n            PollardRho pr = new PollardRho();\n            Map<Integer, ExtLucasFactorial> factorialMap = new HashMap();\n\n            public ExtLucas(int p) {\n                Map<Integer, Integer> factors = pr.findAllFactors(p);\n                for (Map.Entry<Integer, Integer> entry : factors.entrySet()) {\n                    factorialMap.put(entry.getValue(), new ExtLucasFactorial(entry.getKey(), entry.getValue(), new int[entry.getValue() + 1]));\n                }\n            }\n\n            /**\n             * Get C(m, n) % p\n             */\n            public int composite(long m, long n) {\n                ExtCRT extCRT = new ExtCRT();\n                for (Map.Entry<Integer, ExtLucasFactorial> entry : factorialMap.entrySet()) {\n                    extCRT.add(entry.getValue().composite(m, n), entry.getKey());\n                }\n                return (int) extCRT.r;\n            }\n        }\n\n        /**\n         * Extend lucas algorithm long version\n         */\n        public static class LongExtLucas {\n            LongPollardRho pr = new LongPollardRho();\n            Map<Integer, ExtLucasFactorial> factorialMap = new HashMap();\n\n            public LongExtLucas(long p) {\n                Map<Long, Long> factors = pr.findAllFactors(p);\n                for (Map.Entry<Long, Long> entry : factors.entrySet()) {\n                    factorialMap.put(entry.getValue().intValue(), new ExtLucasFactorial(entry.getKey().intValue(), entry.getValue().intValue(), new int[entry.getValue().intValue() + 1]));\n                }\n            }\n\n            /**\n             * Get C(m, n) % p\n             */\n            public int composite(long m, long n) {\n                ExtCRT extCRT = new ExtCRT();\n                for (Map.Entry<Integer, ExtLucasFactorial> entry : factorialMap.entrySet()) {\n                    extCRT.add(entry.getValue().composite(m, n), entry.getKey());\n                }\n                return (int) extCRT.r;\n            }\n        }\n\n        /**\n         * Extend gcd\n         */\n        public static class ExtGCD {\n            private long x;\n            private long y;\n            private long g;\n\n            public long getX() {\n                return x;\n            }\n\n            public long getY() {\n                return y;\n            }\n\n            /**\n             * Get g = Gcd(a, b) and find a way to set x and y to match ax+by=g\n             */\n            public long extgcd(long a, long b) {\n                if (a >= b) {\n                    g = extgcd0(a, b);\n                } else {\n                    g = extgcd0(b, a);\n                    long tmp = x;\n                    x = y;\n                    y = tmp;\n                }\n                return g;\n            }\n\n\n            private long extgcd0(long a, long b) {\n                if (b == 0) {\n                    x = 1;\n                    y = 0;\n                    return a;\n                }\n                long g = extgcd0(b, a % b);\n                long n = x;\n                long m = y;\n                x = m;\n                y = n - m * (a / b);\n                return g;\n            }\n        }\n\n        public static class Gcd {\n            public long gcd(long a, long b) {\n                return a >= b ? gcd0(a, b) : gcd0(b, a);\n            }\n\n            private long gcd0(long a, long b) {\n                return b == 0 ? a : gcd0(b, a % b);\n            }\n\n            public int gcd(int a, int b) {\n                return a >= b ? gcd0(a, b) : gcd0(b, a);\n            }\n\n            private int gcd0(int a, int b) {\n                return b == 0 ? a : gcd0(b, a % b);\n            }\n        }\n\n        /**\n         * Euler sieve for filter primes\n         */\n        public static class EulerSieve {\n            int[] primes;\n            boolean[] isComp;\n            int primeLength;\n\n            public EulerSieve(int limit) {\n                isComp = new boolean[limit + 1];\n                primes = new int[limit + 1];\n                primeLength = 0;\n                for (int i = 2; i <= limit; i++) {\n                    if (!isComp[i]) {\n                        primes[primeLength++] = i;\n                    }\n                    for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                        int pi = primes[j] * i;\n                        isComp[pi] = true;\n                        if (i % primes[j] == 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Euler sieve for multiplicative function\n         */\n        public static class MultiplicativeFunctionSieve {\n            int[] primes;\n            boolean[] isComp;\n            int primeLength;\n            int[] mobius;\n            int[] euler;\n            int[] factors;\n            int[] smallestPrimeFactor;\n            int[] numberOfSmallestPrimeFactor;\n\n            public MultiplicativeFunctionSieve(int limit, boolean enableMobius, boolean enableEuler, boolean enableFactors) {\n                isComp = new boolean[limit + 1];\n                primes = new int[limit + 1];\n                numberOfSmallestPrimeFactor = new int[limit + 1];\n                smallestPrimeFactor = new int[limit + 1];\n                primeLength = 0;\n                for (int i = 2; i <= limit; i++) {\n                    if (!isComp[i]) {\n                        primes[primeLength++] = i;\n                        numberOfSmallestPrimeFactor[i] = smallestPrimeFactor[i] = i;\n                    }\n                    for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                        int pi = primes[j] * i;\n                        smallestPrimeFactor[pi] = primes[j];\n                        numberOfSmallestPrimeFactor[pi] = smallestPrimeFactor[i] == primes[j]\n                                ? (numberOfSmallestPrimeFactor[i] * numberOfSmallestPrimeFactor[primes[j]])\n                                : numberOfSmallestPrimeFactor[primes[j]];\n                        isComp[pi] = true;\n                        if (i % primes[j] == 0) {\n                            break;\n                        }\n                    }\n                }\n\n                if (enableMobius) {\n                    mobius = new int[limit + 1];\n                    mobius[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            mobius[i] = -1;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] != smallestPrimeFactor[i]) {\n                                mobius[i] = 0;\n                            } else {\n                                mobius[i] = mobius[numberOfSmallestPrimeFactor[i]] *\n                                        mobius[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n\n                if (enableEuler) {\n                    euler = new int[limit + 1];\n                    euler[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            euler[i] = i - 1;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] == i) {\n                                euler[i] = i - i / smallestPrimeFactor[i];\n                            } else {\n                                euler[i] = euler[numberOfSmallestPrimeFactor[i]] *\n                                        euler[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n\n                if (enableFactors) {\n                    factors = new int[limit + 1];\n                    factors[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            factors[i] = 2;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] == i) {\n                                factors[i] = 1 + factors[i / smallestPrimeFactor[i]];\n                            } else {\n                                factors[i] = factors[numberOfSmallestPrimeFactor[i]] *\n                                        factors[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Mod operations\n         */\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int mul(long x, long y) {\n                x = valueOf(x);\n                y = valueOf(y);\n                return valueOf(x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int plus(long x, long y) {\n                x = valueOf(x);\n                y = valueOf(y);\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public int subtract(long x, long y) {\n                return valueOf(x - y);\n            }\n\n            @Override\n            public String toString() {\n                return \"mod \" + m;\n            }\n        }\n\n        /**\n         * Bit operations\n         */\n        public static class BitOperator {\n            public int bitAt(int x, int i) {\n                return (x >> i) & 1;\n            }\n\n            public int bitAt(long x, int i) {\n                return (int) ((x >> i) & 1);\n            }\n\n            public int setBit(int x, int i, boolean v) {\n                if (v) {\n                    x |= 1 << i;\n                } else {\n                    x &= ~(1 << i);\n                }\n                return x;\n            }\n\n            public long setBit(long x, int i, boolean v) {\n                if (v) {\n                    x |= 1L << i;\n                } else {\n                    x &= ~(1L << i);\n                }\n                return x;\n            }\n\n            public long swapBit(long x, int i, int j) {\n                int bi = bitAt(x, i);\n                int bj = bitAt(x, j);\n                x = setBit(x, i, bj == 1);\n                x = setBit(x, j, bi == 1);\n                return x;\n            }\n\n            public int swapBit(int x, int i, int j) {\n                int bi = bitAt(x, i);\n                int bj = bitAt(x, j);\n                x = setBit(x, i, bj == 1);\n                x = setBit(x, j, bi == 1);\n                return x;\n            }\n\n            /**\n             * Determine whether x is subset of y\n             */\n            public boolean subset(long x, long y) {\n                return intersect(x, y) == x;\n            }\n\n            /**\n             * Merge two set\n             */\n            public long merge(long x, long y) {\n                return x | y;\n            }\n\n            public long intersect(long x, long y) {\n                return x & y;\n            }\n\n            public long differ(long x, long y) {\n                return x - intersect(x, y);\n            }\n        }\n\n        /**\n         * Power operations\n         */\n        public static class Power {\n            public Modular getModular() {\n                return modular;\n            }\n\n            final Modular modular;\n\n            public Power(Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n            public int inverse(int x) {\n                return pow(x, modular.m - 2);\n            }\n\n            public int pow2(int x) {\n                return x * x;\n            }\n\n            public long pow2(long x) {\n                return x * x;\n            }\n\n            public double pow2(double x) {\n                return x * x;\n            }\n        }\n\n        /**\n         * Log operations\n         */\n        public static class Log2 {\n            public int ceilLog(int x) {\n                return 32 - Integer.numberOfLeadingZeros(x - 1);\n            }\n\n            public int floorLog(int x) {\n                return 31 - Integer.numberOfLeadingZeros(x);\n            }\n\n            public int ceilLog(long x) {\n                return 64 - Long.numberOfLeadingZeros(x - 1);\n            }\n\n            public int floorLog(long x) {\n                return 63 - Long.numberOfLeadingZeros(x);\n            }\n        }\n\n        /**\n         * Find all inverse number\n         */\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n        }\n\n        /**\n         * Factorial\n         */\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n\n            public Factorial(int[] fact, int[] inv, InverseNumber in, int limit, Modular modular) {\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new InverseNumber(limit, modular), limit, modular);\n            }\n        }\n\n        /**\n         * Composition\n         */\n        public static class Composite {\n            final Factorial factorial;\n            final Modular modular;\n\n            public Composite(Factorial factorial, Modular modular) {\n                this.factorial = factorial;\n                this.modular = modular;\n            }\n\n            public Composite(int limit, Modular modular) {\n                this(new Factorial(limit, modular), modular);\n            }\n\n            public int composite(int m, int n) {\n                if (n > m) {\n                    return 0;\n                }\n                return modular.mul(modular.mul(factorial.fact[m], factorial.inv[n]), factorial.inv[m - n]);\n            }\n        }\n\n        /**\n         * Test whether a number is primes\n         */\n        public static class MillerRabin {\n            Modular modular;\n            Power power;\n\n            /**\n             * Check whether n is a prime s times\n             */\n            public boolean mr(int n, int s) {\n                if (n == 2) {\n                    return true;\n                }\n                if (n % 2 == 0) {\n                    return false;\n                }\n                modular = new Modular(n);\n                power = new Power(modular);\n                for (int i = 0; i < s; i++) {\n                    int x = RANDOM.nextInt(n - 2) + 2;\n                    if (!mr0(x, n)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            private boolean mr0(int x, int n) {\n                int exp = n - 1;\n                while (true) {\n                    int y = power.pow(x, exp);\n                    if (y != 1 && y != n - 1) {\n                        return false;\n                    }\n                    if (y != 1 || exp % 2 == 1) {\n                        break;\n                    }\n                    exp = exp / 2;\n                }\n                return true;\n            }\n        }\n\n        /**\n         * Modular operation for long version\n         */\n        public static class LongModular {\n            final long m;\n\n            public LongModular(long m) {\n                this.m = m;\n            }\n\n            public long mul(long a, long b) {\n                return b == 0 ? 0 : ((mul(a, b >> 1) << 1) % m + a * (b & 1)) % m;\n            }\n\n            public long plus(long a, long b) {\n                return valueOf(a + b);\n            }\n\n            public long valueOf(long a) {\n                a %= m;\n                if (a < 0) {\n                    a += m;\n                }\n                return a;\n            }\n        }\n\n        public static class LongPower {\n            final LongModular modular;\n\n            public LongPower(LongModular modular) {\n                this.modular = modular;\n            }\n\n            long pow(long x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.mul(r, r);\n                if ((n & 1) == 1) {\n                    r = modular.mul(r, x);\n                }\n                return r;\n            }\n\n            long inverse(long x) {\n                return pow(x, modular.m - 2);\n            }\n        }\n\n        /**\n         * Test whether a number is primes\n         */\n        public static class LongMillerRabin {\n            LongModular modular;\n            LongPower power;\n\n            /**\n             * Check whether n is a prime s times\n             */\n            public boolean mr(long n, int s) {\n                if (n == 2) {\n                    return true;\n                }\n                if (n % 2 == 0) {\n                    return false;\n                }\n                modular = new LongModular(n);\n                power = new LongPower(modular);\n                for (int i = 0; i < s; i++) {\n                    long x = (long) (RANDOM.nextDouble() * (n - 2) + 2);\n                    if (!mr0(x, n)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            private boolean mr0(long x, long n) {\n                long exp = n - 1;\n                while (true) {\n                    long y = power.pow(x, exp);\n                    if (y != 1 && y != n - 1) {\n                        return false;\n                    }\n                    if (y != 1 || exp % 2 == 1) {\n                        break;\n                    }\n                    exp = exp / 2;\n                }\n                return true;\n            }\n        }\n\n        public static class LongPollardRho {\n            LongMillerRabin mr = new LongMillerRabin();\n            Gcd gcd = new Gcd();\n            LongModular modular;\n\n            /**\n             * Find a factor of n, if n is returned, it means n is 1 or a prime\n             */\n            public long findFactor(long n) {\n                if (mr.mr(n, 3)) {\n                    return n;\n                }\n                modular = new LongModular(n);\n                while (true) {\n                    long f = findFactor0((long) (RANDOM.nextDouble() * n), (long) (RANDOM.nextDouble() * n), n);\n                    if (f != -1) {\n                        return f;\n                    }\n                }\n            }\n\n            private long findFactor0(long x, long c, long n) {\n                long xi = x;\n                long xj = x;\n                int j = 2;\n                int i = 1;\n                while (i < n) {\n                    i++;\n                    xi = modular.plus(modular.mul(xi, xi), c);\n                    long g = gcd.gcd(n, Math.abs(xi - xj));\n                    if (g != 1 && g != n) {\n                        return g;\n                    }\n                    if (i == j) {\n                        j = j << 1;\n                        xj = xi;\n                    }\n                }\n                return -1;\n            }\n\n            /**\n             * Find the representation of n=p1^c1 * p2^c2 * ... * pm ^ cm.\n             * <br>\n             * The returned map contained such entries: pi -> pi^ci\n             */\n            public Map<Long, Long> findAllFactors(long n) {\n                Map<Long, Long> map = new HashMap();\n                findAllFactors(map, n);\n                return map;\n            }\n\n            private void findAllFactors(Map<Long, Long> map, long n) {\n                if (n == 1) {\n                    return;\n                }\n                long f = findFactor(n);\n                if (f == n) {\n                    Long value = map.get(f);\n                    if (value == null) {\n                        value = 1L;\n                    }\n                    map.put(f, value * f);\n                    return;\n                }\n                findAllFactors(map, f);\n                findAllFactors(map, n / f);\n            }\n\n        }\n\n        /**\n         * Extend chinese remainder theory\n         */\n        public static class ExtCRT {\n            /**\n             * remainder\n             */\n            long r;\n            /**\n             * modulus\n             */\n            long m;\n            ExtGCD gcd = new ExtGCD();\n\n            public ExtCRT() {\n                r = 0;\n                m = 1;\n            }\n\n            /**\n             * Add a new condition: x % m = r\n             */\n            public boolean add(long r, long m) {\n                long m1 = this.m;\n                long x1 = this.r;\n                long m2 = m;\n                long x2 = ((r % m) + m) % m;\n                long g = gcd.extgcd(m1, m2);\n                long a = gcd.getX();\n                if ((x2 - x1) % g != 0) {\n                    return false;\n                }\n                this.m = m1 / g * m2;\n                this.r = BigInteger.valueOf(a).multiply(BigInteger.valueOf((x2 - x1) / g))\n                        .multiply(BigInteger.valueOf(m1)).add(BigInteger.valueOf(x1))\n                        .mod(BigInteger.valueOf(this.m)).longValue();\n                return true;\n            }\n        }\n\n        /**\n         * Lucas algorithm\n         */\n        public static class Lucas {\n            private final Composite composite;\n            private int modulus;\n\n            public Lucas(Composite composite) {\n                this.composite = composite;\n                this.modulus = composite.modular.m;\n            }\n\n            public int composite(long m, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                return composite.modular.mul(composite.composite((int) (m % modulus), (int) (n % modulus)),\n                        composite(m / modulus, n / modulus));\n            }\n        }\n\n        /**\n         * Find all factors of a number\n         */\n        public static class PollardRho {\n            MillerRabin mr = new MillerRabin();\n            Gcd gcd = new Gcd();\n            Random random = new Random();\n\n            public int findFactor(int n) {\n                if (mr.mr(n, 10)) {\n                    return n;\n                }\n                while (true) {\n                    int f = findFactor0(random.nextInt(n), random.nextInt(n), n);\n                    if (f != -1) {\n                        return f;\n                    }\n                }\n            }\n\n            /**\n             * Find all prime factor of n\n             * <br>\n             * p1 => p1^c1\n             * <br>\n             * ...\n             * <br>\n             * pk => pk^ck\n             */\n            public Map<Integer, Integer> findAllFactors(int n) {\n                Map<Integer, Integer> map = new HashMap();\n                findAllFactors(map, n);\n                return map;\n            }\n\n            private void findAllFactors(Map<Integer, Integer> map, int n) {\n                if (n == 1) {\n                    return;\n                }\n                int f = findFactor(n);\n                if (f == n) {\n                    Integer value = map.get(f);\n                    if (value == null) {\n                        value = 1;\n                    }\n                    map.put(f, value * f);\n                    return;\n                }\n                findAllFactors(map, f);\n                findAllFactors(map, n / f);\n            }\n\n            private int findFactor0(int x, int c, int n) {\n                int xi = x;\n                int xj = x;\n                int j = 2;\n                int i = 1;\n                while (i < n) {\n                    i++;\n                    xi = (int) ((long) xi * xi + c) % n;\n                    int g = gcd.gcd(n, Math.abs(xi - xj));\n                    if (g != 1 && g != n) {\n                        return g;\n                    }\n                    if (i == j) {\n                        j = j << 1;\n                        xj = xi;\n                    }\n                }\n                return -1;\n            }\n        }\n\n        public static class ModExpression {\n            ExtGCD extGCD = new ExtGCD();\n            Modular modular = new Modular(1);\n\n            /**\n             * Find ka=b(mod c) where k is the minimum possible non negative integer.\n             * <br>\n             * If it's impossible, -1 will be returned.\n             */\n            public long solve(long a, long b, int c) {\n                modular.m = c;\n                a = modular.valueOf(a);\n                b = modular.valueOf(b);\n                int g = (int) extGCD.extgcd((int) a, c);\n                if (b % g != 0) {\n                    return -1;\n                }\n                modular.m = c / g;\n                return modular.valueOf(b / g * extGCD.getX());\n            }\n        }\n\n        /**\n         * \\sum_{i=1}^{limit}f(\\lfloor n/i \\rfloor)\n         */\n        public static class FloorDivisionOptimizer {\n            int l;\n            int r;\n            int n;\n            int limit;\n\n\n            public FloorDivisionOptimizer(int n, int l, int limit) {\n                this.n = n;\n                this.l = 0;\n                this.limit = limit;\n                this.r = l - 1;\n            }\n\n            public boolean hasNext() {\n                return r < limit;\n            }\n\n            public int next() {\n                l = r + 1;\n                r = n / (n / l);\n                return n / l;\n            }\n        }\n\n\n        public static class QuadraticResidue {\n            final Modular modular;\n            final BitOperator bitOperator = new BitOperator();\n            Power power;\n            final PollardRho rho = new PollardRho();\n\n\n            public QuadraticResidue(Modular modular) {\n                this.modular = modular;\n                power = new Power(modular);\n            }\n\n            /**\n             * return \\sqrt{n} or -1 if it doesn't exist\n             */\n            public int square(int n) {\n                n = modular.valueOf(n);\n                if (n == 0) {\n                    return 0;\n                }\n                int p = modular.m;\n                if (power.pow(n, (p - 1) / 2) != 1) {\n                    return -1;\n                }\n                while (true) {\n                    int a = RANDOM.nextInt(p);\n                    int w = modular.plus(modular.mul(a, a), -n);\n                    if (power.pow(w, (p - 1) / 2) == 1) {\n                        continue;\n                    }\n\n\n                    int pow = (p + 1) / 2;\n                    int i = 31 - Integer.numberOfLeadingZeros(pow);\n                    int real = 1;\n                    int img = 0;\n                    for (; i >= 0; i--) {\n                        int nReal = modular.plus(modular.mul(real, real),\n                                modular.mul(modular.mul(img, img), w));\n                        int nImg = modular.mul(modular.mul(real, img), 2);\n                        real = nReal;\n                        img = nImg;\n                        if (bitOperator.bitAt(pow, i) == 1) {\n                            nReal = modular.plus(modular.mul(real, a), modular.mul(img, w));\n                            nImg = modular.plus(modular.mul(img, a), real);\n                            real = nReal;\n                            img = nImg;\n                        }\n                    }\n\n                    return real;\n                }\n            }\n\n            public int minPrimitiveRoot() {\n                if (modular.m == 2) {\n                    return 1;\n                }\n                Map<Integer, Integer> factorMap = rho.findAllFactors(modular.m - 1);\n                int[] factors = factorMap.keySet().stream().mapToInt(Integer::intValue).toArray();\n                for (int i = 2; ; i++) {\n                    boolean valid = true;\n                    for (int factor : factors) {\n                        if (power.pow(i, (modular.m - 1) / factor) == 1) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (valid) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder(20 << 20);\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nstruct ModInt(long M) {\n  long x;\n  this(in ModInt a) { x = a.x; }\n  this(in long a) { x = a % M; if (x < 0) x += M; }\n  ref ModInt opAssign(in long a) { return this = ModInt(a); }\n  ref ModInt opOpAssign(string op)(in ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x *= a.x; x %= M; }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(in long a) { return mixin(\"this \" ~ op ~ \"= ModInt(a)\"); }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(in T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(in long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\n\nenum MO = 10L^^9 + 7;\nalias Mint = ModInt!MO;\nenum LIM = 10^^6;\n\nlong[] inv, fac, invFac;\nvoid prepare() {\n  inv = new long[LIM];\n  fac = new long[LIM];\n  invFac = new long[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = MO - ((MO / i) * inv[cast(size_t)(MO % i)]) % MO;\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = (fac[i - 1] * i) % MO;\n    invFac[i] = (invFac[i - 1] * inv[i]) % MO;\n  }\n}\nlong binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] % MO * invFac[cast(size_t)(n - k)] % MO;\n  } else {\n    return 0;\n  }\n}\n\n\nMint solve(long N, long M, long R) {\n  debug {\n    writefln(\"N = %s, M = %s, R = %s\", N, M, R);\n  }\n  Mint all = binom(R + N, N);\n  debug {\n    writeln(\"  all = \", all);\n  }\n  Mint sep;\n  foreach (x; 1 .. R + 1) {\n    if (R - M * x < 0) {\n      break;\n    }\n    Mint sum;\n    foreach (t; 0 .. 2) {\n      foreach (k; 0 .. N - M + 1) {\n        const r = R - M * (x + t) - k * x;\n        if (r < 0) {\n          break;\n        }\n        Mint tmp = (k % 2 != 0) ? -1 : +1;\n        tmp *= binom(N - M, k);\n        tmp *= binom(r + N, N);\n        sum += ((t != 0) ? -1 : +1) * tmp;\n      }\n      debug {\n        writefln(\"  x = %s: sum = %s\", x, sum);\n      }\n    }\n    sep += sum;\n  }\n  const ret = all - binom(N, M) * sep;\n  debug {\n    writeln(\"  sep = \", sep);\n    writeln(\"  ret = \", ret);\n  }\n  return ret;\n}\n\nvoid main() {\n  prepare();\n  \n  try {\n    for (; ; ) {\n      const N = readLong();\n      const M = readLong();\n      const L = readLong();\n      const R = readLong();\n      \n      const ans = solve(N, M, R) - solve(N, M, L - 1);\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nstruct ModInt(long M) {\n  long x;\n  this(in ModInt a) { x = a.x; }\n  // this(in long a) { x = a % M; if (x < 0) x += M; }\n  this(in long a) { x = (a % M + M) % M; }\n  ref ModInt opAssign(in long a) { return this = ModInt(a); }\n  ref ModInt opOpAssign(string op)(in ModInt a) {\n    // static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    // else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    // else static if (op == \"*\") { x *= a.x; x %= M; }\n    static if (op == \"+\") { x += a.x; x = (x % M + M) % M; }\n    else static if (op == \"-\") { x -= a.x; x = (x % M + M) % M; }\n    else static if (op == \"*\") { x *= a.x; x = (x % M + M) % M; }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(in long a) { return mixin(\"this \" ~ op ~ \"= ModInt(a)\"); }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(in T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(in long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\n\nenum MO = 10L^^9 + 7;\nalias Mint = ModInt!MO;\nenum LIM = 10^^6;\n\nlong[] inv, fac, invFac;\nvoid prepare() {\n  inv = new long[LIM];\n  fac = new long[LIM];\n  invFac = new long[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = MO - ((MO / i) * inv[cast(size_t)(MO % i)]) % MO;\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = (fac[i - 1] * i) % MO;\n    invFac[i] = (invFac[i - 1] * inv[i]) % MO;\n  }\n}\nlong binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] % MO * invFac[cast(size_t)(n - k)] % MO;\n  } else {\n    return 0;\n  }\n}\n\n\nMint solve(long N, long M, long R) {\n  debug {\n    writefln(\"N = %s, M = %s, R = %s\", N, M, R);\n  }\n  Mint all = binom(R + N, N);\n  debug {\n    writeln(\"  all = \", all);\n  }\n  Mint sep;\n  foreach (x; 1 .. R + 1) {\n    if (R - M * x < 0) {\n      break;\n    }\n    Mint sum;\n    foreach (t; 0 .. 2) {\n      foreach (k; 0 .. N - M + 1) {\n        const r = R - M * (x + t) - k * x;\n        if (r < 0) {\n          break;\n        }\n        Mint tmp = (k % 2 != 0) ? -1 : +1;\n        debug {\n          writeln(\"    \", tmp);\n        }\n        tmp *= binom(N - M, k);\n        tmp *= binom(r + N, N);\n        debug {\n          writeln(\"    \", t, \" \", k, \" \", r, \" \", tmp);\n          writeln(\"    sum = \", sum);\n        }\n        // sum += ((t != 0) ? -1 : +1) * tmp;\n        if (t == 0) {\n          sum += tmp;\n        } else {\n          sum -= tmp;\n        }\n      }\n      debug {\n        writefln(\"  x = %s: sum = %s\", x, sum);\n      }\n    }\n    sep += sum;\n  }\n  const ret = all - binom(N, M) * sep;\n  debug {\n    writeln(\"  sep = \", sep);\n    writeln(\"  ret = \", ret);\n  }\n  return ret;\n}\n\nvoid main() {\n  prepare();\n  \n  try {\n    for (; ; ) {\n      const N = readLong();\n      const M = readLong();\n      const L = readLong();\n      const R = readLong();\n      \n      const ans = solve(N, M, R) - solve(N, M, L - 1);\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN,M,L,R = map(int,input().split())\n\nMOD = 10 ** 9 + 7\n\nX=1000\nfact = np.arange(X*X,dtype=np.int64).reshape(X,X)\nfact[0,0] = 1\nfor n in range(1,X):\n    fact[:,n] *= fact[:,n-1]\n    fact[:,n] %= MOD\nfor n in range(1,X):\n    fact[n] *= fact[n-1,-1]\n    fact[n] %= MOD\nfact = fact.ravel()\n\nfact_inv = np.arange(1,X*X+1,dtype=np.int64)[::-1].reshape(X,X)\nfact_inv[0,0] = pow(int(fact[-1]),MOD-2,MOD)\nfor n in range(1,X):\n    fact_inv[:,n] *= fact_inv[:,n-1]\n    fact_inv[:,n] %= MOD\nfor n in range(1,X):\n    fact_inv[n] *= fact_inv[n-1,-1]\n    fact_inv[n] %= MOD\nfact_inv = fact_inv.ravel()[::-1]\n\nU = N - M\ncomb = fact[U] * fact_inv[:U+1] % MOD * fact_inv[U::-1] % MOD\ncomb[1::2] *= (-1)\n\nF = np.zeros(N+M+1,dtype=np.int64)\nF[M:N+1] = comb\n\nP = np.zeros(R+1,dtype=np.int64)\nfor i,x in enumerate(F[1:],1):\n    P[::i] += x\n\nP[:M-1:-1] -= P[-M-1::-1]\nP %= MOD\n\n# (1-x)^{N+1}で割る\nQ = fact[N:N+R+1] * fact_inv[:R+1] % MOD * fact_inv[N] % MOD\n\ndef f(R):\n    total = fact[R+N] * fact_inv[R] % MOD * fact_inv[N] % MOD\n    x = (Q[R::-1] * P[:R+1] % MOD).sum() % MOD\n    coef = fact[N] * fact_inv[M] % MOD * fact_inv[N-M] % MOD\n    return (total - x*coef)%MOD\n\nanswer = (f(R) - f(L-1))%MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\n\nN,M,L,R = map(int,input().split())\n\nMOD = 10 ** 9 + 7\n\nU = 6*10**5 + 100\nfact = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1]*n%MOD\nfact_inv = [1] * (U+1)\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\nfact = np.array(fact,dtype=np.int64)\nfact_inv = np.array(fact_inv,dtype=np.int64)\n\nU = N - M\ncomb = fact[U] * fact_inv[:U+1] % MOD * fact_inv[U::-1] % MOD\ncomb[1::2] *= (-1)\n\nF = np.zeros(N+M+1,dtype=np.int64)\nF[M:N+1] = comb\n\nP = np.zeros(R+1,dtype=np.int64)\nfor a in range(1,R+1):\n    n = min(len(F),(R+a)//a)\n    P[:a*n:a] += F[:n]\n\nP[M:] -= P.copy()[:-M]\nP %= MOD\n\n# (1-x)^{N+1}で割る\nQ = fact[N:N+R+1] * fact_inv[:R+1] % MOD * fact_inv[N] % MOD\n\ndef f(R):\n    total = fact[R+N] * fact_inv[R] % MOD * fact_inv[N] % MOD\n    x = (Q[R::-1] * P[:R+1] % MOD).sum() % MOD\n    coef = fact[N] * fact_inv[M] % MOD * fact_inv[N-M] % MOD\n    return (total - x*coef)%MOD\n\nanswer = (f(R) - f(L-1))%MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "MOD = 10**9+7\n\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n): return kaijo_memo[n]\n  if(len(kaijo_memo) == 0): kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n): kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\n\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n): return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0): gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n): gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\n\ndef nCr(n,r):\n  if n == r: return 1\n  if n < r or r < 0: return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\n\nN,M,L,R = map(int,input().split())\n\nP = [0 for i in range(R+1)]\nfor k in range(R+1):\n  u = (R-M*(k+1))//(k+1)\n  for j in range(u+1):\n    P[(k+1)*j+M*(k+1)] += nCr(N-M,j)*(-1)**(j%2)\n    P[(k+1)*j+M*(k+1)] %= MOD\nfor k in range(1,R+1):\n  u = (R-M*(k+1))//k\n  for j in range(u+1):\n    P[k*j+M*(k+1)] -= nCr(N-M,j)*(-1)**(j%2)\n    P[k*j+M*(k+1)] %= MOD\n\nQ = [nCr(i+N,N) for i in range(R+1)]\n\ndef f(MAX):\n  ans = 0\n  for t in range(MAX+1):\n    ans += P[t]*Q[MAX-t]\n    ans %= MOD\n  return ans\n\ndef F(x):\n  return (Q[x]-nCr(N,M)*f(x))%MOD\n\nprint((F(R)-F(L-1))%MOD)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN,M,L,R = map(int,input().split())\n\nMOD = 10 ** 9 + 7\n\nX=1000\nfact = np.arange(X*X,dtype=np.int64).reshape(X,X)\nfact[0,0] = 1\nfor n in range(1,X):\n    fact[:,n] *= fact[:,n-1]\n    fact[:,n] %= MOD\nfor n in range(1,X):\n    fact[n] *= fact[n-1,-1]\n    fact[n] %= MOD\nfact = fact.ravel()\n\nfact_inv = np.arange(1,X*X+1,dtype=np.int64)[::-1].reshape(X,X)\nfact_inv[0,0] = pow(int(fact[-1]),MOD-2,MOD)\nfor n in range(1,X):\n    fact_inv[:,n] *= fact_inv[:,n-1]\n    fact_inv[:,n] %= MOD\nfor n in range(1,X):\n    fact_inv[n] *= fact_inv[n-1,-1]\n    fact_inv[n] %= MOD\nfact_inv = fact_inv.ravel()[::-1]\n\nU = N - M\ncomb = fact[U] * fact_inv[:U+1] % MOD * fact_inv[U::-1] % MOD\ncomb[1::2] *= (-1)\n\nP = np.zeros(R+1,dtype=np.int64)\nfor i,x in enumerate(comb,M):\n    P[::i] += x\n\nP[:M-1:-1] -= P[-M-1::-1]\nP %= MOD\n\n# (1-x)^{N+1}で割る\nQ = fact[N:N+R+1] * fact_inv[:R+1] % MOD * fact_inv[N] % MOD\n\ndef f(R):\n    total = fact[R+N] * fact_inv[R] % MOD * fact_inv[N] % MOD\n    x = (Q[R::-1] * P[:R+1] % MOD).sum() % MOD\n    coef = fact[N] * fact_inv[M] % MOD * fact_inv[N-M] % MOD\n    return (total - x*coef)%MOD\n\nanswer = (f(R) - f(L-1))%MOD\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = TEN(6);\n\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n}\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nll solve_sub(int N, int M, int S, int r, int l) {\n\tll v = 0;\n\tfor (int i = 0; i <= N - M; ++i) {\n\t\tll rem = S - (ll)r * M - (ll)(l + 1) * i;\n\t\tif (rem < 0) break;\n\t\tll t = comb(rem + N, N);\n\t\tif (i % 2 == 1) {\n\t\t\tt *= -1;\n\t\t}\n\n\t\tt = t * comb(N - M, i) % MOD;\n\t\tif (t < 0) t += MOD;\n\t\tv = (v + t) % MOD;\n\t}\n\tv = v * comb(N, M) % MOD;\n\treturn v;\n}\n\nll solve(int N, int M, int S) {\n\tll all = comb(S + N, N);\n\tll ng = 0;\n\n\tfor (int x = 1; (ll)x * M <= S; ++x) { //minimum of bigger part\n\t\tll a = solve_sub(N, M, S, x, x-1) - solve_sub(N, M, S, x+1, x-1);\n\t\tng = (ng + a) % MOD;\n\t\tif (ng < 0) ng += MOD;\n\t}\n\n\treturn (all - ng + MOD) % MOD;\n}\n\nint main() {\n\tint N, M, L, R;\n\tcin >> N >> M >> L >> R;\n\n\tinit();\n\n\tll ans = (solve(N, M, R) - solve(N, M, L-1) + MOD) % MOD;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nN,M,L,R = map(int,input().split())\n\nMOD = 10 ** 9 + 7\n\nU = 6*10**5 + 100\nfact = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1]*n%MOD\nfact_inv = [1] * (U+1)\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\nfact = np.array(fact,dtype=np.int64)\nfact_inv = np.array(fact_inv,dtype=np.int64)\n\nU = N - M\ncomb = fact[U] * fact_inv[:U+1] % MOD * fact_inv[U::-1] % MOD\ncomb[1::2] *= (-1)\n\nF = np.zeros(N+M+1,dtype=np.int64)\nF[M:N+1] = comb\n\nP = np.zeros(R+1,dtype=np.int64)\nfor i,x in enumerate(F[1:],1):\n    P[::i] += x\n\nP[:M-1:-1] -= P[-M-1::-1]\nP %= MOD\n\n# (1-x)^{N+1}で割る\nQ = fact[N:N+R+1] * fact_inv[:R+1] % MOD * fact_inv[N] % MOD\n\ndef f(R):\n    total = fact[R+N] * fact_inv[R] % MOD * fact_inv[N] % MOD\n    x = (Q[R::-1] * P[:R+1] % MOD).sum() % MOD\n    coef = fact[N] * fact_inv[M] % MOD * fact_inv[N-M] % MOD\n    return (total - x*coef)%MOD\n\nanswer = (f(R) - f(L-1))%MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\n\nN,M,L,R = map(int,input().split())\n\nMOD = 10 ** 9 + 7\n\nU = 6*10**5 + 100\nfact = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1]*n%MOD\nfact_inv = [1] * (U+1)\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\nfact = np.array(fact,dtype=np.int64)\nfact_inv = np.array(fact_inv,dtype=np.int64)\n\nU = N - M\ncomb = fact[U] * fact_inv[:U+1] % MOD * fact_inv[U::-1] % MOD\ncomb[1::2] *= (-1)\n\nF = np.zeros(N+M+1,dtype=np.int64)\nF[M:N+1] = comb\n\nP = np.zeros(R+1,dtype=np.int64)\nfor i,x in enumerate(F[1:],1):\n    P[::i] += x\n\nP[M:] -= P.copy()[:-M]\nP %= MOD\n\n# (1-x)^{N+1}で割る\nQ = fact[N:N+R+1] * fact_inv[:R+1] % MOD * fact_inv[N] % MOD\n\ndef f(R):\n    total = fact[R+N] * fact_inv[R] % MOD * fact_inv[N] % MOD\n    x = (Q[R::-1] * P[:R+1] % MOD).sum() % MOD\n    coef = fact[N] * fact_inv[M] % MOD * fact_inv[N-M] % MOD\n    return (total - x*coef)%MOD\n\nanswer = (f(R) - f(L-1))%MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\n\nN,M,L,R = map(int,input().split())\n\nMOD = 10 ** 9 + 7\n\nU = 6*10**5 + 100\nfact = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1]*n%MOD\nfact_inv = [1] * (U+1)\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\nfact = np.array(fact,dtype=np.int64)\nfact_inv = np.array(fact_inv,dtype=np.int64)\n\n\nU = N - M\ncomb = fact[U] * fact_inv[:U+1] % MOD * fact_inv[U::-1] % MOD\ncomb[1::2] *= (-1)\n\nP = np.zeros(R+1,dtype=np.int64)\nfor i,x in enumerate(comb,M):\n    P[::i] += x\n\n\nP[M:] -= P.copy()[:-M]\nP %= MOD\n\n# (1-x)^{N+1}で割る\nQ = fact[N:N+R+1] * fact_inv[:R+1] % MOD * fact_inv[N] % MOD\n\ndef f(R):\n    total = fact[R+N] * fact_inv[R] % MOD * fact_inv[N] % MOD\n    x = (Q[R::-1] * P[:R+1] % MOD).sum() % MOD\n    coef = fact[N] * fact_inv[M] % MOD * fact_inv[N-M] % MOD\n    return (total - x*coef)%MOD\n\nanswer = (f(R) - f(L-1))%MOD\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN,M,L,R = map(int,input().split())\n\nMOD = 10 ** 9 + 7\n\nX=1000\nfact = np.arange(X*X,dtype=np.int64).reshape(X,X)\nfact[0,0] = 1\nfor n in range(1,X):\n    fact[:,n] *= fact[:,n-1]\n    fact[:,n] %= MOD\nfor n in range(1,X):\n    fact[n] *= fact[n-1,-1]\n    fact[n] %= MOD\nfact = fact.ravel()\n\nfact_inv = np.arange(1,X*X+1,dtype=np.int64)[::-1].reshape(X,X)\nfact_inv[0,0] = pow(int(fact[-1]),MOD-2,MOD)\nfor n in range(1,X):\n    fact_inv[:,n] *= fact_inv[:,n-1]\n    fact_inv[:,n] %= MOD\nfor n in range(1,X):\n    fact_inv[n] *= fact_inv[n-1,-1]\n    fact_inv[n] %= MOD\nfact_inv = fact_inv.ravel()[::-1]\n\nU = N - M\ncomb = fact[U] * fact_inv[:U+1] % MOD * fact_inv[U::-1] % MOD\ncomb[1::2] *= (-1)\n\nP = np.zeros(R+1,dtype=np.int64)\nfor i,x in enumerate(comb,M):\n    P[::i] += x\n\nP[M:] -= P.copy()[:-M]\nP %= MOD\n\n# (1-x)^{N+1}で割る\nQ = fact[N:N+R+1] * fact_inv[:R+1] % MOD * fact_inv[N] % MOD\n\ndef f(R):\n    total = fact[R+N] * fact_inv[R] % MOD * fact_inv[N] % MOD\n    x = (Q[R::-1] * P[:R+1] % MOD).sum() % MOD\n    coef = fact[N] * fact_inv[M] % MOD * fact_inv[N-M] % MOD\n    return (total - x*coef)%MOD\n\nanswer = (f(R) - f(L-1))%MOD\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\n#############\n# Libraries #\n#############\n\nimport sys\ninput = sys.stdin.readline\n\nimport math\n#from math import gcd\nimport bisect\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom functools import lru_cache\n\n#############\n# Constants #\n#############\n\nMOD = 10**9+7\nINF = float('inf')\nAZ = \"abcdefghijklmnopqrstuvwxyz\"\n\n#############\n# Functions #\n#############\n\n######INPUT######\ndef I(): return int(input().strip())\ndef S(): return input().strip()\ndef IL(): return list(map(int,input().split()))\ndef SL(): return list(map(str,input().split()))\ndef ILs(n): return list(int(input()) for _ in range(n))\ndef SLs(n): return list(input().strip() for _ in range(n))\ndef ILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef SLL(n): return [list(map(str, input().split())) for _ in range(n)]\n\n######OUTPUT######\ndef P(arg): print(arg); return\ndef Y(): print(\"Yes\"); return\ndef N(): print(\"No\"); return\ndef E(): exit()\ndef PE(arg): print(arg); exit()\ndef YE(): print(\"Yes\"); exit()\ndef NE(): print(\"No\"); exit()\n\n#####Shorten#####\ndef DD(arg): return defaultdict(arg)\n\n#####Inverse#####\ndef inv(n): return pow(n, MOD-2, MOD)\n\n######Combination######\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n): return kaijo_memo[n]\n  if(len(kaijo_memo) == 0): kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n): kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\n\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n): return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0): gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n): gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\n\ndef nCr(n,r):\n  if n == r: return 1\n  if n < r or r < 0: return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\n\n######Factorization######\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5//1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0: \n        cnt+=1 \n        temp //= i\n      arr.append([i, cnt])\n  if temp!=1: arr.append([temp, 1])\n  if arr==[]: arr.append([n, 1])\n  return arr\n\n#####MakeDivisors######\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i: \n        divisors.append(n//i)\n  return divisors\n\n#####MakePrimes######\ndef make_primes(N):\n  max = int(math.sqrt(N))\n  seachList = [i for i in range(2,N+1)]\n  primeNum = []\n  while seachList[0] <= max:\n    primeNum.append(seachList[0])\n    tmp = seachList[0]\n    seachList = [i for i in seachList if i % tmp != 0]\n  primeNum.extend(seachList)\n  return primeNum\n\n#####GCD#####\ndef gcd(a, b):\n    while b: a, b = b, a % b\n    return a\n\n#####LCM#####\ndef lcm(a, b):\n    return a * b // gcd (a, b)\n\n#####BitCount#####\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n-1\n    count += 1\n  return count\n\n#####ChangeBase#####\ndef base_10_to_n(X, n):\n  if X//n: return base_10_to_n(X//n, n)+[X%n]\n  return [X%n]\n\ndef base_n_to_10(X, n):\n  return sum(int(str(X)[-i-1])*n**i for i in range(len(str(X))))\n\ndef base_10_to_n_without_0(X, n):\n  X -= 1\n  if X//n: return base_10_to_n_without_0(X//n, n)+[X%n]\n  return [X%n]\n\n#####IntLog#####\ndef int_log(n, a):\n  count = 0\n  while n>=a:\n    n //= a\n    count += 1\n  return count\n\n#############\n# Main Code #\n#############\nN,M,L,R = IL()\n\nP = [0 for i in range(R+1)]\n\nfor k in range(R+1):\n  u = (R-M*(k+1))//(k+1)\n  for j in range(u+1):\n    P[(k+1)*j+M*(k+1)] += nCr(N-M,j)*(-1)**(j%2)\n    P[(k+1)*j+M*(k+1)] %= MOD\nfor k in range(1,R+1):\n  u = (R-M*(k+1))//k\n  for j in range(u+1):\n    P[k*j+M*(k+1)] -= nCr(N-M,j)*(-1)**(j%2)\n    P[k*j+M*(k+1)] %= MOD\n    \n\"\"\"\n@lru_cache(maxsize=None)\ndef P(t):\n  ans = 0\n  for k in range(t+1):\n    u = t-M*(k+1)\n    if u>=0:\n      if u%(k+1) == 0:\n        ans += nCr(N-M,u//(k+1))*(-1)**((u//(k+1))%2)\n    ans %= MOD\n  for k in range(t+1):\n    u = t-M*(k+1)\n    if u>=0:\n      if k!=0:\n        if u%k == 0:\n          ans -= nCr(N-M,u//k)*(-1)**((u//k)%2)\n    ans %= MOD\n  return ans\n\"\"\"\n\n@lru_cache(maxsize=None)\ndef Q(t):\n  ans = nCr(t+N,N)\n  return ans\n\ndef f(MAX):\n  ans = 0\n  for t in range(MAX+1):\n    ans += P[t]*Q(MAX-t)\n    ans %= MOD\n  return ans\n\ndef F(x):\n  return (Q(x)-nCr(N,M)*f(x))%MOD\n\nprint((F(R)-F(L-1))%MOD)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\n#############\n# Libraries #\n#############\n\nimport sys\ninput = sys.stdin.readline\n\nimport math\n#from math import gcd\nimport bisect\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom functools import lru_cache\n\n#############\n# Constants #\n#############\n\nMOD = 10**9+7\nINF = float('inf')\nAZ = \"abcdefghijklmnopqrstuvwxyz\"\n\n#############\n# Functions #\n#############\n\n######INPUT######\ndef I(): return int(input().strip())\ndef S(): return input().strip()\ndef IL(): return list(map(int,input().split()))\ndef SL(): return list(map(str,input().split()))\ndef ILs(n): return list(int(input()) for _ in range(n))\ndef SLs(n): return list(input().strip() for _ in range(n))\ndef ILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef SLL(n): return [list(map(str, input().split())) for _ in range(n)]\n\n######OUTPUT######\ndef P(arg): print(arg); return\ndef Y(): print(\"Yes\"); return\ndef N(): print(\"No\"); return\ndef E(): exit()\ndef PE(arg): print(arg); exit()\ndef YE(): print(\"Yes\"); exit()\ndef NE(): print(\"No\"); exit()\n\n#####Shorten#####\ndef DD(arg): return defaultdict(arg)\n\n#####Inverse#####\ndef inv(n): return pow(n, MOD-2, MOD)\n\n######Combination######\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n): return kaijo_memo[n]\n  if(len(kaijo_memo) == 0): kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n): kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\n\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n): return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0): gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n): gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\n\ndef nCr(n,r):\n  if n == r: return 1\n  if n < r or r < 0: return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\n\n######Factorization######\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5//1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0: \n        cnt+=1 \n        temp //= i\n      arr.append([i, cnt])\n  if temp!=1: arr.append([temp, 1])\n  if arr==[]: arr.append([n, 1])\n  return arr\n\n#####MakeDivisors######\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i: \n        divisors.append(n//i)\n  return divisors\n\n#####MakePrimes######\ndef make_primes(N):\n  max = int(math.sqrt(N))\n  seachList = [i for i in range(2,N+1)]\n  primeNum = []\n  while seachList[0] <= max:\n    primeNum.append(seachList[0])\n    tmp = seachList[0]\n    seachList = [i for i in seachList if i % tmp != 0]\n  primeNum.extend(seachList)\n  return primeNum\n\n#####GCD#####\ndef gcd(a, b):\n    while b: a, b = b, a % b\n    return a\n\n#####LCM#####\ndef lcm(a, b):\n    return a * b // gcd (a, b)\n\n#####BitCount#####\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n-1\n    count += 1\n  return count\n\n#####ChangeBase#####\ndef base_10_to_n(X, n):\n  if X//n: return base_10_to_n(X//n, n)+[X%n]\n  return [X%n]\n\ndef base_n_to_10(X, n):\n  return sum(int(str(X)[-i-1])*n**i for i in range(len(str(X))))\n\ndef base_10_to_n_without_0(X, n):\n  X -= 1\n  if X//n: return base_10_to_n_without_0(X//n, n)+[X%n]\n  return [X%n]\n\n#####IntLog#####\ndef int_log(n, a):\n  count = 0\n  while n>=a:\n    n //= a\n    count += 1\n  return count\n\n#############\n# Main Code #\n#############\nN,M,L,R = IL()\nM = max(M,N-M)\n\n@lru_cache(maxsize=None)\ndef P(t):\n  ans = 0\n  for k in range(t//M+1):\n    u = t-M*(k+1)\n    if u>=0:\n      if u%(k+1) == 0:\n        ans += nCr(N-M,u//(k+1))*(-1)**((u//(k+1))%2)\n      if k!=0:\n        if u%k == 0:\n          ans -= nCr(N-M,u//k)*(-1)**((u//k)%2)\n    ans %= MOD\n  return ans\n\n@lru_cache(maxsize=None)\ndef Q(t):\n  ans = nCr(t+N,N)\n  return ans\n\ndef f(MAX):\n  ans = 0\n  for t in range(MAX+1):\n    ans += P(t)*Q(MAX-t)\n    ans %= MOD\n  return ans\n\ndef F(x):\n  return (Q(x)-nCr(N,M)*f(x))%MOD\n  \nprint((F(R)-F(L-1))%MOD)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\n#############\n# Libraries #\n#############\n\nimport sys\ninput = sys.stdin.readline\n\nimport math\n#from math import gcd\nimport bisect\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom functools import lru_cache\n\n#############\n# Constants #\n#############\n\nMOD = 10**9+7\nINF = float('inf')\nAZ = \"abcdefghijklmnopqrstuvwxyz\"\n\n#############\n# Functions #\n#############\n\n######INPUT######\ndef I(): return int(input().strip())\ndef S(): return input().strip()\ndef IL(): return list(map(int,input().split()))\ndef SL(): return list(map(str,input().split()))\ndef ILs(n): return list(int(input()) for _ in range(n))\ndef SLs(n): return list(input().strip() for _ in range(n))\ndef ILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef SLL(n): return [list(map(str, input().split())) for _ in range(n)]\n\n######OUTPUT######\ndef P(arg): print(arg); return\ndef Y(): print(\"Yes\"); return\ndef N(): print(\"No\"); return\ndef E(): exit()\ndef PE(arg): print(arg); exit()\ndef YE(): print(\"Yes\"); exit()\ndef NE(): print(\"No\"); exit()\n\n#####Shorten#####\ndef DD(arg): return defaultdict(arg)\n\n#####Inverse#####\ndef inv(n): return pow(n, MOD-2, MOD)\n\n######Combination######\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n): return kaijo_memo[n]\n  if(len(kaijo_memo) == 0): kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n): kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\n\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n): return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0): gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n): gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\n\ndef nCr(n,r):\n  if n == r: return 1\n  if n < r or r < 0: return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\n\n######Factorization######\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5//1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0: \n        cnt+=1 \n        temp //= i\n      arr.append([i, cnt])\n  if temp!=1: arr.append([temp, 1])\n  if arr==[]: arr.append([n, 1])\n  return arr\n\n#####MakeDivisors######\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i: \n        divisors.append(n//i)\n  return divisors\n\n#####MakePrimes######\ndef make_primes(N):\n  max = int(math.sqrt(N))\n  seachList = [i for i in range(2,N+1)]\n  primeNum = []\n  while seachList[0] <= max:\n    primeNum.append(seachList[0])\n    tmp = seachList[0]\n    seachList = [i for i in seachList if i % tmp != 0]\n  primeNum.extend(seachList)\n  return primeNum\n\n#####GCD#####\ndef gcd(a, b):\n    while b: a, b = b, a % b\n    return a\n\n#####LCM#####\ndef lcm(a, b):\n    return a * b // gcd (a, b)\n\n#####BitCount#####\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n-1\n    count += 1\n  return count\n\n#####ChangeBase#####\ndef base_10_to_n(X, n):\n  if X//n: return base_10_to_n(X//n, n)+[X%n]\n  return [X%n]\n\ndef base_n_to_10(X, n):\n  return sum(int(str(X)[-i-1])*n**i for i in range(len(str(X))))\n\ndef base_10_to_n_without_0(X, n):\n  X -= 1\n  if X//n: return base_10_to_n_without_0(X//n, n)+[X%n]\n  return [X%n]\n\n#####IntLog#####\ndef int_log(n, a):\n  count = 0\n  while n>=a:\n    n //= a\n    count += 1\n  return count\n\n#############\n# Main Code #\n#############\nN,M,L,R = IL()\n\n@lru_cache(maxsize=None)\ndef P(t):\n  ans = 0\n  for k in range(t//M+1):\n    u = t-M*(k+1)\n    if u>=0:\n      if u%(k+1) == 0:\n        ans += nCr(N-M,u//(k+1))*(-1)**((u//(k+1))%2)\n      if k!=0:\n        if u%k == 0:\n          ans -= nCr(N-M,u//k)*(-1)**((u//k)%2)\n    ans %= MOD\n  return ans\n\n@lru_cache(maxsize=None)\ndef Q(t):\n  ans = nCr(t+N,N)\n  return ans\n\ndef f(MAX):\n  ans = 0\n  for t in range(MAX+1):\n    ans += P(t)*Q(MAX-t)\n    ans %= MOD\n  return ans\n\ndef F(x):\n  return (Q(x)-nCr(N,M)*f(x))%MOD\n  \nprint((F(R)-F(L-1))%MOD)"
  },
  {
    "language": "Python",
    "code": "MOD = 10**9+7\n\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n): return kaijo_memo[n]\n  if(len(kaijo_memo) == 0): kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n): kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\n\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n): return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0): gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n): gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\n\ndef nCr(n,r):\n  if n == r: return 1\n  if n < r or r < 0: return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\n\nN,M,L,R = map(int,input().split())\n\nP = [0 for i in range(R+1)]\nQ = [0 for i in range(R+1)]\nZ = [0 for i in range(R+1)]\nfor k in range(1,R+1):\n  u = (R-M*k)//k\n  for j in range(u+1):\n    P[k*j+M*k] += nCr(N-M,j)*(-1)**(j%2)\n    P[k*j+M*k] %= MOD\nfor k in range(R+1):\n  Q[k] += nCr(k+N,N)\n  Q[k] %= MOD\n  Z[k] += nCr(k+N,N)\n  Z[k] %= MOD\nfor k in range(R-M+1):\n  Q[k+M] -= nCr(k+N,N)\n  Q[k+M] %= MOD\n\ndef f(MAX):\n  ans = 0\n  for t in range(MAX+1):\n    ans += P[t]*Q[MAX-t]\n    ans %= MOD\n  return ans\n\ndef F(x):\n  return (Z[x]-nCr(N,M)*f(x))%MOD\n\nprint((F(R)-F(L-1))%MOD)"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nfn main() {\n    input!{\n        n: usize,\n        m: usize,\n        l: usize,\n        r: usize\n    }\n    let d = 1000000007;\n    let ans = (solve(r, n, m, d) + d - solve(l - 1, n, m, d)) % d;\n    println!(\"{}\", ans);\n}\n\nfn solve(r: usize, n: usize, m: usize, d: usize) -> usize {\n    let mut st = vec![1; n + r + 1];\n    for i in 1..n + r + 1 {\n        st[i] = st[i - 1] * i % d;\n    }\n    let sti: Vec<usize> = st.iter().map(|&x| inv_m(x, d)).collect();\n    let mut a = vec![0; r + 1];\n    for i in 0..r + 1 {\n        a[i] = st[n + i] * sti[n] % d * sti[i] % d;\n    }\n    for i in (m..r + 1).rev() {\n        a[i] = (a[i] + d - a[i - m]) % d;\n    }\n    let mut b = vec![0; r + 1];\n    for i in 0..n - m + 1 {\n        let c = st[n - m] * sti[i] % d * sti[n - m - i] % d;\n        for j in 1..r {\n            if (i + m) * j > r {\n                break;\n            }\n            if i % 2 == 0 {\n                b[(i + m) * j] = (b[(i + m) * j] + c) % d;\n            } else {\n                b[(i + m) * j] = (b[(i + m) * j] + d - c) % d;\n            }\n        }\n    }\n    let cr = a.iter().zip(b.iter().rev()).fold(0, |ac, (&x, &y)| (ac + x * y) % d);\n    (st[n + r] * sti[n] % d * sti[r] % d + d - st[n] * sti[m] % d * sti[n - m] % d * cr % d) % d\n}\n\nfn pow_m(n: usize, mut p: usize, d: usize) -> usize {\n    let mut r = n;\n    let mut ret = 1;\n    while p > 0 {\n        if p % 2 == 0 {\n            r = r * r % d;\n            p /= 2;\n        } else {\n            ret = ret * r % d;\n            p -= 1;\n        }\n    }\n    ret\n}\n\nfn inv_m(n: usize, d: usize) -> usize {\n    pow_m(n, d - 2, d)\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_f\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nstruct Combination {\n    fact: Vec<u64>,\n    invfact: Vec<u64>,\n}\n\nimpl Combination {\n    fn inv(a: u64) -> u64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: u64, p: u64) -> u64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as u64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as u64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: u64, r: u64) -> u64 {\n        if n < 0 || r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n as usize] * self.invfact[r as usize] % MOD * self.invfact[(n - r) as usize] % MOD\n    }\n\n    fn perm(&self, n: usize, r: usize) -> u64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[n-r] % MOD\n    }\n}\n\nconst MOD: u64 = 1e9 as u64 + 7;\n\nfn doit(n: u64, less: u64, total: u64, max: u64, comb: &Combination) -> u64 {\n    let mut ret = 0;\n    for z in 0..less+1 {\n        if total < max * z {\n            break;\n        }\n        let part = comb.comb(total-max*z+n, n) * comb.comb(less, z) % MOD;\n        if z % 2 == 0 {\n            ret += part;\n        } else {\n            ret += MOD-part;\n        }\n        ret %= MOD;\n    }\n    ret\n}\n\nfn solve(n: u64, m: u64, x: u64, comb: &Combination) -> u64 {\n    let all = comb.comb(x+n, n); // Σ(i=0 to x)comb.comb(i+n-1, n-1);\n    let less = n-m;\n    let more = m;\n\n    let mut total_ng = 0;\n    for k in 0..x {\n        let lk = k;\n        let rk = k+1;\n        if lk + rk > x {\n            continue;\n        }\n        if rk * more > x {\n            continue\n        }\n        let ptnall = comb.comb(x-rk*more+n, n); // Σ(i=0 to x)comb.comb(i-rk*more+n-1, n-1);\n\n        // L is no less than lk+1\n        let mut w0 = doit(n, less, x-rk*more, lk+1, comb);\n        // L is no less than lk\n        let mut w1 = doit(n, less, x-rk*more, lk, comb);\n\n        // let ptnngl = if lk + 1 + rk * more > x {\n        //     0\n        // } else {\n        //     (comb.comb(x-rk*more-lk-1+n, n) * less) % MOD\n        // };\n        // // L is no less than lk\n        // let ptnnglp1 = if lk + rk * more > x {\n        //     0\n        // } else {\n        //     (comb.comb(x-rk*more-lk+n, n) * less) % MOD\n        // };\n        // debug!(x, w0, w1);\n        total_ng += w0 + MOD - w1;\n        total_ng %= MOD;\n\n    }\n    // debug!(\"==\", all, total_ng, total_ng * comb.comb(less+more, less));\n\n    total_ng *= comb.comb(less+more, less);\n    total_ng %= MOD;\n    (all + MOD - total_ng) % MOD\n}\n\nfn main() {\n    input! {\n        n: u64, m: u64, l: u64, r: u64\n    };\n\n    let comb = Combination::new(650000);\n    let left = solve(n, m, l-1, &comb);\n    let right = solve(n, m, r, &comb);\n\n    // debug!(left, right);\n    println!(\"{}\", (right + MOD - left) % MOD);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n// ---------- begin Precalc ----------\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD / i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n// ---------- end Precalc ----------\n\nuse std::cmp::*;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let it = s.trim().split_whitespace();\n    let a: Vec<usize> = it.map(|s| s.parse().unwrap()).collect();\n    let (n, m, l, r) = (a[0], a[1], a[2], a[3]);\n    let pc = Precalc::new(r + n);\n    let calc = |x: usize| -> ModInt {\n        let mut all = pc.comb(x + n, n);\n        for k in 1..(x / m + 1) {\n            let rem = x - k * m;\n            let mut sign = ModInt::one();\n            let mut way = ModInt::zero();\n            for i in 0..(min(n - m, rem / k) + 1) {\n                let mut v = pc.comb(rem - k * i + n, n);\n                if rem >= k * i + m {\n                    v -= pc.comb(rem - k * i - m + n, n);\n                }\n                way += sign * v * pc.comb(n - m, i);\n                sign = -sign;\n            }\n            all -= way * pc.comb(n, m);\n        }\n        all\n    };\n    let ans = calc(r) - calc(l - 1);\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_f\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\n// ===\n\nstruct Combination {\n    fact: Vec<i64>,\n    invfact: Vec<i64>,\n}\n\nimpl Combination {\n    fn inv(a: i64) -> i64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: i64, p: i64) -> i64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as i64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as i64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: usize, r: usize) -> i64 {\n        if r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[r] % MOD * self.invfact[n - r] % MOD\n    }\n}\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\n//===\n\n// ===\n\nfn solve(n: usize, m: usize, x: usize, comb: &Combination) -> i64 {\n    let k = n-m;\n    let mut total = 0i64;\n    for a in 1..x+1 {\n        for f in 0..2 {\n            for i in 0..k+1 {\n                let rm = a*m+(a-f)*i;\n                if x < rm {\n                    break;\n                }\n                let left = x-rm;\n                let add = comb.comb(left+n, n) * comb.comb(k, i) % MOD;\n                if (i % 2 == 0) ^ (f == 1) {\n                    total += add;\n                } else {\n                    total += MOD-add;\n                }\n                total %= MOD;\n            }\n        }\n    }\n    (comb.comb(x+n, n) + MOD - total * comb.comb(n, m) % MOD) % MOD\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize, l: usize, r: usize\n    };\n    let comb = Combination::new(1000000);\n\n    let w = solve(n, m, r, &comb) + MOD - solve(n, m, l-1, &comb);\n    println!(\"{}\", w%MOD);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_f\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nstruct Combination {\n    fact: Vec<u64>,\n    invfact: Vec<u64>,\n}\n\nimpl Combination {\n    fn inv(a: u64) -> u64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: u64, p: u64) -> u64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as u64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as u64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: u64, r: u64) -> u64 {\n        if n < 0 || r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n as usize] * self.invfact[r as usize] % MOD * self.invfact[(n - r) as usize] % MOD\n    }\n\n    fn perm(&self, n: usize, r: usize) -> u64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[n-r] % MOD\n    }\n}\n\nconst MOD: u64 = 1e9 as u64 + 7;\n\nfn doit(n: u64, less: u64, total: u64, max: u64, comb: &Combination) -> u64 {\n    let mut ret = 0;\n    for z in 0..less+1 {\n        if total < max * z {\n            break;\n        }\n        let part = comb.comb(total-max*z+n, n) * comb.comb(less, z) % MOD;\n        if z % 2 == 0 {\n            ret += part;\n        } else {\n            ret += MOD-part;\n        }\n        ret %= MOD;\n    }\n    ret\n}\n\nfn solve(n: u64, m: u64, x: u64, comb: &Combination) -> u64 {\n    let all = comb.comb(x+n, n); // Σ(i=0 to x)comb.comb(i+n-1, n-1);\n    let less = n-m;\n    let more = m;\n\n    let mut total_ng = 0;\n    for k in 0..x {\n        let lk = k;\n        let rk = k+1;\n        if lk + rk > x {\n            continue;\n        }\n        if rk * more > x {\n            continue\n        }\n        // L is no less than lk+1\n        let mut w0 = doit(n, less, x-rk*more, lk+1, comb);\n        // L is no less than lk\n        let mut w1 = doit(n, less, x-rk*more, lk, comb);\n\n        // L is exactly equal to lk\n        total_ng += w0 + MOD - w1;\n        total_ng %= MOD;\n\n    }\n    total_ng *= comb.comb(less+more, less);\n    total_ng %= MOD;\n    (all + MOD - total_ng) % MOD\n}\n\nfn main() {\n    input! {\n        n: u64, m: u64, l: u64, r: u64\n    };\n\n    let comb = Combination::new(650000);\n    let left = solve(n, m, l-1, &comb);\n    let right = solve(n, m, r, &comb);\n\n    // debug!(left, right);\n    println!(\"{}\", (right + MOD - left) % MOD);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ${url}\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nstruct Combination {\n    fact: Vec<i64>,\n    invfact: Vec<i64>,\n}\n\nimpl Combination {\n    fn inv(a: i64) -> i64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: i64, p: i64) -> i64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as i64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as i64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: usize, r: usize) -> i64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[r] % MOD * self.invfact[n - r] % MOD\n    }\n}\n\n//===\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\nfn solve(n: usize, m: usize, h: usize) -> i64 {\n    let comb = Combination::new(h+n+10);\n    let more = m;\n    let less = n - m;\n    let mut total = 0;\n    for l in 0..h {\n        let least_use = (l+1) * more;\n        if least_use > h {\n            break;\n        }\n        let mut w = 0;\n        let left = h - least_use;\n        for z in 0..less+1 {\n            let f = (l+1)*z;\n            if left < f {\n                break;\n            }\n            let add = comb.comb(less, z) * comb.comb(left-f+n, n) % MOD;\n            if z % 2 == 0 {\n                w += add;\n            } else {\n                w += MOD-add;\n            }\n        }\n        for z in 0..less+1 {\n            let f = l*z;\n            if left < f {\n                break;\n            }\n            let add = comb.comb(less, z) * comb.comb(left-f+n, n) % MOD;\n            if z % 2 == 1 {\n                w += add;\n            } else {\n                w += MOD-add;\n            }\n        }\n        total += w % MOD;\n        total %= MOD;\n    }\n    total *= comb.comb(n, m);\n    total %= MOD;\n    (comb.comb(h+n, n) + MOD - total) % MOD\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize, low: usize, high: usize\n    };\n    println!(\"{}\", (solve(n, m, high) + MOD - solve(n, m, low-1)) % MOD);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\n//https://github.com/kenkoooo/competitive-programming-rs/blob/master/src/math/mod_int.rs\n//を参考にしています\n#[allow(dead_code)]\nmod modint {\n    pub const MOD: u32 = 1_000_000_007;\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n    type Num = u32;\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, other: ModInt<Num>) -> ModInt<Num> {\n            let mut d = self.0 + other.0;\n            if d >= MOD {\n                d -= MOD;\n            }\n            ModInt(d)\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, other: ModInt<Num>) -> ModInt<Num> {\n            let mut d = self.0 + MOD - other.0;\n            if d >= MOD {\n                d -= MOD;\n            }\n            ModInt(d)\n        }\n    }\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn mul(self, other: ModInt<Num>) -> ModInt<Num> {\n            ModInt(((self.0 as u64) * (other.0 as u64) % (MOD as u64)) as u32)\n        }\n    }\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, other: ModInt<Num>) {\n            *self = *self * other;\n        }\n    }\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, other: ModInt<Num>) -> ModInt<Num> {\n            self * other.pow(MOD - 2)\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, other: ModInt<Num>) {\n            *self = *self / other;\n        }\n    }\n    impl Neg for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn neg(self) -> ModInt<Num> {\n            ModInt(if self.0 == 0 { 0 } else { MOD - self.0 })\n        }\n    }\n    impl ModInt<Num> {\n        pub fn new(v: u32) -> ModInt<Num> {\n            ModInt(v % MOD)\n        }\n        pub fn pow(self, mut n: u32) -> ModInt<Num> {\n            let mut t = ModInt::new(1);\n            let mut s = self;\n            while n > 0 {\n                if (n & 1) == 1 {\n                    t *= s;\n                }\n                s *= s;\n                n >>= 1;\n            }\n            t\n        }\n    }\n    pub struct Precalc {\n        n: usize,\n        inv: Vec<ModInt<Num>>,\n        fact: Vec<ModInt<Num>>,\n        ifact: Vec<ModInt<Num>>,\n    }\n    impl Precalc {\n        pub fn new(n: usize) -> Precalc {\n            let mut inv = vec![ModInt(1); n + 1];\n            let mut fact = vec![ModInt(1); n + 1];\n            let mut ifact = vec![ModInt(1); n + 1];\n            for i in 1..(n + 1) {\n                if i >= 2 {\n                    inv[i] = -inv[(MOD as usize) % i] * ModInt(MOD / (i as u32));\n                }\n                fact[i] = ModInt(i as u32) * fact[i - 1];\n                ifact[i] = inv[i] * ifact[i - 1];\n            }\n            Precalc {\n                n: n,\n                inv: inv,\n                fact: fact,\n                ifact: ifact,\n            }\n        }\n        pub fn fact(&self, n: usize) -> ModInt<Num> {\n            self.fact[n]\n        }\n        pub fn inv(&self, x: usize) -> ModInt<Num> {\n            self.inv[x]\n        }\n        pub fn ifact(&self, x: usize) -> ModInt<Num> {\n            self.ifact[x]\n        }\n        pub fn comb(&self, n: usize, k: usize) -> ModInt<Num> {\n            if !(k <= n) {\n                return ModInt(0);\n            }\n            self.fact[n] * self.ifact[k] * self.ifact[n - k]\n        }\n    }\n    use std;\n    impl std::fmt::Display for ModInt<Num> {\n        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n}\n// ---------- end ModInt ----------\n\nuse modint::*;\n\nfn calc(r: usize, n: usize, m: usize, pc: &Precalc) -> ModInt<u32> {\n    let mut sum = ModInt(0);\n    for k in 1..(r / m + 1) {\n        let r = r - k * m;\n        let mut sign = ModInt(1);\n        let mut i = 0;\n        while i <= n - m && k * i <= r {\n            let way = if m <= r - k * i {\n                pc.comb(r - k * i + n, n) - pc.comb(r - k * i - m + n, n)\n            } else {\n                pc.comb(r - k * i + n, n)\n            };\n            sum += sign * pc.comb(n - m, i) * way;\n            i += 1;\n            sign = -sign;\n        }\n    }\n    pc.comb(r + n, n) - sum * pc.comb(n, m)\n}\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let m: usize = it.next().unwrap().parse().unwrap();\n    let l: usize = it.next().unwrap().parse().unwrap();\n    let r: usize = it.next().unwrap().parse().unwrap();\n    let pc = Precalc::new(r + n);\n    let ans = calc(r, n, m, &pc) - calc(l - 1, n, m, &pc);\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  }
]