[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 105\n#define MAX_R 10005\n\nlong long dp[MAX_N][MAX_R];\n\nint main() {\n    int N, L, R, M;\n    scanf(\"%d %d %d %d\", &N, &L, &R, &M);\n\n    dp[0][0] = 1;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j <= R; j++) {\n            for (int k = 0; k <= j && k <= R; k++) {\n                dp[i][j] = (dp[i][j] + dp[i-1][j-k]) % MOD;\n            }\n        }\n    }\n\n    long long result = 0;\n    for (int x = 0; x <= R; x++) {\n        for (int total = L; total <= R; total++) {\n            if (total - x >= 0 && total - x <= R) {\n                result = (result + dp[N-1][total-x] * dp[1][x]) % MOD;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:43:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 200\n\nlong long comb[MAX_N + 1][MAX_N + 1];\n\nvoid precompute_comb() {\n    for (int i = 0; i <= MAX_N; i++) {\n        comb[i][0] = 1;\n        for (int j = 1; j <= i; j++) {\n            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;\n        }\n    }\n}\n\nlong long mod(long long x) {\n    return (x % MOD + MOD) % MOD;\n}\n\nlong long solve(int N, int M, int L, int R) {\n    precompute_comb();\n    long long total = 0;\n    for (int k = 0; k <= N; k++) {\n        long long c = comb[N][k];\n        for (int t = 0; t <= k; t++) {\n            long long c1 = comb[k][t];\n            for (int s = 0; s <= N - k; s++) {\n                long long c2 = comb[N - k][s];\n                int a = t + s;\n                int b = t;\n                int lower = a * M + b * (N - M);\n                int upper = a * M + b * (N - M) + (a + b) * (R - L);\n                if (lower <= R && upper >= L) {\n                    int actual_lower = (lower > L) ? lower : L;\n                    int actual_upper = (upper < R) ? upper : R;\n                    if (actual_lower <= actual_upper) {\n                        long long ways = mod(c * c1);\n                        ways = mod(ways * c2);\n                        ways = mod(ways * (actual_upper - actual_lower + 1));\n                        total = mod(total + ways);\n                    }\n                }\n            }\n        }\n    }\n    return total;\n}\n\nint main() {\n    int N, M, L, R;\n    scanf(\"%d %d %d %d\", &N, &M, &L, &R);\n    printf(\"%lld\\n\", solve(N, M, L, R));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nint comb[3001][3001];\n\nvoid precompute() {\n    comb[0][0] = 1;\n    for (int n = 1; n <= 3000; ++n) {\n        comb[n][0] = 1;\n        for (int k = 1; k <= n; ++k) {\n            comb[n][k] = (comb[n-1][k-1] + comb[n-1][k]) % MOD;\n        }\n    }\n}\n\nint solve(int N, int M, int L, int R) {\n    precompute();\n    int total = 0;\n    for (int s = L; s <= R; ++s) {\n        for (int k = 0; k <= N - M; ++k) {\n            int t = s - k;\n            if (t < 0) continue;\n            int ways = comb[N][M];\n            if (k > 0) {\n                ways = 1LL * ways * comb[N - M + k - 1][k] % MOD;\n            }\n            total = (total + ways) % MOD;\n        }\n    }\n    return total;\n}\n\nint main() {\n    int N, M, L, R;\n    cin >> N >> M >> L >> R;\n    cout << solve(N, M, L, R) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n    static long[] fact;\n    static long[] invFact;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int L = sc.nextInt();\n        int R = sc.nextInt();\n\n        precomputeFactorials(N + R);\n\n        long total = 0;\n        for (int k = 0; k <= R; k++) {\n            long c = comb(N + k - 1, k);\n            if (k >= L) {\n                total = (total + c) % MOD;\n            }\n        }\n\n        long invalid = 0;\n        for (int k = 0; k <= R; k++) {\n            int maxA = k / M;\n            long sum = 0;\n            for (int a = 0; a <= maxA; a++) {\n                int rem = k - a * M;\n                if (rem < 0) continue;\n                long term = comb(N, M);\n                term = term * comb(M + a - 1, a) % MOD;\n                term = term * comb(N - M + rem - 1, rem) % MOD;\n                sum = (sum + term) % MOD;\n            }\n            if (k >= L) {\n                invalid = (invalid + sum) % MOD;\n            }\n        }\n\n        long answer = (total - invalid + MOD) % MOD;\n        System.out.println(answer);\n    }\n\n    static void precomputeFactorials(int max) {\n        fact = new long[max + 1];\n        invFact = new long[max + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= max; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n        }\n        invFact[max] = modInverse(fact[max], MOD);\n        for (int i = max - 1; i >= 0; i--) {\n            invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n        }\n    }\n\n    static long comb(int n, int k) {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n    }\n\n    static long modInverse(long a, int mod) {\n        return pow(a, mod - 2, mod);\n    }\n\n    static long pow(long a, long b, int mod) {\n        long res = 1;\n        a = a % mod;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % mod;\n            }\n            a = a * a % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 22:44:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public static int countSequences(int N, int L, int R, int M) {\n        long[][][][] dp = new long[N + 1][R + 1][M + 1][M + 1];\n        dp[0][0][0][0] = 1;\n\n        for (int i = 0; i < N; i++) {\n            for (int sum = 0; sum <= R; sum++) {\n                for (int m = 0; m <= M; m++) {\n                    for (int eqCount = 0; eqCount <= m; eqCount++) {\n                        if (dp[i][sum][m][eqCount] == 0) continue;\n\n                        for (int x = 0; x <= R - sum; x++) {\n                            int newSum = sum + x;\n                            int newM = m;\n                            int newEqCount = eqCount;\n\n                            if (x > 0 && eqCount < m) {\n                                newM = m;\n                                newEqCount = eqCount + 1;\n                            } else if (x == 0 && eqCount == m) {\n                                newM = m + 1;\n                                newEqCount = m + 1;\n                            }\n\n                            if (newSum <= R) {\n                                dp[i + 1][newSum][newM][newEqCount] = \n                                    (dp[i + 1][newSum][newM][newEqCount] + dp[i][sum][m][eqCount]) % MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        long result = 0;\n        for (int sum = L; sum <= R; sum++) {\n            result = (result + dp[N][sum][M][M]) % MOD;\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int L = scanner.nextInt();\n        int R = scanner.nextInt();\n        int M = scanner.nextInt();\n\n        int answer = countSequences(N, L, R, M);\n        System.out.println(answer);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:44:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint solve(int N, int L, int R, int M) {\n    vector<vector<vector<int>>> dp(N + 1, vector<vector<int>>(R + 1, vector<int>(R + 1, 0)));\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < N; i++) {\n        for (int sum = 0; sum <= R; sum++) {\n            for (int mval = 0; mval <= R; mval++) {\n                if (dp[i][sum][mval] == 0) continue;\n                \n                for (int cur = 0; cur <= R - sum; cur++) {\n                    int newSum = sum + cur;\n                    int newMval = max(mval, cur);\n                    \n                    if (newSum <= R) {\n                        dp[i+1][newSum][newMval] = (dp[i+1][newSum][newMval] + dp[i][sum][mval]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    int result = 0;\n    for (int sum = L; sum <= R; sum++) {\n        for (int mval = 0; mval <= R; mval++) {\n            result = (result + dp[N][sum][mval]) % MOD;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int N, L, R, M;\n    cin >> N >> L >> R >> M;\n    cout << solve(N, L, R, M) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef count_sequences(N, L, R, M):\n    if N < 2 or M >= N:\n        return 0\n\n    def count_with_sum_prefix(S, idx, same_m):\n        if idx == N:\n            return L <= S <= R and same_m\n        cnt = 0\n        start = (S + 1) // (idx + 1) if idx > 0 and same_m else 0\n        for Ai in range(start, (R - S) // (N - idx) + 1):\n            cnt += count_with_sum_prefix(S + Ai, idx + 1, same_m or (idx + 1 == M and idx > 0 and idx == N - 1))\n            cnt %= MOD\n        return cnt\n\n    total_cnt = 0\n    for base_value in range((L + N - 1) // N, (R // N) + 1):\n        sum_base = base_value * N\n        cnt = count_with_sum_prefix(sum_base, 0, False)\n        total_cnt += cnt\n        total_cnt %= MOD\n\n    return total_cnt\n\n# Example usage:\nN = 3\nL = 2\nR = 4\nM = 2\nprint(count_sequences(N, L, R, M))",
    "timestamp": "2025-08-13 12:20:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class SequenceFinder {\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int L = scanner.nextInt();\n        int R = scanner.nextInt();\n        int M = scanner.nextInt();\n        scanner.close();\n\n        System.out.println(findSequences(N, L, R, M));\n    }\n\n    private static int findSequences(int N, int L, int R, int M) {\n        long[][] dp = new long[N + 1][R + 1];\n        dp[0][0] = 1;\n        \n        for (int i = 1; i <= N; i++) {\n            for (int sum = 0; sum <= R; sum++) {\n                for (int val = 0; val <= sum; val++) {\n                    dp[i][sum] = (dp[i][sum] + dp[i - 1][sum - val]) % MOD;\n                }\n            }\n        }\n        \n        long totalSequences = 0;\n\n        for (int sum = L; sum <= R; sum++) {\n            totalSequences = (totalSequences + calculateWithEqualM(dp[N][sum], N, M)) % MOD;\n        }\n\n        return (int) totalSequences;\n    }\n\n    private static long calculateWithEqualM(long sequences, int N, int M) {\n        long result = 0;\n        for (int i = 0; i < N; i++) {\n            long[] combinations = generateCombinations(N, i + 1);\n            result = (result + combinations[M - 1] * combinations[N - M]) % MOD;\n        }\n        return (result * sequences) % MOD;\n    }\n\n    private static long[] generateCombinations(int n, int k) {\n        long[] comb = new long[n + 1];\n        Arrays.fill(comb, 0);\n        comb[0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = Math.min(i, k); j > 0; j--) {\n                comb[j] = (comb[j] + comb[j - 1]) % MOD;\n            }\n        }\n\n        return comb;\n    }\n}",
    "timestamp": "2025-08-13 12:20:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#define MOD 1000000007\n\nint dp[101][10001];\nint N,L,R,M;\n\n// Function to quickly compute power of a number modulo MOD\nint power(int base, int exp) {\n    int res = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            res = (1LL * res * base) % MOD;\n        }\n        base = (1LL * base * base) % MOD;\n        exp /= 2;\n    }\n    return res;\n}\n\n// Function to compute the factorial modulo MOD\nint factorial(int n) {\n    int res = 1;\n    for (int i = 1; i <= n; ++i) {\n        res = (1LL * res * i) % MOD;\n    }\n    return res;\n}\n\n// Function to compute the modular inverse using Fermat's little theorem\nint modInverse(int n) {\n    return power(n, MOD - 2);\n}\n\n// Function to initialize combinatorial numbers dynamically\nvoid initCombinations(int maxN, int maxK) {\n    for (int i = 0; i <= maxN; ++i) {\n        dp[i][0] = 1;\n    }\n    for (int i = 1; i <= maxN; ++i) {\n        for (int j = 1; j <= maxK; ++j) {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;\n        }\n    }\n}\n\n// Function to calculate combinations C(n, k)\nint C(int n, int k) {\n    if (k > n) return 0;\n    return dp[n][k];\n}\n\n// Function to calculate number of sequences\nint countSequences(int N, int S) {\n    if (S < N) return 0;\n    int res = C(N - 1 + S, S);\n    return res;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &N, &L, &R, &M);\n\n    initCombinations(100, 10000);\n    \n    long long result = 0;\n    \n    for (int sum = L; sum <= R; sum++) {\n        if (sum >= N * (M + M-1) && (sum % N) == 0) {\n            int fix = sum / N;\n            result = (result + countSequences(M+1, fix - M) - countSequences(M, fix - N)) % MOD;\n        }\n    }\n\n    if (result < 0) result += MOD;\n    \n    printf(\"%lld\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:20:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findSequences(N, M, L, R) {\n    const MOD = 1000000007;\n    \n    function mod(n, m) {\n        return ((n % m) + m) % m;\n    }\n\n    function binomialCoefficient(n, k) {\n        if (k > n) return 0;\n        if (k === 0 || k === n) return 1;\n        let c = 1;\n        for (let i = 0; i < k; i++) {\n            c = (c * (n - i)) % MOD;\n            c = (c * modInverse(i + 1, MOD)) % MOD;\n        }\n        return c;\n    }\n\n    function modInverse(a, m) {\n        function extendedGCD(a, b) {\n            if (b === 0) return [a, 1, 0];\n            const [g, x1, y1] = extendedGCD(b, a % b);\n            return [g, y1, x1 - Math.floor(a / b) * y1];\n        }\n        const [g, x] = extendedGCD(a, m);\n        return g === 1 ? mod(x, m) : null;\n    }\n\n    function numberOfWays(n, k, L, R) {\n        return (sumOfWays(n, k, R) - sumOfWays(n, k, L - 1) + MOD) % MOD;\n    }\n\n    function sumOfWays(n, k, s) {\n        if (s < 0) return 0;\n        let sum = 0;\n        for (let i = 0; i <= Math.floor(s / (k + 1)); i++) {\n            sum = (sum + mod(\n                binomialCoefficient(n + s - i * (k + 1) - 1, n - 1) * (i % 2 === 0 ? 1 : -1),\n                MOD\n            )) % MOD;\n        }\n        return sum;\n    }\n\n    const minSum = Math.floor(L / N);\n    const maxSum = Math.floor(R / N);\n\n    let totalWays = 0;\n    for (let s = minSum; s <= maxSum; s++) {\n        const ways = numberOfWays(N, M, L - s * N, R - s * N);\n        totalWays = (totalWays + mod(ways * binomialCoefficient(N, N - M) % MOD, MOD)) % MOD;\n    }\n\n    return mod(totalWays, MOD);\n}\n\n// Example usage:\nconsole.log(findSequences(3, 2, 3, 6));  // Adjust the parameters N, M, L, R as needed",
    "timestamp": "2025-08-13 12:20:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, L, R, M):\n    MOD = 10**9 + 7\n    \n    @lru_cache(None)\n    def dp(index, remaining_sum, equal_flag):\n        if index == N:\n            return 1 if L <= remaining_sum <= R else 0\n        \n        total_count = 0\n        max_val = R if not equal_flag else M\n        \n        for current_val in range(max_val + 1):\n            if equal_flag and current_val > M:\n                break\n            \n            if remaining_sum + current_val > R:\n                break\n            \n            next_equal = equal_flag and current_val == M\n            total_count += dp(index + 1, remaining_sum + current_val, next_equal)\n            total_count %= MOD\n        \n        return total_count\n    \n    result = dp(0, 0, True)\n    return result\n\ndef main():\n    N, L, R, M = map(int, input().split())\n    print(solve(N, L, R, M))\n\nfrom functools import lru_cache\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 12:20:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countSequences(N, L, R, M) {\n    const MOD = 1e9 + 7;\n    const dp = new Array(N + 1).fill(0).map(() => new Array(R + 1).fill(0).map(() => new Array(R + 1).fill(0)));\n    \n    dp[0][0][0] = 1;\n    \n    for (let i = 0; i < N; i++) {\n        for (let sum = 0; sum <= R; sum++) {\n            for (let equal = 0; equal <= R; equal++) {\n                if (dp[i][sum][equal] === 0) continue;\n                \n                for (let next = 0; next <= R - sum; next++) {\n                    const newSum = sum + next;\n                    const newEqual = (next === equal) ? equal : Math.max(next, equal);\n                    \n                    if (newSum <= R) {\n                        dp[i + 1][newSum][newEqual] = (dp[i + 1][newSum][newEqual] + dp[i][sum][equal]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    \n    let result = 0;\n    for (let sum = L; sum <= R; sum++) {\n        for (let equal = 0; equal <= R; equal++) {\n            if (M - 1 >= 0 && equal >= M - 1) {\n                result = (result + dp[N][sum][equal]) % MOD;\n            }\n        }\n    }\n    \n    return result;\n}",
    "timestamp": "2025-08-13 12:20:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N, M, L, R = map(int, sys.stdin.readline().split())\n    \n    # Precompute factorial, inverse factorial up to N + R\n    max_n = N + R\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(a, b):\n        if a < 0 or b < 0 or a < b:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n    \n    def f(S):\n        # Number of sequences where sum is S and sorted condition is met\n        if S < 0:\n            return 0\n        # Let x be the M-th element (and M+1-th)\n        # The problem reduces to counting sequences where at least M elements >= x, and at most M-1 elements >= x+1\n        # So for some x, the count is (sequences with >= M elements >=x) - (sequences with >= M elements >=x+1)\n        # Sum over all x >=0\n        res = 0\n        max_x = S // (N - M + 1)  # x can be up to S/(N-M+1) because (N-M+1)*x <= S\n        for x in range(0, max_x + 1):\n            # Compute sequences where >= M elements >=x\n            # Let k = number of elements >=x. k >= M.\n            # Transform: B_i = A_i - x if A_i >=x, else 0. Then sum B_i = S - x*k, and B_i >=0.\n            # The number is comb(S - x*k + N - 1, N - 1) * comb(N, k)\n            # Sum over k from M to N\n            # Similarly for x+1\n            # So the term is (sum_{k=M}^N comb(N, k) * comb(S - x*k + N - 1, N - 1)) - (sum_{k=M}^N comb(N, k) * comb(S - (x+1)*k + N - 1, N - 1))\n            term1 = 0\n            term2 = 0\n            for k in range(M, N + 1):\n                # Term1: x\n                s1 = S - x * k\n                if s1 >= 0:\n                    c = comb(s1 + N - 1, N - 1)\n                    term1 = (term1 + comb(N, k) * c) % MOD\n                # Term2: x+1\n                s2 = S - (x + 1) * k\n                if s2 >= 0:\n                    c = comb(s2 + N - 1, N - 1)\n                    term2 = (term2 + comb(N, k) * c) % MOD\n            res = (res + term1 - term2) % MOD\n        return res\n    \n    total = 0\n    for S in range(L, R + 1):\n        total = (total + f(S)) % MOD\n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 12:21:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction modInv(a, mod) {\n    let b = mod, u = 1, v = 0;\n    while (b) {\n        const t = Math.floor(a / b);\n        a -= t * b; [a, b] = [b, a];\n        u -= t * v; [u, v] = [v, u];\n    }\n    u %= mod;\n    if (u < 0) u += mod;\n    return u;\n}\n\nfunction comb(n, k, fact, invFact) {\n    if (n < 0 || k < 0 || k > n) return 0;\n    return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n}\n\nfunction solve(N, M, L, R) {\n    const maxN = N + R;\n    const fact = new Array(maxN + 1).fill(0);\n    const invFact = new Array(maxN + 1).fill(0);\n    fact[0] = 1;\n    for (let i = 1; i <= maxN; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    invFact[maxN] = modInv(fact[maxN], MOD);\n    for (let i = maxN - 1; i >= 0; i--) {\n        invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n    }\n\n    function f(S) {\n        let res = 0;\n        for (let k = 0; k <= N; k++) {\n            const c = comb(N, k, fact, invFact);\n            const s = S - M * k;\n            if (s < 0) continue;\n            const c2 = comb(s + N - 1, N - 1, fact, invFact);\n            res = (res + c * c2 % MOD * (k % 2 === 0 ? 1 : -1)) % MOD;\n        }\n        return (res + MOD) % MOD;\n    }\n\n    const upper = f(R);\n    const lower = f(L - 1);\n    return (upper - lower + MOD) % MOD;\n}\n\n// Example usage:\n// console.log(solve(3, 2, 1, 5));",
    "timestamp": "2025-08-13 12:21:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, M, L, R;\n    cin >> N >> M >> L >> R;\n    \n    vector<vector<int>> dp(N + 1, vector<int>(R + 1, 0));\n\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= N; ++i) {\n        for (int sum = 0; sum <= R; ++sum) {\n            for (int x = 0; x + sum <= R; ++x) {\n                dp[i][sum + x] = (dp[i][sum + x] + dp[i - 1][sum]) % MOD;\n            }\n        }\n    }\n\n    auto calc = [&](int x) {\n        vector<vector<int>> temp(N + 1, vector<int>(x + 1, 0));\n        temp[0][0] = 1;\n        for (int i = 1; i <= N; ++i) {\n            for (int sum = 0; sum <= x; ++sum) {\n                for (int v = 0; v + sum <= x; ++v) {\n                    if (i == M && v > 0) {\n                        if (sum + 2 * v <= x) {\n                            temp[i][sum + 2 * v] = (temp[i][sum + 2 * v] + temp[i - 1][sum]) % MOD;\n                        }\n                    } else {\n                        temp[i][sum + v] = (temp[i][sum + v] + temp[i - 1][sum]) % MOD;\n                    }\n                }\n            }\n        }\n        int total = 0;\n        for (int sum = L; sum <= x; ++sum) {\n            total = (total + temp[N][sum]) % MOD;\n        }\n        return total;\n    };\n\n    int result = (calc(R) - calc(L - 1) + MOD) % MOD;\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:34:13"
  }
]