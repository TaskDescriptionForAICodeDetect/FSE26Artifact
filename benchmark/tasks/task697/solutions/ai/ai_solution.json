[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_LEN 100005\n\nchar S[MAX_LEN];\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    scanf(\"%s\", S);\n\n    while (Q--) {\n        int type;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            int i;\n            char c;\n            scanf(\"%d %c\", &i, &c);\n            S[i-1] = c;\n        } else {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            \n            bool seen[26] = {false};\n            int unique = 0;\n            \n            for (int j = l-1; j < r; j++) {\n                if (!seen[S[j] - 'a']) {\n                    seen[S[j] - 'a'] = true;\n                    unique++;\n                }\n            }\n            \n            printf(\"%d\\n\", unique);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:36:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int freq[26];\n} SegmentTreeNode;\n\nSegmentTreeNode tree[400000];\nchar S[100001];\nint N;\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        memset(tree[node].freq, 0, sizeof(tree[node].freq));\n        tree[node].freq[S[start] - 'a'] = 1;\n    } else {\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        for (int i = 0; i < 26; i++) {\n            tree[node].freq[i] = tree[2 * node].freq[i] + tree[2 * node + 1].freq[i];\n        }\n    }\n}\n\nvoid update(int node, int start, int end, int idx, char old_char, char new_char) {\n    if (start == end) {\n        tree[node].freq[old_char - 'a']--;\n        tree[node].freq[new_char - 'a']++;\n    } else {\n        int mid = (start + end) / 2;\n        if (start <= idx && idx <= mid) {\n            update(2 * node, start, mid, idx, old_char, new_char);\n        } else {\n            update(2 * node + 1, mid + 1, end, idx, old_char, new_char);\n        }\n        tree[node].freq[old_char - 'a']--;\n        tree[node].freq[new_char - 'a']++;\n    }\n}\n\nvoid query(int node, int start, int end, int l, int r, int *freq) {\n    if (r < start || end < l) {\n        return;\n    }\n    if (l <= start && end <= r) {\n        for (int i = 0; i < 26; i++) {\n            freq[i] += tree[node].freq[i];\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    query(2 * node, start, mid, l, r, freq);\n    query(2 * node + 1, mid + 1, end, l, r, freq);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    scanf(\"%s\", S + 1);\n    build(1, 1, N);\n    int Q;\n    scanf(\"%d\", &Q);\n    while (Q--) {\n        int type;\n        scanf(\"%d\", &type);\n        if (type == 1) {\n            int i;\n            char c;\n            scanf(\"%d %c\", &i, &c);\n            if (S[i] != c) {\n                update(1, 1, N, i, S[i], c);\n                S[i] = c;\n            }\n        } else {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            int freq[26] = {0};\n            query(1, 1, N, l, r, freq);\n            int count = 0;\n            for (int i = 0; i < 26; i++) {\n                if (freq[i] > 0) {\n                    count++;\n                }\n            }\n            printf(\"%d\\n\", count);\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:37:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SegmentTree {\n    int size;\n    vector<array<int, 26>> counts;\n    vector<int> lazy;\n\n    SegmentTree(const string &s) {\n        size = 1;\n        while (size < (int)s.size()) size <<= 1;\n        counts.resize(2 * size);\n        lazy.resize(2 * size, -1);\n        for (int i = 0; i < (int)s.size(); ++i) {\n            counts[size + i][s[i] - 'a'] = 1;\n        }\n        for (int i = size - 1; i > 0; --i) {\n            for (int j = 0; j < 26; ++j) {\n                counts[i][j] = counts[2 * i][j] + counts[2 * i + 1][j];\n            }\n        }\n    }\n\n    void apply(int node, int val, int len) {\n        fill(counts[node].begin(), counts[node].end(), 0);\n        counts[node][val] = len;\n        if (node < size) {\n            lazy[node] = val;\n        }\n    }\n\n    void push(int node, int node_len) {\n        if (lazy[node] != -1) {\n            apply(2 * node, lazy[node], node_len / 2);\n            apply(2 * node + 1, lazy[node], node_len / 2);\n            lazy[node] = -1;\n        }\n    }\n\n    void update_range(int l, int r, int val, int node, int node_l, int node_r) {\n        if (r < node_l || node_r < l) return;\n        if (l <= node_l && node_r <= r) {\n            apply(node, val, node_r - node_l + 1);\n            return;\n        }\n        push(node, node_r - node_l + 1);\n        int mid = (node_l + node_r) / 2;\n        update_range(l, r, val, 2 * node, node_l, mid);\n        update_range(l, r, val, 2 * node + 1, mid + 1, node_r);\n        for (int j = 0; j < 26; ++j) {\n            counts[node][j] = counts[2 * node][j] + counts[2 * node + 1][j];\n        }\n    }\n\n    void update_point(int pos, int val) {\n        pos += size;\n        for (int j = 0; j < 26; ++j) {\n            counts[pos][j] = 0;\n        }\n        counts[pos][val] = 1;\n        for (pos >>= 1; pos >= 1; pos >>= 1) {\n            for (int j = 0; j < 26; ++j) {\n                counts[pos][j] = counts[2 * pos][j] + counts[2 * pos + 1][j];\n            }\n        }\n    }\n\n    array<int, 26> query(int l, int r, int node, int node_l, int node_r) {\n        if (r < node_l || node_r < l) return {};\n        if (l <= node_l && node_r <= r) {\n            return counts[node];\n        }\n        push(node, node_r - node_l + 1);\n        int mid = (node_l + node_r) / 2;\n        auto left = query(l, r, 2 * node, node_l, mid);\n        auto right = query(l, r, 2 * node + 1, mid + 1, node_r);\n        array<int, 26> res;\n        for (int j = 0; j < 26; ++j) {\n            res[j] = left[j] + right[j];\n        }\n        return res;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, Q;\n    string S;\n    cin >> N >> S >> Q;\n\n    SegmentTree st(S);\n\n    while (Q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int i;\n            char c;\n            cin >> i >> c;\n            --i;\n            if (S[i] != c) {\n                S[i] = c;\n                st.update_point(i, c - 'a');\n            }\n        } else {\n            int l, r;\n            cin >> l >> r;\n            --l; --r;\n            auto cnt = st.query(l, r, 1, 0, st.size - 1);\n            int ans = 0;\n            for (int j = 0; j < 26; ++j) {\n                if (cnt[j] > 0) ++ans;\n            }\n            cout << ans << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:37:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class SegmentTree {\n        int[][] tree;\n        int n;\n        char[] arr;\n\n        SegmentTree(char[] arr) {\n            this.arr = arr;\n            this.n = arr.length;\n            this.tree = new int[4 * n][26];\n            build(0, 0, n - 1);\n        }\n\n        void build(int node, int start, int end) {\n            if (start == end) {\n                tree[node][arr[start] - 'a'] = 1;\n            } else {\n                int mid = (start + end) / 2;\n                build(2 * node + 1, start, mid);\n                build(2 * node + 2, mid + 1, end);\n                for (int i = 0; i < 26; i++) {\n                    tree[node][i] = tree[2 * node + 1][i] + tree[2 * node + 2][i];\n                }\n            }\n        }\n\n        void update(int node, int start, int end, int idx, char oldVal, char newVal) {\n            if (start == end) {\n                tree[node][oldVal - 'a'] = 0;\n                tree[node][newVal - 'a'] = 1;\n            } else {\n                int mid = (start + end) / 2;\n                if (start <= idx && idx <= mid) {\n                    update(2 * node + 1, start, mid, idx, oldVal, newVal);\n                } else {\n                    update(2 * node + 2, mid + 1, end, idx, oldVal, newVal);\n                }\n                tree[node][oldVal - 'a'] = tree[2 * node + 1][oldVal - 'a'] + tree[2 * node + 2][oldVal - 'a'];\n                tree[node][newVal - 'a'] = tree[2 * node + 1][newVal - 'a'] + tree[2 * node + 2][newVal - 'a'];\n            }\n        }\n\n        int[] query(int node, int start, int end, int l, int r) {\n            if (r < start || end < l) {\n                return new int[26];\n            }\n            if (l <= start && end <= r) {\n                return tree[node].clone();\n            }\n            int mid = (start + end) / 2;\n            int[] left = query(2 * node + 1, start, mid, l, r);\n            int[] right = query(2 * node + 2, mid + 1, end, l, r);\n            int[] res = new int[26];\n            for (int i = 0; i < 26; i++) {\n                res[i] = left[i] + right[i];\n            }\n            return res;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer st;\n\n        int N = Integer.parseInt(br.readLine());\n        char[] S = br.readLine().toCharArray();\n        SegmentTree stree = new SegmentTree(S);\n\n        int Q = Integer.parseInt(br.readLine());\n        while (Q-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int type = Integer.parseInt(st.nextToken());\n            if (type == 1) {\n                int i = Integer.parseInt(st.nextToken()) - 1;\n                char c = st.nextToken().charAt(0);\n                if (S[i] != c) {\n                    stree.update(0, 0, N - 1, i, S[i], c);\n                    S[i] = c;\n                }\n            } else {\n                int l = Integer.parseInt(st.nextToken()) - 1;\n                int r = Integer.parseInt(st.nextToken()) - 1;\n                int[] freq = stree.query(0, 0, N - 1, l, r);\n                int count = 0;\n                for (int f : freq) {\n                    if (f > 0) count++;\n                }\n                out.println(count);\n            }\n        }\n        out.close();\n    }\n}",
    "timestamp": "2025-08-05 22:38:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        String[] input = br.readLine().split(\" \");\n        int N = Integer.parseInt(input[0]);\n        int Q = Integer.parseInt(input[1]);\n        \n        String S = br.readLine();\n        char[] arr = S.toCharArray();\n        \n        for (int q = 0; q < Q; q++) {\n            input = br.readLine().split(\" \");\n            int type = Integer.parseInt(input[0]);\n            \n            if (type == 1) {\n                int i = Integer.parseInt(input[1]) - 1;\n                char c = input[2].charAt(0);\n                arr[i] = c;\n            } else {\n                int l = Integer.parseInt(input[1]) - 1;\n                int r = Integer.parseInt(input[2]) - 1;\n                \n                Set<Character> uniqueChars = new HashSet<>();\n                for (int j = l; j <= r; j++) {\n                    uniqueChars.add(arr[j]);\n                }\n                \n                bw.write(uniqueChars.size() + \"\\n\");\n            }\n        }\n        \n        bw.flush();\n        bw.close();\n        br.close();\n    }\n}",
    "timestamp": "2025-08-05 22:38:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> processQueries(string& s, vector<vector<int>>& queries) {\n        vector<int> results;\n        \n        for (auto& query : queries) {\n            if (query[0] == 1) {\n                // Type 1 query: modify character\n                int index = query[1] - 1;\n                char newChar = query[2];\n                if (s[index] != newChar) {\n                    s[index] = newChar;\n                }\n            } else {\n                // Type 2 query: count unique characters in substring\n                int left = query[1] - 1;\n                int right = query[2] - 1;\n                unordered_set<char> uniqueChars;\n                \n                for (int i = left; i <= right; i++) {\n                    uniqueChars.insert(s[i]);\n                }\n                \n                results.push_back(uniqueChars.size());\n            }\n        }\n        \n        return results;\n    }\n};\n\nint main() {\n    string s;\n    cin >> s;\n    \n    int q;\n    cin >> q;\n    \n    vector<vector<int>> queries(q);\n    for (int i = 0; i < q; i++) {\n        int type, a, b;\n        cin >> type >> a >> b;\n        queries[i] = {type, a, b};\n    }\n    \n    Solution solution;\n    vector<int> results = solution.processQueries(s, queries);\n    \n    for (int result : results) {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.tree = [set() for _ in range(4 * self.n)]\n        self.build(data, 0, 0, self.n - 1)\n\n    def build(self, data, node, start, end):\n        if start == end:\n            self.tree[node] = set(data[start])\n        else:\n            mid = (start + end) // 2\n            self.build(data, 2*node+1, start, mid)\n            self.build(data, 2*node+2, mid+1, end)\n            self.tree[node] = self.tree[2*node+1].union(self.tree[2*node+2])\n\n    def update(self, idx, char, node, start, end):\n        if start == end:\n            self.tree[node] = {char}\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update(idx, char, 2*node+1, start, mid)\n            else:\n                self.update(idx, char, 2*node+2, mid+1, end)\n            self.tree[node] = self.tree[2*node+1].union(self.tree[2*node+2])\n\n    def query(self, L, R, node, start, end):\n        if R < start or end < L:\n            return set()\n        if L <= start and end <= R:\n            return self.tree[node]\n        mid = (start + end) // 2\n        left_query = self.query(L, R, 2*node+1, start, mid)\n        right_query = self.query(L, R, 2*node+2, mid+1, end)\n        return left_query.union(right_query)\n\ndef process_queries(N, S, queries):\n    seg_tree = SegmentTree(S)\n    result = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, i_q, c_q = query\n            i_q -= 1\n            if S[i_q] != c_q:\n                S = S[:i_q] + c_q + S[i_q+1:]\n                seg_tree.update(i_q, c_q, 0, 0, N - 1)\n        elif query[0] == 2:\n            _, l_q, r_q = query\n            l_q -= 1\n            r_q -= 1\n            unique_chars = seg_tree.query(l_q, r_q, 0, 0, N - 1)\n            result.append(len(unique_chars))\n    \n    return result\n\n# Example Usage:\nN = 5\nS = 'abcde'\nqueries = [(2, 1, 5), (1, 3, 'z'), (2, 1, 5)]\nprint(process_queries(N, S, queries))  # Output: [5, 5]",
    "timestamp": "2025-08-13 11:44:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        String S = scanner.next();\n        int N = S.length();\n        int Q = scanner.nextInt();\n        \n        char[] sArray = S.toCharArray();\n        \n        for (int q = 0; q < Q; q++) {\n            int queryType = scanner.nextInt();\n            if (queryType == 1) {\n                int i_q = scanner.nextInt() - 1;\n                char c_q = scanner.next().charAt(0);\n                \n                if (sArray[i_q] != c_q) {\n                    sArray[i_q] = c_q;\n                }\n            } else if (queryType == 2) {\n                int l_q = scanner.nextInt() - 1;\n                int r_q = scanner.nextInt() - 1;\n                \n                Set<Character> charSet = new HashSet<>();\n                for (int i = l_q; i <= r_q; i++) {\n                    charSet.add(sArray[i]);\n                }\n                \n                System.out.println(charSet.size());\n            }\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 11:44:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 100000\n#define MAX_CHAR 26\n\nchar S[MAX_N + 1];\nint freq[MAX_CHAR][MAX_N + 1];\n\nvoid initializeFrequencies(int N) {\n    memset(freq, 0, sizeof(freq));\n    for (int i = 0; i < N; ++i) {\n        for (int c = 0; c < MAX_CHAR; ++c) {\n            if (i > 0) {\n                freq[c][i] = freq[c][i - 1];\n            }\n        }\n        freq[S[i] - 'a'][i]++;\n    }\n}\n\nvoid processQueries(int Q) {\n    while (Q--) {\n        int type;\n        scanf(\"%d\", &type);\n        if (type == 1) {\n            int i;\n            char c;\n            scanf(\"%d %c\", &i, &c);\n            i--; // converting to 0-based index\n            char originalChar = S[i];\n            if (originalChar != c) {\n                for (int j = i; j < strlen(S); ++j) {\n                    freq[originalChar - 'a'][j]--;\n                    freq[c - 'a'][j]++;\n                }\n                S[i] = c;\n            }\n        } else {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            l--; r--; // converting to 0-based index\n            int diffCharCount = 0;\n            for (int c = 0; c < MAX_CHAR; ++c) {\n                int count = freq[c][r] - (l > 0 ? freq[c][l - 1] : 0);\n                if (count > 0) {\n                    diffCharCount++;\n                }\n            }\n            printf(\"%d\\n\", diffCharCount);\n        }\n    }\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    scanf(\"%s\", S);\n    \n    initializeFrequencies(N);\n    processQueries(Q);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:45:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class SegmentTree {\n    constructor(size) {\n        this.size = size;\n        this.data = Array(4 * size).fill(new Set());\n    }\n\n    // Merge two sets\n    mergeSets(set1, set2) {\n        const resultSet = new Set(set1);\n        for (let elem of set2) {\n            resultSet.add(elem);\n        }\n        return resultSet;\n    }\n\n    build(S, node, start, end) {\n        if (start === end) {\n            this.data[node] = new Set([S[start]]);\n        } else {\n            const mid = Math.floor((start + end) / 2);\n            this.build(S, 2 * node + 1, start, mid);\n            this.build(S, 2 * node + 2, mid + 1, end);\n            this.data[node] = this.mergeSets(this.data[2 * node + 1], this.data[2 * node + 2]);\n        }\n    }\n\n    update(index, char, node, start, end) {\n        if (start === end) {\n            this.data[node] = new Set([char]);\n        } else {\n            const mid = Math.floor((start + end) / 2);\n            if (start <= index && index <= mid) {\n                this.update(index, char, 2 * node + 1, start, mid);\n            } else {\n                this.update(index, char, 2 * node + 2, mid + 1, end);\n            }\n            this.data[node] = this.mergeSets(this.data[2 * node + 1], this.data[2 * node + 2]);\n        }\n    }\n\n    query(l, r, node, start, end) {\n        if (r < start || end < l) {\n            return new Set();\n        }\n        if (l <= start && end <= r) {\n            return this.data[node];\n        }\n        const mid = Math.floor((start + end) / 2);\n        const leftSet = this.query(l, r, 2 * node + 1, start, mid);\n        const rightSet = this.query(l, r, 2 * node + 2, mid + 1, end);\n        return this.mergeSets(leftSet, rightSet);\n    }\n}\n\nfunction processQueries(S, queries) {\n    const N = S.length;\n    const segmentTree = new SegmentTree(N);\n    segmentTree.build(S, 0, 0, N - 1);\n    \n    const results = [];\n    \n    for (const query of queries) {\n        const [type, a, b] = query;\n        if (type === 1) {\n            const index = a - 1;\n            const char = b;\n            if (S[index] !== char) {\n                S = S.substring(0, index) + char + S.substring(index + 1);\n                segmentTree.update(index, char, 0, 0, N - 1);\n            }\n        } else if (type === 2) {\n            const l = a - 1;\n            const r = b - 1;\n            const distinctChars = segmentTree.query(l, r, 0, 0, N - 1);\n            results.push(distinctChars.size);\n        }\n    }\n    \n    return results;\n}",
    "timestamp": "2025-08-13 11:45:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Solution:\n    def solve(self, N, S, Q, queries):\n        S = list(S)\n        results = []\n        \n        for query_type, arg1, arg2 in queries:\n            if query_type == 1:\n                # Change character at index\n                S[arg1-1] = arg2\n            else:\n                # Count unique characters in substring\n                substring = S[arg1-1:arg2]\n                unique_chars = len(set(substring))\n                results.append(unique_chars)\n        \n        return results",
    "timestamp": "2025-08-13 11:45:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class Solution {\n    constructor(s) {\n        this.s = s.split('');\n    }\n\n    type1Query(index, char) {\n        if (this.s[index - 1] !== char) {\n            this.s[index - 1] = char;\n        }\n    }\n\n    type2Query(left, right) {\n        const substring = this.s.slice(left - 1, right);\n        return new Set(substring).size;\n    }\n}\n\nfunction processQueries(s, queries) {\n    const solution = new Solution(s);\n    const results = [];\n\n    for (const query of queries) {\n        if (query[0] === 1) {\n            solution.type1Query(query[1], query[2]);\n        } else {\n            results.push(solution.type2Query(query[1], query[2]));\n        }\n    }\n\n    return results;\n}",
    "timestamp": "2025-08-13 11:45:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    S = input[ptr]\n    ptr += 1\n    Q = int(input[ptr])\n    ptr += 1\n    \n    # Using a list of sets for segment tree\n    size = 1\n    while size < N:\n        size <<= 1\n    seg = [set() for _ in range(2 * size)]\n    \n    # Initialize leaves\n    for i in range(N):\n        seg[size + i] = {S[i]}\n    # Build the segment tree\n    for i in range(size - 1, 0, -1):\n        seg[i] = seg[2 * i] | seg[2 * i + 1]\n    \n    for _ in range(Q):\n        query = input[ptr]\n        ptr += 1\n        if query == '1':\n            i = int(input[ptr]) - 1\n            ptr += 1\n            c = input[ptr]\n            ptr += 1\n            if S[i] == c:\n                continue\n            S = S[:i] + c + S[i+1:]\n            pos = size + i\n            seg[pos] = {c}\n            pos >>= 1\n            while pos >= 1:\n                new_set = seg[2 * pos] | seg[2 * pos + 1]\n                if seg[pos] == new_set:\n                    break\n                seg[pos] = new_set\n                pos >>= 1\n        else:\n            l = int(input[ptr]) - 1\n            ptr += 1\n            r = int(input[ptr]) - 1\n            ptr += 1\n            res = set()\n            l += size\n            r += size\n            while l <= r:\n                if l % 2 == 1:\n                    res |= seg[l]\n                    l += 1\n                if r % 2 == 0:\n                    res |= seg[r]\n                    r -= 1\n                l >>= 1\n                r >>= 1\n            print(len(res))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 11:46:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').split('\\n');\n\nclass SegmentTree {\n    constructor(data) {\n        this.n = data.length;\n        this.size = 1;\n        while (this.size < this.n) this.size <<= 1;\n        this.tree = Array(this.size * 2).fill().map(() => new Set());\n        for (let i = 0; i < this.n; i++) {\n            this.tree[this.size + i].add(data[i]);\n        }\n        for (let i = this.size - 1; i > 0; i--) {\n            this.tree[i] = new Set([...this.tree[i * 2], ...this.tree[i * 2 + 1]]);\n        }\n    }\n\n    update(pos, oldVal, newVal) {\n        pos += this.size;\n        this.tree[pos].delete(oldVal);\n        this.tree[pos].add(newVal);\n        for (pos >>= 1; pos >= 1; pos >>= 1) {\n            const left = pos * 2;\n            const right = pos * 2 + 1;\n            this.tree[pos] = new Set([...this.tree[left], ...this.tree[right]]);\n        }\n    }\n\n    query(l, r) {\n        let res = new Set();\n        l += this.size;\n        r += this.size;\n        while (l <= r) {\n            if (l % 2 === 1) {\n                this.tree[l].forEach(c => res.add(c));\n                l++;\n            }\n            if (r % 2 === 0) {\n                this.tree[r].forEach(c => res.add(c));\n                r--;\n            }\n            l >>= 1;\n            r >>= 1;\n        }\n        return res.size;\n    }\n}\n\nfunction main() {\n    let ptr = 0;\n    const N = parseInt(input[ptr++], 10);\n    const S = input[ptr++].trim();\n    const Q = parseInt(input[ptr++], 10);\n    const queries = [];\n    for (let i = 0; i < Q; i++) {\n        queries.push(input[ptr++].trim().split(' '));\n    }\n\n    const st = new SegmentTree(S.split(''));\n    const arr = S.split('');\n\n    for (const query of queries) {\n        if (query[0] === '1') {\n            const i = parseInt(query[1], 10) - 1;\n            const c = query[2];\n            if (arr[i] !== c) {\n                st.update(i, arr[i], c);\n                arr[i] = c;\n            }\n        } else {\n            const l = parseInt(query[1], 10) - 1;\n            const r = parseInt(query[2], 10) - 1;\n            console.log(st.query(l, r));\n        }\n    }\n}\n\nmain();",
    "timestamp": "2025-08-13 11:46:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n// Solution class containing methods to process queries\nclass Solution {\npublic:\n    // Method to process queries\n    void processQueries(string &S, vector<vector<string>> &queries) {\n        int N = S.size();\n        for (const auto &query : queries) {\n            int type = stoi(query[0]);\n            if (type == 1) {\n                int i = stoi(query[1]) - 1;  // Convert to 0-based index\n                char c = query[2][0];\n                if (S[i] != c) {\n                    S[i] = c;\n                }\n            } else if (type == 2) {\n                int l = stoi(query[1]) - 1;  // Convert to 0-based index\n                int r = stoi(query[2]) - 1;\n                cout << countDistinct(S, l, r) << endl;\n            }\n        }\n    }\n\n    // Method to count distinct characters in a substring\n    int countDistinct(const string &S, int l, int r) {\n        set<char> distinctChars;\n        for (int i = l; i <= r; ++i) {\n            distinctChars.insert(S[i]);\n        }\n        return distinctChars.size();\n    }\n};\n\nint main() {\n    // Sample input\n    string S;\n    cin >> S;\n    int Q;\n    cin >> Q;\n    vector<vector<string>> queries(Q, vector<string>(3));\n    for (int i = 0; i < Q; ++i) {\n        cin >> queries[i][0] >> queries[i][1] >> queries[i][2];\n    }\n    \n    Solution solution;\n    solution.processQueries(S, queries);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:04:52"
  }
]