[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    int p;\n    int s;\n} Carriage;\n\nint compare(const void *a, const void *b) {\n    Carriage *carriageA = (Carriage *)a;\n    Carriage *carriageB = (Carriage *)b;\n    return carriageA->p - carriageB->p;\n}\n\ndouble max(double a, double b) {\n    return a > b ? a : b;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    Carriage *carriages = (Carriage *)malloc(n * sizeof(Carriage));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &carriages[i].p, &carriages[i].s);\n    }\n    \n    qsort(carriages, n, sizeof(Carriage), compare);\n    \n    double *times = (double *)malloc(n * sizeof(double));\n    for (int i = 0; i < n; i++) {\n        times[i] = (double)(1000000 - carriages[i].p) / carriages[i].s;\n    }\n    \n    for (int i = 1; i < n; i++) {\n        if (carriages[i].s <= carriages[i - 1].s) {\n            continue;\n        }\n        double t = (double)(carriages[i].p - carriages[i - 1].p) / (carriages[i - 1].s - carriages[i].s);\n        if (t < 0) {\n            continue;\n        }\n        double meet_pos = carriages[i - 1].p + carriages[i - 1].s * t;\n        if (meet_pos > 1000000) {\n            continue;\n        }\n        times[i] = max(times[i], times[i - 1] + (1000000 - meet_pos) / carriages[i].s);\n    }\n    \n    double max_time = 0;\n    for (int i = 0; i < n; i++) {\n        if (times[i] > max_time) {\n            max_time = times[i];\n        }\n    }\n    \n    printf(\"%.10f\\n\", max_time);\n    \n    free(carriages);\n    free(times);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:30:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Carriage {\n    int S;\n    int D;\n    bool operator<(const Carriage& other) const {\n        return D < other.D;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Carriage> carriages(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> carriages[i].S >> carriages[i].D;\n    }\n    sort(carriages.begin(), carriages.end());\n\n    vector<int> passes(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> passes[i];\n    }\n    sort(passes.begin(), passes.end());\n\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n    for (int i = 0; i < n; ++i) {\n        pq.push({carriages[i].D * 1.0 / carriages[i].S, i});\n    }\n\n    vector<double> arrival_times(n);\n    for (int i = 0; i < m; ++i) {\n        if (pq.empty()) break;\n        auto current = pq.top();\n        pq.pop();\n        int idx = current.second;\n        double time = current.first;\n        arrival_times[idx] = time;\n    }\n\n    double max_time = 0;\n    for (int i = 0; i < n; ++i) {\n        if (arrival_times[i] == 0) {\n            arrival_times[i] = carriages[i].D * 1.0 / carriages[i].S;\n        }\n        max_time = max(max_time, arrival_times[i]);\n    }\n\n    cout << max_time << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:31:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        double[] s = new double[n];\n        for (int i = 0; i < n; i++) {\n            s[i] = sc.nextDouble();\n        }\n        double[] t = new double[n];\n        for (int i = 0; i < n; i++) {\n            t[i] = 1.0 / s[i];\n        }\n        Arrays.sort(t);\n        double maxTime = t[n - 1];\n        if (m >= n - 1) {\n            System.out.println(maxTime);\n            return;\n        }\n        PriorityQueue<Double> pq = new PriorityQueue<>();\n        for (int i = 0; i < m; i++) {\n            pq.add(t[i]);\n        }\n        for (int i = m; i < n; i++) {\n            double earliest = pq.poll();\n            pq.add(earliest + t[i]);\n        }\n        double totalTime = 0;\n        while (!pq.isEmpty()) {\n            totalTime = pq.poll();\n        }\n        System.out.println(totalTime);\n    }\n}",
    "timestamp": "2025-08-05 21:31:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class HorseCarriageTour {\n    static class Carriage implements Comparable<Carriage> {\n        int id;\n        double speed;\n        double startTime;\n        double position;\n        \n        Carriage(int id, double speed, double startTime) {\n            this.id = id;\n            this.speed = speed;\n            this.startTime = startTime;\n            this.position = 0;\n        }\n        \n        @Override\n        public int compareTo(Carriage other) {\n            return Double.compare(this.position, other.position);\n        }\n    }\n    \n    static class PassingArea {\n        double start;\n        double end;\n        \n        PassingArea(double start, double end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n    \n    public static double minimizeTotalTime(int n, double[] speeds, double[] startTimes, PassingArea[] passingAreas, double goalDistance) {\n        List<Carriage> carriages = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            carriages.add(new Carriage(i, speeds[i], startTimes[i]));\n        }\n        \n        carriages.sort((a, b) -> Double.compare(a.startTime, b.startTime));\n        \n        double maxTime = 0;\n        for (Carriage carriage : carriages) {\n            double timeToGoal = (goalDistance - carriage.position) / carriage.speed;\n            double arrivalTime = carriage.startTime + timeToGoal;\n            \n            // Check if carriage needs to pass others\n            for (Carriage otherCarriage : carriages) {\n                if (otherCarriage == carriage) continue;\n                \n                double relativeSpeed = carriage.speed - otherCarriage.speed;\n                double meetTime = meetingTime(carriage, otherCarriage, goalDistance, passingAreas);\n                \n                if (meetTime != -1) {\n                    arrivalTime = Math.max(arrivalTime, meetTime + timeToGoal);\n                }\n            }\n            \n            maxTime = Math.max(maxTime, arrivalTime);\n        }\n        \n        return maxTime;\n    }\n    \n    static double meetingTime(Carriage c1, Carriage c2, double goalDistance, PassingArea[] passingAreas) {\n        if (c1.speed <= c2.speed) return -1;\n        \n        double relativeDeparture = c1.startTime - c2.startTime;\n        double relativeSpeed = c1.speed - c2.speed;\n        \n        for (PassingArea area : passingAreas) {\n            double meetDistance = area.start + (area.end - area.start) / 2.0;\n            double timeToMeet = (meetDistance - c2.position) / (c1.speed - c2.speed) + c2.startTime;\n            \n            if (timeToMeet >= c1.startTime && timeToMeet >= c2.startTime) {\n                return timeToMeet;\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int n = 3;\n        double[] speeds = {2.0, 3.0, 1.5};\n        double[] startTimes = {0.0, 1.0, 2.0};\n        PassingArea[] passingAreas = {\n            new PassingArea(10.0, 20.0),\n            new PassingArea(30.0, 40.0)\n        };\n        double goalDistance = 50.0;\n        \n        double result = minimizeTotalTime(n, speeds, startTimes, passingAreas, goalDistance);\n        System.out.println(\"Minimum total time: \" + result);\n    }\n}",
    "timestamp": "2025-08-05 21:31:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100000\n#define MAX_M 100000\n\ntypedef struct {\n    long long speed;\n    long long startTime;\n    long long position;\n} Carriage;\n\ntypedef struct {\n    long long position;\n} PassingArea;\n\nint compareCarriages(const void* a, const void* b) {\n    Carriage* c1 = (Carriage*)a;\n    Carriage* c2 = (Carriage*)b;\n    return (c1->startTime > c2->startTime) - (c1->startTime < c2->startTime);\n}\n\nlong long minimizeTravelTime(int n, int m, Carriage* carriages, PassingArea* passingAreas) {\n    qsort(carriages, n, sizeof(Carriage), compareCarriages);\n    \n    long long maxTime = 0;\n    for (int i = 0; i < n; i++) {\n        long long timeToGoal = (1000000 - carriages[i].startTime) / carriages[i].speed;\n        maxTime = (timeToGoal > maxTime) ? timeToGoal : maxTime;\n    }\n    \n    return maxTime;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    Carriage carriages[MAX_N];\n    PassingArea passingAreas[MAX_M];\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld %lld\", &carriages[i].speed, &carriages[i].startTime);\n        carriages[i].position = carriages[i].startTime * carriages[i].speed;\n    }\n    \n    for (int i = 0; i < m; i++) {\n        scanf(\"%lld\", &passingAreas[i].position);\n    }\n    \n    long long result = minimizeTravelTime(n, m, carriages, passingAreas);\n    printf(\"%lld\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:31:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\nstruct Carriage {\n    int speed;\n    double startTime;\n};\n\nbool canPass(const Carriage& a, const Carriage& b, int passingAreas) {\n    return passingAreas > 0;\n}\n\ndouble calculateTotalTime(vector<Carriage>& carriages, int passingAreas) {\n    int n = carriages.size();\n    sort(carriages.begin(), carriages.end(), [](const Carriage& a, const Carriage& b) {\n        return a.speed < b.speed;\n    });\n\n    double maxTime = 0.0;\n    for (int i = 0; i < n; i++) {\n        double currentTime = carriages[i].startTime;\n        int remainingPassingAreas = passingAreas;\n\n        for (int j = i + 1; j < n; j++) {\n            if (carriages[j].speed > carriages[i].speed) {\n                double timeDiff = (1.0 / carriages[j].speed - 1.0 / carriages[i].speed);\n                double meetTime = max(carriages[i].startTime, carriages[j].startTime);\n\n                if (!canPass(carriages[i], carriages[j], remainingPassingAreas)) {\n                    meetTime += abs(timeDiff);\n                    remainingPassingAreas--;\n                }\n\n                currentTime = max(currentTime, meetTime + 1.0 / carriages[i].speed);\n            }\n        }\n\n        maxTime = max(maxTime, currentTime);\n    }\n\n    return maxTime;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<Carriage> carriages(n);\n    for (int i = 0; i < n; i++) {\n        cin >> carriages[i].speed >> carriages[i].startTime;\n    }\n\n    double result = calculateTotalTime(carriages, m);\n    cout << fixed << setprecision(10) << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:31:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimize_travel_time(n, m, speeds, pass_zones):\n    # Helper function to check if a given time can be a feasible finish time\n    def can_finish_in(time_limit):\n        zones = sorted(pass_zones)\n        pos = [0] * n\n        zones_used = 0\n        \n        for i in range(n):\n            travel_time = time_limit * speeds[i]\n            if i == 0:\n                pos[i] = travel_time\n            else:\n                pos[i] = max(pos[i - 1] + 1, travel_time)\n                \n            if pos[i] <= pos[i - 1]:\n                zones_used += 1\n                if zones_used > m:\n                    return False\n            \n        return True\n    \n    # Binary search for the minimum time\n    left, right = 0, max(pass_zones) / min(speeds)\n    best_time = right\n    \n    while right - left > 1e-9:\n        mid = (left + right) / 2\n        if can_finish_in(mid):\n            best_time = mid\n            right = mid\n        else:\n            left = mid\n    \n    return best_time\n\n# Example usage\nn = 3\nm = 1\nspeeds = [1, 3, 2]\npass_zones = [1]\nprint(minimize_travel_time(n, m, speeds, pass_zones))",
    "timestamp": "2025-08-13 06:49:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CarriageRace {\n\n    static class Carriage implements Comparable<Carriage> {\n        int speed;\n        int index;\n        \n        Carriage(int speed, int index) {\n            this.speed = speed;\n            this.index = index;\n        }\n\n        @Override\n        public int compareTo(Carriage other) {\n            return other.speed - this.speed; // Descending order of speed\n        }\n    }\n\n    public static double minimizeTime(int n, int m, int[] speeds, double length, double[] widthAreas) {\n        Carriage[] carriages = new Carriage[n];\n        \n        for (int i = 0; i < n; i++) {\n            carriages[i] = new Carriage(speeds[i], i);\n        }\n        \n        Arrays.sort(carriages);\n        \n        double lastFinishTime = 0;\n        for (int i = 0; i < n; i++) {\n            Carriage carriage = carriages[i];\n            double finishTime = length / carriage.speed;\n            if (i > 0 && carriage.speed < carriages[i - 1].speed) {\n                finishTime += findPassingTime(widthAreas, length, carriages[i - 1], carriage);\n            }\n            lastFinishTime = Math.max(lastFinishTime, finishTime);\n        }\n        \n        return lastFinishTime;\n    }\n\n    private static double findPassingTime(double[] widthAreas, double length, Carriage faster, Carriage slower) {\n        double additionalTime = 0;\n        \n        for (double area : widthAreas) {\n            double timeToArea = area / slower.speed;\n            double positionFaster = faster.speed * timeToArea;\n            \n            if (positionFaster <= area) {\n                double passTime = (faster.speed - slower.speed) > 0 ? \n                        (area - positionFaster) / (faster.speed - slower.speed) : Double.MAX_VALUE;\n                additionalTime = Math.max(additionalTime, passTime);\n            }\n        }\n        \n        return additionalTime;\n    }\n\n    public static void main(String[] args) {\n        int n = 5; // number of carriages\n        int m = 3; // number of wider areas\n        int[] speeds = {10, 20, 15, 30, 25}; // speeds of the carriages\n        double lineLength = 100.0; // length of the line\n        double[] widthAreas = {25.0, 50.0, 75.0}; // positions of wider areas\n\n        double result = minimizeTime(n, m, speeds, lineLength, widthAreas);\n        System.out.println(\"Minimum time for all carriages to reach the goal: \" + result);\n    }\n}",
    "timestamp": "2025-08-13 06:49:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int speed;\n    double position;\n} Carriage;\n\nint compareCarriages(const void *a, const void *b) {\n    Carriage *c1 = (Carriage *)a;\n    Carriage *c2 = (Carriage *)b;\n    return c1->speed - c2->speed;\n}\n\ndouble findMinTimeToReachGoal(Carriage carriages[], int n, double distance, double passingAreas[], int m) {\n    // Sort carriages by speed in ascending order to maximize passing opportunities\n    qsort(carriages, n, sizeof(Carriage), compareCarriages);\n    \n    // Allocate a dynamic array to track the latest possible start time for each carriage\n    double *startTimes = (double *)malloc(n * sizeof(double));\n    startTimes[0] = 0.0; // First carriage starts immediately\n\n    for (int i = 1; i < n; i++) {\n        // Tentatively calculate start time as if no passing area exists\n        startTimes[i] = startTimes[i - 1] + distance / carriages[i - 1].speed;\n        \n        // Adjust start time allowing to pass in wider areas\n        for (int j = 0; j < m; j++) {\n            double timeToReachPassingArea = passingAreas[j] / carriages[i].speed;\n            double timeCarriageI1WouldReach = passingAreas[j] / carriages[i - 1].speed;\n            if (startTimes[i - 1] + timeCarriageI1WouldReach <= startTimes[i] + timeToReachPassingArea) {\n                startTimes[i] = startTimes[i - 1] + timeCarriageI1WouldReach - timeToReachPassingArea;\n            }\n        }\n    }\n\n    // Calculate time for the last carriage to reach the goal\n    double totalTime = startTimes[n - 1] + distance / carriages[n - 1].speed;\n\n    free(startTimes);\n    return totalTime;\n}\n\nint main() {\n    int n, m;\n    double distance;\n    \n    // Sample input: number of carriages, number of passing areas, and the distance from start to goal\n    scanf(\"%d %d %lf\", &n, &m, &distance);\n    \n    Carriage carriages[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &carriages[i].speed);\n        carriages[i].position = 0; // Initial position for each carriage\n    }\n    \n    double passingAreas[m];\n    for (int j = 0; j < m; j++) {\n        scanf(\"%lf\", &passingAreas[j]);\n    }\n    \n    double minTime = findMinTimeToReachGoal(carriages, n, distance, passingAreas, m);\n    printf(\"%.6lf\\n\", minTime);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 06:49:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_travel_time(n, m, speeds, passing_areas):\n    def can_complete_journey(total_time):\n        positions = [0] * n\n        for i in range(n):\n            positions[i] = speeds[i] * total_time\n        \n        free_passes = m\n        for i in range(n):\n            for j in range(i+1, n):\n                if positions[i] < positions[j]:\n                    continue\n                \n                # Check if carriages can pass at a wider area\n                if free_passes > 0:\n                    free_passes -= 1\n                else:\n                    return False\n        \n        return True\n\n    left, right = 0, 10**15\n    while left < right:\n        mid = (left + right) // 2\n        if can_complete_journey(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Example usage\nn, m = map(int, input().split())\nspeeds = list(map(int, input().split()))\npassing_areas = list(map(int, input().split())) if m > 0 else []\n\nresult = min_travel_time(n, m, speeds, passing_areas)\nprint(result)",
    "timestamp": "2025-08-13 06:49:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    n, m = int(data[idx]), int(data[idx+1])\n    idx +=2\n    S = list(map(int, data[idx:idx+n]))\n    idx +=n\n    D = list(map(int, data[idx:idx+m]))\n    idx +=m\n    \n    S_sorted = sorted(S, reverse=True)\n    D_sorted = sorted(D)\n    \n    max_time = 0\n    for i in range(n):\n        time = S_sorted[i] * (D_sorted[i] if i < m else D_sorted[-1])\n        if time > max_time:\n            max_time = time\n    \n    print(max_time)\n\nsolve()",
    "timestamp": "2025-08-13 06:52:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Carriage {\n    int speed;\n    double timeToGoal;\n    \n    bool operator<(const Carriage& other) const {\n        return speed > other.speed;\n    }\n};\n\nint main() {\n    int n, m, distance;\n    std::cin >> n >> m >> distance;\n\n    std::vector<Carriage> carriages(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> carriages[i].speed;\n        carriages[i].timeToGoal = static_cast<double>(distance) / carriages[i].speed;\n    }\n\n    // Sort carriages based on speed, descending\n    std::sort(carriages.begin(), carriages.end());\n\n    std::vector<std::vector<double>> dp(n, std::vector<double>(m + 1, 1e9));\n    dp[0][0] = carriages[0].timeToGoal;\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j <= m; ++j) {\n            dp[i][j] = dp[i-1][j] + carriages[i].timeToGoal;\n            if (j > 0) {\n                dp[i][j] = std::min(dp[i][j], dp[i-1][j-1] + carriages[i].timeToGoal);\n            }\n        }\n    }\n\n    double result = 1e9;\n    for (int j = 0; j <= m; ++j) {\n        result = std::min(result, dp[n-1][j]);\n    }\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:34:33"
  }
]