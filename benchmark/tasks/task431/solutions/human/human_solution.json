[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.immutable.HashSet\nimport scala.io.StdIn._\nobject Main extends App {\n  import Fractional.Implicits._\n  import Ordering.Implicits._\n  type Time = Rational\n  type Position = Rational\n  type Speed = Rational\n  type Index = Int\n\n  val goal = readLong().toRational\n  val n = readInt()\n  val carriages: Array[Carriage] = Array.tabulate(n){ i ⇒ Carriage(i, 1.toRational / readInt().toRational)}\n  val m = readInt()\n  val widePosition: Array[Position] = Array.tabulate(m){ _ ⇒ readInt().toRational} :+ goal\n  val memo = Array.fill(1 << n){None: Option[List[Schedule]]}\n  memo(1) = Some(List(Schedule(List(CarriagePlan(carriages(0), 0.toRational)))))\n\n  private val result = calSuspects(BitSet.fill(n))(memo)\n  println(result.map(_.lastTime).min)\n  def calSuspects(set: BitSet)(implicit memo: Array[Option[List[Schedule]]]): List[Schedule] = {\n    memo(set.toInt) match {\n      case Some(r) ⇒\n        r\n      case None ⇒\n        memo(set.toInt) = Some((1 until n).filter(set.isOn).flatMap(i ⇒ calSuspects(set - i).flatMap(_.added(carriages(i)))).toList)\n        calSuspects(set)\n    }\n  }\n  object BitSet{\n    def fill(size: Int): BitSet = BitSet((1 << size) - 1)\n  }\n  case class BitSet(val toInt: Int) {\n    def &(that: BitSet): BitSet = BitSet(toInt & that.toInt)\n    def |(that: BitSet): BitSet = BitSet(toInt | that.toInt)\n    def ^(that: BitSet): BitSet = BitSet(toInt ^ that.toInt)\n    def isOn(that: Int): Boolean = ((toInt >> that) & 1) == 1\n    def +(value: Int): BitSet = BitSet(toInt | (1 << value))\n    def -(value: Int): BitSet = BitSet(toInt & ~(1 << value))\n    def isEmpty: Boolean = toInt == 0\n  }\n  case class Carriage(id: Index, speed: Speed)\n  case class Schedule(plans: List[CarriagePlan], used: Set[(Time, Position)] = HashSet()) {\n    def tryAdd(that: CarriagePlan): Option[Schedule] = {\n      if (plans.exists(plan ⇒ (plan.carriage.id < that.carriage.id && plan.startTime >= that.startTime) || (plan.carriage.id > that.carriage.id && plan.startTime <= that.startTime))) None\n      else plans.flatMap(that.cross).filter{case (_, position) ⇒ 0.toRational <= position && position < goal}.partition{case pair@(_, position) ⇒ !widePosition.contains(position) || used.contains(pair)} match {\n        case (Nil, cp) ⇒ Some(Schedule(that::plans, used ++ cp))\n        case _ ⇒ None\n      }\n    }\n    def added(that: Carriage): List[Schedule] = {\n      plans.flatMap(plan ⇒ plan.constraints(that).flatMap(tryAdd))\n    }\n    def lastTime: Time = plans.map(_.reachTime(goal)).max\n  }\n  object CarriagePlan {\n    def apply(carriage: Carriage, time: Time, position: Position): CarriagePlan = {\n      CarriagePlan(carriage, time - position / carriage.speed)\n    }\n  }\n  case class CarriagePlan(carriage: Carriage, startTime: Time) {\n    def constraints(other: Carriage): List[CarriagePlan] = {\n      val res = if (carriage.id < other.id) {\n        if (!cross(CarriagePlan(other, startTime + 1.toRational)).exists { case (_, position) ⇒ 0.toRational <= position && position < goal }) CarriagePlan(other, (startTime + 1.toRational)) :: widePosition.map { position ⇒ CarriagePlan(other, reachTime(position), position) }.filter(startTime < _.startTime).toList\n        else widePosition.map { position ⇒ CarriagePlan(other, reachTime(position), position) }.filter(startTime < _.startTime).toList\n      }\n      else if (carriage.id > other.id) {\n        if (!cross(CarriagePlan(other, startTime - 1.toRational)).exists{case (_, position) ⇒ 0.toRational <= position && position < goal}) CarriagePlan(other, (startTime - 1.toRational)) :: widePosition.map{position ⇒ CarriagePlan(other, reachTime(position), position)}.filter(_.startTime < startTime).toList\n        else widePosition.map{position ⇒ CarriagePlan(other, reachTime(position), position)}.filter(_.startTime < startTime).toList\n      }else ???\n      res\n    }\n    def reachTime(position: Position): Time = {\n      position / carriage.speed + startTime\n    }\n    def cross(other: CarriagePlan): Option[(Time, Position)] = {\n      if (carriage.id < other.carriage.id) {\n        if (carriage.speed < other.carriage.speed) Some((other.startTime - startTime) * carriage.speed / (other.carriage.speed - carriage.speed)).map(time ⇒ (other.startTime + time, time * other.carriage.speed))\n        else None\n      }else {\n        if (other.carriage.speed < carriage.speed) Some((startTime - other.startTime) * other.carriage.speed / (carriage.speed - other.carriage.speed)).map(time ⇒ (startTime + time, time * carriage.speed))\n        else None\n      }\n    }\n  }\n\n  def max[T: Ordering](values: T*): T = values.min\n  implicit class Wrap[T](val value: T) extends AnyVal {\n    def toRational(implicit ev: T ⇒ Long): Rational = Rational.fromLong(value)\n    def pipe(@inline func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n  }\n  final class Rational private (val numerator: Long, val denominator: Long) {\n    override def equals(obj: Any): Boolean = obj match {\n      case r: Rational ⇒ numerator == r.numerator && denominator == r.denominator\n      case _ ⇒ super.equals(obj)\n    }\n    override def hashCode(): Int = numerator.hashCode() ^ denominator.hashCode()\n    override def toString: String = if (denominator == 1) numerator.toString else s\"$numerator/$denominator\"\n  }\n  implicit object Rational extends Fractional[Rational] {\n    @tailrec private[this] def gcd(a: Long, b: Long): Long = b match {\n      case 0 ⇒ a\n      case _ ⇒ gcd(b, a % b)\n    }\n    def apply(numerator: Long, denominator: Long): Rational = {\n      val g = gcd(numerator.abs, denominator.abs)\n      new Rational(denominator.signum * numerator / g, denominator.abs / g)\n    }\n    def fromLong(x: Long): Rational = new Rational(x, 1)\n    override def div(x: Rational, y: Rational): Rational = Rational(x.numerator * y.denominator, x.denominator * y.numerator)\n    override def plus(x: Rational, y: Rational): Rational = Rational(x.numerator * y.denominator + x.denominator * y.numerator, x.denominator * y.denominator)\n    override def minus(x: Rational, y: Rational): Rational = Rational(x.numerator * y.denominator - x.denominator * y.numerator, x.denominator * y.denominator)\n    override def times(x: Rational, y: Rational): Rational = Rational(x.numerator * y.numerator, x.denominator * y.denominator)\n    override def negate(x: Rational): Rational = new Rational(-x.numerator, x.denominator)\n    override def fromInt(x: Int): Rational = new Rational(x, 1)\n    override def toInt(x: Rational): Int = (x.numerator / x.denominator).toInt\n    override def toLong(x: Rational): Long = (x.numerator / x.denominator).toLong\n    override def toFloat(x: Rational): Float = toDouble(x).toFloat\n    override def toDouble(x: Rational): Double = x.numerator.toDouble / x.denominator\n    override def compare(x: Rational, y: Rational): Int = (x.numerator * y.denominator).compare(x.denominator * y.numerator)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint n,m;\nint S[MAXN];\nint D[MAXN];\nint OK[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,int> mp;\nstruct permutation{\n    int a[10];\n}per;\nint percnt;\nvector<permutation> P;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=n;i++)if(out_time[i]<=out_time[i-1]) return false;\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<n;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=m;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n            if(!ok) return false;\n            if(mp.count(tmpD)) return false;\n            mp[tmpD]++;\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=n;i++) tmpans=max(tmpans,out_time[i]+(LL)dist*S[i]);\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\" : tmpans = %lld\\n\",tmpans);\n    ans=min(ans,tmpans);\n}\n\nint mark[MAXN];\nvoid DFS1(int cur){\n    if(cur>n){\n        per.a[0]=1;\n        P.push_back(per);\n        return;\n    }\n    for(int i=2;i<=n;i++)if(!mark[i]){\n        per.a[++percnt]=i;\n        mark[i]=1;\n        DFS1(cur+1);\n        percnt--;\n        mark[i]=0;\n    }\n}\n\nvoid DFS2(int curid,permutation now){\n    if(curid>=n){\n        update();\n        return;\n    }\n    int cur=now.a[curid];\n    for(int t=0;t<curid;t++){\n        int pre=now.a[t];\n        if(cur<pre){\n            out_time[cur]=out_time[pre]-1;\n            DFS2(curid+1,now);\n    //        if(S[cur]<=S[pre]) return;\n            for(int i=1;i<=m+1;i++){\n                LL dt=(i==m+1) ? dist : D[i];\n                out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n                DFS2(curid+1,now);\n            }\n        }\n        if(cur>pre){\n            out_time[cur]=out_time[pre]+1;\n            DFS2(curid+1,now);\n    //        if(S[cur]>=S[pre]) return;\n            for(int i=1;i<=m+1;i++){\n                LL dt=(i==m+1) ? dist : D[i];\n                out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n                DFS2(curid+1,now);\n            }\n        }\n\n    }\n}\n\nvoid solve(){\n    out_time[1]=0LL;\n    for(int perid=0;perid<P.size();perid++){\n        permutation now=P[perid];\n        DFS2(1,now);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++) scanf(\"%d\",&D[i]);\n    for(int j=2;j<=n;j++){\n        int ok=1;\n        for(int i=1;i<j;i++) if(S[i]>S[j]) ok=0;\n        for(int k=j+1;k<=n;k++) if(S[j]>S[k]) ok=0;\n        OK[j]=ok;\n    }\n    ans=(LL)INF*INF;\n    out_time[1]=0;\n    DFS1(2);\n//    printf(\"Pcnt = %d\\n\",P.size());\n//    for(int i=0;i<P.size();i++){\n//        for(int k=1;k<=n-1;k++) printf(\"%d \",P[i].a[k]);\n//        printf(\"\\n\");\n//    }\n    solve();\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nll dist,n,m;\nll S[6],D[6];\nint decide[6];\nll ans;\nll start[6];\n\nvoid f(int cur){\n\t//cout<<cur<<\": \";\n\t//rep(i,n)cout<<start[i]<<\" \";cout<<endl;\n\tif(cur==n){\n\t\t//rep(i,n)cout<<start[i]<<\" \";\n\t\tll res=0;\n\t\trep(i,n){\n\t\t\tres=max(res,start[i] + dist*S[i]);\n\t\t}\n\t\t//cout<<\":\"<<res<<endl;\n\t\tans=min(ans,res);\n\t\treturn;\n\t}\n\tint target=decide[cur];\n\trep(i,cur+1)rep(j,i<cur ? m : 1){\n\t\tif(i==cur){\n\t\t\tif(start[target-1]==-1)continue;\n\t\t\tstart[target]=start[target-1]+1;\n\t\t}\n\t\telse{\n\t\t\tint car=decide[i];\n\t\t\tif(S[target] == S[car])continue;\n\t\t\tstart[target] = start[car] + D[j] * (S[car]-S[target]);\n\t\t}\n\t\t//cout<<cur<<\" start: \"<<start[target]<<endl;\n\t\t\n\t\tif(start[target]<0){\n\t\t\tstart[target]=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tint ok=1;\n\t\tint used[6]={};\n\t\trep(k,cur){\n\t\t\tint car=decide[k];\n\t\t\tif(car < target && start[target] <= start[car]\n\t\t\t|| car > target && start[target] >= start[car]){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tll difstart = start[car]-start[target];\n\t\t\tll difS = S[target]-S[car];\n\t\t\t//cout<<k<<\" \"<<difstart<<\" \"<<difS<<endl;\n\t\t\tif(difS == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart > 0 && difS < 0 || difstart < 0 && difS > 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart < 0 && difS < 0){\n\t\t\t\tdifstart*=-1;\n\t\t\t\tdifS*=-1;\n\t\t\t}\n\t\t\tif(difstart >= difS * dist)continue;\n\t\t\tif(difstart % difS){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tll point = difstart/difS;\n\t\t\t//cout<<point<<endl;\n\t\t\tint found=0;\n\t\t\trep(l,m)if(D[l]==point){\n\t\t\t\tfound=1;\n\t\t\t\tif(used[l]){\n\t\t\t\t\tok=0;break;\n\t\t\t\t}\n\t\t\t\tused[l]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!found){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tf(cur+1);\n\t\t}\n\t\tstart[target]=-1;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>dist>>n;\n\trep(i,n)cin>>S[i];\n\tcin>>m;\n\trep(i,m)cin>>D[i];\n\tD[m++]=dist;\n\tsort(D,D+m);\n\t//rep(i,m)cout<<D[i]<<\" \";cout<<endl;\n\t\n\trep(i,n)decide[i]=i;\n\tmemset(start,-1,sizeof(start));\n\tstart[0]=0;\n\tans=INF*INF;\n\tdo{\n\t\t//rep(i,n)cout<<decide[i]<<\" \";cout<<endl;\n\t\tf(1);\n\t\t//cout<<endl;\n\t}while(next_permutation(decide+1,decide+n));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = (ll)1e15;\n\nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n\ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(dif[i][k]!=inf && dif[k][j]!=inf && i!=j)\n\t  dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)if(dif[i][j]<0)return inf;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(dif[v[i]][v[j]] == inf)continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n\t  if(dif[v[i]][v[j]]<0)continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n\n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(dif[j][i] != inf){\n\t    start[j] = start[i] + dif[i][j];\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n      /*\n      for(int j=0;j<=i;j++){\n\tcout << start[j] << \" \" << goal[j] << endl;\n      }\n      cout << \"----------------------\" << endl;\n      */\n    }\n    \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl;\n\n    cout << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n  \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      wf();      \n      swap(v[i],v[i+1]);\n\n      res = min(res,rec(v,depth+1));\n\n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n\n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n\t  dif[v[j]][v[j+1]] = t2; dif[v[j+1]][v[j]] = -t2;\n\t  wf();\n\t  swap(v[j],v[j+1]);\n\n\t  res = min(res,rec(v,depth+1));\n\n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n\t}\n      }\n\n      swap(v[i],v[i+1]);\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = (ll)1e15;\n\nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n\ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(dif[i][k] == inf || dif[k][j] == inf)continue;\n\telse dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(dif[v[i]][v[j]] == inf)continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n\t  return inf;\n\t}else{\n\t  if(s[v[i]] > s[v[j]])return inf;\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n\n    ll goal[9],start[9];\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(dif[j][i] == inf && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(dif[j][i] != inf){\n\t    start[j] = start[i] + dif[i][j];\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n  \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n\n  rec(v,depth+1);\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n \n      int t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      wf();      \n      swap(v[i],v[i+1]);\n\n      res = min(res,rec(v,depth+1));\n\n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n\n\t  int t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n\t  dif[v[j]][v[j+1]] = t2; dif[v[j]][v[j+1]] = -t2;\n\t  wf();\n\t  swap(v[j],v[j+1]);\n\n\t  res = min(res,rec(v,depth+1));\n\n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n\t}\n      }\n\n      swap(v[i],v[i+1]);\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, intr;\nvector<LL> D;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\n\tvector<vector<int> > odr(m + 1, vector<int>(n));\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\t\n\tint cnt = 0;\n\tfor(int j = 0; j < m; ++j){\n\t\todr[j + 1] = odr[j];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i + 1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j + 1][i], odr[j + 1][i + 1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] != -1LL) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] == -1LL && stm[b] != -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[j] * (S[b] - S[a]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] != -1LL && stm[b] == -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[j] * (S[a] - S[b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] != -1LL; ++j)\n\t\tfor(int k = j + 1; stm[k] != -1LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(y >= n - 1 || odr[x][y+1] != k ||\n\t\t\t  odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\tif(cnt != 0) return;\n\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr.resize(m);\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  while(1){\n    cout << \"海ちゃんイェーイ！\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<long long int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[uf.root(i).first] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taa afrom(prev(it)->second);\n\t\t\taa ato(it->second);\n\n\t\t\tif (afrom.lasfintime - afrom.lasstatime>ato.fstfintime-ato.fststatime) {\n\t\t\t\tuf.unionSet(afrom.lasfinid, ato.fstfinid, times[afrom.lasfinid][M] - times[ato.fstfinid][M]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf.unionSet(afrom.lasstaid, ato.fststaid, 1);\n\t\t\t}\n\t\t\t/*aUnionFind auf(uf);\n\t\t\taUnionFind buf(uf);\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasfinid;\n\t\t\t\tint to = (it)->second.fstfinid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tauf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauf.unionSet((prev(it))->second.lasstaid, (it)->second.fststaid, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasstaid;\n\t\t\t\tint to = (it)->second.fststaid;\n\t\t\t\tbuf.unionSet(from, to, 1);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (buf.root((it)->second.fststaid).second > auf.root((it)->second.fststaid).second) {\n\t\t\t\tuf = buf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf = auf;\n\t\t\t}*/\n\t\t}\n\t}\n\tfor (int i = 0; i < HorseNum - 1; ++i) {\n\t\tif (uf.root(i).second >= uf.root(i + 1).second)return My_LInf;\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\t\n\t\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tsort(ds.begin(), ds.end());\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tans = min(ans,a);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nll dist,n,m;\nll S[6],D[6];\nint decide[6];\nll ans;\nll start[6];\n\nvoid f(int cur){\n\t//cout<<cur<<\": \";\n\t//rep(i,n)cout<<start[i]<<\" \";cout<<endl;\n\tif(cur==n){\n\t\t//rep(i,n)cout<<start[i]<<\" \";cout<<endl;\n\t\tll res=0;\n\t\trep(i,n){\n\t\t\tres=max(res,start[i] + dist*S[i]);\n\t\t}\n\t\tans=min(ans,res);\n\t\treturn;\n\t}\n\tint target=decide[cur];\n\trep(i,cur+1)rep(j,i<cur ? m : 1){\n\t\tif(i==cur){\n\t\t\tif(start[target-1]==-1)continue;\n\t\t\tstart[target]=start[target-1]+1;\n\t\t}\n\t\telse{\n\t\t\tint car=decide[i];\n\t\t\tif(S[target] == S[car])continue;\n\t\t\tstart[target] = start[car] + D[j] * (S[car]-S[target]);\n\t\t}\n\t\t//cout<<cur<<\" start: \"<<start[target]<<endl;\n\t\t\n\t\tif(start[target]<0){\n\t\t\tstart[target]=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tint ok=1;\n\t\trep(k,cur){\n\t\t\tint car=decide[k];\n\t\t\tif(car < target && start[target] <= start[car]\n\t\t\t|| car > target && start[target] >= start[car]){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tll difstart = start[car]-start[target];\n\t\t\tll difS = S[target]-S[car];\n\t\t\t//cout<<k<<\" \"<<difstart<<\" \"<<difS<<endl;\n\t\t\tif(difS == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart > 0 && difS < 0 || difstart < 0 && difS > 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart < 0 && difS < 0){\n\t\t\t\tdifstart*=-1;\n\t\t\t\tdifS*=-1;\n\t\t\t}\n\t\t\tif(difstart > difS * dist)continue;\n\t\t\tif(difstart % difS){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tll point = difstart/difS;\n\t\t\tint found=0;\n\t\t\trep(l,m)if(D[l]==point){\n\t\t\t\tfound=1;break;\n\t\t\t}\n\t\t\tif(!found){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tf(cur+1);\n\t\t}\n\t\tstart[target]=-1;\n\t}\n}\n\nvoid main2(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>dist>>n;\n\trep(i,n)cin>>S[i];\n\tcin>>m;\n\trep(i,m)cin>>D[i];\n\tD[m++]=dist;\n\tsort(D,D+m);\n\t//rep(i,m)cout<<D[i]<<\" \";cout<<endl;\n\t\n\trep(i,n)decide[i]=i;\n\tmemset(start,-1,sizeof(start));\n\tstart[0]=0;\n\tans=INF*INF;\n\tdo{\n\t\t//rep(i,n)cout<<decide[i]<<\" \";cout<<endl;\n\t\tf(1);\n\t\t//cout<<endl;\n\t}while(next_permutation(decide+1,decide+n));\n\tcout<<ans<<endl;\n}\n\nint main(){\n\trep(i,100000)main2();\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    ?????????????????¨??????\n*/\n\n#define __1__\n\n#ifdef __1__\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0;i < (n);i++)\n#define _MAX 7\n#define INF 7e10\n#define MIN(a,b) (a)>(b)?(b):(a)\nusing namespace std;\ntypedef long long int lint;\n\n\nint dist,n,m;\nlint tm[_MAX][_MAX+2]; //tm[][0]?????????????????????,tm[][m+1]???????????´??????\nlint S[_MAX];\nlint D[_MAX];\n\nlint rettm(){\n    lint ans = 0;\n    rep(i,n){\n        ans = max(ans,tm[i][m+1]);\n    }\n    return ans;\n}\n\nvoid maketm(int x){\n    rep(i,m){\n        tm[x][i+1]=tm[x][0]+D[i]*S[x];\n    }\n    tm[x][m+1]=tm[x][0]+S[x]*dist;\n    return;\n}\n\nvoid show(){\n    rep(i,n){\n        rep(j,m+2){\n            printf(\"%4lld \",tm[i][j]);\n        }\n        cout << endl;\n    }\n    cout << endl;\n    return;\n}\n\nint flag[5]={0};\n\nbool check(){\n    rep(i,n-1){\n        if(tm[i][0]>=tm[i+1][0]){\n            return false;\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            if(i<j&&tm[i][m+1]>tm[j][m+1]){\n                bool hoge = 0;\n                rep(k,m){\n                    if(tm[i][k+1]==tm[j][k+1]){\n                        rep(l,n){\n                            if(l!=i&&l!=j&&tm[i][k+1]==tm[l][k+1])\n                                return false;\n                        }\n                        hoge = true;\n                    }\n                }\n                if(hoge == 0)\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n\nlint dfs(int d){\n    lint ans = INF;\n    if(d==n){\n        if(check()){\n//            show();\n            return rettm();\n        }else{\n            return 7e10;\n        }\n    }\n    rep(i,n){\n        if(flag[i]==1)\n            continue;\n        flag[i]=1;\n        if(i==0){\n            tm[i][0]=0;\n            maketm(i);\n            ans = min(dfs(d+1),ans);\n        }else if(flag[i-1]==1){\n            tm[i][0]=tm[i-1][0]+1;\n            maketm(i);\n            ans = min(dfs(d+1),ans);\n        }\n        rep(j,n){\n            if(j==i||flag[j]==0)\n                continue;\n            rep(k,m){\n                tm[i][0]=tm[j][k+1]-D[k]*S[i];\n                maketm(i);\n                ans = min(dfs(d+1),ans);\n            }\n            tm[i][0]=tm[j][m+1]-dist*S[i];\n            maketm(i);\n            ans = min(dfs(d+1),ans);\n        }\n        flag[i]=0;\n    }\n    return ans;\n}\n    \nint main() {\n    cin >> dist >> n;\n    rep(i,n){\n        cin >> S[i];\n    }\n    cin >> m;\n    rep(i,m){\n        cin >> D[i];\n    }\n    cout << dfs(0) << endl;\n    return 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\n#define fs first\n#define sc second\n\nconst ll inf = (ll)1e15;\nP par[9];\nint rank[9];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n \nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n   \n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nll dis(int a, int b){\n  if(!same(a,b))return inf;\n  return find(b).sc - find(a).sc;\n}\n\nll dist;\nint n,m;\nll s[9],d[9];\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++)\n      for(int j=i;j<n;j++)\n\tif(dis(i,j)<=0)return inf;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] <= s[v[j]])continue;\n\t  if(!same(v[i],v[j]))continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dis(v[i],v[j]))continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dis(v[j],v[i]));\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n    \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(same(i-1,i))start[i] = start[i-1] + dis(i-1,i);\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(same(i,j)){\n\t    start[j] = start[i] + dis(i,j);\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=0;i<n;i++)res = max(res,goal[i]);\n    return res;\n  }\n  \n  ll res = inf;\n  P tp1[9],tp2[9];\n  int tr1[9],tr2[9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++){\n\ttp1[x] = par[x];\n\ttr1[x] = rank[x];\n      }\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(!unite(v[i],v[i+1],t1))continue;\n\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++){\n\t    tp2[x] = par[x];\n\t    tr2[x] = rank[x];\n\t  }\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(!unite(v[j],v[j+1],t2))continue;\n\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++){\n\t    par[x] = tp2[x];\n\t    rank[x] = tr2[x];\n\t  }\n\t}\n      }\n      swap(v[i],v[i+1]);\n     \n      for(int x=0;x<n;x++){\n\tpar[x] = tp1[x];\n\trank[x] = tr1[x];\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  init(n);\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\n\n\nconst ll INF = 1LL<<50;\nconst int MAX_V = 20;\n\ntemplate<class T> struct Edge {\n    int from, to;\n    T cost;\n    Edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n    friend bool operator < (const Edge &e1, const Edge &e2) {return e1.cost < e2.cost;}\n    friend bool operator > (const Edge &e1, const Edge &e2) {return e1.cost > e2.cost;}\n};\n\ntemplate<class T> struct Graph {\n    int V,E;\n    vector<Edge<T> > list[MAX_V];\n    \n    Graph(int n = 0) : V(n), E(0) {}\n    void init(int n = 0) {V = n; E = 0; for (int i = 0; i < MAX_V; ++i) list[i].clear();}\n    inline vector<Edge<T> >& operator [] (int i) {return list[i];}\n    \n    void direct(int f, int t, T c) {\n        ++E;\n        list[f].push_back(Edge<T>(f,t,c));\n    }\n};\n\n\nll dist[MAX_V];\ntemplate<class T> bool BellmanFord(Graph<T> &G, int s) {\n    fill(dist, dist+G.V, INF);\n    dist[s] = 0;\n    for (int i = 0; i <= G.V; ++i) {\n        bool finish = true;\n        for (int i = 0; i < G.V; ++i) {\n            if (dist[i] != INF) {\n                for (int j = 0; j < G[i].size(); ++j) {\n                    Edge<T> e = G[i][j];\n                    if (dist[e.to] > dist[i] + e.cost) {\n                        dist[e.to] = dist[i] + e.cost;\n                        finish = false;\n                    }\n                }\n            }\n        }\n        if (finish) return true;\n    }\n    return false;\n}\n\n\nGraph<ll> G;\n\nint n, m;\nll Dist;\nll S[MAX_V], D[MAX_V];\n\nbool caninter[MAX_V][MAX_V];\nint place[MAX_V][MAX_V];\n\nll solve() {\n    Graph<ll> nG = G;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            if (place[i][j] == -1) {\n                ll d = (S[j] - S[i]) * Dist;\n                nG.direct(i, j, d);\n            }\n            else {\n                int k = place[i][j];\n                ll d = (S[i] - S[j]) * D[k];\n                nG.direct(j, i, d);\n                nG.direct(i, j, -d);\n            }\n        }\n    }\n    \n    bool ok = BellmanFord(nG, 0);\n    if (ok) {\n        ll Max = -1;\n        for (int i = 0; i < n; ++i) {\n            Max = max(Max, -dist[i] + S[i] * Dist);\n        }\n        return Max;\n    }\n    return INF;\n}\n\n\nll res = INF;\nvoid dfs(int i, int j) {\n    if (i == n-1) {\n        bool ok = true;\n        set<int> se[MAX_V];\n        for (int k = 0; k < n; ++k) {\n            for (int l = k+1; l < n; ++l) {\n                int p = place[k][l];\n                if (p == -1) continue;\n                if (se[p].count(k) || se[p].count(l)) ok = false;\n                else {se[p].insert(k); se[p].insert(l);}\n            }\n        }\n        if (ok) {\n            ll temp = solve();\n            res = min(res, temp);\n        }\n        return;\n    }\n    else if (j == n) {\n        dfs(i+1, i+2);\n        return;\n    }\n    \n    dfs(i, j+1);\n    if (caninter[i][j]) {\n        for (int k = 0; k < m; ++k) {\n            place[i][j] = k;\n            dfs(i, j+1);\n            place[i][j] = -1;\n        }\n    }   \n}\n\nint main() {\n    while (cin >> Dist) {\n        cin >> n; for (int i = 0; i < n; ++i) cin >> S[i];\n        cin >> m; for (int i = 0; i < m; ++i) cin >> D[i];\n        \n        G.init(n);\n        for (int i = 0; i < n-1; ++i) G.direct(i, i+1, -1);\n        \n        memset(caninter, 0, sizeof(caninter));\n        for (int i = 0; i < n; ++i) {\n            for (int j = i+1; j < n; ++j) {\n                if (S[i] > S[j]) caninter[i][j] = true;\n            }\n        }\n        \n        memset(place, -1, sizeof(place));\n        res = INF;\n        dfs(0, 1);\n        \n        cout << res << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, D, intr;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\t\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tp[i] = i;\n\t}\n\n\tvector<vector<int> > odr(m + 1);\n\todr[0].resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\n\tint cnt = 0;\n\tfor(int j = 1; j <= m; ++j){\n\t\todr[j] = odr[j - 1];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j-1] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i+1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j][i], odr[j][i+1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] >= 0) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] == -1LL && stm[b] != -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[j] * (S[b] - S[a]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] != -1LL && stm[b] == -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[j] * (S[a] - S[b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] >= 0LL; ++j)\n\t\tfor(int k = j + 1; stm[k] >= 0LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\n\tif(cnt != 0) return;\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr = D;\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = (ll)1e15;\n\nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n\ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(dif[i][k] == inf || dif[k][j] == inf)continue;\n\telse dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(dif[v[i]][v[j]] == inf)continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n\t  return inf;\n\t}else{\n\t  if(s[v[i]] > s[v[j]])return inf;\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n\n    ll goal[9],start[9];\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(v[j]<v[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(dif[j][i] != inf){\n\t    start[j] = start[i] + dif[i][j];\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n  \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n \n      int t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      wf();      \n      swap(v[i],v[i+1]);\n\n      res = min(res,rec(v,depth+1));\n\n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n\n\t  int t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n\t  dif[v[j]][v[j+1]] = t2; dif[v[j]][v[j+1]] = -t2;\n\t  wf();\n\t  swap(v[j],v[j+1]);\n\n\t  res = min(res,rec(v,depth+1));\n\n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n\t}\n      }\n\n      swap(v[i],v[i+1]);\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[i] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime =uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taUnionFind auf(uf);\n\t\t\taUnionFind buf(uf);\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasfinid;\n\t\t\t\tint to = (it)->second.fstfinid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tauf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauf.unionSet(from, to, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasstaid;\n\t\t\t\tint to = (it)->second.fststaid;\n\t\t\t\tbuf.unionSet(from, to, 1);\n\t\t\t\t\n\t\t\t}\n\t\t\tif (buf.root((it)->second.fststaid).second > auf.root((it)->second.fststaid).second) {\n\t\t\t\tuf = buf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf = auf;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\t\n\t\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tans = min(ans,a);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\n#define fs first\n#define sc second\n\nconst ll inf = (ll)1e15;\nP par[9];\nint rank[9];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n \nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n   \n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nll dis(int a, int b){\n  if(!same(a,b))return inf;\n  return par[b].sc - par[a].sc;\n}\n\nll dist;\nint n,m;\nll s[9],d[9];\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(same(i,j) && dis(i,j)<=0)return inf;\n    /*\n    cout << \"[\";\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << \"]\\n\";\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(!same(i,j))cout << inf << \" \";\n\telse cout << dis(i,j) << \" \";\n      }\n      cout << endl;\n    }\n    */\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(!same(v[i],v[j]))continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dis(v[i],v[j]))continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dis(v[j],v[i]));\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n    \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(same(i-1,i))start[i] = start[i-1] + dis(i-1,i);\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(same(i,j)){\n\t    start[j] = start[i] + dis(i,j);\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n      /*      \n      for(int j=0;j<=i;j++){\n\tcout << start[j] << \" \" << goal[j] << endl;\n      }\n      cout << \"----------------------\" << endl;\n      */\n    }\n    \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    return res;\n  }\n  \n  ll res = inf;\n  P tp1[9],tp2[9];\n  int tr1[9],tr2[9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++){\n\ttp1[x] = par[x];\n\ttr1[x] = rank[x];\n      }\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(!unite(v[i],v[i+1],t1))continue;\n\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++){\n\t    tp2[x] = par[x];\n\t    tr2[x] = rank[x];\n\t  }\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(!unite(v[j],v[j+1],t2))continue;\n\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++){\n\t    par[x] = tp2[x];\n\t    rank[x] = tr2[x];\n\t  }\n\t}\n      }\n      swap(v[i],v[i+1]);\n     \n      for(int x=0;x<n;x++){\n\tpar[x] = tp1[x];\n\trank[x] = tr1[x];\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  init(n);\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i,n) for(int i = 0;i < n;i++)\n\nusing namespace std;\n#define INF 1e16\ntypedef long long lint;\n\nbool went[5]={0};\nlint tm[5];\nlint S[5];\nlint dist;\nlint D[5];\nint n,m;\nlint answer = INF;\nlint pre;\n\nvoid judge(){\n    vector<pair<lint,lint> > meet;\n    rep(i,n-1){\n        for(int j = i + 1;j < n;j++){\n            int hoge = 0;\n            if(S[i] < S[j]||tm[j]-tm[i] >= (S[i]-S[j])*dist)\n                continue;\n            rep(k,m){\n                if(tm[i]-tm[j] == (S[j]-S[i])*D[k]){\n                    meet.push_back(make_pair(tm[j]+S[j]*D[k],k));\n                    hoge = 1;\n                    break;\n                }\n            }\n            if(!hoge){\n                return;\n            }\n        }\n    }\n    if(!meet.empty()){\n        sort(meet.begin(),meet.end());\n        rep(i,meet.size()-1){\n            if(meet[i] == meet[i+1])\n                return;\n        }\n    }\n    pre = 0;\n    rep(i,n){\n        pre = max(pre,tm[i]+dist*S[i]);\n    }\n    answer = min(answer,pre);\n}\n\nvoid search(int p){\n    if(p == 0){\n        tm[0] = 0;\n        went[0]=1;\n        search(1);\n        return;\n    }\n    rep(i,n-1){\n        if(went[i] && went[i+1] && tm[i] >= tm[i+1])\n            return;\n    }\n    if(p == n){\n        judge();\n        return;\n    }\n    rep(i,n-1){\n        if(went[i] && !went[i+1]){\n            tm[i+1] = tm[i]+1;\n            went[i+1] = 1;\n            search(p+1);\n            went[i+1] = 0;\n        }\n        if(!went[i] && went[i+1]){\n            tm[i] = tm[i+1]-1;\n            went[i] = 1;\n            search(p+1);\n            went[i] = 0;\n        }\n    }\n    rep(i,n){\n        if(!went[i]){\n            rep(j,n){\n                if((i < j && S[i]<S[j])||(i > j && S[i]>S[j]))\n                    continue;\n                if(went[j]){\n                    rep(k,m){\n                        tm[i] = tm[j]+(S[j]-S[i])*D[k];\n                        went[i] = 1;\n                        search(p+1);\n                        went[i] = 0;\n                    }\n                    tm[i] = tm[j]+(S[j]-S[i])*dist;\n                    went[i] = 1;\n                    search(p+1);\n                    went[i] = 0;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    cin  >> dist;\n    cin >> n;\n    rep(i,n){\n        cin >> S[i];\n    }\n    cin >> m;\n    rep(i,m){\n        cin >> D[i];\n    }\n    search(0);\n    cout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[i] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime =uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taUnionFind auf(uf);\n\t\t\taUnionFind buf(uf);\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasfinid;\n\t\t\t\tint to = (it)->second.fstfinid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tauf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauf.unionSet((prev(it))->second.lasstaid, (it)->second.fststaid, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasstaid;\n\t\t\t\tint to = (it)->second.fststaid;\n\t\t\t\tbuf.unionSet(from, to, 1);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (buf.root((it)->second.fststaid).second > auf.root((it)->second.fststaid).second) {\n\t\t\t\tuf = buf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf = auf;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\t\n\t\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tans = min(ans,a);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = (ll)1e15;\n\nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n\ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(dif[i][k] == inf || dif[k][j] == inf)continue;\n\telse dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(dif[v[i]][v[j]] == inf)continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n\t  return inf;\n\t}else{\n\t  if(s[v[i]] > s[v[j]])return inf;\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n\n    ll res = 0,start = 0;\n    for(int i=0;i<n;i++){\n      if(i){\n\tif(dif[i-1][i] != inf)start += dif[i-1][i];\n\telse start += max(1LL,(s[i-1]-s[i])*dist);\n      }\n      res = max(res,start+dist*s[i]);\n    }\n    return res;\n  }\n  \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n\n  rec(v,depth+1);\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n \n      int t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      wf();      \n      swap(v[i],v[i+1]);\n\n      res = min(res,rec(v,depth+1));\n\n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n\n\t  int t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n\t  dif[v[j]][v[j+1]] = t2; dif[v[j]][v[j+1]] = -t2;\n\t  wf();\n\t  swap(v[j],v[j+1]);\n\n\t  res = min(res,rec(v,depth+1));\n\n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n\t}\n      }\n\n      swap(v[i],v[i+1]);\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nll dist,n,m;\nll S[6],D[6];\nint decide[6];\nll ans=INF*INF;\nll start[6];\n\nvoid f(int cur){\n\t//cout<<cur<<\": \";\n\t//rep(i,n)cout<<start[i]<<\" \";cout<<endl;\n\tif(cur==n){\n\t\tll res=0;\n\t\trep(i,n){\n\t\t\tres=max(res,start[i] + dist*S[i]);\n\t\t}\n\t\tans=min(ans,res);\n\t\treturn;\n\t}\n\tint target=decide[cur];\n\trep(i,cur+1)rep(j,i<cur ? m : 1){\n\t\tif(i==cur){\n\t\t\tif(start[target-1]==-1)continue;\n\t\t\tstart[target]=start[target-1]+1;\n\t\t}\n\t\telse{\n\t\t\tint car=decide[i];\n\t\t\tif(S[target] == S[car])continue;\n\t\t\tstart[target] = start[car] + D[j] * (S[car]-S[target]);\n\t\t}\n\t\t//cout<<cur<<\" start: \"<<start[target]<<endl;\n\t\t\n\t\tif(start[target-1]!=-1 && start[target] <= start[target-1] ||\n\t\tstart[target+1]!=-1 && start[target] >= start[target+1]){\n\t\t\tcontinue;\n\t\t}\n\t\tint ok=1;\n\t\trep(k,cur){\n\t\t\tint car=decide[k];\n\t\t\tif(S[car] == S[target])continue;\n\t\t\tll difstart = start[car]-start[target];\n\t\t\tll difS = S[target]-S[car];\n\t\t\t//cout<<k<<\" \"<<difstart<<\" \"<<difS<<endl;\n\t\t\tif(difstart == 0){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tif(difS == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart > 0 && difS < 0 || difstart < 0 && difS > 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart < 0 && difS < 0){\n\t\t\t\tdifstart*=-1;\n\t\t\t\tdifS*=-1;\n\t\t\t}\n\t\t\tif(difstart > difS * dist)continue;\n\t\t\tif(difstart % difS){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tint found=0;\n\t\t\trep(l,m)if(D[l]==dist){\n\t\t\t\tfound=1;break;\n\t\t\t}\n\t\t\tif(!found){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tf(cur+1);\n\t\t}\n\t\tstart[target]=-1;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>dist>>n;\n\trep(i,n)cin>>S[i];\n\tcin>>m;\n\trep(i,m)cin>>D[i];\n\tD[m++]=dist;\n\tsort(D,D+m);\n\t//rep(i,m)cout<<D[i]<<\" \";cout<<endl;\n\t\n\trep(i,n)decide[i]=i;\n\tmemset(start,-1,sizeof(start));\n\tstart[0]=0;\n\tdo{\n\t\t//rep(i,n)cout<<decide[i]<<\" \";cout<<endl;\n\t\tf(1);\n\t\t//cout<<endl;\n\t}while(next_permutation(decide+1,decide+n));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\n#define fs first\n#define sc second\n\nconst ll inf = (ll)1e15;\nP par[9];\nint rank[9];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n \nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n   \n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nll dis(int a, int b){\n  if(!same(a,b))return inf;\n  return find(b).sc - find(a).sc;\n}\n\nll dist;\nint n,m;\nll s[9],d[9];\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(dis(i,j)<=0)return inf;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] <= s[v[j]])continue;\n\t  if(!same(v[i],v[j]))continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dis(v[i],v[j]))continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dis(v[j],v[i]));\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n    \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(same(i-1,i))start[i] = start[i-1] + dis(i-1,i);\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(same(i,j)){\n\t    start[j] = start[i] + dis(i,j);\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=0;i<n;i++)res = max(res,goal[i]);\n    return res;\n  }\n  \n  ll res = inf;\n  P tp1[9],tp2[9];\n  int tr1[9],tr2[9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++){\n\ttp1[x] = par[x];\n\ttr1[x] = rank[x];\n      }\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(!unite(v[i],v[i+1],t1))continue;\n\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++){\n\t    tp2[x] = par[x];\n\t    tr2[x] = rank[x];\n\t  }\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(!unite(v[j],v[j+1],t2))continue;\n\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++){\n\t    par[x] = tp2[x];\n\t    rank[x] = tr2[x];\n\t  }\n\t}\n      }\n      swap(v[i],v[i+1]);\n     \n      for(int x=0;x<n;x++){\n\tpar[x] = tp1[x];\n\trank[x] = tr1[x];\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  init(n);\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint n,m;\nint S[MAXN];\nint D[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,int> mp;\nstruct permutation{\n    int a[10];\n}per;\nint percnt;\nvector<permutation> P;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=n;i++)if(out_time[i]<=out_time[i-1]) return false;\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<n;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=m;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n            if(!ok) return false;\n            if(mp.count(tmpD)) return false;\n            mp[tmpD]++;\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=n;i++) tmpans=max(tmpans,out_time[i]+(LL)dist*S[i]);\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\" : tmpans = %lld\\n\",tmpans);\n    ans=min(ans,tmpans);\n}\n\nint mark[MAXN];\nvoid DFS1(int cur){\n    if(cur>n){\n        per.a[0]=1;\n        P.push_back(per);\n        return;\n    }\n    for(int i=2;i<=n;i++)if(!mark[i]){\n        per.a[++percnt]=i;\n        mark[i]=1;\n        DFS1(cur+1);\n        percnt--;\n        mark[i]=0;\n    }\n}\n\nvoid DFS2(int curid,permutation now){\n    if(curid>=n){\n        update();\n        return;\n    }\n    int cur=now.a[curid];\n    for(int t=0;t<curid;t++){\n        int pre=now.a[t];\n        if(cur<pre){\n            out_time[cur]=out_time[pre]-1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=m;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n                DFS2(curid+1,now);\n            }\n            LL dt=dist;\n            while(S[cur]>S[pre]&&out_time[pre]-dt*(S[cur]-S[pre])>0){\n                out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n                DFS2(curid+1,now);\n            }\n        }\n        if(cur>pre){\n            out_time[cur]=out_time[pre]+1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=m;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n                DFS2(curid+1,now);\n            }\n            LL dt=dist;\n            while(dt<=dist+100){\n                out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n                DFS2(curid+1,now);\n\n            }\n        }\n\n    }\n}\n\nvoid solve(){\n    out_time[1]=0LL;\n    for(int perid=0;perid<P.size();perid++){\n        permutation now=P[perid];\n        DFS2(1,now);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++) scanf(\"%d\",&D[i]);\n    ans=(LL)INF*INF;\n    out_time[1]=0;\n    DFS1(2);\n//    printf(\"Pcnt = %d\\n\",P.size());\n//    for(int i=0;i<P.size();i++){\n//        for(int k=1;k<=n-1;k++) printf(\"%d \",P[i].a[k]);\n//        printf(\"\\n\");\n//    }\n    solve();\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n \ntypedef long long ll;\n \nconst ll inf = (ll)1e15;\n \nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n \ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n    if(dif[i][k]!=inf && dif[k][j]!=inf && i!=j)\n      dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n \n \nll rec(vector<int> v, int depth){\n  if(depth == m){\n    ll tmp[9][9];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)tmp[i][j] = dif[i][j];\n \n    wf();\n \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n    if(tmp[i][j]!=inf && dif[i][j] != tmp[i][j])return inf;\n    if(i<j && dif[i][j]<=0)return inf;\n      }\n    /*\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)dif[i][j] = tmp[i][j];\n     \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++)\n      if(dif[i][k]!=inf && dif[k][j]!=inf)\n        dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n    */\n \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n    if(v[i]<v[j]){\n      if(s[v[i]] < s[v[j]])continue;\n      if(dif[v[i]][v[j]] == inf)continue;\n      if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n      if(dif[v[i]][v[j]]<=0)continue;\n      return inf;\n    }else{\n      bool f = false;\n      for(int k=0;k<m;k++){\n        f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n      }\n      if(!f)return inf;\n    }\n      }\n    }\n \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n \n    for(int i=0;i<n;i++){\n      if(!i){\n    start[i] = 0;\n    goal[i] = s[i]*dist;\n      }else{\n    if(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n    else start[i] = start[i-1] + 1;\n    goal[i] = start[i] + s[i]*dist;\n    for(int j=0;j<i;j++){\n      if(pos[j]<pos[i] && goal[j]>goal[i]){\n        start[i] += goal[j]-goal[i];\n        goal[i] = goal[j];\n      }\n    }\n    for(int j=0;j<i;j++){\n      if(dif[j][i] != inf){\n        start[j] = start[i] - dif[j][i];\n        goal[j] = start[j] + s[j]*dist;\n      }\n    }\n      }\n      /*\n      for(int j=0;j<=i;j++){\n    cout << start[j] << \" \" << goal[j] << endl;\n      }\n      cout << \"----------------------\" << endl;\n      */\n    }\n     \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl;\n \n    cout << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n   \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n \n  res = min(res,rec(v,depth+1));\n \n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n    for(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n  \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      //if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      //wf();\n      swap(v[i],v[i+1]);\n       \n      res = min(res,rec(v,depth+1));\n       \n      for(int j=i+2;j<n-1;j++){\n    if(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n      for(int x=0;x<n;x++)\n        for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n       \n      ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n      //if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n      dif[v[j]][v[j+1]] = t2; dif[v[j+1]][v[j]] = -t2;\n      //wf();\n      swap(v[j],v[j+1]);\n       \n      res = min(res,rec(v,depth+1));\n       \n      swap(v[j],v[j+1]);\n      for(int x=0;x<n;x++)\n        for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n    }\n    swap(v[i],v[i+1]);\n      }\n      for(int x=0;x<n;x++)\n    for(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n \nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n \n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst ll INF = 1000000000000000000ll;\n\nll dist;\nint n, m;\nvector<ll> S, D;\n\nbool check(int a, ll t, const vector<int> &order, vector<int> &used, const vector<ll> &stime){\n\tbool valid = true;\n\tfor(int i = 0; valid && i < a; ++i){\n\t\tll g0 = stime[order[i]] + S[order[i]] * dist;\n\t\tll g1 = t + S[order[a]] * dist;\n\t\tbool crossing = false;\n\t\tif(order[i] < order[a]){\n\t\t\tif(stime[order[i]] >= t){ valid = false; }\n\t\t\tif(g0 > g1){ crossing = true; }\n\t\t}else{\n\t\t\tif(stime[order[i]] <= t){ valid = false; }\n\t\t\tif(g0 < g1){ crossing = true; }\n\t\t}\n\t\tif(crossing){\n\t\t\tint pos = -1;\n\t\t\tfor(int j = 0; pos < 0 && j < m; ++j){\n\t\t\t\tif(used[order[i]] & (1 << j)){ continue; }\n\t\t\t\tll ta = D[j] * S[order[i]] + stime[order[i]];\n\t\t\t\tll tb = D[j] * S[order[a]] + t;\n\t\t\t\tif(ta == tb){ pos = j; }\n\t\t\t}\n\t\t\tif(pos < 0){\n\t\t\t\tvalid = false;\n\t\t\t}else{\n\t\t\t\tused[order[i]] |= (1 << pos);\n\t\t\t\tused[order[a]] |= (1 << pos);\n\t\t\t}\n\t\t}\n\t}\n\treturn valid;\n}\n\nll solve(int a, const vector<int> &order, const vector<int> &used, vector<ll> &stime){\n\tif(a == 0){\n\t\tint index = order[a];\n\t\tvector<int> next_used(used);\n\t\tvector<ll> next_stime(stime);\n\t\tnext_stime[index] = 0;\n\t\treturn solve(1, order, next_used, next_stime);\n\t}else if(a == n){\n\t\tll start = INF, goal = -INF;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstart = min(start, stime[i]);\n\t\t\tgoal = max(goal, stime[i] + S[i] * dist);\n\t\t}\n\t\treturn goal - start;\n\t}else{\n\t\tll result = INF;\n\t\tint index = order[a];\n\t\tfor(int i = 0; i < a; ++i){\n\t\t\tint c = order[i];\n\t\t\tfor(int j = 0; j <= m; ++j){\n\t\t\t\tif(used[c] & (1 << j)){ continue; }\n\t\t\t\tll d = (j == m ? dist : D[j]);\n\t\t\t\tll t = d * S[c] + stime[c] - d * S[index];\n\t\t\t\tvector<int> next_used(used);\n\t\t\t\tif(!check(a, t, order, next_used, stime)){ continue; }\n\t\t\t\tstime[order[a]] = t;\n\t\t\t\tresult = min(solve(a + 1, order, next_used, stime), result);\n\t\t\t}\n\t\t}\n\t\tll t = -INF;\n\t\tfor(int i = 0; i < a; ++i){\n\t\t\tif(order[i] < order[a]){\n\t\t\t\tt = max(t, order[a] - order[i] + stime[order[i]]);\n\t\t\t}\n\t\t}\n\t\tvector<int> next_used(used);\n\t\tif(check(a, t, order, next_used, stime)){\n\t\t\tstime[order[a]] = t;\n\t\t\tresult = min(solve(a + 1, order, next_used, stime), result);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\tfor(int i = 0; i < n; ++i){ cin >> S[i]; }\n\tcin >> m;\n\tD.resize(m);\n\tfor(int i = 0; i < m; ++i){ cin >> D[i]; }\n\tvector<int> order(n);\n\tfor(int i = 0; i < n; ++i){ order[i] = i; }\n\tll answer = INF;\n\tdo {\n\t\tvector<int> used(n);\n\t\tvector<ll> stime(n);\n\t\tanswer = min(answer, solve(0, order, used, stime));\n\t} while(!next_permutation(order.begin(), order.end()));\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, D, intr;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\t\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tp[i] = i;\n\t}\n\n\tvector<vector<int> > odr(m + 1);\n\todr[0].resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\n\tint cnt = 0;\n\tfor(int j = 1; j <= m; ++j){\n\t\todr[j] = odr[j - 1];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j-1] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i+1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j][i], odr[j][i+1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] >= 0) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] == -1LL && stm[b] != -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[j] * (S[b] - S[a]);\n\t\t\t\t\t\tif(stm[a] >= stm[b]) while(1);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] != -1LL && stm[b] == -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[j] * (S[a] - S[b]);\n\t\t\t\t\t\tif(stm[a] >= stm[b]) throw 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] >= 0LL; ++j)\n\t\tfor(int k = j + 1; stm[k] >= 0LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\n\tif(cnt != 0) return;\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr = D;\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\nstruct UnionFind {\n    vector<int> data; int group;\n    UnionFind(int N) : data(N, -1), group(N) {}\n    void init(int N) {\n        data.assign(N, -1);\n        group = N;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            --group;\n        }\n    }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]);}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm; // ??´??????????????????\n        vector<vector<int>> adj_mat;\n        // adj_mat[i][j] := if i??¨j????????§???????????????????????? then ??????????????´???????????? else -1\n        State(int n) : perm(n), adj_mat(n, vector<int>(n, -1)) {\n            iota(perm.begin(), perm.end(), 0);\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    vector<State> cur_states = { State(n)};\n    for (int hiroi_id : in(m)) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    if (speed_rev[s.perm[i]] <= speed_rev[s.perm[i + 1]]) {\n                        ok = false;\n                        break;\n                    };\n                    // now_dist * spr1 = now_dist * spr2 + jikan_sa\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = hiroi_id;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = hiroi_id;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    i64 ans = goal_dist * 1000ll;\n    for (const auto& state : cur_states) {\n        UnionFind uf(n);\n        for (int i : in(n))\n            for (int j : in(i))\n                if (state.adj_mat[i][j] != -1)\n                    uf.unite(i, j);\n        vector<i64> start_time;\n        bool is_valid = [&]() {\n            Bs done(0);\n            for (int i : in(n)) {\n                if (done[i] == true) continue;\n                int gsize = [&]() {\n                    int res = 0;\n                    for (int j : in(i, n)) {\n                        if (uf.same(i, j)) {\n                            ++res;\n                            done[j] = true;\n                        }\n                    }\n                    return res;\n                }();\n                // ?????????????????????????????§????????????????¬?????????????????±???????\n                start_time.emplace_back(0); // ??¨????????????0???????????????????????§?????£??????\n                for (int j : in(i + 1, gsize + i)) {\n                    i64 stime_tmp = start_time.back() + 1;\n                    bool time_lock = false;\n                    for (int k : in(i, j)) {\n                        if (state.adj_mat[j][k] == -1) continue;\n                        int pass_id = state.adj_mat[j][k];\n                        i64 cand_time = start_time[k] + hiroi[pass_id] * (speed_rev[k] - speed_rev[j]);\n                        if (time_lock && stime_tmp != cand_time) return false;\n                        time_lock = true;\n                        stime_tmp = cand_time;\n                    }\n                    start_time.emplace_back(stime_tmp);\n                }\n                for (int j : in(i + 1, gsize + i))\n                    if (start_time[j - 1] >= start_time[j])\n                        return false;\n                // ????§???????????????´??????\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need - start_time[j]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] += offset;\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll INF = LLONG_MAX/3;\n\nll dist;\nint n,m;\nll s[5],d[5];\n\nll ans = INF;\n\nusing P = pair<ll,ll>;\nusing D = pair<ll,P>;\n\nvector<P> v[5];\nll t[5];\nvoid dfs(int mask){\n    if(mask == (1<<n)-1){\n        bool ok = true;\n\n        // printf(\"CHECK: t : \");\n        // rep(i,n) printf(\" %lld\", t[i]);\n        // printf(\"\\n\");\n\n        rep(i,n-1)if(t[i]>=t[i+1]) return;\n\n        vector< vector<D> > pass_b(m+1),pass_a(m+1);\n\n        rep(i,n){\n            rep(j,m){\n                pass_b[j].pb({ t[i]+d[j]*s[i],{-s[i],i} });\n                pass_a[j].pb({ t[i]+d[j]*s[i],{s[i],i} });\n            }\n            pass_b[m].pb({ t[i]+dist*s[i],{-s[i],i} });\n            pass_a[m].pb({ t[i]+dist*s[i],{s[i],i} });\n        }\n\n        rep(j,m+1){\n            sort(all(pass_b[j]));\n            sort(all(pass_a[j]));\n        }\n\n        vector<int> now(n);\n        rep(i,n) now[i] = i;\n\n        rep(j,m+1){\n            // dbg(pass_b[j]);\n            if(j<m){\n                // 「ゴール地点は十分に広いため、何台の馬車が同時に到着しても構いません。」\n                map<ll,int> ct;\n                rep(k,n) ct[pass_b[j][k].fi]++;\n                for(const auto &p:ct){\n                    // 「\"すこしひろいところ\"がm箇所あり、そこでのみ2台まで並ぶことができ、ある馬車が別の馬車を追い抜くことが可能」\n                    if(p.se>=3) ok = false;\n                }\n                if(!ok) break;\n            }\n\n            rep(k,n){\n                int idx = pass_b[j][k].se.se;\n                if(now[k] != idx) ok = false;\n            }\n            if(!ok) break;\n            rep(k,n){\n                int idx = pass_a[j][k].se.se;\n                now[k] = idx;\n            }\n        }\n\n        if(ok){\n            ll tmp = 0;\n            rep(i,n) tmp = max(tmp, t[i]+dist*s[i]);\n            // printf(\" !!OK : time %lld\\n\",tmp);\n            ans = min(ans, tmp);\n        }\n        return;\n    }\n\n    for(int i=1; i<n; ++i)if(!(mask>>i&1)){\n        for(const auto &p:v[i])if(mask>>p.fi&1){\n            t[i] = t[p.fi] + p.se;\n            dfs(mask|(1<<i));\n            t[i] = -1;\n        }\n    }\n}\n\nint main(){\n    cin >>dist;\n    cin >>n;\n    rep(i,n) cin >>s[i];\n    cin >>m;\n    rep(i,m) cin >>d[i];\n    sort(d,d+m);\n\n    for(int i=1; i<n; ++i){\n        rep(j,i){\n            if(s[j] <= s[i]){\n                v[i].pb({j, i-j});\n            }\n            else{\n                ll S = s[j]-s[i];\n                rep(k,m) v[i].pb({j,S*d[k]});\n                v[i].pb({j,S*dist});\n            }\n        }\n        for(int j=i+1; j<n; ++j){\n            if(s[i] <= s[j]){\n                v[i].pb({j, i-j});\n            }\n            else{\n                ll S = s[i]-s[j];\n                rep(k,m) v[i].pb({j,-S*d[k]});\n                v[i].pb({j,-S*dist});\n            }\n        }\n\n        // dbg(v[i]);\n    }\n\n    rep(i,n) t[i] = -1;\n    t[0] = 0;\n    dfs(1);\n\n    assert(ans<INF);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint n,m;\nint S[MAXN];\nint D[MAXN];\nint OK[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,int> mp;\nstruct permutation{\n    int a[10];\n}per;\nint percnt;\nvector<permutation> P;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=n;i++)if(out_time[i]<=out_time[i-1]) return false;\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<n;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=m;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n            if(!ok) return false;\n            if(mp.count(tmpD)) return false;\n            mp[tmpD]++;\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=n;i++) tmpans=max(tmpans,out_time[i]+(LL)dist*S[i]);\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\" : tmpans = %lld\\n\",tmpans);\n    ans=min(ans,tmpans);\n}\n\nint mark[MAXN];\nvoid DFS1(int cur){\n    if(cur>n){\n        per.a[0]=1;\n        P.push_back(per);\n        return;\n    }\n    for(int i=2;i<=n;i++)if(!mark[i]){\n        per.a[++percnt]=i;\n        mark[i]=1;\n        DFS1(cur+1);\n        percnt--;\n        mark[i]=0;\n    }\n}\n\nvoid DFS2(int curid,permutation now){\n    if(curid>=n){\n        update();\n        return;\n    }\n    int cur=now.a[curid];\n    for(int t=0;t<curid;t++){\n        int pre=now.a[t];\n        if(cur<pre){\n            out_time[cur]=out_time[pre]-1;\n            DFS2(curid+1,now);\n    //        if(S[cur]<=S[pre]) return;\n            for(int i=1;i<=m+1;i++){\n                LL dt=(i==m+1) ? dist : D[i];\n                out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n                DFS2(curid+1,now);\n            }\n        }\n        if(cur>pre){\n            out_time[cur]=out_time[pre]+1;\n            DFS2(curid+1,now);\n    //        if(S[cur]>=S[pre]) return;\n            for(int i=1;i<=m+1;i++){\n                LL dt=(i==m+1) ? dist : D[i];\n                out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n                DFS2(curid+1,now);\n            }\n        }\n\n    }\n}\n\nvoid solve(){\n    out_time[1]=0LL;\n    for(int perid=0;perid<P.size();perid++){\n        permutation now=P[perid];\n        DFS2(1,now);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++) scanf(\"%d\",&D[i]);\n    for(int j=2;j<=n;j++){\n        int ok=1;\n        for(int i=1;i<j;i++) if(S[i]>S[j]) ok=0;\n        for(int k=j+1;k<=n;k++) if(S[j]>S[k]) ok=0;\n        OK[j]=ok;\n    }\n    ans=(LL)INF*INF;\n    out_time[1]=0;\n    DFS1(2);\n//    printf(\"Pcnt = %d\\n\",P.size());\n//    for(int i=0;i<P.size();i++){\n//        for(int k=1;k<=n-1;k++) printf(\"%d \",P[i].a[k]);\n//        printf(\"\\n\");\n//    }\n    solve();\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<hamakou.h>\nint main(){\n  return \"意味がわからん\";\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\nstruct UnionFind {\n    vector<int> data; int group;\n    UnionFind(int N) : data(N, -1), group(N) {}\n    void init(int N) {\n        data.assign(N, -1);\n        group = N;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            --group;\n        }\n    }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]);}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm; // ??´??????????????????\n        vector<vector<int>> adj_mat;\n        // adj_mat[i][j] := if i??¨j????????§???????????????????????? then ??????????????´???????????? else -1\n        State(int n) : perm(n), adj_mat(n, vector<int>(n, -1)) {\n            iota(perm.begin(), perm.end(), 0);\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    vector<State> cur_states = { State(n)};\n    for (int hiroi_id : in(m)) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    if (speed_rev[s.perm[i]] <= speed_rev[s.perm[i + 1]]) {\n                        ok = false;\n                        break;\n                    };\n                    // now_dist * spr1 = now_dist * spr2 + jikan_sa\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = hiroi_id;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = hiroi_id;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    i64 ans = goal_dist * 150ll;\n    for (const auto& state : cur_states) {\n        UnionFind uf(n);\n        for (int i : in(n))\n            for (int j : in(i))\n                if (state.adj_mat[i][j] != -1)\n                    uf.unite(i, j);\n        vector<i64> start_time;\n        bool is_valid = [&]() {\n            Bs done(0);\n            for (int i : in(n)) {\n                if (done[i] == true) continue;\n                int gsize = [&]() {\n                    int res = 0;\n                    for (int j : in(i, n)) {\n                        if (uf.same(i, j)) {\n                            ++res;\n                            done[j] = true;\n                        }\n                    }\n                    return res;\n                }();\n                // ?????????????????????????????§????????????????¬?????????????????±???????\n                start_time.emplace_back(0); // ??¨????????????0???????????????????????§?????£??????\n                for (int j : in(i + 1, gsize + i)) {\n                    i64 stime_tmp = start_time.back() + 1;\n                    bool time_lock = false;\n                    for (int k : in(i, j)) {\n                        if (state.adj_mat[j][k] == -1) continue;\n                        int pass_id = state.adj_mat[j][k];\n                        i64 cand_time = start_time[k] + hiroi[pass_id] * (speed_rev[k] - speed_rev[j]);\n                        if (time_lock && stime_tmp != cand_time) return false;\n                        time_lock = true;\n                        stime_tmp = cand_time;\n                    }\n                    start_time.emplace_back(stime_tmp);\n                }\n                // ????§???????????????´??????\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need - start_time[j]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] += offset;\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        // print_vec(start_time);\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, D, intr;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\t\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tp[i] = i;\n\t}\n\n\tvector<vector<int> > odr(m + 1);\n\todr[0].resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\n\tint cnt = 0;\n\tfor(int j = 1; j <= m; ++j){\n\t\todr[j] = odr[j - 1];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j-1] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i+1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j][i], odr[j][i+1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] >= 0) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] == -1LL && stm[b] != -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[j] * (S[b] - S[a]);\n\t\t\t\t\t\tif(stm[a] >= stm[b]) return;\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] != -1LL && stm[b] == -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[j] * (S[a] - S[b]);\n\t\t\t\t\t\tif(stm[a] >= stm[b]) return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] >= 0LL; ++j)\n\t\tfor(int k = j + 1; stm[k] >= 0LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\n\tif(cnt != 0) return;\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr = D;\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint M,N;\nint S[MAXN];\nint D[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,set<int> > mp;\nstruct permutation{\n    int a[10];\n}per;\nint percnt;\nvector<permutation> P;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=N;i++)if(out_time[i]<=out_time[i-1]) return false;\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    for(int i=1;i<N;i++){\n        for(int j=i+1;j<=N;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=M;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n//            printf(\"ok = %d! , tmpD = %-12d , i = %d , j = %d\\n\",ok,tmpD,i,j);\n            if(!ok) return false;\n            if(mp.count(tmpD)){\n                if(mp[tmpD].count(i)) return false;\n                if(mp[tmpD].count(j)) return false;\n            }\n            mp[tmpD].insert(i);\n            mp[tmpD].insert(j);\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    for(int i=N;i>=1;i--) out_time[i]-=out_time[1];\n//    for(int i=1;i<N;i++)if(out_time[i]>=out_time[i+1]) return;\n//    for(int i=1;i<=N;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=N;i++){\n        LL tmp=out_time[i]+(LL)dist*S[i];\n        tmpans=max(tmpans,tmp);\n    }\n//    if(tmpans==6577480535){\n//        for(int i=1;i<=N;i++) printf(\"%lld \",out_time[i]);\n//        printf(\"\\n\");\n//        if(is_judge()) printf(\"true!\\n\");\n//        else printf(\"false!\\n\");\n//        exit(0xff);\n//    }\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\" : tmpans = %lld\\n\",tmpans);\n    ans=min(ans,tmpans);\n}\n\nint mark[MAXN];\nvoid DFS1(int cur){\n    if(cur>N){\n        per.a[0]=1;\n        P.push_back(per);\n        return;\n    }\n    for(int i=1;i<=N;i++)if(!mark[i]){\n        per.a[++percnt]=i;\n        mark[i]=1;\n        DFS1(cur+1);\n        percnt--;\n        mark[i]=0;\n    }\n}\n\nvoid DFS2(int curid,const permutation& now){\n    if(curid>N){\n        update();\n        return;\n    }\n    int cur=now.a[curid];\n    if(curid==1){\n        out_time[cur]=0;\n        DFS2(curid+1,now);\n        return;\n    }\n\n    for(int t=1;t<curid;t++){\n        int pre=now.a[t];\n        if(cur<pre){\n            out_time[cur]=out_time[pre]-1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=M;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n    //            printf(\"%d-%d : %lld->%lld\\n\",pre,cur,out_time[pre],out_time[cur]);\n                DFS2(curid+1,now);\n            }\n        }\n        if(cur>pre){\n            out_time[cur]=out_time[pre]+1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=M;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n    //            printf(\"%d-%d : %lld->%lld\\n\",pre,cur,out_time[pre],out_time[cur]);\n                DFS2(curid+1,now);\n            }\n        }\n    }\n}\n\nvoid solve(){\n    for(int perid=0;perid<P.size();perid++){\n        DFS2(1,P[perid]);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&N);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&M);\n    for(int i=1;i<=M;i++) scanf(\"%d\",&D[i]);\n    D[++M]=dist;\n    ans=(LL)INF*INF;\n    DFS1(1);\n//    printf(\"Pcnt = %d\\n\",P.size());\n//    for(int i=0;i<P.size();i++){\n//        for(int k=1;k<=N;k++) printf(\"%d \",P[i].a[k]);\n//        printf(\"\\n\");\n//    }\n    solve();\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n/*\ninput\n60516263\n5\n45\n16\n94\n71\n91\n4\n20586550\n54017689\n36941264\n49153094\n\noutput\n6577480535\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<long long int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[uf.root(i).first] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taa afrom(prev(it)->second);\n\t\t\taa ato(it->second);\n\n\t\t\tif (afrom.lasfintime - afrom.lasstatime>ato.fstfintime-ato.fststatime) {\n\t\t\t\tuf.unionSet(afrom.lasfinid, ato.fstfinid, times[afrom.lasfinid][M] - times[ato.fstfinid][M]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf.unionSet(afrom.lasstaid, ato.fststaid, 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < HorseNum - 1; ++i) {\n\t\tif (uf.root(i).second >= uf.root(i + 1).second)return My_LInf;\n\t}\n\tfor (int i = 0; i < HorseNum - 1; ++i) {\n\t\tif (uf.root(seq[i]).second+times[seq[i]][M] > uf.root(seq[i + 1]).second + times[seq[i+1]][M])return My_LInf;\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tsort(ds.begin(), ds.end());\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tif (a < ans) {\n\t\t\tans = a;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 5\n\nstruct Info{\n\tvoid set(int arg_loc,int arg_overtake_time){\n\t\tloc = arg_loc;\n\t\tovertake_time = arg_overtake_time;\n\t}\n\tll loc,overtake_time,debug_start_time;\n};\n\nstruct LOC{\n\tll num_overtake,table[NUM];\n};\n\nint N,M;\nll DIST;\nll speed[NUM],loc[NUM],start_time[NUM];\nbool decided[NUM];\nInfo info[NUM][NUM]; //info[抜く方][抜かれる方] = 場所と時間\nLOC loc_table[NUM];\nll ans;\n\nll goal_time(int car_id){\n\n\treturn start_time[car_id]+DIST*speed[car_id];\n}\n\n\nbool is_ok(){\n\n\t//矛盾チェック\n\n\t//出発時刻が昇順か\n\tint pre_time = -1;\n\tfor(int i = 0; i < N; i++){\n\t\tif(decided[i] == false)continue;\n\n\t\tpre_time = start_time[i];\n\t}\n\n\t//「少し広いところ」以外での追い抜きが発生していないか\n\tfor(int i = 0; i < N-1; i++){ //抜かれる側\n\t\tif(!decided[i])continue;\n\t\tfor(int k = i+1; k < N; k++){ //抜く側\n\t\t\tif(!decided[k])continue;\n\n\t\t\tif(goal_time(i) > goal_time(k)){\n\t\t\t\tif(info[k][i].loc == -1){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(info[k][i].overtake_time != start_time[k]+loc[info[k][i].loc]*speed[k]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//追い抜き時刻は競合しないか\n\tfor(int i = 0; i < M; i++){\n\t\tif(loc_table[i].num_overtake <= 1)continue;\n\n\t\tfor(int a = 0; a < loc_table[i].num_overtake-1; a++){\n\t\t\tfor(int b = 0; b < loc_table[i].num_overtake; b++){\n\t\t\t\tif(loc_table[i].table[a] == loc_table[i].table[b]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\n//n*nの表を順に埋めていくイメージ\nvoid recursive(vector<int> V,int from_index,int to_car_id,ll max_goal_time){\n\n\tif(max_goal_time >= ans)return;\n\n\t//n*nの表を埋め終わった場合\n\tif(from_index == N-1){ //★★0を抜いているため1つ少ない★★\n\n\t\tif(is_ok()){\n\n\t\t\tans = min(ans,max_goal_time);\n\t\t}\n\t\treturn;\n\t}\n\n\tint from_car_id = V[from_index];\n\n\tif(from_car_id == to_car_id || decided[to_car_id] == false){\n\n\t\tif(to_car_id == N-1){\n\n\t\t\tif(start_time[from_car_id] == -1){ //出発時刻未定である場合\n\n\t\t\t\tll max_start_time = 0,max_id,tmp_start_time,tmp_time;\n\n\t\t\t\tfor(int i = 0; i < from_car_id; i++){\n\t\t\t\t\tif(!decided[i])continue;\n\n\t\t\t\t\t//出発時刻は昇順になっているはず\n\t\t\t\t\tmax_start_time = start_time[i];\n\t\t\t\t\tmax_id = i;\n\t\t\t\t}\n\n\t\t\t\ttmp_start_time = max_start_time+(from_car_id-max_id); //仮の最速出発時刻\n\n\t\t\t\tstart_time[from_car_id] = tmp_start_time;\n\t\t\t}\n\n\t\t\tdecided[from_car_id] = true;\n\t\t\trecursive(V,from_index+1,0,max(max_goal_time,goal_time(from_car_id)));\n\t\t\tdecided[from_car_id] = false;\n\t\t\tstart_time[from_car_id] = -1;\n\n\t\t}else{\n\n\t\t\trecursive(V,from_index,to_car_id+1,max_goal_time);\n\t\t}\n\t}\n\n\n\tll to_goal_time = goal_time(to_car_id);\n\tll max_start_time = 0,max_id = -1,tmp_start_time,tmp_time;\n\n\tif(start_time[from_car_id] == -1){ //出発時刻未定\n\n\t\tfor(int i = 0; i < from_car_id; i++){\n\t\t\tif(!decided[i])continue;\n\n\t\t\t//出発時刻は昇順になっているはず\n\t\t\tmax_start_time = start_time[i];\n\t\t\tmax_id = i;\n\t\t}\n\n\t\ttmp_start_time = max_start_time+(from_car_id-max_id); //仮の最速出発時刻\n\n\t\tif(to_car_id < from_car_id && to_goal_time > tmp_start_time+DIST*speed[from_car_id]){ //仮の最速出発時刻で出発したら、抜いてしまう場合\n\n\t\t\t//抜かない場合:同時にゴールするようにする\n\t\t\tstart_time[from_car_id] = to_goal_time-(DIST*speed[from_car_id]);\n\n\t\t\tif(is_ok()){\n\t\t\t\tif(to_car_id == N-1){\n\n\t\t\t\t\tdecided[from_car_id] = true;\n\t\t\t\t\trecursive(V,from_index+1,0,max_goal_time);\n\t\t\t\t\tdecided[from_car_id] = false;\n\n\t\t\t\t}else{\n\n\t\t\t\t\trecursive(V,from_index,to_car_id+1,max_goal_time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart_time[from_car_id] = -1;\n\n\n\t\t\t//抜く場合:抜く場所を全探索\n\t\t\tfor(int k = 0; k < M; k++){\n\n\t\t\t\ttmp_time = start_time[to_car_id]+loc[k]*speed[to_car_id]; //抜く対象の馬車が、場所kに着く時刻\n\t\t\t\tif(tmp_start_time+loc[k]*speed[from_car_id] > tmp_time)continue; //最速で出発しても、抜く対象の馬車に追いつけない場合\n\n\t\t\t\tstart_time[from_car_id] = tmp_time-(loc[k]*speed[from_car_id]);\n\n\t\t\t\tloc_table[k].table[loc_table[k].num_overtake] = tmp_time;\n\t\t\t\tloc_table[k].num_overtake++;\n\t\t\t\tinfo[from_car_id][to_car_id].overtake_time = tmp_time;\n\t\t\t\tinfo[from_car_id][to_car_id].debug_start_time = start_time[from_car_id];\n\t\t\t\tinfo[from_car_id][to_car_id].loc = k;\n\n\t\t\t\tif(is_ok()){ //矛盾が生じない場合のみ再帰\n\t\t\t\t\tif(to_car_id == N-1){\n\n\t\t\t\t\t\tdecided[from_car_id] = true;\n\t\t\t\t\t\trecursive(V,from_index+1,0,max_goal_time);\n\t\t\t\t\t\tdecided[from_car_id] = false;\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\trecursive(V,from_index,to_car_id+1,max_goal_time);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tloc_table[k].num_overtake--;\n\t\t\t\tstart_time[from_car_id] = -1;\n\t\t\t\tinfo[from_car_id][to_car_id].overtake_time = -1;\n\t\t\t\tinfo[from_car_id][to_car_id].loc = -1;\n\t\t\t}\n\n\t\t}else if(to_car_id > from_car_id && to_goal_time < tmp_start_time+DIST*speed[from_car_id]){ //抜かれてしまう場合\n\n\t\t\t//抜かれる場所を全探索\n\t\t\tfor(int k = 0; k < M; k++){\n\n\t\t\t\ttmp_time = start_time[to_car_id]+loc[k]*speed[to_car_id]; //抜かれる対象の馬車が、場所kに着く時刻\n\t\t\t\tif(tmp_start_time+DIST*speed[from_car_id] > tmp_time)continue; //最速で出発しても、場所kにtmp_time以前に着けないならcontinue\n\n\t\t\t\tstart_time[from_car_id] = tmp_time-(DIST*speed[from_car_id]);\n\n\t\t\t\tloc_table[k].table[loc_table[k].num_overtake] = tmp_time;\n\t\t\t\tloc_table[k].num_overtake++;\n\t\t\t\tinfo[to_car_id][from_car_id].overtake_time = tmp_time;\n\t\t\t\tinfo[to_car_id][from_car_id].loc = k;\n\n\t\t\t\tif(is_ok()){ //矛盾が生じない場合のみ再帰\n\t\t\t\t\tif(to_car_id == N-1){\n\n\t\t\t\t\t\tdecided[from_car_id] = true;\n\t\t\t\t\t\trecursive(V,from_index+1,0,max(max_goal_time,goal_time(from_car_id)));\n\t\t\t\t\t\tdecided[from_car_id] = false;\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\trecursive(V,from_index,to_car_id+1,max_goal_time);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tloc_table[k].num_overtake--;\n\t\t\t\tstart_time[from_car_id] = -1;\n\t\t\t\tinfo[to_car_id][from_car_id].overtake_time = -1;\n\t\t\t\tinfo[to_car_id][from_car_id].loc = -1;\n\t\t\t}\n\n\n\t\t}else{ //接触がない場合\n\n\t\t\tif((to_car_id == N-1) || (from_car_id == N-1 && to_car_id == N-2)){ //何かしらの値を設定する必要あり\n\n\t\t\t\tstart_time[from_car_id] = tmp_start_time; //制約がないなら最速にする\n\t\t\t\tif(is_ok()){\n\t\t\t\t\tif(to_car_id == N-1){\n\n\t\t\t\t\t\tdecided[from_car_id] = true;\n\t\t\t\t\t\trecursive(V,from_index+1,0,max(max_goal_time,goal_time(from_car_id)));\n\t\t\t\t\t\tdecided[from_car_id] = false;\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\trecursive(V,from_index,to_car_id+1,max_goal_time);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart_time[from_car_id] = -1;\n\n\t\t\t}else{ //出発時刻の決定を保留\n\n\t\t\t\trecursive(V,from_index,to_car_id+1,max_goal_time);\n\t\t\t}\n\t\t}\n\n\t}else{ //出発時刻決定済\n\n\t\tif(to_car_id < from_car_id && to_goal_time > start_time[from_car_id]+DIST*speed[from_car_id]){ //仮の最速出発時刻で出発したら、抜いてしまう場合\n\n\t\t\t//抜く場合:抜く場所を全探索\n\t\t\tfor(int k = 0; k < M; k++){\n\n\t\t\t\ttmp_time = start_time[to_car_id]+loc[k]*speed[to_car_id]; //抜く対象の馬車が、場所kに着く時刻\n\n\t\t\t\tif(start_time[from_car_id] == tmp_time-(loc[k]*speed[from_car_id])){ //ぴったり抜ける場合\n\n\t\t\t\t\tloc_table[k].table[loc_table[k].num_overtake] = tmp_time;\n\t\t\t\t\tloc_table[k].num_overtake++;\n\t\t\t\t\tinfo[from_car_id][to_car_id].overtake_time = tmp_time;\n\t\t\t\t\tinfo[from_car_id][to_car_id].loc = k;\n\n\t\t\t\t\tif(is_ok()){ //矛盾が生じない場合のみ再帰\n\t\t\t\t\t\tif(to_car_id == N-1){\n\n\t\t\t\t\t\t\tdecided[from_car_id] = true;\n\t\t\t\t\t\t\trecursive(V,from_index+1,0,max_goal_time);\n\t\t\t\t\t\t\tdecided[from_car_id] = false;\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\trecursive(V,from_index,to_car_id+1,max_goal_time);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tloc_table[k].num_overtake--;\n\t\t\t\t\tinfo[from_car_id][to_car_id].overtake_time = -1;\n\t\t\t\t\tinfo[from_car_id][to_car_id].loc = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else if(to_car_id > from_car_id && to_goal_time < start_time[from_car_id]+DIST*speed[from_car_id]){ //抜かれてしまう場合\n\n\t\t\t//抜かれる場所を全探索\n\t\t\tfor(int k = 0; k < M; k++){\n\n\t\t\t\ttmp_time = start_time[to_car_id]+loc[k]*speed[to_car_id]; //抜かれる対象の馬車が、場所kに着く時刻\n\n\t\t\t\t\tif(start_time[from_car_id] == tmp_time-(DIST*speed[from_car_id])){ //ぴったり抜かれる場合\n\n\t\t\t\t\t\tloc_table[k].table[loc_table[k].num_overtake] = tmp_time;\n\t\t\t\t\t\tloc_table[k].num_overtake++;\n\t\t\t\t\t\tinfo[to_car_id][from_car_id].overtake_time = tmp_time;\n\t\t\t\t\t\tinfo[to_car_id][from_car_id].loc = k;\n\n\t\t\t\t\t\tif(is_ok()){ //矛盾が生じない場合のみ再帰\n\t\t\t\t\t\t\tif(to_car_id == N-1){\n\n\t\t\t\t\t\t\t\tdecided[from_car_id] = true;\n\t\t\t\t\t\t\t\trecursive(V,from_index+1,0,max_goal_time);\n\t\t\t\t\t\t\t\tdecided[from_car_id] = false;\n\n\t\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\trecursive(V,from_index,to_car_id+1,max_goal_time);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloc_table[k].num_overtake--;\n\t\t\t\t\t\tinfo[to_car_id][from_car_id].overtake_time = -1;\n\t\t\t\t\t\tinfo[to_car_id][from_car_id].loc = -1;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}else{ //接触がない場合\n\n\t\t\tif(to_car_id == N-1){\n\n\t\t\t\tdecided[from_car_id] = true;\n\t\t\t\trecursive(V,from_index+1,0,max(max_goal_time,goal_time(from_car_id)));\n\t\t\t\tdecided[from_car_id] = false;\n\n\t\t\t}else{\n\n\t\t\t\trecursive(V,from_index,to_car_id+1,max(max_goal_time,goal_time(from_car_id)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%lld\",&DIST);\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&speed[i]);\n\t}\n\n\tscanf(\"%d\",&M);\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%lld\",&loc[i]);\n\t}\n\n\tif(N == 1){\n\t\tprintf(\"%lld\\n\",DIST*speed[0]);\n\t\treturn 0;\n\t}\n\n\tvector<int> V;\n\n\tfor(int i = 1; i < N; i++){ //★0は除く!!★\n\t\tV.push_back(i);\n\t}\n\n\tans = HUGE_NUM;\n\n\tdo{ //決定順のループ\n\n\t\tfor(int a = 0; a < N; a++){\n\t\t\tdecided[a] = false;\n\t\t\tstart_time[a] = -1;\n\t\t}\n\n\t\tfor(int a = 0; a < N; a++){\n\t\t\tfor(int b = 0; b < N; b++){\n\t\t\t\tinfo[a][b].loc = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int a = 0; a < M; a++){\n\t\t\tloc_table[a].num_overtake = 0;\n\t\t}\n\n\t\tstart_time[0] = 0; //先頭の馬車は必ず時刻0に出発\n\t\tdecided[0] = true;\n\n\t\trecursive(V,0,0,DIST*speed[0]);\n\n\t\tbreak;\n\n\t}while(next_permutation(V.begin(),V.end()));\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n \ntypedef long long ll;\n \nconst ll inf = (ll)1e15;\n \nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n \ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n    if(dif[i][k]!=inf && dif[k][j]!=inf && i!=j)\n      dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n \n \nll rec(vector<int> v, int depth){\n  if(depth == m){\n    ll tmp[9][9];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)tmp[i][j] = dif[i][j];\n \n    wf();\n \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n    if(tmp[i][j]!=inf && dif[i][j] != tmp[i][j])return inf;\n    if(i<=j && dif[i][j]<0)return inf;\n      }\n    /*\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)dif[i][j] = tmp[i][j];\n     \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++)\n      if(dif[i][k]!=inf && dif[k][j]!=inf)\n        dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n    */\n \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n    if(v[i]<v[j]){\n      if(s[v[i]] < s[v[j]])continue;\n      if(dif[v[i]][v[j]] == inf)continue;\n      if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n      if(dif[v[i]][v[j]]<0)continue;\n      return inf;\n    }else{\n      bool f = false;\n      for(int k=0;k<m;k++){\n        f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n      }\n      if(!f)return inf;\n    }\n      }\n    }\n \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n \n    for(int i=0;i<n;i++){\n      if(!i){\n    start[i] = 0;\n    goal[i] = s[i]*dist;\n      }else{\n    if(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n    else start[i] = start[i-1] + 1;\n    goal[i] = start[i] + s[i]*dist;\n    for(int j=0;j<i;j++){\n      if(pos[j]<pos[i] && goal[j]>goal[i]){\n        start[i] += goal[j]-goal[i];\n        goal[i] = goal[j];\n      }\n    }\n    for(int j=0;j<i;j++){\n      if(dif[j][i] != inf){\n        start[j] = start[i] - dif[j][i];\n        goal[j] = start[j] + s[j]*dist;\n      }\n    }\n      }\n      /*\n      for(int j=0;j<=i;j++){\n    cout << start[j] << \" \" << goal[j] << endl;\n      }\n      cout << \"----------------------\" << endl;\n      */\n    }\n     \n    ll res = 0;\n/*\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n*/\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl;\n \n    cout << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n   \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n \n  res = min(res,rec(v,depth+1));\n \n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n    for(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n  \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      //if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      //wf();\n      swap(v[i],v[i+1]);\n       \n      res = min(res,rec(v,depth+1));\n       \n      for(int j=i+2;j<n-1;j++){\n    if(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n      for(int x=0;x<n;x++)\n        for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n       \n      ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n      //if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n      dif[v[j]][v[j+1]] = t2; dif[v[j+1]][v[j]] = -t2;\n      //wf();\n      swap(v[j],v[j+1]);\n       \n      res = min(res,rec(v,depth+1));\n       \n      swap(v[j],v[j+1]);\n      for(int x=0;x<n;x++)\n        for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n    }\n    swap(v[i],v[i+1]);\n      }\n      for(int x=0;x<n;x++)\n    for(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n \nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n \n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint n,m;\nint S[MAXN];\nint D[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,int> mp;\nstruct permutation{\n    int a[10];\n}per;\nint percnt;\nvector<permutation> P;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=n;i++)if(out_time[i]<=out_time[i-1]) return false;\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<n;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=m;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n            if(!ok) return false;\n            if(mp.count(tmpD)) return false;\n            mp[tmpD]++;\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=n;i++) tmpans=max(tmpans,out_time[i]+(LL)dist*S[i]);\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\" : tmpans = %lld\\n\",tmpans);\n    ans=min(ans,tmpans);\n}\n\nint mark[MAXN];\nvoid DFS1(int cur){\n    if(cur>n){\n        per.a[0]=1;\n        P.push_back(per);\n        return;\n    }\n    for(int i=2;i<=n;i++)if(!mark[i]){\n        per.a[++percnt]=i;\n        mark[i]=1;\n        DFS1(cur+1);\n        percnt--;\n        mark[i]=0;\n    }\n}\n\nvoid DFS2(int curid,permutation now){\n    if(curid>=n){\n        update();\n        return;\n    }\n    int cur=now.a[curid];\n    for(int t=0;t<curid;t++){\n        int pre=now.a[t];\n        if(cur<pre){\n            out_time[cur]=out_time[pre]-1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=m;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n                DFS2(curid+1,now);\n            }\n            LL dt=dist;\n            while(S[cur]>S[pre]&&out_time[pre]-dt*(S[cur]-S[pre])>0){\n                out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n                DFS2(curid+1,now);\n            }\n        }\n        if(cur>pre){\n            out_time[cur]=out_time[pre]+1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=m;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n                DFS2(curid+1,now);\n            }\n            LL dt=dist;\n            while(dt<=dist+100){\n                out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n                DFS2(curid+1,now);\n\n            }\n        }\n\n    }\n}\n\nvoid solve(){\n    out_time[1]=0LL;\n    for(int perid=0;perid<P.size();perid++){\n        permutation now=P[perid];\n        DFS2(1,now);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++) scanf(\"%d\",&D[i]);\n    ans=(LL)INF*INF;\n    out_time[1]=0;\n    DFS1(2);\n//    printf(\"Pcnt = %d\\n\",P.size());\n//    for(int i=0;i<P.size();i++){\n//        for(int k=1;k<=n-1;k++) printf(\"%d \",P[i].a[k]);\n//        printf(\"\\n\");\n//    }\n    solve();\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e17;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n \nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm; // \n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  |j????????????????????? - i?????????????????????|\n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    i64 ans = INF;\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            auto g = state.adj_mat;\n            for (int k : in(n)) \n                for (int i : in(n)) \n                    for (int j : in(n)) \n                        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                int gsize = 1;\n                for (int j : in(i + 1, n))\n                    if (g[i][j] != INF)\n                        gsize++, used[j] = 1;\n                for (int j : in(i + 1, gsize + i))\n                    if (g[i][j - 1] >= g[i][j])\n                        return false;\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need + start_time[k] - g[i][j]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + g[i][j];\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll INF = (ll)1e12;\n\nll dist, n, m;\nll S[10], D[10], T[10];\n\nbool check(int N, int *p){\n  //出発順が守られているか\n  vector<P> v;\n  rep(i, N + 1) v.push_back(P(p[i], T[i]));\n  sort(v.begin(), v.end());\n  rep(i, v.size() - 1) if(v[i+1].second <= v[i].second) return false;\n  \n  //少し広いところを同時に3つ以上の馬車が通るか\n  rep(i, m){\n    map<int, int> mp;\n    rep(j, N + 1) if(++mp[T[j] + D[i] * S[p[j]]] > 2) return false;\n  }\n  //狭いところですれ違うか\n  rep(i, N + 1)rep(j, N){\n    bool f = false;\n    rep(k, m)   if(T[i] + S[p[i]] * D[k] == T[j] + S[p[j]] * D[k]) f = true;\n    if(f) continue;\n    if((T[i] - T[j]) * (T[i] - T[j] + (S[p[i]] - S[p[j]]) * dist) < 0) return false; \n  }\n  \n  return true;\n}\n\nll dfs(int N, int *p){\n  ll res = INF;\n  if(N == n){\n    res = -INF;\n    rep(i, n) res = max(res, T[i] + S[p[i]] * dist);\n    //cout << res << \"  \"<< *min_element(T, T + n) << endl;\n    return res - *min_element(T, T + n);\n  }\n\n  //どの馬車ともすれ違わない場合と\n  ll lb = -INF;\n  ll ub = INF;\n  rep(i, N){\n    if(p[i] < p[N]){\n      lb = max(lb, T[i] + 1);\n      lb = max(lb, (T[i] + (S[p[i]] - S[p[N]]) * dist));\n    }else{\n      ub = min(ub, T[i] - 1);\n      ub = min(ub, (T[i] + (S[p[i]] - S[p[N]]) * dist));\n    }\n  }\n  if(lb <= ub){\n    T[N] = lb == -INF ? ub : lb;\n    res = min(res, dfs(N + 1, p));\n  }\n  \n  //各少し広いところで各でどの馬車とすれ違うかで探索\n  rep(i, m)rep(j, N){\n    T[N] = T[j] + (S[p[j]] - S[p[N]]) * D[i];\n    if(check(N, p))  res = min(res, dfs(N + 1, p));\n  }\n  return res;\n}\n\nint main(){\n  ll res = INF;\n  int p[10];\n  cin >> dist >> n;\n  rep(i, n) cin >> S[i];\n  cin >> m;\n  rep(i, m) cin >> D[i];\n  rep(i, n) p[i] = i;\n  do{\n    T[0] = 0;\n    res = min(res, dfs(1, p));\n  }while(next_permutation(p, p + n));\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint n,m;\nint S[MAXN];\nint D[MAXN];\nvector<pair<int,LL> > t[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,int> mp;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=n;i++)if(out_time[i]<=out_time[i-1]) return false;\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<n;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=m;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n            if(!ok) return false;\n            if(mp.count(tmpD)) return false;\n            mp[tmpD]++;\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=n;i++) tmpans=max(tmpans,out_time[i]+(LL)dist*S[i]);\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\" : tmpans = %lld\\n\",tmpans);\n    ans=min(ans,tmpans);\n}\n\nvoid DFS(int cur){\n    if(cur>n){\n        update();\n        return;\n    }\n    for(int i=0;i<t[cur].size();i++){\n        int pre=t[cur][i].first;\n        int dt=t[cur][i].second;\n        out_time[cur]=out_time[pre]+dt;\n        DFS(cur+1);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++) scanf(\"%d\",&D[i]);\n    for(int j=2;j<=n;j++){\n        t[j].push_back(make_pair(j-1,1));\n        for(int i=1;i<j;i++){\n            if(S[j]<S[i]){\n                for(int k=1;k<=m+1;k++){\n                    LL delta=(k==m+1) ? dist : D[k];\n                    t[j].push_back(make_pair(i,delta*(S[i]-S[j])));\n                }\n            }\n        }\n    }\n    for(int j=2;j<=n;j++){\n        for(int k=j+1;k<=n;k++){\n            if(S[k]<S[j]){\n                for(int p=0;p<t[k].size();p++){\n                    int id=t[k][p].first;\n                    int dt=t[k][p].second;\n                    if(id>=j) continue;\n                    for(int q=1;q<=m;q++){\n                        LL delta=D[q];\n                        t[j].push_back(make_pair(id,dt-delta*(S[j]-S[k])));\n                    }\n                }\n            }\n        }\n    }\n    ans=(LL)INF*INF;\n    out_time[1]=0;\n    DFS(2);\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nll dist,n,m;\nll S[6],D[6];\nint decide[6];\nll ans=INF*INF;\nll start[6];\n\nvoid f(int cur){\n\t//cout<<cur<<\": \";\n\t//rep(i,n)cout<<start[i]<<\" \";cout<<endl;\n\tif(cur==n){\n\t\t//rep(i,n)cout<<start[i]<<\" \";cout<<endl;\n\t\tll res=0;\n\t\trep(i,n){\n\t\t\tres=max(res,start[i] + dist*S[i]);\n\t\t}\n\t\tans=min(ans,res);\n\t\treturn;\n\t}\n\tint target=decide[cur];\n\trep(i,cur+1)rep(j,i<cur ? m : 1){\n\t\tif(i==cur){\n\t\t\tif(start[target-1]==-1)continue;\n\t\t\tstart[target]=start[target-1]+1;\n\t\t}\n\t\telse{\n\t\t\tint car=decide[i];\n\t\t\tif(S[target] == S[car])continue;\n\t\t\tstart[target] = start[car] + D[j] * (S[car]-S[target]);\n\t\t}\n\t\t//cout<<cur<<\" start: \"<<start[target]<<endl;\n\t\t\n\t\tif(start[target]<0 ||\n\t\tstart[target-1]!=-1 && start[target] <= start[target-1] ||\n\t\tstart[target+1]!=-1 && start[target] >= start[target+1]){\n\t\t\tstart[target]=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tint ok=1;\n\t\trep(k,cur){\n\t\t\tint car=decide[k];\n\t\t\tif(S[car] == S[target])continue;\n\t\t\tll difstart = start[car]-start[target];\n\t\t\tll difS = S[target]-S[car];\n\t\t\t//cout<<k<<\" \"<<difstart<<\" \"<<difS<<endl;\n\t\t\tif(difstart == 0){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tif(difS == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart > 0 && difS < 0 || difstart < 0 && difS > 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart < 0 && difS < 0){\n\t\t\t\tdifstart*=-1;\n\t\t\t\tdifS*=-1;\n\t\t\t}\n\t\t\tif(difstart > difS * dist)continue;\n\t\t\tif(difstart % difS){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tll point = difstart/difS;\n\t\t\tint found=0;\n\t\t\trep(l,m)if(D[l]==point){\n\t\t\t\tfound=1;break;\n\t\t\t}\n\t\t\tif(!found){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tf(cur+1);\n\t\t}\n\t\tstart[target]=-1;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>dist>>n;\n\trep(i,n)cin>>S[i];\n\tcin>>m;\n\trep(i,m)cin>>D[i];\n\tD[m++]=dist;\n\tsort(D,D+m);\n\t//rep(i,m)cout<<D[i]<<\" \";cout<<endl;\n\t\n\trep(i,n)decide[i]=i;\n\tmemset(start,-1,sizeof(start));\n\tstart[0]=0;\n\tdo{\n\t\t//rep(i,n)cout<<decide[i]<<\" \";cout<<endl;\n\t\tf(1);\n\t\t//cout<<endl;\n\t}while(next_permutation(decide+1,decide+n));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n    \n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n    \n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n    \n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n    \n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n    \n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n    \n    friend ostream& operator << (ostream& s, UnionFind uf) {\n        map<int, vector<int> > res;\n        for (int i = 0; i < uf.par.size(); ++i) {\n            int r = uf.root(i);\n            res[r].push_back(i);\n        }\n        for (map<int, vector<int> >::iterator it = res.begin(); it != res.end(); ++it) {\n            s << endl;\n            for (int j = 0; j < (int)it->second.size(); ++j) {\n                s << it->second[j] << \"(\" << uf.weight(it->second[j]) << \"), \";\n            }\n        }\n        return s << endl;\n    }\n};\n\ntypedef pair<int,int> pint;\n\nlong long dist;\nint n, m;\nlong long S[11], D[11];\n\nconst long long INF = 1LL<<60;\nlong long res = INF; // 答えを更新していく\n\n// 各馬車が「どこですれ違うか」\nvoid check(vector<long long> diffs) {\n    UnionFind<long long> uf(n);\n    int iter = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            long long diff = diffs[iter++];\n            if (diff == -1) continue;\n            \n            if (uf.issame(i, j)) {\n                long long curdiff = uf.diff(i, j);\n                if (diff != curdiff) return;\n            }\n            else {\n                uf.merge(i, j, diff);\n            }\n        }\n    }\n\n    // 暫定回を求める\n    long long start = 0, goal = 0;\n    for (int i = 0; i < n; ++i) {\n        long long start_i = start + uf.diff(0, i);\n        long long goal_i = start_i + S[i] * dist;\n        if (start > start_i) start = start_i;\n        if (goal < goal_i) goal = goal_i;\n    }\n    \n    // 整合性を確認\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (!uf.issame(i, j)) return; // 繋がっていない箇所があったら明らかに最適でないので return\n            if (uf.diff(i, j) < 1) return; // j が i の 1分後よりも早く出ていたらダメ\n            \n            // 追い越している場合はどこで追い越してるか\n            long long start_i = uf.diff(0, i);\n            long long goal_i = start_i + S[i] * dist;\n            long long start_j = uf.diff(0, j);\n            long long goal_j = start_j + S[j] * dist;\n            if (goal_j < goal_i) {\n                int pl = -1;\n                for (int k = 0; k < m; ++k) {\n                    long long it = start_i + S[i] * D[k];\n                    long long jt = start_j + S[j] * D[k];\n                    if (it == jt) {\n                        pl = k;\n                    }\n                }\n                if (pl == -1) return; // 「少し広いところ以外で交わったらダメ\n            }\n        }\n    }\n    \n    // 本当に m 箇所それぞれについて、3 個以上の馬車が交わることがないか確認\n    for (int i = 0; i < m; ++i) {\n        map<long long,int> ma;\n        for (int j = 0; j < n; ++j) {\n            long long t = uf.diff(0, j) + S[j] * D[i];\n            ma[t]++;\n        }\n        for (map<long long,int>::iterator it = ma.begin(); it != ma.end(); ++it) {\n            if (it->second >= 3) return;\n        }\n    }\n    \n    /*\n    COUT(\"--------------\");\n    COUT(diffs);\n    COUT(uf);\n    COUT(start);\n    COUT(goal);\n    */\n    \n    // 確認を終えたら OK\n    if (res > goal - start) res = goal - start;\n}\n\nvoid dfs(vector<long long> diffs, int i, int j) {\n    if (i == n-1) {\n        check(diffs);\n        return;\n    }\n    \n    // 馬車 i, j が何分でゴールするか\n    long long total_i = S[i] * dist;\n    long long total_j = S[j] * dist;\n    \n    // 次の index\n    int ni = i;\n    int nj = j+1;\n    if (nj == n) {\n        ++ni;\n        nj = ni+1;\n    }\n    \n    // weight(j) - weight(i) = 1 (j が i より 1 分遅れスタートで、途中で抜かさない場合\n    if (total_j >= total_i - 1) {\n        diffs.push_back(1);\n        dfs(diffs, ni, nj);\n        diffs.pop_back();\n    }\n    \n    // ゴールでピッタリ\n    {\n        long long diff = total_i - total_j;\n        if (diff >= 1) {\n            diffs.push_back(diff);\n            dfs(diffs, ni, nj);\n            diffs.pop_back();\n        }\n    }\n    \n    // m 箇所それぞれ\n    if (S[i] != S[j]) {\n        for (int k = 0; k < m; ++k) {\n            long long diff = (S[i] - S[j]) * D[k];\n            if (diff >= 1) {\n                diffs.push_back(diff);\n                dfs(diffs, ni, nj);\n                diffs.pop_back();\n            }\n        }\n    }\n    \n    // それ以外\n    diffs.push_back(-1);\n    dfs(diffs, ni, nj);\n    diffs.pop_back();\n}\n\nint main() {\n    while (cin >> dist) {\n        cin >> n;\n        for (int i = 0; i < n; ++i) cin >> S[i];\n        cin >> m;\n        for (int i = 0; i < m; ++i) cin >> D[i];\n        \n        vector<long long> diffs;\n        dfs(diffs, 0, 1);\n        \n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e18;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n\nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm; // ??´??????????????????\n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  j??????????????? - i??????????????? INF???????????? \n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    // ????§??????????????????????\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    // ???????????????????????????????£??????????\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = -time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    // ?????????????????????????????£?????§????????§??????????????????????§??????????\n    i64 ans = INF;\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            auto g = state.adj_mat;\n            for (int k : in(n)) {\n                for (int i : in(n)) {\n                    for (int j : in(n)) {\n                        if (g[i][k] == INF || g[k][j] == INF)\n                            continue;\n                        if (g[i][j] == INF)\n                            g[i][j] = g[i][k] + g[k][j];\n                        else if (g[i][j] != g[i][k] + g[k][j])\n                            return false;\n                    }\n                }\n            }\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                int gsize = 1;\n                // ??£?????????????????£?¶???????????????????\n                for (int j : in(i + 1, n))\n                    if (g[i][j] != INF)\n                        gsize++, used[j] = 1;\n                for (int j : in(i + 1, gsize + i))\n                    if (g[i][j - 1] >= g[i][j])\n                        return false;\n                // ????§???????????????´??????\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need + start_time[k] - g[i][j]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + g[i][j];\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, D, intr;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\t\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tp[i] = i;\n\t}\n\n\tvector<vector<int> > odr(m + 1);\n\todr[0].resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\n\tint cnt = 0;\n\tfor(int j = 1; j <= m; ++j){\n\t\todr[j] = odr[j - 1];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j-1] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i+1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j][i], odr[j][i+1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] >= 0) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] < 0LL && stm[b] >= 0LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[j] * (S[b] - S[a]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] >= 0LL && stm[b] < 0LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[j] * (S[a] - S[b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] >= 0LL; ++j)\n\t\tfor(int k = j + 1; stm[k] >= 0LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\n\tif(cnt != 0) return;\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr = D;\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n \ntypedef long long ll;\n \nconst ll inf = (ll)1e15;\n \nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n \ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n    if(dif[i][k]!=inf && dif[k][j]!=inf && i!=j)\n      dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n \n \nll rec(vector<int> v, int depth){\n  if(depth == m){\n    ll tmp[9][9];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)tmp[i][j] = dif[i][j];\n \n    wf();\n \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n    if(tmp[i][j]!=inf && dif[i][j] != tmp[i][j])return inf;\n    if(i<=j && dif[i][j]<0)return inf;\n      }\n    /*\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)dif[i][j] = tmp[i][j];\n     \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++)\n      if(dif[i][k]!=inf && dif[k][j]!=inf)\n        dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n    */\n \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n    if(v[i]<v[j]){\n      if(s[v[i]] < s[v[j]])continue;\n      if(dif[v[i]][v[j]] == inf)continue;\n      if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n      if(dif[v[i]][v[j]]<0)continue;\n      return inf;\n    }else{\n      bool f = false;\n      for(int k=0;k<m;k++){\n        f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n      }\n      if(!f)return inf;\n    }\n      }\n    }\n \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n \n    for(int i=0;i<n;i++){\n      if(!i){\n    start[i] = 0;\n    goal[i] = s[i]*dist;\n      }else{\n    if(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n    else start[i] = start[i-1] + 1;\n    goal[i] = start[i] + s[i]*dist;\n    for(int j=0;j<i;j++){\n      if(pos[j]<pos[i] && goal[j]>goal[i]){\n        start[i] += goal[j]-goal[i];\n        goal[i] = goal[j];\n      }\n    }\n    for(int j=0;j<i;j++){\n      if(dif[j][i] != inf){\n        start[j] = start[i] - dif[j][i];\n        goal[j] = start[j] + s[j]*dist;\n      }\n    }\n      }\n      /*\n      for(int j=0;j<=i;j++){\n    cout << start[j] << \" \" << goal[j] << endl;\n      }\n      cout << \"----------------------\" << endl;\n      */\n    }\n     \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl;\n \n    cout << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n   \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n \n  res = min(res,rec(v,depth+1));\n \n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n    for(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n  \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      //if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      //wf();\n      swap(v[i],v[i+1]);\n       \n      res = min(res,rec(v,depth+1));\n       \n      for(int j=i+2;j<n-1;j++){\n    if(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n      for(int x=0;x<n;x++)\n        for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n       \n      ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n      //if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n      dif[v[j]][v[j+1]] = t2; dif[v[j+1]][v[j]] = -t2;\n      //wf();\n      swap(v[j],v[j+1]);\n       \n      res = min(res,rec(v,depth+1));\n       \n      swap(v[j],v[j+1]);\n      for(int x=0;x<n;x++)\n        for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n    }\n    swap(v[i],v[i+1]);\n      }\n      for(int x=0;x<n;x++)\n    for(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n \nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n \n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint M,N;\nint S[MAXN];\nint D[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,int> mp;\nstruct permutation{\n    int a[10];\n}per;\nint percnt;\nvector<permutation> P;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=N;i++)if(out_time[i]<=out_time[i-1]) return false;\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    for(int i=1;i<N;i++){\n        for(int j=i+1;j<=N;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=M;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n//            printf(\"ok = %d! , tmpD = %lld , i = %d , j = %d\\n\",ok,tmpD,i,j);\n            if(!ok) return false;\n//            if(mp.count(tmpD)) return false;\n            mp[tmpD]++;\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    for(int i=N;i>=1;i--) out_time[i]-=out_time[1];\n//    for(int i=1;i<N;i++)if(out_time[i]>=out_time[i+1]) return;\n//    for(int i=1;i<=N;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=N;i++){\n        LL tmp=out_time[i]+(LL)dist*S[i];\n        tmpans=max(tmpans,tmp);\n    }\n//    if(tmpans==6577480535){\n//        for(int i=1;i<=N;i++) printf(\"%lld \",out_time[i]);\n//        printf(\"\\n\");\n//        exit(0xff);\n//        is_judge();\n//    }\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\" : tmpans = %lld\\n\",tmpans);\n    ans=min(ans,tmpans);\n}\n\nint mark[MAXN];\nvoid DFS1(int cur){\n    if(cur>N){\n        per.a[0]=1;\n        P.push_back(per);\n        return;\n    }\n    for(int i=1;i<=N;i++)if(!mark[i]){\n        per.a[++percnt]=i;\n        mark[i]=1;\n        DFS1(cur+1);\n        percnt--;\n        mark[i]=0;\n    }\n}\n\nvoid DFS2(int curid,const permutation& now){\n    if(curid>N){\n        update();\n        return;\n    }\n    int cur=now.a[curid];\n    if(curid==1){\n        out_time[cur]=0;\n        DFS2(curid+1,now);\n        return;\n    }\n\n    for(int t=1;t<curid;t++){\n        int pre=now.a[t];\n        if(cur<pre){\n            out_time[cur]=out_time[pre]-1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=M;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n    //            printf(\"%d-%d : %lld->%lld\\n\",pre,cur,out_time[pre],out_time[cur]);\n                DFS2(curid+1,now);\n            }\n        }\n        if(cur>pre){\n            out_time[cur]=out_time[pre]+1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=M;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n    //            printf(\"%d-%d : %lld->%lld\\n\",pre,cur,out_time[pre],out_time[cur]);\n                DFS2(curid+1,now);\n            }\n        }\n    }\n}\n\nvoid solve(){\n    for(int perid=0;perid<P.size();perid++){\n        DFS2(1,P[perid]);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&N);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&M);\n    for(int i=1;i<=M;i++) scanf(\"%d\",&D[i]);\n    D[++M]=dist;\n    ans=(LL)INF*INF;\n    DFS1(1);\n//    printf(\"Pcnt = %d\\n\",P.size());\n//    for(int i=0;i<P.size();i++){\n//        for(int k=1;k<=N;k++) printf(\"%d \",P[i].a[k]);\n//        printf(\"\\n\");\n//    }\n    solve();\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n/*\ninput\n60516263\n5\n45\n16\n94\n71\n91\n4\n20586550\n54017689\n36941264\n49153094\n\noutput\n6577480535\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\n#define fs first\n#define sc second\n\nconst ll inf = (ll)1e15;\nP par[9];\nint rank[9];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n \nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n   \n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nll dis(int a, int b){\n  if(!same(a,b))return inf;\n  return par[b].sc - par[a].sc;\n}\n\nll dist;\nint n,m;\nll s[9],d[9];\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(dis(i,j)<=0)return inf;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(!same(v[i],v[j]))continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dis(v[i],v[j]))continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dis(v[j],v[i]));\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n    \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(same(i-1,i))start[i] = start[i-1] + dis(i-1,i);\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(same(i,j)){\n\t    start[j] = start[i] + dis(i,j);\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=0;i<n;i++)res = max(res,goal[i]);\n    return res;\n  }\n  \n  ll res = inf;\n  P tp1[9],tp2[9];\n  int tr1[9],tr2[9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++){\n\ttp1[x] = par[x];\n\ttr1[x] = rank[x];\n      }\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(!unite(v[i],v[i+1],t1))continue;\n\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++){\n\t    tp2[x] = par[x];\n\t    tr2[x] = rank[x];\n\t  }\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(!unite(v[j],v[j+1],t2))continue;\n\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++){\n\t    par[x] = tp2[x];\n\t    rank[x] = tr2[x];\n\t  }\n\t}\n      }\n      swap(v[i],v[i+1]);\n     \n      for(int x=0;x<n;x++){\n\tpar[x] = tp1[x];\n\trank[x] = tr1[x];\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  init(n);\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst ll INF = 1000000000000000000ll;\n\nll dist;\nint n, m;\nvector<ll> S, D;\n\nbool check(int a, ll t, const vector<int> &order, vector<int> &used, const vector<ll> &stime){\n\tbool valid = true;\n\tfor(int i = 0; valid && i < a; ++i){\n\t\tll g0 = stime[order[i]] + S[order[i]] * dist;\n\t\tll g1 = t + S[order[a]] * dist;\n\t\tbool crossing = false;\n\t\tif(order[i] < order[a]){\n\t\t\tif(stime[order[i]] >= t){ valid = false; }\n\t\t\tif(g0 > g1){ crossing = true; }\n\t\t}else{\n\t\t\tif(stime[order[i]] <= t){ valid = false; }\n\t\t\tif(g0 < g1){ crossing = true; }\n\t\t}\n\t\tif(crossing){\n\t\t\tint pos = -1;\n\t\t\tfor(int j = 0; pos < 0 && j < m; ++j){\n\t\t\t\tif(used[order[i]] & (1 << j)){ continue; }\n\t\t\t\tll ta = D[j] * S[order[i]] + stime[order[i]];\n\t\t\t\tll tb = D[j] * S[order[a]] + t;\n\t\t\t\tif(ta == tb){ pos = j; }\n\t\t\t}\n\t\t\tif(pos < 0){\n\t\t\t\tvalid = false;\n\t\t\t}else{\n\t\t\t\tused[order[i]] |= (1 << pos);\n\t\t\t\tused[order[a]] |= (1 << pos);\n\t\t\t}\n\t\t}\n\t}\n\treturn valid;\n}\n\nll solve(int a, const vector<int> &order, const vector<int> &used, vector<ll> &stime){\n\tif(a == 0){\n\t\tint index = order[a];\n\t\tstime[index] = 0;\n\t\treturn solve(1, order, used, stime);\n\t}else if(a == n){\n\t\tll start = INF, goal = -INF;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstart = min(start, stime[i]);\n\t\t\tgoal = max(goal, stime[i] + S[i] * dist);\n\t\t}\n\t\treturn goal - start;\n\t}else{\n\t\tll result = INF;\n\t\tint index = order[a];\n\t\tfor(int i = 0; i < a; ++i){\n\t\t\tint c = order[i];\n\t\t\tfor(int j = 0; j <= m; ++j){\n\t\t\t\tif(used[c] & (1 << j)){ continue; }\n\t\t\t\tll d = (j == m ? dist : D[j]);\n\t\t\t\tll t = d * S[c] + stime[c] - d * S[index];\n\t\t\t\tvector<int> next_used(used);\n\t\t\t\tif(!check(a, t, order, next_used, stime)){ continue; }\n\t\t\t\tstime[order[a]] = t;\n\t\t\t\tresult = min(solve(a + 1, order, next_used, stime), result);\n\t\t\t}\n\t\t}\n\t\tll t = -INF;\n\t\tfor(int i = 0; i < a; ++i){\n\t\t\tif(order[i] < order[a]){\n\t\t\t\tt = max(t, order[a] - order[i] + stime[order[i]]);\n\t\t\t}\n\t\t}\n\t\tif(t <= -INF){\n\t\t\tfor(int i = 0; i < a; ++i){\n\t\t\t\tif(order[i] > order[a]){\n\t\t\t\t\tt = max(t, stime[order[i]] - (order[a] - order[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> next_used(used);\n\t\tif(check(a, t, order, next_used, stime)){\n\t\t\tstime[order[a]] = t;\n\t\t\tresult = min(solve(a + 1, order, next_used, stime), result);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\tfor(int i = 0; i < n; ++i){ cin >> S[i]; }\n\tcin >> m;\n\tD.resize(m);\n\tfor(int i = 0; i < m; ++i){ cin >> D[i]; }\n\tvector<int> order(n);\n\tfor(int i = 0; i < n; ++i){ order[i] = i; }\n\tll answer = INF;\n\tdo {\n\t\tvector<int> used(n);\n\t\tvector<ll> stime(n);\n\t\tanswer = min(answer, solve(0, order, used, stime));\n\t} while(!next_permutation(order.begin(), order.end()));\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i,n) for(int i = 0;i < n;i++)\n\nusing namespace std;\n#define INF 1e16\ntypedef long long lint;\n\nbool went[5]={0};   //全探索で、現在使用中かどうかのフラグ\nlint tm[5];         //馬車の出発時間\nlint S[5];\nlint dist;\nlint D[5];\nint n,m;\nlint answer = INF;  //答え\nlint pre;           //適切な出発時間であるような、答えの候補\n\nvoid judge(){   //tmが適切かどうかを判定する(ほそながいところとゴール以外で追いつかないか・ほそながいところで3つ以上の馬車が同時に追いつかないか)\n    vector<pair<lint,lint> > meet;\n    rep(i,n-1){\n        for(int j = i + 1;j < n;j++){\n            int hoge = 0;\n            if(S[i] < S[j]||tm[j]-tm[i] >= (S[i]-S[j])*dist)\n                continue;\n            rep(k,m){\n                if(tm[i]-tm[j] == (S[j]-S[i])*D[k]){\n                    meet.push_back(make_pair(tm[j]+S[j]*D[k],k));\n                    hoge = 1;\n                    break;\n                }\n            }\n            if(!hoge){\n                return;\n            }\n        }\n    }\n    if(!meet.empty()){\n        sort(meet.begin(),meet.end());\n        rep(i,meet.size()-1){ //3つ以上の馬車が同時に細長いところで追いついている\n            if(meet[i] == meet[i+1])\n                return;\n        }\n    }\n    pre = 0;\n    rep(i,n){\n        pre = max(pre,tm[i]+dist*S[i]);\n    }\n    answer = min(answer,pre);\n}\n\nvoid search(int p){ //全探索 pは探索の深さ\n    if(p == 0){\n        tm[0] = 0;\n        went[0]=1;\n        search(1);\n        return;\n    }\n    rep(i,n-1){\n        if(went[i] && went[i+1] && tm[i] >= tm[i+1])\n            return;\n    }\n    if(p == n){\n        judge();\n        return;\n    }\n    rep(i,n-1){\n        if(went[i] && !went[i+1]){\n            tm[i+1] = tm[i]+1;\n            went[i+1] = 1;\n            search(p+1);\n            went[i+1] = 0;\n        }\n        //!went[i] && went[i+1]の場合は探索しなくてよい(馬車iは必ずどこかで他の馬車に追いつくから)\n    }\n    rep(i,n){\n        if(!went[i]){\n            rep(j,n){\n                if((i < j && S[i]<S[j])||(i > j && S[i]>S[j]))\n                    continue;\n                if(went[j]){\n                    rep(k,m){   //iとjがkで追いつく\n                        tm[i] = tm[j]+(S[j]-S[i])*D[k];\n                        went[i] = 1;\n                        search(p+1);\n                        went[i] = 0;\n                    }\n                    tm[i] = tm[j]+(S[j]-S[i])*dist;\n                    went[i] = 1;\n                    search(p+1);\n                    went[i] = 0;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    cin  >> dist;\n    cin >> n;\n    rep(i,n){\n        cin >> S[i];\n    }\n    cin >> m;\n    rep(i,m){\n        cin >> D[i];\n    }\n    search(0);\n    cout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst ll INF = 1000000000000000000ll;\n\nll dist;\nint n, m;\nvector<ll> S, D;\n\nbool check(int a, ll t, const vector<int> &order, vector<int> &used, const vector<ll> &stime){\n\tbool valid = true;\n\tfor(int i = 0; valid && i < a; ++i){\n\t\tll g0 = stime[order[i]] + S[order[i]] * dist;\n\t\tll g1 = t + S[order[a]] * dist;\n\t\tbool crossing = false;\n\t\tif(order[i] < order[a]){\n\t\t\tif(stime[order[i]] >= t){ valid = false; }\n\t\t\tif(g0 > g1){ crossing = true; }\n\t\t}else{\n\t\t\tif(stime[order[i]] <= t){ valid = false; }\n\t\t\tif(g0 < g1){ crossing = true; }\n\t\t}\n\t\tif(crossing){\n\t\t\tint pos = -1;\n\t\t\tfor(int j = 0; pos < 0 && j < m; ++j){\n\t\t\t\tif(used[order[i]] & (1 << j)){ continue; }\n\t\t\t\tll ta = D[j] * S[order[i]] + stime[order[i]];\n\t\t\t\tll tb = D[j] * S[order[a]] + t;\n\t\t\t\tif(ta == tb){ pos = j; }\n\t\t\t}\n\t\t\tif(pos < 0){\n\t\t\t\tvalid = false;\n\t\t\t}else{\n\t\t\t\tused[order[i]] |= (1 << pos);\n\t\t\t\tused[order[a]] |= (1 << pos);\n\t\t\t}\n\t\t}\n\t}\n\treturn valid;\n}\n\nll solve(int a, const vector<int> &order, const vector<int> &used, vector<ll> &stime){\n\tif(a == 0){\n\t\tint index = order[a];\n\t\tstime[index] = 0;\n\t\treturn solve(1, order, used, stime);\n\t}else if(a == n){\n\t\tll start = INF, goal = -INF;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstart = min(start, stime[i]);\n\t\t\tgoal = max(goal, stime[i] + S[i] * dist);\n\t\t}\n\t\treturn goal - start;\n\t}else{\n\t\tll result = INF;\n\t\tint index = order[a];\n\t\tfor(int i = 0; i < a; ++i){\n\t\t\tint c = order[i];\n\t\t\tfor(int j = 0; j <= m; ++j){\n\t\t\t\tif(used[c] & (1 << j)){ continue; }\n\t\t\t\tll d = (j == m ? dist : D[j]);\n\t\t\t\tll t = d * S[c] + stime[c] - d * S[index];\n\t\t\t\tvector<int> next_used(used);\n\t\t\t\tif(!check(a, t, order, next_used, stime)){ continue; }\n\t\t\t\tstime[order[a]] = t;\n\t\t\t\tresult = min(solve(a + 1, order, next_used, stime), result);\n\t\t\t}\n\t\t}\n\t\tll t = -INF;\n\t\tfor(int i = 0; i < a; ++i){\n\t\t\tif(order[i] < order[a]){\n\t\t\t\tt = max(t, order[a] - order[i] + stime[order[i]]);\n\t\t\t}\n\t\t}\n\t\tif(t <= -INF){\n\t\t\tfor(int i = 0; i < a; ++i){\n\t\t\t\tif(order[i] > order[a]){\n\t\t\t\t\tt = max(t, stime[order[i]] - (order[a] - order[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> next_used(used);\n\t\tif(check(a, t, order, next_used, stime)){\n\t\t\tstime[order[a]] = t;\n\t\t\tresult = min(solve(a + 1, order, next_used, stime), result);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\tfor(int i = 0; i < n; ++i){ cin >> S[i]; }\n\tcin >> m;\n\tD.resize(m);\n\tfor(int i = 0; i < m; ++i){ cin >> D[i]; }\n\tvector<int> order(n);\n\tfor(int i = 0; i < n; ++i){ order[i] = i; }\n\tll answer = INF;\n\tdo {\n\t\tvector<int> used(n);\n\t\tvector<ll> stime(n);\n\t\tanswer = min(answer, solve(0, order, used, stime));\n\t} while(next_permutation(order.begin(), order.end()));\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = (ll)1e15;\n\nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n\ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(dif[i][k]!=inf && dif[k][j]!=inf && i!=j)\n\t  dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    ll tmp[9][9];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)tmp[i][j] = dif[i][j];\n\n    wf();\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(tmp[i][j]!=inf && dif[i][j] != tmp[i][j])return inf;\n\tif(i<=j && dif[i][j]<0)return inf;\n      }\n    /*\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)dif[i][j] = tmp[i][j];\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=i+1;j<n;j++)\n\t  if(dif[i][k]!=inf && dif[k][j]!=inf)\n\t    dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n    */\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(dif[v[i]][v[j]] == inf)continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n\t  if(dif[v[i]][v[j]]<0)continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n\n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(dif[j][i] != inf){\n\t    start[j] = start[i] - dif[j][i];\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n      /*\n      for(int j=0;j<=i;j++){\n\tcout << start[j] << \" \" << goal[j] << endl;\n      }\n      cout << \"----------------------\" << endl;\n      */\n    }\n    \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl;\n\n    cout << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n  \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      //if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      //wf();\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  //if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n\t  dif[v[j]][v[j+1]] = t2; dif[v[j+1]][v[j]] = -t2;\n\t  //wf();\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n\t}\n\tswap(v[i],v[i+1]);\n      }\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e18;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n\nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm; // ??´??????????????????\n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  j??????????????? - i??????????????? INF???????????? \n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    // ????§??????????????????????\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    // ???????????????????????????????£??????????\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = -time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    // ?????????????????????????????£?????§????????§??????????????????????§??????????\n    i64 ans = INF;\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            auto g = state.adj_mat;\n            for (int k : in(n)) {\n                for (int i : in(n)) {\n                    for (int j : in(n)) {\n                        if (g[i][k] == INF || g[k][j] == INF)\n                            continue;\n                        if (g[i][j] == INF)\n                            g[i][j] = g[i][k] + g[k][j];\n                        else if (g[i][j] != g[i][k] + g[k][j])\n                            return false;\n                    }\n                }\n            }\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                int gsize = 1;\n                // ??£?????????????????£?¶???????????????????\n                for (int j : in(i + 1, n))\n                    if (g[i][j] != INF)\n                        gsize++, used[j] = 1;\n                for (int j : in(i + 1, gsize + i))\n                    if (g[i][j - 1] >= g[i][j])\n                        return false;\n                // ????§???????????????´??????\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need - g[i][j]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + g[i][j];\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        // cout << \">_<\" << endl;\n        // print_vec(start_time);\n        // print_vec(state.perm);\n        // for (auto v : state.adj_mat) print_vec(v);\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint n,m;\nint S[MAXN];\nint D[MAXN];\nvector<pair<int,LL> > t[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,int> mp;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=n;i++)if(out_time[i]<=out_time[i-1]) return false;\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<n;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            if(mp.count(tmpD)) return false;\n            mp[tmpD]++;\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=n;i++) tmpans=max(tmpans,out_time[i]+(LL)dist*S[i]);\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    ans=min(ans,tmpans);\n}\n\nvoid DFS(int cur){\n    if(cur>n){\n        update();\n        return;\n    }\n    for(int i=0;i<t[cur].size();i++){\n        int pre=t[cur][i].first;\n        int dt=t[cur][i].second;\n        out_time[cur]=out_time[pre]+dt;\n        DFS(cur+1);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++) scanf(\"%d\",&D[i]);\n    for(int j=2;j<=n;j++){\n        t[j].push_back(make_pair(j-1,1));\n        for(int i=1;i<j;i++){\n            if(S[j]<S[i]){\n                for(int k=1;k<=m+1;k++){\n                    LL delta=(k==m+1) ? dist : D[k];\n                    t[j].push_back(make_pair(i,delta*(S[i]-S[j])));\n                }\n            }\n        }\n    }\n    ans=(LL)INF*INF;\n    out_time[1]=0;\n    DFS(2);\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 5\n\nint N,M;\nll DIST,ans;\nll start_time[NUM];\nll unit_time[NUM],loc[NUM];\n\nll goal_time(int car_id){\n\n\treturn start_time[car_id]+unit_time[car_id]*DIST;\n}\n\nvoid recursive(int car_id){\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(start_time[i] == -1)continue;\n\n\t\tif(goal_time(i) >= ans){\n\t\t\treturn;\n\t\t}\n\t}\n\n\tll pre = 0;\n\n\tfor(int i = 1; i < N; i++){\n\t\tif(start_time[i] == -1)continue;\n\n\t\tif(start_time[i] <= pre){\n\t\t\treturn;\n\t\t}\n\n\t\tpre = start_time[i];\n\t}\n\n\tif(car_id == N){\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(start_time[i] == -1)return;\n\t\t}\n\n\t\tbool FLG;\n\n\t\tvector<ll> V[NUM];\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tif(goal_time(i) <= goal_time(k))continue;\n\n\t\t\t\tFLG = false;\n\n\t\t\t\tfor(int a = 0; a < M; a++){\n\t\t\t\t\tif(start_time[i]+unit_time[i]*loc[a] == start_time[k]+unit_time[k]*loc[a]){\n\t\t\t\t\t\tV[a].push_back(start_time[i]+unit_time[i]*loc[a]);\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(!FLG)return;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(V[i].size() <= 1)continue;\n\n\t\t\tfor(int a = 0; a < V[i].size()-1; a++){\n\t\t\t\tfor(int b = a+1; b < V[i].size(); b++){\n\t\t\t\t\tif(V[i][a] == V[i][b]){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll tmp_ans = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ttmp_ans = max(tmp_ans,goal_time(i));\n\t\t}\n\n\t\tans = min(ans,tmp_ans);\n\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\n\t\tif(start_time[i] != -1 && start_time[i+1] == -1){\n\n\t\t\tstart_time[i+1] = start_time[i]+1;\n\t\t\trecursive(car_id+1);\n\t\t\tstart_time[i+1] = -1;\n\t\t}\n\n\t\tif(start_time[i] == -1 && start_time[i+1] != -1){\n\n\t\t\tstart_time[i] = start_time[i+1]-1;\n\t\t\trecursive(car_id+1);\n\t\t\tstart_time[i] = -1;\n\t\t}\n\t}\n\n\tfor(int i = 1; i < N; i++){\n\t\tif(start_time[i] != -1)continue;\n\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(k == i || start_time[k] == -1 || (k < i && unit_time[k] <= unit_time[i]) || (i < k && unit_time[i] <= unit_time[k]))continue;\n\n\t\t\tfor(int a = 0; a < M; a++){\n\n\t\t\t\tstart_time[i] = start_time[k]+(unit_time[k]-unit_time[i])*loc[a];\n\t\t\t\trecursive(car_id+1);\n\t\t\t\tstart_time[i] = -1;\n\t\t\t}\n\t\t\tstart_time[i] = start_time[k]+(unit_time[k]-unit_time[i])*DIST;\n\t\t\trecursive(car_id+1);\n\t\t\tstart_time[i] = -1;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%lld\",&DIST);\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&unit_time[i]);\n\t}\n\n\tscanf(\"%d\",&M);\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%lld\",&loc[i]);\n\t}\n\n\tif(N == 1){\n\n\t\tprintf(\"%lld\\n\",unit_time[0]*DIST);\n\t\treturn 0;\n\t}\n\n\tstart_time[0] = 0;\n\n\tfor(int i = 1; i < N; i++){\n\t\tstart_time[i] = -1;\n\t}\n\n\tans = HUGE_NUM;\n\n\trecursive(1);\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e18;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n\nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm; // ??´??????????????????\n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  j??????????????? - i??????????????? INF???????????? \n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    // ????§??????????????????????\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    // ???????????????????????????????£??????????\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = -time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    // ?????????????????????????????£?????§????????§??????????????????????§??????????\n    i64 ans = INF;\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            auto g = state.adj_mat;\n            for (int k : in(n)) {\n                for (int i : in(n)) {\n                    for (int j : in(n)) {\n                        if (g[i][k] == INF || g[k][j] == INF)\n                            continue;\n                        if (g[i][j] == INF)\n                            g[i][j] = g[i][k] + g[k][j];\n                        else if (g[i][j] != g[i][k] + g[k][j])\n                            return false;\n                    }\n                }\n            }\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                int gsize = 1;\n                // ??£?????????????????£?¶???????????????????\n                for (int j : in(i + 1, n))\n                    if (g[i][j] != INF)\n                        gsize++, used[j] = 1;                \n                // ????§???????????????´??????\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need - g[i][j]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + g[i][j];\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        // cout << \">_<\" << endl;\n        // print_vec(start_time);\n        // print_vec(state.perm);\n        // for (auto v : state.adj_mat) print_vec(v);\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n  return \"意味がわからん\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\n#define fs first\n#define sc second\n\nconst ll inf = (ll)1e15;\nP par[9];\nint rank[9];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n \nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n   \n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nll dis(int a, int b){\n  if(!same(a,b))return inf;\n  return par[b].sc - par[a].sc;\n}\n\nll dist;\nint n,m;\nll s[9],d[9];\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(dis(i,j)<=0)return inf;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] <= s[v[j]])continue;\n\t  if(!same(v[i],v[j]))continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dis(v[i],v[j]))continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dis(v[j],v[i]));\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n    \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(same(i-1,i))start[i] = start[i-1] + dis(i-1,i);\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(same(i,j)){\n\t    start[j] = start[i] + dis(i,j);\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=0;i<n;i++)res = max(res,goal[i]);\n    return res;\n  }\n  \n  ll res = inf;\n  P tp1[9],tp2[9];\n  int tr1[9],tr2[9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++){\n\ttp1[x] = par[x];\n\ttr1[x] = rank[x];\n      }\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(!unite(v[i],v[i+1],t1))continue;\n\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++){\n\t    tp2[x] = par[x];\n\t    tr2[x] = rank[x];\n\t  }\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(!unite(v[j],v[j+1],t2))continue;\n\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++){\n\t    par[x] = tp2[x];\n\t    rank[x] = tr2[x];\n\t  }\n\t}\n      }\n      swap(v[i],v[i+1]);\n     \n      for(int x=0;x<n;x++){\n\tpar[x] = tp1[x];\n\trank[x] = tr1[x];\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  init(n);\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n fusei();\n}\nint fusei(){\nreturn fusei();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[uf.root(i).first] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime =uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taa afrom(prev(it)->second);\n\t\t\taa ato(it->second);\n\n\t\t\tif (afrom.lasfintime - afrom.lasstatime>ato.fstfintime-ato.fststatime) {\n\t\t\t\tuf.unionSet(afrom.lasfinid, ato.fstfinid, times[afrom.lasfinid][M] - times[ato.fstfinid][M]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf.unionSet(afrom.lasstaid, ato.fststaid, 1);\n\t\t\t}\n\t\t\t/*aUnionFind auf(uf);\n\t\t\taUnionFind buf(uf);\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasfinid;\n\t\t\t\tint to = (it)->second.fstfinid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tauf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauf.unionSet((prev(it))->second.lasstaid, (it)->second.fststaid, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasstaid;\n\t\t\t\tint to = (it)->second.fststaid;\n\t\t\t\tbuf.unionSet(from, to, 1);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (buf.root((it)->second.fststaid).second > auf.root((it)->second.fststaid).second) {\n\t\t\t\tuf = buf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf = auf;\n\t\t\t}*/\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\t\n\t\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tans = min(ans,a);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint M,N;\nint S[MAXN];\nint D[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,set<int> > mp;\nstruct permutation{\n    int a[10];\n}per;\nint percnt;\nvector<permutation> P;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=N;i++)if(out_time[i]<=out_time[i-1]) return false;\n    for(int i=1;i<N;i++){\n        for(int j=i+1;j<=N;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=M;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n            if(!ok) return false;\n            if(mp.count(tmpD)){\n                if(mp[tmpD].count(i)) return false;\n                if(mp[tmpD].count(j)) return false;\n            }\n            mp[tmpD].insert(i);\n            mp[tmpD].insert(j);\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    for(int i=N;i>=1;i--) out_time[i]-=out_time[1];\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=N;i++){\n        LL tmp=out_time[i]+(LL)dist*S[i];\n        tmpans=max(tmpans,tmp);\n    }\n    ans=min(ans,tmpans);\n}\n\nint mark[MAXN];\nvoid DFS1(int cur){\n    if(cur>N){\n        per.a[0]=1;\n        P.push_back(per);\n        return;\n    }\n    for(int i=1;i<=N;i++)if(!mark[i]){\n        per.a[++percnt]=i;\n        mark[i]=1;\n        DFS1(cur+1);\n        percnt--;\n        mark[i]=0;\n    }\n}\n\nvoid DFS2(int curid,const permutation& now){\n    if(curid>N){\n        update();\n        return;\n    }\n    int cur=now.a[curid];\n    if(curid==1){\n        out_time[cur]=0;\n        DFS2(curid+1,now);\n        return;\n    }\n\n    for(int t=1;t<curid;t++){\n        int pre=now.a[t];\n        if(cur<pre){\n            out_time[cur]=out_time[pre]-1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=M;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n    //            printf(\"%d-%d : %lld->%lld\\n\",pre,cur,out_time[pre],out_time[cur]);\n                DFS2(curid+1,now);\n            }\n        }\n        if(cur>pre){\n            out_time[cur]=out_time[pre]+1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=M;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n                DFS2(curid+1,now);\n            }\n        }\n    }\n}\n\nvoid solve(){\n    for(int perid=0;perid<P.size();perid++){\n        DFS2(1,P[perid]);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&N);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&M);\n    for(int i=1;i<=M;i++) scanf(\"%d\",&D[i]);\n    D[++M]=dist;\n    ans=(LL)INF*INF;\n    DFS1(1);\n    solve();\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n/*\ninput\n60516263\n5\n45\n16\n94\n71\n91\n4\n20586550\n54017689\n36941264\n49153094\n\noutput\n6577480535\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int dist;\n  cin>>dist;\n  Int n;\n  cin>>n;\n  vector<Int> s(n);\n  for(Int i=0;i<n;i++) cin>>s[i];\n  Int m;\n  cin>>m;\n  vector<Int> d(m);\n  for(Int i=0;i<m;i++) cin>>d[i];\n\n  const Int INF = 1e17;\n  Int t[10][10];\n  Int ans=INF;\n  auto check=\n    [&]()->Int{\n      struct edge{\n\tInt from,to,cost;\n\tedge(Int from,Int to,Int cost):from(from),to(to),cost(cost){}\n      };\n      vector<edge> es;\n      \n      for(Int i=1;i<n;i++){\n\t// p[i-1] + 1 <= p[i]\n\t// p[i-1] - p[i] <= -1\n\tes.emplace_back(i,i-1,-1);\n      }\n      for(Int i=0;i<n;i++){\n\tfor(Int j=i+1;j<n;j++){\n\t  // j catch up i at t[i][j]\n\t  if(t[i][j]>m) continue;\n\t  if(t[i][j]==m){\n\t    // dist * s[i] + p[i] <= dist * s[j] + p[j]\n\t    // p[i] - p[j] <= dist * s[j] - dist * s[i]\t    \n\t    es.emplace_back(j,i,dist*(s[j]-s[i]));\n\t    continue;\n\t  }\n\t  Int x=d[t[i][j]];\n\t  // x * s[i] + p[i] == x * s[j] + p[j]\n\t  \n\t  // x * s[i] + p[i] <= x * s[j] + p[j]\t  \n\t  // p[i] - p[j] <= x * s[j] - x * s[i]\n\t  es.emplace_back(j,i,x*(s[j]-s[i]));\n\t  // x * s[i] + p[i] >= x * s[j] + p[j]\n\t  // p[j] - p[i] <= x * s[i] - x * s[j]\n\t  es.emplace_back(i,j,x*(s[i]-s[j]));\n\t}\n      }\n      \n      vector<Int> p(n,INF);\n      // minimize p[n-1] - p[0]\n      // maximize p[0] - p[n-1]\n      p[n-1] = 0;\n      Int flg=1;\n      for(Int t=0;t<n*3;t++){\n\tflg=0;\n\tfor(auto e:es){\n\t  if(p[e.from]+e.cost<p[e.to]){\n\t    p[e.to]=p[e.from]+e.cost;\n\t    flg=1;\t    \n\t  }\n\t}\n      }\n      if(flg) return -1;      \n      vector<Int> z(n);\n      for(Int i=0;i<n;i++) z[i]=p[i]-p[0];\n      \n      for(Int i=0;i<m;i++){\n\tmap<Int, Int> cnt;\n\tfor(Int j=0;j<n;j++)\n\t  cnt[d[i]*s[j]+z[j]]++;\n\tfor(auto p:cnt) if(p.second>2) return -2;\n      }\n      \n      Int res=0;\n      for(Int i=0;i<n;i++) chmax(res,dist*s[i]+z[i]);\n      return res;\n    };\n\n  using P = pair<Int, Int>;\n  vector<P> vp;\n  for(Int i=0;i<n;i++)\n    for(Int j=i+1;j<n;j++)\n      vp.emplace_back(i,j);\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      t[i][j]=m+1;\n  \n  function<void(Int)> dfs=\n    [&](Int x){\n      Int res=check();\n      if(res==-1) return;\n      if(x==(Int)vp.size()){\n\tif(res>=0) chmin(ans,res);\n\treturn;\n      }\n      for(Int i=0;i<=m;i++){\n\tt[vp[x].first][vp[x].second]=i;\n\tdfs(x+1);\n\tt[vp[x].first][vp[x].second]=m+1;\n      }\n    };\n  \n  dfs(0);\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = (ll)1e15;\n\nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n\ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(dif[i][k]!=inf && dif[k][j]!=inf && i!=j)\n\t  dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(dif[v[i]][v[j]] == inf)continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n\t  if(dif[v[i]][v[j]]<0)continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n\n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(dif[j][i] != inf){\n\t    start[j] = start[i] - dif[j][i];\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n      /*\n      for(int j=0;j<=i;j++){\n\tcout << start[j] << \" \" << goal[j] << endl;\n      }\n      cout << \"----------------------\" << endl;\n      */\n    }\n    \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl;\n\n    cout << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n  \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      wf();      \n      swap(v[i],v[i+1]);\n\n      res = min(res,rec(v,depth+1));\n\n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n\n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n\t  dif[v[j]][v[j+1]] = t2; dif[v[j+1]][v[j]] = -t2;\n\t  wf();\n\t  swap(v[j],v[j+1]);\n\n\t  res = min(res,rec(v,depth+1));\n\n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n\t}\n      }\n\n      swap(v[i],v[i+1]);\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e18;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n\nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm; // ??´??????????????????\n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  j??????????????? - i??????????????? INF???????????? \n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    // ????§??????????????????????\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    // ???????????????????????????????£??????????\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = -time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    // ?????????????????????????????£?????§????????§??????????????????????§??????????\n    i64 ans = INF;\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            auto g = state.adj_mat;\n            for (int k : in(n)) {\n                for (int i : in(n)) {\n                    for (int j : in(n)) {\n                        if (g[i][k] == INF || g[k][j] == INF)\n                            continue;\n                        if (g[i][j] == INF)\n                            g[i][j] = g[i][k] + g[k][j];\n                        // else if (g[i][j] != g[i][k] + g[k][j])\n                        //     return false;\n                    }\n                }\n            }\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                int gsize = 1;\n                // ??£?????????????????£?¶???????????????????\n                for (int j : in(i + 1, n))\n                    if (g[i][j] != INF)\n                        gsize++, used[j] = 1;\n                for (int j : in(i + 1, gsize + i))\n                    if (g[i][j - 1] >= g[i][j])\n                        return false;\n                // ????§???????????????´??????\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need + start_time[k] - g[i][j]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + g[i][j];\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, D, intr;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\t\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tp[i] = i;\n\t}\n\n\tvector<vector<int> > odr(m + 1);\n\todr[0].resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\t\n\tint cnt = 0;\n\tfor(int j = 0; j < m; ++j){\n\t\todr[j + 1] = odr[j];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i + 1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j + 1][i], odr[j + 1][i + 1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] >= 0) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] == -1LL && stm[b] != -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[j] * (S[b] - S[a]);\n\t\t\t\t\t\tif(stm[a] >= stm[b]) while(1);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] != -1LL && stm[b] == -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[j] * (S[a] - S[b]);\n\t\t\t\t\t\tif(stm[a] >= stm[b]) throw 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] >= 0LL; ++j)\n\t\tfor(int k = j + 1; stm[k] >= 0LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\n\tif(cnt != 0) return;\n\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr = D;\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint n,m;\nint S[MAXN];\nint D[MAXN];\nint OK[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,int> mp;\nstruct permutation{\n    int a[10];\n}per;\nint percnt;\nvector<permutation> P;\n\nbool is_judge(){\n    mp.clear();\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    for(int i=2;i<=n;i++)if(out_time[i]<=out_time[i-1]) return false;\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<n;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=m;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n            if(!ok) return false;\n            if(mp.count(tmpD)) return false;\n            mp[tmpD]++;\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=n;i++) tmpans=max(tmpans,out_time[i]+(LL)dist*S[i]);\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\" : tmpans = %lld\\n\",tmpans);\n    ans=min(ans,tmpans);\n}\n\nint mark[MAXN];\nvoid DFS1(int cur){\n    if(cur>n){\n        per.a[0]=1;\n        P.push_back(per);\n        return;\n    }\n    for(int i=2;i<=5;i++)if(!mark[i]){\n        per.a[++percnt]=i;\n        mark[i]=1;\n        DFS1(cur+1);\n        percnt--;\n        mark[i]=0;\n    }\n}\n\nvoid DFS2(int curid,permutation now){\n    if(curid>=n){\n        update();\n        return;\n    }\n    int cur=now.a[curid];\n    int pre=now.a[curid-1];\n    if(cur<pre){\n        out_time[cur]=out_time[pre]-1;\n        DFS2(curid+1,now);\n        if(S[cur]<=S[pre]) return;\n        for(int i=1;i<=m+1;i++){\n            LL dt=(i==m+1) ? dist : D[i];\n            out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n            DFS2(curid+1,now);\n        }\n    }\n    if(cur>pre){\n        out_time[cur]=out_time[pre]+1;\n        DFS2(curid+1,now);\n        if(S[cur]>=S[pre]) return;\n        for(int i=1;i<=m+1;i++){\n            LL dt=(i==m+1) ? dist : D[i];\n            out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n            DFS2(curid+1,now);\n        }\n    }\n}\n\nvoid solve(){\n    out_time[1]=0LL;\n    for(int perid=0;perid<P.size();perid++){\n        permutation now=P[perid];\n        DFS2(1,now);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++) scanf(\"%d\",&D[i]);\n    for(int j=2;j<=n;j++){\n        int ok=1;\n        for(int i=1;i<j;i++) if(S[i]>S[j]) ok=0;\n        for(int k=j+1;k<=n;k++) if(S[j]>S[k]) ok=0;\n        OK[j]=ok;\n    }\n    ans=(LL)INF*INF;\n    out_time[1]=0;\n    DFS1(2);\n//    printf(\"Pcnt = %d\\n\",P.size());\n//    for(int i=0;i<P.size();i++){\n//        for(int k=1;k<=4;k++) printf(\"%d \",P[i].a[k]);\n//        printf(\"\\n\");\n//    }\n    solve();\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n    ?????????????????¨??????\n*/\n\n#define __1__\n\n#ifdef __1__\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0;i < (n);i++)\n#define _MAX 7\n#define INF 7e10\n#define MIN(a,b) (a)>(b)?(b):(a)\nusing namespace std;\ntypedef long long int lint;\n\n\nint dist,n,m;\nlint tm[_MAX][_MAX+2]; //tm[][0]?????????????????????,tm[][m+1]???????????´??????\nlint S[_MAX];\nlint D[_MAX];\n\nvoid maketm(int x){\n    rep(i,m){\n        tm[x][i+1]=tm[x][0]+D[i]*S[x];\n    }\n    tm[x][m+1]=tm[x][0]+S[x]*dist;\n    return;\n}\n\nvoid show(){\n    rep(i,n){\n        rep(j,m+2){\n            printf(\"%4lld \",tm[i][j]);\n        }\n        cout << endl;\n    }\n    cout << endl;\n    return;\n}\n\nint flag[5]={0};\n\nbool check(){\n    rep(i,n-1){\n        if(tm[i][0]>=tm[i+1][0]){\n            return false;\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            if(i<j&&tm[i][m+1]>tm[j][m+1]){\n                bool hoge = 0;\n                rep(k,m){\n                    if(tm[i][k+1]==tm[j][k+1]){\n                        rep(l,n){\n                            if(l!=i&&l!=j&&tm[i][k+1]==tm[l][k+1])\n                                return false;\n                        }\n                        hoge = true;\n                    }\n                }\n                if(hoge == 0)\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n\nlint dfs(int d){\n    lint ans = INF;\n    if(d==n){\n        if(check()){\n            return tm[n-1][m+1];\n        }else{\n            return 7e10;\n        }\n    }\n    rep(i,n){\n        if(flag[i]==1)\n            continue;\n        flag[i]=1;\n        if(i==0){\n            tm[i][0]=0;\n            maketm(i);\n            ans = min(dfs(d+1),ans);\n        }else if(flag[i-1]==1){\n            tm[i][0]=tm[i-1][0]+1;\n            maketm(i);\n            ans = min(dfs(d+1),ans);\n        }\n        rep(j,n){\n            if(j==i||flag[j]==0)\n                continue;\n            rep(k,m){\n                tm[i][0]=tm[j][k+1]-D[k]*S[i];\n                maketm(i);\n                ans = min(dfs(d+1),ans);\n            }\n            tm[i][0]=tm[j][m+1]-dist*S[i];\n            maketm(i);\n            ans = min(dfs(d+1),ans);\n        }\n        flag[i]=0;\n    }\n    return ans;\n}\n    \nint main() {\n    cin >> dist >> n;\n    rep(i,n){\n        cin >> S[i];\n    }\n    cin >> m;\n    rep(i,m){\n        cin >> D[i];\n    }\n    cout << dfs(0) << endl;\n    return 1;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nll dist,n,m;\nll S[6],D[6];\nint decide[6];\nll ans=INF*INF;\nll start[6];\n\nvoid f(int cur){\n\t//cout<<cur<<\": \";\n\t//rep(i,n)cout<<start[i]<<\" \";cout<<endl;\n\tif(cur==n){\n\t\tll res=0;\n\t\trep(i,n){\n\t\t\tres=max(res,start[i] + dist*S[i]);\n\t\t}\n\t\tans=min(ans,res);\n\t\treturn;\n\t}\n\tint target=decide[cur];\n\trep(i,cur+1)rep(j,i<cur ? m : 1){\n\t\tif(i==cur){\n\t\t\tif(start[target-1]==-1)continue;\n\t\t\tstart[target]=start[target-1]+1;\n\t\t}\n\t\telse{\n\t\t\tint car=decide[i];\n\t\t\tif(S[target] == S[car])continue;\n\t\t\tstart[target] = start[car] + D[j] * (S[car]-S[target]);\n\t\t}\n\t\t//cout<<cur<<\" start: \"<<start[target]<<endl;\n\t\t\n\t\tif(start[target]<0 ||\n\t\tstart[target-1]!=-1 && start[target] <= start[target-1] ||\n\t\tstart[target+1]!=-1 && start[target] >= start[target+1]){\n\t\t\tstart[target]=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tint ok=1;\n\t\trep(k,cur){\n\t\t\tint car=decide[k];\n\t\t\tif(S[car] == S[target])continue;\n\t\t\tll difstart = start[car]-start[target];\n\t\t\tll difS = S[target]-S[car];\n\t\t\t//cout<<k<<\" \"<<difstart<<\" \"<<difS<<endl;\n\t\t\tif(difstart == 0){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tif(difS == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart > 0 && difS < 0 || difstart < 0 && difS > 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart < 0 && difS < 0){\n\t\t\t\tdifstart*=-1;\n\t\t\t\tdifS*=-1;\n\t\t\t}\n\t\t\tif(difstart > difS * dist)continue;\n\t\t\tif(difstart % difS){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tint found=0;\n\t\t\trep(l,m)if(D[l]==dist){\n\t\t\t\tfound=1;break;\n\t\t\t}\n\t\t\tif(!found){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tf(cur+1);\n\t\t}\n\t\tstart[target]=-1;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>dist>>n;\n\trep(i,n)cin>>S[i];\n\tcin>>m;\n\trep(i,m)cin>>D[i];\n\tD[m++]=dist;\n\tsort(D,D+m);\n\t//rep(i,m)cout<<D[i]<<\" \";cout<<endl;\n\t\n\trep(i,n)decide[i]=i;\n\tmemset(start,-1,sizeof(start));\n\tstart[0]=0;\n\tdo{\n\t\t//rep(i,n)cout<<decide[i]<<\" \";cout<<endl;\n\t\tf(1);\n\t\t//cout<<endl;\n\t}while(next_permutation(decide+1,decide+n));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[uf.root(i).first] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime =uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taUnionFind auf(uf);\n\t\t\taUnionFind buf(uf);\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasfinid;\n\t\t\t\tint to = (it)->second.fstfinid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tauf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauf.unionSet((prev(it))->second.lasstaid, (it)->second.fststaid, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasstaid;\n\t\t\t\tint to = (it)->second.fststaid;\n\t\t\t\tbuf.unionSet(from, to, 1);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (buf.root((it)->second.fststaid).second > auf.root((it)->second.fststaid).second) {\n\t\t\t\tuf = buf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf = auf;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\t\n\t\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tans = min(ans,a);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\n#define fs first\n#define sc second\n\nconst ll inf = (ll)1e15;\nP par[9];\nint rank[9];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n \nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n   \n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nll dis(int a, int b){\n  if(!same(a,b))return inf;\n  return par[b].sc - par[a].sc;\n}\n\nll dist;\nint n,m;\nll s[9],d[9];\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(dis(i,j)<=0)return inf;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] <= s[v[j]])continue;\n\t  if(!same(v[i],v[j]))continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dis(v[i],v[j]))continue;\n\t  if(dis(v[i],v[j])<=0)continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dis(v[j],v[i]));\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n    \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(same(i-1,i))start[i] = start[i-1] + dis(i-1,i);\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(same(i,j)){\n\t    start[j] = start[i] + dis(i,j);\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=0;i<n;i++)res = max(res,goal[i]);\n    return res;\n  }\n  \n  ll res = inf;\n  P tp1[9],tp2[9];\n  int tr1[9],tr2[9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++){\n\ttp1[x] = par[x];\n\ttr1[x] = rank[x];\n      }\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(!unite(v[i],v[i+1],t1))continue;\n\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++){\n\t    tp2[x] = par[x];\n\t    tr2[x] = rank[x];\n\t  }\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(!unite(v[j],v[j+1],t2))continue;\n\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++){\n\t    par[x] = tp2[x];\n\t    rank[x] = tr2[x];\n\t  }\n\t}\n      }\n      swap(v[i],v[i+1]);\n     \n      for(int x=0;x<n;x++){\n\tpar[x] = tp1[x];\n\trank[x] = tr1[x];\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  init(n);\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = (ll)1e15;\n\nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n\ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(dif[i][k] == inf || dif[k][j] == inf)continue;\n\telse dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(dif[v[i]][v[j]] == inf)continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n\t  if(dif[v[i]][v[j]]<=0)continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n\n    ll goal[9],start[9];\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(v[j]<v[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(dif[j][i] != inf){\n\t    start[j] = start[i] + dif[i][j];\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n  \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n \n      int t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      wf();      \n      swap(v[i],v[i+1]);\n\n      res = min(res,rec(v,depth+1));\n\n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n\n\t  int t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n\t  dif[v[j]][v[j+1]] = t2; dif[v[j]][v[j+1]] = -t2;\n\t  wf();\n\t  swap(v[j],v[j+1]);\n\n\t  res = min(res,rec(v,depth+1));\n\n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n\t}\n      }\n\n      swap(v[i],v[i+1]);\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ ?????????????????¨??????\n// AC???????????????http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2557418#1\n// ???????????????????????????(??°???i??§a???b?????????????????????????????????)?????¨???????????????????????????????????????????????????????????§??????????????? ...@\n// https://i.imgur.com/dvAGXgE.png???????????°???????????¨?????????????????????????????°?????????????????????????????????????±??????????\n// ?????????????????????????????°?????????????????§??????????????§?????????????????????????????????????????§????????????????????????????????°???????????????????????????????????????\n// ?????????????§£??\\??????????????§??£??????????????¨????????????????????¶???????????¢????????§????£?????°???????????????£??????\ntemplate<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e17;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n  \nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    sort(hiroi.begin(), hiroi.end());\n    struct State {\n        vector<int> perm; \n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  j??????????????? - i???????????????\n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = -time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    i64 ans = INF;\n    auto calc_stime = [&](const vector<vector<i64>>& g, int start) {\n        vector<i64> start_time(n - start, INF);\n        start_time[0] = 0ll;\n        queue<int> que;\n        que.emplace(start);\n        while (!que.empty()) {\n            int cur = que.front();\n            que.pop();\n            for (int i : in(start, n)) {\n                if (g[cur][i] != INF && start_time[i - start] == INF) {\n                    start_time[i - start] = start_time[cur - start] + g[cur][i];\n                    que.emplace(i);\n                }\n            }\n        }\n        while (start_time.back() == INF) start_time.pop_back();\n        return start_time;\n    };\n    auto collison_ok = [&](const vector<vector<i64>>& adj, const vector<i64>& stime, int start) {\n        int gsize = stime.size();\n        for (int i : in(start, gsize + start)) {\n            for (int j : in(i + 1, gsize + start)) {\n                if (speed_rev[i] <= speed_rev[j]) continue;\n                if (adj[i][j] != INF) {\n                    if (stime[j - start] - stime[i - start] != adj[i][j]) return false;\n                    continue;\n                }\n                i64 collision_point = (stime[i - start] - stime[j - start]) / (speed_rev[j] - speed_rev[i]);\n                if (collision_point < goal_dist) return false;\n            }\n        }\n        return true;\n    };\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                auto stime = calc_stime(state.adj_mat, i);\n                int gsize = stime.size();\n                for (int j : in(i, gsize + i)) used[j] = true;\n                for (int j : in(i + 1, gsize + i)) if (stime[j - i - 1] >= stime[j - i]) return false;\n                if (collison_ok(state.adj_mat, stime, i) == false) return false;\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need + start_time[k] - stime[j - i]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + stime[j - i];\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        // cout << \">_<: \" << local_ans << endl;\n        // print_vec(start_time);\n        // for (auto v : state.adj_mat) print_vec(v);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[i] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime =uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taUnionFind auf(uf);\n\t\t\taUnionFind buf(uf);\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasfinid;\n\t\t\t\tint to = (it)->second.fstfinid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tauf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauf.unionSet((prev(it))->second.lasstaid, to, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasstaid;\n\t\t\t\tint to = (it)->second.fststaid;\n\t\t\t\tbuf.unionSet(from, to, 1);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (buf.root((it)->second.fststaid).second > auf.root((it)->second.fststaid).second) {\n\t\t\t\tuf = buf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf = auf;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\t\n\t\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tans = min(ans,a);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<long long int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[uf.root(i).first] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taa afrom(prev(it)->second);\n\t\t\taa ato(it->second);\n\n\t\t\tif (afrom.lasfintime - afrom.lasstatime>ato.fstfintime-ato.fststatime) {\n\t\t\t\tuf.unionSet(afrom.lasfinid, ato.fstfinid, times[afrom.lasfinid][M] - times[ato.fstfinid][M]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf.unionSet(afrom.lasstaid, ato.fststaid, 1);\n\t\t\t}\n\t\t\t/*aUnionFind auf(uf);\n\t\t\taUnionFind buf(uf);\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasfinid;\n\t\t\t\tint to = (it)->second.fstfinid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tauf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauf.unionSet((prev(it))->second.lasstaid, (it)->second.fststaid, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasstaid;\n\t\t\t\tint to = (it)->second.fststaid;\n\t\t\t\tbuf.unionSet(from, to, 1);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (buf.root((it)->second.fststaid).second > auf.root((it)->second.fststaid).second) {\n\t\t\t\tuf = buf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf = auf;\n\t\t\t}*/\n\t\t}\n\t}\n\tfor (int i = 0; i < HorseNum - 1; ++i) {\n\t\tif (uf.root(i).second >= uf.root(i + 1).second)return My_LInf;\n\t}\n\tfor (int i = 0; i < HorseNum - 1; ++i) {\n\t\tif (uf.root(seq[i]).second+times[seq[i]][M] > uf.root(seq[i + 1]).second + times[seq[i+1]][M])return My_LInf;\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\taUnionFind uu(10);\n\tuu.unionSet(0, 1, 3);\n\tuu.unionSet(0, 2, 4);\n\tuu.unionSet(2, 4, 5);\n\tuu.unionSet(6, 7, 1);\n\tuu.unionSet(7, 8, 2);\n\tuu.unionSet(0, 8, 0);\n\t\n\t\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tsort(ds.begin(), ds.end());\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tif (a < ans) {\n\t\t\tans = a;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<long long int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[uf.root(i).first] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taa afrom(prev(it)->second);\n\t\t\taa ato(it->second);\n\n\t\t\tif (afrom.lasfintime - afrom.lasstatime>ato.fstfintime-ato.fststatime) {\n\t\t\t\tuf.unionSet(afrom.lasfinid, ato.fstfinid, times[afrom.lasfinid][M] - times[ato.fstfinid][M]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf.unionSet(afrom.lasstaid, ato.fststaid, 1);\n\t\t\t}\n\t\t\t/*aUnionFind auf(uf);\n\t\t\taUnionFind buf(uf);\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasfinid;\n\t\t\t\tint to = (it)->second.fstfinid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tauf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauf.unionSet((prev(it))->second.lasstaid, (it)->second.fststaid, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasstaid;\n\t\t\t\tint to = (it)->second.fststaid;\n\t\t\t\tbuf.unionSet(from, to, 1);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (buf.root((it)->second.fststaid).second > auf.root((it)->second.fststaid).second) {\n\t\t\t\tuf = buf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf = auf;\n\t\t\t}*/\n\t\t}\n\t}\n\tfor (int i = 0; i < HorseNum - 1; ++i) {\n\t\tif (uf.root(i).second >= uf.root(i + 1).second)return My_LInf;\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\t\n\t\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tans = min(ans,a);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e17;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n\nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm; // ??´??????????????????\n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  j??????????????? - i??????????????? INF???????????? \n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    // ????§??????????????????????\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    // ???????????????????????????????£??????????\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = -time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    // ?????????????????????????????£?????§????????§??????????????????????§??????????\n    i64 ans = INF;\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            auto g = state.adj_mat;\n            for (int k : in(n)) {\n                for (int i : in(n)) {\n                    for (int j : in(n)) {\n                        if (g[i][k] == INF || g[k][j] == INF)\n                            continue;\n                        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n                    }\n                }\n            }\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                int gsize = 1;\n                // ??£?????????????????£?¶???????????????????\n                for (int j : in(i + 1, n))\n                    if (g[i][j] != INF)\n                        gsize++, used[j] = 1;\n                for (int j : in(i + 1, gsize + i))\n                    if (g[i][j - 1] >= g[i][j])\n                        return false;\n                // ????§???????????????´??????\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need + start_time[k] - g[i][j]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + g[i][j];\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = (ll)1e15;\n\nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n\ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tdif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    /*\n    if(v[0] == 1 && v[1] == 3 && v[2] == 2 && v[3] == 0 && v[4] == 4){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n\tcout << endl;\n      }\n    }\n    */\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(dif[v[i]][v[j]] == inf)continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n\t  if(dif[v[i]][v[j]]<0)continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n\n    ll goal[9],start[9];\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(v[j]<v[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(dif[j][i] != inf){\n\t    start[j] = start[i] - dif[i][j];\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    \n    //for(int i=0;i<n;i++)cout << v[i] << \" \";\n    //cout << endl;\n    /*\n    cout << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n  \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n \n      int t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = dif[v[i+1]][v[i]] = t1;\n      wf();      \n      swap(v[i],v[i+1]);\n\n      res = min(res,rec(v,depth+1));\n\n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n\n\t  int t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n\t  dif[v[j]][v[j+1]] = dif[v[j+1]][v[j]] = t2;\n\t  wf();\n\t  swap(v[j],v[j+1]);\n\n\t  res = min(res,rec(v,depth+1));\n\n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n\t}\n      }\n\n      swap(v[i],v[i+1]);\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\n#define fs first\n#define sc second\n\nconst ll inf = (ll)1e15;\nP par[9];\nint rank[9];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n \nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n   \n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nll dis(int a, int b){\n  if(!same(a,b))return inf;\n  return par[b].sc - par[a].sc;\n}\n\nll dist;\nint n,m;\nll s[9],d[9];\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(dis(i,j)<=0)return inf;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(!same(v[i],v[j]))continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dis(v[i],v[j]))continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dis(v[j],v[i]));\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n    \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(same(i-1,i))start[i] = start[i-1] + dis(i-1,i);\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(same(i,j)){\n\t    start[j] = start[i] + dis(i,j);\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++)res = max(res,goal[i]);\n    return res;\n  }\n  \n  ll res = inf;\n  P tp1[9],tp2[9];\n  int tr1[9],tr2[9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++){\n\ttp1[x] = par[x];\n\ttr1[x] = rank[x];\n      }\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(!unite(v[i],v[i+1],t1))continue;\n\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++){\n\t    tp2[x] = par[x];\n\t    tr2[x] = rank[x];\n\t  }\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(!unite(v[j],v[j+1],t2))continue;\n\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++){\n\t    par[x] = tp2[x];\n\t    rank[x] = tr2[x];\n\t  }\n\t}\n      }\n      swap(v[i],v[i+1]);\n     \n      for(int x=0;x<n;x++){\n\tpar[x] = tp1[x];\n\trank[x] = tr1[x];\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  init(n);\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint n,m;\nint S[MAXN];\nint D[MAXN];\nvector<pair<int,LL> > t[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,int> mp;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=n;i++)if(out_time[i]<=out_time[i-1]) return false;\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<n;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=m;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n            if(!ok) return false;\n            if(mp.count(tmpD)) return false;\n            mp[tmpD]++;\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=n;i++) tmpans=max(tmpans,out_time[i]+(LL)dist*S[i]);\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\" : tmpans = %lld\\n\",tmpans);\n    ans=min(ans,tmpans);\n}\n\nvoid DFS(int cur){\n    if(cur>n){\n        update();\n        return;\n    }\n    for(int i=0;i<t[cur].size();i++){\n        int pre=t[cur][i].first;\n        int dt=t[cur][i].second;\n        out_time[cur]=out_time[pre]+dt;\n        DFS(cur+1);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++) scanf(\"%d\",&D[i]);\n    for(int j=2;j<=n;j++){\n        t[j].push_back(make_pair(j-1,1));\n        for(int i=1;i<j;i++){\n            if(S[j]<S[i]){\n                for(int k=1;k<=m+1;k++){\n                    LL delta=(k==m+1) ? dist : D[k];\n                    t[j].push_back(make_pair(i,delta*(S[i]-S[j])));\n                }\n            }\n        }\n    }\n    ans=(LL)INF*INF;\n    out_time[1]=0;\n    DFS(2);\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, intr;\nvector<LL> D;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\n\tvector<vector<int> > odr(m + 1, vector<int>(n));\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\t\n\tint cnt = 0;\n\tfor(int j = 0; j < m; ++j){\n\t\todr[j + 1] = odr[j];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i + 1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j + 1][i], odr[j + 1][i + 1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] != -1LL) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] == -1LL && stm[b] != -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[j] * (S[b] - S[a]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] != -1LL && stm[b] == -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[j] * (S[a] - S[b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] != -1LL; ++j)\n\t\tfor(int k = j + 1; stm[k] != -1LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(y >= n - 1 || odr[x][y+1] != k ||\n\t\t\t  odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tfor(int j = i; j < u; ++j){\n\t\t\tif(stm[j] >= stm[j + 1]){ return; }\n\t\t}\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\tif(cnt != 0) return;\n\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr.resize(m);\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n \ntypedef long long ll;\n \nconst ll inf = (ll)1e15;\n \nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n \ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n    if(dif[i][k]!=inf && dif[k][j]!=inf && i!=j)\n      dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n \n \nll rec(vector<int> v, int depth){\n  if(depth == m){\n    ll tmp[9][9];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)tmp[i][j] = dif[i][j];\n \n    wf();\n \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n    if(tmp[i][j]!=inf && dif[i][j] != tmp[i][j])return inf;\n    if(i<=j && dif[i][j]<0)return inf;\n      }\n    /*\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)dif[i][j] = tmp[i][j];\n     \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++)\n      if(dif[i][k]!=inf && dif[k][j]!=inf)\n        dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n    */\n \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n    if(v[i]<v[j]){\n      if(s[v[i]] < s[v[j]])continue;\n      if(dif[v[i]][v[j]] == inf)continue;\n      if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n      if(dif[v[i]][v[j]]<=0)continue;\n      return inf;\n    }else{\n      bool f = false;\n      for(int k=0;k<m;k++){\n        f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n      }\n      if(!f)return inf;\n    }\n      }\n    }\n \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n \n    for(int i=0;i<n;i++){\n      if(!i){\n    start[i] = 0;\n    goal[i] = s[i]*dist;\n      }else{\n    if(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n    else start[i] = start[i-1] + 1;\n    goal[i] = start[i] + s[i]*dist;\n    for(int j=0;j<i;j++){\n      if(pos[j]<pos[i] && goal[j]>goal[i]){\n        start[i] += goal[j]-goal[i];\n        goal[i] = goal[j];\n      }\n    }\n    for(int j=0;j<i;j++){\n      if(dif[j][i] != inf){\n        start[j] = start[i] - dif[j][i];\n        goal[j] = start[j] + s[j]*dist;\n      }\n    }\n      }\n      /*\n      for(int j=0;j<=i;j++){\n    cout << start[j] << \" \" << goal[j] << endl;\n      }\n      cout << \"----------------------\" << endl;\n      */\n    }\n     \n    ll res = 0;\n/*\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n*/\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl;\n \n    cout << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n   \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n \n  res = min(res,rec(v,depth+1));\n \n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n    for(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n  \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      //if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      //wf();\n      swap(v[i],v[i+1]);\n       \n      res = min(res,rec(v,depth+1));\n       \n      for(int j=i+2;j<n-1;j++){\n    if(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n      for(int x=0;x<n;x++)\n        for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n       \n      ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n      //if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n      dif[v[j]][v[j+1]] = t2; dif[v[j+1]][v[j]] = -t2;\n      //wf();\n      swap(v[j],v[j+1]);\n       \n      res = min(res,rec(v,depth+1));\n       \n      swap(v[j],v[j+1]);\n      for(int x=0;x<n;x++)\n        for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n    }\n    swap(v[i],v[i+1]);\n      }\n      for(int x=0;x<n;x++)\n    for(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n \nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n \n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e17;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n \nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    sort(hiroi.begin(), hiroi.end());\n    struct State {\n        vector<int> perm; // \n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  |j????????????????????? - i?????????????????????|\n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = -time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    i64 ans = INF;\n    auto calc_stime = [&](const vector<vector<i64>>& g, int start) {\n        vector<i64> start_time(n - start, INF);\n        start_time[0] = 0ll;\n        queue<int> que;\n        que.emplace(start);\n        while (!que.empty()) {\n            int cur = que.front();\n            que.pop();\n            for (int i : in(start, n)) {\n                if (g[cur][i] != INF && start_time[i - start] == INF) {\n                    start_time[i - start] = start_time[cur - start] + g[cur][i];\n                    que.emplace(i);\n                }\n            }\n        }\n        while (start_time.back() == INF) start_time.pop_back();\n        return start_time;\n    };\n    auto collison_check = [&](const vector<vector<i64>>& adj, const vector<i64>& stime) {\n        for (int i : in(n)) {\n            for (int j : in(i)) {\n                if (adj[i][j] != INF) continue;\n                if (speed_rev[j] <=  speed_rev[i]) continue;\n                i64 collision_point = (stime[i] - stime[j]) / (speed_rev[j] - speed_rev[i]);\n                if (collision_point < goal_dist) return true;\n            }\n        }\n        return false;\n    };\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                auto stime = calc_stime(state.adj_mat, i);\n                int gsize = stime.size();\n                for (int j : in(i, gsize + i)) used[j] = true;\n                for (int j : in(i + 1, gsize + i)) if (stime[j - i - 1] >= stime[j - i]) return false;\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need + start_time[k] - stime[j - i]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + stime[j - i];\n            }\n            return collison_check(state.adj_mat, start_time) == false;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n        //   print_vec(start_time);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e17;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n \nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm; // \n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  |j????????????????????? - i?????????????????????|\n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = -time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    i64 ans = INF;\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            auto g = state.adj_mat;\n            for (int k : in(n)) \n                for (int i : in(n)) \n                    for (int j : in(n)) \n                        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                int gsize = 1;\n                for (int j : in(i + 1, n))\n                    if (g[i][j] != INF)\n                        gsize++, used[j] = 1;\n                for (int j : in(i + 1, gsize + i))\n                    if (g[i][j - 1] >= g[i][j])\n                        return false;\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need + start_time[k] - g[i][j]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + g[i][j];\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long p[10];\nlong long q[10];\nstruct wolf{\n\tint p[5];\n\twolf(){}\n};\nwolf now[6];\nint N,M;\nint rev[10][10];\nint perm[10][10];\nlong long INF=9999999999999999LL;\nlong long t[10][10];\nlong long dfs(int a){\n\tif(a==M){\n\t\tfor(int i=0;i<=M+1;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tt[i][j]=j+p[j]*q[i];\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool chg=false;\n\t\t\tfor(int i=0;i<=M;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tfor(int k=j+1;k<N;k++){\n\t\t\t\t\t\tif(t[i][now[i].p[j]]+p[now[i].p[j]]*(q[i+1]-q[i])>t[i][now[i].p[k]]+p[now[i].p[k]]*(q[i+1]-q[i])){\n\t\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\t\tt[i][now[i].p[k]]=t[i][now[i].p[j]]+p[now[i].p[j]]*(q[i+1]-q[i])-p[now[i].p[k]]*(q[i+1]-q[i]);\n\t\t\t\t\t\t\tfor(int l=0;l<=M+1;l++)t[l][now[i].p[k]]=t[i][now[i].p[k]]+p[now[i].p[k]]*(q[l]-q[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(t[i][now[i].p[j]]>t[i][now[i].p[k]]){\n\t\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\t\tt[i][now[i].p[k]]=t[i][now[i].p[j]];\n\t\t\t\t\t\t\tfor(int l=0;l<=M+1;l++)t[l][now[i].p[k]]=t[i][now[i].p[k]]+p[now[i].p[k]]*(q[l]-q[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==0&&t[i][now[i].p[j]]>=t[i][now[i].p[k]]){\n\t\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\t\tfor(int l=0;l<=M+1;l++)t[l][now[i].p[k]]=t[i][now[i].p[j]]+1+p[now[i].p[k]]*(q[l]-q[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t/*\tfor(int i=1;i<=M+1;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tif(t[i][j]<t[i-1][j]+p[j]*(q[i]-q[i-1])){\n\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\tt[i][j]=t[i-1][j]+p[j]*(q[i]-q[i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tif(!chg)break;\n\t\t}\n\t\tlong long ret=0;\n\t\tfor(int i=0;i<N;i++)ret=max(ret,t[M+1][i]);\n\t\t/*if(ret==382){\n\t\t\tfor(int i=0;i<=M;i++){\n\t\t\t\tfor(int j=0;j<N;j++)printf(\"%d \",now[i].p[j]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tfor(int i=0;i<=M+1;i++){\n\t\t\t\tfor(int j=0;j<N;j++)printf(\"%lld \",t[i][j]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}*/\n\t\treturn ret;\n\t}\n\tlong long ret=INF;\n\tfor(int i=0;i<N;i++){\n\t\tperm[a][i]=i;\n\t\trev[a][now[a].p[i]]=i;\n\t}\n\tdo{\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(rev[a][perm[a][i]]>i+1)ok=false;\n\t\t\tif(rev[a][perm[a][i]]<i-1)ok=false;\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tif(rev[a][perm[a][i]]>rev[a][perm[a][j]]&&p[perm[a][i]]>=p[perm[a][j]])ok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int i=0;i<N;i++)now[a+1].p[i]=perm[a][i];\n\t\t\tret=min(ret,dfs(a+1));\n\t\t}\n\t}while(next_permutation(perm[a],perm[a]+N));\n\treturn ret;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++)scanf(\"%lld\",p+i);\n\tscanf(\"%d\",&c);\n\tN=b;M=c;\n\tfor(int i=0;i<c;i++)scanf(\"%lld\",q+i+1);\n\tstd::sort(q,q+c+1);\n\tq[c+1]=a;\n\tfor(int i=0;i<b;i++){\n\t\tnow[0].p[i]=i;\n\t}\n\tprintf(\"%lld\\n\",dfs(0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, D, intr;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\t\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tp[i] = i;\n\t}\n\n\tvector<vector<int> > odr(m + 1);\n\todr[0].resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\tfor(int j = 1; j <= m; ++j){\n\t\todr[j] = odr[j - 1];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j-1] >> i & 1){\n\t\t\t\tint a = odr[j][i], b = odr[j][i+1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j][i], odr[j][i+1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] >= 0) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] < 0LL && stm[b] >= 0LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[k] * (S[b] - S[a]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] >= 0LL && stm[b] < 0LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[k] * (S[a] - S[b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] >= 0LL; ++j)\n\t\tfor(int k = j + 1; stm[k] >= 0LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = S[j] * S[k] * (stm[k] - stm[j]) / (S[k] - S[j]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif(S[j] * S[k] * (stm[k] - stm[j]) % (S[k] - S[j]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = lower_bound(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\t\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\ttry{\n\t\t\tcalcans();\n\t\t}\n\t\tcatch(...){}\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr = D;\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 5\n\nint N,M;\nll DIST,ans;\nll start_time[NUM];\nll unit_time[NUM],loc[NUM];\n\nll goal_time(int car_id){\n\n\treturn start_time[car_id]+unit_time[car_id]*DIST;\n}\n\nvoid recursive(int car_id){\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(start_time[i] == -1)continue;\n\n\t\tif(goal_time(i) >= ans){\n\t\t\treturn;\n\t\t}\n\t}\n\n\tll pre = 0;\n\n\tfor(int i = 1; i < N; i++){\n\t\tif(start_time[i] == -1)continue;\n\n\t\tif(start_time[i] <= pre){\n\t\t\treturn;\n\t\t}\n\n\t\tpre = start_time[i];\n\t}\n\n\tif(car_id == N){\n\n\t\tbool FLG;\n\n\t\tvector<ll> V[NUM];\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tif(goal_time(i) <= goal_time(k))continue;\n\n\t\t\t\tFLG = false;\n\n\t\t\t\tfor(int a = 0; a < M; a++){\n\t\t\t\t\tif(start_time[i]+unit_time[i]*loc[a] == start_time[k]+unit_time[k]*loc[a]){\n\t\t\t\t\t\tV[a].push_back(start_time[i]+unit_time[i]*loc[a]);\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(!FLG)return;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(V[i].size() <= 1)continue;\n\n\t\t\tfor(int a = 0; a < V[i].size()-1; a++){\n\t\t\t\tfor(int b = a+1; b < V[i].size(); b++){\n\t\t\t\t\tif(V[i][a] == V[i][b]){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll tmp_ans = -1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ttmp_ans = max(tmp_ans,goal_time(i));\n\t\t}\n\n\t\tans = min(ans,tmp_ans);\n\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\n\t\tif(start_time[i] != -1 && start_time[i+1] == -1){\n\n\t\t\tstart_time[i+1] = start_time[i]+1;\n\t\t\trecursive(car_id+1);\n\t\t\tstart_time[i+1] = -1;\n\t\t}\n\n\t\tif(start_time[i] == -1 && start_time[i+1] != -1){\n\n\t\t\tstart_time[i] = start_time[i+1]-1;\n\t\t\trecursive(car_id+1);\n\t\t\tstart_time[i] = -1;\n\t\t}\n\t}\n\n\tfor(int i = 1; i < N; i++){\n\t\tif(start_time[i] != -1)continue;\n\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(k == i || start_time[k] == -1 || (k < i && unit_time[k] <= unit_time[i]) || (i < k && unit_time[i] <= unit_time[k]))continue;\n\n\t\t\tfor(int a = 0; a < M; a++){\n\n\t\t\t\tstart_time[i] = start_time[k]+(unit_time[k]-unit_time[i])*loc[a];\n\t\t\t\trecursive(car_id+1);\n\t\t\t\tstart_time[i] = -1;\n\t\t\t}\n\t\t\tstart_time[i] = start_time[k]+(unit_time[k]-unit_time[i])*DIST;\n\t\t\trecursive(car_id+1);\n\t\t\tstart_time[i] = -1;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%lld\",&DIST);\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&unit_time[i]);\n\t}\n\n\tscanf(\"%d\",&M);\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%lld\",&loc[i]);\n\t}\n\n\tif(N == 1){\n\n\t\tprintf(\"%lld\\n\",unit_time[0]*DIST);\n\t\treturn 0;\n\t}\n\n\tstart_time[0] = 0;\n\n\tfor(int i = 1; i < N; i++){\n\t\tstart_time[i] = -1;\n\t}\n\n\tans = HUGE_NUM;\n\n\trecursive(1);\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nll dist,n,m;\nll S[6],D[6];\nint decide[6];\nll ans;\nll start[6];\n\nvoid f(int cur){\n\t//cout<<cur<<\": \";\n\t//rep(i,n)cout<<start[i]<<\" \";cout<<endl;\n\tif(cur==n){\n\t\t//rep(i,n)cout<<start[i]<<\" \";cout<<endl;\n\t\tll res=0;\n\t\trep(i,n){\n\t\t\tres=max(res,start[i] + dist*S[i]);\n\t\t}\n\t\tans=min(ans,res);\n\t\treturn;\n\t}\n\tint target=decide[cur];\n\trep(i,cur+1)rep(j,i<cur ? m : 1){\n\t\tif(i==cur){\n\t\t\tif(start[target-1]==-1)continue;\n\t\t\tstart[target]=start[target-1]+1;\n\t\t}\n\t\telse{\n\t\t\tint car=decide[i];\n\t\t\tif(S[target] == S[car])continue;\n\t\t\tstart[target] = start[car] + D[j] * (S[car]-S[target]);\n\t\t}\n\t\t//cout<<cur<<\" start: \"<<start[target]<<endl;\n\t\t\n\t\tif(start[target]<0){\n\t\t\tstart[target]=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tint ok=1;\n\t\trep(k,cur){\n\t\t\tint car=decide[k];\n\t\t\tif(car < target && start[target] <= start[car]\n\t\t\t|| car > target && start[target] >= start[car]){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tll difstart = start[car]-start[target];\n\t\t\tll difS = S[target]-S[car];\n\t\t\t//cout<<k<<\" \"<<difstart<<\" \"<<difS<<endl;\n\t\t\tif(difS == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart > 0 && difS < 0 || difstart < 0 && difS > 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(difstart < 0 && difS < 0){\n\t\t\t\tdifstart*=-1;\n\t\t\t\tdifS*=-1;\n\t\t\t}\n\t\t\tif(difstart > difS * dist)continue;\n\t\t\tif(difstart % difS){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tll point = difstart/difS;\n\t\t\tint found=0;\n\t\t\trep(l,m)if(D[l]==point){\n\t\t\t\tfound=1;break;\n\t\t\t}\n\t\t\tif(!found){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tf(cur+1);\n\t\t}\n\t\tstart[target]=-1;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>dist>>n;\n\trep(i,n)cin>>S[i];\n\tcin>>m;\n\trep(i,m)cin>>D[i];\n\tD[m++]=dist;\n\tsort(D,D+m);\n\t//rep(i,m)cout<<D[i]<<\" \";cout<<endl;\n\t\n\trep(i,n)decide[i]=i;\n\tmemset(start,-1,sizeof(start));\n\tstart[0]=0;\n\tans=INF*INF;\n\tdo{\n\t\t//rep(i,n)cout<<decide[i]<<\" \";cout<<endl;\n\t\tf(1);\n\t\t//cout<<endl;\n\t}while(next_permutation(decide+1,decide+n));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[i] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime =uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taUnionFind auf(uf);\n\t\t\taUnionFind buf(uf);\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasfinid;\n\t\t\t\tint to = (it)->second.fstfinid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tauf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauf.unionSet(from, to, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasstaid;\n\t\t\t\tint to = (it)->second.fststaid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tbuf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.unionSet(from, to, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (buf.root((it)->second.fststaid).second > auf.root((it)->second.fststaid).second) {\n\t\t\t\tuf = buf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf = auf;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\t\n\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tans = min(ans,a);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<LL> S, D, intr;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\t\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tp[i] = i;\n\t}\n\n\tvector<vector<int> > odr(m + 1);\n\todr[0].resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\t\n\tint cnt = 0;\n\tfor(int j = 0; j < m; ++j){\n\t\todr[j + 1] = odr[j];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i + 1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j + 1][i], odr[j + 1][i + 1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] >= 0) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] == -1LL && stm[b] != -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[j] * (S[b] - S[a]);\n\t\t\t\t\t\tif(stm[a] >= stm[b]) while(1);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] != -1LL && stm[b] == -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[j] * (S[a] - S[b]);\n\t\t\t\t\t\tif(stm[a] >= stm[b]) throw 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] >= 0LL; ++j)\n\t\tfor(int k = j + 1; stm[k] >= 0LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\n\tif(cnt != 0) return;\n\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr = D;\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<map>\nusing namespace std;\nconst int MAXN = (int) 105;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint dist;\nint M,N;\nint S[MAXN];\nint D[MAXN];\nLL ans;\nLL out_time[MAXN];\nmap<LL,int> mp;\nstruct permutation{\n    int a[10];\n}per;\nint percnt;\nvector<permutation> P;\n\nbool is_judge(){\n    mp.clear();\n    for(int i=2;i<=N;i++)if(out_time[i]<=out_time[i-1]) return false;\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    for(int i=1;i<=N;i++){\n        for(int j=i+1;j<N;j++){\n            if(S[i]<=S[j]) continue;\n            if((out_time[j]-out_time[i])/(S[i]-S[j])>=dist) continue;\n            if((out_time[j]-out_time[i])%(S[i]-S[j])!=0) return false;\n            int tmpD=(out_time[j]-out_time[i])/(S[i]-S[j]);\n            int ok=0;\n            for(int k=1;k<=M;k++){\n                if(D[k]==tmpD) ok=1;\n            }\n            if(!ok) return false;\n            if(mp.count(tmpD)) return false;\n            mp[tmpD]++;\n        }\n    }\n    return true;\n}\n\nvoid update(){\n    for(int i=N;i>=1;i--) out_time[i]-=out_time[1];\n//    for(int i=1;i<N;i++)if(out_time[i]>=out_time[i+1]) return;\n//    for(int i=1;i<=N;i++) printf(\"%lld \",out_time[i]);\n//    printf(\"\\n\");\n    if(!is_judge()) return;\n    LL tmpans=0;\n    for(int i=1;i<=N;i++){\n        LL tmp=out_time[i]+(LL)dist*S[i];\n        tmpans=max(tmpans,tmp);\n    }\n//    for(int i=1;i<=n;i++) printf(\"%lld \",out_time[i]);\n//    printf(\" : tmpans = %lld\\n\",tmpans);\n    ans=min(ans,tmpans);\n}\n\nint mark[MAXN];\nvoid DFS1(int cur){\n    if(cur>N){\n        per.a[0]=1;\n        P.push_back(per);\n        return;\n    }\n    for(int i=1;i<=N;i++)if(!mark[i]){\n        per.a[++percnt]=i;\n        mark[i]=1;\n        DFS1(cur+1);\n        percnt--;\n        mark[i]=0;\n    }\n}\n\nvoid DFS2(int curid,permutation now){\n    if(curid>N){\n        update();\n        return;\n    }\n    int cur=now.a[curid];\n    if(curid==1){\n        out_time[cur]=0;\n        DFS2(curid+1,now);\n        return;\n    }\n\n    for(int t=1;t<curid;t++){\n        int pre=now.a[t];\n        if(cur<pre){\n            out_time[cur]=out_time[pre]-1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=M;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]-dt*(S[cur]-S[pre]);\n    //            printf(\"%d-%d : %lld->%lld\\n\",pre,cur,out_time[pre],out_time[cur]);\n                DFS2(curid+1,now);\n            }\n        }\n        if(cur>pre){\n            out_time[cur]=out_time[pre]+1;\n            DFS2(curid+1,now);\n            for(int i=1;i<=M;i++){\n                LL dt=D[i];\n                out_time[cur]=out_time[pre]+dt*(S[pre]-S[cur]);\n    //            printf(\"%d-%d : %lld->%lld\\n\",pre,cur,out_time[pre],out_time[cur]);\n                DFS2(curid+1,now);\n            }\n        }\n    }\n}\n\nvoid solve(){\n    for(int perid=0;perid<P.size();perid++){\n        permutation now=P[perid];\n        DFS2(1,now);\n    }\n}\n\nvoid work(){\n    scanf(\"%d%d\",&dist,&N);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&S[i]);\n    scanf(\"%d\",&M);\n    for(int i=1;i<=M;i++) scanf(\"%d\",&D[i]);\n    D[++M]=dist;\n    ans=(LL)INF*INF;\n    DFS1(1);\n//    printf(\"Pcnt = %d\\n\",P.size());\n//    for(int i=0;i<P.size();i++){\n//        for(int k=1;k<=n;k++) printf(\"%d \",P[i].a[k]);\n//        printf(\"\\n\");\n//    }\n    solve();\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n/*\n60516263\n5\n45\n16\n94\n71\n91\n4\n20586550\n54017689\n36941264\n49153094\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, D, intr;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\t\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tp[i] = i;\n\t}\n\n\tvector<vector<int> > odr(m + 1);\n\todr[0].resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\n\tint cnt = 0;\n\tfor(int j = 1; j <= m; ++j){\n\t\todr[j] = odr[j - 1];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j-1] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i+1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j][i], odr[j][i+1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] >= 0) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] < 0LL && stm[b] >= 0LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[k] * (S[b] - S[a]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] >= 0LL && stm[b] < 0LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[k] * (S[a] - S[b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] >= 0LL; ++j)\n\t\tfor(int k = j + 1; stm[k] >= 0LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\tif(cnt != 0) return;\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\t\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr = D;\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = (ll)1e15;\n\nll dist;\nint n,m;\nll s[9],d[9];\nll dif[9][9];\n\ninline void wf(void){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(dif[i][k]!=inf && dif[k][j]!=inf && i!=j)\n\t  dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n}\n\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    /*\n    ll tmp[9][9];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)tmp[i][j] = dif[i][j];\n    */\n\n    wf();\n    for(int i=0;i<n;i++)\n      for(int j=i;j<n;j++)if(dif[i][j]<0)return inf;\n    /*\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)dif[i][j] = tmp[i][j];\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=i+1;j<n;j++)\n\t  if(dif[i][k]!=inf && dif[k][j]!=inf)\n\t    dif[i][j] = min(dif[i][j],dif[i][k] + dif[k][j]);\n    */\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] < s[v[j]])continue;\n\t  if(dif[v[i]][v[j]] == inf)continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dif[v[i]][v[j]])continue;\n\t  if(dif[v[i]][v[j]]<0)continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dif[v[j]][v[i]]);\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n\n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(dif[i-1][i] != inf)start[i] = start[i-1] + dif[i-1][i];\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(dif[j][i] != inf){\n\t    start[j] = start[i] - dif[j][i];\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n      /*\n      for(int j=0;j<=i;j++){\n\tcout << start[j] << \" \" << goal[j] << endl;\n      }\n      cout << \"----------------------\" << endl;\n      */\n    }\n    \n    ll res = 0;\n    for(int i=n-1;i>=0;i--){\n      goal[i] -= start[0];\n      start[i] -= start[0];\n    }\n    for(int i=0;i<n;i++){\n      //cout << start[i] << \" \" << goal[i] << endl;\n      res = max(res,goal[i]);\n    }\n    /*\n    for(int i=0;i<n;i++)cout << v[i] << \" \";\n    cout << endl;\n\n    cout << \"----------\" << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << dif[i][j] << \" \";\n      cout << endl;\n    }\n    cout << \"----------\" << endl;\n    */\n    return res;\n  }\n  \n  ll res = inf;\n  ll tmp1[9][9],tmp2[9][9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)tmp1[x][y] = dif[x][y];\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      //if(dif[v[i]][v[i+1]] != inf && dif[v[i]][v[i+1]] != t1)continue;\n      dif[v[i]][v[i+1]] = t1; dif[v[i+1]][v[i]] = -t1;\n      //wf();\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)tmp2[x][y] = dif[x][y];\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  //if(dif[v[j]][v[j+1]] != inf && dif[v[j]][v[j+1]] != t2)continue;\n\t  dif[v[j]][v[j+1]] = t2; dif[v[j+1]][v[j]] = -t2;\n\t  //wf();\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++)\n\t    for(int y=0;y<n;y++)dif[x][y] = tmp2[x][y];\n\t}\n\tswap(v[i],v[i+1]);\n      }\n      for(int x=0;x<n;x++)\n\tfor(int y=0;y<n;y++)dif[x][y] = tmp1[x][y];\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i==j)dif[i][j] = 0;\n      else dif[i][j] = inf;\n\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e18;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n\nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm; // ??´??????????????????\n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  j??????????????? - i??????????????? INF???????????? \n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    // ????§??????????????????????\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    // ???????????????????????????????£??????????\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = -time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    // ?????????????????????????????£?????§????????§??????????????????????§??????????\n    i64 ans = INF;\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            auto g = state.adj_mat;\n            for (int k : in(n)) {\n                for (int i : in(n)) {\n                    for (int j : in(n)) {\n                        // if (g[i][k] == INF || g[k][j] == INF)\n                        //     continue;\n                        // if (g[i][j] == INF)\n                        //     g[i][j] = g[i][k] + g[k][j];\n                        // else if (g[i][j] != g[i][k] + g[k][j])\n                        //     exit(1);\n                        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n                    }\n                }\n            }\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                int gsize = 1;\n                // ??£?????????????????£?¶???????????????????\n                for (int j : in(i + 1, n))\n                    if (g[i][j] != INF)\n                        gsize++, used[j] = 1;\n                for (int j : in(i + 1, gsize + i))\n                    if (g[i][j - 1] >= g[i][j])\n                        return false;\n                // ????§???????????????´??????\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need + start_time[k] - g[i][j]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + g[i][j];\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, intr;\nvector<LL> D;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\n\tvector<vector<int> > odr(m + 1, vector<int>(n));\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\t\n\tint cnt = 0;\n\tfor(int j = 0; j < m; ++j){\n\t\todr[j + 1] = odr[j];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i + 1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j + 1][i], odr[j + 1][i + 1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] != -1LL) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] == -1LL && stm[b] != -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[j] * (S[b] - S[a]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] != -1LL && stm[b] == -1LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[j] * (S[a] - S[b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] != -1LL; ++j)\n\t\tfor(int k = j + 1; stm[k] != -1LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\n\tif(cnt != 0) return;\n\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr.resize(m);\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\n#define fs first\n#define sc second\n\nconst ll inf = (ll)1e15;\nP par[9];\nint rank[9];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n \nbool unite(int a,int b,ll cost){\n  P x = find(a);\n  P y = find(b);\n   \n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nll dis(int a, int b){\n  if(!same(a,b))return inf;\n  return par[b].sc - par[a].sc;\n}\n\nll dist;\nint n,m;\nll s[9],d[9];\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(dis(i,j)<=0)return inf;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] <= s[v[j]])continue;\n\t  if(!same(v[i],v[j]))continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dis(v[i],v[j]))continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++)f |= (d[k]*(s[v[j]] - s[v[i]]) == dis(v[j],v[i]));\n\t  if(!f)return inf;\n\t}\n      }\n    }\n    \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(same(i-1,i))start[i] = start[i-1] + dis(i-1,i);\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(same(i,j)){\n\t    start[j] = start[i] + dis(i,j);\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=0;i<n;i++)res = max(res,goal[i]);\n    return res;\n  }\n  \n  ll res = inf;\n  P tp1[9],tp2[9];\n  int tr1[9],tr2[9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++){\n\ttp1[x] = par[x];\n\ttr1[x] = rank[x];\n      }\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(!unite(v[i],v[i+1],t1))continue;\n\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++){\n\t    tp2[x] = par[x];\n\t    tr2[x] = rank[x];\n\t  }\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(!unite(v[j],v[j+1],t2))continue;\n\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++){\n\t    par[x] = tp2[x];\n\t    rank[x] = tr2[x];\n\t  }\n\t}\n      }\n      swap(v[i],v[i+1]);\n     \n      for(int x=0;x<n;x++){\n\tpar[x] = tp1[x];\n\trank[x] = tr1[x];\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  init(n);\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long p[10];\nlong long q[10];\nstruct wolf{\n\tint p[5];\n\twolf(){}\n};\nwolf now[6];\nint N,M;\nint rev[10][10];\nint perm[10][10];\nlong long INF=9999999999999999LL;\nlong long t[10][10];\nlong long dfs(int a){\n\tif(a==M){\n\t\tfor(int i=0;i<=M+1;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tt[i][j]=j+p[j]*q[i];\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\twhile(1){\n\t\t\tbool chg=false;\n\t\t\tfor(int i=0;i<=M;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tfor(int k=j+1;k<N;k++){\n\t\t\t\t\t\tif(t[i][now[i].p[j]]+p[now[i].p[j]]*(q[i+1]-q[i])>t[i][now[i].p[k]]+p[now[i].p[k]]*(q[i+1]-q[i])){\n\t\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\t\tt[i][now[i].p[k]]=t[i][now[i].p[j]]+p[now[i].p[j]]*(q[i+1]-q[i])-p[now[i].p[k]]*(q[i+1]-q[i]);\n\t\t\t\t\t\t\tfor(int l=0;l<=M+1;l++)t[l][now[i].p[k]]=t[i][now[i].p[k]]+p[now[i].p[k]]*(q[l]-q[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(t[i][now[i].p[j]]>t[i][now[i].p[k]]){\n\t\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\t\tt[i][now[i].p[k]]=t[i][now[i].p[j]];\n\t\t\t\t\t\t\tfor(int l=0;l<=M+1;l++)t[l][now[i].p[k]]=t[i][now[i].p[k]]+p[now[i].p[k]]*(q[l]-q[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==0&&t[i][now[i].p[j]]>=t[i][now[i].p[k]]){\n\t\t\t\t\t\t\tchg=true;\n\t\t\t\t\t\t\tfor(int l=0;l<=M+1;l++)t[l][now[i].p[k]]=t[i][now[i].p[j]]+1+p[now[i].p[k]]*(q[l]-q[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif(cnt==200)return INF;\n\t\t\t//long long tmp=0;\n\t\t\t//for(int i=0;i<N;i++)tmp=max(tmp,t[M+1][i]);\n\t\t\t//printf(\"%lld\\n\",tmp);\n\t\t\tif(!chg)break;\n\t\t}\n\t\tlong long ret=0;\n\t\tfor(int i=0;i<N;i++)ret=max(ret,t[M+1][i]);\n\t\t/*if(ret==382){\n\t\t\tfor(int i=0;i<=M;i++){\n\t\t\t\tfor(int j=0;j<N;j++)printf(\"%d \",now[i].p[j]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tfor(int i=0;i<=M+1;i++){\n\t\t\t\tfor(int j=0;j<N;j++)printf(\"%lld \",t[i][j]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}*/\n\t\treturn ret;\n\t}\n\tlong long ret=INF;\n\tfor(int i=0;i<N;i++){\n\t\tperm[a][i]=i;\n\t\trev[a][now[a].p[i]]=i;\n\t}\n\tdo{\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(rev[a][perm[a][i]]>i+1)ok=false;\n\t\t\tif(rev[a][perm[a][i]]<i-1)ok=false;\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tif(rev[a][perm[a][i]]>rev[a][perm[a][j]]&&p[perm[a][i]]>=p[perm[a][j]])ok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int i=0;i<N;i++)now[a+1].p[i]=perm[a][i];\n\t\t\tret=min(ret,dfs(a+1));\n\t\t}\n\t}while(next_permutation(perm[a],perm[a]+N));\n\treturn ret;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++)scanf(\"%lld\",p+i);\n\tscanf(\"%d\",&c);\n\tN=b;M=c;\n\tfor(int i=0;i<c;i++)scanf(\"%lld\",q+i+1);\n\tstd::sort(q,q+c+1);\n\tq[c+1]=a;\n\tfor(int i=0;i<b;i++){\n\t\tnow[0].p[i]=i;\n\t}\n\tprintf(\"%lld\\n\",dfs(0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, D, intr;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\t\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tp[i] = i;\n\t}\n\n\tvector<vector<int> > odr(m + 1);\n\todr[0].resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\n\tint cnt = 0;\n\tfor(int j = 1; j <= m; ++j){\n\t\todr[j] = odr[j - 1];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j-1] >> i & 1){\n\t\t\t\t++cnt;\n\t\t\t\tint a = odr[j][i], b = odr[j][i+1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j][i], odr[j][i+1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] >= 0) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] < 0LL && stm[b] >= 0LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[j] * (S[b] - S[a]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] >= 0LL && stm[b] < 0LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[j] * (S[a] - S[b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] >= 0LL; ++j)\n\t\tfor(int k = j + 1; stm[k] >= 0LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t--cnt;\n\t\t}\n\t\tif(cnt != 0) return;\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\t\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr = D;\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst long long int My_LInf=9223372036854775807;\n\n\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\n\t//y is w bigger than x\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second = w + data[x].second - data[y].second;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn root(x).second + w == root(y).second;\n\t\t}\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\t//x is belong to first\n\t//x is second bigger than first\n\tpair<int, long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second = data[x].second + root(data[x].first).second;\n\t\t\treturn data[x] = ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\nint HorseNum, M;\n\nvector<long long int>sps;\n\nstruct aa {\n\tint fstfinid;\n\tlong long int fstfintime;\n\tint lasfinid;\n\tlong long int lasfintime;\n\tint fststaid;\n\tlong long int fststatime;\n\tint lasstaid;\n\tlong long int lasstatime;\n};\n\n\nlong long int check(const vector<vector<bool>>&changes, const vector<vector<long long int>>&times) {\n\tvector<int>seq(HorseNum);\n\tiota(seq.begin(), seq.end(), 0);\n\taUnionFind uf(HorseNum);\n\tfor (int wide = 0; wide < M; ++wide) {\n\t\tfor (int change = 0; change < HorseNum - 1; ++change) {\n\t\t\tif (changes[wide][change]) {\n\t\t\t\tconst int c0 = seq[change];\n\t\t\t\tconst int c1 = seq[change + 1];\n\t\t\t\tconst long long int  sa = times[c0][wide] - times[c1][wide];\n\t\t\t\tif (sa > 0) {\n\t\t\t\t\tif (!uf.unionSet(c0, c1, sa)) {\n\t\t\t\t\t\treturn My_LInf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn My_LInf;\n\t\t\t\t}\n\t\t\t\tswap(seq[change], seq[change + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tmap<int, aa>mp;\n\tfor (int i = 0; i < HorseNum; ++i) {\n\t\tif (!mp.count(uf.root(i).first)) {\n\t\t\tmp[uf.root(i).first] = aa{\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,uf.root(i).second + times[i][M],\n\t\t\ti,0,\n\t\t\ti,0,\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tif (mp[uf.root(i).first].fstfintime > uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].fstfinid = i;\n\t\t\t\tmp[uf.root(i).first].fstfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tif (mp[uf.root(i).first].lasfintime < uf.root(i).second + times[i][M]) {\n\t\t\t\tmp[uf.root(i).first].lasfinid = i;\n\t\t\t\tmp[uf.root(i).first].lasfintime = uf.root(i).second + times[i][M];\n\t\t\t}\n\t\t\tmp[uf.root(i).first].lasstaid = i;\n\t\t\tmp[uf.root(i).first].lasstatime = uf.root(i).second;\n\t\t}\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); ++it) {\n\t\tif (it != mp.begin()) {\n\t\t\taa afrom(prev(it)->second);\n\t\t\taa ato(it->second);\n\n\t\t\tif (afrom.lasfintime - afrom.lasstatime>ato.fstfintime-ato.fststatime) {\n\t\t\t\tuf.unionSet(afrom.lasfinid, ato.fstfinid, times[afrom.lasfinid][M] - times[ato.fstfinid][M]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf.unionSet(afrom.lasstaid, ato.fststaid, 1);\n\t\t\t}\n\t\t\t/*aUnionFind auf(uf);\n\t\t\taUnionFind buf(uf);\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasfinid;\n\t\t\t\tint to = (it)->second.fstfinid;\n\n\t\t\t\tif (sps[from] > sps[to]) {\n\t\t\t\t\tauf.unionSet(from, to, times[from][M] - times[to][M]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauf.unionSet((prev(it))->second.lasstaid, (it)->second.fststaid, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint from = (prev(it))->second.lasstaid;\n\t\t\t\tint to = (it)->second.fststaid;\n\t\t\t\tbuf.unionSet(from, to, 1);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (buf.root((it)->second.fststaid).second > auf.root((it)->second.fststaid).second) {\n\t\t\t\tuf = buf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf = auf;\n\t\t\t}*/\n\t\t}\n\t}\n\tlong long int amax = 0;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tamax = max(amax, uf.root(i).second + times[i][M] - uf.root(0).second);\n\t}\n\treturn amax;\n}\n\nint main() {\n\t\n\t\n\tlong long int dist;\n\tcin >> dist;\n\n\tcin >> HorseNum;\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tint S; cin >> S;\n\t\tsps.push_back(S);\n\t}\n\tcin >> M;\n\tvector<long long int>ds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint D; cin >> D;\n\t\tds.push_back(D);\n\t}\n\tvector<vector<long long int>>times(HorseNum, vector<long long int>(M + 1));\n\tfor (int i = 0; i <HorseNum; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\ttimes[i][j] = sps[i] * ds[j];\n\t\t}\n\t\ttimes[i][M] = sps[i] * dist;\n\t}\n\tlong long int ans = My_LInf;\n\tfor (int i = 0; i < 1<<((HorseNum-1)*M); ++i) {\n\t\tbitset<20>bs(i);\n\t\tvector<vector<bool>>changes(M, vector<bool>(HorseNum -1));\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 1; ++k) {\n\t\t\t\tchanges[j][k] = bs[j*(HorseNum - 1) + k];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tfor (int k = 0; k < HorseNum - 2; ++k) {\n\t\t\t\tif (changes[j][k] && changes[j][k + 1]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tlong long int a = check(changes, times);\n\t\tans = min(ans,a);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\n#define fs first\n#define sc second\n\nconst ll inf = (ll)1e15;\nP par[9];\nint rank[9];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n \nbool unite(int a,int b,ll cost){\n  P x = find(a);\n  P y = find(b);\n   \n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nll dis(int a, int b){\n  if(!same(a,b))return inf;\n  return par[b].sc - par[a].sc;\n}\n\nll dist;\nint n,m;\nll s[9],d[9];\n\nll rec(vector<int> v, int depth){\n  if(depth == m){\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(dis(i,j)<=0)return inf;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(v[i]<v[j]){\n\t  if(s[v[i]] <= s[v[j]])continue;\n\t  if(!same(v[i],v[j]))continue;\n\t  if(dist * (s[v[i]]-s[v[j]]) <= dis(v[i],v[j]))continue;\n\t  if(dis(v[i],v[j])<=0)continue;\n\t  return inf;\n\t}else{\n\t  bool f = false;\n\t  for(int k=0;k<m;k++){\n\t    f |= (d[k]*(s[v[j]] - s[v[i]]) == dis(v[j],v[i]));\n\t  }\n\t  if(!f)return inf;\n\t}\n      }\n    }\n    \n    ll goal[9],start[9];\n    vector<int> pos(n);\n    for(int i=0;i<n;i++)pos[v[i]] = i;\n\n    for(int i=0;i<n;i++){\n      if(!i){\n\tstart[i] = 0;\n\tgoal[i] = s[i]*dist;\n      }else{\n\tif(same(i-1,i))start[i] = start[i-1] + dis(i-1,i);\n\telse start[i] = start[i-1] + 1;\n\tgoal[i] = start[i] + s[i]*dist;\n\tfor(int j=0;j<i;j++){\n\t  if(pos[j]<pos[i] && goal[j]>goal[i]){\n\t    start[i] += goal[j]-goal[i];\n\t    goal[i] = goal[j];\n\t  }\n\t}\n\tfor(int j=0;j<i;j++){\n\t  if(same(i,j)){\n\t    start[j] = start[i] + dis(i,j);\n\t    goal[j] = start[j] + s[j]*dist;\n\t  }\n\t}\n      }\n    }\n    \n    ll res = 0;\n    for(int i=0;i<n;i++)res = max(res,goal[i]);\n    return res;\n  }\n  \n  ll res = inf;\n  P tp1[9],tp2[9];\n  int tr1[9],tr2[9];\n\n  res = min(res,rec(v,depth+1));\n\n  for(int i=0;i<n-1;i++){\n    if(v[i] < v[i+1] && s[v[i]] > s[v[i+1]]){\n      for(int x=0;x<n;x++){\n\ttp1[x] = par[x];\n\ttr1[x] = rank[x];\n      }\n \n      ll t1 = (s[v[i]]-s[v[i+1]])*d[depth];\n      if(!unite(v[i],v[i+1],t1))continue;\n\n      swap(v[i],v[i+1]);\n      \n      res = min(res,rec(v,depth+1));\n      \n      for(int j=i+2;j<n-1;j++){\n\tif(v[j] < v[j+1] && s[v[j]] > s[v[j+1]]){\n\t  for(int x=0;x<n;x++){\n\t    tp2[x] = par[x];\n\t    tr2[x] = rank[x];\n\t  }\n\t  \n\t  ll t2 = (s[v[j]]-s[v[j+1]])*d[depth];\n\t  if(!unite(v[j],v[j+1],t2))continue;\n\n\t  swap(v[j],v[j+1]);\n\t  \n\t  res = min(res,rec(v,depth+1));\n\t  \n\t  swap(v[j],v[j+1]);\n\t  for(int x=0;x<n;x++){\n\t    par[x] = tp2[x];\n\t    rank[x] = tr2[x];\n\t  }\n\t}\n      }\n      swap(v[i],v[i+1]);\n     \n      for(int x=0;x<n;x++){\n\tpar[x] = tp1[x];\n\trank[x] = tr1[x];\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> dist >> n;\n  for(int i=0;i<n;i++)cin >> s[i];\n  cin >> m;\n  for(int i=0;i<m;i++)cin >> d[i];\n  sort(d,d+m);\n\n  vector<int> v(n);\n  for(int i=0;i<n;i++)v[i] = i;\n\n  init(n);\n  cout << rec(v,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    ?????????????????¨??????\n*/\n\n#define __1__\n\n#ifdef __1__\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0;i < (n);i++)\n#define _MAX 7\n#define INF 7e10\n#define MIN(a,b) (a)>(b)?(b):(a)\nusing namespace std;\ntypedef long long int lint;\n\n\nint dist,n,m;\nlint tm[_MAX][_MAX+2]; //tm[][0]?????????????????????,tm[][m+1]???????????´??????\nlint S[_MAX];\nlint D[_MAX];\n\nvoid maketm(int x){\n    rep(i,m){\n        tm[x][i+1]=tm[x][0]+D[i]*S[x];\n    }\n    tm[x][m+1]=tm[x][0]+S[x]*dist;\n    return;\n}\n\nvoid show(){\n    rep(i,n){\n        rep(j,m+2){\n            printf(\"%4lld \",tm[i][j]);\n        }\n        cout << endl;\n    }\n    cout << endl;\n    return;\n}\n\nint flag[5]={0};\n\nbool check(){\n    rep(i,n-1){\n        if(tm[i][0]>=tm[i+1][0]){\n            return false;\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            if(i<j&&tm[i][m+1]>tm[j][m+1]){\n                bool hoge = 0;\n                rep(k,m){\n                    if(tm[i][k+1]==tm[j][k+1]){\n                        rep(l,n){\n                            if(l!=i&&l!=j&&tm[i][k+1]==tm[l][k+1])\n                                return false;\n                        }\n                        hoge = true;\n                    }\n                }\n                if(hoge == 0)\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n\nlint dfs(int d){\n    lint ans = INF;\n    if(d==n){\n        if(check()){\n            return tm[n-1][m+1];\n        }else{\n            return 7e10;\n        }\n    }\n    rep(i,n){\n        if(flag[i]==1)\n            continue;\n        flag[i]=1;\n        if(i==0){\n            tm[i][0]=0;\n            maketm(i);\n            ans = min(dfs(d+1),ans);\n        }else if(flag[i-1]==1){\n            tm[i][0]=tm[i-1][0]+1;\n            maketm(i);\n            ans = min(dfs(d+1),ans);\n        }\n        rep(j,n){\n            if(j==i||flag[j]==0)\n                continue;\n            rep(k,m){\n                tm[i][0]=tm[j][k+1]-D[k]*S[i];\n                maketm(i);\n                ans = min(dfs(d+1),ans);\n            }\n            tm[i][0]=tm[j][m+1]-dist*S[i];\n            maketm(i);\n            ans = min(dfs(d+1),ans);\n        }\n        flag[i]=0;\n    }\n    return ans;\n}\n    \nint main() {\n    cin >> dist >> n;\n    rep(i,n){\n        cin >> S[i];\n    }\n    cin >> m;\n    rep(i,m){\n        cin >> D[i];\n    }\n    cout << dfs(0) << endl;\n    return 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    struct State {\n        vector<int> perm;\n        vector<vector<int>> adj_mat;\n        // adj_mat[i][j] := i????????????????????? - j?????????????????????\n        State(int n) : perm(n), adj_mat(n, vector<int>(n, -1)) {\n            iota(perm.begin(), perm.end(), 0);\n        }\n    };\n    const int MAX_N = 5;\n    using bs = bitset<MAX_N>;\n    vector<bs> swap_pairs = [&]() {\n        vector<bs> res = { static_cast<bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    vector<State> cur_states = { State(n)};\n    for (int hiroi_id : in(m)) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    if (speed_rev[s.perm[i]] <= speed_rev[s.perm[i + 1]]) {\n                        ok = false;\n                        break;\n                    };\n                    // now_dist * spr1 = now_dist * spr2 + jikan_sa\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = hiroi_id;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    i64 ans = goal_dist * 100;\n    for (const auto& state : cur_states) {\n        vector<i64> start = {0};\n        vector<set<i64>> time_check(m);\n        i64 max_time = goal_dist * speed_rev.front();\n        bool ok = [&]() {\n            for (int j : in(1, n)) {\n                i64 time_min = start.back() + 1, time_max = 1e18;\n                auto is_valid_time = [&](i64 t) {\n                    return time_min <= t && t <= time_max;\n                };\n                for (int i : in(j)) { // i?????? j?????????\n                    if (speed_rev[i] <= speed_rev[j]) continue;\n                    // ????????¬??????????????????????????????\n                    if (state.adj_mat[i][j] != -1) {\n                        int nuku_i = state.adj_mat[i][j];\n                        i64 jikansa = hiroi[nuku_i] * (speed_rev[i] - speed_rev[j]);\n                        i64 cand_stime = start[i] + jikansa;\n                        if (is_valid_time(cand_stime) == false)\n                            return false;\n                        i64 nuku_jikan = hiroi[nuku_i] * speed_rev[i] + start[i];\n                        if (time_check[nuku_i].count(nuku_jikan) == 1)\n                            return false;\n                        time_check[nuku_i].emplace(nuku_jikan);\n                        time_min = cand_stime;\n                        time_max = cand_stime;\n                        continue;\n                    }\n                    i64 jikan_sa = goal_dist * (speed_rev[i] - speed_rev[j]);\n                    if (time_max < start[i] + jikan_sa) return false;\n                    time_min = max(time_min, start[i] + jikan_sa);\n                }\n                max_time = max(max_time, time_min + speed_rev[j] * goal_dist);\n                start.emplace_back(time_min);\n            }\n            return true;\n        }();\n        if (ok) ans = min(ans, max_time);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\n\nLL dist, ans = (LL)1e18;\nint n, m;\nvector<int> S, D, intr;\n\nvector<int> ptn;\n\nvoid enumpattern(int a, int i){\n\tif(i >= n - 1){\n\t\tptn.push_back(a);\n\t}\n\telse{\n\t\tenumpattern(a, i + 1);\n\t\tenumpattern(a | 1 << i, i + 2);\n\t}\n}\n\nvoid calcans(){\n\tvector<LL> stm(n + 1, -1LL);\n\tLL lst0 = -1, lft0 = 0;\t// last start/finish time\n\t\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tp[i] = i;\n\t}\n\n\tvector<vector<int> > odr(m + 1);\n\todr[0].resize(n);\n\tfor(int i = 0; i < n; ++i){\n\t\todr[0][i] = i;\n\t}\n\tfor(int j = 1; j <= m; ++j){\n\t\todr[j] = odr[j - 1];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(intr[j-1] >> i & 1){\n\t\t\t\tint a = odr[j][i], b = odr[j][i+1];\n\t\t\t\tif(a > b || S[a] <= S[b]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswap(odr[j][i], odr[j][i+1]);\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tif(stm[i] >= 0) continue;\n\n\t\tstm[i] = 0;\n\t\tbool updated = true;\n\t\twhile(updated){\n\t\t\tupdated = false;\n\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tfor(int k = i; k < n; ++k){\n\t\t\t\t\tif((intr[j] >> k & 1) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint a = odr[j][k], b = odr[j][k+1];\n\t\t\t\t\tif(stm[a] < 0LL && stm[b] >= 0LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[a] = stm[b] + D[k] * (S[b] - S[a]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(stm[a] >= 0LL && stm[b] < 0LL){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstm[b] = stm[a] + D[k] * (S[a] - S[b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = i; stm[j] >= 0LL; ++j)\n\t\tfor(int k = j + 1; stm[k] >= 0LL; ++k){\n\t\t\tif(S[j] <= S[k]){ continue; }\n\t\t\tLL ip = (stm[k] - stm[j]) / (S[j] - S[k]);\n\t\t\tif(ip < 0 || ip >= dist){ continue; }\n\t\t\tif((stm[k] - stm[j]) % (S[j] - S[k]) != 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint x = find(D.begin(), D.end(), ip) - D.begin();\n\t\t\tif(x >= m) return;\n\t\t\tint y = find(odr[x].begin(), odr[x].end(), j) - odr[x].begin();\n\t\t\tif(odr[x][y+1] != k || odr[x+1][y] != k || odr[x+1][y+1] != j){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint u = find(stm.begin(), stm.end(), -1LL) - stm.begin() - 1;\t//[i,u]\n\t\tint farv = odr[m][i], larv = odr[m][u];\t//first/last arrival\n\t\tLL lst1 = stm[u];\n\t\tLL fft1 = S[farv] * dist + stm[farv];\n\t\tLL lft1 = S[larv] * dist + stm[larv];\n\n\t\tLL offset;\n\t\tif(lst0 + fft1 + 1 >= lft0){\t//start as early as possible\n\t\t\toffset = lst0 + 1;\n\t\t}\n\t\telse{\n\t\t\toffset = lft0 - fft1;\n\t\t}\n\t\tlst0 = offset + lst1;\n\t\tlft0 = offset + lft1;\n\n\t\ti = u;\n\t}\n\t\n\tans = min(ans, lft0);\n}\n\nvoid solve(int i){\n\tif(i == m){\n\t\tcalcans();\n\t}\n\telse{\n\t\tfor(int j = 0; j < ptn.size(); ++j){\n\t\t\tintr[i] = ptn[j];\n\t\t\tsolve(i + 1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> dist >> n;\n\tS.resize(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> S[i];\n\t}\n\tcin >> m;\n\tD.resize(m);\n\tintr = D;\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> D[i];\n\t}\n\tsort(D.begin(), D.end());\n\n\tenumpattern(0, 0);\n\n\tsolve(0);\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint fusei(){\nreturn fusei();\n}\nint main(){\n fusei();\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = 1e17;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\n  \nint main() {\n    i64 goal_dist = num_in<i64>();\n    int n = num_in<int>();\n    auto speed_rev = vec_in<i64>(n);\n    int m = num_in<int>();\n    auto hiroi = vec_in<i64>(m);\n    sort(hiroi.begin(), hiroi.end());\n    struct State {\n        vector<int> perm; // \n        vector<vector<i64>> adj_mat;\n        // adj_mat[i][j] :=  |j????????????????????? - i?????????????????????|\n        State(int n) : perm(n), adj_mat(n, vector<i64>(n, INF)) {\n            iota(perm.begin(), perm.end(), 0);\n            for (int i : in(n)) adj_mat[i][i] = 0ll;\n        }\n    };\n    const int MAX_N = 5;\n    using Bs = bitset<MAX_N>;\n    vector<Bs> swap_pairs = [&]() {\n        vector<Bs> res = { static_cast<Bs>(0)};        \n        for (int it : in(n - 1)) {\n            auto nxt = res;\n            for (const auto& b : res) {\n                if (it < 1 || b[it - 1] == false) {\n                    auto bn = b;\n                    bn[it] = true;\n                    nxt.emplace_back(bn);\n                }\n            }\n            res = nxt;\n        }\n        return res;\n    }();\n    vector<State> cur_states = { State(n)};\n    for (const auto& pass_dist : hiroi) {\n        vector<State> nxt_states = cur_states;\n        for (const auto& s : cur_states) {\n            for (auto flag : swap_pairs) {\n                if (flag == static_cast<Bs>(0)) continue;\n                State ns = s;\n                bool ok = true;\n                for (int i : in(n - 1)) {\n                    if (flag[i] == false) continue;\n                    i64 spr1 = speed_rev[s.perm[i]], spr2 = speed_rev[s.perm[i + 1]];\n                    if (spr1 <= spr2) {\n                        ok = false;\n                        break;\n                    };\n                    swap(ns.perm[i], ns.perm[i + 1]);\n                    // pass_dist * spr1 = pass_dist * spr2 + time_diff\n                    i64 time_diff = pass_dist * (spr1 - spr2);\n                    ns.adj_mat[s.perm[i]][s.perm[i + 1]] = time_diff;\n                    ns.adj_mat[s.perm[i + 1]][s.perm[i]] = -time_diff;\n                }\n                if (ok) nxt_states.emplace_back(ns);\n            }\n        }\n        cur_states = nxt_states;\n    }\n    i64 ans = INF;\n    auto calc_stime = [&](const vector<vector<i64>>& g, int start) {\n        vector<i64> start_time(n - start, INF);\n        start_time[0] = 0ll;\n        queue<int> que;\n        que.emplace(start);\n        while (!que.empty()) {\n            int cur = que.front();\n            que.pop();\n            for (int i : in(start, n)) {\n                if (g[cur][i] != INF && start_time[i - start] == INF) {\n                    start_time[i - start] = start_time[cur - start] + g[cur][i];\n                    que.emplace(i);\n                }\n            }\n        }\n        while (start_time.back() == INF) start_time.pop_back();\n        return start_time;\n    };\n    auto collison_ok = [&](const vector<vector<i64>>& adj, const vector<i64>& stime, int start) {\n        int gsize = stime.size();\n        for (int i : in(start, gsize + start)) {\n            for (int j : in(i + 1, gsize + start)) {\n                if (speed_rev[i] <=  speed_rev[j]) continue;\n                if (adj[i][j] != INF) {\n                    if (stime[j - start] - stime[i - start] != adj[i][j]) return false;\n                    continue;\n                }\n                i64 collision_point = (stime[i - start] - stime[j - start]) / (speed_rev[j] - speed_rev[i]);\n                if (collision_point < goal_dist) return false;\n            }\n        }\n        return true;\n    };\n    for (const auto& state : cur_states) {\n        vector<i64> start_time(n);\n        bool is_valid = [&]() {\n            Bs used(0);\n            for (int i : in(n)) {\n                if (used[i]) continue;\n                auto stime = calc_stime(state.adj_mat, i);\n                int gsize = stime.size();\n                for (int j : in(i, gsize + i)) used[j] = true;\n                for (int j : in(i + 1, gsize + i)) if (stime[j - i - 1] >= stime[j - i]) return false;\n                if (collison_ok(state.adj_mat, stime, i) == false) return false;\n                i64 offset = [&]() {\n                    if (i == 0) return 0ll;\n                    i64 tdiff_max = start_time[i - 1] + 1ll;\n                    for (int j : in(i, i + gsize)) {\n                        for (int k : in(i)) {\n                            if (speed_rev[k] <= speed_rev[j]) continue;\n                            i64 need = goal_dist * (speed_rev[k] - speed_rev[j]);\n                            tdiff_max = max(tdiff_max, need + start_time[k] - stime[j - i]);\n                        }\n                    }\n                    return tdiff_max;\n                }();\n                for (int j : in(i, gsize + i)) start_time[j] = offset + stime[j - i];\n            }\n            return true;\n        }();\n        if (!is_valid) continue;\n        i64 local_ans = 0;\n        for (int i : in(n)) local_ans = max(local_ans, start_time[i] + goal_dist * speed_rev[i]);\n        // cout << \">_<: \" << local_ans << endl;\n        // print_vec(start_time);\n        // for (auto v : state.adj_mat) print_vec(v);\n        ans = min(ans, local_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tlong dist;\n\tint n, m;\n\tlong[] ss, ds;\n\n\tvoid run(){\n\t\tdist=sc.nextInt();\n\t\tn=sc.nextInt();\n\t\tss=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tss[i]=sc.nextInt();\n\t\t}\n\t\tm=sc.nextInt();\n\t\tds=new long[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tds[i]=sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tts=new long[n];\n\t\tfill(ts, -1);\n\t\tts[0]=0;\n\t\tmin=1L<<60;\n\t\trec(0);\n\t\tprintln(min+\"\");\n\t}\n\n\tlong[] ts;\n\n\tvoid rec(int p){\n\t\tif(ts[p]==-1){\n\t\t\treturn;\n\t\t}\n\t\tlong last=0;\n\t\tint det=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tlast=max(last, ts[i]+ss[i]*dist);\n\t\t\tif(ts[i]!=-1){\n\t\t\t\tdet++;\n\t\t\t}\n\t\t}\n\n\t\tif(det==n){\n\t\t\tupdate();\n\t\t\treturn;\n\t\t}\n\t\tfor(int k=0; k<n; k++){\n\t\t\tif(ts[k]==-1){\n\t\t\t\tif(k-1>=0&&ts[k-1]!=-1){\n\t\t\t\t\tts[k]=ts[k-1]+1;\n\t\t\t\t\trec(k);\n\t\t\t\t}\n\t\t\t\tif(k+1<n&&ts[k+1]!=-1){\n\t\t\t\t\tts[k]=ts[k+1]-1;\n\t\t\t\t\trec(k);\n\t\t\t\t}\n\t\t\t\tts[k]=last-ss[k]*dist;\n\t\t\t\trec(k);\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(i==k||ts[i]==-1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\t\tlong at=ts[i]+ss[i]*ds[j];\n\t\t\t\t\t\tts[k]=at-ss[k]*ds[j];\n\t\t\t\t\t\trec(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tts[k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong min;\n\n\tHashMap<Long, Integer> map=new HashMap<Long, Integer>();\n\n\tvoid update(){\n\t\tboolean ok=true;\n\t\tlong last=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tlast=max(last, ts[i]+ss[i]*dist);\n\t\t\tif(i>0){\n\t\t\t\tok&=ts[i]>ts[i-1];\n\t\t\t\tif(!ok){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(ss[i]==ss[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble x=1.*(ts[j]-ts[i])/(ss[i]-ss[j]);\n\t\t\t\tif(0<x+EPS&&x<dist+EPS){}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tok&=(ts[j]-ts[i])%(ss[i]-ss[j])==0;\n\t\t\t\tif(!ok){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlong at=(ts[j]-ts[i])/(ss[i]-ss[j]);\n\t\t\t\tif(0<=at&&at<=dist){\n\t\t\t\t\tboolean hit=at==dist;\n\t\t\t\t\tfor(int k=0; k<m; k++){\n\t\t\t\t\t\thit|=at==ds[k];\n\t\t\t\t\t}\n\t\t\t\t\tok&=hit;\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<m; j++){\n\t\t\tmap.clear();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tlong tick=ts[i]+ss[i]*ds[j];\n\t\t\t\tif(!map.containsKey(tick)){\n\t\t\t\t\tmap.put(tick, 0);\n\t\t\t\t}\n\t\t\t\tmap.put(tick, map.get(tick)+1);\n\t\t\t\tok&=map.get(tick)<=2;\n\t\t\t\tif(!ok){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\t// debug(ts, ok, last);\n\t\t\tmin=min(min, last);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tstatic double dist;\n\tstatic int n;\n\tstatic double[] S;\n\tstatic int m;\n\tstatic double[] D;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = sc.nextDouble();\n\t\tn = sc.nextInt();\n\t\tS = new double[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tS[i] = sc.nextDouble();\n\t\t}\n\t\tm = sc.nextInt();\n\t\tD = new double[m];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tD[i] = sc.nextDouble();\n\t\t}\n\n\t\tint[] ord1 = new int[n];// ord1[i]:i???????????????????????¬??????ord1[i]\n\t\tint[] ord2 = new int[n];// ord2[i]:i??????????????¶??????ord2[i]???????????????????????¬???\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tord1[i] = i;\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 10;\n\t\t// do {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tord2[i] = i;\n\t\t}\n\t\tdo {\n\t\t\tif (ord2[0] != 0)\n\t\t\t\tcontinue;\n\t\t\tdouble[] departTime = new double[n];\n\t\t\tArrays.fill(departTime, -1);\n\t\t\tdepartTime[0] = 0;\n\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, 1));\n\t\t} while (nextPermutation(ord2));\n\t\t// } while (nextPermutation(ord1));\n\t\tSystem.out.println((long) ans);\n\t}\n\n\t// ord1[i]:i???????????????????????¬??????ord1[i]\n\t// ord2[i]:i??????????????¶??????ord2[i]???????????????????????¬???\n\t// departTime[i]:i???????????????????????¬????????????\n\n\tstatic double dfs(int[] ord1, int[] ord2, double[] departTime, int cnt) {\n\t\tdouble ans = Double.MAX_VALUE / 10;\n\t\tdouble[] env = new double[m + 1];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (departTime[j] == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tenv[i] = Math.max(env[i], S[ord1[j]] * D[i] + departTime[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tenv[m] = Math.max(env[m], S[ord1[i]] * dist + departTime[i]);\n\t\t}\n\t\tif (cnt == n) {\n\t\t\treturn env[m];\n\t\t}\n\t\tint curIdx1 = ord2[cnt];\n\t\tif (departTime[curIdx1 - 1] != -1) {\n\t\t\tif (check(ord1, ord2, curIdx1, departTime[curIdx1 - 1] + 1, departTime)) {\n\t\t\t\tdepartTime[curIdx1] = departTime[curIdx1 - 1] + 1;\n\t\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, cnt + 1));\n\t\t\t\tdepartTime[curIdx1] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= m; ++i) {\n\t\t\tdouble curDepartTime = env[i] - S[ord1[curIdx1]] * (i == m ? dist : D[i]);\n\t\t\tif (curDepartTime <= 0)\n\t\t\t\tcontinue;\n\t\t\tif (check(ord1, ord2, curIdx1, curDepartTime, departTime)) {\n\t\t\t\tdepartTime[curIdx1] = curDepartTime;\n\t\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, cnt + 1));\n\t\t\t\tdepartTime[curIdx1] = -1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\n\t}\n\n\tstatic boolean check(int[] ord1, int[] ord2, int curIdx1, double curDepartTime, double[] departTime) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tif (i < curIdx1 && departTime[i] + 1 > curDepartTime)\n\t\t\t\treturn false;\n\t\t\tif (curIdx1 < i && curDepartTime + 1 > departTime[i])\n\t\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == curIdx1 || departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tdouble crossX = -(departTime[i] - curDepartTime) / (S[ord1[i]] - S[ord1[curIdx1]]);\n\t\t\tif (S[ord1[i]] - S[ord1[curIdx1]] == 0)\n\t\t\t\tcontinue;\n\t\t\tif (0 < crossX && crossX < dist - 1e-6) {\n\t\t\t\tboolean f = false;\n\t\t\t\tfor (int j = 0; j < m; ++j) {// X=D??\\???????????§??´???cur??¨??´???i???????????£?????????????????????\n\t\t\t\t\tif (Math.abs(crossX - D[j]) < 1e-6)\n\t\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif (!f)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {// X=Di??§2?????\\??????????????¨????????£?????????????????????\n\t\t\tdouble curHeight = S[ord1[curIdx1]] * D[i] + curDepartTime;\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (j == curIdx1 || departTime[j] == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble height = S[ord1[j]] * D[i] + departTime[j];\n\t\t\t\tif (Math.abs(curHeight - height) < 1e-6)\n\t\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif (cnt > 1)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic boolean nextPermutation(int[] ord) {\n\t\tint len = ord.length;\n\t\tint i = len - 1;\n\t\twhile (i > 0 && ord[i - 1] > ord[i])\n\t\t\t--i;\n\t\tif (i == 0)\n\t\t\treturn false;\n\t\tint j = i;\n\t\twhile (j + 1 < len && ord[j + 1] > ord[i - 1])\n\t\t\t++j;\n\t\tint tmp = ord[i - 1];\n\t\tord[i - 1] = ord[j];\n\t\tord[j] = tmp;\n\t\tint s = i;\n\t\tint t = len - 1;\n\t\twhile (t - s > 0) {\n\t\t\ttmp = ord[s];\n\t\t\tord[s] = ord[t];\n\t\t\tord[t] = tmp;\n\t\t\t++s;\n\t\t\t--t;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tlong dist;\n\tint n, m;\n\tlong[] ss, ds;\n\n\tvoid run(){\n\t\tdist=sc.nextInt();\n\t\tn=sc.nextInt();\n\t\tss=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tss[i]=sc.nextInt();\n\t\t}\n\t\tm=sc.nextInt();\n\t\tds=new long[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tds[i]=sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tts=new long[n];\n\t\tfill(ts, -1);\n\t\tts[0]=0;\n\t\tmin=1L<<60;\n\t\trec(0);\n\t\tprintln(min+\"\");\n\t}\n\n\tlong[] ts;\n\n\tvoid rec(int p){\n\t\tif(ts[p]==-1){\n\t\t\treturn;\n\t\t}\n\t\tlong last=0;\n\t\tint det=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tlast=max(last, ts[i]+ss[i]*dist);\n\t\t\tif(ts[i]!=-1){\n\t\t\t\tdet++;\n\t\t\t}\n\t\t}\n\n\t\tif(det==n){\n\t\t\tcheck();\n\t\t\treturn;\n\t\t}\n\t\tfor(int k=0; k<n; k++){\n\t\t\tif(ts[k]==-1){\n\t\t\t\tif(k-1>=0&&ts[k-1]!=-1){\n\t\t\t\t\tts[k]=ts[k-1]+1;\n\t\t\t\t\trec(k);\n\t\t\t\t}\n\t\t\t\tif(k+1<n&&ts[k+1]!=-1){\n\t\t\t\t\tts[k]=ts[k+1]-1;\n\t\t\t\t\trec(k);\n\t\t\t\t}\n\t\t\t\tts[k]=last-ss[k]*dist;\n\t\t\t\trec(k);\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(i==k||ts[i]==-1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\t\tlong at=ts[i]+ss[i]*ds[j];\n\t\t\t\t\t\tts[k]=at-ss[k]*ds[j];\n\t\t\t\t\t\trec(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tts[k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong min;\n\n\tboolean check(){\n\t\tboolean ok=true;\n\t\tlong last=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tlast=max(last, ts[i]+ss[i]*dist);\n\t\t\tif(i>0){\n\t\t\t\tok&=ts[i]>ts[i-1];\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(ss[i]==ss[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble x=1.*(ts[j]-ts[i])/(ss[i]-ss[j]);\n\t\t\t\tif(0<=x&&x<=dist){}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tok&=(ts[j]-ts[i])%(ss[i]-ss[j])==0;\n\t\t\t\tlong at=(ts[j]-ts[i])/(ss[i]-ss[j]);\n\t\t\t\tif(0<=at&&at<=dist){\n\t\t\t\t\tboolean hit=at==dist;\n\t\t\t\t\tfor(int k=0; k<m; k++){\n\t\t\t\t\t\thit|=at==ds[k];\n\t\t\t\t\t}\n\t\t\t\t\tok&=hit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<m; j++){\n\t\t\tHashMap<Long, Integer> map=new HashMap<Long, Integer>();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tlong at=ts[i]+ss[i]*ds[j];\n\t\t\t\tif(!map.containsKey(at)){\n\t\t\t\t\tmap.put(at, 0);\n\t\t\t\t}\n\t\t\t\tmap.put(at, map.get(at)+1);\n\t\t\t\tok&=map.get(at)<=2;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n//\t\t\tdebug(ts, ok, last);\n\t\t\tmin=min(min, last);\n\t\t}\n\t\treturn ok;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tstatic double dist;\n\tstatic int n;\n\tstatic double[] S;\n\tstatic int m;\n\tstatic double[] D;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = sc.nextDouble();\n\t\tn = sc.nextInt();\n\t\tS = new double[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tS[i] = sc.nextDouble();\n\t\t}\n\t\tm = sc.nextInt();\n\t\tD = new double[m];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tD[i] = sc.nextDouble();\n\t\t}\n\n\t\tint[] ord1 = new int[n];// ord1[i]:i???????????????????????¬??????ord1[i]\n\t\tint[] ord2 = new int[n];// ord2[i]:i??????????????¶??????ord2[i]???????????????????????¬???\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tord1[i] = i;\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 10;\n\t\t// do {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tord2[i] = i;\n\t\t}\n\t\tdo {\n\t\t\tif (ord2[0] != 0)\n\t\t\t\tcontinue;\n\t\t\tdouble[] departTime = new double[n];\n\t\t\tArrays.fill(departTime, -1);\n\t\t\tdepartTime[0] = 0;\n\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, 1));\n\t\t} while (nextPermutation(ord2));\n\t\t// } while (nextPermutation(ord1));\n\t\tSystem.out.println((int) Math.round(ans));\n\t}\n\n\t// ord1[i]:i???????????????????????¬??????ord1[i]\n\t// ord2[i]:i??????????????¶??????ord2[i]???????????????????????¬???\n\t// departTime[i]:i???????????????????????¬????????????\n\n\tstatic double dfs(int[] ord1, int[] ord2, double[] departTime, int cnt) {\n\t\tdouble ans = Double.MAX_VALUE / 10;\n\t\tdouble[] env = new double[m + 1];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (departTime[j] == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tenv[i] = Math.max(env[i], S[ord1[j]] * D[i] + departTime[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tenv[m] = Math.max(env[m], S[ord1[i]] * dist + departTime[i]);\n\t\t}\n\t\tif (cnt == n) {\n\t\t\treturn env[m];\n\t\t}\n\t\tint curIdx1 = ord2[cnt];\n\t\tif (departTime[curIdx1 - 1] != -1) {\n\t\t\tif (check(ord1, ord2, curIdx1, departTime[curIdx1 - 1] + 1, departTime)) {\n\t\t\t\tdepartTime[curIdx1] = departTime[curIdx1 - 1] + 1;\n\t\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, cnt + 1));\n\t\t\t\tdepartTime[curIdx1] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= m; ++i) {\n\t\t\tdouble curDepartTime = env[i] - S[ord1[curIdx1]] * (i == m ? dist : D[i]);\n\t\t\tif (curDepartTime <= 0)\n\t\t\t\tcontinue;\n\t\t\tif (check(ord1, ord2, curIdx1, curDepartTime, departTime)) {\n\t\t\t\tdepartTime[curIdx1] = curDepartTime;\n\t\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, cnt + 1));\n\t\t\t\tdepartTime[curIdx1] = -1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\n\t}\n\n\tstatic boolean check(int[] ord1, int[] ord2, int curIdx1, double curDepartTime, double[] departTime) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tif (i < curIdx1 && departTime[i] + 1 > curDepartTime)\n\t\t\t\treturn false;\n\t\t\tif (curIdx1 < i && curDepartTime + 1 > departTime[i])\n\t\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == curIdx1 || departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tdouble crossX = -(departTime[i] - curDepartTime) / (S[ord1[i]] - S[ord1[curIdx1]]);\n\t\t\tif (S[ord1[i]] - S[ord1[curIdx1]] == 0)\n\t\t\t\tcontinue;\n\t\t\tif (0 < crossX && crossX < dist - 1e-6) {\n\t\t\t\tboolean f = false;\n\t\t\t\tfor (int j = 0; j < m; ++j) {// X=D??\\???????????§??´???cur??¨??´???i???????????£?????????????????????\n\t\t\t\t\tif (Math.abs(crossX - D[j]) < 1e-6)\n\t\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif (!f)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {// X=Di??§2?????\\??????????????¨????????£?????????????????????\n\t\t\tdouble curHeight = S[ord1[curIdx1]] * D[i] + curDepartTime;\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (j == curIdx1 || departTime[j] == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble height = S[ord1[j]] * D[i] + departTime[j];\n\t\t\t\tif (Math.abs(curHeight - height) < 1e-6)\n\t\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif (cnt > 1)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic boolean nextPermutation(int[] ord) {\n\t\tint len = ord.length;\n\t\tint i = len - 1;\n\t\twhile (i > 0 && ord[i - 1] > ord[i])\n\t\t\t--i;\n\t\tif (i == 0)\n\t\t\treturn false;\n\t\tint j = i;\n\t\twhile (j + 1 < len && ord[j + 1] > ord[i - 1])\n\t\t\t++j;\n\t\tint tmp = ord[i - 1];\n\t\tord[i - 1] = ord[j];\n\t\tord[j] = tmp;\n\t\tint s = i;\n\t\tint t = len - 1;\n\t\twhile (t - s > 0) {\n\t\t\ttmp = ord[s];\n\t\t\tord[s] = ord[t];\n\t\t\tord[t] = tmp;\n\t\t\t++s;\n\t\t\t--t;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tstatic double dist;\n\tstatic int n;\n\tstatic double[] S;\n\tstatic int m;\n\tstatic double[] D;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = sc.nextDouble();\n\t\tn = sc.nextInt();\n\t\tS = new double[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tS[i] = sc.nextDouble();\n\t\t}\n\t\tm = sc.nextInt();\n\t\tD = new double[m];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tD[i] = sc.nextDouble();\n\t\t}\n\n\t\tint[] ord1 = new int[n];// ord1[i]:i???????????????????????¬??????ord1[i]\n\t\tint[] ord2 = new int[n];// ord2[i]:i??????????????¶??????ord2[i]???????????????????????¬???\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tord1[i] = i;\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 10;\n//\t\tdo {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tord2[i] = i;\n\t\t\t}\n\t\t\tdo {\n\t\t\t\tif (ord2[0] != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble[] departTime = new double[n];\n\t\t\t\tArrays.fill(departTime, -1);\n\t\t\t\tdepartTime[0] = 0;\n\t\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, 1));\n\t\t\t} while (nextPermutation(ord2));\n//\t\t} while (nextPermutation(ord1));\n\t\tSystem.out.println(ans);\n\t}\n\n\t// ord1[i]:i???????????????????????¬??????ord1[i]\n\t// ord2[i]:i??????????????¶??????ord2[i]???????????????????????¬???\n\t// departTime[i]:i???????????????????????¬????????????\n\n\tstatic double dfs(int[] ord1, int[] ord2, double[] departTime, int cnt) {\n\t\tdouble ans = Double.MAX_VALUE / 10;\n\t\tdouble[] env = new double[m + 1];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (departTime[j] == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tenv[i] = Math.max(env[i], S[ord1[j]] * D[i] + departTime[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tenv[m] = Math.max(env[m], S[ord1[i]] * dist + departTime[i]);\n\t\t}\n\t\tif (cnt == n) {\n\t\t\treturn env[m];\n\t\t}\n\t\tint curIdx1 = ord2[cnt];\n\t\tif (departTime[curIdx1 - 1] != -1) {\n\t\t\tif (check(ord1, ord2, curIdx1, departTime[curIdx1 - 1] + 1, departTime)) {\n\t\t\t\tdepartTime[curIdx1] = departTime[curIdx1 - 1] + 1;\n\t\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, cnt + 1));\n\t\t\t\tdepartTime[curIdx1] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= m; ++i) {\n\t\t\tdouble curDepartTime = env[i] - S[ord1[curIdx1]] * (i == m ? dist : D[i]);\n\t\t\tif (curDepartTime <= 0)\n\t\t\t\tcontinue;\n\t\t\tif (check(ord1, ord2, curIdx1, curDepartTime, departTime)) {\n\t\t\t\tdepartTime[curIdx1] = curDepartTime;\n\t\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, cnt + 1));\n\t\t\t\tdepartTime[curIdx1] = -1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\n\t}\n\n\tstatic boolean check(int[] ord1, int[] ord2, int curIdx1, double curDepartTime, double[] departTime) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tif (i < curIdx1 && departTime[i] + 1 > curDepartTime)\n\t\t\t\treturn false;\n\t\t\tif (curIdx1 < i && curDepartTime + 1 > departTime[i])\n\t\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == curIdx1 || departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tdouble crossX = -(departTime[i] - curDepartTime) / (S[ord1[i]] - S[ord1[curIdx1]]);\n\t\t\tif (S[ord1[i]] - S[ord1[curIdx1]] == 0)\n\t\t\t\tcontinue;\n\t\t\tif (0 < crossX && crossX < dist - 1e-6) {\n\t\t\t\tboolean f = false;\n\t\t\t\tfor (int j = 0; j < m; ++j) {// X=D??\\???????????§??´???cur??¨??´???i???????????£?????????????????????\n\t\t\t\t\tif (Math.abs(crossX - D[j]) < 1e-6)\n\t\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif (!f)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {// X=Di??§2?????\\??????????????¨????????£?????????????????????\n\t\t\tdouble curHeight = S[ord1[curIdx1]] * D[i] + curDepartTime;\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (j == curIdx1 || departTime[j] == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble height = S[ord1[j]] * D[i] + departTime[j];\n\t\t\t\tif (Math.abs(curHeight - height) < 1e-6)\n\t\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif (cnt > 1)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic boolean nextPermutation(int[] ord) {\n\t\tint len = ord.length;\n\t\tint i = len - 1;\n\t\twhile (i > 0 && ord[i - 1] > ord[i])\n\t\t\t--i;\n\t\tif (i == 0)\n\t\t\treturn false;\n\t\tint j = i;\n\t\twhile (j + 1 < len && ord[j + 1] > ord[i - 1])\n\t\t\t++j;\n\t\tint tmp = ord[i - 1];\n\t\tord[i - 1] = ord[j];\n\t\tord[j] = tmp;\n\t\tint s = i;\n\t\tint t = len - 1;\n\t\twhile (t - s > 0) {\n\t\t\ttmp = ord[s];\n\t\t\tord[s] = ord[t];\n\t\t\tord[t] = tmp;\n\t\t\t++s;\n\t\t\t--t;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tlong dist;\n\tint n, m;\n\tlong[] ss, ds;\n\n\tvoid run(){\n\t\tdist=sc.nextInt();\n\t\tn=sc.nextInt();\n\t\tss=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tss[i]=sc.nextInt();\n\t\t}\n\t\tm=sc.nextInt();\n\t\tds=new long[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tds[i]=sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tts=new long[n];\n\t\tfill(ts, -1);\n\t\tts[0]=0;\n\t\tmin=1L<<60;\n\t\trec(0);\n\t\tprintln(min+\"\");\n\t}\n\n\tlong[] ts;\n\n\tvoid rec(int p){\n\t\tif(ts[p]==-1){\n\t\t\treturn;\n\t\t}\n\t\tlong last=0;\n\t\tint det=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tlast=max(last, ts[i]+ss[i]*dist);\n\t\t\tif(ts[i]!=-1){\n\t\t\t\tdet++;\n\t\t\t}\n\t\t}\n\n\t\tif(det==n){\n\t\t\tupdate();\n\t\t\treturn;\n\t\t}\n\t\tfor(int k=0; k<n; k++){\n\t\t\tif(ts[k]==-1){\n\t\t\t\tif(k-1>=0&&ts[k-1]!=-1){\n\t\t\t\t\tts[k]=ts[k-1]+1;\n\t\t\t\t\trec(k);\n\t\t\t\t}\n\t\t\t\tif(k+1<n&&ts[k+1]!=-1){\n\t\t\t\t\tts[k]=ts[k+1]-1;\n\t\t\t\t\trec(k);\n\t\t\t\t}\n\t\t\t\tts[k]=last-ss[k]*dist;\n\t\t\t\trec(k);\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(i==k||ts[i]==-1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\t\tlong at=ts[i]+ss[i]*ds[j];\n\t\t\t\t\t\tts[k]=at-ss[k]*ds[j];\n\t\t\t\t\t\trec(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tts[k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong min;\n\n\tHashMap<Long, Integer> map=new HashMap<Long, Integer>();\n\n\tvoid update(){\n\t\tboolean ok=true;\n\t\tlong last=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tlast=max(last, ts[i]+ss[i]*dist);\n\t\t\tif(i>0){\n\t\t\t\tok&=ts[i]>ts[i-1];\n\t\t\t\tif(!ok){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(ss[i]==ss[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble x=1.*(ts[j]-ts[i])/(ss[i]-ss[j]);\n\t\t\t\tif(0<=x&&x<=dist){}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tok&=(ts[j]-ts[i])%(ss[i]-ss[j])==0;\n\t\t\t\tif(!ok){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlong at=(ts[j]-ts[i])/(ss[i]-ss[j]);\n\t\t\t\tif(0<=at&&at<=dist){\n\t\t\t\t\tboolean hit=at==dist;\n\t\t\t\t\tfor(int k=0; k<m; k++){\n\t\t\t\t\t\thit|=at==ds[k];\n\t\t\t\t\t}\n\t\t\t\t\tok&=hit;\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<m; j++){\n\t\t\tmap.clear();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tlong at=ts[i]+ss[i]*ds[j];\n\t\t\t\tif(!map.containsKey(at)){\n\t\t\t\t\tmap.put(at, 0);\n\t\t\t\t}\n\t\t\t\tmap.put(at, map.get(at)+1);\n\t\t\t\tok&=map.get(at)<=2;\n\t\t\t\tif(!ok){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\t// debug(ts, ok, last);\n\t\t\tmin=min(min, last);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tlong dist;\n\tint n, m;\n\tlong[] ss, ds;\n\n\tvoid run(){\n\t\tdist=sc.nextInt();\n\t\tn=sc.nextInt();\n\t\tss=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tss[i]=sc.nextInt();\n\t\t}\n\t\tm=sc.nextInt();\n\t\tds=new long[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tds[i]=sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tts=new long[n];\n\t\tfill(ts, -1);\n\t\tts[0]=0;\n\t\tmin=1L<<60;\n\t\trec(0);\n\t\tprintln(min+\"\");\n\t}\n\n\tlong[] ts;\n\n\tvoid rec(int p){\n\t\tif(ts[p]==-1){\n\t\t\treturn;\n\t\t}\n\t\tlong last=0;\n\t\tint det=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tlast=max(last, ts[i]+ss[i]*dist);\n\t\t\tif(ts[i]!=-1){\n\t\t\t\tdet++;\n\t\t\t}\n\t\t}\n\n\t\tif(det==n){\n\t\t\tcheck();\n\t\t\treturn;\n\t\t}\n\t\tfor(int k=0; k<n; k++){\n\t\t\tif(ts[k]==-1){\n\t\t\t\tif(k-1>=0&&ts[k-1]!=-1){\n\t\t\t\t\tts[k]=ts[k-1]+1;\n\t\t\t\t\trec(k);\n\t\t\t\t}\n\t\t\t\tif(k+1<n&&ts[k+1]!=-1){\n\t\t\t\t\tts[k]=ts[k+1]-1;\n\t\t\t\t\trec(k);\n\t\t\t\t}\n\t\t\t\tts[k]=last-ss[k]*dist;\n\t\t\t\trec(k);\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(i==k||ts[i]==-1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\t\tlong at=ts[i]+ss[i]*ds[j];\n\t\t\t\t\t\tts[k]=at-ss[k]*ds[j];\n\t\t\t\t\t\trec(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tts[k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong min;\n\n\tHashMap<Long, Integer> map=new HashMap<Long, Integer>();\n\t\n\tboolean check(){\n\t\tboolean ok=true;\n\t\tlong last=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tlast=max(last, ts[i]+ss[i]*dist);\n\t\t\tif(i>0){\n\t\t\t\tok&=ts[i]>ts[i-1];\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(ss[i]==ss[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble x=1.*(ts[j]-ts[i])/(ss[i]-ss[j]);\n\t\t\t\tif(0<=x&&x<=dist){}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tok&=(ts[j]-ts[i])%(ss[i]-ss[j])==0;\n\t\t\t\tlong at=(ts[j]-ts[i])/(ss[i]-ss[j]);\n\t\t\t\tif(0<=at&&at<=dist){\n\t\t\t\t\tboolean hit=at==dist;\n\t\t\t\t\tfor(int k=0; k<m; k++){\n\t\t\t\t\t\thit|=at==ds[k];\n\t\t\t\t\t}\n\t\t\t\t\tok&=hit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<m; j++){\n\t\t\tmap.clear();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tlong at=ts[i]+ss[i]*ds[j];\n\t\t\t\tif(!map.containsKey(at)){\n\t\t\t\t\tmap.put(at, 0);\n\t\t\t\t}\n\t\t\t\tmap.put(at, map.get(at)+1);\n\t\t\t\tok&=map.get(at)<=2;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n//\t\t\tdebug(ts, ok, last);\n\t\t\tmin=min(min, last);\n\t\t}\n\t\treturn ok;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tstatic double dist;\n\tstatic int n;\n\tstatic double[] S;\n\tstatic int m;\n\tstatic double[] D;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = sc.nextDouble();\n\t\tn = sc.nextInt();\n\t\tS = new double[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tS[i] = sc.nextDouble();\n\t\t}\n\t\tm = sc.nextInt();\n\t\tD = new double[m];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tD[i] = sc.nextDouble();\n\t\t}\n\n\t\tint[] ord1 = new int[n];// ord1[i]:i???????????????????????¬??????ord1[i]\n\t\tint[] ord2 = new int[n];// ord2[i]:i??????????????¶??????ord2[i]???????????????????????¬???\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tord1[i] = i;\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 10;\n\t\t// do {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tord2[i] = i;\n\t\t}\n\t\tdo {\n\t\t\tif (ord2[0] != 0)\n\t\t\t\tcontinue;\n\t\t\tdouble[] departTime = new double[n];\n\t\t\tArrays.fill(departTime, -1);\n\t\t\tdepartTime[0] = 0;\n\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, 1));\n\t\t} while (nextPermutation(ord2));\n\t\t// } while (nextPermutation(ord1));\n\t\tSystem.out.println((int) (ans + 0.9999999999));\n\t}\n\n\t// ord1[i]:i???????????????????????¬??????ord1[i]\n\t// ord2[i]:i??????????????¶??????ord2[i]???????????????????????¬???\n\t// departTime[i]:i???????????????????????¬????????????\n\n\tstatic double dfs(int[] ord1, int[] ord2, double[] departTime, int cnt) {\n\t\tdouble ans = Double.MAX_VALUE / 10;\n\t\tdouble[] env = new double[m + 1];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (departTime[j] == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tenv[i] = Math.max(env[i], S[ord1[j]] * D[i] + departTime[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tenv[m] = Math.max(env[m], S[ord1[i]] * dist + departTime[i]);\n\t\t}\n\t\tif (cnt == n) {\n\t\t\treturn env[m];\n\t\t}\n\t\tint curIdx1 = ord2[cnt];\n\t\tif (departTime[curIdx1 - 1] != -1) {\n\t\t\tif (check(ord1, ord2, curIdx1, departTime[curIdx1 - 1] + 1, departTime)) {\n\t\t\t\tdepartTime[curIdx1] = departTime[curIdx1 - 1] + 1;\n\t\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, cnt + 1));\n\t\t\t\tdepartTime[curIdx1] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= m; ++i) {\n\t\t\tdouble curDepartTime = env[i] - S[ord1[curIdx1]] * (i == m ? dist : D[i]);\n\t\t\tif (curDepartTime <= 0)\n\t\t\t\tcontinue;\n\t\t\tif (check(ord1, ord2, curIdx1, curDepartTime, departTime)) {\n\t\t\t\tdepartTime[curIdx1] = curDepartTime;\n\t\t\t\tans = Math.min(ans, dfs(ord1, ord2, departTime, cnt + 1));\n\t\t\t\tdepartTime[curIdx1] = -1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\n\t}\n\n\tstatic boolean check(int[] ord1, int[] ord2, int curIdx1, double curDepartTime, double[] departTime) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tif (i < curIdx1 && departTime[i] + 1 > curDepartTime)\n\t\t\t\treturn false;\n\t\t\tif (curIdx1 < i && curDepartTime + 1 > departTime[i])\n\t\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == curIdx1 || departTime[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tdouble crossX = -(departTime[i] - curDepartTime) / (S[ord1[i]] - S[ord1[curIdx1]]);\n\t\t\tif (S[ord1[i]] - S[ord1[curIdx1]] == 0)\n\t\t\t\tcontinue;\n\t\t\tif (0 < crossX && crossX < dist - 1e-6) {\n\t\t\t\tboolean f = false;\n\t\t\t\tfor (int j = 0; j < m; ++j) {// X=D??\\???????????§??´???cur??¨??´???i???????????£?????????????????????\n\t\t\t\t\tif (Math.abs(crossX - D[j]) < 1e-6)\n\t\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif (!f)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {// X=Di??§2?????\\??????????????¨????????£?????????????????????\n\t\t\tdouble curHeight = S[ord1[curIdx1]] * D[i] + curDepartTime;\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (j == curIdx1 || departTime[j] == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble height = S[ord1[j]] * D[i] + departTime[j];\n\t\t\t\tif (Math.abs(curHeight - height) < 1e-6)\n\t\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif (cnt > 1)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic boolean nextPermutation(int[] ord) {\n\t\tint len = ord.length;\n\t\tint i = len - 1;\n\t\twhile (i > 0 && ord[i - 1] > ord[i])\n\t\t\t--i;\n\t\tif (i == 0)\n\t\t\treturn false;\n\t\tint j = i;\n\t\twhile (j + 1 < len && ord[j + 1] > ord[i - 1])\n\t\t\t++j;\n\t\tint tmp = ord[i - 1];\n\t\tord[i - 1] = ord[j];\n\t\tord[j] = tmp;\n\t\tint s = i;\n\t\tint t = len - 1;\n\t\twhile (t - s > 0) {\n\t\t\ttmp = ord[s];\n\t\t\tord[s] = ord[t];\n\t\t\tord[t] = tmp;\n\t\t\t++s;\n\t\t\t--t;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.IO;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n\n\n        public void Solve() {\n            var D = rl;\n            var n = ri;\n            var s = Enumerate(n, x => rl);\n            var m = ri;\n            var d = Enumerate(m, x => rl);\n            var min = long.MaxValue;\n            var pair = new List<int>();\n            for (int i = 0; i < n; i++)\n                for (int j = i + 1; j < n; j++)\n                    pair.Add(i * n + j);\n            Action<int, bool[][], int[]> rec = null;\n            rec = (id, used, pos) => {\n                if (id == pair.Count) {\n                    var g = Enumerate(n, x => new long[n]);\n                    for (int i = 0; i < n; i++)\n                        for (int j = i + 1; j < n; j++)\n                            g[i][j] = g[j][i] = INF;\n                    for (int i = 0; i < n - 1; i++)\n                        g[i + 1][i] = -1;\n                    for (int iid = 0; iid < pos.Length; iid++) {\n                        var i = pair[iid] / n;\n                        var j = pair[iid] % n;\n                        var k = pos[iid];\n                        if (k == m) {\n                            g[j][i] = Math.Min(g[j][i], D * (s[j] - s[i]));\n                        }\n                        else {\n                            g[i][j] = Math.Min(g[i][j], d[k] * (s[i] - s[j]));\n                            g[j][i] = Math.Min(g[j][i], d[k] * (s[j] - s[i]));\n                        }\n                    }\n                    for (int k = 0; k < n; k++)\n                        for (int i = 0; i < n; i++)\n                            for (int j = 0; j < n; j++)\n                                g[i][j] = Math.Min(g[i][j], g[i][k] + g[k][j]);\n                    if (g[0].Min() >= 0) {\n                        var max = 0L;\n                        for (int i = 0; i < n; i++)\n                            max = Math.Max(max, D * s[i] + g[n - 1][i] - g[n - 1][0]);\n                        var ok = true;\n                        for (int iid = 0; iid < pos.Length; iid++) {\n                            var i = pair[iid] / n;\n                            var j = pair[iid] % n;\n                            var k = pos[iid];\n                            if (k != m) {\n                                ok &= g[i][j] == d[k] * (s[i] - s[j]);\n                                ok &= g[j][i] == d[k] * (s[j] - s[i]);\n                            }\n                        }\n                        if (ok)\n                            min = Math.Min(min, max);\n                    }\n\n                    return;\n                }\n                var a = pair[id] / n;\n                var b = pair[id] % n;\n                for (int j = 0; j <= m; j++) {\n                    if (j < m && used[a][j]) continue;\n                    if (j < m && used[b][j]) continue;\n                    pos[id] = j;\n                    used[a][j] = true;\n                    used[b][j] = true;\n                    rec(id + 1, used, pos);\n                    used[b][j] = false;\n                    used[a][j] = false;\n                    pos[id] = -1;\n                }\n            };\n            rec(0, Enumerate(n, x => new bool[m + 1]), new int[pair.Count]);\n            Console.WriteLine(min);\n        }\n\n\n        const long INF = 1L << 60;\n        //int[] dx = { -1, 0, 1, 0 };\n        //int[] dy = { 0, 1, 0, -1 };\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read())\n                if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "Python",
    "code": "dist=int(input())\nn=int(input())\ns=[int(input()) for i in range(n)]\nm=int(input())\nd=[int(input()) for i in range(m)]\nd.append(dist)\ndef solve(stime):\n    if len(stime)==n:\n        return max([stime[i] + s[i]*dist for i in range(n)])\n    nxt=len(stime)\n    sbase=stime[-1]+1\n    ret=10**20\n    for i in range(m+1):\n        for j in range(nxt):\n            t=stime[j]+s[j]*d[i]-s[nxt]*d[i]\n            if t<sbase:\n                continue\n            for k in range(nxt):\n                if s[k]<=s[nxt]:\n                    continue\n                # stime[k] + s[k]*dist = t + s[nxt]*dist\n                # dist = (t-stime[k]) / (s[k]-s[nxt])\n                if (t-stime[k])*1.0/(s[k]-s[nxt])<dist and not (t-stime[k])*1.0/(s[k]-s[nxt]) in d:\n                    break\n            else:\n                ret=min(ret,solve(stime+[t]))\n    # starttime = sbaseも考慮\n    for k in range(nxt):\n        if s[k]<=s[nxt]:\n            continue\n        if (sbase-stime[k])*1.0/(s[k]-s[nxt])<dist and not (sbase-stime[k])*1.0/(s[k]-s[nxt]) in d:\n            break\n    else:\n        ret=min(ret,solve(stime+[sbase]))\n    return ret\nprint(solve([0]))\n"
  },
  {
    "language": "Python",
    "code": "dist=int(input())\nn=int(input())\ns=[int(input()) for i in range(n)]\nm=int(input())\nd=[int(input()) for i in range(m)]\nd.append(dist)\ndef solve(stime):\n    if len(stime)==n:\n        return max([stime[i] + s[i]*dist for i in range(n)])\n    nxt=len(stime)\n    sbase=stime[-1]+1\n    ret=10**20\n    for i in range(m+1):\n        for j in range(nxt):\n            t=stime[j]+s[j]*d[i]-s[nxt]*d[i]\n            if t<sbase:\n                continue\n            for k in range(nxt):\n                if s[k]<=s[nxt]:\n                    continue\n                # stime[k] + s[k]*dist = t + s[nxt]*dist\n                # dist = (t-stime[k]) / (s[k]-s[nxt])\n                if (t-stime[k])>=(s[k]-s[nxt])*dist:\n                    continue\n                flag=False\n                if not (t-stime[k])*1.0/(s[k]-s[nxt]) in d:\n                    flag=True\n                for l in range(k):\n                    if s[l]<=s[k]:\n                        continue\n                    if (stime[k]-stime[l])*(s[k]-s[nxt]) == (t-stime[k])*(s[l]-s[k]):\n                        flag=True\n                if flag:\n                    break\n            else:\n                ret=min(ret,solve(stime+[t]))\n    # starttime = sbaseも考慮\n    for k in range(nxt):\n        if s[k]<=s[nxt]:\n            continue\n        if (sbase-stime[k])>=(s[k]-s[nxt])*dist:\n            continue\n        flag=False\n        if (sbase-stime[k])*1.0/(s[k]-s[nxt])<dist and not (sbase-stime[k])*1.0/(s[k]-s[nxt]) in d:\n            flag=True\n        for l in range(k):\n            if s[l]<=s[k]:\n                continue\n            if (stime[k]-stime[l])*(s[k]-s[nxt]) == (sbase-stime[k])*(s[l]-s[k]):\n                flag=True\n        if flag:\n            break\n    else:\n        ret=min(ret,solve(stime+[sbase]))\n    return ret\nprint(solve([0]))\n"
  }
]