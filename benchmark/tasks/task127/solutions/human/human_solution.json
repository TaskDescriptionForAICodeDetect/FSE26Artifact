[
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n\n  val Array(w, h) = readLine.trim.split(' ').map(_.toInt)\n  val state = Array.tabulate(h){_ ⇒ readLine.trim.split(' ').map(_.toLong) :+ 0L} :+ Array.tabulate(w + 1){_ ⇒ 0L}\n  for (i ← (0 until h).reverse; j ← (0 until w).reverse) {\n    state(i)(j) += state(i)(j + 1) + state(i + 1)(j) - state(i + 1)(j + 1)\n  }\n  val memo = Array.tabulate(h)({_ ⇒ Array.tabulate(w){_ ⇒ None: Option[Long]}})\n  memo(h - 1)(w - 1) = if (((w + h) % 2 == 0 && state(h - 1)(w - 1) > 0) || ((w + h) % 2 == 1 && state(h - 1)(w - 1) < 0)) Some(state(h - 1)(w - 1)) else Some(-state(h - 1)(w - 1))\n  val res = math.abs(solve(0, 0))\n  println(res)\n  def solve(x: Int, y: Int): Long = {\n    if (x == w || y == h) 0\n    else memo(y)(x) match {\n      case Some(r) ⇒ r\n      case None if (x + y) % 2 == 1 ⇒\n        math.min(solve(x + 1, y) - state(y)(x) + state(y)(x + 1), solve(x, y + 1) + state(y)(x) - state(y + 1)(x)).also{r ⇒ memo(y)(x) = Some(r)}\n      case None ⇒\n        math.max(solve(x + 1, y) - state(y)(x) + state(y)(x + 1), solve(x, y + 1) + state(y)(x) - state(y + 1)(x)).also{r ⇒ memo(y)(x) = Some(r)}\n    }\n  }\n  implicit class Extension[T](value :T){\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {func(value); value}\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint dp[1007][1007],a[1007][1007],sum[1007][1007],vis[1007][1007],total=0;\nint solve(int x,int y){\n\tif(vis[x][y]) return dp[x][y];\n\tif(x==n && y==m) return 0;\n\tvis[x][y]=1;\n\tint turn=(x+y)%2,ret=0;\n\tif(turn==1){\n\t\tret=-2e9;\n\t\tif(y!=m) ret=max(ret,solve(x,y+1));\n\t\tif(x!=n) ret=max(ret,solve(x+1,y)+sum[x+1][y]);\n\t}\n\telse{\n\t\tret=2e9;\n\t\tif(y!=m) ret=min(ret,solve(x,y+1));\n\t\tif(x!=n) ret=min(ret,solve(x+1,y)+sum[x+1][y]);\n\t}\n\tdp[x][y]=ret;\n\treturn ret;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>a[i][j];\n\t\t\tsum[i][j]=sum[i][j-1]+a[i][j];\n\t\t\ttotal+=a[i][j];\n\t\t}\n\t}\n\tsolve(0,0);\n\t//cout<<dp[0][0]<<endl;\n\tcout<<abs(total-2*dp[0][0])<<\"\\n\";;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n//vector<vector<int> > dp;\n//vector<vector<vector<int> > > vvvi;\n//dp=vector<vector<int> >(N, vector<int>(M,0));\n//vector<pair<int,int> > v;\n//v.push_back(make_pair(x,y));\n//priority_queue<int,vector<int>, greater<int> > q2;\nint W, H;\nint s[1010][1010] = { 0 };\n\nint score(int i, int j) {\n\tif ((i + j) % 2 == 0)return (s[i + 1][W] - s[i + 1][j]) - s[i + 1][j];\n\treturn s[i + 1][j] - (s[i + 1][W] - s[i + 1][j]);\n}\n\nsigned main(){\ncin.tie(0);\nios::sync_with_stdio(false);\n\n\tint dp[1010][1010];\n\tcin >> W >> H;\n\teFOR(i,1, H) {\n\t\teFOR(j,1, W) {\n\t\t\tcin >> s[i][j];\n\t\t\ts[i][j] += s[i][j - 1];\n\t\t}\n\t}\n\t\n\tfor (int i = H; i >= 0; i--) {\n\t\tfor (int j = W; j >= 0; j--) {\n\t\t\tif (i == H)dp[i][j] = 0;\n\t\t\telse if (j == W)dp[i][j] = score(i, j) - dp[i + 1][j];\n\t\t\telse dp[i][j] = max(-dp[i][j + 1], score(i, j) - dp[i + 1][j]);\n\t\t}\n\t}\n\tcout << abs(dp[0][0]) << endl;\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\nconst int Maxh=1000+100;\n\nint h,w;\nint a[Maxh][Maxh];\nint l[Maxh][Maxh],r[Maxh][Maxh];\nint fl[Maxh][Maxh],fr[Maxh][Maxh],sl[Maxh][Maxh],sr[Maxh][Maxh];\nint Res;\n\nvoid BuildLR()\n{\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=w; j>=1; j--) r[i][j]=r[i][j+1]+a[i][j];\n        for (int j=1; j<=w; j++) l[i][j]=l[i][j-1]+a[i][j];\n    }\n}\n\nvoid BuildFSLR()\n{\n    for (int i=h; i>=1; i--)\n    {\n        for (int j=w+1; j>=0; j--)\n        {\n            fl[i][j]=sl[i+1][j]+l[i][j];\n            sl[i][j]=max(fl[i][j],sl[i][j+1]);\n            fr[i][j]=sr[i+1][j]+r[i][j];\n            sr[i][j]=max(fr[i][j],sr[i][j+1]);\n        }\n    }\n}\n\nvoid Solve()\n{\n    Res=0;\n    int i=1, j=0;\n    while (true)\n    {\n        if (fr[i][j+1]==sr[i][j+1]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n        if (fl[i][j]==sl[i][j]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n    }\n\n    int S=0;\n    for (int i=1; i<=h; i++) S+=r[i][1];\n    S-=Res; Res=abs(Res-S);\n}\n\nvoid PrintAll()\n{\n    cout << \"A\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << a[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"L\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << l[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"FL\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << fl[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"SL\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << sl[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"R\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << r[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"FR\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << fr[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"SR\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << sr[i][j] << \" \";\n        cout << '\\n';\n    }\n}\n\nint main()\n{\n    //freopen(\"inp.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1; i<=h; i++)\n    for (int j=1; j<=w; j++) scanf(\"%d\",&a[i][j]);\n\n    BuildLR();\n    BuildFSLR();\n    Solve();\n    //PrintAll();\n\n    printf(\"%d\",Res);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define up(i, a, b) for (int i = a, _b = b; i <= _b; i++)\n#define down(i, a, b) for (int i = a, _b = b; i >= _b; i--)\n#define long long long\n#define endl '\\n'\n#define X first\n#define Y second\n#define II pair<int, int>\n#define debug(X) cerr << #X << \" = \" << X << endl\n#define debug2(X, Y) cerr << #X << \" = \" << X << \" , \" << #Y << \" = \" << Y << endl\n#define show(X, a, b) { cerr << #X << \" = \"; up(_, a, b) cerr << X[_] << \" \"; cerr << endl; }\n#define gc getchar\n#define pc putchar\nusing namespace std;\ninline void read(int &x) {\n        register int c = gc();\n        x = 0;\n        int neg = 0;\n        for (; ((c<48 || c>57) && c != '-'); c = gc());\n        if(c=='-') {neg=1; c=gc();}\n        for(; c>47 && c<58; c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n        if(neg) x=-x;\n}\ninline void writeln(int x) {\n\n        char buffor[21];\n        register int i=0;\n        int neg=0; if (x<0) {neg=1; x= -x;}\n        do {\n                buffor[i++]=(x%10)+'0';\n                x/=10;\n        } while(x);\n        i--;\n        if (neg) pc('-');\n        while(i>=0) pc(buffor[i--]);\n        pc('\\n');\n}\nconst int N = 1010;\nint m, n, a[N][N], f[N][N];\nvoid input() {\n        cin >> n >> m;\n        up(i, 1, m)\n          up(j, 1, n)\n            cin >> a[i][j];\n}\nint query(int x, int y, int u, int v) {\n        return a[u][v] - a[x - 1][v] - a[u][y - 1] + a[x -1][y - 1];\n}\n\nvoid solve() {\n        up(i, 1, m)\n          up(j, 1, n)\n            a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];\n\n        f[m][n] = 0;\n        down(i, m, 0)\n         down(j, n, 0) {\n            if (i == m && j == n) continue;\n            if ((i + j) % 2 == 0) {\n                f[i][j] = -1e9; //try to maximize;\n                if (i + 1 <= m) f[i][j] = max(f[i][j], f[i + 1][j] + query(i + 1, j + 1, i + 1, n));\n                if (j + 1 <= n) f[i][j] = max(f[i][j], f[i][j + 1] - query(i + 1, j + 1, m, j + 1));\n            }\n            if ((i + j) % 2 == 1) {\n                f[i][j] = 1e9; //try to minimize;\n                if (i + 1 <= m) f[i][j] = min(f[i][j], f[i + 1][j] + query(i + 1, j + 1, i + 1, n));\n                if (j + 1 <= n) f[i][j] = min(f[i][j], f[i][j + 1] - query(i + 1, j + 1, m, j + 1));\n            }\n         }\n\n        cout << abs(f[0][0]) << endl;\n}\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL);\n\n  #ifdef I_Love_Pork\n  #define TASK \"tmp\"\n        freopen(TASK \".inp\",\"r\",stdin);\n        freopen(TASK \".out\",\"w\",stdout);\n  #endif\n\n\n        input();\n        solve();\n\n\n\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\nconst int Maxh=1000+100;\n\nint h,w;\nint a[Maxh][Maxh];\nint l[Maxh][Maxh],r[Maxh][Maxh];\nint fl[Maxh][Maxh],fr[Maxh][Maxh],sl[Maxh][Maxh],sr[Maxh][Maxh];\nint Res;\n\nvoid BuildLR()\n{\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=w; j>=1; j--) r[i][j]=r[i][j+1]+a[i][j];\n        for (int j=1; j<=w; j++) l[i][j]=l[i][j-1]+a[i][j];\n    }\n}\n\nvoid BuildFSLR()\n{\n    for (int i=h; i>=1; i--)\n    {\n        for (int j=w+1; j>=0; j--)\n        {\n            fl[i][j]=sl[i+1][j]+l[i][j];\n            sl[i][j]=max(fl[i][j],sl[i][j+1]);\n            fr[i][j]=sr[i+1][j]+r[i][j];\n            sr[i][j]=max(fr[i][j],sr[i][j+1]);\n        }\n    }\n}\n\nvoid Solve()\n{\n    Res=0;\n    int i=1, j=0;\n    while (true)\n    {\n        if (fr[i][j+1]==sr[i][j+1]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n        if (fl[i][j]==sl[i][j]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n    }\n\n    int S=0;\n    for (int i=1; i<=h; i++) S+=r[i][1];\n    S-=Res; Res=abs(Res-S);\n}\n\nvoid PrintAll()\n{\n    cout << \"A\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << a[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"L\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << l[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"FL\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << fl[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"SL\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << sl[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"R\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << r[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"FR\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << fr[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"SR\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << sr[i][j] << \" \";\n        cout << '\\n';\n    }\n}\n\nint main()\n{\n    //freopen(\"inp.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1; i<=h; i++)\n    for (int j=1; j<=w; j++) scanf(\"%d\",&a[i][j]);\n\n    BuildLR();\n    BuildFSLR();\n    Solve();\n    //PrintAll();\n\n    printf(\"%d\",Res);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint w, h; cin >> w >> h;\n\tvector<vi> v(h, vi(w));\n\tvector<vi> yoko(h + 1, vi(w + 1));\n\tvector<vi> tate(h + 1, vi(w + 1));\n\tvector<vi> dp(h + 1, vi(w + 1));\n\t\n\trep(i, h) rep(j, w) cin >> v[i][j];\n\tfor(int i = h - 1; i >= 0; i--) for(int j = w - 1; j >= 0; j--){\n\t\tyoko[i][j] = yoko[i][j + 1] + v[i][j];\n\t\ttate[i][j] = tate[i + 1][j] + v[i][j];\n\t}\n\tfor(int i = h; i >= 0; i--) for(int j = w; j >= 0; j--){\n\t\tif(i == h && j == w) continue;\n\t\t\n\t\tint mx = -inf, mn = inf;\n\t\tif(i + 1 <= h){\n\t\t\tmx = max(mx, dp[i + 1][j] + yoko[i][j]);\n\t\t\tmn = min(mn, dp[i + 1][j] + yoko[i][j]);\n\t\t}\n\t\tif(j + 1 <= w){\n\t\t\tmx = max(mx, dp[i][j + 1] - tate[i][j]);\n\t\t\tmn = min(mn, dp[i][j + 1] - tate[i][j]);\n\t\t}\n\t\tdp[i][j] = i + j & 1 ? mn : mx;\n\t}\n\tcout << abs(dp[0][0]) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0352\n\n#include<bits/stdc++.h>\nconst int N = 1005;\nconst int inf = 2e9;\nusing namespace std;\n\nint n, m, a[N][N], dp[N][N];\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> m >> n;\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> a[i][j];\n    for (int i = n; i >= 0; i--) for (int j = m; j >= 0; j--) a[i][j] += a[i+1][j] + a[i][j+1] - a[i+1][j+1];\n    dp[n][m] = 0;\n    for (int i = n; i >= 0; i--) for (int j = m; j >= 0; j--){\n        if (i == n && j == m) continue;\n        if ((i + j) % 2 == 0) {\n            dp[i][j] = -inf;\n            if (i < n) dp[i][j] = max(dp[i][j], dp[i+1][j] + a[i+1][j+1] - a[i+2][j+1]);\n            if (j < m) dp[i][j] = max(dp[i][j], dp[i][j+1] - a[i+1][j+1] + a[i+1][j+2]);\n        }\n        else {\n            dp[i][j] = inf;\n            if (i < n) dp[i][j] = min(dp[i][j], dp[i+1][j] + a[i+1][j+1] - a[i+2][j+1]);\n            if (j < m) dp[i][j] = min(dp[i][j], dp[i][j+1] - a[i+1][j+1] + a[i+1][j+2]);\n        }\n    }\n    cout << abs(dp[0][0]) << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=998244353;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint W,H,i,j;cin>>W>>H;\n\tstatic int dp[1001][1001];\n\t//1001^2のメモリを確保するので実質square1001(は?)\n\tstatic int yk[1001][1001]={};\n\tstatic int te[1001][1001]={};\n\tfor(i=0;i<H;i++){\n\t\tfor(j=0;j<W;j++){cin>>dp[i][j];}\n\t}\n\tfor(i=0;i<H;i++){\n\t\tint gen=0;\n\t\tfor(j=W-1;j>=0;j--){gen+=dp[i][j];yk[i][j]=gen;}\n\t}\n\tfor(j=0;j<W;j++){\n\t\tint gen=0;\n\t\tfor(i=H-1;i>=0;i--){gen+=dp[i][j];te[i][j]=gen;}\n\t}\n\tfor(i=0;i<=H;i++){dp[i][W]=0;}\n\tfor(j=0;j<=W;j++){dp[H][j]=0;}\n\tfor(i=H-1;i>=0;i--){\n\t\tfor(j=W-1;j>=0;j--){\n\t\t\tif((i+j)%2==0){dp[i][j]=max(dp[i+1][j]+yk[i][j],dp[i][j+1]-te[i][j]);}\n\t\t\telse{\t\t   dp[i][j]=min(dp[i+1][j]+yk[i][j],dp[i][j+1]-te[i][j]);}\n\t\t}\n\t}\n\tcout<<abs(dp[0][0])<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\nstruct RectangleSum{\n    vector<vector<i64>> sum;\n    i64 h, w;\n    RectangleSum(vector<vector<i64>>& v) :\n        h(v.size()),\n        w(v[0].size())\n    {\n        sum.assign(h + 1, vector<i64>(w + 1, 0));\n        for(i64 i = 0; i < h; ++i)\n            for(i64 j = 0; j < w; ++j)\n                sum[i + 1][j + 1] = v[i][j];\n\n        for(i64 i = 0; i < h + 1; ++i)\n            for(i64 j = 0; j < w; ++j)\n                sum[i][j + 1] += sum[i][j];\n        for(i64 j = 0; j < w + 1; ++j)\n            for(i64 i = 0; i < h; ++i)\n                sum[i + 1][j] += sum[i][j];\n    }\n    i64 getSum(i64 sx, i64 sy, i64 ex, i64 ey){\n        return sum[ex][ey] + sum[sx][sy] - sum[sx][ey] - sum[ex][sy];\n    }\n\n};\n\nsigned main(){\n    i64 w, h;\n    cin >> w >> h;\n    vector<vector<i64>> v(h, vector<i64>(w));\n    for(auto& x : v)\n        for(auto& y : x)\n            cin >> y;\n\n    RectangleSum r(v);\n\n    vector<vector<i64>> dp(h + 1, vector<i64>(w + 1, -INF));\n    dp[h][w] = 0;\n    function<i64(i64,i64)> f = [&](i64 x, i64 y){\n        if(dp[x][y] != -INF)\n            return dp[x][y];\n        i64 res_1 = (x == h ? -INF : -f(x + 1, y) + ((x + y) % 2 == 1 ? 1 : -1) * r.getSum(x, 0, x + 1, y));\n        i64 res_2 = (y == w ? -INF : -f(x, y + 1) + ((x + y) % 2 == 0 ? 1 : -1) * r.getSum(0, y, x, y + 1));\n        return dp[x][y] = max(res_1, res_2);\n    };\n    f(0, 0);\n    cout << abs(dp[0][0]) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll N = 1000 + 10;\nconst ll inf = 1e9 + 7;\n\nvoid maximize(ll &a, ll b) { a = max(a, b); }\nvoid minimize(ll &a, ll b) { a = min(a, b); }\n\nll n, m;\nll a[N][N];\n\nll dp[N][N];\nll vis[N][N];\nll col[N][N];\n\nll tx[3] = {0, 1};\nll ty[3] = {1, 0};\n\nll getCol(ll cid, ll l, ll r){\n\tif (r < l) return 0;\n\treturn col[cid][r] - col[cid][l - 1];\n}\n\nll dfs(ll i, ll j){\n\tif (vis[i][j]) return dp[i][j];\n\tif (i == n && j == m) \n\t\treturn dp[i][j] = 0;\n\tll turn = (i + j) % 2;\n\tdp[i][j] = (turn == 0 ? -inf : inf);\n\tfor (ll t = 0; t < 2; t++){\n\t\tll ni = tx[t] + i, nj = ty[t] + j;\n\t\tif (0 <= ni && ni <= n && 0 <= nj && nj <= m); else continue;\n\t\tll del = (t == 1 ? 0 : getCol(nj, 1, ni) - getCol(nj, ni + 1, n) );\n\t\tif (!turn) maximize( dp[i][j], dfs(ni, nj) + del);\n\t\telse\t   minimize( dp[i][j], dfs(ni, nj) + del);\n\t}\n\treturn dp[i][j];\n}\n\nmain(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\t// freopen(\"8.inp\", \"r\", stdin);\n\tcin >> m >> n;\n\tfor (ll i = 1; i <= n; i++)\n\t\tfor (ll j = 1; j <= m; j++)\n\t\t\tcin >> a[i][j];\n\t\n\tfor (ll j = 1; j <= m; j++){\n\t\tfor (ll i = 1; i <= n; i++)\n\t\t\tcol[j][i] = col[j][i - 1] + a[i][j];\n\t}\n\tcout << abs( dfs(0, 0) ) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int w,h,i,j,k,x,y,z=0,ans=0;\n  cin>>w>>h;\n  int m[h][w];\n  int s[h][w+4];\n  int s2[h+4][w];\n  memset(s,0,sizeof(s));\n  memset(s2,0,sizeof(s2));\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      cin>>m[i][j];\n      z+=m[i][j];\n    }\n  }\n\n  //cout << z << endl;\n  \n  for(i=0;i<h;i++){\n    s[i][w]=0;\n    for(j=w;j>0;j--){\n      s[i][j-1]=s[i][j]+m[i][j-1];\n    }\n  }\n\n  for(j=0;j<w;j++){\n    s2[h][j]=0;\n    for(i=h;i>0;i--){\n      s2[i-1][j]=s2[i][j]+m[i-1][j];\n    }\n  }\n  /*\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      cout << s[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      cout << s2[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  //*/\n  bool t=1;\n  x=0;y=0;\n  while(x<w&&y<h){\n    //cout << x << \" \" << y << endl;\n    if(t)\n      if(s[y][x+1]>s[y][x]&&s[y][x+2]>s[y][x]) x++;\n      else ans+=s[y][x],y++;\n    else\n      if(s2[y+1][x]>s2[y][x]&&s2[y+2][x]>s2[y][x]) ans+=s[y][x],y++;\n      else x++;\n    t=!t;\n  }\n  //cout << ans << endl;\n  cout << abs(z-ans*2) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_H 1005\n#define MAX_W 1005\nll INF=(1LL<<50);\nint H,W;\nll t[MAX_H][MAX_W];\nll u[MAX_H][MAX_W];\nll dp[MAX_H][MAX_W];\n\nint dy[]={-1,0};\nint dx[]={0,-1};\n\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      u[i][j+1]=t[i][j]+u[i][j];\n    }\n  }\n\n  dp[H][W]=0;\n  for(int i=H;i>=0;i--){\n    for(int j=W;j>=0;j--){\n      if(i==H&&j==W)continue;\n      \n      if((i+j)&1){\n        dp[i][j]=INF;\n        if(j+1<=W)dp[i][j]=min(dp[i][j],dp[i][j+1]);\n        if(i+1<=H)dp[i][j]=min(dp[i][j],u[i][W]-u[i][j]-u[i][j]+dp[i+1][j]);\n      }else{\n        dp[i][j]=-INF;\n        if(j+1<=W)dp[i][j]=max(dp[i][j],dp[i][j+1]);\n        if(i+1<=H)dp[i][j]=max(dp[i][j],u[i][W]-u[i][j]-u[i][j]+dp[i+1][j]);\n      }\n    }\n  }\n\n  cout<< abs(dp[0][0]) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define endl '\\n'\n#define pque priority_queue\n#define pi acos(-1)\n#define int long long\n#define N 1000000\ntypedef pair < int, int > ii;\ntypedef vector < int > vi;\nconst int mod = 1000000007;\nint n, m, a[1009][1009], f[1009][1009], row[1009][1009], col[1009][1009];\nsigned main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin >> n >> m;\n\tswap(n, m);\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= m; j ++)\n\t\t\tcin >> a[i][j];\n\tfor(int i = n; i > 0; i --)\n\t\tfor(int j = m; j > 0; j --)\n\t\t{\n\t\t\tcol[i][j] = col[i + 1][j] + a[i][j];\n\t\t\trow[i][j] = row[i][j + 1] + a[i][j];\n\t\t\tif((i + j) % 2)\n\t\t\t\tf[i][j] = max(f[i][j + 1] + col[i][j], f[i + 1][j] - row[i][j]);\n\t\t\telse\n\t\t\t\tf[i][j] = min(f[i][j + 1] + col[i][j], f[i + 1][j] - row[i][j]);\n\t\t\t//cout << i << ' ' << j << ' ' << f[i][j] << endl;\n\t\t}\n\tcout << abs(f[1][1]) << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*input\n2 1\n-2 1\n\n5 4\n5 3 2 -5 2\n2 -4 2 8 -4\n2 3 -7 6 7\n3 -4 10 -3 -3\n\n2 2\n2 -3\n3 -1\n\n\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define int long long\n#define N 1005\n#define bit(x,y) ((x>>y)&1LL)\nconst int INF = 1e18;\n\nint n, m;\nint a[N][N];\nint dp[N][N][2];\nint sum[N][N];\n// p1 - p2\n\nint cal(int x, int y, int type) {\n\tif (x == n && y == m) return 0;\n\tint &ret = dp[x][y][type];\n\tif (ret != INF) return ret;\n\n\tif (type == 0) {\n\t\tret = -INF;\n\t\tif (x != n) {\n\t\t\tret = max(ret, cal(x + 1, y, 1));\n\t\t}\n\t\tif (y != m) {\n\t\t\tret = max(ret, cal(x, y + 1, 1) + sum[y + 1][x] - (sum[y + 1][n] - sum[y + 1][x]));\n\t\t}\n\t}\n\telse {\n\t\tret = INF;\n\t\tif (x != n) {\n\t\t\tret = min(ret, cal(x + 1, y, 0));\n\t\t}\n\t\tif (y != m) {\n\t\t\tret = min(ret, cal(x, y + 1, 0) + sum[y + 1][x] - (sum[y + 1][n] - sum[y + 1][x]));\n\t\t}\n\t}\n\treturn ret;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> m >> n;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> a[i][j];\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) sum[i][j] = sum[i][j - 1] + a[j][i];\n\t}\n\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++)\tdp[i][j][0] = dp[i][j][1] = INF;\n\tcout << abs(cal(0, 0, 0)) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint f[1069][1069][2],da[1069][1069],w,h,a[1069][1069];\nint cal(int x,int y,int turn){\n    if (f[x][y][turn]!=-1)return f[x][y][turn];\n    if (x>=w) return 0;\n        int re;\n    if (turn==0){\n        re=-1e9;\n        if (y+1<=h) re=max(re,cal(x,y+1,1-turn));\n        re=max(re,cal(x+1,y,1-turn)-da[x+1][h]+2*da[x+1][y]);\n    }\n    else { re=1e9;\n        if (y+1<=h) re=min(re,cal(x,y+1,1-turn));\n        re=min(re,cal(x+1,y,1-turn)-da[x+1][h]+2*da[x+1][y]);\n\n    }\n    return f[x][y][turn]=re;\n}\nint main(){\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1;i<=h;i++)\n        for (int j=1;j<=w;j++) scanf(\"%d\",&a[j][i]);\n    for (int i=1;i<=w;i++)\n        for (int j=1;j<=h;j++) da[i][j]=da[i][j-1]+a[i][j];\n    memset(f,-1,sizeof(f));\n    cout<<abs(cal(0,0,0))<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint dp[1005][1005],t[1005][1005],T,a,m,n,o;\nint dq(int x,int y)\n{\n    if (x==m && y==n)\n        return 0;\n    if (dp[x][y]!=o)\n        return dp[x][y];\n\n    vector<int> v;\n\n    if (x<m)\n        v.push_back(dq(x+1,y));\n    if (y<n)\n        v.push_back(dq(x,y+1)+t[x][y+1]-(t[m][y+1]-t[x][y+1]));\n\n    int h=(x+y)%2,kq;\n    if (h==0)\n    {\n        kq=-o;\n        for (int i=0; i<v.size(); ++i)\n            kq=max(kq,v[i]);\n    }\n    else\n    {\n        kq=o;\n        for (int i=0; i<v.size(); ++i)\n            kq=min(kq,v[i]);\n\n    }\n    return dp[x][y]=kq;\n\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin>>n>>m;\n    for (int i=1; i<=m; ++i)\n        for (int j=1; j<=n; ++j)\n        {\n            cin>>a;\n            t[i][j]=t[i-1][j]+a;\n            T+=a;\n        }\n    o=2000000000;\n    for (int i=0; i<=m; ++i)\n        for (int j=0; j<=n; ++j)\n            dp[i][j]=o;\n    a=(dq(0,0));\n    if (a<0)a=-a;\n    cout<<a<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\nint H, W;\nvector<vector<int>>sums;\nint solve(vector<vector<vector<int>>>&memo,int nowx, int nowy, bool fst) {\n\tif (memo[nowy][nowx][fst] == 1e9 + 1) {\n\t\tif (nowx == W&&nowy == H) {\n\t\t\tmemo[nowy][nowx][fst] = 0;\n\t\t}\n\t\telse {\n\t\t\tint nans = -1e9 - 1;\n\t\t\tif (fst) {\n\t\t\t\tif (nowx != W) {\n\t\t\t\t\tnans = max(nans, -solve(memo, nowx + 1, nowy, !fst) + sums[nowy][nowx]);\n\t\t\t\t}\n\t\t\t\tif (nowy !=H) {\n\t\t\t\t\tnans = max(nans, -solve(memo, nowx, nowy + 1, !fst));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (nowx != W) {\n\t\t\t\t\tnans = max(nans, -solve(memo, nowx + 1, nowy, !fst) - sums[nowy][nowx]);\n\t\t\t\t}\n\t\t\t\tif (nowy !=H) {\n\t\t\t\t\tnans = max(nans, -solve(memo, nowx, nowy + 1, !fst));\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[nowy][nowx][fst] = nans;\n\t\t}\n\t\t\n\t}\n\treturn memo[nowy][nowx][fst];\n}\n\nint main() {\n\tcin >> W >> H;\n\tvector<vector<int>>field(H, vector<int>(W));\n\tint all_sum = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> field[i][j];\n\t\t\tall_sum += field[i][j];\n\t\t}\n\t}\n\tsums=vector<vector<int>>(H + 1, vector<int>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tsums[i + 1][j] = sums[i][j] + field[i][j];\n\n\t\t}\n\t}\n\tvector<vector<vector<int>>>memo(H + 1, vector<vector<int>>(W + 1, vector<int>(2,1e9+1)));\n\tauto ans = solve(memo, 0, 0, true);\n\tcout << abs(2 * ans - all_sum) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\nconst int Maxh=1000+100;\n\nint h,w;\nint a[Maxh][Maxh];\nint l[Maxh][Maxh],r[Maxh][Maxh];\nint fl[Maxh][Maxh],fr[Maxh][Maxh],sl[Maxh][Maxh],sr[Maxh][Maxh];\nint Res;\n\nvoid BuildLR()\n{\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=w; j>=1; j--) r[i][j]=r[i][j+1]+a[i][j];\n        for (int j=1; j<=w; j++) l[i][j]=l[i][j-1]+a[i][j];\n    }\n}\n\nvoid BuildFSLR()\n{\n    for (int i=h; i>=1; i--)\n    {\n        for (int j=w+1; j>=0; j--)\n        {\n            fl[i][j]=sl[i+1][j]+l[i][j];\n            sl[i][j]=max(fl[i][j],sl[i][j+1]);\n            fr[i][j]=sr[i+1][j]+r[i][j];\n            sr[i][j]=max(fr[i][j],sr[i][j+1]);\n        }\n    }\n}\n\nvoid Solve()\n{\n    Res=0;\n    int i=1, j=0;\n    while (true)\n    {\n        if (fr[i][j+1]==sr[i][j+1]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n        if (fl[i][j]==sl[i][j]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n    }\n\n    int S=0;\n    for (int i=1; i<=h; i++) S+=r[i][1];\n    S-=Res; Res=abs(Res-S);\n}\n\nvoid PrintAll()\n{\n    cout << \"A\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << a[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"L\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << l[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"FL\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << fl[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"SL\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << sl[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"R\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << r[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"FR\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << fr[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"SR\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << sr[i][j] << \" \";\n        cout << '\\n';\n    }\n}\n\nint main()\n{\n    //freopen(\"inp.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1; i<=h; i++)\n    for (int j=1; j<=w; j++) scanf(\"%d\",&a[i][j]);\n\n    BuildLR();\n    BuildFSLR();\n    Solve();\n    //PrintAll();\n\n    printf(\"%d\",Res);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll N = 1000 + 10;\nconst ll inf = 1e9 + 7;\n\nvoid maximize(ll &a, ll b) { a = max(a, b); }\nvoid minimize(ll &a, ll b) { a = min(a, b); }\n\nll n, m;\nll a[N][N];\n\nll dp[N][N];\nll vis[N][N];\nll col[N][N];\n\nll tx[3] = {0, 1};\nll ty[3] = {1, 0};\n\nll getCol(ll cid, ll l, ll r){\n\tif (r < l) return 0;\n\treturn col[cid][r] - col[cid][l - 1];\n}\n\nll dfs(ll i, ll j){\n\tif (vis[i][j]) return dp[i][j];\n\tif (i == n && j == m) \n\t\treturn dp[i][j] = 0;\n\tll turn = (i + j) % 2;\n\tdp[i][j] = (turn == 0 ? -inf : inf);\n\tfor (ll t = 0; t < 2; t++){\n\t\tll ni = tx[t] + i, nj = ty[t] + j;\n\t\tif (0 <= ni && ni <= n && 0 <= nj && nj <= m); else continue;\n\t\tll del = (t == 1 ? 0 : getCol(nj, 1, ni) - getCol(nj, ni + 1, n) );\n\t\tif (!turn) maximize( dp[i][j], dfs(ni, nj) + del);\n\t\telse\t   minimize( dp[i][j], dfs(ni, nj) + del);\n\t}\n\treturn dp[i][j];\n}\n\nmain(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\t// freopen(\"8.inp\", \"r\", stdin);\n\tcin >> m >> n;\n\tfor (ll i = 1; i <= n; i++)\n\t\tfor (ll j = 1; j <= m; j++)\n\t\t\tcin >> a[i][j];\n\t\n\tfor (ll j = 1; j <= m; j++){\n\t\tfor (ll i = 1; i <= n; i++)\n\t\t\tcol[j][i] = col[j][i - 1] + a[i][j];\n\t}\n\tcout << abs( dfs(0, 0) );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fto(i, x, y) for(int i = (x); i <= (y); ++i)\n#define fdto(i, x, y) for(int i = (x); i >= (y); --i)\n#define ftoa(i, x, y, a) for(int i = (x); i <= (y); i += a)\n#define ftoit(it, var) for (__typeof(var.begin()) it = var.begin(); it != var.end(); ++it)\n\n#define ii pair<int, int>\n#define mp make_pair\n#define FF first\n#define SS second\n\n#define vi vector<int>\n#define vii vector<ii>\n#define ll long long\n#define vll vector<ll>\n\n#define eb emplace_back\n#define ef emplace_front\n#define lb lower_bound\n#define ub upper_bound\n#define sz(a) (int)a.size()\n\n#define oo 1000000007\n#define OO 1000000000000000007LL\n\nusing namespace std;\n\n#define Pro \"tmp\"\n#define maxN 1507\n\nint f[maxN][maxN][5], dp[maxN][maxN];\nint a[maxN][maxN];\n\nint main() {\n    #ifndef ONLINE_JUDGE\n        freopen(Pro\".inp\", \"r\", stdin);\n        freopen(Pro\".out\", \"w\", stdout);\n    #endif // ONLINE_JUDGE\n\n    int n, m;\n    scanf(\"%d%d\", &m, &n);\n\n    fto (i, 1, n) {\n        fto (j, 1, m) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n\n    fdto (i, n, 1) {\n        fdto (j, m, 1) {\n            dp[i][j] = dp[i+1][j]+dp[i][j+1]-dp[i+1][j+1]+a[i][j];\n        }\n    }\n\n    fdto (sum, n+m, 2) {\n        fto (i, 1, n) {\n            int j = sum-i;\n            if (j < 1 || j > m) continue;\n\n            f[i][j][0] = max(dp[i][j]-f[i+1][j][1], dp[i][j+1]-f[i][j+1][1]);\n            f[i][j][1] = max(dp[i+1][j]-f[i+1][j][0], dp[i][j]-f[i][j+1][0]);\n        }\n    }\n\n//    fto (i, 1, n) {\n//        fto (j, 1, m) printf(\"%3d\", dp[i][j]);\n//        puts(\"\");\n//    }\n//    puts(\"\");\n//\n//    fto (i, 1, n) {\n//        fto (j, 1, m) printf(\"%3d\", f[i][j][0]);\n//        puts(\"\");\n//    }\n//    puts(\"\");\n//\n//    fto (i, 1, n) {\n//        fto (j, 1, m) printf(\"%3d\", f[i][j][1]);\n//        puts(\"\");\n//    }\n\n    cout << abs(dp[1][1]-2*f[1][1][0]) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std::chrono;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing pq_int=priority_queue<int,vector<int>,greater<int>>;\nconst ll LINF=0x3fffffffffffffff;\nconst ll MOD=1000000007;\nconst ll MODD=0x3b800001;\nconst int INF=0x3fffffff;\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep1(n) _rep2(i,n)\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(ll i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_rep4,_rep3,_rep2,_rep1)(__VA_ARGS__)\n#define _rrep1(n) _rrep2(i,n)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(ll i=b-1;i>=a;i--)\n#define _rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrep4,_rrep3,_rrep2,_rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto&& i:a)\n#define sum(...) accumulate(range(__VA_ARGS__),0LL)\n#define _range(i) (i).begin(),(i).end()\n#define _range2(i,k) (i).begin(),(i).begin()+k\n#define _range3(i,a,b) (i).begin()+a,(i).begin()+b\n#define range(...) _overload3(__VA_ARGS__,_range3,_range2,_range)(__VA_ARGS__)\n#define Yes(i) out(i?\"Yes\":\"No\")\n#define YES(i) out(i?\"YES\":\"NO\")\n//#define START auto start=system_clock::now()\n//#define END auto end=system_clock::now();cerr<<duration_cast<milliseconds>(end-start).count()<<\" ms\\n\"\n#define elif else if\n#define unless(a) if(!(a))\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n__attribute__((constructor)) void SETTINGS(){cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(15);};\ntemplate<class T>\ninline constexpr T gcd (T a,T b) {if(a==b)return a;else return gcd(b,(a-1)%b+1);}\ntemplate<class T>\ninline constexpr T min(vector<T>& v){return *min_element(range(v));}\ninline char min(string& v){return *min_element(range(v));}\ntemplate<class T>\ninline constexpr T max(vector<T>& v){return *max_element(range(v));}\ninline char max(string& v){return *max_element(range(v));}\ntemplate<typename T>\ninline bool update_min(T& mn,const T& cnt){if(mn>cnt){mn=cnt;return 1;}else return 0;}\ntemplate<typename T>\ninline bool update_max(T& mx,const T& cnt){if(mx<cnt){mx=cnt;return 1;}else return 0;}\ninline void in() {}\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& vec);\ntemplate<class T,size_t size>\nistream& operator >> (istream& is, array<T,size>& vec);\ntemplate<class T,class L>\nistream& operator >> (istream& is, pair<T,L>& p);\ntemplate<class T>\nostream& operator << (ostream& os, vector<T>& vec);\ntemplate<class T,class L>\nostream& operator << (ostream& os, pair<T,L>& p);\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& vec){for(T& x: vec) is >> x;return is;}\ntemplate<class T,class L>\nistream& operator >> (istream& is, pair<T,L>& p){is >> p.first;is >> p.second;return is;}\ntemplate<class T>\nostream& operator << (ostream& os, vector<T>& vec){os << vec[0];rep(i,1,vec.size()){os << ' ' << vec[i];}return os;}\ntemplate<class T>\nostream& operator << (ostream& os, deque<T>& deq){os << deq[0];rep(i,1,deq.size()){os << ' ' << deq[i];}return os;}\ntemplate<class T,class L>\nostream& operator << (ostream& os, pair<T,L>& p){os << p.first << \" \" << p.second;return os;}\ntemplate <class Head, class... Tail>\ninline void in(Head&& head,Tail&&... tail){cin>>head;in(move(tail)...);}\ntemplate <class T>\ninline void out(T t){cout<<t<<'\\n';}\ninline void out(){cout<<'\\n';}\ntemplate <class Head, class... Tail>\ninline void out(Head head,Tail... tail){cout<<head<<' ';out(move(tail)...);}\ntemplate <class T>\ninline void err(T t){cerr<<t<<'\\n';}\ninline void err(){cerr<<'\\n';}\ntemplate <class Head, class... Tail>\ninline void err(Head head,Tail... tail){cerr<<head<<' ';out(move(tail)...);}\n\n\nll w=1000,h=1000;\nvv(ll,s,h,w);\nvv(ll,mem,h,w,LINF);\nll dp(int y,int x){\n    if(x==w||y==h)return 0;\n    if(mem[y][x]-LINF)return mem[y][x];\n    ll sum=0,sum2=0;\n    rep(i,x,w)sum+=s[y][i];\n    rep(i,y,h)sum2+=s[i][x];\n    if((x+y)&1) return mem[y][x]=min(dp(y+1,x)+sum,dp(y,x+1)-sum2);\n    else return mem[y][x]=max(dp(y+1,x)+sum,dp(y,x+1)-sum2);\n}\nsigned main(){\n    in(w,h);\n    rep(h)rep(j,w)in(s[i][j]);\n    out(abs(dp(0, 0)));\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint W, H, S[1000][1000];\nint ei1333[1000][1001];\nint beet[1000][1001];\nint dp[1001][1001];\n\nint rec(int x, int y, bool which)\n{\n  if(x == W && y == H) return (0);\n  if(~dp[x][y]) return (dp[x][y]);\n\n  int ret = -INF;\n  if(!which) {\n    int get = 0;\n    if(y + 1 <= H) {\n      get += (ei1333[y][W] - ei1333[y][x]);\n      ret = max(ret, get - rec(x, y + 1, 1));\n      get = 0;\n    }\n    if(x + 1 <= W) {\n      get -= (beet[x][H] - beet[x][y]);\n      ret = max(ret, get - rec(x + 1, y, 1));\n    }\n  } else {\n    int get = 0;\n    if(y + 1 <= H) {\n      get -= (ei1333[y][W] - ei1333[y][x]);\n      ret = max(ret, get - rec(x, y + 1, 0));\n    }\n    if(x + 1 <= W) {\n      get = 0;\n      get += (beet[x][H] - beet[x][y]);\n      ret = max(ret, get - rec(x + 1, y, 0));\n    }\n  }\n\n  return (dp[x][y] = ret);\n}\n\nint main()\n{\n  scanf(\"%d %d\", &W, &H);\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) scanf(\"%d\", &S[i][j]);\n  }\n\n  for(int i = 0; i < H; i++) {\n    ei1333[i][0] = 0;\n    for(int j = 1; j <= W; j++) ei1333[i][j] += ei1333[i][j - 1] + S[i][j - 1];\n  }\n  for(int i = 0; i < W; i++) {\n    beet[i][0] = 0;\n    for(int j = 1; j <= H; j++) beet[i][j] += beet[i][j - 1] + S[j - 1][i];\n  }\n\n  memset(dp, -1, sizeof(dp));\n  cout << abs(rec(0, 0, 0)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n#define let auto const\n\ntemplate<typename... Types>\nstruct dynarr: std::vector<Types...> {\n  using std::vector<Types...>::vector;\n  using size_type = typename std::vector<Types...>::size_type;\n  auto&& operator[](size_type i) { return this->at(i); }\n  auto&& operator[](size_type i) const { return this->at(i); }\n};\n\nint main() {\n  i64 W, H;\n  cin >> W >> H;\n  dynarr<dynarr<i64>> s(H, dynarr<i64>(W));\n  rep(i,0,H) rep(j,0,W) cin >> s[i][j];\n  dynarr<dynarr<i64>> Hsum(H + 1, dynarr<i64>(W));\n  dynarr<dynarr<i64>> Wsum(H, dynarr<i64>(W + 1));\n  rep(j,0,W) rep(i,0,H) {\n    Hsum[i + 1][j] = Hsum[i][j] + s[i][j];\n  }\n  rep(i,0,H) rep(j,0,W) {\n    Wsum[i][j + 1] = Wsum[i][j] + s[i][j];\n  }\n  dynarr<dynarr<i64>> dp(H + 1, dynarr<i64>(W + 1));\n  dp[H][W] = 0;\n  for(int i = H; i >= 0; i--) {\n    for(int j = W;j >= 0;j--) {\n      if(i == H && j == W) continue;\n      if((i + j) % 2 == 0) {\n        dp[i][j] = -1e18;\n        // left ... +\n        if(j + 1 <= W) {\n          dp[i][j] = max(dp[i][j], dp[i][j + 1] + Hsum[i][j]);\n        }\n        // up ... -\n        if(i + 1 <= H) {\n          dp[i][j] = max(dp[i][j], dp[i + 1][j] - Wsum[i][j]);\n        }\n      }\n      else {\n        dp[i][j] = 1e18;\n        if(j + 1 <= W) {\n          dp[i][j] = min(dp[i][j], dp[i][j + 1] + Hsum[i][j]);\n        }\n        // up ... +\n        if(i + 1 <= H) {\n          dp[i][j] = min(dp[i][j], dp[i + 1][j] - Wsum[i][j]);\n        }\n      }\n    }\n  }\n  cout << abs(dp[0][0]) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nusing int64 = long long;\nusing i64 = int64;\n\nconst int inf = 1<<30;\nconst int64 inf64 = 1ll<<60;\n\n#define rep(i,N) for(int i=0; i<(int)N; ++i)\n\nint64 dp[1001][1001];\nint s[1001][1001];\ni64 sumh[1001][1001], sumw[1001][1001];\n\nsigned main() {\n\tint W, H; cin >> W >> H;\n\trep(i, H) rep(j, W) cin >> s[i][j];\n\t\n\trep(i, H) {\n\t\tsumh[i][0] = s[i][0];\n\t\tfor(int j=1; j<W; ++j) sumh[i][j] += sumh[i][j-1] + s[i][j];\n\t}\n\trep(j, W) {\n\t\tsumw[0][j] = s[0][j];\n\t\tfor(int i=1; i<H; ++i) sumw[i][j] += sumw[i-1][j] + s[i][j];\n\t}\n\t\n\tdp[H-1][W-1] = 0;\n\tfor(int i=H; i>=0; --i) {\n\t\tfor(int j=W; j>=0; --j) {\n\t\t\tif(i == H && j == W) continue;\n\t\t\t\n\t\t\ti64 n1 = inf64;\n\t\t\tif(i + 1 <= H) {\n\t\t\t\tif(j != 0) n1 = dp[i+1][j] + (sumh[i][W-1] - sumh[i][j-1]);\n\t\t\t\telse n1 = dp[i+1][j] + sumh[i][W-1];\n\t\t\t}\n\t\t\t\n\t\t\ti64 n2 = inf64;\n\t\t\tif(j + 1 <= W) {\n\t\t\t\tif(i != 0) n2 = dp[i][j+1] - (sumw[H-1][j] - sumw[i-1][j]);\n\t\t\t\telse n2 = dp[i][j+1] - sumw[H-1][j];\n\t\t\t}\n\t\t\t\n\t\t\tif((i + j) % 2 == 0) {\n\t\t\t\tif(n1 == inf64) dp[i][j] = n2;\n\t\t\t\telse if(n2 == inf64) dp[i][j] = n1;\n\t\t\t\telse dp[i][j] = max({ n1, n2});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = min({n1, n2});\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\trep(i, H + 1) {\n\t\trep(j, W + 1) cout << dp[i][j] << \" \";\n\t\tcout << endl;\n\t}*/\n\t\n\t\n\tcout << abs(dp[0][0]) << endl;\n}\n\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#define Link \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0352\"\n\n#include <iostream>\n#include <cstdio>\n\n#define TASK \"Forecast of Forces\"\n\nusing namespace std;\n\nvoid OpenFile()\n{\n    freopen(TASK\".INP\",\"r\",stdin);\n    freopen(TASK\".OUT\",\"w\",stdout);\n}\n\nconst int maxn = 1e3 + 1;\nint w,h,a[maxn][maxn],d[maxn][maxn],f[maxn][maxn];\n\nvoid Enter()\n{\n    cin >> w >> h;\n    for (int i=1;i<=h;++i)\n        for (int j=1;j<=w;++j)\n            cin >> a[i][j];\n}\n\nvoid Init()\n{\n    for (int i=1;i<=h;++i) {\n        for (int j=1;j<=w;++j)\n            d[i][0] -= a[i][j];\n        for (int j=1;j<=w;++j)\n            d[i][j] = d[i][j-1] + 2 * a[i][j];\n//        for (int j=0;j<=w;++j)\n//            cout << i << ' ' << j << ' ' << d[i][j] << ' ' << a[i][j] << '\\n';\n    }\n}\n\nvoid Solve()\n{\n    f[0][0] = 0;\n    for (int i=0;i<=h;++i)\n        for (int j=0;j<=w;++j) {\n            if (i != 0 || j != 0)\n                if (i == 0)\n                    f[i][j] = f[i][j-1];\n                else\n                    if (j == 0)\n                        f[i][j] = f[i-1][j] + d[i][j];\n                    else\n                        if ((i+j) % 2)\n                            f[i][j] = max(f[i][j-1],f[i-1][j]+d[i][j]);\n                        else\n                            f[i][j] = min(f[i][j-1],f[i-1][j]+d[i][j]);\n//            cout << i << ' ' << j << ' ' << f[i][j] << '\\n';\n        }\n    cout << max(f[h][w],-f[h][w]) << '\\n';\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    //OpenFile();\n\n    Enter();\n    Init();\n    Solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define Link \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0352\"\n\n#include <iostream>\n#include <cstdio>\n\n#define TASK \"Forecast of Forces\"\n\nusing namespace std;\n\nvoid OpenFile()\n{\n    freopen(TASK\".INP\",\"r\",stdin);\n    freopen(TASK\".OUT\",\"w\",stdout);\n}\n\nconst int maxn = 1e3 + 1;\nint w,h,a[maxn][maxn],d[maxn][maxn],f[maxn][maxn];\n\nvoid Enter()\n{\n    cin >> w >> h;\n    for (int i=1;i<=h;++i)\n        for (int j=1;j<=w;++j)\n            cin >> a[i][j];\n}\n\nvoid Init()\n{\n    for (int i=1;i<=h;++i) {\n        for (int j=1;j<=w;++j)\n            d[i][0] -= a[i][j];\n        for (int j=1;j<=w;++j)\n            d[i][j] = d[i][j-1] + 2 * a[i][j];\n//        for (int j=0;j<=w;++j)\n//            cout << i << ' ' << j << ' ' << d[i][j] << ' ' << a[i][j] << '\\n';\n    }\n}\n\nvoid Solve()\n{\n    f[0][0] = 0;\n    for (int i=0;i<=h;++i)\n        for (int j=0;j<=w;++j) {\n            if (i != 0 || j != 0)\n                if (i == 0)\n                    f[i][j] = f[i][j-1];\n                else\n                    if (j == 0)\n                        f[i][j] = f[i-1][j] + d[i][j];\n                    else\n                        if ((i+j) % 2)\n                            f[i][j] = max(f[i][j-1],f[i-1][j]+d[i][j]);\n                        else\n                            f[i][j] = min(f[i][j-1],f[i-1][j]+d[i][j]);\n//            cout << i << ' ' << j << ' ' << f[i][j] << '\\n';\n        }\n    cout << max(f[h][w],-f[h][w]);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    //OpenFile();\n\n    Enter();\n    Init();\n    Solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\nconst int Maxh=1000+100;\n\nint h,w;\nint a[Maxh][Maxh];\nint l[Maxh][Maxh],r[Maxh][Maxh];\nint fl[Maxh][Maxh],fr[Maxh][Maxh],sl[Maxh][Maxh],sr[Maxh][Maxh];\nint Res;\n\nint abs(int a)\n{\n    if (a<0) a=-a;\n    return a;\n}\n\nvoid BuildLR()\n{\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=w; j>=1; j--) r[i][j]=r[i][j+1]+a[i][j];\n        for (int j=1; j<=w; j++) l[i][j]=l[i][j-1]+a[i][j];\n    }\n}\n\nvoid BuildFSLR()\n{\n    for (int i=h; i>=1; i--)\n    {\n        for (int j=w+1; j>=0; j--)\n        {\n            fl[i][j]=sl[i+1][j]+l[i][j];\n            sl[i][j]=max(fl[i][j],sl[i][j+1]);\n            fr[i][j]=sr[i+1][j]+r[i][j];\n            sr[i][j]=max(fr[i][j],sr[i][j+1]);\n        }\n    }\n}\n\nvoid Solve()\n{\n    Res=0;\n    int i=1, j=0;\n    while (true)\n    {\n        if (fr[i][j+1]==sr[i][j+1]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n        if (fl[i][j]==sl[i][j]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n    }\n\n    int S=0;\n    for (int i=1; i<=h; i++) S+=r[i][1];\n    S-=Res; Res=abs(Res-S);\n}\n\nvoid PrintAll()\n{\n    cout << \"A\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << a[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"L\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << l[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"FL\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << fl[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"SL\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << sl[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"R\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << r[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"FR\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << fr[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"SR\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << sr[i][j] << \" \";\n        cout << '\\n';\n    }\n}\n\nint main()\n{\n    //freopen(\"inp.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1; i<=h; i++)\n    for (int j=1; j<=w; j++) scanf(\"%d\",&a[i][j]);\n\n    BuildLR();\n    BuildFSLR();\n    Solve();\n    //PrintAll();\n\n    printf(\"%d\",Res);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\nint H,W;\nint S[1111][1111];\n\nint memo[1111][1111];\n\nint dfs(int y,int x){\n    int &ret=memo[y][x];\n    if(y==H&&x==W)return 0;\n    if(ret!=INF)return ret;\n\n    int t=(y+x)&1;\n    if(t==0){\n        ret=-INF;\n        if(y!=H)chmax(ret,dfs(y+1,x));\n        if(x!=W)chmax(ret,dfs(y,x+1)+S[y][x]);\n    }\n    else{\n        ret=INF;\n        if(y!=H)chmin(ret,dfs(y+1,x));\n        if(x!=W)chmin(ret,dfs(y,x+1)+S[y][x]);\n    }\n    return ret;\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&W,&H);\n    rep(i,H)rep(j,W)scanf(\"%lld\",&S[i+1][j]),S[i+1][j]+=S[i][j];\n\n    fill_n(*memo,1111*1111,INF);\n    int sum=0;\n    rep(i,W)sum+=S[H][i];\n    cout<<abs(sum-2*dfs(0,0))<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(x, a, b) for (int x = a; x <= b; ++x)\n#define FOD(x, a, b) for (int x = a; x >= b; --x)\n#define REP(x, a, b) for (int x = a; x < b; ++x)\n#define DEBUG(X) { cout << #X << \" = \" << X << endl; }\n#define PR(A, n) { cout << #A << \" = \"; FOR(_, 1, n) cout << A[_] << \" \"; cout << endl; }\n#define PR0(A, n)  { cout << #A << \" = \"; REP(_, 0, n) cout << A[_] << \" \"; cout << endl; }\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> II;\n\nconst int N = 1e3 + 10;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\nint dp[N][N], a[N][N], s[N][N];\n\nbool Inside(int x, int y) {\n    return 1 <= x && x <= n + 1 && 0 <= y && y <= m;\n}\n\nint DP(int i, int j) {\n    if (i == n + 1 && j == m) return 0;\n    int &ans = dp[i][j];\n    if (ans != -1) return ans;\n    ans = -INF;\n    // R\n    if (Inside(i, j + 1)) ans = max(ans, -DP(i, j + 1));\n    // D\n    bool first = ((i + j) % 2 == 1);\n    int sum = (s[i][m] - s[i][j]) - s[i][j];\n    if (Inside(i + 1, j)) ans = max(ans, -DP(i + 1, j) + (first ? sum : -sum));\n    return ans;\n}\n\nint main() {\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif // LOCAL\n    scanf(\"%d%d\", &m, &n);\n    FOR(i, 1, n)\n        FOR(j, 1, m) scanf(\"%d\", &a[i][j]);\n    FOR(i, 1, n)\n        FOR(j, 1, m) s[i][j] = s[i][j - 1] + a[i][j];\n    memset(dp, -1, sizeof dp);\n    cout << abs(DP(1, 0)) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nint dp[1001][1001],w,h,s[1001][1001];\n\nint calc(int x1,int x2,int y1,int y2){\n\treturn s[x2 + 1][y2 + 1] - s[x2 + 1][y1] - s[x1][y2 + 1] + s[x1][y1];\n}\n\nint dfs(int x,int y){\n\tif(x == h || y == w) return 0;\n\tif(dp[x][y] != INF) return dp[x][y];\n\tif((x + y) % 2 == 0) return dp[x][y] = max(dfs(x + 1,y) + calc(x,x,y,w - 1),dfs(x,y + 1) - calc(x,h - 1,y,y));\n\telse return dp[x][y] = min(dfs(x + 1,y) + calc(x,x,y,w - 1),dfs(x,y + 1) - calc(x,h - 1,y,y));\n}\n\nsigned main(){\n\tcin >> w >> h;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tcin >> s[i + 1][j + 1];\n\t\t}\n\t}\n\tfor(int i = 0;i <= h;i++){\n\t\tfor(int j = 0;j <= w;j++) dp[i][j] = INF;\n\t}\n\tfor(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\ts[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];\n\t\t}\n\t}\n\tcout << abs(dfs(0,0)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long i64;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nint h, w;\nstd::vector<std::vector<i64>> a, s;\n\ni64 dp[1010][1010] = {};\ni64 solve(int x = 0, int y = 0) {\n\tif(dp[x][y] != 1LL << 60) return dp[x][y];\n\tif(x == h and y == w) return 0;\n\t\n\ti64 ret = 0;\n\tint f = (x + y) % 2;\n\tif(!f) {\n\t\tret = -(1LL << 60);\n\t\tif(x != h) ret = std::max(ret, solve(x + 1, y));\n\t\tif(y != w) ret = std::max(ret, s[y][x] + solve(x, y + 1));\n\t} else {\n\t\tret = (1LL << 60);\n\t\tif(x != h) ret = std::min(ret, solve(x + 1, y));\n\t\tif(y != w) ret = std::min(ret, s[y][x] + solve(x, y + 1));\n\t}\n\treturn dp[x][y] = ret;\n}\n\nint main() {\n\tcin >> w >> h; a.resize(h, std::vector<i64>(w)); s.resize(w, std::vector<i64>(h + 1, 0));\n\tfor(int i = 0; i < h; i++) for(int j = 0; j < w; j++) cin >> a[i][j];\n\tfor(int i = 0; i < w; i++) for(int j = 0; j < h; j++) s[i][j + 1] = s[i][j] + a[j][i];\n\t\n\ti64 sum = 0;\n\tfor(int i = 0; i < h; i++) for(int j = 0; j < w; j++) sum += a[i][j];\n\tfor(int i = 0; i <= h; i++) for(int j = 0; j <= w; j++) dp[i][j] = 1LL << 60;\n\t\n\ti64 ma = std::abs(sum - 2 * solve());\n\tcout << ma << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint** tate_ruisekiwa;\nint** yoko_ruisekiwa;\nint** dp;\nint W,H;\n\nint recursive(int row,int col,int turn){\n\n\tif(row == H || col == W)return 0;\n\n\tif(dp[row][col] != -BIG_NUM)return dp[row][col];\n\n\tif(turn == 0){\n\n\t\tdp[row][col] = max(recursive(row+1,col,1-turn)+(yoko_ruisekiwa[row+1][W]-yoko_ruisekiwa[row+1][col]),recursive(row,col+1,1-turn)-(tate_ruisekiwa[H][col+1]-tate_ruisekiwa[row][col+1]));\n\n\t}else{\n\n\t\tdp[row][col] = min(recursive(row+1,col,1-turn)+(yoko_ruisekiwa[row+1][W]-yoko_ruisekiwa[row+1][col]),recursive(row,col+1,1-turn)-(tate_ruisekiwa[H][col+1]-tate_ruisekiwa[row][col+1]));\n\n\t}\n\n\treturn dp[row][col];\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&W,&H);\n\n\ttate_ruisekiwa = new int*[H+1];\n\tyoko_ruisekiwa = new int*[H+1];\n\tdp = new int*[H+1];\n\n\tfor(int row = 0; row <= H; row++){\n\t\ttate_ruisekiwa[row] = new int[W+1];\n\t\tyoko_ruisekiwa[row] = new int[W+1];\n\t\tdp[row] = new int[W+1];\n\t\tfor(int col = 0; col <= W; col++){\n\t\t\ttate_ruisekiwa[row][col] = 0;\n\t\t\tyoko_ruisekiwa[row][col] = 0;\n\t\t\tdp[row][col] = -BIG_NUM;\n\t\t}\n\t}\n\n\tfor(int row = 1; row <= H; row++){\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tscanf(\"%d\",&tate_ruisekiwa[row][col]);\n\t\t\tyoko_ruisekiwa[row][col] = tate_ruisekiwa[row][col];\n\t\t}\n\t}\n\n\tfor(int col = 1; col <= W; col++){\n\t\tfor(int row = 1; row <= H; row++){\n\t\t\ttate_ruisekiwa[row][col] += tate_ruisekiwa[row-1][col];\n\t\t}\n\t}\n\n\tfor(int row = 1; row <= H; row++){\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tyoko_ruisekiwa[row][col] += yoko_ruisekiwa[row][col-1];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",abs(recursive(0,0,0)));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nint m , n ;\n\nconst pair < int , int > INF = make_pair( -int(1e9) + 7 , int(1e9) + 7 ) ;\n\nint a[1010][1010] , sum[1010][1010] ;\n\npair < int , int > dp[1010][1010] ;\n\nint get_sum( int x1 , int y1 , int x2 , int y2 ){\n\treturn sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1] ;\n}\n\npair < int , int > combine( pair < int , int > foo , pair < int , int > bar ){\n\tif( foo.first - foo.second > bar.first - bar.second ) return foo ;\n\treturn bar ;\n}\n\npair < int , int > find_answer( int x , int y ){\n\tif(x == m && y == n) return dp[x][y] = make_pair(0 , 0) ;\n\tif( dp[x][y] != INF ) return dp[x][y] ;\n\tif( x != m ){\n\t\tpair < int , int > foo = find_answer(x + 1 , y) ;\n\t\tswap( foo.first , foo.second ) ;\n\t\tif( (x + y) % 2 == 0 ) foo.first += get_sum( x + 1 , y + 1 , x + 1 , n ) ;\n\t\telse foo.second += get_sum( x + 1 , y + 1 , x + 1 , n ) ;\n\t\tdp[x][y] = combine( dp[x][y] , foo ) ;\n\t}\n\tif( y != n ){\n\t\tpair < int , int > foo = find_answer(x , y + 1) ;\n\t\tswap(foo.first , foo.second) ;\n\t\tif( (x + y) % 2 ) foo.first += get_sum( x + 1 , y + 1 , m , y + 1 ) ;\n\t\telse foo.second += get_sum( x + 1 , y + 1 , m , y + 1 ) ;\n\t\tdp[x][y] = combine( dp[x][y] , foo ) ;\n\t}\n\treturn dp[x][y] ;\n}\n\nint main(){\n\t#define NAME \"ForecastofForces\"\n\t//freopen( NAME\".inp\" , \"r\" , stdin ) ; freopen( NAME\".out\" , \"w\" , stdout ) ;\n\n\tcin >> n >> m ;\n\n\tfor( int i = 1 ; i <= m ; ++ i ){\n\t\tfor( int j = 1 ; j <= n ; ++ j ) {\n\t\t\tcin >> a[i][j] ;\n\t\t\tsum[i][j] = a[i][j] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] ;\n\t\t}\n\t}\n\t\n\tfor( int i = 0 ; i <= m ; ++ i ){\n\t\tfor( int j = 0 ; j <= n ; ++ j ) dp[i][j] = INF ;\n\t}\n\t\n\tpair < int , int > ans = find_answer(0 , 0) ;\n\n\tcout << abs(ans.first - ans.second) << endl ;\n\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define Link \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0352\"\n\n#include <iostream>\n#include <cstdio>\n\n#define TASK \"Forecast of Forces\"\n\nusing namespace std;\n\nvoid OpenFile()\n{\n    freopen(TASK\".INP\",\"r\",stdin);\n    freopen(TASK\".OUT\",\"w\",stdout);\n}\n\nconst int maxn = 1e3 + 1;\nint w,h,a[maxn][maxn],d[maxn][maxn],f[maxn][maxn];\n\nvoid Enter()\n{\n    cin >> w >> h;\n    for (int i=1;i<=h;++i)\n        for (int j=1;j<=w;++j)\n            cin >> a[i][j];\n}\n\nvoid Init()\n{\n    for (int i=1;i<=h;++i) {\n        for (int j=1;j<=w;++j)\n            d[i][0] -= a[i][j];\n        for (int j=1;j<=w;++j)\n            d[i][j] = d[i][j-1] + 2 * a[i][j];\n//        for (int j=0;j<=w;++j)\n//            cout << i << ' ' << j << ' ' << d[i][j] << ' ' << a[i][j] << '\\n';\n    }\n}\n\nvoid Solve()\n{\n    f[0][0] = 0;\n    for (int i=0;i<=h;++i)\n        for (int j=0;j<=w;++j) {\n            if (i != 0 || j != 0)\n                if (i == 0)\n                    f[i][j] = f[i][j-1];\n                else\n                    if (j == 0)\n                        f[i][j] = f[i-1][j] + d[i][j];\n                    else\n                        if ((i+j) % 2)\n                            f[i][j] = max(f[i][j-1],f[i-1][j]+d[i][j]);\n                        else\n                            f[i][j] = min(f[i][j-1],f[i-1][j]+d[i][j]);\n//            cout << i << ' ' << j << ' ' << f[i][j] << '\\n';\n        }\n    cout << max(f[h][w],-f[h][w]) << '\\n';\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    //OpenFile();\n\n    Enter();\n    Init();\n    Solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n \nusing namespace std;\nconst int Maxh=1000+100;\n \nint h,w;\nint a[Maxh][Maxh];\nint l[Maxh][Maxh],r[Maxh][Maxh];\nint fl[Maxh][Maxh],fr[Maxh][Maxh],sl[Maxh][Maxh],sr[Maxh][Maxh];\nint Res;\n \nvoid BuildLR()\n{\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=w; j>=1; j--) r[i][j]=r[i][j+1]+a[i][j];\n        for (int j=1; j<=w; j++) l[i][j]=l[i][j-1]+a[i][j];\n    }\n}\n \nvoid BuildFSLR()\n{\n    for (int i=h; i>=1; i--)\n    {\n        for (int j=w+1; j>=0; j--)\n        {\n            fl[i][j]=sl[i+1][j]+l[i][j];\n            sl[i][j]=max(fl[i][j],sl[i][j+1]);\n            fr[i][j]=sr[i+1][j]+r[i][j];\n            sr[i][j]=max(fr[i][j],sr[i][j+1]);\n        }\n    }\n}\n \nvoid Solve()\n{\n    Res=0;\n    int i=1, j=0;\n    while (true)\n    {\n        if (fr[i][j+1]==sr[i][j+1]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n        if (fl[i][j]==sl[i][j]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n    }\n \n    int S=0;\n    for (int i=1; i<=h; i++) S+=r[i][1];\n    S-=Res; Res=abs(Res-S);\n}\n \nint main()\n{\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1; i<=h; i++)\n    for (int j=1; j<=w; j++) scanf(\"%d\",&a[i][j]);\n \n    BuildLR();\n    BuildFSLR();\n    Solve();\n \n    printf(\"%d\",Res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define ff(i,a,b) for (int i=(a);i<=(b);i++)\nusing namespace std;\nconst int N=1010, inf=2e9+9;\nint n,m;\nint a[N][N], sa[N][N];\nbool ready[N][N][2]; int memo[N][N][2];\nint sum (int r1, int c1, int r2, int c2) {\n    if (r1>r2 || c1>c2) return 0;\n    return sa[r2][c2] - sa[r2][c1-1] - sa[r1-1][c2] + sa[r1-1][c1-1];\n}\nint game (int r, int c, int p) {\n    if (r==n+1 && c==m+1) return 0;\n    if (ready[r][c][p]) return memo[r][c][p];\n    int ans=(p==0)?-inf:inf; ///Đang muốn làm max/làm min miệu.\n    ///Người cmơi miện tại: Nam tiến\n    if (r<n+1) {\n        int tmp = game(r+1, c, 1-p) + sum(r,c,r,m) - sum(r,1,r,c-1); ///Hiệu (Nobuo-Shizuo) mới.\n        if (p==0) { ///Đây là Nobuo, ăn pmía đông\n            if (tmp > ans)\n                ans = tmp;\n        }\n        else { ///Đây là Shizuo, sẽ ăn phần phía tây.\n            if (tmp<ans)\n                ans = tmp;\n        }\n    }\n    ///Người chơi hiện tại: Đông tiến.\n    if (c<m+1) {\n        ///Nobuo ăn Bắc, Shizuo ăn nam\n        int tmp = game(r, c+1, 1-p) + sum(1,c,r-1,c) - sum(r,c,n,c);\n        if (p==0) {\n            if (tmp>ans)\n                ans=tmp;\n        }\n        else {\n            if (tmp<ans)\n                ans=tmp;\n        }\n    }\n    ready[r][c][p]=1;\n    return memo[r][c][p]=ans;\n}\nint main() {/*\n    freopen(\"in.txt\",\"r\",stdin); freopen(\"out.txt\",\"w\",stdout); //*/\n    scanf(\"%d%d\",&n,&m); swap(n,m);\n    ff(i,1,n)\n    ff(j,1,m) {\n        scanf(\"%d\",&a[i][j]);\n        sa[i][j] = sa[i-1][j] + sa[i][j-1] - sa[i-1][j-1] + a[i][j];\n    }\n    printf(\"%d\\n\",abs(game (1,1,0))/2);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<unordered_set>\nusing namespace std;\n//int p = 998244353;\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<int,pin>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define rev(s) reverse(s.begin(),s.end())\nint max_kai = 150000;\nvel kai(max_kai, 1);\nvel inv_kai;\nint rui(int a, int n) {\n\tif (n == 0) { return 1; }\n\tint x = rui(a, n / 2);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\nint inv(int a) { return rui(a, p - 2); }\nvoid make_kai() {\n\tfor (int i = 1; i < max_kai; i++) { kai[i] = kai[i - 1] * i; kai[i] %= p; }\n\tinv_kai = kai;\n\trep(i, max_kai) { inv_kai[i] = inv(kai[i]); }\n}\nint nCr(int n, int r) {\n\tint a = kai[n] * inv_kai[r]; a %= p;\n\ta *= inv_kai[n - r]; a %= p;\n\treturn a;\n}\nvel pa;\nint root(int x) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x]); pa[x] = ans;\n\treturn ans;\n}\nvoid marge(int x, int y) {\n\tx = root(x);\n\ty = root(y);\n\tif (x != y) {pa[x] = y;}\n}\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nint num_lp(int a, vel &nex) {\n\tunordered_set<int> se;\n\tint ans = 0;\n\twhile (true) {\n\t\tif (se.find(a) != se.end()) {\n\t\t\tbreak;\n\t\t}\n\t\tse.insert(a);\n\t\ta = nex[a];\n\t\tans++;\n\t}\n\treturn ans;\n}\nint find_cr(int a, vel &nex) {\n\tunordered_set<int> se;\n\twhile (true) {\n\t\tif (se.find(a) != se.end()) {break;}\n\t\tse.insert(a);\n\t\ta = nex[a];\n\t}\n\treturn num_lp(a, nex);\n}\nint inf = 2000000000;\nvvel dp;\nint solve(vvel &sum, int i, int j, bool is_f) {\n\tint h = sum.size(); h--;\n\tint w = sum[0].size();\n\tif (i == h || j == w) { return 0; }\n\tif (dp[i][j] == inf) {\n\t\tint ans1 = solve(sum, i + 1, j, !is_f);\n\t\tint ans2 = solve(sum, i, j + 1, !is_f);\n\t\tans2 += sum[i][j];\n\t\tif (is_f) {\n\t\t\tdp[i][j] = min(ans1, ans2);\n\t\t}\n\t\telse {\n\t\t\tdp[i][j] = max(ans1, ans2);\n\t\t}\n\t}\n\treturn dp[i][j];\n}\nsigned main(){\n\tint w, h; cin >> w >> h;\n\tvvel s(h, vel(w));\n\tint sum1 = 0;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> s[i][j];\n\t\t\tsum1 += s[i][j];\n\t\t}\n\t}\n\tvvel sum(h + 1, vel(w, 0));\n\tdp = vvel(h + 1, vel(w +1,inf));\n\trep(j, w) {\n\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\tsum[i][j] = sum[i + 1][j] + s[i][j];\n\t\t}\n\t}\n\tcout << abs(solve(sum, 0, 0, true)*2-sum1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint INF = 1e+12;\nint w, h;\nint s[1000][1000];\nint rs[1000][1001];\nint dp[1001][1001];\n\nint Abs(int x) { if (x > 0) return x; return -x; }\n\n//(y, x)??\\?????§?????????????????????????????¢\nint dfs(int y, int x) {\n\tif (y == h && x == w) return 0;\n\tif (dp[y][x] != -1) return dp[y][x];\n\t\n\tif ((y + x) % 2 == 0) {\n\t\tint ret = -INF;\n\t\tif (x < w) ret = max(ret, dfs(y, x + 1));\n\t\tif (y < h) ret = max(ret, rs[y][w] - rs[y][x] + dfs(y + 1, x));\n\t\treturn dp[y][x] = ret;\n\t}\n\t\n\tint ret = INF;\n\tif (x < w) ret = min(ret, dfs(y, x + 1));\n\tif (y < h) ret = min(ret, rs[y][w] - rs[y][x] + dfs(y + 1, x));\n\treturn dp[y][x] = ret;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> w >> h;\n\tfor (i = 0; i < h; i++) for (j = 0; j < w; j++) cin >> s[i][j];\n\tfor (i = 0; i <= h; i++) for (j = 0; j <= w; j++) dp[i][j] = -1;\n\t\n\tint ssum = 0;\n\tfor (i = 0; i < h; i++) {\n\t\trs[i][0] = 0;\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tssum += s[i][j - 1];\n\t\t\trs[i][j] = rs[i][j - 1] + s[i][j - 1];\n\t\t}\n\t}\n\tcout << Abs(2 * dfs(0, 0) - ssum) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\nint main(){\n\tstd::ios_base::sync_with_stdio(false);std::cin.tie(nullptr);\n\tint ncol,nrow;std::cin>>ncol>>nrow;\n\tstd::vector<std::vector<int>>mat(nrow);\n\tfor(auto&row:mat){\n\t\trow.resize(ncol);\n\t\tfor(int&cell:row)std::cin>>cell;\n\t\trow.push_back(0);\n\t}\n\tmat.emplace_back(ncol+1,0);\n\t//convert mat to postfix sum array\n\tfor(int row=nrow;row-->0;)for(int col=ncol;col-->0;)\n\t\tmat[row][col]+=mat[row+1][col]+mat[row][col+1]-mat[row+1][col+1];\n\t#define sum(r0,c0,r1,c1) /* r0<=r1,c0<=c1 */ \\\n\t(mat[r0][c0]-mat[r0][c1]-mat[r1][c0]+mat[r1][c1])\n\tauto dp=mat;//difference between UR and DL.border=0.\n\tfor(int row=nrow;row-->0;)for(int col=ncol;col-->0;){\n\t\tint parity=(row+col)&1;//even:first:UR(maximize diff),otherwise:\n\t\t//second:DL(minimize diff)\n\t\tint d1=dp[row+1][col]+sum(row,col,row+1,ncol);\n\t\tint d2=dp[row][col+1]-sum(row,col,nrow,col+1);\n\t\tdp[row][col]=parity?std::min(d1,d2):std::max(d1,d2);\n\t}\n\tstd::cout<<std::abs(dp[0][0])<<'\\n';\n\t#undef sum\n}\n"
  },
  {
    "language": "C++",
    "code": "#define Link \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0352\"\n\n#include <iostream>\n#include <cstdio>\n\n#define TASK \"Forecast of Forces\"\n\nusing namespace std;\n\nvoid OpenFile()\n{\n    freopen(TASK\".INP\",\"r\",stdin);\n    freopen(TASK\".OUT\",\"w\",stdout);\n}\n\nconst int maxn = 1e3 + 1;\nint w,h,a[maxn][maxn],d[maxn][maxn],f[maxn][maxn];\n\nvoid Enter()\n{\n    cin >> w >> h;\n    for (int i=1;i<=h;++i)\n        for (int j=1;j<=w;++j)\n            cin >> a[i][j];\n}\n\nvoid Init()\n{\n    for (int i=1;i<=h;++i) {\n        for (int j=1;j<=w;++j)\n            d[i][0] -= a[i][j];\n        for (int j=1;j<=w;++j)\n            d[i][j] = d[i][j-1] + 2 * a[i][j];\n//        for (int j=0;j<=w;++j)\n//            cout << i << ' ' << j << ' ' << d[i][j] << ' ' << a[i][j] << '\\n';\n    }\n}\n\nvoid Solve()\n{\n    f[0][0] = 0;\n    for (int i=0;i<=h;++i)\n        for (int j=0;j<=w;++j) {\n            if (i != 0 || j != 0)\n                if (i == 0)\n                    f[i][j] = f[i][j-1];\n                else\n                    if (j == 0)\n                        f[i][j] = f[i-1][j] + d[i][j];\n                    else\n                        if ((i+j) % 2)\n                            f[i][j] = max(f[i][j-1],f[i-1][j]+d[i][j]);\n                        else\n                            f[i][j] = min(f[i][j-1],f[i-1][j]+d[i][j]);\n//            cout << i << ' ' << j << ' ' << f[i][j] << '\\n';\n        }\n    cout << max(f[h][w],-f[h][w]);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    //OpenFile();\n\n    Enter();\n    Init();\n    Solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint main(){\n\n\tint W,H;\n\tscanf(\"%d %d\",&W,&H);\n\n\tint** tate_ruisekiwa = new int*[H+1];\n\tint** yoko_ruisekiwa = new int*[H+1];\n\n\tfor(int row = 0; row <= H; row++){\n\t\ttate_ruisekiwa[row] = new int[W+1];\n\t\tyoko_ruisekiwa[row] = new int[W+1];\n\t\tfor(int col = 0; col <= W; col++){\n\t\t\ttate_ruisekiwa[row][col] = 0;\n\t\t\tyoko_ruisekiwa[row][col] = 0;\n\t\t}\n\t}\n\n\tfor(int row = 1; row <= H; row++){\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tscanf(\"%d\",&tate_ruisekiwa[row][col]);\n\t\t\tyoko_ruisekiwa[row][col] = tate_ruisekiwa[row][col];\n\t\t}\n\t}\n\n\tfor(int col = 1; col <= W; col++){\n\t\tfor(int row = 1; row <= H; row++){\n\t\t\ttate_ruisekiwa[row][col] += tate_ruisekiwa[row-1][col];\n\t\t}\n\t}\n\n\tfor(int row = 1; row <= H; row++){\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tyoko_ruisekiwa[row][col] += yoko_ruisekiwa[row][col-1];\n\t\t}\n\t}\n\n\tint sente_sum = 0,gote_sum = 0;\n\n\tint row = 0,col = 0;\n\tint turn = 0;\n\n\twhile(row < H && col < W){\n\n\t\tif(turn == 0){\n\n\t\t\tint if_right = tate_ruisekiwa[H][col+1]-tate_ruisekiwa[row][col+1];\n\n\t\t\tint if_under = yoko_ruisekiwa[row+1][W]-yoko_ruisekiwa[row+1][col];\n\n\t\t\tif(if_under >= (-1)*if_right){\n\t\t\t\tsente_sum += if_under;\n\t\t\t\trow++;\n\t\t\t}else{\n\t\t\t\tgote_sum += if_right;\n\t\t\t\tcol++;\n\t\t\t}\n\t\t}else{\n\n\t\t\tint if_right = tate_ruisekiwa[H][col+1]-tate_ruisekiwa[row][col+1];\n\n\t\t\tint if_under = yoko_ruisekiwa[row+1][W]-yoko_ruisekiwa[row+1][col];\n\n\t\t\tif(if_right >= (-1)*if_under){\n\t\t\t\tgote_sum += if_right;\n\t\t\t\tcol++;\n\t\t\t}else{\n\t\t\t\tsente_sum += if_under;\n\t\t\t\trow++;\n\t\t\t}\n\t\t}\n\t\tturn = 1 - turn;\n\t}\n\n\tprintf(\"%d\\n\",abs(sente_sum-gote_sum));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n \nusing namespace std;\nconst int Maxh=1000+100;\n \nint h,w;\nint a[Maxh][Maxh];\nint l[Maxh][Maxh],r[Maxh][Maxh];\nint fl[Maxh][Maxh],fr[Maxh][Maxh],sl[Maxh][Maxh],sr[Maxh][Maxh];\nint Res;\n \nvoid BuildLR()\n{\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=w; j>=1; j--) r[i][j]=r[i][j+1]+a[i][j];\n        for (int j=1; j<=w; j++) l[i][j]=l[i][j-1]+a[i][j];\n    }\n}\n \nvoid BuildFSLR()\n{\n    for (int i=h; i>=1; i--)\n    {\n        for (int j=w+1; j>=0; j--)\n        {\n            fl[i][j]=sl[i+1][j]+l[i][j];\n            sl[i][j]=max(fl[i][j],sl[i][j+1]);\n            fr[i][j]=sr[i+1][j]+r[i][j];\n            sr[i][j]=max(fr[i][j],sr[i][j+1]);\n        }\n    }\n}\n \nvoid Solve()\n{\n    Res=0;\n    int i=1, j=0;\n    while (true)\n    {\n        if (fr[i][j+1]==sr[i][j+1]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n        if (fl[i][j]==sl[i][j]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n    }\n \n    int S=0;\n    for (int i=1; i<=h; i++) S+=r[i][1];\n    S-=Res; Res=abs(Res-S);\n}\n \nint main()\n{\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1; i<=h; i++)\n    for (int j=1; j<=w; j++) scanf(\"%d\",&a[i][j]);\n \n    BuildLR();\n    BuildFSLR();\n    Solve();\n \n    printf(\"%d\",Res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll N = 1000 + 10;\nconst ll inf = 1e9 + 7;\n\nvoid maximize(ll &a, ll b) { a = max(a, b); }\nvoid minimize(ll &a, ll b) { a = min(a, b); }\n\nll n, m;\nll a[N][N];\n\nll dp[N][N];\nll vis[N][N];\nll col[N][N];\n\nll tx[3] = {0, 1};\nll ty[3] = {1, 0};\n\nll getCol(ll cid, ll l, ll r){\n\tif (r < l) return 0;\n\treturn col[cid][r] - col[cid][l - 1];\n}\n\nll dfs(ll i, ll j){\n\tif (vis[i][j]) return dp[i][j];\n\tvis[i][j] = 1;\n\tif (i == n && j == m) \n\t\treturn dp[i][j] = 0;\n\tll turn = (i + j) % 2;\n\tdp[i][j] = (turn == 0 ? -inf : inf);\n\tfor (ll t = 0; t < 2; t++){\n\t\tll ni = tx[t] + i, nj = ty[t] + j;\n\t\tif (0 <= ni && ni <= n && 0 <= nj && nj <= m); else continue;\n\t\tll del = (t == 1 ? 0 : getCol(nj, 1, ni) - getCol(nj, ni + 1, n) );\n\t\tif (!turn) maximize( dp[i][j], dfs(ni, nj) + del);\n\t\telse\t   minimize( dp[i][j], dfs(ni, nj) + del);\n\t}\n\treturn dp[i][j];\n}\n\nmain(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\t// freopen(\"8.inp\", \"r\", stdin);\n\tcin >> m >> n;\n\tfor (ll i = 1; i <= n; i++)\n\t\tfor (ll j = 1; j <= m; j++)\n\t\t\tcin >> a[i][j];\n\t\n\tfor (ll j = 1; j <= m; j++){\n\t\tfor (ll i = 1; i <= n; i++)\n\t\t\tcol[j][i] = col[j][i - 1] + a[i][j];\n\t}\n\tcout << abs( dfs(0, 0) ) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll N = 1000 + 10;\nconst ll inf = 1e9 + 7;\n\nvoid maximize(ll &a, ll b) { a = max(a, b); }\nvoid minimize(ll &a, ll b) { a = min(a, b); }\n\nll n, m;\nll a[N][N];\n\nll dp[N][N];\nll vis[N][N];\nll col[N][N];\n\nll tx[3] = {0, 1};\nll ty[3] = {1, 0};\n\nll getCol(ll cid, ll l, ll r){\n\tif (r < l) return 0;\n\treturn col[cid][r] - col[cid][l - 1];\n}\n\nll dfs(ll i, ll j){\n\tif (vis[i][j]) return dp[i][j];\n\tif (i == n && j == m) \n\t\treturn dp[i][j] = 0;\n\tll turn = (i + j) % 2;\n\tdp[i][j] = (turn == 0 ? -inf : inf);\n\tfor (ll t = 0; t < 2; t++){\n\t\tll ni = tx[t] + i, nj = ty[t] + j;\n\t\tif (0 <= ni && ni <= n && 0 <= nj && nj <= m); else continue;\n\t\tll del = (t == 1 ? 0 : getCol(nj, 1, ni) - getCol(nj, ni + 1, n) );\n\t\tif (!turn) maximize( dp[i][j], dfs(ni, nj) + del);\n\t\telse\t   minimize( dp[i][j], dfs(ni, nj) + del);\n\t}\n\treturn dp[i][j];\n}\n\nmain(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\t// freopen(\"8.inp\", \"r\", stdin);\n\tcin >> m >> n;\n\tfor (ll i = 1; i <= n; i++)\n\t\tfor (ll j = 1; j <= m; j++)\n\t\t\tcin >> a[i][j];\n\t\n\tfor (ll j = 1; j <= m; j++){\n\t\tfor (ll i = 1; i <= n; i++)\n\t\t\tcol[j][i] = col[j][i - 1] + a[i][j];\n\t}\n\tcout << abs( dfs(0, 0) );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fto(i, x, y) for(int i = (x); i <= (y); ++i)\n#define fdto(i, x, y) for(int i = (x); i >= (y); --i)\n#define ftoa(i, x, y, a) for(int i = (x); i <= (y); i += a)\n#define ftoit(it, var) for (__typeof(var.begin()) it = var.begin(); it != var.end(); ++it)\n\n#define ii pair<int, int>\n#define mp make_pair\n#define FF first\n#define SS second\n\n#define vi vector<int>\n#define vii vector<ii>\n#define ll long long\n#define vll vector<ll>\n\n#define eb emplace_back\n#define ef emplace_front\n#define lb lower_bound\n#define ub upper_bound\n#define sz(a) (int)a.size()\n\n#define oo 1000000007\n#define OO 1000000000000000007LL\n\nusing namespace std;\n\n#define Pro \"tmp\"\n#define maxN 1507\n\nint f[maxN][maxN][5], dp[maxN][maxN];\nint a[maxN][maxN];\n\nint main() {\n//    #ifndef ONLINE_JUDGE\n//        freopen(Pro\".inp\", \"r\", stdin);\n//        freopen(Pro\".out\", \"w\", stdout);\n//    #endif // ONLINE_JUDGE\n\n    int n, m;\n    scanf(\"%d%d\", &m, &n);\n\n    fto (i, 1, n) {\n        fto (j, 1, m) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n\n    fdto (i, n, 1) {\n        fdto (j, m, 1) {\n            dp[i][j] = dp[i+1][j]+dp[i][j+1]-dp[i+1][j+1]+a[i][j];\n        }\n    }\n\n    fdto (sum, n+m, 2) {\n        fto (i, 1, n) {\n            int j = sum-i;\n            if (j < 1 || j > m) continue;\n\n            f[i][j][0] = max(dp[i][j]-f[i+1][j][1], dp[i][j+1]-f[i][j+1][1]);\n            f[i][j][1] = max(dp[i+1][j]-f[i+1][j][0], dp[i][j]-f[i][j+1][0]);\n        }\n    }\n\n    cout << abs(dp[1][1]-2*f[1][1][0]) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n \nusing namespace std;\nconst int Maxh=1000+100;\n \nint h,w;\nint a[Maxh][Maxh];\nint l[Maxh][Maxh],r[Maxh][Maxh];\nint fl[Maxh][Maxh],fr[Maxh][Maxh],sl[Maxh][Maxh],sr[Maxh][Maxh];\nint Res;\n \nvoid BuildLR()\n{\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=w; j>=1; j--) r[i][j]=r[i][j+1]+a[i][j];\n        for (int j=1; j<=w; j++) l[i][j]=l[i][j-1]+a[i][j];\n    }\n}\n \nvoid BuildFSLR()\n{\n    for (int i=h; i>=1; i--)\n    {\n        for (int j=w+1; j>=0; j--)\n        {\n            fl[i][j]=sl[i+1][j]+l[i][j];\n            sl[i][j]=max(fl[i][j],sl[i][j+1]);\n            fr[i][j]=sr[i+1][j]+r[i][j];\n            sr[i][j]=max(fr[i][j],sr[i][j+1]);\n        }\n    }\n}\n \nvoid Solve()\n{\n    Res=0;\n    int i=1, j=0;\n    while (true)\n    {\n        if (fr[i][j+1]==sr[i][j+1]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n        if (fl[i][j]==sl[i][j]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n    }\n \n    int S=0;\n    for (int i=1; i<=h; i++) S+=r[i][1];\n    S-=Res; Res=abs(Res-S);\n}\n \nint main()\n{\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1; i<=h; i++)\n    for (int j=1; j<=w; j++) scanf(\"%d\",&a[i][j]);\n \n    BuildLR();\n    BuildFSLR();\n    Solve();\n \n    printf(\"%d\",Res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define up(i, a, b) for (int i = a, _b = b; i <= _b; i++)\n#define down(i, a, b) for (int i = a, _b = b; i >= _b; i--)\n#define long long long\n#define endl '\\n'\n#define X first\n#define Y second\n#define II pair<int, int>\n#define debug(X) cerr << #X << \" = \" << X << endl\n#define debug2(X, Y) cerr << #X << \" = \" << X << \" , \" << #Y << \" = \" << Y << endl\n#define show(X, a, b) { cerr << #X << \" = \"; up(_, a, b) cerr << X[_] << \" \"; cerr << endl; }\n#define gc getchar\n#define pc putchar\nusing namespace std;\ninline void read(int &x) {\n        register int c = gc();\n        x = 0;\n        int neg = 0;\n        for (; ((c<48 || c>57) && c != '-'); c = gc());\n        if(c=='-') {neg=1; c=gc();}\n        for(; c>47 && c<58; c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n        if(neg) x=-x;\n}\ninline void writeln(int x) {\n\n        char buffor[21];\n        register int i=0;\n        int neg=0; if (x<0) {neg=1; x= -x;}\n        do {\n                buffor[i++]=(x%10)+'0';\n                x/=10;\n        } while(x);\n        i--;\n        if (neg) pc('-');\n        while(i>=0) pc(buffor[i--]);\n        pc('\\n');\n}\nconst int N = 1010;\nint m, n, a[N][N], f[N][N];\nvoid input() {\n        cin >> n >> m;\n        up(i, 1, m)\n          up(j, 1, n)\n            cin >> a[i][j];\n}\nint query(int x, int y, int u, int v) {\n        return a[u][v] - a[x - 1][v] - a[u][y - 1] + a[x -1][y - 1];\n}\n\nvoid solve() {\n        up(i, 1, m)\n          up(j, 1, n)\n            a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];\n\n        f[m][n] = 0;\n        down(i, m, 0)\n         down(j, n, 0) {\n            if (i == m && j == n) continue;\n            if ((i + j) % 2 == 0) {\n                f[i][j] = -1e9; //try to maximize;\n                if (i + 1 <= m) f[i][j] = max(f[i][j], f[i + 1][j] + query(i + 1, j + 1, i + 1, n));\n                if (j + 1 <= n) f[i][j] = max(f[i][j], f[i][j + 1] - query(i + 1, j + 1, m, j + 1));\n            }\n            if ((i + j) % 2 == 1) {\n                f[i][j] = 1e9; //try to minimize;\n                if (i + 1 <= m) f[i][j] = min(f[i][j], f[i + 1][j] + query(i + 1, j + 1, i + 1, n));\n                if (j + 1 <= n) f[i][j] = min(f[i][j], f[i][j + 1] - query(i + 1, j + 1, m, j + 1));\n            }\n         }\n\n        cout << abs(f[0][0]);\n}\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL);\n\n  #ifdef I_Love_Pork\n  #define TASK \"tmp\"\n        freopen(TASK \".inp\",\"r\",stdin);\n        freopen(TASK \".out\",\"w\",stdout);\n  #endif\n\n\n        input();\n        solve();\n\n\n\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b)    for (int i = a; i <= (int) b; ++i)\n#define ii              pair <int, int>\nusing namespace std;\nconst int N = 1e3 + 3;\nint m, n, a[N][N], f[N][N][2], vis[N][N][2];\n\nvoid init() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    //freopen(\"main.inp\",\"r\",stdin);\n    //freopen(\"main.out\",\"w\",stdout);\n}\n\nint get(int xo, int yo, int xi, int yi) {\n    return a[xi][yi] + a[xo - 1][yo - 1] - a[xi][yo - 1] - a[xo - 1][yi];\n}\n\nint dp(int i, int j, int id) {\n    int &shc = f[i][j][id], &foo = vis[i][j][id];\n    if (foo != -1) return foo;\n    if (i == m || j == n) return shc = 0;\n    shc = INT_MIN; foo = 1;\n    if (id == 0) {\n        if (i < m && j < n) {\n            shc = max(shc, get(i + 1, j + 1, i + 1, n) - dp(i + 1, j, 1));\n            shc = max(shc, - get(i + 1, j + 1, m, j + 1) - dp(i, j + 1, 1));\n        }\n    }\n    else {\n        if (i < m && j < n) {\n            shc = max(shc, - get(i + 1, j + 1, i + 1, n) - dp(i + 1, j, 0));\n            shc = max(shc, get(i + 1, j + 1, m, j + 1) - dp(i, j + 1, 0));\n        }\n    }\n    return shc;\n}\n\nvoid solve() {\n    cin >> m >> n;\n    FOR(i, 1, m) FOR(j, 1, n) {\n        int x; cin >> x;\n        a[i][j] = a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1] + x;\n    }\n\n    memset(vis, -1, sizeof vis);\n    cout << abs(dp(0, 0, 0));\n}\n\nmain() {\n    init(); solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fto(i, x, y) for(int i = (x); i <= (y); ++i)\n#define fdto(i, x, y) for(int i = (x); i >= (y); --i)\n#define ftoa(i, x, y, a) for(int i = (x); i <= (y); i += a)\n#define ftoit(it, var) for (__typeof(var.begin()) it = var.begin(); it != var.end(); ++it)\n\n#define ii pair<int, int>\n#define mp make_pair\n#define FF first\n#define SS second\n\n#define vi vector<int>\n#define vii vector<ii>\n#define ll long long\n#define vll vector<ll>\n\n#define eb emplace_back\n#define ef emplace_front\n#define lb lower_bound\n#define ub upper_bound\n#define sz(a) (int)a.size()\n\n#define oo 1000000007\n#define OO 1000000000000000007LL\n\nusing namespace std;\n\n#define Pro \"tmp\"\n#define maxN 1507\n\nint f[maxN][maxN][5], dp[maxN][maxN];\nint a[maxN][maxN];\n\nint main() {\n\n    int n, m;\n    scanf(\"%d%d\", &m, &n);\n\n    fto (i, 1, n) {\n        fto (j, 1, m) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n\n    fdto (i, n, 1) {\n        fdto (j, m, 1) {\n            dp[i][j] = dp[i+1][j]+dp[i][j+1]-dp[i+1][j+1]+a[i][j];\n        }\n    }\n\n    fdto (sum, n+m, 2) {\n        fto (i, 1, n) {\n            int j = sum-i;\n            if (j < 1 || j > m) continue;\n\n            f[i][j][0] = max(dp[i][j]-f[i+1][j][1], dp[i][j+1]-f[i][j+1][1]);\n            f[i][j][1] = max(dp[i+1][j]-f[i+1][j][0], dp[i][j]-f[i][j+1][0]);\n        }\n    }\n\n//    fto (i, 1, n) {\n//        fto (j, 1, m) printf(\"%3d\", dp[i][j]);\n//        puts(\"\");\n//    }\n//    puts(\"\");\n//\n//    fto (i, 1, n) {\n//        fto (j, 1, m) printf(\"%3d\", f[i][j][0]);\n//        puts(\"\");\n//    }\n//    puts(\"\");\n//\n//    fto (i, 1, n) {\n//        fto (j, 1, m) printf(\"%3d\", f[i][j][1]);\n//        puts(\"\");\n//    }\n\n    cout << abs(dp[1][1]-2*f[1][1][0]) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1012345678;\nint main() {\n\tint H, W;\n\tcin >> W >> H;\n\tvector<vector<int> > a(H + 1, vector<int>(W + 1));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tvector<vector<int> > sv = a, sh = a;\n\tfor (int i = 0; i < W; ++i) {\n\t\tfor (int j = H - 1; j >= 0; --j) {\n\t\t\tsv[j][i] += sv[j + 1][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = W - 1; j >= 0; --j) {\n\t\t\tsh[i][j] += sh[i][j + 1];\n\t\t}\n\t}\n\tvector<vector<int> > dp(H + 1, vector<int>(W + 1));\n\tfor (int i = H; i >= 0; --i) {\n\t\tfor (int j = W; j >= 0; --j) {\n\t\t\tif (i == H && j == W) continue;\n\t\t\tint turn = (i + j) % 2;\n\t\t\tif (turn == 0) {\n\t\t\t\tdp[i][j] = -inf;\n\t\t\t\tif (i != H) {\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i + 1][j] + sh[i][j]);\n\t\t\t\t}\n\t\t\t\tif (j != W) {\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][j + 1] - sv[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = inf;\n\t\t\t\tif (i != H) {\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i + 1][j] + sh[i][j]);\n\t\t\t\t}\n\t\t\t\tif (j != W) {\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][j + 1] - sv[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << abs(dp[0][0]) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e3 + 5;\n\nint n, m, a[N][N], f[N][N], visited[N][N], col[N][N];\n\nint dp(int x, int y) {\n\tif(visited[x][y]) return f[x][y];\n\tif(x == n && y == m) return f[x][y] = 0;\n\tvisited[x][y] = true; f[x][y] = -1e9;\n\tint sum = col[n][y + 1] - 2 * col[x][y + 1];\n\tif(!((x + y) & 1)) sum = -sum;\n\tif(x + 1 <= n) f[x][y] = max(f[x][y], - dp(x + 1, y));\n\tif(y + 1 <= m) {\n\t\tf[x][y] = max(f[x][y], sum - dp(x, y + 1));\n\t}\n\treturn f[x][y];\n}\n\nint main() {\n\tcin >> m >> n;\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= m; ++j)\n\t\tcin >> a[i][j], col[i][j] = col[i - 1][j] + a[i][j];\n\tcout << abs(dp(0, 0));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\nconst LL INF = 1e18;\n\nint W, H;\nvector<vector<LL>> S;\n\nLL score(int i, int j) {\n  auto L = S[i+1][j] - S[i+1][0];\n  auto R = S[i+1][W] - S[i+1][j];\n  return ((i + j) & 1) ? L - R : R - L ;\n}\n\nLL dfs(int i, int j) {\n  static vector<vector<LL>> memo(H + 1, vector<LL>(W + 1, INF));\n  if(memo[i][j] != INF) return memo[i][j];\n  if(i == H) return memo[i][j] = 0;\n  if(j == W) return memo[i][j] = score(i, j) - dfs(i + 1, j);\n  return memo[i][j] = max(-dfs(i, j + 1), score(i, j) - dfs(i + 1, j));\n}\n\nint main() {\n  cin >> W >> H;\n  S.assign(H + 1, vector<LL>(W + 1));\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> S[i][j], S[i][j] += S[i][j - 1];\n  cout << abs(dfs(0, 0)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\n\nsigned main(){\n    \n    int h, w; cin >> w >> h;\n    vector<vector<int>> s(h + 1, vector<int> (w + 1, 0));\n    for(int i = 1; i <= h; i++) for(int j = 1; j <= w; j++) cin >> s[i][j];\n    for(int i = 1; i <= h; i++) for(int j = 1; j <= w; j++) s[i][j] += s[i][j - 1];\n    for(int j = 1; j <= w; j++) for(int i = 1; i <= h; i++) s[i][j] += s[i - 1][j];\n\n    vector<vector<int>> dp(h + 1, vector<int> (w + 1, -1));\n    for(int i = 0; i <= h; i++) dp[i][w] = 0;\n    for(int j = 0; j <= w; j++) dp[h][j] = 0;\n\n    for(int i = h - 1; i >= 0; i--){\n        for(int j = w - 1; j >= 0; j--){\n            \n            int turn = (i + j) % 2;\n                \n            if(turn == 0){\n                // 先手\n                //スコアを最大化したい\n                int score = max(dp[i + 1][j] + s[i + 1][w] - s[i + 1][j] - s[i][w] + s[i][j], dp[i][j + 1] - (s[h][j + 1] - s[h][j] - s[i][j + 1] + s[i][j]));\n                dp[i][j] = score;\n            }else{\n                int score = min(dp[i + 1][j] + s[i + 1][w] - s[i + 1][j] - s[i][w] + s[i][j], dp[i][j + 1] - (s[h][j + 1] - s[h][j] - s[i][j + 1] + s[i][j]));\n                dp[i][j] = score;\n            }\n        }\n    }\n    \n    /*\n    cout << h << \" \" << w << endl;\n    for(int i = 0; i <= h; i++){\n        for(int j = 0; j <= w; j++){\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }*/\n\n    int ans = dp[0][0];\n    if(ans < 0) ans = -ans;\n    \n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h, w;\nbool used[1010][1010] = {};\nint dp[1010][1010] = {};\nint rui[1010][1010] = {};\n\nint dfs(int right, int bottom){\n  if(right == w || bottom == h) return 0;\n  if(used[right][bottom]) return dp[right][bottom];\n  used[right][bottom] = true;\n  if((right + bottom) % 2 == 0){\n    return dp[right][bottom] = max(dfs(right+1,bottom),dfs(right,bottom+1)+rui[bottom][w]-rui[bottom][right]);\n  }else{\n    return dp[right][bottom] = min(dfs(right+1,bottom),dfs(right,bottom+1)+rui[bottom][w]-rui[bottom][right]);\n  }\n}\n\nint main(){\n  cin >> w >> h;\n  for(int i = 0;i < h;i++){\n    for(int j = 0;j < w;j++){\n      cin >> rui[i][j+1];\n      rui[i][j+1] += rui[i][j];\n    }\n  }\n  int ans = dfs(0,0);\n  int all = 0;\n  for(int i = 0;i < h;i++){\n    all += rui[i][w];\n  }\n  cout << abs(ans-(all-ans)) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 1001;\nconst int INF = 1234567890;\n\nint w,h;\nint s[N][N]={};\nint ps[N][N]={};\n\nint dp[N][N][2];\nint dfs(int y, int x, int t)\n{\n    if(dp[y][x][t] != -INF) return dp[y][x][t];\n    if(x==w) return 0;\n\n    int ret;\n    if(t==0)\n    {\n        ret = -INF;\n        // down\n        if(y+1<=h) ret = max(ret, dfs(y+1,x,!t));\n        // right\n        if(x+1<=w)\n        {\n            int diff = 2*ps[y][x+1] - ps[h][x+1];\n            ret = max(ret,dfs(y,x+1,!t) + diff);\n        }\n    }\n    else\n    {\n        ret = INF;\n        // down\n        if(y+1<=h) ret = min(ret, dfs(y+1,x,!t));\n        // right\n        if(x+1<=w)\n        {\n            int diff = 2*ps[y][x+1] - ps[h][x+1];\n            ret = min(ret,dfs(y,x+1,!t) + diff);\n        }\n    }\n\n    return dp[y][x][t] = ret;\n}\n\nint main()\n{\n    scanf(\" %d %d\", &w, &h);\n    rep(i,h)rep(j,w) scanf(\" %d\", &s[i+1][j+1]);\n\n    // prefix sum (vertical)\n    rep(i,w+1)\n    {\n        for(int j=1; j<=h; ++j) ps[j][i] = ps[j-1][i]+s[j][i];\n    }\n\n    rep(i,N)rep(j,N)rep(k,2) dp[i][j][k] = -INF;\n    printf(\"%d\\n\", abs(dfs(0,0,0)));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b)    for (int i = a; i <= (int) b; ++i)\n#define ii              pair <int, int>\nusing namespace std;\nconst int N = 1e3 + 3;\nint m, n, a[N][N], f[N][N][2], vis[N][N][2];\n\nvoid init() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    //freopen(\"main.inp\",\"r\",stdin);\n    //freopen(\"main.out\",\"w\",stdout);\n}\n\nint get(int xo, int yo, int xi, int yi) {\n    return a[xi][yi] + a[xo - 1][yo - 1] - a[xi][yo - 1] - a[xo - 1][yi];\n}\n\nint dp(int i, int j, int id) {\n    int &shc = f[i][j][id], &foo = vis[i][j][id];\n    if (foo) return shc;\n    if (i == m || j == n) return shc = 0;\n    shc = INT_MIN; foo = 1;\n    if (id == 0) {\n        if (i < m && j < n) {\n            shc = max(shc, get(i + 1, j + 1, i + 1, n) - dp(i + 1, j, 1));\n            shc = max(shc, - get(i + 1, j + 1, m, j + 1) - dp(i, j + 1, 1));\n        }\n    }\n    else {\n        if (i < m && j < n) {\n            shc = max(shc, - get(i + 1, j + 1, i + 1, n) - dp(i + 1, j, 0));\n            shc = max(shc, get(i + 1, j + 1, m, j + 1) - dp(i, j + 1, 0));\n        }\n    }\n    return shc;\n}\n\nvoid solve() {\n    cin >> n >> m;\n    FOR(i, 1, m) FOR(j, 1, n) {\n        int x; cin >> x;\n        a[i][j] = a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1] + x;\n    }\n\n    cout << abs(dp(0, 0, 0)) << '\\n';\n}\n\nmain() {\n    init(); solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\nconst LL INF = 1e18;\n\nint W, H;\nvector<vector<LL>> S;\n\nLL score(int i, int j) {\n  auto L = S[i+1][j] - S[i+1][0];\n  auto R = S[i+1][W] - S[i+1][j];\n  return ((i + j) & 1) ? L - R : R - L ;\n}\n\nLL dfs(int i, int j) {\n  static vector<vector<LL>> memo(H + 1, vector<LL>(W + 1, INF));\n  if(memo[i][j] != INF) return memo[i][j];\n  if(i == H) return memo[i][j] = 0;\n  if(j == W) return memo[i][j] = score(i, j) - dfs(i + 1, j);\n  return memo[i][j] = max(-dfs(i, j + 1), score(i, j) - dfs(i + 1, j));\n}\n\nint main() {\n  cin >> W >> H;\n  S.assign(H + 1, vector<LL>(W + 1));\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> S[i][j], S[i][j] += S[i][j - 1];\n  cout << dfs(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 1001;\nconst int INF = 19191919;\n\nint w,h;\nint s[N][N]={};\nint ps[N][N]={};\n\nint dp[N][N][2];\nint dfs(int y, int x, int t)\n{\n    if(dp[y][x][t] != -INF) return dp[y][x][t];\n    if(x==w) return 0;\n\n    int ret;\n    if(t==0)\n    {\n        ret = -INF;\n        // down\n        if(y+1<=h) ret = max(ret, dfs(y+1,x,!t));\n        // right\n        if(x+1<=w)\n        {\n            int diff = 2*ps[y][x+1] - ps[h][x+1];\n            ret = max(ret,dfs(y,x+1,!t) + diff);\n        }\n    }\n    else\n    {\n        ret = INF;\n        // down\n        if(y+1<=h) ret = min(ret, dfs(y+1,x,!t));\n        // right\n        if(x+1<=w)\n        {\n            int diff = 2*ps[y][x+1] - ps[h][x+1];\n            ret = min(ret,dfs(y,x+1,!t) + diff);\n        }\n    }\n\n    return dp[y][x][t] = ret;\n}\n\nint main()\n{\n    scanf(\" %d %d\", &w, &h);\n    rep(i,h)rep(j,w) scanf(\" %d\", &s[i+1][j+1]);\n\n    // prefix sum (vertical)\n    rep(i,w+1)\n    {\n        for(int j=1; j<=h; ++j) ps[j][i] = ps[j-1][i]+s[j][i];\n    }\n\n    rep(i,N)rep(j,N)rep(k,2) dp[i][j][k] = -INF;\n    printf(\"%d\\n\", abs(dfs(0,0,0)));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint w,h;\nint dp[2000][2000][2],s[2000][2000];\nint sum[2000][2000];\nint dx[]{1,0},dy[]{0,1};\n\nint rec(int x,int y,int a){\n\tif(dp[x][y][a]!=-1)return dp[x][y][a];\n\tif(y==w)return 0;\n\tint res=(a==0?INT_MIN:INT_MAX);\n\trep(i,2){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx>h)continue;\n\t\tint b=rec(nx,ny,!a)+(i==1?sum[x][y]:0);\n\t\tif(a==0)res=max(res,b);\n\t\telse res=min(res,b);\n\t}\n\treturn dp[x][y][a]=res;\n}\nint main(){\n\tscanf(\"%d%d\",&w,&h);\n\trep(i,h)rep(j,w)scanf(\"%d\",&s[i][j]);\n\tint a=0;\n\trep(i,w)rep(j,h){\n\t\tsum[j+1][i]=sum[j][i]+s[j][i];\n\t\ta+=s[j][i];\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tcout<<abs(a-rec(0,0,0)*2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll W,H;\nll s[1003][1003];\n\nll memo[1003][1003];\nll dp[1003][1003];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> W >> H;\n\n    for (int i = 0;i < H;i++){\n        for (int j = 0;j < W;j++){\n            cin >> s[i][j];\n        }\n    }\n\n    for (int i = 0;i < H;i++){\n        ll sum = 0;\n        for (int j = 0;j < W;j++){\n            sum += s[i][j];\n        }\n        ll tmp = 0;\n        for (int j = 0;j <= W;j++){\n            memo[i][j] = tmp-(sum-tmp);\n            if((i+j)%2 == 0){\n                memo[i][j] *= -1;\n            }\n            if(j != W) tmp += s[i][j];\n        }\n    }\n\n    for (int i = H;i >= 0;i--){\n        for (int j = W;j >= 0;j--){\n            if(i == H) dp[i][j] = 0;\n            else if(j == W) dp[i][j] = memo[i][j]-dp[i+1][j];\n            else dp[i][j] = max(-dp[i][j+1],memo[i][j]-dp[i+1][j]);\n        }\n    }\n\n    cout << abs(dp[0][0]) << endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint dp[1007][1007],a[1007][1007],sum[1007][1007],vis[1007][1007],total=0;\nint solve(int x,int y){\n\tif(vis[x][y]) return dp[x][y];\n\tif(x==n && y==m) return 0;\n\tvis[x][y]=1;\n\tint turn=(x+y)%2,ret=0;\n\tif(turn==1){\n\t\tret=-2e9;\n\t\tif(y!=m) ret=max(ret,solve(x,y+1));\n\t\tif(x!=n) ret=max(ret,solve(x+1,y)+sum[x+1][y]);\n\t}\n\telse{\n\t\tret=2e9;\n\t\tif(y!=m) ret=min(ret,solve(x,y+1));\n\t\tif(x!=n) ret=min(ret,solve(x+1,y)+sum[x+1][y]);\n\t}\n\tdp[x][y]=ret;\n\treturn ret;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>m>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tsum[i][0]=0;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>a[i][j];\n\t\t\tsum[i][j]=sum[i][j-1]+a[i][j];\n\t\t\ttotal+=a[i][j];\n\t\t}\n\t}\n\tsolve(0,0);\n\t//cout<<dp[0][0]<<endl;\n\tcout<<abs(total-2*dp[0][0])<<\"\\n\";;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include    <bits/stdc++.h>\n#define fo(i,a,b) for(int i=a;i<=b;++i)\n#define fd(i,a,b) for(int i=a;i>=b;--i)\n#define rep(i,a,b)  for(int i=a;i<b;++i)\n#define fore(i,a)  for(__typeof(a.begin()) i=a.begin();i!=a.end();++i)\n#define __unique(V) V.resize(unique(V.begin(),V.end())-V.begin())\n#define cntbit(X)   __builtin_popcount(X)\n#define fi  first\n#define se  second\n#define LL  long long\n#define ii  pair<int,int>\n#define iii pair<int,ii>\n#define TASK \"FOF\"\nusing   namespace   std;\nint n,m,a[1005][1005];\nint F[1005][1005],G[1005][1005][2];\n///--------------------------\nvoid    readf(){\n    cin>>n>>m;\n    fo(i,1,m) fo(j,1,n){\n        cin>>a[i][j];\n        F[i][j]=F[i-1][j]+F[i][j-1]-F[i-1][j-1]+a[i][j];\n    }\n}\n///--------------------------\nint get(int X1,int Y1,int X2,int Y2){\n    return (F[X2][Y2]-F[X1-1][Y2]-F[X2][Y1-1]+F[X1-1][Y1-1]);\n}\n///--------------------------\nint dp(int i,int j,int id){\n    if (G[i][j][id]!=-1) return G[i][j][id];\n    int &rs=G[i][j][id];\n    if (i==m || j==n) return (rs=0);\n    rs=-1e9-1;\n    if (id==0){\n        if (i<m && j<n){\n            rs=max(rs,get(i+1,j+1,i+1,n)-dp(i+1,j,1));\n            rs=max(rs,-get(i+1,j+1,m,j+1)-dp(i,j+1,1));\n        }\n    }else{\n        if (i<m && j<n){\n            rs=max(rs,-get(i+1,j+1,i+1,n)-dp(i+1,j,0));\n            rs=max(rs,get(i+1,j+1,m,j+1)-dp(i,j+1,0));\n        }\n    }\n    return rs;\n}\n///--------------------------\nvoid    solve(){\n    memset(G,-1,sizeof(G));\n    cout<<abs(dp(0,0,0))<<'\\n';\n}\n///--------------------------\nint     main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    readf();\n    solve();\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define Link \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0352\"\n\n#include <iostream>\n#include <cstdio>\n\n#define TASK \"Forecast of Forces\"\n\nusing namespace std;\n\nvoid OpenFile()\n{\n    freopen(TASK\".INP\",\"r\",stdin);\n    freopen(TASK\".OUT\",\"w\",stdout);\n}\n\nconst int maxn = 1e3 + 1;\nint w,h,a[maxn][maxn],d[maxn][maxn],f[maxn][maxn];\n\nvoid Enter()\n{\n    cin >> w >> h;\n    for (int i=1;i<=h;++i)\n        for (int j=1;j<=w;++j)\n            cin >> a[i][j];\n}\n\nvoid Init()\n{\n    for (int i=1;i<=h;++i) {\n        for (int j=1;j<=w;++j)\n            d[i][0] -= a[i][j];\n        for (int j=1;j<=w;++j)\n            d[i][j] = d[i][j-1] + 2 * a[i][j];\n//        for (int j=0;j<=w;++j)\n//            cout << i << ' ' << j << ' ' << d[i][j] << ' ' << a[i][j] << '\\n';\n    }\n}\n\nvoid Solve()\n{\n    f[0][0] = 0;\n    for (int i=0;i<=h;++i)\n        for (int j=0;j<=w;++j) {\n            if (i != 0 || j != 0)\n                if (i == 0)\n                    f[i][j] = f[i][j-1];\n                else\n                    if (j == 0)\n                        f[i][j] = f[i-1][j] + d[i][j];\n                    else\n                        if ((i+j) % 2)\n                            f[i][j] = max(f[i][j-1],f[i-1][j]+d[i][j]);\n                        else\n                            f[i][j] = min(f[i][j-1],f[i-1][j]+d[i][j]);\n//            cout << i << ' ' << j << ' ' << f[i][j] << '\\n';\n        }\n    cout << max(f[h][w],-f[h][w]);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    //OpenFile();\n\n    Enter();\n    Init();\n    Solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n \nusing namespace std;\nconst int Maxh=1000+100;\n \nint h,w;\nint a[Maxh][Maxh];\nint l[Maxh][Maxh],r[Maxh][Maxh];\nint fl[Maxh][Maxh],fr[Maxh][Maxh],sl[Maxh][Maxh],sr[Maxh][Maxh];\nint Res;\n \nvoid BuildLR()\n{\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=w; j>=1; j--) r[i][j]=r[i][j+1]+a[i][j];\n        for (int j=1; j<=w; j++) l[i][j]=l[i][j-1]+a[i][j];\n    }\n}\n \nvoid BuildFSLR()\n{\n    for (int i=h; i>=1; i--)\n    {\n        for (int j=w+1; j>=0; j--)\n        {\n            fl[i][j]=sl[i+1][j]+l[i][j];\n            sl[i][j]=max(fl[i][j],sl[i][j+1]);\n            fr[i][j]=sr[i+1][j]+r[i][j];\n            sr[i][j]=max(fr[i][j],sr[i][j+1]);\n        }\n    }\n}\n \nvoid Solve()\n{\n    Res=0;\n    int i=1, j=0;\n    while (true)\n    {\n        if (fr[i][j+1]==sr[i][j+1]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n        if (fl[i][j]==sl[i][j]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n    }\n \n    int S=0;\n    for (int i=1; i<=h; i++) S+=r[i][1];\n    S-=Res; Res=abs(Res-S);\n}\n \nint main()\n{\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1; i<=h; i++)\n    for (int j=1; j<=w; j++) scanf(\"%d\",&a[i][j]);\n \n    BuildLR();\n    BuildFSLR();\n    Solve();\n \n    printf(\"%d\",Res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define ff(i,a,b) for (int i=(a);i<=(b);i++)\nusing namespace std;\nconst int N=1010, inf=1e9+7;\nint n,m;\nint a[N][N], sa[N][N];\nbool ready[N][N][2]; int memo[N][N][2];\nint sum (int r1, int c1, int r2, int c2) {\n    if (r1>r2 || c1>c2) return 0;\n    return sa[r2][c2] - sa[r2][c1-1] - sa[r1-1][c2] + sa[r1-1][c1-1];\n}\nint game (int r, int c, int p) {\n    if (r==n+1 && c==m+1) return 0;\n    if (ready[r][c][p]) return memo[r][c][p];\n    int ans=(p==0)?-inf:inf; ///Đang muốn làm max/làm min miệu.\n    ///Người cmơi miện tại: Nam tiến\n    if (r<n+1) {\n        int tmp = game(r+1, c, 1-p) + sum(r,c,r,m) - sum(r,1,r,c-1); ///Hiệu (Nobuo-Shizuo) mới.\n        if (p==0) { ///Đây là Nobuo, ăn pmía đông\n            if (tmp > ans)\n                ans = tmp;\n        }\n        else { ///Đây là Shizuo, sẽ ăn phần phía tây.\n            if (tmp<ans)\n                ans = tmp;\n        }\n    }\n    ///Người chơi hiện tại: Đông tiến.\n    if (c<m+1) {\n        ///Nobuo ăn Bắc, Shizuo ăn nam\n        int tmp = game(r, c+1, 1-p) + sum(1,c,r-1,c) - sum(r,c,n,c);\n        if (p==0) {\n            if (tmp>ans)\n                ans=tmp;\n        }\n        else {\n            if (tmp<ans)\n                ans=tmp;\n        }\n    }\n    ready[r][c][p]=1;\n    return memo[r][c][p]=ans;\n}\nint main() {/*\n    freopen(\"in.txt\",\"r\",stdin); freopen(\"out.txt\",\"w\",stdout); //*/\n    scanf(\"%d%d\",&n,&m); swap(n,m);\n    ff(i,1,n)\n    ff(j,1,m) {\n        scanf(\"%d\",&a[i][j]);\n        sa[i][j] = sa[i-1][j] + sa[i][j-1] - sa[i-1][j-1] + a[i][j];\n    }\n    printf(\"%d\\n\",abs(game (1,1,0))/2);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint w,h;\nint t[1005][1005],y[1005][1005];\nint dp[1005][1005];\nint main(void){\n    scanf(\"%d%d\",&w,&h);\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            int x;\n            scanf(\"%d\",&x);\n            t[i][j]+=x;\n            y[i][j]+=x;\n            t[i+1][j]+=t[i][j];\n            y[i][j+1]+=y[i][j];\n        }\n    }\n    for(int i=h;i>=0;i--){\n        for(int j=w;j>=0;j--){\n            int x=dp[i+1][j]+y[i+1][w]-y[i+1][j],y=dp[i][j+1]+t[i][j+1]-t[h][j+1];\n            if(i==h)dp[i][j]=y;\n            else if(j==w)dp[i][j]=x;\n            else{\n                if((i+j)%2==0)dp[i][j]=max(x,y);\n                else dp[i][j]=min(x,y);\n            }\n        }\n    }\n    printf(\"%d\\n\",abs(dp[0][0]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint x[1003][1003], H, W, dp[1003][1003][2];\nint range(int a, int b, int c, int d) {\n\treturn x[a - 1][b - 1] + x[c][d] - x[a - 1][d] - x[c][b - 1];\n}\nint solve(int p, int q, int r) {\n\tif (dp[p][q][r] >= (-1LL << 30))return dp[p][q][r];\n\tif (p == H + 1 || q == W + 1)return 0;\n\tint r1 = -2e9, r2 = -2e9;\n\tr1 = solve(p + 1, q, r ^ 1);\n\tr1 += range(p, q, p, W);\n\tr2 = solve(p, q + 1, r ^ 1);\n\tr2 -= range(p, q, H, q);\n\tif (r == 0) { dp[p][q][r] = max(r1, r2); return max(r1, r2); }\n\tif (r == 1) { dp[p][q][r] = min(r1, r2); return min(r1, r2); }\n}\nint main() {\n\tcin >> W >> H; for (int i = 0; i <= H + 1; i++) { for (int j = 0; j <= W + 1; j++) { dp[i][j][0] = -2e9; dp[i][j][1] = -2e9; } }\n\tfor (int i = 1; i <= H; i++) { for (int j = 1; j <= W; j++)cin >> x[i][j]; }\n\tfor (int i = 1; i <= H; i++) { for (int j = 1; j <= W; j++)x[i][j] += x[i - 1][j]; }\n\tfor (int i = 1; i <= H; i++) { for (int j = 1; j <= W; j++)x[i][j] += x[i][j - 1]; }\n\tcout << abs(solve(1, 1, 0)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<deque>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\nusing lint = long long;\nusing P = pair<int, int>;\nusing LLP = pair<long long, long long>;\n\n#define REP(i, x, n) for(int i = (x), i##_len = int(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = int(n) ; i < i##_len ; ++i)\n#define reps(i, n) for(int i = 1, i##_len = int(n) ; i <= i##_len ; ++i)\n#define rrep(i, n) for(int i = int(n) - 1 ; i >= 0 ; --i)\n#define rreps(i, n) for(int i = int(n) ; i > 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n#define TWINS(x) cout << ((x) ? \"Yay!\" : \":(\") << endl\n\nconst int IINF = (1 << 30) - 1;\nconst long long LLINF = 1LL << 61;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\nint w, h;\nvector< vector<int> > s;\nvector< vector<int> > sum;\nint dp[1005][1005];\n\ntemplate<typename T>\nbool chmax(T &_a, T _b){\n    if(_a < _b){\n        _a = _b;\n        return true;\n    }else{\n        return false;\n    }\n}\n\ntemplate<typename T>\nbool chmin(T &_a, T _b){\n    if(_a > _b){\n        _a = _b;\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint solve(int i, int j){\n    if(dp[i][j] < IINF){\n        return dp[i][j];\n    }else if(i == h && j == w){\n        return dp[i][j] = 0;\n    }\n\n    int res;\n    if((i + j) % 2 == 0){\n        res = -IINF;\n        if(i + 1 <= h) chmax(res, solve(i + 1, j) + (sum[i + 1][w] - sum[i + 1][j] - sum[i][w] + sum[i][j]));\n        if(j + 1 <= w) chmax(res, solve(i, j + 1) - (sum[h][j + 1] - sum[h][j] - sum[i][j + 1] + sum[i][j]));\n    }else{\n        res = IINF;\n        if(i + 1 <= h) chmin(res, solve(i + 1, j) + (sum[i + 1][w] - sum[i + 1][j] - sum[i][w] + sum[i][j]));\n        if(j + 1 <= w) chmin(res, solve(i, j + 1) - (sum[h][j + 1] - sum[h][j] - sum[i][j + 1] + sum[i][j]));\n    }\n\n    return dp[i][j] = res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> w >> h;\n\n    s.resize(h);\n    sum.resize(h + 1);\n    sum[0].resize(w + 1);\n    rep(i, h){\n        s[i].resize(w);\n        sum[i + 1].resize(w + 1);\n        rep(j, w){\n            cin >> s[i][j];\n            sum[i + 1][j + 1] = s[i][j];\n        }\n    }\n\n    rep(i, h + 1){\n        reps(j, w){\n            sum[i][j] += sum[i][j - 1];\n        }\n    }\n\n    rep(j, w + 1){\n        reps(i, h){\n            sum[i][j] += sum[i - 1][j];\n        }\n    }\n\n    fill(dp[0], dp[1005], IINF);\n\n    cout << abs(solve(0, 0)) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint W, H;\nint S[1001][1001];\nint TX[1001][1001], TY[1001][1001];\nint dp[1001][1001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> W >> H;\n  rep(i, H) rep(j, W) cin >> S[j][i];\n  rep(x, W) rep(y, H) {\n    dp[x][y] = -INF;\n  }\n  rep(x, W) {\n    for (int y=H-1; y>=0; y--) TY[x][y] = TY[x][y+1] + S[x][y];\n  }\n  rep(y, H) {\n    for (int x=W-1; x>=0; x--) TX[x][y] = TX[x+1][y] + S[x][y];\n  }\n\n  W++, H++;\n  dp[W-1][H-1] = 0;\n  for (int x=W-1; x>=0; x--) {\n    for (int y=H-1; y>=0; y--) {\n      bool fp = (x+y)%2 == 0;\n      int right = TY[x][y], down = TX[x][y];\n      if (fp) right *= -1;\n      if (!fp) down *= -1;\n      if (x+1 < W) dp[x][y] = max(dp[x][y], -dp[x+1][y] + right);\n      if (y+1 < H) dp[x][y] = max(dp[x][y], -dp[x][y+1] + down);\n    }\n  }\n  cout << abs(dp[0][0]) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int N=1e3+10;\nint n,m,a[N][N],L[N][N],R[N][N],ans[N][N][2];\nbool went[N][N][2];\nint max(int l,int r){return l>r?l:r;}\nint min(int l,int r){return l<r?l:r;}\nint dp(int x,int y,bool f){\n    if(went[x][y][f])return ans[x][y][f];\n    ans[x][y][f]=0;\n    int temp;\n    if(f){\n        if(x!=n){\n            ans[x][y][f]=dp(x+1,y,false)+R[x+1][m]-R[x+1][y];\n            went[x][y][f]=true;\n        }\n        if(y!=m){\n            temp=dp(x,y+1,false)-L[n][y+1]+L[x][y+1];\n            if(went[x][y][f])ans[x][y][f]=max(ans[x][y][f],temp);\n            else ans[x][y][f]=temp;\n        }\n    }\n    else{\n        if(x!=n){\n            ans[x][y][f]=dp(x+1,y,true)+R[x+1][m]-R[x+1][y];\n            went[x][y][f]=true;\n        }\n        if(y!=m){\n            temp=dp(x,y+1,true)-L[n][y+1]+L[x][y+1];\n            if(went[x][y][f])ans[x][y][f]=min(ans[x][y][f],temp);\n            else ans[x][y][f]=temp;\n        }\n    }\n    went[x][y][f]=true;\n    return ans[x][y][f];\n}\nint abs(int l){return l>0?l:-l;}\nint main(){\n    scanf(\"%d%d\",&m,&n);\n    for(int i=0;i<=n;i++)for(int j=0;j<=m;j++)went[i][j][0]=went[i][j][1]=L[i][j]=R[i][j]=false;\n    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){\n        scanf(\"%d\",&a[i][j]);\n        L[i][j]=a[i][j]+L[i-1][j];\n        R[i][j]=a[i][j]+R[i][j-1];\n    }\n    printf(\"%d\\n\",abs(dp(0,0,true)));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 1e3 + 7;\nint t, res, n, m, sum;\nint a[N][N], dp[N][N][2];\nbool check[N][N][2];\n\nint go(int i, int j, int typ)\n{\n    if(check[i][j][typ]) return dp[i][j][typ];\n    check[i][j][typ] = true;\n    if(i == n) return dp[i][j][typ] = 0;\n    if(j == m) return dp[i][j][typ] = a[i + 1][m] + go(i + 1, j, 1 - typ);\n    if(typ == 0) return dp[i][j][0] = max(go(i, j + 1, 1), a[i + 1][j] + go(i + 1, j, 1));\n    return dp[i][j][1] = min(go(i, j + 1, 0), a[i + 1][j] + go(i + 1, j, 0));\n}\n\nmain()\n{\n#define file \"r\"\n//    freopen(file\".inp\", \"r\", stdin);\n//  freopen(file\".out\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin >> m >> n;\n    for(int i = 1; i <= n; i ++)\n        for(int j = 1; j <= m; j ++)\n        {\n            cin >> a[i][j];\n            sum += a[i][j]; a[i][j] += a[i][j - 1];\n        }\n    cout << abs(sum - 2*go(0, 0, 1)) << \"\\n\";\n//    for(int i = 0; i <= n; i ++)\n//    {\n//        for(int j = 0; j <= m; j ++) cout << dp[i][j][0] << \" \"; cout << \"\\n\";\n//        for(int j = 0; j <= m; j ++) cout << dp[i][j][1] << \" \"; cout << \"\\n\\n\";\n//    }\n//    cout << sum << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b)    for (int i = a; i <= (int) b; ++i)\n#define ii              pair <int, int>\nusing namespace std;\nconst int N = 1e3 + 3;\nint m, n, a[N][N], f[N][N][2], vis[N][N][2];\n\nvoid init() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    //freopen(\"main.inp\",\"r\",stdin);\n    //freopen(\"main.out\",\"w\",stdout);\n}\n\nint get(int xo, int yo, int xi, int yi) {\n    return a[xi][yi] + a[xo - 1][yo - 1] - a[xi][yo - 1] - a[xo - 1][yi];\n}\n\nint dp(int i, int j, int id) {\n    int &shc = f[i][j][id], &foo = vis[i][j][id];\n    if (foo != -1) return shc;\n    if (i == m || j == n) return shc = 0;\n    shc = INT_MIN; foo = 1;\n    if (id == 0) {\n        if (i < m && j < n) {\n            shc = max(shc, get(i + 1, j + 1, i + 1, n) - dp(i + 1, j, 1));\n            shc = max(shc, - get(i + 1, j + 1, m, j + 1) - dp(i, j + 1, 1));\n        }\n    }\n    else {\n        if (i < m && j < n) {\n            shc = max(shc, - get(i + 1, j + 1, i + 1, n) - dp(i + 1, j, 0));\n            shc = max(shc, get(i + 1, j + 1, m, j + 1) - dp(i, j + 1, 0));\n        }\n    }\n    return shc;\n}\n\nvoid solve() {\n    cin >> m >> n;\n    FOR(i, 1, m) FOR(j, 1, n) {\n        int x; cin >> x;\n        a[i][j] = a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1] + x;\n    }\n\n    memset(vis, -1, sizeof vis);\n    cout << abs(dp(0, 0, 0)) << '\\n';\n}\n\nmain() {\n    init(); solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n \nusing namespace std;\nconst int Maxh=1000+100;\n \nint h,w;\nint a[Maxh][Maxh];\nint l[Maxh][Maxh],r[Maxh][Maxh];\nint fl[Maxh][Maxh],fr[Maxh][Maxh],sl[Maxh][Maxh],sr[Maxh][Maxh];\nint Res;\n \nvoid BuildLR()\n{\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=w; j>=1; j--) r[i][j]=r[i][j+1]+a[i][j];\n        for (int j=1; j<=w; j++) l[i][j]=l[i][j-1]+a[i][j];\n    }\n}\n \nvoid BuildFSLR()\n{\n    for (int i=h; i>=1; i--)\n    {\n        for (int j=w+1; j>=0; j--)\n        {\n            fl[i][j]=sl[i+1][j]+l[i][j];\n            sl[i][j]=max(fl[i][j],sl[i][j+1]);\n            fr[i][j]=sr[i+1][j]+r[i][j];\n            sr[i][j]=max(fr[i][j],sr[i][j+1]);\n        }\n    }\n}\n \nvoid Solve()\n{\n    Res=0;\n    int i=1, j=0;\n    while (true)\n    {\n        if (fr[i][j+1]==sr[i][j+1]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n        if (fl[i][j]==sl[i][j]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n    }\n \n    int S=0;\n    for (int i=1; i<=h; i++) S+=r[i][1];\n    S-=Res; Res=abs(Res-S);\n}\n \nint main()\n{\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1; i<=h; i++)\n    for (int j=1; j<=w; j++) scanf(\"%d\",&a[i][j]);\n \n    BuildLR();\n    BuildFSLR();\n    Solve();\n \n    printf(\"%d\",Res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nusing int64 = long long int;\nconst int64 INF = 1LL << 60;\n\n// first - second\nint W, H; int64 dp[1010][1010];\nvector< vector<int> > rows;\nvector< vector<int> > cols;\n\nint64 solve(int r, int c) {\n  // fprintf(stderr, \"r = %d, c = %d\\n\", r, c);\n  int64 &res = dp[r][c];\n  if(res != INF) return res;\n  if(r == H and c == W) return res = 0;\n  bool is_second = (r + c) % 2 == 1;\n  \n  res = (is_second ? INF : -INF);\n  // second\n  if(is_second) {\n    if(r + 1 <= H) {\n      int64 val = rows[r][W] - rows[r][c];\n      int64 fs = solve(r+1, c);\n      fs += val;\n      res = min(res, fs);\n    }\n    if(c + 1 <= W) {\n      int64 val = cols[c][H] - cols[c][r];\n      int64 fs = solve(r, c+1);\n      fs -= val;\n      res = min(res, fs);\n    }\n  }\n  // first\n  else {\n    if(r + 1 <= H) {\n      int64 val = rows[r][W] - rows[r][c];\n      int64 fs = solve(r+1, c);\n      fs += val;\n      res = max(res, fs);\n    }\n    if(c + 1 <= W) {\n      int64 val = cols[c][H] - cols[c][r];\n      int64 fs = solve(r, c+1);\n      fs -= val;\n      res = max(res, fs);\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin >> W >> H;\n  rows.resize(H);\n  cols.resize(W);\n  for(int i=0; i<H; i++) rows[i].emplace_back(0);\n  for(int i=0; i<W; i++) cols[i].emplace_back(0);\n\n  for(int i=0; i<H; i++) {\n    for(int j=0; j<W; j++) {\n      int val; cin >> val;\n      rows[i].emplace_back(rows[i].back() + val);\n      cols[j].emplace_back(cols[j].back() + val);\n    }\n  }\n\n  fill(dp[0], dp[H+1], INF);\n  cout << abs(solve(0, 0)) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b)    for (int i = a; i <= (int) b; ++i)\n#define ii              pair <int, int>\nusing namespace std;\nconst int N = 1e3 + 3;\nint m, n, a[N][N], f[N][N][2], vis[N][N][2];\n\nvoid init() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    //freopen(\"main.inp\",\"r\",stdin);\n    //freopen(\"main.out\",\"w\",stdout);\n}\n\nint get(int xo, int yo, int xi, int yi) {\n    return a[xi][yi] + a[xo - 1][yo - 1] - a[xi][yo - 1] - a[xo - 1][yi];\n}\n\nint dp(int i, int j, int id) {\n    int &shc = f[i][j][id], &foo = vis[i][j][id];\n    if (foo != -1) return foo;\n    if (i == m || j == n) return shc = 0;\n    shc = INT_MIN; foo = 1;\n    if (id == 0) {\n        if (i < m && j < n) {\n            shc = max(shc, get(i + 1, j + 1, i + 1, n) - dp(i + 1, j, 1));\n            shc = max(shc, - get(i + 1, j + 1, m, j + 1) - dp(i, j + 1, 1));\n        }\n    }\n    else {\n        if (i < m && j < n) {\n            shc = max(shc, - get(i + 1, j + 1, i + 1, n) - dp(i + 1, j, 0));\n            shc = max(shc, get(i + 1, j + 1, m, j + 1) - dp(i, j + 1, 0));\n        }\n    }\n    return shc;\n}\n\nvoid solve() {\n    cin >> m >> n;\n    FOR(i, 1, m) FOR(j, 1, n) {\n        int x; cin >> x;\n        a[i][j] = a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1] + x;\n    }\n\n    memset(vis, -1, sizeof vis);\n    cout << abs(dp(0, 0, 0)) << '\\n';\n}\n\nmain() {\n    init(); solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w, h;\nint a[1010][1010], b[1010][1010];\n\nint main()\n{\n  cin >> w >> h;\n  for (int i = 0; i < h; i++){\n    for (int j = 0; j < w; j++){\n      cin >> a[i][j];\n      b[i][j] = a[i][j];\n    }\n  }\n\n  for (int i = 0; i < h; i++){\n    for (int j = w - 2; j >= 0; j--){\n      a[i][j] += a[i][j + 1];\n    }\n  }\n\n\n  for (int i = h - 2; i >= 0; i--){\n    for (int j = 0; j < w; j++){\n      b[i][j] += b[i + 1][j];\n    }\n  }\n\n  int x = 0, y = 0;\n  int c1 = 0, c2 = 0;\n  for (int i = 0; i < h * w; i++){\n    if (i % 2){\n      if (a[y][x] < 0){\n        c1 += a[y][x];\n        y++;\n      } else {\n        c2 += b[y][x];\n        x++;\n      }\n    } else {\n      if (b[y][x] < 0){\n        c2 += b[y][x];\n        x++;\n      } else {\n        c1 += a[y][x];\n        y++;\n      }\n    }\n  }\n\n  cout << abs(c1 - c2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 2e9;\n\nint main() {\n    int w, h; cin >> w >> h;\n    vector<vector<int>> s(h, vector<int>(w));\n    vector<vector<int>> hsum(h, vector<int>(w + 1));\n    for(int i = 0; i < h; ++i) {\n        for(int j = 0; j < w; ++j) {\n            cin >> s[i][j];\n        }\n    }\n    for(int i = 0; i < h; ++i) {\n        for(int j = 0; j < w; ++j) {\n            hsum[i][j + 1] += hsum[i][j] + s[i][j];\n        }\n    }\n\n    vector<vector<int>> dp(h + 1, vector<int>(w + 1, inf));\n    dp[h][w] = 0;\n    function<int(int, int)> solve = [&] (int y, int x) {\n        assert(y < (int)dp.size() && x < (int)dp[y].size());\n        if(dp[y][x] != inf) return dp[y][x];\n        const int turn = (y + x) & 1;\n        int& res = dp[y][x] = (turn == 0 ? -inf : inf);\n        if(y != h) {\n            if(turn == 0) res = max(res, solve(y + 1, x) + (hsum[y][w] - hsum[y][x]) - hsum[y][x]);\n            else          res = min(res, solve(y + 1, x) + (hsum[y][w] - hsum[y][x]) - hsum[y][x]);\n        }\n        if(x != w) {\n            if(turn == 0) res = max(res, solve(y, x + 1));\n            else          res = min(res, solve(y, x + 1));\n        }\n        return res;\n    };\n\n    cout << abs(solve(0, 0)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint dp[1007][1007],a[1007][1007],sum[1007][1007],vis[1007][1007],total=0;\nint solve(int x,int y){\n\tif(vis[x][y]) return dp[x][y];\n\tif(x==n && y==m) return 0;\n\tvis[x][y]=1;\n\tint turn=(x+y)%2,ret=0;\n\tif(turn==1){\n\t\tret=-2e9;\n\t\tif(y!=m) ret=max(ret,solve(x,y+1));\n\t\tif(x!=n) ret=max(ret,solve(x+1,y)+sum[x+1][y]);\n\t}\n\telse{\n\t\tret=2e9;\n\t\tif(y!=m) ret=min(ret,solve(x,y+1));\n\t\tif(x!=n) ret=min(ret,solve(x+1,y)+sum[x+1][y]);\n\t}\n\tdp[x][y]=ret;\n\treturn ret;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>a[i][j];\n\t\t\tsum[i][j]=sum[i][j-1]+a[i][j];\n\t\t\ttotal+=a[i][j];\n\t\t}\n\t}\n\tsolve(0,0);\n\t//cout<<dp[0][0]<<endl;\n\tcout<<abs(total-2*dp[0][0]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll N = 1000 + 10;\nconst ll inf = 1e9 + 7;\n\nvoid maximize(ll &a, ll b) { a = max(a, b); }\nvoid minimize(ll &a, ll b) { a = min(a, b); }\n\nll n, m;\nll a[N][N];\n\nll dp[N][N];\nll vis[N][N];\nll col[N][N];\n\nll tx[3] = {0, 1};\nll ty[3] = {1, 0};\n\nll getCol(ll cid, ll l, ll r){\n\tif (r < l) return 0;\n\treturn col[cid][r] - col[cid][l - 1];\n}\n\nll dfs(ll i, ll j){\n\tif (vis[i][j]) return dp[i][j];\n\tif (i == n && j == m) \n\t\treturn dp[i][j] = 0;\n\tll turn = (i + j) % 2;\n\tdp[i][j] = (turn == 0 ? -inf : inf);\n\tfor (ll t = 0; t < 2; t++){\n\t\tll ni = tx[t] + i, nj = ty[t] + j;\n\t\tif (0 <= ni && ni <= n && 0 <= nj && nj <= m); else continue;\n\t\tll del = (t == 1 ? 0 : getCol(nj, 1, ni) - getCol(nj, ni + 1, n) );\n\t\tif (!turn) maximize( dp[i][j], dfs(ni, nj) + del);\n\t\telse\t   minimize( dp[i][j], dfs(ni, nj) + del);\n\t}\n\treturn dp[i][j];\n}\n\nmain(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\t// freopen(\"8.inp\", \"r\", stdin);\n\tcin >> m >> n;\n\tfor (ll i = 1; i <= n; i++)\n\t\tfor (ll j = 1; j <= m; j++)\n\t\t\tcin >> a[i][j];\n\t\n\tfor (ll j = 1; j <= m; j++){\n\t\tfor (ll i = 1; i <= n; i++)\n\t\t\tcol[j][i] = col[j][i - 1] + a[i][j];\n\t}\n\tcout << abs( dfs(0, 0) ) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define Link \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0352\"\n\n#include <iostream>\n#include <cstdio>\n\n#define TASK \"Forecast of Forces\"\n\nusing namespace std;\n\nvoid OpenFile()\n{\n    freopen(TASK\".INP\",\"r\",stdin);\n    freopen(TASK\".OUT\",\"w\",stdout);\n}\n\nconst int maxn = 1e3 + 1;\nint w,h,a[maxn][maxn],d[maxn][maxn],f[maxn][maxn];\n\nvoid Enter()\n{\n    cin >> w >> h;\n    for (int i=1;i<=h;++i)\n        for (int j=1;j<=w;++j)\n            cin >> a[i][j];\n}\n\nvoid Init()\n{\n    for (int i=1;i<=h;++i) {\n        for (int j=1;j<=w;++j)\n            d[i][0] -= a[i][j];\n        for (int j=1;j<=w;++j)\n            d[i][j] = d[i][j-1] + 2 * a[i][j];\n//        for (int j=0;j<=w;++j)\n//            cout << i << ' ' << j << ' ' << d[i][j] << ' ' << a[i][j] << '\\n';\n    }\n}\n\nvoid Solve()\n{\n    f[0][0] = 0;\n    for (int i=0;i<=h;++i)\n        for (int j=0;j<=w;++j) {\n            if (i != 0 || j != 0)\n                if (i == 0)\n                    f[i][j] = f[i][j-1];\n                else\n                    if (j == 0)\n                        f[i][j] = f[i-1][j] + d[i][j];\n                    else\n                        if ((i+j) % 2)\n                            f[i][j] = max(f[i][j-1],f[i-1][j]+d[i][j]);\n                        else\n                            f[i][j] = min(f[i][j-1],f[i-1][j]+d[i][j]);\n//            cout << i << ' ' << j << ' ' << f[i][j] << '\\n';\n        }\n    cout << max(f[h][w],-f[h][w]);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    //OpenFile();\n\n    Enter();\n    Init();\n    Solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e3 + 5;\n\nint n, m, a[N][N], f[N][N], visited[N][N], col[N][N];\n\nint dp(int x, int y) {\n\tif(visited[x][y]) return f[x][y];\n\tif(x == n && y == m) return f[x][y] = 0;\n\tvisited[x][y] = true; f[x][y] = -1e9;\n\tint sum = col[n][y + 1] - 2 * col[x][y + 1];\n\tif(!((x + y) & 1)) sum = -sum;\n\tif(x + 1 <= n) f[x][y] = max(f[x][y], - dp(x + 1, y));\n\tif(y + 1 <= m) {\n\t\tf[x][y] = max(f[x][y], sum - dp(x, y + 1));\n\t}\n\treturn f[x][y];\n}\n\nint main() {\n\tcin >> m >> n;\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= m; ++j)\n\t\tcin >> a[i][j], col[i][j] = col[i - 1][j] + a[i][j];\n\tcout << abs(dp(0, 0)) << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P,P> PP;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(2e5 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nint w, h, a[1005][1005], dp[1005][1005];\n\nint rec(bool turn, int i, int j){\n    if(i==h && j==w) return 0;\n    if(dp[i][j] != -IINF) return dp[i][j];\n\n    int res = IINF*(turn?-1:1);\n    if(i<h){\n        int tmp = rec(!turn, i+1, j), sum = a[i+1][w] - a[i+1][j] - a[i][w] + a[i][j];\n        if(turn) res = max(res, tmp+sum);\n        else res = min(res, tmp+sum);\n    }\n    if(j<w){\n        int tmp = rec(!turn, i, j+1), sum = a[h][j+1] - a[h][j] - a[i][j+1] + a[i][j];\n        if(turn) res = max(res, tmp-sum);\n        else res = min(res, tmp-sum);\n    }\n    return dp[i][j] = res;\n}\n\n\nint main() {\n    cin >> w >> h;\n    REP(i,h)REP(j,w) cin >> a[i+1][j+1];\n    REP(i,h){\n        REP(j,w){\n            a[i+1][j+1] += a[i+1][j] + a[i][j+1] - a[i][j];\n        }\n    }\n    \n    REP(i,h+1) fill(dp[i],dp[i]+w+1,-IINF);\n    cout << abs(rec(true,0,0)) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int LIM = 1e3 + 5, INF = 1e9 + 7;\n\nint n, m, s[LIM][LIM], f[LIM][LIM];\nbool chk[LIM][LIM];\n\nint solve(int i, int j, bool turn)\n{\n\tif (i > m || j > n) return 0;\n\t\n\tif (chk[i][j]) return f[i][j];\n\tchk[i][j] = true;\n\tf[i][j] = -INF;\n\t\n\tint val, tmp;\n\t\n\tval = s[i][n] - s[i][j - 1] - s[i - 1][n] + s[i - 1][j - 1];\n\ttmp = solve(i + 1, j, !turn);\n\tif (!turn) f[i][j] = std::max(f[i][j], val - tmp);\n\telse f[i][j] = std::max(f[i][j], -val - tmp);\n\t\n\tval = s[m][j] - s[m][j - 1] - s[i - 1][j] + s[i - 1][j - 1];\n\ttmp = solve(i, j + 1, !turn);\n\tif (!turn) f[i][j] = std::max(f[i][j], -val - tmp);\n\telse f[i][j] = std::max(f[i][j], val - tmp);\n\t\n//\tprintf(\"f %d %d = %d\\n\", i, j, f[i][j]);\n\t\n\treturn f[i][j];\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t{\n\t\t\tscanf(\"%d\", &s[i][j]);\n\t\t\ts[i][j] += s[i - 1][j];\n\t\t\ts[i][j] += s[i][j - 1];\n\t\t\ts[i][j] -= s[i - 1][j - 1];\n\t\t}\n\tprintf(\"%d\\n\", abs(solve(1, 1, false)));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS  = 1e-10;\nconst bool debug = 0;\n//---------------------------//\n\nint H, W;\nint s[1000][1000], sum[1000][1001];\nint allsum[1001][1001];\nint dp[1001][1001];\n\nint dfs(int i, int j, int turn) {\n\tif (i == H && j == W) return 0;\n\tif (~dp[i][j]) return dp[i][j];\n\t\n\tint res;\n\tif (i == H) res = dfs(i, j + 1, !turn);\n\telse if (j == W) res = dfs(i + 1, j, !turn) + sum[i][W] - sum[i][j];\n\telse {\n\t\tint fc1 = dfs(i + 1, j, !turn) + sum[i][W] - sum[i][j];\n\t\tint sc1 = allsum[H][W] - allsum[i][W] - allsum[H][j] + allsum[i][j] - fc1;\n\t\t\n\t\tint fc2 = dfs(i, j + 1, !turn);\n\t\tint sc2 = allsum[H][W] - allsum[i][W] - allsum[H][j] + allsum[i][j] - fc2;\n\t\t\n\t\tif (!turn) {\n\t\t\tif (fc1 - sc1 < fc2 - sc2) res = fc2;\n\t\t\telse res = fc1;\n\t\t}\n\t\telse {\n\t\t\tif (fc1 - sc1 > fc2 - sc2) res = fc2;\n\t\t\telse res = fc1;\n\t\t}\n\t}\n\t\n\treturn dp[i][j] = res;\n}\n\nint main(){\n\tcin >> W >> H;\n\tREP(i, H) REP(j, W) scanf(\"%d\", &s[i][j]);\n\t\n\tREP(i, H) REP(j, W) sum[i][j + 1] = sum[i][j] + s[i][j];\n\t\n\tREP(i, H) REP(j, W) allsum[i + 1][j + 1] = allsum[i + 1][j] + s[i][j];\n\tREP(j, W) REP(i, H) allsum[i + 1][j + 1] += allsum[i][j + 1];\n\t\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tint fc = dfs(0, 0, 0);\n\tint sc = allsum[H][W] - fc;\n\tcout << abs(fc - sc) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint W, H;\nint S[1000][1000];\nint TX[1001][1001], TY[1001][1001];\nint dp[1001][1001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> W >> H;\n  rep(i, H) rep(j, W) cin >> S[j][i];\n  rep(x, W) rep(y, H) {\n    dp[x][y] = -INF;\n  }\n  rep(x, W) {\n    for (int y=H-1; y>=0; y--) TY[x][y] = TY[x][y+1] + S[x][y];\n  }\n  rep(y, H) {\n    for (int x=W-1; x>=0; x--) TX[x][y] = TX[x+1][y] + S[x][y];\n  }\n\n  W++, H++;\n  dp[W-1][H-1] = 0;\n  for (int x=W-1; x>=0; x--) {\n    for (int y=H-1; y>=0; y--) {\n      bool fp = (x+y)%2 == 0;\n      // right: + S[x][*]\n      if (x+1 < W) dp[x][y] = max(dp[x][y], -dp[x+1][y] + (fp?-S[x][y]:TY[x][y]));\n      // down: + S[*][y]\n      if (y+1 < H) dp[x][y] = max(dp[x][y], -dp[x][y+1] + (fp?TX[x][y]:-S[x][y]));\n    }\n  }\n  cout << abs(dp[0][0]) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\nint main() {\n    int h, w;\n    cin >> w >> h;\n    auto S = make_v(h+1, w, 0);\n    auto T = make_v(h, w+1, 0);\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            scanf(\"%d\", &S[i][j]);\n            T[i][j] = S[i][j];\n        }\n    }\n    for (int i = h-1; i >= 0; --i) {\n        for (int j = w-1; j >= 0; --j) {\n            S[i][j] += S[i+1][j];\n            T[i][j] += T[i][j+1];\n        }\n    }\n    auto dp = make_v(h+1, w+1, -INF<int>);\n    dp.back().back() = 0;\n    for (int i = h; i >= 0; --i) {\n        for (int j = w; j >= 0; --j) {\n            if((i+j)&1){\n                if(i) chmax(dp[i-1][j], -dp[i][j]+T[i-1][j]);\n                if(j) chmax(dp[i][j-1], -dp[i][j]-S[i][j-1]);\n            }else {\n                if(i) chmax(dp[i-1][j], -dp[i][j]-T[i-1][j]);\n                if(j) chmax(dp[i][j-1], -dp[i][j]+S[i][j-1]);\n            }\n        }\n    }\n    cout << abs(dp[0][0]) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst int M = 1005, N = 1005;\n\nint m, n, in[M][N], c[M][N], ans[M][N];\nbool vis[M][N];\n\nint solve(int a, int b)\n{\n    if (vis[a][b])\n        return ans[a][b];\n    vis[a][b] = true;\n    if (b == n + 1)\n        return ans[a][b] = 0;\n    else\n    {\n        if ((a + b) % 2 == 0)        // first player\n        {\n            if (a == m + 1)\n                return ans[a][b] = c[m][b] - solve(a, b + 1);\n            else\n                return ans[a][b] = max(2 * c[a - 1][b] - c[m][b] - solve(a, b + 1), -solve(a + 1, b));\n        }\n        else                    // second player\n        {\n            if (a == m + 1)\n                return ans[a][b] = -c[m][b] - solve(a, b + 1);\n            else\n                return ans[a][b] = max(c[m][b] - 2 * c[a - 1][b] - solve(a, b + 1), -solve(a + 1, b));\n        }\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= m; i++)\n        for (int j = 1; j <= n; j++)\n        {\n            scanf(\"%d\", &in[i][j]);\n            c[i][j] = c[i - 1][j] + in[i][j];\n        }\n    printf(\"%d\\n\", abs(solve(1, 1)));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint w,h;\nint dp[2000][2000][2],s[2000][2000];\nint sum[2000][2000];\nint dx[]{1,0},dy[]{0,1};\n\nint rec(int x,int y,int a){\n\tif(dp[x][y][a]!=-1)return dp[x][y][a];\n\tif(y==w)return 0;\n\tint res=(a==0?INT_MIN:INT_MAX);\n\trep(i,2){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx>h)continue;\n\t\tint b=rec(nx,ny,!a)+(i==1?sum[x][y]:0);\n\t\tif(a==0)res=max(res,b);\n\t\telse res=min(res,b);\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&w,&h);\n\trep(i,h)rep(j,w)scanf(\"%d\",&s[i][j]);\n\tint a=0;\n\trep(i,w)rep(j,h){\n\t\tsum[j+1][i]=sum[j][i]+s[j][i];\n\t\ta+=s[j][i];\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tcout<<abs(a-rec(0,0,0)*2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\ntemplate <class T>\nclass cumulativeSum\n{\nprivate:\n    int ny, nx;\n    vector<vector<T> > sum;\npublic:\n    cumulativeSum(){\n    }\n    cumulativeSum(const vector<vector<T> >& a)\n    {\n        ny = a.size();\n        nx = a[0].size();\n        sum.assign(ny+1, vector<T>(nx+1, 0));\n        for(int i=0; i<ny; ++i){\n            for(int j=0; j<nx; ++j){\n                sum[i+1][j+1] = a[i][j] + sum[i][j+1] + sum[i+1][j] - sum[i][j];\n            }\n        }\n    }\n    T getSum(int y1, int x1, int y2, int x2)\n    {\n        y1 = max(y1, 0);\n        x1 = max(x1, 0);\n        y2 = min(y2, ny-1);\n        x2 = min(x2, nx-1);\n        if(y1 > y2 || x1 > x2)\n            return 0;\n        return sum[y2+1][x2+1] - sum[y1][x2+1] - sum[y2+1][x1] + sum[y1][x1];\n    }\n};\n\nconst int INF = INT_MAX / 2;\n\nint h, w;\ncumulativeSum<int> cs;\nvector<vector<int> > memo;\n\nint solve(int y, int x)\n{\n    if(y == h && x == w)\n        return 0;\n    if(memo[y][x] != -1)\n        return memo[y][x];\n\n    bool isFirst = ((y + x) % 2 == 0);\n    int ans = (isFirst ? -INF : INF);\n    if(y < h){\n        int tmp = solve(y+1, x);\n        tmp += cs.getSum(y, x, y, w-1);\n        if(isFirst)\n            ans = max(ans, tmp);\n        else\n            ans = min(ans, tmp);\n    }\n    if(x < w){\n        int tmp = solve(y, x+1);\n        tmp -= cs.getSum(y, x, h-1, x);\n        if(isFirst)\n            ans = max(ans, tmp);\n        else\n            ans = min(ans, tmp);\n    }\n\n    return memo[y][x] = ans;\n}\n\nint main()\n{\n    cin >> w >> h;\n    vector<vector<int> > s(h, vector<int>(w));\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            cin >> s[i][j];\n        }\n    }\n    cs = cumulativeSum<int>(s);\n\n    memo.assign(h+1, vector<int>(w+1, -1));\n    cout << abs(solve(0, 0)) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\nconst int Maxh=1000+100;\n\nint h,w;\nint a[Maxh][Maxh];\nint l[Maxh][Maxh],r[Maxh][Maxh];\nint fl[Maxh][Maxh],fr[Maxh][Maxh],sl[Maxh][Maxh],sr[Maxh][Maxh];\nint Res;\n\nvoid BuildLR()\n{\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=w; j>=1; j--) r[i][j]=r[i][j+1]+a[i][j];\n        for (int j=1; j<=w; j++) l[i][j]=l[i][j-1]+a[i][j];\n    }\n}\n\nvoid BuildFSLR()\n{\n    for (int i=h; i>=1; i--)\n    {\n        for (int j=w+1; j>=0; j--)\n        {\n            fl[i][j]=sl[i+1][j]+l[i][j];\n            sl[i][j]=max(fl[i][j],sl[i][j+1]);\n            fr[i][j]=sr[i+1][j]+r[i][j];\n            sr[i][j]=max(fr[i][j],sr[i][j+1]);\n        }\n    }\n}\n\nvoid Solve()\n{\n    Res=0;\n    int i=1, j=0;\n    while (true)\n    {\n        if (fr[i][j+1]==sr[i][j+1]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n        if (fl[i][j]==sl[i][j]) Res+=r[i][j+1],i++; else j++;\n        if ((i>h) || (j>=w)) break;\n    }\n\n    int S=0;\n    for (int i=1; i<=h; i++) S+=r[i][1];\n    S-=Res; Res=abs(Res-S);\n}\n\nvoid PrintAll()\n{\n    cout << \"A\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << a[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"L\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << l[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"FL\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << fl[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"SL\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << sl[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"R\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << r[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"FR\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << fr[i][j] << \" \";\n        cout << '\\n';\n    }\n    cout << \"SR\\n\";\n    for (int i=1; i<=h; i++)\n    {\n        for (int j=1; j<=w; j++) cout << sr[i][j] << \" \";\n        cout << '\\n';\n    }\n}\n\nint main()\n{\n    //freopen(\"inp.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\n    scanf(\"%d%d\",&w,&h);\n    for (int i=1; i<=h; i++)\n    for (int j=1; j<=w; j++) scanf(\"%d\",&a[i][j]);\n\n    BuildLR();\n    BuildFSLR();\n    Solve();\n    //PrintAll();\n\n    printf(\"%d\",Res);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0352\n\n#include<bits/stdc++.h>\nconst int N = 1005;\nconst int inf = 1e9;\nusing namespace std;\n\nint n, m, a[N][N], dp[N][N];\n\nint main(){\n    cin >> m >> n;\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> a[i][j];\n    for (int i = n; i >= 0; i--) for (int j = m; j >= 0; j--) a[i][j] += a[i+1][j] + a[i][j+1] - a[i+1][j+1];\n    dp[0][0] = 0;\n    for (int i = 0; i <= n; i++) for (int j = 0; j <= m; j++){\n        if (i == 0 && j == 0) continue;\n        if ((i + j) % 2 == 0) {\n            dp[i][j] = inf;\n            if (i > 0) dp[i][j] = min(dp[i][j], dp[i-1][j] - a[i][j+1] + a[i+1][j+1]);\n            if (j > 0) dp[i][j] = min(dp[i][j], dp[i][j-1] + a[i+1][j] - a[i+1][j+1]);\n        }\n        else {\n            dp[i][j] = -inf;\n            if (i > 0) dp[i][j] = max(dp[i][j], dp[i-1][j] - a[i][j+1] + a[i+1][j+1]);\n            if (j > 0) dp[i][j] = max(dp[i][j], dp[i][j-1] + a[i+1][j] - a[i+1][j+1]);\n        }\n    }\n    cout << abs(dp[n][m]) << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint W, H;\nint S[1001][1001];\nint TX[1001][1001], TY[1001][1001];\nint dp[1001][1001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> W >> H;\n  rep(i, H) rep(j, W) cin >> S[j][i];\n  rep(x, W) rep(y, H) {\n    dp[x][y] = -INF;\n  }\n  rep(x, W) {\n    for (int y=H-1; y>=0; y--) TY[x][y] = TY[x][y+1] + S[x][y];\n  }\n  rep(y, H) {\n    for (int x=W-1; x>=0; x--) TX[x][y] = TX[x+1][y] + S[x][y];\n  }\n\n  W++, H++;\n  dp[W-1][H-1] = 0;\n  for (int x=W-1; x>=0; x--) {\n    for (int y=H-1; y>=0; y--) {\n      bool fp = (x+y)%2 == 0;\n      // right: + S[x][*]\n      if (x+1 < W) dp[x][y] = max(dp[x][y], -dp[x+1][y] + (fp?-S[x][y]:TY[x][y]));\n      // down: + S[*][y]\n      if (y+1 < H) dp[x][y] = max(dp[x][y], -dp[x][y+1] + (fp?TX[x][y]:-S[x][y]));\n    }\n  }\n  cout << abs(dp[0][0]) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0352: Forecast of Forces\n// 2017.10.26\n\n#include <stdio.h>\n\n#define ABS(a) ((a)>=0?(a):-(a))\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\nint w, h;\nlong long map[1002][1002];\nlong long dp[1002][1002];\n\nlong long score(int r, int c)\n{\n\tif ((r+c) & 1) return map[r+1][c] - (map[r+1][w] - map[r+1][c]);\n\treturn (map[r+1][w] - map[r+1][c]) - map[r+1][c];\n}\n\nint main()\n{\n\tint r, c, v;\n\n\tscanf(\"%d%d\", &w, &h);\n\tfor (r = 1; r <= h; r++) for (c = 1; c <= w; c++) {\n\t\tscanf(\"%d\", &v);\n\t\tmap[r][c] = map[r][c-1] + v;\n\t}\n\tfor (r = h; r >= 0; r--) for (c = w; c >= 0; c--) {\n\t\tif (r == h) dp[r][c] = 0;\n\t\telse if (c == w) dp[r][c] = score(r, c) - dp[r+1][c];\n\t\telse dp[r][c] = MAX(-dp[r][c+1], score(r, c) - dp[r+1][c]);\n\t}\n\tprintf(\"%lld\\n\", ABS(dp[0][0]));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0352: Forecast of Forces\n// 2017.10.26 bal4u@uu\n// 2017.11.14\n\n#include <stdio.h>\n\n#define ABS(a) ((a)>=0?(a):-(a))\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\nint w, h;\nlong long map[1002][1002];\nlong long dp[1002][1002];\n\nlong long score(int r, int c)\n{\n\tlong long x = map[r+1][w] - (map[r+1][c] << 1);\n\tif ((r+c) & 1) return -x;\n\treturn x;\n}\n\nchar buf[6500], *p;\nint getint()\n{\n\tint n = 0;\n\tif (*p == '-') {\n\t\tp++; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\t\treturn -n;\n\t}\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint r, c;\n\n\tfgets(p=buf, 20, stdin), w = getint(), p++, h = getint();\n\tfor (r = 1; r <= h; r++) {\n\t\tfgets(p=buf, 6500, stdin);\n\t\tfor (c = 1; c <= w; c++) {\n\t\t\tmap[r][c] = map[r][c-1] + getint(); p++;\n\t\t}\n\t}\n\tfor (r = h; r >= 0; r--) for (c = w; c >= 0; c--) {\n\t\tif (r == h); // dp[r][c] = 0;\n\t\telse if (c == w) dp[r][c] = score(r, c) - dp[r+1][c];\n\t\telse             dp[r][c] = MAX(-dp[r][c+1], score(r, c) - dp[r+1][c]);\n\t}\n\tprintf(\"%lld\\n\", ABS(dp[0][0]));\n\treturn 0;\n}"
  },
  {
    "language": "Ruby",
    "code": "class Array\n    def accum\n        ac = Array.new(size + 1)\n        ac[0] = 0\n        (1..size).each do |i|\n            ac[i] = ac[i-1] + self[i-1]\n        end\n        ac\n    end\nend\n\nw, h = gets.split.map(&:to_i)\na = (1..h).map { gets.split.map(&:to_i) }\nh_accum = a.map(&:accum)\nv_accum = a.transpose.map(&:accum).transpose\n\nbest = (0..h).map { Array.new(w+1) }\nh.downto(0) do |i|\n    w.downto(0) do |j|\n        if i == h && j == w\n            best[i][j] = 0\n        elsif i == h\n            best[i][j] =   v_accum[i][j] + best[i][j+1]\n        elsif j == w\n            best[i][j] = - h_accum[i][j] + best[i+1][j]\n        else\n            candidates = [\n                v_accum[i][j] + best[i][j+1],\n              - h_accum[i][j] + best[i+1][j]\n            ]\n            best[i][j] = (i + j).even? ? candidates.max : candidates.min\n        end\n    end\nend\n\np a[0][0].abs\n"
  },
  {
    "language": "Ruby",
    "code": "class Array\n    def accum\n        ac = Array.new(size + 1)\n        ac[0] = 0\n        (1..size).each do |i|\n            ac[i] = ac[i-1] + self[i-1]\n        end\n        ac\n    end\nend\n\nw, h = gets.split.map(&:to_i)\na = (1..h).map { gets.split.map(&:to_i) }\nh_accum = a.map(&:accum)\nv_accum = a.transpose.map(&:accum).transpose\n\nbest = (0..h).map { Array.new(w+1) }\nh.downto(0) do |i|\n    w.downto(0) do |j|\n        if i == h && j == w\n            best[i][j] = 0\n        elsif i == h\n            best[i][j] =   v_accum[i][j] + best[i][j+1]\n        elsif j == w\n            best[i][j] = - h_accum[i][j] + best[i+1][j]\n        else\n            candidates = [\n                v_accum[i][j] + best[i][j+1],\n              - h_accum[i][j] + best[i+1][j]\n            ]\n            best[i][j] = (i + j).even? ? candidates.max : candidates.min\n        end\n    end\nend\n\np best[0][0].abs\n"
  },
  {
    "language": "Python",
    "code": "from itertools import accumulate\nimport sys\n\nsys.setrecursionlimit(1000000)\n\n\ndef main():\n    w, h = map(int, input().split())\n    mp = [list(map(int, input().split())) for _ in range(h)]\n    acc_mp = list(map(lambda line:[0] + list(accumulate(line)), mp))\n    mem = {}\n\n    def score(x, y, turn):\n        if (x, y) in mem:return mem[(x, y)]\n        if y >= h:\n            ret = 0\n        elif x >= w:\n            ret = acc_mp[y][x] + score(x, y + 1, 0)\n        else:\n            left = acc_mp[y][x]\n            right = acc_mp[y][w] - left\n            if turn == 0:\n                ret = max(score(x + 1, y, 1), left - right + score(x, y + 1, 1))\n            if turn == 1:\n                ret = min(score(x + 1, y, 0), left - right + score(x, y + 1, 0))\n        mem[(x, y)] = ret\n        return ret\n\n    print(abs(score(0, 0, 1)))\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\nw, h = map(int, input().split())\nS = [list(map(int, input().split())) for i in range(h)]\nSW = [[0]*w for i in range(h)]\nSH = [[0]*w for i in range(h)]\nfor i in range(h):\n    cnt = 0\n    for j in range(w-1, -1, -1):\n        cnt += S[i][j]\n        SW[i][j] = cnt\nfor j in range(w):\n    cnt = 0\n    for i in range(h-1, -1, -1):\n        cnt += S[i][j]\n        SH[i][j] = cnt\nmemo = {}\ndef dfs(x, y):\n    if (x, y) in memo:\n        return memo[x, y]\n    if x == w or y == h:\n        return 0\n    if (x+y) % 2 == 0:\n        # first\n        res = max(dfs(x+1, y) - SH[y][x], dfs(x, y+1) + SW[y][x])\n    else:\n        # second\n        res = min(dfs(x+1, y) - SH[y][x], dfs(x, y+1) + SW[y][x])\n    memo[x, y] = res\n    return res\nprint(abs(dfs(0, 0)))"
  },
  {
    "language": "Python",
    "code": "w, h = map(int, input().split())\nS = [list(map(int, input().split())) for i in range(h)]\nSW = [[0]*w for i in range(h)]\nSH = [[0]*w for i in range(h)]\nfor i in range(h):\n    cnt = 0\n    for j in range(w-1, -1, -1):\n        cnt += S[i][j]\n        SW[i][j] = cnt\nfor j in range(w):\n    cnt = 0\n    for i in range(h-1, -1, -1):\n        cnt += S[i][j]\n        SH[i][j] = cnt\nmemo = {}\ndef dfs(x, y):\n    if (x, y) in memo:\n        return memo[x, y]\n    if x == w or y == h:\n        return 0\n    if (x+y) % 2 == 0:\n        # first\n        res = max(dfs(x+1, y) - SH[y][x], dfs(x, y+1) + SW[y][x])\n    else:\n        # second\n        res = min(dfs(x+1, y) - SH[y][x], dfs(x, y+1) + SW[y][x])\n    memo[x, y] = res\n    return res\nprint(abs(dfs(0, 0)))"
  }
]