[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint maxDifference(int rows, int cols, int grid[rows][cols]) {\n    int dp[rows][cols];\n    int total = 0;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            total += grid[i][j];\n        }\n    }\n\n    dp[rows-1][cols-1] = grid[rows-1][cols-1];\n\n    for (int i = rows - 2; i >= 0; i--) {\n        dp[i][cols-1] = dp[i+1][cols-1] + grid[i][cols-1];\n    }\n\n    for (int j = cols - 2; j >= 0; j--) {\n        dp[rows-1][j] = dp[rows-1][j+1] + grid[rows-1][j];\n    }\n\n    for (int i = rows - 2; i >= 0; i--) {\n        for (int j = cols - 2; j >= 0; j--) {\n            dp[i][j] = grid[i][j] + (dp[i+1][j] > dp[i][j+1] ? dp[i+1][j] : dp[i][j+1]);\n        }\n    }\n\n    int player1 = dp[0][0];\n    int player2 = total - player1;\n    return abs(player1 - player2);\n}\n\nint main() {\n    int rows, cols;\n    scanf(\"%d %d\", &rows, &cols);\n    int grid[rows][cols];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    printf(\"%d\\n\", maxDifference(rows, cols, grid));\n    return 0;\n}",
    "timestamp": "2025-08-05 18:43:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TerritoryGame {\n    public static int maxScoreDifference(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        \n        // DP table to store max scores for reaching each cell\n        int[][] dp = new int[rows][cols];\n        dp[0][0] = grid[0][0];\n        \n        // Initialize first row\n        for (int j = 1; j < cols; j++) {\n            dp[0][j] = dp[0][j-1] + grid[0][j];\n        }\n        \n        // Initialize first column\n        for (int i = 1; i < rows; i++) {\n            dp[i][0] = dp[i-1][0] + grid[i][0];\n        }\n        \n        // Fill DP table\n        for (int i = 1; i < rows; i++) {\n            for (int j = 1; j < cols; j++) {\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n            }\n        }\n        \n        // Compute territories\n        int totalScore = 0;\n        for (int[] row : grid) {\n            for (int cell : row) {\n                totalScore += cell;\n            }\n        }\n        \n        // Northeast territory\n        int northeastScore = 0;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (i + j < rows + cols - 2) {\n                    northeastScore += grid[i][j];\n                }\n            }\n        }\n        \n        // Absolute score difference\n        int southwestScore = totalScore - northeastScore;\n        return Math.abs(northeastScore - southwestScore);\n    }\n    \n    public static void main(String[] args) {\n        int[][] grid = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        System.out.println(maxScoreDifference(grid));\n    }\n}",
    "timestamp": "2025-08-05 18:43:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<int>> grid(H, vector<int>(W));\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<int>> dp(H, vector<int>(W, 0));\n    dp[0][0] = grid[0][0];\n    for (int i = 1; i < H; ++i) {\n        dp[i][0] = dp[i-1][0] + grid[i][0];\n    }\n    for (int j = 1; j < W; ++j) {\n        dp[0][j] = dp[0][j-1] + grid[0][j];\n    }\n    for (int i = 1; i < H; ++i) {\n        for (int j = 1; j < W; ++j) {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n        }\n    }\n\n    int total = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            total += grid[i][j];\n        }\n    }\n\n    int max_diff = abs(2 * dp[H-1][W-1] - total);\n    cout << max_diff << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n\nint solve(int rows, int cols, int** grid) {\n    int** dp = malloc(rows * sizeof(int*));\n    for (int i = 0; i < rows; i++) {\n        dp[i] = calloc(cols, sizeof(int));\n    }\n\n    dp[0][0] = grid[0][0];\n\n    for (int i = 1; i < rows; i++) {\n        dp[i][0] = dp[i-1][0] + grid[i][0];\n    }\n\n    for (int j = 1; j < cols; j++) {\n        dp[0][j] = dp[0][j-1] + grid[0][j];\n    }\n\n    for (int i = 1; i < rows; i++) {\n        for (int j = 1; j < cols; j++) {\n            dp[i][j] = MAX(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n        }\n    }\n\n    int total_sum = 0;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            total_sum += grid[i][j];\n        }\n    }\n\n    int max_path_sum = dp[rows-1][cols-1];\n    int result = abs(max_path_sum - (total_sum - max_path_sum));\n\n    for (int i = 0; i < rows; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n\n    return result;\n}\n\nint main() {\n    int rows, cols;\n    scanf(\"%d %d\", &rows, &cols);\n\n    int** grid = malloc(rows * sizeof(int*));\n    for (int i = 0; i < rows; i++) {\n        grid[i] = malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int result = solve(rows, cols, grid);\n    printf(\"%d\\n\", result);\n\n    for (int i = 0; i < rows; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint maxTerritoryScoreDifference(int m, int n, vector<vector<int>>& grid) {\n    vector<vector<int>> dp(m, vector<int>(n, 0));\n    vector<vector<int>> northeast(m, vector<int>(n, 0));\n    vector<vector<int>> southwest(m, vector<int>(n, 0));\n\n    dp[0][0] = grid[0][0];\n    for (int i = 1; i < m; i++) dp[i][0] = dp[i-1][0] + grid[i][0];\n    for (int j = 1; j < n; j++) dp[0][j] = dp[0][j-1] + grid[0][j];\n\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n        }\n    }\n\n    int totalScore = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            totalScore += grid[i][j];\n        }\n    }\n\n    int maxDiff = INT_MIN;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int northeastScore = 0;\n            int southwestScore = 0;\n\n            for (int x = 0; x <= i; x++) {\n                for (int y = j + 1; y < n; y++) {\n                    northeastScore += grid[x][y];\n                }\n            }\n\n            for (int x = i + 1; x < m; x++) {\n                for (int y = 0; y <= j; y++) {\n                    southwestScore += grid[x][y];\n                }\n            }\n\n            maxDiff = max(maxDiff, abs(northeastScore - southwestScore));\n        }\n    }\n\n    return maxDiff;\n}\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    \n    vector<vector<int>> grid(m, vector<int>(n));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    int result = maxTerritoryScoreDifference(m, n, grid);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:45:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class TerritoryGame {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        int[][] grid = new int[H][W];\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        int[][] dp = new int[H][W];\n        dp[0][0] = grid[0][0];\n        \n        for (int i = 1; i < H; i++) {\n            dp[i][0] = dp[i-1][0] + grid[i][0];\n        }\n        \n        for (int j = 1; j < W; j++) {\n            dp[0][j] = dp[0][j-1] + grid[0][j];\n        }\n        \n        for (int i = 1; i < H; i++) {\n            for (int j = 1; j < W; j++) {\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n            }\n        }\n        \n        int total = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                total += grid[i][j];\n            }\n        }\n        \n        int player1 = dp[H-1][W-1];\n        int player2 = total - player1;\n        System.out.println(Math.abs(player1 - player2));\n    }\n}",
    "timestamp": "2025-08-05 18:45:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_abs_diff(island):\n    def dfs(x, y, territory1, territory2):\n        if x == len(island) - 1 and y == len(island[0]) - 1:\n            territory1_sum = sum(sum(island[i][j] for j in range(y + 1, len(island[0]))) for i in range(x + 1))\n            territory2_sum = sum(sum(island[i][j] for j in range(0, y + 1)) for i in range(x, len(island)))\n            territory1_sum += territory1\n            territory2_sum += territory2\n            return abs(territory1_sum - territory2_sum)\n        \n        max_diff = 0\n        if x + 1 < len(island):\n            max_diff = max(max_diff, dfs(x + 1, y, territory1, territory2 + island[x][y]))\n        if y + 1 < len(island[0]):\n            max_diff = max(max_diff, dfs(x, y + 1, territory1 + island[x][y], territory2))\n        \n        return max_diff\n    \n    return dfs(0, 0, island[0][0], 0)\n\n# Example usage:\nisland = [\n    [3, 2, 1], \n    [1, 9, -2], \n    [-5, 3, 7]\n]\n\nprint(max_abs_diff(island))",
    "timestamp": "2025-08-13 00:43:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class TerritoryGame {\n    public static int maxScoreDifference(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n\n        int[][] dpFirst = new int[n][m];\n        int[][] dpSecond = new int[n][m];\n        \n        // Initialize the DP tables\n        dpFirst[0][0] = grid[0][0];\n        dpSecond[0][0] = grid[0][0];\n\n        // Fill the DP table for the first player's territory\n        for (int i = 1; i < n; i++) {\n            dpFirst[i][0] = dpFirst[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < m; j++) {\n            dpFirst[0][j] = dpFirst[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < m; j++) {\n                dpFirst[i][j] = Math.max(dpFirst[i - 1][j], dpFirst[i][j - 1]) + grid[i][j];\n            }\n        }\n\n        // Fill the DP table for the second player's territory\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = m - 1; j >= 0; j--) {\n                if (i == n - 1 && j == m - 1) continue;\n                int down = i + 1 < n ? dpSecond[i + 1][j] : Integer.MIN_VALUE;\n                int right = j + 1 < m ? dpSecond[i][j + 1] : Integer.MIN_VALUE;\n                dpSecond[i][j] = Math.max(down, right) + grid[i][j];\n            }\n        }\n\n        return Math.abs(dpFirst[n - 1][m - 1] - dpSecond[0][0]);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n\n        scanner.close();\n        System.out.println(maxScoreDifference(grid));\n    }\n}",
    "timestamp": "2025-08-13 00:44:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nint max_abs_diff(int grid[MAX][MAX], int n, int m) {\n    int dp_south[MAX][MAX] = {0}, dp_east[MAX][MAX] = {0};\n\n    dp_south[0][0] = grid[0][0];\n    dp_east[0][0] = grid[0][0];\n\n    for (int i = 1; i < n; ++i) {\n        dp_south[i][0] = dp_south[i - 1][0] + grid[i][0];\n    }\n    for (int j = 1; j < m; ++j) {\n        dp_east[0][j] = dp_east[0][j - 1] + grid[0][j];\n    }\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 1; j < m; ++j) {\n            dp_south[i][j] = grid[i][j] + dp_south[i - 1][j];\n            dp_east[i][j] = grid[i][j] + dp_east[i][j - 1];\n        }\n    }\n\n    int northeast_sum = dp_east[n - 1][m - 2] + dp_south[n - 2][m - 1];\n    int southwest_sum = dp_south[n - 2][m - 1] + dp_east[n - 1][m - 2];\n\n    return abs(northeast_sum - southwest_sum);\n}\n\nint main() {\n    int n, m;\n    int grid[MAX][MAX];\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int result = max_abs_diff(grid, n, m);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:44:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_territory_score_difference(grid):\n    rows, cols = len(grid), len(grid[0])\n    \n    # Dynamic programming to compute cumulative scores\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            dp[i][j] = grid[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n    \n    # Function to calculate territory score\n    def territory_score(r1, c1, r2, c2):\n        return dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1]\n    \n    max_diff = float('-inf')\n    \n    # Try all possible paths and territories\n    for r in range(rows):\n        for c in range(cols):\n            northeast_score = territory_score(0, c+1, r+1, cols)\n            southwest_score = territory_score(r+1, 0, rows, c+1)\n            max_diff = max(max_diff, abs(northeast_score - southwest_score))\n    \n    return max_diff",
    "timestamp": "2025-08-13 00:44:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_absolute_difference(grid):\n    m = len(grid)\n    n = len(grid[0]) if m > 0 else 0\n    \n    # Create a DP table where dp[i][j] represents the maximum difference achievable\n    # when the piece is at (i, j) and it's the current player's turn.\n    dp = [[0] * n for _ in range(m)]\n    \n    # Base case: at the southeast corner, the difference is 0\n    dp[m-1][n-1] = 0\n    \n    # Fill the last row (can only move east, but since it's the end, no moves left)\n    for j in range(n-2, -1, -1):\n        dp[m-1][j] = grid[m-1][j] - dp[m-1][j+1]\n    \n    # Fill the last column (can only move south)\n    for i in range(m-2, -1, -1):\n        dp[i][n-1] = grid[i][n-1] - dp[i+1][n-1]\n    \n    # Fill the rest of the table\n    for i in range(m-2, -1, -1):\n        for j in range(n-2, -1, -1):\n            dp[i][j] = max(grid[i][j] - dp[i+1][j], grid[i][j] - dp[i][j+1])\n    \n    return abs(dp[0][0])\n\n# Example usage:\n# grid = [\n#     [1, 2, 3],\n#     [4, 5, 6],\n#     [7, 8, 9]\n# ]\n# print(max_absolute_difference(grid))",
    "timestamp": "2025-08-13 00:44:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint calculateMaxDifference(vector<vector<int>>& scores, int n, int m) {\n    vector<vector<pair<int, int>>> dp(n, vector<pair<int, int>>(m, {0, 0}));\n\n    // Initialize the starting point\n    dp[0][0].first = scores[0][0]; // First player's score\n    dp[0][0].second = 0;           // Second player's score\n\n    // Fill the dp table\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (i > 0) {\n                int newScore1 = dp[i-1][j].first + scores[i][j];\n                int newScore2 = dp[i-1][j].second;\n                dp[i][j] = max(dp[i][j], {newScore1, newScore2});\n            }\n            if (j > 0) {\n                int newScore1 = dp[i][j-1].first + scores[i][j];\n                int newScore2 = dp[i][j-1].second;\n                dp[i][j] = max(dp[i][j], {newScore1, newScore2});\n            }\n        }\n    }\n\n    int totalScore = 0;\n    for (const auto& row : scores)\n        for (int score : row)\n            totalScore += score;\n    \n    int firstPlayerScore = dp[n-1][m-1].first;\n    int secondPlayerScore = totalScore - firstPlayerScore;\n    return abs(firstPlayerScore - secondPlayerScore);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> scores(n, vector<int>(m));\n    \n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            cin >> scores[i][j];\n\n    cout << calculateMaxDifference(scores, n, m) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:55:37"
  }
]