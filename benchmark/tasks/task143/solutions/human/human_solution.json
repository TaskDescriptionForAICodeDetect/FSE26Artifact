[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\twhile(1){\n\t\tstatic int h,w,n;\n\t\tstatic int a[1005][1005] = {};\n\t\t\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\trep1(i,h){\n\t\t\trep1(j,w){\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic int dp[1005][1005] = {};\n\t\tdp[1][1] = n-1;\n\t\t\n\t\tfor(int i = 2 ; i <= w+h ; i ++){\n\t\t\trep1(j,h){\n\t\t\t\tif(i-j < 1)break;\n\t\t\t\tif(i-j > w)continue;\n\t\t\t\tdp[j+1][i-j] += dp[j][i-j]/2;\n\t\t\t\tdp[j][i-j+1] += dp[j][i-j]/2;\n\t\t\t\tif(dp[j][i-j]&1){\n\t\t\t\t\tdp[j+dir_4[a[j][i-j]][0]][i-j+dir_4[a[j][i-j]][1]] ++;\n\t\t\t\t\ta[j][i-j] ^= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x = 1,y = 1;\n\t\twhile(x <= h && y <= w){\n\t\t\tif(a[x][y]){\n\t\t\t\ty ++;\n\t\t\t}\n\t\t\telse x ++;\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\",x,y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000005\n#define MAX 5001\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n \nint a[1002][1002];\nint dp[1002][1002];\nint main(){\n    int h, w, n;\n    while(1){\n    \tscanf(\"%d%d%d\", &h, &w, &n);\n    \tif(!h)break;\n    \tfill((int*)a, (int*)(a+1002), 0);\n    \tfill((int*)dp, (int*)(dp+1002), 0);\n    \tfor(int i = 1;i <= h;i++)\n    \tfor(int j = 1;j <= w;j++)scanf(\"%d\", &a[i][j]);\n    \tn--;dp[1][1] = n;\n    \tfor(int i = 1;i <= h;i++){\n       \t\tfor(int j = 1;j <= w;j++){\n            \tdp[i][j] += dp[i][j-1]/2;\n            \tif(a[i][j-1] == 1)dp[i][j] += dp[i][j-1]%2;\n            \tdp[i][j] += dp[i-1][j]/2;\n            \tif(a[i-1][j] == 0)dp[i][j] += dp[i-1][j]%2;\n        \t}\n    \t}\n     \t\n    \tint y = 1, x = 1, t, f;\n    \twhile(y <= h && x <= w){\n        \tf = a[y][x];\n        \tif(dp[y][x]%2)f = !f;\n        \tif(f == 0)y++;\n        \telse x++;\n   \t\t}\n    \tprintf(\"%d %d\\n\", y, x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint a[1000][1000], dp[1000][1000], b[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%d\", &a[i][j]); b[i][j] = a[i][j];\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] / 2;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) / 2;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) / 2;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] / 2;\n\t\t\t}\n\t\t\tif (dp[i][j] & 1)b[i][j] = !b[i][j];\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (b[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", x + 1, y + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n;\nvector<vector<int>> f;\n\nbool input(){\n  int x,y;\n  cin>>x>>y;\n  cin>>n;\n  if(x==y&&y==n&&n==0)return false;\n  f.resize(x);\n  for(int i=0;i<f.size();i++){\n    f[i].resize(y);\n  }\n  for(int i=0;i<f.size();i++){\n    for(int j=0;j<f[i].size();j++){\n      cin>>f[i][j];\n    }\n  }\n  return true;\n}\n\nbool inside(vector<vector<int>> c,int x,int y){\n  if(x<0)return false;\n  if(y<0)return false;\n  if(c.size()<=x)return false;\n  if(c[x].size()<=y)return false;\n  return true;\n}\n\npair<int,int> solve(){\n  vector<vector<int>> change;\n  change.resize(f.size());\n  for(int i=0;i<change.size();i++){\n    change[i].resize(f[i].size());\n  }\n  change[0][0] = n-1;\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(inside(change,i+1,j))change[i+1][j] = change[i][j]/2;\n      if(inside(change,i,j+1))change[i][j+1] = change[i][j]/2;\n      if(change[i][j]%2){\n        if(f[i][j]==0){\n          if(inside(change,i+1,j))change[i+1][j]++;\n        }else{\n          if(inside(change,i,j+1))change[i][j+1]++;\n        }\n      }\n    }\n  }\n  /*\n  for(auto i:change){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(change[i][j]%2){\n        f[i][j] = !f[i][j];\n      }\n    }\n  }\n  /*\n  for(auto i:f){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  \n  pair<int,int> res;\n  while(res.first<change.size()&&res.second<change[0].size()){\n    if(!f[res.first][res.second]){\n      res.first++;\n    }else{\n      res.second++;\n    }\n  }\n  res.first++;\n  res.second++;\n  return res;\n}\n\n\nint main(){\n  while(input()){\n    /*\n    for(auto i:f){\n      for(auto j:i){\n        cout<<j<<\" \";\n      }cout<<endl;\n    }cout<<endl;\n    */\n    auto ans = solve();\n    cout<<ans.first<<\" \"<<ans.second<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint f[1005][1005];\nint dp[1005][1005];\nint h,w,n;\n\nint main()\n{\nwhile(1)\n{\n\tscanf(\"%d %d %d\",&h,&w,&n); if(!n) return 0;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&f[i][j]);\n\t\t}\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tdp[1][1]=n-1;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tdp[i][j]+=(dp[i-1][j]+(!f[i-1][j]?1:-1))/2;\n\t\t\tdp[i][j]+=(dp[i][j-1]+(f[i][j-1]?1:-1))/2;\n\t\t}\n\t}\n\tint nx=1,ny=1;\n\twhile(nx<=h && ny<=w)\n\t{\n\t\tbool x=f[nx][ny];\n\t\tbool y=(dp[nx][ny]%2);\n\t\tif((x^y)) ny++;\n\t\telse nx++;\n\t} \n\tprintf(\"%d %d\\n\",nx,ny);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nint h, w, n;\nvector<vector<int> > board;\nvector<vector<int> > dp;\n\nint main(int argc, char const* argv[])\n{\n  while(true){\n    cin >> h >> w >> n;\n    if(h == 0)break;\n    board.clear();\n    board.resize(h);\n    dp.clear();\n    dp.resize(h + 1);\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        int a;\n        cin >> a;\n        board[i].pb(a);\n        dp[i].pb(0);\n      }\n      dp[i].pb(0);\n    }\n    for(int i = 0; i <= w; i++){\n      dp[h].pb(0);\n    }\n    dp[0][0] = n - 1;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(board[i][j] == 0){\n          dp[i + 1][j] += (dp[i][j] + 1) / 2;\n          dp[i][j + 1] += (dp[i][j]) / 2;\n        }else{\n          dp[i + 1][j] += (dp[i][j]) / 2;\n          dp[i][j + 1] += (dp[i][j] + 1) / 2;\n        }\n      }\n    }\n    int currx = 0;\n    int curry = 0;\n    while(true){\n      if(currx == h || curry == w)break;\n      if(board[currx][curry] == 0){\n        if(dp[currx][curry] % 2 == 0){\n          currx++;\n        }else{\n          curry++;\n        }\n      }else{\n        if(dp[currx][curry] % 2 == 0){\n          curry++;\n        }else{\n          currx++;\n        }\n      }\n    }\n    cout << currx + 1 << \" \" << curry + 1 << endl;\n  }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n;\nvector<vector<int>> f;\n\nbool input(){\n  int x,y;\n  cin>>x>>y;\n  cin>>n;\n  f.clear();\n  if(x==y&&y==n&&n==0)return false;\n  f.resize(x);\n  for(int i=0;i<f.size();i++){\n    f[i].resize(y);\n  }\n  for(int i=0;i<f.size();i++){\n    for(int j=0;j<f[i].size();j++){\n      cin>>f[i][j];\n    }\n  }\n  return true;\n}\n\nbool inside(vector<vector<int>> &c,int x,int y){\n  if(x<0)return false;\n  if(y<0)return false;\n  if(c.size()<=x)return false;\n  if(c[x].size()<=y)return false;\n  return true;\n}\n\npair<int,int> solve(){\n  vector<vector<int>> change;\n  change.resize(f.size());\n  for(int i=0;i<change.size();i++){\n    change[i].resize(f[i].size());\n  }\n  change[0][0] = n;\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(inside(change,i+1,j))change[i+1][j] = change[i][j]/2;\n      if(inside(change,i,j+1))change[i][j+1] = change[i][j]/2;\n      if(change[i][j]%2){\n        if(f[i][j]==0){\n          if(inside(change,i+1,j))change[i+1][j]++;\n        }else{\n          if(inside(change,i,j+1))change[i][j+1]++;\n        }\n      }\n    }\n  }\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(change[i][j]%2){\n        f[i][j] = !f[i][j];\n      }\n    }\n  }\n  pair<int,int> res(0,0);\n  while(res.first<change.size()&&res.second<change[0].size()){\n    if(f[res.first][res.second]){\n      res.first++;\n    }else{\n      res.second++;\n    }\n  }\n  res.first++;\n  res.second++;\n  return res;\n}\n\n\nint main(){\n  while(input()){\n    auto ans = solve();\n    cout<<ans.first<<\" \"<<ans.second<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nint nowmasu[1100][1100];\nint nokori[1100][1100];\n\nint main(){\n\twhile(1){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tif(a==0)break;\n\t\t\n\t\trep(i,1100)rep(j,1100)nowmasu[i][j]=nokori[i][j]=0;\n\t\t\n\t\trep(i,a){\n\t\t\trep(j,b){\n\t\t\t\tscanf(\"%d\",&nowmasu[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tnokori[0][0]=c-1;\n\t\t\n\t\trep(i,a){\n\t\t\trep(j,b){\n\t\t\t\tint e,f;\n\t\t\t\te = nokori[i][j]/2 + nokori[i][j]%2;\n\t\t\t\tf = nokori[i][j]/2;\n\t\t\t\t\n\t\t\t\tif(nowmasu[i][j]==1){\n\t\t\t\t\tnokori[i][j+1] += e;\n\t\t\t\t\tnokori[i+1][j] += f;\n\t\t\t\t}else{\n\t\t\t\t\tnokori[i+1][j] += e;\n\t\t\t\t\tnokori[i][j+1] += f;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnowmasu[i][j] = (nowmasu[i][j]+nokori[i][j])%2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint py=0,px=0;\n\t\twhile(1){\n\t\t\tif(py>=a || px>=b)break;\n\t\t\tif(nowmasu[py][px] == 1)px++;\n\t\t\telse py++;\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\",py+1,px+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\n//constexpr int MAX_N = 1005;\nconstexpr int MAX_H = 1005;\nconstexpr int dx[] = {0, 1};\nconstexpr int dy[] = {1, 0};\n\nint h, w, n, fld[MAX_H][MAX_H], dp[MAX_H][MAX_H];\n\nbool Solve() {\n    cin >> h >> w >> n;\n    if (!h) return false;\n\n    memset(fld, -1, sizeof(fld));\n    memset(dp, 0, sizeof(dp));\n\n    for (int y = 1; y <= h; ++y) {\n        for (int x = 1; x <= w; ++x) {\n            cin >> fld[x][y];\n        }\n    }\n\n    dp[1][1] = n - 1;\n    for (int y = 1; y <= h; ++y) {\n        for (int x = (y == 1 ? 2 : 1); x <= w; ++x) {\n            for (int i = 0; i < 2; ++i) {\n                int tx = x - dx[i], ty = y - dy[i];\n                dp[x][y] += dp[tx][ty] / 2 + (dp[tx][ty] % 2 && fld[tx][ty] == i ? 1 : 0);\n            }\n        }\n    }\n\n    for (int y = 1; y <= h; ++y) {\n        for (int x = 1; x <= w; ++x) {\n            fld[x][y] += dp[x][y];\n            fld[x][y] %= 2;\n        }\n    }\n\n    {\n        int x = 1, y = 1;\n\n        while (fld[x][y] != -1) {\n            int nx = x + dx[fld[x][y]];\n            y += dy[fld[x][y]];\n            x = nx;\n        }\n\n        cout << y << \" \" << x << endl;\n    }\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w, n;\nint dp[1005][1005];\n\nint main() {\n\twhile(cin >> h >> w >> n) {\n\t\tif(h == 0 && w == 0 && n == 0) break;\n\n\t\tvector< vector<int> > v(h, vector<int>(w));\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n;\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tint s = dp[i][j] / 2;\n\t\t\t\tint t = dp[i][j] - s;\n\n\t\t\t\tif(v[i][j] % 2 == 1) {\n\t\t\t\t\tdp[i][j+1] += t;\n\t\t\t\t\tdp[i+1][j] += s;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i+1][j] += t;\n\t\t\t\t\tdp[i][j+1] += s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint y = 0, x = 0;\n\t\twhile(y != h && x != w) {\n\t\t\tif(v[y][x] == 1) {\n\t\t\t\tif(dp[y][x] % 2 == 1) {\n\t\t\t\t\tx++;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(dp[y][x] % 2 == 1) {\n\t\t\t\t\ty++;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << y + 1 << \" \" << x + 1 << endl;\n\t\t// rep(i, h) {\n\t\t// \trep(j, w) {\n\t\t// \t\tcout << dp[i][j] << \" \";\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nint field[1024][1024];\nint dp[1024][1024];\nint h,w,n;\n\nint main(){\n  \n  while(scanf(\"%d%d%d\",&h,&w,&n),h|w|n){\n    memset(dp,0,sizeof(dp));\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i+1][j+1]);\n      }\n    }\n    dp[1][1] = n-1;\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tint k1,k2;\n\tif( dp[i-1][j]%2 && field[i-1][j]==0 ){\n\t  k1 = 1;\n\t}else{\n\t  k1 = 0;\n\t}\n\tif( dp[i][j-1]%2 && field[i][j-1]==1 ){\n\t  k2 = 1;\n\t}else{\n\t  k2 = 0;\n\t}\n\n\tdp[i][j] += (dp[i-1][j]+k1)/2  + (dp[i][j-1]+k2)/2;\n      }\n    }\n#if DEB\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tprintf(\"%2d \",dp[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    \n    // Nツ嘉アツ姪堋づ個湘ウツ妥板づーツ青カツ青ャ\n    /*\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tfield[i][j] = (field[i][j]+dp[i][j])%2;\n      }\n    }\n    */\n#if DEB\n    puts(\"field\");\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tprintf(\"%2d \",field[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    \n    int x=1;\n    int y=1;\n    for(;;){\n      if( x>w || y>h )break;\n      if( (field[y][x]+dp[y][x])%2==1 ){\n\tx++;\n      }else{\n\ty++;\n      }\n    }\n\n    printf(\"%d %d\\n\",y,x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint H,W,N;\nint X[1000][1000];\nint DP[1000][1000];\nint main()\n{\n\twhile(true){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tDP[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d\",&H,&W,&N);\n\t\tif(H==0&&W==0&&N==0)break;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tscanf(\"%d\",&X[i][j]);\n\t\t\t}\n\t\t}\n\t\tDP[0][0]=N-1;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(i==0&&j==0)continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(DP[i][j-1]&1){\n\t\t\t\t\t\tif(X[i][j-1]==1){\n\t\t\t\t\t\t\tDP[i][j]=(DP[i][j-1]>>1)+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse DP[i][j]=DP[i][j-1]>>1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tDP[i][j]=DP[i][j-1]>>1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(j==0){\n\t\t\t\t\tif(DP[i-1][j]&1){\n\t\t\t\t\t\tif(X[i-1][j]==0){\n\t\t\t\t\t\t\tDP[i][j]=(DP[i-1][j]>>1)+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse DP[i][j]=DP[i-1][j]>>1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tDP[i][j]=DP[i-1][j]>>1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(DP[i-1][j]&1){\n\t\t\t\t\t\tif(X[i-1][j]==0){\n\t\t\t\t\t\t\tDP[i][j]+=(DP[i-1][j]>>1)+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse DP[i][j]+=DP[i-1][j]>>1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tDP[i][j]+=DP[i-1][j]>>1;\n\t\t\t\t\t}\n\t\t\t\t\tif(DP[i][j-1]&1){\n\t\t\t\t\t\tif(X[i][j-1]==1){\n\t\t\t\t\t\t\tDP[i][j]+=(DP[i][j-1]>>1)+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse DP[i][j]+=DP[i][j-1]>>1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tDP[i][j]+=DP[i][j-1]>>1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tX[i][j]=(X[i][j]+DP[i][j])&1;\n\t\t\t}\n\t\t}\n\t\tint XX=0;int YY=0;\n\t\twhile(XX<W&&YY<H){\n\t\t\tif(X[YY][XX])XX++;\n\t\t\telse YY++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",YY+1,XX+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nbool mp[1002][1002];\nint count[1002][1002];\nint main(){\n    int h,w,n;\n    while(cin>>h>>w>>n,h){\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                cin>>mp[i][j];\n            }\n        }\n        memset(count,0,sizeof(count));\n        count[0][0]=n-1;\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                mp[i][j]=mp[i][j]^(count[i][j]%2);\n                count[i][j+1] += (count[i][j]+!mp[i][j])/2;\n                count[i+1][j] += (count[i][j]+mp[i][j])/2;\n            }\n        }\n        int x=0,y=0;\n        while(x<w&&y<h){\n            if(mp[y][x]) ++x;\n            else ++y;\n        }\n        cout<<y+1<<\" \"<<x+1<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint H,W,N;\nint dp[1024][1024];\nint g[1024][1024];\n\nint main(){\n  while(scanf(\"%d%d%d\",&H,&W,&N) && H||W||N){\n    memset(dp, 0, sizeof dp);\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) scanf(\"%d\", &g[i][j]);\n\n    dp[0][0] = N-1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tdp[i][j+1] += (dp[i][j]+(g[i][j]==1))/2;\n\tdp[i+1][j] += (dp[i][j]+(g[i][j]!=1))/2;\n      }\n    }\n    int y = 0, x = 0;\n    while(y < H && x < W){\n      if(g[y][x]^(dp[y][x]%2)) x++;\n      else y++;\n    }\n    printf(\"%d %d\\n\", y+1, x+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int h, w, n;\n        cin >> h >> w >> n;\n        if(h == 0)\n            return 0;\n\n        vector<vector<bool> > east(h, vector<bool>(w));\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                int a;\n                cin >> a;\n                east[i][j] = (a == 1);\n            }\n        }\n\n        vector<vector<int> > num(h+1, vector<int>(w+1, 0));\n        num[0][0] = n - 1;\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                num[i+1][j] += num[i][j] / 2;\n                num[i][j+1] += num[i][j] / 2;\n                if(num[i][j] % 2 == 1){\n                    if(east[i][j])\n                        ++ num[i][j+1];\n                    else\n                        ++ num[i+1][j];\n                    east[i][j] = !east[i][j];\n                }\n            }\n        }\n\n        int y = 0;\n        int x = 0;\n        while(y < h && x < w){\n            if(east[y][x])\n                ++ x;\n            else\n                ++ y;\n        }\n        cout << (y+1) << ' ' << (x+1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int MAX_N=10000000, INF=1<<30;\nint h, w, n;\nint ma[1001][1001];\nint dp[1001][1001];\nvoid solve(int i, int j){\n  if(i>h||j>w){\n    cout<<i<<' '<<j<<endl;\n    return;\n  }\n    if(ma[i][j])\n      solve(i,j+1);\n    else\n      solve(i+1,j);\n}\nint main(){\n  while(cin>>h>>w>>n&&h){\n    for(int i=0;i<1001;i++){\n      fill(ma[i],ma[i]+1001,0);\n      fill(dp[i],dp[i]+1001,0);\n    }\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcin>>ma[i][j];\n      }\n    }\n    ma[1][0]=INF;\n    dp[1][1]=n-1;\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tif(i==1&&j==1) continue;\n\tdp[i][j]+=dp[i][j-1]/2+dp[i-1][j]/2;\n\tif(ma[i][j-1]&&dp[i][j-1]%2==1)\n\t  dp[i][j]++;\n\tif(ma[i-1][j]==0&&dp[i-1][j]%2==1)\n\t  dp[i][j]++;\n      }\n    }\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tif(dp[i][j]%2==1){\n\t  if(ma[i][j]==1)\n\t    ma[i][j]=0;\n\t  else\n\t    ma[i][j]=1;\n\t}\n      }\n    }\n    solve(1,1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\n#ifndef INPUTS_DIR\n#define INPUTS_DIR \"./\"\n#endif\n\n\n\nint dp[1000][1000];\nint d[1000][1000];\n\nvoid main_(istream &cin) {\n    int H, W, N;\n    while (cin >> H >> W >> N && H) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> d[i][j];\n            }\n        }\n        dp[0][0] = N - 1;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (i + 1 < H)\n                    dp[i + 1][j] += (dp[i][j] + (d[i][j] == 0)) / 2;\n                if (j + 1 < W)\n                    dp[i][j + 1] += (dp[i][j] + (d[i][j] == 1)) / 2;\n\n            }\n        }\n        int w = 0, h = 0;\n        while (w < W && h < H) {\n            d[h][w] ^= dp[h][w] % 2;\n            if (d[h][w]) w++;\n            else h++;\n        }\n        cout << h + 1 << \" \" << w + 1 << endl;\n    }\n}\n\nint main() {\n#ifdef INTELLIJ\n    ifstream ifs(string(INPUTS_DIR) + \"in_1.txt\");\n    if (ifs.is_open()) {\n        main_(ifs);\n        ifs.close();\n    } else {\n        cerr << \"Error: no input.\" << endl;\n    }\n#else\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    main_(cin);\n#endif\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[1002][1002];\nlong long int dp[1002][1002];\nlong long int x,y;\nint h,w;\nlong int n;\n\nvoid root(int xx,int yy){\n\tx=xx,y=yy;\n\tdp[xx][yy]+=1;\n\tif(xx<=w && yy<=h){\n\t\tif(map[xx][yy]==1){\n\t\t\tmap[xx][yy]=0;\n\t\t\troot(xx+1,yy);\n\t\t}else{\n\t\t\tmap[xx][yy]=1;\n\t\t\troot(xx,yy+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint a,b,c;\n\twhile(1){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&map[b][a]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tif(dp[b][a]%2==0)dp[b+1][a]=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)dp[b+1][a]=(dp[b][a]+1)/2;\n\t\t\t\t\tif(map[b][a]==0)dp[b+1][a]=(dp[b][a]-1)/2;\n\t\t\t\t}\n\t\t\t\tif(dp[b][a]%2==0)dp[b][a+1]=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)dp[b][a+1]=(dp[b][a]+1)/2;\n\t\t\t\t\tif(map[b][a]==0)dp[b][a+1]=(dp[b][a]-1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tmap[b][a]=(map[b][a]+dp[b][a])%2;\n\t\t\t}\n\t\t}\n\t\troot(1,1);\n\t\tcout << y << \" \" << x << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint h, w, n;\nint a[1010][1010];\nint dp[1010][1010][2];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d %d\", &h, &w, &n);\n\t\tif(h == 0) break;\n\t\tfor(int i=1; i<=h; ++i)\n\t\t\tfor(int j=1; j<=w; ++j)\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[1][1][1-a[1][1]] = (n-1) / 2;\n\t\tdp[1][1][a[1][1]] = n-1 - dp[1][1][1-a[1][1]];\n\t\tfor(int i=2; i<=h; ++i){\n\t\t\tdp[i][1][1-a[i][1]] = dp[i-1][1][0] / 2;\n\t\t\tdp[i][1][a[i][1]] = dp[i-1][1][0] - dp[i][1][1-a[i][1]];\n\t\t}\n\t\tfor(int i=2; i<=w; ++i){\n\t\t\tdp[1][i][1-a[1][i]] = dp[1][i-1][1] / 2;\n\t\t\tdp[1][i][a[1][i]] = dp[1][i-1][1] - dp[1][i][1-a[1][i]];\n\t\t}\n\t\tfor(int i=2; i<=h; ++i){\n\t\t\tfor(int j=2; j<=w; ++j){\n\t\t\t\tint s = dp[i-1][j][0] + dp[i][j-1][1];\n\t\t\t\tdp[i][j][1-a[i][j]] = s / 2;\n\t\t\t\tdp[i][j][a[i][j]] = s - dp[i][j][1-a[i][j]];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=h; ++i){\n\t\t\tfor(int j=1; j<=w; ++j){\n\t\t\t\tint t = (dp[i][j][0] + dp[i][j][1]) % 2;\n\t\t\t\ta[i][j] = (a[i][j] + t) % 2;\n\t\t\t}\n\t\t}\n\t\tint x = 1, y = 1;\n\t\twhile(x <= w && y <= h){\n\t\t\tif(a[y][x] == 0) y++;\n\t\t\telse x++;\n\t\t}\n/*\t\tfor(int i=1; i<=h; ++i){\n\t\t\tfor(int j=1; j<=w; ++j){\n\t\t\t\tprintf(\"%d\\t\", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n*/\t\tprintf(\"%d %d\\n\", y, x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint root[1000][1000];\nbool right[1000][1000];\n\nint main()\n{\n\tint h, w, n, tmp, ax, ay;\n\n\twhile(true) {\n\t\tscanf(\"%d%d%d\", &h, &w, &n);\n\t\tif(h == 0 && w == 0 && n == 0) break;\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\tscanf(\"%d\", &tmp);\n\t\t\t\tright[x][y] = tmp;\n\t\t\t\troot[x][y] = 0;\n\t\t\t\tif(x == 0 && y == 0)\n\t\t\t\t\troot[x][y] = n - 1;\n\t\t\t\tif(x != 0) {\n\t\t\t\t\tif(right[x - 1][y])\n\t\t\t\t\t\troot[x][y] += (root[x - 1][y] + 1) / 2;\n\t\t\t\t\telse\n\t\t\t\t\t\troot[x][y] += (root[x - 1][y]) / 2;\n\t\t\t\t}\n\t\t\t\tif(y != 0) {\n\t\t\t\t\tif(right[x][y - 1])\n\t\t\t\t\t\troot[x][y] += (root[x][y - 1]) / 2;\n\t\t\t\t\telse\n\t\t\t\t\t\troot[x][y] += (root[x][y - 1] + 1) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tax = 0;\n\t\tay = 0;\n\t\twhile(ax < w && ay < h) {\n\t\t\tif((right[ax][ay] + root[ax][ay]) % 2 == 1)\n\t\t\t\t++ax;\n\t\t\telse\n\t\t\t\t++ay;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", ay + 1, ax + 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tif(y == 0 && x == 0) continue;\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y-1 >= 0) dp[y][x] += ((dp[y-1][x] + (direction[y-1][x] == 0 ? 1:0)) / 2);\n\tif(x-1 >= 0) dp[y][x] += ((dp[y][x-1] + (direction[y][x-1] == 1 ? 1:0)) / 2);\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    for(int round = 0; round <= 1000; round++){\n      if((dp[y][x] + direction[y][x]) % 2 == 0) y++;\n      else if((dp[y][x] + direction[y][x]) % 2 == 1) x++;\n      if(y == H || x == W) break;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\nint a[1005][1005];\nint dp[1005][1005]; // dp[i][j] := N-1???????????§???(i, j)??????????????£??????\n\nint main()\n{\n\tomajinai;\n\n\tint H, W, N;\n\t\n\twhile (cin >> H >> W >> N, H) {\n\t\tmemset(dp, 0, sizeof dp);\n\n\t\trep(i, H) rep(j, W) cin >> a[i][j];\n\n\t\tdp[0][0] = N - 1;\n\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (i == 0 && j == 0) continue;\n\n\t\t\tif (i - 1 >= 0) {\n\t\t\t\tbool f = (dp[i - 1][j] % 2 == 0 ? a[i - 1][j] : !a[i - 1][j]) == 0;\n\t\t\t\tdp[i][j] += (f ? (dp[i - 1][j] / 2) : (dp[i - 1][j] + 1) / 2);\n\t\t\t}\n\n\t\t\tif (j - 1 >= 0) {\n\t\t\t\tbool f = (dp[i][j - 1] % 2 == 0 ? a[i][j - 1] : !a[i][j - 1]) == 1;\n\t\t\t\tdp[i][j] += (f ? dp[i][j - 1] / 2 : (dp[i][j - 1] + 1) / 2);\n\t\t\t}\n\t\t}\n\n\t\trep(i, H) rep(j, W) {\n\t\t\ta[i][j] ^= dp[i][j] % 2;\n\t\t}\n\n\t\tint y = 0, x = 0;\n\n\t\twhile (y < H && x < W) {\n\t\t\t(a[y][x] ? x : y)++;\n\t\t}\n\n\t\tcout << y + 1 << ' ' << x + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000005\n#define MAX 5001\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n \nint a[1002][1002];\nint dp[1002][1002];\nint main(){\n    int h, w, n;\n    while(1){\n    \t//scanf(\"%d%d%d\", &h, &w, &n);\n    \tcin >> h >> w >> n;\n    \tif(!h)break;\n    \tfill((int*)a, (int*)(a+1002), 0);\n    \tfill((int*)dp, (int*)(dp+1002), 0);\n    \tfor(int i = 1;i <= h;i++)\n    \tfor(int j = 1;j <= w;j++)cin >> a[i][j];\n    \tn--;dp[1][1] = n;\n    \tfor(int i = 1;i <= h;i++){\n       \t\tfor(int j = 1;j <= w;j++){\n            \tdp[i][j] += dp[i][j-1]/2;\n            \tif(a[i][j-1] == 1)dp[i][j] += dp[i][j-1]%2;\n            \tdp[i][j] += dp[i-1][j]/2;\n            \tif(a[i-1][j] == 0)dp[i][j] += dp[i-1][j]%2;\n        \t}\n    \t}\n     \t\n    \tint y = 1, x = 1, t, f;\n    \twhile(y <= h && x <= w){\n        \tf = a[y][x];\n        \tif(dp[y][x]%2)f = !f;\n        \tif(f == 0)y++;\n        \telse x++;\n   \t\t}\n    \t//printf(\"%d %d\\n\", y, x);\n    \tcout << y << \" \" << x << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nint** getarray(int w,int h){\n\tint** a = new int*[w];\n\tfor(int i = 0;i < w;i++){\n\t\ta[i] = new int[h];\n\t}\n\treturn a;\n}\n\nint remarray(int** a,int w,int h){\n\tfor(int i=0;i<w;i++){\n\t\tdelete[] a[i];\n\t}\n\tdelete[] a;\n}\n\nint main(){\n\tint h,w,n;\n\tint self;\n\tint** d;\n\tint** m;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t\tif(!h && !w && !n){break;}\n\t\td = getarray(w + 1,h + 1);\n\t\tm = getarray(w + 1,h + 1);\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tscanf(\"%d\",&self);\n\t\t\t\tm[j][i] = self;\n\t\t\t}\n\t\t}\n\t\t\n\t\td[0][0] = n - 1;\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tif(i == 0 && j == 0){continue;}\n\t\t\t\td[i][j] = 0;\n\t\t\t\tif(i != 0 && d[i-1][j] > 0){\n\t\t\t\t\td[i][j] += (d[i-1][j]) / 2;\n\t\t\t\t\tif(m[i-1][j] == 1){\n\t\t\t\t\t\td[i][j] += (d[i-1][j]) % 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j != 0 && d[i][j - 1] > 0){\n\t\t\t\t\td[i][j] += (d[i][j-1]) / 2;\n\t\t\t\t\tif(m[i][j-1] == 0){\n\t\t\t\t\t\td[i][j] += (d[i][j-1]) % 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tm[i][j] = (m[i][j] + d[i][j]) % 2;\n\t\t\t\t//printf(\"%d \",m[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tint x,y;\n\t\tx = y = 0;\n\t\twhile(x < w && y < h){\n\t\t\tif(m[x][y] == 1){\n\t\t\t\t//printf(\"ツ督圭n\");\n\t\t\t\tx += 1;\n\t\t\t}else{\n\t\t\t\t//printf(\"ツ禿ャ\\n\");\n\t\t\t\ty += 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",y + 1,x + 1);\n\t\tremarray(m,w+1,h+1);\n\t\tremarray(d,w+1,h+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\npair<int, int> solve(int H, int W, int N, vector<vector<int>> f) {\n    vector<pair<int, int>> memo;\n    map<vector<vector<int>>, int> count;\n    int num = 0;\n    int start = -1, end = -1;\n    while (true) {\n        int y = 0, x = 0;\n        vector<vector<int>> c = f;\n        if (count[c] != 0) {\n            start = count[c];\n            end = num;\n            break;\n        }\n        count[c] = num;\n\n        while (true) {\n\n            int p = f[y][x];\n            if (p == 0) {\n                f[y][x] = 1;\n                y += 1;\n            }\n            else {\n                f[y][x] = 0;\n                x += 1;\n            }\n\n            if (y == H or x == W) {\n                break;\n            }\n        }\n        memo.emplace_back(make_pair(y, x));\n        num++;\n    }\n\n    if (N < memo.size()) {\n        return memo[N - 1];\n    }\n\n    int rest = N - num;\n    int r = end - start;\n    rest %= r;\n    return memo[start + rest - 1];\n}\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int H, W, N;\n    cin >> H >> W >> N;\n    vector<vector<int>> f(H, vector<int>(W));\n    FOR(y, 0, H) {\n        FOR(x, 0, W) {\n            cin >> f[y][x];\n        }\n    }\n\n    auto ans1 = solve(H, W, N, f);\n    cout << ans1.first + 1<< \" \" << ans1.second + 1 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nint dp[1010][1010], map[1010][1010];\n\nstruct P{\n    int x, y;\n};\n\nint H, W, N;\n\nP walk(int x, int y){\n    if(x > W || y > H){\n        return {x, y};\n    }\n\n    if(map[y][x] == 1){// east\n        return walk(x+1, y);\n    }\n    return walk(x, y+1);\n}\n\nint main(){\n    std::cin >> H >> W >> N;\n\n    FOR(i, 1, H+1){\n        FOR(j, 1, W+1){\n            std::cin >> map[i][j];\n        }\n    }\n\n    dp[1][1] = N-1;\n\n    FOR(i, 1, H+1){\n        FOR(j, 1, W+1){\n            if(dp[i][j] % 2 == 0){\n                dp[i+1][j] += dp[i][j] / 2;\n                dp[i][j+1] += dp[i][j] / 2;\n            }else{\n                if(map[i][j] == 1){// EAST\n                    dp[i][j+1] += (dp[i][j] + 1) / 2;\n                    dp[i+1][j] += (dp[i][j] - 1) / 2;\n                }else{// NORTH\n                    dp[i+1][j] += (dp[i][j] + 1) / 2;\n                    dp[i][j+1] += (dp[i][j] - 1) / 2;\n                }\n            }\n        }\n    }\n\n    // FOR(i, 1, 11){\n    //     FOR(j, 1, 11){\n    //         std::cout << dp[i][j] << \" \";\n    //     }\n    //     std::cout << std::endl;\n    // }\n\n    FOR(i, 1, H+1){\n        FOR(j, 1, W+1){\n            if(dp[i][j] % 2 == 1){\n                map[i][j] = !map[i][j];\n            }\n        }\n    }\n\n\n\n    auto p = walk(1, 1);\n    std::cout << p.y << \" \" << p.x << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint H,W,N;\n\nint field[1003][1003];\n\nint sum[1003][1003];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n    cin >> H >> W >> N;\n    if(H == 0) break;\n    \n    memset(sum,0,sizeof(sum));\n\n    for (int i = 0;i < H;i++){\n        for (int j = 0;j< W;j++){\n            cin >> field[i][j];\n        }\n    }\n\n    sum[0][0] = N-1;\n\n    for (int i = 0;i < H;i++){\n        for (int j = 0;j < W;j++){\n            sum[i+1][j] += sum[i][j]/2;\n            sum[i][j+1] += sum[i][j]/2;\n            if(sum[i][j]%2 != 0){\n                if(field[i][j] == 0) sum[i+1][j]++;\n                else sum[i][j+1]++;\n            }\n        }\n    }\n\n    for (int i = 0;i < H;i++){\n        for (int j = 0;j< W;j++){\n            field[i][j] = (field[i][j]+sum[i][j])%2;\n        }\n    }\n\n    int x = 0,y = 0;\n    while(!(x == W || y == H)){\n        if(field[y][x] == 0) y++;\n        else x++;\n    }\n\n    cout << ++y << \" \" << ++x << endl;}\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N 2000\n\nlong long x[MAX_N][MAX_N];\nlong long dp[MAX_N][MAX_N];\nint h, w, n, cx, cy;\nint main() {\n\twhile (true) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tcin >> h >> w >> n;\n\t\tif (h == 0 && w == 0 && n == 0) { break; }\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tscanf(\"%d\", x[i][j]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1] = n - 1;\n\t\tfor (int i = 2; i <= h + w; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tint k = i - j;\n\t\t\t\tif (j <= h && k <= w) {\n\t\t\t\t\tif (x[j][k] == 0) {\n\t\t\t\t\t\tdp[j][k + 1] += dp[j][k] / 2;\n\t\t\t\t\t\tdp[j + 1][k] += (dp[j][k] + 1) / 2;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[j][k + 1] += (dp[j][k] + 1) / 2;\n\t\t\t\t\t\tdp[j + 1][k] += dp[j][k] / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tx[i][j] += dp[i][j];\n\t\t\t\tx[i][j] %= 2;\n\t\t\t}\n\t\t}\n\t\tcx = 1; cy = 1;\n\t\twhile (cx <= w && cy <= h) {\n\t\t\tif (x[cy][cx] == 0) {\n\t\t\t\tcy++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcx++;\n\t\t\t}\n\t\t}\n\t\tcout << cy << ' ' << cx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n    int h,w,n;\n    int map[1000][1000]{0};\n    int i=0,k=0;\n    \n    cin>>h>>w>>n;\n    for(i=0;i<h;i++){\n        for(k=0;k<w;k++){\n            cin>>map[i][k];\n        }\n    }\n    \n    for(int j=0;j<n;j++){\n        i=0;\n        k=0;\n        while(1){\n            if(i>=h||k>=w)break;\n            if(map[i][k]==1){\n                map[i][k]=!map[i][k];\n                k++;\n            }\n            else{\n                map[i][k]=!map[i][k];\n                i++;\n            }\n        }\n    }\n    cout<<i+1<<\" \"<<k+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define SOUTH 0\n#define EAST  1\n\nint town_map[1000][1000];\nint table1[1000][1000];\nint table2[1000][1000];\n\nint calc_times(int table[1000][1000], int i, int j) {\n    int ret = 0;\n\n    if (i > 0) {\n        if (town_map[i-1][j] == SOUTH) {\n            ret += (table[i-1][j]+1)/2;\n        } else {\n            ret += table[i-1][j]/2;\n        }\n    }\n\n    if (j > 0) {\n        if (town_map[i][j-1] == EAST) {\n            ret += (table[i][j-1]+1)/2;\n        } else {\n            ret += table[i][j-1]/2;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    while (1) {\n        int i;\n        int h, w, n;\n        int now_x = 0;\n        int now_y = 0;\n        scanf(\"%d %d %d\", &h, &w, &n);\n        if (h == 0) return 0;\n    \n        for (i=0;i<h;i++) {\n            int j;\n            for (j=0;j<w;j++) {\n                scanf(\"%d\", &town_map[i][j]);\n                table1[i][j] = 0;\n                table2[i][j] = 0;\n            }\n        }\n    \n        table1[0][0] = n-1;\n        table2[0][0] = n;\n    \n        for (i=0;i<h;i++) {\n            int j;\n            for (j=0;j<w;j++) {\n                table1[i][j] += calc_times(table1, i, j);\n                table2[i][j] += calc_times(table2, i, j);\n            }\n        }\n    \n        for (i=0;i<h;i++) {\n            if (table1[i][w-1] != table2[i][w-1]) printf(\"%d %d\\n\", i+1, w+1);\n        }\n    \n        for (i=0;i<w;i++) {\n            if (table1[h-1][i] != table2[h-1][i]) printf(\"%d %d\\n\", h+1, i+1);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nqueue<POS> check;\nlong next[201][201],field[201][201],n;\nbool flag[201][201];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n    }\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<stack>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nint main(){\n\twhile(1){\n\t\tint dp[102][102];\n\t\tint n,m,k;\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0)break;\n\t\tint masu[102][102];\n\t\trep(i,102)rep(j,102)masu[i][j]=dp[i][j]=0;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tscanf(\"%d\",&masu[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[0][0]=k-1;\n\t\t\n\t\trep(i,m){\n\t\t\trep(j,n){\n\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmasu[i][j]+=dp[i][j];\n\t\t\t\tmasu[i][j]%=2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x=0,y=0;\n\t\twhile(1){\n\t\t\tif(masu[x][y]==0){\n\t\t\t\ty++;\n\t\t\t}else{\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(y>=n || x>=m){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tprintf(\"%d \",masu[j][i]);\n\t\t\t}puts(\"\");\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n}\n\n/*\n3 4 3\n1 0 1 1\n0 1 0 0\n1 0 1 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "// {{{\n// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\n#define MP  make_pair\n#define PB  push_back\nusing namespace std;\ntypedef long long ll;\n\nint vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n// }}}\n\nint field[1000][1000];\nint dp[1000][1000];\nint main(){\n    for(;;){\n        int H,W,N;\n        scanf(\"%d%d%d\",&H,&W,&N);\n        if(H==0&&W==0&&N==0) break;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                scanf(\"%d\",&field[i][j]);\n            }\n        }\n        dp[0][0]=N-1;\n        for(int i=1;i<H;i++){\n            if(field[i-1][0]==0) dp[i][0]=(dp[i-1][0]+1)/2;\n            else dp[i][0]=dp[i-1][0]/2;\n        }\n        for(int i=1;i<W;i++){\n            if(field[0][i-1]==1) dp[0][i]=(dp[0][i-1]+1)/2;\n            else dp[0][i]=dp[0][i-1]/2;\n        }\n        for(int i=1;i<H;i++){\n            for(int j=1;j<W;j++){\n                dp[i][j]=0;\n                if(field[i-1][j]==0) dp[i][j]+=(dp[i-1][j]+1)/2;\n                else dp[i][j]+=dp[i-1][j]/2;\n                if(field[i][j-1]==1) dp[i][j]+=(dp[i][j-1]+1)/2;\n                else dp[i][j]+=dp[i][j-1]/2;\n            }\n        }\n        int nx=0,ny=0;\n        while(nx<H&&ny<W){\n            if((dp[nx][ny]+field[nx][ny])%2==1) ny++;\n            else nx++;\n        }\n        printf(\"%d %d\\n\",nx+1,ny+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\nint dp[1001][1001];\nbool g[1000][1000];\nint main(){\n\tint H,W,N;\n\twhile(scanf(\"%d%d%d\",&H,&W,&N),H){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)scanf(\"%d\",g[i]+j);\n\t\tdp[0][0]=N-1;\n\t\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)dp[i][j+1]+=(dp[i][j]+g[i][j])/2,dp[i+1][j]+=(dp[i][j]+!g[i][j])/2;\n\t\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)if(dp[i][j]%2)g[i][j]=(g[i][j]?0:1);\n\t\tint y=0,x=0;\n\t\twhile(y<H&&x<W){\n\t\t\tif(g[y][x])x++;\n\t\t\telse y++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nint s[1000][1000],c[1001][1001];\n\nint main(){\n\twhile(true){\n\t\t\n\tmemset(s,0,sizeof(s));\n\tmemset(c,0,sizeof(c));\n\tint h=read(),w=read();\n\tc[0][0]=read()-1;\n\tif(h==0&&w==0)\n\t\tbreak;\n\tREP(i,h)\n\t\tREP(j,w)\n\t\t\ts[i][j]=read();\n\tREP(l,h+w-2)\n\t\tREP(x,w){\n\t\t\tint y=l-x;\n\t\t\tif(y<0||h<=y)\n\t\t\t\tcontinue;\n\t\t\tif(c[y][x]%2==0){\n\t\t\t\tc[y+1][x]+=c[y][x]/2;\n\t\t\t\tc[y][x+1]+=c[y][x]/2;\n\t\t\t}else{\n\t\t\t\tc[y+1][x]+=c[y][x]/2+1-s[y][x];\n\t\t\t\tc[y][x+1]+=c[y][x]/2+s[y][x];\n\t\t\t\ts[y][x]^=1;\n\t\t\t}\n\t\t}\n\tint x=0,y=0;\n\twhile(x<w&&y<h){\n\t\tif(s[y][x]==0)\n\t\t\ty++;\n\t\telse\n\t\t\tx++;\n\t}\n\tprintf(\"%d %d\\n\",y+1,x+1);\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nenum Direction{SOUTH,EAST};\n\nint main()\n{\n  int H,W,N;\n  while(cin>>H>>W>>N,H|W|N){\n    vector< vector<int> >v(H,vector<int>(W));\n    vector< vector<int> >dp(H,vector<int>(W,0));\n    for(int i=0;i<H;i++)for(int j=0;j<W;j++)cin>>v[i][j];\n    dp[0][0]=N-1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(i-1>=0){\n\t  if(dp[i-1][j]&1){\n\t    if(v[i-1][j]==SOUTH)dp[i][j]+=(dp[i-1][j]+1)/2;\n\t    else dp[i][j]+=(dp[i-1][j]-1)/2;\n\t  }else{\n\t    dp[i][j]+=dp[i-1][j]/2;\n\t  }\n\t}\n\tif(j-1>=0){\n\t  if(dp[i][j-1]&1){\n\t    if(v[i][j-1]==EAST)dp[i][j]+=(dp[i][j-1]+1)/2;\n\t    else dp[i][j]+=(dp[i][j-1]-1)/2;\n\t  }else{\n\t    dp[i][j]+=dp[i][j-1]/2;\n\t  }\n\t}\n      }\n    }\n    int y,x;\n    int ny,nx;\n    int dy[2]={1,0};\n    int dx[2]={0,1};\n    y=x=ny=nx=0;\n    while(x<W && y<H){\n      v[y][x]+=dp[y][x];\n      v[y][x]&=1;\n      ny+=dy[ v[y][x] ];\n      nx+=dx[ v[y][x] ];\n      y=ny;\n      x=nx;\n    }\n    cout<<y+1<<\" \"<<x+1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nclass map{\npublic:\n    bool dotti;\n    int num;\n};\nint main(){\n    int H,W,N;\n    map **walk;\n    while(cin>>H>>W>>N&&H!=0){\n        walk=new map*[H+1];\n        walk[0]=new map[W+1];\n        for(int i=1;i<=H;++i){\n            walk[i]=new map[W+1];\n            for(int j=1;j<=W;++j){\n                cin>>walk[i][j].dotti;\n                walk[i][j].num=0;\n            }\n        }\n        for(int i=0;i<=H;++i){\n            walk[i][0].dotti=0;\n            walk[i][0].num=0;\n        }\n        for(int i=0;i<=W;++i){\n            walk[0][i].dotti=0;\n            walk[0][i].num=0;\n        }\n        walk[1][1].num=N-1;\n        for(int i=1;i<=H;++i){\n            for(int j=1;j<=W;++j){\n                walk[i][j].num+=(walk[i][j-1].dotti)?(walk[i][j-1].num+1)/2:walk[i][j-1].num/2;\n                walk[i][j].num+=(walk[i-1][j].dotti)?walk[i-1][j].num/2:(walk[i-1][j].num+1)/2;\n            }\n        }\n        for(int i=1;i<=H;++i){\n            for(int j=1;j<=W;++j){\n                if(walk[i][j].num%2){\n                    walk[i][j].dotti=!walk[i][j].dotti;\n                }\n            }\n        }\n        //W=?¨?0H=???1\n        int answer[]{1,1};\n        while(answer[0]<=W&&answer[1]<=H){\n            if(walk[answer[1]][answer[0]].dotti==1){\n                ++answer[0];\n            }else{\n                ++answer[1];\n            }\n        }\n        cout<<answer[1]<<' '<<answer[0]<<endl;\n        for(int i=0;i<=H;++i){\n            delete[] walk[i];\n        }\n        delete[] walk;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y+1 < H) dp[y+1][x] += ((dp[y][x] + (direction[y][x] == 0 ? 1:0)) / 2);\n\tif(x+1 < W) dp[y][x+1] += ((dp[y][x] + (direction[y][x] == 1 ? 1:0)) / 2);\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    while(y < H && x < W){\n      if(dp[y][x] % 2 + direction[y][x] == 0) y++;\n      else if(dp[y][x] % 2 + direction[y][x] == 1) x++;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y+1 < H) dp[y+1][x] += ((dp[y][x] + (direction[y][x] == 0 ? 1:0)) / 2);\n\tif(x+1 < W) dp[y][x+1] += ((dp[y][x] + (direction[y][x] == 1 ? 1:0)) / 2);\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    for(int round = 0; round <= 1010; round++){\n      if((dp[y][x] + direction[y][x]) % 2 == 0) y++;\n      else if((dp[y][x] + direction[y][x]) % 2 == 1) x++;\n      if(y == H || x == W) break;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint main(){\n\tint n,m,k;\n\twhile(cin>>n>>m>>k,n){\n\t\tvvi in(n,vi(m)),dp(n+1,vi(m+1));\n\t\trep(i,n)rep(j,m)cin>>in[i][j];\n\t\tdp[0][0]=k-1;\n\t\trep(i,n)rep(j,m)if(dp[i][j]){\n\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\tif(dp[i][j]%2){\n\t\t\t\tif(in[i][j])dp[i][j+1]++;\n\t\t\t\telse dp[i+1][j]++;\n\t\t\t}\n\t\t\tif(dp[i][j]%2)in[i][j]^=1;\n\t\t}\n\t\tint x=0,y=0;\n\t\twhile(x!=n&&y!=m){\n\t\t\tif(in[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\tcout<<x+1<<\" \"<<y+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[1002][1002];\nlong int dp[1002][1002];\nint x,y;\nint h,w;\nlong int n;\n\nvoid root(int xx,int yy){\n\tx=xx,y=yy;\n\tdp[xx][yy]+=1;\n\tif(xx<=w && yy<=h){\n\t\tif(map[xx][yy]==1){\n\t\t\tmap[xx][yy]=0;\n\t\t\troot(xx+1,yy);\n\t\t}else{\n\t\t\tmap[xx][yy]=1;\n\t\t\troot(xx,yy+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint a,b,c;\n\twhile(1){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&map[b][a]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tint d,e;\n\t\t\t\tif(dp[b][a]%2==0)dp[b+1][a]=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)d=(dp[b+1][a]-1)/2;\n\t\t\t\t\tif(map[b][a]==0)d=(dp[b+1][a]+1)/2;\n\t\t\t\t}\n\t\t\t\tif(dp[b][a]%2==0)e=dp[b][a+1]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)e=(dp[b][a+1]+1)/2;\n\t\t\t\t\tif(map[b][a]==0)e=(dp[b][a+1]-1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tmap[b][a]=(map[b][a]+dp[b][a])%2;\n\t\t\t}\n\t\t}\n\t\troot(1,1);\n\t\tcout << y << \" \" << x << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int Height = 1000;\nconst int Width = 1000;\nbool b_map[Height][Width];\nint i_map[Height+1][Width+1];\n\nint main()\n{\n\tint h, w, n;\n\twhile(cin >> h >> w >> n, h | w | n)\n\t{\n\t\tfor(int y=0; y < h; y++)\n\t\t\tfor(int x=0; x < w; x++) {\n\t\t\t\tcin >> b_map[y][x];\n\t\t\t\ti_map[y][x] = 0;\n\t\t\t}\n\t\tfor(int y=0; y < h; y++) i_map[y][w] = 0;\n\t\tfor(int x=0; x < w; x++) i_map[h][x] = 0;\n\t\ti_map[0][0] = n - 1;\n\t\tfor(int y=0; y < h; y++)\n\t\t\tfor(int x=0; x < w; x++) {\n\t\t\t\tif(!i_map[y][x]) continue;\n\t\t\t\tif(i_map[y][x] & 1) {\n\t\t\t\t\tint num = i_map[y][x] >> 1;\n\t\t\t\t\tif(b_map[y][x]) {\n\t\t\t\t\t\ti_map[y][x+1] = num + 1;\n\t\t\t\t\t\ti_map[y+1][x] = num;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ti_map[y][x+1] = num;\n\t\t\t\t\t\ti_map[y+1][x] = num + 1;\n\t\t\t\t\t}\n\t\t\t\t\tb_map[y][x] = !b_map[y][x];\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t\ti_map[y+1][x] = i_map[y][x+1] = i_map[y][x] >> 1;\n\t\t\t}\n\t\tint x, y;\n\t\tx = y = 0;\n\t\tdo {\n\t\t\tif(b_map[y][x])\n\t\t\t\tx++;\n\t\t\telse\n\t\t\t\ty++;\n\t\t}while(x < w && y < h);\n\t\tcout << y+1 << ' ' << x+1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int h,w,n,c[1001][1001]={},a;\n  while(cin>>h>>w>>n&&h){\n    c[0][0]=n-1;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>a;\n\tc[i+1][j]+=c[i][j]/2;\n\tc[i][j+1]+=c[i][j]/2;\n\tif(c[i][j]%2){\n\t  if(!a)c[i+1][j]++;\n\t  if(a)c[i][j+1]++;\n\t}\n\tif(c[i][j]%2)c[i][j]=!a;\n\telse c[i][j]=a;\n      }\n    int x=0,y=0;\n    while(x!=w&&y!=h){\n      if(c[y][x])x++;\n      else y++;\n    }\n    cout<<y+1<<' '<<x+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int h, w, n;\n    while(cin >> h >> w >> n && h) {\n        vector<vector<int>> fld(h + 1, vector<int>(w + 1, -1));\n        for(int i : in(h))\n          for(int j : in(w))\n            cin >> fld[i][j];\n        --n;\n        int x = 0, y = 0;\n        while(true) {\n            if(fld[y][x] == -1) {\n                cout << y + 1 << ' ' << x + 1 << endl;\n                break;\n            }\n            if((n ^ fld[y][x]) & 1)\n              ++x;\n            else\n              ++y;\n            n >>= 1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint H, W, T, a[1009][1009], dp[1009][1009];\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &T), H) {\n\t\tgetchar();\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\ta[i][j] = getchar_unlocked() - 48; getchar_unlocked();\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = T - 1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tdp[i + 1][j] += (dp[i][j] - a[i][j] + 1) >> 1;\n\t\t\t\tdp[i][j + 1] += (dp[i][j] + a[i][j]) >> 1;\n\t\t\t}\n\t\t}\n\t\tint cx = 0, cy = 0;\n\t\twhile (cx < H && cy < W) {\n\t\t\tif ((dp[cx][cy] ^ a[cx][cy]) & 1) cy++;\n\t\t\telse cx++;\n\t\t\tT >>= 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", cx + 1, cy + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nint main() {\n\twhile (1) {\n\t\tint H, W, N; cin >> H >> W >> N;\n\t\tif (!H)break;\n\t\tvector<vector<int>>easts(H, vector<int>(W));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> easts[i][j];\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>nums(H+1, vector<int>(W+1));\n\t\tnums[0][0] = N - 1;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tconst int total = nums[i][j];\n\t\t\t\tint a = (total + 1) / 2;\n\t\t\t\tint b = total / 2;\n\t\t\t\tif (!easts[i][j]) {\n\t\t\t\t\tnums[i][j + 1] += b;\n\t\t\t\t\tnums[i + 1][j] += a;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnums[i][j + 1] += a;\n\t\t\t\t\tnums[i + 1][j] += b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nx = 0, ny = 0;\n\t\twhile (nx != W&&ny != H) {\n\t\t\tif ((easts[ny][nx] + nums[ny][nx]) % 2) {\n\t\t\t\tnx++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tny++;\n\t\t\t}\n\t\t}\n\t\tcout << ny+1 << \" \" << nx+1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint tab[2][1024][1024];\nint initial[1024][1024];\n\nint main() {\n\tint H, W, N;\n\twhile(cin >> H >> W >> N, H || W || N) {\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> initial[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 1024; i++)\n\t\t\tfor(int j = 0; j < 1024; j++)\n\t\t\t\ttab[0][i][j] = tab[1][i][j] = 0;\n\n\t\tN--;\n\t\tif(initial[0][0] == 0) {\n\t\t\ttab[0][1][1] = N / 2 + (N % 2);\n\t\t\ttab[1][1][1] = N / 2;\n\t\t}\n\t\telse {\n\t\t\ttab[0][1][1] = N / 2;\n\t\t\ttab[1][1][1] = N / 2 + (N % 2);\n\t\t}\n\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tint tmp;\n\t\t\t\ttmp = tab[0][i-1+1][j+1] + tab[1][i+1][j-1+1];\n\t\t\t\ttab[0][i+1][j+1] += tmp / 2 + (initial[i][j] == 0 ? (tmp % 2) : 0);\n\t\t\t\ttab[1][i+1][j+1] += tmp / 2 + (initial[i][j] == 1 ? (tmp % 2) : 0);\n\t\t\t}\n\t\t}\n\n\t\tint x, y;\n\t\tx = y = 0;\n\t\twhile(x < W && y < H) {\n\t\t\tif((initial[y][x] + tab[0][y+1][x+1] + tab[1][y+1][x+1]) % 2) {\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\tcout << y+1 << \" \" << x+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint H,W,N;\nint fie[1001][1001];\nint A[1001][1001];\nint solve(){\n  A[0][0]=N-1;\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(fie[x][y]){\n\tA[x+1][y]+=(A[x][y]+1)/2;\n\tA[x][y+1]+=A[x][y]/2;\n      } else {\n\tA[x+1][y]+=A[x][y]/2;\n\tA[x][y+1]+=(A[x][y]+1)/2;\n      }\n    }\n  }\n}\nP traced(int x,int y){\n  if(x==W || y==H) return P(x,y);\n  P ret;\n  if(A[x][y]%2){\n    if(fie[x][y]) ret = traced(x,y+1);\n    else ret = traced(x+1,y);\n  } else {\n    if(fie[x][y]) ret = traced(x+1,y);\n    else ret = traced(x,y+1);\n  }\n  return ret;\n}\nint main(){\n  while(1){\n    memset(A,0,sizeof(A));\n    scanf(\"%d %d %d\",&H,&W,&N);\n    if(!H && !W && !N) break;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n\tscanf(\"%d\",&fie[j][i]);\n    solve();\n    P res = traced(0,0);\n    \n    printf(\"%d %d\\n\",res.S+1,res.F+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nbool grid[1000][1000];\nint num[1001][1001];\nint h,w,n,tmp;\n\nint main(){\n  while(scanf(\"%d %d %d\",&h,&w,&n) && (h||w||n)){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tscanf(\"%d\",&tmp);\n\tgrid[i][j] = (tmp)?true:false;\n\tnum[i][j] = 0;\n      }\n\n    num[0][0] = n-1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tint N=num[i][j];\n\tif(grid[i][j]){\n\t  num[i+1][j] += N/2;\n\t  num[i][j+1] += N-N/2;\n\t}else{\n\t  num[i][j+1] += N/2;\n\t  num[i+1][j] += N-N/2;\n\t}\n\tif(N&1)grid[i][j] = !grid[i][j];\n      }\n    }\n\n    int y=0,x=0;\n    while(y<h && x<w){\n      if(grid[y][x])x++;\n      else y++;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nint m[1010][1010];\nint fst[1010][1010], cyc1[1010][1010], cyc2[1010][1010];\nint main() {\n\tfor (int H, W, N; cin >> H >> W >> N, (H | W | N) != 0; ) {\n\t\tmemset(m, -1, sizeof(m));\n\t\trep(i, H) rep(j, W) cin >> m[i][j];\n\t\tmemset(fst, 0, sizeof(fst));\n\t\tmemset(cyc1, 0, sizeof(cyc1));\n\t\tmemset(cyc2, 0, sizeof(cyc2));\n\t\tfst[0][0] = 1;\n\t\tcyc1[0][0] = 1;\n\t\tcyc2[0][0] = 1;\n\t\trep(i, H) rep(j, W) if (i + j != 0) {\n\t\t\tint f1 = 1000000000, f2 = 1000000000;\n\t\t\tif (i > 0) {\n\t\t\t\tif (m[i - 1][j]) f1 = min(f1, fst[i - 1][j] + cyc1[i - 1][j] + cyc2[i - 1][j] - 2);\n\t\t\t\telse f1 = min(f1, fst[i - 1][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tif (m[i][j - 1]) f2 = min(f2, fst[i][j - 1]);\n\t\t\t\telse f2 = min(f2, fst[i][j - 1] + cyc1[i][j - 1] + cyc2[i][j - 1] - 2);\n\t\t\t}\n\t\t\tif (f1 == 1000000000) {\n\t\t\t\tfst[i][j] = f2;\n\t\t\t\tcyc1[i][j] = cyc2[i][j] = cyc1[i][j - 1] + cyc2[i][j - 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f2 == 1000000000) {\n\t\t\t\tfst[i][j] = f1;\n\t\t\t\tcyc1[i][j] = cyc2[i][j] = cyc1[i - 1][j] + cyc2[i - 1][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f1 < f2) {\n\t\t\t\tfst[i][j] = f1;\n\t\t\t\tcyc2[i][j] = f2 - f1;\n\t\t\t\tcyc1[i][j] = cyc1[i - 1][j] + cyc2[i - 1][j] - cyc2[i][j];\n\t\t\t}\n\t\t\tif (f1 > f2) {\n\t\t\t\tfst[i][j] = f2;\n\t\t\t\tcyc1[i][j] = f1 - f2;\n\t\t\t\tcyc2[i][j] = cyc1[i][j - 1] + cyc2[i][j - 1] - cyc1[i][j];\n\t\t\t}\n\t\t\t\n/*\t\t\t{\n\t\t\t\tcout << \"#########fst###########\" << endl;\n\t\t\t\trep(i, H) {\n\t\t\t\t\trep(j, W) cout << fst[i][j] << ' ';\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tcout << \"#########cyc1###########\" << endl;\n\t\t\t\trep(i, H) {\n\t\t\t\t\trep(j, W) cout << cyc1[i][j] << ' ';\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tcout << \"#########cyc2###########\" << endl;\n\t\t\t\trep(i, H) {\n\t\t\t\t\trep(j, W) cout << cyc2[i][j] << ' ';\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tassert(f1 != f2);\n\t\t\tif (f1 == f2) {\n\t\t\t\tprintf(\"%d, %d\\n\", j, i);\n\t\t\t}\n*/\t\t}\n\t\t\n\t\t\n\t\tN--;\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (fst[i][j] > N) continue;\n\t\t\tint n = N - fst[i][j];\n\t\t\tint mod = n % (cyc1[i][j] + cyc2[i][j]);\n\t\t\tif (cyc2[i][j] > mod) m[i][j] = m[i][j] ? 0 : 1;\n\t\t}\n\t\t\n/*\t\tcout << \"########################\" << endl;\n\t\trep(i, H) {\n\t\t\trep(j, W) cout << m[i][j] << ' ';\n\t\t\tcout << endl;\n\t\t}\n*/\t\t\n\t\tint x = 0, y = 0;\n\t\twhile (m[y][x] != -1) {\n\t\t\tif (m[y][x]) x++;\n\t\t\telse y++;\n\t\t}\n\t\tcout << y + 1 << ' ' << x + 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dp[1001][1001];\nint map[1001][1001];\nint main(void)\n{\n\tint h,w,n;\n\tint a,b;\n\tint i,j;\n\t\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t\telse if(dp[i][j]%2!=0){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]==0){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t/*\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\t\t\n\t\ta=b=1;\n\t\twhile(a<=h && b<=w){\n\t\t\tif(map[a][b]==0){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if(map[a][b]==1){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",a,b);\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<array>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<unordered_map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) {cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) {cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nconst int MOD = 1e9 + 7;\n\n#define MAX 1010\n\nsigned main() {\n\tstatic bool east[MAX][MAX] = {};\n\tstatic int dp[MAX][MAX] = {};\n\tfor (int H, W, N; cin >> H >> W >> N&&H;) {\n\t\tfill(east[0], east[MAX], false);\n\t\tfill(dp[0], dp[MAX], 0);\n\t\trep(i, 0, H)rep(j, 0, W) {\n\t\t\tcin >> east[i][j];\n\t\t}\n\t\tdp[0][0] = N - 1;\n\t\trep(i, 0, H + 1)rep(j, 0, W + 1) {\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\tif (dp[i][j] % 2 == 1) {\n\t\t\t\tif (east[i][j])dp[i][j + 1] += 1;\n\t\t\t\telse dp[i + 1][j] += 1;\n\t\t\t}\n\t\t}\n\t\trep(i, 0, H + 1)rep(j, 0, W + 1) {\n\t\t\tdp[i][j] += east[i][j];\n\t\t\tdp[i][j] %= 2;\n\t\t}\n\t\tint i = 0, j = 0;\n\t\twhile (i < H && j < W) {\n\t\t\tif (dp[i][j] % 2 == 0)i++;\n\t\t\telse if (dp[i][j] % 2 == 1)j++;\n\t\t}\n\t\tcout << (i + 1) << \" \" << (j + 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tif(y == 0 && x == 0) continue;\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y-1 >= 0) dp[y][x] += ((dp[y-1][x] + (direction[y-1][x] == 0 ? 1:0)) / 2);\n\tif(x-1 >= 0) dp[y][x] += ((dp[y][x-1] + (direction[y][x-1] == 1 ? 1:0)) / 2);\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    for(int round = 0; round <= 1010; round++){\n      if((dp[y][x] + direction[y][x]) % 2 == 0) y++;\n      else if((dp[y][x] + direction[y][x]) % 2 == 1) x++;\n      if(y == H || x == W) break;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y+1 < H) dp[y+1][x] += (dp[y][x] + (direction[y][x] == 0 ? 1:0)) / 2;\n\tif(x+1 < W) dp[y][x+1] += (dp[y][x] + (direction[y][x] == 1 ? 1:0)) / 2;\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    while(y < H && x < W){\n      if((dp[y][x] + direction[y][x]) % 2 == 0) y++;\n      else if((dp[y][x] % 2 + direction[y][x]) % 2 == 1) x++;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\n    int H,W,N;\n    for(;;){\n        scanf(\"%d%d%d\",&H,&W,&N);\n        if(H==0&&W==0&&N==0) break;\n        vector<vector<int> > fst(H,vector<int>(W));\n        vector<vector<vector<int> > > gotime(H+1,vector<vector<int> >(W+1,vector<int>()));\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                scanf(\"%d\",&fst[i][j]);\n            }\n        }\n        gotime[0][0].push_back(0);\n        for(int i=0;i<=H;i++){\n            for(int j=0;j<=W;j++){\n                if(i>0&&j<W){\n                    int sz=gotime[i-1][j].size();\n                    if(sz%2==0){\n                        for(int k=fst[i-1][j];k<sz;k+=2){\n                            gotime[i][j].push_back(gotime[i-1][j][k]);\n                            if(i-1+j<32&&gotime[i-1][j][k]+(1<<(i-1+j)) <= 10000000){\n                                gotime[i][j].push_back(gotime[i-1][j][k]+(1<<(i-1+j)));\n                            }\n                        }\n                    }else{\n                        for(int k=fst[i-1][j];k<sz;k+=2){\n                            gotime[i][j].push_back(gotime[i-1][j][k]);\n                        }\n                        for(int k=(fst[i-1][j]+1)%2;k<sz;k+=2){\n                            if(i-1+j<32&&gotime[i-1][j][k]+(1<<(i-1+j)) <= 10000000){\n                                gotime[i][j].push_back(gotime[i-1][j][k]+(1<<(i-1+j)));\n                            }\n                        }\n                    }\n                }\n                if(j>0&&i<H){\n                    int sz=gotime[i][j-1].size();\n                    if(sz%2==0){\n                        for(int k=(fst[i][j-1]+1)%2;k<sz;k+=2){\n                            gotime[i][j].push_back(gotime[i][j-1][k]);\n                            if(i+j-1<32&&gotime[i][j-1][k]+(1<<(i+j-1)) <= 10000000){\n                                gotime[i][j].push_back(gotime[i][j-1][k]+(1<<(i+j-1)));\n                            }\n                        }\n                    }else{\n                        for(int k=(fst[i][j-1]+1)%2;k<sz;k+=2){\n                            gotime[i][j].push_back(gotime[i][j-1][k]);\n                        }\n                        for(int k=fst[i][j-1];k<sz;k+=2){\n                            if(i+j-1<32&&gotime[i][j-1][k]+(1<<(i+j-1)) <= 10000000){\n                                gotime[i][j].push_back(gotime[i][j-1][k]+(1<<(i+j-1)));\n                            }\n                        }\n                    }\n                }\n                sort(gotime[i][j].begin(),gotime[i][j].end());\n            }\n        }\n        N--;\n        for(int i=0;i<=H;i++){\n            int nn=N;\n            if(i+W<32) nn%=(1<<(i+W));\n            if(binary_search(gotime[i][W].begin(),gotime[i][W].end(),nn)){\n                printf(\"%d %d\\n\",i+1,W+1);\n            }\n        }\n        for(int j=0;j<W;j++){\n            int nn=N;\n            if(j+H<32) nn%=(1<<(j+H));\n            if(binary_search(gotime[H][j].begin(),gotime[H][j].end(),nn)){\n                printf(\"%d %d\\n\",H+1,j+1);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_H 1111\nint H,W,N;\nint ro[MAX_H][MAX_H];\nint cou[MAX_H][MAX_H];\n\nint ro1[MAX_H][MAX_H];\n\nint main()\n{\n\twhile(true){\n\tscanf(\"%d%d%d\",&H,&W,&N);\n\tif(H==0)break;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%d\",&ro[i][j]);\n\t\t\t//ro1[i][j]=ro[i][j];\n\t\t\tcou[i][j]=0;\n\t\t}\n\t}\n\t\n\tcou[0][0]=N-1;\n\t/*\n\tfor(int j=0;j<W;j++){\n\t\tif(cou[0][j]&1){\n\t\t\tif(ro[0][j]==1){\n\t\t\t\tcou[0][j+1]=1+(cou[0][j]>>1);\n\t\t\t\tcou[1][j]=cou[0][j]-cou[0][j+1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcou[1][j]=1+(cou[0][j]>>1);\n\t\t\t\tcou[0][j+1]=cou[0][j]-cou[1][j];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcou[0][j+1]=(cou[0][j]>>1);\n\t\t\tcou[1][j]=(cou[0][j]>>1);\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tif(cou[i][0]&1){\n\t\t\tif(ro[i][0]==1){\n\t\t\t\tcou[i][1]=1+(cou[0][j]>>1);\n\t\t\t\tcou[i+1][0]=cou[0][j]-cou[0][j+1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcou[1][j]=1+(cou[0][j]>>1);\n\t\t\t\tcou[0][j+1]=cou[0][j]-cou[1][j];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcou[0][j+1]=(cou[0][j]>>1);\n\t\t\tcou[1][j]=(cou[0][j]>>1);\n\t\t}\n\t}*/\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(cou[i][j]&1){\n\t\t\t\tif(ro[i][j]==1){\n\t\t\t\t\tcou[i][j+1]+=1+(cou[i][j]>>1);\n\t\t\t\t\tcou[i+1][j]+=cou[i][j]-cou[i][j+1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\tcou[i+1][j]+=1+(cou[i][j]>>1);\n\t\t\t\t\tcou[i][j+1]+=cou[i][j]-cou[i+1][j];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcou[i][j+1]+=(cou[i][j]>>1);\n\t\t\t\tcou[i+1][j]+=(cou[i][j]>>1);\n\t\t\t}\n\t\t\t//printf(\"%d %d:cou[%d][%d]=%d\\n\",i,j,1,1,cou[1][1]);\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\t//printf(\"%d \",cou[i][j]);\n\t\t\tro[i][j]=(ro[i][j]+cou[i][j])&1;\n\t\t}\n\t\t//printf(\"\\n\");\n\t}\n\tint ans1=0,ans2=0;\n\twhile(ans1<H&&ans2<W){\n\t\tif(ro[ans1][ans2]==1){\n\t\t\tans2++;\n\t\t}\n\t\telse{\n\t\t\tans1++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",ans1+1,ans2+1);\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tint now1=0,now2=0;\n\t\twhile(now1<H&&now2<W){\n\t\t\tif(ro1[now1][now2]==1){\n\t\t\t\tro1[now1][now2]=0;\n\t\t\t\tnow2++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tro1[now1][now2]=1;\n\t\t\t\tnow1++;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(i==N-1){\n\t\t\tprintf(\"%d %d\\n\",now1+1,now2+1);\n\t\t}\n\t}*/\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tif(y == 0 && x == 0) continue;\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y-1 >= 0) dp[y][x] += ((dp[y-1][x] + (direction[y-1][x] == 0 ? 1:0)) / 2);\n\tif(x-1 >= 0) dp[y][x] += ((dp[y][x-1] + (direction[y][x-1] == 1 ? 1:0)) / 2);\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    for(int round = 0; round <= 1000; round++){\n      if(dp[y][x] % 2 + direction[y][x] == 0) y++;\n      else if(dp[y][x] % 2 + direction[y][x] == 1) x++;\n      if(y == H || x == W) break;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dy[2]={1,0};\nint dx[2]={0,1};\n\nint y,x,ny,nx,a,b;\nint H,W,N;\nint t[1001][1001];\nint u[1001][1001];\n\nint main(){\n  while(cin>>H>>W>>N&&H&&W&&N){\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n\tcin>>t[i][j];\n\tu[i][j]=0;\n      }\n    }\n    u[1][1]=N;\n    y=x=1;\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n\tif(u[i][j]==0)continue;\n\ta=t[i][j];\n\tb=1-a;\n\tny=i+dy[a],nx=j+dx[a];\n\tu[ny][nx]+=(u[i][j]-u[i][j]/2);\n\tny=i+dy[b],nx=j+dx[b];\n\tu[ny][nx]+=(u[i][j]/2);\n\tif(y==i&&x==j){\n\t  if(u[i][j]%2==1)y=y+dy[a],x=x+dx[a];\n\t  else y=y+dy[b],x=x+dx[b];\n\t}\n      }\n    }\n    cout<<y<<' '<<x<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n;\nvector<vector<int>> f;\n\nbool input(){\n  int x,y;\n  cin>>x>>y;\n  cin>>n;\n  if(x==y&&y==n&&n==0)return false;\n  f.resize(x);\n  for(int i=0;i<f.size();i++){\n    f[i].resize(y);\n  }\n  for(int i=0;i<f.size();i++){\n    for(int j=0;j<f[i].size();j++){\n      cin>>f[i][j];\n    }\n  }\n  return true;\n}\n\nbool inside(vector<vector<int>> &c,int x,int y){\n  if(x<0)return false;\n  if(y<0)return false;\n  if(c.size()<=x)return false;\n  if(c[x].size()<=y)return false;\n  return true;\n}\n\npair<int,int> solve(){\n  vector<vector<int>> change;\n  change.resize(f.size());\n  for(int i=0;i<change.size();i++){\n    change[i].resize(f[i].size());\n  }\n  change[0][0] = n-1;\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(inside(change,i+1,j))change[i+1][j] = change[i][j]/2;\n      if(inside(change,i,j+1))change[i][j+1] = change[i][j]/2;\n      if(change[i][j]%2){\n        if(f[i][j]==0){\n          if(inside(change,i+1,j))change[i+1][j]++;\n        }else{\n          if(inside(change,i,j+1))change[i][j+1]++;\n        }\n      }\n    }\n  }\n  /*\n  for(auto i:change){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(change[i][j]%2){\n        f[i][j] = !f[i][j];\n      }\n    }\n  }\n  /*\n  for(auto i:f){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  \n  pair<int,int> res;\n  while(res.first<change.size()&&res.second<change[0].size()){\n    if(!f[res.first][res.second]){\n      res.first++;\n    }else{\n      res.second++;\n    }\n  }\n  res.first++;\n  res.second++;\n  return res;\n}\n\n\nint main(){\n  while(input()){\n    /*\n    for(auto i:f){\n      for(auto j:i){\n        cout<<j<<\" \";\n      }cout<<endl;\n    }cout<<endl;\n    */\n    auto ans = solve();\n    cout<<ans.first<<\" \"<<ans.second<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n#define MAX 1024\n#define fr first\n#define sc second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<int,int> pi;\n\nvoid MakeCountMap(int h, int w, int M[][MAX],int cnt[][MAX]){\n  queue<pi> qp;\n  qp.push( mp(0,0) );\n  while(!qp.empty()){\n    pi now=qp.front();\n    qp.pop();\n    if(now.fr==h||now.sc==w)continue;\n    int flr=cnt[now.fr][now.sc]/2;\n    int cel=cnt[now.fr][now.sc]%2==0?flr:flr+1;\n    cnt[now.fr+1][now.sc]+=M[now.fr][now.sc]==1?flr:cel;\n    cnt[now.fr][now.sc+1]+=M[now.fr][now.sc]==1?cel:flr;\n    qp.push(mp(now.fr+1,now.sc));qp.push(mp(now.fr,now.sc+1));\n  }\n}\n\nint main()\n{\n  while(true){\n    static int M[MAX][MAX];\n    static int cnt[MAX][MAX];\n    int h,w,n;\n    cin >> h >> w >> n;\n    \n    if( h == 0 && w == 0 && n == 0 ) break;\n    \n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n\tcnt[i][j] = 0;\n      }\n    }\n    cnt[0][0] = n-1;\n\n    MakeCountMap(h,w,M,cnt);\n\n    int nowi=0;\n    int nowj=0;\n    while(nowi<h&&nowj<w){\n      if(!(M[nowi][nowj]&(1&cnt[nowi][nowj]))){\n\tnowj++;\n      }else{\n\tnowi++;\n      }\n    }\n    cout<<1+nowi<<' '<<1+nowj<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n\nint a[1010][1010];\nint dp[1010][1010];\n\nint main()\n{\n    int h,w,n;\n    \n    while (cin>>h>>w>>n, h) {\n        memset(dp, 0, sizeof(dp));\n        rep(i, h) rep(j, w) cin >> a[i][j];\n\n        dp[0][0] = n-1;\n\n        rep(i, h) {\n            rep(j, w) {\n                if (a[i][j] == 0) {\n                    dp[i+1][j] += dp[i][j] / 2 + (dp[i][j] % 2);\n                    dp[i][j+1] += dp[i][j] / 2;\n                } else {\n                    dp[i][j+1] += dp[i][j] / 2 + (dp[i][j] % 2);\n                    dp[i+1][j] += dp[i][j] / 2;\n                }\n            }\n        }\n\n        rep(i, h) rep(j, w) {\n            a[i][j] = (a[i][j] + dp[i][j]) % 2;\n        }\n\n        int y = 0, x = 0;\n\n        while (y < h && x < w) {\n            if (a[y][x] == 1) x++;\n            else y++;\n        }\n\n        cout << y+1 << ' ' << x+1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint main(){\n\tint H,W,N;\n\tint cMap[1003][1003];\n\n\twhile(true){\n\t    int Map[1003][1003];\n\t    for(int i=0;i<1100;i++)for(int J=0;J<1100;J++)cMap[J][i] = 0;\n\t    cin >> H >> W >> N;\n\t    if(H+W+N == 0)break;\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t  cin >> Map[i][j];\n\t\t}\n\t    }\n\t    cMap[1][1] = N;//奇数ならそのまま偶数なら別\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\n\t\t    cMap[i][j+1] += cMap[i][j]/2; \n\t\t    cMap[i+1][j] += cMap[i][j]/2;\n\t\t    if(cMap[i][j]%2 != 0 ){\n\t\t\tif(Map[i][j] == 1){\n\t\t\t    cMap[i][j+1]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t    cMap[i+1][j]++;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  \n\t    int x,y;\n\t    x = y = 1;\n\t    while(1<= y && y <= H && 1<= x && x<= W){\n\t\tif(cMap[y][x]%2 == 0){\n\t\t    if(Map[y][x] == 1)y++;\n\t\t    else x++;\n\t\t}\n\t\telse{\n\t\t    if(Map[y][x] == 1)x++;\n\t\t    else y++;\n\t\t    \n\t\t}\n\t    }\n\t    cout << y << \" \" << x << endl;\n\n\t}\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000005\n#define MAX 5001\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n\nint a[1002][1002];\nint dp[1002][1002];\nint main(){\n\tint h, w, n;\n\twhile(1){\n\tscanf(\"%d%d%d\", &h, &w, &n);\n\tif(!h)break;\n\tfor(int i = 1;i <= h;i++)\n\tfor(int j = 1;j <= w;j++)scanf(\"%d\", &a[i][j]);\n\tn--;dp[1][1] = n;\n\tfor(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\tdp[i][j] += dp[i][j-1]/2;\n\t\t\tif(a[i][j-1] == 1)dp[i][j] += dp[i][j-1]%2;\n\t\t\tdp[i][j] += dp[i-1][j]/2;\n\t\t\tif(a[i-1][j] == 0)dp[i][j] += dp[i-1][j]%2;\n\t\t}\n\t}\n\t\n\tint y = 1, x = 1, t, f;\n\twhile(y <= h && x <= w){\n\t\tf = a[y][x];\n\t\tif(dp[y][x]%2)f = !f;\n\t\tif(f == 0)y++;\n\t\telse x++;\n\t}\n\tprintf(\"%d %d\\n\", y, x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nconst int MOD=100000;\nint B=1000000;\nint main(){\n      int h,w,n;\n      while(cin>>h>>w>>n&&(h||w||n)){\n            bool fld[w][h];\n            REP(i,h)REP(j,w)cin>>fld[j][i];\n            int cnt[w][h];\n            memset(cnt,0,sizeof(cnt));\n            cnt[0][0]=n-1;\n            REP(i,h)REP(j,w){\n                  if(fld[j][i]){\n                        if(j<w-1)cnt[j+1][i]+=(cnt[j][i]+1)/2;\n                        if(i<h-1)cnt[j][i+1]+=cnt[j][i]/2;\n                  }else{\n                        if(j<w-1)cnt[j+1][i]+=cnt[j][i]/2;\n                        if(i<h-1)cnt[j][i+1]+=(cnt[j][i]+1)/2;\n                  }\n            }\n            REP(i,h)REP(j,w){\n                  //printf(\"%2d%c\",cnt[j][i],j==w-1?'\\n':' ');\n                  if(cnt[j][i]%2==1)fld[j][i]^=1;\n            }\n            int x=0,y=0;\n            while(x<w&&y<h){\n                  if(fld[x][y])x++;\n                  else y++;\n            }\n            cout<<y+1<<\" \"<<x+1<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H, W, N;\nint MapData[1000][1000];\nint DpDirection[1001][1001];\n\nvoid solve(int curRow, int curCol) {\n\n\tif (curRow == H || curCol == W) {\n\t\tcout << curRow + 1 << \" \" << curCol + 1 << endl;\n\t\treturn;\n\t}\n\n\tif (MapData[curRow][curCol] == 1) {\n\t\tif (DpDirection[curRow][curCol] % 2 == 1) {\n\t\t\t++curCol;\n\t\t}\n\t\telse {\n\t\t\t++curRow;\n\t\t}\n\t}\n\telse {\n\t\tif (DpDirection[curRow][curCol] % 2 == 1) {\n\t\t\t++curRow;\n\t\t}\n\t\telse {\n\t\t\t++curCol;\n\t\t}\n\t}\n\tsolve(curRow, curCol);\n}\n\nint main() {\n\n\twhile (cin >> H >> W >> N, H) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> MapData[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemset(DpDirection, 0, sizeof(DpDirection));\n\t\tDpDirection[0][0] = N;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (MapData[i][j] == 1) {\n\t\t\t\t\tDpDirection[i][j + 1] += DpDirection[i][j] - DpDirection[i][j] / 2;\n\t\t\t\t\tDpDirection[i + 1][j] += DpDirection[i][j] / 2;\n\t\t\t\t}\n\t\t\t\telse if (MapData[i][j] == 0) {\n\t\t\t\t\tDpDirection[i][j + 1] += DpDirection[i][j] / 2;\n\t\t\t\t\tDpDirection[i + 1][j] += DpDirection[i][j] - DpDirection[i][j] / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsolve(0, 0);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint a[1111][1111];\nint count[1111][1111];\n\nint main(){\n  int h, w, n;\n  for (;;) {\n    cin >> h >> w >> n;\n    if (h == 0 && w == 0 && n == 0) break;\n    rep (i, h) rep (j, w) cin >> a[i][j];\n    rep (i, h) rep (j, w) count[i][j] = 0;\n    count[0][0] = n - 1;\n    rep (i, w - 1) count[0][i + 1] = (count[0][i] + a[0][i]) / 2;\n    rep (i, h - 1) count[i + 1][0] = (count[i][0] + 1 - a[i][0]) / 2;\n    rep (i, h - 1) rep (j, w - 1) {\n      count[i + 1][j + 1] = (count[i + 1][j] + a[i + 1][j]) / 2\n\t+ (count[i][j + 1] + 1 - a[i][j + 1]) / 2;\n    }\n    rep (i, h) rep (j, w) a[i][j] ^= count[i][j] % 2;\n    int x = 0, y = 0;\n    while (x < w && y < h) {\n      if (a[y][x] == 1) ++x;\n      else ++y;\n    }\n    cout << y + 1 << \" \" << x + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, N) for(int i = 0; i < N; i++)\n\nsigned main()\n{\n  int H, W, N;\n  int mas[1005][1005];\n  while(cin >> H >> W >> N, H || W || N) {\n    \n    Rep(i, H) Rep(j, W) cin >> mas[i][j];\n    \n    int x = 0, y = 0; --N;\n    \n    while(x < W && y < H) {\n      if((N + mas[y][x]) % 2) x++;\n      else y++;\n      N /= 2;\n    }\n    \n    cout << y + 1 << \" \" << x + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000005\n#define MAX 5001\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n\nint a[1002][1002];\nint dp[1002][1002];\nint main(){\n\tint h, w, n;\n\twhile(1){\n\tscanf(\"%d%d%d\", &h, &w, &n);\n\tif(!h)break;\n\tfor(int i = 1;i <= h;i++)\n\tfor(int j = 1;j <= w;j++)scanf(\"%d\", &a[i][j]);\n\tn--;dp[1][1] = n;\n\tfor(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\tdp[i][j] += dp[i][j-1]/2;\n\t\t\tif(a[i][j-1] == 1)dp[i][j] += dp[i][j-1]%2;\n\t\t\tdp[i][j] += dp[i-1][j]/2;\n\t\t\tif(a[i-1][j] == 0)dp[i][j] += dp[i-1][j]%2;\n\t\t}\n\t}\n\t\n\tint y = 1, x = 1, t, f;\n\twhile(y <= h && x <= w){\n\t\tf = a[y][x];\n\t\tif(dp[y][x]%2)f = !f;\n\t\tif(f == 0)y++;\n\t\telse x++;\n\t}\n\tprintf(\"%d %d\\n\", y, x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_H 1111\nint H,W,N;\nint ro[MAX_H][MAX_H];\nint cou[MAX_H][MAX_H];\n\nint ro1[MAX_H][MAX_H];\nint cou1[MAX_H][MAX_H];\n\nint main()\n{\n\twhile(true){\n\tscanf(\"%d%d%d\",&H,&W,&N);\n\tif(H==0)break;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%d\",&ro[i][j]);\n\t\t\tro1[i][j]=ro[i][j];\n\t\t\tcou[i][j]=0;\n\t\t}\n\t}\n\t\n\tcou[0][0]=N-1;\n\t/*\n\tfor(int j=0;j<W;j++){\n\t\tif(cou[0][j]&1){\n\t\t\tif(ro[0][j]==1){\n\t\t\t\tcou[0][j+1]=1+(cou[0][j]>>1);\n\t\t\t\tcou[1][j]=cou[0][j]-cou[0][j+1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcou[1][j]=1+(cou[0][j]>>1);\n\t\t\t\tcou[0][j+1]=cou[0][j]-cou[1][j];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcou[0][j+1]=(cou[0][j]>>1);\n\t\t\tcou[1][j]=(cou[0][j]>>1);\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tif(cou[i][0]&1){\n\t\t\tif(ro[i][0]==1){\n\t\t\t\tcou[i][1]=1+(cou[0][j]>>1);\n\t\t\t\tcou[i+1][0]=cou[0][j]-cou[0][j+1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcou[1][j]=1+(cou[0][j]>>1);\n\t\t\t\tcou[0][j+1]=cou[0][j]-cou[1][j];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcou[0][j+1]=(cou[0][j]>>1);\n\t\t\tcou[1][j]=(cou[0][j]>>1);\n\t\t}\n\t}*/\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(cou[i][j]&1){\n\t\t\t\tif(ro[i][j]==1){\n\t\t\t\t\tcou[i][j+1]+=(1+(cou[i][j]>>1));\n\t\t\t\t\tcou[i+1][j]+=(cou[i][j]-(1+(cou[i][j]>>1)));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\tcou[i+1][j]+=(1+(cou[i][j]>>1));\n\t\t\t\t\tcou[i][j+1]+=(cou[i][j]-(1+(cou[i][j]>>1)));\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcou[i][j+1]+=(cou[i][j]>>1);\n\t\t\t\tcou[i+1][j]+=(cou[i][j]>>1);\n\t\t\t}\n\t\t\t//printf(\"%d %d:cou[%d][%d]=%d\\n\",i,j,4,0,cou[4][0]);\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\t//printf(\"%d \",cou[i][j]);\n\t\t\tro[i][j]=(ro[i][j]+cou[i][j])&1;\n\t\t}\n\t\t//printf(\"\\n\");\n\t}\n\tint ans1=0,ans2=0;\n\twhile(ans1<H&&ans2<W){\n\t\tif(ro[ans1][ans2]==1){\n\t\t\tans2++;\n\t\t}\n\t\telse{\n\t\t\tans1++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",ans1+1,ans2+1);\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tint now1=0,now2=0;\n\t\twhile(now1<H&&now2<W){\n\t\t\tif(now1+now2==1){\n\t\t\t\tprintf(\"%d %d\\n\",now1,now2);\n\t\t\t}\n\t\t\tif(i!=N-1)cou1[now1][now2]++;\n\t\t\tif(ro1[now1][now2]==1){\n\t\t\t\tro1[now1][now2]=0;\n\t\t\t\tnow2++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tro1[now1][now2]=1;\n\t\t\t\tnow1++;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(i==N-1){\n\t\t\tprintf(\"%d %d\\n\",now1+1,now2+1);\n\t\t}\n\t}\n\tfor(int j=0;j<H;j++){\n\t\t\tfor(int k=0;k<W;k++){\n\t\t\t\tprintf(\"%d \",cou1[j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\nint p[1010][1010];\nint dp[1010][1010];\n\nint main(){\n\tint h,w,n;\n\twhile(cin >> h >> w >> n,n){\n\t\tn--;\n\t\trep(i,h)rep(j,w) cin >> p[i][j];\n\t\trep(i,h)rep(j,w) dp[i][j]=0;\n\t\tdp[0][0]=n;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(dp[i][j]&1){\n\t\t\t\tif(p[i][j]){\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t}\n\t\t\t\tp[i][j]^=1;\n\t\t\t}else{\n\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t}\n\t\t}\n\t\tint ch=0,cw=0;\n\t\twhile(ch<h&&cw<w){\n\t\t\tif(p[ch][cw])\n\t\t\t\tcw++;\n\t\t\telse\n\t\t\t\tch++;\n\t\t}\n\t\tcout << ch+1 << \" \" << cw+1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint num[1005][1005],h,w,n;\npair<int,int>p;\nint main(){\nwhile(1){\nscanf(\"%d %d %d\",&h,&w,&n);\nfor(int i=1;i<=h;i++){\nfor(int j=1;j<=w;j++){\nscanf(\"%d\",&num[j][i]);\n}\n}\nint y=1,s=1,cou=0;\nwhile(1){\nif(num[y][s]){\ny++;\nnum[y][s]=(num[y][s]+1)%2;\nif(y==w+1){\ncou++;\np=make_pair(y,s);\n}\n}else{\nnum[y][s]=(num[y][s]+1)%2;\ns++;\nif(y==h+1){\ncou++;\np=make_pair(y,s);\n}\n}\nif(cou==n){\ncout << p.first << \" \" << p.second << endl; return 0;\n}\nif(p.first==1 && p.second==h){\ncout << p.first <<\" \"<< p.second << endl; return 0;\n}\nif(p.first==w && p.second==1){\ncout << p.first <<\" \"<<p.second <<endl; return 0;\n}\n}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int h,w,n;\n  int dx[] = {0,1};\n  int dy[] = {1,0};\n\n  while(cin>>h>>w>>n,h||w||n) {\n    bool ba[w][h];\n    REP(y,h) REP(x,w)\n      cin >> ba[x][y];\n    int dp[w][h];               // dp[i][j] : n ñUàµÄ(j,i) ÉÚ®·éñ\n    memset(dp,0,sizeof(dp));\n    dp[0][0] = n;\n    REP(y, h) {\n      REP(x, w) {\n        bool d;\n        if (dp[x][y]%2) {\n          d = ba[x][y];\n        } else {\n          d = !ba[x][y];\n        }\n        if (d) {\n          if (x<w-1)\n            dp[x+1][y] += (dp[x][y] + 1) / 2;\n          if (y<h-1)\n            dp[x][y+1] += dp[x][y] / 2;\n        } else {\n          if (x<w-1)\n            dp[x+1][y] += dp[x][y] / 2;\n          if (y<h-1)\n            dp[x][y+1] += (dp[x][y] + 1) / 2;\n        }\n      }\n    }\n    // REP(y,h){\n    //   REP(x,w) {\n    //     cout<<dp[x][y]<<\" \";\n    //   }cout << endl;\n    // }\n    int x=0,y=0;\n    while(x<w&&y<h) {\n//      cout << x << \" \" << y << endl;\n      bool d;\n      if (dp[x][y]%2) {\n        d = ba[x][y];\n      } else {\n        d = !ba[x][y];\n      }\n\n      x += dx[d];\n      y += dy[d];\n    }\n    cout << y+1 << \" \" << x+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nint dp[1001][1001];\nint h, w, n;\nint data[1000][1000];\n\nint main() {\n\twhile (cin >> h >> w >> n, h || w || n) {\n\t\tREP(i, h) REP(j, w) scanf(\"%d\", &data[i][j]);\n\t\t\n\t\tint nx = 0, ny = 0;\n\t\t\n\t\tfill(dp[0], dp[h + 1], 0);\n\t\tdp[0][0] = n;\n\t\tREP(i, h) REP(j, w) {\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\t\n\t\t\tif (dp[i][j] & 1) {\n\t\t\t\tif (data[i][j]) {\n\t\t\t\t\tdp[i][j + 1] += (dp[i][j] + 1) / 2;\n\t\t\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j] += (dp[i][j] + 1) / 2;\n\t\t\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\t}\n\t\t\t\n\t\t\tif (nx == j && ny == i) {\n\t\t\t\tint move = data[i][j];\n\t\t\t\tif ((dp[i][j] & 1) == 0) move ^= 1;\n\t\t\t\t\n\t\t\t\tif (move) nx++;\n\t\t\t\telse ny++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tcout << ny + 1 << \" \" << nx + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000005\n#define MAX 5001\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n\nint a[1002][1002];\nint dp[1002][1002];\nint main(){\n\tint h, w, n;\n\twhile(1){\n\tscanf(\"%d%d%d\", &h, &w, &n);\n\tif(!h)break;\n\tfill((int*)a, (int*)(a+1002), 0);\n\tfill((int*)dp, (int*)(dp+1002), 0);\n\tfor(int i = 1;i <= h;i++)\n\tfor(int j = 1;j <= w;j++)scanf(\"%d\", &a[i][j]);\n\tn--;dp[1][1] = n;\n\tfor(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\tdp[i][j] += dp[i][j-1]/2;\n\t\t\tif(a[i][j-1] == 1)dp[i][j] += dp[i][j-1]%2;\n\t\t\tdp[i][j] += dp[i-1][j]/2;\n\t\t\tif(a[i-1][j] == 0)dp[i][j] += dp[i-1][j]%2;\n\t\t}\n\t}\n\t\n\tint y = 1, x = 1, t, f;\n\twhile(y <= h && x <= w){\n\t\tf = a[y][x];\n\t\tif(dp[y][x]%2)f = !f;\n\t\tif(f == 0)y++;\n\t\telse x++;\n\t}\n\tprintf(\"%d %d\\n\", y, x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int dy[2]={1,0},dx[2]={0,1};\nint H,W,stage[1000][1000],ansy,ansx;\n\nvoid solve(int y,int x,int cnt){\n\tif(y>=H || x>=W){\n\t\tansy = y+1; ansx = x+1;\n\t\treturn;\n\t}\n\tint ny,nx;\n\tny = y+dy[(stage[y][x]+cnt)%2];\n\tnx = x+dx[(stage[y][x]+cnt)%2];\n\tsolve(ny,nx,cnt/2);\n}\n\nint main(){\n\tint N;\n\twhile(cin>>H>>W>>N,H||W||N){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>stage[i][j];\n\t\t\t}\n\t\t}\n\t\tsolve(0,0,N-1);\n\t\tprintf(\"%d %d\\n\",ansy,ansx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\nusing namespace std;\n\nint main(){\n\tint box[100][100],n,h,w,i,j;\n\t\n\twhile(1){\n\tcin >> h >> w >> n ;\n\tif((n==0)&&(h==0)&&(w==0)){\n\t\treturn 0;\n\t}\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tcin >> box[i][j] ;\n\t\t}\n\t}\n\t\n\tint a,b,turn=0;\n\twhile(1){\n\t\ta=0; b=0;\n\t\twhile((a!=h)&&(b!=w)){\n\t\t\tif(box[a][b]==1){\n\t\t\t\tbox[a][b]=0;\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbox[a][b]=1;\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tprintf(\"%d %d\\n\",a,b);\n\t\t}\n\t\tturn++;\n\t\tcout << \"\\n\";\n\t\tif(turn == n){\n\t\t\tprintf(\"%d %d\\n\",a+1,b+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint a[1000][1000], dp[1000][1000];\nchar b[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%d\", &a[i][j]); b[i][j] = a[i][j];\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] / 2;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) / 2;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) / 2;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] / 2;\n\t\t\t}\n\t\t\tif (dp[i][j] & 1)b[i][j] = !b[i][j];\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (b[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", x + 1, y + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 1010\n \nbool a[MAX][MAX];\nint dp[MAX][MAX];\nint H, W;\n \nbool get_dir(int n, bool dir)\n{\n    return (n % 2 == 0 ? dir : !dir);\n}\n \nvoid find_last_point()\n{\n    int x = 0, y = 0;\n    while (true) {\n        if (a[y][x] == 1) {\n            x++;\n        } else {\n            y++;\n        }\n        if (x >= W || y >= H) break;\n    }\n    cout << y+1 << \" \" << x+1 << endl;\n}\n \nint main()\n{\n    int N;\n    while (cin >> H >> W >> N, H) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = N-1;\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp[i][j] == 0) continue;\n                a[i][j] = get_dir(dp[i][j], a[i][j]);\n                if (dp[i][j] % 2 == 1) {\n                    if (a[i][j] == 0) {\n                        dp[i+1][j] += dp[i][j] / 2;\n                        dp[i][j+1] += dp[i][j] / 2 + 1;\n                    } else {\n                        dp[i+1][j] += dp[i][j] / 2 + 1;\n                        dp[i][j+1] += dp[i][j] / 2;\n                    }\n                } else {\n                    dp[i+1][j] += dp[i][j] / 2;\n                    dp[i][j+1] += dp[i][j] / 2;\n                }\n            }\n        }\n        find_last_point();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nvoid solve()\n{\n\tint H, W, N;\n\twhile(cin >> H >> W >> N, H || W || N)\n\t{\n\t\tvector< vector<int> > Field(H, vector<int>(W));\n\t\tfor(int i = 0; i < H; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < W; ++j)\n\t\t\t{\n\t\t\t\tcin >> Field[i][j];\n\t\t\t}\n\t\t}\n\t\tP pos;\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tpos.first = 0;\n\t\t\tpos.second = 0;\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif(pos.first == W || pos.second == H)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(Field[pos.second][pos.first] == 1)\n\t\t\t\t{\n\t\t\t\t\tField[pos.second][pos.first] = 0;\n\t\t\t\t\tpos.first++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tField[pos.second][pos.first] = 1;\n\t\t\t\t\tpos.second++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << pos.second + 1 << \" \" << pos.first + 1 << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tbool judge = true;\n\twhile (judge) {\n\t\tint h, w, n;\n\t\tcin >> h >> w >> n;\n\t\tif (h == 0 && w == 0 && n == 0) {\n\t\t\tjudge = false;\n\t\t\treturn 0;\n\t\t}\n\t\tint p[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> p[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[1010][1010] = { 0 };\n\t\tdp[0][0] = n - 1;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (dp[i][j] % 2 == 0) {\n\t\t\t\t\tif (i != h - 1) {\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\t\t}\n\t\t\t\t\tif (j != w - 1) {\n\t\t\t\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (p[i][j] == 0) {\n\t\t\t\t\t\tif (i != h - 1) {\n\t\t\t\t\t\t\tdp[i + 1][j] += dp[i][j] / 2 + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j != w - 1) {\n\t\t\t\t\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (i != h - 1) {\n\t\t\t\t\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j != w - 1) {\n\t\t\t\t\t\t\tdp[i][j + 1] += dp[i][j] / 2 + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (dp[i][j] % 2 == 1) {\n\t\t\t\t\tif (p[i][j] == 0) {\n\t\t\t\t\t\tp[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint a = 0, b = 0;\n\t\twhile (a < h && b < w) {\n\t\t\tif (p[a][b] == 0) {\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tcout << a + 1 << ' ' << b + 1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int H, W, N;\n  while(cin >> H >> W >> N && (H|W|N)) {\n    vector<vector<int>> G(H, vector<int>(W));\n    rep(i, H) rep(j, W) {\n      cin >> G[i][j];\n    }\n\n    vector<vector<int>> dp(H+10, vector<int>(W+10));\n    dp[0][0] = N - 1;\n    rep(i, H) rep(j, W) {\n      if(G[i][j]) {\n        dp[i][j+1] += (dp[i][j] + 1) / 2;\n        dp[i+1][j] += (dp[i][j]) / 2;\n      } else {\n        dp[i+1][j] += (dp[i][j] + 1) / 2;\n        dp[i][j+1] += (dp[i][j]) / 2;\n      }\n    }\n\n    std::function<pair<int,int>(int, int)> dfs = [&](int y, int x) {\n      if(y>=H || x>=W){\n        return make_pair(y+1, x+1);\n      }\n      if(G[y][x]) {\n        return dfs(y + dp[y][x] % 2, x + (dp[y][x] + 1) % 2);\n      } else {\n        return dfs(y + (dp[y][x] + 1) % 2, x + dp[y][x] % 2);\n      }\n    };\n\n    auto k = dfs(0, 0);\n    cout << k.first << \" \" << k.second << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tgetchar_unlocked(); a[i][j] = getchar_unlocked() - '0';\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] >> 1;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) >> 1;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) >> 1;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] >> 1;\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (dp[x][y] & 1)a[x][y] = !a[x][y];\n\t\t\tif (a[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", x + 1, y + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n \n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n \n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n \nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  int H, W, N;\nwhile(\n  cin >> H >> W >> N,W){\n  VVI xs(H, VI(W));\n  REP(y,H) REP(x,W) cin >> xs[y][x];\n \n  VVI cnt(H+1, VI(W+1));\n  cnt[0][0] = N-1;\n  REP(y,H) REP(x,W){\n\tcnt[y][x+1] += cnt[y][x] / 2;\n\tcnt[y+1][x] += cnt[y][x] / 2;\n\tif(xs[y][x]) cnt[y][x+1] += cnt[y][x] % 2;\n\telse cnt[y+1][x] += cnt[y][x] % 2;\n  }\n \n  int x = 0, y = 0;\n  while(x < W && y < H){\n\tif((xs[y][x] + cnt[y][x]) % 2) ++x;\n\telse ++y;\n  }\n  cout << y+1 << \" \" << x+1 << endl;  \n }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \": \" << x << '\\n';\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = (int)1e9;\n\nint dp[1010][1010];\nint grid[1010][1010];\nint dx[] = {0, 1};\nint dy[] = {1, 0};\n\nint main(void){\n\tint H, W, N; cin >> H >> W >> N;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tint b; cin >> b;\n\t\t\tgrid[i][j] = b;\n\t\t}\n\t}\n\n\tdp[0][0] = N-1;\n\tfor(int y = 0; y < H; y++){\n\t\tfor(int x = 0; x < W; x++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\t\t\tif(ny<H and nx<W){\n\t\t\t\t\tif(grid[y][x] == k){\n\t\t\t\t\t\tdp[ny][nx] += (dp[y][x] + 1) / 2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[ny][nx] += dp[y][x] / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint x = 0, y = 0;\n\twhile(y<H and x<W){\n\t\t// printf(\"(%d, %d)\\n\", y, x);\n\t\tif(dp[y][x]%2 == 0){\n\t\t\ty += dy[grid[y][x]];\n\t\t\tx += dx[grid[y][x]];\n\t\t}else{\n\t\t\ty += dy[(grid[y][x] + 1)%2];\n\t\t\tx += dx[(grid[y][x] + 1)%2];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", y+1, x+1);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W,N;\nint** table;\nint** dp;\n\nvoid func(){\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tscanf(\"%d\",&table[i][k]);\n\t\t\tdp[i][k] = 0;\n\t\t}\n\t}\n\n\tdp[0][0] = N-1;\n\tfor(int i = 1; i < W; i++){\n\t\tif(dp[0][i-1]%2 == 0){\n\t\t\tdp[0][i] = dp[0][i-1]/2;\n\t\t}else{\n\t\t\tif(table[0][i-1] == 1){\n\t\t\t\tdp[0][i] = (dp[0][i-1]+1)/2;\n\t\t\t}else{\n\t\t\t\tdp[0][i] = (dp[0][i-1]-1)/2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 1; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\n\t\t\tif(dp[row-1][col]%2== 0){\n\t\t\t\tdp[row][col] += dp[row-1][col]/2;\n\t\t\t}else{\n\t\t\t\tif(table[row-1][col] == 0){\n\t\t\t\t\tdp[row][col] += (dp[row-1][col]+1)/2;\n\t\t\t\t}else{\n\t\t\t\t\tdp[row][col] += (dp[row-1][col]-1)/2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(col > 0){\n\t\t\t\tif(dp[row][col-1]%2 == 0){\n\t\t\t\t\tdp[row][col] += dp[row][col-1]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(table[row][col-1] == 1){\n\t\t\t\t\t\tdp[row][col] += (dp[row][col-1]+1)/2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[row][col] += (dp[row][col-1]-1)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(dp[row][col]%2==1){\n\t\t\t\ttable[row][col] = 1 - table[row][col];\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans_row = 0,ans_col = 0;\n\twhile(ans_row < H && ans_col < W){\n\t\tif(table[ans_row][ans_col] == 0){\n\t\t\tans_row++;\n\t\t}else{\n\t\t\tans_col++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",ans_row+1,ans_col+1);\n\n}\n\n\nint main(){\n\n\ttable = new int*[1001];\n\tdp = new int*[1001];\n\tfor(int i = 0; i < 1001; i++){\n\t\ttable[i] = new int[1001];\n\t\tdp[i] = new int[1001];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&N);\n\t\tif(H == 0 && W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n//typedef vector<vector<bool> > v2;\ntypedef bool city[1001][1001];\ntypedef pair<int,int> pos;\n\nint h,w,n;\n\ncity field;\n\npos next(city &f){\n\tint x=0;\n\tint y=0;\n\twhile(x<w && y<h){\n\t\tbool b = f[x][y];\n\t\tf[x][y]= !b;\n\t\tif(b){\n\t\t\tx++;\n\t\t}else{\n\t\t\ty++;\n\t\t}\n\t}\n\treturn make_pair(x,y);\n}\n\nbool same(city f1,city f2){\n\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(f1[x][y]!=f2[x][y])return false;\n\t\t\t}\n\treturn true;\n}\n\nvoid cp(const city& orig,city& to){\n\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tto[x][y]=orig[x][y];\n\t\t\t}\n\n}\n\nint rep(city c){\n\tcity copy;\n\tcp(field,copy);\n\tnext(copy);\n\tfor(int i=1;;i++){\n\t\tif(same(c,copy))return i;\n\t\tnext(copy);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> h >> w >> n;\n\t\tif(h==0&&w==0&&n==0)return 0;\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tint o;\n\t\t\t\tcin >> o;\n\t\t\t\tfield[x][y] = o==1;\n\t\t\t}\n\t\tint r = rep(field);\n\t\tpos ans;\n\t\tfor(int i=0;i<(n%r);i++){\n\t\t\tans=next(field);\n\t\t}\n\t\tcout << ans.second+1 << \" \" << ans.first+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tgetchar_unlocked(); a[i][j] = getchar_unlocked() - '0';\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] >> 1;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) >> 1;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) >> 1;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] >> 1;\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif ((dp[x][y] ^ a[x][y]) & 1)y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", x + 1, y + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nenum Direction{SOUTH,EAST};\n\nint v[1001][1001],dp[1001][1001];\nint main()\n{\n  int H,W,N;\n  int y,x;\n  while(cin>>H>>W>>N,H|W|N){\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>v[i][j];\n    dp[1][1]=N-1;\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n\tif(dp[i-1][j]&1){\n\t  if(v[i-1][j]==SOUTH)dp[i][j]+=(dp[i-1][j]+1)/2;\n\t  else dp[i][j]+=(dp[i-1][j]-1)/2;\n\t}else{\n\t  dp[i][j]+=dp[i-1][j]/2;\n\t}\n\tif(dp[i][j-1]&1){\n\t  if(v[i][j-1]==EAST)dp[i][j]+=(dp[i][j-1]+1)/2;\n\t  else dp[i][j]+=(dp[i][j-1]-1)/2;\n\t}else{\n\t  dp[i][j]+=dp[i][j-1]/2;\n\t}\n      }\n    }\n    y=x=1;\n    while(x<=W && y<=H){\n      v[y][x]^=dp[y][x]&1;\n      //cout<<y<<\",\"<<x<<\":\"<<v[y][x]<<endl;\n      if(v[y][x]==SOUTH)y++;\n      else x++;\n    }\n    cout<<y<<\" \"<<x<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\n//constexpr int MAX_N = 1005;\nconstexpr int MAX_H = 1005;\nconstexpr int dx[] = {0, 1};\nconstexpr int dy[] = {1, 0};\n\nint h, w, n, fld[MAX_H][MAX_H], dp[MAX_H][MAX_H];\n\nbool Solve() {\n    cin >> h >> w >> n;\n    if (!h) return false;\n\n    memset(fld, -1, sizeof(fld));\n    memset(dp, 0, sizeof(dp));\n\n    for (int y = 1; y <= h; ++y) {\n        for (int x = 1; x <= w; ++x) {\n            cin >> fld[x][y];\n        }\n    }\n\n    dp[1][1] = n - 1;\n    for (int y = 1; y <= h; ++y) {\n        for (int x = (y == 1 ? 2 : 1); x <= w; ++x) {\n            for (int i = 0; i < 2; ++i) {\n                int tx = x - dx[i], ty = y - dy[i];\n                dp[x][y] += dp[tx][ty] / 2 + (dp[tx][ty] % 2 && fld[tx][ty] == i) ? 1 : 0;\n            }\n        }\n    }\n\n    for (int y = 1; y <= h; ++y) {\n        for (int x = 1; x <= w; ++x) {\n            fld[x][y] += dp[x][y];\n            fld[x][y] %= 2;\n        }\n    }\n\n    {\n        int x = 1, y = 1;\n\n        while (fld[x][y] != -1) {\n            int nx = x + dx[fld[x][y]];\n            y += dy[fld[x][y]];\n            x = nx;\n        }\n\n        cout << y << \" \" << x << endl;\n    }\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint main(){\n\tint h,w,n,data[101][101];\n\twhile(std::cin>>h>>w>>n,h,w,n){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tstd::cin>>data[i][j];\n\t\t\t}\n\t\t}\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx=0,y=0;\n\t\t\twhile(1){\n\t\t\t\tif(x==w||y==h)break;\n\t\t\t\tif(data[y][x]==0)data[y][x]=1,y++;\n\t\t\t\telse data[y][x]=0,x++;\n\t\t\t}\n\t\t}\n\t\tstd::cout<<y+1<<\" \"<<x+1<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nlong long n,field[1001][1001],dp[1001][1001];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    memset(dp,0,sizeof(dp));\n    memset(field,0,sizeof(field));\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    dp[0][0] = n-1;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(dp[i][j]>0){\n\t  if(dp[i][j]%2 == 0){\n\t    dp[i+1][j]+=dp[i][j]/2;\n\t    dp[i][j+1]+=dp[i][j]/2;\n\t  }\n\t  else{\n\t    if(field[i][j] == 0){\n\t      dp[i+1][j]+=dp[i][j]/2;\n\t      dp[i][j+1]+=dp[i][j]/2+1;\n\t    }\n\t    if(field[i][j] == 1){\n\t      dp[i+1][j]+=dp[i][j]/2+1;\n\t      dp[i][j+1]+=dp[i][j]/2;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout <<endl;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+dp[j][i]%2)%2;\n      }\n    }\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dp[1001][1001];\nint map[1001][1001];\nint main(void)\n{\n\tint h,w,n;\n\tint a,b;\n\tint i,j;\n\t\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t\telse if(dp[i][j]%2!=0){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]==0){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\t\t\n\t\ta=b=1;\n\t\twhile(a<=h && b<=w){\n\t\t\tif(map[a][b]==0){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if(map[a][b]==1){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",a,b);\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nstruct P {\n    ll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//???£??\\????????????¨???\n    ll to, cost;\n};\nstruct S {//????????????±?????\\????????????°\n    int from, to, cost;\n};\nstruct H {\n    int x, y;\n};\nll gcd(ll i, ll j) {//??????§???¬??´????°\n    if (i > j) swap(i, j);\n    if (i == 0) return j;\n    return gcd(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n    return sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad??????§??¨???????2???????????????¢\n//---------------------------------------------------\n//+++++++++++++++++++++++++++++++++++++++++++++++++++\nstruct A{\n\tint x,y;\n\tstring s;\n};\nbool operator<(A a,A b){\n\treturn a.s<b.s;\n}\nbool operator>(A a,A b){\n\treturn a.s>b.s;\n}\npriority_queue<A, vector<A>, greater<A>>p;\nbool b[1000][1000];\nint h,w,n;\nvector<H>c;\nsigned main() {\n\twhile(cin>>h>>w>>n&&h+w+n>0){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcin>>b[i][j];\n\t\tc.clear();\n\t\tp.push(A{0,0,\"\"});\n\t\twhile(!p.empty()){\n\t\t\tA t=p.top();p.pop();\n\t\t\tif(t.x==h||t.y==w){\n\t\t\t\tc.push_back(H{t.x,t.y});\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b[t.x][t.y]){\n\t\t\t\tp.push(A{t.x,t.y+1,t.s+\"0\"});\n\t\t\t\tp.push(A{t.x+1,t.y,t.s+\"1\"});\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp.push(A{t.x+1,t.y,t.s+\"0\"});\n\t\t\t\tp.push(A{t.x,t.y+1,t.s+\"1\"});\n\t\t\t}\n\t\t}\n\t\tint k=c.size();\n\t\tk=n%k;\n\t\tcout<<c[k].x+1<<\" \"<<c[k].y+1<<endl;\n\t\tfor(int i=0;i<c.size();i++){\n\t\t\tcout<<c[i].x<<\" \"<<c[i].y<<endl;\n\t\t}\n\t}\n    getchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define SOUTH 0\n#define EAST  1\n\nint town_map[1001][1001];\nint table1[1001][1001];\nint table2[1001][1001];\n\nint calc_times(int table[1001][1001], int i, int j) {\n    int ret = 0;\n\n    if (i > 0) {\n        if (town_map[i-1][j] == SOUTH) {\n            ret += (table[i-1][j]+1)/2;\n        } else if (town_map[i-1][j] == EAST) {\n            ret += table[i-1][j]/2;\n        }\n    }\n\n    if (j > 0) {\n        if (town_map[i][j-1] == EAST) {\n            ret += (table[i][j-1]+1)/2;\n        } else if (town_map[i][j-1] == SOUTH) {\n            ret += table[i][j-1]/2;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    while (1) {\n        int i;\n        int h, w, n;\n        int now_x = 0;\n        int now_y = 0;\n        scanf(\"%d %d %d\", &h, &w, &n);\n        if (h == 0) return 0;\n    \n        for (i=0;i<h+1;i++) {\n            int j;\n            for (j=0;j<w+1;j++) {\n                table1[i][j] = 0;\n                table2[i][j] = 0;\n                town_map[i][j] = -1;\n            }\n        }\n\n        for (i=0;i<h;i++) {\n            int j;\n            for (j=0;j<w;j++) {\n                scanf(\"%d\", &town_map[i][j]);\n            }\n        }\n\n        table1[0][0] = n-1;\n        table2[0][0] = n;\n    \n        for (i=0;i<h+1;i++) {\n            int j;\n            for (j=0;j<w+1;j++) {\n                table1[i][j] += calc_times(table1, i, j);\n                table2[i][j] += calc_times(table2, i, j);\n            }\n        }\n    \n        for (i=0;i<h+1;i++) {\n            if (table1[i][w] != table2[i][w]) printf(\"%d %d\\n\", i+1, w+1);\n        }\n    \n        for (i=0;i<w;i++) {\n            if (table1[h][i] != table2[h][i]) printf(\"%d %d\\n\", h+1, i+1);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[1002][1002];\nlong int dp[1002][1002];\nint x,y;\nint h,w;\nlong int n;\n\nvoid root(int xx,int yy){\n\tx=xx,y=yy;\n\tdp[xx][yy]+=1;\n\tif(xx<=w && yy<=h){\n\t\tif(map[xx][yy]==1){\n\t\t\tmap[xx][yy]=0;\n\t\t\troot(xx+1,yy);\n\t\t}else{\n\t\t\tmap[xx][yy]=1;\n\t\t\troot(xx,yy+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint a,b,c;\n\twhile(1){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&map[b][a]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tint d,e;\n\t\t\t\tif(dp[b][a-1]%2==0)d=dp[b][a-1]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a-1]==1)d=(dp[b][a-1]+1)/2;\n\t\t\t\t\tif(map[b][a-1]==0)d=(dp[b][a-1]-1)/2;\n\t\t\t\t}\n\t\t\t\tif(dp[b-1][a]%2==0)e=dp[b-1][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b-1][a]==1)e=(dp[b-1][a]+1)/2;\n\t\t\t\t\tif(map[b-1][a]==0)e=(dp[b-1][a]-1)/2;\n\t\t\t\t}\n\t\t\t\tdp[b][a]+=d+e;\n\t\t\t}\n\t\t}\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tmap[b][a]=(map[b][a]+dp[b][a])%2;\n\t\t\t}\n\t\t}\n\t\troot(1,1);\n\t\tcout << y << \" \" << x << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nint field[1024][1024];\nint dp[1024][1024];\nint h,w,n;\n\nint main(){\n  \n  while(scanf(\"%d%d%d\",&h,&w,&n),h|w|n){\n    memset(dp,0,sizeof(dp));\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i+1][j+1]);\n      }\n    }\n\n    int x=1;\n    int y=1;\n    dp[1][1] = n-1;\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tint k1,k2;\n\tif( dp[i-1][j]%2 && field[i-1][j]==0 ){\n\t  k1 = 1;\n\t}else{\n\t  k1 = 0;\n\t}\n\tif( dp[i][j-1]%2 && field[i][j-1]==1 ){\n\t  k2 = 1;\n\t}else{\n\t  k2 = 0;\n\t}\n\n\tdp[i][j] += (dp[i-1][j]+k1)/2  + (dp[i][j-1]+k2)/2;\n\tif( i==y && j==x ){\n\t  if( (field[i][j]+dp[i][j])%2==1 ){\n\t    x++;\n\t  }else{\n\t    y++;\n\t  }\n\t}\n      }\n    }\n#if DEB\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tprintf(\"%2d \",dp[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    \n    // Nツ嘉アツ姪堋づ個湘ウツ妥板づーツ青カツ青ャ\n    /*\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tfield[i][j] = (field[i][j]+dp[i][j])%2;\n      }\n    }\n    */\n#if DEB\n    puts(\"field\");\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tprintf(\"%2d \",field[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    \n    /*\n    int x=1;\n    int y=1;\n    for(;;){\n      if( x>w || y>h )break;\n      if( (field[y][x]+dp[y][x])%2==1 ){\n\tx++;\n      }else{\n\ty++;\n      }\n    }\n    */\n\n    printf(\"%d %d\\n\",y,x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint w,h,n;\nint num[1005][1005];\nint dp[1005][1005]={};\nint main(){\n\twhile(1){\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\tif(h+w+n==0) break;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tscanf(\"%d\",&num[i][j]);\n\t\t}\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tdp[1][1]=n-1;\n        for(int i=2;i<=w;i++){\n            dp[1][i]+=(dp[1][i-1]/2);\n            if (dp[1][i-1]%2==1 && num[1][i-1]==1){\n                dp[1][i]++;\n            }\n        } \n        for (int i=2;i<=h;i++){\n            dp[i][1]+=(dp[i-1][1]/2);\n            if (dp[i-1][1]%2==1 && num[i-1][1]==0){\n                dp[i][1]++;\n            }\n        }\n\tfor(int i=2;i<=h;i++){\n\t\tfor(int j=2;j<=w;j++){\n\t\t\t\tif(dp[i-1][j]%2==0){\n\t\t\t\t\tdp[i][j]+=dp[i-1][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(num[i][j]==0){\n\t\t\t\t\t\tdp[i][j]+=(dp[i-1][j]+1)/2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j]+=(dp[i-1][j]-1)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dp[i][j-1]%2==0){\n\t\t\t\t\tdp[i][j]+=dp[i][j-1]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(num[i][j]==1){\n\t\t\t\t\t\tdp[i][j]+=(dp[i][j-1]+1)/2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j]+=(dp[i][j-1]-1)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\tint i=1,j=1;\n\twhile(i!=h+1 && j!=w+1){\n\t\tif(dp[i][j]%2==0){\n\t\t\tif(num[i][j]==0){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}else{\n\t\t\tif(num[i][j]==1){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\t\tprintf(\"%d %d\\n\",i,j);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w, n;\nvector< vector<int> > v(1000, vector<int>(1000));\nvector< vector<int> > t(1000, vector<int>(1000));\nmap<int, P> m;\n\nint main() {\n\twhile(cin >> h >> w >> n) {\n\t\tif(h == 0 && w == 0 && n == 0) break;\n\n\t\tm.clear();\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t\tt[i][j] = v[i][j];\n\t\t\t}\n\t\t}\n\t\tint y = 0, x = 0, m = n;\n\t\twhile(y != h && x != w) {\n\t\t\tint s = m / 2;\n\t\t\tint t = m - s;\n\n\t\t\tif(v[y][x] == 1) {\n\t\t\t\tif(m % 2 == 0) {\n\t\t\t\t\tm = t;\n\t\t\t\t\ty++;\n\t\t\t\t} else {\n\t\t\t\t\tm = t;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(m % 2 == 0) {\n\t\t\t\t\tm = t;\n\t\t\t\t\tx++;\n\t\t\t\t} else {\n\t\t\t\t\tm = t;\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << y + 1 << \" \" << x + 1 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(ll i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define RREP(i,n) for(ll i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nll way[1002][1002];\nll dp[1002][1002];\nint main(){\n    while(true){\n\tll h,w,n;\n\t//memset(dp,0ll,sizeof(dp));\n\t//memset(way,0ll,sizeof(way));\n\tREP(i,1001)REP(j,1001){\n\t    dp[i][j] = 0;\n\t    way[i][j] = 0;\n\t}\n\tcin >> h >> w >> n;\n\tif(h == 0 && w == 0 && n == 0) break;\n\tREP(i,h)REP(j,w) {\n\t    cin >> way[i+1][j+1];\n\t}\n\tdp[1][1] = n-1;\n\tREP(i,h)REP(j,w){\n\t    if(i == 0 && j == 0) continue;\n\t    ll u = 0;\n\t    ll l = 0;\n\t    if(i > 0){\n\t\tif(dp[i][j+1]%2 == 0) u = dp[i][j+1]/2;\n\t\telse if(way[i][j+1] == 0) u = 1 + dp[i][j+1]/2;\n\t    }\n\t    if(j > 0){\n\t\tif(dp[i+1][j]%2 == 0) l = dp[i+1][j]/2;\n\t\telse if(way[i+1][j] == 1) l = 1 + dp[i+1][j]/2;\n\t    }\n\t    dp[i+1][j+1] = u + l;\n\t}\n\tll x = 1;\n\tll y = 1;\n\twhile(x <= w && y <= h){\n\t    if( (way[y][x] + dp[y][x])%2 == 1){\n\t\tx++;\n\t    }else y++;\n\t}\n\tprintf(\"%d %d\\n\",y,x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "  while(1) {\n    cin>>h>>w>>n;\n    if(h==0&&w==0&&n==0) break;\n\n    int r[w][h];\n\n    for(int i=0; i<h; i++)\n      for(int j=0; j<w; j++)\n\tcin>>r[j][i];\n\n    int x,y;\n    for(long l=0; l<n; l++) {\n      x=0,y=0;\n      while(1) {\n\tif(x>w-1 || y>h-1) break;\n\tif(r[x][y]==0) {\n\t  r[x][y]=1;\n\t  y++;\n\t}else{\n\t  r[x][y]=0;\n\t  x++;\n\t}\n      }\n      if(l==n-1) cout<<y+1<<\" \"<<x+1<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)    (x).begin(),(x).end()\n# define UNIQ(c)   (c).erase(unique(ALL((c))), end((c)))\n# define mp        make_pair\n# define eb        emplace_back\n# define REP(i, a) for (int i = 0; i < (a); i++)\n# define INIT      std::ios::sync_with_stdio(false);std::cin.tie(0);\n \nint maze[1010][1010], dp[1010][1010], h, w, n;\n \nint main() {\n\tcin >> h >> w >> n;\n\tfor (int i = 1; i <= h; i++)for (int j = 1; j <= w; j++) {\n\t\tcin >> maze[i][j];\n\t}\n\tn--, dp[1][1] = n;\n \n\tfor (int i = 1; i <= h; i++) for (int j = 1; j <= w; j++) {\n\t\tdp[i][j] += dp[i][j - 1]/2;\n\t\tif (maze[i][j - 1] == 1)dp[i][j] += dp[i][j - 1] % 2;\n\t\tdp[i][j] += dp[i - 1][j] / 2;\n\t\tif (maze[i - 1][j] == 0)dp[i][j] += dp[i - 1][j] % 2;\n\t}\n \n\tint y = 1, x = 1, t, f;\n\twhile (y <= h && x <= w) {\n\t\tf = maze[y][x];\n\t\tif (dp[y][x] % 2)f = !f;\n\t\tif (f == 0)y++;\n\t\telse x++;\n\t}\n \n\tcout << y << \" \" << x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 1010\nusing namespace std;\n\nint mp[MAX][MAX],dp[MAX][MAX];\n\nvoid solve(){\n int h,w,n;\n for(;;){\n  cin>>h>>w>>n;\n  if(!h&&!w&&!n) break;\n  FOR(i,h) FOR(j,w) cin>>mp[i][j];\n  ZERO(dp);\n  dp[0][0]=n-1;\n  FOR(i,h){\n   FOR(j,w){\n    if(i+1!=h) dp[i+1][j]+=(dp[i][j]+mp[i][j]^1)>>1;\n    if(j+1!=w) dp[i][j+1]+=(dp[i][j]+mp[i][j])>>1;\n   }\n  }\n  FOR(i,h) FOR(j,w) if(dp[i][j]&1) mp[i][j]^=1;\n  int x=0,y=0;\n  while(x!=h-1&&y!=w-1){\n   if(mp[x][y]) y++;\n   else x++;\n  }\n  cout<<x<<\" \"<<y<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint m[1000][1000];\nint kai[1001][1001];\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint h,w,n;\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t\tif(h == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < h + 1; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < w + 1; ii++)\n\t\t\t{\n\t\t\t\tkai[i][ii] = 0;\n\t\t\t}\n\t\t}\n\t\tkai[0][0] = n - 1;\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < w; ii++)\n\t\t\t{\n\t\t\t\tint w;\n\t\t\t\tscanf(\"%d\",&w);\n\t\t\t\tif(kai[i][ii] % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tkai[i + 1][ii] += kai[i][ii] / 2;\n\t\t\t\t\tkai[i][ii + 1] += kai[i][ii] / 2;\n\t\t\t\t\tm[i][ii] = w;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(w == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tkai[i + 1][ii] += kai[i][ii] / 2 + 1;\n\t\t\t\t\t\tkai[i][ii + 1] += kai[i][ii] / 2;\n\t\t\t\t\t\tm[i][ii] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tkai[i + 1][ii] += kai[i][ii] / 2;\n\t\t\t\t\t\tkai[i][ii + 1] += kai[i][ii] / 2 + 1;\n\t\t\t\t\t\tm[i][ii] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nowy = 0;\n\t\tint nowx = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tif(nowy == h || nowx == w)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d\\n\",nowy + 1,nowx + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(m[nowy][nowx] == 0)\n\t\t\t{\n\t\t\t\tnowy++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnowx++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint h,w,n;\n\tint dp[101][101];\n\tint map[101][101];\n\tint a,b;\n\tint i,j;\n\t\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta=b=1;\n\t\twhile(a<=h && b<=w){\n\t\t\tif(map[a][b]==0){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",a,b);\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N 2000\n\nlong long x[MAX_N][MAX_N];\nlong long dp[MAX_N][MAX_N];\nint h, w, n, cx, cy;\nint main() {\n\twhile (true) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tcin >> h >> w >> n;\n\t\tif (h == 0 && w == 0 && n == 0) { break; }\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tscanf(\"%d\", &x[i][j]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1] = n - 1;\n\t\tfor (int i = 2; i <= h + w; i++) {\n\t\t\tfor (int j = 1; j <= h; j++) {\n\t\t\t\tint k = i - j;\n\t\t\t\tif (k >= 1 && k <= w) {\n\t\t\t\t\tif (x[j][k] == 0) {\n\t\t\t\t\t\tdp[j][k + 1] += dp[j][k] / 2;\n\t\t\t\t\t\tdp[j + 1][k] += (dp[j][k] + 1) / 2;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[j][k + 1] += (dp[j][k] + 1) / 2;\n\t\t\t\t\t\tdp[j + 1][k] += dp[j][k] / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tx[i][j] += dp[i][j];\n\t\t\t\tx[i][j] %= 2;\n\t\t\t}\n\t\t}\n\t\tcx = 1; cy = 1;\n\t\twhile (cx <= w && cy <= h) {\n\t\t\tif (x[cy][cx] == 0) {\n\t\t\t\tcy++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcx++;\n\t\t\t}\n\t\t}\n\t\tcout << cy << ' ' << cx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dp[1001][1001];\nint s[1001][1001];\nint dx[2] = {0,1};\nint dy[2] = {1,0};\n\nP solve(int w, int h, int n){\n\t// 初期化\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tdp[y][x] = 0;\n\t\t}\n\t}\n\t\n\tdp[0][0] = n;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t// a := (x,y) の通る回数, b := 通った回数が偶数か奇数か.\n\t\t\tint a = dp[y][x];\n\t\t\tint b = a % 2;\n\t\t\t\n\t\t\t// (x1,y1) はもともと書かれた数値に進んだ時の座標\n\t\t\t// (x2,y2) は書かれた数値を反転した時に進んだ時の座標\n\t\t\tint x1 = x + dx[s[y][x]];\n\t\t\tint y1 = y + dy[s[y][x]];\n\t\t\tint x2 = x + dx[s[y][x]^1];\n\t\t\tint y2 = y + dy[s[y][x]^1];\n\t\t\tif( x1 < w && y1 < h )\n\t\t\t\tdp[y1][x1] += (a+b) / 2;\n\t\t\tif( x2 < w && y2 < h )\n\t\t\t\tdp[y2][x2] += (a-b) / 2;\n\t\t}\n\t}\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\ts[y][x] ^= dp[y][x] % 2;\n\t\t}\n\t}\n\t\n\t// シミュレーションで n 回目の散歩の終了時の位置を求める.\n\tint x=0, y=0;\n\twhile( x < w && y < h ){\n\t\tif( s[y][x] ) x += 1;\n\t\telse y += 1;\n\t}\n\treturn P(x,y);\n}\n\nint main(){\n\tint w, h, n;\n\twhile( cin >> h >> w >> n , h || w || n ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\tP p = solve(w,h,n-1);\n\t\tcout << p.second+1 << \" \" << p.first+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\n#define FOR(i,b,n) for(int i=b;i<n;i++)\n#define RFOR(i,b,n) for(int i=n-1;i>=b;i--)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n\nusing namespace std;\n\nstatic const double EPS = 1e-9;\ntypedef long long ll;\ntypedef pair<int, int> paii;\n\nint h, w, n;\nint ma[2000][2000];\n\npaii solve()\n{\n\tpaii res;\n\t\n\tFOR(k, 0, n)\n\t{\n\t\tint i = 0, j = 0;\n\t\t\n\t\twhile( i >= 0 && i < w && j >= 0 && j < h )\n\t\t{\n\t\t\tif( ma[j][i] == 1)//east\n\t\t\t{\n\t\t\t\tma[j][i] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tma[j][i] = 1;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tres.first = i+1;\n\t\tres.second = j+1;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> h >> w >> n, (h||w||n))\n\t{\n\t\tFOR(j, 0, h)\n\t\t\tFOR(i, 0, w)\n\t\t\t{\n\t\t\t\tcin >> ma[j][i];\n\t\t\t}\n\t\t\n\t\tpaii p = solve();\n\t\t\n\t\tcout << p.second << \" \" << p.first << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n \nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint stage[1024][1004];\nint dp[1024][1024];\nint main(){\n    int h,w,n;\n    while(scanf(\"%d%d%d\",&h,&w,&n),(h|w)|n){\n        rep(i,h)rep(j,w)scanf(\"%d\",&stage[i][j]);\n        memset(dp,0,sizeof(dp));\n        dp[0][0] = --n;\n        rep(i,h){\n            rep(j,w){\n                if(dp[i][j] % 2 == 0){\n                    dp[i][j+1] = dp[i][j]/2;\n                    dp[i+1][j] = dp[i][j]/2;\n                 }\n                 else{\n                    if(stage[i][j] == 0){\n                        dp[i+1][j] += dp[i][j]/2 + 1;\n                        dp[i][j+1] += dp[i][j]/2;\n                    }\n                    else if(stage[i][j] == 1){\n                        dp[i+1][j] += dp[i][j]/2;\n                        dp[i][j+1] += dp[i][j]/2 + 1;\n                    }\n                 }\n            }\n        }\n        int x = 0,y = 0;\n        while(x < w && y < h){\n            if(dp[y][x] % 2== 0){\n                if(stage[y][x] == 0)y++;\n                else x++;\n            }\n            else{\n                if(stage[y][x] == 0)x++;\n                else y++;\n            }\n        }\n        printf(\"%d %d\\n\",++y,++x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\npair<int, int> solve(int H, int W, int N, vector<vector<int>> f) {\n\n    vector<vector<int>> dp(H + 1, vector<int>(W + 1, 0));\n    dp[0][0] = N - 1;\n    FOR(y, 0, H) {\n        FOR(x, 0, W) {\n            int num = dp[y][x];\n            if (num % 2 == 0) {\n                dp[y + 1][x] += num / 2;\n                dp[y][x + 1] += num / 2;\n            }\n            else {\n                if (f[y][x] == 0) {\n                    dp[y + 1][x] += num - (num / 2);\n                    dp[y][x + 1] += num / 2;\n                }\n                if (f[y][x] == 1) {\n                    dp[y + 1][x] += num / 2;\n                    dp[y][x + 1] += num - (num / 2);\n                }\n            }\n        }\n    }\n\n    FOR(y, 0, H) {\n        FOR(x, 0, W) {\n            if (dp[y][x] % 2 != 0) {\n                f[y][x] = 1 - f[y][x];\n            }\n        }\n    }\n\n    int y = 0, x = 0;\n    while (true) {\n        int p = f[y][x];\n        if (p == 0) {\n            y += 1;\n        }\n        else {\n            x += 1;\n        }\n\n        if (y == H or x == W) {\n            break;\n        }\n    }\n\n    return make_pair(y, x);\n}\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true) {\n        int H, W, N;\n        cin >> H >> W >> N;\n        if (H == 0 and W == 0 and N == 0) {\n            break;\n        }\n        vector<vector<int>> f(H + 1, vector<int>(W + 1));\n        FOR(y, 0, H) {\n            FOR(x, 0, W) {\n                cin >> f[y][x];\n            }\n        }\n\n        auto ans1 = solve(H, W, N, f);\n        cout << ans1.first + 1 << \" \" << ans1.second + 1 << endl;\n\n    }\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define vvvel vector<vvel>\nvoid mmin(int &a, int b) { a = min(a, b); }\nvoid mmax(int &a, int b) { a = max(a, b); }\nvoid sor(vel &v) { sort(v.begin(), v.end()); }\nsigned main() {\n\tint h, w;\n\tcin >> h >> w;\n\tint n; cin >> n;\n\twhile(h!=0){\n\tvvel wr(h, vel(w));\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> wr[i][j];\n\t\t}\n\t}\n\tvvel ka(h, vel(w));\n\tka[0][0] = n;\n\tfor (int in = 1; in <= h + w-2; in++) {\n\t\tif (in < w) {\n\t\t\tka[0][in] = (ka[0][in-1] +wr[0][in-1]) / 2;\n\t\t}\n\t\tfor (int i = 1; i < h; i++) {\n\t\t\tint j = in - i;\n\t\t\tif (j == 0) {\n\t\t\t\tka[in][0] = (ka[in - 1][0] + 1-wr[in - 1][0]) / 2;\n\t\t\t}\n\t\t\tif (0 < j and j < w) {\n\t\t\t\tka[i][j] = (ka[i - 1][j] + 1 - wr[i - 1][j]) / 2;\n\t\t\t\tka[i][j] += (ka[i][j - 1] + wr[i][j - 1]) / 2;\n\t\t\t}\n\t\t}\n\t}\n\tint ni = 0;\n\tint nj = 0;\n\twhile (ni < h and nj < w) {\n\t\tif ((ka[ni][nj] + wr[ni][nj])%2 == 0) {\n\t\t\tnj++;\n\t\t}\n\t\telse ni++;\n\t}\n\tcout << ni + 1 << \" \" << nj + 1 << endl;\n\tcin >> h >> w >> n;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <map>\n#include <iostream>\n#include <string>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> P;\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse return 0;\n}\n\nint main(){\n\tint H,W,N;\n\twhile(cin >> H >> W >> N&&H){\n\t\tvector<vector<int> > g(H,vector<int>(W));\n\t\tvector<vector<int> > c(H,vector<int>(W));\n\t\tfor(int i=0; i<H; ++i){\n\t\t\tfor(int j=0; j<W; ++j){\n\t\t\t\tcin >> g[i][j];\n\t\t\t}\n\t\t}\n\t\tc[0][0]=N-1;\n\t\tfor(int i=1; i<W; ++i){\n\t\t\tif(c[0][i-1]%2==0) c[0][i]=c[0][i-1]/2;\n\t\t\telse if(g[0][i-1]==0) c[0][i]=(c[0][i-1]-1)/2;\n\t\t\telse c[0][i]=(c[0][i-1]+1)/2;\n\t\t}\n\t\tfor(int i=1; i<H; ++i){\n\t\t\tif(c[i-1][0]%2==0) c[i][0]=c[i-1][0]/2;\n\t\t\telse if(g[i-1][0]==0) c[i][0]=(c[i-1][0]+1)/2;\n\t\t\telse c[i][0]=(c[i-1][0]-1)/2;\n\t\t}\n\t\tfor(int i=1; i<H; ++i){\n\t\t\tfor(int j=1; j<W; ++j){\n\t\t\t\tif(c[i][j-1]%2==0) c[i][j]+=c[i][j-1]/2;\n\t\t\t\telse if(g[i][j-1]==0) c[i][j]+=(c[i][j-1]-1)/2;\n\t\t\t\telse c[i][j]+=(c[i][j-1]+1)/2;\n\t\t\t\tif(c[i-1][j]%2==0) c[i][j]+=c[i-1][j]/2;\n\t\t\t\telse if(g[i-1][j]==0) c[i][j]+=(c[i-1][j]+1)/2;\n\t\t\t\telse c[i][j]+=(c[i-1][j]-1)/2;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<H; ++i) for(int j=0; j<W; ++j) g[i][j]=(c[i][j]%2==0?g[i][j]:f(g[i][j]));\n\t\t\n\t\t{\n\t\t\tint y=0,x=0;\n\t\t\twhile(y!=H&&x!=W){\n\t\t\t\tif(g[y][x]==0) ++y;\n\t\t\t\telse ++x;\n\t\t\t}\n\t\t\tcout << y+1 << ' ' << x+1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nbool grid[1005][1005];\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.walk\", \"r\", stdin );\n\tint h, w, n;\n\twhile (scanf (\"%d %d %d\", &h, &w, &n ), h, w, n ){\n\t\tmemset (grid, false, sizeof (grid ) );\n\t\trep (i, h ){\n\t\t\trep (j, w ){\n\t\t\t\tint in;\n\t\t\t\tscanf (\"%d\", &in );\n\t\t\t\tgrid[i][j] = (in == 1 ? true : false );\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tint row = 0, col = 0;\n\t\twhile (n-- ){\n\t\t\trow = 0, col = 0;\n\t\t\twhile (row < h && col < w ){\n\t\t\t\tif (grid[row][col] ){\t// 1 なら 東\n\t\t\t\t\tgrid[row][col] = false;\n\t\t\t\t\tcol++;\n\t\t\t\t}else{\t\t\t\t\t// 0 なら 南\n\t\t\t\t\tgrid[row][col] = true;\n\t\t\t\t\trow++;\n\t\t\t\t} // end if\n\t\t\t} // end while\n\t\t} // end while\n\t\tprintf (\"%d %d\\n\", row+1, col+1 );\t\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <bits/stdc++.h>\n\nint32_t H,W,N;\nint map[10000][10000];//h,W\nint main()\n{\n\tfor(;;){\n\t\t\n\tscanf(\"%d%d%d\", &H,&W,&N);\n\tif(H==0&&W==0&&N==0){break;}\n\t//getchar();//\\n????????????\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tscanf(\"%d\", &map[i][j]);//map[i][j] -= '0';getchar();//\\n\\s????????????\n\t}}\n\t\t#ifdef DEBUG\n\t\tprintf(\"\\n----\\n\");\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tputchar(map[i][j] +'0');\n\t}putchar('\\n');}printf(\"----\\n\");\n\t\t#endif\n\t\n\tint npos_x=0,npos_y = 0, now_n = N;\n\twhile(npos_x < W && npos_y < H)\n\t{\n\t\t#ifdef DEBUG\n\t\tprintf(\"----\\n\");\n\t\tprintf(\"%d %d %d\\n\", npos_x,npos_y, now_n);\n\t\tprintf(\"%d %d %d\\n\", (now_n&1), map[npos_y][npos_x], (now_n&1) ^ (map[npos_y][npos_x]));\n\t\tprintf(\"----\\n\");\n\t\t#endif\n\t\tif((now_n&1) ^ (map[npos_y][npos_x])){\n\t\t\t++npos_y;\n\t\t}\n\t\telse{\n\t\t\t++npos_x;\n\t\t}\n\t\tnow_n = (now_n>>1)+(now_n&1);\n\t}\n\tprintf(\"%d %d\\n\",npos_y+1, npos_x+1);\n\t\n\t}//for(;;)\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint f[1005][1005];\nint h,w,n;\n\nvoid rec(int x,int y,int ff,int kan)\n{\n\tif(x==h+1 || y==w+1)\n\t{\n\t\tprintf(\"%d %d\\n\",x,y);\n\t\treturn ;\n\t}\n\tbool same;\n\tif((n-ff)%(2*kan)==0) same=true;\n\telse { same=false; ff+=kan;}\n\t\n\tif(f[x][y]&&same) y++;\n\telse if(f[x][y]&&!same) x++;\n\telse if(!f[x][y]&&same) x++;\n\telse y++;\n\tif(n!=ff) kan*=2;\n\trec(x,y,ff,kan);\n}\nint main()\n{\nwhile(1)\n{\n\tscanf(\"%d %d %d\",&h,&w,&n); if(!n) return 0;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&f[i][j]);\n\t\t}\n\t}\n\trec(1,1,1,1);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint times[1001][1001];\nint d[1000][1000];\nint main(){\n\tint a,b,c;\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tif(a==0)return 0;\n\t\tfor(int i=0;i<1001;i++)\n\t\t\tfor(int j=0;j<1001;j++)\n\t\t\t\ttimes[i][j]=0;\n\t\t\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++)\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\n\t\ttimes[0][0]=c-1;\n\t\t\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(times[i][j]%2==0){\n\t\t\t\t\ttimes[i+1][j]+=times[i][j]/2;\n\t\t\t\t\ttimes[i][j+1]+=times[i][j]/2;\n\t\t\t\t}else if(d[i][j]==1){\n\t\t\t\t\ttimes[i+1][j]+=times[i][j]/2;\n\t\t\t\t\ttimes[i][j+1]+=times[i][j]/2+1;\n\t\t\t\t}\n\t\t\t}\n\t\tint x=1,y=1;\n\t\twhile(x<b+1&&y<a+1){\n\t\t\tif((times[y-1][x-1]+d[y-1][x-1])%2==0)y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",y,x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 1010\n \nbool a[MAX][MAX];\nint dp[MAX][MAX];\nint H, W;\n \nbool get_dir(int n, bool dir)\n{\n    return (n % 2 == 0 ? dir : !dir);\n}\n \nvoid find_last_point()\n{\n    int x = 0, y = 0;\n    while (true) {\n        if (a[y][x] == 1) {\n            x++;\n        } else {\n            y++;\n        }\n        if (x >= W || y >= H) break;\n    }\n    cout << y+1 << \" \" << x+1 << endl;\n}\n \nint main()\n{\n    int N;\n    while (cin >> H >> W >> N, H) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = N-1;\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp[i][j] == 0) continue;\n                a[i][j] = get_dir(dp[i][j], a[i][j]);\n                if (dp[i][j] % 2 == 1) {\n                    if (a[i][j] == 0) {\n                        dp[i+1][j] += dp[i][j] / 2;\n                        dp[i][j+1] += dp[i][j] / 2 + 1;\n                    } else {\n                        dp[i+1][j] += dp[i][j] / 2 + 1;\n                        dp[i][j+1] += dp[i][j] / 2;\n                    }\n                } else {\n                    dp[i+1][j] += dp[i][j] / 2;\n                    dp[i][j+1] += dp[i][j] / 2;\n                }\n            }\n        }\n        find_last_point();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; i++)\nint dx[] = {0,1};\nint dy[] = {1,0};\nint dp[1001][1001] = {0};\nbool data[1002][1002] = {{0}}; \n\nint main(){\n\tint h,w,n;\n\twhile(cin >> h >> w >> n , h){\n\t\trep(i,1002)rep(j,1002)dp[i][j] = 0;\n\t\trep(i,h)rep(j,w)cin >> data[i+1][j+1];\n\t\t\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tif(i == 1 && j == 1){\n\t\t\t\t\tdp[i][j] = n-1;\n\t\t\t\t}else{\n\t\t\t\t\tif(dp[i][j]%2 == 0)dp[i][j] += dp[i-1][j] / 2;\n\t\t\t\t\telse if(data[i-1][j] == 0)dp[i][j] += (dp[i-1][j]+1)/2;\n\t\t\t\t\telse dp[i][j] += dp[i-1][j] / 2;\n\t\n\t\t\t\t\tif(dp[i][j]%2 == 0)dp[i][j] += dp[i][j-1] / 2;\n\t\t\t\t\telse if(data[i][j-1] == 1)dp[i][j] += (dp[i][j-1]+1)/2;\n\t\t\t\t\telse dp[i][j] += dp[i][j-1] / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x = 1 , y = 1;\n\t\twhile( x < w+1 && y < h+1){\n\t\t\tint t = (data[y][x]+dp[y][x])%2;\n\t\t\tx += dx[t], y += dy[t];\n\t\t}\n\t\t\n\t\tcout << y << \" \" << x << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nvoid mainmain(){\n\tint h,w,n;\n\twhile(cin>>h>>w>>n,h||w||n){\n\t\tvvint vv;\n\t\tinitvv(vv,h,w);\n\t\tvvint dp=vv;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin>>vv[i][j];\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0]=n-1;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tint a=dp[i][j]/2;\n\t\t\t\tint b=dp[i][j]-a;\n\t\t\t\tif(vv[i][j]){\n\t\t\t\t\tif(j+1<w) dp[i][j+1]+=b;\n\t\t\t\t\tif(i+1<h) dp[i+1][j]+=a;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j+1<w) dp[i][j+1]+=a;\n\t\t\t\t\tif(i+1<h) dp[i+1][j]+=b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(dp[i][j]%2) vv[i][j]=1-vv[i][j];\n\t\t\t}\n\t\t}\n\t\tint x=0,y=0;\n\t\twhile(1){\n\t\t\tif(y==h||x==w){\n\t\t\t\tcout<<y+1<<\" \"<<x+1<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vv[y][x]){\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\t\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream.h>\nint num[1005][1005],h,w,n;\npair<int,int>p;\nint main(){\nwhile(1){\nscanf(\"%d %d %d\",&h,&w,&n);\nfor(int i=1;i<=h;i++){\nfor(int j=1;j<=w;j++){\nscanf(\"%d\",&num[j][i]);\n}\n}\nint y=1,s=1,cou=0;\nwhile(1){\ncou++;\nif(num[y][s]){\ny++;\nnum[y][s]=(num[y][s]+1)%2;\np=make_pair(y,s);\n}else{\nnum[y][s]=(num[y][s]+1)%2;\ns++;\np=make_pair(y,s);\n}\nif(cou==n){\ncout << p.first << \" \" << p.second << endl; return 0;\n}\nif(p.first==1 && p.second==h){\ncout << p.first <<\" \"<< p.second << endl; return 0;\n}\nif(p.first==w && p.second==1){\ncout << p.first <<\" \"<<p.second <<endl; return 0;\n}\n}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <bits/stdc++.h>\n#undef DEBUG\nint32_t H,W,N;\nint map[10000][10000];//h,W\nint mapn[10000][10000]={};//h,W\nint main()\n{\n\tfor(;;){\n\t\t\n\tscanf(\"%d%d%d\", &H,&W,&N);\n\tif(H==0&&W==0&&N==0){break;}\n\t//getchar();//\\n????????????\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tscanf(\"%d\", &map[i][j]);//map[i][j] -= '0';getchar();//\\n\\s????????????\n\t}}\n\t\t#ifdef DEBUG\n\t\tprintf(\"\\n----\\n\");\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tputchar(map[i][j] +'0');\n\t}putchar('\\n');}printf(\"----\\n\");\n\t\t#endif\n\t//?????£????????°\n\tmapn[0][0] = N;\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tmapn[i+1][j] += mapn[i][j]>>1;\n\t\tmapn[i][j+1] += mapn[i][j]>>1;\n\t\tif(mapn[i][j]&1){\n\t\t\tif((mapn[i][j]&1) ^ map[i][j]){\n\t\t\t\t++mapn[i+1][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++mapn[i][j+1];\n\t\t\t}\n\t\t}\n\t}}\n\tint32_t npos_x=0,npos_y = 0, now_n = N;\n\twhile(npos_x < W && npos_y < H)\n\t{\n\t\t#ifdef DEBUG\n\t\tprintf(\"----\\n\");\n\t\tprintf(\"%d %d %d\\n\", npos_x,npos_y, now_n);\n\t\tprintf(\"%d %d %d\\n\", (now_n&1), map[npos_y][npos_x], (now_n&1) ^ (map[npos_y][npos_x]));\n\t\tprintf(\"----\\n\");\n\t\t#endif\n\t\tif((now_n&1) ^ map[npos_y][npos_x]){\n\t\t\t++npos_y;\n\t\t}\n\t\telse{\n\t\t\t++npos_x;\n\t\t}\n\t\tnow_n = (now_n/2)+(now_n&1);\n\t}\n\tprintf(\"%d %d\\n\",npos_y+1, npos_x+1);\n\t\n\t}//for(;;)\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint h,w,k;\nint field[1001][1001];\n\nint main(){\n\n\twhile(cin>>h>>w>>k&&!(h==0&&w==0&&k==0)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tint cx,cy;\n\t\t\tcx=cy=0;\n\t\t\twhile(1){\n\t\t\t\tif(cx>=w||cy>=h)\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cy][cx]){\n\t\t\t\t\tfield[cy][cx]=0;\n\t\t\t\t\tcx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfield[cy][cx]=1;\n\t\t\t\t\tcy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==k-1){\n\t\t\t\tcout<<cy+1<<\" \"<<cx+1<<endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int *x) { int k, m = 0; *x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { *x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; *x = (*x) * 10 + k - '0'; }if (m)(*x) = -(*x); }\nvoid reader(int *x, int *y) { reader(x); reader(y); }\nvoid reader(int *x, int *y, int *z) { reader(x); reader(y); reader(z); }\nvoid writer(int x, char c) { int i, sz = 0, m = 0; char buf[10]; if (x<0)m = 1, x = -x; while (x)buf[sz++] = x % 10, x /= 10; if (!sz)buf[sz++] = 0; if (m)mypc('-'); while (sz--)mypc(buf[sz] + '0'); mypc(c); }\n\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (reader(&h, &w, &n), h) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i || j)getchar_unlocked(); a[i][j] = getchar_unlocked() - '0';\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] >> 1;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) >> 1;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) >> 1;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] >> 1;\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif ((dp[x][y] ^ a[x][y]) & 1)y++;\n\t\t\telse x++;\n\t\t}\n\t\twriter(x + 1, ' '); writer(y + 1, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int Height = 1000;\nconst int Width = 1000;\nbool b_map[Height][Width];\nint i_map[Height+1][Width+1];\n\nint main()\n{\n\tint h, w, n;\n\twhile(cin >> h >> w >> n, h | w | n)\n\t{\n\t\tfor(int y=0; y < h; y++)\n\t\t\tfor(int x=0; x < w; x++) {\n\t\t\t\tcin >> b_map[y][x];\n\t\t\t\ti_map[y][x] = 0;\n\t\t\t}\n\t\tfor(int y=0; y < h; y++) i_map[y][w] = 0;\n\t\tfor(int x=0; x < w; x++) i_map[h][x] = 0;\n\t\ti_map[0][0] = n - 1;\n\t\tfor(int y=0; y < h; y++)\n\t\t\tfor(int x=0; x < w; x++) {\n\t\t\t\tif(!i_map[y][x]) continue;\n\t\t\t\tint num = i_map[y][x] >> 1;\n\t\t\t\tif(i_map[y][x] & 1) {\n\t\t\t\t\tif(b_map[y][x]) {\n\t\t\t\t\t\ti_map[y][x+1] += num + 1;\n\t\t\t\t\t\ti_map[y+1][x] += num;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ti_map[y][x+1] += num;\n\t\t\t\t\t\ti_map[y+1][x] += num + 1;\n\t\t\t\t\t}\n\t\t\t\t\tb_map[y][x] = !b_map[y][x];\n\t\t\t\t}\n\t\t\t\telse  {\n\t\t\t\t\ti_map[y+1][x] += num;\n\t\t\t\t\ti_map[y][x+1] += num;\n\t\t\t\t}\n\t\t\t}\n\t\tint x, y;\n\t\tx = y = 0;\n\t\tdo {\n\t\t\tif(b_map[y][x])\n\t\t\t\tx++;\n\t\t\telse\n\t\t\t\ty++;\n\t\t}while(x < w && y < h);\n\t\tcout << y+1 << ' ' << x+1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint num[1005][1005],h,w,n;\npair<int,int>p;\nint main(){\nwhile(1){\nscanf(\"%d %d %d\",&h,&w,&n);\nfor(int i=1;i<=h;i++){\nfor(int j=1;j<=w;j++){\nscanf(\"%d\",&num[j][i]);\n}\n}\nint y=1,s=1,cou=0;\nwhile(1){\ncou++;\nif(num[y][s]){\ny++;\nnum[y][s]=(num[y][s]+1)%2;\np=make_pair(y,s);\nbreak;\n}else{\nnum[y][s]=(num[y][s]+1)%2;\ns++;\np=make_pair(y,s);\n}\nif(cou==n){\ncout << p.first << \" \" << p.second << endl; return 0;\n}\nif(p.first==1 && p.second==h){\ncout << p.first <<\" \"<< p.second << endl; return 0;\n}\nif(p.first==w && p.second==1){\ncout << p.first <<\" \"<<p.second <<endl; return 0;\n}\n}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#include <cstdlib>\n\n#include <cmath>\n\n#include <climits>\n\n#include <cfloat>\n\n#include <map>\n\n#include <utility>\n\n#include <set>\n\n#include <iostream>\n\n#include <memory>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <functional>\n\n#include <sstream>\n\n#include <complex>\n\n#include <stack>\n\n#include <queue>\n\n#include <numeric>\n\n#include <cstring>\n\n\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\n#define pb push_back\n\n\n\nusing namespace std;\n\n\n\ntypedef long long ll;\n\ntypedef pair<int, int> P;\n\ntypedef vector<int> vi;\n\ntypedef vector<vi> vvi;\n\n\n\nconst int INF = 1 << 29;\n\nconst double EPS = 1e-9;\n\n\n\nint main(){\n\n\tint N, H, W;\n\n\tvvi field;\n\n\tint mx, my;\n\n\tint n;\n\n\n\n\twhile(1){\n\n\t\tcin >> H >> W >> N;\n\n\t\tif(H == 0 && W == 0 && N == 0) break;\n\n\n\n\t\tfield.resize(H);\n\n\t\trep(i, H){\n\n\t\t\tfield[i].resize(W);\n\n\t\t\trep(j, W){\n\n\t\t\t\tcin >> field[i][j];\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\tn = N % (H + W);\n\n\t\tif(N >= H + W) n++;\n\n\n\n\t\trep(i, n){\n\n\t\t\tmx = 0, my = 0;\n\n\t\t\twhile(my < H && mx < W){\n\n\t\t\t\tif(field[my][mx] == 0){\n\n\t\t\t\t\tfield[my][mx] = 1;\n\n\t\t\t\t\tmy += 1;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tfield[my][mx] = 0;\n\n\t\t\t\t\tmx += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmy++, mx++;\n\n\t\tcout << my << \" \" << mx << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(void){\n\t\n\tstatic int h,w,n,grid[1001][1001],dp[1001][1001];\n\n\twhile(cin >> h >> w >> n,h|w|n){\n\t\tfor(int i=1;i<=h;i++)\n\t\t\tfor(int j=1;j<=w;j++)\n\t\t\t\tcin >> grid[i][j];\n\t\t\n\t\tfill(dp[0],dp[1001],0);\n\t\tdp[1][1]=n-1;\n\t\t\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tdp[i][j+1]+=(dp[i][j]+grid[i][j])>>1;\n\t\t\t\tdp[i+1][j]+=(dp[i][j]+!grid[i][j])>>1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=0;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2)grid[i][j]^=dp[i][j]&1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x=1,y=1;\n\t\twhile(true){\n\t\t\tif(y>h || x>w)break;\n\t\t\tif(grid[y][x])x++;\n\t\t\telse y++;\n\t\t}\n\t\t\n\t\tcout << y << \" \" << x << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint main(){\n\tint H,W,N;\n\tint cMap[1003][1003];\n  int Map[1003][1003];\n\twhile(true){\n\t  \n\t    for(int i=0;i<1100;i++)for(int J=0;J<1100;J++)cMap[J][i] = 0;\n\t    cin >> H >> W >> N;\n\t    if(H+W+N == 0)break;\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t  cin >> Map[i][j];\n\t\t}\n\t    }\n\t    cMap[1][1] = N;//奇数ならそのまま偶数なら別\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\n\t\t    cMap[i][j+1] += cMap[i][j]/2; \n\t\t    cMap[i+1][j] += cMap[i][j]/2;\n\t\t    if(cMap[i][j]%2 != 0 ){\n\t\t\tif(Map[i][j] == 1){\n\t\t\t    cMap[i][j+1]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t    cMap[i+1][j]++;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  \n\t    int x,y;\n\t    x = y = 1;\n\t    while(1<= y && y <= H && 1<= x && x<= W){\n\t\tif(cMap[y][x]%2 == 0){\n\t\t    if(Map[y][x] == 1)y++;\n\t\t    else x++;\n\t\t}\n\t\telse{\n\t\t    if(Map[y][x] == 1)x++;\n\t\t    else y++;\n\t\t    \n\t\t}\n\t    }\n\t    cout << y << \" \" << x << endl;\n\n\t}\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int h,w;\n  long n;\n  while(1) {\n    cin>>h>>w>>n;\n    if(h==0&&w==0&&n==0) break;\n\n    int r[w][h];\n\n    for(int i=0; i<h; i++)\n      for(int j=0; j<w; j++)\n\tcin>>r[j][i];\n\n    int x,y;\n    for(long l=0; l<n-1; l++) {\n      x=0,y=0;\n      while(1) {\n\tif(x>w-1 || y>h-1) break;\n\tif(r[x][y]==0) {\n\t  r[x][y]=1;\n\t  y++;\n\t}else{\n\t  r[x][y]=0;\n\t  x++;\n\t}\n      }\n    }\n\n    x=0,y=0;\n    while(1) {\n      if(x>w-1 || y>h-1) break;\n      if(r[x][y]==0) {\n\tr[x][y]=1;\n\ty++;\n      }else{\n\tr[x][y]=0;\n\tx++;\n      }\n    }\n    cout<<y+1<<\" \"<<x+1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nint mo[5] = {0,1,0,-1,0};\n\nvoid calc(int h,int w,int n){\n    int in[1000][1000],dp[1001][1001]={0},x,y;\n    \n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n            scanf(\"%d\",&in[i][j]);\n    \n    dp[0][0]=n-1;\n    \n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++){\n            dp[i+1][j]+=(dp[i][j]+1-in[i][j])/2;\n            dp[i][j+1]+=(dp[i][j]+in[i][j])/2;\n        }\n    \n    while(x<w && y<h){\n        if((dp[y][x]+in[y][x])%2)\n            x++;\n        else\n            y++;\n    }\n    \n    printf(\"%d %d\\n\",y+1,x+1);\n    \n}\n\nint main(){\n    int h,w,n;\n    \n    while(1){\n        scanf(\"%d%d%d\",&h,&w,&n);\n        \n        if(h==0) break;\n        \n        calc(h,w,n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nqueue<POS> check;\nlong n,field[201][201];//,next[201][201];\nbool flag[201][201];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    /*    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n      }*/\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    //    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    /*    while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n      }*/\n    /*    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n      }*/\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint h,w,n;\nint a[1002][1002],b[1002][1002]={0};\n\npair<int,int> walk(int x,int y){\n\tif(a[x][y]==0)x++;\n\telse y++;\n\tif(x<h&&y<w)return walk(x,y);\n\tpair<int,int>ret; ret.first=x+1; ret.second=y+1; return ret;\n}\n\nint main(){\nwhile(1){\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tif(h==0)break;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tb[0][0]=n-1;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tb[i][j+1]+=b[i][j]/2;\n\t\t\tb[i+1][j]+=b[i][j]/2;\n\t\t\tif(b[i][j]%2==1){\n\t\t\t\tif(a[i][j]==0)b[i+1][j]++;\n\t\t\t\telse b[i][j+1]++;\n\t\t\t}\n\t\t\ta[i][j]+=b[i][j];\n\t\t\ta[i][j]%=2;\n\t\t}\n\t}\n\tpair<int,int> ret=walk(0,0);\n\tprintf(\"%d %d\\n\",ret.first,ret.second);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dp[1001][1001];\nint map[1001][1001];\nint main(void)\n{\n\tint h,w,n;\n\tint a,b;\n\tint i,j;\n\t\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t\telse if(dp[i][j]%2!=0){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]==0){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\t\t\n\t\ta=b=1;\n\t\twhile(a<=h && b<=w){\n\t\t\tif(map[a][b]==0){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if(map[a][b]==1){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",a,b);\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int *x) { int k, m = 0; *x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { *x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; *x = (*x) * 10 + k - '0'; }if (m)(*x) = -(*x); }\nvoid reader(int *x, int *y) { reader(x); reader(y); }\nvoid reader(int *x, int *y, int *z) { reader(x); reader(y); reader(z); }\nvoid writer(int x, char c) { int i, sz = 0, m = 0; char buf[10]; if (x<0)m = 1, x = -x; while (x)buf[sz++] = x % 10, x /= 10; if (!sz)buf[sz++] = 0; if (m)mypc('-'); while (sz--)mypc(buf[sz] + '0'); mypc(c); }\n\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (reader(&h, &w, &n), h) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tgetchar_unlocked(); a[i][j] = getchar_unlocked() - '0';\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] >> 1;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) >> 1;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) >> 1;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] >> 1;\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif ((dp[x][y] ^ a[x][y]) & 1)y++;\n\t\t\telse x++;\n\t\t}\n\t\twriter(x + 1, ' '); writer(y + 1, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nbool mp[1002][1002];\nint count[1002][1002];\nint main(){\n    int h,w,n;\n    while(cin>>h>>w>>n,h){\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                cin>>mp[i][j];\n            }\n        }\n        memset(count,0,h*w*sizeof(int));\n        count[0][0]=n-1;\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                mp[i][j]=mp[i][j]^(count[i][j]%2);\n                count[i][j+1] += (count[i][j]+!mp[i][j])/2;\n                count[i+1][j] += (count[i][j]+mp[i][j])/2;\n            }\n        }\n        int x=0,y=0;\n        while(x<w&&y<h){\n            if(mp[y][x]) ++x;\n            else ++y;\n        }\n        cout<<y+1<<\" \"<<x+1<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    while (true) {\n        int h, w, n;\n        cin >> h >> w >> n;\n        if (h == 0)break;\n        vector<vector<bool>> east(h, vector<bool>(w));\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                int x;\n                cin >> x;\n                east[i][j] = x == 1;\n            }\n        }\n\n        vector<vector<int>> dp(h, vector<int>(w));\n        dp[0][0] = n - 1;\n        for (int sum = 0; sum <= h + w - 2; sum++) {\n            for (int i = 0; i < h; i++) {\n                int j = sum - i;\n                if (0 <= j && j < w) {\n                    if (i + 1 < h) {\n                        dp[i + 1][j] += dp[i][j] / 2;\n                        if (!east[i][j])dp[i + 1][j] += dp[i][j] % 2;\n                    }\n                    if (j + 1 < w) {\n                        dp[i][j + 1] += dp[i][j] / 2;\n                        if (east[i][j])dp[i][j + 1] += dp[i][j] % 2;\n                    }\n                    east[i][j] = (east[i][j] == (dp[i][j] % 2 == 0));\n                }\n            }\n        }\n\n        int retx = 0, rety = 0;\n        while (retx < h && rety < w) {\n            if (east[retx][rety])rety++;\n            else retx++;\n        }\n\n        cout << retx + 1 << \" \" << rety + 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, N) for(int i = 0; i < N; i++)\n\nsigned main()\n{\n  int H, W, N;\n  int mas[1005][1005];\n  while(cin >> H >> W >> N, H || W || N) {\n    \n    Rep(i, H) Rep(j, W) cin >> mas[i][j];\n    \n    int x = 0, y = 0; --N;\n    \n    while(x < W && y < H) {\n      if((N + mas[y][x]) & 1) x++;\n      else y++;\n      N /= 2;\n    }\n    \n    cout << y + 1 << \" \" << x + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint main(){\n\tint H,W,N;\n\tint cMap[100][100];\n  int Map[100][100];\n\twhile(true){\n\t  \n\t    for(int i=0;i<1100;i++)for(int J=0;J<1100;J++)cMap[J][i] = 0;\n\t    cin >> H >> W >> N;\n\t    if(H+W+N == 0)break;\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t  cin >> Map[i][j];\n\t\t}\n\t    }\n\t    cMap[1][1] = N;//奇数ならそのまま偶数なら別\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\n\t\t    cMap[i][j+1] += cMap[i][j]/2; \n\t\t    cMap[i+1][j] += cMap[i][j]/2;\n\t\t    if(cMap[i][j]%2 != 0 ){\n\t\t\tif(Map[i][j] == 1){\n\t\t\t    cMap[i][j+1]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t    cMap[i+1][j]++;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  \n\t    int x,y;\n\t    x = y = 1;\n\t    while(1<= y && y <= H && 1<= x && x<= W){\n\t\tif(cMap[y][x]%2 == 0){\n\t\t    if(Map[y][x] == 1)y++;\n\t\t    else x++;\n\t\t}\n\t\telse{\n\t\t    if(Map[y][x] == 1)x++;\n\t\t    else y++;\n\t\t    \n\t\t}\n\t    }\n\t    cout << y << \" \" << x << endl;\n\n\t}\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_H 1111\nint H,W,N;\nint ro[MAX_H][MAX_H];\nint cou[MAX_H][MAX_H];\n\nint ro1[MAX_H][MAX_H];\n\nint main()\n{\n\twhile(true){\n\tscanf(\"%d%d%d\",&H,&W,&N);\n\tif(H==0)break;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%d\",&ro[i][j]);ro1[i][j]=ro[i][j];\n\t\t}\n\t}\n\tcou[0][0]=N-1;\n\tfor(int j=0;j<W;j++){\n\t\tif(cou[0][j]&1){\n\t\t\tif(ro[0][j]==1){\n\t\t\t\tcou[0][j+1]=1+(cou[0][j]>>1);\n\t\t\t\tcou[1][j]=cou[0][j]-cou[0][j+1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcou[1][j]=1+(cou[0][j]>>1);\n\t\t\t\tcou[0][j+1]=cou[0][j]-cou[1][j];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcou[0][j+1]=(cou[0][j]>>1);\n\t\t\tcou[1][j]=(cou[0][j]>>1);\n\t\t}\n\t}\n\tfor(int i=1;i<H;i++){\n\t\tfor(int j=1;j<W;j++){\n\t\t\tif(cou[i][j]&1){\n\t\t\t\tif(ro[i][j]==1){\n\t\t\t\t\tcou[i][j+1]=1+(cou[i][j]>>1);\n\t\t\t\t\tcou[i+1][j]=cou[i][j]-cou[i][j+1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcou[i+1][j]=1+(cou[i][j]>>1);\n\t\t\t\t\tcou[i][j+1]=cou[i][j]-cou[i+1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcou[i][j+1]=(cou[i][j]>>1);\n\t\t\t\tcou[i+1][j]=(cou[i][j]>>1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tro[i][j]=(ro[i][j]+cou[i][j])&1;\n\t\t}\n\t}\n\tint ans1=0,ans2=0;\n\twhile(ans1<H&&ans2<W){\n\t\tif(ro[ans1][ans2]==1){\n\t\t\tans2++;\n\t\t}\n\t\telse{\n\t\t\tans1++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",ans1+1,ans2+1);\n\t}\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tint now1=0,now2=0;\n\t\twhile(now1<H&&now2<W){\n\t\t\tif(ro1[now1][now2]==1){\n\t\t\t\tro1[now1][now2]=0;\n\t\t\t\tnow2++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tro1[now1][now2]=1;\n\t\t\t\tnow1++;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(i==N-1){\n\t\t\tprintf(\"%d %d\\n\",now1+1,now2+1);\n\t\t}\n\t}*/\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint H,W,N;\nint field[1000][1000];\t//東0,南1\nint DP[1001][1001];\nbool done[1001][1001] = {false};\n//N-1回の散歩で通った回数を考える\nvoid makeroot(int y,int x){\n\tif(y == H || x == W || done[y][x] == true)\n\t\treturn;\n\tif((x==0&&y==0)||(x==0&&done[y-1][x])||(y==0&&done[y][x-1])||(x>0&&y>0&&done[y][x-1]&&done[y-1][x]))\n\t\tdone[y][x] = true;\n\telse\n\t\treturn;\n\tif(field[y][x]){\n\t\tDP[y][x+1] += (DP[y][x]+1)/2;\n\t\tDP[y+1][x] += DP[y][x]/2;\n\t}\n\telse{\n\t\tDP[y][x+1] += DP[y][x]/2;\n\t\tDP[y+1][x] += (DP[y][x]+1)/2;\n\t}\n\tmakeroot(y,x+1);\n\tmakeroot(y+1,x);\n}\npair<int,int> walk(int y,int x){\n\tif(y == H || x == W){\n\t\tpair<int,int> p;\n\t\tp.first = y;\n\t\tp.second = x;\n\t\treturn p;\n\t}\n\tif((field[y][x]+DP[y][x])%2)\n\t\treturn walk(y,x+1);\n\telse\n\t\treturn walk(y+1,x);\n}\nint main(){\n\tint i,j;\n\tpair<int,int> pos[200];\n\tint pcor = 0;\n\twhile(1){\n\t\tcin>>H>>W>>N;\n\t\tif(H==0&&W==0&&N==0)\n\t\t\tbreak;\n\t\tfor(i=0;i<H;i++){\n\t\t\tfor(j=0;j<W;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=H;i++){\n\t\t\tfor(j=0;j<=W;j++){\n\t\t\t\tDP[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tDP[0][0] = N-1;\n\t\tmakeroot(0,0);\n\t\tpos[pcor] = walk(0,0);\n\t\tpcor++;\n\t}\n\tfor(i = 0;i < pcor;i++)\n\t\tcout << pos[i].first+1 << \" \" << pos[i].second+1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint dp[1010][1010];\nbool fld[1010][1010];\nint main(){\n\tint h,w,n;\n\twhile(1){\n\t\tcin>>h>>w>>n;\n\t\tif(h==0&&w==0&&n==0)break;\n\t\tREP(i,h)REP(j,w)cin>>fld[j][i];\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=n-1;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tif(j!=0){\n\t\t\t\t\tdp[j][i]+=dp[j-1][i]/2;\n\t\t\t\t\tif(dp[j-1][i]&1&&fld[j-1][i])dp[j][i]++;\n\t\t\t\t}\n\t\t\t\tif(i!=0){\n\t\t\t\t\tdp[j][i]+=dp[j][i-1]/2;\n\t\t\t\t\tif(dp[j][i-1]&1&&!fld[j][i-1])dp[j][i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i,h)REP(j,w)fld[j][i]=(fld[j][i]+dp[j][i])%2;\n\t\tint nx=0,ny=0;\n\t\twhile(nx<w&&ny<h){\n\t\t\tif(fld[nx][ny])nx++;\n\t\t\telse ny++;\n\t\t}\n\t\tcout<<ny+1<<\" \"<<nx+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T>\nvector<vector<T> > make_v(size_t a,size_t b){\n  return vector<vector<T> >(a,make_v<T>(b));\n}\ntemplate<typename T>\nvector<vector<vector<T> > > make_v(size_t a,size_t b,size_t c){\n  return vector<vector<vector<T> > > (a,make_v<T>(b,c));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int h,w,n;\n  while(cin>>h>>w>>n,n){\n    auto z=make_v<Int>(h,w);\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcin>>z[i][j];\n    \n    n--;\n    auto dp=make_v<Int>(h+1,w+1);\n    fill_v(dp,0);\n    dp[0][0]=n;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tdp[i][j+1]+=(dp[i][j]+ z[i][j])/2;\n\tdp[i+1][j]+=(dp[i][j]+!z[i][j])/2;\n\tz[i][j]^=(dp[i][j]&1);\n      }\n    }\n    Int y=0,x=0;\n    while(y<h&&x<w){\n      if(z[y][x]) x++;\n      else y++;\n    }\n    cout<<y+1<<\" \"<<x+1<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int h, w, n; cin >> h >> w >> n, h;) {\n\t\tvector<vector<int> > east(h, vector<int>(w));\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tcin >> east[i][j];\n\n\t\tint x = 0, y = 0;\n\t\twhile(x < w && y < h) {\n\t\t\tint num_east = n - n / 2, num_south = n / 2;\n\t\t\tif(!east[y][x])\n\t\t\t\tswap(num_east, num_south);\n\n\t\t\tif((n + east[y][x]) & 1) {\n\t\t\t\t++y;\n\t\t\t\tn = num_south;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++x;\n\t\t\t\tn = num_east;\n\t\t\t}\n\t\t}\n\n\t\tcout << y + 1 << \" \" << x + 1 << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dp[1001][1001];\nint map[1001][1001];\nint main(void)\n{\n\tint h,w,n;\n\tint a,b;\n\tint i,j;\n\t\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\t\t\n\t\ta=b=1;\n\t\twhile(a<=h && b<=w){\n\t\t\tif(map[a][b]==0){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",a,b);\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nint h,w,k;\nint field[1001][1001];\nint loop[1001][1001];\n\ntypedef pair<int,int> P;\n\nconst int dy[]={0,-1,1,0};\nconst int dx[]={-1,0,0,1};\n\ntypedef long long ll;\n\nvoid dp(){\n\tmemset(loop,0,sizeof(loop));\n\tloop[0][0]=1;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tint prvy=i-1;\n\t\t\tint prvx=j;\n\t\t\tif(prvy>=0&&prvx>=0&&prvy<h&&prvx<w){\n\t\t\t\tloop[i][j]+=loop[prvy][prvx];\n\t\t\t}\n\t\t\tprvy=i;\n\t\t\tprvx=j-1;\n\t\t\tif(prvy>=0&&prvx>=0&&prvy<h&&prvx<w){\n\t\t\t\tloop[i][j]+=loop[prvy][prvx];\n\t\t\t}\n\t\t}\n\t}\n}\n\nll gcd(ll a,ll b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\treturn a*b/gcd(a,b);\n}\n\nint main(){\n\n\twhile(cin>>h>>w>>k&&!(h==0&&w==0&&k==0)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>field[i][j];\n\t\t\t}\n\t\t}\n\t\tdp();\n\t\t// ½ñÀsµ½çSÌÆµÄ[v·é©\n\t\tll ln=1;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tln=lcm(ln,loop[i][j]);\n\t\t\t}\n\t\t}\n\t\tll num=k%ln;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tint cx,cy;\n\t\t\tcx=cy=0;\n\t\t\twhile(1){\n\t\t\t\tif(cx>=w||cy>=h)\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cy][cx]){\n\t\t\t\t\tfield[cy][cx]=0;\n\t\t\t\t\tcx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfield[cy][cx]=1;\n\t\t\t\t\tcy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==k-1){\n\t\t\t\tcout<<cy+1<<\" \"<<cx+1<<endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#include <cstdlib>\n\n#include <cmath>\n\n#include <climits>\n\n#include <cfloat>\n\n#include <map>\n\n#include <utility>\n\n#include <set>\n\n#include <iostream>\n\n#include <memory>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <functional>\n\n#include <sstream>\n\n#include <complex>\n\n#include <stack>\n\n#include <queue>\n\n#include <numeric>\n\n#include <cstring>\n\n\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\n#define pb push_back\n\n\n\nusing namespace std;\n\n\n\ntypedef long long ll;\n\ntypedef pair<int, int> P;\n\ntypedef vector<int> vi;\n\ntypedef vector<vi> vvi;\n\n\n\nconst int INF = 1 << 29;\n\nconst double EPS = 1e-9;\n\n\n\nint main(){\n\n\tint N, H, W;\n\n\tvvi field;\n\n\tint mx, my;\n\n\tint n;\n\n\n\n\twhile(1){\n\n\t\tcin >> H >> W >> N;\n\n\t\tif(H == 0 && W == 0 && N == 0) break;\n\n\n\n\t\tfield.resize(H);\n\n\t\trep(i, H){\n\n\t\t\tfield[i].resize(W);\n\n\t\t\trep(j, W){\n\n\t\t\t\tcin >> field[i][j];\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\tn = N % (H + W);\n\n\t\tif(N >= H % W) n++;\n\n\n\n\t\trep(i, n){\n\n\t\t\tmx = 0, my = 0;\n\n\t\t\twhile(my < H && mx < W){\n\n\t\t\t\tif(field[my][mx] == 0){\n\n\t\t\t\t\tfield[my][mx] = 1;\n\n\t\t\t\t\tmy += 1;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tfield[my][mx] = 0;\n\n\t\t\t\t\tmx += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmy++, mx++;\n\n\t\tcout << my << \" \" << mx << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nbool grid[1000][1000];\nint num[1001][1001],i,j,h,w,n,t;\n\nint main(){\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&t);\n\tgrid[i][j] = t?true:false;\n\tnum[i][j] = 0;\n      }\n\n    num[0][0] = n-1;\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tint N=num[i][j];\n\tif(grid[i][j]){\n\t  num[i+1][j] += N/2;\n\t  num[i][j+1] += N-N/2;\n\t}else{\n\t  num[i][j+1] += N/2;\n\t  num[i+1][j] += N-N/2;\n\t}\n\tif(N&1)grid[i][j] = !grid[i][j];\n      }\n\n    i=j=0;\n    while(i<h && j<w)grid[i][j]?j++:i++;\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nvoid solve(int H,int W,int N) {\n    int moji[H][W];\n    int cnt[H+1][W+1];\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            cin >> moji[i][j]; // 0->south / 1->east\n        }\n    }\n\n    // count visits for N-1 walk\n    cnt[0][0]=N-1;\n    for(int j=0; j<W-1; ++j) {\n        cnt[0][j+1]=(cnt[0][j]+moji[0][j])/2;\n    }\n    for(int i=0; i<H-1; ++i) {\n        cnt[i+1][0]=(cnt[i][0]+1-moji[i][0])/2;\n    }\n    for(int i=0; i<H-1; ++i) {\n        for(int j=0; j<W-1; ++j) {\n            cnt[i+1][j+1]=(cnt[i+1][j]+moji[i+1][j])/2+(cnt[i][j+1]+1-moji[i][j+1])/2;\n        }\n    }\n    // calculate status after N-1 walk\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            moji[i][j]=(moji[i][j]+cnt[i][j])%2;\n        }\n    }\n    // Nth walk\n    int h=0, w=0;\n    while(h<H && w<W) {\n        if(moji[h][w]==0) ++h;\n        else ++w;\n    }\n    cout << h+1 << \" \" << w+1 << endl;\n\n    return;\n}\n\nint main() {\n    int H,W,N;\n    while(true) {\n        cin >> H >> W >> N;\n        if(H==0 && W==0 && N==0) break;\n        solve(H,W,N);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nconst int MOD=100000;\nint B=1000000;\nint main(){\n      int h,w,n;\n      while(cin>>h>>w>>n&&(h||w||n)){\n            bool fld[w][h];\n            REP(i,h)REP(j,w)cin>>fld[j][i];\n            int cnt[w][h];\n            memset(cnt,0,sizeof(cnt));\n            cnt[0][0]=n-1;\n            REP(i,h-1)REP(j,w-1){\n                  if(fld[j][i]){\n                        cnt[j+1][i]+=(cnt[j][i]+1)/2;\n                        cnt[j][i+1]+=cnt[j][i]/2;\n                  }else{\n                        cnt[j+1][i]+=cnt[j][i]/2;\n                        cnt[j][i+1]+=(cnt[j][i]+1)/2;\n                  }\n            }\n            REP(i,h)REP(j,w)if(cnt[j][i]%2)fld[j][i]^=1;\n            int x=0,y=0;\n            while(x<w&&y<h){\n                  if(fld[x][y])x++;\n                  else y++;\n            }\n            cout<<y+1<<\" \"<<x+1<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint dp[1001][1001];\n\nint main(void)\n{\n\tint h, w;\n\tint n;\n\tchar field[1000][1000];\n\tint x, y;\n\t\n\twhile (1){\n\t\t\n\t\tscanf(\"%d%d%d\", &h, &w, &n);\n\t\t\n\t\tif (h == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tscanf(\"%d\", &field[x][y]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(dp, 0, sizeof(dp));\n\t\t\n\t\tdp[0][0] = n - 1;\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tif (dp[x][y] % 2 == 0){\n\t\t\t\t\tdp[x][y + 1] += dp[x][y] / 2;\n\t\t\t\t\tdp[x + 1][y] += dp[x][y] / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[x + 1][y] += field[x][y] == 1 ? dp[x][y] / 2 + 1 : dp[x][y] / 2;\n\t\t\t\t\tdp[x][y + 1] += field[x][y] == 0 ? dp[x][y] / 2 + 1 : dp[x][y] / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tfield[x][y] = (field[x][y] + dp[x][y]) % 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tx = y = 0;\n\t\twhile (x < w && y < h){\n\t\t\t(field[x][y] == 1 ? x : y) += 1;\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\", y + 1, x + 1);\n\t\t\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint h,w,n;\nint maps[1001][1001];\nint home[1001][1001];\nint main(void){\n  scanf(\"%d%d%d\",&h,&w,&n);\n  while(h!=0){\n    memset(maps,0,sizeof(maps));\n    memset(home,0,sizeof(home));\n    int i,j;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&(maps[i][j]));\n      }\n    }\n    home[0][0]=n-1;\n    int a;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(home[i][j]%2==1){\n\t  a=(home[i][j]-1)/2;\n\t  home[i+1][j]+=a;\n\t  home[i][j+1]+=a;\n\t  if(maps[i][j]==1){\n\t    maps[i][j]=0;\n\t    home[i][j+1]++;\n\t  }\n\t  else{\n\t    maps[i][j]=1;\n\t    home[i+1][j]++;\n\t  }\n\t}\n\telse{\n\t  a=home[i][j]/2;\n\t  home[i+1][j]+=a;\n\t  home[i][j+1]+=a;\n\t}\n      }\n    }\n    int ansi=0,ansj=0;\n    while(ansi<h && ansj<w){\n      if(maps[ansi][ansj]==1){\n\tansj++;\n      }\n      else{\n\tansi++;\n      }\n      //printf(\"%d\\x0020%d\\n\",ansi+1,ansj+1);\n    }\n    printf(\"%d\\x0020%d\\n\",ansi+1,ansj+1);\n    scanf(\"%d%d%d\",&h,&w,&n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int h,w,n,masu[1000][1000];\n  while(scanf(\"%d %d %d\",&h,&w,&n),h!=0||w!=0||n!=0){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tscanf(\"%d\",&masu[i][j]);\n      }\n    }\n    int dp[1000][1000]={};\n    dp[0][0] = n-1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(i > 0){\n\t  if(dp[i-1][j]%2 == 0){\n\t    dp[i][j] += dp[i-1][j]/2;\n\t  } else {\n\t    if(masu[i-1][j] == 0){\n\t      dp[i][j] += (dp[i-1][j]+1)/2;\n\t    } else {\n\t      dp[i][j] += dp[i-1][j]/2;\n\t    }\n\t  }\n\t}\n\tif(j > 0){\n\t  if(dp[i][j-1]%2 == 0){\n\t    dp[i][j] += dp[i][j-1]/2;        \n\t  } else {\n\t    if(masu[i][j-1] == 1){\n\t      dp[i][j] += (dp[i][j-1]+1)/2;\n\t    } else {\n\t      dp[i][j] += dp[i][j-1]/2;\n\t    }\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tmasu[i][j] = (masu[i][j]+dp[i][j])&1;\n      }\n    }\n    int y=0,x=0;\n    while(y<h&&x<w){\n      if(masu[y][x] == 1) x++;\n      else y++;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\nusing namespace std;\n\nint h, w, n;\nint field[1001][1001];\npair<int, bool> dp[1002][1002];\nint main()\n{\n  while(cin >> h >> w >> n && (h || w || n)){\n\n    //part1\n    for(int i = 1; i <= h + 1; i++)\n      for(int j = 1; j <= w + 1; j++)\n\tdp[i][j] = make_pair(0, false);\n    \n    for(int i = 1; i <= h; i++)\n      for(int j = 1; j <= w; j++)\n\tcin >> field[i][j];\n\n    //part2\n    dp[1][1] = make_pair(n, true);\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\n\t//part2-1\n\tif(dp[i][j].first % 2){\n\t  if(field[i][j]){\n\t    dp[i][j + 1].first += dp[i][j].first / 2 + 1;\n\t    dp[i + 1][j].first += dp[i][j].first / 2;\n\t  }\n\t  else{\n\t    dp[i][j + 1].first += dp[i][j].first / 2;\n\t    dp[i + 1][j].first += dp[i][j].first / 2 + 1;\n\t  }\n\t}\n\telse{\n\t  dp[i][j + 1].first += dp[i][j].first / 2;\n\t  dp[i + 1][j].first += dp[i][j].first / 2;\n\t}\n\n\t//part2-2\n\tif(dp[i][j].second){\n\t  if(dp[i][j].first % 2){\n\t    if(field[i][j])\n\t      dp[i][j + 1].second = true;\n\t    else\n\t      dp[i + 1][j].second = true;\n\t  }\n\t  else{\n\t    if(field[i][j])\n\t      dp[i + 1][j].second = true;\n\t    else\n\t      dp[i][j + 1].second = true;\n\t  }\n\t}\n      }\n    }\n\n    //part3\n    pair<int, int> ans;\n    for(int i = 1; i <= h; i++)\n      if(dp[i][w + 1].second)\n\tans = make_pair(i, w + 1);\n\n    for(int i = 1; i <= w; i++)\n      if(dp[h + 1][i].second)\n\tans = make_pair(h + 1, i);\n\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nint dp[1000][1000];\n\nint main()\n{\n\tint w, h, n;\n\twhile(cin >> h >> w >> n && w)\n\t{\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tvector<vint> field(w, vint(h));\n\n\t\trep(y, h) rep(x, w)\n\t\t\tcin >> field[x][y];\n\n\t\tdp[0][0] = n-1;\n\t\trep(x, w) rep(y, h)\n\t\t{\n\t\t\t// ðKêéê\n\t\t\tif(x+1 < w) \n\t\t\t\tdp[x+1][y] += (dp[x][y] + dp[x][y] % 2 * -(1 - field[x][y] * 2)) / 2;\n\t\t\t\n\t\t\t// ìðKêéê\n\t\t\tif(y+1 < h)\n\t\t\t\tdp[x][y+1] += (dp[x][y] + dp[x][y] % 2 *  (1 - field[x][y] * 2)) / 2;\n\t\t}\n\n\t\tpint p = make_pair(0,0);\n\t\twhile(p.first < w && p.second < h)\n\t\t{\n\t\t\tif(dp[p.first][p.second] & 1)\n\t\t\t\tfield[p.first][p.second] = !field[p.first][p.second]; \n\n\t\t\tif(field[p.first][p.second])\n\t\t\t\tp.first++;\n\t\t\telse\n\t\t\t\tp.second++;\n\t\t}\n\n\t\tcout << p.second + 1 << \" \" << p.first + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\nint a[1005][1005];\nint dp[1005][1005]; // dp[i][j] := N-1???????????§???(i, j)??????????????£??????\n\nint main()\n{\n\tint H, W, N;\n\t\n\twhile (cin >> H >> W >> N, H) {\n\t\tmemset(dp, 0, sizeof dp);\n\n\t\trep(i, H) rep(j, W) cin >> a[i][j];\n\n\t\tdp[0][0] = N - 1;\n\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (i == 0 && j == 0) continue;\n\n\t\t\tif (i - 1 >= 0) {\n\t\t\t\tbool f = (dp[i - 1][j] % 2 == 0 ? a[i - 1][j] : !a[i - 1][j]) == 0;\n\t\t\t\tdp[i][j] += (f ? (dp[i - 1][j] / 2) : (dp[i - 1][j] + 1) / 2);\n\t\t\t}\n\n\t\t\tif (j - 1 >= 0) {\n\t\t\t\tbool f = (dp[i][j - 1] % 2 == 0 ? a[i][j - 1] : !a[i][j - 1]) == 1;\n\t\t\t\tdp[i][j] += (f ? dp[i][j - 1] / 2 : (dp[i][j - 1] + 1) / 2);\n\t\t\t}\n\t\t}\n\n\t\trep(i, H) rep(j, W) {\n\t\t\ta[i][j] ^= dp[i][j] % 2;\n\t\t}\n\n\t\tint y = 0, x = 0;\n\n\t\twhile (y < H && x < W) {\n\t\t\t(a[y][x] ? x : y)++;\n\t\t}\n\n\t\tcout << y + 1 << ' ' << x + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef VI::iterator VII;\n\nint h, w, n;\nbool bfield[1010][1010];\nint dp[1010][1010];\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d%d\", &h, &w, &n);\n    if(!h && !w && !n)\n      break;\n\n    for(int i = 1; i <= h; i++)\n      for(int j = 1; j <= w; j++)\n\tscanf(\"%d\", &bfield[i][j]);\n    \n    dp[1][1] = n - 1;\n    for(int i = 1; i <= h; i++)\n      for(int j = 1; j <= w; j++){\n\tif(!(dp[i][j] & 1)){\n\t  dp[i][j + 1] += dp[i][j] / 2;\n\t  dp[i + 1][j] += dp[i][j] / 2;\n\t}\n\telse{\n\t  dp[i][j + 1] += dp[i][j] / 2 + bfield[i][j];\n\t  dp[i + 1][j] += dp[i][j] / 2 + !bfield[i][j];\n\t  bfield[i][j] = !bfield[i][j];\n\t}\n      }\n    \n    int i = 1, j = 1;\n    while(i <= h && j <= w){\n      if(bfield[i][j])\n\tj++;\n      else\n\ti++;\n    }\n    \n    if(i > h)\n      printf(\"%d %d\\n\", h + 1, j);\n    else\n      printf(\"%d %d\\n\", i, w + 1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\n#ifndef INPUTS_DIR\n#define INPUTS_DIR \"./\"\n#endif\n\n\nint dp[1000][1000];\nint d[1000][1000];\n\nvoid main_(istream &cin) {\n    int H, W, N;\n    while (cin >> H >> W >> N && H) {\n        memset(dp, 0, sizeof(dp));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> d[i][j];\n            }\n        }\n        dp[0][0] = N - 1;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (i + 1 < H)\n                    dp[i + 1][j] += (dp[i][j] + (d[i][j] == 0)) / 2;\n                if (j + 1 < W)\n                    dp[i][j + 1] += (dp[i][j] + (d[i][j] == 1)) / 2;\n\n            }\n        }\n        int w = 0, h = 0;\n        while (w < W && h < H) {\n            d[h][w] ^= dp[h][w] % 2;\n            if (d[h][w]) w++;\n            else h++;\n        }\n        cout << h + 1 << \" \" << w + 1 << endl;\n    }\n}\n\nint main() {\n#ifdef INTELLIJ\n    ifstream ifs(string(INPUTS_DIR) + \"in_1.txt\");\n    if (ifs.is_open()) {\n        main_(ifs);\n        ifs.close();\n    } else {\n        cerr << \"Error: no input.\" << endl;\n    }\n#else\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    main_(cin);\n#endif\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(n); i++)\n\nchar board[1000][1000];\nint memo[1000][1000];\n\n#define SOUTH 0\n#define EAST  1\n\nint main(){\n  int h,w,n;\n  while(scanf(\"%d%d%d\",&h,&w,&n),h+w+n){\n    REP(i,h) REP(j,w){\n      scanf(\"%d\",&board[i][j]);\n    }\n\n    memo[0][0] = n - 1;\n    REP(i,h) REP(j,w){\n      if(i == 0 && j == 0) continue;\n\n      int tmp = 0;\n      if(i != 0){\n\tint b =(int)board[i-1][j];\n\tif(b == SOUTH){\n\t  tmp += (memo[i-1][j]+1) / 2;\n\t}else{\n\t  tmp += memo[i-1][j] / 2;\n\t}\n      }\n      if(j != 0){\n\tint b =(int)board[i][j-1];\n\tif(b == EAST){\n\t  tmp += (memo[i][j-1]+1) / 2;\n\t}else{\n\t  tmp += memo[i][j-1] / 2;\n\t}\n      }\n\n      memo[i][j] = tmp;\n    }\n\n    int x = 0;\n    int y = 0;\n\n    while(x != w && y != h){\n      int b = ((int)board[y][x] + memo[y][x]) % 2;\n      if(b == SOUTH) ++y;\n      else ++x;\n    }\n\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n\nint a[1010][1010];\nint dp[1010][1010];\n\nint main()\n{\n    int h,w,n;cin>>h>>w>>n;\n\n    rep(i, h) rep(j, w) cin >> a[i][j];\n\n    dp[0][0] = n-1;\n\n    rep(i, h) {\n        rep(j, w) {\n            if (a[i][j] == 0) {\n                dp[i+1][j] += dp[i][j] / 2 + (dp[i][j] % 2);\n                dp[i][j+1] += dp[i][j] / 2;\n            } else {\n                dp[i][j+1] += dp[i][j] / 2 + (dp[i][j] % 2);\n                dp[i+1][j] += dp[i][j] / 2;\n            }\n        }\n    }\n\n    rep(i, h) rep(j, w) {\n        a[i][j] = (a[i][j] + dp[i][j]) % 2;\n    }\n\n    int y = 0, x = 0;\n\n    puts(\"\");\n    rep(i, h) rep(j, w) {\n        printf(\"%d%c\", a[i][j], j==w-1?'\\n':' ');\n    }\n\n    while (y < h && x < w) {\n        if (a[y][x] == 1) x++;\n        else y++;\n    }\n\n    cout << y+1 << ' ' << x+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1ll << 60;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\n#ifdef WIN32\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\"\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\"\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nstatic vector < vector<bool> > east;\nint n, m, many;\nint ans_x, ans_y;\nstatic PII r[ 10000000 ];\nstatic set < vector<vector<bool> > > s;\nint i;\nvoid walk() {\n\tint now_x = 0, now_y = 0;\n\twhile ( now_x != n && now_y != m ) {\n\t\tif ( east[ now_x ][ now_y ] ) {\n\t\t\teast[ now_x ][ now_y ] = !east[ now_x ][ now_y ];\n\t\t\tnow_y++;\n\t\t}\n\t\telse {\n\t\t\teast[ now_x ][ now_y ] = !east[ now_x ][ now_y ];\n\t\t\tnow_x++;\n\t\t}\n\t}\n\tr[ i ] = MP( now_x, now_y );\n}\n\nvoid solve() {\n\ts.clear();\n\tfor ( i = 0; i < many; i++ ) {\n\t\tif ( s.count( east ) ) {\n\t\t\tr[ many - 1 ] = r[ many % s.size() ];\n\t\t\tbreak;\n\t\t}\n\t\twalk();\n\t}\n\tcout << r[ many - 1 ].first + 1 << \" \" << r[ many - 1 ].second + 1 << \"\\n\";\n}\n\nint main() {\n\tsrand( ( uint ) time( NULL ) );\n\tios::sync_with_stdio( false );\n\tcin.tie( 0 );\n#ifdef WIN32\n\tcout << \"Debug Mode\\n\";\n#endif\n\twhile ( cin >> n >> m >> many && n && m && many ) {\n\t\teast.resize( n, vector<bool>( m ) );\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tfor ( int j = 0; j < m; j++ ) {\n\t\t\t\tint num;\n\t\t\t\tcin >> num;\n\t\t\t\teast[ i ][ j ] = num;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int , int > Pi;\n\nint main()\n{\n  int H, W, N, mas[1000][1000], dp[1000][1000];\n\n  while(scanf(\"%d %d %d\", &H, &W, &N), H){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        scanf(\"%d\", &mas[i][j]);\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][0] = N - 1;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        if(i + 1 < H) dp[i + 1][j] += (dp[i][j] + 1 - mas[i][j]) >> 1;\n        if(j + 1 < W) dp[i][j + 1] += (dp[i][j] + mas[i][j]) >> 1;\n      }\n    }\n    int h = 0, w = 0;\n    while(h != H && w != W){\n      if((dp[h][w] + mas[h][w]) & 1) w++;\n      else h++;\n    }\n    printf(\"%d %d\\n\", h + 1, w + 1);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nint field[1000][1000];\nint dp[1000][1000];\nint h, w, n;\n// 0---ì 1---\nint main() {\n    while (scanf(\"%d%d%d\",&h,&w,&n)) {\n        if (!h&&!w&&!n) break;\n        for (int i=0; i<h; i++) for (int j=0; j<w; j++)\n            scanf(\"%d\",&field[i][j]);\n        dp[0][0]=n;\n        for (int i=1; i<w; i++) {\n            if (field[0][i-1]&&dp[0][i-1]%2) {\n                dp[0][i]=floor(dp[0][i-1]/2)+1;\n            } else {\n                dp[0][i]=floor(dp[0][i-1]/2);\n            }\n        }\n        for (int i=1; i<h; i++) for (int j=0; j<w; j++) {\n            dp[i][j]=0;\n            if (!field[i-1][j]&&dp[i-1][j]%2) {\n                dp[i][j]+=floor(dp[i-1][j]/2)+1;\n            } else {\n                dp[i][j]+=floor(dp[i-1][j]/2);\n            }\n            if (j&&field[i][j-1]&&dp[i][j-1]%2) {\n                dp[i][j]+=floor(dp[i][j-1]/2)+1;\n            } else {\n                dp[i][j]+=floor(dp[i][j-1]/2);\n            }\n        }\n        for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            if (dp[i][j]%2==0) {\n                field[i][j]^=1;\n            }\n            // printf(\"%d%c\",dp[i][j],j==w-1?'\\n':' ');\n        }\n        int nx=0, ny=0;\n        while (nx<h&&ny<w) {\n            if (field[nx][ny]) ny++;\n            else nx++;\n        }\n        printf(\"%d %d\\n\",nx+1,ny+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int h, w, n;\n    while(cin >> h >> w >> n && h) {\n        vector<vector<int>> fld(h + 1, vector<int>(w + 1, -1));\n        for(int i : in(h))\n          for(int j : in(w))\n            cin >> fld[i][j];\n        --n;\n        int ansx, ansy;\n        tie(ansx, ansy) = [&]() {\n            int x = 0, y = 0;\n            int turn = 1;\n            while(true) {\n                if(fld[y][x] == -1)\n                  return make_pair(x, y);\n                int num = fld[y][x];\n                if(n >= turn) {\n                    int t = n / turn;\n                    if(t & 1) num ^= 1;\n                    turn *= 2;\n                }\n                if(num) ++x; else ++y;\n            }\n            return make_pair(-1, -1);\n        }();\n        cout << ansy + 1 << ' ' << ansx + 1<< endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\nconst int MAX_N=10000000, INF=1<<30;\nint h, w, n;\nint ma[1001][1001];\nint dp[1001][1001];\nvoid solve(int i, int j){\n  if(i>h||j>w){\n    cout<<i<<' '<<j<<endl;\n    return;\n  }\n    if(ma[i][j])\n      solve(i,j+1);\n    else\n      solve(i+1,j);\n}\nint main(){\n  while(cin>>h>>w>>n&&h){\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcin>>ma[i][j];\n      }\n    }\n    memset(dp,sizeof(dp),0);\n    ma[1][0]=INF;\n    dp[1][1]=n-1;\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tif(i==1&&j==1) continue;\n\tdp[i][j]+=dp[i][j-1]/2+dp[i-1][j]/2;\n\tif(ma[i][j-1]&&dp[i][j-1]%2==1)\n\t  dp[i][j]++;\n\tif(ma[i-1][j]==0&&dp[i-1][j]%2==1)\n\t  dp[i][j]++;\n      }\n    }\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tif(dp[i][j]%2==1){\n\t  if(ma[i][j]==1)\n\t    ma[i][j]=0;\n\t  else\n\t    ma[i][j]=1;\n\t}\n      }\n    }\n    solve(1,1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <vector>\n# include <limits>\n# include <algorithm>\n# include <map>\n# include <string>\n# include <functional>\nusing namespace std;\n\nint main() {\n\tint h, w, n;\n\twhile (cin >> h >> w >> n&&h != 0 && w != 0 && n != 0) {\n\t\tint map[1000][1000];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> map[j][i];\n\t\t\t}\n\t\t}\n\t\tint ansh = 0, answ = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint posh = 0, posw = 0;\n\t\t\twhile (posh != h && posw != w) {\n\t\t\t\tif (map[posw][posh] == 0) {\n\t\t\t\t\tmap[posw][posh] = 1;\n\t\t\t\t\tposh++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[posw][posh] = 0;\n\t\t\t\t\tposw++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tcout << map[j][i];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tansh = posh + 1, answ = posw + 1;\n\t\t}\n\t\tcout << ansh << \" \" << answ << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nint N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W >> N;\n\twhile(H){\n\t    vector<vector<short>>v(H, vector<short>(W));\n\tfor (auto &i : v)for (auto &j : i)cin >> j;\n\t//0-south 1-east\n\tvector<vector<int>>turn(H, vector<int>(W));\n\tvector<vector<short>>last(H, vector<short>(W, -1));\n\tturn[0][0] = N;\n\tlast[0][0] = v[0][0] ^ ((N ^ 1) & 1);\n\tfor (int i = 1; i < W; i++) {\n\t\tturn[0][i] = (turn[0][i - 1] + v[0][i - 1]) / 2;\n\t\tif (last[0][i - 1] == 1) {\n\t\t\tlast[0][i] = v[0][i] ^ (((turn[0][i]) ^ 1) & 1);\n\t\t}\n\t}\n\tfor (int i = 1; i < H; i++) {\n\t\tturn[i][0] = (turn[i - 1][0] + 1 - v[i - 1][0]) / 2;\n\t\tif (last[i - 1][0] == 0) {\n\t\t\tlast[i][0] = v[i][0] ^ (((turn[i][0]) ^ 1) & 1);\n\t\t}\n\t}\n\tfor (int i = 1; i < H; i++) {\n\t\tfor (int j = 1; j < W; j++) {\n\t\t\tturn[i][j] = (turn[i][j - 1] + v[i][j - 1]) / 2 + (turn[i - 1][j] + 1 - v[i - 1][j]) / 2;\n\t\t\tif (last[i - 1][j] == 0) {\n\t\t\t\tlast[i][j] = v[i][j] ^ (((turn[i][j]) ^ 1) & 1);\n\t\t\t}\n\t\t\tif (last[i][j - 1] == 1) {\n\t\t\t\tlast[i][j] = v[i][j] ^ (((turn[i][j]) ^ 1) & 1);\n\t\t\t}\n\t\t}\n\t}\n\tbool flag=true;\n\tfor (int i = 0; i < H; i++) {\n\t\tif (last[i].back() == 1) {\n\t\t\tif(flag)cout << i + 1 << \" \" << W + 1 << endl;\n\t\t\tflag=false;\n\t\t}\n\t}\n\tfor (int i = 0; i < W; i++) {\n\t\tif (last.back()[i] == 0) {\n\t\t\tif(flag)cout << H + 1 << \" \" << i + 1 << endl;\n\t\t\tflag=false;\n\t\t}\n\t}\n\tcin>>H>>W>>N;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y+1 < H) dp[y+1][x] += ((dp[y][x] + (direction[y][x] == 0 ? 1:0)) / 2);\n\tif(x+1 < W) dp[y][x+1] += ((dp[y][x] + (direction[y][x] == 1 ? 1:0)) / 2);\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    while(y < H && x < W){\n      if((dp[y][x] + direction[y][x]) % 2 == 0) y++;\n      else if((dp[y][x] + direction[y][x]) % 2 == 1) x++;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint H, W, N;\nint A[1001][1001];\nint dp[1001][1001];\n\nint main() {\n  while (cin >> H >> W >> N) {\n    if (H == 0 && W == 0 && N == 0) break;\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        cin >> A[j][i];\n      }\n    }\n    for (int x=0; x<=W; x++) {\n      for (int y=0; y<=H; y++) {\n        dp[x][y] = 0;\n      }\n    }\n    dp[0][0] = N-1;\n    for (int x=0; x<W; x++) {\n      for (int y=0; y<H; y++) {\n        if (dp[x][y] % 2 == 0) {\n          dp[x+1][y] += dp[x][y] / 2;\n          dp[x][y+1] += dp[x][y] / 2;\n          continue;\n        }\n        if (A[x][y] == 1) {\n          dp[x+1][y] += (dp[x][y]+1) / 2;\n          dp[x][y+1] += (dp[x][y]-1) / 2;\n        }\n        else {\n          dp[x+1][y] += (dp[x][y]-1) / 2;\n          dp[x][y+1] += (dp[x][y]+1) / 2;\n        }\n      }\n    }\n\n    int x = 0, y = 0;\n    while (x != W && y != H) {\n      int t = (dp[x][y] % 2) ^ A[x][y];\n      if (t == 1) x += 1;\n      else        y += 1;\n    }\n    cout << y+1 << \" \" << x+1 << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint f[1005][1005]={};\nint dp[1005][1005];\nint h,w,n;\n\nint main()\n{\nwhile(1)\n{\n\tscanf(\"%d %d %d\",&h,&w,&n); if(!n) return 0;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&f[i][j]);\n\t\t}\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tdp[1][1]=n-1;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(dp[i-1][j]%2==1) dp[i][j]+=max(0,(dp[i-1][j]+(!f[i-1][j]?1:-1))/2);\n\t\t\telse dp[i][j]+=max(0,(dp[i-1][j])/2);\n\t\t\t\n\t\t\tif(dp[i][j-1]%2==1) dp[i][j]+=max(0,(dp[i][j-1]+(f[i][j-1]?1:-1))/2);\n\t\t\telse dp[i][j]+=max(0,(dp[i][j-1])/2);\n\t\t}\n\t}\n\tint nx=1,ny=1;\n\twhile(nx<=h && ny<=w)\n\t{\n\t\tbool x=f[nx][ny];\n\t\tbool y=(dp[nx][ny]%2);\n\t\tif((x+y)%2==1) ny++;\n\t\telse nx++;\n\t} \n\tprintf(\"%d %d\\n\",nx,ny);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nint f[1001][1001];\nint ct[1001][1001];\n\nint main()\n{\n    int H,W,N;\n    while(scanf(\" %d %d %d\", &H, &W, &N),H)\n    {\n        rep(i,H)rep(j,W) scanf(\" %d\", &f[i][j]);\n        #define IN(x,y) (0<=x && x<W && 0<=y && y<H)\n\n        memset(ct,0,sizeof(ct));\n        ct[0][0]=N-1;\n\n        int dx[2]={0,1}, dy[2]={1,0};\n        rep(s,H+W+1)\n        {\n            int l=max(0,s-H), r=min(W-1,s);\n            for(int x=l; x<=r; ++x)\n            {\n                int y=s-x;\n                rep(i,2)\n                {\n                    int nx=x+dx[i], ny=y+dy[i];\n                    if(!IN(nx,ny)) continue;\n\n                    int nct=ct[y][x]/2;\n                    if(ct[y][x]%2==1 && f[y][x]==i) ++nct;\n\n                    ct[ny][nx]+=nct;\n                }\n            }\n        }\n\n        int X=0,Y=0;\n        while(IN(X,Y))\n        {\n            int d=(f[Y][X]+ct[Y][X])%2;\n            X+=dx[d];\n            Y+=dy[d];\n        }\n        printf(\"%d %d\\n\", Y+1,X+1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nusing namespace std;\nint main(){\n  int h,w,n;\n  while(scanf(\"%d%d%d\",&h,&w,&n)&&h){\n    int c[1001][1001]={},a;\n    c[0][0]=n-1;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tscanf(\"%d\",&a);\n\tc[i+1][j]+=c[i][j]/2;\n\tc[i][j+1]+=c[i][j]/2;\n\tif(c[i][j]%2){\n\t  if(a)c[i][j+1]++;\n\t  else c[i+1][j]++;\n\t}\n\tc[i][j]+=a;\n      }\n    int x=0,y=0;\n    while(x!=w&&y!=h){\n      if(c[y][x]%2)x++;\n      else y++;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nint field[1024][1024];\nint dp[1024][1024];\nint h,w,n;\n\nint main(){\n  \n  while(scanf(\"%d%d%d\",&h,&w,&n),h|w|n){\n    memset(dp,0,sizeof(dp));\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i+1][j+1]);\n      }\n    }\n    dp[1][1] = n-1;\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tint k1,k2;\n\tif( dp[i-1][j]%2 && field[i-1][j]==0 ){\n\t  k1 = 1;\n\t}else{\n\t  k1 = 0;\n\t}\n\tif( dp[i][j-1]%2 && field[i][j-1]==1 ){\n\t  k2 = 1;\n\t}else{\n\t  k2 = 0;\n\t}\n\n\tdp[i][j] += (dp[i-1][j]+k1)/2  + (dp[i][j-1]+k2)/2;\n      }\n    }\n#if DEB\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tprintf(\"%2d \",dp[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    \n    // Nツ嘉アツ姪堋づ個湘ウツ妥板づーツ青カツ青ャ\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tfield[i][j] = (field[i][j]+dp[i][j])%2;\n      }\n    }\n#if DEB\n    puts(\"field\");\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tprintf(\"%2d \",field[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    \n    int x=1;\n    int y=1;\n    for(;;){\n      if( x>w || y>h )break;\n      if( field[y][x]==1 ){\n\tx++;\n      }else{\n\ty++;\n      }\n    }\n\n    printf(\"%d %d\\n\",y,x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <bits/stdc++.h>\n\nint32_t H,W,N;\nint map[10000][10000];//h,W\nint main()\n{\n\tfor(;;){\n\t\t\n\tscanf(\"%d%d%d\", &H,&W,&N);\n\tif(H==0&&W==0&&N==0){break;}\n\t//getchar();//\\n????????????\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tscanf(\"%d\", &map[i][j]);//map[i][j] -= '0';getchar();//\\n\\s????????????\n\t}}\n\t\t#ifdef DEBUG\n\t\tprintf(\"\\n----\\n\");\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tputchar(map[i][j] +'0');\n\t}putchar('\\n');}printf(\"----\\n\");\n\t\t#endif\n\t\n\tint32_t npos_x=0,npos_y = 0, now_n = N;\n\twhile(npos_x < W && npos_y < H)\n\t{\n\t\t#ifdef DEBUG\n\t\tprintf(\"----\\n\");\n\t\tprintf(\"%d %d %d\\n\", npos_x,npos_y, now_n);\n\t\tprintf(\"%d %d %d\\n\", (now_n&1), map[npos_y][npos_x], (now_n&1) ^ (map[npos_y][npos_x]));\n\t\tprintf(\"----\\n\");\n\t\t#endif\n\t\tif((now_n&1) ^ map[npos_y][npos_x]){\n\t\t\t++npos_y;\n\t\t}\n\t\telse{\n\t\t\t++npos_x;\n\t\t}\n\t\tnow_n = (now_n/2)+(now_n&1);\n\t}\n\tprintf(\"%d %d\\n\",npos_y+1, npos_x+1);\n\t\n\t}//for(;;)\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint num[1005][1005],h,w,n;\npair<int,int>p;\nint main(){\nwhile(1){\nscanf(\"%d %d %d\",&h,&w,&n);\nfor(int i=1;i<=h;i++){\nfor(int j=1;j<=w;j++){\nscanf(\"%d\",&num[j][i]);\n}\n}\nint y=1,s=1,cou=0;\nwhile(1){\ncou++;\nif(num[y][s]){\ny++;\nnum[y][s]=(num[y][s]+1)%2;\nif(y==w+1){\np=make_pair(y,s);\n}\n}else{\nnum[y][s]=(num[y][s]+1)%2;\ns++;\nif(s==h+1){\np=make_pair(y,s);\n}\n}\nif(cou==n){\ncout << p.first << \" \" << p.second << endl; return 0;\n}\nif(p.first==1 && p.second==h){\ncout << p.first <<\" \"<< p.second << endl; return 0;\n}\nif(p.first==w && p.second==1){\ncout << p.first <<\" \"<<p.second <<endl; return 0;\n}\n}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ntypedef long long ll;\n\nint a[1010][1010];\nint dp[1010][1010];\n\nint main(void){\n\n\tint H,W,N;\n\tcin >> H >> W >> N;\n\tint i,j;\n\tfor(i=1;i<=H;i++) for(j=1;j<=W;j++) cin >> a[i][j];\n\tdp[1][1]=N-1;\n\tfor(i=1;i<=H;i++) for(j=1;j<=W;j++){\n\t\tif(i!=1 || j!=1){\n\t\tif(dp[i-1][j]%2==1 && a[i-1][j]==0) dp[i][j]+=(dp[i-1][j]+1)/2;\n\t\tif(dp[i-1][j]%2==1 && a[i-1][j]==1) dp[i][j]+=(dp[i-1][j]-1)/2;\n\t\tif(dp[i-1][j]%2==0) dp[i][j]+=dp[i-1][j]/2;\n\t\tif(dp[i][j-1]%2==1 && a[i][j-1]==0) dp[i][j]+=(dp[i][j-1]-1)/2;\n\t\tif(dp[i][j-1]%2==1 && a[i][j-1]==1) dp[i][j]+=(dp[i][j-1]+1)/2;\n\t\tif(dp[i][j-1]%2==0) dp[i][j]+=dp[i][j-1]/2;\n\t\t}\n\t}\n\n\tint x=1,y=1;\n\twhile(x<=H && y<=W){\n\t\tif(dp[x][y]%2==0 && a[x][y]==0) x++;\n\t\telse if(dp[x][y]%2==0 && a[x][y]==1) y++;\n\t\telse if(dp[x][y]%2==1 && a[x][y]==0) y++;\n\t\telse if(dp[x][y]%2==1 && a[x][y]==1) x++;\n\t}\n\n\tcout << x << ' ' << y << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll H,W,N;\nll g[1002][1002];\nll visited[1002][1002];\n\nbool ok(ll y,ll x){\n\treturn 0<=y&&y<H&&0<=x&&x<W;\n}\n\nP dfs(ll y,ll x){\n\tif(x>=W) return P(y,x);\n\tif(y>=H) return P(y,x);\n\tif(g[y][x]==0) return dfs(y+1,x);\n\telse return dfs(y,x+1);\n}\n\nint main()\n{while(1){\n\tcin>>H>>W>>N;\n\tif(!N) break;\n \tmemset(visited,0,sizeof(visited));\n\tH;\n\tW;\n\trep(i,H) rep(j,W) cin>>g[i][j];\n\tvisited[0][0]=N-1;\n\trep(i,H) rep(j,W){\n\t\tif(g[i][j]==0){\n\t\t\tif(ok(i+1,j)) visited[i+1][j]+=(visited[i][j]+1)/2;\n\t\t\tif(ok(i,j+1)) visited[i][j+1]+=visited[i][j]/2;\n\t\t\tif(visited[i][j]%2) g[i][j]^=1;\n\t\t}\n\t\telse{\n\t\t\tif(ok(i+1,j)) visited[i+1][j]+=visited[i][j]/2;\n\t\t\tif(ok(i,j+1)) visited[i][j+1]+=(visited[i][j]+1)/2;\n\t\t\tif(visited[i][j]%2) g[i][j]^=1;\n\t\t}\n\t}\n\tP p = dfs(0,0);\n\tcout<<p.fr+1<<\" \"<<p.sc+1<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nenum Direction{SOUTH,EAST};\n\nint main()\n{\n  int H,W,N;\n  int y,x;\n  while(cin>>H>>W>>N,H|W|N){\n    vector< vector<int> >v(H+1,vector<int>(W+1,SOUTH));\n    vector< vector<int> >dp(H+1,vector<int>(W+1,0));\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>v[i][j];\n    dp[1][1]=N-1;\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n\tif(dp[i-1][j]&1){\n\t  if(v[i-1][j]==SOUTH)dp[i][j]+=(dp[i-1][j]+1)/2;\n\t  else dp[i][j]+=(dp[i-1][j]-1)/2;\n\t}else{\n\t  dp[i][j]+=dp[i-1][j]/2;\n\t}\n\tif(dp[i][j-1]&1){\n\t  if(v[i][j-1]==EAST)dp[i][j]+=(dp[i][j-1]+1)/2;\n\t  else dp[i][j]+=(dp[i][j-1]-1)/2;\n\t}else{\n\t  dp[i][j]+=dp[i][j-1]/2;\n\t}\n      }\n    }\n    //for(int i=0;i<H;i++,puts(\"\"))for(int j=0;j<W;j++)cout<<v[i][j]<<\",\";\n    //puts(\"\");\n    //for(int i=0;i<=H;i++,puts(\"\"))for(int j=0;j<=W;j++)cout<<dp[i][j]<<\",\";\n    //puts(\"\");\n    //for(int i=0;i<H;i++,puts(\"\"))for(int j=0;j<W;j++)cout<<((v[i][j]+dp[i][j])&1)<<\",\";\n    //puts(\"\");\n    y=x=1;\n    while(x<=W && y<=H){\n      v[y][x]^=dp[y][x]&1;\n      //cout<<y<<\",\"<<x<<\":\"<<v[y][x]<<endl;\n      if(v[y][x]==SOUTH)y++;\n      else x++;\n    }\n    cout<<y<<\" \"<<x<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nstruct Edge\n{\n  int to;\n  int weight;\n  Edge(int t, int w) : to(t), weight(w) {}\n};\n// using Graph = vector<vector<Edge>>;\nusing Graph = vector<vector<int>>;\n\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1000000000;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, 1, -1, 1, 0, -1};\n\nint grid[1010][1010];\nint dp[1010][1010];\nint nGrid[1010][1010];\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int H, W, N;\n  while (true)\n  {\n    for (int i = 0; i < H; i++)\n    {\n      for (int j = 0; j < W; j++)\n      {\n        grid[i][j] = 0;\n      }\n    }\n    for (int i = 0; i < H + 1; i++)\n    {\n      for (int j = 0; j < W + 1; j++)\n      {\n        dp[i][j] = 0;\n      }\n    }\n    for (int i = 0; i < H; i++)\n    {\n      for (int j = 0; j < W; j++)\n      {\n        nGrid[i][j] = 0;\n      }\n    }\n    \n    cin >> H >> W >> N;\n    if (H == W && W == N)\n      break;\n\n    for (int i = 0; i < H; i++)\n    {\n      for (int j = 0; j < W; j++)\n      {\n        cin >> grid[i][j];\n      }\n    }\n\n    dp[0][0] = N - 1;\n\n    for (int i = 0; i < H; i++)\n    {\n      for (int j = 0; j < W; j++)\n      {\n        if (grid[i][j])\n        {\n          dp[i + 1][j] += dp[i][j] / 2;\n          dp[i][j + 1] += (dp[i][j] + 1) / 2;\n        }\n        else\n        {\n          dp[i + 1][j] += (dp[i][j] + 1) / 2;\n          dp[i][j + 1] += dp[i][j] / 2;\n        }\n      }\n    }\n\n    for (int i = 0; i < H; i++)\n    {\n      for (int j = 0; j < W; j++)\n      {\n        if (grid[i][j])\n        {\n          if (dp[i][j] % 2 == 0)\n          {\n            nGrid[i][j] = 1;\n          }\n          else\n          {\n            nGrid[i][j] = 0;\n          }\n        }\n        else\n        {\n          if (dp[i][j] % 2 == 0)\n          {\n            nGrid[i][j] = 0;\n          }\n          else\n          {\n            nGrid[i][j] = 1;\n          }\n        }\n      }\n    }\n\n    int nowy = 0, nowx = 0;\n    while (0 <= nowy && nowy < H && 0 <= nowx && nowx < W)\n    {\n      if (nGrid[nowy][nowx])\n        nowx++;\n      else\n        nowy++;\n    }\n\n    cout << nowy + 1 << \" \" << nowx + 1 << endl;\n  }\n  return 0;\n}\n\n// N回目の「南」「東」を決めなければならない\n// 1～(N - 1)回目にたどりついた場所を知る必要はない．　また詳しいルートを1回ずつ区別して計算する必要もない．なぜならばN回目のルートやたどりつく場所に影響を与えないからであり各交差点を1～(N- 1)回目で何回通ったかが重要になる．まず，交差点(1, 1)をN-1回通る．この後，(1, 1)が東ならば(1, 2)を切り上げの(N - 1)/2回，南ならば(N - 1)/2回通る．同様に(1, 1)が東ならば(2, 1)を(N- 1)/2回，南ならば切上げの(N - 1)/2回通る．整理すると，\n// (y, x)をT回通る時，\n// (y, x)が東ならば(y, x + 1)を切り上げのT / 2回，(y + 1, x)をT / 2回通る．(y, x)が南ならば(y, x + 1)をT / 2回，(y + 1, x)を切り上げのT / 2回通る．\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(void){\n\t\n\tstatic int h,w,n,grid[1002][1002],dp[1002][1002];\n\n\twhile(cin >> h >> w >> n,h|w|n){\n\t\tfor(int i=1;i<=h;i++)\n\t\t\tfor(int j=1;j<=w;j++)\n\t\t\t\tcin >> grid[i][j];\n\t\t\n\t\tfill(dp[0],dp[1002],0);\n\t\tdp[1][1]=n-1;\n\t\t\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tdp[i][j+1]+=(dp[i][j]+grid[i][j])>>1;\n\t\t\t\tdp[i+1][j]+=(dp[i][j]+!grid[i][j])>>1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=0;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2)grid[i][j]^=dp[i][j]&1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x=1,y=1;\n\t\twhile(true){\n\t\t\tif(y>h || x>w)break;\n\t\t\tif(grid[y][x])x++;\n\t\t\telse y++;\n\t\t}\n\t\t\n\t\tcout << y << \" \" << x << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n//#define int long long \n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\nconst int INF=1001001001;\nint H,W,N;//H=1000,W=1000,N=10000000\n//?¨????????????????O(N)?????????O(H???W)?????????????????????????????¨??????\n//????´????????????¨H*W??????????????????N????????????30%??§??????\n//???????????°?????????????????§\n//??¶???????¨??????§?????????????????????\nint m[1002][1002];//0?????????1?????±\nint pm[1002][1002];//??????\nclass WALK{\n    private:\n    \n    public:\n    pair<int,int> solve(){\n        scanf(\"%d %d %d\",&H,&W,&N);//N???????????£????????????????????°????????????\n        if(H==0&&W==0&&N==0)return mp(-1,-1);\n        fill(pm[0],pm[H+1],0);\n        rep(i,H){\n            rep(j,W){\n                scanf(\"%d\",&m[i][j]);\n            }\n        }\n        //???????????°??????????????°??¶???????????????????????????\n        rep(i,H){\n            rep(j,W){\n                pm[i][j]=0;\n                if(i==0&&j==0){\n                    pm[i][j]=N-1;\n                }else if(i==0){//???????????????\n                    pm[i][j]+=( m[i][j-1]==1&&(pm[i][j-1])%2 ? (pm[i][j-1])/2+1 : (pm[i][j-1])/2 );\n                }else if(j==0){//???????????????\n                    pm[i][j]+=( m[i-1][j]==0&&(pm[i-1][j])%2 ? (pm[i-1][j])/2+1 : (pm[i-1][j])/2 );\n                }else{\n                    pm[i][j]+=( m[i][j-1]==1&&(pm[i][j-1])%2 ? (pm[i][j-1])/2+1 : (pm[i][j-1])/2 );\n                    pm[i][j]+=( m[i-1][j]==0&&(pm[i-1][j])%2 ? (pm[i-1][j])/2+1 : (pm[i-1][j])/2 );\n                    \n                }\n            }\n        }\n        //N???????????????????????§???????????§??¢?´¢??????\n        pair<int,int> ans=mp(0,0);\n        while(1){\n            if(ans.first==H || ans.second==W)break;\n            if( ( m[ans.first][ans.second]+pm[ans.first][ans.second] )%2 ){\n                ans.second++;\n            }else{\n                ans.first++;\n            }\n        }\n        return ans;\n    }\n};\nsigned main(){\n    while(1){\n        WALK ans;\n        pair<int,int> p=ans.solve();\n        if(p.first==-1)break;\n        printf(\"%d %d\\n\",p.first+1,p.second+1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int N, W, H;\n  while(cin>>H>>W>>N &&( H || W || N )){\n    int dp[1002][1002] = {};\n    int grid[1002][1002];\n    REP(y, H)REP(x, W) cin>>grid[y][x];\n    dp[0][0] = N - 1;\n    REP(y,H)REP(x,W){\n      dp[y+1][x] += (dp[y][x] + !grid[y][x])/2;\n      dp[y][x+1] += (dp[y][x] +  grid[y][x])/2;\n    }\n    REP(y,H)REP(x,W){\n      grid[y][x] ^= dp[y][x] % 2;\n    }\n    int nx = 0, ny = 0;\n    while(nx < W && ny < H){\n      if(grid[ny][nx] == 0) ny++;\n      else if(grid[ny][nx] == 1) nx++;\n    }\n    assert(nx == W || ny == H);\n    printf(\"%d %d\\n\",ny + 1, nx + 1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nqueue<POS> check;\nlong next[201][201],field[201][201],n;\nbool flag[201][201];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    /*    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n      }*/\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    /*    while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n      }*/\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n    }\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct\n{\n\tint x;\n\tint y;\n} pos;\n\nint N,H,W,M[100][100],C[101][101];\npos temp_p;\n\npos* makepos(int x,int y)\n{\n\ttemp_p.x = x;\n\ttemp_p.y = y;\n\treturn &temp_p;\n}\n\nint main(void)\n{\n\tcin >> H >> W >> N;\n\tfor(int y = 0;y < H;y++)\n\t{\n\t\tfor(int x = 0;x < W;x++)\n\t\t{\n\t\t\tcin >> M[x][y];\n\t\t}\n\t}\n\tC[0][0] = N-1;\n\tfor(int y = 0;y < H;y++)\n\t{\n\t\tfor(int x = 0;x < W;x++)\n\t\t{\n\t\t\tC[x][y+1] += C[x][y] / 2;\n\t\t\tC[x+1][y] += C[x][y] / 2;\n\t\t\tif(C[x][y] % 2 == 1)\n\t\t\t{\n\t\t\t\tif(M[x][y] == 0)\n\t\t\t\t\tC[x][y+1]++;\n\t\t\t\telse\n\t\t\t\t\tC[x+1][y]++;\n\t\t\t\tM[x][y] = (M[x][y] + 1) % 2;\n\t\t\t}\n\t\t}\n\t}\n\tpos cp;\n\tcp.x = 0;\n\tcp.y = 0;\n\twhile(cp.x != W && cp.y != H)\n\t{\n\t\tif(M[cp.x][cp.y] == 0)\n\t\t\tcp.y++;\n\t\telse\n\t\t\tcp.x++;\n\t}\n\tcout << cp.y+1 << \" \" << cp.x+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint di[2] = {1, 0};\nint dj[2] = {0, 1};\n\nint main(){\n    int h, w, n;\n    while(cin >> h >> w >> n, h+w+n){\n        int mat[h][w], dp[h+1][w+1];\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> mat[i][j];\n                dp[i][j] = 0;\n            }\n        }\n        dp[0][0] = n-1;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(dp[i][j] == 0)   continue;\n                int tmp = mat[i][j];\n                mat[i][j] = (mat[i][j]+dp[i][j])%2;\n                int ni = i+di[tmp], nj = j+dj[tmp];\n                dp[ni][nj] += (dp[i][j]+1)/2;\n                ni = i+di[1-tmp], nj = j+dj[1-tmp];\n                dp[ni][nj] += dp[i][j]/2;\n            }\n        }\n        int ansi = 0, ansj = 0;\n        while(ansi != h && ansj != w){\n            if(mat[ansi][ansj] == 0)    ansi++;\n            else                        ansj++;\n        }\n        cout << ansi+1 << \" \" << ansj+1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n\nint main()\n{\n  int h,w,n;\n  int maps[1001][1001];\n  int cnts[1001][1001];\n  for(;cin>>h>>w>>n,h;)\n    {\n      memset(cnts,0,sizeof(cnts));\n      cnts[0][0]=n-1;\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>maps[i][j];\n\t    if(i>0)\n\t      {\n\t\tcnts[i][j]+=cnts[i-1][j]/2;\n\t\tif(maps[i-1][j]==0)\n\t\t  cnts[i][j]+=(cnts[i-1][j]%2);\n\t      }\n\t    if(j>0)\n\t      {\n\t\tcnts[i][j]+=cnts[i][j-1]/2;\n\t\tif(maps[i][j-1]==1)\n\t\t  cnts[i][j]+=(cnts[i][j-1]%2);\n\t      }\n\t  }\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    //   cout<<cnts[i][j]<<\" \";\n\t    if(maps[i][j]==0 && (cnts[i][j]%2)!=0)\n\t      maps[i][j]=1;\n\t    else if(maps[i][j]==1 && (cnts[i][j]%2)!=0)\n\t      maps[i][j]=0;\n\t  }\n      int i=0;\n      int j=0;\n      while(true)\n\t{\n\t  if(i>=h || j>=w)\n\t    {\n\t      cout<<i+1<<\" \"<<j+1<<endl;\n\t      break;\n\t    }\n\t  if(maps[i][j]==0)\n\t    i++;\n\t  else\n\t    j++;\n\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint H,W,N;\nint field[1000][1000];\t//東0,南1\nint DP[1001][1001];\nbool done[1001][1001] = {false};\n//N-1回の散歩で通った回数を考える\nvoid makeroot(int y,int x){\n\tif(y == H || x == W || done[y][x] == true)\n\t\treturn;\n\tif((x==0&&y==0)||(x==0&&done[y-1][x])||(y==0&&done[y][x-1])||(x>0&&y>0&&done[y][x-1]&&done[y-1][x]))\n\t\tdone[y][x] = true;\n\telse\n\t\treturn;\n\tif(field[y][x]){\n\t\tDP[y][x+1] += (DP[y][x]+1)/2;\n\t\tDP[y+1][x] += DP[y][x]/2;\n\t}\n\telse{\n\t\tDP[y][x+1] += DP[y][x]/2;\n\t\tDP[y+1][x] += (DP[y][x]+1)/2;\n\t}\n\tmakeroot(y,x+1);\n\tmakeroot(y+1,x);\n}\npair<int,int> walk(int y,int x){\n\tif(y == H || x == W){\n\t\tpair<int,int> p;\n\t\tp.first = y;\n\t\tp.second = x;\n\t\treturn p;\n\t}\n\tif((field[y][x]+DP[y][x])%2)\n\t\treturn walk(y,x+1);\n\telse\n\t\treturn walk(y+1,x);\n}\nint main(){\n\tint i,j;\n\tpair<int,int> pos[200];\n\tint pcor = 0;\n\twhile(1){\n\t\tcin>>H>>W>>N;\n\t\tif(H==0&&W==0&&N==0)\n\t\t\tbreak;\n\t\tfor(i=0;i<H;i++){\n\t\t\tfor(j=0;j<W;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=H;i++){\n\t\t\tfor(j=0;j<=W;j++){\n\t\t\t\tDP[i][j]=0;\n\t\t\t\tdone[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tDP[0][0] = N-1;\n\t\tmakeroot(0,0);\n\t\tpos[pcor] = walk(0,0);\n\t\tpcor++;\n\t}\n\tfor(i = 0;i < pcor;i++)\n\t\tcout << pos[i].first+1 << \" \" << pos[i].second+1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nbool map[1001][1001];\n\nint flow[1001][1001];\n\nint H, W, n;\n\nvoid search(int x, int y){\n\tif(x >= W || y >= H){\n\t\tprintf(\"%d %d\\n\", y + 1, x + 1);\n\t\treturn;\n\t}\n\tif(map[y][x]){\n\t\tsearch(x + 1, y);\n\t}else{\n\t\tsearch(x, y + 1);\n\t}\n}\n\nint main(){\n\t\n\twhile(true){\n\t\tcin >> H >> W >> n;\n\t\tif(H == 0 && W == 0 && n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint d;\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tcin >> d;\n\t\t\t\tif(d == 1){\n\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t}else{\n\t\t\t\t\tmap[i][j] = false;\n\t\t\t\t}\n\t\t\t\tflow[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tflow[0][0] = n - 1;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(flow[i][j] % 2 == 0){\n\t\t\t\t\tflow[i + 1][j] += flow[i][j] / 2;\n\t\t\t\t\tflow[i][j + 1] += flow[i][j] / 2;\n\t\t\t\t}else{\n\t\t\t\t\tif(map[i][j]){\n\t\t\t\t\t\tflow[i + 1][j] += flow[i][j] / 2;\n\t\t\t\t\t\tflow[i][j + 1] += flow[i][j] / 2 + 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tflow[i + 1][j] += flow[i][j] / 2 + 1;\n\t\t\t\t\t\tflow[i][j + 1] += flow[i][j] / 2;\n\t\t\t\t\t}\n\t\t\t\t\tmap[i][j] = !map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsearch(0, 0);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint h,w,n;\nint d[1009][1009];\nint dp[1009][1009];\nint main(){\nwhile(1){\n\tscanf(\"%d%d%d\",&h,&w,&n);\nif(h == 0)break;\n\tfor(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\n\tdp[1][1] = n-1;\n\n\tfor(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\tif(dp[i][j] % 2 == 0){\n\t\t\t\tdp[i+1][j] += dp[i][j]/2;\n\t\t\t\tdp[i][j+1] += dp[i][j]/2;\n\t\t\t}else{\n\t\t\t\tif(d[i][j] == 0){\n\t\t\t\t\tdp[i+1][j] += (dp[i][j]+1)/2;\n\t\t\t\t\tdp[i][j+1] += dp[i][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j+1] += (dp[i][j]+1)/2;\n\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\tif(dp[i][j] % 2 == 0)continue;\n\t\t\tif(d[i][j] == 0)d[i][j] = 1;\n\t\t\telse d[i][j] = 0;\n\t\t}\n\t}\n\t\n\tint x = 1,y = 1;\n\twhile(x <= w && y <= h){\n\t\tif(d[y][x] == 0)y++;\n\t\telse x++;\n\t}\n\tprintf(\"%d %d\\n\",y,x);\n}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint dp[1001][1001];\n\nint main(void)\n{\n\tint h, w;\n\tint n;\n\tchar field[1000][1000];\n\tint x, y;\n\t\n\twhile (1){\n\t\t\n\t\tscanf(\"%d%d%d\", &h, &w, &n);\n\t\t\n\t\tif (h == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tscanf(\"%d\", &field[x][y]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(dp, 0, sizeof(dp));\n\t\t\n\t\tdp[0][0] = n - 1;\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tif (dp[x][y] % 2 == 0){\n\t\t\t\t\tdp[x][y + 1] += dp[x][y] / 2;\n\t\t\t\t\tdp[x + 1][y] += dp[x][y] / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[x + 1][y] += field[x][y] == 1 ? dp[x][y] / 2 + 1 : dp[x][y] / 2;\n\t\t\t\t\tdp[x][y + 1] += field[x][y] == 0 ? dp[x][y] / 2 + 1 : dp[x][y] / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tprintf(\"%d \", dp[x][y]);\n\t\t\t\tfield[x][y] = (field[x][y] + dp[x][y]) % 2;\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t\n\t\tx = y = 0;\n\t\twhile (x < w && y < h){\n\t\t\t(field[x][y] == 1 ? x : y) += 1;\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\", y + 1, x + 1);\n\t\t\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[1002][1002];\nlong int dp[1002][1002];\nint x,y;\nint h,w;\nlong int n;\n\nvoid root(int xx,int yy){\n\tx=xx,y=yy;\n\tdp[xx][yy]+=1;\n\tif(xx<=w && yy<=h){\n\t\tif(map[xx][yy]==1){\n\t\t\tmap[xx][yy]=0;\n\t\t\troot(xx+1,yy);\n\t\t}else{\n\t\t\tmap[xx][yy]=1;\n\t\t\troot(xx,yy+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint a,b,c;\n\twhile(1){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&map[b][a]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tint d,e;\n\t\t\t\tif(dp[b][a]%2==0)dp[b+1][a]=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)d=(dp[b+1][a]-1)/2;\n\t\t\t\t\tif(map[b][a]==0)d=(dp[b+1][a]+1)/2;\n\t\t\t\t}\n\t\t\t\tif(dp[b][a]%2==0)e=dp[b][a+1]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)e=(dp[b][a+1]-1)/2;\n\t\t\t\t\tif(map[b][a]==0)e=(dp[b][a+1]+1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tmap[b][a]=(map[b][a]+dp[b][a])%2;\n\t\t\t}\n\t\t}\n\t\troot(1,1);\n\t\tcout << y << \" \" << x << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\n\nstatic const int MAX = 1001;\n\nmain(){\n  int H, W, N, D[MAX][MAX], dp[MAX][MAX], k;\n  \n  while(1){\n    cin >> H >> W >> N;\n    if ( H == 0 && W == 0 && N == 0) break;\n    rep(i, H) rep(j, W) {\n      cin >> D[i][j];\n      dp[i][j] = 0;\n    }\n    \n    dp[0][0] = N-1;\n    rep(i, H) rep(j, W) {\n      if ( i ){\n\tk = dp[i-1][j];\n\tif ( k % 2 == 0 ){\n\t  dp[i][j] += dp[i-1][j]/2;\n\t} else {\n\t  if ( D[i-1][j] == 0 ) dp[i][j] += (dp[i-1][j] + 1)/2;\n\t  else dp[i][j] += (dp[i-1][j] - 1)/2;\n\t}\n      } \n      if ( j ){\n\tk = dp[i][j-1];\n\tif ( k % 2 == 0 ){\n\t  dp[i][j] += dp[i][j-1]/2;\n\t} else {\n\t  if ( D[i][j-1] == 1 ) dp[i][j] += (dp[i][j-1] + 1)/2;\n\t  else dp[i][j] += (dp[i][j-1] - 1)/2;\n\t}\n      }\n    }\n\n    int pi, pj;\n    pi = pj = 0;\n    while(1){\n      if ( pi == H || pj == W ) break;\n      if ( (dp[pi][pj] + D[pi][pj]) % 2 == 1 ) pj++;\n      else pi++;\n    }\n\n    cout << pi+1 << \" \" << pj+1 << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint main()\n{\n\twhile(1)\n\t{\n\t\tint H,W,N;\n\t\tcin >> H >> W >> N;\n\t\tif(H==0&&W==0&&N==0)break;\n\t\tint mp[H+2][W+2];\n\t\tint dp[H+2][W+2];\n\t\tfor(int i=0;i<H+2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<W+2;j++)\n\t\t\t{\n\t\t\t\tmp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[1][1]=N-1;\n\t\tfor(int i=1;i<=H;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=W;j++)\n\t\t\t{\n\t\t\t\tcin >> mp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=H;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=W;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]%2==1)\n\t\t\t\t{\n\t\t\t\t\tif(mp[i][j]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][j]+=(dp[i][j]+1)/2;\n\t\t\t\t\t\tdp[i][j+1]+=(dp[i][j]-1)/2;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j+1]+=(dp[i][j]+1)/2;\n\t\t\t\t\t\tdp[i+1][j]+=(dp[i][j]-1)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint i=1,j=1;\n\t\twhile(1)\n\t\t{\n\t\t\tif(mp[i][j]==-1)break;\n\t\t\tif(mp[i][j]&&dp[i][j]%2)i++;\n\t\t\telse if(mp[i][j]&&!(dp[i][j]%2))j++;\n\t\t\telse if(!mp[i][j]&&dp[i][j]%2)j++;\n\t\t\telse i++;\n\t\t}\n\t\tcout << i << ' ' << j << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <queue>\n#include <algorithm>\n#include <memory>\n#include <memory.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\nconst double PI = 3.14159;\n\nint route[1001][1001];\nint dp[1001][1001];\n\nint main(){\n\tint h, w, n;\n\twhile(cin >> h >> w >> n && (h || w || n)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> route[i][j];\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n-1;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(dp[i][j] % 2 == 0){\n\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2;\n\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t}else{\n\t\t\t\t\tif(route[i][j] == 1){\n\t\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2 + 1;\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2 + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\troute[i][j] = (route[i][j] + dp[i][j]) % 2;\n\t\t\t}\n\t\t}\n\t\tint y = 0, x = 0;\n\t\twhile(y < h && x < w){\n\t\t\tif(route[y][x] == 1) x++;\n\t\t\telse y++;\n\t\t}\n\t\tcout << y + 1 << \" \" << x + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int h,w;\n  long n;\n  while(1) {\n    cin>>h>>w>>n;\n    if(h==0&&w==0&&n==0) break;\n\n    int r[w][h];\n\n    for(int i=0; i<h; i++)\n      for(int j=0; j<w; j++)\n\tcin>>r[j][i];\n\n    int x,y;\n    for(long l=0; l<n; l++) {\n      x=0,y=0;\n      while(1) {\n\tif(x>w-1 || y>h-1) break;\n\tif(r[x][y]==0) {\n\t  r[x][y]=1;\n\t  y++;\n\t}else{\n\t  r[x][y]=0;\n\t  x++;\n\t}\n      }\n      if(l==n-1) cout<<y+1<<\" \"<<x+1<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[1002][1002];\nlong long int dp[1002][1002];\nlong long int x,y;\nint h,w;\nlong int n;\n\nvoid root(int xx,int yy){\n\tx=xx,y=yy;\n\tif(xx<=w && yy<=h){\n\t\tif(map[xx][yy]==1){\n\t\t\troot(xx+1,yy);\n\t\t}else{\n\t\t\troot(xx,yy+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint a,b,c;\n\twhile(1){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&map[b][a]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tif(dp[b][a]%2==0)dp[b+1][a]+=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)dp[b+1][a]+=(dp[b][a]+1)/2;\n\t\t\t\t\tif(map[b][a]==0)dp[b+1][a]+=(dp[b][a]-1)/2;\n\t\t\t\t}\n\t\t\t\tif(dp[b][a]%2==0)dp[b][a+1]+=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)dp[b][a+1]+=(dp[b][a]-1)/2;\n\t\t\t\t\tif(map[b][a]==0)dp[b][a+1]+=(dp[b][a]+1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tmap[b][a]=(map[b][a]+dp[b][a])%2;\n\t\t\t}\n\t\t}\n\t\troot(1,1);\n\t\tcout << y << \" \" << x << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<stack>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\n\t\tint dp[1003][1003];\n\t\tint masu[1003][1003];\nint main(){\n\twhile(1){\n\t\tint n,m,k;\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0)break;\n\t\trep(i,1003)rep(j,1003)masu[i][j]=dp[i][j]=0;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tscanf(\"%d\",&masu[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[0][0]=k-1;\n\t\t\n\t\trep(i,m){\n\t\t\trep(j,n){\n\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmasu[i][j]+=dp[i][j];\n\t\t\t\tmasu[i][j]%=2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x=0,y=0;\n\t\twhile(1){\n\t\t\tif(masu[x][y]==0){\n\t\t\t\ty++;\n\t\t\t}else{\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(y>=n || x>=m){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n}\n\n/*\n3 4 3\n1 0 1 1\n0 1 0 0\n1 0 1 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint h,w,n;\nint maps[1001][1001];\nvoid change(int i,int j, int cnt)\n{\n  // cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\n  if(i>=h || j>=w|| cnt<=0)\n    return;\n\n  if(maps[i][j]==0)\n    {\n      change(i+1,j,(cnt/2)+(cnt%2));\n      change(i,j+1,(cnt/2));\n      if((cnt%2)!=0)\n\tmaps[i][j]=1;\n    }\n  else\n    {\n      change(i,j+1,(cnt/2)+(cnt%2));\n      change(i+1,j,(cnt/2));\n      if((cnt%2)!=0)\n\tmaps[i][j]=0;\n    }\n\n  //  int cnt1=(cnt/2)+(cnt%2);\n  // int cnt2=(cnt/2);\n\n}\nvoid print(int i,int j)\n{\n  if(i>=h || j>=w)\n    {\n    cout<<i+1<<\" \"<<j+1<<endl;\n    return;\n    }\n  if(maps[i][j]==0)\n    print(i+1,j);\n  else\n    print(i,j+1);\n}\n\nint main()\n{\n  for(;cin>>h>>w>>n,h;)\n    {\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  cin>>maps[i][j];\n      change(0,0,n-1);\n      print(0,0);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint main(){\n  bool g[1000][1000];\n  int p[2][1000],i,j,h,w,n,t;\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&t);\n\tg[i][j]=t?1:0;\n\tp[i&1][j]=0;\n      }\n\n    p[0][0]=n-1;\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tt=i&1;\n\tn=p[t][j];\n\tif(g[i][j]){\n\t  p[1-t][j]+=n/2;\n\t  p[t][j+1]+=n-n/2;\n\t}else{\n\t  p[1-t][j]+=n-n/2;\n\t  p[t][j+1]+=n/2;\n\t}\n\tif(n&1)g[i][j]=!g[i][j];\n\tp[t][j]=0;\n      }\n\n    i=j=0;\n    while(i<h && j<w)g[i][j]?j++:i++;\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint W,H,K;\nint m[1001][1001];\nint c[1001][1001];\n\nint dx[] = {0,1};\nint dy[] = {1,0};\n\nint sim(){\n\tint x = 0 , y = 0;\n\twhile(x < W && y < H){\n\n\t\tint d = c[y][x];\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n\tcout << y+1 << \" \" << x+1 << endl;\n}\n\nint main(){\n\n\twhile(cin >> H >> W >> K && H){\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tc[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tc[0][0] = K-1;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tint x = c[i][j];\n\t\t\t\tc[i+1][j] += x/2;\n\t\t\t\tc[i][j+1] += x/2;\n\t\t\t\tc[i+dy[m[i][j]]][j+dx[m[i][j]]] += x%2; \n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tc[i][j] = (c[i][j]+m[i][j])%2;\n\t\t\t}\n\t\t}\n\t\tsim();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int Height = 1000;\nconst int Width = 1000;\nbool map[Height][Width];\n\nint main()\n{\n\tint h, w, n;\n\twhile(cin >> h >> w >> n, h | w | n)\n\t{\n\t\tfor(int y=0; y < h; y++)\n\t\t\tfor(int x=0; x < w; x++) {\n\t\t\t\tcin >> map[y][x];\n\t\t\t}\n\t\tint x, y;\n\t\twhile(n--) {\n\t\t\tx = y = 0;\n\t\t\tdo {\n\t\t\t\tif(map[y][x])\n\t\t\t\t\tmap[y][x++] = false;\n\t\t\t\telse\n\t\t\t\t\tmap[y++][x] = true;\n\t\t\t}while(x < w && y < h);\n\t\t}\n\t\tcout << y+1 << ' ' << x+1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 1010\nusing namespace std;\n\nint mp[MAX][MAX],dp[MAX][MAX];\n\nvoid solve(){\n int h,w,n;\n for(;;){\n  cin>>h>>w>>n;\n  if(!h&&!w&&!n) break;\n  FOR(i,h) FOR(j,w) cin>>mp[i][j];\n  ZERO(dp);\n  dp[0][0]=n-1;\n  FOR(i,h){\n   FOR(j,w){\n    if(i+1!=h) dp[i+1][j]+=(dp[i][j]+mp[i][j]^1)>>1;\n    if(j+1!=w) dp[i][j+1]+=(dp[i][j]+mp[i][j])>>1;\n   }\n  }\n  FOR(i,h) FOR(j,w) if(dp[i][j]&1) mp[i][j]^=1;\n  int x=0,y=0;\n  while(x<h&&y<w){\n   if(mp[x][y]) y++;\n   else x++;\n  }\n  x++; y++;\n  cout<<x<<\" \"<<y<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\nbool solve(){\n    int h, w, k;\n    cin >> h >> w >> k;\n    if(!h)\n        return false;\n\n    vector<vector<int>> a(h, vector<int>(w, 0));\n    for(int i = 0; i < h; ++i)\n        for(int j = 0; j < w; ++j)\n            cin >> a[i][j];\n\n    vector<vector<i64>> dp(h, vector<i64>(w, 0));\n    dp[0][0] = k - 1;\n    for(int i = 0; i < h; ++i){\n        for(int j = 0; j < w; ++j){\n            int cnt_1 = dp[i][j] / 2 + (a[i][j] == 0 && dp[i][j] % 2);\n            int cnt_2 = dp[i][j] / 2 + (a[i][j] == 1 && dp[i][j] % 2);\n            if(i != h - 1)\n                dp[i + 1][j] += cnt_1;\n            if(j != w - 1)\n                dp[i][j + 1] += cnt_2;\n        }\n    }\n    for(int i = 0; i < h; ++i){\n        for(int j = 0; j < w; ++j){\n            a[i][j] = (dp[i][j] + a[i][j]) % 2;\n        }\n    }\n    int x = 0, y = 0;\n    while(x != h && y != w){\n        if(a[x][y])\n            ++y;\n        else\n            ++x;\n    }\n    cout << x + 1 << \" \" << y + 1 << endl;\n\n    return true;\n}\n\nsigned main(){\n\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int MAX_N=10000000;\nint h, w, n;\nint ma[1001][1001];\nvoid solve(int i, int j, int t){\n  if(i>h||j>w){\n    cout<<i<<' '<<j<<endl;\n    return;\n  }\n  bool dir;\n  dir=ma[i][j];\n  int south, east;\n  if(t){\n    if(dir){\n      south=(t-1)/2;\n      east=t/2;\n    }\n    else{\n      south=t/2;\n      east=(t-1)/2;\n    }\n    if(t-1%2){      if(dir)\n\tsolve(i,j+1,east);\n      else\n\tsolve(i+1,j,south);\n    }\n    else{\n      if(dir)\n\tsolve(i+1,j,east);\n      else\n\tsolve(i,j+1,south);\n    }\n  }\n  else{\n    if(dir)\n      solve(i,j+1,0);\n    else\n      solve(i+1,j,0);\n  }\n}\nint main(){\n  while(cin>>h>>w>>n&&h){\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcin>>ma[i][j];\n      }\n    }\n    solve(1,1, n);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 1010\nusing namespace std;\n\nint mp[MAX][MAX],dp[MAX][MAX];\n\nvoid solve(){\n int h,w,n;\n for(;;){\n  cin>>h>>w>>n;\n  if(!h&&!w&&!n) break;\n  FOR(i,h) FOR(j,w) cin>>mp[i][j];\n  ZERO(dp);\n  dp[0][0]=n-1;\n  FOR(i,h){\n   FOR(j,w){\n    if(i+1!=h) dp[i+1][j]+=(dp[i][j]+(mp[i][j]^1))>>1;\n    if(j+1!=w) dp[i][j+1]+=(dp[i][j]+mp[i][j])>>1;\n   }\n  }\n  FOR(i,h) FOR(j,w) if(dp[i][j]&1) mp[i][j]^=1;\n  int x=0,y=0;\n  while(x<h&&y<w){\n   if(mp[x][y]) y++;\n   else x++;\n  }\n  x++; y++;\n  cout<<x<<\" \"<<y<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nint field[128][128];\nint dp[128][128];\nint h,w,n;\n\nint main(){\n  \n  while(scanf(\"%d%d%d\",&h,&w,&n),h|w|n){\n    memset(dp,0,sizeof(dp));\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i+1][j+1]);\n      }\n    }\n    dp[1][1] = n-1;\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tint k1,k2;\n\tif( dp[i-1][j]%2 && field[i-1][j]==0 ){\n\t  k1 = 1;\n\t}else{\n\t  k1 = 0;\n\t}\n\tif( dp[i][j-1]%2 && field[i][j-1]==1 ){\n\t  k2 = 1;\n\t}else{\n\t  k2 = 0;\n\t}\n\n\tdp[i][j] += (dp[i-1][j]+k1)/2  + (dp[i][j-1]+k2)/2;\n      }\n    }\n#if DEB\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tprintf(\"%2d \",dp[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    \n    // Nツ嘉アツ姪堋づ個湘ウツ妥板づーツ青カツ青ャ\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tfield[i][j] = (field[i][j]+dp[i][j])%2;\n      }\n    }\n#if DEB\n    puts(\"field\");\n    REP(i,1,h+1){\n      REP(j,1,w+1){\n\tprintf(\"%2d \",field[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    \n    int x=1;\n    int y=1;\n    for(;;){\n      if( x>w || y>h )break;\n      if( field[y][x]==1 ){\n\tx++;\n      }else{\n\ty++;\n      }\n    }\n\n    printf(\"%d %d\\n\",y,x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint main(){\n  bool g[1000][1000];\n  int p[2][1000],i,j,h,w,n,t;\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&t);\n\tg[i][j]=t?true:false;\n\tp[i&1][j]=0;\n      }\n\n    p[0][0]=n-1;\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tt=i&1;\n\tn=p[t][j];\n\tp[1-t][j]+=n/2;\n\tp[t][j+1]+=n/2;\n\tif(n&1){\n\t  g[i][j]?p[t][j+1]++:p[1-t][j]++;\n\t  g[i][j]=!g[i][j];\n\t}\n\tp[t][j]=0;\n      }\n\n    i=j=0;\n    while(i<h && j<w)g[i][j]?j++:i++;\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nbool mp[1002][1002];\nint count[1002][1002];\nint main(){\n    int h,w,n;\n    while(cin>>h>>w>>n,h){\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                cin>>mp[i][j];\n            }\n        }\n        memset(count,0,(size_t)h*w*4);\n        count[0][0]=n-1;\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                mp[i][j]=mp[i][j]^(count[i][j]%2);\n                count[i][j+1] += (count[i][j]+!mp[i][j])/2;\n                count[i+1][j] += (count[i][j]+mp[i][j])/2;\n            }\n        }\n        int x=0,y=0;\n        while(x<w&&y<h){\n            if(mp[y][x]) ++x;\n            else ++y;\n        }\n        cout<<y+1<<\" \"<<x+1<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define int ll\n#define INF 999999999\n//#define INF (1LL<<59)\n\nint data[1010][1010];\nint dp[1010][1010];\n\nint h,w,n;\n\nvoid dfs(int y,int x, int num){\n\tif(num==0)return ;\n\tif(y==h||x==w)return ;\n\tdp[y][x] += num;\n\t\n\tint d=num/2, r=num/2;\n\tif(data[y][x]==0) d+=num%2;\n\tif(data[y][x]==1) r+=num%2;\n\n\tdfs(y+1,x,d);\n\tdfs(y,x+1,r);\n}\n\n\nvoid move(int y,int x){\n\tif(y==h||x==w) cout<<y+1<<\" \"<<x+1<<endl;\n\n\tif(data[y][x]==0)move(y+1,x);\n\tif(data[y][x]==1)move(y,x+1);\n}\n\n\nsigned main(){\n\tcin>>h>>w>>n;\n\t\n\trep(i,1010)rep(j,1010)data[i][j]=-1;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tcin>>data[i][j];\n\t\t}\n\t}\n\t\n\t\n\trep(i,1010)rep(j,1010)dp[i][j]=0;\n\t\n\tdfs(0,0,n-1);\n\t\n\t\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(dp[i][j]%2==1) data[i][j] = !data[i][j];\n\t\t}\n\t}\n\t\n\t\n\tmove(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef VI::iterator VII;\n\nint h, w, n;\nbool bfield[1010][1010];\nint dp[1010][1010];\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d%d\", &h, &w, &n);\n    if(!h && !w && !n)\n      break;\n\n    memset(dp, 0, sizeof dp);\n\n    for(int i = 1; i <= h; i++)\n      for(int j = 1; j <= w; j++)\n\tscanf(\"%d\", &bfield[i][j]);\n    \n    dp[1][1] = n - 1;\n    for(int i = 1; i <= h; i++)\n      for(int j = 1; j <= w; j++){\n\tif(!(dp[i][j] & 1)){\n\t  dp[i][j + 1] += dp[i][j] / 2;\n\t  dp[i + 1][j] += dp[i][j] / 2;\n\t}\n\telse{\n\t  dp[i][j + 1] += dp[i][j] / 2 + bfield[i][j];\n\t  dp[i + 1][j] += dp[i][j] / 2 + !bfield[i][j];\n\t  bfield[i][j] = !bfield[i][j];\n\t}\n      }\n    \n    int i = 1, j = 1;\n    while(i <= h && j <= w){\n      if(bfield[i][j])\n\tj++;\n      else\n\ti++;\n    }\n    \n    if(i > h)\n      printf(\"%d %d\\n\", h + 1, j);\n    else\n      printf(\"%d %d\\n\", i, w + 1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n \nusing namespace std;\n \nconst int Height = 1000;\nconst int Width = 1000;\nbool b_map[Height][Width];\nint i_map[Height+1][Width+1];\n \nint main()\n{\n    int h, w, n;\n    while(cin >> h >> w >> n, h | w | n)\n    {\n        for(int y=0; y < h; y++)\n            for(int x=0; x < w; x++) {\n                cin >> b_map[y][x];\n                i_map[y][x] = 0;\n            }\n        for(int y=0; y < h; y++) i_map[y][w] = 0;\n        for(int x=0; x < w; x++) i_map[h][x] = 0;\n        i_map[0][0] = n - 1;\n        for(int y=0; y < h; y++)\n            for(int x=0; x < w; x++) {\n                if(!i_map[y][x]) continue;\n                int num = i_map[y][x] >> 1;\n                if(i_map[y][x] & 1) {\n                    if(b_map[y][x]) {\n                        i_map[y][x+1] += num + 1;\n                        i_map[y+1][x] += num;\n                    }\n                    else {\n                        i_map[y][x+1] += num;\n                        i_map[y+1][x] += num + 1;\n                    }\n                    b_map[y][x] = !b_map[y][x];\n                }\n                else  {\n                    i_map[y+1][x] += num;\n                    i_map[y][x+1] += num;\n                }\n            }\n        int x, y;\n        x = y = 0;\n        do {\n            if(b_map[y][x])\n                x++;\n            else\n                y++;\n        }while(x < w && y < h);\n        cout << y+1 << ' ' << x+1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nint m[1010][1010];\nint fst[1010][1010], cyc1[1010][1010], cyc2[1010][1010];\nint main() {\n\tfor (int H, W, N; cin >> H >> W >> N, (H | W | N) != 0; ) {\n\t\tmemset(m, -1, sizeof(m));\n\t\trep(i, H) rep(j, W) cin >> m[i][j];\n\t\tmemset(fst, 0, sizeof(fst));\n\t\tmemset(cyc1, 0, sizeof(cyc1));\n\t\tmemset(cyc2, 0, sizeof(cyc2));\n\t\tfst[0][0] = 1;\n\t\tcyc1[0][0] = 1;\n\t\tcyc2[0][0] = 1;\n\t\trep(i, H) rep(j, W) if (i + j != 0) {\n\t\t\tint f1 = 1000000000, f2 = 1000000000;\n\t\t\tif (i > 0) {\n\t\t\t\tif (m[i - 1][j]) f1 = min(f1, fst[i - 1][j] + cyc1[i - 1][j] + cyc2[i - 1][j] - 1);\n\t\t\t\telse f1 = min(f1, fst[i - 1][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tif (m[i][j - 1]) f2 = min(f2, fst[i][j - 1]);\n\t\t\t\telse f2 = min(f2, fst[i][j - 1] + cyc1[i][j - 1] + cyc2[i][j - 1] - 1);\n\t\t\t}\n\t\t\tif (f1 == 1000000000) {\n\t\t\t\tfst[i][j] = f2;\n\t\t\t\tcyc1[i][j] = cyc2[i][j] = cyc1[i][j - 1] + cyc2[i][j - 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f2 == 1000000000) {\n\t\t\t\tfst[i][j] = f1;\n\t\t\t\tcyc1[i][j] = cyc2[i][j] = cyc1[i - 1][j] + cyc2[i - 1][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f1 < f2) {\n\t\t\t\tfst[i][j] = f1;\n\t\t\t\tcyc2[i][j] = f2 - f1;\n\t\t\t\tcyc1[i][j] = cyc1[i - 1][j] + cyc2[i - 1][j] - cyc2[i][j];\n\t\t\t}\n\t\t\tif (f1 > f2) {\n\t\t\t\tfst[i][j] = f2;\n\t\t\t\tcyc1[i][j] = f1 - f2;\n\t\t\t\tcyc2[i][j] = cyc1[i][j - 1] + cyc2[i][j - 1] - cyc1[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tN--;\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (fst[i][j] > N) continue;\n\t\t\tint n = N - fst[i][j];\n\t\t\tint mod = n % (cyc1[i][j] + cyc2[i][j]);\n\t\t\tif (cyc2[i][j] > mod) m[i][j] = m[i][j] ? 0 : 1;\n\t\t}\n\t\t\n/*\t\tcout << \"########################\" << endl;\n\t\trep(i, H) {\n\t\t\trep(j, W) cout << m[i][j] << ' ';\n\t\t\tcout << endl;\n\t\t}\n*/\t\t\n\t\tint x = 0, y = 0;\n\t\twhile (m[y][x] != -1) {\n\t\t\tif (m[y][x]) x++;\n\t\t\telse y++;\n\t\t}\n\t\tcout << y + 1 << ' ' << x + 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long ll;\n\nint h,w,k;\nll field[1001][1001];\nll loop[1001][1001];\n\ntypedef pair<ll,ll> P;\n\nconst ll dy[]={0,-1,1,0};\nconst ll dx[]={-1,0,0,1};\n\n\nvoid dp(){\n\tmemset(loop,0,sizeof(loop));\n\tloop[0][0]=k-1;\n\tfor(ll i = 0; i < h; i++){\n\t\tfor(ll j = 0; j < w; j++){\n\t\t\tll prvy=i-1;\n\t\t\tll prvx=j;\n\t\t\tif(prvy>=0&&prvx>=0&&prvy<h&&prvx<w&&loop[prvy][prvx]!=0){\n\t\t\t\tll p=field[prvy][prvx];\n\t\t\t\tif(loop[prvy][prvx]%2==0)\n\t\t\t\t\tp=1;\n\t\t\t\tloop[i][j]+=loop[prvy][prvx]/2+!p;\n\t\t\t}\n\t\t\tprvy=i;\n\t\t\tprvx=j-1;\n\t\t\tif(prvy>=0&&prvx>=0&&prvy<h&&prvx<w&&loop[prvy][prvx]!=0){\n\t\t\t\tll p=field[prvy][prvx];\n\t\t\t\tif(loop[prvy][prvx]%2==0)\n\t\t\t\t\tp=0;\n\t\t\t\tloop[i][j]+=loop[prvy][prvx]/2+p;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll gcd(ll a,ll b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\treturn a*b/gcd(a,b);\n}\n\nint main(){\n\n\twhile(cin>>h>>w>>k&&!(h==0&&w==0&&k==0)){\n\t\tfor(ll i = 0; i < h; i++){\n\t\t\tfor(ll j = 0; j < w; j++){\n\t\t\t\tll t;\n\t\t\t\tcin>>field[i][j];\n\t\t\t}\n\t\t}\n\t\tdp();\n\n\t\tfor(ll i = 0; i < 1; i++){\n\t\t\tll cx,cy;\n\t\t\tcx=cy=0;\n\t\t\twhile(1){\n\t\t\t\tif(cx>=w||cy>=h)\n\t\t\t\t\tbreak;\n\t\t\t\tif(loop[cy][cx]%2==0){\n\t\t\t\t\tif(field[cy][cx]){\n\t\t\t\t\t\tfield[cy][cx]=0;\n\t\t\t\t\t\tcx++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[cy][cx]=1;\n\t\t\t\t\t\tcy++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(!field[cy][cx]){\n\t\t\t\t\t\tfield[cy][cx]=0;\n\t\t\t\t\t\tcx++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[cy][cx]=1;\n\t\t\t\t\t\tcy++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<cy+1<<\" \"<<cx+1<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n;\nvector<vector<int>> f;\n\nbool input(){\n  int x,y;\n  cin>>x>>y;\n  cin>>n;\n  if(x==y&&y==n&&n==0)return false;\n  f.resize(x);\n  for(int i=0;i<f.size();i++){\n    f[i].resize(y);\n  }\n  for(int i=0;i<f.size();i++){\n    for(int j=0;j<f[i].size();j++){\n      cin>>f[i][j];\n    }\n  }\n  return true;\n}\n\nbool inside(vector<vector<int>> c,int x,int y){\n  if(x<0)return false;\n  if(y<0)return false;\n  if(c.size()<=x)return false;\n  if(c[x].size()<=y)return false;\n  return true;\n}\n\npair<int,int> solve(){\n  vector<vector<int>> change;\n  change.resize(f.size());\n  for(int i=0;i<change.size();i++){\n    change[i].resize(f[i].size());\n  }\n  change[0][0] = n-1;\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(inside(change,i+1,j))change[i+1][j] = change[i][j]/2;\n      if(inside(change,i,j+1))change[i][j+1] = change[i][j]/2;\n      if(change[i][j]%2){\n        if(f[i][j]==0){\n          if(inside(change,i+1,j))change[i+1][j]++;\n        }else{\n          if(inside(change,i,j+1))change[i][j+1]++;\n        }\n      }\n    }\n  }\n  /*\n  for(auto i:change){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(change[i][j]%2){\n        f[i][j] = !f[i][j];\n      }\n    }\n  }\n  /*\n  for(auto i:f){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  \n  pair<int,int> res;\n  while(res.first<change.size()&&res.second<change[0].size()){\n    if(!f[res.first][res.second]){\n      res.first++;\n    }else{\n      res.second++;\n    }\n  }\n  res.first++;\n  res.second++;\n  return res;\n}\n\n\nint main(){\n  while(input()){\n    /*\n    for(auto i:f){\n      for(auto j:i){\n        cout<<j<<\" \";\n      }cout<<endl;\n    }cout<<endl;\n    */\n    auto ans = solve();\n    cout<<ans.first<<\" \"<<ans.second<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint h,w,n,c[1000][1000];\nint dp[1001][1001];\nint d[1000][1000];\n\nint main(){\n\twhile(scanf(\"%d%d%d\",&h,&w,&n),h){\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) scanf(\"%d\",&c[i][j]);\n\t\tfor(int i=0;i<=1000;i++) for(int j=0;j<=1000;j++) dp[i][j]=0;\n\t\tdp[1][1]=n-1;\n\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++){\n\t\t\tif(i!=1){\n\t\t\t\tif(c[i-2][j-1]==0) dp[i][j]+=(dp[i-1][j]+1)/2;\n\t\t\t\telse dp[i][j]+=dp[i-1][j]/2;\n\t\t\t}\n\t\t\tif(j!=1){\n\t\t\t\tif(c[i-1][j-2]==1) dp[i][j]+=(dp[i][j-1]+1)/2;\n\t\t\t\telse dp[i][j]+=dp[i][j]/2;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++)\n\t\t\td[i][j]=(c[i][j]+dp[i+1][j+1])%2;\n\t\tint i=1,j=1;\n\t\twhile(i<=h&&j<=w){\n\t\t\tif(d[i-1][j-1]) j++;\n\t\t\telse i++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",i,j);\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1ll << 60;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\n#ifdef WIN32\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\"\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\"\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nvector < vector<bool> > east;\nint n, m, many;\nint ans_x, ans_y;\nPII r[ 10000000 ];\nset < vector<vector<bool> > > s;\nint i;\nvoid walk() {\n\tint now_x = 0, now_y = 0;\n\twhile ( now_x != n && now_y != m ) {\n\t\tif ( east[ now_x ][ now_y ] ) {\n\t\t\teast[ now_x ][ now_y ] = !east[ now_x ][ now_y ];\n\t\t\tnow_y++;\n\t\t}\n\t\telse {\n\t\t\teast[ now_x ][ now_y ] = !east[ now_x ][ now_y ];\n\t\t\tnow_x++;\n\t\t}\n\t}\n\tr[ i ] = MP( now_x, now_y );\n}\n\nvoid solve() {\n\ts.clear();\n\tfor ( i = 0; i < many; i++ ) {\n\t\tif ( s.count( east ) ) {\n\t\t\tr[ many - 1 ] = r[ many % s.size() ];\n\t\t\tbreak;\n\t\t}\n\t\twalk();\n\t}\n\tcout << r[ many - 1 ].first + 1 << \" \" << r[ many - 1 ].second + 1 << \"\\n\";\n}\n\nint main() {\n\tsrand( ( uint ) time( NULL ) );\n\tios::sync_with_stdio( false );\n\tcin.tie( 0 );\n#ifdef WIN32\n\tcout << \"Debug Mode\\n\";\n#endif\n\twhile ( cin >> n >> m >> many && n && m && many ) {\n\t\teast.resize( n, vector<bool>( m ) );\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tfor ( int j = 0; j < m; j++ ) {\n\t\t\t\tint num;\n\t\t\t\tcin >> num;\n\t\t\t\teast[ i ][ j ] = num;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000005\n#define MAX 5001\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n \nint a[1002][1002];\nint dp[1002][1002];\nint main(){\n    int h, w, n;\n    while(1){\n    scanf(\"%d%d%d\", &h, &w, &n);\n    if(!h)break;\n    fill((int*)a, (int*)(a+1002), 0);\n    fill((int*)dp, (int*)(dp+1002), 0);\n    for(int i = 1;i <= h;i++)\n    for(int j = 1;j <= w;j++)scanf(\"%d\", &a[i][j]);\n    n--;dp[1][1] = n;\n    for(int i = 1;i <= h;i++){\n        for(int j = 1;j <= w;j++){\n            dp[i][j] += dp[i][j-1]/2;\n            if(a[i][j-1] == 1)dp[i][j] += dp[i][j-1]%2;\n            dp[i][j] += dp[i-1][j]/2;\n            if(a[i-1][j] == 0)dp[i][j] += dp[i-1][j]%2;\n        }\n    }\n     \n    int y = 1, x = 1, t, f;\n    while(y <= h && x <= w){\n        f = a[y][x];\n        if(dp[y][x]%2)f = !f;\n        if(f == 0)y++;\n        else x++;\n    }\n    printf(\"%d %d\\n\", y, x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n\nint c[1010][1010],g[1010][1010];\n\nint main(){\n  int H,W,N;\n  while(true){\n    memset(c,0,sizeof(c));\n    memset(g,0,sizeof(g));\n    ///配列初期化\n\n    scanf(\"%d%d%d\",&H,&W,&N);\n    printf(\"%d%d%d\\n\",H,W,N); \n    if(H==0 && W==0 && N==0){break;}\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  scanf(\"%d\",&c[i][j]);///初期ステ読み込み\n\t  ///printf(\"%d\",c[i][j]);\n\t}///printf(\"\\n\");\n    }\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  if(g[i][j-1]%2==0){\n\t    if(g[i-1][j]%2==0)\n\t      {g[i][j]=g[i-1][j]/2+g[i][j-1]/2;}\n\t    else\n\t\t{g[i][j]=(g[i-1][j]-1)/2+g[i][j-1]/2;\n\t\t  if(c[i-1][j]==0)\n\t\t    {g[i][j] = g[i][j] +1;}\n\t\t}\n\t  }\n\t  if(g[i][j-1]%2==1){\n\t    if(g[i-1][j]%2==0)\n\t      {g[i][j] = g[i-1][j]/2 + (g[i][j-1]-1)/2;}\n\t    else\n\t      {g[i][j] = (g[i-1][j]-1)/2 + (g[i][j-1]-1)/2;\n\t\tif(c[i-1][j]==0)\n\t\t  {g[i][j]=g[i][j]+1;}\n\t      }\n\t    if(c[i][j-1]==1)\n\t      {g[i][j] = g[i][j] +1;}\n\t  }\n\t  if(i==1&&j==1){g[1][1]=N;}\n\t  ///回数判定fin\n\t}\n    }\n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  c[i][j]=(c[i][j]+g[i][j])%2;\n\t  printf (\"%d,%d \",c[i][j],g[i][j]);\n\t}\n      printf(\"\\n\");\n    }///目的のマップ\n    \n    int x,y;///Let's walking\n    x=1;\n    y=1;\n    while(x<=H&&y<=W)      \n      {\n\tif(c[x][y]==0)\n\t  {y=y+1;}\n\telse\n\t  {x=x+1;}\n      }\n    \n\n\n\n    printf(\"%d %d\\n\",x,y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint a[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w)scanf(\"%d\", &a[i][j]);\n\t\trep(i, n) {\n\t\t\tint x = 0, y = 0;\n\t\t\twhile (x < h&&y < w) {\n\t\t\t\ta[x][y] = !a[x][y];\n\t\t\t\tif (a[x][y])x++;\n\t\t\t\telse y++;\n\t\t\t}\n\t\t\tif (i == n - 1)printf(\"%d %d\\n\", x + 1, y + 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_H 1111\nint H,W,N;\nint ro[MAX_H][MAX_H];\nint cou[MAX_H][MAX_H];\nint main()\n{\n\twhile(true){\n\tscanf(\"%d%d%d\",&H,&W,&N);\n\tif(H==0)break;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%d\",&ro[i][j]);\n\t\t}\n\t}\n\tcou[0][0]=N-1;\n\tfor(int j=0;j<W;j++){\n\t\tif(cou[0][j]&1){\n\t\t\tif(ro[0][j]==1){\n\t\t\t\tcou[0][j+1]=1+(cou[0][j]>>1);\n\t\t\t\tcou[1][j]=cou[0][j]-cou[0][j+1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcou[1][j]=1+(cou[0][j]>>1);\n\t\t\t\tcou[0][j+1]=cou[0][j]-cou[1][j];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcou[0][j+1]=(cou[0][j]>>1);\n\t\t\tcou[1][j]=(cou[0][j]>>1);\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tro[i][j]=(ro[i][j]+cou[i][j])&1;\n\t\t}\n\t}\n\tint ans1=0,ans2=0;\n\twhile(ans1<H&&ans2<W){\n\t\tif(ro[ans1][ans2]==1){\n\t\t\tans2++;\n\t\t}\n\t\telse{\n\t\t\tans1++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",ans1+1,ans2+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint h,w,n;\nint f[1111][1111];\nint m[1111][1111];\nint dx[] = {0,1};\nint dy[] = {1,0};\nint main(void){\n  while(cin >> h >> w >> n && h){\n    m[0][0] = n-1;\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n\tcin >> f[x][y];\n\tfor(int k = 0; k < 2; k++){\n\t  int nx = x + dx[k];\n\t  int ny = y + dy[k];\n\t  m[nx][ny] += (m[x][y] + ((f[x][y] == k)?1:0) )/2;\n\t}\n\tif(m[x][y] % 2) f[x][y] = (f[x][y]+1)%2;\n      }\n    }\n\n    int x = 0,y = 0;\n    while(x != w && y != h){\n      int nx = x + dx[f[x][y]];\n      int ny = y + dy[f[x][y]];\n      x = nx;\n      y = ny;\n    }\n    cout << y+1 << \" \" << x+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1000;\n\nint h, w, n, dp[N][N], data[N][N];\n\nmain(){\n  while(cin >> h >> w >> n && (h|w|n)){\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> data[i][j];\n    dp[0][0] = n-1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(i == 0 && j == 0) continue;\n        int s = 0, e = 0;\n        if(i){\n          if(dp[i-1][j] % 2){\n            if(!data[i-1][j]) s = (dp[i-1][j] + 1) / 2;\n            else s = (dp[i-1][j] - 1) / 2;\n          }else s = dp[i-1][j] / 2;\n        }\n        if(j){\n          if(dp[i][j-1] % 2){\n            if(data[i][j-1]) e = (dp[i][j-1] + 1) / 2;\n            else e = (dp[i][j-1] - 1) / 2;\n          }else e = dp[i][j-1] / 2;\n        }\n        dp[i][j] = s + e;\n      }\n    }\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++) if(dp[i][j] % 2) data[i][j] = 1 - data[i][j];\n    int y = 0, x = 0;\n    while(1){\n      if(y >= h || x >= w) break;\n      if(data[y][x]) x++;\n      else y++;\n    }\n    cout << y + 1 << ' ' << x + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint d[1024][1024];\nint dp[1024][1024];\nint H,W,N;\n\n\nint main(){\n  while(scanf(\"%d%d%d\",&H,&W,&N) && H||W||N){\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) scanf(\"%d\", &d[i][j]);\n    memset(dp, 0, sizeof dp);\n    dp[0][0] = N-1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tdp[i+1][j] += (dp[i][j]+d[i][j]^1)/2;\n\tdp[i][j+1] += (dp[i][j]+d[i][j])  /2;\n      }\n    }\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) d[i][j] = (d[i][j]+dp[i][j])%2;\n    int y = 0, x = 0;\n    while(y < H && x < W){\n      if(d[y][x]) x++;\n      else y++;\n    }\n    printf(\"%d %d\\n\", y+1, x+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool ba[1000][1000];\nint dx[] = {0,1};\nint dy[] = {1,0};\nint h, w;\n\nvoid solve(int x, int y, int n) {\n//  cout << x << \" \" << y << endl;\n  if (x >= w || y >= h) {\n    cout << y+1 << \" \" << x+1 << endl;\n    //  cout << endl;\n    return;\n  }\n  bool d;\n  if (n%2) {\n    d = ba[x][y];\n  } else {\n    d = !ba[x][y];\n  }\n  solve(x+dx[d], y+dy[d], (n+1)/2);\n}\n\nint main() {\n  int n;\n  while(cin>>h>>w>>n,h||w||n) {\n    REP(y,h) REP(x,w)\n      cin >> ba[x][y];\n    solve(0,0,n);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX_H = 1000;\nstatic const int MAX_W = 1000;\n\nint H, W, N;\nint field[MAX_H][MAX_W];\nint memo[MAX_H][MAX_W];\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d %d %d\", &H, &W, &N);\n\t\tif(H == 0 && W == 0 && N == 0) break;\n\t\tfill(memo[0], memo[H], 0);\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &field[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(i == 0 && j == 0) memo[i][j] = N - 1;\n\t\t\t\tif(memo[i][j] % 2 == 0){\n\t\t\t\t\tmemo[i + 1][j] += memo[i][j] / 2;\n\t\t\t\t\tmemo[i][j + 1] += memo[i][j] / 2;\n\t\t\t\t}else{\n\t\t\t\t\tif(field[i][j] == 0){\n\t\t\t\t\t\tmemo[i + 1][j] += memo[i][j] / 2 + 1;\n\t\t\t\t\t\tmemo[i][j + 1] += memo[i][j] / 2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmemo[i + 1][j] += memo[i][j] / 2;\n\t\t\t\t\t\tmemo[i][j + 1] += memo[i][j] / 2 + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint i = 0, j = 0;\n\t\tfor(;;){\n\t\t\tif(i == H || j == W){\n\t\t\t\tprintf(\"%d %d\\n\", i + 1, j + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif((memo[i][j] + field[i][j]) % 2 == 0) i++;\n\t\t\telse j++;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[1005][1005];bool e[1005][1005];\nint a,b,c;\nsigned main(){\n   while(cin>>a>>b>>c,a|b|c){\n       memset(d,0,sizeof(d));\n       memset(e,false,sizeof(e));\n   for(int f=0;f<a;f++){\n       for(int g=0;g<b;g++){\n\t   scanf(\"%d\",&e[f][g]);\n\t   }\n       }\n       d[0][0]=c-1;\n       for(int h=0;h<a+b-1;h++){\n\t   for(int i=0;i<=h;i++){\n\t       int x=i,y=h-i;\n\t       if(d[x][y]&1){\n\t\t   if(e[x][y]){\n\t\t       d[x+1][y]+=d[x][y]/2;d[x][y+1]+=d[x][y]/2+1;\n\t\t       }\n\t\t   else {\n\t\t       d[x+1][y]+=d[x][y]/2+1;d[x][y+1]+=d[x][y]/2;\n\t\t       }\n\t\t   }\n\t\telse {d[x+1][y]+=d[x][y]/2;d[x][y+1]+=d[x][y]/2;}\n\t\te[x][y]=(e[x][y]+d[x][y])&1;\n\t       }\n\t   }\n\tint x=0,y=0;\n\twhile(1){\n\t    if(x==a||y==b){cout<<x+1<<\" \"<<y+1<<endl;break;}\n\t    if(e[x][y])y++;\n\t    else x++;\n\t    }\n\t}\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nenum Direction{SOUTH,EAST};\n\nint main()\n{\n  int H,W,N;\n  int y,x;\n  while(cin>>H>>W>>N,H|W|N){\n    vector< vector<int> >v(H,vector<int>(W));\n    vector< vector<int> >dp(H,vector<int>(W,0));\n    for(int i=0;i<H;i++)for(int j=0;j<W;j++)cin>>v[i][j];\n    dp[0][0]=N-1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(i-1>=0){\n\t  if(dp[i-1][j]&1){\n\t    if(v[i-1][j]==SOUTH)dp[i][j]+=(dp[i-1][j]+1)/2;\n\t    else dp[i][j]+=(dp[i-1][j]-1)/2;\n\t  }else{\n\t    dp[i][j]+=dp[i-1][j]/2;\n\t  }\n\t}\n\tif(j-1>=0){\n\t  if(dp[i][j-1]&1){\n\t    if(v[i][j-1]==EAST)dp[i][j]+=(dp[i][j-1]+1)/2;\n\t    else dp[i][j]+=(dp[i][j-1]-1)/2;\n\t  }else{\n\t    dp[i][j]+=dp[i][j-1]/2;\n\t  }\n\t}\n      }\n    }\n    y=x=0;\n    while(x<W && y<H){\n      v[y][x]+=dp[y][x];\n      v[y][x]&=1;\n      if(v[y][x]==SOUTH)y++;\n      else x++;\n    }\n    cout<<y+1<<\" \"<<x+1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\ntypedef struct\n{\n\tint x;\n\tint y;\n} pos;\n\nint N,H,W,M[1000][1000],C[1001][1001];\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> H >> W >> N;\n\t\tif(H == 0 && W == 0 && N == 0)\n\t\t\texit(0);\n\t\tmemset(M,0,sizeof(int[1000][1000]));\n\t\tmemset(C,0,sizeof(int[1001][1001]));\n\t\tfor(int y = 0;y < H;y++)\n\t\t{\n\t\t\tfor(int x = 0;x < W;x++)\n\t\t\t{\n\t\t\t\tcin >> M[x][y];\n\t\t\t}\n\t\t}\n\t\tC[0][0] = N-1;\n\t\tfor(int y = 0;y < H;y++)\n\t\t{\n\t\t\tfor(int x = 0;x < W;x++)\n\t\t\t{\n\t\t\t\tC[x][y+1] += C[x][y] / 2;\n\t\t\t\tC[x+1][y] += C[x][y] / 2;\n\t\t\t\tif(C[x][y] % 2 == 1)\n\t\t\t\t{\n\t\t\t\t\tif(M[x][y] == 0)\n\t\t\t\t\t\tC[x][y+1]++;\n\t\t\t\t\telse\n\t\t\t\t\t\tC[x+1][y]++;\n\t\t\t\t\tM[x][y] = (M[x][y] + 1) % 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpos cp;\n\t\tcp.x = 0;\n\t\tcp.y = 0;\n\t\twhile(cp.x != W && cp.y != H)\n\t\t{\n\t\t\tif(M[cp.x][cp.y] == 0)\n\t\t\t\tcp.y++;\n\t\t\telse\n\t\t\t\tcp.x++;\n\t\t}\n\t\tcout << cp.y+1 << \" \" << cp.x+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dy[2]={1,0};\nint dx[2]={0,1};\n\nint y,x,ny,nx,a,b;\nint H,W,N;\nint t[1001][1001];\nint u[1001][1001];\n\n\nint main(){\n  while(cin>>H>>W>>N&&H&&W&&N){\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n\tcin>>t[i][j];\n\tu[i][j]=0;\n      }\n    }\n    u[1][1]=N;\n    y=x=1;\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n\tif(u[i][j]==0)continue;\n\ta=t[i][j],b=1-a;\n\tny=y+dy[a],nx=x+dx[a];\n\tu[ny][nx]+=(u[i][j]-u[i][j]/2);\n\tny=y+dy[b],nx=x+dx[b];\n\tu[ny][nx]+=(u[i][j]/2);\n\tif(y==i&&x==j){\n\t  if(u[i][j]%2==1)y=y+dy[a],x=x+dx[a];\n\t  else y=y+dy[b],x=x+dx[b];\n\t}\n      }\n    }\n    cout<<y<<' '<<x<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#define rep(i,n) for(int i=1;i<=n;i++)\nint h,w,n;\nbool c[1002][1002];\nint t[1002][1002];\n\nint main(){\n  while(cin>>h>>w>>n,h){\n    rep(i,h)rep(j,w)cin>>c[i][j];\n    rep(i,h+1)rep(j,w+1)t[i][j]=0;\n    t[1][1]=n;\n    rep(i,h){\n      rep(j,w){\n        t[i+1][j]+=t[i][j]/2;\n        t[i][j+1]+=t[i][j]/2;\n        if(t[i][j]%2){\n          if(c[i][j])t[i][j+1]++;\n          else t[i+1][j]++;\n        }\n      }\n    }\n    #ifdef DEBUG\n    rep(i,h){\n      rep(j,w)cout<<c[i][j]<<\" \";\n      cout<<endl;\n    }\n    rep(i,h+1){\n      rep(j,w+1)cout<<t[i][j]<<\" \";\n      cout<<endl;\n    }\n    #endif\n    int i=1,j=1;\n    while(i<=h&&j<=w){\n      if((t[i][j]-c[i][j])%2){\n        i++;\n      }else{\n        j++;\n      }\n    }\n    cout<<i<<\" \"<<j<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nvoid solve(int H,int W,int N) {\n    int moji[H][W];\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            cin >> moji[i][j]; // 0->south / 1->east\n        }\n    }\n\n    int h,w;\n    for(int i=0; i<N; ++i) {\n        h=0; w=0;\n        while(h<H && w<W) {\n            if(moji[h][w]==0) {\n                moji[h][w]=1;\n                ++h;\n            } else {\n                moji[h][w]=0;\n                ++w;\n            }\n        }\n    }\n\n    cout << h+1 << \" \" << w+1 << endl;\n\n    return;\n}\n\nint main() {\n    int H,W,N;\n    while(true) {\n        cin >> H >> W >> N;\n        if(H==0 && W==0 && N==0) break;\n        solve(H,W,N);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstring>\n \n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n#define all(v) v.begin(), v.end()\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nconst int INF = 1<<29;\n\nint v[1001][1001];\nint cnt[1001][1001];\nint main(){\n\tint h, w, n;\n\twhile(cin >> h >> w >> n, h|w|n){\n        FOR(i, 1, h+1) FOR(j, 1, w+1) cin >> v[i][j];\n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                if(i == 1 && j == 1){\n                    cnt[i][j] = n-1;\n                    continue;\n                }\n                cnt[i][j] = (!v[i-1][j]+cnt[i-1][j])/2+(v[i][j-1]+cnt[i][j-1])/2;\n            }\n        }\n        int x = 1, y = 1;\n        while(x <= w && y <= h){\n            if((v[y][x]+cnt[y][x])%2)x++;\n            else y++;\n        }\n        cout << y << ' ' << x << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint w, h, n;\nint y, x;\nint dp[1000][1000];\nint table[1000][1000];\n\nvoid solve(){\n\tmemset(dp,0,sizeof(dp));\n\tx = 0; y = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++) scanf(\"%d\", &table[i][j]);\n\t}\n\tdp[0][0] = n-1;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(dp[i][j]%2){\n\t\t\t\tif(table[i][j]){\n\t\t\t\t\tif(j != w-1) dp[i][j+1] += dp[i][j]/2+1;\n\t\t\t\t\tif(i != h-1) dp[i+1][j] += dp[i][j]/2;\n\t\t\t\t} else{\n\t\t\t\t\tif(j != w-1) dp[i][j+1] += dp[i][j]/2;\n\t\t\t\t\tif(i != h-1) dp[i+1][j] += dp[i][j]/2+1;\n\t\t\t\t}\n\t\t\t\ttable[i][j] = (table[i][j]+1)%2;\n\t\t\t} else{\n\t\t\t\tif(j != w-1) dp[i][j+1] += dp[i][j]/2;\n\t\t\t\tif(i != h-1) dp[i+1][j] += dp[i][j]/2;\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tif(y == h || x == w){\n\t\t\tprintf(\"%d %d\\n\", y+1, x+1);\n\t\t\tbreak;\n\t\t}\n\t\tif(table[y][x]){\n\t\t\tx++;\n\t\t} else{\n\t\t\ty++;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d%d\", &h, &w, &n), w||h||n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nint f[1001][1001];\nint ct[1001][1001];\n\nint main()\n{\n    int H,W,N;\n    while(scanf(\" %d %d %d\", &H, &W, &N),H)\n    {\n        rep(i,H)rep(j,W) scanf(\" %d\", &f[i][j]);\n\n        queue<pi> que;\n        que.push(pi(0,0));\n        ct[0][0]=N-1;\n\n        #define IN(x,y) (0<=x && x<W && 0<=y && y<H)\n        int dx[2]={0,1}, dy[2]={1,0};\n        while(!que.empty())\n        {\n            pi p=que.front();\n            que.pop();\n\n            int x=p.se, y=p.fi;\n            rep(i,2)\n            {\n                int nx=x+dx[i], ny=y+dy[i];\n                if(IN(nx,ny))\n                {\n                    int nct=ct[y][x]/2;\n                    if(ct[y][x]%2==1 && f[y][x]==i) ++nct;\n\n                    ct[ny][nx]=nct;\n                    que.push(pi(ny,nx));\n                }\n            }\n        }\n\n        int X=0,Y=0;\n        while(IN(X,Y))\n        {\n            int d=(f[Y][X]+ct[Y][X])%2;\n            // printf(\"X,Y %d %d  : f= %d, ct= %d -> d= %d\\n\", X,Y,f[Y][X],ct[Y][X],d);\n\n            X+=dx[d];\n            Y+=dy[d];\n\n        }\n        printf(\"%d %d\\n\", Y+1,X+1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint d[1024][1024];\nint dp[1024][1024];\nint H,W,N;\n\n\nint main(){\n  while(scanf(\"%d%d%d\",&H,&W,&N) && H||W||N){\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) scanf(\"%d\", &d[i][j]);\n    memset(dp, 0, sizeof dp);\n    dp[0][0] = N-1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tdp[i+1][j] = (dp[i][j]+d[i][j]^1)/2;\n\tdp[i][j+1] = (dp[i][j]+d[i][j])  /2;\n      }\n    }\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) d[i][j] = (d[i][j]+dp[i][j])%2;\n    int y = 0, x = 0;\n    while(y < H && x < W){\n      if(d[y][x]) x++;\n      else y++;\n    }\n    printf(\"%d %d\\n\", y+1, x+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W,N;\nint** table;\nint** dp;\n\nvoid func(){\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tscanf(\"%d\",&table[i][k]);\n\t\t\tdp[i][k] = 0;\n\t\t}\n\t}\n\n\tdp[0][0] = N-1;\n\tfor(int i = 1; i < W; i++){\n\t\tif(dp[0][i-1]%2 == 0){\n\t\t\tdp[0][i] = dp[0][i-1]/2;\n\t\t}else{\n\t\t\tif(table[0][i-1] == 1){\n\t\t\t\tdp[0][i] = (dp[0][i-1]+1)/2;\n\t\t\t}else{\n\t\t\t\tdp[0][i] = (dp[0][i-1]-1)/2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 1; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(col > 0){\n\t\t\t\tif(dp[row][col-1]%2 == 0){\n\t\t\t\t\tdp[row][col] += dp[row][col-1]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(table[row][col-1] == 1){\n\t\t\t\t\t\tdp[row][col] += (dp[row][col-1]+1)/2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[row][col] += (dp[row][col-1]-1)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(dp[row-1][col]%2== 0){\n\t\t\t\tdp[row][col] += dp[row-1][col]/2;\n\t\t\t}else{\n\t\t\t\tif(table[row][col-1] == 0){\n\t\t\t\t\tdp[row][col] += (dp[row-1][col]+1)/2;\n\t\t\t\t}else{\n\t\t\t\t\tdp[row][col] += (dp[row-1][col]-1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(dp[row][col]%2==1){\n\t\t\t\ttable[row][col] = 1 - table[row][col];\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans_row = 0,ans_col = 0;\n\twhile(ans_row < H && ans_col < W){\n\t\tif(table[ans_row][ans_col] == 0){\n\t\t\tans_row++;\n\t\t}else{\n\t\t\tans_col++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",ans_row+1,ans_col+1);\n\n}\n\n\nint main(){\n\n\ttable = new int*[1001];\n\tdp = new int*[1001];\n\tfor(int i = 0; i < 1001; i++){\n\t\ttable[i] = new int[1001];\n\t\tdp[i] = new int[1001];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&N);\n\t\tif(H == 0 && W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nint main(){\n  queue<POS> check;\n  long next[201][201],field[201][201],n;\n  bool flag[201][201];\n  int h,w;\n  while(cin >>h>>w>>n,h||w||n){\n    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    while(!check.empty()){\n      POS p = check.front();\n      if(next[p.x][p.y]>0 && p.x<w && p.y<h){\n\tif(next[p.x][p.y]%2 == 0){\n\t  next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t  next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t}\n\telse{\n\t  if(field[p.x][p.y] == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t  }\n\t  else{\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t}\n\ta.x = p.x+1;a.y = p.y;\n\tif(!flag[a.x][a.y]){\n\t  check.push(a);\n\t  flag[a.x][a.y] = true;\n\t}\n\ta.x = p.x;a.y = p.y+1;\n\tif(!flag[a.x][a.y]){\n\t  check.push(a);\n\t  flag[a.x][a.y] = true;\n\t}\n      }\n      check.pop();\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n    }\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nint mo[5] = {0,1,0,-1,0};\n\nvoid calc(int h,int w,int n){\n    int in[1000][1000],dp[1001][1001]={0},x=0,y=0;\n    \n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n            scanf(\"%d\",&in[i][j]);\n    \n    dp[0][0]=n-1;\n    \n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++){\n            dp[i+1][j]+=(dp[i][j]+1-in[i][j])/2;\n            dp[i][j+1]+=(dp[i][j]+in[i][j])/2;\n        }\n    \n    while(x<w && y<h){\n        if((dp[y][x]+in[y][x])%2)\n            x++;\n        else\n            y++;\n    }\n    \n    printf(\"%d %d\\n\",y+1,x+1);\n    \n}\n\nint main(){\n    int h,w,n;\n    \n    while(1){\n        scanf(\"%d%d%d\",&h,&w,&n);\n        \n        if(h==0) break;\n        \n        calc(h,w,n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint main(){\n  bool grid[1000][1000];\n  int num[1001][1001],i,j,h,w,n,t;\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&t);\n\tgrid[i][j] = t?true:false;\n\tnum[i][j] = 0;\n      }\n\n    num[0][0] = n-1;\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tint N=num[i][j];\n\tif(grid[i][j]){\n\t  num[i+1][j] += N/2;\n\t  num[i][j+1] += N-N/2;\n\t}else{\n\t  num[i][j+1] += N/2;\n\t  num[i+1][j] += N-N/2;\n\t}\n\tif(N&1)grid[i][j] = !grid[i][j];\n      }\n\n    i=j=0;\n    while(i<h && j<w)grid[i][j]?j++:i++;\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int h,w,n;scanf(\"%d%d%d\",&h,&w,&n),h;){\n\t\tstatic int B[1000][1000];\n\t\trep(i,h) rep(j,w) scanf(\"%d\",B[i]+j);\n\n\t\tstatic int dp[1000][1000];\n\t\trep(i,h) rep(j,w) dp[i][j]=0;\n\t\tdp[0][0]=n-1;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(i<h-1) dp[i+1][j]+=(dp[i][j]+(B[i][j]==1?0:1))/2;\n\t\t\tif(j<w-1) dp[i][j+1]+=(dp[i][j]+(B[i][j]==0?0:1))/2;\n\t\t}\n\n\t\tint y=0,x=0;\n\t\twhile(y<h && x<w) if((B[y][x]+dp[y][x])%2==0) y++; else x++;\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint dp[1002][1002],field[1002][1002];\nint main() {\n\tint H,W,N;\n\twhile(scanf(\"%d %d %d\",&H,&W,&N),H|W|N) {\n\t\tfor(int y=1;y<=H;y++) {\n\t\t\tfor(int x=1;x<=W;x++) {\n\t\t\t\tscanf(\"%d\",&field[x][y]);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[1][1]=N-1;\n\t\tfor(int y=1;y<=(H+1);y++) {\n\t\t\tfor(int x=1;x<=(W+1);x++) {\n\t\t\t\tif(dp[x][y-1]&1) {\n\t\t\t\t\tif(!field[x][y-1]) dp[x][y]+=(dp[x][y-1]+1)/2; else dp[x][y]+=(dp[x][y-1]-1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tdp[x][y]+=dp[x][y-1]/2;\n\t\t\t\t}\n\t\t\t\tif(dp[x-1][y]&1) {\n\t\t\t\t\tif(field[x-1][y]) dp[x][y]+=(dp[x-1][y]+1)/2; else dp[x][y]+=(dp[x-1][y]-1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tdp[x][y]+=dp[x-1][y]/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x=1,y=1;\n\t\twhile(x<=W&&y<=H) {\n\t\t\tif((field[x][y]+dp[x][y])&1) x++; else y++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",y,x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nenum Direction{SOUTH,EAST};\n\nint v[1002][1002],dp[1002][1002];\nint main()\n{\n  int H,W,N;\n  int y,x;\n  while(cin>>H>>W>>N,H|W|N){\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>v[i][j];\n    dp[1][1]=N-1;\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n\tif(dp[i-1][j]&1){\n\t  if(v[i-1][j]==SOUTH)dp[i][j]+=(dp[i-1][j]+1)/2;\n\t  else dp[i][j]+=(dp[i-1][j]-1)/2;\n\t}else{\n\t  dp[i][j]+=dp[i-1][j]/2;\n\t}\n\tif(dp[i][j-1]&1){\n\t  if(v[i][j-1]==EAST)dp[i][j]+=(dp[i][j-1]+1)/2;\n\t  else dp[i][j]+=(dp[i][j-1]-1)/2;\n\t}else{\n\t  dp[i][j]+=dp[i][j-1]/2;\n\t}\n      }\n    }\n    y=x=1;\n    while(x<=W && y<=H){\n      v[y][x]^=dp[y][x]&1;\n      //cout<<y<<\",\"<<x<<\":\"<<v[y][x]<<endl;\n      if(v[y][x]==SOUTH)y++;\n      else x++;\n    }\n    cout<<y<<\" \"<<x<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int H, W, N;\n    int dp[1005][1005] = {};\n    int mas[1005][1005];\n    cin >> H >> W >> N;\n    dp[0][0] = N - 1;\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            cin >> mas[i][j];\n            if(dp[i][j] % 2 == 0) {\n                dp[i + 1][j] += dp[i][j] / 2;\n                dp[i][j + 1] += dp[i][j] / 2;\n            } else {\n                dp[i + 1][j] += dp[i][j] / 2 + 1 - mas[i][j];\n                dp[i][j + 1] += dp[i][j] / 2 + mas[i][j];\n            }\n            (mas[i][j] += dp[i][j] % 2) %= 2;\n        }\n    }\n    int x = 0, y = 0;\n    while(x < W && y < H) {\n        if(mas[y][x] == 0) y++;\n        else x++;\n    }\n    cout << y + 1 << \" \" << x + 1 << endl;\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nqueue<POS> check;\nlong n,field[201][201];//,next[201][201];\n//bool flag[201][201];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    /*    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n      }*/\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    //    next[0][0] = n-1;\n    POS a;\n    //    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    /*    while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n      }*/\n    /*    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n      }*/\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint dx[] = {0,1};\nint dy[] = {1,0};\nint mp[1024][1024];\nint dp[1024][1024];\n\nint main()\n{\n\tint H,W,N;\n\twhile(cin>>H>>W>>N, H||W||N)\n\t{\n\t\tfor(int y=0; y<H; y++)\n\t\tfor(int x=0; x<W; x++)\n\t\t{\n\t\t\tcin >> mp[y][x];\n\t\t}\n\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tdp[0][0] = N-1;\n\t\tfor(int y=0; y<H; y++)\n\t\tfor(int x=0; x<W; x++)\n\t\tfor(int i=0; i<2; i++)\n\t\t{\n\t\t\tint ny = y+dy[i];\n\t\t\tint nx = x+dx[i];\n\t\t\tif(ny<H && nx<W)\n\t\t\t{\n\t\t\t\tint s = (mp[y][x]==i?1:0);\n\t\t\t\tdp[ny][nx] += (dp[y][x]+s)/2;\n\t\t\t}\n\t\t}\n\n\t\tint y=0,x=0;\n\t\twhile(y<H && x<W)\n\t\t{\n\t\t\tint s = (mp[y][x]+dp[y][x])%2;\n\t\t\ty = y+dy[s];\n\t\t\tx = x+dx[s];\n\t\t}\n\n\t\tcout << y+1 << \" \" << x+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)    (x).begin(),(x).end()\n# define UNIQ(c)   (c).erase(unique(ALL((c))), end((c)))\n# define mp        make_pair\n# define eb        emplace_back\n# define REP(i, a) for (int i = 0; i < (a); i++)\n# define INIT      std::ios::sync_with_stdio(false);std::cin.tie(0);\n \nint maze[1010][1010], dp[1010][1010], h, w, n;\n \nint main() {\n\tcin >> h >> w >> n;\n\tfor (int i = 1; i <= h; i++)for (int j = 1; j <= w; j++) {\n\t\tcin >> maze[i][j];\n\t}\n\tn--, dp[1][1] = n;\n \n\tfor (int i = 1; i <= h; i++) for (int j = 1; j <= w; j++) {\n\t\tdp[i][j] += dp[i][j - 1]/2;\n\t\tif (maze[i][j - 1] == 1)dp[i][j] += dp[i][j - 1] % 2;\n\t\tdp[i][j] += dp[i - 1][j] / 2;\n\t\tif (maze[i - 1][j] == 0)dp[i][j] += dp[i - 1][j] % 2;\n\t}\n \n\tint y = 1, x = 1, t, f;\n\twhile (y <= h && x <= w) {\n\t\tf = maze[y][x];\n\t\tif (dp[y][x] % 2)f = !f;\n\t\tif (f == 0)y++;\n\t\telse x++;\n\t}\n \n\tcout << y << \" \" << x << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y+1 < H) dp[y+1][x] += ((dp[y][x] + (direction[y][x] == 0 ? 1:0)) / 2);\n\tif(x+1 < W) dp[y][x+1] += ((dp[y][x] + (direction[y][x] == 1 ? 1:0)) / 2);\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    for(int round = 0; round <= 1010; round++){\n      if(y == H || x == W) break;\n      if((dp[y][x] + direction[y][x]) % 2 == 0) y++;\n      else if((dp[y][x] + direction[y][x]) % 2 == 1) x++;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\ntypedef pair<int,int> P;\nint H,W,N;\nint X[1000][1000];\nP change()\n{\n\tint x=0,y=0;\n\twhile(x<W&&y<H){\n\t\tif(X[y][x]){\n\t\t\tx++;\n\t\t\tX[y][x-1]=0;\n\t\t}\n\t\telse{\n\t\t\ty++;\n\t\t\tX[y-1][x]=1;\n\t\t}\n\t}\n\treturn P(y,x);\n}\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d%d%d\",&H,&W,&N);\n\t\tif(H==0&&W==0&&N==0)break;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tscanf(\"%d\",&X[i][j]);\n\t\t\t}\n\t\t}\n\t\tint ans1=0;int ans2=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(i==N-1){\n\t\t\t\tP p=change();\n\t\t\t\tans1=p.first;\n\t\t\t\tans2=p.second;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tP p=change();\n\t\t\t\t//printf(\"%d %d\\n\",p.first+1,p.second+1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",ans2+1,ans1+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int h,w,n,i,j;\n  int a[1001][1001];\n  int b[101][101][4];\n\n  while(1){\n    cin >> h >> w >> n;\n    if(n == 0)break;\n\n    for(i = 0;i < h;i++){\n      for(j = 0;j < w;j++){\n\tcin >> a[i][j];\n      }\n    }\n    // 0,0テ・ツョツ堙ァツセツゥ\n    b[0][0][2] = n-1;\n    if((n-1)%2 == 0){\n      b[0][0][0] = b[0][0][2]/2;\n      b[0][0][1] = b[0][0][2]/2;\n    }\n    else if(a[0][0] == 1){\n      b[0][0][0] = b[0][0][2]/2;\n      b[0][0][1] = (b[0][0][2]/2) + 1;\n    }\n    else if(a[0][0] == 0){\n      b[0][0][0] = (b[0][0][2]/2) + 1;\n      b[0][0][1] = b[0][0][2]/2;\n    }\n\n    //テ、ツクツ甘ヲツョツオテ・ツョツ堙ァツセツゥ\n    for(j = 1;j < w;j++){\n      b[0][j][2] = b[0][j-1][1];\n      \n      if(b[0][j][2]%2 == 0){\n\tb[0][j][0] = b[0][j][2]/2;\n\tb[0][j][1] = b[0][j][2]/2;\n      }\n      else if(a[0][j] == 1 && b[0][j][2]%2 == 1){\n\tb[0][j][0] = b[0][j][2]/2;\n\tb[0][j][1] = (b[0][j][2]/2) + 1;\n      }\n      else if(a[0][j] == 0 && b[0][j][2]%2 == 1){\n\tb[0][j][0] = (b[0][j][2]/2) + 1;\n\tb[0][j][1] = b[0][j][2]/2;\n      }\n    }\n\n    //テ・ツキツヲテ・ツ按療・ツョツ堙ァツセツゥ\n    for(i = 1;i < h;i++){\n      b[i][0][2] = b[i-1][0][0];\n      \n      if(b[i][0][2]%2 == 0){\n\tb[i][0][0] = b[i][0][2]/2;\n\tb[i][0][1] = b[i][0][2]/2;\n      }\n      else if(a[i][0] == 1 && b[i][0][2]%2 == 1){\n\tb[i][0][0] = b[i][0][2]/2;\n\tb[i][0][1] = (b[i][0][2]/2) + 1;\n      }\n      else if(a[i][0] == 0 && b[0][j][2]%2 == 1){\n\tb[i][0][0] = (b[i][0][2]/2) + 1;\n\tb[i][0][1] = b[i][0][2]/2;\n      }\n    }\n\n    //テ、ツクツュテ・ツョツ堙ァツセツゥ\n    for(i = 1;i < h;i++){\n      for(j = 1;j < w;j++){\t\n\tb[i][j][2] = b[i-1][j][0] + b[i][j-1][1];\n\n\tif(b[i][j][2]%2 == 0){\n\t  b[i][j][0] = b[i][j][2]/2;\n\t  b[i][j][1] = b[i][j][2]/2;\n\t}\n\telse if(a[i][j] == 1 && b[i][j][2]%2 == 1){\n\t  b[i][j][0] = b[i][j][2]/2;\n\t  b[i][j][1] = b[i][j][2]/2 + 1;\n\t}\n\telse if(a[i][j] == 0 && b[i][j][2]%2 == 1){\n\t  b[i][j][0] = b[i][j][2]/2 + 1;\n\t  b[i][j][1] = b[i][j][2]/2;\n\t}\n      }\n    }\n\n\n    i=j=0;\n    while(1){\n      if(i == h || j == w)break;\n      if(a[i][j] == 1){\n\tif(b[i][j][2]%2 == 0)j++;\n\telse i++;\n      }\n      else if(a[i][j] == 0){\n\tif(b[i][j][2]%2 == 0)i++;\n\telse j++;\n      }\n    }\n    cout << i+1 << \" \" << j+1 <<endl;\n  }\n  return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint w,h,n;\n\t\n\twhile(cin >> h >> w >> n){\n\t\tif(!(w|h|n)) break;\n\t\t\n\t\tbool dir[h][w];\n\t\tint dp[h+1][w+1],t;\n\t\tfill((int *)dp, (int *) dp + (h+1) * (w+1), 0);\n\t\tdp[0][0] = n-1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> t;\n\t\t\t\tdir[i][j] = t?true:false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(dp[i][j] % 2 == 0){\n\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2; \n\t\t\t\t}else{\n\t\t\t\t\tif(dir[i][j]){ //east\n\t\t\t\t\t\tdir[i][j] = false;\n\t\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2 + 1;\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir[i][j] = true;\n\t\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2 + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile(x < h && y < w){\n\t\t\tif(dir[x][y]){\n\t\t\t\ty++;\n\t\t\t}else{\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tcout << x+1 << \" \" << y+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w)scanf(\"%d\", &a[i][j]);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] / 2;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) / 2;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) / 2;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] / 2;\n\t\t\t}\n\t\t}\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (dp[i][j] & 1)a[i][j] = !a[i][j];\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (a[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", x + 1, y + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nint main() {\n    while(true) {\n        int h,w,n; scanf(\"%d%d%d\", &h, &w, &n);\n        if(h==0) break;\n        static int dp[1001][1001];\n        for(int y = 0; y < h; y++)\n            for(int x = 0; x < w; x++)\n                dp[y][x] = 0;\n        dp[0][0] = n-1;\n        for(int y = 0; y < h; y++) {\n            for(int x = 0; x < w; x++) {\n                int dir; scanf(\"%d\", &dir);\n                int cnt = dp[y][x];\n                dp[y+dir][x+(dir^1)] += cnt/2;\n                dp[y+(dir^1)][x+dir] += (cnt+1)/2;\n                dp[y][x] = (dir+cnt)&1;\n            }\n        }\n        int ax=0,ay=0;\n        while(ax<w && ay<h) {\n            int dir = dp[ay][ax];\n            ay += dir^1;\n            ax += dir;\n        }\n        printf(\"%d %d\\n\", ay+1, ax+1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\nint main() {\n\tint h, w, n;\n\twhile (scnaf(\"%d %d %d\", &h, &w, &n)) {\n\t\tif (!n)\n\t\t\tbreak;\n\t\tvector<vector<int>> m(h, vector<int>(w));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tscanf(\"%d\", &m[i][j]);\n\t\t\t}\n\t\t}\n\t\tn--;\n\t\tint dp[1001][1001] = {};\n\t\tdp[0][0] = n;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tdp[i][j + 1] += (dp[i][j] + m[i][j]) / 2;\n\t\t\t\tdp[i + 1][j] += (dp[i][j] + 1 - m[i][j]) / 2;\n\t\t\t}\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tm[i][j] ^= dp[i][j] % 2;\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;\n\t\tfor (; h > y; y++) {\n\t\t\tfor (; w > x; x++) {\n\t\t\t\tif (!m[y][x])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (w == x)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d %d\\n\", y + 1, x + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h | w | n)\n\t{\n\t\tstatic bool east[1024][1024];\n\t\tfor (int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\teast[i][j] = t == 1;\n\t\t\t}\n\t\t}\n\n\t\tstatic int visit[1024][1024];\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t\tvisit[i][j] = 0;\n\n\t\tvisit[0][0] = --n;\n\t\tfor (int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tint a = visit[i][j] / 2, b = (visit[i][j] + 1) / 2;\n\t\t\t\tif (east[i][j])\n\t\t\t\t\tswap(a, b);\n\t\t\t\tvisit[i][j + 1] += a;\n\t\t\t\tvisit[i + 1][j] += b;\n\n\t\t\t\teast[i][j] ^= visit[i][j] & 1;\n\t\t\t}\n\t\t}\n\n\t\tint x, y;\n\t\tx = y = 0;\n\t\twhile (x < w && y < h)\n\t\t{\n\t\t\tif (east[y][x])\n\t\t\t\t++x;\n\t\t\telse\n\t\t\t\t++y;\n\t\t}\n\t\tprintf(\"%d %d\\n\", ++y, ++x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nint main(){\n  queue<POS> check;\n  long long next[101][101],field[101][101],n;\n  bool flag[101][101];\n  int h,w;\n  while(cin >>h>>w>>n,h||w||n){\n    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    while(!check.empty()){\n      POS p = check.front();\n      if(next[p.x][p.y]>0 && p.x<w && p.y<h){\n\tif(next[p.x][p.y]%2 == 0){\n\t  next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t  next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t}\n\telse{\n\t  if(field[p.x][p.y] == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t  }\n\t  else{\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t}\n\ta.x = p.x+1;a.y = p.y;\n\tif(!flag[a.x][a.y]){\n\t  check.push(a);\n\t  flag[a.x][a.y] = true;\n\t}\n\ta.x = p.x;a.y = p.y+1;\n\tif(!flag[a.x][a.y]){\n\t  check.push(a);\n\t  flag[a.x][a.y] = true;\n\t}\n      }\n      check.pop();\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n    }\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#pragma warning(disable : 4996)\nint H, W, T, a[1009][1009], dp[1009][1009];\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &T), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= H; i++) {\n\t\t\tfor (int j = 0; j <= W; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = T - 1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tdp[i + 1][j] += (dp[i][j] - a[i][j] + 1) >> 1;\n\t\t\t\tdp[i][j + 1] += (dp[i][j] + a[i][j]) >> 1;\n\t\t\t}\n\t\t}\n\t\tint cx = 0, cy = 0;\n\t\twhile (cx < H && cy < W) {\n\t\t\tif ((dp[cx][cy] ^ a[cx][cy]) & 1) cy++;\n\t\t\telse cx++;\n\t\t\tT >>= 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", cx + 1, cy + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint H,W,N;\nint board[1010][1010];\nint main(){\n\twhile(cin>>H>>W>>N,H||W||N){\n\t\tint posx,posy;\n\t\tfor(int i =1;i <=H;i++){\n\t\t\tfor(int j =1;j <=W;j++){\n\t\t\t\tcin>>board[i][j];\n\t\t\t}\n\t\t}\n\t\twhile(N){\n\t\t\tposx=posy=1;\n\t\t\twhile(true){\n\t\t\t\tif(posx>=W+1||posy>=H+1){\n\t\t\t\t\tN--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(board[posy][posx]==1){\n\t\t\t\t\tboard[posy][posx]=0;\n\t\t\t\t\tposx++;\n\t\t\t\t}else{\n\t\t\t\t\tboard[posy][posx]=1;\n\t\t\t\t\tposy++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<posy<<\" \"<<posx<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint map[1001][1001];\nint dp[1001][1001];\nint main(void)\n{\n\tint h,w,n;\n\tint i,j;\n\tint x,y;\n\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t}\n\t\t}\n\t\twhile(n>0){\n\t\t\tx=1;\n\t\t\ty=1;\n\t\t\twhile(x<=h && y<=w){\n\t\t\t\tif(map[x][y]==1){\n\t\t\t\t\tmap[x][y]=0;\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\telse if(map[x][y]==0){\n\t\t\t\t\tmap[x][y]=1;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t\tprintf(\"%d %d\\n\",x,y);\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint DP[1001][1001];\nint pt[1001][1001];\nint main() {\n\twhile(true){\n\tint H,W,N;\n\n\tint lastX=1,lastY=1;\n\tcin >> H >> W >> N;\n\t\tif(H==0)\n\tbreak;\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\tcin >> pt[j][i];\n\tDP[1][1]=N-1;\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\tif(i!=1|| j!=1 ){\n\t\t\tDP[j][i]=DP[j][i-1]/2+DP[j-1][i]/2;\n\t\t\tif(pt[j][i-1]==0 && DP[j][i-1] %2 ==1)\n\t\t\tDP[j][i]++;\n\t\t\tif(pt[j-1][i]==1 && DP[j-1][i] %2 ==1)\n\t\t\tDP[j][i]++;\n\t\t\t}\n\twhile(lastX<=W && lastY<=H){\n\t\tif((DP[lastX][lastY]+pt[lastX][lastY])%2==1)\n\t\tlastX++;\n\t\telse\n\t\tlastY++;\n\t}\n\tcout << lastY << \" \" << lastX << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 1010\nusing namespace std;\n\nint mp[MAX][MAX],dp[MAX][MAX];\n\nvoid solve(){\n int h,w,n;\n for(;;){\n  cin>>h>>w>>n;\n  if(!h&&!w&&!h) break;\n  FOR(i,h) FOR(j,w) cin>>mp[i][j];\n  ZERO(dp);\n  dp[0][0]=n-1;\n  FOR(i,h){\n   FOR(j,w){\n    if(i+1!=h) dp[i+1][j]+=(dp[i][j]+mp[i][j]^1)>>1;\n    if(j+1!=w) dp[i][j+1]+=(dp[i][j]+mp[i][j])>>1;\n   }\n  }\n  FOR(i,h) FOR(j,w) if(dp[i][j]&1) mp[i][j]^=1;\n  int x=0,y=0;\n  while(x!=h-1-1&&y!=w-1){\n   if(mp[x][y]) y++;\n   else x++;\n  }\n  cout<<x<<\" \"<<y<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nqueue<POS> check;\nlong next[201][201],field[201][201],n;\nbool flag[201][201];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    /*    while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n      }*/\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n    }\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\n\nint h,w;\nint a[1010][1010]={};\nint b[1010][1010]={};\n\nsigned main(){\n\t\n\t\ncin.tie(0);\nios::sync_with_stdio(false);\nwhile(1){\n\tint n;\n\tcin>>h>>w>>n;\n\tif(h==0) exit(0);\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\tcin>>a[i][j];\n\t\tb[i][j]=0;\n\t}\n\tb[0][0]=n-1;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\tif(b[i][j]%2==0){\n\t\t\tb[i+1][j]+=b[i][j]/2;\n\t\t\tb[i][j+1]+=b[i][j]/2;\n\t\t\t\n\t\t}\n\t\telse if(a[i][j]){\n\t\t\ta[i][j]^=1;\n\t\t\tb[i+1][j]+=b[i][j]/2;\n\t\t\tb[i][j+1]+=b[i][j]/2+1;\n\t\t\t\n\t\t}\n\t\telse{\n\t\t\ta[i][j]^=1;\n\t\t\tb[i+1][j]+=b[i][j]/2+1;\n\t\t\tb[i][j+1]+=b[i][j]/2;\n\t\t\t\n\t\t}\n\t}\n\t\n\tint x=0,y=0;\n\twhile(1){\n\t\tif(a[x][y])y++;\n\t\telse x++;\n\t\tif(x==h || y==w)break;\n\t}\n\tcout<<x+1<<\" \"<<y+1<<endl;\n\t}\n\treturn 0;\n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<array>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<unordered_map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) {cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) {cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nconst int MOD = 1e9 + 7;\n\n#define MAX 1010\n\nsigned main() {\n\tint H, W, N; cin >> H >> W >> N;\n\tbool east[MAX][MAX] = {};\n\trep(i, 0, H)rep(j, 0, W) {\n\t\tcin >> east[i][j];\n\t}\n\tint dp[MAX][MAX] = {};\n\tdp[0][0] = N - 1;\n\trep(i, 0, H)rep(j, 0, W) {\n\t\tif (dp[i][j] == 0) continue;\n\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\tif (dp[i][j] % 2 == 1) {\n\t\t\tif (east[i][j])dp[i][j + 1] += 1;\n\t\t\telse dp[i + 1][j] += 1;\n\t\t}\n\t}\n\tint i = 0, j = 0;\n\twhile (i != H - 1 && j != W - 1) {\n\t\tif ((dp[i][j] + east[i][j]) % 2 == 0)i++;\n\t\tif ((dp[i][j] + east[i][j]) % 2 == 1)j++;\n\t}\n\tcout << (i + 1 + (i == H - 1)) << \" \" << (j + 1 + (j == W - 1)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\n    int H,W,N;\n    for(;;){\n        scanf(\"%d%d%d\",&H,&W,&N);\n        if(H==0&&W==0&&N==0) break;\n        vector<vector<int> > fst(H,vector<int>(W));\n        vector<vector<vector<int> > > gotime(H+1,vector<vector<int> >(W+1,vector<int>()));\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                scanf(\"%d\",&fst[i][j]);\n            }\n        }\n        gotime[0][0].push_back(0);\n        for(int i=0;i<=H;i++){\n            for(int j=0;j<=W;j++){\n                if(i>0&&j<W){\n                    int sz=gotime[i-1][j].size();\n                    if(sz%2==0){\n                        for(int k=fst[i-1][j];k<sz;k+=2){\n                            gotime[i][j].push_back(gotime[i-1][j][k]);\n                            if(gotime[i-1][j][k]+(1<<(i-1+j)) <= 10000000){\n                                gotime[i][j].push_back(gotime[i-1][j][k]+(1<<(i-1+j)));\n                            }\n                        }\n                    }else{\n                        for(int k=fst[i-1][j];k<sz;k+=2){\n                            gotime[i][j].push_back(gotime[i-1][j][k]);\n                        }\n                        for(int k=(fst[i-1][j]+1)%2;k<sz;k+=2){\n                            if(gotime[i-1][j][k]+(1<<(i-1+j)) <= 10000000){\n                                gotime[i][j].push_back(gotime[i-1][j][k]+(1<<(i-1+j)));\n                            }\n                        }\n                    }\n                }\n                if(j>0&&i<H){\n                    int sz=gotime[i][j-1].size();\n                    if(sz%2==0){\n                        for(int k=(fst[i][j-1]+1)%2;k<sz;k+=2){\n                            gotime[i][j].push_back(gotime[i][j-1][k]);\n                            if(gotime[i][j-1][k]+(1<<(i+j-1)) <= 10000000){\n                                gotime[i][j].push_back(gotime[i][j-1][k]+(1<<(i+j-1)));\n                            }\n                        }\n                    }else{\n                        for(int k=(fst[i][j-1]+1)%2;k<sz;k+=2){\n                            gotime[i][j].push_back(gotime[i][j-1][k]);\n                        }\n                        for(int k=fst[i][j-1];k<sz;k+=2){\n                            if(gotime[i][j-1][k]+(1<<(i+j-1)) <= 10000000){\n                                gotime[i][j].push_back(gotime[i][j-1][k]+(1<<(i+j-1)));\n                            }\n                        }\n                    }\n                }\n                sort(gotime[i][j].begin(),gotime[i][j].end());\n            }\n        }\n        N--;\n        for(int i=0;i<=H;i++){\n            int nn=N;\n            if(i+W<32) nn%=(1<<(i+W));\n            if(binary_search(gotime[i][W].begin(),gotime[i][W].end(),nn)){\n                printf(\"%d %d\\n\",i+1,W+1);\n            }\n        }\n        for(int j=0;j<W;j++){\n            int nn=N;\n            if(j+H<32) nn%=(1<<(j+H));\n            if(binary_search(gotime[H][j].begin(),gotime[H][j].end(),nn)){\n                printf(\"%d %d\\n\",H+1,j+1);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main() {\n\tint h, w, n;\n\twhile(cin >> h >> w >> n) {\n\t\tif(h == 0 && w == 0 && n == 0) break;\n\n\t\tvector< vector<int> > v(h, vector<int>(w)), t(h, vector<int>(w));\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t\tt[i][j] = v[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tmap<int, P> m;\n\n\t\twhile(true) {\n\t\t\tint y = 0, x = 0;\n\t\t\twhile(y != h && x != w) {\n\t\t\t\tif(v[y][x] == 1) {\n\t\t\t\t\tv[y][x] = 0;\n\t\t\t\t\tx++;\n\t\t\t\t} else {\n\t\t\t\t\tv[y][x] = 1;\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm[cnt + 1] = mp(y, x);\n\n\t\t\tbool flag = true;\n\t\t\trep(i, h) {\n\t\t\t\trep(j, w) {\n\t\t\t\t\tif(t[i][j] == v[i][j]) continue;\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flag) break;\n\t\t\tcnt++;\n\t\t}\n\n\t\tP p = m[n % cnt];\n\t\tcout << p.first + 1 << \" \" << p.second + 1 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint main(){\n  bool grid[1000][1000];\n  int num[2][1000],i,j,h,w,n,t;\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&t);\n\tgrid[i][j] = t?true:false;\n      }\n\n    for(i=0;i<w;i++)num[0][i] = num[1][i] = 0;\n    num[0][0] = n-1;\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tt = i&1;\n\tint N=num[t][j];\n\tif(grid[i][j]){\n\t  num[1-t][j] += N/2;\n\t  num[t][j+1] += N-N/2;\n\t}else{\n\t  num[t][j+1] += N/2;\n\t  num[1-t][j] += N-N/2;\n\t}\n\tif(N&1)grid[i][j] = !grid[i][j];\n\tnum[t][j] = 0;\n      }\n\n    i=j=0;\n    while(i<h && j<w)grid[i][j]?j++:i++;\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint h, w, n;\nint a[1010][1010];\nint dp[1010][1010][2];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d %d\", &h, &w, &n);\n\t\tif(h == 0) break;\n\t\tfor(int i=1; i<=h; ++i)\n\t\t\tfor(int j=1; j<=w; ++j)\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[1][1][1-a[1][1]] = (n-1) / 2;\n\t\tdp[1][1][a[1][1]] = n-1 - dp[1][1][1-a[1][1]];\n\t\tfor(int i=2; i<=h; ++i){\n\t\t\tdp[i][1][1-a[i][1]] = dp[i-1][1][0] / 2;\n\t\t\tdp[i][1][a[i][1]] = dp[i-1][1][0] - dp[i][1][1-a[i][1]];\n\t\t}\n\t\tfor(int i=2; i<=w; ++i){\n\t\t\tdp[1][i][1-a[1][i]] = dp[1][i-1][1] / 2;\n\t\t\tdp[1][i][a[i][1]] = dp[1][i-1][1] - dp[1][i][1-a[1][i]];\n\t\t}\n\t\tfor(int i=2; i<=h; ++i){\n\t\t\tfor(int j=2; j<=w; ++j){\n\t\t\t\tint s = dp[i-1][j][0] + dp[i][j-1][1];\n\t\t\t\tdp[i][j][1-a[i][j]] = s / 2;\n\t\t\t\tdp[i][j][a[i][j]] = s - dp[i][j][1-a[i][j]];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=h; ++i){\n\t\t\tfor(int j=1; j<=w; ++j){\n\t\t\t\tint t = (dp[i][j][0] + dp[i][j][1]) % 2;\n\t\t\t\ta[i][j] = (a[i][j] + t) % 2;\n\t\t\t}\n\t\t}\n\t\tint x = 1, y = 1;\n\t\twhile(x <= w && y <= h){\n\t\t\tif(a[y][x] == 0) y++;\n\t\t\telse x++;\n\t\t}\n/*\t\tfor(int i=1; i<=h; ++i){\n\t\t\tfor(int j=1; j<=w; ++j){\n\t\t\t\tprintf(\"%d\\t\", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n*/\t\tprintf(\"%d %d\\n\", y, x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nconst std::vector<std::pair<int, int>> dxys{{1, 0}, {0, 1}};\n\nbool solve() {\n    int h, w, n;\n    std::cin >> h >> w >> n;\n    if (h == 0) return false;\n\n    auto way = vec(h, vec(w, 0));\n    for (auto& v : way) {\n        for (auto& x : v) std::cin >> x;\n    }\n\n    auto visit = vec(h, vec(w, 0));\n    visit[0][0] = n - 1;\n\n    for (int x = 0; x < h; ++x) {\n        for (int y = 0; y < w; ++y) {\n            int m = visit[x][y];\n            for (int i = 0; i < 2; ++i) {\n                int dx, dy;\n                std::tie(dx, dy) = dxys[i];\n\n                int nx = x + dx,\n                    ny = y + dy;\n                if (nx >= h || ny >= w) continue;\n\n                visit[nx][ny] += m / 2 + (m % 2 == 1 && way[x][y] == i);\n            }\n\n            if (m % 2 == 1) way[x][y] = 1 - way[x][y];\n        }\n    }\n\n    int x = 0, y = 0;\n    while (x < h && y < w) {\n        int dx, dy;\n        std::tie(dx, dy) = dxys[way[x][y]];\n        x += dx, y += dy;\n    }\n\n    std::cout << x + 1 << \" \" << y + 1 << \"\\n\";\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\nint map[1005][1005];\nint dat[1005][1005];\n\nint n;\nint w,h;\n\nint main(void){\n\twhile(1){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(dat,0,sizeof(dat));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0)break;\n\t\trep(y,h){\n\t\t\trep(x,w){\n\t\t\t\tscanf(\"%d\",&map[y][x]);\n\t\t\t}\n\t\t}\n\t\tdat[0][0]=n-1;\n\t\trep(y,h){\n\t\t\trep(x,w){\n\t\t\t\tint no = dat[y][x];\n\t\t\t\tdat[y+1][x]+=no/2;\n\t\t\t\tdat[y][x+1]+=no/2;\n\t\t\t\tif(no%2==1){\n\t\t\t\t\tif(map[y][x]==0){\n\t\t\t\t\t\tdat[y+1][x]++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdat[y][x+1]++;\n\t\t\t\t\t}\n\t\t\t\t\tmap[y][x]=1-map[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x=0,y=0;\n\t\twhile(x<w && y<h){\n\t\t\tif(map[y][x]==0)y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint main(){\n\tint h,w,n,data[101][101];\n\twhile(std::cin>>h>>w>>n,h,w,n){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tstd::cin>>data[i][j];\n\t\t\t}\n\t\t}\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx=0,y=0;\n\t\t\twhile(1){\n\t\t\t\tif(x==w||y==h)break;\n\t\t\t\tif(data[y][x]==0)data[y][x]=1,y++;\n\t\t\t\telse data[y][x]=0,x++;\n\t\t\t}\n\t\t}\n\t\tstd::cout<<x+1<<\" \"<<y+1<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n\n#define INF 1010000000\n\nint masu[1001][1001];\nint dp[1001][1001];\n\nint n,m,k;\nint xx,yy;\n\nvoid saiki(int x,int y,int masu[1001][1001]){\n\t//printf(\"%d %d\\n\",y,x);\n\tif(x>=m || y>=n){\n\t\txx=x+1;\n\t\tyy=y+1;\n\t\treturn;\n\t}\n\t\n\tif(masu[x][y]==1){\n\t\tsaiki(x+1,y,masu);\n\t}else{\n\t\tsaiki(x,y+1,masu);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tsinttt(n,m,k);\n\t\tif(n==0)break;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tsint(masu[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,1001){\n\t\t\trep(j,1001)dp[i][j]=0;\n\t\t}\n\t\t\n\t\tdp[0][0]=k-1;\n\t\trep(j,n){\n\t\t\trep(i,m){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(j,n){\n\t\t\trep(i,m){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tmasu[i][j]=!masu[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsaiki(0,0,masu);\n\t\tprintf(\"%d %d\\n\",yy,xx);\n\t\t\n\t\t/*\n\t\t\n\t\tputs(\"\");\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tprintf(\"%d \",dp[j][i]);\n\t\t\t}puts(\"\");\n\t\t}\n\t\tputs(\"\");\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tprintf(\"%d \",masu[j][i]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t}\n}\n/*\n3 4 2\n1 0 1 1\n0 1 0 0\n1 0 1 0\n0 0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define all(x) x.begin(),x.end()\n#define rep(i,N) for(int i=0;i<(int)N;++i)\nusing namespace std;\nusing ll = long long;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nusing vll2 = vector<vector<ll>>;\nconst ll INF = (1LL << 30);\nconst ll LINF = (1LL << 60);\nconst ll MOD = 1e9 + 7;\n\nint main() {\n   cin.tie(0);\n   ios::sync_with_stdio(false);\n\n   while (true) {\n      int H, W, N;\n      cin >> H >> W >> N;\n      if (H == 0 && W == 0 && N == 0) break;\n      vll2 g(H, vll(W));\n      rep(i, H) rep(j, W) cin >> g[i][j];\n\n      vll2 c(H, vll(W));\n      c[0][0] = N - 1;\n      rep(i, H) rep(j, W) {\n         if (i == 0 && j == 0) continue;\n         if (j - 1 >= 0) {\n            c[i][j] += c[i][j - 1] / 2;\n            if (c[i][j - 1] % 2 != 0 && g[i][j - 1] == 1) c[i][j]++;\n         }\n         if (i - 1 >= 0) {\n            c[i][j] += c[i - 1][j] / 2;\n            if (c[i - 1][j] % 2 != 0 && g[i - 1][j] == 0) c[i][j]++;\n         }\n      }\n\n      rep(i, H) rep(j, W) if (c[i][j] & 1) g[i][j] ^= 1;\n\n      int y = 0, x = 0;\n      while (y < H && x < W) {\n         if (g[y][x] == 1) x++;\n         else y++;\n      }\n\n      cout << y + 1 << \" \" << x + 1 << endl;\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint d[1024][1024];\nint dp[1024][1024];\nint H,W,N;\n\n\nint main(){\n  while(scanf(\"%d%d%d\",&H,&W,&N) && H||W||N){\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) scanf(\"%d\", &d[i][j]);\n    memset(dp, 0, sizeof dp);\n    dp[0][0] = N-1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tdp[i+1][j] += (dp[i][j]+(d[i][j]^1))/2;\n\tdp[i][j+1] += (dp[i][j]+d[i][j])  /2;\n      }\n    }\n\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) d[i][j] = (d[i][j]+dp[i][j])%2;\n    int y = 0, x = 0;\n    while(y < H && x < W){\n      if(d[y][x]) x++;\n      else y++;\n    }\n    printf(\"%d %d\\n\", y+1, x+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int *x) { int k, m = 0; *x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { *x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; *x = (*x) * 10 + k - '0'; }if (m)(*x) = -(*x); }\nvoid reader(int *x, int *y) { reader(x); reader(y); }\nvoid reader(int *x, int *y, int *z) { reader(x); reader(y); reader(z); }\nvoid writer(int x, char c) { int i, sz = 0, m = 0; char buf[10]; if (x<0)m = 1, x = -x; while (x)buf[sz++] = x % 10, x /= 10; if (!sz)buf[sz++] = 0; if (m)mypc('-'); while (sz--)mypc(buf[sz] + '0'); mypc(c); }\n\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (reader(&h, &w, &n), h) {\n\t\trep(i, h)rep(j, w)reader(&a[i][j]);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] >> 1;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) >> 1;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) >> 1;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] >> 1;\n\t\t\t}\n\t\t}\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (dp[i][j] & 1)a[i][j] = !a[i][j];\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (a[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\twriter(x + 1, ' '); writer(y + 1, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  typedef vector<vector<bool> > mat;\n  int dx[] = {0,1};\n  int dy[] = {1,0};\n  int h,w,n;\n  while(cin>>h>>w>>n,h||w||n) {\n    mat ba(h,vector<bool>(w));\n    REP(i,h)\n      REP(j,w) {\n      bool aa;\n      cin >> aa;\n      ba[i][j] = aa;\n    }\n    typedef pair<int,int> pii;\n    int cnt = 0;\n    set<mat> mp;\n    mat now = ba;\n    vector<pii> table;\n    while(mp.count(now)==0 && cnt <= n) {\n      // FOR(it, now) {\n      //   FOR(jt, *it)\n      //     cout << *jt << \" \";\n      //   cout << endl;\n      // }\n      int nx=0,ny=0;\n      mat tmp = now;\n      while(nx!=w&&ny!=h) {\n        tmp[ny][nx] = !tmp[ny][nx];\n//                cout << now[ny][nx];\n        if (now[ny][nx])\n          nx++;\n        else\n          ny++;\n        // printf(\"(%d,%d)\",ny,nx);\n      }\n      table.push_back(pii(ny,nx));\n      mp.insert(now);\n      now = tmp;\n      cnt++;\n    }\n    n--;\n    cout << table[n%cnt].first+1 <<\" \" << table[n%cnt].second+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\nconst int N = 1000;\nint g[N][N], flips[N+1][N+1];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int h, w, n;\n    while(cin >> h >> w >> n and h and w and n) {\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                cin >> g[i][j];\n                flips[i][j] = 0;\n            }\n        }\n        flips[0][0] = n - 1;\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                if(g[i][j]) {\n                    flips[i][j+1] += (flips[i][j] + 1) / 2;\n                    flips[i+1][j] += flips[i][j] / 2;\n                } else {\n                    flips[i+1][j] += (flips[i][j] + 1) / 2;\n                    flips[i][j+1] += flips[i][j] / 2;\n                }\n            }\n        }\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                g[i][j] ^= flips[i][j] & 1;\n            }\n        }\n        int x = 0, y = 0;\n        while(x < h and y < w) {\n            (g[x][y] ? y : x)++;\n        }\n        cout << x + 1 << \" \" << y + 1 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int N, W, H;\n  while(cin>>H>>W>>N, H || W || N){\n    int dp[1002][1002] = {};\n    int grid[1002][1002];\n    REP(y,H)REP(x,W)cin>>grid[y][x];\n    dp[0][0] = N - 1;\n    REP(y,H)REP(x,W){\n      dp[y+1][x] = (dp[y][x] + !grid[y][x])/2;\n      dp[y][x+1] = (dp[y][x] +  grid[y][x])/2;\n    }\n    REP(y,H)REP(x,W){\n      grid[y][x] ^= dp[y][x] & 1;\n    }\n    int nx = 0, ny = 0;\n    while(nx < W && ny < H){\n      if(grid[ny][nx] == 0) ny++;\n      else nx++;\n    }\n    assert(nx == W || ny == H);\n    printf(\"%d %d\\n\",ny + 1, nx + 1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int , int > Pi;\n\nint main()\n{\n  int H, W, N, mas[1000][1000], dp[1000][1000];\n\n  while(scanf(\"%d %d %d\", &H, &W, &N), H){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        scanf(\"%d\", &mas[i][j]);\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][0] = N - 1;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        if(i + 1 < H) dp[i + 1][j] += (dp[i][j] + !mas[i][j]) >> 1;\n        if(j + 1 < W) dp[i][j + 1] += (dp[i][j] + mas[i][j]) >> 1;\n      }\n    }\n    int h = 0, w = 0;\n    while(h != H && w != W){\n      if((dp[h][w] + mas[h][w]) % 2) w++;\n      else h++;\n    }\n    printf(\"%d %d\\n\", h + 1, w + 1);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n;\nvector<vector<int>> f;\n\nbool input(){\n  int x,y;\n  cin>>x>>y;\n  cin>>n;\n  f.clear();\n  if(x==y&&y==n&&n==0)return false;\n  f.resize(x);\n  for(int i=0;i<f.size();i++){\n    f[i].resize(y);\n  }\n  for(int i=0;i<f.size();i++){\n    for(int j=0;j<f[i].size();j++){\n      cin>>f[i][j];\n    }\n  }\n  return true;\n}\n\nbool inside(vector<vector<int>> &c,int x,int y){\n  if(x<0)return false;\n  if(y<0)return false;\n  if(c.size()<=x)return false;\n  if(c[x].size()<=y)return false;\n  return true;\n}\n\npair<int,int> solve(){\n  vector<vector<int>> change;\n  change.resize(f.size());\n  for(int i=0;i<change.size();i++){\n    change[i].resize(f[i].size());\n  }\n  change[0][0] = n-1;\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(inside(change,i+1,j))change[i+1][j] = change[i][j]/2;\n      if(inside(change,i,j+1))change[i][j+1] = change[i][j]/2;\n      if(change[i][j]%2){\n        if(f[i][j]==0){\n          if(inside(change,i+1,j))change[i+1][j]++;\n        }else{\n          if(inside(change,i,j+1))change[i][j+1]++;\n        }\n      }\n    }\n  }\n  /*\n  for(auto i:change){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(change[i][j]%2){\n        f[i][j] = !f[i][j];\n      }\n    }\n  }\n  /*\n  for(auto i:f){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  \n  pair<int,int> res;\n  while(res.first<change.size()&&res.second<change[0].size()){\n    if(!f[res.first][res.second]){\n      res.first++;\n    }else{\n      res.second++;\n    }\n  }\n  res.first++;\n  res.second++;\n  return res;\n}\n\n\nint main(){\n  while(input()){\n    /*\n    for(auto i:f){\n      for(auto j:i){\n        cout<<j<<\" \";\n      }cout<<endl;\n    }cout<<endl;\n    */\n    auto ans = solve();\n    cout<<ans.first<<\" \"<<ans.second<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n\nint main(void){\n  int w,h,n;\n  while(cin>>h>>w>>n,h+w+n){\n    vector<vector<int> > m(h,vector<int>(w));\n    rep(i,h)\n      rep(j,w)cin>>m[i][j];\n\n    int x,y;\n    rep(t,n){\n      x = y = 0;\n      while(x < w && y < h){\n        if(m[y][x]){\n          m[y][x] = 0;\n          x ++;\n        }else{\n          m[y][x] = 1;\n          y ++;\n        }\n      }\n    }\n    cout<<++y<<\" \"<<++x<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[1002][1002];\nlong int dp[1002][1002];\nint x,y;\nint h,w;\nlong int n;\n\nvoid root(int xx,int yy){\n\tx=xx,y=yy;\n\tdp[xx][yy]+=1;\n\tif(xx<=w && yy<=h){\n\t\tif(map[xx][yy]==1){\n\t\t\tmap[xx][yy]=0;\n\t\t\troot(xx+1,yy);\n\t\t}else{\n\t\t\tmap[xx][yy]=1;\n\t\t\troot(xx,yy+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint a,b,c;\n\twhile(1){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&map[b][a]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tif(b==1 && a==1)continue;\n\t\t\t\tint d,e;\n\t\t\t\tif(dp[b][a-1]%2==0)d=dp[b][a-1]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a-1]==1)d=(dp[b][a-1]+1)/2;\n\t\t\t\t\tif(map[b][a-1]==0)d=(dp[b][a-1]-1)/2;\n\t\t\t\t}\n\t\t\t\tif(dp[b-1][a]%2==0)e=dp[b-1][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b-1][a]==1)e=(dp[b-1][a]+1)/2;\n\t\t\t\t\tif(map[b-1][a]==0)e=(dp[b-1][a]-1)/2;\n\t\t\t\t}\n\t\t\t\tdp[b][a]+=d+e;\n\t\t\t}\n\t\t}\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tmap[b][a]=(map[b][a]+dp[b][a])%2;\n\t\t\t}\n\t\t}\n\t\troot(1,1);\n\t\tcout << y << \" \" << x << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 1010\n \nbool a[MAX][MAX];\nint dp[MAX][MAX];\nint H, W;\n \nbool get_dir(int n, bool dir)\n{\n    return (n % 2 == 0 ? dir : !dir);\n}\n \nvoid find_last_point()\n{\n    int x = 0, y = 0;\n    while (true) {\n        if (a[y][x] == 1) {\n            x++;\n        } else {\n            y++;\n        }\n        if (x >= W || y >= H) break;\n    }\n    cout << y+1 << \" \" << x+1 << endl;\n}\n \nint main()\n{\n    int N;\n    while (cin >> H >> W >> N, H) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = N-1;\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp[i][j] == 0) continue;\n                a[i][j] = get_dir(dp[i][j], a[i][j]);\n                if (dp[i][j] % 2 == 1) {\n                    if (a[i][j] == 0) {\n                        dp[i+1][j] += dp[i][j] / 2;\n                        dp[i][j+1] += dp[i][j] / 2 + 1;\n                    } else {\n                        dp[i+1][j] += dp[i][j] / 2 + 1;\n                        dp[i][j+1] += dp[i][j] / 2;\n                    }\n                } else {\n                    dp[i+1][j] += dp[i][j] / 2;\n                    dp[i][j+1] += dp[i][j] / 2;\n                }\n            }\n        }\n        find_last_point();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    while(true) {\n        int H, W, N;\n        cin >> H >> W >> N;\n        if(!H && !W && !N) break;\n\n        vector<vector<int> > v(H, vector<int>(W));\n        vector<vector<int> > cnt(H+1, vector<int>(W+1, 0));\n        for(int i = 0; i < H; ++i) {\n            for(int j = 0; j < W; ++j) {\n                cin >> v[i][j];\n            }\n        }\n        cnt[0][0] = N-1;\n        for(int i = 0; i < H; ++i) {\n            for(int j = 0; j < W; ++j) {\n                cnt[i+1][j] += cnt[i][j]/2;\n                cnt[i][j+1] += cnt[i][j]/2;\n                if(cnt[i][j] & 1) {\n                    if(v[i][j] == 0) cnt[i+1][j]++;\n                    else cnt[i][j+1]++;\n\n                    v[i][j] ^= 1;\n                }\n            }\n        }\n        int i = 0, j = 0;\n        while(i < H && j < W) {\n            if(v[i][j] == 0) ++i;\n            else ++j;\n        }\n        cout << (i+1) << ' ' << (j+1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint map[1001][1001];\nint dp[1001][1001];\nint main(void)\n{\n\tint h,w,n;\n\tint i,j;\n\tint x,y;\n\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t\telse if(dp[i][j]%2!=0){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]==0){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2!=0){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx=1;\n\t\ty=1;\n\t\twhile(x<=h && y<=w){\n\t\t\tif(map[x][y]==1){\n\t\t\t\ty++;\n\t\t\t}\n\t\t\telse if(map[x][y]==0){\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",x,y);\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ntypedef long long ll;\n\nint a[1010][1010];\nint dp[1010][1010];\n\nint main(void){\n\n\twhile(1){\n\tint H,W,N;\n\tcin >> H >> W >> N;\n\tif(H==0 && W==0 && N==0) break;\n\tint i,j;\n\tfor(i=1;i<=1000;i++) for(j=1;j<=1000;j++) a[i][j]=0;\n\tfor(i=1;i<=1000;i++) for(j=1;j<=1000;j++) dp[i][j]=0;\n\tfor(i=1;i<=H;i++) for(j=1;j<=W;j++) cin >> a[i][j];\n\tdp[1][1]=N-1;\n\tfor(i=1;i<=H;i++) for(j=1;j<=W;j++){\n\t\tif(i!=1 || j!=1){\n\t\tif(dp[i-1][j]%2==1 && a[i-1][j]==0) dp[i][j]+=(dp[i-1][j]+1)/2;\n\t\tif(dp[i-1][j]%2==1 && a[i-1][j]==1) dp[i][j]+=(dp[i-1][j]-1)/2;\n\t\tif(dp[i-1][j]%2==0) dp[i][j]+=dp[i-1][j]/2;\n\t\tif(dp[i][j-1]%2==1 && a[i][j-1]==0) dp[i][j]+=(dp[i][j-1]-1)/2;\n\t\tif(dp[i][j-1]%2==1 && a[i][j-1]==1) dp[i][j]+=(dp[i][j-1]+1)/2;\n\t\tif(dp[i][j-1]%2==0) dp[i][j]+=dp[i][j-1]/2;\n\t\t}\n\t}\n\n\tint x=1,y=1;\n\twhile(x<=H && y<=W){\n\t\tif(dp[x][y]%2==0 && a[x][y]==0) x++;\n\t\telse if(dp[x][y]%2==0 && a[x][y]==1) y++;\n\t\telse if(dp[x][y]%2==1 && a[x][y]==0) y++;\n\t\telse if(dp[x][y]%2==1 && a[x][y]==1) x++;\n\t}\n\n\tcout << x << ' ' << y << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<stack>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\n\t\tint dp[1003][1003];\n\t\tint masu[1003][1003];\nint main(){\n\twhile(1){\n\t\tint n,m,k;\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0)break;\n\t\trep(i,103)rep(j,103)masu[i][j]=dp[i][j]=0;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tscanf(\"%d\",&masu[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[0][0]=k-1;\n\t\t\n\t\trep(i,m){\n\t\t\trep(j,n){\n\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmasu[i][j]+=dp[i][j];\n\t\t\t\tmasu[i][j]%=2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x=0,y=0;\n\t\twhile(1){\n\t\t\tif(masu[x][y]==0){\n\t\t\t\ty++;\n\t\t\t}else{\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(y>=n || x>=m){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n}\n\n/*\n3 4 3\n1 0 1 1\n0 1 0 0\n1 0 1 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N 5000\n\nlong long x[MAX_N][MAX_N];\nlong long dp[MAX_N][MAX_N];\nint h, w, n, cx, cy;\nint main() {\n\twhile (true) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tcin >> h >> w >> n;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tscanf(\"%d\", x[i][j]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1] = n - 1;\n\t\tfor (int i = 2; i <= h + w; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tint k = i - j;\n\t\t\t\tif (j <= h && k <= w) {\n\t\t\t\t\tif (x[j][k] == 0) {\n\t\t\t\t\t\tdp[j][k + 1] += dp[j][k] / 2;\n\t\t\t\t\t\tdp[j + 1][k] += (dp[j][k] + 1) / 2;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[j][k + 1] += (dp[j][k] + 1) / 2;\n\t\t\t\t\t\tdp[j + 1][k] += dp[j][k] / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tx[i][j] += dp[i][j];\n\t\t\t\tx[i][j] %= 2;\n\t\t\t}\n\t\t}\n\t\tcx = 1; cy = 1;\n\t\twhile (cx <= w && cy <= h) {\n\t\t\tif (x[cy][cx] == 0) {\n\t\t\t\tcy++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcx++;\n\t\t\t}\n\t\t}\n\t\tcout << cy << ' ' << cx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int dx[] = {0, 1};\nconst int dy[] = {1, 0};\nint map[2000][2000];\n\nint main()\n{\n\tint H, W, N;\n\t\n\twhile (scanf(\"%d %d %d\", &H, &W, &N), H + W + N){\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint y, x;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\ty = 0;\n\t\t\tx = 0;\n\t\t\twhile (y < H && x < W){\n\t\t\t\tint c = map[y][x];\n\t\t\t\tmap[y][x] = !map[y][x];\n\t\t\t\ty += dy[c];\n\t\t\t\tx += dx[c];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\", y + 1, x + 1);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nbool f[1000][1000];\nint dp[1001][1001];\nint main(){\n\tint h,w,n;\n\tint i,j;\n\twhile(1){\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\tif(h==0)return 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tf[i][j]=b==0;\n\t\t}\n\t}\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++)dp[i][j]=0;\n\tdp[0][0]=n-1;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tint a,b;\n\t\t\tif(dp[i][j]%2==0){a=dp[i][j]/2;b=dp[i][j]/2;}\n\t\t\telse{\n\t\t\t\tif(f[i][j]){a=dp[i][j]/2+1;b=dp[i][j]/2;}\n\t\t\t\telse{a=dp[i][j]/2;b=dp[i][j]/2+1;}\n\t\t\t}\n\t\t\tdp[i+1][j]+=a;dp[i][j+1]+=b;\n\t\t\tf[i][j]=!(f[i][j]^dp[i][j]%2==0);\n\t\t}\n\t}\n\ti=0;j=0;\n\twhile(i!=h&&j!=w){\n\t\tif(f[i][j])i++;\n\t\telse j++;\n\t}\n\tprintf(\"%d %d\\n\",i+1,j+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<bool, int> pii;\nvoid solve();\n\nint H,W,N;\nint dx[] = {0,1},dy[] = {1,0};\npii field[1010][1010];\n\nint main()\n{\n    while(scanf(\"%d%d%d\",&H,&W,&N),H + W + N)\n    {\n        for(int i = 0; i < H; i++)\n        {\n            for(int j = 0; j < W; j++)\n            {\n                scanf(\"%d\",&field[i][j].first);\n                field[i][j].second = 0;\n            }\n        }\n        solve();\n    }\n    return 0;\n}\n\nvoid solve()\n{\n    field[0][0].second = N - 1;\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            field[i + 1][j].second += field[i][j].second / 2 + (!field[i][j].first && field[i][j].second % 2 == 1);\n            field[i][j + 1].second += field[i][j].second / 2 + (field[i][j].first && field[i][j].second % 2 == 1);\n            if(field[i][j].second % 2 == 1)field[i][j].first = !field[i][j].first;\n        }\n    }\n    int x = 0,y = 0;\n    while(x < W && y < H)\n    {\n        if(field[y][x].first == 1)x++;\n        else y++;\n    }\n    printf(\"%d %d\\n\",y + 1,x + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint a[1000][1000];\nint b[1001][1001];\n\nint main(){\n\tint h;\n\tint w;\n\tint n;\n\tint x;\n\tint y;\n\twhile(true) {\n\t\tcin >> h >> w >> n;\n\t\tif ( h == 0 ) break;\n\t\tfor ( int i = 0; i < h; i++ ) {\n\t\t\tfor ( int j = 0; j < w; j++ ) {\n\t\t\t\tint k;\n\t\t\t\tcin >> k;\n\t\t\t\ta[j][i] = k;\n\t\t\t\tb[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = n - 1;\n\t\tfor ( int i = 0; i < h + w - 1; i++ ) {\n\t\t\tfor ( int j = 0; j < i + 1; j++ ) {\n\t\t\t\tx = i - j;\n\t\t\t\ty = j;\n\t\t\t\tif ( x >= w || y >= h ) continue;\n\t\t\t\tif ( b[x][y] % 2 == 1 ) {\n\t\t\t\t\ta[x][y] = 1 - a[x][y];\n\t\t\t\t\tif ( a[x][y] == 0 ) {\n\t\t\t\t\t\tb[x+1][y] += b[x][y] / 2 + 1;\n\t\t\t\t\t\tb[x][y+1] += b[x][y] / 2;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tb[x+1][y] += b[x][y] / 2;\n\t\t\t\t\t\tb[x][y+1] += b[x][y] / 2 + 1;\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tb[x+1][y] += b[x][y] / 2;\n\t\t\t\t\tb[x][y+1] += b[x][y] / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx = 0;\n\t\ty = 0;\n\t\twhile(true) {\n\t\t\tif ( a[x][y] == 1 ) {\n\t\t\t\tx++;\n\t\t\t}else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tif ( x == w || y == h ) break;\n\t\t}\n\t\tcout << y+1 << \" \" << x+1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nqueue<POS> check;\nlong n,field[201][201];//,next[201][201];\n//bool flag[201][201];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    /*    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n      }*/\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    //    next[0][0] = n-1;\n    POS a;\n    //    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    /*    while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n      }*/\n    /*    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n      }*/\n    int px = 0,py = 0;\n    /*    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n      }*/\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint H, W, N;\nint initDir[1000][1000];\nint visitCnt[1000][1000];\n\nint main() {\n    int y, x;\n    \n    while (true) {    //複数テストケース\n        cin >> H >> W >> N;\n        if (H == 0 && W == 0 && N == 0) {\n            break;\n        }\n        \n        rep(y, H) rep(x, W) cin >> initDir[y][x];\n\n        //初期化\n        rep(y, H) {\n            rep(x, W) {\n                visitCnt[y][x] = 0;\n            }\n        }\n        \n        //1～N-1回目までで各マスに何回訪れたか？\n        visitCnt[0][0] = N - 1;\n        rep(y, H) {\n            rep(x, W) {\n                int cnt = visitCnt[y][x];\n                //右\n                if (x + 1 < W) {\n                    visitCnt[y][x + 1] += cnt / 2;\n                    if (cnt % 2 == 1 && initDir[y][x] == 1) { //東が最初\n                        visitCnt[y][x + 1] += 1;\n                    }\n                }\n                //下\n                if (y + 1 < H) {\n                    visitCnt[y + 1][x] += cnt / 2;\n                     if (cnt % 2 == 1 && initDir[y][x] == 0) { //南が最初\n                        visitCnt[y + 1][x] += 1;\n                     }\n                }\n            }\n        }\n\n        //N回目の散歩のシミュレーション\n        y = 0;\n        x = 0;\n        while (y < H && x < W) {\n            //y行x列目の方向を調べる\n            int dir = (initDir[y][x] + visitCnt[y][x]) % 2;\n            if (dir == 0) { //南\n                y++;\n            }\n            else { //東\n                x++;\n            }\n        }\n\n        cout << y + 1 << \" \" << x + 1 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<array>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<unordered_map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) {cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) {cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nconst int MOD = 1e9 + 7;\n\n#define MAX 1010\n\nsigned main() {\n\tstatic bool east[MAX][MAX] = {};\n\tstatic int dp[MAX][MAX] = {};\n\tfor (int H, W, N; cin >> H >> W >> N&&H;) {\n\t\tfill(east[0], east[MAX], false);\n\t\tfill(dp[0], dp[MAX], 0);\n\t\trep(i, 0, H)rep(j, 0, W) {\n\t\t\tcin >> east[i][j];\n\t\t}\n\t\tdp[0][0] = N - 1;\n\t\trep(i, 0, H + 1)rep(j, 0, W + 1) {\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\tif (dp[i][j] % 2 == 1) {\n\t\t\t\tif (east[i][j])dp[i][j + 1] += 1;\n\t\t\t\telse dp[i + 1][j] += 1;\n\t\t\t}\n\t\t}\n\t\trep(i, 0, H + 1)rep(j, 0, W + 1) {\n\t\t\tdp[i][j] += east[i][j];\n\t\t\tdp[i][j] %= 2;\n\t\t}\n\t\tint i = 0, j = 0;\n\t\twhile (i != H && j != W) {\n\t\t\tif (dp[i][j] % 2 == 0)i++;\n\t\t\tif (dp[i][j] % 2 == 1)j++;\n\t\t}\n\t\tcout << (i + 1) << \" \" << (j + 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n, h, w;\n\nint m[1005][1005];\nint dp[1005][1005];\nvoid change(int n){\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0][0] = n;\n\tREP(i, h)REP(j, w){\n\t\tdp[i+1][j] += dp[i][j]>>1;\n\t\tdp[i][j+1] += dp[i][j]>>1;\n\t\tif(dp[i][j]&1) (m[i][j] ? dp[i][j+1] : dp[i+1][j]) ++;\n\t\tm[i][j] ^= dp[i][j]&1;\n\t}\n}\n\npii go(int y, int x){\n\twhile(y<h && x<w){\n//\t\tcout << x << \", \" << y << endl;\n\t\tif(m[y][x]) x++;\n\t\telse y++;\n\t}\n\treturn pii(y+1, x+1);\n}\n\nmain(){\n\twhile(scanf(\"%d%d%d\", &h, &w, &n), h){\n\t\tvi p(n);\n\t\tREP(i, h)REP(j, w) scanf(\"%d\", &m[i][j]);\n\t\tchange(n-1);\n\t\tpii res = go(0, 0);\n\t\tcout << res.first << \" \" << res.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//ライブラリゾーン！！！！\ntypedef long long ll;\ntypedef long double ld;\n#define str string\n#define rep(i,j) for(ll i=0;i<(long long)(j);i++)\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//隣接リスト表現\n\tll to, cost;\n};\nstruct E {//辺の情報を入れる変数\n\tll from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tll x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//最大公約数\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad＝座標上の2点間の距離\nll ari(ll a, ll b, ll c) {\n\treturn (a + b)*c / 2;\n}//等差数列の和\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nll fact(ll i, ll z) {\n\tll sum = 1;\n\tfor (ll j = max(z, 2LL); j <= i; j++)\n\t\tsum = (sum* j) % Mod;\n\treturn sum;\n}//階乗(正）\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res*x%Mod;\n\t\tx = x*x%p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n#define int long long\nconst long long inf = 4523372036854775807;\nconst int iinf = 1500000000;\n//----------------------------------------------------\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\nint h, w, n;\nbool a[1000][1000];\nint dp[1001][1001];\nH ans;\nvoid solve(int x, int y) {\n\tif (x == h || y == w) {\n\t\tans = H{ x,y };\n\t\treturn;\n\t}\n\tif (a[x][y]) solve(x, y + 1);\n\telse solve(x + 1, y);\n}\nsigned main() {\n\twhile (cin >> h >> w >> n&&h + w + n > 0) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = n - 1;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (a[i][j]) {\n\t\t\t\t\tdp[i][j + 1] += ceil(dp[i][j] / 2.0);\n\t\t\t\t\tdp[i + 1][j] += floor(dp[i][j] / 2.0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j] += ceil(dp[i][j] / 2.0);\n\t\t\t\t\tdp[i][j + 1] += floor(dp[i][j] / 2.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (dp[i][j] % 2 == 1) {\n\t\t\t\t\ta[i][j] = !a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(0, 0);\n\t\tcout << ans.x + 1 << \" \" << ans.y + 1 << endl;\n\t}\n\tgetchar(); getchar();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nbool grid[1000][1000];\nint num[1001][1001];\nint h,w,n,tmp;\n\nint main(){\n  while(scanf(\"%d %d %d\",&h,&w,&n) && (h||w||n)){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tscanf(\"%d\",&tmp);\n\tgrid[i][j] = (tmp)?true:false;\n\tnum[i][j] = 0;\n      }\n\n    num[0][0] = n-1;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tint N=num[i][j];\n\tif(grid[i][j]){\n\t  num[i+1][j] += N/2;\n\t  num[i][j+1] += N-N/2;\n\t}else{\n\t  num[i][j+1] += N/2;\n\t  num[i+1][j] += N-N/2;\n\t}\n\tif(N&1)grid[i][j] = ~grid[i][j];\n      }\n\n    int y=0,x=0;\n    while(y<h && x<w){\n      if(grid[y][x])x++;\n      else y++;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint table[1000][1000];\nint dp[1000][1000];\nint H,W,N;\nint main() {\nwhile(1)\n{\n\tscanf(\"%d%d%d\",&H,&W,&N);\n\tif(H==0)return 0;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%d\",table[i]+j);\n\t\t\tdp[i][j]=0;\n\t\t}\n\t}\n\tdp[0][0]=N-1;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(i+1<H){\n\t\t\t\tdp[i+1][j]=(dp[i][j]+1-table[i][j])/2;\n\t\t\t}\n\t\t\tif(j+1<W){\n\t\t\t\tdp[i][j+1]=(dp[i][j]+table[i][j])/2;\n\t\t\t}\n\t\t\ttable[i][j]=(table[i][j]+dp[i][j])%2;\n\t\t}\n\t}\n\tint x=0;\n\tint y=0;\n\twhile(x<H&&y<W){\n\t\tif(table[x][y]){\n\t\t\ty++;\n\t\t}\n\t\telse{\n\t\t\tx++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",x+1,y+1);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w)scanf(\"%d\", &a[i][j]);\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += (dp[i - 1][j] - 1) / 2;\n\t\t\t\telse dp[i][j] += dp[i - 1][j] / 2;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += dp[i][j - 1] / 2;\n\t\t\t\telse dp[i][j] += (dp[i][j - 1] - 1) / 2;\n\t\t\t}\n\t\t}\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (dp[i][j] & 1)a[i][j] = !a[i][j];\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (a[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", x + 1, y + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef long long ll;\nll dp[N][N];\nll d[N][N];\nint h,w,n;\n \nint main(){\n  while(1){\n    cin>>h>>w>>n;\n    if(!h&&!w&&!n)break;\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=n-1;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n    cin>>d[i][j];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n    ll cnt=dp[i][j],a,b;\n    a=b=cnt/2;\n    if(cnt%2){\n      if(d[i][j])b++;\n      else a++;\n    }\n    dp[i+1][j]+=a;\n    dp[i][j+1]+=b;\n      }\n    }\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n    d[i][j]=(d[i][j]+dp[i][j])%2;\n    int y=0,x=0;\n    while(y<h&&x<w){\n      if(d[y][x])x++;\n      else y++;\n    }\n    cout<<y+1<<' '<<x+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n  };\nqueue<POS> check;\nlong long n,field[1001][1001],next[1001][1001];\nbool flag[1001][1001];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n        while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n      }\n      for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n      field[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n      }\n      int px = 0,py = 0;\n      while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n      }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n\tint **a, h, w, n, x, y;\n\t\n\twhile(1){\n\t\tcin >> h >> w >> n;\n\t\tif(h  == 0){\n\t\t\tbreak;\n\t\t}\n\t\ta = (int **)calloc((h+1), sizeof(int));\n\t\ta[0] = (int *)calloc((w+1), sizeof(int));\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\ta[i] = (int *)calloc((w+1), sizeof(int));\n\t\t\tfor(int j = 1, tmp = 0; j <= w; j++){\n\t\t\t\tcin >> tmp;\n\t\t\t\ta[i][j] = tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx = y = 1;\n\t\t\twhile(x <= w && y <= h){\n\t\t\t\tif(a[y][x] == 0){\n\t\t\t\t\ta[y][x] = 1;\n\t\t\t\t\ty++;\n\t\t\t\t} else {\n\t\t\t\t\ta[y][x] = 0;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << y << \" \" << x << endl;\n\t\t\n\t\tfor(int i = 0; i <= h; i++){\n\t\t\tfree(a[i]);\n\t\t}\n\t\tfree(a);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint H,W,N;\nint board[1010][1010];\nint dp[1010][1010];//N-1回までの（i,j）の通った回数を数える\nint main(){\n\twhile(cin>>H>>W>>N,H||W||N){\n\t\tint posx,posy;\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tfor(int i =1;i <=H;i++){\n\t\t\tfor(int j =1;j <=W;j++){\n\t\t\t\tcin>>board[i][j];\n\t\t\t}\n\t\t}\n\t\tN--;\n\t\tdp[1][1]=N;\n\t\tfor(int i =1;i <=H;i++){\n\t\t\tfor(int j=1;j <=W;j++){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(board[i][j]==0){\n\t\t\t\t\t\tdp[i+1][j]+=(dp[i][j]+1)/2;\n\t\t\t\t\t\tdp[i][j+1]+=(dp[i][j]-1)/2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i+1][j]+=(dp[i][j]-1)/2;\n\t\t\t\t\t\tdp[i][j+1]+=(dp[i][j]+1)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tposx=posy=1;\n\t\twhile(true){\n\t\t\t//cout <<posx<<\" \"<<posy<<endl;\n\t\t\tif(board[posy][posx]&&dp[posy][posx]%2)posy++;//最初が東で奇数→反転\n\t\t\telse if(board[posy][posx]&&!(dp[posy][posx]%2))posx++;//最初が東で偶数→そのまま\n\t\t\telse if(!board[posy][posx]&&dp[posy][posx]%2)posx++;//最初が南で奇数→反転\n\t\t\telse posy++;\n\t\t\tif(posx>=W+1||posy>=H+1)break;\n\t\t}\n\t\tcout <<posy<<\" \"<<posx<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n\tint **a, h, w, n, x, y;\n\t\n\twhile(1){\n\t\tcin >> h >> w >> n;\n\t\tif(h  == 0){\n\t\t\tbreak;\n\t\t}\n\t\ta = (int **)calloc((h+1), sizeof(int));\n\t\ta[0] = (int *)calloc((w+1), sizeof(int));\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\ta[i] = (int *)calloc((w+1), sizeof(int));\n\t\t\tfor(int j = 1, tmp = 0; j <= w; j++){\n\t\t\t\tcin >> tmp;\n\t\t\t\ta[i][j] = tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx = y = 1;\n\t\t\twhile(x <= w && y <= h){\n\t\t\t\tif(a[y][x] == 0){\n\t\t\t\t\ta[y][x] = 1;\n\t\t\t\t\ty++;\n\t\t\t\t} else {\n\t\t\t\t\ta[y][x] = 0;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << y << \" \" << x << endl;\n\t\t\n\t\tfor(int i = 0; i <= h; i++){\n\t\t\tfree(a[i]);\n\t\t}\n\t\tfree(a);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n\n#define INF 1010000000\n\nint masu[1001][1001];\nint dp[1001][1001];\n\nint n,m,k;\nint xx,yy;\n\nvoid saiki(int x,int y,int masu[1001][1001]){\n\t//rintf(\"%d %d\\n\",y,x);\n\tif(x>n || y>m){\n\t\txx=x+1;\n\t\tyy=y+1;\n\t\treturn;\n\t}\n\t\n\tif(masu[x][y]==1){\n\t\tsaiki(x+1,y,masu);\n\t}else{\n\t\tsaiki(x,y+1,masu);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tsinttt(n,m,k);\n\t\tif(n==0)break;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tsint(masu[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,1000){\n\t\t\trep(j,1000)dp[i][j]=0;\n\t\t}\n\t\t\n\t\tdp[0][0]=k-1;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(j,n){\n\t\t\trep(i,m){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tmasu[i][j]=!masu[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsaiki(0,0,masu);\n\t\tprintf(\"%d %d\\n\",yy,xx);\n\t\t\n\t\t/*\n\t\tputs(\"\");\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tprintf(\"%d \",dp[j][i]);\n\t\t\t}puts(\"\");\n\t\t}\n\t\tputs(\"\");\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tprintf(\"%d \",masu[j][i]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t}\n}\n/*\n3 4 2\n1 0 1 1\n0 1 0 0\n1 0 1 0\n0 0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[1002][1002];\nlong int dp[1002][1002];\nint x,y;\nint h,w;\nlong int n;\n\nvoid root(int xx,int yy){\n\tx=xx,y=yy;\n\tdp[xx][yy]+=1;\n\tif(xx<=w && yy<=h){\n\t\tif(map[xx][yy]==1){\n\t\t\tmap[xx][yy]=0;\n\t\t\troot(xx+1,yy);\n\t\t}else{\n\t\t\tmap[xx][yy]=1;\n\t\t\troot(xx,yy+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint a,b,c;\n\twhile(1){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&map[b][a]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tint d,e;\n\t\t\t\tif(dp[b][a]%2==0)dp[b+1][a]=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)d=(dp[b+1][a]+1)/2;\n\t\t\t\t\tif(map[b][a]==0)d=(dp[b+1][a]-1)/2;\n\t\t\t\t}\n\t\t\t\tif(dp[b][a]%2==0)e=dp[b][a+1]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)e=(dp[b][a+1]-1)/2;\n\t\t\t\t\tif(map[b][a]==0)e=(dp[b][a+1]+1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tmap[b][a]=(map[b][a]+dp[b][a])%2;\n\t\t\t}\n\t\t}\n\t\troot(1,1);\n\t\tcout << y << \" \" << x << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nint** getarray(int w,int h){\n\tint** a = new int*[w];\n\tfor(int i = 0;i < w;i++){\n\t\ta[i] = new int[h];\n\t}\n\treturn a;\n}\n\nint remarray(int** a,int w,int h){\n\tfor(int i=0;i<w;i++){\n\t\tdelete[] a[i];\n\t}\n\tdelete[] a;\n}\n\nint main(){\n\tint h,w,n;\n\tint self;\n\tint** d;\n\tint** m;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t\tif(!h && !w && !n){break;}\n\t\td = getarray(w + 1,h + 1);\n\t\tm = getarray(w + 1,h + 1);\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tscanf(\"%d\",&self);\n\t\t\t\tm[j][i] = self;\n\t\t\t}\n\t\t}\n\t\t\n\t\td[0][0] = n - 1;\n\t\tfor(int k=0;k < n - 1;k++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\t\tif(i == 0 && j == 0){continue;}\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\tif(i != 0 && d[i-1][j] > 0){\n\t\t\t\t\t\td[i][j] += (d[i-1][j]) / 2;\n\t\t\t\t\t\tif(m[i-1][j] == 1){\n\t\t\t\t\t\t\td[i][j] += (d[i-1][j]) % 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j != 0 && d[i][j - 1] > 0){\n\t\t\t\t\t\td[i][j] += (d[i][j-1]) / 2;\n\t\t\t\t\t\tif(m[i][j-1] == 0){\n\t\t\t\t\t\t\td[i][j] += (d[i][j-1]) % 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tm[i][j] = (m[i][j] + d[i][j]) % 2;\n\t\t\t\t//printf(\"%d \",m[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tint x,y;\n\t\tx = y = 0;\n\t\twhile(x < w && y < h){\n\t\t\tif(m[x][y] == 1){\n\t\t\t\t//printf(\"ツ督圭n\");\n\t\t\t\tx += 1;\n\t\t\t}else{\n\t\t\t\t//printf(\"ツ禿ャ\\n\");\n\t\t\t\ty += 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",x + 1,y + 1);\n\t\tremarray(m,w+1,h+1);\n\t\tremarray(d,w+1,h+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n;\nvector<vector<int>> f;\n\nbool input(){\n  int x,y;\n  cin>>x>>y;\n  cin>>n;\n  f.clear();\n  if(x==y&&y==n&&n==0)return false;\n  f.resize(x);\n  for(int i=0;i<f.size();i++){\n    f[i].resize(y);\n  }\n  for(int i=0;i<f.size();i++){\n    for(int j=0;j<f[i].size();j++){\n      cin>>f[i][j];\n    }\n  }\n  return true;\n}\n\nbool inside(vector<vector<int>> &c,int x,int y){\n  if(x<0)return false;\n  if(y<0)return false;\n  if(c.size()<=x)return false;\n  if(c[x].size()<=y)return false;\n  return true;\n}\n\npair<int,int> solve(){\n  vector<vector<int>> change;\n  change.resize(f.size());\n  for(int i=0;i<change.size();i++){\n    change[i].resize(f[i].size());\n  }\n  change[0][0] = n-1;\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(inside(change,i+1,j))change[i+1][j] = change[i][j]/2;\n      if(inside(change,i,j+1))change[i][j+1] = change[i][j]/2;\n      if(change[i][j]%2){\n        if(f[i][j]==0){\n          if(inside(change,i+1,j))change[i+1][j]++;\n        }else{\n          if(inside(change,i,j+1))change[i][j+1]++;\n        }\n      }\n    }\n  }\n  /*\n  for(auto i:change){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(change[i][j]%2){\n        f[i][j] = !f[i][j];\n      }\n    }\n  }\n  /*\n  for(auto i:f){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  \n  pair<int,int> res(0,0);\n  while(res.first<change.size()&&res.second<change[0].size()){\n    if(!f[res.first][res.second]){\n      res.first++;\n    }else{\n      res.second++;\n    }\n  }\n  res.first++;\n  res.second++;\n  return res;\n}\n\n\nint main(){\n  while(input()){\n    /*\n    for(auto i:f){\n      for(auto j:i){\n        cout<<j<<\" \";\n      }cout<<endl;\n    }cout<<endl;\n    */\n    auto ans = solve();\n    cout<<ans.first<<\" \"<<ans.second<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n \nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint stage[1024][1004];\nint dp[1024][1024];\nint main(){\n    int h,w,n;\n    while(scanf(\"%d%d%d\",&h,&w,&n),(h|w)|n){\n        rep(i,h)rep(j,w)scanf(\"%d\",&stage[i][j]);\n        memset(dp,0,sizeof(dp));\n        dp[0][0] = --n;\n        rep(i,h){\n            rep(j,w){\n                if(dp[i][j] % 2 == 0){\n                    dp[i][j+1] = dp[i][j]/2;\n                    dp[i+1][j] = dp[i][j]/2;\n                 }\n                 else{\n                    if(stage[i][j] == 0){\n                        dp[i+1][j] += dp[i][j]/2 + 1;\n                        dp[i][j+1] += dp[i][j]/2;\n                    }\n                    else if(stage[i][j] == 1){\n                        dp[i+1][j] += dp[i][j]/2;\n                        dp[i][j+1] += dp[i][j]/2 + 1;\n                    }\n                 }\n            }\n        }\n        int x = 0,y = 0;\n        while(x < w && y < h){\n            if(dp[y][x]%2 == 1){\n                if(stage[y][x] == 0){\n                    x++;\n                }\n                else{\n                    y++;\n                }\n            }\n            else{\n                if(stage[y][x] == 0){\n                    y++;\n                }\n                else{\n                    x++;\n                }\n            }\n        }\n        printf(\"%d %d\\n\",++y,++x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<stack>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nint main(){\n\twhile(1){\n\t\tint dp[203][203];\n\t\tint n,m,k;\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0)break;\n\t\tint masu[203][203];\n\t\trep(i,103)rep(j,103)masu[i][j]=dp[i][j]=0;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tscanf(\"%d\",&masu[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[0][0]=k-1;\n\t\t\n\t\trep(i,m){\n\t\t\trep(j,n){\n\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmasu[i][j]+=dp[i][j];\n\t\t\t\tmasu[i][j]%=2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x=0,y=0;\n\t\twhile(1){\n\t\t\tif(masu[x][y]==0){\n\t\t\t\ty++;\n\t\t\t}else{\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(y>=n || x>=m){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n}\n\n/*\n3 4 3\n1 0 1 1\n0 1 0 0\n1 0 1 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n#define PLL pair<ll, ll>\n\nusing namespace std;\n\n\nint H, W, N;\nint main() {\n\twhile (cin >> H >> W >> N, H)\n\t{\n\t\tvector<vector<int>> sign(H, vector<int>(W));\n\t\trep(i, H) rep(j, W) {\n\t\t\tcin >> sign[i][j];\n\t\t}\n\t\t\n\t\tvector<vector<int>> dp(H+1, vector<int>(W+1));\n\t\tdp[0][0] = N - 1;\n\t\trep(i, H) rep(j, W){\n\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\tif (sign[i][j] == 0) dp[i + 1][j] += dp[i][j] % 2;\n\t\t\telse dp[i][j + 1] += dp[i][j] % 2;\n\t\t}\n\n\t\tint x = 0, y = 0;\n\t\twhile (x < H && y < W)\n\t\t{\n\t\t\tif ((sign[x][y] + dp[x][y]) % 2 == 0) x++;\n\t\t\telse y++;\n\t\t}\n\n\n\t\tcout << x + 1 << ' ' << y + 1 << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nbool mp[1002][1002];\nint count[1002][1002];\nint main(){\n    int h,w,n;\n    while(cin>>h>>w>>n,h){\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                cin>>mp[i][j];\n            }\n        }\n        memset(count,0,(h+1)*(w+1)*4);\n        count[0][0]=n-1;\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                mp[i][j]=mp[i][j]^(count[i][j]%2);\n                count[i][j+1] += (count[i][j]+!mp[i][j])/2;\n                count[i+1][j] += (count[i][j]+mp[i][j])/2;\n            }\n        }\n        int x=0,y=0;\n        while(x<w&&y<h){\n            if(mp[y][x]) ++x;\n            else ++y;\n        }\n        cout<<y+1<<\" \"<<x+1<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n//typedef vector<vector<bool> > v2;\ntypedef bool city[1001][1001];\ntypedef pair<int,int> pos;\n\nint h,w,n;\n\ncity field;\n\npos next(city &f){\n\tint x=0;\n\tint y=0;\n\twhile(x<w && y<h){\n\t\tbool b = f[x][y];\n\t\tf[x][y]= !b;\n\t\tif(b){\n\t\t\tx++;\n\t\t}else{\n\t\t\ty++;\n\t\t}\n\t}\n\treturn make_pair(x,y);\n}\n\nbool same(city f1,city f2){\n\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(f1[x][y]!=f2[x][y])return false;\n\t\t\t}\n\treturn true;\n}\n\nvoid cp(const city& orig,city& to){\n\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tto[x][y]=orig[x][y];\n\t\t\t}\n\n}\n\nint rep(city c){\n\tcity copy;\n\tcp(field,copy);\n\tnext(copy);\n\tfor(int i=1;;i++){\n\t\tif(same(c,copy))return i;\n\t\tnext(copy);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tbool q = cin >> h >> w >> n;\n\t\tif((!q) || (h==0&&w==0&&n==0))return 0;\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tint o;\n\t\t\t\tcin >> o;\n\t\t\t\tfield[x][y] = o==1;\n\t\t\t}\n\t\tint r = rep(field);\n\t\tpos ans;\n\t\tfor(int i=0;i<(n%r);i++){\n\t\t\tans=next(field);\n\t\t}\n\t\tcout << ans.second+1 << \" \" << ans.first+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint h,w,n;\nbool d[1000][1000];\nint t[1000][1000];\nint i,j;\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t\tif(h==0)return 0;\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(x==1)d[i][j]=true;\n\t\t\tif(x==0)d[i][j]=false;\n\t\t\tt[i][j]=0;\n\t\t}\n\t\tt[0][0]=n-1;\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\t\tif(t[i][j]%2==0){\n\t\t\t\tif(i+1<h)t[i+1][j]+=t[i][j]/2;\n\t\t\t\tif(j+1<w)t[i][j+1]+=t[i][j]/2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(d[i][j]){\n\t\t\t\t\tif(i+1<h)t[i+1][j]+=t[i][j]/2;\n\t\t\t\t\tif(j+1<w)t[i][j+1]+=t[i][j]/2+1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(i+1<h)t[i+1][j]+=t[i][j]/2+1;\n\t\t\t\t\tif(j+1<w)t[i][j+1]+=t[i][j]/2;\n\t\t\t\t}\n\t\t\t\td[i][j]=!d[i][j];\n\t\t\t}\n\t\t}\n\t\tint x,y;\n\t\tx=0;\n\t\ty=0;\n\t\twhile(x!=w&&y!=h){\n\t\t\tif(d[y][x])x++;\n\t\t\telse y++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nint m[1010][1010];\nint fst[1010][1010], cyc1[1010][1010], cyc2[1010][1010];\nint main() {\n\tfor (int H, W, N; cin >> H >> W >> N, (H | W | N) != 0; ) {\n\t\tmemset(m, -1, sizeof(m));\n\t\trep(i, H) rep(j, W) cin >> m[i][j];\n\t\tmemset(fst, 0, sizeof(fst));\n\t\tmemset(cyc1, 0, sizeof(cyc1));\n\t\tmemset(cyc2, 0, sizeof(cyc2));\n\t\tfst[0][0] = 1;\n\t\tcyc1[0][0] = 1;\n\t\tcyc2[0][0] = 1;\n\t\trep(i, H) rep(j, W) if (i + j != 0) {\n\t\t\tint f1 = 1000000000, f2 = 1000000000;\n\t\t\tif (i > 0) {\n\t\t\t\tif (m[i - 1][j]) f1 = min(f1, fst[i - 1][j] + cyc1[i - 1][j] + cyc2[i - 1][j] - 1);\n\t\t\t\telse f1 = min(f1, fst[i - 1][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tif (m[i][j - 1]) f2 = min(f2, fst[i][j - 1]);\n\t\t\t\telse f2 = min(f2, fst[i][j - 1] + cyc1[i][j - 1] + cyc2[i][j - 1] - 1);\n\t\t\t}\n\t\t\tif (f1 == 1000000000) {\n\t\t\t\tfst[i][j] = f2;\n\t\t\t\tcyc1[i][j] = cyc2[i][j] = cyc1[i][j - 1] + cyc2[i][j - 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f2 == 1000000000) {\n\t\t\t\tfst[i][j] = f1;\n\t\t\t\tcyc1[i][j] = cyc2[i][j] = cyc1[i - 1][j] + cyc2[i - 1][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f1 < f2) {\n\t\t\t\tfst[i][j] = f1;\n\t\t\t\tcyc2[i][j] = f2 - f1;\n\t\t\t\tcyc1[i][j] = cyc1[i - 1][j] + cyc2[i - 1][j] - cyc2[i][j];\n\t\t\t}\n\t\t\tif (f1 > f2) {\n\t\t\t\tfst[i][j] = f2;\n\t\t\t\tcyc1[i][j] = f1 - f2;\n\t\t\t\tcyc2[i][j] = cyc1[i][j - 1] + cyc2[i][j - 1] - cyc1[i][j];\n\t\t\t}\n\t\t\tif (f1 == f2) {\n\t\t\t\tfor( ; ;) ;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tN--;\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (fst[i][j] > N) continue;\n\t\t\tint n = N - fst[i][j];\n\t\t\tint mod = n % (cyc1[i][j] + cyc2[i][j]);\n\t\t\tif (cyc2[i][j] > mod) m[i][j] = m[i][j] ? 0 : 1;\n\t\t}\n\t\t\n/*\t\tcout << \"########################\" << endl;\n\t\trep(i, H) {\n\t\t\trep(j, W) cout << m[i][j] << ' ';\n\t\t\tcout << endl;\n\t\t}\n*/\t\t\n\t\tint x = 0, y = 0;\n\t\twhile (m[y][x] != -1) {\n\t\t\tif (m[y][x]) x++;\n\t\t\telse y++;\n\t\t}\n\t\tcout << y + 1 << ' ' << x + 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint main(){\n  bool g[1000][1000];\n  int p[2][1000],i,j,h,w,n,t;\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&t);\n\tg[i][j]=t?1:0;\n       \n      }\n    for(i=0;i<w;i++)p[0][i]=p[1][i]=0;\n    p[0][0]=n-1;\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tt=i&1;\n\tn=p[t][j];\n\tif(g[i][j]){\n\t  p[1-t][j]+=n/2;\n\t  p[t][j+1]+=n-n/2;\n\t}else{\n\t  p[1-t][j]+=n-n/2;\n\t  p[t][j+1]+=n/2;\n\t}\n\tif(n&1)g[i][j]=!g[i][j];\n\tp[t][j]=0;\n      }\n\n    i=j=0;\n    while(i<h && j<w)g[i][j]?j++:i++;\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y+1 <= H) dp[y+1][x] += ((dp[y][x] + (direction[y][x] == 0 ? 1:0)) / 2);\n\tif(x+1 <= W) dp[y][x+1] += ((dp[y][x] + (direction[y][x] == 1 ? 1:0)) / 2);\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    for(int round = 0; round <= 1010; round++){\n      if((dp[y][x] + direction[y][x]) % 2 == 0) y++;\n      else if((dp[y][x] + direction[y][x]) % 2 == 1) x++;\n      if(y == H || x == W) break;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main(){\n\tint h,w,n;\n\tstatic bool field[1001][1001] = {};\n\tstatic int dp[1001][1001] = {};\n\twhile(cin >> h >> w >> n,h){\n\t\tfor(int i = 0;i <= h;i++){\n\t\t\tfor(int j = 0;j <= w;j++) {\n\t\t\t\tfield[i][j] = false;\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = n - 1;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\tif(dp[i][j] % 2 == 1){\n\t\t\t\t\tif(!field[i][j]) dp[i + 1][j]++;\n\t\t\t\t\telse dp[i][j + 1]++;\n\t\t\t\t\tfield[i][j] = !field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = 0,y = 0;\n\t\twhile(x < h && y < w){\n\t\t\tif(field[x][y]) y++;\n\t\t\telse x++;\n\t\t}\n\t\tcout << x + 1 << \" \" << y + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#include <cstdlib>\n\n#include <cmath>\n\n#include <climits>\n\n#include <cfloat>\n\n#include <map>\n\n#include <utility>\n\n#include <set>\n\n#include <iostream>\n\n#include <memory>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <functional>\n\n#include <sstream>\n\n#include <complex>\n\n#include <stack>\n\n#include <queue>\n\n#include <numeric>\n\n#include <cstring>\n\n\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\n#define pb push_back\n\n\n\nusing namespace std;\n\n\n\ntypedef long long ll;\n\ntypedef pair<int, int> P;\n\ntypedef vector<int> vi;\n\ntypedef vector<vi> vvi;\n\n\n\nconst int INF = 1 << 29;\n\nconst double EPS = 1e-9;\n\n\n\nint main(){\n\n\tint N, H, W;\n\n\tvvi field;\n\n\tint mx, my;\n\n\tint n;\n\n\n\n\twhile(1){\n\n\t\tcin >> H >> W >> N;\n\n\t\tif(H == 0 && W == 0 && N == 0) break;\n\n\n\n\t\tfield.resize(H);\n\n\t\trep(i, H){\n\n\t\t\tfield[i].resize(W);\n\n\t\t\trep(j, W){\n\n\t\t\t\tcin >> field[i][j];\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\tn = N % (H + W);\n\n\n\n\t\trep(i, n){\n\n\t\t\tmx = 0, my = 0;\n\n\t\t\twhile(my < H && mx < W){\n\n\t\t\t\tif(field[my][mx] == 0){\n\n\t\t\t\t\tfield[my][mx] = 1;\n\n\t\t\t\t\tmy += 1;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tfield[my][mx] = 0;\n\n\t\t\t\t\tmx += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmy++, mx++;\n\n\t\tcout << my << \" \" << mx << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nbool mp[1002][1002];\nint count[1002][1002];\nint main(){\n    int h,w,n;\n    while(cin>>h>>w>>n,h){\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                cin>>mp[i][j];\n            }\n        }\n        memset(count,0,sizeof(count));\n        count[0][0]=n-1;\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                mp[i][j]=mp[i][j]^(count[i][j]%2);\n                count[i][j+1] += (count[i][j]+!mp[i][j])/2;\n                count[i+1][j] += (count[i][j]+mp[i][j])/2;\n            }\n        }\n        int x=0,y=0;\n        while(x<w&&y<h){\n            if(mp[y][x]) ++x;\n            else ++y;\n        }\n        cout<<y+1<<\" \"<<x+1<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint H, W, T, a[1009][1009];\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &T), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t}\n\t\t}\n\t\tint cx = 0, cy = 0;\n\t\twhile (cx < H && cy < W) {\n\t\t\tif ((T ^ a[cx][cy]) & 1) cx++;\n\t\t\telse cy++;\n\t\t\tT = (T + 1) >> 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", cx + 1, cy + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a[1000][1000];\nint main()\n{\n\tint h, w, n, x, y, i, j;\n\twhile (cin >> h >> w >> n)\n\t{\n\t\tif (!h && !w && !n) break;\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tcin >> a[i][j];\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (x = y = 0; (x < w && y < h);)\n\t\t\t{\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\ta[y][x] = 1, y++;\n\t\t\t\telse if (a[y][x] == 1)\n\t\t\t\t\ta[y][x] = 0, x++;\n\t\t\t}\n\t\t}\n\t\tcout << y+1 << \" \" << x+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int h,w,n,c[1001][1001]={},a,d[1000][1000];\n  while(cin>>h>>w>>n&&h){\n    c[0][0]=n-1;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tscanf(\"%d\",&a);\n\tc[i+1][j]+=c[i][j]/2;\n\tc[i][j+1]+=c[i][j]/2;\n\tif(c[i][j]%2){\n\t  if(a)c[i][j+1]++;\n\t  else c[i+1][j]++;\n\t}\n\tif(c[i][j]%2)d[i][j]=!a;\n\telse d[i][j]=a;\n      }\n    int x=0,y=0;\n    while(x!=w&&y!=h){\n      if(d[y][x])x++;\n      else y++;\n    }\n    cout<<y+1<<' '<<x+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nlong long n,field[1001][1001],dp[1001][1001];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    memset(dp,0,sizeof(dp));\n    memset(field,0,sizeof(field));\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    dp[0][0] = n-1;\n    for(int i=0; i<w; i++){\n      for(int j=0; j<h; j++){\n \tif(dp[i][j]>0){\n\t  if(dp[i][j]%2 == 0){\n\t    dp[i+1][j]+=dp[i][j]/2;\n\t    dp[i][j+1]+=dp[i][j]/2;\n\t  }\n\t  else{\n\t    if(field[i][j] == 0){\n\t      dp[i+1][j]+=dp[i][j]/2;\n\t      dp[i][j+1]+=dp[i][j]/2+1;\n\t    }\n\t    if(field[i][j] == 1){\n\t      dp[i+1][j]+=dp[i][j]/2+1;\n\t      dp[i][j+1]+=dp[i][j]/2;\n\t    }\n\t  }\n\t}\n      }\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+dp[j][i]%2)%2;\n      }\n    }\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<map>\nusing namespace std;\n#define fr first\n#define sc second\nint main(){\n  int h,w,n,mas[1002][1002],dp[1002][1002],x,y;\n  while(cin >> h >> w >> n , h){\n    for(int i = 0 ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        cin >> mas[i][j];\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][0] = n - 1;\n    for(int i = 0 ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        if(i<h-1)dp[i + 1][j] += (dp[i][j] + (mas[i][j] == 1 ? 0:1)) / 2;\n        if(j<w-1)dp[i][j + 1] += (dp[i][j] + (mas[i][j] == 0 ? 0:1)) / 2;\n      }\n    }\n    x = 0 , y = 0;\n    while(x != h && y != w) (dp[x][y]+mas[x][y]) % 2 == 0 ? x++ : y++ ;\n    cout << x + 1 << \" \" << y + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint w,h;\nint f[1111][1111];\nint dx[] = {1,0};\nint dy[] = {0,1};\n\nvoid solve(int n,int x,int y){\n  if(x==w || y == h){\n    printf(\"%d %d\\n\",y+1,x+1);\n    return;\n  }\n  int m = (n+f[x][y])%2;\n  solve((n-1)/2+1,x+dx[m],y+dy[m]);\n}\n\nint main(void){\n  int n;\n  while(1){\n    scanf(\"%d%d%d\",&n,&w,&h); if(!n)break;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tscanf(\"%d\",&f[j][i]);\n      }\n    }\n    solve(n,0,0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint t[1002][1002];\nint dp[1002][1002];\n\nint main(void){\n  int i,j,ti,tj;\n  int w,h,n;\n  int d,gx,gy;\n\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        scanf(\"%d\",&t[i][j]);\n      }\n    }\n\n    memset(dp,0,sizeof(dp));\n    dp[0][0] = n;\n    gx = 0, gy = 0;\n\n    for(tj=0;tj<w && gx<w && gy<h;tj++){\n      for(i=0;i<h && 0<=tj-i && gx<w && gy<h;i++){\n        d = 0;\n        j = tj - i;\n\n        if(dp[i][j] % 2 == 0){\n          d = !t[i][j];\n          dp[i][j+1] += dp[i][j] / 2;\n          dp[i+1][j] += dp[i][j] / 2;\n        }\n        else{\n          d = t[i][j];\n          dp[i][j+1] += dp[i][j] / 2 + d;\n          dp[i+1][j] += dp[i][j] / 2 + !d;\n        }\n        if(gx == j && gy == i){\n          gx += d;\n          gy += !d;\n        }\n      }\n    }\n\n    for(ti=1;ti<h && gx<w && gy<h;ti++){\n      for(tj=0;tj<w && ti+tj<h && gx<w && gy<h;tj++){\n        d = 0;\n        i = ti + tj;\n        j = w - tj - 1;\n\n        if(dp[i][j] % 2 == 0){\n          d = !t[i][j];\n          dp[i][j+1] += dp[i][j] / 2;\n          dp[i+1][j] += dp[i][j] / 2;\n        }\n        else{\n          d = t[i][j];\n          dp[i][j+1] += dp[i][j] / 2 + d;\n          dp[i+1][j] += dp[i][j] / 2 + !d;\n        }\n        if(gx == j && gy == i){\n          gx += d;\n          gy += !d;\n        }\n      }\n    }\n\n    printf(\"%d %d\\n\",gy+1,gx+1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#pragma warning(disable : 4996)\nint H, W, T, a[1009][1009], dp[1009][1009];\nint main() {\n\twhile (scanf(\"%d%d%d\\n\", &H, &W, &T), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\ta[i][j] = getchar_unlocked(); getchar_unlocked();\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = T - 1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tdp[i + 1][j] += (dp[i][j] - a[i][j] + 1) >> 1;\n\t\t\t\tdp[i][j + 1] += (dp[i][j] + a[i][j]) >> 1;\n\t\t\t}\n\t\t}\n\t\tint cx = 0, cy = 0;\n\t\twhile (cx < H && cy < W) {\n\t\t\tif ((dp[cx][cy] ^ a[cx][cy]) & 1) cy++;\n\t\t\telse cx++;\n\t\t\tT >>= 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", cx + 1, cy + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nbool grid[1000][1000];\nint num[1000][1000];\nint h,w,n,tmp;\n\nint main(){\n  while(scanf(\"%d %d %d\",&h,&w,&n) && (h||w||n)){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tscanf(\"%d\",&tmp);\n\tgrid[i][j] = (tmp)?true:false;\n\tnum[i][j] = 0;\n      }\n\n    num[0][0] = n-1;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tint N=num[i][j];\n\tif(grid[i][j]){\n\t  num[i+1][j] += N/2;\n\t  num[i][j+1] += N-N/2;\n\t}else{\n\t  num[i][j+1] += N/2;\n\t  num[i+1][j] += N-N/2;\n\t}\n\tif(N&1)grid[i][j] = ~grid[i][j];\n      }\n\n    int y=0,x=0;\n    while(y<h && x<w){\n      if(grid[y][x])x++;\n      else y++;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<functional>\nusing namespace std;\nint za[1002][1002],suu[1002][1002];\nint main(void)\n{\n\tint i,j,h,w,n,x,y;\n\twhile(1) {\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0) break;\n\t\tfor(i=1;i<=h;i++) {\n\t\t\tfor(j=1;j<=w;j++) {\n\t\t\t\tscanf(\"%d\",&za[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++) {\n\t\t\tfor(j=1;j<=w;j++) {\n\t\t\t\tsuu[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tsuu[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++) {\n\t\t\tfor(j=1;j<=w;j++) {\n\t\t\t\tif(suu[i][j]%2==0) {\n\t\t\t\t\tsuu[i+1][j]+=suu[i][j]/2;\n\t\t\t\t\tsuu[i][j+1]+=suu[i][j]/2;\n\t\t\t\t}\n\t\t\t\telse if(suu[i][j]%2==1) {\n\t\t\t\t\tif(za[i][j]==0) {\n\t\t\t\t\t\tsuu[i+1][j]+=suu[i][j]/2+1;\n\t\t\t\t\t\tsuu[i][j+1]+=suu[i][j]/2;\n\t\t\t\t\t\tza[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuu[i][j+1]+=suu[i][j]/2+1;\n\t\t\t\t\t\tsuu[i+1][j]+=suu[i][j]/2;\n\t\t\t\t\t\tza[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t\tx=1;\n\t\ty=1;\n\t\twhile(1) {\n\t\t\tif(za[x][y]==1) y++;\n\t\t\telse x++;\n\t\t\tif(x==h+1 || y==w+1) break;\n\t\t}\n\t\tprintf(\"%d %d\\n\",x,y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool ba[1000][1000];\nint dx[] = {0,1};\nint dy[] = {1,0};\nint h, w;\n\nvoid solve(int x, int y, int n) {\n  if (x > h || y > w) {\n    cout << y+1 << \" \" << x+1 << endl;\n    return;\n  }\n  bool d;\n  if (n%2) {\n    d = ba[x][y];\n  } else {\n    d = !ba[x][y];\n  }\n  solve(x+dx[d], y+dy[d], (n+1)/2);\n}\n\nint main() {\n  int n;\n  while(cin>>h>>w>>n,h||w||n) {\n    REP(y,h) REP(x,w)\n      cin >> ba[x][y];\n    solve(0,0,n);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\twhile(1){\n\t\tstatic int h,w,n;\n\t\tstatic int a[1005][1005] = {};\n\t\t\n\t\tscanf(\"%d%d%d\",&h,&w,&n); if(h==0)break;\n\t\trep1(i,h){\n\t\t\trep1(j,w){\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic int dp[1005][1005] = {};\n\t\tdp[1][1] = n-1;\n\t\t\n\t\tfor(int i = 2 ; i <= w+h ; i ++){\n\t\t\trep1(j,h){\n\t\t\t\tif(i-j < 1)break;\n\t\t\t\tif(i-j > w)continue;\n\t\t\t\tdp[j+1][i-j] += dp[j][i-j]/2;\n\t\t\t\tdp[j][i-j+1] += dp[j][i-j]/2;\n\t\t\t\tif(dp[j][i-j]&1){\n\t\t\t\t\tdp[j+dir_4[a[j][i-j]][0]][i-j+dir_4[a[j][i-j]][1]] ++;\n\t\t\t\t\ta[j][i-j] ^= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x = 1,y = 1;\n\t\twhile(x <= h && y <= w){\n\t\t\tif(a[x][y]){\n\t\t\t\ty ++;\n\t\t\t}\n\t\t\telse x ++;\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\",x,y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//58\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int h,w,n;cin>>h>>w>>n,h|w|n;){\n    static int g[1000][1000];\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n      }\n    }\n    static int t[1001][1001];\n    fill(t[0],t[1001],0);\n    t[0][0]=n-1;\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tt[y+1][x]+=t[y][x]/2+(g[y][x]==0&&t[y][x]%2);\n\tt[y][x+1]+=t[y][x]/2+(g[y][x]==1&&t[y][x]%2);\n\tg[y][x]^=t[y][x]%2;\n      }\n    }\n    int y=0,x=0;\n    while(y!=h&&x!=w){\n      (g[y][x]?x:y)++;\n    }\n    cout<<y+1<<' '<<x+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nqueue<POS> check;\nlong next[201][201],field[201][201],n;\nbool flag[201][201];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    /*    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n      }*/\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    /*    while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n      }*/\n    /*    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n      }*/\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int MAX_N=10000000, INF=1<<30;\nint h, w, n;\nint ma[1001][1001];\nint dp[1001][1001];\nvoid solve(int i, int j){\n  if(i>h||j>w){\n    cout<<i<<' '<<j<<endl;\n    return;\n  }\n    if(ma[i][j])\n      solve(i,j+1);\n    else\n      solve(i+1,j);\n}\nint main(){\n  while(cin>>h>>w>>n&&h){\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcin>>ma[i][j];\n      }\n    }\n    ma[1][0]=INF;\n    dp[1][1]=n-1;\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tif(i==1&&j==1) continue;\n\tdp[i][j]+=dp[i][j-1]/2+dp[i-1][j]/2;\n\tif(ma[i][j-1]&&dp[i][j-1]%2==1)\n\t  dp[i][j]++;\n\tif(ma[i-1][j]==0&&dp[i-1][j]%2==1)\n\t  dp[i][j]++;\n      }\n    }\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tif(dp[i][j]%2==1){\n\t  if(ma[i][j]==1)\n\t    ma[i][j]=0;\n\t  else\n\t    ma[i][j]=1;\n\t}\n      }\n    }\n    solve(1,1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n;\nvector<vector<int>> f;\n\nbool input(){\n  int x,y;\n  cin>>x>>y;\n  cin>>n;\n  f.clear();\n  if(x==y&&y==n&&n==0)return false;\n  f.resize(x);\n  for(int i=0;i<f.size();i++){\n    f[i].resize(y);\n  }\n  for(int i=0;i<f.size();i++){\n    for(int j=0;j<f[i].size();j++){\n      cin>>f[i][j];\n    }\n  }\n  return true;\n}\n\nbool inside(vector<vector<int>> &c,int x,int y){\n  if(x<0)return false;\n  if(y<0)return false;\n  if(c.size()<=x)return false;\n  if(c[x].size()<=y)return false;\n  return true;\n}\n\npair<int,int> solve(){\n  vector<vector<int>> change;\n  change.resize(f.size());\n  for(int i=0;i<change.size();i++){\n    change[i].resize(f[i].size());\n  }\n  change[0][0] = n-1;\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(change[i][j] <= 0)continue;\n      if(inside(change,i+1,j))change[i+1][j] += change[i][j]/2;\n      if(inside(change,i,j+1))change[i][j+1] += change[i][j]/2;\n      if(change[i][j]%2){\n        if(f[i][j]==0){\n          if(inside(change,i+1,j))change[i+1][j]++;\n        }else{\n          if(inside(change,i,j+1))change[i][j+1]++;\n        }\n      }\n    }\n  }\n  /*\n  for(auto i:f){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  for(auto i:change){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  for(int i=0;i<change.size();i++){\n    for(int j=0;j<change[i].size();j++){\n      if(change[i][j]%2==1){\n        f[i][j] = !f[i][j];\n      }\n    }\n  }\n  /*\n  for(auto i:f){\n    for(auto j:i){\n      cout<<j<<\" \";\n    }cout<<endl;\n  }cout<<endl;\n  */\n  pair<int,int> res(0,0);\n  while(res.first<change.size()&&res.second<change[0].size()){\n    if(f[res.first][res.second]==0){\n      res.first++;\n    }else{\n      res.second++;\n    }\n  }\n  res.first++;\n  res.second++;\n  return res;\n}\n\n\nint main(){\n  while(input()){\n    auto ans = solve();\n    cout<<ans.first<<\" \"<<ans.second<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <string.h>\n\nint board[1234][1234];\nint mark[1234][1234];\n\nint main()\n{\n\tfor (;;)\n\t{\n\t\tint h, w, n;\n\t\tscanf(\"%d %d %d\", &h, &w, &n);\n\t\tif (h == 0 && w == 0 && n == 0)break;\n\t\tmemset(board, 255, sizeof(board));\n\t\tfor (int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &board[i][j]);\n\t\t\t}\n\t\t}\n\t\tmemset(mark, 0, sizeof(mark));\n\t\tmark[0][0] = n - 1;\n\t\tfor (int sum = 0; sum < w + h - 1; ++sum)\n\t\t{\n\t\t\tfor (int vr = 0; vr <= sum; ++vr)\n\t\t\t{\n\t\t\t\tint hr = sum - vr;\n\t\t\t\tif (hr >= w)continue;\n\t\t\t\tif (hr < 0)break;\n\t\t\t\tif (board[vr][hr] == 0)\n\t\t\t\t{\n\t\t\t\t\tmark[vr][hr + 1] += mark[vr][hr] / 2;\n\t\t\t\t\tmark[vr + 1][hr] += mark[vr][hr] / 2 + (mark[vr][hr] % 2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmark[vr][hr + 1] += mark[vr][hr] / 2 + (mark[vr][hr] % 2);\n\t\t\t\t\tmark[vr + 1][hr] += mark[vr][hr] / 2;\n\t\t\t\t}\n\t\t\t\tif (mark[vr][hr] % 2)\n\t\t\t\t{\n\t\t\t\t\tboard[vr][hr] = (board[vr][hr] == 0) ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint py = 0, px = 0;\n\t\twhile (board[py][px] >= 0)\n\t\t{\n\t\t\tif (board[py][px] == 0)\n\t\t\t{\n\t\t\t\t++py;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++px;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", py + 1, px + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nusing namespace std;\nint main(){\n  int h,w,n;\n  while(scanf(\"%d%d%d\",&h,&w,&n)&&h){\n    int c[1001][1001]={},a;\n    c[0][0]=n-1;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tscanf(\"%d\",&a);\n\tc[i+1][j]+=c[i][j]/2;\n\tc[i][j+1]+=c[i][j]/2;\n\tif(c[i][j]%2){\n\t  if(a)c[i][j+1]++;\n\t  else c[i+1][j]++;\n\t}\n\tc[i][j]+=a;\n      }\n    int x=0,y=0;\n    while(x!=w&&y!=h){\n      if(c[y][x]%2)x++;\n      else y++;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nint mo[5] = {0,1,0,-1,0};\n\nvoid calc(int h,int w,int n){\n    int in[1000][1000],dp[1001][1001]={0},x,y;\n    \n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n            scanf(\"%d\",&in[i][j]);\n    \n    dp[0][0]=n-1;\n    \n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++){\n            dp[i+1][j]=(dp[i][j]+1-in[i][j])/2;\n            dp[i][j+1]=(dp[i][j]+in[i][j])/2;\n        }\n    \n    while(x<w && y<h){\n        if((dp[y][x]+in[y][x])%2)\n            x++;\n        else\n            y++;\n    }\n    \n    printf(\"%d %d\\n\",y+1,x+1);\n    \n}\n\nint main(){\n    int h,w,n;\n    \n    while(1){\n        scanf(\"%d%d%d\",&h,&w,&n);\n        \n        if(h==0) break;\n        \n        calc(h,w,n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n\nint c[1010][1010],g[1010][1010];\n\nint main(){\n  int H,W,N;\n  while(true){\n    memset(c,0,sizeof(c));\n    memset(g,0,sizeof(g));\n    ///配列初期化\n\n    scanf(\"%d%d%d\",&H,&W,&N);\n    ///printf(\"%d%d%d\\n\",H,W,N); \n    if(H==0 && W==0 && N==0){break;}\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  scanf(\"%d\",&c[i][j]);///初期ステ読み込み\n\t  ///printf(\"%d\",c[i][j]);\n\t}///printf(\"\\n\");\n    }\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  if(g[i-1][j]%2==1){\n\t    g[i][j]=g[i][j]+(g[i-1][j]-1)/2;\t    \n\t    if(c[i-1][j]==0){\n\t    g[i][j]=g[i][j]+1;\n\t    }\n\t  }\n\t  else{\n\t    g[i][j]=g[i][j]+g[i-1][j]/2;\n\t  }\n\t  \n\t  if(g[i][j-1]%2==1){\n\t    g[i][j]=g[i][j]+(g[i][j-1]-1)/2;\n\t    if(c[i][j-1]==1){\n\t    g[i][j]=g[i][j]+1;\n\t    }\n\t  }\n\t  else{\n\t    g[i][j]=g[i][j]+g[i][j-1]/2;\n\t  }\n\t  if(i==1&&j==1){g[1][1]=N-1;}\n\t  ///回数判定fin\n\t}\n    }\n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  c[i][j]=(c[i][j]+g[i][j])%2;\n\t  /// printf (\"%d \",c[i][j]);\n\t}\n      ///  printf(\"\\n\");\n    }///目的のマップ\n    \n    int x,y;///Let's walking\n    x=1;\n    y=1;\n    while(x<=H&&y<=W)      \n      {\n\tif(c[x][y]==1)\n\t  {y=y+1;}\n\telse\n\t  {x=x+1;}\n      }\n    \n\n\n\n    printf(\"%d %d\\n\",x,y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n#define MAX 1024\n#define fr first\n#define sc second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<int,int> pi;\n\nvoid MakeCountMap(int h, int w, int M[][MAX],int cnt[][MAX]){\n  queue<pi> qp;\n  bool vis[MAX][MAX]={{false,},};\n  qp.push( mp(0,0) );\n  while(!qp.empty()){\n    pi now=qp.front();\n    qp.pop();\n    if(now.fr==h||now.sc==w)continue;\n    int flr=cnt[now.fr][now.sc]/2;\n    int cel=cnt[now.fr][now.sc]%2==0?flr:flr+1;\n    cnt[now.fr+1][now.sc]+=M[now.fr][now.sc]==1?flr:cel;\n    cnt[now.fr][now.sc+1]+=M[now.fr][now.sc]==1?cel:flr;\n    if(!vis[now.fr+1][now.sc]){\n      vis[now.fr+1][now.sc]=true;\n      qp.push(mp(now.fr+1,now.sc));\n    }\n    if(!vis[now.fr][now.sc+1]){\n      vis[now.fr][now.sc+1]=true;\n      qp.push(mp(now.fr,now.sc+1));\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    static int M[MAX][MAX];\n    static int cnt[MAX][MAX];\n    int h,w,n;\n    cin >> h >> w >> n;\n    \n    if( h == 0 && w == 0 && n == 0 ) break;\n    \n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n\tcnt[i][j] = 0;\n      }\n    }\n    cnt[0][0] = n;\n\n    MakeCountMap(h,w,M,cnt);\n\n    /*\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcout << cnt[i][j] << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n\n    int nowi=0;\n    int nowj=0;\n    while(nowi<h&&nowj<w){\n      if(cnt[nowi][nowj]%2==0){\n\tM[nowi][nowj]=M[nowi][nowj]==1?0:1;\n      }\n      if(M[nowi][nowj]){\n\tnowj++;\n      }else{\n\tnowi++;\n      }\n    }\n    cout<<1+nowi<<' '<<1+nowj<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\n//constexpr int MAX_N = 1005;\nconstexpr int MAX_H = 1005;\nconstexpr int dx[] = {0, 1};\nconstexpr int dy[] = {1, 0};\n\nint h, w, n, fld[MAX_H][MAX_H], dp[MAX_H][MAX_H];\n\nbool Solve() {\n    cin >> h >> w >> n;\n    if (!h) return false;\n\n    memset(fld, -1, sizeof(fld));\n\n    for (int y = 1; y <= h; ++y) {\n        for (int x = 1; x <= w; ++x) {\n            cin >> fld[x][y];\n        }\n    }\n\n    dp[1][1] = n - 1;\n    for (int y = 1; y <= h; ++y) {\n        for (int x = (y == 1 ? 2 : 1); x <= w; ++x) {\n            for (int i = 0; i < 2; ++i) {\n                int tx = x - dx[i], ty = y - dy[i];\n                dp[x][y] = dp[tx][ty] / 2 + (dp[tx][ty] % 2 && fld[tx][ty] == i) ? 1 : 0;\n            }\n        }\n    }\n\n    for (int y = 1; y <= h; ++y) {\n        for (int x = 1; x <= w; ++x) {\n            fld[x][y] += dp[x][y];\n            fld[x][y] %= 2;\n        }\n    }\n\n    {\n        int x = 1, y = 1;\n\n        while (fld[x][y] != -1) {\n            int nx = x + dx[fld[x][y]];\n            y += dy[fld[x][y]];\n            x = nx;\n        }\n\n        cout << y << \" \" << x << endl;\n    }\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint h,w,n;\nint f[1111][1111];\nint m[1111][1111];\nint dx[] = {0,1};\nint dy[] = {1,0};\nint main(void){\n  while(cin >> h >> w >> n && h){\n    memset(m,0,sizeof(m));\n    m[0][0] = n-1;\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n\tcin >> f[x][y];\n\tfor(int k = 0; k < 2; k++){\n\t  int nx = x + dx[k];\n\t  int ny = y + dy[k];\n\t  m[nx][ny] += (m[x][y] + ((f[x][y] == k)?1:0) )/2;\n\t}\n\tif(m[x][y] % 2) f[x][y] = (f[x][y]+1)%2;\n      }\n    }\n\n    int x = 0,y = 0;\n    while(x != w && y != h){\n      int nx = x + dx[f[x][y]];\n      int ny = y + dy[f[x][y]];\n      x = nx;\n      y = ny;\n    }\n    cout << y+1 << \" \" << x+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define SOUTH 0\n#define EAST  1\n\nint town_map[1000][1000];\nint table1[1000][1000];\nint table2[1000][1000];\n\nint calc_times(int table[1000][1000], int i, int j) {\n    int ret = 0;\n\n    if (i > 0) {\n        if (town_map[i-1][j] == SOUTH) {\n            ret += (table[i-1][j]+1)/2;\n        } else {\n            ret += table[i-1][j]/2;\n        }\n    }\n\n    if (j > 0) {\n        if (town_map[i][j-1] == EAST) {\n            ret += (table[i][j-1]+1)/2;\n        } else {\n            ret += table[i][j-1]/2;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    while (1) {\n        int i;\n        int h, w, n;\n        int now_x = 0;\n        int now_y = 0;\n        scanf(\"%d %d %d\", &h, &w, &n);\n        if (h == 0) return 0;\n    \n        for (i=0;i<h;i++) {\n            int j;\n            for (j=0;j<w;j++) {\n                scanf(\"%d\", &town_map[i][j]);\n                table1[i][j] = 0;\n                table2[i][j] = 0;\n            }\n        }\n    \n        table1[0][0] = n-1;\n        table2[0][0] = n;\n    \n        for (i=0;i<h;i++) {\n            int j;\n            for (j=0;j<w;j++) {\n                table1[i][j] += calc_times(table1, i, j);\n                table2[i][j] += calc_times(table2, i, j);\n            }\n        }\n    \n        for (i=0;i<h;i++) {\n            if (table1[i][w-1] != table2[i][w-1]) printf(\"%d %d\\n\", i+1, w+1);\n        }\n    \n        for (i=0;i<w-1;i++) {\n            if (table1[h-1][i] != table2[h-1][i]) printf(\"%d %d\\n\", h+1, i+1);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nint main(){\n  queue<POS> check;\n  long next[201][201],field[201][201],n;\n  bool flag[201][201];\n  int h,w;\n  while(cin >>h>>w>>n,h||w||n){\n    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n    }\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int , int > Pi;\n\nint main()\n{\n  int H, W, N, mas[1000][1000], dp[1000][1000];\n\n  while(cin >> H >> W >> N, H){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> mas[i][j];\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][0] = N - 1;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        if(i + 1 < H) dp[i + 1][j] += (dp[i][j] + !mas[i][j]) >> 1;\n        if(j + 1 < W) dp[i][j + 1] += (dp[i][j] + mas[i][j]) >> 1;\n      }\n    }\n    int h = 0, w = 0;\n    while(h != H && w != W){\n      if((dp[h][w] + mas[h][w]) % 2) w++;\n      else h++;\n    }\n\n    cout << h + 1 << \" \" << w + 1 << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 1010\nusing namespace std;\n\nint mp[MAX][MAX],dp[MAX][MAX];\n\nvoid solve(){\n int h,w,n;\n for(;;){\n  cin>>h>>w>>n;\n  if(!h&&!w&&!n) break;\n  FOR(i,h) FOR(j,w) cin>>mp[i][j];\n  ZERO(dp);\n  dp[0][0]=n-1;\n  FOR(i,h){\n   FOR(j,w){\n    if(i+1!=h) dp[i+1][j]+=(dp[i][j]+mp[i][j]^1)>>1;\n    if(j+1!=w) dp[i][j+1]+=(dp[i][j]+mp[i][j])>>1;\n   }\n  }\n  FOR(i,h) FOR(j,w) if(dp[i][j]&1) mp[i][j]^=1;\n  int x=0,y=0;\n  while(x!=h-1&&y!=w-1){\n   if(mp[x][y]) y++;\n   else x++;\n  }\n  x++; y++;\n  cout<<x<<\" \"<<y<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int h, w, n; cin >> h >> w >> n, h;) {\n\t\tvector<vector<int> > east(h, vector<int>(w));\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tcin >> east[i][j];\n\n\t\tvector<vector<int> > dp(h + 1, vector<int>(w + 1, 0));\n\t\tdp[0][0] = n;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tint num_east = dp[i][j] - dp[i][j] / 2, num_south = dp[i][j] / 2;\n\t\t\t\tif(!east[i][j])\n\t\t\t\t\tswap(num_east, num_south);\n\n\t\t\t\tdp[i][j + 1] += num_east;\n\t\t\t\tdp[i + 1][j] += num_south;\n\t\t\t}\n\t\t}\n\n\t\tint x = 0, y = 0;\n\t\twhile(x < w && y < h) {\n\t\t\tif((dp[y][x] + east[y][x]) & 1)\n\t\t\t\t++y;\n\t\t\telse\n\t\t\t\t++x;\n\t\t}\n\n\t\tcout << y + 1 << \" \" << x + 1 << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint angle[2][2] = {\n\t{1, 0}, {0, 1}\n};\n\nbool map[2000][2000];\n\nint main()\n{\n\tint H, W, N;\n\t\n\twhile (scanf(\"%d %d %d\", &H, &W, &N), H + W + N){\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint y, x;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\ty = 0;\n\t\t\tx = 0;\n\t\t\twhile (y != H && x != W){\n\t\t\t\tint a = angle[map[y][x]][0];\n\t\t\t\tint b = angle[map[y][x]][1];\n\t\t\t\tmap[y][x] = !map[y][x];\n\t\t\t\t\n\t\t\t\ty += a;\n\t\t\t\tx += b;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\", y + 1, x + 1);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[1005][1005];bool e[1005][1005];\nint a,b,c;\nvoid saiki(int x,int y){\n    if(x==a||y==b){cout<<x+1<<\" \"<<y+1<<endl;return;}\n    if(e[x][y])saiki(x,y+1);\n    else saiki(x+1,y);\n    }\nsigned main(){\n   cin>>a>>b>>c;\n   for(int f=0;f<a;f++){\n       for(int g=0;g<b;g++){\n\t   scanf(\"%d\",&e[f][g]);\n\t   }\n       }\n       d[0][0]=c-1;\n       for(int h=0;h<a+b-1;h++){\n\t   for(int i=0;i<=h;i++){\n\t       int x=i,y=h-i;\n\t       if(d[x][y]&1){\n\t\t   if(e[x][y]){\n\t\t       d[x+1][y]+=d[x][y]/2;d[x][y+1]+=d[x][y]/2+1;\n\t\t       }\n\t\t   else {\n\t\t       d[x+1][y]+=d[x][y]/2+1;d[x][y+1]+=d[x][y]/2;\n\t\t       }\n\t\t   }\n\t\telse {d[x+1][y]+=d[x][y]/2;d[x][y+1]+=d[x][y]/2;}\n\t\te[x][y]=(e[x][y]+d[x][y])&1;\n\t       }\n\t   }\n\tsaiki(0,0);\n    }"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define int ll\n#define INF 999999999\n//#define INF (1LL<<59)\n\nint data[1010][1010];\nint dp[1010][1010];\n\nint h,w,n;\n\nvoid dfs(int y,int x, int num){\n\tif(num==0)return ;\n\tif(y==h||x==w)return ;\n\tdp[y][x] += num%2;\n\t\n\tint d=num/2, r=num/2;\n\tif(data[y][x]==0) d+=num%2;\n\tif(data[y][x]==1) r+=num%2;\n\n\tdfs(y+1,x,d);\n\tdfs(y,x+1,r);\n}\n\n\nvoid move(int y,int x){\n\tif(y==h||x==w) cout<<y+1<<\" \"<<x+1<<endl;\n\n\tif(data[y][x]==0)move(y+1,x);\n\tif(data[y][x]==1)move(y,x+1);\n}\n\n\nsigned main(){\n\tcin>>h>>w>>n;\n\t\n\trep(i,1010)rep(j,1010)data[i][j]=-1;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tcin>>data[i][j];\n\t\t}\n\t}\n\t\n\t\n\trep(i,1010)rep(j,1010)dp[i][j]=0;\n\t\n\tdfs(0,0,n-1);\n\t\n\t\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(dp[i][j]%2==1) data[i][j] = !data[i][j];\n\t\t}\n\t}\n\t\n\t\n\tmove(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint h,w,n;\n\tint dp[101][101];\n\tint map[101][101];\n\tint a,b;\n\tint i,j;\n\t\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta=b=1;\n\t\twhile(a<=h && b<=w){\n\t\t\tif(map[a][b]==0){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",a,b);\n\t\tscanf(\"%d %d %d\",h,w,n);\n\t}\n\treturn 0;\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream.h>\nint num[1005][1005],h,w,n;\npair<int,int>p;\nint main(){\nwhile(1){\nscanf(\"%d %d %d\",&h,&w,&n);\nfor(int i=1;i<=h;i++){\nfor(int j=1;j<=w;j++){\nscanf(\"%d\",&num[j][i]);\n}\n}\nint y=1,s=1,cou=0;\nwhile(1){\ncou++;\nif(num[y][s]){\ny++;\nnum[y][s]=(num[y][s]+1)%2;\np=make_pair(y,s);\nbreak;\n}else{\nnum[y][s]=(num[y][s]+1)%2;\ns++;\np=make_pair(y,s);\n}\nif(cou==n){\ncout << p.first << \" \" << p.second << endl; return 0;\n}\nif(p.first==1 && p.second==h){\ncout << p.first <<\" \"<< p.second << endl; return 0;\n}\nif(p.first==w && p.second==1){\ncout << p.first <<\" \"<<p.second <<endl; return 0;\n}\n}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<map>\nusing namespace std;\n#define fr first\n#define sc second\nint main(){\n  int h,w,n,mas[1002][1002],x,y;\n  while(cin >> h >> w >> n , h){\n    for(int i = 0 ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        cin >> mas[i][j];\n      }\n    }\n    for(int i = 0 ; i < n ; i++ ){\n      x = 0 , y = 0;\n      while( x != h && y != w ){\n        if(mas[x][y] == 1){\n          mas[x][y] = 0;\n          y++;\n        }else{\n          mas[x][y] = 1;\n          x++;\n        }\n      }\n    }\n    cout << x + 1 << \" \" << y + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n\nint a[1010][1010];\nint dp[1010][1010];\n\nint main()\n{\n    int h,w,n;\n    \n    while (cin>>h>>w>>n, h) {\n        memset(dp, 0, sizeof(dp));\n        rep(i, h) rep(j, w) cin >> a[i][j];\n\n        dp[0][0] = n-1;\n\n        rep(i, h) {\n            rep(j, w) {\n                if (a[i][j] == 0) {\n                    dp[i+1][j] += dp[i][j] / 2 + (dp[i][j] % 2);\n                    dp[i][j+1] += dp[i][j] / 2;\n                } else {\n                    dp[i][j+1] += dp[i][j] / 2 + (dp[i][j] % 2);\n                    dp[i+1][j] += dp[i][j] / 2;\n                }\n            }\n        }\n\n        rep(i, h) rep(j, w) {\n            a[i][j] = (a[i][j] + dp[i][j]) % 2;\n        }\n\n        int y = 0, x = 0;\n\n        puts(\"\");\n        rep(i, h) rep(j, w) {\n            printf(\"%d%c\", a[i][j], j==w-1?'\\n':' ');\n        }\n\n        while (y < h && x < w) {\n            if (a[y][x] == 1) x++;\n            else y++;\n        }\n\n        cout << y+1 << ' ' << x+1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint h,w,n,c[1000][1000];\nint dp[1001][1001];\nint d[1000][1000];\n\nint main(){\n\twhile(scanf(\"%d%d%d\",&h,&w,&n),h){\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) scanf(\"%d\",&c[i][j]);\n\t\tfor(int i=0;i<=1000;i++) for(int j=0;j<=1000;j++) dp[i][j]=0;\n\t\tdp[1][1]=n-1;\n\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++){\n\t\t\tif(i!=1){\n\t\t\t\tif(c[i-2][j-1]==0) dp[i][j]+=(dp[i-1][j]+1)/2;\n\t\t\t\telse dp[i][j]+=dp[i-1][j]/2;\n\t\t\t}\n\t\t\tif(j!=1){\n\t\t\t\tif(c[i-1][j-2]==1) dp[i][j]+=(dp[i][j-1]+1)/2;\n\t\t\t\telse dp[i][j]+=dp[i][j]/2;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++)\n\t\t\td[i][j]=(c[i][j]+dp[i+1][j+1])%2;\n\t\tint i=1,j=1;\n\t\twhile(i<=h&&j<=w){\n\t\t\tif(d[i-1][j-1]) j++;\n\t\t\telse i++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",i,j);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nint h,w,n;\nint maps[1001][1001];\nint home[1001][1001];\nint main(void){\n  scanf(\"%d%d%d\",&h,&w,&n);\n  while(h!=0){\n    memset(maps,0,sizeof(maps));\n    memset(home,0,sizeof(home));\n    int i,j;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&(maps[i][j]));\n      }\n    }\n    home[0][0]=n-1;\n    int a;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(home[i][j]%2==1){\n\t  a=(home[i][j]-1)/2;\n\t  home[i+1][j]=a;\n\t  home[i][j+1]=a;\n\t  if(maps[i][j]==1){\n\t    maps[i][j]=0;\n\t    home[i][j+1]++;\n\t  }\n\t  else{\n\t    maps[i][j]=1;\n\t    home[i+1][j]++;\n\t  }\n\t}\n\telse{\n\t  a=home[i][j]/2;\n\t  home[i+1][j]=a;\n\t  home[i][j+1]=a;\n\t}\n      }\n    }\n    int ansi=0,ansj=0;\n    while(ansi<h && ansj<w){\n      if(maps[ansi][ansj]==1){\n\tansj++;\n      }\n      else{\n\tansi++;\n      }\n    }\n    printf(\"%d\\x0020%d\\n\",ansi+1,ansj+1);\n    scanf(\"%d%d%d\",&h,&w,&n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n\n#define INF 1010000000\n\nint masu[1001][1001];\nint dp[1001][1001];\n\nint n,m,k;\nint xx,yy;\n\nvoid saiki(int x,int y,int masu[1001][1001]){\n\t\n\tif(x>n || y>m){\n\t\txx=x+1;\n\t\tyy=y+1;\n\t\treturn;\n\t}\n\t\n\tif(masu[x][y]==1){\n\t\tsaiki(x+1,y,masu);\n\t}else{\n\t\tsaiki(x,y+1,masu);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tsinttt(n,m,k);\n\t\tif(n==0)break;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tsint(masu[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,1000){\n\t\t\trep(j,1000)dp[i][j]=0;\n\t\t}\n\t\t\n\t\tdp[0][0]=k-1;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tmasu[i][j]=!masu[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsaiki(0,0,masu);\n\t\tprintf(\"%d %d\\n\",yy,xx);\n\t\t/*\n\t\tputs(\"\");\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tprintf(\"%d \",masu[j][i]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint main(){\n  bool g[1000][1000];\n  int p[2][1000],i,j,h,w,n,t;\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&t);\n\tg[i][j]=t?1:0;\n\tp[i&1][j]=0;\n      }\n\n    p[0][0] = n-1;\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tt=i&1;\n\tn=p[t][j];\n\tp[1-t][j]+=n/2;\n\tp[t][j+1]+=n/2;\n\tif(n&1){\n\t  g[i][j]?p[t][j+1]++:p[1-t][j]++;\n\t  g[i][j]=!g[i][j];\n\t}\n\tp[t][j]=0;\n      }\n\n    i=j=0;\n    while(i<h && j<w)g[i][j]?j++:i++;\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint h, w, n;\n\twhile(scanf(\"%d%d%d\", &h, &w, &n), h){\n\t\tvector<vector<int> > a(h, vector<int>(w));\n\t\tvector<vector<int> > c(h + 1, vector<int>(w + 1));\n\t\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tc[0][0] = n - 1;\n\t\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tint s = c[i][j];\n\t\t\tint ch = s >> 1;\n\t\t\tif(s & 1){\n\t\t\t\tif(!a[i][j]){\n\t\t\t\t\tch = (s + 1) >> 1;\n\t\t\t\t}\n\t\t\t\ta[i][j] = !a[i][j];\n\t\t\t}\n\t\t\tc[i + 1][j] += ch;\n\t\t\tc[i][j + 1] += s - ch;\n\t\t}\n\n\t\tint y = 0, x = 0;\n\t\twhile(y < h && x < w){\n\t\t\tif(a[y][x]){ ++x; }\n\t\t\telse{ ++y; }\n\t\t}\n\t\tprintf(\"%d %d\\n\", y + 1, x + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(ll i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define RREP(i,n) for(ll i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nll way[1002][1002];\nll dp[1002][1002];\nint main(){\n    while(true){\n\tll h,w,n;\n\tmemset(dp,0ll,sizeof(dp));\n\tmemset(way,0ll,sizeof(way));\n\tcin >> h >> w >> n;\n\tif(h == 0 && w == 0 && n == 0) break;\n\tREP(i,h)REP(j,w) {\n\t    cin >> way[i+1][j+1];\n\t}\n\tdp[1][1] = n-1;\n\tREP(i,h)REP(j,w){\n\t    if(i == 0 && j == 0) continue;\n\t    ll u = 0;\n\t    ll l = 0;\n\t    if(i > 0){\n\t\tif(dp[i][j+1]%2 == 0) u = dp[i][j+1]/2;\n\t\telse if(way[i][j+1] == 0) u = 1 + dp[i][j+1]/2;\n\t\telse u = dp[i][j+1]/2;\n\t    }\n\t    if(j > 0){\n\t\tif(dp[i+1][j]%2 == 0) l = dp[i+1][j]/2;\n\t\telse if(way[i+1][j] == 1) l = 1 + dp[i+1][j]/2;\n\t\telse l = dp[i+1][j]/2;\n\t    }\n\t    dp[i+1][j+1] = u + l;\n\t}\n\tll x = 1;\n\tll y = 1;\n\twhile(x <= w && y <= h){\n\t    if( (way[y][x] + dp[y][x])%2 == 1){\n\t\tx++;\n\t    }else y++;\n\t}\n\tprintf(\"%d %d\\n\",y,x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tgetchar_unlocked(); a[i][j] = getchar_unlocked() - '0';\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] >> 1;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) >> 1;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) >> 1;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] >> 1;\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (dp[x][y] ^ a[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", x + 1, y + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\n\tint h,w,n;\n\tint field[1000][1000];\n\twhile(cin >> h >> w >> n && !(h == 0 && n == 0 && w == 0)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nint dp[1000][1000];\n\nint main()\n{\n\tint w, h, n;\n\twhile(cin >> h >> w >> n && w)\n\t{\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tvector<vint> field(w, vint(h));\n\n\t\trep(y, h) rep(x, w)\n\t\t\tcin >> field[x][y];\n\n\t\tdp[0][0] = n-1;\n\t\trep(x, w) rep(y, h)\n\t\t{\n\t\t\t// ðKêéê\n\t\t\tif(x+1 < w) \n\t\t\t\tdp[x+1][y] += (dp[x][y] + dp[x][y] % 2 * -(1 - field[x][y] * 2)) / 2;\n\t\t\t\n\t\t\t// ìðKêéê\n\t\t\tif(y+1 < h)\n\t\t\t\tdp[x][y+1] += (dp[x][y] + dp[x][y] % 2 *  (1 - field[x][y] * 2)) / 2;\n\t\t}\n\n\t\tpint p = make_pair(0,0);\n\t\twhile(p.first < w && p.second < h)\n\t\t{\n\t\t\tif(dp[p.first][p.second] & 1)\n\t\t\t\tfield[p.first][p.second] = !field[p.first][p.second]; \n\n\t\t\tif(field[p.first][p.second])\n\t\t\t\tp.first++;\n\t\t\telse\n\t\t\t\tp.second++;\n\t\t}\n\n\t\tcout << p.second + 1 << \" \" << p.first + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint num[1005][1005],h,w,n;\npair<int,int>p;\nint main(){\nwhile(1){\nscanf(\"%d %d %d\",&h,&w,&n);\nfor(int i=1;i<=h;i++){\nfor(int j=1;j<=w;j++){\nscanf(\"%d\",&num[j][i]);\n}\n}\nint y=1,s=1,cou=0;\nwhile(1){\nif(num[y][s]){\ny++;\nif(y==w+1){\ncou++;\np=make_pair(y,s);\n}else{\nnum[y][s]=(num[y][s]+1)%2;\n}\n}else{\ns++;\nif(y==h+1){\ncou++;\np=make_pair(y,s);\n}else{\nnum[y][s]=(num[y][s]+1)%2;\n}\n}\nif(cou==n){\ncout << p.first << \" \" << p.second << endl; return 0;\n}\nif(p.first==1 && p.second==h){\ncout << p.first <<\" \"<< p.second << endl; return 0;\n}\nif(p.first==w && p.second==1){\ncout << p.first <<\" \"<<p.second <<endl; return 0;\n}\n}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int MAX_N=10000000;\nint h, w, n;\nint ma[1001][1001];\nvoid solve(int i, int j, int t){\n  if(i>h||j>w){\n    cout<<i<<' '<<j<<endl;\n    return;\n  }\n  bool dir;\n  dir=ma[i][j];\n  int south, east;\n  if(i!=1||j!=1)\n    if(t!=0)\n      t++;\n  if(t){\n    if(dir){\n      south=(t-1)/2;\n      east=t/2;\n    }\n    else{\n      south=t/2;\n      east=(t-1)/2;\n    }\n    if(t%2==0){\n      if(dir)\n\tsolve(i+1,j,south);\n      else\n\tsolve(i,j+1,east);\n    }\n    else{\n      if(dir)\n\tsolve(i,j+1,east);\n      else\n\tsolve(i+1,j,south);\n    }\n  }\n  else{\n    if(dir)\n      solve(i,j+1,0);\n    else\n      solve(i+1,j,0);\n  }\n}\nint main(){\n  while(cin>>h>>w>>n&&h){\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcin>>ma[i][j];\n      }\n    }\n    solve(1,1, n);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#include <cstdlib>\n\n#include <cmath>\n\n#include <climits>\n\n#include <cfloat>\n\n#include <map>\n\n#include <utility>\n\n#include <set>\n\n#include <iostream>\n\n#include <memory>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <functional>\n\n#include <sstream>\n\n#include <complex>\n\n#include <stack>\n\n#include <queue>\n\n#include <numeric>\n\n#include <cstring>\n\n\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\n#define pb push_back\n\n\n\nusing namespace std;\n\n\n\ntypedef long long ll;\n\ntypedef pair<int, int> P;\n\ntypedef vector<int> vi;\n\ntypedef vector<vi> vvi;\n\n\n\nconst int INF = 1 << 29;\n\nconst double EPS = 1e-9;\n\n\n\nint main(){\n\n\tint N, H, W;\n\n\tvvi field;\n\n\tint mx, my;\n\n\tint n;\n\n\n\n\twhile(1){\n\n\t\tcin >> H >> W >> N;\n\n\t\tif(H == 0 && W == 0 && N == 0) break;\n\n\n\n\t\tfield.resize(H);\n\n\t\trep(i, H){\n\n\t\t\tfield[i].resize(W);\n\n\t\t\trep(j, W){\n\n\t\t\t\tcin >> field[i][j];\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\tn = N % (H + W);\n\n\t\tif(N >= H + W) n++;\n\n\n\n\t\trep(i, n){\n\n\t\t\tmx = 0, my = 0;\n\n\t\t\twhile(my < H && mx < W){\n\n\t\t\t\tif(field[my][mx] == 0){\n\n\t\t\t\t\tfield[my][mx] = 1;\n\n\t\t\t\t\tmy += 1;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tfield[my][mx] = 0;\n\n\t\t\t\t\tmx += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmy++, mx++;\n\n\t\tcout << my << \" \" << mx << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint g[1024][1024];\nint dp[1024][1024];\nint H, W, N;\n\nint main(){\n  while(1){\n    scanf(\"%d%d%d\", &H, &W, &N);\n    if(!H && !W && !N) break;\n    rep(i,H) rep(j,W) scanf(\"%d\", &g[i][j]);\n    \n    memset(dp, 0, sizeof(dp));\n    \n    dp[0][0] = N-1;\n    rep(i,H) rep(j,W){\n      dp[i][j+1] += (dp[i][j]+g[i][j])/2;\n      dp[i+1][j] += (dp[i][j]+!g[i][j])/2;\n    }\n\n    int h = 0, w = 0;\n    while(h < H && w < W){\n      if((dp[h][w]+g[h][w])%2) w++;\n      else h++;\n    }\n    \n    printf(\"%d %d\\n\", h+1, w+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint h,w,n;\n\tbool field[1000][1000];\n\tint dp[1001][1001] = {};\n\twhile(1){\n\t\tcin >> h >> w >> n;\n\t\tif(!h) break;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = n - 1;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\tif(dp[i][j] % 2 == 1){\n\t\t\t\t\tif(field[i][j]){\n\t\t\t\t\t\tdp[i][j + 1]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i + 1][j]++;\n\t\t\t\t\t}\n\t\t\t\t\tfield[i][j] = !field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = 0,y = 0;\n\t\twhile(x < h && y < w){\n\t\t\tif(field[x][y]) y++;\n\t\t\telse x++;\n\t\t}\n\t\tcout << x + 1 << \" \" << y + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\n//更新の頻度に着目\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    START:\n    \n    int H,W,N;\n    cin >> H >> W >> N;\n    if(H == 0) return 0;\n    int state[1000][1000];\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            cin >> state[i][j];\n        }\n    }\n    \n    //N-1回目までの訪問回数を求める\n    int c[1000][1000] = {};\n    c[0][0] = N-1;\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            if(i == 0 && j == 0) continue;\n            if(j != 0) c[i][j] += c[i][j-1] / 2;\n            if(j != 0 && c[i][j-1]%2 == 1 && state[i][j-1] == 1) c[i][j]++;\n            if(i != 0) c[i][j] += c[i-1][j] / 2;\n            if(i != 0 && c[i-1][j]%2 == 1 && state[i-1][j] == 0) c[i][j]++;\n        }\n    }\n\n    int x = 0; int y = 0;\n    while(x < W && y < H){\n        if((state[y][x] + c[y][x]) % 2 == 0) y++;\n        else x++;\n    }\n    cout << y+1 << \" \" << x+1 << endl;\n\n    goto START;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint num[1005][1005],h,w,n;\npair<int,int>p;\nint main(){\nwhile(1){\nscanf(\"%d %d %d\",&h,&w,&n);\nfor(int i=1;i<=h;i++){\nfor(int j=1;j<=w;j++){\nscanf(\"%d\",&num[j][i]);\n}\n}\nint y=1,s=1,cou=0;\nwhile(1){\ncou++;\nif(num[y][s]){\ny++;\nnum[y][s]=(num[y][s]+1)%2;\np=make_pair(y,s);\n}else{\nnum[y][s]=(num[y][s]+1)%2;\ns++;\np=make_pair(y,s);\n}\nif(cou==n){\ncout << p.first << \" \" << p.second << endl; return 0;\n}\nif(p.first==1 && p.second==h){\ncout << p.first <<\" \"<< p.second << endl; return 0;\n}\nif(p.first==w && p.second==1){\ncout << p.first <<\" \"<<p.second <<endl; return 0;\n}\n}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[1010][1010];\nint grd[1010][1010];\nint main(){\n\twhile(true){\n\tint h,w,n;\tcin>>h>>w>>n;\n\tif(h==0)\treturn 0;\n\tmemset(dp,0,sizeof(dp));\tmemset(grd,0,sizeof(grd));\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)\tcin>>grd[i][j];\n\t}\n\tdp[0][0]=n-1;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(j+1<w){\n\t\t\t\tif(grd[i][j]==1)\tdp[i][j+1]+=(dp[i][j]+1)/2;\n\t\t\t\telse \tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t}\n\t\t\tif(i+1<h){\n\t\t\t\tif(grd[i][j]==1)\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\telse \tdp[i+1][j]+=(dp[i][j]+1)/2;\n\t\t\t}\n\t\t\tdp[i][j]%=2;\n\t\t}\n\t}\n\tint x=0,y=0;\n\twhile(x<w&&y<h){\n\t\tif((grd[y][x]^dp[y][x])==1)\tx++;\n\t\telse \ty++;\n\t}\n\tcout<<y+1<<\" \"<<x+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\nll divup(ll a, ll b) {\n    if (a > 0) return (a-1)/b+1;\n    else return a/b;\n}\n\nll divlo(ll a, ll b) {\n    if (a < 0) return (a+1)/b-1;\n    else return a/b;\n}\n\nint dx[2] = {1, 0};\nint dy[2] = {0, 1};\n\n\nconst int MAX = 1010;\n\nint H, W, N;\nint a[MAX][MAX];\n\npint dp[MAX][MAX];\n\nint main() {\n    while (cin >> H >> W >> N) {\n        if (H == 0) break;\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j)\n                cin >> a[i][j];\n    \n        for (int i = 0; i < MAX; ++i) for (int j = 0; j < MAX; ++j) dp[i][j] = MP(0,0);\n        if (a[0][0] == 0) dp[0][0] = MP(divup(N-1,2), divlo(N-1,2));\n        else dp[0][0] = MP(divlo(N-1,2), divup(N-1,2));\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                if (i == 0 && j == 0) continue;\n                int num = 0;\n                if (i >= 1) num += dp[i-1][j].FI;\n                if (j >= 1) num += dp[i][j-1].SE;\n                if (a[i][j] == 0) dp[i][j] = MP(divup(num,2), divlo(num,2));\n                else dp[i][j] = MP(divlo(num,2), divup(num,2));\n                \n                //cout << i << \", \" << j << \" : \" << dp[i][j] << endl;\n            }\n        }\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                int num = dp[i][j].FI + dp[i][j].SE;\n                if (num & 1) a[i][j] = 1 - a[i][j];\n            }\n        }\n        int x = 0, y = 0;\n        while (x != H && y != W) {\n            x += dx[a[x][y]], y += dy[a[x][y]];\n        }\n        ++x; ++y;\n        \n        cout << x << \" \" << y << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n\nint c[1010][1010],g[1010][1010];\n\nint main(){\n  int H,W,N;\n  while(true){\n    memset(c,0,sizeof(c));\n    memset(g,0,sizeof(g));\n    ///配列初期化\n\n    scanf(\"%d%d%d\",&H,&W,&N);\n    printf(\"%d%d%d\\n\",H,W,N); \n    if(H==0 && W==0 && N==0){break;}\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  scanf(\"%d\",&c[i][j]);///初期ステ読み込み\n\t  ///printf(\"%d\",c[i][j]);\n\t}///printf(\"\\n\");\n    }\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  if(g[i][j-1]%2==0){\n\t    if(g[i-1][j]%2==0)\n\t      {g[i][j]=g[i-1][j]/2+g[i][j-1]/2;}\n\t    else\n\t\t{g[i][j]=(g[i-1][j]-1)/2+g[i][j-1]/2;\n\t\t  if(c[i-1][j]==0)\n\t\t    {g[i][j] = g[i][j] +1;}\n\t\t}\n\t  }\n\t  if(g[i][j-1]%2==1){\n\t    if(g[i-1][j]%2==0)\n\t      {g[i][j] = g[i-1][j]/2 + (g[i][j-1]-1)/2;}\n\t    else\n\t      {g[i][j] = (g[i-1][j]-1)/2 + (g[i][j-1]-1)/2;\n\t\tif(c[i-1][j]==0)\n\t\t  {g[i][j]=g[i][j]+1;}\n\t      }\n\t    if(c[i][j-1]==1)\n\t      {g[i][j] = g[i][j] +1;}\n\t  }\n\t  if(i==1&&j==1){g[1][1]=N-1;}\n\t  ///回数判定fin\n\t}\n    }\n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  c[i][j]=(c[i][j]+g[i][j])%2;\n\t  printf (\"%d,%d \",c[i][j],g[i][j]);\n\t}\n      printf(\"\\n\");\n    }///目的のマップ\n    \n    int x,y;///Let's walking\n    x=1;\n    y=1;\n    while(x<=H&&y<=W)      \n      {\n\tif(c[x][y]==1)\n\t  {y=y+1;}\n\telse\n\t  {x=x+1;}\n      }\n    \n\n\n\n    printf(\"%d %d\\n\",x,y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\n//dp[H][W]\nint ary[1010][1010],dp[1010][1010];\nint main(){\n\tint H,W,N;\n\twhile(true){\n\t\tcin>>H>>W>>N;\n\t\tif(H==0&&W==0&&N==0) break;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>ary[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=H+1;i++){\n\t\t\tfor(int j=1;j<=W+1;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tdp[1][1]=N;\n\t\tint nx,ny;\n\t\tnx=1;ny=1;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tint tmp=dp[i][j];\n\t\t\t\tif(tmp&1){\n\t\t\t\t\tif(i==ny&&j==nx){\n\t\t\t\t\t\tif(ary[i][j]){\n\t\t\t\t\t\t\tnx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tny++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ary[i][j]){\n\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j+1]+=(dp[i][j]>>1);\n\t\t\t\t\tdp[i+1][j]+=(dp[i][j]>>1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(i==ny&&j==nx){\n\t\t\t\t\t\tif(ary[i][j]){\n\t\t\t\t\t\t\tny++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j+1]+=(dp[i][j]>>1);\n\t\t\t\t\tdp[i+1][j]+=(dp[i][j]>>1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ny<<\" \"<<nx<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint grid[1000][1000];\nint dp[1001][1001];\nint dx[] = {1, 0};\nint dy[] = {0, 1};\n\nint main()\n{\n\tint h, w, n;\n\twhile (scanf(\"%d %d %d\", &h, &w, &n), h){\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\tif (dp[i][j] & 1){\n\t\t\t\t\tif (grid[i][j] == 0) dp[i + 1][j]++;\n\t\t\t\t\telse dp[i][j + 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint nx = 0;\n\t\tint ny = 0;\n\t\twhile (nx < h && ny < w){\n\t\t\tint dir = (grid[nx][ny] + dp[nx][ny]) & 1;\n\t\t\tnx += dx[dir];\n\t\t\tny += dy[dir];\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\", nx + 1, ny + 1);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bitset>\nint main()\n{\n\tint h,w,n,x,i,j,s;\n\tstd::bitset<1001>b[1001];\n\twhile(scanf(\"%d%d%d\",&h,&w,&n),n)\n\t{\n\t\tint a[2][1001]={0};\n\t\tfor(i=0;i<h;++i)for(j=0;j<w;++j)scanf(\"%d\",&x),b[i][j]=x;\n\t\ta[0][0]=n-1;\n\t\tfor(s=i=0;i<h;++i,s=!s)for(j=0;j<w;++j)\n\t\t{\n\t\t\ta[s][j+1]+=(a[s][j]+b[i][j])/2;\n\t\t\ta[!s][j]=(a[s][j]+!b[i][j])/2;\n\t\t\tif(a[s][j]&1)b[i].flip(j);\n\t\t}\n\t\tfor(i=j=0;i<h&&j<w;)\n\t\t{\n\t\t\tif(b[i][j])++j;\n\t\t\telse ++i;\n\t\t}\n\t\tprintf(\"%d %d\\n\",i+1,j+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nvoid solve(int H,int W,int N) {\n    int moji[H][W];\n    int cnt[H][W];\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            cin >> moji[i][j]; // 0->south / 1->east\n            cnt[i][j]=0;\n        }\n    }\n\n    // count visit numbers for N-1 walk\n    cnt[0][0]=N-1;\n    for(int j=0; j<W-1; ++j) {\n        cnt[0][j+1]=(cnt[0][j]+moji[0][j])/2;\n    }\n    for(int i=0; i<H-1; ++i) {\n        cnt[i+1][0]=(cnt[i][0]+1-moji[i][0])/2;\n    }\n    for(int i=1; i<H-1; ++i) {\n        for(int j=1; j<W-1; ++j) {\n            cnt[i+1][j+1]=(cnt[i+1][j]+moji[i+1][j])/2+(cnt[i][j+1]+1-moji[i][j+1])/2;\n        }\n    }\n    // calculate status after N-1 walk\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            moji[i][j]=(moji[i][j]+cnt[i][j])%2;\n        }\n    }\n    // Nth walk\n    int h=0, w=0;\n    while(h<H && w<W) {\n        if(moji[h][w]==0) ++h;\n        else ++w;\n    }\n    cout << h+1 << \" \" << w+1 << endl;\n\n    return;\n}\n\nint main() {\n    int H,W,N;\n    while(true) {\n        cin >> H >> W >> N;\n        if(H==0 && W==0 && N==0) break;\n        solve(H,W,N);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n    int h,w,n;\n    int map[1000][1000]{0};\n    int i=0,k=0;\n    \n    while (1) {\n    cin>>h>>w>>n;\n        if(h==0)break;\n    for(i=0;i<h;i++){\n        for(k=0;k<w;k++){\n            cin>>map[i][k];\n        }\n    }\n    \n    for(int j=0;j<n;j++){\n        i=0;\n        k=0;\n        while(1){\n            if(i>=h||k>=w)break;\n            if(map[i][k]==1){\n                map[i][k]=!map[i][k];\n                k++;\n            }\n            else{\n                map[i][k]=!map[i][k];\n                i++;\n            }\n        }\n    }\n    }\n    cout<<i+1<<\" \"<<k+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W,N;\nint** table;\nint** dp;\n\nvoid func(){\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tscanf(\"%d\",&table[i][k]);\n\t\t\tdp[i][k] = 0;\n\t\t}\n\t}\n\n\tdp[0][0] = N-1;\n\tfor(int i = 1; i < W; i++){\n\t\tif(dp[0][i-1]%2 == 0){\n\t\t\tdp[0][i] = dp[0][i-1]/2;\n\t\t}else{\n\t\t\tif(table[0][i-1] == 1){\n\t\t\t\tdp[0][i] = (dp[0][i-1]+1)/2;\n\t\t\t}else{\n\t\t\t\tdp[0][i] = (dp[0][i-1]-1)/2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 1; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\n\t\t\tif(dp[row-1][col]%2== 0){\n\t\t\t\tdp[row][col] += dp[row-1][col]/2;\n\t\t\t}else{\n\t\t\t\tif(table[row][col-1] == 0){\n\t\t\t\t\tdp[row][col] += (dp[row-1][col]+1)/2;\n\t\t\t\t}else{\n\t\t\t\t\tdp[row][col] += (dp[row-1][col]-1)/2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(col > 0){\n\t\t\t\tif(dp[row][col-1]%2 == 0){\n\t\t\t\t\tdp[row][col] += dp[row][col-1]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(table[row][col-1] == 1){\n\t\t\t\t\t\tdp[row][col] += (dp[row][col-1]+1)/2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[row][col] += (dp[row][col-1]-1)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(dp[row][col]%2==1){\n\t\t\t\ttable[row][col] = 1 - table[row][col];\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans_row = 0,ans_col = 0;\n\twhile(ans_row < H && ans_col < W){\n\t\tif(table[ans_row][ans_col] == 0){\n\t\t\tans_row++;\n\t\t}else{\n\t\t\tans_col++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",ans_row+1,ans_col+1);\n\n}\n\n\nint main(){\n\n\ttable = new int*[1001];\n\tdp = new int*[1001];\n\tfor(int i = 0; i < 1001; i++){\n\t\ttable[i] = new int[1001];\n\t\tdp[i] = new int[1001];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&N);\n\t\tif(H == 0 && W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1000;\n\nint h, w, n, dp[N][N], data[N][N];\n\nmain(){\n  cin >> h >> w >> n;\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> data[i][j];\n  dp[0][0] = n-1;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(i == 0 && j == 0) continue;\n      int s = 0, e = 0;\n      if(i){\n        if(dp[i-1][j] % 2){\n          if(!data[i-1][j]) s = (dp[i-1][j] + 1) / 2;\n          else s = (dp[i-1][j] - 1) / 2;\n        }else s = dp[i-1][j] / 2;\n      }\n      if(j){\n        if(dp[i][j-1] % 2){\n          if(data[i][j-1]) e = (dp[i][j-1] + 1) / 2;\n          else e = (dp[i][j-1] - 1) / 2;\n        }else e = dp[i][j-1] / 2;\n      }\n      dp[i][j] = s + e;\n    }\n  }\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) if(dp[i][j] % 2) data[i][j] = 1 - data[i][j];\n  int y = 0, x = 0;\n  while(1){\n    if(y >= h || x >= w) break;\n    if(data[y][x]) x++;\n    else y++;\n  }\n  cout << y + 1 << ' ' << x + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int h, w, n;\n    while(cin >> h >> w >> n && h) {\n        vector<vector<int>> fld(h + 1, vector<int>(w + 1, -1));\n        for(int i : in(h))\n          for(int j : in(w))\n            cin >> fld[i][j];\n        vector<vector<int>> dp(h + 1, vector<int>(w + 1, 0));\n        dp[0][0] = n - 1;\n        for(int i : in(h)) for(int j : in(w)) {\n            dp[i + 1][j] += (dp[i][j] + fld[i][j]) >> 1;\n            dp[i][j + 1] += (dp[i][j] + !fld[i][j]) >> 1;\n        }\n        int x = 0, y = 0;\n        while(true) {\n            if(fld[y][x] == -1) {\n                cout << y + 1 << ' ' << x + 1 << endl;\n                break;\n            }\n            int num = fld[y][x];\n            if(dp[y][x] & 1) num ^= 1;\n            if(num) ++x; else ++y;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nint dp[1010][1010], map[1010][1010];\n\nstruct P{\n    int x, y;\n};\n\nint H, W, N;\n\nP walk(int x, int y){\n    if(x > W || y > H){\n        return {x, y};\n    }\n\n    if(map[y][x] == 1){// east\n        return walk(x+1, y);\n    }\n    return walk(x, y+1);\n}\n\nint main(){\n    std::cin >> H >> W >> N;\n\n    FOR(i, 1, H+1){\n        FOR(j, 1, W+1){\n            std::cin >> map[i][j];\n        }\n    }\n\n    dp[1][1] = N-1;\n\n    FOR(i, 1, H){\n        FOR(j, 1, W){\n            if(dp[i][j] % 2 == 0){\n                dp[i+1][j] = dp[i][j] / 2;\n                dp[i][j+1] = dp[i][j] / 2;\n            }else{\n                if(map[i][j] == 1){// EAST\n                    dp[i][j+1] = (dp[i][j] + 1) / 2;\n                    dp[i+1][j] = (dp[i][j] - 1) / 2;\n                }else{// NORTH\n                    dp[i+1][j] = (dp[i][j] + 1) / 2;\n                    dp[i][j+1] = (dp[i][j] - 1) / 2;\n                }\n            }\n        }\n    }\n\n    FOR(i, 1, H+1){\n        FOR(j, 1, W+1){\n            if(dp[i][j] == 1){\n                map[i][j] = !map[i][j];\n            }\n        }\n    }\n\n    auto p = walk(1, 1);\n    std::cout << p.y << \" \" << p.x << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint h,w,n;\nint a[1002][1002],b[1002][1002]={0};\n\npair<int,int> walk(int x,int y){\n\tif(a[x][y]==0)x++;\n\telse y++;\n\tif(x<h&&y<w)return walk(x,y);\n\tpair<int,int>ret; ret.first=x+1; ret.second=y+1; return ret;\n}\n\nint main(){\nwhile(1){\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\tb[0][0]=n-1;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tb[i][j+1]+=b[i][j]/2;\n\t\t\tb[i+1][j]+=b[i][j]/2;\n\t\t\tif(b[i][j]%2==1){\n\t\t\t\tif(a[i][j]==0)b[i+1][j]++;\n\t\t\t\telse b[i][j+1]++;\n\t\t\t}\n\t\t\ta[i][j]+=b[i][j];\n\t\t\ta[i][j]%=2;\n\t\t}\n\t}\n\tpair<int,int> ret=walk(0,0);\n\tprintf(\"%d %d\\n\",ret.first,ret.second);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint main(){\n\tint h,w,n;\n\tbool data[1001][1001];\n\twhile(std::cin>>h>>w>>n,h,w,n){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tstd::cin>>data[i][j];\n\t\t\t}\n\t\t}\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx=0,y=0;\n\t\t\twhile(1){\n\t\t\t\tif(x==w||y==h)break;\n\t\t\t\tif(data[y][x]==0)data[y][x]=1,y++;\n\t\t\t\telse data[y][x]=0,x++;\n\t\t\t}\n\t\t}\n\t\tstd::cout<<y+1<<\" \"<<x+1<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint main(){\n  bool g[1000][1000];\n  int p[2][1000],i,j,h,w,n,t;\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&t);\n\tg[i][j]=t?1:0;\n\tp[i&1][j]=0;\n      }\n\n    p[0][0] = n-1;\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tt=i&1;\n\tn=p[t][j];\n\tp[1-t][j]+=n/2;\n\tp[t][j+1]+=n/2;\n\tif(n&1){\n\t  g[i][j]?p[t][j+1]++:p[1-t][j]++;\n\t  g[i][j]=!g[i][j];\n\t}\n\tp[t][j]=0;\n      }\n\n    i=j=0;\n    while(i<h && j<w)g[i][j]?j++:i++;\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<52;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst vi emp;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,-0};\nconst int DX[8]={-1,-1,-1,0,0,1,1,1},DY[8]={1,0,-1,1,-1,1,0,-1};\n\nint h,w,n;\nvvb a;\n\nint main(){\n\twhile(1){\n\t\tcin>>h>>w>>n;\n\t\tif(!h) break;\n\t\ta=vvb(h,vb(w));\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\tint b;\n\t\t\tcin>>b;\n\t\t\ta[i][j]=b;\n\t\t}\n\t\tint x=0,y=0;\n\t\tvvi dp(h+1,vi(w+1));\n\t\tdp[0][0]=n;\n\t\tfor(int i=0;i<h+w;i++) for(int j=0;j<=i;j++) if(i-j<h&&j<w){\n\t\t\tint DP=dp[i-j][j],b=a[i-j][j];\n\t\t\tdp[i-j][j+1]+=(DP+b)/2;\n\t\t\tdp[i-j+1][j]+=(DP+!b)/2;\n\t\t\tif(x==i-j&&y==j){\n\t\t\t\tif(b^DP%2==1) x++;\n\t\t\t\telse y++;\n\t\t\t}\n\t\t}\n\t\tcout<<x+1<<' '<<y+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\twhile(1){\n\t\tstatic int h,w,n;\n\t\tstatic int a[1005][1005] = {};\n\t\t\n\t\tscanf(\"%d%d%d\",&h,&w,&n); if(h==0)break;\n\t\trep1(i,h){\n\t\t\trep1(j,w){\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic int dp[1005][1005];\n\t\trep(i,1005)rep(j,1005)dp[i][j] = 0;\n\t\tdp[1][1] = n-1;\n\t\t\n\t\tfor(int i = 2 ; i <= w+h ; i ++){\n\t\t\trep1(j,h){\n\t\t\t\tif(i-j < 1)break;\n\t\t\t\tif(i-j > w)continue;\n\t\t\t\tdp[j+1][i-j] += dp[j][i-j]/2;\n\t\t\t\tdp[j][i-j+1] += dp[j][i-j]/2;\n\t\t\t\tif(dp[j][i-j]&1){\n\t\t\t\t\tdp[j+dir_4[a[j][i-j]][0]][i-j+dir_4[a[j][i-j]][1]] ++;\n\t\t\t\t\ta[j][i-j] ^= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x = 1,y = 1;\n\t\twhile(x <= h && y <= w){\n\t\t\tif(a[x][y]){\n\t\t\t\ty ++;\n\t\t\t}\n\t\t\telse x ++;\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\",x,y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\nusing namespace std;\nint h,w,n,i,j,k,l;\nint kan[10000][10000];\nint dp[10000][10000];\nint main(void){\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&kan[i][j]);\t//kan=kanbann\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(kan[i][j]==1){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tdp[i][j+1]=dp[i][j+1]+dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i+1][j]+=(dp[i][j]/2);\n\t\t\t\t\t}\n\t\t\t\t\telse if(dp[i][j]%2==0){\n\t\t\t\t\t\t/*if(i==2 && j==2){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",dp[i][j],dp[i+1][j]);\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(kan[i][j]==0){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tdp[i][j+1]+=(dp[i][j]/2);\n\t\t\t\t\t\tdp[i+1][j]=dp[i+1][j]+(dp[i][j]/2)+1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(dp[i][j]%2==0){\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(l=1;l<=h;l++){\n\t\t\t\tfor(k=1;k<=w;k++){\n\t\t\t\t\tprintf(\"%d \",dp[l][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]!=0){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tif(kan[i][j]==0){\n\t\t\t\t\t\t\tkan[i][j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(kan[i][j]==1){\n\t\t\t\t\t\t\tkan[i][j]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti=1;\n\t\tj=1;\n\t\twhile(1){\n\t\t\tif(kan[i][j]==1){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(kan[i][j]==0){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(i==h+1 || j==w+1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",i,j);\t\n\t\t/*for(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\t\t\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tscanf(\"%d &d %d\\n\",&h,&w,&n);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[1001][1001];\nbool field[1001][1001];\nint main(){\n    int n,w,h;\n    while(scanf(\"%d%d%d\",&h,&w,&n),n){\n        for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++)\n                scanf(\"%d\",&field[i][j]);\n\n        fill(*dp,*dp+1001*1001,0);\n        dp[0][0]=n-1;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                int latte=dp[i][j];\n                dp[i+1][j]+=latte/2;\n                dp[i][j+1]+=latte/2;\n                if(latte&1){\n                    if(field[i][j])dp[i][j+1]++;\n                    else dp[i+1][j]++;\n                }\n            }\n        }\n\n        int y=0,x=0;\n        while(true){\n            if(y>=h||x>=w){\n                printf(\"%d %d\\n\",y+1,x+1);\n                break;\n            }\n            if(dp[y][x]&1)field[y][x]=field[y][x]?false:true;\n            if(field[y][x])x++;\n            else y++;\n        }\n    }\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            printf(\"%d \",dp[i][j]);\n        }\n        puts(\"\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<52;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst vi emp;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,-0};\nconst int DX[8]={-1,-1,-1,0,0,1,1,1},DY[8]={1,0,-1,1,-1,1,0,-1};\n\nint h,w,n;\nvvb a;\n\nint main(){\n\twhile(1){\n\t\tcin>>h>>w>>n;\n\t\tif(!h) break;\n\t\ta=vvb(h,vb(w));\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\tint b;\n\t\t\tcin>>b;\n\t\t\ta[i][j]=b;\n\t\t}\n\t\tint x=0,y=0;\n\t\tvvi dp(h+1,vi(w+1));\n\t\tdp[0][0]=n;\n\t\tfor(int i=0;i<h+w;i++) for(int j=0;j<=i;j++) if(i-j<h&&j<w){\n\t\t\tint DP=dp[i-j][j],b=a[i-j][j];\n\t\t\tdp[i-j][j+1]=(DP+b)/2;\n\t\t\tdp[i-j+1][j]=(DP+!b)/2;\n\t\t\tif(x==i-j&&y==j){\n\t\t\t\tif(b^DP%2==1) x++;\n\t\t\t\telse y++;\n\t\t\t}\n\t\t}\n\t\tcout<<x+1<<' '<<y+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 1010\n \nbool dp[MAX][MAX];\nint dp2[MAX][MAX];\nint H, W, N;\n \nbool get_dir(int n, bool dir)\n{\n    if (n % 2 == 0) {\n        return dir;\n    } else {\n        return !dir;\n    }\n}\n \nvoid find_last_point()\n{\n    int x = 0, y = 0;\n    while (true) {\n        if (dp[y][x] == 1) {\n            x++;\n        } else {\n            y++;\n        }\n        if (x >= W || y >= H) break;\n    }\n    cout << y+1 << \" \" << x+1 << endl;\n}\n \nint main()\n{\n    while (cin >> H >> W >> N, H) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> dp[i][j];\n            }\n        }\n        memset(dp2, 0, sizeof(dp2));\n \n        dp[0][0] = get_dir(N-1, dp[0][0]);\n        dp2[0][0] = N-1;\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp2[i][j] == 0) continue;\n                if (dp2[i][j] % 2 == 1) {\n                    if (dp[i][j] == 1) {\n                        dp2[i+1][j] += dp2[i][j]/2;\n                        dp2[i][j+1] += dp2[i][j]/2+1;\n                    } else {\n                        dp2[i+1][j] += dp2[i][j]/2+1;\n                        dp2[i][j+1] += dp2[i][j]/2;\n                    }\n                } else {\n                    dp2[i+1][j] += dp2[i][j]/2;\n                    dp2[i][j+1] += dp2[i][j]/2;\n                }\n                dp[i][j] = get_dir(dp2[i][j], dp[i][j]);\n            }\n        }\n        find_last_point();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint h,w,n;\nint maps[1001][1001];\nint home[1001][1001];\nint main(void){\n  scanf(\"%d%d%d\",&h,&w,&n);\n  while(h!=0){\n    memset(maps,0,sizeof(maps));\n    memset(home,0,sizeof(home));\n    int i,j;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&(maps[i][j]));\n      }\n    }\n    home[0][0]=n-1;\n    int a;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(home[i][j]%2==1){\n\t  a=(home[i][j]-1)/2;\n\t  home[i+1][j]=a;\n\t  home[i][j+1]=a;\n\t  if(maps[i][j]==1){\n\t    maps[i][j]=0;\n\t    home[i][j+1]++;\n\t  }\n\t  else{\n\t    maps[i][j]=1;\n\t    home[i+1][j]++;\n\t  }\n\t}\n\telse{\n\t  a=home[i][j]/2;\n\t  home[i+1][j]=a;\n\t  home[i][j+1]=a;\n\t}\n      }\n    }\n    int ansi=0,ansj=0;\n    while(ansi<h && ansj<w){\n      if(maps[ansi][ansj]==1){\n\tansj++;\n      }\n      else{\n\tansi++;\n      }\n    }\n    printf(\"%d\\x0020%d\\n\",ansi+1,ansj+1);\n    scanf(\"%d%d%d\",&h,&w,&n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint main(){\n\tint H,W,N;\n\tint cMap[1013][1013];\n\tint Map[1013][1013];\n\twhile(cin >> H >> W >> N && H && W && N){\n\t    for(int i=0;i<H+3;i++)for(int J=0;J<W+3;J++)cMap[J][i] = 0;\n\t    if(H+W+N == 0)break;\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t  cin >> Map[i][j];\n\t\t}\n\t    }\n\t    cMap[1][1] = N;//奇数ならそのまま偶数なら別\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\n\t\t    cMap[i][j+1] += cMap[i][j]/2; \n\t\t    cMap[i+1][j] += cMap[i][j]/2;\n\t\t    if(cMap[i][j]%2 != 0 ){\n\t\t\tif(Map[i][j] == 1){\n\t\t\t    cMap[i][j+1]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t    cMap[i+1][j]++;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  \n\t    int x,y;\n\t    x = y = 1;\n\t    while(1<= y && y <= H && 1<= x && x<= W){\n\t\tif(cMap[y][x]%2 == 0){\n\t\t    if(Map[y][x] == 1)y++;\n\t\t    else x++;\n\t\t}\n\t\telse{\n\t\t    if(Map[y][x] == 1)x++;\n\t\t    else y++;\n\t\t    \n\t\t}\n\t    }\n\t    cout << y << \" \" << x << endl;\n\n\t}\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint H, W, N;\n\twhile (cin >> H >> W >> N, H | W | N) {\n\t\tvector<vector<int>> a(H + 1, vector<int>(W + 1));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>> dp(H + 1, vector<int>(W + 1));\n\t\tdp[0][0] = N - 1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tdp[i + 1][j] += a[i][j] ? dp[i][j] / 2 : (dp[i][j] + 1) / 2;\n\t\t\t\tdp[i][j + 1] += a[i][j] ? (dp[i][j] + 1) / 2 : dp[i][j] / 2;\n\t\t\t}\n\t\t}\n\t\tint ti = 0, tj = 0;\n\t\twhile (ti < H && tj < W) {\n\t\t\tif (a[ti][tj] ^ (dp[ti][tj] & 1)) {\n\t\t\t\ttj++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tti++;\n\t\t\t}\n\t\t}\n\t\tcout << ti + 1 << ' ' << tj + 1 << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint main() {\n\tint h, w, n;\n\tbool a[1001][1001];\n\twhile (cin >> h >> w >> n&&h != 0 && w != 0 && n != 0) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tint b;\n\t\t\t\tcin >> b;\n\t\t\t\tif (b == 0) a[i][j] = false;\n\t\t\t\telse a[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tint sum = 0, sum2 = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = 0, y = 0;\n\t\t\twhile (x != h  && y != w) {\n\t\t\t\tif (a[x][y]) {\n\t\t\t\t\ta[x][y] = false;\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[x][y] = true;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = x + 1;\n\t\t\tsum2 = y + 1;\n\t\t}\n\t\tcout << sum << \" \" << sum2 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[3005][3005];bool e[3005][3005];\nint a,b,c;\nsigned main(){\n   while(cin>>a>>b>>c,a|b|c){\n       memset(d,0,sizeof(d));\n       memset(e,false,sizeof(e));\n   for(int f=0;f<a;f++){\n       for(int g=0;g<b;g++){\n\t   scanf(\"%d\",&e[f][g]);\n\t   }\n       }\n       d[0][0]=c-1;\n       for(int h=0;h<a+b-1;h++){\n\t   for(int i=0;i<=h;i++){\n\t       int x=i,y=h-i;\n\t       if(d[x][y]&1){\n\t\t   if(e[x][y]){\n\t\t       d[x+1][y]+=d[x][y]/2;d[x][y+1]+=d[x][y]/2+1;\n\t\t       }\n\t\t   else {\n\t\t       d[x+1][y]+=d[x][y]/2+1;d[x][y+1]+=d[x][y]/2;\n\t\t       }\n\t\t   }\n\t\telse {d[x+1][y]+=d[x][y]/2;d[x][y+1]+=d[x][y]/2;}\n\t\te[x][y]=(e[x][y]+d[x][y])&1;\n\t       }\n\t   }\n\tint x=0,y=0;\n\twhile(1){\n\t    if(x==a||y==b){cout<<x+1<<\" \"<<y+1<<endl;break;}\n\t    if(e[x][y])y++;\n\t    else x++;\n\t    }\n\t}\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lol(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint d[1010][1010],h,w,a;\nint main(){\n    while(cin>>h>>w>>a&&h){\n    int x=0,y=0;\n    memset(d,0,sizeof(d));\n    d[0][0]=a;\n    lol(i,h)lol(j,w){\n\tcin>>a;\n\td[i+1][j]+=d[i][j]/2+d[i][j]%2*(1-a);\n\td[i][j+1]+=d[i][j]/2+d[i][j]%2*a;\n\td[i][j]+=a;\n    }\n    while(x<w&&y<h){\n\tif(d[y][x]%2)y++;\n\telse x++;\n    }\n    cout<<y+1<<\" \"<<x+1<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int N, W, H;\n  while(cin>>H>>W>>N, N){\n    int dp[1001][1001] = {};\n    int grid[1001][1001];\n    REP(y,H)REP(x,W)cin>>grid[y][x];\n    dp[0][0] = N - 1;\n    REP(y,H)REP(x,W){\n      dp[y+1][x] = dp[y][x]/2;\n      dp[y][x+1] = dp[y][x]/2;\n      if(dp[y][x] % 2 == 1){\n        if(grid[y][x] == 0){\n          dp[y+1][x] += 1;\n        }else{\n          dp[y][x+1] += 1;\n        }\n      }\n    }\n    REP(y,H)REP(x,W){\n      grid[y][x] ^= dp[y][x] & 1;\n    }\n    int nx = 0, ny = 0;\n    while(nx < W && ny < H){\n      if(grid[ny][nx] == 0) ny ++;\n      else nx ++;\n    }\n    assert(nx == W || ny == H);\n    printf(\"%d %d\\n\",ny + 1, nx + 1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int h,w,n,masu[1000][1000];\n  scanf(\"%d %d %d\",&h,&w,&n);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      scanf(\"%d\",&masu[i][j]);\n    }\n  }\n  int dp[1000][1000]={};\n  dp[0][0] = n-1;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(i > 0){\n        if(dp[i-1][j]%2 == 0){\n          dp[i][j] += dp[i-1][j]/2;\n        } else {\n          if(masu[i-1][j] == 0){\n            dp[i][j] += (dp[i-1][j]+1)/2;\n          } else {\n            dp[i][j] += dp[i-1][j]/2;\n          }\n        }\n      }\n      if(j > 0){\n        if(dp[i][j-1]%2 == 0){\n          dp[i][j] += dp[i][j-1]/2;        \n\t} else {\n          if(masu[i][j-1] == 1){\n            dp[i][j] += (dp[i][j-1]+1)/2;\n          } else {\n            dp[i][j] += dp[i][j-1]/2;\n          }\n        }\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      masu[i][j] = (masu[i][j]+dp[i][j])&1;\n    }\n  }\n  int y=0,x=0;\n  while(y<h&&x<w){\n    if(masu[y][x] == 1) x++;\n    else y++;\n  }\n  printf(\"%d %d\\n\",y+1,x+1);\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h | w | n)\n\t{\n\t\tstatic bool east[1024][1024];\n\t\tfor (int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\teast[i][j] = t == 1;\n\t\t\t}\n\t\t}\n\n\t\tstatic int visit[1024][1024];\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tvisit[0][0] = --n;\n\t\tfor (int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tint a = visit[i][j] / 2, b = (visit[i][j] + 1) / 2;\n\t\t\t\tif (east[i][j])\n\t\t\t\t\tswap(a, b);\n\t\t\t\tvisit[i][j + 1] += a;\n\t\t\t\tvisit[i + 1][j] += b;\n\n\t\t\t\teast[i][j] ^= visit[i][j] & 1;\n\t\t\t}\n\t\t}\n\n\t\tint x, y;\n\t\tx = y = 0;\n\t\twhile (x < w && y < h)\n\t\t{\n\t\t\tif (east[y][x])\n\t\t\t\t++x;\n\t\t\telse\n\t\t\t\t++y;\n\t\t}\n\t\tprintf(\"%d %d\\n\", ++y, ++x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  while(true){\n    int w,h,n;\n    static int cnt[1000][1000],dir[1000][1000],field[1000][1000];\n    scanf(\"%d %d %d\",&h,&w,&n);\n    if(h==0&&w==0&&n==0) return 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        scanf(\"%d\",&dir[i][j]);\n        if(i==0&&j==0) cnt[i][j] = n - 1;\n        else if(i==0) cnt[i][j] = cnt[i][j - 1] / 2 + ((cnt[i][j - 1]) % 2) * dir[i][j - 1];\n        else if(j==0) cnt[i][j] = cnt[i - 1][j] / 2 + ((cnt[i - 1][j]) % 2) * (1^dir[i - 1][j]);\n        else cnt[i][j] = cnt[i - 1][j] / 2 + ((cnt[i - 1][j]) % 2) * (1^dir[i - 1][j]) + cnt[i][j - 1] / 2 + ((cnt[i][j - 1]) % 2) * dir[i][j - 1];\n        field[i][j] = (dir[i][j] + cnt[i][j]) % 2;\n      }\n    }\n    int x = 0, y = 0;\n    while(x<h&&y<w){\n      if(field[x][y]) y++;\n      else x++;\n    }\n    printf(\"%d %d\\n\",x+1,y+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\nint p[1010][1010];\nint dp[1010][1010];\n\nint main(){\n\tint h,w,n;\n\twhile(cin >> h >> w >> n,h){\n\t\tn--;\n\t\trep(i,h)rep(j,w) cin >> p[i][j];\n\t\trep(i,h)rep(j,w) dp[i][j]=0;\n\t\tdp[0][0]=n;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(dp[i][j]&1){\n\t\t\t\tif(p[i][j]){\n\t\t\t\t\tdp[i][j+1]=dp[i][j]/2+1;\n\t\t\t\t\tdp[i+1][j]=dp[i][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j+1]=dp[i][j]/2;\n\t\t\t\t\tdp[i+1][j]=dp[i][j]/2+1;\n\t\t\t\t}\n\t\t\t\tp[i][j]^=1;\n\t\t\t}else{\n\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t}\n\t\t}\n\t\tint ch=0,cw=0;\n\t\twhile(ch<h&&cw<w){\n\t\t\tif(p[ch][cw])\n\t\t\t\tcw++;\n\t\t\telse\n\t\t\t\tch++;\n\t\t}\n\t\tcout << ch+1 << \" \" << cw+1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint mp[1001][1001],dp[1001][1001];\nint h,w,n;\n\nvoid saiki(int x,int y){\n  int dx[]={0,1},dy[]={1,0};\n  if(y==h||x==w)cout << y+1<<\" \"<<x+1<<endl;\n  else  saiki(x+dx[mp[y][x]],y+dy[mp[y][x]]);\n}\n\nint main(){\n  while(1){\n    cin>>h>>w>>n;\n    if(!h&&!w&&!n)break;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>mp[i][j];\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=n-1;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tdp[i][j+1]+=dp[i][j]/2+mp[i][j]*dp[i][j]%2;\n\tdp[i+1][j]+=dp[i][j]/2+!mp[i][j]*dp[i][j]%2;\n\tif(dp[i][j]%2)mp[i][j]=!mp[i][j];\n      }\n\n    saiki(0,0);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[1005][1005];bool e[1005][1005];\nint a,b,c;\nvoid saiki(int x,int y){\n    if(x==a||y==b){cout<<x+1<<\" \"<<y+1<<endl;return;}\n    if(e[x][y])saiki(x,y+1);\n    else saiki(x+1,y);\n    }\nsigned main(){\n   while(cin>>a>>b>>c,a|b|c){\n       memset(d,0,sizeof(d));\n       memset(e,false,sizeof(e));\n   for(int f=0;f<a;f++){\n       for(int g=0;g<b;g++){\n\t   scanf(\"%d\",&e[f][g]);\n\t   }\n       }\n       d[0][0]=c-1;\n       for(int h=0;h<a+b-1;h++){\n\t   for(int i=0;i<=h;i++){\n\t       int x=i,y=h-i;\n\t       if(d[x][y]&1){\n\t\t   if(e[x][y]){\n\t\t       d[x+1][y]+=d[x][y]/2;d[x][y+1]+=d[x][y]/2+1;\n\t\t       }\n\t\t   else {\n\t\t       d[x+1][y]+=d[x][y]/2+1;d[x][y+1]+=d[x][y]/2;\n\t\t       }\n\t\t   }\n\t\telse {d[x+1][y]+=d[x][y]/2;d[x][y+1]+=d[x][y]/2;}\n\t\te[x][y]=(e[x][y]+d[x][y])&1;\n\t       }\n\t   }\n\tsaiki(0,0);}\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint grid[1005][1005];\nint dp[1005][1005];\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.walk\", \"r\", stdin );\n\tint h, w, n;\n\twhile (scanf (\"%d %d %d\", &h, &w, &n ), h, w, n ){\n\t\tmemset (grid, false, sizeof (grid ) );\n\t\trep (i, h ){\n\t\t\trep (j, w ){\n\t\t\t\tint in;\n\t\t\t\tscanf (\"%d\", &grid[i][j] );// 1 : 東 0 : 南\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tmemset (dp, 0, sizeof (dp ) );\n\t\tdp[0][0] = n - 1;\n\t\tfor (int i = 1; i < h; i++ ){\n\t\t\tint k = dp[i-1][0];\n\t\t\tdp[i][0] = (k % 2 == 0 ? k/2 : (!grid[i-1][0] ? (k+1)/2 : (k-1)/2 ) );\n\t\t} // end for\n\t\tfor (int j = 1; j < w; j++ ){\n\t\t\tint m = dp[0][j-1];\n\t\t\tdp[0][j] = (m % 2 == 0 ? m/2 : ( grid[0][j-1] ? (m+1)/2 : (m-1)/2 ) );\n\t\t} // end for\n\n\t\tfor (int i = 1; i < h; i++ ){\n\t\t\tfor (int j = 1; j < w; j++ ){\n\t\t\t\tint k = dp[i-1][j], m = dp[i][j-1];\n\t\t\t\tdp[i][j] += (k % 2 == 0 ? k/2 : (!grid[i-1][j] ? (k+1)/2 : (k-1)/2 ) );\t\n\t\t\t\tdp[i][j] += (m % 2 == 0 ? m/2 : ( grid[i][j-1] ? (m+1)/2 : (m-1)/2 ) );\n\t\t\t} // end for\n\t\t} // end for\n\n\t\tint row = 0, col = 0;\n\t\twhile (row < h && col < w ){\n\t\t\tif ((dp[row][col] + grid[row][col] ) % 2 == 0 ){\n\t\t\t\trow++;\n\t\t\t}else{\n\t\t\t\tcol++;\n\t\t\t} // end if\n\t\t} // end while \n \n\t\tprintf (\"%d %d\\n\", row+1, col+1 );\t\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i = 0;i < (int)(n);i++)\nusing ll = long long;\nconst ll MOD=1000000007;\nconst long long INF = 1LL << 60;\nconst double pi=acos(-1.0);\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\nll H,W,N;\nvector<vector<ll>> grid;\n\n//dp\nvector<vector<ll>> table;\nll dp(ll x,ll y){\n  if(x<0||y<0) return 0;\n  if(x==0&&y==0) return N-1;\n  if(table.at(y).at(x)>-1) return table.at(y).at(x);\n  \n  table.at(y).at(x)=0;\n  table.at(y).at(x)+=dp(x-1,y)/2;\n  if(x>0&&dp(x-1,y)%2==1&&grid.at(y).at(x-1)==1) table.at(y).at(x)++;\n  \n  table.at(y).at(x)+=dp(x,y-1)/2;\n  if(y>0&&dp(x,y-1)%2==1&&grid.at(y-1).at(x)==0) table.at(y).at(x)++;\n  \n  return table.at(y).at(x);\n}\n  \n\nint main()\n{\n  while(true){\n    cin>>H>>W>>N; if(H==0&&W==0&&N==0) break;\n    grid=vector<vector<ll>>(H,vector<ll>(W)); rep(i,H) rep(j,W) cin>>grid.at(i).at(j);\n    \n    //dp\n    table=vector<vector<ll>>(H,vector<ll>(W,-1));\n    vector<vector<ll>> vec(H,vector<ll>(W));\n    \n    rep(y,H){\n      rep(x,W){\n        if(dp(x,y)%2==0) vec.at(y).at(x)=grid.at(y).at(x);\n        else vec.at(y).at(x)=1-grid.at(y).at(x);\n      }\n    }\n    \n    //復元\n    ll x=0,y=0;\n    while(true){\n      if(x>=W||y>=H) break;\n      if(vec.at(y).at(x)==0) y+=1;\n      else x+=1;\n    }\n    cout<<y+1<<\" \"<<x+1<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N 2000\n\nlong long x[MAX_N][MAX_N];\nlong long dp[MAX_N][MAX_N];\nint h, w, n, cx, cy;\nint main() {\n\twhile (true) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tcin >> h >> w >> n;\n\t\tif (h == 0 && w == 0 && n == 0) { break; }\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tscanf(\"%d\", x[i][j]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1] = n - 1;\n\t\tfor (int i = 2; i <= h + w; i++) {\n\t\t\tfor (int j = 1; j <= h; j++) {\n\t\t\t\tint k = i - j;\n\t\t\t\tif (k >= 1 && k <= w) {\n\t\t\t\t\tif (x[j][k] == 0) {\n\t\t\t\t\t\tdp[j][k + 1] += dp[j][k] / 2;\n\t\t\t\t\t\tdp[j + 1][k] += (dp[j][k] + 1) / 2;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[j][k + 1] += (dp[j][k] + 1) / 2;\n\t\t\t\t\t\tdp[j + 1][k] += dp[j][k] / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tx[i][j] += dp[i][j];\n\t\t\t\tx[i][j] %= 2;\n\t\t\t}\n\t\t}\n\t\tcx = 1; cy = 1;\n\t\twhile (cx <= w && cy <= h) {\n\t\t\tif (x[cy][cx] == 0) {\n\t\t\t\tcy++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcx++;\n\t\t\t}\n\t\t}\n\t\tcout << cy << ' ' << cx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    while(true){\n\tint h,w,n;\n\tint way[1002][1002];\n\tint dp[1002][1002];\n\tmemset(dp,0,sizeof(dp));\n\tmemset(way,0,sizeof(way));\n\tcin >> h >> w >> n;\n\tif(h == 0 && w == 0 && n == 0) break;\n\tREP(i,h)REP(j,w) {\n\t    cin >> way[i+1][j+1];\n\t}\n\tdp[1][1] = n-1;\n\tREP(i,h)REP(j,w){\n\t    if(i == 0 && j == 0) continue;\n\t    int u = 0;\n\t    int l = 0;\n\t    if(i > 0){\n\t\tif(dp[i][j+1]%2 == 0) u = dp[i][j+1]/2;\n\t\telse if(way[i][j+1] == 0) u = 1 + dp[i][j+1]/2;\n\t    }\n\t    if(j > 0){\n\t\tif(dp[i+1][j]%2 == 0) l = dp[i+1][j]/2;\n\t\telse if(way[i+1][j] == 1) l = 1 + dp[i+1][j]/2;\n\t    }\n\t    dp[i+1][j+1] = u + l;\n\t}\n\tint x = 1;\n\tint y = 1;\n\twhile(x <= w && y <= h){\n\t    if( (way[y][x] + dp[y][x])%2 == 1){\n\t\tx++;\n\t    }else y++;\n\t}\n\tprintf(\"%d %d\\n\",y,x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int h, w, n;\n    while(cin >> h >> w >> n && h) {\n        vector<vector<int>> fld(h + 1, vector<int>(w + 1, -1));\n        for(int i : in(h))\n          for(int j : in(w))\n            cin >> fld[i][j];\n        vector<vector<int>> dp(h + 1, vector<int>(w + 1, 0));\n        dp[0][0] = n - 1;\n        for(int i : in(h)) for(int j : in(w)) {\n            dp[i + 1][j] += (dp[i][j] + !fld[i][j]) >> 1;\n            dp[i][j + 1] += (dp[i][j] + fld[i][j]) >> 1;\n        }\n        int x = 0, y = 0;\n        while(true) {\n            if(fld[y][x] == -1) {\n                cout << y + 1 << ' ' << x + 1 << endl;\n                break;\n            }\n            int num = fld[y][x];\n            if(dp[y][x] & 1) num ^= 1;\n            if(num) ++x; else ++y;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define int ll\n#define INF 999999999\n//#define INF (1LL<<59)\n\nint data[1010][1010];\nint dp[1010][1010];\n\nint h,w,n;\n\nvoid dfs(int y,int x, int num){\n\tif(num==0)return ;\n\tif(y==h||x==w)return ;\n\tdp[y][x] += num%2;\n\t\n\tint d=num/2, r=num/2;\n\tif(data[y][x]==0) d+=num%2;\n\tif(data[y][x]==1) r+=num%2;\n\t\n\tdfs(y+1,x,d);\n\tdfs(y,x+1,r);\n}\n\n\nvoid move(int y,int x){\n\tif(y==h||x==w) cout<<y+1<<\" \"<<x+1<<endl;\n\t\n\tif(data[y][x]==0)move(y+1,x);\n\tif(data[y][x]==1)move(y,x+1);\n}\n\n\nsigned main(){\n\twhile(cin>>h>>w>>n&&(h||w||n)){\n\t\t\n\t\trep(i,1010)rep(j,1010)data[i][j]=-1;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin>>data[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\trep(i,1010)rep(j,1010)dp[i][j]=0;\n\t\t\n\t\tdfs(0,0,n-1);\n\t\t\n\t\t\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(dp[i][j]%2==1) data[i][j] = !data[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tmove(0,0);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint H, W, T, a[1009][1009], dp[1009][1009];\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &T), H) {\n\t\tgetchar();\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\ta[i][j] = getchar_unlocked(); getchar_unlocked();\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = T - 1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tdp[i + 1][j] += (dp[i][j] - a[i][j] + 1) >> 1;\n\t\t\t\tdp[i][j + 1] += (dp[i][j] + a[i][j]) >> 1;\n\t\t\t}\n\t\t}\n\t\tint cx = 0, cy = 0;\n\t\twhile (cx < H && cy < W) {\n\t\t\tif ((dp[cx][cy] ^ a[cx][cy]) & 1) cy++;\n\t\t\telse cx++;\n\t\t\tT >>= 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", cx + 1, cy + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint H, W, T, a[1009][1009], dp[1009][1009];\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &T), H) {\n\t\tfor (int i = 0; i <= H; i++) {\n\t\t\tfor (int j = 0; j <= W; j++) {\n\t\t\t\tif(i < H && j < W) scanf(\"%d\", &a[i][j]);\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = T - 1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tdp[i + 1][j] += (dp[i][j] - a[i][j] + 1) >> 1;\n\t\t\t\tdp[i][j + 1] += (dp[i][j] + a[i][j]) >> 1;\n\t\t\t}\n\t\t}\n\t\tint cx = 0, cy = 0;\n\t\twhile (cx < H && cy < W) {\n\t\t\tif ((dp[cx][cy] ^ a[cx][cy]) & 1) cy++;\n\t\t\telse cx++;\n\t\t\tT >>= 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", cx + 1, cy + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nbool grid[1000][1000];\nint num[1001][1001],i,j,h,w,n,t;\n\nint main(){\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&t);\n\tgrid[i][j] = t?true:false;\n\tnum[i][j] = 0;\n      }\n\n    num[0][0] = n-1;\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tint N=num[i][j];\n\tif(grid[i][j]){\n\t  num[i+1][j] += N/2;\n\t  num[i][j+1] += N-N/2;\n\t}else{\n\t  num[i][j+1] += N/2;\n\t  num[i+1][j] += N-N/2;\n\t}\n\tif(N&1)grid[i][j] = !grid[i][j];\n      }\n\n    i=j=0;\n    while(i<h && j<w)grid[i][j]?j++:i++;\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n  };\nqueue<POS> check;\nlong n,field[1001][1001],next[1001][1001];\nbool flag[1001][1001];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n        while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n      }\n      for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n      field[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n      }\n      int px = 0,py = 0;\n      while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n      }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tif(y == 0 && x == 0) continue;\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y-1 >= 0) dp[y][x] += ((dp[y-1][x] + (direction[y-1][x] == 0 ? 1:0)) / 2);\n\tif(x-1 >= 0) dp[y][x] += ((dp[y][x-1] + (direction[y][x-1] == 1 ? 1:0)) / 2);\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    for(int round = 0; round <= 1000; round++){\n      if((dp[y][x] + direction[y][x]) % 2 == 0) y++;\n      else if((dp[y][x] + direction[y][x]) % 2 == 1) x++;\n      if(y == H || x == W) break;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n\nint c[1010][1010],g[1010][1010];\n\nint main(){\n  int H,W,N;\n  while(true){\n    memset(c,0,sizeof(c));\n    memset(g,0,sizeof(g));\n    ///配列初期化\n\n    scanf(\"%d%d%d\",&H,&W,&N);\n    printf(\"%d%d%d\\n\",H,W,N); \n    if(H==0 && W==0 && N==0){break;}\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  scanf(\"%d\",&c[i][j]);///初期ステ読み込み\n\t  ///printf(\"%d\",c[i][j]);\n\t}///printf(\"\\n\");\n    }\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  if(g[i-1][j]%2==1){\n\t    g[i][j]=g[i][j]+(g[i-1][j]-1)/2;\t    \n\t    if(c[i-1][j]==1){\n\t    g[i][j]=g[i][j]+1;\n\t    }\n\t  }\n\t  else{\n\t    g[i][j]=g[i][j]+g[i-1][j]/2;\n\t  }\n\t  \n\t  if(g[i][j-1]%2==1){\n\t    g[i][j]=g[i][j]+(g[i][j-1]-1)/2;\n\t    \n\t    if(c[i][j-1]==1){\n\t    g[i][j]=g[i][j]+1;\n\t    }\n\t  }\n\t  else{\n\t    g[i][j]=g[i][j]+g[i][j-1]/2;\n\t  }\n\t \n\t  if(i==1&&j==1){g[1][1]=N-1;}\n\t  ///回数判定fin\n\t}\n    }\n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  c[i][j]=(c[i][j]+g[i][j])%2;\n\t  printf (\"%d \",c[i][j]);\n\t}\n      printf(\"\\n\");\n    }///目的のマップ\n    \n    int x,y;///Let's walking\n    x=1;\n    y=1;\n    while(x<=H&&y<=W)      \n      {\n\tif(c[x][y]==1)\n\t  {y=y+1;}\n\telse\n\t  {x=x+1;}\n      }\n    \n\n\n\n    printf(\"%d %d\\n\",x,y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n\n#define INF 1010000000\n\nint masu[1000][1000];\nint dp[1000][1000];\n\nint n,m,k;\nint xx,yy;\n\nvoid saiki(int x,int y,int masu[1000][1000]){\n\t\n\tif(x>n || y>m){\n\t\txx=x+1;\n\t\tyy=y+1;\n\t\treturn;\n\t}\n\t\n\tif(masu[x][y]==1){\n\t\tsaiki(x+1,y,masu);\n\t}else{\n\t\tsaiki(x,y+1,masu);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tsinttt(n,m,k);\n\t\tif(n==0)break;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tsint(masu[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,1000){\n\t\t\trep(j,1000)dp[i][j]=0;\n\t\t}\n\t\t\n\t\tdp[0][0]=k-1;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tmasu[i][j]=!masu[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsaiki(0,0,masu);\n\t\tprintf(\"%d %d\\n\",yy,xx);\n\t\t/*\n\t\tputs(\"\");\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tprintf(\"%d \",masu[j][i]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint m[1000][1000];\nint kai[1001][1001];\n\nint main()\n{\n\tint h,w,n;\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\tfor(int i = 0; i < h + 1; i++)\n\t{\n\t\tfor(int ii = 0; ii < w + 1; ii++)\n\t\t{\n\t\t\tkai[i][ii] = 0;\n\t\t}\n\t}\n\tkai[0][0] = n - 1;\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int ii = 0; ii < w; ii++)\n\t\t{\n\t\t\tint w;\n\t\t\tscanf(\"%d\",&w);\n\t\t\tif(kai[i][ii] % 2 == 0)\n\t\t\t{\n\t\t\t\tkai[i + 1][ii] += kai[i][ii] / 2;\n\t\t\t\tkai[i][ii + 1] += kai[i][ii] / 2;\n\t\t\t\tm[i][ii] = w;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(w == 0)\n\t\t\t\t{\n\t\t\t\t\tkai[i + 1][ii] += kai[i][ii] / 2 + 1;\n\t\t\t\t\tkai[i][ii + 1] += kai[i][ii] / 2;\n\t\t\t\t\tm[i][ii] = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tkai[i + 1][ii] += kai[i][ii] / 2;\n\t\t\t\t\tkai[i][ii + 1] += kai[i][ii] / 2 + 1;\n\t\t\t\t\tm[i][ii] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint nowy = 0;\n\tint nowx = 0;\n\twhile(1)\n\t{\n\t\tif(nowy == h || nowx == w)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",nowy + 1,nowx + 1);\n\t\t\treturn 0;\n\t\t}\n\t\tif(m[nowy][nowx] == 0)\n\t\t{\n\t\t\tnowy++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnowx++;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[1005][1005];bool e[1005][1005];\nint a,b,c;\nvoid saiki(int x,int y){\n    if(x==a||y==b){cout<<x+1<<\" \"<<y+1<<endl;return;}\n    if(e[x][y])saiki(x,y+1);\n    else saiki(x+1,y);\n    }\nsigned main(){\n   while(cin>>a>>b>>c,a|b|c){\nmemset(d,0,sizeof(d));\nmemset(e,false,sizeof(e));\n   for(int f=0;f<a;f++){\n       for(int g=0;g<b;g++){\n\t   scanf(\"%d\",&e[f][g]);\n\t   }\n       }\n       d[0][0]=c-1;\n       for(int h=0;h<a+b-1;h++){\n\t   for(int i=0;i<=h;i++){\n\t       int x=i,y=h-i;\n\t       if(d[x][y]&1){\n\t\t   if(e[x][y]){\n\t\t       d[x+1][y]+=d[x][y]/2;d[x][y+1]+=d[x][y]/2+1;\n\t\t       }\n\t\t   else {\n\t\t       d[x+1][y]+=d[x][y]/2+1;d[x][y+1]+=d[x][y]/2;\n\t\t       }\n\t\t   }\n\t\telse {d[x+1][y]+=d[x][y]/2;d[x][y+1]+=d[x][y]/2;}\n\t\te[x][y]=(e[x][y]+d[x][y])&1;\n\t       }\n\t   }\n\tsaiki(0,0);}\n    }"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int h, w, n;\n    while (cin >> h >> w >> n, h) {\n        vector<vector<int>> a(h, vector<int>(w));\n        for (auto &ai: a) for (int &aij: ai) cin >> aij;\n        vector<vector<int>> dp(h + 1, vector<int>(w + 1));\n        dp[0][0] = n - 1;\n        for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) {\n            dp[i + 1][j] += (dp[i][j] + !a[i][j]) / 2;\n            dp[i][j + 1] += (dp[i][j] +  a[i][j]) / 2;\n            a[i][j] ^= dp[i][j] & 1;\n        }\n        int i = 0, j = 0;\n        while (i < h && j < w) {\n            (a[i][j] ? j : i)++;\n        }\n        cout << i + 1 << \" \" << j + 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint num[1005][1005],h,w,n;\npair<int,int>p;\nint main(){\nwhile(1){\nscanf(\"%d %d %d\",&h,&w,&n);\nfor(int i=1;i<=h;i++){\nfor(int j=1;j<=w;j++){\nscanf(\"%d\",&num[j][i]);\n}\n}\nint y=1,s=1,cou=0;\nwhile(1){\nif(num[y][s]){\ny++;\nif(y==w+1){\ncou++;\np=make_pair(y,s);\n}else{\nnum[y][s]=(num[y][s]+1)%2;\n}\n}else{\ns++;\nif(s=h+1){\ncou++;\np=make_pair(y,s);\n}else{\nnum[y][s]=(num[y][s]+1)%2;\n}\n}\nif(cou==n){\ncout << p.first << \" \" << p.second << endl; return 0;\n}\nif(p.first==1 && p.second==h){\ncout << p.first <<\" \"<< p.second << endl; return 0;\n}\nif(p.first==w && p.second==1){\ncout << p.first <<\" \"<<p.second <<endl; return 0;\n}\n}\n}\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nint dp[1005][1005];\nint f[1005][1005];\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\twhile(1)\n\t{\n\t\tint h,w,n;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t\tif(!h) return 0;\n\t\tfor(int i=1;i<=h;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=w;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&f[i][j]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(int i=1;i<=h;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=w;j++)\n\t\t\t{\n\t\t\t\tdp[i][j]+=(dp[i-1][j]+(!f[i-1][j]?1:0))/2+(dp[i][j-1]+(f[i][j-1]?1:0))/2;\n\t\t\t}\n\t\t}\n\t\tint x=1,y=1;\n\t\twhile(x!=h+1 && y!=w+1)\n\t\t{\n\t\t\tint dir=(f[x][y]+dp[x][y])%2;\n\t\t\tif(!dir) x++; else y++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",x,y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint h,w,n;\nbool d[1000][1000];\nint t[1000][1000];\nint i,j;\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t\tif(h==0)return 0;\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(x==1)d[i][j]=true;\n\t\t\tif(x==0)d[i][j]=false;\n\t\t\tt[i][j]=0;\n\t\t}\n\t\tt[0][0]=n-1;\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\t\tif(t[i][j]%2==0){\n\t\t\t\tif(i+1<h)t[i+1][j]+=t[i][j]/2;\n\t\t\t\tif(j+1<w)t[i][j+1]+=t[i][j]/2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(d[i][j]){\n\t\t\t\t\tif(i+1<h)t[i+1][j]+=t[i][j]/2;\n\t\t\t\t\tif(j+1<w)t[i][j+1]+=t[i][j]/2+1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(i+1<h)t[i+1][j]+=t[i][j]/2+1;\n\t\t\t\t\tif(j+1<w)t[i][j+1]+=t[i][j]/2;\n\t\t\t\t}\n\t\t\t\td[i][j]=!d[i][j];\n\t\t\t}\n\t\t}\n\t\tint x,y;\n\t\tx=0;\n\t\ty=0;\n\t\twhile(x!=w&&y!=h){\n\t\t\tif(d[y][x])x++;\n\t\t\telse y++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",x+1,y+1);\n\t}\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n\nint c[1010][1010],g[1010][1010];\n\nint main(){\n  int H,W,N;\n  int n;\n  n = N-1;\n  while(true){\n    memset(c,0,sizeof(c));\n    memset(g,0,sizeof(g));\n    ///配列初期化\n\n    scanf(\"%d%d%d\",&H,&W,&N);\n    if(H==0 && W==0 && N==0){break;}\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  scanf(\"%d\",&c[i][j]);///初期ステ読み込み\n\t}\n    }\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{    \n\t  if(g[i][j-1]%2==0){\n\t    if(g[i-1][j]%2==0)\n\t      {g[i][j]=g[i-1][j]/2+g[i][j-1]/2;}\n\t    else///\n\t\t{g[i][j]=(g[i-1][j]-1)/2+g[i][j-1]/2;\n\t\t  if(c[i][j-1]==1)\n\t\t    {g[i][j] = g[i][j] +1;}\n\t\t  if(c[i-1][j]==0)\n\t\t    {g[i][j] = g[i][j] +1;}\n\t\t}\n\t  }\n\t  if(g[i][j-1]%2==1){\n\t    if(g[i-1][j]%2==0)\n\t      {g[i][j] = g[i-1][j]/2 + (g[i][j-1]-1)/2;}\n\t    else\n\t      {g[i][j] = (g[i-1][j]-1)/2 + (g[i][j-1]-1)/2;\n\t\tif(c[i-1][j]==0)\n\t\t  {g[i][j] = g[i][j] +1;}\n\t      }\n\t    if(c[i][j-1]==1)\n\t      {g[i][j] = g[i][j] +1;}\n\t  }\n\t  if(i==1&&j==1){g[1][1]=n;}\n\t  ///回数判定fin\n\t}\n    }\n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  c[i][j]=(c[i][j]+g[i][j])%2;\n\t}\n    }///目的のマップ\n    \n    int x,y;\n    x=1;\n    y=1;\n    while(x<=H&&y<=W)      \n      {\n\tif(c[x][y]==1)\n\t  {y=y+1;}\n\telse\n\t  {x=x+1;}\n      }\n    \n    printf(\"%d %d\\n\",x,y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\n#define FOR(i,b,n) for(int i=b;i<n;i++)\n#define RFOR(i,b,n) for(int i=n-1;i>=b;i--)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n\nusing namespace std;\n\nstatic const double EPS = 1e-9;\ntypedef long long ll;\ntypedef pair<int, int> paii;\n\nint h, w, n;\nint ma[2000][2000];\nint dp[2000][2000];\n\npaii solve()\n{\n\tpaii res = paii(0, 0);\n\tCLR(dp);\n\t\n\tdp[0][0] = n-1;\n\t\n\tFOR(j, 0, h)\n\t\tFOR(i, 0, w)\n\t\t{\n\t\t\tif((n-1)%2==0)\n\t\t\t{\n\t\t\t\tdp[j+1][i] += dp[j][i]/2;\n\t\t\t\tdp[j][i+1] += dp[j][i]/2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( ma[j][i] == 1 )\n\t\t\t\t{\n\t\t\t\t\tdp[j+1][i] += (dp[j][i]+1)/2;\n\t\t\t\t\tdp[j][i+1] += (dp[j][i]-1)/2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[j+1][i] += (dp[j][i]-1)/2;\n\t\t\t\t\tdp[j][i+1] += (dp[j][i]+1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\tFOR(j, 0, h)\n\t\tFOR(i, 0, w)\n\t\t{\n\t\t\tif(dp[j][i]%2 != 0)\n\t\t\t\tma[j][i] = ma[j][i] == 0 ? 1 : 0;\n\t\t}\n\n\twhile( res.first >= 0 && res.first < w && res.second >= 0 && res.second < h )\n\t{\t\n\t\tif( ma[res.second][res.first] == 1)//east\n\t\t{\n\t\t\tres.first++;\n\t\t}\n\t\telse//south\n\t\t{\n\t\t\tres.second++;\n\t\t}\n\t}\n\t\n\tres.first++;\n\tres.second++;\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> h >> w >> n, (h||w||n))\n\t{\n\t\tFOR(j, 0, h)\n\t\t\tFOR(i, 0, w)\n\t\t\t{\n\t\t\t\tcin >> ma[j][i];\n\t\t\t}\n\t\t\n\t\tpaii p = solve();\n\t\t\n\t\tcout << p.second << \" \" << p.first << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint times[1001][1001];\nint d[1000][1000];\nint main(){\n\tint a,b,c;\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tif(a==0)return 0;\n\t\tfor(int i=0;i<1001;i++)\n\t\t\tfor(int j=0;j<1001;j++)\n\t\t\t\ttimes[i][j]=0;\n\t\t\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++)\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\n\t\ttimes[0][0]=c-1;\n\t\t\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(times[i][j]%2==0){\n\t\t\t\t\ttimes[i+1][j]+=times[i][j]/2;\n\t\t\t\t\ttimes[i][j+1]+=times[i][j]/2;\n\t\t\t\t}else if(d[i][j]==1){\n\t\t\t\t\ttimes[i+1][j]+=times[i][j]/2;\n\t\t\t\t\ttimes[i][j+1]+=times[i][j]/2+1;\n\t\t\t\t}else{\n\t\t\t\t\ttimes[i+1][j]+=times[i][j]/2+1;\n\t\t\t\t\ttimes[i][j+1]+=times[i][j]/2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tint x=1,y=1;\n\t\twhile(x<b+1&&y<a+1){\n\t\t\tif((times[y-1][x-1]+d[y-1][x-1])%2==0)y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",y,x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\n//constexpr int MAX_N = 1005;\nconstexpr int MAX_H = 1005;\nconstexpr int dx[] = {0, 1};\nconstexpr int dy[] = {1, 0};\n\nint h, w, n, fld[MAX_H][MAX_H], dp[MAX_H][MAX_H];\n\nvoid Sim(int x, int y, int k) {\n    if (fld[x][y] == -1) {\n        cout << y << \" \" << x << endl;\n    }\n\n    Sim(x + dx[fld[x][y]], y + dy[fld[x][y]], k);\n}\n\nbool Solve() {\n    cin >> h >> w >> n;\n    if (!h) return false;\n\n    memset(fld, -1, sizeof(fld));\n\n    for (int y = 1; y <= h; ++y) {\n        for (int x = 1; x <= w; ++x) {\n            cin >> fld[x][y];\n        }\n    }\n\n    dp[1][1] = n - 1;\n    for (int y = 1; y <= h; ++y) {\n        for (int x = (y == 1 ? 2 : 1); x <= w; ++x) {\n            for (int i = 0; i < 2; ++i) {\n                int tx = x - dx[i], ty = y - dy[i];\n                dp[x][y] = dp[tx][ty] / 2 + (dp[tx][ty] % 2 && fld[tx][ty] == i) ? 1 : 0;\n            }\n        }\n    }\n\n    for (int y = 1; y <= h; ++y) {\n        for (int x = 1; x <= w; ++x) {\n            fld[x][y] += dp[x][y];\n            fld[x][y] %= 2;\n        }\n    }\n\n    Sim(1, 1, n);\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tvvi in(n,vi(m)),dp(n+1,vi(m+1));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tdp[0][0]=k-1;\n\trep(i,n)rep(j,m)if(dp[i][j]){\n\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\tif(dp[i][j]%2){\n\t\t\tif(in[i][j])dp[i][j+1]++;\n\t\t\telse dp[i+1][j]++;\n\t\t}\n\t\tif(dp[i][j]%2)in[i][j]^=1;\n\t}\n\tint x=0,y=0;\n\twhile(x!=n&&y!=m){\n\t\tif(in[x][y])y++;\n\t\telse x++;\n\t}\n\tcout<<x+1<<\" \"<<y+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <string.h>\n\nint board[1234][1234];\nint mark[1234][1234];\n\nint main()\n{\n\tfor (;;)\n\t{\n\t\tint h, w, n;\n\t\tscanf(\"%d %d %d\", &h, &w, &n);\n\t\tif (h == 0 && w == 0 && n == 0)break;\n\t\tmemset(board, 255, sizeof(board));\n\t\tfor (int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &board[i][j]);\n\t\t\t}\n\t\t}\n\t\tmemset(mark, 0, sizeof(mark));\n\t\tmark[0][0] = n - 1;\n\t\tfor (int sum = 0; sum < w + h - 1; ++sum)\n\t\t{\n\t\t\tfor (int vr = 0; vr <= sum; ++vr)\n\t\t\t{\n\t\t\t\tif (vr >= h)break;\n\t\t\t\tint hr = sum - vr;\n\t\t\t\tif (hr >= w)continue;\n\t\t\t\tif (hr < 0)break;\n\t\t\t\tif (board[vr][hr] == 0)\n\t\t\t\t{\n\t\t\t\t\tmark[vr][hr + 1] += mark[vr][hr] / 2;\n\t\t\t\t\tmark[vr + 1][hr] += mark[vr][hr] / 2 + (mark[vr][hr] % 2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmark[vr][hr + 1] += mark[vr][hr] / 2 + (mark[vr][hr] % 2);\n\t\t\t\t\tmark[vr + 1][hr] += mark[vr][hr] / 2;\n\t\t\t\t}\n\t\t\t\tif (mark[vr][hr] % 2)\n\t\t\t\t{\n\t\t\t\t\tboard[vr][hr] = (board[vr][hr] == 0) ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint py = 0, px = 0;\n\t\twhile (board[py][px] >= 0)\n\t\t{\n\t\t\tif (board[py][px] == 0)\n\t\t\t{\n\t\t\t\t++py;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++px;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", py + 1, px + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n  \nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint stage[1024][1004];\nint dp[1024][1024];\nint main(){\n    int h,w,n;\n    while(scanf(\"%d%d%d\",&h,&w,&n),(h|w)|n){\n        rep(i,h)rep(j,w)scanf(\"%d\",&stage[i][j]);\n        memset(dp,0,sizeof(dp));\n        dp[0][0] = --n;\n        rep(i,h){\n            rep(j,w){\n                if(dp[i][j] % 2 == 0){\n                    dp[i][j+1] += dp[i][j]/2;\n                    dp[i+1][j] += dp[i][j]/2;\n                 }\n                 else{\n                    if(stage[i][j] == 0){\n                        dp[i+1][j] += dp[i][j]/2 + 1;\n                        dp[i][j+1] += dp[i][j]/2;\n                    }\n                    else if(stage[i][j] == 1){\n                        dp[i+1][j] += dp[i][j]/2;\n                        dp[i][j+1] += dp[i][j]/2 + 1;\n                    }\n                 }\n            }\n        }\n        int x = 0,y = 0;\n        while(x < w && y < h){\n            if(dp[y][x]%2 == 1){\n                if(stage[y][x] == 0){\n                    x++;\n                }\n                else{\n                    y++;\n                }\n            }\n            else{\n                if(stage[y][x] == 0){\n                    y++;\n                }\n                else{\n                    x++;\n                }\n            }\n        }\n        printf(\"%d %d\\n\",++y,++x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\nint data[1010][1010];\nint dp[1010][1010];\n\nint h,w,n;\n\nvoid dfs(int y,int x, int num){\n\tif(num==0)return ;\n\tif(y==h||x==w)return ;\n\tdp[y][x] += num;\n\t\n\tint d=num/2, r=num/2;\n\tif(data[y][x]==0) d+=num%2;\n\tif(data[y][x]==1) r+=num%2;\n\n\tdfs(y+1,x,d);\n\tdfs(y,x+1,r);\n}\n\nvoid move(int y,int x){\n\tif(y==h||x==w) cout<<y+1<<\" \"<<x+1<<endl;\n\n\tif(data[y][x]==0)move(y+1,x);\n\tif(data[y][x]==1)move(y,x+1);\n}\n\nint main(){\n\tcin>>h>>w>>n;\n\t\n\trep(i,1010)rep(j,1010)data[i][j]=-1;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tcin>>data[i][j];\n\t\t}\n\t}\n\t\n\t\n\trep(i,1010)rep(j,1010)dp[i][j]=0;\n\t\n\tdfs(0,0,n-1);\n\t\n\t\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(dp[i][j]%2==1) data[i][j] = !data[i][j];\n\t\t}\n\t}\n\t\n\t\n\tmove(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[1010][1010];\nint grd[1010][1010];\nint main(){\n\twhile(true){\n\tint h,w,n;\tcin>>h>>w>>n;\n\tif(h==0)\treturn 0;\n\tmemset(dp,0,sizeof(dp));\tmemset(grd,0,sizeof(grd));\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)\tcin>>grd[i][j];\n\t}\n\tdp[0][0]=n-1;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(j+1<w){\n\t\t\t\tif(grd[i][j]==1)\tdp[i][j+1]+=(dp[i][j]+1)/2;\n\t\t\t\telse \tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t}\n\t\t\tif(i+1<h){\n\t\t\t\tif(grd[i][j]==1)\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\telse \tdp[i+1][j]+=(dp[i][j]+1)/2;\n\t\t\t}\n\t\t\tdp[i][j]%=2;\n\t\t}\n\t}\n\tint x=0,y=0;\n\twhile(x<w&&y<h){\n\t\tif((grd[y][x]^dp[y][x])==1)\tx++;\n\t\telse \ty++;\n\t}\n\tcout<<y+1<<\" \"<<x+1<<endl;\n\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <bits/stdc++.h>\n#undef DEBUG\nint32_t H,W,N;\nint map[10000][10000];//h,W\nint mapn[10000][10000]={};//h,W\nint main()\n{\n\tfor(;;){\n\t\t\n\tscanf(\"%d%d%d\", &H,&W,&N);\n\tif(H==0&&W==0&&N==0){break;}\n\t//getchar();//\\n????????????\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tscanf(\"%d\", &map[i][j]);//map[i][j] -= '0';getchar();//\\n\\s????????????\n\t}}\n\t\t#ifdef DEBUG\n\t\tprintf(\"\\n----\\n\");\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tputchar(map[i][j] +'0');\n\t}putchar('\\n');}printf(\"----\\n\");\n\t\t#endif\n\t//?????£????????°\n\tmapn[0][0] = N;\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tmapn[i+1][j] += mapn[i][j]>>1;\n\t\tmapn[i][j+1] += mapn[i][j]>>1;\n\t\tif(mapn[i][j]&1){\n\t\t\tif((mapn[i][j]&1) ^ map[i][j]){\n\t\t\t\t++mapn[i+1][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++mapn[i][j+1];\n\t\t\t}\n\t\t}\n\t}}\n\tint32_t npos_x=0,npos_y = 0;\n\twhile(npos_x < W && npos_y < H)\n\t{\n\t\t#ifdef DEBUG\n\t\tprintf(\"----\\n\");\n\t\tprintf(\"%d %d %d\\n\", npos_x,npos_y, now_n);\n\t\tprintf(\"%d %d %d\\n\", (now_n&1), map[npos_y][npos_x], (now_n&1) ^ (map[npos_y][npos_x]));\n\t\tprintf(\"----\\n\");\n\t\t#endif\n\t\tif((mapn[npos_y][npos_x]&1) ^ map[npos_y][npos_x]){\n\t\t\t++npos_y;\n\t\t}\n\t\telse{\n\t\t\t++npos_x;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",npos_y+1, npos_x+1);\n\t\n\t}//for(;;)\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef long long ll;\nll dp[N][N];\nll d[N][N];\nint h,w,n;\n\nint main(){\n  while(1){\n    cin>>h>>w>>n;\n    if(!h&&!w&&!n)break;\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=n-1;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>d[i][j];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tll cnt=dp[i][j],a,b;\n\ta=b=cnt/2;\n\tif(cnt%2){\n\t  if(d[i][j])b++;\n\t  else a++;\n\t}\n\tdp[i+1][j]+=a;\n\tdp[i][j+1]+=b;\n      }\n    }\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\td[i][j]=(d[i][j]+dp[i][j])%2;\n    int y=0,x=0;\n    while(y<h&&x<w){\n      if(d[y][x])x++;\n      else y++;\n    }\n    cout<<y+1<<' '<<x+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\n#define FOR(i,b,n) for(int i=b;i<n;i++)\n#define RFOR(i,b,n) for(int i=n-1;i>=b;i--)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n\nusing namespace std;\n\nstatic const double EPS = 1e-9;\ntypedef long long ll;\ntypedef pair<int, int> paii;\n\nint h, w, n;\nint ma[2000][2000];\nint dp[2000][2000];\n\npaii solve()\n{\n\tpaii res = paii(0, 0);\n\tCLR(dp);\n\t\n\tdp[0][0] = n-1;\n\t\n\tFOR(j, 0, h)\n\t\tFOR(i, 0, w)\n\t\t{\n\t\t\tif(dp[j][i]%2==0)\n\t\t\t{\n\t\t\t\tdp[j+1][i] += dp[j][i]/2;\n\t\t\t\tdp[j][i+1] += dp[j][i]/2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( ma[j][i] == 0 )\n\t\t\t\t{\n\t\t\t\t\tdp[j+1][i] += (dp[j][i]+1)/2;\n\t\t\t\t\tdp[j][i+1] += (dp[j][i]-1)/2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[j+1][i] += (dp[j][i]-1)/2;\n\t\t\t\t\tdp[j][i+1] += (dp[j][i]+1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\tFOR(j, 0, h)\n\t\tFOR(i, 0, w)\n\t\t{\n\t\t\tif(dp[j][i]%2 != 0)\n\t\t\t\tma[j][i] = !ma[j][i];\n\t\t}\n\t\n\twhile( res.first >= 0 && res.first < w && res.second >= 0 && res.second < h )\n\t{\t\n\t\tif( ma[res.second][res.first] == 1)//east\n\t\t{\n\t\t\tres.first++;\n\t\t}\n\t\telse//south\n\t\t{\n\t\t\tres.second++;\n\t\t}\n\t}\n\t\n\tres.first++;\n\tres.second++;\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> h >> w >> n, (h||w||n))\n\t{\n\t\tFOR(j, 0, h)\n\t\t\tFOR(i, 0, w)\n\t\t\t{\n\t\t\t\tcin >> ma[j][i];\n\t\t\t}\n\t\t\n\t\tpaii p = solve();\n\t\t\n\t\tcout << p.second << \" \" << p.first << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[1002][1002];\nlong long int dp[1002][1002];\nlong long int x,y;\nint h,w;\nlong int n;\n\nvoid root(int xx,int yy){\n\tx=xx,y=yy;\n\tdp[xx][yy]+=1;\n\tif(xx<=w && yy<=h){\n\t\tif(map[xx][yy]==1){\n\t\t\tmap[xx][yy]=0;\n\t\t\troot(xx+1,yy);\n\t\t}else{\n\t\t\tmap[xx][yy]=1;\n\t\t\troot(xx,yy+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint a,b,c;\n\twhile(1){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&map[b][a]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tif(dp[b][a]%2==0)dp[b+1][a]=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)dp[b+1][a]=(dp[b][a]+1)/2;\n\t\t\t\t\tif(map[b][a]==0)dp[b+1][a]=(dp[b][a]-1)/2;\n\t\t\t\t}\n\t\t\t\tif(dp[b][a]%2==0)dp[b][a+1]=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)dp[b][a+1]=(dp[b][a]-1)/2;\n\t\t\t\t\tif(map[b][a]==0)dp[b][a+1]=(dp[b][a]+1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tmap[b][a]=(map[b][a]+dp[b][a])%2;\n\t\t\t}\n\t\t}\n\t\troot(1,1);\n\t\tcout << y << \" \" << x << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint h, w, n;\nint a[1010][1010];\nint dp[1010][1010][2];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d %d\", &h, &w, &n);\n\t\tif(h == 0) break;\n\t\tfor(int i=1; i<=h; ++i)\n\t\t\tfor(int j=1; j<=w; ++j)\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[1][1][1-a[1][1]] = (n-1) / 2;\n\t\tdp[1][1][a[1][1]] = n-1 - dp[1][1][1-a[1][1]];\n\t\tfor(int i=2; i<=h; ++i){\n\t\t\tdp[i][1][1-a[i][1]] = dp[i-1][1][0] / 2;\n\t\t\tdp[i][1][a[i][1]] = dp[i-1][1][0] - dp[i][1][1-a[i][1]];\n\t\t}\n\t\tfor(int i=2; i<=w; ++i){\n\t\t\tdp[1][i][1-a[1][i]] = dp[1][i-1][1] / 2;\n\t\t\tdp[1][i][a[i][1]] = dp[1][i-1][1] - dp[1][i][1-a[1][i]];\n\t\t}\n\t\tfor(int i=2; i<=h; ++i){\n\t\t\tfor(int j=2; j<=w; ++j){\n\t\t\t\tint s = dp[i-1][j][0] + dp[i][j-1][1];\n\t\t\t\tdp[i][j][1-a[i][j]] = s / 2;\n\t\t\t\tdp[i][j][a[i][j]] = s - dp[i][j][1-a[i][j]];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=h; ++i){\n\t\t\tfor(int j=1; j<=w; ++j){\n\t\t\t\tint t = (dp[i][j][0] + dp[i][j][1]) % 2;\n\t\t\t\ta[i][j] = (a[i][j] + t) % 2;\n\t\t\t}\n\t\t}\n\t\tint x = 1, y = 1;\n\t\twhile(x <= w && y <= h){\n\t\t\tif(a[y][x] == 0) y++;\n\t\t\telse x++;\n\t\t}\n/*\t\tfor(int i=1; i<=h; ++i){\n\t\t\tfor(int j=1; j<=w; ++j){\n\t\t\t\tprintf(\"%d\\t\", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n*/\t\tprintf(\"%d %d\\n\", y, x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool solve(){\n    int h, w, n;\n    cin >> h >> w >> n;\n    if(h==0) return false;\n    vector<vector<int> > a(h, vector<int>(w)), dp(h+1, vector<int>(w+1));\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin >> a[i][j];\n        }\n    }\n    dp[0][0] = n-1;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(a[i][j]==0){\n                dp[i+1][j] += (dp[i][j]+1)/2;\n                dp[i][j+1] += dp[i][j]/2;\n            }else{\n                dp[i+1][j] += dp[i][j]/2;\n                dp[i][j+1] += (dp[i][j]+1)/2;\n            }\n        }\n    }\n    int ni=0, nj=0;\n    while(ni<h && nj<w){\n        if((a[ni][nj]+dp[ni][nj]%2)%2 == 0) ni++;\n        else nj++;\n    }\n    cout << ni+1 << \" \" << nj+1 << endl;\n    return true;\n}\n\nint main(){\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct POS{\n  int x;\n  int y;\n};\nint main(){\n  queue<POS> check;\n  long long next[201][201],field[201][201],n;\n  bool flag[201][201];\n  int h,w;\n  while(cin >>h>>w>>n,h||w||n){\n    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    next[0][0] = n-1;\n    POS a;\n    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    while(!check.empty()){\n      POS p = check.front();\n      if(next[p.x][p.y]>0 && p.x<w && p.y<h){\n\tif(next[p.x][p.y]%2 == 0){\n\t  next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t  next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t}\n\telse{\n\t  if(field[p.x][p.y] == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t  }\n\t  else{\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t}\n\ta.x = p.x+1;a.y = p.y;\n\tif(!flag[a.x][a.y]){\n\t  check.push(a);\n\t  flag[a.x][a.y] = true;\n\t}\n\ta.x = p.x;a.y = p.y+1;\n\tif(!flag[a.x][a.y]){\n\t  check.push(a);\n\t  flag[a.x][a.y] = true;\n\t}\n      }\n      check.pop();\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n    }\n    int px = 0,py = 0;\n    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n    }\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nint** getarray(int w,int h){\n\tint** a = new int*[w];\n\tfor(int i = 0;i < w;i++){\n\t\ta[i] = new int[h];\n\t}\n\treturn a;\n}\n\nint remarray(int** a,int w,int h){\n\tfor(int i=0;i<w;i++){\n\t\tdelete[] a[i];\n\t}\n\tdelete[] a;\n}\n\nint main(){\n\tint h,w,n;\n\tint self;\n\tint** d;\n\tint** m;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t\tif(!h && !w && !n){break;}\n\t\td = getarray(w + 1,h + 1);\n\t\tm = getarray(w + 1,h + 1);\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tscanf(\"%d\",&self);\n\t\t\t\tm[j][i] = self;\n\t\t\t}\n\t\t}\n\t\t\n\t\td[0][0] = n - 1;\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tif(i == 0 && j == 0){continue;}\n\t\t\t\td[i][j] = 0;\n\t\t\t\tif(i != 0 && d[i-1][j] > 0){\n\t\t\t\t\td[i][j] += (d[i-1][j]) / 2;\n\t\t\t\t\tif(m[i-1][j] == 1){\n\t\t\t\t\t\td[i][j] += (d[i-1][j]) % 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j != 0 && d[i][j - 1] > 0){\n\t\t\t\t\td[i][j] += (d[i][j-1]) / 2;\n\t\t\t\t\tif(m[i][j-1] == 0){\n\t\t\t\t\t\td[i][j] += (d[i][j-1]) % 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tm[i][j] = (m[i][j] + d[i][j]) % 2;\n\t\t\t\t//printf(\"%d \",m[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tint x,y;\n\t\tx = y = 0;\n\t\twhile(x < w && y < h){\n\t\t\tif(m[x][y] == 1){\n\t\t\t\t//printf(\"ツ督圭n\");\n\t\t\t\tx += 1;\n\t\t\t}else{\n\t\t\t\t//printf(\"ツ禿ャ\\n\");\n\t\t\t\ty += 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",x + 1,y + 1);\n\t\tremarray(m,w+1,h+1);\n\t\tremarray(d,w+1,h+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint m[1000][1000];\n\nint main() {\n\n\tint h, w, n;\n\n\twhile(cin >> h >> w >> n) {\n\t\tif(!h&&!w&&!n) {\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tcin >> m[i][j];\n\t\t\t}\n\t\t}\n\t\tint x, y;\n\t\twhile(n) {\n\t\t\tx=0, y=0;\n\t\t\twhile((x!=h)&&(y!=w)) {\n\t\t\t\tif(m[x][y]==1) {\n\t\t\t\t\tm[x][y]=0;\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tm[x][y]=1;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t\tcout << x+1 << \" \" << y+1 << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <bits/stdc++.h>\n#undef DEBUG\nint32_t H,W,N;\nint map[1000][1000];//h,W\nint num[1100][1100]={};//h,W\nint main()\n{\n\tfor(;;){\n\t\t\n\tscanf(\"%d%d%d\", &H,&W,&N);\n\tif(H==0&&W==0&&N==0){break;}\n\t//getchar();//\\n????????????\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tscanf(\"%d\", &map[i][j]);//map[i][j] -= '0';getchar();//\\n\\s????????????\n\t}}\n\t\t#ifdef DEBUG\n\t\tprintf(\"\\n----\\n\");\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tputchar(map[i][j] +'0');\n\t}putchar('\\n');}printf(\"----\\n\");\n\t\t#endif\n\t//?????£????????°\n\tfor(auto& arr:num)for(auto& i:arr){i = 0;}\n\tnum[0][0] = N;\n\tfor(int32_t i = 0;i < H;++i){\n\tfor(int32_t j = 0;j < W;++j){\n\t\tnum[i+1][j] += num[i][j]>>1;\n\t\tnum[i][j+1] += num[i][j]>>1;\n\t\tif(num[i][j]&1){\n\t\t\tif(map[i][j]){\n\t\t\t\t++num[i][j+1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++num[i+1][j];\n\t\t\t}\n\t\t}\n\t}}\n\tint32_t npos_x=0,npos_y = 0;\n\twhile(npos_x < W && npos_y < H)\n\t{\n\t\t#ifdef DEBUG\n\t\tprintf(\"----\\n\");\n\t\tprintf(\"%d %d %d\\n\", npos_x,npos_y, now_n);\n\t\tprintf(\"%d %d %d\\n\", (now_n&1), map[npos_y][npos_x], (now_n&1) ^ (map[npos_y][npos_x]));\n\t\tprintf(\"----\\n\");\n\t\t#endif\n\t\tif((num[npos_y][npos_x]&1) ^ map[npos_y][npos_x]){\n\t\t\t++npos_y;\n\t\t}\n\t\telse{\n\t\t\t++npos_x;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",npos_y+1, npos_x+1);\n\t\n\t}//for(;;)\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n\n#define INF 1010000000\n\nint masu[1001][1001];\nint dp[1001][1001];\n\nint n,m,k;\nint xx,yy;\n\nvoid saiki(int x,int y,int masu[1001][1001]){\n\t//rintf(\"%d %d\\n\",y,x);\n\tif(x>n || y>m){\n\t\txx=x+1;\n\t\tyy=y+1;\n\t\treturn;\n\t}\n\t\n\tif(masu[x][y]==1){\n\t\tsaiki(x+1,y,masu);\n\t}else{\n\t\tsaiki(x,y+1,masu);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tsinttt(n,m,k);\n\t\tif(n==0)break;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tsint(masu[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,1001){\n\t\t\trep(j,1001)dp[i][j]=0;\n\t\t}\n\t\t\n\t\tdp[0][0]=k-1;\n\t\trep(j,n){\n\t\t\trep(i,m){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(masu[i][j]==1){\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(j,n){\n\t\t\trep(i,m){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tmasu[i][j]=!masu[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsaiki(0,0,masu);\n\t\tprintf(\"%d %d\\n\",yy,xx);\n\t\t\n\t\t/*\n\t\tputs(\"\");\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tprintf(\"%d \",dp[j][i]);\n\t\t\t}puts(\"\");\n\t\t}\n\t\tputs(\"\");\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tprintf(\"%d \",masu[j][i]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t}\n}\n/*\n3 4 2\n1 0 1 1\n0 1 0 0\n1 0 1 0\n0 0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[1002][1002];\nlong int dp[1002][1002];\nlong long int x,y;\nint h,w;\nlong int n;\n\nvoid root(int xx,int yy){\n\tx=xx,y=yy;\n\tdp[xx][yy]+=1;\n\tif(xx<=w && yy<=h){\n\t\tif(map[xx][yy]==1){\n\t\t\tmap[xx][yy]=0;\n\t\t\troot(xx+1,yy);\n\t\t}else{\n\t\t\tmap[xx][yy]=1;\n\t\t\troot(xx,yy+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint a,b,c;\n\twhile(1){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&map[b][a]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tint d,e;\n\t\t\t\tif(dp[b][a]%2==0)dp[b+1][a]=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)d=(dp[b+1][a]+1)/2;\n\t\t\t\t\tif(map[b][a]==0)d=(dp[b+1][a]-1)/2;\n\t\t\t\t}\n\t\t\t\tif(dp[b][a]%2==0)e=dp[b][a+1]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)e=(dp[b][a+1]-1)/2;\n\t\t\t\t\tif(map[b][a]==0)e=(dp[b][a+1]+1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tmap[b][a]=(map[b][a]+dp[b][a])%2;\n\t\t\t}\n\t\t}\n\t\troot(1,1);\n\t\tcout << y << \" \" << x << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ntypedef long long ll;\n\nint a[1010][1010];\nint dp[1010][1010];\n\nint main(void){\n\n\tint H,W,N;\n\tcin >> H >> W >> N;\n\tint i,j;\n\tfor(i=1;i<=H;i++) for(j=1;j<=W;j++) cin >> a[i][j];\n\tdp[1][1]=N-1;\n\tfor(i=1;i<=H;i++) for(j=1;j<=W;j++){\n\t\tif(i!=1 || j!=1){\n\t\tif(dp[i-1][j]%2==1 && a[i-1][j]==0) dp[i][j]+=(dp[i-1][j]+1)/2;\n\t\tif(dp[i-1][j]%2==1 && a[i-1][j]==1) dp[i][j]+=(dp[i-1][j]-1)/2;\n\t\tif(dp[i-1][j]%2==0) dp[i][j]+=dp[i-1][j]/2;\n\t\tif(dp[i][j-1]%2==1 && a[i][j-1]==0) dp[i][j]+=(dp[i][j-1]-1)/2;\n\t\tif(dp[i][j-1]%2==1 && a[i][j-1]==1) dp[i][j]+=(dp[i][j-1]+1)/2;\n\t\tif(dp[i][j-1]%2==0) dp[i][j]+=dp[i][j-1]/2;\n\t\t}\n\t}\n\n\tint x=1,y=1;\n\twhile(x<=H && y<=W){\n\t\tif(dp[x][y]%2==0 && a[x][y]==0) x++;\n\t\telse if(dp[x][y]%2==0 && a[x][y]==1) y++;\n\t\telse if(dp[x][y]%2==1 && a[x][y]==0) y++;\n\t\telse if(dp[x][y]%2==1 && a[x][y]==1) x++;\n\t}\n\n\tcout << x << \" \" << y << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint H,W,N;\nint fld[1005][1005];\nint dp[1005][1005];\n\nsigned main(){\n    while(1){\n        cin>>H>>W>>N;\n        if(H==0&&W==0&&N==0)break;\n        N--;\n        dp[0][0]=N;\n        for(int i=0;i<H;++i)\n            for(int j=0;j<W;++j)cin>>fld[i][j];\n\n        for(int i=0;i<H;++i){\n            for(int j=0;j<W;++j){\n                int a=dp[i][j]/2;\n                int b=dp[i][j]-a;\n                if(fld[i][j]==1){\n                    dp[i+1][j]+=a;\n                    dp[i][j+1]+=b;\n                }\n                else{\n                    dp[i+1][j]+=b;\n                    dp[i][j+1]+=a;\n                }\n            }\n        }\n        int x=1,y=1;\n        while(1){\n            if(x>W||y>H)break;\n            if(dp[y-1][x-1]%2==0){\n                if(fld[y-1][x-1]==0)y++;\n                else x++;\n            }\n            else {\n                if(fld[y-1][x-1]==0)x++;\n                else y++;\n            }\n        }\n        cout<<y<<\" \"<<x<<endl;\n        memset(dp,0,sizeof(dp));\n        memset(fld,0,sizeof(fld));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n\tint **a, h, w, n, x, y;\n\t\n\twhile(1){\n\t\tcin >> h >> w >> n;\n\t\tif(h  == 0){\n\t\t\tbreak;\n\t\t}\n\t\ta = (int **)calloc((h+1), sizeof(int));\n\t\ta[0] = (int *)calloc((w+1), sizeof(int));\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\ta[i] = (int *)calloc((w+1), sizeof(int));\n\t\t\tfor(int j = 1, tmp = 0; j <= w; j++){\n\t\t\t\tcin >> tmp;\n\t\t\t\ta[i][j] = tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx = y = 1;\n\t\t\twhile(x <= w && y <= h){\n\t\t\t\tif(a[y][x] == 0){\n\t\t\t\t\ta[y][x] = 1;\n\t\t\t\t\ty++;\n\t\t\t\t} else {\n\t\t\t\t\ta[y][x] = 0;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << y << \" \" << x << endl;\n\t\t\n\t\tfor(int i = 0; i <= h; i++){\n\t\t\tfree(a);\n\t\t}\n\t\tfree(a);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint mp[1001][1001],dp[1001][1001];;\nint h,w,n;\n\nvoid saiki(int x,int y){\n  int dx[]={0,1},dy[]={1,0};\n  if(y==h||x==w)cout << y+1<<\" \"<<x+1<<endl;\n  else  saiki(x+dx[mp[y][x]],y+dy[mp[y][x]]);\n}\n\nint main(){\n  while(1){\n    cin>>h>>w>>n;\n    if(!h&&!w&&!n)break;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>mp[i][j];\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=n-1;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tdp[i][j+1]+=dp[i][j]/2+mp[i][j]*dp[i][j]%2;\n\tdp[i+1][j]+=dp[i][j]/2+!mp[i][j]*dp[i][j]%2;\n\tif(dp[i][j]%2)mp[i][j]=!mp[i][j];\n      }\n\n    saiki(0,0);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define rep(i,j) for(int i=0;i<j;i++)\nint d[1024][1024];\nint main(){\n    int h,w,n,m;\n    for(;;){\n        scanf(\"%d%d%d\",&h,&w,&n);\n        if(!h)break;\n        memset(d,0,sizeof(d));\n        d[0][0]=--n;\n        rep(i,h)rep(j,w){\n            scanf(\"%d\",&m);\n            d[i][j+1] += (d[i][j]+(1&m))>>1;\n            d[i+1][j] += (d[i][j]+(1&~m))>>1;\n            d[i][j] = (d[i][j]+m)&1;\n        }\n        int x=0,y=0;\n        while(x!=w && y!=h){\n            int t=d[y][x];\n            x+=t;\n            y+=1-t;\n        }\n        printf(\"%d %d\\n\",y+1,x+1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int *x) { int k, m = 0; *x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { *x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; *x = (*x) * 10 + k - '0'; }if (m)(*x) = -(*x); }\nvoid reader(int *x, int *y) { reader(x); reader(y); }\nvoid reader(int *x, int *y, int *z) { reader(x); reader(y); reader(z); }\nvoid writer(int x, char c) { int i, sz = 0, m = 0; char buf[10]; if (x<0)m = 1, x = -x; while (x)buf[sz++] = x % 10, x /= 10; if (!sz)buf[sz++] = 0; if (m)mypc('-'); while (sz--)mypc(buf[sz] + '0'); mypc(c); }\n\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (reader(&h, &w, &n), h) {\n\t\trep(i, h)rep(j, w)reader(&a[i][j]);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] / 2;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) / 2;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) / 2;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] / 2;\n\t\t\t}\n\t\t}\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (dp[i][j] & 1)a[i][j] = !a[i][j];\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (a[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\twriter(x + 1, ' '); writer(y + 1, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\nusing namespace std;\nint h,w,n,i,j,k,l;\nint kan[10000][10000];\nint dp[10000][10000];\nint main(void){\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=1001;i++){\n\t\t\tfor(j=1;j<=1001;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&kan[i][j]);\t//kan=kanbann\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(kan[i][j]==1){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tdp[i][j+1]=dp[i][j+1]+dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i+1][j]+=(dp[i][j]/2);\n\t\t\t\t\t}\n\t\t\t\t\telse if(dp[i][j]%2==0){\n\t\t\t\t\t\t/*if(i==2 && j==2){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",dp[i][j],dp[i+1][j]);\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(kan[i][j]==0){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tdp[i][j+1]+=(dp[i][j]/2);\n\t\t\t\t\t\tdp[i+1][j]=dp[i+1][j]+(dp[i][j]/2)+1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(dp[i][j]%2==0){\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(l=1;l<=h;l++){\n\t\t\t\tfor(k=1;k<=w;k++){\n\t\t\t\t\tprintf(\"%d \",dp[l][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]!=0){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tif(kan[i][j]==0){\n\t\t\t\t\t\t\tkan[i][j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(kan[i][j]==1){\n\t\t\t\t\t\t\tkan[i][j]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti=1;\n\t\tj=1;\n\t\twhile(1){\n\t\t\tif(kan[i][j]==1){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(kan[i][j]==0){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(i==h+1 || j==w+1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",i,j);\t\n\t\t/*for(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\t\t\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tscanf(\"%d &d %d\\n\",&h,&w,&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n#define int long long\n//using LL = long long;\n//using P = pair < int, int > ;\n//using PI = pair < P, int > ;\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nsigned main()\n{\n\tint h, w;\n\twhile (cin >> h >> w && h)\n\t{\n\t\tint n; cin >> n;\n\t\tauto stage = vvector<int>(h, w);\n\t\trep(i, h)rep(j, w) cin >> stage[i][j];\n\t\tauto dp = vvector(h + 1, w + 1);\n\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)\n\t\t{\n\t\t\trep(j, w)\n\t\t\t{\n\t\t\t\tbool rem = dp[i][j] % 2;\n\t\t\t\tdp[i][j + 1] += dp[i][j] / 2 + (rem ? stage[i][j] : 0);\n\t\t\t\tdp[i + 1][j] += dp[i][j] / 2 + (rem ? !stage[i][j] : 0);\n\t\t\t}\n\t\t}\n\n\t\trep(i, h) rep(j, w) stage[i][j] = (stage[i][j] + dp[i][j]) % 2;\n\t\tP now = P(0, 0);\n\t\twhile (now.first != h && now.second != w)\n\t\t{\n\t\t\tif (stage[now.first][now.second]) now.second++;\n\t\t\telse now.first++;\n\t\t}\n\t\tcout << now.first + 1 << \" \" << now.second + 1 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\nint maze[1010][1010], dp[1010][1010], h, w, n;\n\nint main() {\n\twhile (cin >> h >> w >> n && (h || w || n)) {\n\t\tfor (int i = 1; i <= h; i++)for (int j = 1; j <= w; j++) {\n\t\t\tcin >> maze[i][j];\n\t\t}\n\t\tfor (int i = 0; i < 1010; i++)for (int j = 0; j < 1010; j++) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t\tn--, dp[1][1] = n;\n\n\t\tfor (int i = 1; i <= h; i++) for (int j = 1; j <= w; j++) {\n\t\t\tdp[i][j] += dp[i][j - 1] / 2;\n\t\t\tif (maze[i][j - 1] == 1)dp[i][j] += dp[i][j - 1] % 2;\n\t\t\tdp[i][j] += dp[i - 1][j] / 2;\n\t\t\tif (maze[i - 1][j] == 0)dp[i][j] += dp[i - 1][j] % 2;\n\t\t}\n\n\t\tint y = 1, x = 1, t, f;\n\t\twhile (y <= h && x <= w) {\n\t\t\tf = maze[y][x];\n\t\t\tif (dp[y][x] % 2)f = !f;\n\t\t\tif (f == 0)y++;\n\t\t\telse x++;\n\t\t}\n\n\t\tcout << y << \" \" << x << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a[1000][1000];\nint main()\n{\n\tint h, w, n, x, y, i, j;\n\twhile (cin >> h >> w >> n)\n\t{\n\t\tif (!h && !w && !n) break;\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tcin >> a[i][j];\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (x = y = 0; (x < w && y < h);)\n\t\t\t{\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\ta[y][x] = 1, y++;\n\t\t\t\telse if (a[y][x] == 1)\n\t\t\t\t\ta[y][x] = 0, x++;\n\t\t\t}\n\t\t}\n\t\tcout << y+1 << \" \" << x+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<stack>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nint main(){\n\twhile(1){\n\t\tint dp[103][103];\n\t\tint n,m,k;\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0)break;\n\t\tint masu[103][103];\n\t\trep(i,103)rep(j,103)masu[i][j]=dp[i][j]=0;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tscanf(\"%d\",&masu[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[0][0]=k-1;\n\t\t\n\t\trep(i,m){\n\t\t\trep(j,n){\n\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(masu[i][j]==0){\n\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmasu[i][j]+=dp[i][j];\n\t\t\t\tmasu[i][j]%=2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x=0,y=0;\n\t\twhile(1){\n\t\t\tif(masu[x][y]==0){\n\t\t\t\ty++;\n\t\t\t}else{\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(y>=n || x>=m){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n}\n\n/*\n3 4 3\n1 0 1 1\n0 1 0 0\n1 0 1 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\ntypedef struct\n{\n\tint x;\n\tint y;\n} pos;\n\nint N,H,W,M[100][100],C[101][101];\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> H >> W >> N;\n\t\tif(H == 0 && W == 0 && N == 0)\n\t\t\texit(0);\n\t\tmemset(M,0,sizeof(int[100][100]));\n\t\tmemset(C,0,sizeof(int[101][101]));\n\t\tfor(int y = 0;y < H;y++)\n\t\t{\n\t\t\tfor(int x = 0;x < W;x++)\n\t\t\t{\n\t\t\t\tcin >> M[x][y];\n\t\t\t}\n\t\t}\n\t\tC[0][0] = N-1;\n\t\tfor(int y = 0;y < H;y++)\n\t\t{\n\t\t\tfor(int x = 0;x < W;x++)\n\t\t\t{\n\t\t\t\tC[x][y+1] += C[x][y] / 2;\n\t\t\t\tC[x+1][y] += C[x][y] / 2;\n\t\t\t\tif(C[x][y] % 2 == 1)\n\t\t\t\t{\n\t\t\t\t\tif(M[x][y] == 0)\n\t\t\t\t\t\tC[x][y+1]++;\n\t\t\t\t\telse\n\t\t\t\t\t\tC[x+1][y]++;\n\t\t\t\t\tM[x][y] = (M[x][y] + 1) % 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpos cp;\n\t\tcp.x = 0;\n\t\tcp.y = 0;\n\t\twhile(cp.x != W && cp.y != H)\n\t\t{\n\t\t\tif(M[cp.x][cp.y] == 0)\n\t\t\t\tcp.y++;\n\t\t\telse\n\t\t\t\tcp.x++;\n\t\t}\n\t\tcout << cp.y+1 << \" \" << cp.x+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\nusing namespace std;\nint h,w,n,i,j,k,l;\nint kan[1201][1201];\nint dp[1201][1201];\nint main(void){\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=1200;i++){\n\t\t\tfor(j=1;j<=1200;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t\tkan[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&kan[i][j]);\t//kan=kanbann\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(kan[i][j]==1){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tdp[i][j+1]=dp[i][j+1]+dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i+1][j]+=(dp[i][j]/2);\n\t\t\t\t\t}\n\t\t\t\t\telse if(dp[i][j]%2==0){\n\t\t\t\t\t\t/*if(i==2 && j==2){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",dp[i][j],dp[i+1][j]);\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(kan[i][j]==0){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tdp[i][j+1]+=(dp[i][j]/2);\n\t\t\t\t\t\tdp[i+1][j]=dp[i+1][j]+(dp[i][j]/2)+1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(dp[i][j]%2==0){\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(l=1;l<=h;l++){\n\t\t\t\tfor(k=1;k<=w;k++){\n\t\t\t\t\tprintf(\"%d \",dp[l][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}*/\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]!=0){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tif(kan[i][j]==0){\n\t\t\t\t\t\t\tkan[i][j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(kan[i][j]==1){\n\t\t\t\t\t\t\tkan[i][j]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti=1;\n\t\tj=1;\n\t\twhile(1){\n\t\t\tif(kan[i][j]==1){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(kan[i][j]==0){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(i==h+1 || j==w+1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",i,j);\t\n\t\t/*for(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\t\t\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int dy[2]={1,0},dx[2]={0,1};\nint H,W,stage[1000][1000],ansy,ansx;\nint dp[1000][1000];\n\nvoid solve(int y,int x){\n\tif(y>=H || x>=W){\n\t\tansy = y+1; ansx = x+1;\n\t\treturn;\n\t}\n\tint ny,nx;\n\tsolve(y+dy[(stage[y][x]+dp[y][x])%2],x+dx[(stage[y][x]+dp[y][x])%2]);\n}\n\nint main(){\n\tint N;\n\twhile(cin>>H>>W>>N,H||W||N){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>stage[i][j];\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = N-1;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tdp[i+dy[stage[i][j]]][j+dx[stage[i][j]]] += (dp[i][j]+1)/2;\n\t\t\t\tdp[i+dy[(stage[i][j]+1)%2]][j+dx[(stage[i][j]+1)%2]] += dp[i][j]/2;\n\t\t\t}\n\t\t}\n\t\tsolve(0,0);\n\t\tprintf(\"%d %d\\n\",ansy,ansx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dp[1001][1001];\nint map[1001][1001];\nint main(void)\n{\n\tint h,w,n;\n\tint a,b;\n\tint i,j;\n\t\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==0){\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta=b=1;\n\t\twhile(a<=h && b<=w){\n\t\t\tif(map[a][b]==0){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",a,b);\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    while(true){\n\tint h,w,n;\n\tint way[1001][1001];\n\tint dp[1001][1001];\n\tmemset(dp,0,sizeof(dp));\n\tcin >> h >> w >> n;\n\tif(h == 0 && w == 0 && n == 0) break;\n\tREP(i,h)REP(j,w) {\n\t    cin >> way[i+1][j+1];\n\t}\n\tdp[1][1] = n-1;\n\tREP(i,h)REP(j,w){\n\t    if(i == 0 && j == 0) continue;\n\t    int u = 0;\n\t    int l = 0;\n\t    if(i > 0){\n\t\tif(dp[i][j+1]%2 == 0) u = dp[i][j+1]/2;\n\t\telse if(way[i][j+1] == 0) u = 1 + dp[i][j+1]/2;\n\t    }\n\t    if(j > 0){\n\t\tif(dp[i+1][j]%2 == 0) l = dp[i+1][j]/2;\n\t\telse if(way[i+1][j] == 1) l = 1 + dp[i+1][j]/2;\n\t    }\n\t    dp[i+1][j+1] = u + l;\n\t}\n\tint x = 1;\n\tint y = 1;\n\twhile(x <= w && y <= h){\n\t    if( (way[y][x] + dp[y][x])%2 == 1){\n\t\tx++;\n\t    }else y++;\n\t}\n\tprintf(\"%d %d\\n\",y,x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n#define MAX 1024\n#define fr first\n#define sc second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<int,int> pi;\n\nvoid MakeCountMap(int h, int w, int M[][MAX],int cnt[][MAX]){\n  queue<pi> qp;\n  bool vis[MAX][MAX]={{false,},};\n  qp.push( mp(0,0) );\n  while(!qp.empty()){\n    pi now=qp.front();\n    qp.pop();\n    if(now.fr==h||now.sc==w)continue;\n    int flr=cnt[now.fr][now.sc]/2;\n    int cel=cnt[now.fr][now.sc]%2==0?flr:flr+1;\n    cnt[now.fr+1][now.sc]+=M[now.fr][now.sc]==1?flr:cel;\n    cnt[now.fr][now.sc+1]+=M[now.fr][now.sc]==1?cel:flr;\n    if(!vis[now.fr+1][now.sc]){\n      vis[now.fr+1][now.sc]=true;\n      qp.push(mp(now.fr+1,now.sc));\n    }\n    if(!vis[now.fr][now.sc+1]){\n      vis[now.fr][now.sc+1]=true;\n      qp.push(mp(now.fr,now.sc+1));\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    static int M[MAX][MAX];\n    static int cnt[MAX][MAX];\n    int h,w,n;\n    cin >> h >> w >> n;\n    \n    if( h == 0 && w == 0 && n == 0 ) break;\n    \n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n\tcnt[i][j] = 0;\n      }\n    }\n    cnt[0][0] = n-1;\n\n    MakeCountMap(h,w,M,cnt);\n\n    int nowi=0;\n    int nowj=0;\n    while(nowi<h&&nowj<w){\n      if(!(M[nowi][nowj]&(1&cnt[nowi][nowj]))){\n\tnowj++;\n      }else{\n\tnowi++;\n      }\n    }\n    cout<<1+nowi<<' '<<1+nowj<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#include <cstdlib>\n\n#include <cmath>\n\n#include <climits>\n\n#include <cfloat>\n\n#include <map>\n\n#include <utility>\n\n#include <set>\n\n#include <iostream>\n\n#include <memory>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <functional>\n\n#include <sstream>\n\n#include <complex>\n\n#include <stack>\n\n#include <queue>\n\n#include <numeric>\n\n#include <cstring>\n\n\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\n#define pb push_back\n\n\n\nusing namespace std;\n\n\n\ntypedef long long ll;\n\ntypedef pair<int, int> P;\n\ntypedef vector<int> vi;\n\ntypedef vector<vi> vvi;\n\n\n\nconst int INF = 1 << 29;\n\nconst double EPS = 1e-9;\n\n\n\nint main(){\n\n\tint N, H, W;\n\n\tvvi field;\n\n\tint mx, my;\n\n\n\n\twhile(1){\n\n\t\tcin >> H >> W >> N;\n\n\t\tif(H == 0 && W == 0 && N == 0) break;\n\n\n\n\t\tfield.resize(H);\n\n\t\trep(i, H){\n\n\t\t\tfield[i].resize(W);\n\n\t\t\trep(j, W){\n\n\t\t\t\tcin >> field[i][j];\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\trep(i, N){\n\n\t\t\tmx = 0, my = 0;\n\n\t\t\twhile(my < H && mx < W){\n\n\t\t\t\tif(field[my][mx] == 0){\n\n\t\t\t\t\tfield[my][mx] = 1;\n\n\t\t\t\t\tmy += 1;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tfield[my][mx] = 0;\n\n\t\t\t\t\tmx += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmy++, mx++;\n\n\t\tcout << my << \" \" << mx << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint w,h,n;\nint num[1005][1005];\nint dp[1005][1005]={};\nint main(){\n\twhile(1){\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\tif(h+w+n==0) break;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tscanf(\"%d\",&num[i][j]);\n\t\t}\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tdp[1][1]=n-1;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tif(i!=1){\n\t\t\t\tif(dp[i-1][j]%2==0){\n\t\t\t\t\tdp[i][j]+=dp[i-1][j]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(num[i-1][j]==0){\n\t\t\t\t\t\tdp[i][j]+=(dp[i-1][j]+1)/2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j]+=(dp[i-1][j]-1)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j!=1){\n\t\t\t\tif(dp[i][j-1]%2==0){\n\t\t\t\t\tdp[i][j]+=dp[i][j-1]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(num[i][j-1]==1){\n\t\t\t\t\t\tdp[i][j]+=(dp[i][j-1]+1)/2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j]+=(dp[i][j-1]-1)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint i=1,j=1;\n\twhile(i!=h+1 && j!=w+1){\n\t\tif(dp[i][j]%2==1){\n\t\t\tif(num[i][j]==0){\n\t\t\t\tj++;\n\t\t\t}else{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}else{\n\t\t\tif(num[i][j]==0){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\t\tprintf(\"%d %d\\n\",i,j);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int N, W, H;\n  while(cin>>H>>W>>N, N){\n    int dp[1001][1001] = {};\n    int grid[1001][1001];\n    REP(y,H)REP(x,W)cin>>grid[y][x];\n    dp[0][0] = N - 1;\n    REP(y,H)REP(x,W){\n      dp[y+1][x] = dp[y][x]/2;\n      dp[y][x+1] = dp[y][x]/2;\n      if(dp[y][x] % 2 == 1){\n        if(grid[y][x] == 0){\n          dp[y+1][x] += 1;\n        }else{\n          dp[y][x+1] += 1;\n        }\n      }\n    }\n    REP(y,H)REP(x,W){\n      grid[y][x] = (grid[y][x] + dp[y][x]) % 2;\n    }\n    int nx = 0, ny = 0;\n    while(nx < W && ny < H){\n      if(grid[ny][nx] == 0) ny ++;\n      else nx ++;\n    }\n    printf(\"%d %d\\n\",ny + 1, nx + 1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j;\n  int a[1000][1000],b[1001][1001],h,w,n,x,y;\n  while(cin>>h>>w>>n&&h+w+n){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++)\n\tcin>>a[j][i];\n    memset(b,0,sizeof(b));\n    b[0][0]=n;\n    for(i=1;i<w+h;i++){\n      x=i-1;\n      y=0;\n      for(j=0;j<i;j++){\n\tif(x<w&&y<h){\n\t  if(b[x][y]%2){\n\t    if(a[x][y]){\n\t      a[x][y]=0;\n\t      b[x+1][y]+=b[x][y]/2+1;\n\t      b[x][y+1]+=b[x][y]/2;\n\t    }else{\n\t      a[x][y]=1;\n\t      b[x+1][y]+=b[x][y]/2;\n\t      b[x][y+1]+=b[x][y]/2+1;\n\t    }\n\t  }else{\n\t    b[x+1][y]+=b[x][y]/2;\n\t    b[x][y+1]+=b[x][y]/2;\n\t  }\n\t}\n\tx--;\n\ty++;\n      }\n    }\n    for(x=y=0;x!=w&&y!=h;){\n      if(a[x][y])\n\ty++;\n      else\n\tx++;\n    }\n    cout<<y+1<<\" \"<<x+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define int ll\n#define INF 999999999\n//#define INF (1LL<<59)\n\nint data[1010][1010];\nint dp[1010][1010];\n\nint h,w,n;\n\nvoid move(int y,int x){\n\tif(y==h||x==w) cout<<y+1<<\" \"<<x+1<<endl;\n\t\n\tif(data[y][x]==0)move(y+1,x);\n\tif(data[y][x]==1)move(y,x+1);\n}\n\n\nsigned main(){\n\twhile(cin>>h>>w>>n&&(h||w||n)){\n\t\t\n\t\trep(i,1010)rep(j,1010)data[i][j]=-1;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin>>data[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\trep(i,1010)rep(j,1010)dp[i][j]=0;\n\t\tdp[0][0] = n-1;\n\t\t\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tint d=dp[i][j]/2, r=dp[i][j]/2;\n\t\t\t\tif(data[i][j]==0) d+=dp[i][j]%2;\n\t\t\t\tif(data[i][j]==1) r+=dp[i][j]%2;\n\n\t\t\t\tdp[i+1][j] += d;\n\t\t\t\tdp[i][j+1] += r;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(dp[i][j]%2==1) data[i][j] = !data[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tmove(0,0);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<functional>\n\n\nusing namespace std;\n\nint h,w,n;\nint dp[1005][1005];\nint fie[1005][1005];\nint main(void){\n\twhile(1){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(fie,0,sizeof(fie));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0)break;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++)scanf(\"%d\",&fie[j][i]);\n\t\t}\n\t\tdp[0][0]=n-1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(dp[j][i]%2==0){\n\t\t\t\t\tdp[j+1][i]+=dp[j][i]/2;\n\t\t\t\t\tdp[j][i+1]+=dp[j][i]/2;\n\t\t\t\t}else{\n\t\t\t\t\tif(fie[j][i]==1){\n\t\t\t\t\t\tdp[j+1][i]+=(dp[j][i]+1)/2;\n\t\t\t\t\t\tdp[j][i+1]+=dp[j][i]/2;\n\t\t\t\t\t}\n\t\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\t\tdp[j+1][i]+=dp[j][i]/2;\n\t\t\t\t\t\tdp[j][i+1]+=(dp[j][i]+1)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x=0,y=0;\n\t\twhile(x<w && y<h){\n\t\t\tif((fie[x][y]+dp[x][y])%2==0)y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#pragma warning(disable : 4996)\nint H, W, T, a[1009][1009];\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &T), T--, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t}\n\t\t}\n\t\tint cx = 0, cy = 0;\n\t\twhile (cx < H && cy < W) {\n\t\t\tif ((T ^ a[cx][cy]) & 1) cy++;\n\t\t\telse cx++;\n\t\t\tT >>= 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", cx + 1, cy + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    while(true){\n\tint h,w,n;\n\tint way[1001][1001];\n\tint dp[1001][1001];\n\tmemset(dp,0,sizeof(dp));\n\tcin >> h >> w >> n;\n\tif(h == 0 && w == 0 && n == 0) break;\n\tREP(i,h)REP(j,w) {\n\t    cin >> way[i+1][j+1];\n\t}\n\tdp[1][1] = n-1;\n\tREP(i,h)REP(j,w){\n\t    if(i == 0 && j == 0) continue;\n\t    int u = 0;\n\t    int l = 0;\n\t    if(i > 0){\n\t\tif(dp[i][j+1]%2 == 0) u = dp[i][j+1]/2;\n\t\telse if(way[i][j+1] == 0) u = 1 + dp[i][j+1]/2;\n\t    }\n\t    if(j > 0){\n\t\tif(dp[i+1][j]%2 == 0) l = dp[i+1][j]/2;\n\t\telse if(way[i+1][j] == 1) l = 1 + dp[i+1][j]/2;\n\t    }\n\t    dp[i+1][j+1] = u + l;\n\t}\n\tint x = 1;\n\tint y = 1;\n\twhile(x <= w && y <= h){\n\t    if( (way[y][x] + dp[y][x])%2 == 1){\n\t\tx++;\n\t    }else y++;\n\t}\n\tprintf(\"%d %d\\n\",y,x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nint dp[1010][1010], map[1010][1010];\n\nstruct P{\n    int x, y;\n};\n\nint H, W, N;\n\nP walk(int x, int y){\n    if(x > W || y > H){\n        return {x, y};\n    }\n\n    if(map[y][x] == 1){// east\n        return walk(x+1, y);\n    }\n    return walk(x, y+1);\n}\n\nint main(){\n    while(std::cin >> H >> W >> N, H){\n        FOR(i, 1, H+1){\n            FOR(j, 1, W+1){\n                std::cin >> map[i][j];\n            }\n        }\n\n        FOR(i, 0, 1010){\n            FOR(j, 0, 1010){\n                dp[i][j] = 0;\n            }\n        }\n\n        dp[1][1] = N-1;\n\n        FOR(i, 1, H+1){\n            FOR(j, 1, W+1){\n                if(dp[i][j] % 2 == 0){\n                    dp[i+1][j] += dp[i][j] / 2;\n                    dp[i][j+1] += dp[i][j] / 2;\n                }else{\n                    if(map[i][j] == 1){// EAST\n                        dp[i][j+1] += (dp[i][j] + 1) / 2;\n                        dp[i+1][j] += (dp[i][j] - 1) / 2;\n                    }else{// NORTH\n                        dp[i+1][j] += (dp[i][j] + 1) / 2;\n                        dp[i][j+1] += (dp[i][j] - 1) / 2;\n                    }\n                }\n            }\n        }\n\n        // FOR(i, 1, 11){\n        //     FOR(j, 1, 11){\n        //         std::cout << dp[i][j] << \" \";\n        //     }\n        //     std::cout << std::endl;\n        // }\n\n        FOR(i, 1, H+1){\n            FOR(j, 1, W+1){\n                if(dp[i][j] % 2 == 1){\n                    map[i][j] = !map[i][j];\n                }\n            }\n        }\n\n        auto p = walk(1, 1);\n        std::cout << p.y << \" \" << p.x << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint grid[1005][1005];\nint dp[1005][1005];\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.walk\", \"r\", stdin );\n\tint h, w, n;\n\twhile (scanf (\"%d %d %d\", &h, &w, &n ), h, w, n ){\n\t\tmemset (grid, 0, sizeof (grid ) );\n\t\trep (i, h ){\n\t\t\trep (j, w ){\n\t\t\t\tscanf (\"%d\", &grid[i][j] );// 1 : 東 0 : 南\n\t\t\t} // end rep\n\t\t} // end rep\n\n\t\tmemset (dp, 0, sizeof (dp ) );\n\t\tdp[0][0] = n - 1;\n\t\tfor (int i = 1; i < h; i++ ){\n\t\t\tint k = dp[i-1][0];\n\t\t\tdp[i][0] = (k % 2 == 0 ? k/2 : (!grid[i-1][0] ? (k+1)/2 : (k-1)/2 ) );\n\t\t} // end for\n\t\tfor (int j = 1; j < w; j++ ){\n\t\t\tint m = dp[0][j-1];\n\t\t\tdp[0][j] = (m % 2 == 0 ? m/2 : ( grid[0][j-1] ? (m+1)/2 : (m-1)/2 ) );\n\t\t} // end for\n\t\tfor (int i = 1; i < h; i++ ){\n\t\t\tfor (int j = 1; j < w; j++ ){\n\t\t\t\tint k = dp[i-1][j], m = dp[i][j-1];\n\t\t\t\tdp[i][j] += (k % 2 == 0 ? k/2 : (!grid[i-1][j] ? (k+1)/2 : (k-1)/2 ) );\t\n\t\t\t\tdp[i][j] += (m % 2 == 0 ? m/2 : ( grid[i][j-1] ? (m+1)/2 : (m-1)/2 ) );\n\t\t\t} // end for\n\t\t} // end for\n\n\t\tint row = 0, col = 0;\n\t\twhile (row < h && col < w ){\n\t\t\tif ((dp[row][col] + grid[row][col] ) % 2 == 0 ){\n\t\t\t\trow++;\n\t\t\t}else{\n\t\t\t\tcol++;\n\t\t\t} // end if\n\t\t} // end while \n \n\t\tprintf (\"%d %d\\n\", row+1, col+1 );\t\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint w,h,n;\n\t\n\twhile(cin >> h >> w >> n){\n\t\tif(!(w|h|n)) break;\n\t\t\n\t\tbool dir[h][w];\n\t\tint dp[h+1][w+1],t;\n\t\tfill((int *)dp, (int *) dp + (h+1) * (w+1), 0);\n\t\tdp[0][0] = n-1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> t;\n\t\t\t\tif(t == 1){\n\t\t\t\t\tdir[i][j] = true;\n\t\t\t\t}else{\n\t\t\t\t\tdir[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(dp[i][j] % 2 == 0){\n\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2; \n\t\t\t\t}else{\n\t\t\t\t\tif(dir[i][j]){ //east\n\t\t\t\t\t\tdir[i][j] = false;\n\t\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2 + 1;\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir[i][j] = true;\n\t\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2 + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint x = 0, y = 0;\n\t\twhile(x < h && y < w){\n\t\t\tif(dir[x][y]){\n\t\t\t\ty++;\n\t\t\t}else{\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tcout << x+1 << \" \" << y+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h,w,n;cin>>h>>w>>n,h|w|n;){\n\t\tvvi grid(h,vi(w));\n\t\trep(i,h) rep(j,w) cin>>grid[i][j];\n\t\t\n\t\tvvi dp(h+1,vi(w+1));\n\t\tdp[0][0]=n-1;\n\t\trep(i,h) rep(j,w){\n\t\t\tdp[i+1][j]+=(dp[i][j]+!grid[i][j])/2;\n\t\t\tdp[i][j+1]+=(dp[i][j]+grid[i][j])/2;\n\t\t}\n\t\t\n\t\tint i=0,j=0;\n\t\twhile(i<h && j<w){\n\t\t\tint di[]={1,0},dj[]={0,1};\n\t\t\tint ni=i+di[grid[i][j]+dp[i][j]&1];\n\t\t\tint nj=j+dj[grid[i][j]+dp[i][j]&1];\n\t\t\ti=ni,j=nj;\n\t\t}\n\t\tcout<<i+1<<' '<<j+1<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(ll i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define RREP(i,n) for(ll i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nll way[1002][1002];\nll dp[1002][1002];\nint main(){\n    while(true){\n\tll h,w,n;\n\tmemset(dp,0ll,sizeof(dp));\n\tmemset(way,0ll,sizeof(way));\n\tcin >> h >> w >> n;\n\tif(h == 0 && w == 0 && n == 0) break;\n\tREP(i,h)REP(j,w) {\n\t    cin >> way[i+1][j+1];\n\t}\n\tdp[1][1] = n-1;\n\tREP(i,h)REP(j,w){\n\t    if(i == 0 && j == 0) continue;\n\t    ll u = 0;\n\t    ll l = 0;\n\t    if(i > 0){\n\t\tif(dp[i][j+1]%2 == 0) u = dp[i][j+1]/2;\n\t\telse if(way[i][j+1] == 0) u = 1 + dp[i][j+1]/2;\n\t    }\n\t    if(j > 0){\n\t\tif(dp[i+1][j]%2 == 0) l = dp[i+1][j]/2;\n\t\telse if(way[i+1][j] == 1) l = 1 + dp[i+1][j]/2;\n\t    }\n\t    dp[i+1][j+1] = u + l;\n\t}\n\tll x = 1;\n\tll y = 1;\n\twhile(x <= w && y <= h){\n\t    if( (way[y][x] + dp[y][x])%2 == 1){\n\t\tx++;\n\t    }else y++;\n\t}\n\tprintf(\"%d %d\\n\",y,x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint t[1000][1000];\n\nint main()\n{\n\tint h, w, n, tmp, ax, ay;\n\n\twhile(true) {\n\t\tscanf(\"%d%d%d\", &h, &w, &n);\n\t\tif(h == 0 && w == 0 && n == 0) break;\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\tscanf(\"%d\", &tmp);\n\t\t\t\tt[x][y] = tmp;\n\t\t\t\tif(x == 0 && y == 0)\n\t\t\t\t\tt[x][y] += n - 1;\n\t\t\t\tif(x != 0)\n\t\t\t\t\tt[x][y] += t[x - 1][y] / 2;\n\t\t\t\tif(y != 0)\n\t\t\t\t\tt[x][y] += (t[x][y - 1] + 1) / 2 - 1;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tax = 0;\n\t\tay = 0;\n\t\twhile(ax < w && ay < h) {\n\t\t\tif(t[ax][ay] % 2 == 0)\n\t\t\t\t++ay;\n\t\t\telse\n\t\t\t\t++ax;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", ay + 1, ax + 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, N) for(int i = 0; i < N; i++)\n \nsigned main()\n{\n  int H, W, N;\n  int mas[1005][1005];\n  cin >> H >> W >> N;\n \n  Rep(i, H) Rep(j, W) cin >> mas[i][j];\n \n  int x = 0, y = 0; --N;\n   \n  while(x < W && y < H) {\n    if((N + mas[y][x]) % 2) x++;\n    else y++;\n    N /= 2;\n  }\n \n  cout << y + 1 << \" \" << x + 1 << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<list>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\nconst int N = 1024;\nint in[N][N];\nmain(){\n  int r,c,n;\n  while(cin>>r>>c>>n && r){\n    rep(i,r)rep(j,c)cin>>in[i][j];\n    int y = 0,x=0;\n    n--;\n    while(true){\n      if (y == r || x == c)break;\n      int dir;\n      if (n%2 == 0)dir = in[y][x];\n      else dir = 1-in[y][x];\n      if (dir == 0)y++;\n      else x++;\n      n/=2;\n    }\n    cout << y+1 <<\" \" << x+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w, n;\nvector< vector<int> > v(1000, vector<int>(1000));\nvector< vector<int> > t(1000, vector<int>(1000));\nmap<int, P> m;\n\nint main() {\n\twhile(cin >> h >> w >> n) {\n\t\tif(h == 0 && w == 0 && n == 0) break;\n\n\t\tm.clear();\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t\tt[i][j] = v[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\n\t\twhile(true) {\n\t\t\tint y = 0, x = 0;\n\t\t\twhile(y != h && x != w) {\n\t\t\t\tif(v[y][x] == 1) {\n\t\t\t\t\tv[y][x] = 0;\n\t\t\t\t\tx++;\n\t\t\t\t} else {\n\t\t\t\t\tv[y][x] = 1;\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm[cnt + 1] = mp(y, x);\n\n\t\t\tbool flag = true;\n\t\t\trep(i, h) {\n\t\t\t\trep(j, w) {\n\t\t\t\t\tif(t[i][j] == v[i][j]) continue;\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flag) break;\n\t\t\tcnt++;\n\t\t}\n\n\t\tP p = m[n % cnt];\n\t\tcout << p.first + 1 << \" \" << p.second + 1 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nvoid solve(int H,int W,int N) {\n    int moji[H][W];\n    int cnt[H+1][W+1];\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            cin >> moji[i][j]; // 0->south / 1->east\n        }\n    }\n\n    // count visits for N-1 walk\n    cnt[0][0]=N-1;\n    for(int j=0; j<W-1; ++j) {\n        cnt[0][j+1]=(cnt[0][j]+moji[0][j])/2;\n    }\n    for(int i=0; i<H-1; ++i) {\n        cnt[i+1][0]=(cnt[i][0]+1-moji[i][0])/2;\n    }\n    for(int i=0; i<H-1; ++i) {\n        for(int j=0; j<W-1; ++j) {\n            cnt[i+1][j+1]=(cnt[i+1][j]+moji[i+1][j])/2+(cnt[i][j+1]+1-moji[i][j+1])/2;\n        }\n    }\n    // calculate status after N-1 walk\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            moji[i][j]=(moji[i][j]+cnt[i][j])%2;\n        }\n    }\n    // Nth walk\n    int h=0, w=0;\n    while(h<H && w<W) {\n        if(moji[h][w]==0) ++h;\n        else ++w;\n    }\n    cout << h+1 << \" \" << w+1 << endl;\n\n    return;\n}\n\nint main() {\n    int H,W,N;\n    while(true) {\n        cin >> H >> W >> N;\n        if(H==0 && W==0 && N==0) break;\n        solve(H,W,N);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n\nint c[1010][1010],g[1010][1010];\n\nint main(){\n  int H,W,N;\n  while(true){\n    memset(c,0,sizeof(c));\n    memset(g,0,sizeof(g));\n    ///配列初期化\n\n    scanf(\"%d%d%d\",&H,&W,&N);\n    printf(\"%d%d%d\\n\",H,W,N); \n    if(H==0 && W==0 && N==0){break;}\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  scanf(\"%d\",&c[i][j]);///初期ステ読み込み\n\t  ///printf(\"%d\",c[i][j]);\n\t}///printf(\"\\n\");\n    }\n    \n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  if(g[i-1][j]%2==1){\n\t    g[i][j]=g[i][j]+(g[i-1][j]-1)/2;\t    \n\t    if(c[i-1][j]==1){\n\t    g[i][j]=g[i][j]+1;\n\t    }\n\t  }\n\t  else{\n\t    g[i][j]=g[i][j]+g[i-1][j]/2;\n\t  }\n\t  \n\t  if(g[i][j-1]%2==1){\n\t    g[i][j]=g[i][j]+(g[i][j-1]-1)/2;\n\t    \n\t    if(c[i][j-1]==0){\n\t    g[i][j]=g[i][j]+1;\n\t    }\n\t  }\n\t  else{\n\t    g[i][j]=g[i][j]+g[i][j-1]/2;\n\t  }\n\t \n\t  if(i==1&&j==1){g[1][1]=N-1;}\n\t  ///回数判定fin\n\t}\n    }\n    for(int i=1;i<=H;i++){\n      for (int j=1;j<=W;j++)\n\t{\n\t  c[i][j]=(c[i][j]+g[i][j])%2;\n\t  printf (\"%d \",c[i][j]);\n\t}\n      printf(\"\\n\");\n    }///目的のマップ\n    \n    int x,y;///Let's walking\n    x=1;\n    y=1;\n    while(x<=H&&y<=W)      \n      {\n\tif(c[x][y]==1)\n\t  {y=y+1;}\n\telse\n\t  {x=x+1;}\n      }\n    \n\n\n\n    printf(\"%d %d\\n\",x,y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nchar a[1000][1000];\nint dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tint d; scanf(\"%d\", &d); a[i][j] = d;\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] / 2;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) / 2;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) / 2;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] / 2;\n\t\t\t}\n\t\t}\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (dp[i][j] & 1)a[i][j] = !a[i][j];\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (a[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", x + 1, y + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\nint h,w,n,p;\nbool board[1001][1001];\nll cnt[1001][1001];\n\nint main() {\n  while(cin>>h>>w>>n, h|w|n) {\n    memset(board, false, sizeof(board));\n    memset(cnt, 0, sizeof(cnt));\n    cnt[0][0] = n-1;\n    for (int i=0; i<h; ++i) {\n      for(int j=0; j<w; ++j) {\n        cin>>p;\n        if (p) board[i][j] = true;\n      }\n    }\n    for (int i=0; i<h; ++i) {\n      for (int j=0; j<w; ++j) {\n        if (cnt[i][j]%2 == 0) {\n          if (j<w-1) cnt[i][j+1] += cnt[i][j]/2;\n          if (i<h-1) cnt[i+1][j] += cnt[i][j]/2;\n        } else {\n          if (j<w-1) cnt[i][j+1] += cnt[i][j]/2 + ((board[i][j])?1:0);\n          if (i<h-1) cnt[i+1][j] += cnt[i][j]/2 + ((!board[i][j])?1:0);\n          board[i][j] ^= true;\n        }\n      }\n    }\n\n    int x=0,y=0;\n    while(x<w && y<h) {\n      if (board[y][x]) x++;\n      else y++;\n    }\n    x++, y++;\n    cout<<y<<\" \"<<x<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  bool grid[1000][1000];\n  int num[2][1000],i,j,h,w,n,t;\n  while(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&t);\n\tgrid[i][j] = t?true:false;\n      }\n\n    for(i=0;i<w;i++)num[0][i] = num[1][i] = 0;\n    num[0][i] = n-1;\n    for(i=0;i<h;i++)\n      for(j=0;j<w;j++){\n\tt = i&1;\n\tint N=num[t][j];\n\tif(grid[i][j]){\n\t  num[1-t][j] += N/2;\n\t  num[t][j+1] += N-N/2;\n\t}else{\n\t  num[t][j+1] += N/2;\n\t  num[1-t][j] += N-N/2;\n\t}\n\tif(N&1)grid[i][j] = !grid[i][j];\n      }\n\n    i=j=0;\n    while(i<h && j<w)grid[i][j]?j++:i++;\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint h, w, n;\n\twhile(scanf(\"%d%d%d\", &h, &w, &n), h){\n\t\tvector<vector<int> > a(h, vector<int>(w));\n\t\tvector<vector<int> > c(h + 1, vector<int>(w + 1));\n\t\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tc[0][0] = n - 1;\n\t\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tint s = c[i][j];\n\t\t\tif(s & 1){\n\t\t\t\tif(a[i][j]){\n\t\t\t\t\tc[i + 1][j] = s >> 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tc[i + 1][j] = (s + 1) >> 1;\n\t\t\t\t}\n\t\t\t\tc[i][j + 1] = s - c[i + 1][j];\n\t\t\t\ta[i][j] = !a[i][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tc[i + 1][j] = c[i][j + 1] = s >> 1;\n\t\t\t}\n\t\t}\n\n\t\tint y = 0, x = 0;\n\t\twhile(y < h && x < w){\n\t\t\tif(a[y][x]){ ++x; }\n\t\t\telse{ ++y; }\n\t\t}\n\t\tprintf(\"%d %d\\n\", y + 1, x + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tgetchar(); a[i][j] = getchar() - '0';\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] >> 1;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) >> 1;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) >> 1;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] >> 1;\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (dp[x][y] & 1)a[x][y] = !a[x][y];\n\t\t\tif (a[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", x + 1, y + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n \nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint stage[1024][1004];\nint dp[1024][1024];\nint main(){\n    int h,w,n;\n    while(scanf(\"%d%d%d\",&h,&w,&n),(h|w)|n){\n        rep(i,h)rep(j,w)scanf(\"%d\",&stage[i][j]);\n        dp[0][0] = --n;\n        rep(i,h){\n            rep(j,w){\n                if(dp[i][j] % 2 == 0){\n                    dp[i][j+1] = dp[i][j]/2;\n                    dp[i+1][j] = dp[i][j]/2;\n                 }\n                 else{\n                    if(stage[i][j] == 0){\n                        dp[i+1][j] += dp[i][j]/2 + 1;\n                        dp[i][j+1] += dp[i][j]/2;\n                    }\n                    else if(stage[i][j] == 1){\n                        dp[i+1][j] += dp[i][j]/2;\n                        dp[i][j+1] += dp[i][j]/2 + 1;\n                    }\n                 }\n            }\n        }\n        int x = 0,y = 0;\n        while(x < w && y < h){\n            if(dp[y][x] % 2== 0){\n                if(stage[y][x] == 0)y++;\n                else x++;\n            }\n            else{\n                if(stage[y][x] == 0)x++;\n                else y++;\n            }\n        }\n        printf(\"%d %d\\n\",++y,++x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint h,w,n,x,y,f[1005][1005],dp[1005][1005];\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d%d%d\",&h,&w,&n);if(!h) return 0;\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)scanf(\"%d\",&f[i][j]),dp[i][j]=0;\n\t\tdp[1][1]=n;\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\t\tif(i>=2) dp[i][j]+=(dp[i-1][j]+!f[i-1][j])/2;\n\t\t\tif(j>=2) dp[i][j]+=(dp[i][j-1]+f[i][j-1])/2;\n\t\t}\n\t\tfor(x=1,y=1;x<=h&&y<=w;){ if((f[x][y]^dp[x][y])&1) x++; else y++;}\n\t\tprintf(\"%d %d\\n\",x,y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint table[1000][1000];\nint dp[1000][1000];\nint H,W,N;\nint main() {\nwhile(1)\n{\n\tscanf(\"%d%d%d\",&H,&W,&N);\n\tif(H==0)return 0;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%d\",table[i]+j);\n\t\t\tdp[i][j]=0;\n\t\t}\n\t}\n\tdp[0][0]=N-1;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(i+1<H){\n\t\t\t\tdp[i+1][j]+=(dp[i][j]+1-table[i][j])/2;\n\t\t\t}\n\t\t\tif(j+1<W){\n\t\t\t\tdp[i][j+1]+=(dp[i][j]+table[i][j])/2;\n\t\t\t}\n\t\t\ttable[i][j]=(table[i][j]+dp[i][j])%2;\n\t\t\t//cout << table[i][j] << \" \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\t/*  \n\tcout << endl;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\tint x=0;\n\tint y=0;\n\twhile(x<H&&y<W){\n\t\tif(table[x][y]){\n\t\t\ty++;\n\t\t}\n\t\telse{\n\t\t\tx++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",x+1,y+1);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n\nusing namespace std;\n\npair<int, int> solve(int H, int W, long long N) {\n    long long grid[H][W];\n    for(int i=0;i<H;++i) {\n        for(int j=0;j<W;++j) {\n            cin >> grid[i][j];\n        }\n    }\n\n    long long dp[H+1][W+1];\n    fill(dp[0], dp[H]+W+1, 0LL);\n    dp[0][0] = N-1;\n    for(int i=0;i<H;++i) {\n        for(int j=0;j<W;++j) {\n            if(grid[i][j]) {\n                dp[i][j+1] += (dp[i][j]+1)/2;\n                dp[i+1][j] += dp[i][j]/2;\n            } else {\n                dp[i+1][j] += (dp[i][j]+1)/2;\n                dp[i][j+1] += dp[i][j]/2;\n            }\n        }\n    }\n    for(int i=0;i<H;++i) {\n        for(int j=0;j<W;++j) {\n            grid[i][j] = (grid[i][j] + dp[i][j]) & 1;\n        }\n    }\n\n    int y = 0, x = 0;\n    while(y < H && x < W) {\n        if(grid[y][x]) {\n            x += 1;\n        } else {\n            y += 1;\n        }\n    }\n    return pair<int, int>(y+1, x+1);\n}\n\nint main() {\n    int H,W; long long N;\n    while(cin >> H >> W >> N, N) {\n        pair<int, int> ans = solve(H, W, N);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int *x) { int k, m = 0; *x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { *x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; *x = (*x) * 10 + k - '0'; }if (m)(*x) = -(*x); }\nvoid reader(int *x, int *y) { reader(x); reader(y); }\nvoid reader(int *x, int *y, int *z) { reader(x); reader(y); reader(z); }\nvoid writer(int x, char c) { int i, sz = 0, m = 0; char buf[10]; if (x<0)m = 1, x = -x; while (x)buf[sz++] = x % 10, x /= 10; if (!sz)buf[sz++] = 0; if (m)mypc('-'); while (sz--)mypc(buf[sz] + '0'); mypc(c); }\n\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (reader(&h, &w, &n), h) {\n\t\trep(i, h)rep(j, w) {\n\t\t\treader(&a[i][j]);\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += dp[i - 1][j] >> 1;\n\t\t\t\telse dp[i][j] += (dp[i - 1][j] + 1) >> 1;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += (dp[i][j - 1] + 1) >> 1;\n\t\t\t\telse dp[i][j] += dp[i][j - 1] >> 1;\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (dp[x][y] & 1)a[x][y] = !a[x][y];\n\t\t\tif (a[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\twriter(x + 1, ' '); writer(y + 1, '\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N 3500\n\nlong long x[MAX_N][MAX_N];\nlong long dp[MAX_N][MAX_N];\nint h, w, n, cx, cy;\nint main() {\n\twhile (true) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tcin >> h >> w >> n;\n\t\tif (h == 0 && w == 0 && n == 0) { break; }\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tscanf(\"%d\", x[i][j]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1] = n - 1;\n\t\tfor (int i = 2; i <= h + w; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tint k = i - j;\n\t\t\t\tif (j <= h && k <= w) {\n\t\t\t\t\tif (x[j][k] == 0) {\n\t\t\t\t\t\tdp[j][k + 1] += dp[j][k] / 2;\n\t\t\t\t\t\tdp[j + 1][k] += (dp[j][k] + 1) / 2;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[j][k + 1] += (dp[j][k] + 1) / 2;\n\t\t\t\t\t\tdp[j + 1][k] += dp[j][k] / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tx[i][j] += dp[i][j];\n\t\t\t\tx[i][j] %= 2;\n\t\t\t}\n\t\t}\n\t\tcx = 1; cy = 1;\n\t\twhile (cx <= w && cy <= h) {\n\t\t\tif (x[cy][cx] == 0) {\n\t\t\t\tcy++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcx++;\n\t\t\t}\n\t\t}\n\t\tcout << cy << ' ' << cx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint dp[1010][1010];\nbool fld[1010][1010];\nint main(){\n\tint h,w,n;\n\twhile(1){\n\t\tcin>>h>>w>>n;\n\t\tif(h==0&&w==0&&n==0)break;\n\t\tREP(i,h)REP(j,w)cin>>fld[j][i];\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=n-1;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tif(j!=0){\n\t\t\t\t\tdp[j][i]+=dp[j-1][i]/2;\n\t\t\t\t\tif(dp[j-1][i]&1&&fld[j-1][i])dp[j][i]++;\n\t\t\t\t}\n\t\t\t\tif(j!=0){\n\t\t\t\t\tdp[j][i]+=dp[j][i-1]/2;\n\t\t\t\t\tif(dp[j][i-1]&1&&!fld[j][i-1])dp[j][i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i,h)REP(j,w)fld[j][i]=(fld[j][i]+dp[j][i])%2;\n\t\tint nx=0,ny=0;\n\t\twhile(nx<w&&ny<h){\n\t\t\tif(fld[nx][ny])nx++;\n\t\t\telse ny++;\n\t\t}\n\t\tcout<<ny+1<<\" \"<<nx+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint a[1000][1000], dp[1000][1000];\nint main() {\n\tint h, w, n;\n\twhile (scanf(\"%d%d%d\", &h, &w, &n), h) {\n\t\trep(i, h)rep(j, w)scanf(\"%d\", &a[i][j]);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = n - 1;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (i) {\n\t\t\t\tif (a[i - 1][j])dp[i][j] += (dp[i - 1][j] - 1) / 2;\n\t\t\t\telse dp[i][j] += dp[i - 1][j] / 2;\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (a[i][j - 1])dp[i][j] += dp[i][j - 1] / 2;\n\t\t\t\telse dp[i][j] += (dp[i][j - 1] - 1) / 2;\n\t\t\t}\n\t\t}\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (dp[i][j] & 1)a[i][j] = !a[i][j];\n\t\t}\n\t\tint x = 0, y = 0;\n\t\twhile (x < h&&y < w) {\n\t\t\tif (a[x][y])y++;\n\t\t\telse x++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", x + 1, y + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\n\nbool dp[MAX][MAX];\nint dp2[MAX][MAX];\nint H, W, N;\n\nbool get_dir(int n, bool dir)\n{\n  if (n % 2 == 0) {\n    return dir;\n  } else {\n    return !dir;\n  }\n}\n\nvoid find_last_point()\n{\n  int x = 0, y = 0;\n  while (true) {\n    if (dp[y][x] == 1) {\n      x++;\n    } else {\n      y++;\n    }\n    if (x >= W || y >= H) break;\n  }\n  cout << y+1 << \" \" << x+1 << endl;\n}\n\nvoid print()\n{\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cout << dp[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid print2()\n{\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cout << dp2[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\n\nint main()\n{\n  while (cin >> H >> W >> N, H) {\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n\tcin >> dp[i][j];\n      }\n    }\n    memset(dp2, 0, sizeof(dp2));\n\n    dp[0][0] = get_dir(N-1, dp[0][0]);\n    dp2[0][0] = N-1;\n\n    for (int i = 0; i < H; i++) {\n      if (dp2[i][0] == 0) continue;\n      if (dp2[i][0] % 2 == 1) {\n\tif (dp[i][0] == 0) {\n\t  dp2[i+1][0] += dp2[i][0]/2;\n\t  if (i > 0) dp2[i][1] += dp2[i][0]/2+1;\n\t} else {\n\t  dp2[i+1][0] += dp2[i][0]/2+1;\n\t  if (i > 0) dp2[i][1] += dp2[i][0]/2;\n\t}\n      } else {\n\tdp2[i+1][0] += dp2[i][0]/2;\n\tif (i > 0) dp2[i][1] += dp2[i][0]/2;\n      }\n      dp[i+1][0] = get_dir(dp2[i+1][0], dp[i+1][0]);\n    }    \n\n    for (int j = 0; j < W; j++) {\n      if (dp2[0][j] == 0) continue;\n      if (dp2[0][j] % 2 == 1) {\n\tif (dp[0][j] == 0) {\n\t  dp2[0][j+1] += dp2[0][j]/2+1;\n\t  if (j > 0) dp2[1][j] += dp2[0][j]/2;\n\t} else {\n\t  dp2[0][j+1] += dp2[0][j]/2;\n\t  if (j > 0) dp2[1][j] += dp2[0][j]/2+1;\n\t}\n      } else {\n\tdp2[0][j+1] += dp2[0][j]/2;\n\tif (j > 0) dp2[1][j] += dp2[0][j]/2;\n      }\n      dp[0][j+1] = get_dir(dp2[0][j+1], dp[0][j+1]);\n    }\n\n    for (int i = 1; i < H; i++) {\n      for (int j = 1; j < W; j++) {\n\tif (dp2[i][j] == 0) continue;\n\tif (dp2[i][j] % 2 == 1) {\n\t  if (dp[i][j] == 1) {\n\t    dp2[i+1][j] += dp2[i][j]/2;\n\t    dp2[i][j+1] += dp2[i][j]/2+1;\n\t  } else {\n\t    dp2[i+1][j] += dp2[i][j]/2+1;\n\t    dp2[i][j+1] += dp2[i][j]/2;\n\t  }\n\t} else {\n\t  dp2[i+1][j] += dp2[i][j]/2;\n\t  dp2[i][j+1] += dp2[i][j]/2;\n\t}\n\tdp[i][j] = get_dir(dp2[i][j], dp[i][j]);\n      }\n    }\n    find_last_point();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nbool mp[1002][1002];\nint count[1002][1002];\nint main(){\n    int h,w,n;\n    while(cin>>h>>w>>n,h){\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                cin>>mp[i][j];\n            }\n        }\n        memset(count,0,h*w*4);\n        count[0][0]=n-1;\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                mp[i][j]=mp[i][j]^(count[i][j]%2);\n                count[i][j+1] += (count[i][j]+!mp[i][j])/2;\n                count[i+1][j] += (count[i][j]+mp[i][j])/2;\n            }\n        }\n        int x=0,y=0;\n        while(x<w&&y<h){\n            if(mp[y][x]) ++x;\n            else ++y;\n        }\n        cout<<y+1<<\" \"<<x+1<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint direction[1001][1001];\nint dp[1001][1001];\n\nint main(){\n  int H,W,n;\n  while(~scanf(\"%d %d %d\",&H,&W,&n)){\n    if(H == 0 && W == 0) break;\n\n    memset(direction,0,sizeof(direction));\n    memset(dp,0,sizeof(dp));\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tscanf(\"%d\",&direction[y][x]);\n      }\n    }\n    \n    dp[0][0] = n-1; //offset\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\t//dir\n\t//0 v\n\t//1 ->\n\tif(y+1 < H) dp[y+1][x] += ((dp[y][x] + (direction[y][x] == 0 ? 1:0)) / 2);\n\tif(x+1 < W) dp[y][x+1] += ((dp[y][x] + (direction[y][x] == 1 ? 1:0)) / 2);\n      }\n    }\n    \n    int x = 0;\n    int y = 0;\n    for(int round = 0; round <= 1010; round++){\n      if((dp[y][x] + direction[y][x]) % 2 == 0) y++;\n      else if((dp[y][x] + direction[y][x]) % 2 == 1) x++;\n      if(y == H || x == W) break;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nint num[1005][1005],h,w,n;\npair<int,int>p;\nint main(){\nwhile(1){\nscanf(\"%d %d %d\",&h,&w,&n);\nfor(int i=1;i<=h;i++){\nfor(int j=1;j<=w;j++){\nscanf(\"%d\",&num[j][i]);\n}\n}\nint y=1,s=1,cou=0;\nwhile(1){\ncou++;\nif(num[y][s]){\ny++;\nnum[y][s]=(num[y][s]+1)%2;\nif(y==w+1){\np=make_pair(y,s);\nbreak;\n}}else{\nnum[y][s]=(num[y][s]+1)%2;\ns++;\nif(s==h+1){\np=make_pair(y,s);\nbreak;\n}\n}\nif(cou==n){\ncout << p.first << \" \" << p.second << endl; return 0;\n}\nif(p.first==1 && p.second==h){\ncout << p.first <<\" \"<< p.second << endl; return 0;\n}\nif(p.first==w && p.second==1){\ncout << p.first <<\" \"<<p.second <<endl; return 0;\n}\n}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint map[1001][1001];\nint dp[1001][1001];\nint main(void)\n{\n    int h,w,n;\n    int i,j;\n    int x,y;\n \n    scanf(\"%d %d %d\",&h,&w,&n);\n    while(h!=0 && w!=0 && n!=0){\n        for(i=1;i<=h;i++){\n            for(j=1;j<=w;j++){\n                scanf(\"%d\",&map[i][j]);\n                dp[i][j]=0;\n            }\n        }\n        dp[1][1]=n-1;\n        for(i=1;i<=h;i++){\n            for(j=1;j<=w;j++){\n                if(dp[i][j]%2==0){\n                    dp[i+1][j]+=dp[i][j]/2;\n                    dp[i][j+1]+=dp[i][j]/2;\n                }\n                else if(dp[i][j]%2!=0){\n                    if(map[i][j]==1){\n                        dp[i][j+1]+=dp[i][j]/2+1;\n                        dp[i+1][j]+=dp[i][j]/2;\n                    }\n                    else if(map[i][j]==0){\n                        dp[i+1][j]+=dp[i][j]/2+1;\n                        dp[i][j+1]+=dp[i][j]/2;\n                    }\n                }\n            }\n        }\n        for(i=1;i<=h;i++){\n            for(j=1;j<=w;j++){\n                if(dp[i][j]%2!=0){\n                    if(map[i][j]==1){\n                        map[i][j]=0;\n                    }\n                    else {\n                        map[i][j]=1;\n                    }\n                }\n            }\n        }\n        x=1;\n        y=1;\n        while(x<=h && y<=w){\n            if(map[x][y]==1){\n                y++;\n            }\n            else if(map[x][y]==0){\n                x++;\n            }\n        }\n        printf(\"%d %d\\n\",x,y);\n        scanf(\"%d %d %d\",&h,&w,&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint h,w,n,c[1000][1000];\nint dp[1001][1001];\nint d[1000][1000];\n\nint main(){\n\twhile(scanf(\"%d%d%d\",&h,&w,&n),h){\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) scanf(\"%d\",&c[i][j]);\n\t\tfor(int i=0;i<=1000;i++) for(int j=0;j<=1000;j++) dp[i][j]=0;\n\t\tdp[1][1]=n-1;\n\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++){\n\t\t\tif(i!=1){\n\t\t\t\tif(c[i-2][j-1]==0) dp[i][j]+=(dp[i-1][j]+1)/2;\n\t\t\t\telse dp[i][j]+=dp[i-1][j]/2;\n\t\t\t}\n\t\t\tif(j!=1){\n\t\t\t\tif(c[i-1][j-2]==1) dp[i][j]+=(dp[i][j-1]+1)/2;\n\t\t\t\telse dp[i][j]+=dp[i][j-1]/2;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++)\n\t\t\td[i][j]=(c[i][j]+dp[i+1][j+1])%2;\n\t\tint i=1,j=1;\n\t\twhile(i<=h&&j<=w){\n\t\t\tif(d[i-1][j-1]) j++;\n\t\t\telse i++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",i,j);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nenum Direction{SOUTH,EAST};\n\nint v[1001][1001],dp[1001][1001];\nint main()\n{\n  int H,W,N;\n  int y,x;\n  while(cin>>H>>W>>N,H|W|N){\n    for(int i=0;i<=H;i++)for(int j=0;j<=W;j++)v[i][j]=dp[i][j]=0;\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>v[i][j];\n    dp[1][1]=N-1;\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n\tif(dp[i-1][j]&1){\n\t  if(v[i-1][j]==SOUTH)dp[i][j]+=(dp[i-1][j]+1)/2;\n\t  else dp[i][j]+=(dp[i-1][j]-1)/2;\n\t}else{\n\t  dp[i][j]+=dp[i-1][j]/2;\n\t}\n\tif(dp[i][j-1]&1){\n\t  if(v[i][j-1]==EAST)dp[i][j]+=(dp[i][j-1]+1)/2;\n\t  else dp[i][j]+=(dp[i][j-1]-1)/2;\n\t}else{\n\t  dp[i][j]+=dp[i][j-1]/2;\n\t}\n      }\n    }\n    //for(int i=0;i<H;i++,puts(\"\"))for(int j=0;j<W;j++)cout<<v[i][j]<<\",\";\n    //puts(\"\");\n    //for(int i=0;i<=H;i++,puts(\"\"))for(int j=0;j<=W;j++)cout<<dp[i][j]<<\",\";\n    //puts(\"\");\n    //for(int i=0;i<H;i++,puts(\"\"))for(int j=0;j<W;j++)cout<<((v[i][j]+dp[i][j])&1)<<\",\";\n    //puts(\"\");\n    y=x=1;\n    while(x<=W && y<=H){\n      v[y][x]^=dp[y][x]&1;\n      //cout<<y<<\",\"<<x<<\":\"<<v[y][x]<<endl;\n      if(v[y][x]==SOUTH)y++;\n      else x++;\n    }\n    cout<<y<<\" \"<<x<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int H, W, N;\n    while(cin >> H >> W >> N, H || W || N) {\n    int dp[1005][1005] = {};\n    int mas[1005][1005];\n    dp[0][0] = N - 1;\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            cin >> mas[i][j];\n            if(dp[i][j] % 2 == 0) {\n                dp[i + 1][j] += dp[i][j] / 2;\n                dp[i][j + 1] += dp[i][j] / 2;\n            } else {\n                dp[i + 1][j] += dp[i][j] / 2 + 1 - mas[i][j];\n                dp[i][j + 1] += dp[i][j] / 2 + mas[i][j];\n            }\n            (mas[i][j] += dp[i][j] % 2) %= 2;\n        }\n    }\n    int x = 0, y = 0;\n    while(x < W && y < H) {\n        if(mas[y][x] == 0) y++;\n        else x++;\n    }\n    cout << y + 1 << \" \" << x + 1 << endl;\n    }\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[1002][1002];\nlong long int dp[1002][1002];\nlong long int x,y;\nint h,w;\nlong int n;\n\nvoid root(int xx,int yy){\n\tx=xx,y=yy;\n\tif(xx<=w && yy<=h){\n\t\tif(map[xx][yy]==1){\n\t\t\troot(xx+1,yy);\n\t\t}else{\n\t\t\troot(xx,yy+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint a,b,c;\n\twhile(1){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&map[b][a]);\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tif(dp[b][a]%2==0)dp[b+1][a]=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)dp[b+1][a]=(dp[b][a]+1)/2;\n\t\t\t\t\tif(map[b][a]==0)dp[b+1][a]=(dp[b][a]-1)/2;\n\t\t\t\t}\n\t\t\t\tif(dp[b][a]%2==0)dp[b][a+1]=dp[b][a]/2;\n\t\t\t\telse{\n\t\t\t\t\tif(map[b][a]==1)dp[b][a+1]=(dp[b][a]-1)/2;\n\t\t\t\t\tif(map[b][a]==0)dp[b][a+1]=(dp[b][a]+1)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tmap[b][a]=(map[b][a]+dp[b][a])%2;\n\t\t\t}\n\t\t}\n\t\troot(1,1);\n\t\tcout << y << \" \" << x << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\n#define MP  make_pair\n#define PB  push_back\nusing namespace std;\ntypedef long long ll;\n\nint vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n// }}}\n\nint field[1000][1000];\nint main(){\n    int H,W,N;\n    scanf(\"%d%d%d\",&H,&W,&N);\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            scanf(\"%d\",&field[i][j]);\n        }\n    }\n    int nx=0,ny=0;\n    while(nx<H&&ny<W){\n        if(((N%2+1)+field[nx][ny])%2==0) nx++;\n        else ny++;\n        N=(N+1)/2;\n    }\n    printf(\"%d %d\\n\",nx+1,ny+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, r[1000][1000], dp[1001][1001];\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &N);\n\n\t\tif (H == 0 && W == 0 && N == 0) { break; }\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &r[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tdp[0][0] = N;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (dp[i][j] % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (r[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j] / 2 + 1;\n\t\t\t\t\t\tdp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\t\t\tdp[i][j + 1] += dp[i][j] / 2 + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint x = 0, y = 0;\n\n\t\twhile (x != W && y != H)\n\t\t{\n\t\t\tint dir = (r[y][x] + dp[y][x] + 1) % 2;\n\n\t\t\tif (dir == 0)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", y + 1, x + 1); // 1 - indexed\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\npair<int, int> solve(int H, int W, int N, vector<vector<int>> f) {\n\n    vector<vector<int>> dp(H + 1, vector<int>(W + 1, 0));\n    dp[0][0] = N - 1;\n    FOR(y, 0, H) {\n        FOR(x, 0, W) {\n            int num = dp[y][x];\n            if (num % 2 == 0) {\n                dp[y + 1][x] += num / 2;\n                dp[y][x + 1] += num / 2;\n            }\n            else {\n                if (f[y][x] == 0) {\n                    dp[y + 1][x] += num - (num / 2);\n                    dp[y][x + 1] += num / 2;\n                }\n                if (f[y][x] == 1) {\n                    dp[y + 1][x] += num / 2;\n                    dp[y][x + 1] += num - (num / 2);\n                }\n            }\n        }\n    }\n\n    FOR(y, 0, H) {\n        FOR(x, 0, W) {\n            if (dp[y][x] % 2 != 0) {\n                f[y][x] = 1 - f[y][x];\n            }\n        }\n    }\n\n    int y = 0, x = 0;\n    while (true) {\n        int p = f[y][x];\n        if (p == 0) {\n            y += 1;\n        }\n        else {\n            x += 1;\n        }\n\n        if (y == H or x == W) {\n            break;\n        }\n    }\n\n    return make_pair(y, x);\n}\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true) {\n        int H, W, N;\n        cin >> H >> W >> N;\n        if (H == 0 and W == 0 and N == 0) {\n            break;\n        }\n        vector<vector<int>> f(H + 1, vector<int>(W + 1));\n        FOR(y, 0, H) {\n            FOR(x, 0, W) {\n                cin >> f[y][x];\n            }\n        }\n\n        auto ans1 = solve(H, W, N, f);\n        cout << ans1.first + 1 << \"\" << ans1.second + 1 << endl;\n        \n    }\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n/*struct POS{\n  int x;\n  int y;\n  };*/\n//queue<POS> check;\nlong n,field[201][201];//,next[201][201];\n//bool flag[201][201];\nint h,w;\nint main(){\n  while(cin >>h>>w>>n,h||w||n){\n    /*    for(int i=0; i<101; i++){\n      for(int j=0; j<101; j++){\n\tnext[j][i] = 0;\n\tflag[j][i] = false;\n\tfield[i][j] = 0;\n      }\n      }*/\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tcin >>field[j][i];\n      }\n    }\n    //    next[0][0] = n-1;\n    //    POS a;\n    //    a.x = 0;a.y = 0;check.push(a);flag[0][0] = true;\n    /*    while(!check.empty()){\n      POS p = check.front();\n      if(p.x<w && p.y<h){\n\tif(next[p.x][p.y]>0){\n\t  if(next[p.x][p.y]%2 == 0){\n\t    next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t    next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t  }\n\t  else{\n\t    if(field[p.x][p.y] == 0){\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2+1;\n\t    }\n\t    else{\n\t      next[p.x+1][p.y]+=next[p.x][p.y]/2+1;\n\t      next[p.x][p.y+1]+=next[p.x][p.y]/2;\n\t    }\n\t  }\n\t  a.x = p.x+1;a.y = p.y;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t  a.x = p.x;a.y = p.y+1;\n\t  if(!flag[a.x][a.y]){\n\t    check.push(a);\n\t    flag[a.x][a.y] = true;\n\t  }\n\t}\n      }\n      check.pop();\n      }*/\n    /*    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tfield[j][i] = (field[j][i]+next[j][i]%2)%2;\n      }\n      }*/\n    int px = 0,py = 0;\n    /*    while(px<w && py<h){\n      if(field[px][py] == 0){py++;}\n      if(field[px][py] == 1){px++;}\n      }*/\n    cout <<py+1<<\" \"<<px+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define lol(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint d[1010][1010],h,w,a;\nint main(){\n    while(cin>>h>>w>>a&&h){\n    int x=0,y=0;\n    memset(d,0,sizeof(d));\n    d[0][0]=a;\n    lol(i,h)lol(j,w){\n\tcin>>a;\n\td[i+1][j]+=d[i][j]/2+d[i][j]%2*(1-a);\n\td[i][j+1]+=d[i][j]/2+d[i][j]%2*a;\n\td[i][j]+=a;\n    }\n    while(x<w&&y<h){\n\tif(d[y][x]%2)y++;\n\telse x++;\n    }\n    cout<<y+1<<\" \"<<x+1<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,K,a[1001][1001],dp[1001][1001];\nint main(){\n\twhile(true){\n\t\tcin>>H>>W>>K;if(H==0)break;\n\t\tfor(int i=0;i<H;i++){for(int j=0;j<W;j++){scanf(\"%d\",&a[i][j]);dp[i][j]=0;}}\n\t\tdp[0][0]=K-1;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(dp[i][j]%2==0){dp[i+1][j]+=dp[i][j]/2;dp[i][j+1]+=dp[i][j]/2;}\n\t\t\t\telse{\n\t\t\t\t\tif(a[i][j]==0){dp[i+1][j]+=dp[i][j]/2+1;dp[i][j+1]+=dp[i][j]/2;}\n\t\t\t\t\tif(a[i][j]==1){dp[i+1][j]+=dp[i][j]/2;dp[i][j+1]+=dp[i][j]/2+1;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<H;i++){for(int j=0;j<W;j++){dp[i][j]%=2;a[i][j]^=dp[i][j];}}\n\t\tint cx=0,cy=0;\n\t\twhile(cx<H && cy<W){if(a[cx][cy]==0)cx++;else cy++;}\n\t\tcout<<cx+1<<' '<<cy+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\nusing namespace std;\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define f(i, k, j) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = (1 << 26);\nconst int MAX_WH = 1010;\n\nint h, w, n;\nint dp[MAX_WH][MAX_WH], field[MAX_WH][MAX_WH];\n\nint main(){\n    while(cin >>h >>w >>n && h && w && n){\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = n - 1;\n        rep(i, h) rep(j, w) cin >>field[i][j];\n\n        rep(i, h){\n            rep(j, w){\n                dp[i + 1][j] += dp[i][j] / 2;\n                dp[i][j + 1] += dp[i][j] / 2;\n                if(dp[i][j] % 2 == 1){\n                    if(field[i][j] == 0) dp[i + 1][j]++;\n                    else dp[i][j + 1]++;\n                }\n                if(dp[i][j] % 2 == 1) field[i][j] = (field[i][j] + 1) % 2;\n            }\n        }\n        int nx = 0, ny = 0;\n        while(nx < w && ny < h){\n            if(field[ny][nx] == 0) ny++;\n            else nx++;\n        }\n        cout <<ny + 1 <<\" \" <<nx + 1 <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ntypedef long long ll;\n\nint a[1010][1010];\nint dp[1010][1010];\n\nint main(void){\n\n\tint H,W,N;\n\tcin >> H >> W >> N;\n\tint i,j;\n\tfor(i=1;i<=H;i++) for(j=1;j<=W;j++) cin >> a[i][j];\n\tdp[1][1]=N-1;\n\tfor(i=1;i<=H;i++) for(j=1;j<=W;j++){\n\t\tif(i!=1 || j!=1){\n\t\tif(dp[i-1][j]%2==1 && a[i-1][j]==0) dp[i][j]+=(dp[i-1][j]+1)/2;\n\t\tif(dp[i-1][j]%2==1 && a[i-1][j]==1) dp[i][j]+=(dp[i-1][j]-1)/2;\n\t\tif(dp[i-1][j]%2==0) dp[i][j]+=dp[i-1][j]/2;\n\t\tif(dp[i][j-1]%2==1 && a[i][j-1]==0) dp[i][j]+=(dp[i][j-1]-1)/2;\n\t\tif(dp[i][j-1]%2==1 && a[i][j-1]==1) dp[i][j]+=(dp[i][j-1]+1)/2;\n\t\tif(dp[i][j-1]%2==0) dp[i][j]+=dp[i][j-1]/2;\n\t\t}\n\t}\n\n\tint x=1,y=1;\n\twhile(x<=H && y<=W){\n\t\tif(dp[x][y]==0 && a[x][y]==0) x++;\n\t\telse if(dp[x][y]==0 && a[x][y]==1) y++;\n\t\telse if(dp[x][y]%2==0 && a[x][y]==0) x++;\n\t\telse if(dp[x][y]%2==0 && a[x][y]==1) y++;\n\t\telse if(dp[x][y]%2==1 && a[x][y]==0) y++;\n\t\telse if(dp[x][y]%2==1 && a[x][y]==1) x++;\n\t}\n\n\tcout << x << ' ' << y << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM,forM_)\nimport Data.Array (Array,listArray,(!))\n\nmain = do\n    [h,w,n] <- getLine >>= return . map read . words\n    if all (==0) [h,w,n] then return () else do\n        init <- replicateM h (getLine >>= return . map read . words)\n                >>= return . listArray ((1,1),(h,w)) . concat\n        let (y,x) = solve h w n init\n        putStrLn $ unwords $ map show $ [y,x]\n        main\n\nsolve :: Int -> Int -> Int -> Array (Int,Int) Int -> (Int,Int)\nsolve h w n init = walk 1 1\n    where\n    walk y x\n        | y == h+1 || x == w+1\n            = (y,x)\n        | otherwise\n            = case (init ! (y,x) + counts ! (y,x)) `mod` 2 of\n                0 -> walk (y+1) x\n                1 -> walk y (x+1)\n\n    counts = listArray ((1,1),(h,w)) [count y x | y <- [1..h], x<-[1..w]]\n\n    count 1 1 = n - 1\n    count y x = (fromNorth y x) + (fromWest y x)\n\n    fromNorth 1 _ = 0\n    fromNorth y x = (counts ! (y-1,x) + (1 - init ! (y-1,x))) `div` 2\n\n    fromWest _ 1 = 0\n    fromWest y x = (counts ! (y,x-1) + init ! (y,x-1)) `div` 2"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM,forM_)\nimport Control.Monad.ST (ST,runST)\nimport qualified Data.Array.ST as STArr\n\nmain = do\n    [h,w,n] <- getLine >>= return . map read . words\n    if all (==0) [h,w,n] then return () else do\n        init <- replicateM h (getLine >>= return . map read . words)\n        let (y,x) = solve h w n init\n        putStrLn $ unwords $ map show $ [y,x]\n        main\n\nsolve :: Int -> Int -> Int -> [[Int]] -> (Int,Int)\nsolve h w n init = runST $ do\n    table <- STArr.newListArray ((1,1),(h,w)) (concat init)\n            :: ST s (STArr.STArray s (Int,Int) Int)\n    forM_ [1..n-1] (\\_ -> walk table (1,1))\n    walk table (1,1)\n\n    where\n    walk table (y,x) = do\n        dir <- STArr.readArray table (y,x)\n        STArr.writeArray table (y,x) (1-dir)\n        let (y',x') = if dir == 0 then (y+1,x) else (y,x+1)\n        if y' == h+1 || x' == w+1\n            then return (y',x')\n            else walk table (y',x')\n        "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint H,W,N,i,j,c,M[2][1005][1005],g[1000005][2],y,x;\n\nvoid dbg()\n{\n\tint i,j;\n\tfor(i=0;i<H;i++,puts(\"\"))\n\t\tfor(j=0;j<W;j++)\n\t\t\tprintf(\"%d \",M[1][i][j]);\n\tputs(\"\");\n}\n\nint ch()\n{\n\tint i,j;\n\tfor(i=0;i<H;i++)\n\t\tfor(j=0;j<W;j++)\n\t\t\tif(M[0][i][j]!=M[1][i][j])\n\t\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d\",&H,&W,&N),H+W+N;)\n\t{\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;M[1][i][j]=M[0][i][j],j++)\n\t\t\t\tscanf(\"%d\",&M[0][i][j]);\n\t\tfor(c=0;c<N&&(c==0||ch()==0);c++)\n\t\t{\n\t\t\tfor(y=0,x=0;y!=H&&x!=W;)\n\t\t\t{\n\t\t\t\tM[1][y][x]^=1;\n\t\t\t\tM[1][y][x]?y++:x++;\n\t\t\t}\n\t\t\tg[c][0]=y+1;\n\t\t\tg[c][1]=x+1;\n\t\t}\n\t\tif(c!=N)N%=c;\n\t\telse N--;\n\t\tprintf(\"%d %d\\n\",g[N][0],g[N][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint field[1000][1000];\nint count[1000][1000];\n\nvoid set_count(int h, int w, int n);\nvoid walk(int h, int w, int *y, int *x);\n\nint main()\n{\n\twhile (1) {\n\t\tint h, w, n;\n\t\tint i, x, y;\n\t\tscanf(\"%d %d %d\", &h, &w, &n);\n\t\tif (h == 0 && w == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tscanf(\"%d\", &field[y][x]);\n\t\t\t}\n\t\t}\n\t\tset_count(h, w, n);\n\t\twalk(h, w, &y, &x);\n\t\tprintf(\"%d %d\\n\", y+1, x+1);\n\t}\n\treturn 0;\n}\n\nvoid set_count(int h, int w, int n)\n{\n\tint x, y;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tif (y == 0 && x == 0) {\n\t\t\t\tcount[y][x] = n - 1;\n\t\t\t} else {\n\t\t\t\tint from_north, from_west;\n\n\t\t\t\tif (y == 0) {\n\t\t\t\t\tfrom_north = 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom_north = count[y-1][x] / 2;\n\t\t\t\t\tif (count[y-1][x] % 2 == 1 && field[y-1][x] == 0) {\n\t\t\t\t\t\tfrom_north += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (x == 0) {\n\t\t\t\t\tfrom_west = 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom_west = count[y][x-1] / 2;\n\t\t\t\t\tif (count[y][x-1] % 2 == 1 && field[y][x-1] == 1) {\n\t\t\t\t\t\tfrom_west += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcount[y][x] = from_north + from_west;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid walk(int h, int w, int *y, int *x)\n{\n\t*y = 0;\n\t*x = 0;\n\twhile (*y < h && *x < w) {\n\t\tint d;\n\t\td = (field[*y][*x] + count[*y][*x]) % 2;\n\t\tif (d == 0) {\n\t\t\t*y += 1;\n\t\t} else if (d == 1) {\n\t\t\t*x += 1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void) {\n   int h, w, n, key[1005][1005], x, y, i, j, k, l;\n   scanf(\"%d %d %d\", &h, &w, &n);\n   while ( 1 ) {\n      for ( i = 1; i <= h + 1; i++ ) {\n         for ( j = 1; j <= j + 1; j++ ) {\n            scanf(\"%d\", &key[i][j]);\n         }\n      }\n      for ( k = 0; k < n; k++ ) {\n         x = y = 1;\n         while (1) {\n            if ( key[y][x] == 0 ) {\n               key[y][x] = 1;\n               y++;\n            }\n            else if ( key[y][x] == 1 ) {\n               key[y][x] = 0;\n               x++;\n            }\n            if ( x == x + 1 || y == h + 1 ) break;\n         }\n      }\n      printf(\"%d %d\\n\", x, y);\n      scanf(\"%d %d %d\", &h, &w, &n);\n      if ( h == 0 && w == 0 && n == 0 ) break;\n   }\n   return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 200\n\nint main(void)\n{\n\twhile(1)\n\t{\t\n\t    int i,j,H,W,N,p[MAX][MAX],dp[MAX][MAX];\n\t    scanf(\"%d%d%d\",&H,&W,&N);\n\t\tif(H==0 && W==0 && N==0) break;\n\t    for(i=0;i<=H-1;i++)\n\t    {\n\t\t    for(j=0;j<=W-1;j++)\n\t\t    {\n\t\t\t    scanf(\"%d\",&p[i][j]);\n\t\t    }\n\t    }\n\t    for(i=0;i<=H;i++)\n\t    {\n\t\t    for(j=0;j<=W;j++)\n\t\t    {\n\t\t\t    dp[i][j]=0;\n\t\t    }\n\t    }\n\t    dp[0][0]=N-1;\n\t    for(i=0;i<=H-1;i++)\n\t    {\n\t\t    for(j=0;j<=W-1;j++)\n\t\t    {\n\t\t\t    if(dp[i][j]%2==0)\n\t\t\t    {\n\t\t\t\t    dp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t    dp[i][j+1]+=dp[i][j]/2;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t    if(p[i][j]==0)\n\t\t\t\t    {\n\t\t\t\t\t    dp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t        dp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t    }\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t    dp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t        dp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t    }\n\t\t\t\t    p[i][j]=1-p[i][j];\n\t\t\t    }\n\t\t    }\n\t    }\n\t    i=0;\n\t    j=0;\n\t    while(i!=H && j!=W)\n\t    {\n\t\t    if(p[i][j]==0)\n\t\t    {\n\t\t\t    i++;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    j++;\n\t\t    }\n\t    }\n\t    printf(\"%d %d\\n\",i+1,j+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n\nint main(void)\n{\n\twhile(1)\n\t{\t\n\t    int i,j,H,W,N,p[MAX][MAX],dp[MAX][MAX];\n\t    scanf(\"%d%d%d\",&H,&W,&N);\n\t\tif(H==0 && W==0 && N==0) break;\n\t    for(i=0;i<=H-1;i++)\n\t    {\n\t\t    for(j=0;j<=W-1;j++)\n\t\t    {\n\t\t\t    scanf(\"%d\",&p[i][j]);\n\t\t    }\n\t    }\n\t    for(i=0;i<=H;i++)\n\t    {\n\t\t    for(j=0;j<=W;j++)\n\t\t    {\n\t\t\t    dp[i][j]=0;\n\t\t    }\n\t    }\n\t    dp[0][0]=N-1;\n\t    for(i=0;i<=H-1;i++)\n\t    {\n\t\t    for(j=0;j<=W-1;j++)\n\t\t    {\n\t\t\t    if(dp[i][j]%2==0)\n\t\t\t    {\n\t\t\t\t    dp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t    dp[i][j+1]+=dp[i][j]/2;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t    if(p[i][j]==0)\n\t\t\t\t    {\n\t\t\t\t\t    dp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t        dp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t    }\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t    dp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t        dp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t    }\n\t\t\t\t    p[i][j]=1-p[i][j];\n\t\t\t    }\n\t\t    }\n\t    }\n\t    i=0;\n\t    j=0;\n\t    while(i!=H && j!=W)\n\t    {\n\t\t    if(p[i][j]==0)\n\t\t    {\n\t\t\t    i++;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    j++;\n\t\t    }\n\t    }\n\t    printf(\"%d %d\\n\",i+1,j+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1001\n\nint main(void)\n{\n\twhile(1)\n\t{\t\n\t    int i,j,H,W,N,p[MAX][MAX],dp[MAX][MAX];\n\t    scanf(\"%d%d%d\",&H,&W,&N);\n\t\tif(H==0 && W==0 && N==0) break;\n\t    for(i=0;i<=H-1;i++)\n\t    {\n\t\t    for(j=0;j<=W-1;j++)\n\t\t    {\n\t\t\t    scanf(\"%d\",&p[i][j]);\n\t\t    }\n\t    }\n\t    for(i=0;i<=H;i++)\n\t    {\n\t\t    for(j=0;j<=W;j++)\n\t\t    {\n\t\t\t    dp[i][j]=0;\n\t\t    }\n\t    }\n\t    dp[0][0]=N-1;\n\t    for(i=0;i<=H-1;i++)\n\t    {\n\t\t    for(j=0;j<=W-1;j++)\n\t\t    {\n\t\t\t    if(dp[i][j]%2==0)\n\t\t\t    {\n\t\t\t\t    dp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t    dp[i][j+1]+=dp[i][j]/2;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t    if(p[i][j]==0)\n\t\t\t\t    {\n\t\t\t\t\t    dp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t        dp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t    }\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t    dp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t        dp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t    }\n\t\t\t\t    p[i][j]=1-p[i][j];\n\t\t\t    }\n\t\t    }\n\t    }\n\t    i=0;\n\t    j=0;\n\t    while(i!=H && j!=W)\n\t    {\n\t\t    if(p[i][j]==0)\n\t\t    {\n\t\t\t    i++;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    j++;\n\t\t    }\n\t    }\n\t    printf(\"%d %d\\n\",i+1,j+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,n,x,y,i,j,t;\n  while(scanf(\"%d %d %d\",&w,&h,&n),w||h||n){\n    int d[1000][1000]={0};\n    int p[1000][1000]={0};\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&d[i][j]);\n      }\n    }\n    y=0;\n    x=0;\n    p[y][x]=n;\n    for(i=0;i<w+h;i++){\n      for(j=0;j<h;j++){\n\tif(i-j<0||w<=i-j)continue;\n\tif(d[i-j][j]){\n\t  if(p[i-j][j]%2)x++;\n\t  else\t         y++;\n\t  if(x==w||y==h)break;\n\t  p[i-j+1][j  ]+=t=p[i-j][j]/2;\n\t  p[i-j  ][j+1]+=  p[i-j][j]-t;\n\t}\n\telse{\n\t  if(p[i-j][j]%2)y++;\n\t  else\t         x++;\n\t  if(x==w||y==h)break;\n\t  p[i-j  ][j+1]+=t=p[i-j][j]/2;\n\t  p[i-j  ][j+1]+=  p[i-j][j]-t;\n\t}\n      }\n      if(x==w||y==h)break;\n    }\n    if(x==w)x++;\n    else    y++;\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint H,W,N,i,j,c,M[2][1005][1005],y,x;\n\nint ch()\n{\n\tint i,j;\n\tfor(i=0;i<H;i++)\n\t\tfor(j=0;j<W;j++)\n\t\t\tif(M[0][i][j]==M[1][i][j])\n\t\t\t\treturn 0;\n\treturn 1;\n}\n\nvoid dbg()\n{\n\tint i,j;\n\tfor(i=0;i<H;i++,puts(\"\"))\n\t\tfor(j=0;j<W;j++)\n\t\t\tprintf(\"%d \",M[1][i][j]);\n\tputs(\"\");\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d\",&H,&W,&N),H+W+N;)\n\t{\n\t\tmemset(M,0,sizeof(M));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;M[1][i][j]=M[0][i][j],j++)\n\t\t\t\tscanf(\"%d\",&M[0][i][j]);\n\t\tfor(c=0;c<N&&ch()==0;c++)\n\t\t{\n\t\t\tfor(y=0,x=0;y!=H&&x!=W;)\n\t\t\t{\n\t\t\t\tM[1][y][x]^=1;\n\t\t\t\tM[1][y][x]?y++:x++;\n\t\t\t}\n\t\t}\n\t\tif(c!=N)\n\t\t{\n\t\t\tN%=c;\n\t\t\tfor(c=0;c<N;c++)\n\t\t\t{\n\t\t\t\tfor(y=0,x=0;y!=H&&x!=W;)\n\t\t\t\t{\n\t\t\t\t\tM[1][y][x]?x++:y++;\n\t\t\t\t\tM[1][y][x]^=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//AOJ0541 DPµÄNñà¢½ãÌ¶ðvZµÄÀs\n#include<stdio.h>\n#include<string.h>\nint c[1005][1005];\nchar d[1005][1005];\nint main(){\n\tint h,w,n,i,j,x,y;\n\tFILE *fp;\n\t//fp=fopen(\"test.txt\",\"r\");\n\tfp=stdin;\n\twhile(1){\n\t\tfscanf(fp,\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(c,0,sizeof(c));\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tfscanf(fp,\"%d\",&x);\n\t\t\t\tif(x==1)d[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tc[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\t//ÅÌ¶ÉæÁÄêª¯µÄvZ\n\t\t\t\tif(d[i][j]==1){\n\t\t\t\t\tc[i][j+1]+=(c[i][j]+1)/2;\n\t\t\t\t\tc[i+1][j]+= c[i][j]   /2;\n\t\t\t\t}else{\n\t\t\t\t\tc[i][j+1]+= c[i][j]   /2;\n\t\t\t\t\tc[i+1][j]+=(c[i][j]+1)/2;\n\t\t\t\t}\n\t\t\t\t//ñãÌ(i,j)Ì¶\n\t\t\t\td[i][j]=(c[i][j]+d[i][j])%2;\n\t\t\t\t//printf(\"%d \",d[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tx=y=1;\n\t\twhile(y<=h && x<=w){\n\t\t\tif(d[y][x]==1) x++;\n\t\t\telse y++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",y,x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint h,w,n;\nbool d[1000][1000];\nint t[1000][1000];\nint i,j;\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&n);\n\t\tif(h==0)return 0;\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(x==1)d[i][j]=true;\n\t\t\tif(x==0)d[i][j]=false;\n\t\t\tt[i][j]=0;\n\t\t}\n\t\tt[0][0]=n-1;\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\t\tif(t[i][j]%2==0){\n\t\t\t\tif(i+1<h)t[i+1][j]+=t[i][j]/2;\n\t\t\t\tif(j+1<w)t[i][j+1]+=t[i][j]/2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(d[i][j]){\n\t\t\t\t\tif(i+1<h)t[i+1][j]+=t[i][j]/2;\n\t\t\t\t\tif(j+1<w)t[i][j+1]+=t[i][j]/2+1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(i+1<h)t[i+1][j]+=t[i][j]/2+1;\n\t\t\t\t\tif(j+1<w)t[i][j+1]+=t[i][j]/2;\n\t\t\t\t}\n\t\t\t\td[i][j]=!d[i][j];\n\t\t\t}\n\t\t}\n\t\tint x,y;\n\t\tx=0;\n\t\ty=0;\n\t\twhile(x!=w&&y!=h){\n\t\t\tif(d[y][x])x++;\n\t\t\telse y++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",x+1,y+1);\n\t}\n}\t"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0541\n  Title:Walk\n  @kankichi573\n*/\n#include <stdio.h>\nint H,W,N,a[1001][1001];\nvoid walk(int *y ,int *x)\n{ \n  if(a[*y][*x]==0)\n    {\n      a[*y][*x]=-1;\n      (*y)++;\n    }\n  else\n    {\n      a[*y][*x]=0;\n      (*x)++;\n    }\n  //printf(\"yx=%d %d\\n\",*y,*x);\n}\nmain()\n{\n  int i,j,x,y;\n\n  while(scanf(\"%d %d %d\",&H,&W,&N) && (H||W||N))\n    {\n      for(i=0;i<H;i++)\n\tfor(j=0;j<W;j++)\n\t  scanf(\"%d\",&a[i][j]);\n      for(i=0;i<N;i++)\n\t{\n\t  x=y=0;\n\t  while(y<H && x < W)\n\t    walk(&y,&x);\n\t  //printf(\"*\\n\");\n\t}\n      printf(\"%d %d\\n\",y+1,x+1);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define W 100\n#define H 100\n\nstatic int d[ W ][ H ];\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int x = 0, y = 0;\n  int h, w, n;\n  int i, j;\n\n  scanf ( \"%d%d%d\", &h, &w, &n );\n  for ( j = 0; j < h; ++j )\n  for ( i = 0; i < w; ++i )\n    scanf ( \"%d\", &d[ i ][ j ] );\n\n  while ( n-- )\n  {\n    x = 0; y = 0;\n\n    while ( x != w && y != h )\n    {\n      switch ( d[ x ][ y ] )\n      {\n        case 0: d[ x ][ y++ ] = 1; break ;\n        case 1: d[ x++ ][ y ] = 0; break ;\n      }\n    }\n  }\n\n  printf ( \"%d %d\\n\", x + 1, y + 1 );\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint H,W,N,i,j,c,M[2][1005][1005],g[1000005][2],y,x;\n\nvoid dbg()\n{\n\tint i,j;\n\tfor(i=0;i<H;i++,puts(\"\"))\n\t\tfor(j=0;j<W;j++)\n\t\t\tprintf(\"%d \",M[1][i][j]);\n\tputs(\"\");\n}\n\nint ch()\n{\n\tint i,j;\n\tfor(i=0;i<H;i++)\n\t\tfor(j=0;j<W;j++)\n\t\t\tif(M[0][i][j]!=M[1][i][j])\n\t\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d\",&H,&W,&N),H+W+N;)\n\t{\n\t\tmemset(M,0,sizeof(M));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;M[1][i][j]=M[0][i][j],j++)\n\t\t\t\tscanf(\"%d\",&M[0][i][j]);\n\t\tfor(c=0;c<N&&(c==0||ch()==0);c++)\n\t\t{\n\t\t\tfor(y=0,x=0;y!=H&&x!=W;)\n\t\t\t{\n\t\t\t\tM[1][y][x]^=1;\n\t\t\t\tM[1][y][x]?y++:x++;\n\t\t\t}\n\t\t\tg[c][0]=y+1;\n\t\t\tg[c][1]=x+1;\n\t\t}\n\t\tif(c!=N)N%=c;\n\t\telse N--;\n\t\tprintf(\"%d %d\\n\",g[N][0],g[N][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(){\n  while(1){\n    int h, w, n;\n    int i, j;\n    int field[1001][1001], dp[1001][1001];\n    memset(field, -1, sizeof(field));\n    memset(dp, 0, sizeof(dp));\n    scanf(\"%d%d%d\", &h, &w, &n);\n    if(h == 0 && w == 0 && n == 0)return 0;\n    for(i = 0;i < h;i++){\n      for(j = 0;j < w;j++){\n\tscanf(\"%d\", &field[i][j]);\n      }\n    }\n    dp[0][0] = n;\n    for(i = 0;i < h;i++){\n      for(j = 0;j < w;j++){\n\tif(field[i][j] == 0){\n\t  dp[i][j + 1] += dp[i][j] / 2;\n\t  dp[i + 1][j] += dp[i][j] - dp[i][j] / 2;\n\t}\n\telse{\n\t  dp[i + 1][j] += dp[i][j] / 2;\n\t  dp[i][j + 1] += dp[i][j] - dp[i][j] / 2;\n\t}\n\tfield[i][j] += dp[i][j];\n\tfield[i][j] %= 2;\n      }\n    }\n    int pi = 0, pj = 0;\n    while(field[pi][pj] != -1){\n      if(field[pi][pj] == 1){\n\tpi++;\n      }\n      else pj++;\n    }\n    printf(\"%d %d\\n\", pi + 1, pj + 1);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,n,x,y,i,j,t;\n  while(scanf(\"%d %d %d\",&w,&h,&n),w||h||n){\n    int d[1000][1000]={0};\n    int p[1000][1000]={0};\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&d[i][j]);\n      }\n    }\n    p[y=0][x=0]=n;\n    for(i=0;i<w+h;i++){\n      for(j=0;j<h;j++){\n\tif(i-j<0||w<=i-j)continue;\n\tif(d[i-j][j]){\n\t  if(p[i-j][j]%2)x++;\n\t  else\t         y++;\n\t  if(x==w||y==h)break;\n\t  p[i-j+1][j  ]+=t=p[i-j][j]/2;\n\t  p[i-j  ][j+1]+=  p[i-j][j]-t;\n\t}\n\telse{\n\t  if(p[i-j][j]%2)y++;\n\t  else\t         x++;\n\t  if(x==w||y==h)break;\n\t  p[i-j  ][j+1]+=t=p[i-j][j]/2;\n\t  p[i-j  ][j+1]+=  p[i-j][j]-t;\n\t}\n      }\n      if(x==w||y==h)break;\n    }\n    if(x==w)x++;\n    else    y++;\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint H,W,N,i,j,c,M[1005][1005],dp[1005][1005],y,x,f;\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d\",&H,&W,&N),H+W+N;)\n\t{\n\t\tmemset(dp,0,sizeof(M));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;j++)\n\t\t\t\tscanf(\"%d\",&M[i][j]);\n\t\tdp[0][0]=N;\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]%2)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2+(M[i][j]==1?1:0);\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+(M[i][j]==0?1:0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(y=0,x=0;y!=H&&x!=W;)\n\t\t\t{\n\t\t\t\tif(dp[y][x]%2==0)M[y][x]^=1;\n\t\t\t\tM[y][x]?x++:y++;\n\t\t\t}\n\t\tprintf(\"%d %d\\n\",y+1,x+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,n,x,y,i,j,t;\n  while(scanf(\"%d %d %d\",&h,&w,&n),w||h||n){\n    int d[1000][1000]={0};\n    int p[1000][1000]={0};\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&d[i][j]);\n      }\n    }\n    y=0;\n    x=0;\n    p[y][x]=n;\n    for(i=0;i<w+h-1;i++){\n      for(j=0;j<h;j++){\n\tif(i-j<0||w<=i-j)continue;\n\tint k,l;\n\t/*for(k=0;k<h;k++){\n\t  for(l=0;l<w;l++)printf(\"%d \",p[k][l]);\n\t  printf(\"\\n\");\n\t  }printf(\"\\n\");*/\n\tif(d[j][i-j]){\n\t  if(j==y&&i-j==x){\n\t    if(p[j][i-j]%2)x++;\n\t    else\t         y++;\n\t    if(x==w||y==h)break;\n\t  }\n\t  p[j+1][i-j  ]+=t=p[j][i-j]/2;\n\t  p[j  ][i-j+1]+=  p[j][i-j]-t;\n\t}\n\telse{\n\t  if(j==y&&i-j==x){\n\t    if(p[j][i-j]%2)y++;\n\t    else\t         x++;\n\t    if(x==w||y==h)break;\n\t  }\n\t  p[j  ][i-j+1]+=t=p[j][i-j]/2;\n\t  p[j+1][i-j  ]+=  p[j][i-j]-t;\n\t}\n      }\n      if(x==w||y==h)break;\n    }\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void) {\n   long h, w, n, key[100][100], x, y, i, j, k, l;\n   scanf(\"%ld %ld %ld\", &h, &w, &n);\n   while ( 1 ) {\n      for ( i = 1; i <= h; i++ ) {\n         for ( j = 1; j <= w; j++ ) {\n            scanf(\"%ld\", &key[i][j]);\n         }\n      }\n      for ( k = 0; k < n; k++ ) {\n         x = y = 1;\n         while (1) {\n            if ( key[y][x] == 0 ) {\n               key[y][x] = 1;\n               y++;\n            }\n            else if ( key[y][x] == 1 ) {\n               key[y][x] = 0;\n               x++;\n            }\n            if ( x == w + 1 || y == h + 1 ) break;\n         }\n      }\n      printf(\"%ld %ld\\n\", y, x);\n      scanf(\"%ld %ld %ld\", &h, &w, &n);\n      if ( h == 0 && w == 0 && n == 0 ) break;\n   }\n   return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void) {\n   int h, w, n, key[1005][1005], x, y, i, j, k, l;\n   scanf(\"%d %d %d\", &h, &w, &n);\n   while ( 1 ) {\n      for ( i = 1; i <= h + 1; i++ ) {\n         for ( j = 1; j <= j + 1; j++ ) {\n            scanf(\"%d\", &key[i][j]);\n         }\n      }\n      for ( k = 0; k < n; k++ ) {\n         x = y = 1;\n         while (1) {\n            if ( key[y][x] == 0 ) {\n               key[y][x] = 1;\n               y++;\n            }\n            else if ( key[y][x] == 1 ) {\n               key[y][x] = 0;\n               x++;\n            }\n            if ( x == j + 1 || y == h + 1 ) break;\n         }\n      }\n      printf(\"%d %d\\n\", x, y);\n      scanf(\"%d %d %d\", &h, &w, &n);\n      if ( h == 0 && w == 0 && n == 0 ) break;\n   }\n   return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,n,x,y,i,j,t;\n  while(scanf(\"%d %d %d\",&w,&h,&n),w||h||n){\n    int d[1000][1000]={0};\n    int p[1000][1000]={0};\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&d[i][j]);\n      }\n    }\n    y=0;\n    x=0;\n    p[y][x]=n;\n    for(i=0;i<w+h-1;i++){\n      for(j=0;j<h;j++){\n\tif(i-j<0||w<=i-j)continue;\n\tif(d[i-j][j]){\n\t  if(p[i-j][j]%2)x++;\n\t  else\t         y++;\n\t  if(x==w||y==h)break;\n\t  p[i-j+1][j  ]+=t=p[i-j][j]/2;\n\t  p[i-j  ][j+1]+=  p[i-j][j]-t;\n\t}\n\telse{\n\t  if(p[i-j][j]%2)y++;\n\t  else\t         x++;\n\t  if(x==w||y==h)break;\n\t  p[i-j  ][j+1]+=t=p[i-j][j]/2;\n\t  p[i-j  ][j+1]+=  p[i-j][j]-t;\n\t}\n      }\n      if(x==w||y==h)break;\n    }\n    if(x==w)x++;\n    else    y++;\n    printf(\"%d %d\\n\",y+1,x+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(){\n  while(1){\n    int h, w, n;\n    int i, j;\n    int field[1000][1000], dp[1000][1000];\n    memset(field, -1, sizeof(field));\n    scanf(\"%d%d%d\", &h, &w, &n);\n    if(h == 0 && w == 0 && n == 0)return 0;\n    for(i = 0;i < h;i++){\n      for(j = 0;j < w;j++){\n\tscanf(\"%d\", &field[i][j]);\n      }\n    }\n    dp[0][0] = n;\n    for(i = 0;i < h;i++){\n      for(j = 0;j < w;j++){\n\tif(field[i][j] == 0){\n\t  dp[i][j + 1] += dp[i][j] / 2;\n\t  dp[i + 1][j] += dp[i][j] - dp[i][j] / 2;\n\t}\n\telse{\n\t  dp[i + 1][j] += dp[i][j] / 2;\n\t  dp[i][j + 1] += dp[i][j] - dp[i][j] / 2;\n\t}\n\tfield[i][j] += dp[i][j];\n\tfield[i][j] %= 2;\n      }\n    }\n    int pi = 0, pj = 0;\n    while(field[pi][pj] != -1){\n      if(field[pi][pj] == 1){\n\tpi++;\n      }\n      else pj++;\n    }\n    printf(\"%d %d\\n\", pi + 1, pj + 1);\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0541: Walk\n// 2017.10.28 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar map[1002][1002];\nint dp[1002][1002];\n\nchar buf[3002], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint h, w, n, r, c;\n\n\twhile (fgets(p=buf, 32, stdin) && *buf != '0') {\n\t\th = getint(), p++, w = getint(), p++, n = getint();\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfgets(p=buf, 3000, stdin);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tmap[r][c] = *p++ & 1, p++;\n\t\t\t}\n\t\t}\n   \n\t\tmemset(dp, 0, sizeof(dp));\n\t    dp[0][0] = n - 1;\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\t\tif (r+1 < h) dp[r+1][c] += (dp[r][c] - map[r][c]+1) / 2;\n\t\t\tif (c+1 < w) dp[r][c+1] += (dp[r][c] + map[r][c]) / 2;\n\t\t}\n\n\t\tr = c = 0;\n\t    while (r < h && c < w) {\n\t      if ((dp[r][c] + map[r][c]) & 1) c++;\n\t      else r++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", r+1, c+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n    int i, j;\n    int x, y, n;\n    static int map[1001][1001], dp[1001][1001];\n    \n    while (1){\n        scanf(\"%d%d%d\", &y, &x, &n);\n        \n        if (x + y + n == 0){\n            break;\n        }\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%d\", &map[i][j]); //1 -> (i, j + 1) 0 -> (i + 1, j)\n            }\n        }\n        \n        memset(dp, 0, sizeof(dp));\n        \n        dp[1][1] = n;\n        for (i = 2; i <= x; i++){\n            dp[1][i] += (dp[1][i - 1] / 2);\n            if (dp[1][i - 1] % 2 == 1 && map[1][i - 1] == 1){\n                dp[1][i]++;\n            }\n        }\n        \n        for (i = 2; i <= y; i++){\n            dp[i][1] += (dp[i - 1][1] / 2);\n            if (dp[i - 1][1] % 2 == 1 && map[i - 1][1] == 0){\n                dp[i][1]++;\n            }\n        }\n        \n        for (i = 2; i <= y; i++){\n            for (j = 2; j <= x; j++){\n                dp[i][j] = (dp[i][j - 1] / 2) + (dp[i - 1][j] / 2);\n                if (dp[i][j - 1] % 2 == 1 && map[i][j - 1] == 1){\n                    dp[i][j]++;\n                }\n                if (dp[i - 1][j] % 2 == 1 && map[i - 1][j] == 0){\n                    dp[i][j]++;\n                }\n            }\n        }\n        \n        i = j = 1;\n        while (i != y + 1 && j != x + 1){\n            if (dp[i][j] % 2 == 1){\n                if (map[i][j] == 1){\n                    j += 1;\n                }\n                else {\n                    i += 1;\n                }\n            }\n            else {\n                if (map[i][j] == 1){\n                    i += 1;\n                }\n                else {\n                    j += 1;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", i, j);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void) {\n   int h, w, n, key[1005][1005], x, y, i, j, k, l;\n   scanf(\"%d %d %d\", &h, &w, &n);\n   while ( 1 ) {\n      for ( i = 1; i <= h + 1; i++ ) {\n         for ( j = 1; j <= w + 1; j++ ) {\n            scanf(\"%d\", &key[i][j]);\n         }\n      }\n      for ( k = 0; k < n; k++ ) {\n         x = y = 1;\n         while (1) {\n            if ( key[y][x] == 0 ) {\n               key[y][x] = 1;\n               y++;\n            }\n            else if ( key[y][x] == 1 ) {\n               key[y][x] = 0;\n               x++;\n            }\n            if ( x == w + 1 || y == h + 1 ) break;\n         }\n      }\n      printf(\"%d %d\\n\", x, y);\n      scanf(\"%d %d %d\", &h, &w, &n);\n      if ( h == 0 && w == 0 && n == 0 ) break;\n   }\n   return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\nusing namespace std;\nint h,w,n,i,j;\nint kan[10000][10000];\nint dp[10000][10000];\nint main(void){\n\tscanf(\"%d %d %d\",&h,&w,&n);\n\twhile(h!=0 && w!=0 && n!=0){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&kan[i][j]);\t//kan=kanbann\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1]=n-1;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(kan[i][j]==1){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tdp[i][j+1]+=(dp[i][j]/2)+1;\n\t\t\t\t\t\tdp[i+1][j]+=(dp[i][j]/2);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j+1]=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(kan[i][j]==0){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tdp[i][j+1]+=(dp[i][j]/2);\n\t\t\t\t\t\tdp[i+1][j]+=(dp[i][j]/2)+1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j+1]=dp[i][j]/2;\n\t\t\t\t\t\tdp[i+1][j]=dp[i][j]/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(dp[i][j]!=0){\n\t\t\t\t\tif(dp[i][j]%2==1){\n\t\t\t\t\t\tif(kan[i][j]==0){\n\t\t\t\t\t\t\tkan[i][j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(kan[i][j]==1){\n\t\t\t\t\t\t\tkan[i][j]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti=1;\n\t\tj=1;\n\t\t//printf(\"%d %d\\n\",h,w);\n\t\twhile(i<h+1 || j<w+1){\n\t\t\tif(kan[i][j]==1){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(kan[i][j]==0){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(i==h+1 || j==w+1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",i,j);\t\n\t\t/*for(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tprintf(\"%d \",kan[i][j]);\t\t\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tscanf(\"%d &d %d\\n\",&h,&w,&n);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint H,W,N,i,j,c,M[2][1005][1005],g[1000005][2],y,x,f;\n\nvoid dbg()\n{\n\tint i,j;\n\tfor(i=0;i<H;i++,puts(\"\"))\n\t\tfor(j=0;j<W;j++)\n\t\t\tprintf(\"%d \",M[1][i][j]);\n\tputs(\"\");\n}\n\nint ch()\n{\n\tint i,j;\n\tfor(i=0;i<H;i++)\n\t\tfor(j=0;j<W;j++)\n\t\t\tif(M[0][i][j]!=M[1][i][j])\n\t\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d\",&H,&W,&N),H+W+N;)\n\t{\n\t\tmemset(M,0,sizeof(M));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;M[1][i][j]=M[0][i][j],j++)\n\t\t\t\tscanf(\"%d\",&M[0][i][j]);\n\t\tfor(c=f=0;c<N&&(c==0||f!=0||ch()==0);c++)\n\t\t{\n\t\t\tf=0;\n\t\t\tfor(y=0,x=0;y!=H&&x!=W;)\n\t\t\t{\n\t\t\t\tM[1][y][x]^=1;\n\t\t\t\tif(M[1][y][x]!=M[0][y][x])f=1;\n\t\t\t\tM[1][y][x]?y++:x++;\n\t\t\t}\n\t\t\tg[c][0]=y+1;\n\t\t\tg[c][1]=x+1;\n\t\t}\n\t\tif(c!=N)N%=c;\n\t\telse N--;\n\t\tprintf(\"%d %d\\n\",g[N][0],g[N][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint main(void)\n{\n\tint i,j,H,W,N,p[MAX][MAX],dp[MAX][MAX];\n\tscanf(\"%d%d%d\",&H,&W,&N);\n\tfor(i=0;i<=H-1;i++)\n\t{\n\t\tfor(j=0;j<=W-1;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&p[i][j]);\n\t\t}\n\t}\n\tfor(i=0;i<=H;i++)\n\t{\n\t\tfor(j=0;j<=W;j++)\n\t\t{\n\t\t\tdp[i][j]=0;\n\t\t}\n\t}\n\tdp[0][0]=N-1;\n\tfor(i=0;i<=H-1;i++)\n\t{\n\t\tfor(j=0;j<=W-1;j++)\n\t\t{\n\t\t\tif(dp[i][j]%2==0)\n\t\t\t{\n\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\tdp[i][j+1]+=dp[i][j]/2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(p[i][j]==0)\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t    dp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t    dp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t}\n\t\t\t\tp[i][j]=1-p[i][j];\n\t\t\t}\n\t\t}\n\t}\n\ti=0;\n\tj=0;\n\twhile(i!=H && j!=W)\n\t{\n\t\tif(p[i][j]==0)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",i+1,j+1);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint field[1000][1000];\nvoid walk(int h, int w, int *y, int *x);\n\nint main()\n{\n\twhile (1) {\n\t\tint h, w, n;\n\t\tint i, x, y;\n\t\tscanf(\"%d %d %d\", &h, &w, &n);\n\t\tif (h == 0 && w == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tscanf(\"%d\", &field[y][x]);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\twalk(h, w, &y, &x);\n\t\t}\n\t\tprintf(\"%d %d\\n\", y+1, x+1);\n\t}\n\treturn 0;\n}\n\nvoid walk(int h, int w, int *y, int *x)\n{\n\t*y = 0;\n\t*x = 0;\n\twhile (*y < h && *x < w) {\n\t\tint d;\n\t\td = field[*y][*x];\n\t\tfield[*y][*x] = 1 - d;\n\t\tif (d == 0) {\n\t\t\t*y += 1;\n\t\t} else if (d == 1) {\n\t\t\t*x += 1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void) {\n   int h, w, n, key[1005][1005], x, y, i, j, k, l;\n   scanf(\"%d %d %d\", &h, &w, &n);\n   while ( 1 ) {\n      for ( i = 1; i <= h + 1; i++ ) {\n         for ( j = 1; j <= j + 1; j++ ) {\n            scanf(\"%d\", &[i][j]);\n         }\n      }\n      for ( k = 0; k < n; k++ ) {\n         x = y = 1;\n         while () {\n            if ( key[y][x] == 0 ) {\n               key[y][x] = 1;\n               y++;\n            }\n            else if ( key[y][x] == 1 ) {\n               key[y][x] = 0;\n               x++;\n            }\n            if ( x == x + 1 || y == h + 1 ) break\n         }\n      }\n      printf(\"%d %d\\n\", x, y);\n      scanf(\"%d %d %d\", &h, &w, &n);\n      if ( h == 0 && w == 0 && n == 0 ) break;\n   }\n   return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint t[1002][1002];\nint dp[1002][1002];\n\nint main(void){\n\tint i,j,ti,tj;\n\tint w,h,n;\n\tint d,gx,gy;\n\n\twhile(scanf(\"%d%d%d\",&h,&w,&n) && (h||w||n)){\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%d\",&t[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0] = n;\n\t\tgx = 0, gy = 0;\n\n\t\tfor(tj=0;tj<w && gx<w && gy<h;tj++){\n\t\t\tfor(i=0;i<h && 0<=tj-i && gx<w && gy<h;i++){\n\t\t\t\td = 0;\n\t\t\t\tj = tj - i;\n\n\t\t\t\tif(dp[i][j] % 2 == 0){\n\t\t\t\t\td = !t[i][j];\n\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\td = t[i][j];\n\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2 + d;\n\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2 + !d;\n\t\t\t\t}\n\t\t\t\tif(gx == j && gy == i){\n\t\t\t\t\tgx += d;\n\t\t\t\t\tgy += !d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(ti=1;ti<h && gx<w && gy<h;ti++){\n\t\t\tfor(tj=0;tj<w && ti+tj<h && gx<w && gy<h;tj++){\n\t\t\t\td = 0;\n\t\t\t\ti = ti + tj;\n\t\t\t\tj = w - tj - 1;\n\n\t\t\t\tif(dp[i][j] % 2 == 0){\n\t\t\t\t\td = !t[i][j];\n\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\td = t[i][j];\n\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2 + d;\n\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2 + !d;\n\t\t\t\t}\n\t\t\t\tif(gx == j && gy == i){\n\t\t\t\t\tgx += d;\n\t\t\t\t\tgy += !d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %d\\n\",gy+1,gx+1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint main(void)\n{\n\twhile(1)\n\t{\n\t\t\n\t    int i,j,H,W,N,p[MAX][MAX],dp[MAX][MAX];\n\t    scanf(\"%d%d%d\",&H,&W,&N);\n\t\tif(H==0 && W==0 && N==0) break;\n\t    for(i=0;i<=H-1;i++)\n\t    {\n\t\t    for(j=0;j<=W-1;j++)\n\t\t    {\n\t\t\t    scanf(\"%d\",&p[i][j]);\n\t\t    }\n\t    }\n\t    for(i=0;i<=H;i++)\n\t    {\n\t\t    for(j=0;j<=W;j++)\n\t\t    {\n\t\t\t    dp[i][j]=0;\n\t\t    }\n\t    }\n\t    dp[0][0]=N-1;\n\t    for(i=0;i<=H-1;i++)\n\t    {\n\t\t    for(j=0;j<=W-1;j++)\n\t\t    {\n\t\t\t    if(dp[i][j]%2==0)\n\t\t\t    {\n\t\t\t\t    dp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t    dp[i][j+1]+=dp[i][j]/2;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t    if(p[i][j]==0)\n\t\t\t\t    {\n\t\t\t\t\t    dp[i+1][j]+=dp[i][j]/2+1;\n\t\t\t\t        dp[i][j+1]+=dp[i][j]/2;\n\t\t\t\t    }\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t    dp[i+1][j]+=dp[i][j]/2;\n\t\t\t\t        dp[i][j+1]+=dp[i][j]/2+1;\n\t\t\t\t    }\n\t\t\t\t    p[i][j]=1-p[i][j];\n\t\t\t    }\n\t\t    }\n\t    }\n\t    i=0;\n\t    j=0;\n\t    while(i!=H && j!=W)\n\t    {\n\t\t    if(p[i][j]==0)\n\t\t    {\n\t\t\t    i++;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    j++;\n\t\t    }\n\t    }\n\t    printf(\"%d %d\\n\",i+1,j+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nimport java.lang.Math.abs\n\nfun main(args:Array<String>):Unit {\n    while (true) {\n        val (h, w, n) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (h == 0 && w == 0 && n == 0) return\n        val street = Array(h){readLine()!!.trim().split(' ').map{\n            when(it){\n                \"0\" -> Direction.South\n                else -> Direction.East\n            }\n        }.toTypedArray()}\n        var x = 0\n        var y = 0\n        var num = n - 1\n        while (x < w && y < h){\n            val dire = if (num % 2 == 1) inverse(street[y][x]) else street[y][x]\n            when(dire) {\n                Direction.East -> ++x\n                Direction.South -> ++y\n            }\n            num /= 2\n        }\n        println(\"${y + 1} ${x + 1}\")\n    }\n}\nfun inverse(direction: Direction):Direction{\n    return when(direction){\n        Direction.East -> Direction.South\n        Direction.South -> Direction.East\n    }\n}\nenum class Direction{\n    South, East\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\tlong startCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0540_input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint h = scan.nextInt();\n\t\t\tif (h == 0)\n\t\t\t\tbreak;\n\t\t\tint w = scan.nextInt();\n\t\t\tint n = scan.nextInt();\n\t\t\tWalk walk = new Walk(h, w);\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\twalk.set(i, j, scan.nextInt());\n\t\t\tint r = walk.end(n);\n\t\t\tif (r > 0)\n\t\t\t\tSystem.out.println((h + 1) + \" \" + r);\n\t\t\telse\n\t\t\t\tSystem.out.println((-1 * r) + \" \" + (w + 1));\n\t\t}\n\n\t\tscan.close();\n\t\tlong stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\t\t// System.out.println(\"CPU=\" + (stopCpuTime - startCpuTime) / 1000000);\n\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Walk {\n\tint[][] cr;\n\n\tpublic Walk(int h, int w) {\n\t\tcr = new int[h][w];\n\t}\n\n\tpublic int end(int n) {\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tthis.move(0, 0);\n\t\treturn this.move(0, 0);\n\t}\n\n\tprivate int move(int h, int w) {\n\t\tif (h >= cr.length)\n\t\t\treturn (w + 1);\n\t\tif (w >= cr[0].length)\n\t\t\treturn (-1 * (h + 1));\n\t\tif (cr[h][w] == 0) {\n\t\t\tcr[h][w] = 1;\n\t\t\treturn move(h + 1, w);\n\t\t} else {\n\t\t\tcr[h][w] = 0;\n\t\t\treturn move(h, w + 1);\n\t\t}\n\t}\n\n\tpublic void set(int h, int w, int d) {\n\t\tcr[h][w] = d;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint h,w,n;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint [][] dp = new int[1000+1][1000+1];\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt() ;\n\t\t\tif((h|w|n) == 0) break;\n\t\t\tn--;\n\t\t\tint [][] inputroad = new int[h+1][w+1];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tinputroad[i][j] = sc.nextInt();\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t\tinputroad[i][w] = -1;\n\t\t\t\tdp[i][w] = 0;\n\t\t\t}\n\t\t\tfor(int i = 0; i <= w; i++){\n\t\t\t\tinputroad[h][i] = -1;\n\t\t\t\tdp[h][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tdp[0][0] = n;\n\t\t\tint indI = 0, indJ = 0;\n\t\t\tboolean flg = false;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tint temp = dp[i][j] / 2;\n\t\t\t\t\tdp[i][j+1] += temp;\n\t\t\t\t\tdp[i+1][j] += temp;\n\t\t\t\t\tif(dp[i][j] %2 == 1){\n\t\t\t\t\t\tif(inputroad[i][j] == 0){\n\t\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinputroad[i][j] = (inputroad[i][j] + 1) % 2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == indI && j == indJ){\n\t\t\t\t\t\tif(inputroad[indI][indJ] == 0){\n\t\t\t\t\t\t\tindI++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tindJ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(inputroad[indI][indJ] == -1){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\tSystem.out.println((indI + 1) + \" \" + (indJ + 1));\n\t\t\t\n\t\t\t//debug\n//\t\t\tfor(int i = 0; i <= h; i++){\n//\t\t\t\tfor(int j = 0; j <= w; j++){\n//\t\t\t\t\tSystem.out.print(dp[i][j] + \" \" );\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//Walk\npublic class Main{\n\tint h, w, n;\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif((h|w|n)==0)break;\n\t\t\tint[][] m = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=sc.nextInt();\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tdp[0][0] = n-1;\n\t\t\tfor(int j=1;j<w;j++)dp[0][j]=(dp[0][j-1]+m[0][j-1])/2;\n\t\t\tfor(int i=1;i<h;i++)dp[i][0]=(dp[i-1][0]+(m[i-1][0]+1)%2)/2;\n\t\t\tfor(int i=1;i<h;i++){\n\t\t\t\tfor(int j=1;j<w;j++){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j]+(m[i-1][j]+1)%2)/2 + (dp[i][j-1]+m[i][j-1])/2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\twhile(!(x==w||y==h)){\n\t\t\t\tif((dp[y][x]+m[y][x])%2==0)y++;\n\t\t\t\telse x++;\n\t\t\t}\n\t\t\tSystem.out.println(++y+\" \"+ ++x);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint h,w,n;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint [][] dp = new int[1000+1][1000+1];\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt() ;\n\t\t\tif((h|w|n) == 0) break;\n\t\t\tn--;\n\t\t\tint [][] inputroad = new int[h+1][w+1];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tinputroad[i][j] = sc.nextInt();\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t\tinputroad[i][w] = -1;\n\t\t\t\tdp[i][w] = 0;\n\t\t\t}\n\t\t\tfor(int i = 0; i <= w; i++){\n\t\t\t\tinputroad[h][i] = -1;\n\t\t\t\tdp[h][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tdp[0][0] = n;\n\t\t\tint indI = 0, indJ = 0;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2;\n\t\t\t\t\tif(dp[i][j] %2 == 1){\n\t\t\t\t\t\tif(inputroad[i][j] == 0){\n\t\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinputroad[i][j] = (inputroad[i][j] + 1) % 2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == indI && j == indJ){\n\t\t\t\t\t\tif(inputroad[indI][indJ] == 0){\n\t\t\t\t\t\t\tindI++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tindJ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((indI + 1) + \" \" + (indJ + 1));\n\t\t\t\n\t\t\t//debug\n//\t\t\tfor(int i = 0; i <= h; i++){\n//\t\t\t\tfor(int j = 0; j <= w; j++){\n//\t\t\t\t\tSystem.out.print(dp[i][j] + \" \" );\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n \nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while(true) {\n            int h = sc.nextInt();\n            int w = sc.nextInt();\n            int n = sc.nextInt();\n            if(h == 0 && w == 0 && n == 0) break;\n            int[][] status = new int[h][w];\n            for(int i = 0; i < h; i++) {\n                for(int j = 0; j < w; j++) {\n                    status[i][j] = sc.nextInt();\n                }\n            }\n             \n            int[][] dp1 = new int[h+1][w+1];\n            dp1[0][0] = n-1;\n            for(int i = 0; i < h; i++) {\n                for(int j = 0; j < w; j++) {\n                        if(status[i][j] == 0) {\n                            dp1[i+1][j] += dp1[i][j]/2 + ((dp1[i][j] % 2 == 0)?0:1);\n                        }\n                        else {\n                            dp1[i+1][j] += dp1[i][j]/2;\n                        }\n                        if(status[i][j] == 0) {\n                            dp1[i][j+1] += dp1[i][j]/2;\n                        }\n                        else {\n                            dp1[i][j+1] += dp1[i][j]/2 + ((dp1[i][j] % 2 == 0)?0:1);\n                        }\n                }\n            }\n            int[][] dp2 = new int[h+1][w+1];\n            dp2[0][0] = n;\n            for(int i = 0; i < h; i++) {\n                for(int j = 0; j < w; j++) {\n                        if(status[i][j] == 0) {\n                            dp2[i+1][j] += dp2[i][j]/2 + ((dp2[i][j] % 2 == 0)?0:1);\n                        }\n                        else {\n                            dp2[i+1][j] += dp2[i][j]/2;\n                        }\n                        if(status[i][j] == 0) {\n                            dp2[i][j+1] += dp2[i][j]/2;\n                        }\n                        else {\n                            dp2[i][j+1] += dp2[i][j]/2 + ((dp2[i][j] % 2 == 0)?0:1);;\n                        }\n                }\n            }\n            int nowx = 0;\n            int nowy = 0;\n             \n            while(nowx != w && nowy != h) {\n                if(dp1[nowy+1][nowx] < dp2[nowy+1][nowx]) nowy++;\n                else nowx++;\n            }\n            System.out.println((nowy+1) + \" \" + (nowx+1));\n        }\n    }\n}\n             \n        "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(h == 0 && w == 0 && n == 0) break;\n\t\t\tint[][] status = new int[h][w];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tstatus[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] dp1 = new int[h+1][w+1];\n\t\t\tdp1[0][0] = n-1;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\t\tif(status[i][j] == 1) {\n\t\t\t\t\t\t\tdp1[i+1][j] = dp1[i][j]/2+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp1[i+1][j] = dp1[i][j]/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(status[i][j] == 1) {\n\t\t\t\t\t\t\tdp1[i][j+1] = dp1[i][j]/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp1[i][j+1] = dp1[i][j]/2 + 1;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp2 = new int[h+1][w+1];\n\t\t\tdp2[0][0] = n;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\t\tif(status[i][j] == 1) {\n\t\t\t\t\t\t\tdp2[i+1][j] = dp2[i][j]/2+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp2[i+1][j] = dp2[i][j]/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(status[i][j] == 1) {\n\t\t\t\t\t\t\tdp2[i][j+1] = dp2[i][j]/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp2[i][j+1] = dp2[i][j]/2 + 1;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowx = 0;\n\t\t\tint nowy = 0;\n\t\t\t\n\t\t\twhile(nowx != w && nowy != h) {\n\t\t\t\tif(dp1[nowy+1][nowx] < dp2[nowy+1][nowx]) nowy++;\n\t\t\t\telse nowx++;\n\t\t\t}\n\t\t\tSystem.out.println((nowy+1) + \" \" + (nowx+1));\n\t\t}\n\t}\n}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = scanner.nextInt();\n\t\t\tint w = scanner.nextInt();\n\t\t\tint n = scanner.nextInt();\n\t\t\tif ((h | w | n) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h + 1][w + 1];\n\t\t\tmap[0][0] = --n;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint m = scanner.nextInt();\n\t\t\t\t\tmap[i][j + 1] += (map[i][j] + (m & 1)) / 2;\n\t\t\t\t\tmap[i+1][j] +=(map[i][j]+(m^1))/2;\n\t\t\t\t\tmap[i][j] = (map[i][j]+m)%2;\n\t\t\t\t}\n\t\t\tint px = 0;\n\t\t\tint py = 0;\n\t\t\twhile (px < w && py < h) {\n\t\t\t\tif (map[py][px] == 1)\n\t\t\t\t\tpx++;\n\t\t\t\telse\n\t\t\t\t\tpy++;\n\t\t\t}\n\t\t\tSystem.out.println((py + 1) + \" \" + (px + 1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h, w, n;\n\t\tint a[][];\n\t\tint x, y;\n\n\t\twhile (true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif ((h | w | n) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ta = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ta[i][j]= sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = y = 1;\n\t\t\twhile (n-- != 0) {\n\t\t\t\tx = y = 1;\n\t\t\t\twhile (x <= w && y <= h) {\n\t\t\t\t\tif (a[y - 1][x - 1] == 0) {\n\t\t\t\t\t\ta[y - 1][x - 1]++;\n\t\t\t\t\t\ta[y - 1][x - 1] %= 2;\n\t\t\t\t\t\ty++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta[y - 1][x - 1]++;\n\t\t\t\t\t\ta[y - 1][x - 1] %= 2;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(y + \" \" + x);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nclass Main{\n    public static void main(String[] args){\n    BufferedReader sc=new BufferedReader(new InputStreamReader(System.in));\n    try {\n\twhile(true){\n\tString[] st = sc.readLine().split(\" \");\n\tint h = Integer.valueOf(st[0]);\n\tint w = Integer.valueOf(st[1]);\n\tint n = Integer.valueOf(st[2]);\n\tif(h==0 && w==0 && h==0) break;\n\tint[][] map = new int[h][w];\n\tfor(int i=0; i<h; i++){\n\tString[] sp = sc.readLine().split(\" \");\n\tfor(int j=0; j<w; j++){\n\tif(sp[j].equals(\"0\")) map[i][j] = 0;\n\telse map[i][j] = 1;\n\t}\n\t}\n\tint i=0, j=0;\n\tfor(int p=0; p<n; p++){\n\t\ti = 0; j = 0;\n\t\twhile(i!=h && j!=w){\n\t\tif(map[i][j]==0){ map[i][j] = 1; i++;}\n\t\telse{ map[i][j] = 0; j++;}\n\t\t}\n\t}\n\tSystem.out.println((i+1)+\" \"+(j+1));\n\t}\n    }catch(Exception e){\n        System.out.println(\"Error\");\n    }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n\n    public static void main(String[] args){\n\tint H,W,N;\n\tint[][] cMap = new int[1100][1100];\n\tScanner in = new Scanner(System.in);\n\n\twhile(true){\n\t    int[][] Map = new int[1100][1100];\n\t    for(int i=0;i<1100;i++)for(int J=0;J<1100;J++)cMap[J][i] = 0;\n\t    H = in.nextInt();\n\t    W = in.nextInt();\n\t    N = in.nextInt();\n\t    if(H+W+N == 0)break;\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t    Map[i][j] = in.nextInt();\n\t\t}\n\t    }\n\t    cMap[1][1] = N;//奇数ならそのまま偶数なら別\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\n\t\t    cMap[i][j+1] += cMap[i][j]/2; \n\t\t    cMap[i+1][j] += cMap[i][j]/2;\n\t\t    if(cMap[i][j]%2 != 0 ){\n\t\t\tif(Map[i][j] == 1){\n\t\t\t    cMap[i][j+1]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t    cMap[i+1][j]++;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    /*\n\t    for(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++)System.out.print(cMap[i][j]+\" \");\n\t\tSystem.out.println();\n\t    }\n\t    */\n\t    int x,y;\n\t    x = y = 1;\n\t    while(1<= y && y <= H && 1<= x && x<= W){\n\t\tif(cMap[y][x]%2 == 0){\n\t\t    if(Map[y][x] == 1)y++;\n\t\t    else x++;\n\t\t}\n\t\telse{\n\t\t    if(Map[y][x] == 1)x++;\n\t\t    else y++;\n\t\t    \n\t\t}\n\t    }\n\t    System.out.println(y + \" \" + x);\n\n\n\n\t}\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint h = scan.nextInt();\n\t\t\tint w = scan.nextInt();\n\t\t\tint n = scan.nextInt();\n\t\t\tif(h == 0 && w == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] route = new int[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\troute[i][j] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tx = 0;\n\t\t\t\ty = 0;\n\t\t\t\twhile(x < h && y < w){\n\t\t\t\t\tif(route[x][y] == 0){\n\t\t\t\t\t\troute[x][y] ^= 1;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\troute[x][y] ^= 1;\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(x+1 + \" \" + (y+1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint h;\n\t\tint w;\n\t\tint n;\n\t\tint[][] route;\n\t\twhile(ture){\n\t\t\th = scan.nextInt();\n\t\t\tw = scan.nextInt();\n\t\t\tn = scan.nextInt();\n\t\t\tif(h == 0 && w == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\troute = new int[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\troute[i][j] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tx = 0;\n\t\t\t\ty = 0;\n\t\t\t\twhile(x < h && y < w){\n\t\t\t\t\tif(route[x][y] == 0){\n\t\t\t\t\t\troute[x][y] = 1;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\troute[x][y] = 0;\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(x+1 + \" \" + (y+1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint h = scan.nextInt();\n\t\t\tint w = scan.nextInt();\n\t\t\tint n = scan.nextInt();\n\t\t\tif(h == 0 && w == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] route = new int[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\troute[i][j] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tx = 0;\n\t\t\t\ty = 0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(x == h || y == w){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(route[x][y] == 0){\n\t\t\t\t\t\troute[x][y] = 1;\n\t\t\t\t\t\tx += 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\troute[x][y] = 0;\n\t\t\t\t\t\ty += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(x+1 + \" \" + (y+1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h, w, n;\n\t\tint a[][];\n\t\t\n\t\th = sc.nextInt();\n\t\tw = sc.nextInt();\n\t\tn = sc.nextInt();\n\t\twhile (h + w + n != 0) {\n\t\t\ta = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tj = 0;\n\t\t\t\tk = 0;\n\t\t\t\twhile (j < h && k < w) {\n\t\t\t\t\tif (a[j][k] == 0) {\n\t\t\t\t\t\ta[j][k] = 1;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta[j][k] = 0;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((j + 1) + \" \" + (k + 1));\n\t\t\t\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint count = sc.nextInt();\n\t\twhile (h != 0 && w != 0 && count != 0) {\n\t\t\tint[][] route = new int[h][w];\n\t\t\tfor (int i = 0; i < h; ++i) {\n\t\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\t\troute[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve(h, w, count, route));\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tcount = sc.nextInt();\n\t\t}\n\t}\n\n\tpublic static String solve(int h, int w, int count, int[][] route) {\n\n\t\tint i = 0, j = 0;\n\t\tfor (int c = 0; c < count; ++c) {\n\t\t\ti = 0;\n\t\t\tj = 0;\n\t\t\twhile (i < h && j < w) {\n\t\t\t\tif (route[i][j] == 1) {\n\t\t\t\t\troute[i][j] = 0;\n\t\t\t\t\t++j;\n\t\t\t\t} else {\n\t\t\t\t\troute[i][j] = 1;\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (i + 1) + \" \" + (j + 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint h, w;\n\tint n;\n\tint[][] map;\n\tint[][] walk;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif( (h|w|n) == 0 ) break;\n\t\t\tmap = new int[h][w];\n\t\t\twalk = new int[h+1][w+1];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\tint px = 1, py = 1;\n\t\twalk[0][0] = n;\n\t\tfor(int i=0;i<py;i++) for(int j=0;j<px;j++) {\n\t\t\tif((map[i][j]+walk[i][j])%2==0) px++;\n\t\t\telse          \t\t\t\t  \tpy++;\n\t\t\twalk[i][j+1] += walk[i][j]/2 + (walk[i][j]%2) * map[i][j];\n\t\t\twalk[i+1][j] += walk[i][j]/2 + (walk[i][j]%2) * (1-map[i][j]);\n\t\t\tif( px == w+1 || py == h+1 ) {\n\t\t\t\tSystem.out.println((py) + \" \" + (px));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint h,w,n;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt() ;\n\t\t\tif((h|w|n) == 0) break;\n\t\t\tn--;\n\t\t\tint [][] inputroad = new int[h+1][w+1];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tinputroad[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tinputroad[i][w] = -1;\n\t\t\t}\n\t\t\tfor(int i = 0; i <= w; i++){\n\t\t\t\tinputroad[h][i] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint [][] dp = new int[h+1][w+1];\n\t\t\t//int [][] lastroute = new int[h+1][w+1];\n\t\t\tdp[0][0] = n;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2;\n\t\t\t\t\tif(dp[i][j] %2 == 1){\n\t\t\t\t\t\tif(inputroad[i][j] == 0){\n\t\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinputroad[i][j] = (inputroad[i][j] + 1) % 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint indI = 0, indJ = 0;\n\t\t\twhile(inputroad[indI][indJ] != -1){\n\t\t\t\tif(inputroad[indI][indJ] == 0){\n\t\t\t\t\tindI++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindJ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((indI + 1) + \" \" + (indJ + 1));\n\t\t\t\n\t\t\t//debug\n//\t\t\tfor(int i = 0; i <= h; i++){\n//\t\t\t\tfor(int j = 0; j <= w; j++){\n//\t\t\t\t\tSystem.out.print(inputroad[i][j] + \" \" );\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = scanner.nextInt();\n\t\t\tint w = scanner.nextInt();\n\t\t\tint n = scanner.nextInt();\n\t\t\tif ((h | w | n) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h][w ];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tmap[i][j] = scanner.nextInt();\n\t\t\tint px = 0;\n\t\t\tint py = 0;\n\t\t\tn--;\n\t\t\twhile (px < w && py < h) {\n\t\t\t\tif ((n + map[py][px]) %2==1)\n\t\t\t\t\tpx++;\n\t\t\t\telse\n\t\t\t\t\tpy++;\n\t\t\t\tn /= 2;\n\t\t\t}\n\t\t\tSystem.out.println((py + 1 )+ \" \" +( px + 1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tboolean[][] dir = new boolean[H][W];\n\t\t\tsc.nextLine();\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tdir[i][j] = line.charAt(j * 2) == '1';\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] count = new int[H + 1][W + 1];\n\t\t\tcount[0][0] = N - 1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tcount[i + 1][j] = count[i][j] / 2;\n\t\t\t\t\tcount[i][j + 1] = count[i][j] / 2;\n\t\t\t\t\tif (count[i][j] % 2 == 1) {\n\t\t\t\t\t\tif (dir[i][j]) {\n\t\t\t\t\t\t\tcount[i][j + 1] += 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcount[i + 1][j] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdir[i][j] = !dir[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = 0;\n\t\t\tint c = 0;\n\t\t\twhile (r < H && c < W) {\n\t\t\t\tif (dir[r][c]) {\n\t\t\t\t\t++c;\n\t\t\t\t} else {\n\t\t\t\t\t++r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((r + 1) + \" \" + (c + 1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint h;\n\t\tint w;\n\t\tint n;\n\t\tint[][] route = new int[1001][1001];\n\t\twhile(true){\n\t\t\th = scan.nextInt();\n\t\t\tw = scan.nextInt();\n\t\t\tn = scan.nextInt();\n\t\t\tif(h == 0 && w == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//route = new int[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\troute[i][j] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tx = 0;\n\t\t\t\ty = 0;\n\t\t\t\twhile(x < h && y < w){\n\t\t\t\t\tif(route[x][y] == 0){\n\t\t\t\t\t\troute[x][y] = 1;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\troute[x][y] = 0;\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(x+1 + \" \" + (y+1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tboolean[][] dir = new boolean[H][W];\n\t\t\tsc.nextLine();\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tdir[i][j] = line.charAt(j * 2) == '1';\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] count = new int[H + 1][W + 1];\n\t\t\tcount[0][0] = N - 1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tcount[i + 1][j] += count[i][j] / 2;\n\t\t\t\t\tcount[i][j + 1] += count[i][j] / 2;\n\t\t\t\t\tif (count[i][j] % 2 == 1) {\n\t\t\t\t\t\tif (dir[i][j]) {\n\t\t\t\t\t\t\tcount[i][j + 1] += 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcount[i + 1][j] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdir[i][j] = !dir[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = 0;\n\t\t\tint c = 0;\n\t\t\twhile (r < H && c < W) {\n\t\t\t\tif (dir[r][c]) {\n\t\t\t\t\t++c;\n\t\t\t\t} else {\n\t\t\t\t\t++r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((r + 1) + \" \" + (c + 1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Walk\npublic class Main{\n\n\tint h, w, n;\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif((h|w|n)==0)break;\n\t\t\tint[][] m = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=sc.nextInt();\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tdp[0][0] = n-1;\n\t\t\tfor(int j=1;j<w;j++)dp[0][j]=(dp[0][j-1]+m[0][j-1])/2;\n\t\t\tfor(int i=1;i<h;i++)dp[i][0]=(dp[i-1][0]+(m[i-1][0]+1)%2)/2;\n\t\t\tfor(int i=1;i<h;i++){\n\t\t\t\tfor(int j=1;j<w;j++){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j]+(m[i-1][j]+1)%2)/2 + (dp[i][j-1]+m[i][j-1])/2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\twhile(!(x==w||y==h)){\n\t\t\t\tif((dp[y][x]+m[y][x])%2==0)y++;\n\t\t\t\telse x++;\n\t\t\t}\n\t\t\tSystem.out.println(++y+\" \"+ ++x);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tif((H | W | N) == 0) return;\n\t\tint[][] f = new int[H][W];\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tf[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tint[][] dp = new int[H][W];\n\t\tdp[0][0] = N - 1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (dp[i][j] > 0) {\n\t\t\t\t\tif (dp[i][j] % 2 == 0) {\n\t\t\t\t\t\tif (i + 1 < H) dp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\t\t\tif (j + 1 < W) dp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (i + 1 < H) dp[i + 1][j] += (f[i][j] == 0 ? 1 : 0) + dp[i][j] / 2;\n\t\t\t\t\t\tif (j + 1 < W) dp[i][j + 1] += (f[i][j] == 1 ? 1 : 0) + dp[i][j] / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (dp[i][j] % 2 == 1) f[i][j] ^= 1;\n\t\t\t}\n\t\t}\n\t\tint h = 0;\n\t\tint w = 0;\n\t\twhile (true) {\n\t\t\tif (h == H || w == W) {\n\t\t\t\tSystem.out.println(++h + \" \" + ++w);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (f[h][w] == 1) w++;\n\t\t\telse h++;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int h = sc.nextInt();\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] map = new boolean[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt() == 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint cur_x = 0;\n\t\t\tint cur_y = 0;\n\t\t\tint path = n - 1;\n\t\t\t\n\t\t\twhile(cur_x != w && cur_y != h){\n\t\t\t\t//System.out.println((cur_y + 1) + \" \" + (cur_x + 1));\n\t\t\t\t\n\t\t\t\tif(path % 2 == 0){\n\t\t\t\t\tint n_x, n_y;\n\t\t\t\t\tn_x = cur_x + (map[cur_y][cur_x] ? 1 : 0);\n\t\t\t\t\tn_y = cur_y + (map[cur_y][cur_x] ? 0 : 1);\n\t\t\t\t\tcur_x = n_x;\n\t\t\t\t\tcur_y = n_y;\n\t\t\t\t}else{\n\t\t\t\t\tint n_x, n_y;\n\t\t\t\t\tn_x = cur_x + (map[cur_y][cur_x] ? 0 : 1);\n\t\t\t\t\tn_y = cur_y + (map[cur_y][cur_x] ? 1 : 0);\n\t\t\t\t\tcur_x = n_x;\n\t\t\t\t\tcur_y = n_y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpath /= 2;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((cur_y + 1) + \" \" + (cur_x + 1));\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tint h,w,n;\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\n\tprivate void doit(){\n\t\t//Scanner sc = new Scanner(System.in);\n\t\t\n\t\tint [][] dp = new int[1000+1][1000+1];\n\t\twhile(true){\n\t\t\tString [] input = read();\n\t\t\th = Integer.parseInt(input[0]);\n\t\t\tw = Integer.parseInt(input[1]);\n\t\t\tn = Integer.parseInt(input[2]);\n\t\t\tif((h|w|n) == 0) break;\n\t\t\tn--;\n\t\t\tint [][] inputroad = new int[h+1][w+1];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tinput = read();\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tinputroad[i][j] = Integer.parseInt(input[j]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tinputroad[i][w] = -1;\n\t\t\t\tArrays.fill(dp[i], 0);\n\t\t\t}\n\t\t\tArrays.fill(inputroad[h], -1);\n\t\t\tArrays.fill(dp[h], 0);\n\t\t\t\n\t\t\tdp[0][0] = n;\n\t\t\tint indI = 0, indJ = 0;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tint temp = dp[i][j] / 2;\n\t\t\t\t\tdp[i][j+1] += temp;\n\t\t\t\t\tdp[i+1][j] += temp;\n\t\t\t\t\tif((dp[i][j] & 1) != 0){\n\t\t\t\t\t\tif(inputroad[i][j] == 0){\n\t\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinputroad[i][j] = inputroad[i][j] ^ 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == indI && j == indJ){\n\t\t\t\t\t\tif(inputroad[i][j] == 0){\n\t\t\t\t\t\t\tindI++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tindJ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((indI + 1) + \" \" + (indJ + 1));\n\t\t\t\n\t\t\t//debug\n//\t\t\tfor(int i = 0; i <= h; i++){\n//\t\t\t\tfor(int j = 0; j <= w; j++){\n//\t\t\t\t\tSystem.out.print(dp[i][j] + \" \" );\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate String[] read() {\n\t\tString[] res = null;\n\t\ttry {\n\t\t\tres = in.readLine().split(\" \");\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\twhile(true){\n\t\t\tStringTokenizer tok = new StringTokenizer(br.readLine());\n\t\t\tfinal int h = Integer.parseInt(tok.nextToken());\n\t\t\tfinal int w = Integer.parseInt(tok.nextToken());\n\t\t\tfinal int n = Integer.parseInt(tok.nextToken());\n\t\t\t\n\t\t\tif(h == 0 && w == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] map = new boolean[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tStringTokenizer tok2 = new StringTokenizer(br.readLine());\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[i][j] = tok2.nextToken().equals(\"1\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tdp[0][0] = n - 1;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(dp[i][j] % 2 == 0){\n\t\t\t\t\t\tif(i != h-1){\n\t\t\t\t\t\t\tdp[i+1][j] = dp[i][j] / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tdp[i][j+1] = dp[i][j] / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(i != h-1){\n\t\t\t\t\t\t\tdp[i+1][j] = dp[i][j] / 2 + (map[i][j] ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tdp[i][j+1] = dp[i][j] / 2 + (map[i][j] ? 1 : 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint cur_x = 0;\n\t\t\tint cur_y = 0;\n\t\t\t\n\t\t\twhile(cur_x != w && cur_y != h){\n\t\t\t\tif(dp[cur_y][cur_x] % 2 == 0){\n\t\t\t\t\tint n_x, n_y;\n\t\t\t\t\tn_x = cur_x + (map[cur_y][cur_x] ? 1 : 0);\n\t\t\t\t\tn_y = cur_y + (map[cur_y][cur_x] ? 0 : 1);\n\t\t\t\t\tcur_x = n_x;\n\t\t\t\t\tcur_y = n_y;\n\t\t\t\t}else{\n\t\t\t\t\tint n_x, n_y;\n\t\t\t\t\tn_x = cur_x + (map[cur_y][cur_x] ? 0 : 1);\n\t\t\t\t\tn_y = cur_y + (map[cur_y][cur_x] ? 1 : 0);\n\t\t\t\t\tcur_x = n_x;\n\t\t\t\t\tcur_y = n_y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((cur_y + 1) + \" \" + (cur_x + 1));\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint h,w,n;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint [][] dp = new int[1000+1][1000+1];\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt() ;\n\t\t\tif((h|w|n) == 0) break;\n\t\t\tn--;\n\t\t\tint [][] inputroad = new int[h+1][w+1];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tinputroad[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tinputroad[i][w] = -1;\n\t\t\t\tArrays.fill(dp[i], 0);\n\t\t\t}\n\t\t\tArrays.fill(inputroad[h], -1);\n\t\t\tArrays.fill(dp[h], 0);\n\t\t\t\n\t\t\tdp[0][0] = n;\n\t\t\tint indI = 0, indJ = 0;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tint temp = dp[i][j] / 2;\n\t\t\t\t\tdp[i][j+1] += temp;\n\t\t\t\t\tdp[i+1][j] += temp;\n\t\t\t\t\tif((dp[i][j] & 1) != 0){\n\t\t\t\t\t\tif(inputroad[i][j] == 0){\n\t\t\t\t\t\t\tdp[i+1][j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j+1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinputroad[i][j] = inputroad[i][j] ^ 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == indI && j == indJ){\n\t\t\t\t\t\tif(inputroad[i][j] == 0){\n\t\t\t\t\t\t\tindI++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tindJ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((indI + 1) + \" \" + (indJ + 1));\n\t\t\t\n\t\t\t//debug\n//\t\t\tfor(int i = 0; i <= h; i++){\n//\t\t\t\tfor(int j = 0; j <= w; j++){\n//\t\t\t\t\tSystem.out.print(dp[i][j] + \" \" );\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\tlong startCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0541-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint h = scan.nextInt();\n\t\t\tif (h == 0)\n\t\t\t\tbreak;\n\t\t\tint w = scan.nextInt();\n\t\t\tint n = scan.nextInt();\n\t\t\tWalk walk = new Walk(h, w);\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\twalk.set(i, j, scan.nextInt());\n\t\t\tint r = walk.end(n);\n\t\t\tif (r > 0)\n\t\t\t\tSystem.out.println((h + 1) + \" \" + r);\n\t\t\telse\n\t\t\t\tSystem.out.println((-1 * r) + \" \" + (w + 1));\n\t\t}\n\n\t\tscan.close();\n\t\tlong stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\t\t// System.out.println(\"CPU=\" + (stopCpuTime - startCpuTime) / 1000000);\n\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Walk {\n\tint[][] cr;\n\tint[][] tm;\n\n\tpublic Walk(int h, int w) {\n\t\tcr = new int[h][w];\n\t\ttm = new int[h + 1][w + 1];\n\t}\n\n\tpublic int end(int n) {\n\t\ttm[0][0] = n - 1;\n\t\tfor (int h = 0; h < tm.length - 1; h++)\n\t\t\tfor (int w = 0; w < tm[0].length - 1; w++) {\n\t\t\t\ttm[h + 1][w] += tm[h][w] / 2;\n\t\t\t\ttm[h][w + 1] += tm[h][w] / 2;\n\t\t\t\tif (tm[h][w] % 2 == 1) {\n\t\t\t\t\tif (cr[h][w] == 0)\n\t\t\t\t\t\ttm[h + 1][w]++;\n\t\t\t\t\telse\n\t\t\t\t\t\ttm[h][w + 1]++;\n\t\t\t\t\tcr[h][w] ^= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\treturn this.move(0, 0);\n\t}\n\n\tprivate int move(int h, int w) {\n\t\tif (h >= cr.length)\n\t\t\treturn (w + 1);\n\t\tif (w >= cr[0].length)\n\t\t\treturn (-1 * (h + 1));\n\t\tif (cr[h][w] == 0) {\n\t\t\tcr[h][w] = 1;\n\t\t\treturn move(h + 1, w);\n\t\t} else {\n\t\t\tcr[h][w] = 0;\n\t\t\treturn move(h, w + 1);\n\t\t}\n\t}\n\n\tpublic void set(int h, int w, int d) {\n\t\tcr[h][w] = d;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint h, w;\n\tlong n;\n\tboolean[][] map;\n\tlong[][] walk;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextLong();\n\t\t\tif( (h|w|n) == 0 ) break;\n\t\t\tmap = new boolean[h][w];\n\t\t\twalk = new long[h+1][w+1];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt() == 1;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\tint px = 0, py = 0;\n\t\twalk[0][0] = n;\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) {\n\t\t\tif(map[i][j]^walk[i][j]%2==0) px++;\n\t\t\telse          \t\t\t\t  py++;\n\t\t\twalk[i][j+1] += walk[i][j]/2 + (walk[i][j]%2) * (map[i][j]? 1:0);\n\t\t\twalk[i+1][j] += walk[i][j]/2 + (walk[i][j]%2) * (map[i][j]? 0:1);\n\t\t\tif( px == w || py == h ) {\n\t\t\t\tSystem.out.println((py+1) + \" \" + (px+1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\twhile(true){\n\t\t\tStringTokenizer tok = new StringTokenizer(br.readLine());\n\t\t\tfinal int h = Integer.parseInt(tok.nextToken());\n\t\t\tfinal int w = Integer.parseInt(tok.nextToken());\n\t\t\tfinal int n = Integer.parseInt(tok.nextToken());\n\t\t\t\n\t\t\tif(h == 0 && w == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] map = new boolean[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tStringTokenizer tok2 = new StringTokenizer(br.readLine());\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[i][j] = tok2.nextToken().equals(\"1\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tdp[0][0] = n - 1;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(dp[i][j] % 2 == 0){\n\t\t\t\t\t\tif(i != h-1){\n\t\t\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(i != h-1){\n\t\t\t\t\t\t\tdp[i+1][j] += dp[i][j] / 2 + (map[i][j] ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tdp[i][j+1] += dp[i][j] / 2 + (map[i][j] ? 1 : 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tSystem.out.print((dp[i][j] % 2 == 0 ? map[i][j] : !map[i][j]) + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\t\t\t\n\t\t\tint cur_x = 0;\n\t\t\tint cur_y = 0;\n\t\t\t\n\t\t\twhile(cur_x != w && cur_y != h){\n\t\t\t\tif(dp[cur_y][cur_x] % 2 == 0){\n\t\t\t\t\tint n_x, n_y;\n\t\t\t\t\tn_x = cur_x + (map[cur_y][cur_x] ? 1 : 0);\n\t\t\t\t\tn_y = cur_y + (map[cur_y][cur_x] ? 0 : 1);\n\t\t\t\t\tcur_x = n_x;\n\t\t\t\t\tcur_y = n_y;\n\t\t\t\t}else{\n\t\t\t\t\tint n_x, n_y;\n\t\t\t\t\tn_x = cur_x + (map[cur_y][cur_x] ? 0 : 1);\n\t\t\t\t\tn_y = cur_y + (map[cur_y][cur_x] ? 1 : 0);\n\t\t\t\t\tcur_x = n_x;\n\t\t\t\t\tcur_y = n_y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((cur_y + 1) + \" \" + (cur_x + 1));\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tint N = sc.nextInt();\n\t\t\tif ((H | W | N) == 0) return;\n\t\t\tint[][] f = new int[H][W];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tf[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[H][W];\n\t\t\tdp[0][0] = N - 1;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (dp[i][j] > 0) {\n\t\t\t\t\t\tif (dp[i][j] % 2 == 0) {\n\t\t\t\t\t\t\tif (i + 1 < H) dp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\t\t\t\tif (j + 1 < W) dp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (i + 1 < H) dp[i + 1][j] += (f[i][j] == 0 ? 1 : 0) + dp[i][j] / 2;\n\t\t\t\t\t\t\tif (j + 1 < W) dp[i][j + 1] += (f[i][j] == 1 ? 1 : 0) + dp[i][j] / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (dp[i][j] % 2 == 1) f[i][j] ^= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint h = 0;\n\t\t\tint w = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (h == H || w == W) {\n\t\t\t\t\tSystem.out.println(++h + \" \" + ++w);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (f[h][w] == 1) w++;\n\t\t\t\telse h++;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = scanner.nextInt();\n\t\t\tint w = scanner.nextInt();\n\t\t\tint n = scanner.nextInt();\n\t\t\tif ((h | w | n) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h + 1][w + 1];\n\t\t\tmap[0][0] = --n;\n\t\t\tboolean[][] b = new boolean[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint m = scanner.nextInt();\n\t\t\t\t\tmap[i][j + 1] += (map[i][j] + (m & 1)) / 2;\n\t\t\t\t\tmap[i + 1][j] += (map[i][j] + (m ^ 1)) / 2;\n\t\t\t\t\tb[i][j] = (map[i][j] + m) % 2 == 1;\n\t\t\t\t}\n\t\t\tint px = 0;\n\t\t\tint py = 0;\n\t\t\twhile (px < w && py < h) {\n\t\t\t\tif (b[py][px])\n\t\t\t\t\tpx++;\n\t\t\t\telse\n\t\t\t\t\tpy++;\n\t\t\t}\n\t\t\tSystem.out.println((py + 1) + \" \" + (px + 1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint h;\n\t\tint w;\n\t\tint n;\n\t\tint[][] route;\n\t\twhile(true){\n\t\t\th = scan.nextInt();\n\t\t\tw = scan.nextInt();\n\t\t\tn = scan.nextInt();\n\t\t\tif(h == 0 && w == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\troute = new int[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\troute[i][j] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tx = 0;\n\t\t\t\ty = 0;\n\t\t\t\twhile(x < h && y < w){\n\t\t\t\t\tif(route[x][y] == 0){\n\t\t\t\t\t\troute[x][y] = 1;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\troute[x][y] = 0;\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(x+1 + \" \" + (y+1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint h, w;\n\tint n;\n\tint[][] map;\n\tint[][] walk;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif( (h|w|n) == 0 ) break;\n\t\t\tmap = new int[h][w];\n\t\t\twalk = new int[h+1][w+1];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = Integer.parseInt(sc.next());\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\tint px = 1, py = 1;\n\t\twalk[0][0] = n;\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) {\n\t\t\twalk[i][j+1] += walk[i][j]/2 + (walk[i][j]%2) * map[i][j];\n\t\t\twalk[i+1][j] += walk[i][j]/2 + (walk[i][j]%2) * (1-map[i][j]);\n\t\t\tif( i+1==py && j+1==px ) {\n\t\t\t\tif((map[i][j]+walk[i][j])%2==0) { px++; }\n\t\t\t\telse          \t\t\t\t  \t{ py++; }\n\t\t\t}\n\t\t\tif( px == w+1 || py == h+1 ) {\n\t\t\t\tSystem.out.println((py) + \" \" + (px));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif( (h|w|n) == 0 ) break;\n\t\t\tboolean[][] map = new boolean[h][w];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt() == 1;\n\t\t\t}\n\t\t\tint i=0,j=0;\n\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\ti = j = 0;\n\t\t\t\tfor(;i!=h&&j!=w;) {\n\t\t\t\t\tmap[i][j] ^= map[i][j];\n\t\t\t\t\tif(map[i][j])\ti++;\n\t\t\t\t\telse \t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println( (i+1) + \" \" + (j+1) );\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[][] f = new int[H][W];\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tf[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tint[][] dp = new int[H][W];\n\t\tdp[0][0] = N - 1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (dp[i][j] > 0) {\n\t\t\t\t\tif (dp[i][j] % 2 == 0) {\n\t\t\t\t\t\tif (i + 1 < H) dp[i + 1][j] += dp[i][j] / 2;\n\t\t\t\t\t\tif (j + 1 < W) dp[i][j + 1] += dp[i][j] / 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (i + 1 < H) dp[i + 1][j] += (f[i][j] == 0 ? 1 : 0) + dp[i][j] / 2;\n\t\t\t\t\t\tif (j + 1 < W) dp[i][j + 1] += (f[i][j] == 1 ? 1 : 0) + dp[i][j] / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (dp[i][j] % 2 == 1) f[i][j] ^= 1;\n\t\t\t}\n\t\t}\n\t\tint h = 0;\n\t\tint w = 0;\n\t\twhile (true) {\n\t\t\tif (h == H || w == W) {\n\t\t\t\tSystem.out.println(++h + \" \" + ++w);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (f[h][w] == 1) w++;\n\t\t\telse h++;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\twhile(true){\n\t\t\tStringTokenizer tok = new StringTokenizer(br.readLine());\n\t\t\tfinal int h = Integer.parseInt(tok.nextToken());\n\t\t\tfinal int w = Integer.parseInt(tok.nextToken());\n\t\t\tfinal int n = Integer.parseInt(tok.nextToken());\n\t\t\t\n\t\t\tif(h == 0 && w == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] map = new boolean[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tStringTokenizer tok2 = new StringTokenizer(br.readLine());\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[i][j] = tok2.nextToken().equals(\"1\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint cur_x = 0;\n\t\t\tint cur_y = 0;\n\t\t\tint path = n - 1;\n\t\t\t\n\t\t\twhile(cur_x != w && cur_y != h){\n\t\t\t\t//System.out.println((cur_y + 1) + \" \" + (cur_x + 1));\n\t\t\t\t\n\t\t\t\tif(path % 2 == 0){\n\t\t\t\t\tint n_x, n_y;\n\t\t\t\t\tn_x = cur_x + (map[cur_y][cur_x] ? 1 : 0);\n\t\t\t\t\tn_y = cur_y + (map[cur_y][cur_x] ? 0 : 1);\n\t\t\t\t\tcur_x = n_x;\n\t\t\t\t\tcur_y = n_y;\n\t\t\t\t}else{\n\t\t\t\t\tint n_x, n_y;\n\t\t\t\t\tn_x = cur_x + (map[cur_y][cur_x] ? 0 : 1);\n\t\t\t\t\tn_y = cur_y + (map[cur_y][cur_x] ? 1 : 0);\n\t\t\t\t\tcur_x = n_x;\n\t\t\t\t\tcur_y = n_y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpath /= 2;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((cur_y + 1) + \" \" + (cur_x + 1));\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint h, w;\n\tint n;\n\tint[][] map;\n\tint[][] walk;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif( (h|w|n) == 0 ) break;\n\t\t\tmap = new int[h][w];\n\t\t\twalk = new int[h+1][w+1];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = Integer.parseInt(sc.next());\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\tint px = 1, py = 1;\n\t\twalk[0][0] = n;\n\t\tfor(int i=0;i<py;i++) for(int j=0;j<px;j++) {\n\t\t\tif((map[i][j]+walk[i][j])%2==0) px++;\n\t\t\telse          \t\t\t\t  \tpy++;\n\t\t\twalk[i][j+1] += walk[i][j]/2 + (walk[i][j]%2) * map[i][j];\n\t\t\twalk[i+1][j] += walk[i][j]/2 + (walk[i][j]%2) * (1-map[i][j]);\n\t\t\tif( px == w+1 || py == h+1 ) {\n\t\t\t\tSystem.out.println((py) + \" \" + (px));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint h, w;\n\tint n;\n\tint[][] map;\n\tint[][] walk;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif( (h|w|n) == 0 ) break;\n\t\t\tmap = new int[h][w];\n\t\t\twalk = new int[h+1][w+1];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = Integer.parseInt(sc.next());\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tvoid solve() {\n\t\tint px = 1, py = 1;\n\t\twalk[0][0] = n;\n\t\tfor(int i=0;i<py;i++) for(int j=0;j<px;j++) {\n\t\t\tif((map[i][j]+walk[i][j])%2==0) px=max(px, j+2);\n\t\t\telse          \t\t\t\t  \tpy=max(py, i+2);\n\t\t\twalk[i][j+1] += walk[i][j]/2 + (walk[i][j]%2) * map[i][j];\n\t\t\twalk[i+1][j] += walk[i][j]/2 + (walk[i][j]%2) * (1-map[i][j]);\n\t\t\tif( px == w+1 || py == h+1 ) {\n\t\t\t\tSystem.out.println((py) + \" \" + (px));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var h = int.Parse(line[0]);\n            var w = int.Parse(line[1]);\n            var n = int.Parse(line[2]);\n            if (h == 0 && w == 0 && n == 0) break;\n            n -= 1;\n            var map = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++)\n                    map[i, j] = line[j] == \"0\" ? true : false;\n            }\n            var map2 = goDP(map, h, w, n);\n            getAns(map2, h, w);\n        }\n    }\n    static void getAns(bool[,] map, int h, int w)\n    {\n        var x = 0;\n        var y = 0;\n        while (true)\n        {\n            if (x == h | y == w) { Console.WriteLine(\"{0} {1}\", x + 1, y + 1); break; }\n            if (map[x, y]) x++;\n            else y++;\n        }\n    }\n    static bool[,] goDP(bool[,] map, int h, int w, int n)\n    {\n        var dp = new int[h, w];\n        var map2 = new bool[h, w];\n        dp[0, 0] = n;\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n            {\n                var t = dp[i, j];\n                if (i + 1 < h) dp[i + 1, j] += t / 2;\n                if (j + 1 < w) dp[i, j + 1] += t / 2;\n                if (t % 2 == 1)\n                {\n                    if (map[i, j] && i + 1 < h) dp[i + 1, j]++;\n                    else if (!map[i, j] && j + 1 < w) dp[i, j + 1]++;\n                }\n                map2[i, j] = t % 2 == 0 ? map[i, j] : !map[i, j];\n            }\n        return map2;\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "## main\n\nloop do\n  h, w, n = gets.strip.split(' ').map{|s| s.to_i}\n  break if (h | w | n) == 0\n\n  drcs = h.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  #p crs\n\n  counts = (h + 1).times.map{(w + 1).times.map{0}}\n  counts[0][0] = n - 1\n\n  for y in (0...h)\n    for x in (0...w)\n      c = counts[y][x]\n      d = drcs[y][x]\n      c2 = c / 2\n\n      counts[y + 1][x] += (c + 1 - d) / 2\n      counts[y][x + 1] += (c + d) / 2\n    end\n  end\n\n  for y in (0...h)\n    for x in (0...w)\n      drcs[y][x] ^= (counts[y][x] & 1)\n    end\n  end\n\n  x = y = 0\n\n  while x < w && y < h\n    if drcs[y][x] == 0\n      y += 1\n    else\n      x += 1\n    end\n  end\n\n  puts [y + 1, x + 1].join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    h, w, n = gets.split.map(&:to_i)\n    break if h == 0\n    n -= 1\n    a = (1..h).map { gets.split.map(&:to_i) }\n    t = (1..h).map { Array.new(w, 0) }\n    (0..h-1).each do |i|\n        (0..w-1).each do |j|\n            if i == 0 && j == 0\n                t[i][j] = n\n            end\n            if a[i][j] == 0\n                t[i+1][j] += (t[i][j] / 2.0).ceil  if i < h - 1\n                t[i][j+1] += (t[i][j] / 2.0).floor if j < w - 1\n            else\n                t[i+1][j] += (t[i][j] / 2.0).floor if i < h - 1\n                t[i][j+1] += (t[i][j] / 2.0).ceil  if j < w - 1\n            end\n        end\n    end\n    i = j = 0\n    loop do\n        if (a[i][j] + t[i][j]).even?\n            i += 1\n            break if i == h\n        else\n            j += 1\n            break if j == w\n        end\n    end\n    puts [i + 1, j + 1] * ' '\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDIRCS = [[0, 1], [1, 0]]\n\n### main\n\nloop do\n  h, w, n = gets.strip.split(' ').map{|s| s.to_i}\n  break if (h | w | n) == 0\n\n  crs = h.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  #p crs\n\n  x = y = 0\n  n -= 1\n\n  while x < w && y < h\n    c = crs[y][x]\n    dx, dy = DIRCS[(c + (n & 1)) % 2]\n    x += dx\n    y += dy\n\n    n >>= 1\n  end\n\n  puts [y + 1, x + 1].join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "h, w, n = gets.split.map(&:to_i)\nn -= 1\na = (1..h).map { gets.split.map(&:to_i) }\nt = (1..h).map { Array.new(w, 0) }\n(0..h-1).each do |i|\n    (0..w-1).each do |j|\n        if i == 0 && j == 0\n            t[i][j] = n\n        end\n        if a[i][j] == 0\n            t[i+1][j] += (t[i][j] / 2.0).ceil  if i < h - 1\n            t[i][j+1] += (t[i][j] / 2.0).floor if j < w - 1\n        else\n            t[i+1][j] += (t[i][j] / 2.0).floor if i < h - 1\n            t[i][j+1] += (t[i][j] / 2.0).ceil  if j < w - 1\n        end\n    end\nend\ni = j = 0\nloop do\n    if (a[i][j] + t[i][j]).even?\n        i += 1\n        break if i == h\n    else\n        j += 1\n        break if j == w\n    end\nend\nputs [i + 1, j + 1] * ' '\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.array;\nimport std.algorithm;\nimport std.conv;\n\nvoid main() {\n    int H, W, N;\n    while (readf(\"%d %d %d\\n\", &H, &W, &N), H || W || N) {\n        int[][] F = new int[][H];\n        foreach (ref L; F) L = readln.chomp.split(\" \").map!(to!int).array;\n        int[][] C = new int[][](H, W);\n        void f() {\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (y - 1 >= 0) {\n                        C[y][x] += (C[y - 1][x] + (F[y - 1][x] == 0)) / 2;\n                    }\n                    if (x - 1 >= 0) {\n                        C[y][x] += (C[y][x - 1] + (F[y][x - 1] == 1)) / 2;\n                    }\n                }\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (C[y][x] % 2) {\n                        F[y][x] = !F[y][x];\n                    }\n                }\n            }\n        }\n        C[0][0] = N - 1;\n        f;\n        int y = 0, x = 0;\n        while (true) {\n            if (F[y][x]) {\n                x++;\n            } else {\n                y++;\n            }\n            if (y >= H || x >= W) {\n                writeln(y + 1, \" \", x + 1);\n                break;\n            }\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.array;\nimport std.algorithm;\nimport std.conv;\n\nvoid main() {\n    int H, W, N;\n    while (readf(\"%d %d %d\\n\", &H, &W, &N), H || W || N) {\n        int[][] F = new int[][H];\n        foreach (ref L; F) L = readln.chomp.split(\" \").map!(to!int).array;\n        int[][] C = new int[][](H, W);\n        void f(int y, int x, int c) {\n            if (y >= H || x >= W) return;\n            C[y][x] += c;\n            if (c % 2 == 0) {\n                f(y + 1, x, c / 2);\n                f(y, x + 1, c / 2);\n            } else {\n                if (c == 1) { // 東\n                    f(y + 1, x, c / 2);\n                    f(y, x + 1, c / 2 + 1);\n                } else {      // 南\n                    f(y + 1, x, c / 2 + 1);\n                    f(y, x + 1, c / 2);\n                }\n            }\n        }\n        f(0, 0, N);\n        int y = 0, x = 0;\n        while (true) {\n            if (C[y][x] % 2) {\n                x++;\n            } else {\n                y++;\n            }\n            if (y >= H || x >= W) {\n                writeln(y + 1, \" \", x + 1);\n                break;\n            }\n        }\n    }\n}"
  },
  {
    "language": "Python",
    "code": "while 1:\n    h, w, n = map(int, raw_input().split())\n    if h == 0: break\n    l = [map(int, raw_input().split()) for i in range(h)]\n    dp = [[0]*w for i in range(h)]\n    dp[0][0] = n - 1\n    for i in range(h-1):\n        for j in range(w-1):\n            dp[i+1][j] += (dp[i][j] + l[i][j] ^ 1) >> 1\n            dp[i][j+1] += (dp[i][j] + l[i][j]) >> 1\n    dx = dy = 0\n    while dx < w and dy < h:\n        if (dp[dy][dx] + l[dy][dx]) % 2 == 0: dy += 1\n        else: dx += 1\n    print dy + 1, dx + 1"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\nimport string\nimport sys\nfrom itertools import chain, takewhile\n\n\ndef read(\n    f, *shape, it=chain.from_iterable(sys.stdin), whitespaces=set(string.whitespace)\n):\n    def read_word():\n        return f(\"\".join(takewhile(lambda c: c not in whitespaces, it)).strip())\n\n    if not shape:\n        return read_word()\n    elif len(shape) == 1:\n        return [read_word() for _ in range(shape[0])]\n    elif len(shape) == 2:\n        return [[read_word() for _ in range(shape[1])] for _ in range(shape[0])]\n\n\ndef arr(*shape, fill_value=0):\n    if len(shape) == 1:\n        return [fill_value] * shape[fill_value]\n    elif len(shape) == 2:\n        return [[fill_value] * shape[1] for _ in range(shape[0])]\n\n\ndef debug(**kwargs):\n    print(\n        \", \".join(\"{} = {}\".format(k, repr(v)) for k, v in kwargs.items()),\n        file=sys.stderr,\n    )\n\n\ndef main():\n    while True:\n        h, w, n = map(int, sys.stdin.readline().split())\n        if (h, w, n) == (0, 0, 0):\n            return\n        grid = []\n        for _ in range(h):\n            row = list(map(int, sys.stdin.readline().split()))\n            grid.append(row)\n\n        dp = arr(h, w)\n        dp[0][0] = n - 1\n\n        for i in range(h):\n            for j in range(w):\n                if i < h - 1 and grid[i][j] == 0:\n                    dp[i + 1][j] += (dp[i][j] + 1) // 2\n                if i < h - 1 and grid[i][j] == 1:\n                    dp[i + 1][j] += dp[i][j] // 2\n                if j < w - 1 and grid[i][j] == 0:\n                    dp[i][j + 1] += dp[i][j] // 2\n                if j < w - 1 and grid[i][j] == 1:\n                    dp[i][j + 1] += (dp[i][j] + 1) // 2\n\n        for i in range(h):\n            for j in range(w):\n                grid[i][j] = (grid[i][j] + dp[i][j]) % 2\n\n        i = 0\n        j = 0\n        while i < h and j < w:\n            if grid[i][j] == 0:\n                i += 1\n            else:\n                j += 1\n        print(i + 1, j + 1)\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nwhile True:\n\n    H, W, N = MAP()\n    if H == W == H == 0:\n        break\n\n    grid = list2d(H, W, 0)\n    for i in range(H):\n        row = LIST()\n        for j in range(W):\n            grid[i][j] = row[j]\n\n    # dp[i][j] := (i, j)のマスをN回目の前までに何回通るか\n    dp = list2d(H+1, W+1, 0)\n    dp[0][0] = N - 1\n    for i in range(H):\n        for j in range(W):\n            # 通る回数が偶数なら半分ずつ\n            if dp[i][j] % 2 == 0:\n                dp[i+1][j] += dp[i][j] // 2\n                dp[i][j+1] += dp[i][j] // 2\n            else:\n                # 通る回数が奇数なら、元のグリッドの状態に応じて1回多く行く方が決まる\n                if grid[i][j] == 0:\n                    dp[i+1][j] += dp[i][j] // 2 + 1\n                    dp[i][j+1] += dp[i][j] // 2\n                else:\n                    dp[i+1][j] += dp[i][j] // 2\n                    dp[i][j+1] += dp[i][j] // 2 + 1\n\n    # N-1回終了時の状態にグリッドを更新\n    for i in range(H):\n        for j in range(W):\n            grid[i][j] ^= dp[i][j]\n            grid[i][j] &= 1\n\n    # N回目の散歩をシミュレーション\n    i = j = 0\n    while i < H and j < W:\n        if grid[i][j] == 0:\n            i += 1\n        else:\n            j += 1\n    print(i+1, j+1)\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    h,w,n = map(int, input().split())\n    if h==0: break\n    \n    mapp = []\n    for i in range(h):\n        hoge = list(map(int,input().split()))\n        hoge.append(0)\n        mapp.append(hoge)\n    mapp.append([0]*(w+1))\n\n    n -= 1\n    nmap = [[0]*(w+1) for _ in range(h+1)]\n    nmap[0][0] = n\n    for i in range(h):\n        for j in range(w):\n            nmap[i+1][j] += (nmap[i][j]+1-mapp[i][j]) // 2\n            nmap[i][j+1] += (nmap[i][j]+mapp[i][j]) // 2\n            mapp[i][j] = (nmap[i][j]+mapp[i][j]) % 2\n\n    i,j = 0,0\n    while i < h and j < w:\n        if mapp[i][j] == 0:\n            i += 1\n        else:\n            j += 1\n    print(i+1,j+1)"
  },
  {
    "language": "Python",
    "code": "def solve():\n  while True:\n    h,w,n = map(int,input().split())\n    if not h: break\n    mp = [[int(s) for s in input().split()] for i in range(h)]\n    dp = [[0 for i in range(w + 1)] for j in range(h + 1)]\n    dp[0][0] = n - 1\n    for x in range(h):\n      dpx = dp[x]\n      dpxp = dp[x + 1]\n      mpx = mp[x]\n      for y in range(w):\n        a = dpx[y]\n        b = mpx[y]\n        if b:\n          if a % 2:\n            dpxp[y] += a // 2\n            dpx[y + 1] += a // 2 + 1\n          else:\n            dpxp[y] += a // 2\n            dpx[y + 1] += a // 2\n        else:\n          if a % 2:\n            dpxp[y] += a // 2 + 1\n            dpx[y + 1] += a // 2\n          else:\n            dpxp[y] += a // 2\n            dpx[y + 1] += a // 2\n        mpx[y] = (a + b) % 2\n  \n    x = y = 0\n    while x < h and y < w:\n      if mp[x][y]:\n        y += 1\n      else:\n        x += 1\n    print(x + 1,y + 1)\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "h, w, n = map(int, raw_input().split())\nl = [map(int, raw_input().split()) for i in range(h)]\ndp = [[0]*w for i in range(h)]\ndp[0][0] = n - 1\nfor i in range(h-1):\n    for j in range(w-1):\n        dp[i+1][j] += (dp[i][j] + l[i][j] ^ 1) >> 1\n        dp[i][j+1] += (dp[i][j] + l[i][j]) >> 1\ndx = dy = 0\nwhile dx < w and dy < h:\n    if (dp[dy][dx] + l[dy][dx]) % 2 == 0: dy += 1\n    else: dx += 1\nprint dy + 1, dx + 1"
  },
  {
    "language": "Python",
    "code": "while True:\n  h,w,n = map(int,input().split())\n  if not h: break\n  sss = [[1 if s == \"1\" else 0 for s in input().split()] for i in range(h)]\n  dp = [[0 for i in range(w + 1)] for j in range(h + 1)]\n  dp[0][0] = n - 1\n  for x in range(h):\n    for y in range(w):\n      a = dp[x][y]\n      if sss[x][y]:\n        if a % 2:\n          dp[x + 1][y] += a // 2\n          dp[x][y + 1] += a // 2 + 1\n        else:\n          dp[x + 1][y] += a // 2\n          dp[x][y + 1] += a // 2\n      else:\n        if a % 2:\n          dp[x + 1][y] += a // 2 + 1\n          dp[x][y + 1] += a // 2\n        else:\n          dp[x + 1][y] += a // 2\n          dp[x][y + 1] += a // 2\n      sss[x][y] = (sss[x][y] + dp[x][y]) % 2\n\n#  print(sss)\n#  print(dp)\n  x = y = 0\n  while x < h and y < w:\n    if sss[x][y]:\n      y += 1\n    else:\n      x += 1\n  print(x + 1,y + 1)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n  while True:\n    h,w,n = map(int,input().split())\n    if not h: break\n    sss = [[1 if s == \"1\" else 0 for s in input().split()] for i in range(h)]\n    dp = [[0 for i in range(w + 1)] for j in range(h + 1)]\n    dp[0][0] = n - 1\n    for x in range(h):\n      for y in range(w):\n        a = dp[x][y]\n        if sss[x][y]:\n          if a % 2:\n            dp[x + 1][y] += a // 2\n            dp[x][y + 1] += a // 2 + 1\n          else:\n            dp[x + 1][y] += a // 2\n            dp[x][y + 1] += a // 2\n        else:\n          if a % 2:\n            dp[x + 1][y] += a // 2 + 1\n            dp[x][y + 1] += a // 2\n          else:\n            dp[x + 1][y] += a // 2\n            dp[x][y + 1] += a // 2\n        sss[x][y] = (sss[x][y] + dp[x][y]) % 2\n  \n  #  print(sss)\n  #  print(dp)\n    x = y = 0\n    while x < h and y < w:\n      if sss[x][y]:\n        y += 1\n      else:\n        x += 1\n    print(x + 1,y + 1)\n  #  print(sss)\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    while True:\n        import sys\n        input=sys.stdin.readline\n        h,w,n=map(int,input().split())\n        if h==0:\n            break\n        grid=[list(map(int,input().split())) for _ in [0]*h]\n        dp=[[0]*(w+1) for _ in [0]*(h+1)]\n        dp[0][0]=n-1\n        for k in range(h+w-1):\n            for i in range(max(0,k-w+1),min(h,k+1)):\n                j=k-i\n                x=dp[i][j]\n                if grid[i][j]==1:\n                    dp[i+1][j]+=x//2\n                    dp[i][j+1]+=x-x//2\n                else:\n                    dp[i][j+1]+=x//2\n                    dp[i+1][j]+=x-x//2\n        for i in range(h):\n            for j in range(w):\n                dp[i][j]=(grid[i][j]+dp[i][j])%2\n        i,j=1,1\n        while True:\n            if dp[i-1][j-1]==1:\n                j+=1\n            else:\n                i+=1\n            if i>h or j>w:\n                break\n        print(i,j)\nif __name__=='__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/python\n# -*- coding: utf-8 -*-\n\ndxy = {True:(0, 1), False:(1, 0)}\nSOUTH = True\nEAST = False\n\ndef main():\n    # input\n    H, W, N = map(int, raw_input().split())\n    data = []\n    for x in xrange(N):\n        data.append(map(makeBool, raw_input().split()))\n\n    last_point = lastReachPoint(data, H, W, N)\n    print(str(last_point[1] + 1) + \" \" + str(last_point[0] + 1))\n\ndef makeBool(string):\n    if int(string) == 0:\n        return True\n    else:\n        return False\n\ndef lastReachPoint(data, H, W, N):\n    for x in xrange(N):\n        data, last_point = walk(H, W, data)\n\n    return last_point\n\ndef walk(H, W, data):\n    now_point = (0, 0)\n    while now_point[0] < W and now_point[1] < H:\n        now_state = data[now_point[1]][now_point[0]]\n        next_point = tuple([sum(x) for x in zip(now_point, dxy[now_state])])\n\n        next_state = not now_state\n        data[now_point[1]][now_point[0]]= next_state\n        now_point = next_point\n\n    return data, next_point\n\ndef test():\n    data = [[False, True, False, False],\n            [True, False, True, True],\n            [False, True, False, True]]\n    H = 3\n    W = 4\n    N = 3\n\n    print(lastReachPoint(data, H, W, N))\n\nif __name__=='__main__':\n    # test()\n    main()"
  },
  {
    "language": "Python",
    "code": "while 1:\n    h, w, n = map(int, raw_input().split())\n    if h == 0: break\n    l = [map(int, raw_input().split()) for i in range(h)]\n    dp = [[0]*w for i in range(h)]\n    dp[0][0] = n - 1\n    for i in range(h):\n        for j in range(w):\n            if i + 1 < h: dp[i+1][j] += (dp[i][j] + (l[i][j] ^ 1)) >> 1\n            if j + 1 < w: dp[i][j+1] += (dp[i][j] + l[i][j]) >> 1\n    dx = dy = 0\n    while dx < w and dy < h:\n        if (dp[dy][dx] + l[dy][dx]) % 2 == 0: dy += 1\n        else: dx += 1\n    print dy + 1, dx + 1"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/python\n# -*- coding: utf-8 -*-\n\ndxy = {True:(0, 1), False:(1, 0)}\nSOUTH = True\nEAST = False\n\ndef main():\n    # input\n    H, W, N = map(int, raw_input().split())\n    data = []\n    for x in xrange(H):\n        data.append(map(makeBool, raw_input().split()))\n\n    last_point = lastReachPoint(data, H, W, N)\n    print(str(last_point[1] + 1) + \" \" + str(last_point[0] + 1))\n\ndef makeBool(string):\n    if int(string) == 0:\n        return True\n    else:\n        return False\n\ndef lastReachPoint(data, H, W, N):\n    for x in xrange(N):\n        data, last_point = walk(H, W, data)\n\n    return last_point\n\ndef walk(H, W, data):\n    now_point = (0, 0)\n    while now_point[0] < W and now_point[1] < H:\n        now_state = data[now_point[1]][now_point[0]]\n        next_point = tuple([sum(x) for x in zip(now_point, dxy[now_state])])\n\n        next_state = not now_state\n        data[now_point[1]][now_point[0]]= next_state\n        now_point = next_point\n\n    return data, next_point\n\ndef test():\n    data = [[False, True, False, False],\n            [True, False, True, True],\n            [False, True, False, True]]\n    H = 3\n    W = 4\n    N = 3\n\n    print(lastReachPoint(data, H, W, N))\n\nif __name__=='__main__':\n    # test()\n    main()"
  },
  {
    "language": "Python",
    "code": "while True:\n  h,w,n = map(int,input().split())\n  if not h: break\n  sss = [[True if s == \"1\" else False for s in input().split()] for i in range(h)]\n  for i in range(n):\n    x = y = 0\n    while x < h and y < w:\n      sss[x][y] = not sss[x][y]\n      if sss[x][y]:\n        x += 1\n      else:\n        y += 1\n  print(x + 1,y + 1)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n  while True:\n    h,w,n = map(int,input().split())\n    if not h: break\n    sss = [[1 if s == \"1\" else 0 for s in input().split()] for i in range(h)]\n    dp = [[0 for i in range(w + 1)] for j in range(h + 1)]\n    dp[0][0] = n - 1\n    for x in range(h):\n      for y in range(w):\n        a = dp[x][y]\n        b = sss[x][y]\n        if b:\n          if a % 2:\n            dp[x + 1][y] += a // 2\n            dp[x][y + 1] += a // 2 + 1\n          else:\n            dp[x + 1][y] += a // 2\n            dp[x][y + 1] += a // 2\n        else:\n          if a % 2:\n            dp[x + 1][y] += a // 2 + 1\n            dp[x][y + 1] += a // 2\n          else:\n            dp[x + 1][y] += a // 2\n            dp[x][y + 1] += a // 2\n        sss[x][y] = (a + b) % 2\n  \n  #  print(sss)\n  #  print(dp)\n    x = y = 0\n    while x < h and y < w:\n      if sss[x][y]:\n        y += 1\n      else:\n        x += 1\n    print(x + 1,y + 1)\n  #  print(sss)\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    h, w, n = map(int, raw_input().split())\n    if h == 0: break\n    l = [map(int, raw_input().split()) for i in range(h)]\n    dp = [[0]*w for i in range(h)]\n    dp[0][0] = n - 1\n    for i in range(h):\n        for j in range(w):\n            if i + 1 < h: dp[i+1][j] += (dp[i][j] + l[i][j] ^ 1) >> 1\n            if j + 1 < w: dp[i][j+1] += (dp[i][j] + l[i][j]) >> 1\n    dx = dy = 0\n    while dx < w and dy < h:\n        if (dp[dy][dx] + l[dy][dx]) % 2 == 0: dy += 1\n        else: dx += 1\n    print dy + 1, dx + 1"
  },
  {
    "language": "Rust",
    "code": "fn main(){\n  loop {\n    let hwn: Vec<usize> = read_vec();\n    let h = hwn[0];\n    let w = hwn[1];\n    let n = hwn[2] as u32;\n\n    if h == 0 && w == 0 && n == 0 { break; }\n  \n    let mut mp: Vec<Vec<u32>> = Vec::new();\n  \n    for _ in 0 .. h {\n      mp.push(read_vec());\n    }\n\n    let mut vc: Vec<Vec<u32>> = vec![vec![0; w]; h];\n\n    vc[0][0] = n - 1;\n\n    for i in 1 .. w {\n      if vc[0][i-1] % 2 == 0 {\n        vc[0][i] = vc[0][i-1] / 2;\n      } if mp[0][i-1] == 0 {\n        vc[0][i] = vc[0][i-1] / 2;\n      } else {\n        vc[0][i] = (vc[0][i-1] + 1) / 2;\n      }\n    }\n\n    for j in 1 .. h {\n      if vc[j-1][0] % 2 == 0 {\n        vc[j][0] = vc[j-1][0] / 2;\n      } if mp[j-1][0] == 1 {\n        vc[j][0] = vc[j-1][0] / 2;\n      } else {\n        vc[j][0] = (vc[j-1][0] + 1) / 2;\n      }\n    }\n    \n    for i in 1 .. w {\n      for j in 1 .. h {\n        match (vc[j][i-1] % 2, vc[j-1][i] % 2) {\n          (0, 0) => {\n            vc[j][i] = vc[j][i-1] / 2 + vc[j-1][i] / 2;\n          },\n          (0, 1) => {\n            vc[j][i] = vc[j][i-1] / 2 + if mp[j-1][i] == 1 { vc[j-1][i] / 2 } else { (vc[j-1][i] + 1) / 2 };\n          },\n          (1, 0) => {\n            vc[j][i] = if mp[j][i-1] == 0 { vc[j][i-1] / 2 } else { (vc[j][i-1] + 1) / 2 } + vc[j-1][i] / 2;\n          },\n          _ => {\n            vc[j][i] = if mp[j][i-1] == 0 { vc[j][i-1] / 2 } else { (vc[j][i-1] + 1) / 2 } +\n                       if mp[j-1][i] == 1 { vc[j-1][i] / 2 } else { (vc[j-1][i] + 1) / 2 } ;\n          },\n        }\n      }\n    }\n    \n    let mut x: usize = 0;\n    let mut y: usize = 0;\n\n    loop {\n      if x == w || y == h {\n        println!(\"{} {}\", y + 1, x + 1);\n        break;\n      }\n\n      if vc[y][x] % 2 == 0 && mp[y][x] == 0 || vc[y][x] % 2 == 1 && mp[y][x] == 1 {\n        y += 1;\n      } else {\n        x += 1;\n      }\n    }\n  }\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\n#[allow(dead_code)]\nfn main() {\n    loop {\n        let (h, w, n) = get!(usize, usize, usize);\n        if h == 0 && w == 0 && n == 0 {\n            break;\n        }\n        let map: Vec<Vec<usize>> = (0..h).map(|_| util::gets()).collect();\n\n        let mut dp = vec![vec![0; w]; h];\n        dp[0][0] = n;\n\n        for i in 0..h {\n            for j in 0..w {\n                if i > 0 {\n                    if map[i - 1][j] == 0 {\n                        dp[i][j] += (dp[i - 1][j] + 1) / 2;\n                    } else {\n                        dp[i][j] += dp[i - 1][j] / 2;\n                    }\n                }\n\n                if j > 0 {\n                    if map[i][j - 1] == 1 {\n                        dp[i][j] += (dp[i][j - 1] + 1) / 2;\n                    } else {\n                        dp[i][j] += dp[i][j - 1] / 2;\n                    }\n                }\n            }\n        }\n\n        let mut i = 0;\n        let mut j = 0;\n\n        while i < h && j < w {\n            // debug!(i, j);\n            if dp[i][j] % 2 == 0 {\n                if map[i][j] == 0 {\n                    j += 1;\n                } else {\n                    i += 1;\n                }\n            } else {\n                if map[i][j] == 0 {\n                    i += 1;\n                } else {\n                    j += 1;\n                }\n            }\n        }\n\n        // debug!(dp);\n\n        println!(\"{} {}\", i + 1, j + 1);\n    }\n}\n\n"
  }
]