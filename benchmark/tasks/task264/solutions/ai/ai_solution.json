[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint minMovesToDisinfect(int** grid, int gridSize, int* gridColSize) {\n    int rows = gridSize;\n    if (rows == 0) return -1;\n    int cols = gridColSize[0];\n    \n    Point queue[rows * cols];\n    int front = 0, rear = 0;\n    int visited[rows][cols];\n    memset(visited, -1, sizeof(visited));\n    \n    int remaining = 0;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 0) {\n                queue[rear++] = (Point){i, j};\n                visited[i][j] = 0;\n            } else if (grid[i][j] == 1) {\n                remaining++;\n            }\n        }\n    }\n    \n    if (remaining == 0) return 0;\n    \n    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    int max_time = 0;\n    \n    while (front < rear) {\n        Point current = queue[front++];\n        \n        for (int k = 0; k < 4; k++) {\n            int ni = current.x + dirs[k][0];\n            int nj = current.y + dirs[k][1];\n            \n            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && grid[ni][nj] == 1 && visited[ni][nj] == -1) {\n                visited[ni][nj] = visited[current.x][current.y] + 1;\n                max_time = visited[ni][nj];\n                queue[rear++] = (Point){ni, nj};\n                remaining--;\n            }\n        }\n    }\n    \n    return remaining == 0 ? max_time : -1;\n}\n\nint main() {\n    // Example usage\n    int gridSize = 3;\n    int gridColSize[] = {3, 3, 3};\n    int** grid = (int**)malloc(gridSize * sizeof(int*));\n    for (int i = 0; i < gridSize; i++) {\n        grid[i] = (int*)malloc(gridColSize[i] * sizeof(int));\n    }\n    \n    // Sample grid\n    grid[0][0] = 0; grid[0][1] = 1; grid[0][2] = 1;\n    grid[1][0] = 1; grid[1][1] = 1; grid[1][2] = 1;\n    grid[2][0] = 1; grid[2][1] = 1; grid[2][2] = 0;\n    \n    int result = minMovesToDisinfect(grid, gridSize, gridColSize);\n    printf(\"%d\\n\", result);\n    \n    for (int i = 0; i < gridSize; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:48:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int disinfectionTime(vector<vector<int>>& grid) {\n        int m = grid.size();\n        if (m == 0) return -1;\n        int n = grid[0].size();\n        \n        queue<pair<int, int>> q;\n        unordered_set<int> visited;\n        int target = 0;\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    q.push({i, j});\n                    visited.insert(i * n + j);\n                }\n                if (grid[i][j] != 2) {\n                    target |= (1 << (i * n + j));\n                }\n            }\n        }\n        \n        if (visited.size() == target) return 0;\n        \n        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        int steps = 0;\n        \n        while (!q.empty()) {\n            int size = q.size();\n            steps++;\n            for (int i = 0; i < size; ++i) {\n                auto curr = q.front(); q.pop();\n                int x = curr.first, y = curr.second;\n                for (auto& dir : dirs) {\n                    int nx = x + dir[0], ny = y + dir[1];\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                        if (grid[nx][ny] == 2) {\n                            grid[nx][ny] = 1;\n                            int key = nx * n + ny;\n                            if (visited.count(key) == 0) {\n                                visited.insert(key);\n                                q.push({nx, ny});\n                            }\n                        }\n                    }\n                }\n            }\n            if (visited.size() == target) return steps;\n        }\n        \n        return -1;\n    }\n};",
    "timestamp": "2025-08-05 20:49:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public int disinfectGrid(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        Queue<int[]> queue = new LinkedList<>();\n        int healthy = 0;\n        int time = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    queue.offer(new int[]{i, j});\n                } else if (grid[i][j] == 0) {\n                    healthy++;\n                }\n            }\n        }\n\n        if (healthy == 0) return 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] current = queue.poll();\n                for (int[] dir : DIRECTIONS) {\n                    int x = current[0] + dir[0];\n                    int y = current[1] + dir[1];\n                    if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 0) {\n                        grid[x][y] = 1;\n                        healthy--;\n                        queue.offer(new int[]{x, y});\n                    }\n                }\n            }\n            time++;\n        }\n\n        return healthy == 0 ? time - 1 : -1;\n    }\n}",
    "timestamp": "2025-08-05 20:49:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int minimumMoves(int[][] grid) {\n        int n = grid.length;\n        int uninfectedCount = 0;\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[n][n];\n\n        // Count uninfected areas and find initial vehicle positions\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    uninfectedCount++;\n                }\n                if (grid[i][j] == 1) {\n                    queue.offer(new int[]{i, j});\n                    visited[i][j] = true;\n                }\n            }\n        }\n\n        // If no uninfected areas, return 0\n        if (uninfectedCount == 0) return 0;\n\n        int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n        int moves = 0;\n\n        while (!queue.isEmpty() && uninfectedCount > 0) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] current = queue.poll();\n                for (int[] dir : directions) {\n                    int newX = current[0] + dir[0];\n                    int newY = current[1] + dir[1];\n\n                    if (newX >= 0 && newX < n && newY >= 0 && newY < n \n                        && !visited[newX][newY] && grid[newX][newY] == 0) {\n                        queue.offer(new int[]{newX, newY});\n                        visited[newX][newY] = true;\n                        uninfectedCount--;\n                    }\n                }\n            }\n            moves++;\n        }\n\n        return uninfectedCount == 0 ? moves : -1;\n    }\n}",
    "timestamp": "2025-08-05 20:49:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 100\n\nint grid[MAX_SIZE][MAX_SIZE];\nint visited[MAX_SIZE][MAX_SIZE];\nint rows, cols;\n\ntypedef struct {\n    int x, y, steps;\n} QueueNode;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint isValid(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols;\n}\n\nint bfs(int startX, int startY) {\n    QueueNode queue[MAX_SIZE * MAX_SIZE];\n    int front = 0, rear = 0;\n    int maxSteps = 0;\n\n    memset(visited, 0, sizeof(visited));\n    queue[rear++] = (QueueNode){startX, startY, 0};\n    visited[startX][startY] = 1;\n\n    while (front < rear) {\n        QueueNode current = queue[front++];\n        maxSteps = (current.steps > maxSteps) ? current.steps : maxSteps;\n\n        for (int i = 0; i < 4; i++) {\n            int newX = current.x + dx[i];\n            int newY = current.y + dy[i];\n\n            if (isValid(newX, newY) && !visited[newX][newY] && grid[newX][newY] == 0) {\n                queue[rear++] = (QueueNode){newX, newY, current.steps + 1};\n                visited[newX][newY] = 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 0 && !visited[i][j]) {\n                return -1;\n            }\n        }\n    }\n\n    return maxSteps;\n}\n\nint solve() {\n    int minMoves = INT_MAX;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 0) {\n                int moves = bfs(i, j);\n                if (moves != -1) {\n                    minMoves = (moves < minMoves) ? moves : minMoves;\n                }\n            }\n        }\n    }\n\n    return (minMoves == INT_MAX) ? -1 : minMoves;\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int result = solve();\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:49:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    int minimumMoves(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<pair<int, int>> zeros, ones;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) zeros.push_back({i, j});\n                else if (grid[i][j] > 1) ones.push_back({i, j});\n            }\n        }\n        \n        if (zeros.empty()) return 0;\n        \n        int minMoves = INT_MAX;\n        do {\n            int currentMoves = 0;\n            vector<pair<int, int>> tempOnes = ones;\n            \n            for (int i = 0; i < zeros.size(); i++) {\n                int minDist = INT_MAX;\n                int removeIndex = -1;\n                \n                for (int j = 0; j < tempOnes.size(); j++) {\n                    int dist = abs(zeros[i].first - tempOnes[j].first) + \n                               abs(zeros[i].second - tempOnes[j].second);\n                    \n                    if (dist < minDist) {\n                        minDist = dist;\n                        removeIndex = j;\n                    }\n                }\n                \n                currentMoves += minDist;\n                tempOnes.erase(tempOnes.begin() + removeIndex);\n            }\n            \n            minMoves = min(minMoves, currentMoves);\n        } while (next_permutation(zeros.begin(), zeros.end()));\n        \n        return minMoves;\n    }\n};",
    "timestamp": "2025-08-05 20:49:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_time_to_disinfect(grid):\n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    m, n = len(grid), len(grid[0])\n    queue = deque()\n    total_areas = 0\n    disinfection = 0\n    \n    # Initialize the queue with uninfected areas (0) and count total areas to be disinfected\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                queue.append((i, j, 0))\n                disinfection += 1\n            if grid[i][j] != -1:\n                total_areas += 1\n    \n    # If there are no uninfected areas, return -1 (impossible to disinfect)\n    if disinfection == 0:\n        return -1\n    \n    # BFS to disinfect all areas, compute the minimum time\n    time = 0\n    disinfected_count = 0\n    while queue:\n        x, y, t = queue.popleft()\n        if grid[x][y] == 0:\n            grid[x][y] = 2\n            disinfected_count += 1\n            time = max(time, t)\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 0\n                    queue.append((nx, ny, t + 1))\n    \n    # If all areas are disinfected, return the time; otherwise, return -1\n    return time if disinfected_count == total_areas else -1\n\n# Example usage\ngrid = [\n    [1, 0, -1, 1],\n    [1, 1, 0, 1],\n    [-1, 1, 1, 1]\n]\nprint(min_time_to_disinfect(grid))",
    "timestamp": "2025-08-13 03:40:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class VirusDisinfection {\n\n    static class Position {\n        int row;\n        int col;\n        Position(int r, int c) {\n            this.row = r;\n            this.col = c;\n        }\n    }\n\n    public int minTimeToDisinfectGrid(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        Queue<Position> queue = new LinkedList<>();\n\n        int uninfectedCount = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 0) {\n                    queue.offer(new Position(i, j));\n                    uninfectedCount++;\n                }\n            }\n        }\n\n        if (uninfectedCount == 0) return 0;\n        if (queue.isEmpty()) return -1;\n\n        int steps = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            steps++;\n            for (int i = 0; i < size; i++) {\n                Position current = queue.poll();\n                for (int[] dir : directions) {\n                    int newRow = current.row + dir[0];\n                    int newCol = current.col + dir[1];\n                    if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m && grid[newRow][newCol] == 1) {\n                        grid[newRow][newCol] = 0;\n                        queue.offer(new Position(newRow, newCol));\n                        uninfectedCount--;\n                        if (uninfectedCount == 0) return steps;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        VirusDisinfection sol = new VirusDisinfection();\n        int[][] grid1 = {\n            {1, 1, 1},\n            {1, 0, 1},\n            {1, 1, 1}\n        };\n        System.out.println(sol.minTimeToDisinfectGrid(grid1)); // Example output\n\n        int[][] grid2 = {\n            {1, 1, 1},\n            {1, 1, 1},\n            {1, 1, 1}\n        };\n        System.out.println(sol.minTimeToDisinfectGrid(grid2)); // Example output\n    }\n}",
    "timestamp": "2025-08-13 03:40:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define MAX_N 100\n\nint grid[MAX_N][MAX_N];\nint n;\n\ntypedef struct {\n    int x, y, time;\n} Node;\n\nint directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nbool visited[MAX_N][MAX_N];\n\nbool isValid(int x, int y) {\n    return x >= 0 && y >= 0 && x < n && y < n;\n}\n\nint bfs(int startX, int startY) {\n    int queueSize = n * n;\n    Node queue[queueSize];\n    int front = 0, rear = 0;\n\n    queue[rear++] = (Node){startX, startY, 0};\n    visited[startX][startY] = true;\n\n    int maxTime = 0;\n\n    while (front < rear) {\n        Node current = queue[front++];\n\n        for (int i = 0; i < 4; i++) {\n            int newX = current.x + directions[i][0];\n            int newY = current.y + directions[i][1];\n\n            if (isValid(newX, newY) && grid[newX][newY] == 0 && !visited[newX][newY]) {\n                visited[newX][newY] = true;\n                queue[rear++] = (Node){newX, newY, current.time + 1};\n                maxTime = current.time + 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 0 && !visited[i][j]) {\n                return -1;\n            }\n        }\n    }\n\n    return maxTime;\n}\n\nint minDisinfectionTime() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 0) {\n                memset(visited, false, sizeof(visited));\n                int time = bfs(i, j);\n                if (time != -1) return time;\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    printf(\"%d\\n\", minDisinfectionTime());\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:40:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_time_to_disinfect(grid):\n    rows, cols = len(grid), len(grid[0])\n    vehicle_positions = []\n    total_infected = 0\n\n    # Find initial vehicle positions and count infected areas\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 2:\n                vehicle_positions.append((r, c))\n            if grid[r][c] == 1:\n                total_infected += 1\n\n    # If no infected areas, return 0\n    if total_infected == 0:\n        return 0\n\n    # Directions for movement (up, down, left, right)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    visited = set(vehicle_positions)\n    time_steps = 0\n    disinfected = 0\n    queue = deque([(pos, 0) for pos in vehicle_positions])\n\n    while queue:\n        (r, c), steps = queue.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            # Check grid boundaries and valid moves\n            if (0 <= nr < rows and 0 <= nc < cols and \n                (nr, nc) not in visited and grid[nr][nc] == 1):\n                \n                # Disinfect area\n                grid[nr][nc] = 2\n                disinfected += 1\n                time_steps = max(time_steps, steps + 1)\n                \n                visited.add((nr, nc))\n                queue.append(((nr, nc), steps + 1))\n\n        # Check if all infected areas are disinfected\n        if disinfected == total_infected:\n            return time_steps\n\n    return -1",
    "timestamp": "2025-08-13 03:40:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef minMovesToDisinfect(grid):\n    rows = len(grid)\n    if rows == 0:\n        return -1\n    cols = len(grid[0])\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Find initial vehicle position and count of infected areas\n    vehicle_pos = None\n    infected_count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                infected_count += 1\n            elif grid[i][j] == 2:\n                vehicle_pos = (i, j)\n    \n    if vehicle_pos is None:\n        return -1\n    \n    # BFS setup\n    queue = deque()\n    # Each state is (vehicle_i, vehicle_j, infected_count, steps)\n    initial_state = (vehicle_pos[0], vehicle_pos[1], infected_count, 0)\n    queue.append(initial_state)\n    visited = set()\n    visited.add((vehicle_pos[0], vehicle_pos[1], infected_count))\n    \n    while queue:\n        i, j, remaining_infected, steps = queue.popleft()\n        \n        if remaining_infected == 0:\n            return steps\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] != 2:\n                new_remaining = remaining_infected\n                new_grid = [row[:] for row in grid]\n                \n                # Disinfect current and adjacent areas\n                for x, y in [(ni, nj), (ni-1, nj), (ni+1, nj), (ni, nj-1), (ni, nj+1)]:\n                    if 0 <= x < rows and 0 <= y < cols and new_grid[x][y] == 1:\n                        new_grid[x][y] = 0\n                        new_remaining -= 1\n                \n                # Move vehicle to (ni, nj)\n                new_grid[i][j] = 0\n                new_grid[ni][nj] = 2\n                \n                state_key = (ni, nj, new_remaining)\n                if state_key not in visited:\n                    visited.add(state_key)\n                    queue.append((ni, nj, new_remaining, steps + 1))\n    \n    return -1",
    "timestamp": "2025-08-13 03:41:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <limits.h>\n\nusing namespace std;\n\nstruct Step {\n    int x, y, time;\n};\n\nint minDisinfectionSteps(vector<vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    queue<Step> q;\n    int totalInfected = 0;\n    \n    // Directions to move: up, down, left, right\n    int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    // Find starting point and initial infection count\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 2) { // Vehicle's starting position\n                q.push({i, j, 0});\n                visited[i][j] = true;\n            }\n            if (grid[i][j] == 1) { // Initially infected\n                totalInfected++;\n            }\n        }\n    }\n    \n    int steps = 0;\n    int disinfectedCount = 0;\n    \n    while (!q.empty()) {\n        Step current = q.front();\n        q.pop();\n        \n        for (int d = 0; d < 4; d++) {\n            int nx = current.x + directions[d][0];\n            int ny = current.y + directions[d][1];\n            \n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]) {\n                if (grid[nx][ny] == 1) {\n                    grid[nx][ny] = 0;\n                    disinfectedCount++;\n                }\n                if (grid[nx][ny] == 0) {\n                    q.push({nx, ny, current.time + 1});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n        \n        steps = current.time;\n    }\n    \n    return (disinfectedCount == totalInfected) ? steps : -1;\n}\n\nint main() {\n    vector<vector<int>> grid = {\n        {0, 1, 0},\n        {1, 2, 1},\n        {0, 1, 0}\n    };\n\n    int result = minDisinfectionSteps(grid);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:14:26"
  }
]