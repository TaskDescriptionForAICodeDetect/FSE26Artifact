[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst int di[]={-1,-1,-1,0,0,1,1,1};\nconst int dj[]={-1,0,1,-1,1,-1,0,1};\n\nvs update(vs a)\n{\n\tint n=a.size();\n\tvs b(n,string(n,'.'));\n\trep(i,n) rep(j,n){\n\t\tif(a[i][j]=='@'){\n\t\t\tb[i][j]='@';\n\t\t\tcontinue;\n\t\t}\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint ni=i+di[k],nj=j+dj[k];\n\t\t\tif(0<=ni && ni<n && 0<=nj && nj<n && a[ni][nj]!='.')\n\t\t\t\tcnt++;\n\t\t}\n\t\tif(a[i][j]=='#' && (cnt==2 || cnt==3) || a[i][j]=='.' && cnt==3)\n\t\t\tb[i][j]='#';\n\t}\n\treturn b;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvs grid(n);\n\t\trep(i,n) cin>>grid[i];\n\t\t\n\t\tset<vs> vis;\n\t\tqueue<pair<vs,int>> q;\n\t\tq.emplace(grid,0);\n\t\tint res=-1;\n\t\twhile(q.size()){\n\t\t\tvs cur; int turn;\n\t\t\ttie(cur,turn)=q.front(); q.pop();\n\t\t\tif(vis.count(cur)) continue;\n\t\t\tvis.insert(cur);\n\t\t\t\n\t\t\tint cnt=0;\n\t\t\trep(i,n) rep(j,n) cnt+=cur[i][j]=='#';\n\t\t\tif(cnt==0){\n\t\t\t\tres=turn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,n) rep(j,n) if(cur[i][j]=='@') rep(k,8){\n\t\t\t\tint ni=i+di[k],nj=j+dj[k];\n\t\t\t\tif(ni<0 || n<=ni || nj<0 || n<=nj || cur[ni][nj]=='#') continue;\n\t\t\t\tswap(cur[i][j],cur[ni][nj]);\n\t\t\t\tq.emplace(update(cur),turn+1);\n\t\t\t\tswap(cur[i][j],cur[ni][nj]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <deque>\n#include <algorithm>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n\n#define MP make_pair\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//AOJ 1304\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={-1,0,1,-1,1,-1,0,1};\n\nset<int> vsi;\nint n;\n\ninline int getx(int a){return (a>>25 & 7);}\ninline int gety(int a){return (a>>28 & 7);}\ninline int getidx(int x, int y){return y*n+x;}\ninline int getstate(int a, int x, int y){return ((a>>getidx(x,y))&1);}\ninline int setstate(int a, int x, int y, int state){\n\tif(state){\n\t\treturn a|(1<<getidx(x,y));\n\t}else{\n\t\tint p=1<<getidx(x,y);\n\t\tp = ~p;\n\t\treturn a&p;\n\t}\n}\ninline int setpos(int a, int x, int y){\n\tint ret=a;\n\tret &= ((1<<25)-1);\n\tret |= x<<25;\n\tret |= y<<28;\n\treturn ret;\n}\n\ninline int count(int b){\n\tint ret = 0;\n\tREP(i,n)REP(j,n)if(getstate(b,i,j))ret++;\n\treturn ret-1;\n}\n\ninline int step(int &b){\n\tint tb = b;\n\tint ret = 0;\n\tint x=getx(b);\n\tint y=gety(b);\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(y==i&&x==j)continue;\n\t\t\tint cnt = 0;\n\t\t\tREP(k,8){\n\t\t\t\tint ny=i+dy[k];\n\t\t\t\tint nx=j+dx[k];\n\t\t\t\tif(nx<0 || ny<0 || nx>=n || ny>=n)continue;\n\t\t\t\tif(getstate(tb,nx,ny))cnt++;\n\t\t\t}\n\t\t\tif(getstate(tb,j,i)){\n\t\t\t\tif(cnt!=2&&cnt!=3)b=setstate(b,j,i,0);\n\t\t\t}else if(!getstate(tb,j,i)){\n\t\t\t\tif(cnt==3)b=setstate(b,j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>n, n){\n\t\tvsi.clear();\n\t\tstring b;\n\t\tREP(i,n){\n\t\t\tstring tmp;\n\t\t\tcin>>tmp;\n\t\t\tb+=tmp;\n\t\t}\n\t\tint is=0;\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tswitch(b[i*n+j]){\n\t\t\t\tcase '@':\n\t\t\t\t\tis = setpos(is, j, i);\n\t\t\t\tcase '#':\n\t\t\t\t\tis |= (1LL<<i*n+j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdeque<pair<int, int> > q;\n\t\tq.push_back(MP(0,is));\n\t\tint ans=-1;\n\t\twhile(!q.empty()){\n\t\t\tint x,y;\n\t\t\tpair<int, int> tmp=q.front();\n\t\t\tq.pop_front();\n\t\t\tif(EXIST(vsi,tmp.second))continue;\n\t\t\tvsi.insert(tmp.second);\n\t\t\tif(count(tmp.second)==0){\n\t\t\t\tans=tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = getx(tmp.second);\n\t\t\ty = gety(tmp.second);\n\t\t\tREP(i,8){\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(nx<0 || ny<0 || nx>=n || ny>=n || getstate(tmp.second, nx, ny)==1)continue;\n\t\t\t\tint tb = tmp.second;\n\t\t\t\ttb=setstate(tb,x,y,0);\n\t\t\t\ttb=setstate(tb,nx,ny,1);\n\t\t\t\ttb=setpos(tb,nx,ny);\n\t\t\t\tstep(tb);\n\t\t\t\tif(EXIST(vsi,tb))continue;\n\t\t\t\tq.push_back(MP(tmp.first+1, tb));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\n\nint N;\nint dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy[] = {1, 0, -1,  1, -1, 1, 0, -1};\nbool check(int bit, int x, int y){\n\treturn 0 <= x && x < N && 0 <= y && y < N && (bit & (1 << (y * N + x)));\n}\n\nint trans(int bit, int x, int y){\n\tint ans = 0;\n\tbit |= 1 << (y * N + x);\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i == y && j == x) continue;\n\t\t\tint cnt = 0;\n\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\tif(check(bit, j + dx[k], i + dy[k])) cnt++;\n\t\t\t}\n\t\t\tif(cnt == 3 || (cnt == 2 && check(bit, j, i))) ans |= 1 << (i * N + j);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint pbit(int bit, int x, int y){\n\tcout << \"===\" << x << \" \" << y << endl;\n\tint idx = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i == y && j == x) cout << '@';\n\t\t\telse if(bit & (1 << idx)) cout << '#';\n\t\t\telse cout << '.';\n\t\t\tidx++;\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tstring str;\n\twhile(cin >> N, N){\n\t\tint idx = 0;\n\t\tint bit = 0;\n\t\tint carx = 0, cary = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> str;\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tchar c = str[j];\n\t\t\t\tif(c == '#') bit |= (1 << idx);\n\t\t\t\tif(c == '@') {\n\t\t\t\t\tcarx = j;\n\t\t\t\t\tcary = i;\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\n\t\tset<P> reach;\n\t\tqueue<PP> que;\n\t\tque.push(PP(P(cary * N + carx, bit), 0));\n\t\tint ans = 10000000;\n\t\twhile(que.size()){\n\t\t\tPP p = que.front(); que.pop();\n\t\t\tif(p.first.second == 0){\n\t\t\t\tans = min(ans, p.second);\n\t\t\t\tbreak;\n\t\t\t}else if(!reach.count(p.first)){\n\t\t\t\treach.insert(p.first);\n\t\t\t\tint y = p.first.first / N;\n\t\t\t\tint x = p.first.first % N;\n\t\t\t\t//cout << x << \" \" << y << endl;\n\t\t\t\tfor(int i = 0; i < 8; i++){\n\t\t\t\t\tif(check(~p.first.second, x + dx[i], y + dy[i])){\n\t\t\t\t\t\tint nb = trans(p.first.second, x + dx[i], y + dy[i]);\n\t\t\t\t\t\tque.push(PP(P((x + dx[i]) + (y + dy[i]) * N, nb), p.second + 1));\n\n\t\t\t\t\t\t//pbit(p.first.second, x, y);\n\t\t\t\t\t\t//cout << \"|||\" << endl;\n\t\t\t\t\t\t//pbit(nb, x + dx[i], y + dy[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 10000000){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nstruct data{\n  uint x : 3;\n  uint y : 3;\n  uint b : 26;\n\n  inline data() : x(0), y(0), b(0) {}\n  inline data(uint xx, uint yy, uint bb) : x(xx), y(yy), b(bb) {}\n  inline operator bool () { return b != (1<<26) - 1; }\n  void printa(int n){\n    REP(i,n){\n      REP(j,n){\n        if(x == j && y == i) printf(\"@\");\n        else printf(\"%c\",((1<<(i*n+j))&b) ? '#' : '.');\n      }\n      puts(\"\");\n    }\n  }\n}__attribute__((packed));\n\ndata m = data(0,0,(1<<26)-1);\n\n#define print(x) printf(\"%d\\n\",x)\nconst int _dx[] = {-1,-1,-1,0,0,1,1,1};\nconst int _dy[] = {-1,0,1,-1,1,-1,0,1};\n\nint main(){\n  int n;\n  while(scanf(\"%d \",&n), n){\n    data init; init.b = 0;\n\n    REP(i,n){\n      char buff[10];\n      scanf(\"%s \",buff);\n      REP(j,n){\n        switch(buff[j]){\n        case '.': break;\n        case '#': init.b |= (1<<(i*n+j)); break;\n        case '@': init.x = j; init.y = i; break;\n        }\n      }\n    }\n\n    //    init.printa(n);\n\n    int ans = 0;\n    const int th = 11;\n    queue<data> q;\n    q.push(init); q.push(m);\n\n    while(q.size() != 1){\n      data d = q.front();\n      q.pop();\n\n      if(!d){\n        ans++;\n        q.push(m);\n        //printf(\"ans: %d\\n\",ans);\n        continue;\n      }\n\n      if(d.b == 0){\n        print(ans);\n        break;\n      }\n\n      if(ans > th)\n        break;\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n      REP(i,8){\n        int xx = (int)d.x + _dx[i];\n        int yy = (int)d.y + _dy[i];\n        if(ISIN(xx,yy,n,n) && (d.b & (1<<(yy*n+xx))) == 0){\n          data dd(xx,yy,0);\n          REP(y,n) REP(x,n) if(y != yy || x != xx){\n            int cnt = 0;\n            REP(j,8){\n              int xxx = x + _dx[j];\n              int yyy = y + _dy[j];\n              if(ISIN(xxx,yyy,n,n) && (d.b & (1<<(yyy*n+xxx))))\n                cnt++;\n              else if(xx == xxx && yy == yyy) cnt++;\n            }\n            if(d.b & (1<<(y*n+x))){\n              if(cnt == 2 || cnt == 3) dd.b |= (1<<(y*n+x));\n            }else{\n              if(cnt == 3) dd.b |= (1<<(y*n+x));\n            }\n          }\n          q.push(dd);\n        }\n      }\n\n    }\n\n    if(ans > th) print(-1);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nint in(int y,int x,int n){\n  return 0<=y&&y<n&&0<=x&&x<n;\n}\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    string s[n];\n    for(int i=0;i<n;i++) cin>>s[i];\n    int st=0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(s[i][j]=='@') st+=(i*n+j)<<(n*n);\n\telse if(s[i][j]=='#') st+=1<<(i*n+j);\n    \n    int ans=-1,mask=(1<<(n*n))-1;\n    //cout<<mask<<endl;\n    int ax[]={1,1,1,0,0,-1,-1,-1};\n    int ay[]={-1,0,1,-1,1,-1,0,1};\n    queue<P> q;\n    \n    q.push(P(st,0));\n    set<int> si;\n    while(!q.empty()){\n      P p=q.front();q.pop();\n      int b=p.first,d=p.second;\n      if(si.count(b)) continue;\n      si.insert(b);\n      int c=b&mask;\n      int z=b>>(n*n);\n      int y=z/n,x=z%n;\n      if(c==0){\n\tans=d;\n\tbreak;\n      }\n      for(int k=0;k<8;k++){\n\tint ny=y+ay[k],nx=x+ax[k],nb=0;\n\tif(!in(ny,nx,n)) continue;\n\tif((c>>(ny*n+nx))&1) continue;\n\tfor(int i=0;i<n;i++){\n\t  for(int j=0;j<n;j++){\n\t    if(ny==i&&nx==j) continue;\n\t    int v=0;\n\t    for(int a=0;a<8;a++){\n\t      if(!in(i+ay[a],j+ax[a],n)) continue;\n\t      if((c>>((i+ay[a])*n+(j+ax[a])))&1) v++;\n\t      else if(ny==i+ay[a]&&nx==j+ax[a]) v++;\n\t    }\n\t    if((c>>(i*n+j))&1){\n\t      if(v==2||v==3) nb+=1<<(i*n+j);\n\t    }else{\n\t      if(v==3) nb+=1<<(i*n+j);\n\t    }\n\t  }\n\t}\n\tnb+=(ny*n+nx)<<(n*n);\n\tq.push(P(nb,d+1));\n      }\n    }\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\n#define REP(i,N) for(int i = 0; i < (int)(N); ++i)\n#define ALL(v) (v).begin(), (v).end()\ntemplate<class T> void pv(T a, T b){for(T i=a;i!=b;++i)cout<<*i<<\" \";cout<<endl;}\n\nconst int dr[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dc[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nstruct State {\n\tint N;\n\tchar table[5][5];\n\tbool valid(int r, int c) {\n\t\treturn 0 <= r && r < N && 0 <= c && c < N;\n\t}\n\tvoid print() {\n\t\tREP(i, N) {\n\t\t\tREP(j, N) cout << table[i][j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tbool operator<(const State& t) const {\n\t\tREP(i, N) REP(j, N) if( table[i][j] != t.table[i][j] ) return table[i][j] < t.table[i][j];\n\t}\n\t\n\tbool finish() {\n\t\tREP(i, N) REP(j, N) if( table[i][j] == '#' ) return 0;\n\t\treturn 1;\n\t}\n\t\n\tvector<State> get_next() {\n\t\tvector<State> res;\n\t\t\n\t\tint x, y;\n\t\tREP(i, N) REP(j, N) if( table[i][j] == '@' ) {\n\t\t\tx = i;\n\t\t\ty = j;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tREP(k, 8) {\n\t\t\tint nx = x + dr[k];\n\t\t\tint ny = y + dc[k];\n\t\t\tif( !valid(nx, ny) || table[nx][ny] == '#' ) continue;\n\t\t\tState t = *this;\n\t\t\tswap( t.table[x][y], t.table[nx][ny] );\n\t\t\tt.trans();\n\t\t\tres.push_back(t);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid trans() {\n\t\tint next[5][5];\n\t\tREP(i, N) REP(j, N) next[i][j] = '.';\n\t\tREP(i, N) REP(j, N) {\n\t\t\tif( table[i][j] == '@' ) next[i][j] = '@';\n\t\t\telse if( table[i][j] == '.' ) {\n\t\t\t\tint adj = count(i, j);\n\t\t\t\tif( adj == 3 ) next[i][j] = '#';\n\t\t\t}\n\t\t\telse if( table[i][j] == '#') {\n\t\t\t\tint adj = count(i, j);\n\t\t\t\tif( adj == 2 || adj == 3 ) \n\t\t\t\t\tnext[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tREP(i, N) REP(j, N) table[i][j] = next[i][j];\n\t}\n\tint count(int x, int y) {\n\t\tint cnt = 0;\n\t\tREP(k, 8) {\n\t\t\tint nx = x + dr[k];\n\t\t\tint ny = y + dc[k];\n\t\t\tif( valid(nx, ny) && table[nx][ny] != '.' ) cnt++;\n\t\t}\n\t\treturn cnt;\n\t}\n};\n\nint bfs(State s) {\n\tmap<State, int> memo;\n\tqueue<State> q;\n\tq.push(s);\n\tmemo[s] = 0;\n\twhile( !q.empty() ) {\n\t\ts = q.front(); q.pop();\n\t\tint cost = memo[s];\n\t\tif( s.finish() ) return cost;\n\t\t\n\t\tvector<State> next = s.get_next();\n\t\tfor(int i = 0; i < next.size(); i++) {\n\t\t\tif( memo.find(next[i]) == memo.end() ) {\n\t\t\t\tmemo[next[i]] = cost + 1;\n\t\t\t\tq.push(next[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tfor(int N; scanf(\"%d\", &N) && N; ) {\n\t\tState start;\n\t\tstart.N = N;\n\t\tREP(i, N) REP(j, N) {\n\t\t\tscanf(\" %c\", &start.table[i][j]);\n\t\t}\n\t\tcout << bfs(start) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\n\n\nstruct state {\n  int turn;\n  int y,x;\n  string ba;\n  state() {}\n  state(int a,int y, int x, string ba) : turn(a) ,y(y) , x(x) ,ba(ba)  {}\n};\n\nint dx[] = {-1,-1,-1,0,0,1,1,1};\nint dy[] = {-1,0,1,-1,1,-1,0,1};\nint main() {\n  int n;\n  while(cin >> n , n){\n    state stat;\n    string ba;\n    for(int i = 0; i < n; i++){\n      string str;\n      cin >> str;\n      ba+=str;\n      REP(j, str.size()) {\n        if (str[j] == '@') {\n          stat.y = i;\n          stat.x = j;\n        }\n      }\n    }\n    stat.ba = ba;\n    stat.turn = 0;\n    queue<state> Q;\n    Q.push(stat);\n\n    int res = -1;\n    map<string , bool> visited;\n    \n    while(!Q.empty()) {\n      state now = Q.front();\n      Q.pop();\n\n      if (visited[now.ba]) continue;\n      visited[now.ba] = 1;\n//      cout << now.turn << endl;\n      \n\n      // REP(i, n) {\n      //   REP(j, n) {\n      //     cout << now.ba[i][j];\n      //   }\n      //   cout << endl;\n      // }\n\n      bool f = 0;\n      REP(i, n) {\n        REP(j, n) {\n          if (now.ba[i*n+j] == '#') {\n            f = 1;\n            break;\n          }\n        }\n        if(f) break;\n      }\n      if (!f) {\n        res = now.turn;\n        break;\n      }\n      REP(k, 8) {\n        int yy = now.y+dy[k];\n        int xx = now.x+dx[k];\n\n        if(yy<0||yy>=n||xx<0||xx>=n) continue;\n        if(now.ba[yy*n+xx] == '#') continue;\n\n        //  cout << yy << \" \" << xx << endl;\n        state next = now;\n        next.turn++;\n        next.ba[now.y*n+now.x] = '.';\n        next.y = yy;\n        next.x = xx;\n        next.ba[yy*n+xx] = '@';\n        \n        REP(i, n) {\n          REP(j, n) {\n            int cnt = 0;\n            REP(k, 8) {\n              int ii = i+dy[k];\n              int jj = j+dx[k];\n              if (ii<0||ii>=n||jj<0||jj>=n) continue;\n              if (now.ba[ii*n+jj] == '#' || next.ba[ii*n+jj] == '@') cnt++;\n            }\n            if (next.ba[i*n+j] == '#') {\n              if (cnt == 2 || cnt == 3);\n              else {\n                next.ba[i*n+j] = '.';\n              }\n            } else if (next.ba[i*n+j] == '.') {\n              if (cnt == 3) {\n                next.ba[i*n+j] = '#';\n              }\n            }\n          }\n        }\n        \n        if(visited[next.ba]) continue;\n        Q.push(next);\n      }\n    }\n    cout << res << endl;\n  }\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr int dx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconstexpr int dy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\n\n\ninline int encode(const vector<string> &state) {\n\tconst int n = state.size();\n\n\tint index;\n\tint res = 0;\n\n\tfor(int y = 0; y < n; ++y) {\n\t\tfor(int x = 0; x < n; ++x) {\n\t\t\tres = (res << 1) + (state[y][x] == '#' ? 1 : 0);\n\t\t\tif(state[y][x] == '@') {\n\t\t\t\tindex = x + y * n;\n\t\t\t}\n\t\t}\n\t}\n\n\tres |= (index << (n * n));\n\treturn res;\n}\n\ninline vector<string> decode(int code, int n) {\n\tvector<string> res(n, string(n, '.'));\n\tfor(int y = n - 1; y >= 0; --y) {\n\t\tfor(int x = n - 1; x >= 0; --x) {\n\t\t\tif(code & 1) res[y][x] = '#';\n\t\t\tcode >>= 1;\n\t\t}\n\t}\n\n\tres[code / n][code % n] = '@';\n\treturn res;\n}\n\ninline bool out(int x, int y, int n) {\n\treturn x < 0 || y < 0 || x >= n || y >= n;\n}\n\nvector<string> update(const vector<string> &state) {\n\tconst int n = state.size();\n\tvector<string> res(n, string(n, '.'));\n\n\tfor(int y = 0; y < n; ++y) {\n\t\tfor(int x = 0; x < n; ++x) {\n\t\t\tif(state[y][x] == '@') {\n\t\t\t\tres[y][x] = '@';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint cnt = 0;\n\t\t\tfor(int d = 0; d < 8; ++d) {\n\t\t\t\tconst int nx = x + dx[d];\n\t\t\t\tconst int ny = y + dy[d];\n\n\t\t\t\tif(!out(nx, ny, n) && state[ny][nx] != '.') ++cnt;\n\t\t\t}\n\n\t\t\tif(cnt == 3 || (cnt == 2 && state[y][x] == '#')) {\n\t\t\t\tres[y][x] = '#';\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint bfs(const vector<string> &start) {\n\tconst int n = start.size();\n\tconst int s = encode(start);\n\tconst int goal_mask = (1 << (n * n)) - 1;\n\n\tif((s & goal_mask) == 0) return 0;\n\n\tunordered_map<int, int> dist;\n\tqueue<int> que;\n\n\tdist.insert({0, s});\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int code = que.front();\n\t\tque.pop();\n\n\t\tconst int current_dist = dist[code];\n\t\tconst auto state = decode(code, n);\n\t\tconst int x = (code >> n * n) % n;\n\t\tconst int y = (code >> n * n) / n;\n\n\t\tfor(int d = 0; d < 8; ++d) {\n\t\t\tconst int nx = x + dx[d];\n\t\t\tconst int ny = y + dy[d];\n\n\t\t\tif(out(nx, ny, n) || state[ny][nx] == '#') continue;\n\n\t\t\tvector<string> next_state(state);\n\t\t\tswap(next_state[ny][nx], next_state[y][x]);\n\t\t\tnext_state = update(move(next_state));\n\t\t\tconst int next_code = encode(next_state);\n\n\t\t\tif(!dist.count(next_code)) {\n\t\t\t\tif((next_code & goal_mask) == 0) return current_dist + 1;\n\t\t\t\tdist.insert({next_code, current_dist + 1});\n\t\t\t\tque.push(next_code);\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tvector<string> start(n);\n\t\tfor(auto &e : start) cin >> e;\n\t\tcout << bfs(start) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int stage;\n  int move_count;\n  State(int _x,int _y,int _s, int _m) : x(_x),y(_y),stage(_s),move_count(_m){}\n  State() : x(0),y(0),stage(0),move_count(0){}\n\n  bool operator<(const State& s) const{\n    return move_count < s.move_count;\n  }\n  bool operator>(const State& s) const{\n    return move_count > s.move_count;\n  }\n};\n\nint update(int stage,int vx,int vy,int N){\n  int next = stage;\n  for(int y=0;y<N;y++){\n    for(int x=0;x<N;x++){\n      if(x == vx && y == vy) continue;\n      int count = 0;\n      for(int i=0;i<8;i++){\n\tint dx = x + tx[i];\n\tint dy = y + ty[i];\n\tif(dx < 0 || dy < 0\n\t   || dx >= N || dy >=N) continue;\n\tif(stage & (1 << (dy*N+dx))) count++;\n\tif(dx == vx && dy == vy) count++;\n      }\n      if((stage & (1<<(y*N+x)))\n\t && (count == 3 || count == 2)){\n\tnext |= (1<<(y*N+x));\n      }\n      else if(!(stage & (1<<(y*N+x)))\n\t      && count == 3){\n\tnext |= (1<<(y*N+x));\n      }\n      else{\n\tnext &= ~(1<<(y*N+x));\n      }\n    }\n  }\n  return next;\n}\n\nvoid print_stage(int stage,int N){\n  for(int y=0;y<N;y++){\n    for(int x=0;x<N;x++){\n      printf(\"%c\",(stage & (1<<(y*N+x)) ? '#' : '.'));\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N==0) break;\n\n    int stage = 0;\n    int sx,sy;\n    for(int y=0;y<N;y++){\n      char buf[128];\n      scanf(\"%s\",buf);\n      for(int x=0;x<N;x++){\n\tif(buf[x] == '@'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(buf[x] == '#'){\n\t  stage |= (1 << (y*N+x));\n\t}\n      }\n    }\n    priority_queue<State,vector<State>,greater<State> > que;\n    //x,y,visited,stage,move_count\n    que.push(State(sx,sy,stage,0));\n    \n    map<int,int> move_count[25];\n    move_count[sy*N+sx][stage] = 0;\n    int res = -1;\n    if(stage == 0){\n      res = 0;\n      goto found;\n    }\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int i=0;i<8;i++){\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\tif(dx < 0 || dy < 0\n\t   || dx >= N || dy >=N) continue;\n\tif(s.stage & (1<<(dy*N+dx))) continue;\n\n\t// print_stage(s.stage,N);\n\tint next_stage = update(s.stage,dx,dy,N);\n\n\tmap<int,int>::iterator it = move_count[dy*N+dx].find(next_stage);\n\tif(it != move_count[dy*N+dx].end()) continue;\n\t\n\tmove_count[dy*N+dx][next_stage] = s.move_count + 1;\n\tif(next_stage == 0){\n\t  res = s.move_count + 1;\n\t  goto found;\n\t}\n\n\tque.push(State(dx,dy,next_stage,s.move_count+1));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define TOP 0\n#define FRONT 1 \n#define LEFT 2\n#define RIGHT 3\n#define BACK 4\n#define BOTTOM 5\n#define N 30\nusing namespace std;\n\n//TOP,FRONT,LEFT,RIGHT,BACK,BOTTOM\nchar dice[6];\nchar clist[6]={'r','m','y','b','g','c'};\n\nvoid init(){\n  for(int i=0;i<6;i++)\n    dice[i]=clist[i];\n}\n\n//?\\\\?????¢??????\nvoid rotN(){\n  swap(dice[TOP],dice[FRONT]);\n  swap(dice[FRONT],dice[BOTTOM]);\n  swap(dice[BOTTOM],dice[BACK]);\n}\n\n//???????????¢??????\nvoid rotS(){\n  //rotN(),rotN(),rotN();\n  swap(dice[TOP],dice[BACK]);\n  swap(dice[BACK],dice[BOTTOM]);\n  swap(dice[BOTTOM],dice[FRONT]);\n}\n\n//????????¢??????\nvoid rotE(){\n  swap(dice[TOP],dice[LEFT]);\n  swap(dice[LEFT],dice[BOTTOM]);\n  swap(dice[BOTTOM],dice[RIGHT]);\n}\n\n//????????¢??????\nvoid rotW(){\n  //rotE(),rotE(),rotE();\n  swap(dice[TOP],dice[RIGHT]);\n  swap(dice[RIGHT],dice[BOTTOM]);\n  swap(dice[BOTTOM],dice[LEFT]);\n}\n\n\nstring s[N],t;\nint h,w;\nint ctoi[300];\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nint check(int ny,int nx,int p){\n  \n  char c=s[ny][nx];\n  \n  if(c=='k')return 2;\n  \n  if(c=='w')return 0;\n  \n  if(c==t[p]&&c==dice[TOP])return 1;\n  return 2;\n}\n\nvoid Rot(int dir){\n  if(dir==0)rotN();\n  if(dir==1)rotE();\n  if(dir==2)rotS();\n  if(dir==3)rotW();\n}\n\nstruct dat{\n  int cost,y,x,p;\n  char dice[6];\n  dat(){};\n  dat(int a,int b,int c,int d){cost=a,y=b,x=c,p=d;};\n};\n\nint d[N][N][6][6][6];\n\nint bfs(int sy,int sx){\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<6;k++)\n\tfor(int l=0;l<6;l++)\n\t  for(int m=0;m<6;m++)\n\t    d[i][j][k][l][m]=INF;\n  \n  d[sy][sx][0][ctoi[dice[TOP]]][ctoi[dice[FRONT]]]=0;\n  \n  queue<dat> q;\n  \n  dat A=dat(0,sy,sx,0);\n  for(int i=0;i<6;i++)A.dice[i]=dice[i];\n  \n  q.push(A);\n  \n  while(!q.empty()){\n    dat u=q.front(); q.pop();\n    \n    if(d[u.y][u.x][u.p][ctoi[u.dice[TOP]]][ctoi[u.dice[FRONT]]]<u.cost)continue;\n    if(u.p==t.size())return u.cost;\n    \n    \n    for(int i=0;i<4;i++){\n      int ny=u.y+dy[i],nx=u.x+dx[i],ncost=u.cost+1;\n     \n      if(ny<0||nx<0||h<=ny||w<=nx)continue;\n      \n      for(int j=0;j<6;j++)dice[j]=u.dice[j];\n      \n      Rot(i);\n      for(int j=0;j<6;j++)u.dice[j]=dice[j];\n      \n      int r=check(ny,nx,u.p);\n      \n      int flag=0;\n      \n      for(int j=0;j<u.p;j++)\n\tif(s[ny][nx]!='k'&&s[ny][nx]!='w'&&s[ny][nx]==t[j])flag=1;\n      \n      if(r==2||flag){\n\tRot(i); Rot(i); Rot(i);\n\tfor(int j=0;j<6;j++)u.dice[j]=dice[j];\n\tcontinue;\n      }\n      \n      if(d[ny][nx][u.p+r][ctoi[u.dice[TOP]]][ctoi[u.dice[FRONT]]]>ncost){\n\td[ny][nx][u.p+r][ctoi[u.dice[TOP]]][ctoi[u.dice[FRONT]]]=ncost;\n\tdat A=dat(ncost,ny,nx,u.p+r);\n\tfor(int j=0;j<6;j++)A.dice[j]=u.dice[j];\n\tq.push(A);\n      }\n    \n      Rot(i); Rot(i); Rot(i);\n      for(int j=0;j<6;j++)u.dice[j]=dice[j];\n    }\n\n  }\n  \n  return INF;\n}\n\nint main(){\n  ctoi['r']=0;  ctoi['m']=1;\n  ctoi['y']=2;  ctoi['b']=3;\n  ctoi['g']=4;  ctoi['c']=5;\n  \n  while(1){\n    \n    cin>>w>>h;\n    if(!h&&!w)break;\n    \n    int sy,sx;\n    for(int i=0;i<h;i++){\n      cin>>s[i];\n      \n      for(int j=0;j<w;j++)\n\tif(s[i][j]=='#'){\n\t  sy=i,sx=j;\n\t  s[i][j]='w';\n\t}\n      \n    }\n    cin>>t;\n    \n    init();\n    int ans=bfs(sy,sx);\n    \n    if(ans==INF) cout<<\"unreachable\"<<endl;\n    else cout<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nstruct Field {\n  int state;\n  char x;\n  char y;\n  int cost;\n  bool operator<(const Field &rhs) const {\n    if (state != rhs.state) { return state < rhs.state; }\n    if (x != rhs.x) { return x < rhs.x; }\n    return y < rhs.y;\n  }\n};\n\nchar input[10][10];\nint now[5][5];\nint temp[5][5];\nint temp2[5][5];\nint n;\nconst int dx[8] = { 1, 1,  1,  0, -1, -1, -1, 0 };\nconst int dy[8] = { 1, 0, -1, -1, -1,  0,  1, 1 };\nset<Field> visit;\n\nvoid print_now(int px, int py) {\n  for (int y = 0; y < n; y++) {\n    for (int x = 0; x < n; x++) {\n      if (temp[y][x] == 1) {\n        putchar('#');\n      } else if (px == x && py == y) {\n        putchar('@');\n      } else {\n        putchar('.');\n      }\n    }\n    puts(\"\");\n  }\n  puts(\"\");\n}\n\nvoid encode(Field &field, int x, int y) {\n  field.x = x;\n  field.y = y;\n  field.cost++;\n  temp[y][x] = 0;\n  field.state = 0;\n  for (int y = 0; y < n; y++) {\n    for (int x = 0; x < n; x++) {\n      if (temp[y][x] == 1) {\n        field.state |= 1 << (x + y * n);\n      }\n    }\n  }\n}\n\nvoid decode(Field field, int &x, int &y) {\n  x = field.x;\n  y = field.y;\n  for (int y = 0; y < n; y++) {\n    for (int x = 0; x < n; x++) {\n      temp[y][x] = (field.state >> (x + y * n)) & 1;\n    }\n  }\n}\n\n\nint get_sum(int x, int y) {\n  int sum = 0;\n  for (int i = 0; i < 8; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if (nx < 0 || nx >= n || ny < 0 || ny >= n) { continue; }\n    sum += temp[ny][nx];\n  }\n  return sum;\n}\n\nvoid lifegame(int x, int y) {\n  temp[y][x] = 1;\n  for (int y = 0; y < n; y++) {\n    for (int x = 0; x < n; x++) {\n      int sum = get_sum(x, y);\n      if (temp[y][x] == 0 && sum == 3) {\n        temp2[y][x] = 1;\n      } else if (temp[y][x] == 1 && (sum == 2 || sum == 3)) {\n        temp2[y][x] = 1;\n      } else {\n        temp2[y][x] = 0;\n      }\n    }\n  }\n  memcpy(temp, temp2, sizeof(temp));\n}\n\nbool end() {\n  for (int y = 0; y < n; y++) {\n    for (int x = 0; x < n; x++) {\n      if (temp[y][x] == 1) { return false; }\n    }\n  }\n  return true;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    int sx, sy;\n    for (int y = 0; y < n; y++) {\n      scanf(\"%s\", input[y]);\n      for (int x = 0; x < n; x++) {\n        if (input[y][x] == '.') {\n          temp[y][x] = 0;\n        } else if (input[y][x] == '#') {\n          temp[y][x] = 1;\n        } else {\n          temp[y][x] = 0;\n          sx = x;\n          sy = y;\n        }\n      }\n    }\n    queue<Field> que;\n    Field field;\n    encode(field, sx, sy);\n    field.cost = 0;\n    que.push(field);\n    visit.clear();\n    visit.insert(field);\n    while (!que.empty()) {\n      field = que.front();\n      que.pop();\n      int x, y;\n      decode(field, x, y);\n      if (end()) { printf(\"%d\\n\", field.cost); goto next; }\n      memcpy(now, temp, sizeof(now));\n      //print_now(x, y);\n      for (int i = 0; i < 8; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx >= n || ny < 0 || ny >= n) { continue; }\n        if (now[ny][nx] == 1) { continue; }\n        Field next = field;\n        memcpy(temp, now, sizeof(temp));\n        lifegame(nx, ny);\n        encode(next, nx, ny);\n        if (visit.find(next) != visit.end()) { continue; }\n        visit.insert(next);\n        que.push(next);\n      }\n    }\n    puts(\"-1\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr int dx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconstexpr int dy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\n\n\ninline int encode(const vector<string> &state) {\n\tconst int n = state.size();\n\n\tint index;\n\tint res = 0;\n\n\tfor(int y = 0; y < n; ++y) {\n\t\tfor(int x = 0; x < n; ++x) {\n\t\t\tres = (res << 1) + (state[y][x] == '#' ? 1 : 0);\n\t\t\tif(state[y][x] == '@') {\n\t\t\t\tindex = x + y * n;\n\t\t\t}\n\t\t}\n\t}\n\n\tres |= (index << (n * n));\n\treturn res;\n}\n\ninline vector<string> decode(int code, int n) {\n\tvector<string> res(n, string(n, '.'));\n\tfor(int y = n - 1; y >= 0; --y) {\n\t\tfor(int x = n - 1; x >= 0; --x) {\n\t\t\tif(code & 1) res[y][x] = '#';\n\t\t\tcode >>= 1;\n\t\t}\n\t}\n\n\tres[code / n][code % n] = '@';\n\treturn res;\n}\n\ninline bool out(int x, int y, int n) {\n\treturn x < 0 || y < 0 || x >= n || y >= n;\n}\n\ninline vector<string> update(const vector<string> &state) {\n\tconst int n = state.size();\n\tvector<string> res(n, string(n, '.'));\n\n\tfor(int y = 0; y < n; ++y) {\n\t\tfor(int x = 0; x < n; ++x) {\n\t\t\tif(state[y][x] == '@') {\n\t\t\t\tres[y][x] = '@';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint cnt = 0;\n\t\t\tfor(int d = 0; d < 8; ++d) {\n\t\t\t\tconst int nx = x + dx[d];\n\t\t\t\tconst int ny = y + dy[d];\n\n\t\t\t\tif(!out(nx, ny, n) && state[ny][nx] != '.') ++cnt;\n\t\t\t}\n\n\t\t\tif(cnt == 3 || (cnt == 2 && state[y][x] == '#')) {\n\t\t\t\tres[y][x] = '#';\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint bfs(const vector<string> &start) {\n\tconst int n = start.size();\n\tconst int s = encode(start);\n\tconst int goal_mask = (1 << (n * n)) - 1;\n\n\tif((s & goal_mask) == 0) return 0;\n\n\tunordered_map<int, int> dist;\n\tqueue<int> que;\n\n\tdist.insert({s, 0});\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int code = que.front();\n\t\tque.pop();\n\n\t\tconst int current_dist = dist[code];\n\t\tconst auto state = decode(code, n);\n\t\tconst int x = (code >> (n * n)) % n;\n\t\tconst int y = (code >> (n * n)) / n;\n\n\t\tfor(int d = 0; d < 8; ++d) {\n\t\t\tconst int nx = x + dx[d];\n\t\t\tconst int ny = y + dy[d];\n\n\t\t\tif(out(nx, ny, n) || state[ny][nx] == '#') continue;\n\n\t\t\tvector<string> next_state(state);\n\t\t\tswap(next_state[ny][nx], next_state[y][x]);\n\t\t\tnext_state = update(move(next_state));\n\t\t\tconst int next_code = encode(next_state);\n\n\t\t\tif(!dist.count(next_code)) {\n\t\t\t\tif((next_code & goal_mask) == 0) return current_dist + 1;\n\t\t\t\tdist.insert({next_code, current_dist + 1});\n\t\t\t\tque.push(next_code);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint cnt = 0;\n\tfor(int n; cin >> n && n;) {\n\t\tvector<string> start(n);\n\t\tfor(auto &e : start) cin >> e;\n\t\tcout << bfs(start) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint dx[]={0,-1,0,1,-1,-1,1,1};\nint dy[]={-1,0,1,0,-1,1,-1,1};\n\nclass State\n{\npublic:\n\tbool f[5][5];\n\tint h,c,x,y;\n\n\tState(int x, int y, bool tmf[5][5], int h, int c)\n\t\t:h(h),c(c),x(x),y(y)\n\t{\n\t\tfor(int i=0; i<5; i++)\n\t\tfor(int j=0; j<5; j++)\n\t\t\tf[j][i]=tmf[j][i];\n\t}\n};\n\nbool tf[5][5],hs[5][5][(1<<25)];\n\nint ch(bool f[5][5],int N)\n{\n\tint ret=0,cnt=0;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t{\n\t\tret|=(f[j][i]<<cnt);\n\t\tcnt++;\n\t}\n\n\treturn ret;\n}\n\nvoid mov(int x, int y, bool f[5][5], int N)\n{\n\tmemset(tf,0,sizeof(tf));\n\tf[x][y]=1;\n\tint cnt[5][5]={0};\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t{\n\t\tif(!f[j][i]) continue;\n\t\tfor(int k=0; k<8; k++)\n\t\t{\n\t\t\tint tx=j+dx[k], ty=i+dy[k];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N) continue;\n\n\t\t\tcnt[tx][ty]++;\n\t\t}\n\t}\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t{\n\t\tif(f[j][i]&&(cnt[j][i]==2||cnt[j][i]==3)) \n\t\t{\n\t\t\ttf[j][i]=1;\n\t\t}\n\t\tif(!f[j][i]&&cnt[j][i]==3)\n\t\t{\n\t\t\ttf[j][i]=1;\n\t\t}\n\t}\n\n\ttf[x][y]=0;\n\tf[x][y]=0;\n}\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tmemset(hs,0,sizeof(hs));\n\t\tbool f[5][5]={0};\n\t\tint sx,sy;\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin.ignore();\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c=='@')\n\t\t\t\t{\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t\tf[j][i]=0;\n\t\t\t\t}\n\t\t\t\tif(c=='#') f[j][i]=1;\n\t\t\t\tif(c=='.') f[j][i]=0;\n\t\t\t}\n\t\t}\n\n\t\tqueue<State> q;\n\t\tq.push(State(sx,sy,f,ch(f,N), 0));\n\n\t\tint ans=-1;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tState s=q.front(); q.pop();\n\t\t\tif(s.h==0)\n\t\t\t{\n\t\t\t\tans=s.c;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<8; i++)\n\t\t\t{\n\t\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\t\tif(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t\t\t\tif(s.f[tx][ty]) continue;\n\n\t\t\t\tmov(tx,ty,s.f,N);\n\t\t\t\tint h=ch(tf,N);\n\t\t\t\tif(hs[tx][ty][h]) continue;\n\t\t\t\ths[tx][ty][h]=1;\n\n\t\t\t\tq.push(State(tx,ty,tf, h, s.c+1));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tset<data> Vis;\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tif(Vis.count(D)>0) continue;\n\t\t\tVis.insert(D);\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\tif(t==10) continue;\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n\nbool onmp(int x,int y){return x>=0&&y>=0&&x<n&&y<n;}\n\nint count(int x,int y,const vector<string> &A){\n  int res=0;  \n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i,ny = y+j;\n      if((!i&&!j)||!onmp(nx,ny))continue;\n      res += A[ny][nx]=='#'||A[ny][nx]=='@';\n    }\n  return res;\n}\n\nbool check(const vector<string> &A){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(A[i][j]=='#')return 0;\n  return 1;\n}\n\n\nvector<string> mkmp(const vector<string> &A){\n  vector<string> res(n,string(n,'.'));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cnt = count(j,i,A);\n      if(A[i][j]=='#')res[i][j]=(cnt==2||cnt==3)? '#':'.';\n      if(A[i][j]=='.')res[i][j]=(cnt==3)? '#':'.';\n      if(A[i][j]=='@')res[i][j]='@';\n    }\n  return res;\n}\n\n\nmap<vector<string>,int> mem;\nint ans;\nvoid dfs(int x,int y,int cnt,vector<string> A){\n  if(check(A))ans=min(cnt,ans);\n  if(cnt>=ans) return;\n  if(mem.count(A)&&mem[A]<=cnt)return;\n  mem[A]=cnt;\n  A[y][x] = '.';\n  for(int dy=-1;dy<=1;dy++){\n    for(int dx=-1;dx<=1;dx++){\n      int nx = x+dx,ny = y+dy;\n      if((!dx&&!dy)||!onmp(nx,ny)||A[ny][nx]=='#')continue;\n      A[ny][nx] = '@';\n      dfs(nx,ny,cnt+1,mkmp(A));\n      A[ny][nx] = '.';\n    }\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    vector<string> mp(n);\n    for(int i=0;i<n;i++)cin>>mp[i];\n    int sx,sy;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)if(mp[i][j]=='@')sy=i,sx=j;\n    ans = 11;\n    dfs(sx,sy,0,mp);\n    cout<<(ans<11? ans:-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) for(int i=0;i<(c).size();i++)\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).begin();i++)\n#define mp make_pair\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nconst int inf=1<<28;\nconst int dy[]={-1,-1,-1,0,1,1,1,0},dx[]={-1,0,1,1,1,0,-1,-1};\n\nint n;\n\nint buftoI(char buf[6][6])\n{\n\tint y,x;\n\trep(i,n)rep(j,n)if(buf[i][j]=='@')y=i,x=j;\n\t\n\tint ret=(y<<3)+x;\n\trep(i,n)rep(j,n)ret*=2,ret+=(buf[i][j]=='#');\n\treturn ret;\n}\npi ItoBuf(int s,char buf[6][6])\n{\n\tfor(int i=n-1;i>=0;i--)for(int j=n-1;j>=0;j--)\n\t{\n\t\tint t=s&1;\n\t\tbuf[i][j]=t?'#':'.';\n\t\ts/=2;\n\t}\n\tint x=s&7,y=s>>3;\n\tbuf[y][x]='@';\n\treturn mp(y,x);\n}\nvoid moveTime(char buf[6][6])\n{\n\tchar tmp[6][6];\n\t\n\trep(i,n)rep(j,n)\n\t{\n\t\tint cnt=0;\n\t\trep(d,8)\n\t\t{\n\t\t\tint ny=i+dy[d],nx=j+dx[d];\n\t\t\tif(ny<0||nx<0||ny>=n||nx>=n)continue;\n\t\t\tif(buf[ny][nx]!='.')cnt++;\n\t\t}\n\t\tif(buf[i][j]=='#')\n\t\t{\n\t\t\tif(cnt==2||cnt==3)tmp[i][j]='#';\n\t\t\telse tmp[i][j]='.';\n\t\t}\n\t\telse if(buf[i][j]=='.')\n\t\t{\n\t\t\tif(cnt==3)tmp[i][j]='#';\n\t\t\telse tmp[i][j]='.';\n\t\t}\n\t\telse tmp[i][j]='@';\n\t}\n\t\n\trep(i,n)rep(j,n)buf[i][j]=tmp[i][j];\n}\n\nint main()\n{\n\n\twhile(cin>>n,n)\n\t{\n\t\tchar buf[6][6];\n\t\trep(i,n)cin>>buf[i];\n\t\t//BFS\n\t\tint ans=-1,cur=buftoI(buf);\n\t\tqueue<pi> Q;\n\t\tQ.push(mp(0,cur));\n\t\tset<int> V;\n\t\tV.insert(cur);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tint step=Q.front().first;\n\t\t\tcur=Q.front().second;\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tif((cur&((1<<n*n)-1))==0)\n\t\t\t{\n\t\t\t\tans=step;break;\n\t\t\t}\n\t\t\t\n\t\t\tpi p=ItoBuf(cur,buf);\n\t\t\tint y=p.first,x=p.second;\n\t\t\t\n\t\t\trep(d,8)\n\t\t\t{\n\t\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\t\tif(ny<0||nx<0||ny>=n||nx>=n)continue;\n\t\t\t\tif(buf[ny][nx]!='.')continue;\n\t\t\t\t\n\t\t\t\tchar nxtbuf[6][6];\n\t\t\t\trep(i,n)rep(j,n)nxtbuf[i][j]=buf[i][j];\t\t\n\t\t\t\tnxtbuf[ny][nx]='@',nxtbuf[y][x]='.';\n\t\t\t\tmoveTime(nxtbuf);\n\t\t\t\tint nxt=buftoI(nxtbuf);\n\t\t\t\t\n\t\t\t\tif(V.count(nxt))continue;\n\t\t\t\tV.insert(nxt);\n\t\t\t\tQ.push(mp(step+1,nxt));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tset<data> Vis;\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tif(t>15) break;\n\n\t\t\tif(Vis.count(D)>0) continue;\n\t\t\tVis.insert(D);\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unordered_set>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint N;\n\nconst int dx[] = {-1,0,1,0,-1,1,1,-1}, dy[] = {0,1,0,-1,-1,-1,1,1};\n\nstruct P {\n    int x, y;\n    int cnt;\n    vvb field;\n};\n\nvoid infect(vvb& field) {\n    vvb newfield(N, vb(N));\n    vvi adjacent(N, vi(N));\n    REP(y, N) REP(x, N) {\n        REP(i, 8) {\n            int sx = x + dx[i], sy = y + dy[i];\n            if (0 <= sx && sx < N && 0 <= sy && sy < N && field[sy][sx]) {\n                adjacent[y][x]++;\n            }\n        }\n    }\n    REP(y, N) REP(x, N) {\n        if (field[y][x] && (adjacent[y][x] == 2 || adjacent[y][x] == 3)) {\n            newfield[y][x] = true;\n        } else if (!field[y][x] && adjacent[y][x] == 3) {\n            newfield[y][x] = true;\n        } else {\n            newfield[y][x] = false;\n        }\n    }\n    field = newfield;\n}\n\nint bitfield(const vvb& field) {\n    int bit = 0;\n    REP(y, N) REP(x, N) {\n        bit <<= 1;\n        bit |= field[y][x];\n    }\n    return bit;\n}\n\nint count_infected(const vvb& field, int ix, int iy) {\n    int cnt = 0;\n    REP(y, N) REP(x, N) {\n        if (!(x == ix && y == iy) && field[y][x]) cnt++;\n    }\n    return cnt;\n}\n\nint main() {\n    while (cin >> N, N) {\n        vvb field(N, vb(N));\n        int ix, iy;\n        REP(y, N) REP(x, N) {\n            char c;\n            cin >> c;\n            // @???infected?????????\n            field[y][x] = c != '.';\n            if (c == '@') {\n                ix = x;\n                iy = y;\n            }\n        }\n\n        vector<vector<unordered_set<int>>> G(N, vector<unordered_set<int>>(N));\n        queue<P> que;\n\n        if (count_infected(field, ix, iy) == 0) {\n            cout << 0 << endl;\n            goto END;\n        }\n        G[iy][ix].insert(bitfield(field));\n        que.push({ix, iy, 0, field});\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            REP(i, 8) {\n                int sx = p.x + dx[i], sy = p.y + dy[i];\n                if (0 <= sx && sx < N && 0 <= sy && sy < N && !p.field[sy][sx]) {\n                    vvb field = p.field;\n                    swap(field[p.y][p.x], field[sy][sx]);\n                    infect(field);\n                    int bit = bitfield(field);\n                    field[sy][sx] = false;\n                    if (!EXIST(G[sy][sx], bit)) {\n                        G[sy][sx].insert(bit);\n                        if (count_infected(field, sx, sy) == 0) {\n                            cout << p.cnt+1 << endl;\n                            goto END;\n                        }\n                        field[sy][sx] = true;\n                        que.push({sx, sy, p.cnt+1, field});\n                    }\n                }\n            }\n        }\n        cout << -1 << endl;\nEND: {}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n\nbool onmp(int x,int y){return x>=0&&y>=0&&x<n&&y<n;}\n\nint count(int x,int y,const vector<string> &A){\n  int res=0;  \n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i,ny = y+j;\n      if((!i&&!j)||!onmp(nx,ny))continue;\n      res += A[ny][nx]=='#'||A[ny][nx]=='@';\n    }\n  return res;\n}\n\nbool check(const vector<string> &A){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(A[i][j]=='#')return 0;\n  return 1;\n}\n\n\nvector<string> mkmp(const vector<string> &A){\n  vector<string> res(n,string(n,'.'));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cnt = count(j,i,A);\n      if(A[i][j]=='#')res[i][j]=(cnt==2||cnt==3)? '#':'.';\n      if(A[i][j]=='.')res[i][j]=(cnt==3)? '#':'.';\n      if(A[i][j]=='@')res[i][j]='@';\n    }\n  return res;\n}\n\nmap<vector<string>,int> mem;\nint ans,flg;\nvoid dfs(int x,int y,int cnt,vector<string> A){\n  if(check(A))ans=min(cnt,ans),flg=1;\n  if(cnt>=ans) return;\n  if(mem.count(A)&&mem[A]<=cnt)return;\n  mem[A]=cnt;\n  A[y][x] = '.';\n  for(int dy=-1;dy<=1;dy++){\n    for(int dx=-1;dx<=1;dx++){\n      int nx = x+dx,ny = y+dy;\n      if((!dx&&!dy)||!onmp(nx,ny)||A[ny][nx]=='#')continue;\n      A[ny][nx] = '@';\n      dfs(nx,ny,cnt+1,mkmp(A));\n      A[ny][nx] = '.';\n    }\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    vector<string> mp(n);\n    for(int i=0;i<n;i++)cin>>mp[i];\n    int sx,sy;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)if(mp[i][j]=='@')sy=i,sx=j;\n    ans = 10;flg=0;\n    mem.clear();\n    dfs(sx,sy,0,mp);\n    cout<<(flg? ans:-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint n;\n\ntypedef tuple<int,int,int> T;\n\n\nbool getBit(int b, int y, int x){\n\treturn b >> (y * n + x) & 1;\n}\nvoid setBit(int& b, int y, int x){\n\tb |= 1 << (y * n + x);\n}\n\nmap<T, int> memo;\nint ans;\nvoid dfs(int bit, int y, int x, int t){\n\t//cout << bitset<9>(bit) <<' ' << y << ' ' << x << endl;\n\tif(t > ans) return;\n\tif(memo.count(T(bit, y, x)) and memo[T(bit, y, x)] <= t) return;\n\tmemo[T(bit, y, x)] = t;\n\n\tif(bit == 0){\n\t\t//show(t)\n\t\tans = min(ans, t);\n\t\treturn ;\n\t}\n\n\trep(vd, 8){\n\t\tint vy = y + dy[vd];\n\t\tint vx = x + dx[vd];\n\t\tif(getBit(bit, vy, vx)) continue;\n\t\tif(vy < 0 || vy >= n || vx < 0 || vx >= n) continue;\n\n\t\tint nxt = 0;\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(vy == i and vx == j) continue;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(d,8){\n\t\t\t\t\tint ny = i + dy[d];\n\t\t\t\t\tint nx = j + dx[d];\n\t\t\t\t\tif(ny < 0 || ny >= n || nx < 0 || nx >= n) continue;\n\t\t\t\t\tif(getBit(bit, ny, nx)) cnt++;\n\t\t\t\t\tif(vy == ny and vx == nx) cnt++;\n\t\t\t\t}\n\n\t\t\t\tif((cnt == 2 or cnt == 3) and getBit(bit, i, j) == 1){\n\t\t\t\t\tsetBit(nxt, i, j);\n\t\t\t\t}else if(cnt == 3 and getBit(bit, i, j) == 0){\n\t\t\t\t\tsetBit(nxt, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(nxt, vy, vx, t + 1);\n\t}\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tint bit = 0, y, x;\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tchar a;\n\t\t\t\tcin >> a;\n\t\t\t\tif(a == '#'){\n\t\t\t\t\tsetBit(bit, i, j);\n\t\t\t\t}\n\t\t\t\tif(a == '@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tans = 15;\n\t\tmemo.clear();\n\t\t//show(bit)\n\t\tdfs(bit, y, x, 0);\n\t\tcout << (ans == 15 ? -1 : ans) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nint in(int y,int x,int n){\n  return 0<=y&&y<n&&0<=x&&x<n;\n}\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    string s[n];\n    for(int i=0;i<n;i++) cin>>s[i];\n    int st=0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(s[i][j]=='@') st+=(i*n+j)<<(n*n);\n\telse if(s[i][j]=='#') st+=1<<(i*n+j);\n    \n    int ans=-1,mask=(1<<(n*n))-1;\n    //cout<<mask<<endl;\n    int ax[]={1,1,1,0,0,-1,-1,-1};\n    int ay[]={-1,0,1,-1,1,-1,0,1};\n    queue<P> q;\n    \n    q.push(P(st,0));\n    set<int> si;\n    while(!q.empty()){\n      P p=q.front();q.pop();\n      int b=p.first,d=p.second;\n      if(si.count(b)) continue;\n      si.insert(b);\n      int c=b&mask;\n      int z=b>>(n*n);\n      int y=z/n,x=z%n;\n      if(c==0){\n\tans=d;\n\tbreak;\n      }\n      for(int k=0;k<8;k++){\n\tint ny=y+ay[k],nx=x+ax[k],nb=0;\n\tif(!in(ny,nx,n)) continue;\n\tif((c>>(ny*n+nx))&1) continue;\n\tfor(int i=0;i<n;i++){\n\t  for(int j=0;j<n;j++){\n\t    if(ny==i&&nx==j) continue;\n\t    int v=0;\n\t    for(int a=0;a<8;a++){\n\t      if(!in(i+ay[a],j+ax[a],n)) continue;\n\t      if((c>>((i+ay[a])*n+(j+ax[a])))&1) v++;\n\t      else if(ny==i+ay[a]&&nx==j+ax[a]) v++;\n\t    }\n\t    if((c>>(i*n+j))&1){\n\t      if(v==2||v==3) nb+=1<<(i*n+j);\n\t    }else{\n\t      if(v==3) nb+=1<<(i*n+j);\n\t    }\n\t  }\n\t}\n\tnb+=(ny*n+nx)<<(n*n);\n\tq.push(P(nb,d+1));\n      }\n    }\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define INF (1e9)\n#define N 5\nusing namespace std;\n\ntypedef pair<vector<string>,int> P;\ntypedef pair<int,int> P1;\ntypedef pair<P,P1> P2;\n\nvector<string> s;\nint n, sy, sx;\n\nbool check(vector<string> grid){\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(grid[i][j]=='#')return false;\n\n  return true;\n}\n\nvector<string> infect(vector<string> grid){\n  \n  vector<string> res(n,string(n,'x'));\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      \n      int cnt=0;\n      \n      for(int k=-1;k<=1;k++){\n\tfor(int l=-1;l<=1;l++){\n\t  \n\t  if(k==0&&l==0)continue;\n\t  \n\t  int ni=i+k,nj=j+l;\n\t  \t  \n\t  if(ni<0||nj<0||n<=ni||n<=nj)continue;\n\t  if(grid[ni][nj]!='.')cnt++;\n\t}\n      }\n      \n      if(grid[i][j]=='@') res[i][j]='@';\n      else if(grid[i][j]=='.'){\n\tif(cnt==3) res[i][j]='#';\n\telse res[i][j]='.';\n      }else{\n\tif(cnt==2||cnt==3) res[i][j]='#';\n\telse res[i][j]='.';\n      }\n      \n    }\n  }\n  \n  return res;\n}\n\nint bfs(){\n  \n  map<vector<string>,int> memo;\n  queue<P2> q;\n  \n  q.push(P2(P(s,0),P1(sy,sx)));\n  memo[s]=0;\n  \n  while(!q.empty()){\n\n    P2 t=q.front(); q.pop();\n    \n    vector<string> grid=t.F.F;\n    \n    int cost=t.F.S, y=t.S.F, x=t.S.S;\n    \n    if(check(grid))return cost;\n    \n    for(int i=-1;i<=1;i++){\n      for(int j=-1;j<=1;j++){\n\n\tif(i==0&&j==0)continue;\n\t\n\tint ncost=cost+1, ny=y+i, nx=x+j;\n\t\n\tif(ny<0||nx<0||n<=ny||n<=nx)continue;\n\tif(grid[ny][nx]=='#')continue;\n\t\n\tvector<string> ngrid=grid;\n\t\n\tswap(ngrid[y][x],ngrid[ny][nx]);\n\t\n\tngrid=infect(ngrid);\n\t\n\tif(memo.count(ngrid))continue;\n\n\tmemo[ngrid]=ncost;\n\tq.push(P2(P(ngrid,ncost),P1(ny,nx)));\n\t\n      }\n    }\n  }\n  \n  return INF;\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n)break;\n    \n    s.resize(n);\n    \n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      \n      for(int j=0;j<n;j++)\n\tif(s[i][j]=='@')sy=i,sx=j;\n      \n    }\n    \n    int ans=bfs();\n    \n    cout<<(ans==INF?-1:ans)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nint n;\nstring s[5];\n\nvoid print_map(){\n    cout << \"------\" << endl;\n    rep(i,n) cout << s[i] << endl;\n    cout << \"------\" << endl;\n}\n\npi get_state(){\n    int mask = 0;\n    int pos = -1;\n    rep(i,n)rep(j,n){\n        int idx = i*n+j;\n        if(s[i][j]=='#') mask |= 1<<idx;\n        if(s[i][j]=='@') pos = idx;\n    }\n\n    assert(pos!=-1);\n    return {pos,mask};\n}\n\nvoid make_state(int pos, int mask){\n    rep(i,n)rep(j,n){\n        int idx = i*n+j;\n        if(mask>>idx&1) s[i][j] = '#';\n        else if(idx == pos) s[i][j] = '@';\n        else s[i][j] = '.';\n    }\n}\n\nbool move(int y, int x){\n    if(s[y][x] == '#') return false;\n\n    rep(i,n)rep(j,n)if(s[i][j]=='@') s[i][j]='.';\n    s[y][x] = '@';\n    return true;\n}\n\nvoid infect(){\n    string t[5];\n    rep(i,n) t[i]=s[i];\n\n    rep(i,n)rep(j,n){\n        if(t[i][j]=='@') s[i][j]='@';\n        else{\n            int ct = 0;\n            for(int dy=-1; dy<=1; ++dy)for(int dx=-1; dx<=1; ++dx){\n                if(dy==0 && dx==0) continue;\n\n                int y = i+dy, x = j+dx;\n                if(0<=y && y<n && 0<=x && x<n) ct += (t[y][x]!='.');\n            }\n\n            if(t[i][j]=='#'){\n                if(ct==2 || ct==3) s[i][j] = '#';\n                else s[i][j] = '.';\n            }\n            else{\n                if(ct==3) s[i][j] = '#';\n                else s[i][j] = '.';\n            }\n        }\n    }\n}\n\nunordered_map<int,int> dp[25];\nint solve(){\n    rep(i,25) dp[i].clear();\n\n    pi start = get_state();\n    if(start.se==0) return 0;\n\n    queue<pi> que;\n    que.push(start);\n    dp[start.fi][start.se] = 0;\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n        int pos = now.fi, mask = now.se;\n        if(mask == 0) return dp[pos][mask];\n\n        // make_state(pos,mask);\n        // dbg(dp[pos][mask]);\n        // print_map();\n\n        int py = pos/n, px = pos%n;\n\n        for(int dy=-1; dy<=1; ++dy)for(int dx=-1; dx<=1; ++dx){\n            if(dy==0 && dx==0) continue;\n\n            int ny = py+dy, nx = px+dx;\n            if(0<=ny && ny<n && 0<=nx && nx<n){\n                make_state(pos,mask);\n\n                if(move(ny,nx)){\n                    infect();\n                    pi nxt = get_state();\n                    if(!dp[nxt.fi].count(nxt.se)){\n                        if(nxt.se == 0) return dp[pos][mask]+1;\n\n                        dp[nxt.fi][nxt.se] = dp[pos][mask]+1;\n                        que.push(nxt);\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(cin >>n,n){\n        rep(i,n) cin >>s[i];\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    const int dy[] = {1, 0, -1, 0, 1, 1, -1, -1},\n              dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        string a;\n        int si, sj;\n        REP(i, n) {\n            string s; cin >> s;\n            a += s;\n            REP(j, n) {\n                if (s[j] == '@') {\n                    si = i, sj = j;\n                }\n            }\n        }\n\n        queue<tuple<string,int,int>> que;\n        map<tuple<string,int,int>,int> dist;\n        que.emplace(a, si, sj);\n        dist[make_tuple(a, si, sj)] = 0;\n\n        int ans = -1;\n\n        while (!que.empty()) {\n            string board;\n            int si, sj;\n            int d = dist[que.front()];\n            tie(board, si, sj) = que.front();\n            que.pop();\n\n            bool finish = true;\n            REP(i, n*n) {\n                if (board[i] == '#') {\n                    finish = false;\n                    break;\n                }\n            }\n            if (finish) {\n                ans = d;\n                break;\n            }\n\n            REP(k, 8) {\n                string tmp = board;\n                int y = si + dy[k], x = sj + dx[k];\n                if (y < 0 or x < 0 or n <= y or n <= x or\n                    tmp[y*n + x] == '#') continue;\n                tmp[y*n + x] = '@';\n                tmp[si*n + sj] = '.';\n                string nxt;\n                REP(i, n) {\n                    REP(j, n) {\n                        if (i == y and j == x) {\n                            nxt += '@';\n                            continue;\n                        }\n                        int cnt = 0;\n                        REP(t, 8) {\n                            int y = i + dy[t], x = j + dx[t];\n                            if (y < 0 or x < 0 or n <= y or n <= x) continue;\n                            cnt += tmp[y*n + x] != '.';\n                        }\n                        if (tmp[i*n + j] == '#' and (cnt == 2 or cnt == 3)) {\n                            nxt += '#';\n                        } else if (tmp[i*n + j] == '.' and cnt == 3) {\n                            nxt += '#';\n                        } else {\n                            nxt += '.';\n                        }\n                    }\n                }\n                if (dist.count(make_tuple(nxt, y, x)) == 0) {\n                    dist[make_tuple(nxt, y, x)] = d + 1;\n                    que.emplace(nxt, y, x);\n                } else if (chmin(dist[make_tuple(nxt, y, x)], d + 1)){\n                    que.emplace(nxt, y, x);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nint n;\n\nstruct S {\n\tchar f[5][5];\n\tint x, y;\n};\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tif(s.f[i][j] == '#') ret |= 1 << (i * n + j);\n\t\t}\n\t}\n\treturn (((ret * n) + s.y)) * n + s.x;\n}\n\nbool isFree(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tif(s.f[i][j] == '#') return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < n && 0 <= y && y < n;\n}\n\nS simulate(S s) {\n\tS ns = s;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tif(i == s.y && j == s.x) continue;\n\t\t\tint cnt = 0;\n\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\tint x = j + dx[k];\n\t\t\t\tint y = i + dy[k];\n\t\t\t\tif(!in(x, y)) continue;\n\t\t\t\tif(s.f[y][x] == '#' || (x == s.x && y == s.y)) cnt++;\n\t\t\t}\n\t\t\tif(s.f[i][j] == '#' && (cnt == 2 || cnt == 3)) ns.f[i][j] = '#';\n\t\t\telse if(s.f[i][j] == '.' && cnt == 3) ns.f[i][j] = '#';\n\t\t\telse ns.f[i][j] = '.';\n\t\t}\n\t}\n\treturn ns;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tS s;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcin >> s.f[i][j];\n\t\t\t\tif(s.f[i][j] == '@') {\n\t\t\t\t\ts.y = i, s.x = j;\n\t\t\t\t\ts.f[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = -1;\n\t\tunordered_map<int, int> m;\n\t\tqueue<S> q;\n\t\tq.push(s);\n\t\tm[conv(s)] = 0;\n\t\twhile(q.size()) {\n\t\t\ts = q.front();\n\t\t\tq.pop();\n\t\t\tint c = m[conv(s)];\n\t\t\tif(isFree(s)) {\n\t\t\t\tans = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\tS ns = s;\n\t\t\t\tns.x = s.x + dx[k];\n\t\t\t\tns.y = s.y + dy[k];\n\t\t\t\tif(!in(ns.x, ns.y)) continue;\n\t\t\t\tif(s.f[ns.y][ns.x] == '#') continue;\n\t\t\t\tns = simulate(ns);\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(m.count(X)) continue;\n\t\t\t\tm[X] = c + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\n#define INF 100000000\n\nint n;\nmap<pair<int,int>,int> dp;\nmap<pair<int,int>,bool> vis;\nmap<pair<int,int>,bool> now;\nmap<pair<int,int>,int> next;\nchar buf[25][25];\nint dx[] = {-1,0,1,-1,1,-1,0,1};\nint dy[] = {-1,-1,-1,0,0,1,1,1};\nint ans;\n\nint make(pair<int,int> p) {\n\tif (next.find(p)!=next.end()) return next[p];\n\tint mask = p.first;\n\tint pos = p.second;\n\tmask |= (1<<pos);\n\tint newmask = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tint k = i*n+j;\n\t\t\tint t = 0;\n\t\t\tif (j>0) {\n\t\t\t\tt += (mask&(1<<(k-1)))>0;\n\t\t\t\tif (i>0) t += (mask&(1<<(k-1-n)))>0;\n\t\t\t\tif (i<n-1) t += (mask&(1<<(k-1+n)))>0;\n\t\t\t}\n\t\t\tif (j<n-1) {\n\t\t\t\tt += (mask&(1<<(k+1)))>0;\n\t\t\t\tif (i>0) t += (mask&(1<<(k+1-n)))>0;\n\t\t\t\tif (i<n-1) t += (mask&(1<<(k+1+n)))>0;\n\t\t\t}\n\t\t\tif (i>0) t += (mask&(1<<(k-n)))>0;\n\t\t\tif (i<n-1) t += (mask&(1<<(k+n)))>0;\n\t\t\tif ((mask&(1<<k)) && k!=pos) {\n\t\t\t\tif (t==2 || t==3) {\n\t\t\t\t\tnewmask |= (1<<k);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (t==3 && k!=pos) {\n\t\t\t\t\tnewmask |= (1<<k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnext[p] = newmask;\n\treturn newmask;\n}\n\nvoid print(int m) {\n\tfor (int i=0; i<n;  i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tint k = i*n+j;\n\t\t\tif (m&(1<<k)) cout<<'#';\n\t\t\telse cout<<'.';\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\nvoid solve(int x, int y, int mask,int cur) {\n\t//cout<<x<<\" \"<<y<<\" \"<<mask<<endl;\n\t//print(mask);\n\t//cout<<endl;\n\tif (cur>ans) return;\n\tif (mask==0) ans = cur;\n\tif (now[make_pair(mask,x*n+y)]) return;\n\t\n\tnow[make_pair(mask,x*n+y)] = 1;\n\t\n\tint tmp = INF;\n\tint t = 1000;\n\t\n\tfor (int k=0; k<8; k++) {\n\t\tint u = x + dx[k];\n\t\tint v = y + dy[k];\n\t\tif (u<0 || u>=n) continue;\n\t\tif (v<0 || v>=n) continue;\n\t\tif (mask&(1<<(u*n+v))) continue;\n\t\t\n\t\t//int m = make(make_pair(mask,u*n+v));\n\t\t\n\t\t//t = min(t,__builtin_popcount(m));\n\t}\n\t\n\tfor (int k=0; k<8; k++) {\n\t\tint u = x + dx[k];\n\t\tint v = y + dy[k];\n\t\tif (u<0 || u>=n) continue;\n\t\tif (v<0 || v>=n) continue;\n\t\tif (mask&(1<<(u*n+v))) continue;\n\t\t\n\t\tint m = make(make_pair(mask,u*n+v));\n\t\t\n\t\t//if (__builtin_popcount(m)==t) {\n\t\t\tsolve(u,v,m,cur+1);\n\t\t//}\n\t}\n\t\n\tnow[make_pair(mask,x*n+y)] = 0;\n\t//vis[make_pair(mask,x*n+y)] = 1;\n\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d\",&n) && n!=0) {\n\t\tfor (int i=0; i<n; i++) scanf(\"%s\",buf+i);\n\t\tint x,y;\n\t\tint mask = 0;\n\t\tfor (int i=0; i<n; i++) for (int j=0; j<n; j++) {\n\t\t\tif (buf[i][j]=='#') mask |= (1<<(i*n+j));\n\t\t\tif (buf[i][j]=='@') {\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t\tnow.clear();\n\t\tvis.clear();\n\t\tdp.clear();\n\t\tans = INF;\n\t\tsolve(x,y,mask,0);\n\t\tif (ans >= INF) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <set>\n#include <bitset>\nusing namespace std;\n\ntypedef vector<vector<char> > vvchar;\n\n\nint dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n\nint solve(int n, const string *a){\n\tvvchar def(n + 2, vector<char>(n + 2));\n\tvvchar v1 = def;\n\n\tint at = -1;\n\tint st = 0;\n\tint bit = 1;\n\tfor(int y = 0; y < n; ++y){\n\t\tfor(int x = 0; x < n; ++x){\n\t\t\tif( a[y][x] == '@' ){\n\t\t\t\tat = (y + 1) << 3 | (x + 1);\n\t\t\t}\n\t\t\telse if( a[y][x] == '#' ){\n\t\t\t\tv1[y + 1][x + 1] = 1;\n\t\t\t\tst |= bit;\n\t\t\t}\n\n\t\t\tbit <<= 1;\n\t\t}\n\t}\n\t\n\tif( st == 0 ){\treturn 0;\t}\n\n\tqueue<int> q;\n\tq.push(st | (at << 25));\n\tq.push(-1);\n\n\tset<int> visit;\n\tvisit.insert( q.front() );\n\n\tint t = 1;\n\twhile( q.size() > 1 ){\n\t\tst = q.front();\n\t\tq.pop();\n\t\t\n\t\tif( st < 0 ){\n\t\t\t++t;\n\t\t\tq.push(-1);\n\t\t}\n\t\telse{\n\t\t\tv1 = def;\n\t\t\tint atx = (st >> 25) & 7;\n\t\t\tint aty = (st >> 28) & 7;\n\n\t\t\tint mask = 1;\n\t\t\tfor(int y = 1; y <= n; ++y){\n\t\t\t\tfor(int x = 1; x <= n; ++x){\n\t\t\t\t\tif( st & mask ){\n\t\t\t\t\t\tv1[y][x] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tmask <<= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 8; ++i){\n\t\t\t\tint ny = aty + dy[i];\n\t\t\t\tint nx = atx + dx[i];\n\t\t\t\tif( ny <= 0 || ny > n || nx <= 0 || nx > n ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif( v1[ny][nx] != 0 ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tv1[ny][nx] = 2;\n\n\t\t\t\tint nst = 0;\n\t\t\t\tbit = 1;\n\t\t\t\tfor(int y = 1; y <= n; ++y)\n\t\t\t\tfor(int x = 1; x <= n; ++x){\n\t\t\t\t\tint cnt = 0;\n\n\t\t\t\t\tfor(int j = 0; j < 8; ++j){\n\t\t\t\t\t\tif( v1[y + dy[j]][x + dx[j]] ){\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif( v1[y][x] == 0 ){\n\t\t\t\t\t\tif( cnt == 3 ){\n\t\t\t\t\t\t\tnst |= bit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if( v1[y][x] == 1 ){\n\t\t\t\t\t\tif( cnt == 2 || cnt == 3 ){\n\t\t\t\t\t\t\tnst |= bit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbit <<= 1;\n\t\t\t\t}\n\n\t\t\t\tv1[ny][nx] = 0;\n\n\t\t\t\tif( nst == 0 ){\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnst |= ny << 28 | nx << 25;\n\t\t\t\tif( visit.insert(nst).second ){\n\t\t\t\t\tq.push(nst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(){\n\tint n;\n\tstring a[5];\n\n\twhile( cin >> n, n != 0 ){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> a[i];\n\t\t}\n\n\t\tcout << solve(n, a) << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nchar board[6][6], ma[6][6], tmap[6][6];\nint mov[8][2] = {1, 0, 1, -1, 0, -1, -1, -1, -1, 0, -1, 1, 0, 1, 1, 1};\nint mark[200];\nint n;\n\nstruct status\n{\n    int x, y;\n    int ord;\n    int te;\n    status(int a, int b, int c)\n    {\n        x = a, y = b, ord = c;\n    }\n};\n\npair < int, int > s;\nmap<pair<int, int>, int > m;\n\nint encode(char(*a)[6])\n{\n    int bb = 0;\n    int va = 1;\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            bb += mark[a[i][j]] * (va);\n            va *= 2;\n        }\n    }\n    return bb;\n}\n\nvoid decode(int p, int x, int y)\n{\n    int cnt = 0;\n    while(cnt != n * n)\n    {\n        int t = p % 2;\n        ma[cnt / n][cnt % n] = t == 1 ? '#' : '.';\n        p /= 2;\n        cnt++;\n    }\n    ma[x][y] = '@';\n}\n\nvoid construct(int s, int e, int ss, int ee)\n{\n    memcpy(tmap, ma, sizeof(tmap));\n    char newmap[6][6];\n    swap(tmap[s][e], tmap[ss][ee]);\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            if(tmap[i][j] == '.')\n            {\n                int cnt = 0;\n                for(int k = 0; k < 8; k++)\n                {\n                    int tx = i + mov[k][0] , ty = j + mov[k][1];\n                    if(tx >= 0 && ty >= 0 && tx < n && ty < n && (tmap[tx][ty] == '#' || tmap[tx][ty] == '@'))\n                        cnt++;\n                }\n                //printf(\"%d %d %d\\n\",i,j,cnt);\n                if(cnt == 3) newmap[i][j] = '#';\n                else newmap[i][j] = tmap[i][j];\n            }\n            else if(tmap[i][j] == '#')\n            {\n                int cnt = 0;\n                for(int k = 0; k < 8; k++)\n                {\n                    int tx = i + mov[k][0] , ty = j + mov[k][1];\n                    if(tx >= 0 && ty >= 0 && tx < n && ty < n && (tmap[tx][ty] == '#' || tmap[tx][ty] == '@'))\n                        cnt++;\n                }\n                if(cnt == 3 || cnt == 2) newmap[i][j] = '#';\n                else newmap[i][j] = '.';\n            }\n            else newmap[i][j] = tmap[i][j];\n        }\n    }\n    memcpy(tmap, newmap, sizeof(tmap));\n}\n\nint bfs()\n{\n    struct status fir(s.first, s.second, 0);\n    fir.te = encode(board);\n    queue <struct status> q;\n    q.push(fir);\n    int flag = -1;\n    while(!q.empty())\n    {\n        struct status vi = q.front();\n        if(m[make_pair(vi.te, vi.x * n + vi.y)] == 1)\n        {\n            q.pop();\n        }\n        else\n        {\n            m[make_pair(vi.te, vi.x * n + vi.y)] = 1;\n            decode(vi.te, vi.x, vi.y);\n            //print(vi.x,vi.y);\n            q.pop();\n            if(!vi.te) flag = vi.ord;\n            if(vi.ord > 10) break;\n            if(flag == -1)\n            {\n                for(int i = 0; i < 8; i++)\n                {\n                    int tx = vi.x + mov[i][0], ty = vi.y + mov[i][1];\n                    if(tx >= 0 && ty >= 0 && tx < n && ty < n && ma[tx][ty] != '#')\n                    {\n                        construct(vi.x, vi.y, tx, ty);\n                        struct status newt(tx, ty, vi.ord + 1);\n                        newt.te = encode(tmap);\n                        q.push(newt);\n                    }\n                }\n            }\n            else break;\n        }\n    }\n    return flag;\n}\n\nint main()\n{\n    mark['#'] = 1, mark['.'] = 0, mark['@'] = 0;\n    while(~scanf(\"%d\", &n), n)\n    {\n        m.clear();\n        getchar();\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j < n; j++)\n            {\n                scanf(\"%c\", &board[i][j]);\n                if(board[i][j] == '@') s = make_pair(i, j);\n            }\n            getchar();\n        }\n        printf(\"%d\\n\", bfs());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint N;\nint dx[8]={0,1,0,-1,1,1,-1,-1};\nint dy[8]={1,0,-1,0,1,-1,1,-1};\nmain()\n{\n\twhile(cin>>N,N)\n\t{\n\t\tstring start=\"\";\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tstring input;cin>>input;start+=input;\n\t\t}\n\t\tmap<string,int>M;\n\t\tM[start]=0;\n\t\tqueue<string>P;\n\t\tP.push(start);\n\t\tint ans=-1;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tstring now=P.front();P.pop();\n\t\t\tint cost=M[now];\n\t\t\tint sx,sy;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<N*N;i++)\n\t\t\t{\n\t\t\t\tif(now[i]=='@')sx=i/N,sy=i%N;\n\t\t\t\tif(now[i]=='#')cnt++;\n\t\t\t}\n\t\t\tif(cnt==0)\n\t\t\t{\n\t\t\t\tans=cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int r=0;r<8;r++)\n\t\t\t{\n\t\t\t\tint tx=sx+dx[r],ty=sy+dy[r];\n\t\t\t\tif(tx<0||ty<0||tx>=N||ty>=N||now[tx*N+ty]=='#')continue;\n\t\t\t\tstring tmp=now;\n\t\t\t\ttmp[sx*N+sy]='.';\n\t\t\t\ttmp[tx*N+ty]='@';\n\t\t\t\tstring nxt=tmp;\n\t\t\t\tfor(int x=0;x<N;x++)for(int y=0;y<N;y++)\n\t\t\t\t{\n\t\t\t\t\tif(nxt[x*N+y]=='@')continue;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tfor(int r=0;r<8;r++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint xx=x+dx[r],yy=y+dy[r];\n\t\t\t\t\t\tif(0<=xx&&xx<N&&0<=yy&&yy<N&&tmp[xx*N+yy]!='.')cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp[x*N+y]=='#'?2<=cnt&&cnt<=3:cnt==3)nxt[x*N+y]='#';\n\t\t\t\t\telse nxt[x*N+y]='.';\n\t\t\t\t}\n\t\t\t\tif(M.find(nxt)==M.end())\n\t\t\t\t{\n\t\t\t\t\tM[nxt]=cost+1;\n\t\t\t\t\tP.push(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tset<data> Vis;\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tif(t>10) break;\n\n\t\t\tif(Vis.count(D)>0) continue;\n\t\t\tVis.insert(D);\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 5;\nconst int dx[] = {1,1,0,-1,-1,-1, 0, 1};\nconst int dy[] = {0,1,1, 1, 0,-1,-1,-1};\n\nint N;\nstruct S {\n  char g[MAX_N][MAX_N];\n  int x, y;\n  int cost;\n  bool operator < (const S &s) const {\n    if(x != s.x) return x < s.x;\n    if(y != s.y) return y < s.y;\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n\tif(g[i][j] != s.g[i][j]) return g[i][j] < s.g[i][j];\n      }\n    }\n    return false;\n  }\n  void show() {\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n\tcout << g[i][j];\n      }\n      cout << endl;\n    }\n    cout << endl;\n  }\n};\n\nbool isAllFree(const S &s) {\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(s.g[i][j] == '#') return false;\n    }\n  }\n  return true;\n}\n\nvoid trance(const S &s, S &t, int x, int y) {\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(j == x && i == y) {\n\tt.g[i][j] = '.';\n\tcontinue;\n      }\n      int cnt = 0;\n      for(int k = 0; k < 8; ++k) {\n\tint nx = j + dx[k];\n\tint ny = i + dy[k];\n\tif(nx < 0 || nx >= N) continue;\n\tif(ny < 0 || ny >= N) continue;\n\tif(nx == x && ny == y) ++cnt;\n\tif(s.g[ny][nx] == '#') ++cnt;\n      }\n      if(s.g[i][j] == '.') {\n\tif(cnt == 3) t.g[i][j] = '#';\n\telse t.g[i][j] = '.';\n      } else {\n\tif(cnt == 2 || cnt == 3) t.g[i][j] = '#';\n\telse t.g[i][j] = '.';\n      }\n    }\n  }\n}\n\nint solve(S s) {\n  queue<S> que;\n  set<S> vis;\n  que.push(s);\n  vis.insert(s);\n  while(!que.empty()) {\n    s = que.front();\n    que.pop();\n    if(isAllFree(s)) return s.cost;\n    for(int i = 0; i < 8; ++i) {\n      S t;\n      t.x = s.x + dx[i];\n      t.y = s.y + dy[i];\n      t.cost = s.cost + 1;\n      if(t.x < 0 || t.x >= N) continue;\n      if(t.y < 0 || t.y >= N) continue;\n      if(s.g[t.y][t.x] == '#') continue;\n      trance(s, t, t.x, t.y);\n      if(vis.find(t) != vis.end()) continue;\n      vis.insert(t);\n      que.push(t);\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> N && N) {\n    S s;\n    s.cost = 0;\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n\tcin >> s.g[i][j];\n\tif(s.g[i][j] == '@') {\n\t  s.g[i][j] = '.';\n\t  s.x = j;\n\t  s.y = i;\n\t}\n      }\n    }\n    cout << solve(s) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nstruct arr{\n    int w, x, y, z;\n}q[10010], u;\nint T, n, m, x, y, l, r, res, cnt, nx, ny, sx, sy, nox, noy;\nint ans, dx[10], dy[10], f[7][7], c[7][7];\nbool flag;\nchar s[200];\nint main(int argc, const char * argv[])\n{\n    dx[0] = dx[1] = dx[2] = -1;\n    dx[5] = dx[6] = dx[7] = 1;\n    dy[0] = dy[3] = dy[5] = -1;\n    dy[2] = dy[4] = dy[7] = 1;\n    while (scanf(\"%d\", &n) != EOF)\n    {\n        if (!n) break;\n        cnt = 0, flag = 1;\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%s\", s);\n            for (int j = 0; j < n; j++)\n            {\n                if (s[j] == '#') cnt += 1 << (i * n + j), flag = 0;\n                if (s[j] == '@') cnt += 1 << (i * n + j), sx = i, sy = j;\n            }\n        }\n        if (flag)\n        {\n            printf(\"0\\n\");\n            continue;\n        }\n        flag = 1;\n        l = r = 0;\n        q[++r].x = sx, q[r].y = sy, q[r].z = cnt, q[r].w = 0;\n        while (l < r)\n        {\n            u = q[++l];\n            memset(c, 0, sizeof(c));\n            cnt = 0;\n            for (int j = 1; j <= n; j++)\n                for (int k = 1; k <= n; k++)\n                    if (u.z & (1 << ((j - 1) * n + k - 1))) c[j][k] = 1, cnt++;\n            //printf(\"%d %d %d %d\\n\", u.w, u.x, u.y, u.z);\n            if (cnt == 1)\n            {\n                //printf(\"%d %d %d \", u.w, u.x, u.y);\n                printf(\"%d\\n\", u.w);\n                flag = 0;\n                break;\n            }\n            for (int i = 0; i < 8; i++)\n            {\n                res = 0;\n                nx = u.x + dx[i], ny = u.y + dy[i];\n                if (nx < 0 || ny < 0 || nx == n || ny == n || c[nx + 1][ny + 1]) continue;\n                memset(f, 0, sizeof(f));\n                for (int j = 1; j <= n; j++)\n                    for (int k = 1; k <= n; k++)\n                        f[j][k] = c[j][k];\n                f[u.x + 1][u.y + 1] = 0;\n                f[nx + 1][ny + 1] = 1;\n                for (int j = 1; j <= n; j++)\n                    for (int k = 1; k <= n; k++)\n                    {\n                        if (j == nx + 1 && k == ny + 1)\n                        {\n                            res += 1 << ((j - 1) * n + k - 1);\n                            continue;\n                        }\n                        cnt = 0;\n                        for (int di = 0; di < 8; di++)\n                        {\n                            nox = j + dx[di], noy = k + dy[di];\n                            cnt += f[nox][noy];\n                        }\n                        if (cnt == 3) res += 1 << ((j - 1) * n + k - 1);\n                        if (cnt == 2 && f[j][k] == 1) res += 1 << ((j - 1) * n + k - 1);\n                    }\n                if (r <= 10000) q[++r].w = u.w + 1, q[r].x = nx, q[r].y = ny, q[r].z = res;\n            }\n        }\n        if (flag) printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <deque>\n#include <algorithm>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n\n#define MP make_pair\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//AOJ 1304\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={-1,0,1,-1,1,-1,0,1};\n\nset<int> vsi;\nint n;\n\ninline int getx(int a){return (a>>25 & 7);}\ninline int gety(int a){return (a>>28 & 7);}\ninline int getidx(int x, int y){return y*n+x;}\ninline int getstate(int a, int x, int y){return ((a>>getidx(x,y))&1);}\ninline int setstate(int a, int x, int y, int state){\n\tif(state){\n\t\treturn a|(1<<getidx(x,y));\n\t}else{\n\t\tint p=1<<getidx(x,y);\n\t\tp = ~p;\n\t\treturn a&p;\n\t}\n}\ninline int setpos(int a, int x, int y){\n\tint ret=a;\n\tret &= ((1<<25)-1);\n\tret |= x<<25;\n\tret |= y<<28;\n\treturn ret;\n}\n\ninline int count(int b){\n\tint ret = 0;\n\tREP(i,n)REP(j,n)if(getstate(b,i,j))ret++;\n\treturn ret-1;\n}\n\ninline int step(int &b){\n\tint tb = b;\n\tint ret = 0;\n\tint x=getx(b);\n\tint y=gety(b);\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(y==i&&x==j)continue;\n\t\t\tint cnt = 0;\n\t\t\tREP(k,8){\n\t\t\t\tint ny=i+dy[k];\n\t\t\t\tint nx=j+dx[k];\n\t\t\t\tif(nx<0 || ny<0 || nx>=n || ny>=n)continue;\n\t\t\t\tif(getstate(tb,nx,ny))cnt++;\n\t\t\t}\n\t\t\tif(getstate(tb,j,i)){\n\t\t\t\tif(cnt!=2&&cnt!=3)b=setstate(b,j,i,0);\n\t\t\t}else if(!getstate(tb,j,i)){\n\t\t\t\tif(cnt==3)b=setstate(b,j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>n, n){\n\t\tvsi.clear();\n\t\tstring b;\n\t\tREP(i,n){\n\t\t\tstring tmp;\n\t\t\tcin>>tmp;\n\t\t\tb+=tmp;\n\t\t}\n\t\tint is=0;\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tswitch(b[i*n+j]){\n\t\t\t\tcase '@':\n\t\t\t\t\tis = setpos(is, j, i);\n\t\t\t\tcase '#':\n\t\t\t\t\tis |= (1LL<<i*n+j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdeque<pair<int, int> > q;\n\t\tq.push_back(MP(0,is));\n\t\tint ans=-1;\n\t\twhile(!q.empty()){\n\t\t\tint x,y;\n\t\t\tpair<int, int> tmp=q.front();\n\t\t\tq.pop_front();\n\t\t\tif(EXIST(vsi,tmp.second))continue;\n\t\t\tvsi.insert(tmp.second);\n\t\t\tif(count(tmp.second)==0){\n\t\t\t\tans=tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = getx(tmp.second);\n\t\t\ty = gety(tmp.second);\n\t\t\tREP(i,8){\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(nx<0 || ny<0 || nx>=n || ny>=n || getstate(tmp.second, nx, ny)==1)continue;\n\t\t\t\tint tb = tmp.second;\n\t\t\t\ttb=setstate(tb,x,y,0);\n\t\t\t\ttb=setstate(tb,nx,ny,1);\n\t\t\t\ttb=setpos(tb,nx,ny);\n\t\t\t\tstep(tb);\n\t\t\t\tif(EXIST(vsi,tb)continue;\n\t\t\t\tq.push_back(MP(tmp.first+1, tb));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2009ツアツジツアツ地ツ凝ヲツ予ツ選 J : Infected Land\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nchar dx[] = {-1,-1,-1,0,1,1,1,0};\nchar dy[] = {-1,0,1,1,1,0,-1,-1};\n\nclass Node{\npublic:\n\tint land, x, y;\n\tNode(int land, int x, int y) : land(land), x(x), y(y) {}\n\tbool operator < (const Node &n) const { \n\t\treturn make_pair(land,make_pair(x,y)) < make_pair(n.land,make_pair(n.x,n.y));\n\t}\n};\n\nint main(){\n\tint n;\n\tstring s[5];\n\twhile(cin >> n, n){\n\t\tfor(int i=0;i<n;i++) cin >> s[i];\n\t\tint sx, sy;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tif(s[i][j]=='@') sx = i, sy = j;\n\t\tint land = 0;\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t\tfor(int j=n-1;j>=0;j--)\n\t\t\t\tland = 2*land + (s[i][j]=='#');\n\t\tint ans = -1;\n\t\tset<Node> mem; mem.insert(Node(land, sx, sy));\n\t\tqueue< pair<Node,int> > qu; qu.push(make_pair(Node(land,sx,sy),0));\n\t\twhile(!qu.empty()){\n\t\t\tpair<Node,int> p = qu.front(); qu.pop();\n\t\t\tint L = p.first.land, x = p.first.x, y = p.first.y, cost = p.second;\n\t\t\tif(L==0){ ans = cost; break; }\n\t\t\tfor(int dir=0;dir<8;dir++){\n\t\t\t\tint nx = x+dx[dir], ny = y+dy[dir];\n\t\t\t\tif(nx<0||n<=nx||ny<0||n<=ny||(L>>(nx*n+ny))&1) continue;\n\t\t\t\tint nL = 0;\n\t\t\t\tfor(int i=n-1;i>=0;i--){\n\t\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\t\tif(i==nx&&j==ny) continue;\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\t\tint ni = i+dx[k], nj = j+dy[k];\n\t\t\t\t\t\t\tif(ni<0||n<=ni||nj<0||n<=nj) continue;\n\t\t\t\t\t\t\tif(ni==nx&&nj==ny) cnt++;\n\t\t\t\t\t\t\telse cnt += (L>>(ni*n+nj))&1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((L>>(i*n+j))&1){\n\t\t\t\t\t\t\tif(cnt==2||cnt==3) nL |= 1<<(i*n+j);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(cnt==3) nL |= 1<<(i*n+j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(mem.find(Node(nL,nx,ny))==mem.end()){\n\t\t\t\t\tmem.insert(Node(nL,nx,ny));\n\t\t\t\t\tqu.push(make_pair(Node(nL,nx,ny),cost+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\nbool dfs(data D,int t){\n\tif(D.S==0) return true;\n\tif(t==0) return false;\n\trep(k,8){\n\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\tif(dfs(next_state(D.S,xx,yy),t-1)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\trep(t,11) if(dfs(ini,t)) { ans=t; break; }\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\nchar g[5][5];\nint n;\n\nbool ok(void){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(g[i][j]=='#')return false;\n  return true;\n}\n\nvoid change(void){\n  bool g1[n][n];\n  fill(g1[0],g1[n],false);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int now=0;\n      if(g[i][j]=='@')continue;\n      for(int k=-1;k<2;k++){\n\tfor(int l=-1;l<2;l++){\n\t  if(i+k<0 || j+l<0 ||n<=i+k || n<=j+l)continue;\n\t  if(k==0 && l==0)continue;\n\t  now+=(g[i+k][j+l]=='#' || g[i+k][j+l]=='@');\n\t}\n      }\n      if(g[i][j]=='#' && (now==2||now==3))g1[i][j]=true;\n      if(g[i][j]=='.' && now==3)g1[i][j]=true;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(g[i][j]=='@')continue;\n      if(g1[i][j])g[i][j]='#';\n      else g[i][j]='.';\n    }\n  }\n}\n\nint lim;\n\nbool rec(int x,int y,int d){\n  \n  if(ok())return true;\n  if(d>=lim)return false;\n  change();  \n\n  for(int i=-1;i<2;i++){\n    for(int j=-1;j<2;j++){\n      int nx=x+j,ny=y+i;\n      if(i==0 && j==0)continue;\n      if(nx<0 || ny<0 || n<=nx || n<=ny || g[ny][nx]=='#')continue;\n      swap(g[y][x],g[ny][nx]);\n      g[y][x]='.';\n      rec(nx,ny,d+1);\n    }\n  }\n  return false;\n}\n\nint main(void){\n\n  while(cin >> n,n){\n    fill(g[0],g[5],'*');\n    for(int i=0;i<n;i++)cin >> g[i];\n\n    int x,y;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(g[i][j]=='@')y=i,x=j;\n\n    for(lim=0;lim<11;lim++){\n      if(rec(x,y,0))break;\n    }\n    if(lim>=11)cout << -1 << endl;\n    else cout << lim << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n\nbool onmp(int x,int y){return x>=0&&y>=0&&x<n&&y<n;}\n\nbool check(const vector<string> &A){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(A[i][j]=='#')return 0;\n  return 1;\n}\n\nint count(int x,int y,const vector<string> &A){\n  int res=0;  \n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i,ny = y+j;\n      if((i||j)&&onmp(nx,ny))res += A[ny][nx]!='.';\n    }\n  return res;\n}\n\nvector<string> mkmp(const vector<string> &A){\n  vector<string> res=A;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cnt = count(j,i,A);\n      if(A[i][j]=='#')res[i][j]=(cnt==2||cnt==3)? '#':'.';\n      if(A[i][j]=='.')res[i][j]=(cnt==3)? '#':'.';\n      if(A[i][j]=='@')res[i][j]='@';\n    }\n  return res;\n}\n\n\nvoid getPos(vector<string>&A,int &x,int &y){\n  for(int i=0;i<n&&x==-1;i++)\n    for(int j=0;j<n&&x==-1;j++) if(A[i][j]=='@')x=j,y=i;\n}\n\nstruct dat{\n  int cost;\n  vector<string> A;\n};\n\nint bfs(vector<string>start){\n  queue<vector<string> > Q;\n  map<vector<string>,int>D;\n  Q.push(start);\n  D[start]=0;\n\n  while(!Q.empty()){\n    vector<string> A=Q.front();Q.pop();\n    int cost = D[A];\n    int x = -1,y=-1;\n    getPos(A,x,y);\n    if(check(A))return cost;\n    if(cost>=10)continue;\n\n    A[y][x] = '.';\n    for(int dy=-1;dy<=1;dy++)\n      for(int dx=-1;dx<=1;dx++){\n\tint nx = x+dx,ny = y+dy;\n\tif((!dx&&!dy)||!onmp(nx,ny)||A[ny][nx]=='#')continue;\n\tA[ny][nx] = '@';\n\tvector<string> nA = mkmp(A);\n\tif(!D.count(nA))Q.push(nA),D[nA] = cost+1;\n\tA[ny][nx] = '.';\n      }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>n,n){\n    vector<string> mp(n);\n    for(int i=0;i<n;i++)cin>>mp[i];\n    cout<<bfs(mp)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nconst int INF = 1LL << 28;\n\nstruct state {\n  int v, s, d;\n};\n\nbool check(state c, int dy, int dx, int N) {\n  int vy = c.v / N, vx = c.v % N;\n  int ny = vy + dy, nx = vx + dx;\n  return 0 <= ny && ny < N && 0 <= nx && nx < N && !(c.s & (1 << (ny * N + nx)));\n}\n\nstate move(state c, int dy, int dx, int N) {\n  int vy = c.v / N, vx = c.v % N;\n  int ny = vy + dy, nx = vx + dx;\n\n  int ns = 0;\n  REP(i, 0, N) REP(j, 0, N) {\n    if (i == ny && j == nx) continue;\n\n    int cnt = 0;\n    REP(di, -1, 2) REP(dj, -1, 2) if (di != 0 || dj != 0) {\n      int ni = i + di, nj = j + dj;\n      if (0 <= ni && ni < N && 0 <= nj && nj < N) {\n        if (c.s & (1 << (ni * N + nj))) cnt++;\n        if (ni == ny && nj == nx) cnt++;\n      }\n    }\n\n    if (c.s & (1 << (i * N + j))) {\n      if (cnt == 2 || cnt == 3) ns |= 1 << (i * N + j);\n    } else {\n      if (cnt == 3) ns |= 1 << (i * N + j);\n    }\n  }\n\n  return (state) { ny * N + nx, ns, c.d + 1 };\n}\n\nint solve(int N, const vector<string> &S) {\n  int init_v, init_s = 0;\n  REP(i, 0, N) REP(j, 0, N) {\n    if (S[i][j] == '@') {\n      init_v = i * N + j;\n    }\n    if (S[i][j] == '#') {\n      init_s |= 1 << (i * N + j);\n    }\n  }\n\n  set<pair<int, int>> st;\n\n  queue<state> q;\n  q.push((state) { init_v, init_s, 0 });\n\n  while (q.size()) {\n    state c = q.front();\n    q.pop();\n\n    if (st.count(make_pair(c.v, c.s))) continue;\n    st.insert(make_pair(c.v, c.s));\n\n    if (c.s == 0) return c.d;\n\n    REP(dy, -1, 2) REP(dx, -1, 2) if (dy != 0 || dx != 0) {\n      if (check(c, dy, dx, N)) {\n        state n = move(c, dy, dx, N);\n        if (!st.count(make_pair(n.v, n.s))) q.push(n);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(void) {\n  for (int N; cin >> N, N;) {\n    vector<string> S(N);\n    REP(i, 0, N) cin >> S[i];\n    cout << solve(N, S) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\nusing namespace std;\n\nconst int mask = (1<<25) - 1;\nunordered_map<int,int> memo;\n\nint n;\nint trnas[1<<25];\n\ninline bool isInfected(int y, int x, const vector<string> &g){\n  int cnt = 0;\n  rep(i,3)rep(j,3){\n    int ny = y+i-1, nx = x+j-1;\n    if(i==1 && j==1)continue;\n    if(!range(ny,0,n) || !range(nx,0,n))continue;\n    if(g[ny][nx] == '#')cnt++;\n  }\n\n  if(cnt == 3)return true;\n  if(g[y][x] == '#' && cnt==2)return true;\n  return false;\n}\n\ninline int encode(int y, int x, const vector<string> &g){\n  int res = 0;\n  rep(i,n)rep(j,n){\n    if(g[i][j] == '#')res |= 1<<(i*n+j);\n  }\n  res |= (y*n+x)<<25;\n  return res;\n}\n\ninline void decode(int c, vector<string> &g){\n  rep(i,n)rep(j,n){\n    if( (c>>(i*n+j))&1 )g[i][j] = '#';\n    else g[i][j] = '.';\n  }\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  while(cin >> n, n){\n    vector<string> a(n);\n    int y = 0,x = 0;\n    rep(i,n){\n      cin >> a[i];\n      rep(j,n){\n\tif(a[i][j] == '@'){\n\t  y = i; x = j; a[i][j] = '.';\n\t}\n      }\n    }\n\n    int cur = encode(y,x,a);\n    memo.clear();\n    memo[cur] = 0;\n    queue<int> q;\n    q.push(cur);\n\n    int ans = -1;\n    while(q.size()){\n      cur = q.front(); q.pop();\n      if( (cur & mask) == 0){\n\tans = memo[cur]; break;\n      }\n\n      decode(cur,a);\n      y = (cur>>25)/n, x = (cur>>25)%n;\n\n      rep(ii,3)rep(jj,3){\n\tint ny = y + ii-1, nx = x + jj-1;\n\tif(ii==1 && jj==1)continue;\n\tif(!range(ny,0,n) || !range(nx,0,n))continue;\n\tif(a[ny][nx] == '#')continue;\n\n\ta[ny][nx] = '#';\n\n\tint nxt = (ny*n+nx) << 25;\n\trep(i,n)rep(j,n){\n\t  if(isInfected(i,j,a) && (ny!=i||nx!=j))nxt |= 1<<(i*n+j);\n\t}\n\tif(memo.count(nxt)==0){\n\t  memo[nxt] = memo[cur]+1;\n\t  q.push(nxt);\n\t}\n\n\ta[ny][nx] = '.';\n      }\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1},ans;\nmap<P,int> m;\nbool check(int x, int y) {\n  return x>=0&&x<n&&y>=0&&y<n;\n}\n\nP S(vector<string> s) {\n  P p=P(0,0);\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<n; j++) {\n      if(s[i][j]=='#') p.first|=1<<(i*n+j);\n      if(s[i][j]=='@') p.second=i*n+j;\n    }\n  }\n  return p;\n}\n\nvector<string> change(vector<string> s) {\n  vector<string> t=s;\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<n; j++) {\n      int c=0;\n      for(int k=0; k<8; k++) {\n        int x=i+dx[k],y=j+dy[k];\n        if(!check(x,y)) continue;\n        if(s[x][y]!='.') c++;\n      }\n      if(s[i][j]=='#') {\n        if(c==2||c==3) t[i][j]='#';\n        else t[i][j]='.';\n      }\n      if(s[i][j]=='.') {\n        if(c==3) t[i][j]='#';\n        else t[i][j]='.';\n      }\n      if(s[i][j]=='@') t[i][j]='@';\n    }\n  }\n  return t;\n}\n\nint main() {\n  while(cin >> n && n) {\n    vector<string> s(n);\n    for(int i=0; i<n; i++) cin >> s[i];\n    queue<P> que;\n    P p=S(s);\n    que.push(p);\n    m.clear();\n    m[p]=0;\n    while(!que.empty()) {\n      P p=que.front();que.pop();\n      vector<string> s(n);\n      bool f=1;\n      for(int i=0; i<n; i++) {\n        for(int j=0; j<n; j++) {\n          if(p.first&(1<<(i*n+j))) s[i]+='#',f=0;\n          else s[i]+='.';\n        }\n      }\n      s[p.second/n][p.second%n]='@';\n      if(f) {\n        cout << m[p] << endl;\n        goto end;\n      }\n      int nx=p.second/n,ny=p.second%n,c=m[p];\n      for(int i=0; i<8; i++) {\n        int x=nx+dx[i],y=ny+dy[i];\n        if(!check(x,y)||s[x][y]!='.') continue;\n        vector<string> t=s;\n        t[nx][ny]='.';\n        t[x][y]='@';\n        t=change(t);\n        P q=S(t);\n        if(m.count(q)) continue;\n        m[q]=c+1;\n        que.push(q);\n      }\n    }\n    cout << -1 << endl;\n  end:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nchar board[6][6],ma[6][6],tmap[6][6];\nint mov[8][2] = {1,0,1,-1,0,-1,-1,-1,-1,0,-1,1,0,1,1,1};\nint mark[200];\nint n;\nstruct status\n{\n    int x,y;\n    int ord;\n    int te;\n    status(int a,int b,int c){x = a, y= b, ord = c;}\n};\npair < int,int > s;\n\nint encode(char (*a)[6])\n{\n    int bb=0;\n    int va = 1;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            bb += mark[a[i][j]]*(va);\n            va *= 2;\n        }\n    }\n    return bb;\n}\n\nvoid decode(int p,int x,int y)\n{\n    int cnt = 0;\n    while(cnt != n*n)\n    {\n        int t = p%2;\n        ma[cnt/n][cnt%n] = t==1?'#':'.';\n        p /= 2;\n        cnt++;\n    }\n    ma[x][y] ='@';\n}\n\nvoid construct(int s,int e,int ss,int ee)\n{\n    memcpy(tmap,ma,sizeof(tmap));\n    char newmap[6][6];\n    swap(tmap[s][e],tmap[ss][ee]);\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            int cnt = 0;\n            for(int k=0;k<8;k++)\n            {\n                int tx = i + mov[k][0] , ty = j + mov[k][1];\n                if(tx >= 0 && ty >= 0 && tx < n && ty < n && (tmap[tx][ty]=='#' || tmap[tx][ty]=='@'))\n                    cnt++;\n            }\n            if(tmap[i][j] == '.')\n            {\n                if(cnt == 3) newmap[i][j] = '#';\n                else newmap[i][j] = tmap[i][j];\n            }\n            else if(tmap[i][j] == '#')\n            {\n                if(cnt == 3 || cnt == 2) newmap[i][j]='#';\n                else newmap[i][j] = '.';\n            }\n            else newmap[i][j] = tmap[i][j];\n        }\n    }\n    memcpy(tmap,newmap,sizeof(tmap));\n}\n\nint bfs()\n{\n     struct status fir(s.first,s.second,0);\n     fir.te = encode(board);\n     queue <struct status> q;\n     q.push(fir);\n     int flag = -1;\n\n     while(!q.empty())\n     {\n         struct status vi = q.front();\n         decode(vi.te,vi.x,vi.y);\n         q.pop();\n         if(!vi.te) flag = vi.ord;\n         if(vi.ord > 10) break;\n         if(flag == -1)\n         {\n             for(int i=0;i<8;i++)\n             {\n                 int tx = vi.x + mov[i][0],ty = vi.y + mov[i][1];\n                 if(tx >= 0 && ty >= 0 && tx < n && ty < n && ma[tx][ty]!='#')\n                 {\n                     construct(vi.x,vi.y,tx,ty);\n                     struct status newt(tx,ty,vi.ord+1);\n                     newt.te = encode(tmap);\n                     q.push(newt);\n                 }\n             }\n         }\n         else break;\n     }\n     return flag;\n}\n\nint main()\n{\n    mark['#'] = 1, mark['.'] = 0, mark['@'] = 0;\n    while(~scanf(\"%d\",&n),n)\n    {\n        getchar();\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                scanf(\"%c\",&board[i][j]);\n                if(board[i][j] == '@') s = make_pair(i,j);\n            }\n            getchar();\n        }\n        printf(\"%d\\n\",bfs());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <fstream>\n#include <set>\n\nusing namespace std;\n\nconst int dy[]={-1,-1,-1,0,0,1,1,1};\nconst int dx[]={-1,0,1,-1,1,-1,0,1};\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> sit;\n\nint n;\nchar field[6][6];\npii sp;\n\n\nint bfs(){\n\tint res=0;\n\tqueue<sit> q[2];\n\tset<sit> used;\n\tint cur=0;\n\tint nxt=1;\n\tint ss=0;\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(field[i][j]=='#')ss|=(1<<(i*n+j));\n\tq[cur].push(sit(ss,sp));\n\twhile(q[cur].size()){\n\t\twhile(q[cur].size()){\n\t\t\tsit csit=q[cur].front();q[cur].pop();\n\t\t\tif(csit.first==0)return res;\n\t\t\tconst int fsit=csit.first;\n\t\t\tconst pii &pp=csit.second;\n\t\t\tfor(int l=0;l<8;l++){\n\t\t\t\tif(l==5){\n\t\t\t\t\t//cout<<endl;\n\t\t\t\t}\n\t\t\t\tint ny=pp.first+dy[l];\n\t\t\t\tint nx=pp.second+dx[l];\n\t\t\t\tif(ny>=0&&nx>=0&&ny<n&&nx<n&&!((fsit>>(ny*n+nx))&1)){\n\t\t\t\t\tint nfield=0;\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\t\tif(ny==i&&nx==j)continue;\n\t\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\t\t\tint adx=j+dx[k];\n\t\t\t\t\t\t\t\tint ady=i+dy[k];\n\t\t\t\t\t\t\t\tif(ady>=0&&adx>=0&&ady<n&&adx<n)\n\t\t\t\t\t\t\t\t\tif(((fsit>>(ady*n+adx))&1)||(ny==ady&&nx==adx))cnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((fsit>>(i*n+j))&1){\n\t\t\t\t\t\t\t\tif(cnt==2||cnt==3)nfield|=(1<<(i*n+j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tif(cnt==3)nfield|=(1<<(i*n+j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsit nsit=make_pair(nfield,make_pair(ny,nx));\n\t\t\t\t\tif(used.find(nsit)!=used.end())continue;\n\t\t\t\t\tused.insert(nsit);\n\t\t\t\t\tq[nxt].push(nsit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(cur,nxt);\n\t\tres++;\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='@')sp.first=i,sp.second=j,field[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tint res=bfs();\n\t\tcout<<res<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\nstruct node{\n\tvs f;\n\tpii pos;\n\tnode(vs &f,pii &pos):f(f),pos(pos){}\n\tstring to_s() const{\n\t\tint n=f.size();\n\t\tstring ret; \n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tret+=pos.first==i&&pos.second==j?'@':f[i][j];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tbool operator<(const node &other)const{\n\t\treturn to_s()<other.to_s();\n\t}\n};\nint dy[]={-1,-1,-1,0,1,1,1,0};\nint dx[]={-1,0,1,1,1,0,-1,-1};\n\nvs change(vs &f,int y,int x){\n\tint n=f.size();\n\tvs nf(f);\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(y==i&&x==j)continue;\n\t\t\tint cnt=0;\n\t\t\tREP(d,8){\n\t\t\t\tint yy=i+dy[d];\n\t\t\t\tint xx=j+dx[d];\n\t\t\t\tif(yy>=0&&xx>=0&&yy<n&&xx<n){\n\t\t\t\t\tcnt+=f[yy][xx]=='#'||(y==yy&&x==xx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch(f[i][j]){\n\t\t\tcase '.':\n\t\t\t\tnf[i][j]=cnt==3?'#':'.';\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tnf[i][j]=(cnt==2||cnt==3?'#':'.');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t}\n\t}\n\treturn nf;\n}\n\nbool done(vs &f){\n\tint n=f.size();\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(f[i][j]=='#'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tvs f(N);\n\t\tpii p;\n\t\tREP(i,N){\n\t\t\tcin>>f[i];\n\t\t\tREP(j,N){\n\t\t\t\tif(f[i][j]=='@'){\n\t\t\t\t\tp=make_pair(i,j);\n\t\t\t\t\tf[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<node> q;\n\t\tmap<node,int> cost;\n\t\tq.push(node(f,p));\n\t\tcost[node(f,p)]=0;\n\t\tint ans=-1;\n\t\twhile(q.size()){\n\t\t\tnode n=q.front();q.pop();\n\t\t\tif(done(n.f)){\n\t\t\t\tans=cost[n];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(d,8){\n\t\t\t\tint y=n.pos.first+dy[d];\n\t\t\t\tint x=n.pos.second+dx[d];\n\t\t\t\tif(y>=0&&x>=0&&y<N&&x<N){\n\t\t\t\t\tif(n.f[y][x]=='.'){\n\t\t\t\t\t\tvs nf=change(n.f,y,x);\n\t\t\t\t\t\tnode nnode(nf,make_pair(y,x));\n\t\t\t\t\t\tif(!EXIST(cost,nnode)){\n\t\t\t\t\t\t\tcost[nnode]=cost[n]+1;\n\t\t\t\t\t\t\tq.push(nnode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nint n,y,x,cnt;\n\nvector< string > a;\nvector< string > b;\n\nstring tmp=\",#@\";\n\nvoid change(ll p){\n  cnt=0;\n  for(int i=n-1;i>=0;i--){\n    for(int j=n-1;j>=0;j--){\n      a[i][j]=tmp[p%3];\n      if(a[i][j]=='#')cnt++;\n      if(a[i][j]=='@')y=i,x=j;\n      p/=3;\n    }\n  }\n}\n\nll change2(){\n  ll res=0;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      res*=3;\n      if(a[i][j]=='#')res++;\n      if(a[i][j]=='@')res+=2;\n    }\n  }\n  return res;\n}\n\nll change3(){\n  b=a;\n  ll res=0;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(a[i][j]=='@'){\n        a[i][j]='@';\n      }else{\n        int cnt=0;\n        for(int k=-1;k<=1;k++){\n          for(int l=-1;l<=1;l++){\n            if(k==0&&l==0)continue;\n            if(i+k<0 || n<=i+k)continue;\n            if(j+l<0 || n<=j+l)continue;\n            if(b[i+k][j+l]!=',')cnt++;\n          }\n        }\n        if(b[i][j]=='#'&&(cnt==3||cnt==2)){\n          a[i][j]='#';\n        }else if(b[i][j]==','&&cnt==3){\n          a[i][j]='#';\n        }else{\n          a[i][j]=',';\n        }\n      }\n      \n      res*=3;\n      if(a[i][j]=='#')res++;\n      if(a[i][j]=='@')res+=2;\n    }\n  }\n  return res;\n}\n\nint solve(){\n  map< ll , int > d;\n  queue< ll > Q;\n  d[ change2() ]=0;\n  Q.push( change2() );\n  while(!Q.empty()){\n    ll p=Q.front();Q.pop();\n    change(p);\n    \n    /*\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        cout<<a[i][j];\n      }\n      cout<<endl;\n    }\n    */\n    if(cnt==0)return d[p];\n\n    for(int ny=y-1;ny<=y+1;ny++){\n      for(int nx=x-1;nx<=x+1;nx++){\n        if(ny<0 || nx<0)continue;\n        if(ny>=n || nx>=n)continue;\n        if(a[ny][nx]!=',')continue;\n\n        swap(a[ny][nx],a[y][x]);\n\n        ll next=change3();\n        if( d.count(next) == 0)d[next]=1e9;\n        if( d[p] + 1 < d[next]){\n          d[next]=d[p]+1;\n          Q.push(next);\n        }\n        \n        change(p);\n      }\n    }\n  }\n  return -1;\n}\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    a.clear();\n    a.resize(n);\n    for(int i=0;i<n;i++)cin>>a[i];\n    cout<< solve() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\n#define INF 100000000\n\nint n;\nmap<pair<int,int>,int> dp;\nmap<pair<int,int>,bool> vis;\nmap<pair<int,int>,bool> now;\nmap<pair<int,int>,int> next;\nchar buf[25][25];\nint dx[] = {-1,0,1,-1,1,-1,0,1};\nint dy[] = {-1,-1,-1,0,0,1,1,1};\n\nint make(pair<int,int> p) {\n\t//if (next.find(p)!=next.end()) return next[p];\n\tint mask = p.first;\n\tint pos = p.second;\n\tmask |= (1<<pos);\n\tint newmask = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tint k = i*n+j;\n\t\t\tint t = 0;\n\t\t\tif (j>0) {\n\t\t\t\tt += (mask&(1<<(k-1)))>0;\n\t\t\t\tif (i>0) t += (mask&(1<<(k-1-n)))>0;\n\t\t\t\tif (i<n-1) t += (mask&(1<<(k-1+n)))>0;\n\t\t\t}\n\t\t\tif (j<n-1) {\n\t\t\t\tt += (mask&(1<<(k+1)))>0;\n\t\t\t\tif (i>0) t += (mask&(1<<(k+1-n)))>0;\n\t\t\t\tif (i<n-1) t += (mask&(1<<(k+1+n)))>0;\n\t\t\t}\n\t\t\tif (i>0) t += (mask&(1<<(k-n)))>0;\n\t\t\tif (i<n-1) t += (mask&(1<<(k+n)))>0;\n\t\t\tif ((mask&(1<<k)) && k!=pos) {\n\t\t\t\tif (t==2 || t==3) {\n\t\t\t\t\tnewmask |= (1<<k);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (t==3 && k!=pos) {\n\t\t\t\t\tnewmask |= (1<<k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//next[p] = newmask;\n\treturn newmask;\n}\n\nvoid print(int m) {\n\tfor (int i=0; i<n;  i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tint k = i*n+j;\n\t\t\tif (m&(1<<k)) cout<<'#';\n\t\t\telse cout<<'.';\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\nint solve(int x, int y, int mask) {\n\t//cout<<x<<\" \"<<y<<\" \"<<mask<<endl;\n\t//print(mask);\n\t//cout<<endl;\n\tif (mask==0) return 0;\n\tif (dp[make_pair(mask,x*n+y)]) return dp[make_pair(mask,x*n+y)];\n\tif (now[make_pair(mask,x*n+y)]) return INF;\n\t\n\tnow[make_pair(mask,x*n+y)] = 1;\n\t\n\tint tmp = INF;\n\tint t = 1000;\n\t\n\tfor (int k=0; k<8; k++) {\n\t\tint u = x + dx[k];\n\t\tint v = y + dy[k];\n\t\tif (u<0 || u>=n) continue;\n\t\tif (v<0 || v>=n) continue;\n\t\tif (mask&(1<<(u*n+v))) continue;\n\t\t\n\t\tint m = make(make_pair(mask,u*n+v));\n\t\t\n\t\tt = min(t,__builtin_popcount(m));\n\t}\n\t\n\tfor (int k=0; k<8; k++) {\n\t\tint u = x + dx[k];\n\t\tint v = y + dy[k];\n\t\tif (u<0 || u>=n) continue;\n\t\tif (v<0 || v>=n) continue;\n\t\tif (mask&(1<<(u*n+v))) continue;\n\t\t\n\t\tint m = make(make_pair(mask,u*n+v));\n\t\t\n\t\tif (__builtin_popcount(m)==t) {\n\t\t\ttmp = min(tmp, 1 + solve(u,v,m));\n\t\t}\n\t}\n\t\n\tnow[make_pair(mask,x*n+y)] = 0;\n\t//vis[make_pair(mask,x*n+y)] = 1;\n\tdp[make_pair(mask,x*n+y)] = tmp;\n\t\n\treturn tmp;\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d\",&n) && n!=0) {\n\t\tfor (int i=0; i<n; i++) scanf(\"%s\",buf+i);\n\t\tint x,y;\n\t\tint mask = 0;\n\t\tfor (int i=0; i<n; i++) for (int j=0; j<n; j++) {\n\t\t\tif (buf[i][j]=='#') mask |= (1<<(i*n+j));\n\t\t\tif (buf[i][j]=='@') {\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t\tnow.clear();\n\t\tvis.clear();\n\t\tdp.clear();\n\t\tint ans = solve(x,y,mask);\n\t\tif (ans >= INF) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n\nbool onmp(int x,int y){return x>=0&&y>=0&&x<n&&y<n;}\n\nint count(int x,int y,const vector<string> &A){\n  int res=0;  \n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i,ny = y+j;\n      if((!i&&!j)||!onmp(nx,ny))continue;\n      res += A[ny][nx]=='#'||A[ny][nx]=='@';\n    }\n  return res;\n}\n\nbool check(const vector<string> &A){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(A[i][j]=='#')return 0;\n  return 1;\n}\n\n\nvector<string> mkmp(const vector<string> &A){\n  vector<string> res(n,string(n,'.'));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cnt = count(j,i,A);\n      if(A[i][j]=='#')res[i][j]=(cnt==2||cnt==3)? '#':'.';\n      if(A[i][j]=='.')res[i][j]=(cnt==3)? '#':'.';\n      if(A[i][j]=='@')res[i][j]='@';\n    }\n  return res;\n}\n\n\nmap<vector<string>,int> mem;\nint ans;\nvoid dfs(int x,int y,int cnt,vector<string> A){\n  if(check(A))ans=min(cnt,ans);\n  if(cnt>=ans) return;\n  if(mem.count(A)&&mem[A]<=cnt)return;\n  mem[A]=cnt;\n  A[y][x] = '.';\n  for(int dy=-1;dy<=1;dy++){\n    for(int dx=-1;dx<=1;dx++){\n      int nx = x+dx,ny = y+dy;\n      if((!dx&&!dy)||!onmp(nx,ny)||A[ny][nx]=='#')continue;\n      A[ny][nx] = '@';\n      dfs(nx,ny,cnt+1,mkmp(A));\n      A[ny][nx] = '.';\n    }\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    vector<string> mp(n);\n    for(int i=0;i<n;i++)cin>>mp[i];\n    int sx,sy;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)if(mp[i][j]=='@')sy=i,sx=j;\n    mem.clear();\n    ans = 15;\n    dfs(sx,sy,0,mp);\n    cout<<(ans<15? ans:-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nstruct data{\n  uint x : 3;\n  uint y : 3;\n  uint b : 26;\n\n  inline data() : x(0), y(0), b(0) {}\n  inline data(uint xx, uint yy, uint bb) : x(xx), y(yy), b(bb) {}\n  inline operator bool () { return b != (1<<26) - 1; }\n  void printa(int n){\n    REP(i,n){\n      REP(j,n){\n        if(x == j && y == i) printf(\"@\");\n        else printf(\"%c\",((1<<(i*n+j))&b) ? '#' : '.');\n      }\n      puts(\"\");\n    }\n  }\n}__attribute__((packed));\n\ndata m = data(0,0,(1<<26)-1);\n\n#define print(x) printf(\"%d\\n\",x)\nconst int _dx[] = {-1,-1,-1,0,0,1,1,1};\nconst int _dy[] = {-1,0,1,-1,1,-1,0,1};\n\nint main(){\n  int n;\n  while(scanf(\"%d \",&n), n){\n    data init; init.b = 0;\n\n    REP(i,n){\n      char buff[10];\n      scanf(\"%s \",buff);\n      REP(j,n){\n        switch(buff[j]){\n        case '.': break;\n        case '#': init.b |= (1<<(i*n+j)); break;\n        case '@': init.x = j; init.y = i; break;\n        }\n      }\n    }\n\n    //    init.printa(n);\n\n    int ans = 0;\n    const int th = 10;\n    queue<data> q;\n    q.push(init); q.push(m);\n\n    while(q.size() != 1){\n      data d = q.front();\n      q.pop();\n\n      if(!d){\n        ans++;\n        q.push(m);\n        //printf(\"ans: %d\\n\",ans);\n        continue;\n      }\n\n      if(d.b == 0){\n        print(ans);\n        break;\n      }\n\n      if(ans > th)\n        break;\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n      REP(i,8){\n        int xx = (int)d.x + _dx[i];\n        int yy = (int)d.y + _dy[i];\n        if(ISIN(xx,yy,n,n) && (d.b & (1<<(yy*n+xx))) == 0){\n          data dd(xx,yy,0);\n          REP(y,n) REP(x,n) if(y != yy || x != xx){\n            int cnt = 0;\n            REP(j,8){\n              int xxx = x + _dx[j];\n              int yyy = y + _dy[j];\n              if(ISIN(xxx,yyy,n,n) && (d.b & (1<<(yyy*n+xxx))))\n                cnt++;\n              else if(xx == xxx && yy == yyy) cnt++;\n            }\n            if(d.b & (1<<(y*n+x))){\n              if(cnt == 2 || cnt == 3) dd.b |= (1<<(y*n+x));\n            }else{\n              if(cnt == 3) dd.b |= (1<<(y*n+x));\n            }\n          }\n          q.push(dd);\n        }\n      }\n\n    }\n\n    if(ans > th) print(-1);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    string S;\n    for(int i = 0; i < N; i++) {\n      string T;\n      cin >> T;\n      S += T;\n    }\n\n    queue< string > que;\n    map< string, int > v;\n    que.emplace(S);\n    v[S] = 0;\n\n    bool flag = false;\n    while(!que.empty()) {\n      string p = que.front();\n      int cost = v[p];\n      que.pop();\n      if(count(begin(p), end(p), '#') == 0) {\n        cout << cost << endl;\n        flag = true;\n        break;\n      }\n      auto pos = p.find('@');\n      int x = pos % N, y = pos / N;\n      for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n          if(i == 0 && j == 0) continue;\n          int nx = x + i, ny = y + j;\n          if(nx < 0 || ny < 0 || nx >= N || ny >= N) continue;\n          if(p[nx + ny * N] == '#') continue;\n          swap(p[nx + ny * N], p[pos]);\n          string T = p;\n          for(int k = 0; k < N; k++) {\n            for(int l = 0; l < N; l++) {\n              int ret = 0;\n              for(int m = -1; m <= 1; m++) {\n                for(int n = -1; n <= 1; n++) {\n                  if(m == 0 && n == 0) continue;\n                  int vx = k + m, vy = l + n;\n                  if(vx < 0 || vy < 0 || vx >= N || vy >= N) continue;\n                  ret += p[vx + vy * N] != '.';\n                }\n              }\n              if(p[k + l * N] == '#') T[k + l * N] = ret == 2 || ret == 3 ? '#' : '.';\n              else if(p[k + l * N] == '.') T[k + l * N] = ret == 3 ? '#' : '.';\n            }\n          }\n          if(!v.count(T)) {\n            v[T] = cost + 1;\n            que.emplace(T);\n          }\n          swap(p[nx + ny * N], p[pos]);\n        }\n      }\n    }\n    if(!flag) cout << -1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstruct NODE{\n\tint x,bit;\n\tNODE(int x,int bit) : x(x) , bit(bit) {}\n};\n\nint n;\nvector<int> dd[25];\n\nint mask[25];\n\nint sim(int bit){\n\tint nextbit = 0;\n\tfor(int i = 0 ; i < n*n ; i++){\n\t\tint c = __builtin_popcount(bit&mask[i]);\n\t\tif( (bit >> i & 1) && (c == 2) ){\n\t\t\tnextbit |= (1<<i);\n\t\t}else if( c == 3 ){\n\t\t\tnextbit |= (1<<i);\n\t\t}\n\t} \n\treturn nextbit;\n}\n\nstring view(int bit){\n\t\tstring s;\n\tfor(int i = 0 ; i < n * n ; i++) s += string(1,(bit>>i&1) + '0') + ((i+1)%n==0?\"\\n\":\"\"); \n\treturn s;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tint bit = 0;\n\t\tint st = 0;\n\t\tint weight = 1;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '#' ) bit += weight;\n\t\t\t\tweight *= 2;\n\t\t\t\tif( c == '@' ) st = n * i + j;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tdd[i*n+j].clear();\n\t\t\t\tmask[i*n+j] = 0;\n\t\t\t\tfor(int k = 0 ; k < 8 ; k++){\n\t\t\t\t\tint dx[] =  {0, 1,0,-1,1,1,-1,-1};\n\t\t\t\t\tint dy[] =  {-1,0,1,0,1,-1,1,-1};\n\t\t\t\t\tint y = i + dy[k];\n\t\t\t\t\tint x = j + dx[k];\n\t\t\t\t\tif( y >= n || x >= n || x < 0 || y < 0 ) continue;\n\t\t\t\t\tdd[i*n+j].push_back(n*y+x);\n\t\t\t\t\tmask[i*n+j] |= (1<<(n*y+x));\n\t\t\t\t\t//cout << i << \",\" << j << \" : \" << dd[i*n+j].back() << endl;\n\t\t\t\t}\n\t\t\t\t//dd[i*n+j].push_back(i*n+j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<NODE> Q;\n\t\tQ.push(NODE(st,bit));\n\t\tmap<int,int> done[25];\n\t\tdone[st][bit] = 0;\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t//cout << view(q.bit) << q.x << \" \" << (q.bit >> q.x & 1 ) << \"[\" << done[q.x][q.bit] << \"]\" << endl;\n\t\t\t\n\t\t\tif( q.bit == 0 ){\n\t\t\t\tcout << done[q.x][q.bit] << endl;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0 ; i < dd[q.x].size() ; i++){\n\t\t\t\tif( !(q.bit >> (dd[q.x][i]) & 1) ){\n\t\t\t\t\tint tnext = sim(q.bit|(1<<dd[q.x][i])) &~ (1<<dd[q.x][i]);\n\t\t\t\t\tif( !done[dd[q.x][i]].count(tnext) ){\n\t\t\t\t\t\tdone[dd[q.x][i]][tnext] = done[q.x][q.bit] + 1;\n\t\t\t\t\t\tQ.push(NODE(dd[q.x][i],tnext));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\n#define FOR(I, A, B) for (int I = int(A); I < int(B); ++I)\n\nconst int Q(2000010), N(6);\nconst int dir[8][2] = {{1, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\nint n, t, x, y, s;\nint q[Q], d[Q];\nchar str[N][N];\nset<int> ha;\n\nint state(int s, int x, int y) {\n    return s * 25 + x * 5 + y;\n}\nvoid add(int s, int _d) {\n    if (ha.count(s)) return;\n    d[t] = _d; q[t++] = s; ha.insert(s);\n}\nint p(int x, int y) {return x * n + y;}\nint bit(int x, int y) {\n    return (x >> y) & 1;\n}\nint cnt(int ss, int x, int y) {\n    int ret = 0;\n    FOR(i, 0, 8) {\n        int tx = x + dir[i][0], ty = y + dir[i][1];\n        if (tx == -1 || ty == -1 || tx == n || ty == n) continue;\n        ret += bit(ss, p(tx, ty));\n    }\n    return ret;\n}\nint bfs() {\n    if (s == 0) return 0;\n    FOR(h, 0, t) {\n        y = q[h] % 5; x = q[h] % 25 / 5; s = q[h] / 25;\n        FOR(i, 0, 8) {\n            int tx = x + dir[i][0], ty = y + dir[i][1];\n            if (tx == -1 || ty == -1 || tx == n || ty == n || bit(s, p(tx, ty))) continue;\n            int ss = s | (1 << p(tx, ty)), ts = 0;\n            FOR(j, 0, n)\n                FOR(k, 0, n) {\n                    int _cnt = cnt(ss, j, k);\n                    if (bit(ss, p(j, k)) == 0) {\n                        if (_cnt == 3) ts |= 1 << p(j, k);\n                    }\n                    else {\n                        if (_cnt == 2 || _cnt == 3) ts |= 1 << p(j, k);\n                    }\n                }\n            if (bit(ts, p(tx, ty))) ts -= 1 << p(tx, ty);\n            if (ts == 0) return d[h] + 1;\n            add(state(ts, tx, ty), d[h] + 1);\n        }\n    }\n    return -1;\n}\nint main() {\n    while (scanf(\"%d\", &n), n) {\n        ha.clear();\n        FOR(i, 0, n)\n            scanf(\"%s\", str[i]);\n        t = s = 0;\n        FOR(i, 0, n)\n            FOR(j, 0, n)\n                if (str[i][j] == '@') {\n                    x = i; y = j;\n                }\n                else if (str[i][j] == '#') s |= 1 << p(i, j);\n        add(state(s, x, y), 0);\n        printf(\"%d\\n\", bfs());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define INFECTED true\n#define UNINFECTED false\n\nint _n;\nclass state{\npublic:\n  bool m[5][5];\n  int x,y;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (x != a.x)return x < a.x;\n    else if ( y !=a.y)return y<a.y;\n    rep(i,_n)\n      rep(j,_n)if( m[i][j]!=a.m[i][j]==INFECTED)return INFECTED;\n    return false;\n  }\n};\n\n\nint dx[]={ 1,1,1,0,-1,-1,-1, 0};\nint dy[]={-1,0,1,1, 1, 0,-1,-1};\nchar m[5][5];\n\nbool sparse(int x,int y,state &now){\n  int cnt=0;\n  rep(i,8){\n    int nex=x+dx[i],ney=y+dy[i];\n    if (nex<0||ney<0||nex>=_n||ney>=_n)continue;\n    else if ( now.m[ney][nex]==INFECTED)cnt++;\n  }\n  if ( now.m[y][x]==INFECTED && (cnt==2||cnt==3))return INFECTED;\n  else if (now.m[y][x]==UNINFECTED && cnt == 3)return INFECTED;\n  return UNINFECTED;\n}\n\nbool  solved(state & now,int n){\n  rep(i,n)\n    rep(j,n)\n    if ( now.m[i][j]==INFECTED)return INFECTED;\n  return UNINFECTED;\n}\n\n\nint bfs(int n,state &ini){\n  set<state>  S;\n  queue<state> Q;\n  Q.push(ini);\n  S.insert(ini);\n  \n  while(!Q.empty()){\n    state now =Q.front();\n    Q.pop();\n    if ( solved(now,n)==UNINFECTED){\n      return now.cnt;\n    }\n  /*\n    rep(i,n){\n      rep(j,n)cout<< (now.m[i][j]==INFECTED?'#':'.');\n      cout << endl;\n    }\n    */\n\n    rep(i,8){\n      int nex=now.x+dx[i],ney=now.y+dy[i];\n      if (nex>=n||ney>=n||nex<0||ney<0||now.m[ney][nex]==INFECTED)continue;\n      state next=now;\n      next.x=nex;\n      next.y=ney;\n      next.cnt++;\n      now.m[ney][nex]=true;\n      rep(k,n){\n\trep(j,n){\n\t  next.m[k][j]=sparse(j,k,now);\n\t}\n      }\n      now.m[ney][nex]=false;\n      next.m[next.y][next.x]=UNINFECTED;\n      if (S.find(next)==S.end()){\n\tQ.push(next);\n\tS.insert(next);\n      }\n    }\n  }\n  return -1;\n}\n\n\nmain(){\n  int n;\n  state ini;\n  while(cin>>n && n){\n    _n=n;\n    ini.cnt=0;\n    rep(i,n){\n      cin>>m[i];\n      rep(j,n){\n\tif (m[i][j]=='@')ini.x=j,ini.y=i,m[i][j]='.';\n\tif ( m[i][j]=='#')ini.m[i][j]=INFECTED;\n\telse ini.m[i][j]=UNINFECTED;\n      }\n    }\n    cout << bfs(n,ini)<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<vector<char> > Area;\nstruct state{\n  Area a;\n  int c;\n};\nint N;\nArea A;\nset<Area> s;\n\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\n\nbool check( const Area &a ) {\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if( a[i][j] == '#' ) return false;\n    }\n  }\n  return true;\n}\n\nbool outc(int x,int y){\n  if( x < 0 || y < 0 || x >= N || y >= N ) return false;\n  return true;\n}\n\nvoid get(const Area &a, int &x,int &y){\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if( a[i][j] == '@' ){\n\tx = j; y  = i;\n\treturn;\n      }\n    }\n  }\n}\n\nArea next( const Area &a ){\n  Area b;\n  b.resize(N);\n  for(int i=0;i<N;i++){\n    b[i].resize(N);\n    for(int j=0;j<N;j++){\n      int cnt = 0;\n      for(int k=0;k<8;k++){\n\tint ni = i + dy[k], nj = j + dx[k];\n\tif( !outc(nj,ni) ) continue;\n\tif( a[ni][nj] == '#' || a[ni][nj] == '@' ) cnt++;\n      }\n      if( a[i][j] == '#' && (cnt == 2 || cnt == 3) ) b[i][j] = '#';\n      else if( a[i][j] == '.' && cnt == 3 ) b[i][j] = '#';\n      else if( a[i][j] == '@' ) b[i][j] = '@';\n      else b[i][j] = '.';\n    }\n  }\n  return b;\n}\n\nvoid view(const Area &a){\n  cout << \"view\" << endl;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      cout << a[i][j];\n    }\n    cout << endl;\n  }\n}\n\nint solve(Area a){\n  if( check(a) ) return 0;\n  queue<state> q;\n  q.push( (state){a,0} );\n  while( !q.empty() ){\n    state p = q.front(); q.pop();\n    int x,y;\n    get(p.a,x,y);\n    for(int i=0;i<8;i++){\n      int ny = y + dy[i], nx = x + dx[i];\n      if( !outc( ny,nx ) ) continue;\n      if( p.a[ny][nx] == '.' ){\n\tp.a[ny][nx] = '@';\n\tp.a[y][x] = '.';\n\tArea b = next(p.a);\n\tif( check(b) ) return p.c + 1;\n\tif( s.count(b) == 0 ){\n\t  q.push( (state){b,p.c+1} );\n\t  s.insert(b);\n\t}\n\tp.a[y][x] = '@';\n\tp.a[ny][nx] = '.';\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while( cin >> N && N ){\n    s.clear();\n   A.resize(N);\n    for(int i=0;i<N;i++){\n      A[i].resize(N);\n      for(int j=0;j<N;j++){\n\tcin >> A[i][j]; \n      }\n    }\n    cout <<  solve(A) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tchar table[5][6];\n\tshort row,col,step;\n};\n\nshort H,W;\nshort diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nmap<string,bool> MAP;\n\nbool rangeCheck(short row,short col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nstring makeString(Info info){\n\tstring ret;\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tret.append(to_string(info.table[row][col]));\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool is_cleard(Info info){\n\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tif(info.table[row][col] == '#')return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid copyInfo(Info& to,Info from){\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tto.table[row][col] = from.table[row][col];\n\t\t}\n\t}\n}\n\nvoid debug(Info info){\n\tfor(short row = 0;row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tprintf(\"%c\",info.table[row][col]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\\n\");\n}\n\nvoid func(){\n\n\tMAP.clear();\n\n\tInfo first;\n\tfor(short row = 0; row < H; row++){\n\t\tscanf(\"%s\",first.table[row]);\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tif(first.table[row][col] == '@'){\n\t\t\t\tfirst.row = row;\n\t\t\t\tfirst.col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tfirst.step = 0;\n\tMAP[makeString(first)] = true;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint adj_row,adj_col,calc_row,calc_col;\n\n\twhile(!Q.empty()){\n\n\t\t//debug(Q.front());\n\n\t\tif(is_cleard(Q.front())){\n\t\t\tprintf(\"%d\\n\",Q.front().step);\n\t\t\treturn;\n\t\t}\n\n\t\tfor(short i = 0; i < 8; i++){\n\t\t\tadj_row = Q.front().row + diff_row[i];\n\t\t\tadj_col = Q.front().col + diff_col[i];\n\n\t\t\tif(rangeCheck(adj_row,adj_col) == false || Q.front().table[adj_row][adj_col] == '#')continue;\n\n\t\t\tInfo next_info;\n\t\t\tcopyInfo(next_info,Q.front());\n\n\t\t\tnext_info.table[Q.front().row][Q.front().col] = '.';\n\t\t\tnext_info.table[adj_row][adj_col] = '@';\n\n\t\t\tfor(short row = 0; row < H; row++){\n\t\t\t\tfor(short col = 0; col < W; col++){\n\t\t\t\t\tif(Q.front().table[row][col] == '#'){\n\t\t\t\t\t\tint count = 0;\n\n\t\t\t\t\t\tfor(short a = 0; a < 8; a++){\n\t\t\t\t\t\t\tcalc_row = row + diff_row[a];\n\t\t\t\t\t\t\tcalc_col = col + diff_col[a];\n\n\t\t\t\t\t\t\tif(rangeCheck(calc_row,calc_col) == false)continue;\n\n\t\t\t\t\t\t\tif(Q.front().table[calc_row][calc_col] == '#' || next_info.table[calc_row][calc_col] == '@')count++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(count == 2 || count == 3){\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnext_info.table[row][col] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(next_info.table[row][col] == '.'){\n\n\t\t\t\t\t\tint count = 0;\n\n\t\t\t\t\t\tfor(short a = 0; a < 8; a++){\n\t\t\t\t\t\t\tcalc_row = row + diff_row[a];\n\t\t\t\t\t\t\tcalc_col = col + diff_col[a];\n\n\t\t\t\t\t\t\tif(rangeCheck(calc_row,calc_col) == false)continue;\n\n\t\t\t\t\t\t\tif(Q.front().table[calc_row][calc_col] == '#' || next_info.table[calc_row][calc_col] == '@')count++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(count == 3){\n\t\t\t\t\t\t\tnext_info.table[row][col] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring next_state = makeString(next_info);\n\n\t\t\tauto at = MAP.find(next_state);\n\n\t\t\tif(at != MAP.end())continue;\n\n\t\t\tMAP[next_state] = true;\n\n\t\t\tnext_info.step = Q.front().step+1;\n\t\t\tnext_info.row = adj_row;\n\t\t\tnext_info.col = adj_col;\n\n\t\t\tQ.push(next_info);\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&H);\n\t\tif(H == 0)break;\n\n\t\tW = H;\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tchar table[5][6];\n\tshort row,col,step;\n};\n\nshort H,W;\nshort diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nmap<string,bool> MAP;\n\nbool rangeCheck(short row,short col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nstring makeString(Info info){\n\tstring ret;\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tret.append(to_string(info.table[row][col]));\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool is_cleard(Info info){\n\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tif(info.table[row][col] == '#')return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid copyInfo(Info& to,Info from){\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tto.table[row][col] = from.table[row][col];\n\t\t}\n\t}\n}\n\nvoid debug(Info info){\n\tfor(short row = 0;row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tprintf(\"%c\",info.table[row][col]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\\n\");\n}\n\nvoid func(){\n\n\tMAP.clear();\n\n\tInfo first;\n\tfor(short row = 0; row < H; row++){\n\t\tscanf(\"%s\",first.table[row]);\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tif(first.table[row][col] == '@'){\n\t\t\t\tfirst.row = row;\n\t\t\t\tfirst.col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tfirst.step = 0;\n\tMAP[makeString(first)] = true;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint adj_row,adj_col,calc_row,calc_col;\n\n\twhile(!Q.empty()){\n\n\t\t//debug(Q.front());\n\n\t\tif(is_cleard(Q.front())){\n\t\t\tprintf(\"%d\\n\",Q.front().step);\n\t\t\treturn;\n\t\t}\n\n\t\tfor(short i = 0; i < 8; i++){\n\t\t\tadj_row = Q.front().row + diff_row[i];\n\t\t\tadj_col = Q.front().col + diff_col[i];\n\n\t\t\tif(rangeCheck(adj_row,adj_col) == false || Q.front().table[adj_row][adj_col] == '#')continue;\n\n\t\t\tInfo next_info;\n\t\t\tcopyInfo(next_info,Q.front());\n\n\t\t\tnext_info.table[Q.front().row][Q.front().col] = '.';\n\t\t\tnext_info.table[adj_row][adj_col] = '@';\n\n\t\t\tfor(short row = 0; row < H; row++){\n\t\t\t\tfor(short col = 0; col < W; col++){\n\t\t\t\t\tif(Q.front().table[row][col] == '#'){\n\t\t\t\t\t\tint count = 0;\n\n\t\t\t\t\t\tfor(short a = 0; a < 8; a++){\n\t\t\t\t\t\t\tcalc_row = row + diff_row[a];\n\t\t\t\t\t\t\tcalc_col = col + diff_col[a];\n\n\t\t\t\t\t\t\tif(rangeCheck(calc_row,calc_col) == false)continue;\n\n\t\t\t\t\t\t\tif(Q.front().table[calc_row][calc_col] == '#' || next_info.table[calc_row][calc_col] == '@')count++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(count == 2 || count == 3){\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnext_info.table[row][col] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(next_info.table[row][col] == '.'){\n\n\t\t\t\t\t\tint count = 0;\n\n\t\t\t\t\t\tfor(short a = 0; a < 8; a++){\n\t\t\t\t\t\t\tcalc_row = row + diff_row[a];\n\t\t\t\t\t\t\tcalc_col = col + diff_col[a];\n\n\t\t\t\t\t\t\tif(rangeCheck(calc_row,calc_col) == false)continue;\n\n\t\t\t\t\t\t\tif(Q.front().table[calc_row][calc_col] == '#' || next_info.table[calc_row][calc_col] == '@')count++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(count == 3){\n\t\t\t\t\t\t\tnext_info.table[row][col] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring next_state = makeString(next_info);\n\n\t\t\tauto at = MAP.find(next_state);\n\n\t\t\tif(at != MAP.end())continue;\n\n\t\t\tMAP[next_state] = true;\n\n\t\t\tnext_info.step = Q.front().step+1;\n\t\t\tnext_info.row = adj_row;\n\t\t\tnext_info.col = adj_col;\n\n\t\t\tQ.push(next_info);\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&H);\n\t\tif(H == 0)break;\n\n\t\tW = H;\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//AOJ 1304\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={-1,0,1,-1,1,-1,0,1};\n\nmap<LL, int> vsi;\nint n;\n\n//0: . 1: #\n\ninline int getx(LL a){return (a>>25 & 7);}\ninline int gety(LL a){return (a>>28 & 7);}\ninline int getidx(int x, int y){return y*n+x;}\ninline int getstate(LL a, int x, int y){return ((a>>getidx(x,y))&1);}\ninline LL setstate(LL a, int x, int y, int state){\n\tif(state){\n\t\treturn a|(1LL<<getidx(x,y));\n\t}else{\n\t\tLL p=1LL<<getidx(x,y);\n\t\tp = ~p;\n\t\treturn a&p;\n\t}\n}\ninline LL setpos(LL a, int x, int y){\n\tLL ret=a;\n\tret &= ((1LL<<25)-1);\n\tret |= ((LL)x)<<25;\n\tret |= ((LL)y)<<28;\n\treturn ret;\n}\n\ninline int count(LL b){\n\tint ret = 0;\n\tREP(i,n)REP(j,n)if(getstate(b,i,j))ret++;\n\treturn ret-1;\n}\n\nint step(LL &b){\n\tLL tb = b;\n\tint ret = 0;\n\tint x=getx(b);\n\tint y=gety(b);\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(y==i&&x==j)continue;\n\t\t\tint cnt = 0;\n\t\t\tREP(k,8){\n\t\t\t\tint ny=i+dy[k];\n\t\t\t\tint nx=j+dx[k];\n\t\t\t\tif(nx<0 || ny<0 || nx>=n || ny>=n)continue;\n\t\t\t\tif(getstate(tb,nx,ny))cnt++;\n\t\t\t}\n\t\t\tif(getstate(tb,j,i)){\n\t\t\t\tif(cnt!=2&&cnt!=3)b=setstate(b,j,i,0);\n\t\t\t}else if(!getstate(tb,j,i)){\n\t\t\t\tif(cnt==3)b=setstate(b,j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>n, n){\n\t\tvsi.clear();\n\t\tstring b;\n\t\tREP(i,n){\n\t\t\tstring tmp;\n\t\t\tcin>>tmp;\n\t\t\tb+=tmp;\n\t\t}\n\t\tLL is=0;\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tswitch(b[i*n+j]){\n\t\t\t\tcase '@':\n\t\t\t\t\tis = setpos(is, j, i);\n\t\t\t\tcase '#':\n\t\t\t\t\tis |= (1LL<<i*n+j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<int, LL>, vector<pair<int, LL> >, greater<pair<int, LL> > > q;\n\t\tq.push(MP(0,is));\n\t\tint ans=-1;\n\t\twhile(!q.empty()){\n\t\t\tint x,y;\n\t\t\tpair<int, LL> tmp=q.top();\n\t\t\tq.pop();\n\t\t\tif(EXIST(vsi,tmp.second))continue;\n\t\t\tvsi[tmp.second] = tmp.first;\n\t\t\tif(count(tmp.second)==0){\n\t\t\t\tans=tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = getx(tmp.second);\n\t\t\ty = gety(tmp.second);\n\t\t\tREP(i,8){\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(nx<0 || ny<0 || nx>=n || ny>=n || getstate(tmp.second, nx, ny)==1)continue;\n\t\t\t\tLL tb = tmp.second;\n\t\t\t\ttb=setstate(tb,x,y,0);\n\t\t\t\ttb=setstate(tb,nx,ny,1);\n\t\t\t\ttb=setpos(tb,nx,ny);\n\t\t\t\tstep(tb);\n\t\t\t\tif(EXIST(vsi,tb))continue;\n\t\t\t\tq.push(MP(tmp.first+1, tb));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\n\nint dy[]={-1,-1,-1,0,1,1,1,0};\nint dx[]={-1,0,1,1,1,0,-1,-1};\nstruct State{\n  vector<string> st;\n  State(int n):st(n){}\n\n  int in(int y,int x) const{\n    return 0<=y&&y<(int)st.size()&&0<=x&&x<(int)st[0].size();\n  }\n\n  State next() const{\n    State res(*this);\n\n    int n=st.size();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(st[i][j]=='@') continue;\n\n        int cnt=0;\n        for(int k=0;k<8;k++){\n          int ny=i+dy[k],nx=j+dx[k];\n          if(!in(ny,nx)) continue;\n          if(st[ny][nx]!='.') cnt++;\n        }\n\n        res.st[i][j]='.';\n        if(st[i][j]=='#'){\n          if(cnt==2) res.st[i][j]='#';\n          if(cnt==3) res.st[i][j]='#';\n        }\n        if(st[i][j]=='.'){\n          if(cnt==3) res.st[i][j]='#';\n        }\n      }\n    }\n    return res;\n  }\n\n  vector<State> move() const{\n    int n=st.size();\n    int y=-1,x=-1;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        if(st[i][j]=='@') y=i,x=j;\n\n    vector<State> adj;\n    for(int k=0;k<8;k++){\n      int ny=y+dy[k],nx=x+dx[k];\n      if(!in(ny,nx)) continue;\n      if(st[ny][nx]=='#') continue;\n      State res(*this);\n      swap(res.st[y][x],res.st[ny][nx]);\n      adj.emplace_back(res.next());\n    }\n    return adj;\n  }\n};\n\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    State init(n);\n    for(int i=0;i<n;i++) cin>>init.st[i];\n\n    map<vector<string>, int> dist;\n    queue<State> que;\n    dist[init.st]=0;\n    que.emplace(init);\n\n    int ans=-1;\n    while(!que.empty()){\n      auto v=que.front();que.pop();\n\n      int cnt=0;\n      for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n          if(v.st[i][j]=='#') cnt++;\n      if(cnt==0){\n        ans=dist[v.st];\n        break;\n      }\n\n      auto adj=v.move();\n      for(auto u:adj){\n        if(dist.count(u.st)) continue;\n        dist[u.st]=dist[v.st]+1;\n        que.emplace(u);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\ninline int calc_hash(const data &D){\n\tint res=(47*D.S+53)&((1<<26)-1);\n\tres=res*(59*D.x+61)&((1<<26)-1);\n\tres=res*(67*D.y+71)&((1<<26)-1);\n\treturn res;\n}\n\nint main(){\n\tfor(char T=1;scanf(\"%d\",&n),n;T++){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tstatic char vis[1<<26];\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tint hash=calc_hash(D);\n\t\t\tif(vis[hash]==T) continue;\n\t\t\tvis[hash]=T;\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n\nbool onmp(int x,int y){return x>=0&&y>=0&&x<n&&y<n;}\n\nbool check(const vector<string> &A){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(A[i][j]=='#')return 0;\n  return 1;\n}\n\nint count(int x,int y,const vector<string> &A){\n  int res=0;  \n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i,ny = y+j;\n      if((i||j)&&onmp(nx,ny))res += A[ny][nx]!='.';\n    }\n  return res;\n}\n\nvector<string> mkmp(const vector<string> &A){\n  vector<string> res=A;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cnt = count(j,i,A);\n      if(A[i][j]=='#')res[i][j]=(cnt==2||cnt==3)? '#':'.';\n      if(A[i][j]=='.')res[i][j]=(cnt==3)? '#':'.';\n      if(A[i][j]=='@')res[i][j]='@';\n    }\n  return res;\n}\n\n\nvoid getPos(vector<string>&A,int &x,int &y){\n  for(int i=0;i<n&&x==-1;i++)\n    for(int j=0;j<n&&x==-1;j++) if(A[i][j]=='@')x=j,y=i;\n}\n\n\n\nint bfs(vector<string>start){\n  queue<vector<string> > Q;\n  map<vector<string>,int>D;\n  Q.push(start);\n  D[start]=0;\n\n  while(!Q.empty()){\n    vector<string> A=Q.front();Q.pop();\n    int cost = D[A];\n    int x = -1,y=-1;\n    getPos(A,x,y);\n    if(check(A))return cost;\n    if(cost>=10)continue;\n\n    A[y][x] = '.';\n    for(int dy=-1;dy<=1;dy++)\n      for(int dx=-1;dx<=1;dx++){\n\tint nx = x+dx,ny = y+dy;\n\tif((!dx&&!dy)||!onmp(nx,ny)||A[ny][nx]=='#')continue;\n\tA[ny][nx] = '@';\n\tvector<string> nA = mkmp(A);\n\tif(!D.count(nA))Q.push(nA),D[nA] = cost+1;\n\tA[ny][nx] = '.';\n      }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>n,n){\n    vector<string> mp(n);\n    for(int i=0;i<n;i++)cin>>mp[i];\n    cout<<bfs(mp)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tset<data> Vis;\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tif(Vis.count(D)>0) continue;\n\t\t\tVis.insert(D);\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n\nbool onmp(int x,int y){return x>=0&&y>=0&&x<n&&y<n;}\n\nbool check(const vector<string> &A){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(A[i][j]=='#')return 0;\n  return 1;\n}\n\nint count(int x,int y,const vector<string> &A){\n  int res=0;  \n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i,ny = y+j;\n      if((i||j)&&onmp(nx,ny))res += A[ny][nx]!='.';\n    }\n  return res;\n}\n\nvector<string> mkmp(const vector<string> &A){\n  vector<string> res=A;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cnt = count(j,i,A);\n      if(A[i][j]=='#')res[i][j]=(cnt==2||cnt==3)? '#':'.';\n      if(A[i][j]=='.')res[i][j]=(cnt==3)? '#':'.';\n      if(A[i][j]=='@')res[i][j]='@';\n    }\n  return res;\n}\n\n\nvoid getPos(vector<string>&A,int &x,int &y){\n  for(int i=0;i<n&&x==-1;i++)\n    for(int j=0;j<n&&x==-1;j++) if(A[i][j]=='@')x=j,y=i;\n}\n\n\n\nint bfs(vector<string>start){\n  queue<vector<string> > Q;\n  map<vector<string>,int>D;\n  Q.push(start);\n  D[start]=0;\n\n  while(!Q.empty()){\n    vector<string> A=Q.front();Q.pop();\n    pr(A);\n    int cost = D[A];\n    int x = -1,y=-1;\n    getPos(A,x,y);\n    if(check(A))return cost;\n    if(cost>=10)continue;\n\n    A[y][x] = '.';\n    for(int dy=-1;dy<=1;dy++)\n      for(int dx=-1;dx<=1;dx++){\n\tint nx = x+dx,ny = y+dy;\n\tif((!dx&&!dy)||!onmp(nx,ny)||A[ny][nx]=='#')continue;\n\tA[ny][nx] = '@';\n\tvector<string> nA = mkmp(A);\n\tif(!D.count(nA))Q.push(nA),D[nA] = cost+1;\n\tA[ny][nx] = '.';\n      }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>n,n){\n    vector<string> mp(n);\n    for(int i=0;i<n;i++)cin>>mp[i];\n    cout<<bfs(mp)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing BIT=bitset<25>;\nstruct State{\n    int h,w;\n    BIT bit;\n    int t;\n};\nint solve(int n){\n    vector<string> f(n);\n    for(int i=0;i<n;i++) cin>>f[i];\n    State ini;\n    auto toIdx=[&](int i,int j){\n        return i*n+j;\n    };\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(f[i][j]=='@'){\n                ini.h=i,ini.w=j;\n                ini.t=0;\n            }           \n            if(f[i][j]=='#'){\n                ini.bit[toIdx(i,j)]=true;\n            }     \n        }\n    }\n    auto isRange=[&](int i,int j){\n        return 0<=i && i<n && 0<=j && j<n;\n    };\n    auto calcInfected=[&](int i,int j,const BIT& bit){\n        int cnt=0;\n        for(int di=-1;di<=1;di++){\n            for(int dj=-1;dj<=1;dj++){\n                if(di==0 && dj==0 || !isRange(i+di,j+dj) || !bit[toIdx(i+di,j+dj)]) continue;\n                cnt++;\n            }\n        }\n        return cnt;\n    };\n    queue<State> que;\n    que.push(ini);\n    set<tuple<int,int,int>> s;\n    while(!que.empty()){\n        State st=que.front(); que.pop();\n        if(st.bit==0) return st.t;\n        for(int di=-1;di<=1;di++) for(int dj=-1;dj<=1;dj++){\n            if(di==0 && dj==0) continue;\n            int toh=st.h+di,tow=st.w+dj;\n            if(!isRange(toh,tow) || st.bit[toIdx(toh,tow)]) continue;\n            st.bit[toIdx(toh,tow)]=true;\n            BIT tobit;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    int cnt=calcInfected(i,j,st.bit);\n                    tobit[toIdx(i,j)]=(st.bit[toIdx(i,j)] && 2<=cnt && cnt<=3) || (!st.bit[toIdx(i,j)] && cnt==3);\n                }\n            } \n            tobit[toIdx(toh,tow)]=false;\n            st.bit[toIdx(toh,tow)]=false;\n            State to;\n            to.h=toh,to.w=tow,to.t=st.t+1,to.bit=tobit;\n            if(!s.count(make_tuple(toh,tow,(int)(tobit.to_ulong())))){\n                s.insert(make_tuple(toh,tow,(int)(tobit.to_ulong())));\n                que.push(to);\n            }\n        }\n    }\n    return -1;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tset<data> Vis;\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tif(t>20) break;\n\n\t\t\tif(Vis.count(D)>0) continue;\n\t\t\tVis.insert(D);\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nstruct data{\n  uint x : 3;\n  uint y : 3;\n  uint b : 26;\n\n  inline data() : x(0), y(0), b(0) {}\n  inline data(uint xx, uint yy, uint bb) : x(xx), y(yy), b(bb) {}\n  inline operator bool () { return b != (1<<26) - 1; }\n  void printa(int n){\n    REP(i,n){\n      REP(j,n){\n        if(x == j && y == i) printf(\"@\");\n        else printf(\"%c\",((1<<(i*n+j))&b) ? '#' : '.');\n      }\n      puts(\"\");\n    }\n  }\n}__attribute__((packed));\n\ndata m = data(0,0,(1<<26)-1);\n\n#define print(x) printf(\"%d\\n\",x)\nconst int _dx[] = {-1,-1,-1,0,0,1,1,1};\nconst int _dy[] = {-1,0,1,-1,1,-1,0,1};\n\nint main(){\n  int n;\n  while(scanf(\"%d \",&n), n){\n    data init; init.b = 0;\n\n    REP(i,n){\n      char buff[10];\n      scanf(\"%s \",buff);\n      REP(j,n){\n        switch(buff[j]){\n        case '.': break;\n        case '#': init.b |= (1<<(i*n+j)); break;\n        case '@': init.x = j; init.y = i; break;\n        }\n      }\n    }\n\n    //    init.printa(n);\n\n    int ans = 0;\n    const int th = 11;\n    queue<data> q;\n    q.push(init); q.push(m);\n\n    while(q.size() != 1){\n      data d = q.front();\n      q.pop();\n\n      if(!d){\n        ans++;\n        q.push(m);\n        //printf(\"ans: %d\\n\",ans);\n        continue;\n      }\n\n      if(ans > th)\n        break;\n\n      if(d.b == 0){\n        print(ans);\n        break;\n      }\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n      REP(i,8){\n        int xx = (int)d.x + _dx[i];\n        int yy = (int)d.y + _dy[i];\n        if(ISIN(xx,yy,n,n) && (d.b & (1<<(yy*n+xx))) == 0){\n          data dd(xx,yy,0);\n          REP(y,n) REP(x,n) if(y != yy || x != xx){\n            int cnt = 0;\n            REP(j,8){\n              int xxx = x + _dx[j];\n              int yyy = y + _dy[j];\n              if(ISIN(xxx,yyy,n,n) && (d.b & (1<<(yyy*n+xxx))))\n                cnt++;\n              else if(xx == xxx && yy == yyy) cnt++;\n            }\n            if(d.b & (1<<(y*n+x))){\n              if(cnt == 2 || cnt == 3) dd.b |= (1<<(y*n+x));\n            }else{\n              if(cnt == 3) dd.b |= (1<<(y*n+x));\n            }\n          }\n          q.push(dd);\n        }\n      }\n\n    }\n\n    if(ans > th) print(-1);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        auto get = [&](int S, int y, int x) -> int {\n            return (S >> (y * n + x)) & 1;\n        };\n\n        int ST = 0;\n        REP(i, n) {\n            string s;\n            cin >> s;\n            REP(j, n) {\n                if (s[j] == '@') {\n                    ST |= (i * n + j) << (n * n);\n                }\n                if (s[j] == '#') {\n                    ST |= 1 << (i * n + j);\n                }\n            }\n        }\n        \n        int dy[8] = {-1, 0, 1, 0, -1, 1, 1, -1};\n        int dx[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n        auto next = [&](int s, int t) -> int {\n            int ret = 0;\n            REP(i, n) {\n                REP(j, n) {\n                    if (i * n + j == t) continue;\n\n                    int cnt = 0;\n                    REP(d, 8) {\n                        int ii = i + dy[d];\n                        int jj = j + dx[d];\n                        if (ii < 0 || ii >= n || jj < 0 || jj >= n) continue;\n                        cnt += get(s, ii, jj) | (ii * n + jj == t);\n                    }\n                    int nxt = 0;\n                    if (get(s, i, j)) {\n                        if (cnt == 2 || cnt == 3) {\n                            nxt = 1;\n                        }\n                    } else {\n                        if (cnt == 3) {\n                            nxt = 1;\n                        }\n                    }\n                    ret |= nxt << (i * n + j);\n                }\n            }\n            return ret;\n        };\n        \n        int ans = -1;\n        map<int, int> dist;\n        queue<int> q;\n        dist[ST] = 0;\n        q.push(ST);\n        while (!q.empty()) {\n            int st = q.front(); q.pop();\n            int s = st & ((1 << (n * n)) - 1), t = st >> (n * n);\n            int y = t / n;\n            int x = t % n;\n\n            if (s == 0) {\n                ans = dist[st];\n                break;\n            }\n\n            REP(dir, 8) {\n                int yy = y + dy[dir];\n                int xx = x + dx[dir];\n                if (yy < 0 || yy >= n || xx < 0 || xx >= n) continue;\n                if (get(s, yy, xx)) continue;\n                int nt = yy * n + xx;\n                int nst = (nt << (n * n)) | next(s, nt);\n                if (dist.find(nst) == dist.end()) {\n                    dist[nst] = dist[st] + 1;\n                    q.push(nst);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint n;\n\ntypedef tuple<int,int,int> T;\n\n\nbool getBit(int b, int y, int x){\n\treturn b >> (y * n + x) & 1;\n}\nvoid setBit(int& b, int y, int x){\n\tb |= 1 << (y * n + x);\n}\n\nmap<T, int> memo;\nint ans;\nvoid dfs(int bit, int y, int x, int t){\n\t//cout << bitset<9>(bit) <<' ' << y << ' ' << x << endl;\n\tif(t > ans) return;\n\tif(memo.count(T(bit, y, x)) and memo[T(bit, y, x)] <= t) return;\n\tmemo[T(bit, y, x)] = t;\n\n\tif(bit == 0){\n\t\t//show(t)\n\t\tans = min(ans, t);\n\t\treturn ;\n\t}\n\n\trep(vd, 8){\n\t\tint vy = y + dy[vd];\n\t\tint vx = x + dx[vd];\n\t\tif(getBit(bit, vy, vx)) continue;\n\t\tif(vy < 0 || vy >= n || vx < 0 || vx >= n) continue;\n\n\t\tint nxt = 0;\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(vy == i and vx == j) continue;\n\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(d,8){\n\t\t\t\t\tint ny = i + dy[d];\n\t\t\t\t\tint nx = j + dx[d];\n\t\t\t\t\tif(ny < 0 || ny >= n || nx < 0 || nx >= n) continue;\n\t\t\t\t\tif(getBit(bit, ny, nx)) cnt++;\n\t\t\t\t\tif(vy == ny and vx == nx) cnt++;\n\t\t\t\t}\n\n\t\t\t\tif((cnt == 2 or cnt == 3) and getBit(bit, i, j) == 1){\n\t\t\t\t\tsetBit(nxt, i, j);\n\t\t\t\t}else if(cnt == 3 and getBit(bit, i, j) == 0){\n\t\t\t\t\tsetBit(nxt, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(nxt, vy, vx, t + 1);\n\t}\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tint bit = 0, y, x;\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tchar a;\n\t\t\t\tcin >> a;\n\t\t\t\tif(a == '#'){\n\t\t\t\t\tsetBit(bit, i, j);\n\t\t\t\t}\n\t\t\t\tif(a == '@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tans = 11;\n\t\tmemo.clear();\n\t\t//show(bit)\n\t\tdfs(bit, y, x, 0);\n\t\tcout << (ans == 11 ? -1 : ans) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<vector<char> > b(n,vector<char>(n));\n    for(auto &e:b){\n      for(auto &f:e){\n\tcin>>f;\n      }\n    }\n    queue<int> qn;\n    qn.push(0);\n    queue<vector<vector<char> > > que;\n    que.push(b);\n    set<vector<vector<char> > > s;\n    while(!que.empty()){\n      int t=qn.front();\n      auto c=que.front();\n      bool v=false;\n      int x,y;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  v|=c[i][j]=='#';\n\t  if(c[i][j]=='@'){\n\t    y=i;\n\t    x=j;\n\t  }\n\t}\n      }\n      if(!v)break;\n      qn.pop();\n      que.pop();\n      if(!s.insert(c).second)continue;\n      for(int i=-1;i<=1;i++){\n\tfor(int j=-1;j<=1;j++){\n\t  if(i||j){\n\t    int ny=y+i;\n\t    int nx=x+j;\n\t    if(0<=ny&&ny<n&&0<=nx&&nx<n&&c[ny][nx]=='.'){\n\t      auto nb=c;\n\t      swap(nb[y][x],nb[ny][nx]);\n\t      auto nn=nb;\n\t      for(int k=0;k<n;k++){\n\t\tfor(int l=0;l<n;l++){\n\t\t  if(nn[k][l]!='@'){\n\t\t    int vc=0;\n\t\t    for(int m=-1;m<=1;m++){\n\t\t      for(int o=-1;o<=1;o++){\n\t\t\tif(m||o){\n\t\t\t  int nny=k+m;\n\t\t\t  int nnx=l+o;\n\t\t\t  vc+=0<=nny&&nny<n&&0<=nnx&&nnx<n&&nb[nny][nnx]!='.';\n\t\t\t}\n\t\t      }\n\t\t    }\n\t\t    nn[k][l]=(nb[k][l]=='#'&&(vc==2||vc==3)||nb[k][l]=='.'&&vc==3)?'#':'.';\n\t\t  }\n\t\t}\n\t      }\n\t      que.push(nn);\n\t      qn.push(t+1);\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<(que.empty()?-1:qn.front())<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\nint main(){\n\tfor(char T=1;scanf(\"%d\",&n),n;T++){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tstatic char vis[1<<24];\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tint hash=((D.S+1)*(D.x+1)*(D.y+1))&((1<<24)-1);\n\t\t\tif(vis[hash]==T) continue;\n\t\t\tvis[hash]=T;\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nstruct arr{\n    int w, x, y, z;\n}q[1000010], u;\nint T, n, m, x, y, l, r, res, cnt, nx, ny, sx, sy, nox, noy;\nint ans, dx[10], dy[10], f[7][7], c[7][7];\nbool flag;\nchar s[200];\nint main(int argc, const char * argv[])\n{\n    dx[0] = dx[1] = dx[2] = -1;\n    dx[5] = dx[6] = dx[7] = 1;\n    dy[0] = dy[3] = dy[5] = -1;\n    dy[2] = dy[4] = dy[7] = 1;\n    while (scanf(\"%d\", &n) != EOF)\n    {\n        if (!n) break;\n        cnt = 0, flag = 1;\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%s\", s);\n            for (int j = 0; j < n; j++)\n            {\n                if (s[j] == '#') cnt += 1 << (i * n + j), flag = 0;\n                if (s[j] == '@') cnt += 1 << (i * n + j), sx = i, sy = j;\n            }\n        }\n        if (flag)\n        {\n            printf(\"0\\n\");\n            continue;\n        }\n        l = r = 0;\n        q[++r].x = sx, q[r].y = sy, q[r].z = cnt, q[r].w = 0;\n        while (l < r)\n        {\n            u = q[++l];\n            memset(c, 0, sizeof(c));\n            cnt = 0;\n            for (int j = 1; j <= n; j++)\n                for (int k = 1; k <= n; k++)\n                    if (u.z & (1 << ((j - 1) * n + k - 1))) c[j][k] = 1, cnt++;\n            //printf(\"%d %d %d %d\\n\", u.w, u.x, u.y, u.z);\n            if (cnt == 1)\n            {\n                //printf(\"%d %d %d \", u.w, u.x, u.y);\n                printf(\"%d\\n\", u.w);\n                break;\n            }\n            for (int i = 0; i < 8; i++)\n            {\n                res = 0;\n                nx = u.x + dx[i], ny = u.y + dy[i];\n                if (nx < 0 || ny < 0 || nx == n || ny == n || c[nx + 1][ny + 1]) continue;\n                memset(f, 0, sizeof(f));\n                for (int j = 1; j <= n; j++)\n                    for (int k = 1; k <= n; k++)\n                        f[j][k] = c[j][k];\n                f[u.x + 1][u.y + 1] = 0;\n                f[nx + 1][ny + 1] = 1;\n                for (int j = 1; j <= n; j++)\n                    for (int k = 1; k <= n; k++)\n                    {\n                        if (j == nx + 1 && k == ny + 1)\n                        {\n                            res += 1 << ((j - 1) * n + k - 1);\n                            continue;\n                        }\n                        cnt = 0;\n                        for (int di = 0; di < 8; di++)\n                        {\n                            nox = j + dx[di], noy = k + dy[di];\n                            cnt += f[nox][noy];\n                        }\n                        if (cnt == 3) res += 1 << ((j - 1) * n + k - 1);\n                        if (cnt == 2 && f[j][k] == 1) res += 1 << ((j - 1) * n + k - 1);\n                    }\n                if (r <= 500000) q[++r].w = u.w + 1, q[r].x = nx, q[r].y = ny, q[r].z = res;\n            }\n        }\n        if (l >= 500000) printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unordered_set>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint N;\n\nconst int dx[] = {-1,0,1,0,-1,1,1,-1}, dy[] = {0,1,0,-1,-1,-1,1,1};\n\nstruct P {\n    int x, y;\n    int cnt;\n    vvb field;\n};\n\nint infect(vvb& field) {\n    vvb newfield(N, vb(N));\n    vvi adjacent(N, vi(N));\n    REP(y, N) REP(x, N) {\n        REP(i, 8) {\n            int sx = x + dx[i], sy = y + dy[i];\n            if (0 <= sx && sx < N && 0 <= sy && sy < N && field[sy][sx]) {\n                adjacent[y][x]++;\n            }\n        }\n    }\n    int infected = 0;\n    REP(y, N) REP(x, N) {\n        if (field[y][x] && (adjacent[y][x] == 2 || adjacent[y][x] == 3)) {\n            newfield[y][x] = true;\n            infected++;\n        } else if (!field[y][x] && adjacent[y][x] == 3) {\n            newfield[y][x] = true;\n            infected++;\n        } else {\n            newfield[y][x] = false;\n        }\n    }\n    field = newfield;\n    return infected;\n}\n\nint bitfield(const vvb& field) {\n    int bit = 0;\n    REP(y, N) REP(x, N) {\n        bit <<= 1;\n        bit |= field[y][x];\n    }\n\n    return bit;\n}\n\nint main() {\n    while (cin >> N, N) {\n        vvb field(N, vb(N));\n        int ix, iy;\n        int infected = 0;\n        REP(y, N) REP(x, N) {\n            char c;\n            cin >> c;\n            // @???infected?????????\n            field[y][x] = c != '.';\n            if (c == '@') {\n                ix = x;\n                iy = y;\n            }\n            if (c == '#') infected++;\n        }\n\n        unordered_set<int> G;\n        queue<P> que;\n\n        if (infected == 0) {\n            cout << 0 << endl;\n            goto END;\n        }\n        G.insert(bitfield(field));\n        que.push({ix, iy, 0, field});\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            REP(i, 8) {\n                int sx = p.x + dx[i], sy = p.y + dy[i];\n                if (0 <= sx && sx < N && 0 <= sy && sy < N && !p.field[sy][sx]) {\n                    vvb field = p.field;\n                    assert(field[p.y][p.x] && !field[sy][sx]);\n                    swap(field[p.y][p.x], field[sy][sx]);\n                    int infected = infect(field);\n                    int bit = bitfield(field);\n                    field[sy][sx] = true;\n                    if (!EXIST(G, bit)) {\n                        G.insert(bit);\n                        if (infected == 0) {\n                            cout << p.cnt+1 << endl;\n                            goto END;\n                        }\n                        que.push({sx, sy, p.cnt+1, field});\n                    }\n                }\n            }\n        }\n        cout << -1 << endl;\nEND: {}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nconst int INF = 1 << 29;\n\nvector<string> get_next_board(const vector<string> &board) {\n    int N = board.size();\n    vector<string> res(N, string(N, '.'));\n\n    // vector<string> sample = {\".....\", \"##.@.\", \"#....\", \"...#.\", \"##.##\"};\n    \n    for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n            int cnt = 0;            \n            for(int k=0; k<8; k++) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if(ni < 0 or ni >= N or nj < 0 or nj >= N) continue;\n                cnt += (board[ni][nj] == '#' or board[ni][nj] == '@');\n            }\n\n            /*\n            if(sample == board) {\n                fprintf(stderr, \"i = %d, j = %d, cnt = %d\\n\", i, j, cnt);\n            }\n            */\n\n            if(board[i][j] == '#') {\n                if(cnt == 2 or cnt == 3) res[i][j] = '#';\n                else res[i][j] = '.';\n            }\n            else if(board[i][j] == '@') {\n                res[i][j] = '@';\n            }\n            else {\n                if(cnt == 3) res[i][j] = '#';\n                else res[i][j] = '.';\n            }\n        }\n    }\n\n    /*\n    if(sample == board) {\n        for(int i=0; i<N; i++) {\n            cerr << \"# \" << res[i] << endl;\n        }\n        for(int i=0; i<N; i++) {\n            cerr << \"? \" << board[i] << endl;\n        }\n    }\n    */\n    return res;\n}\n\nint bfs(const vector<string> &board, int ax, int ay) {\n    map< vector<string>, int > state;\n    int N = board.size();\n    state[board] = 0;\n\n    queue< tuple< vector<string>, int, int> > que;\n    que.emplace(board, ax, ay);\n\n    int res = INF;\n    while(que.size()) {\n        vector<string> B; int x, y;\n        tie(B, x, y) = que.front(); que.pop();\n        int cost = state[B];\n        \n        int cnt = 0;\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                if(B[i][j] == '#') {\n                    cnt = 1;\n                    break;\n                }\n            }\n        }\n        if(cnt == 0) {\n            res = cost;\n            break;\n        }\n        \n        for(int k=0; k<8; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if(nx < 0 or nx >= N or ny < 0 or ny >= N) continue;\n            if(B[nx][ny] == '#') continue;\n            swap(B[x][y], B[nx][ny]);\n            vector<string> NB = get_next_board(B);\n            if(!state.count(NB)) {\n                state[NB] = cost + 1;\n                que.emplace(NB, nx, ny);\n            }\n            swap(B[x][y], B[nx][ny]);\n        }\n    }\n    return res;\n}\n\nint solve_testcase() {\n    int N; cin >> N;\n    if(N == 0) return 1;\n\n    vector<string> board(N);\n    int ax = -1, ay = -1;\n    for(int i=0; i<N; i++) {\n        cin >> board[i];\n        for(int j=0; j<N; j++) {\n            if(board[i][j] == '@') {\n                ax = i, ay = j;\n            }\n        }\n    }\n\n    int ans = bfs(board, ax, ay);\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\nstruct node{\n\tvs f;\n\tpii pos;\n\tnode(vs f,pii pos):f(f),pos(pos){}\n\tstring to_s() const{\n\t\tint n=f.size();\n\t\tstring ret; \n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tret+=pos.first==i&&pos.second==j?'@':f[i][j];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tbool operator<(const node &other)const{\n\t\treturn to_s()<other.to_s();\n\t}\n};\nint dy[]={-1,-1,-1,0,1,1,1,0};\nint dx[]={-1,0,1,1,1,0,-1,-1};\n\nvs change(vs &f,int y,int x){\n\tint n=f.size();\n\tvs nf(f);\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(y==i&&x==j)continue;\n\t\t\tint cnt=0;\n\t\t\tREP(d,8){\n\t\t\t\tint yy=i+dy[d];\n\t\t\t\tint xx=j+dx[d];\n\t\t\t\tif(yy>=0&&xx>=0&&yy<n&&xx<n){\n\t\t\t\t\tcnt+=f[yy][xx]=='#'||(y==yy&&x==xx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch(f[i][j]){\n\t\t\tcase '.':\n\t\t\t\tnf[i][j]=cnt==3?'#':'.';\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tnf[i][j]=(cnt==2||cnt==3?'#':'.');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t}\n\t}\n\treturn nf;\n}\n\nbool done(vs &f){\n\tint n=f.size();\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(f[i][j]=='#'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tvs f(N);\n\t\tpii p;\n\t\tREP(i,N){\n\t\t\tcin>>f[i];\n\t\t\tREP(j,N){\n\t\t\t\tif(f[i][j]=='@'){\n\t\t\t\t\tp=make_pair(i,j);\n\t\t\t\t\tf[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<node> q;\n\t\tmap<node,int> cost;\n\t\tq.push(node(f,p));\n\t\tcost[node(f,p)]=0;\n\t\tint ans=-1;\n\t\twhile(q.size()){\n\t\t\tnode n=q.front();q.pop();\n\t\t\tif(done(n.f)){\n\t\t\t\tans=cost[n];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(d,8){\n\t\t\t\tint y=n.pos.first+dy[d];\n\t\t\t\tint x=n.pos.second+dx[d];\n\t\t\t\tif(y>=0&&x>=0&&y<N&&x<N){\n\t\t\t\t\tif(n.f[y][x]=='.'){\n\t\t\t\t\t\tvs nf=change(n.f,y,x);\n\t\t\t\t\t\tnode nnode(nf,make_pair(y,x));\n\t\t\t\t\t\tif(!EXIST(cost,nnode)){\n\t\t\t\t\t\t\tcost[nnode]=cost[n]+1;\n\t\t\t\t\t\t\tq.push(nnode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dx[] = {1,1,0,-1,-1,-1,0,1};\nint dy[] = {0,1,1,1,0,-1,-1,-1};\n\nint N;\nint T[1<<25];\nint trans(int b, int p){\n  b |= 1<<p;\n  VVI cnt(N, VI(N));\n  REP(y,N) REP(x,N){\n\tint i = y*N + x;\n\tif(b>>i&1){\n\t  REP(d,8){\n\t\tint tx = x + dx[d];\n\t\tint ty = y + dy[d];\n\t\tif(0 <= tx && tx < N && 0 <= ty && ty < N)\n\t\t  cnt[ty][tx]++;\n\t  }\n\t}\n  }\n  int res = 0;\n  REP(y,N) REP(x,N){\n\tint i = y*N+x;\n\tif(p == i) continue;\n\tif(b>>i&1){\n\t  res |= (cnt[y][x]==2 || cnt[y][x]==3? 1 : 0) << i;\n\t}\n\telse{\n\t  res |= (cnt[y][x]==3? 1 : 0) << i;\n\t}\n  }\n  return res;\n}\n\nint solve(int b, int p){\n  queue<int> q;\n  map<int,int> dist;\n  q.push(b|(p<<25));\n  dist[b|(p<<25)] = 0;\n\n  while(!q.empty()){\n\tint bp = q.front();\n\tq.pop();\n\tint b = bp & ((1<<25)-1);\n\tif(b == 0){\n\t  return dist[bp];\n\t}\n\tint p = bp >> 25;\n\tint x = p % N, y = p / N;\n\tREP(d,8){\n\t  int tx = x + dx[d];\n\t  int ty = y + dy[d];\n\t  int np = ty*N + tx;\n\t  if(!(0 <= tx && tx < N && 0 <= ty && ty < N) || (b>>np&1)) continue;\n\t  int nb = trans(b, np);\n\t  int nbp = nb | (np<<25);\n\t  if(!dist.count(nbp)){\n\t\tdist[nbp] = dist[bp] + 1;\n\t\tq.push(nbp);\n\t  }\n\t}\n  }\n  return -1;\n}\n\nvoid print(int x){\n  REP(y,N){\n\tcout << bitset<3>(x&((1<<N)-1)) << endl;\n\tx >>= N;\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N,N){\n\tint b = 0, p = 0;\n\tREP(y,N){\n\t  string s;\n\t  cin >> s;\n\t  REP(x,N)\n\t\tif(s[x] == '@')\n\t\t  p = y*N+x;\n\t\telse if(s[x] == '#')\n\t\t  b |= 1 << (y*N+x);\n\t}\n\n\tint res = solve(b, p);\n\tcout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<string,int>P;\n\nint dy[]={-1,-1,0,1,1,1,0,-1};\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint n;\nstring s,t;\nset<string>st;\n\n\nbool CNT(string &S){\n  r(i,n*n)if(S[i]=='#')return 0;\n  return 1;\n}\n\nvoid solve(){\n  st.insert(s);\n  queue<P>q;\n  q.push(P(s,0));\n  while(!q.empty()){\n    s=q.front().first;\n    int cost=q.front().second;q.pop();\n    if(CNT(s)){\n      cout<<cost<<endl;\n      return;\n    }\n    string a[n],b[n];\n    r(i,n)a[i]=b[i]=s.substr(i*n,n);\n    r(i,n)r(j,n)if(a[i][j]=='@'){\n      r(k,8){\n        a[i][j]='.';\n        int y=i+dy[k];\n        int x=j+dx[k];\n        if(y<0||x<0||y>=n||x>=n)continue;\n        if(a[y][x]=='#')continue;\n        a[y][x]='@';\n        r(i1,n)r(j1,n)if(!(i1==y&&j1==x)){\n          int sum=0;\n          r(k1,8){\n            int ny=i1+dy[k1];\n            int nx=j1+dx[k1];\n            if(ny<0||nx<0||ny>=n||nx>=n)continue;\n            if(b[ny][nx]=='#'||a[ny][nx]=='@')sum++;\n          }\n          if((b[i1][j1]!='#')&&sum==3)a[i1][j1]='#';\n          if((b[i1][j1]=='#')&&!(sum==3||sum==2))a[i1][j1]='.';\n        }\n        t=\"\";\n        r(q,n)t+=a[q];\n        if(!st.count(t)){\n          st.insert(t);\n          q.push(P(t,cost+1));\n        }\n        r(q,n)a[q]=b[q];\n      }\n      a[i][j]='@';\n    }\n  }\n  cout<<-1<<endl;\n}\n\nsigned main(){\n  while(cin>>n,n){\n    st.clear();\n    s=\"\";\n    r(i,n){\n      cin>>t;\n      s+=t;\n    }\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<cassert>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint dx[8] = {0, 1, 0, -1, -1, -1, 1, 1};\nint dy[8] = {1, 0, -1, 0, -1, 1, 1, -1};\nint n;\n\ninline char atc(string s,int i,int j) { return s.at(i*n+j); }\n\nbool iseliminate(string mp) {\n    int i,j;\n    rep(i,mp.length()) if(mp[i] == '#') return false;\n    return true;\n}\n\npair<int,int> getPos(string mp) {\n    int i,j;\n    rep(i,mp.length()) if(mp[i] == '@') return make_pair(i/n,i%n);\n}\n\n\nstring update(string &mp) {\n    int i,j,k;\n    string tmp = mp;\n\n    rep(i,n) rep(j,n) {\n        int adj = 0;\n        if(mp.at(i*n+j) == '@') continue;\n        rep(k,8) {\n            if(i+dy[k] < 0 || i+dy[k] >= n) continue;\n            if(j+dx[k] < 0 || j+dx[k] >= n) continue;\n            if(mp.at((i+dy[k])*n+(j+dx[k])) == '#'\n               || mp.at((i+dy[k])*n+(j+dx[k])) == '@') adj++;\n        }\n        if(mp.at(i*n+j) == '#') {\n            if(adj == 2 || adj == 3) continue;\n            else tmp.at(i*n+j) = '.';\n            //cout<<\"eliminated !!\"<<endl;\n        }else{\n            if(adj == 3) tmp.at(i*n+j) = '#';\n        }\n    }\n    return tmp;\n}\n\nint bfs(string bmap) {\n    int i,j;\n    queue<pair<int,string > >Q;\n    set<string> memo;\n    memo.insert(bmap);\n    Q.push(make_pair(0,bmap));\n    while(!Q.empty()) {\n        string nmap = Q.front().second;\n        int ii = Q.front().first;\n        Q.pop();\n\n\n        // cout<<ii<<endl;\n        // rep(i,n) cout<<nmap.substr(i*n,n)<<endl;\n        // cout<<endl;\n\n        if(iseliminate(nmap)) return ii;\n\n        pair<int,int> pos = getPos(nmap);\n        for(int i=0; i<8; ++i) {\n            if(pos.first+dy[i] < 0 || pos.first+dy[i] >= n) continue;\n            if(pos.second+dx[i] < 0 || pos.second+dx[i] >= n) continue;\n            if(nmap.at((pos.first+dy[i])*n+(pos.second+dx[i])) == '#') continue;\n            string next = string(nmap);\n            next.at((pos.first+dy[i])*n+pos.second+dx[i]) = '@';\n            next.at((pos.first)*n+pos.second) = '.';\n            next = update(next);\n            if(memo.find(next) != memo.end()) continue;\n            memo.insert(next);\n            Q.push(make_pair(ii+1, next));\n        }\n    }\n    return -1;\n    assert(false);\n}\n\nint main() {\n    while(cin>>n, n) {\n        string imap = \"\",tmp;\n        for(int i=0; i<n; ++i) {\n            cin>>tmp;\n            imap += tmp;\n        }\n        cout<<bfs(imap)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<cassert>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint dx[8] = {0, 1, 0, -1, -1, -1, 1, 1};\nint dy[8] = {1, 0, -1, 0, -1, 1, 1, -1};\nint n;\n\nstruct State{\n    string mp;\n    int turn,x,y;\n    State(string mp,int turn,int x,int y) : mp(mp), turn(turn), x(x), y(y) {;}\n};\n\npair<int,int> getPos(string mp) {\n    int i,j;\n    rep(i,mp.length()) if(mp[i] == '@') return make_pair(i/n,i%n);\n}\n\n\nstring update(string &mp) {\n    int i,j,k;\n    string tmp = mp;\n\n    rep(i,n) rep(j,n) {\n        int adj = 0;\n        if(mp.at(i*n+j) == '@') continue;\n        rep(k,8) {\n            if(i+dy[k] < 0 || i+dy[k] >= n) continue;\n            if(j+dx[k] < 0 || j+dx[k] >= n) continue;\n            if(mp.at((i+dy[k])*n+(j+dx[k])) == '#'\n               || mp.at((i+dy[k])*n+(j+dx[k])) == '@') adj++;\n        }\n        if(mp.at(i*n+j) == '#') {\n            if(adj == 2 || adj == 3) continue;\n            else tmp.at(i*n+j) = '.';\n        }else{\n            if(adj == 3) tmp.at(i*n+j) = '#';\n        }\n    }\n    return tmp;\n}\n\nint bfs(string bmap,int y,int x) {\n    int i,j;\n    queue<State> Q;\n    set<string> memo;\n    memo.insert(bmap);\n    Q.push(State(bmap,0,x,y));\n    while(!Q.empty()) {\n        State now = Q.front();\n        string nmap = now.mp;\n        int ii = now.turn;\n        Q.pop();\n\n        if(nmap.find(\"#\") == string::npos) return ii;\n\n        for(int i=0; i<8; ++i) {\n            if(now.y+dy[i] < 0 || now.y+dy[i] >= n) continue;\n            if(now.x+dx[i] < 0 || now.x+dx[i] >= n) continue;\n            if(nmap.at((now.y+dy[i])*n+(now.x+dx[i])) == '#') continue;\n            string next = string(nmap);\n            next.at((now.y+dy[i])*n+now.x+dx[i]) = '@';\n            next.at((now.y)*n+now.x) = '.';\n            next = update(next);\n            if(memo.find(next) != memo.end()) continue;\n            memo.insert(next);\n            Q.push(State(next,ii+1,now.x+dx[i],now.y+dy[i]));\n        }\n    }\n    return -1;\n    assert(false);\n}\n\nint main() {\n    while(cin>>n, n) {\n        string imap = \"\",tmp;\n        for(int i=0; i<n; ++i) {\n            cin>>tmp;\n            imap += tmp;\n        }\n        cout<<bfs(imap,getPos(imap).first,getPos(imap).second)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define wh while\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define REP(i,n) for(int i = 1; i <= n; i++)\n#define sf scanf\n#define pf printf\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define clr(abc,z) memset(abc,z,sizeof(abc))\n\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nmap<int, bool> mp;\nint n, st, state, ans;\nint dx[] = {1, 1, 1, -1, -1, -1, 0, 0};\nint dy[] = {1, 0, -1, 1, 0, -1, 1, -1};\nbool isOK(int x, int y){\n    if(x >= 0 && x < n && y >= 0 && y < n) return true;\n    return false;\n}\n\nbool isInfected(int state, int loc){\n    int cnt = 0;\n    int cx = loc / n, cy = loc % n;\n    FOR(j, 8){\n        int ncx = (cx + dx[j]), ncy = (cy + dy[j]);\n        if(!isOK(ncx, ncy)) continue;\n        if(state & (1 << (ncx * n + ncy)))\n        cnt++;\n    }\n    if(cnt == 2 || cnt == 3) return true;\n    return false;\n}\nbool notInfected(int state, int loc){\n    int cnt = 0;\n    int cx = loc / n, cy = loc % n;\n    FOR(j, 8){\n        int ncx = (cx + dx[j]), ncy = (cy + dy[j]);\n        if(!isOK(ncx, ncy)) continue;\n        if(state & (1 << (ncx * n + ncy)))\n        cnt++;\n    }\n    if(cnt == 3) return true;\n    return false;\n}\n\nstruct NODE{\n    int state, loc, step;\n};\nvoid bfs(int cst, int cstate){\n    queue<NODE> Q;\n    wh(!Q.empty()) Q.pop();\n    NODE a; a.loc = st, a.state = state, a.step = 0; Q.push(a);\n    wh(!Q.empty()){\n        NODE now = Q.front(); Q.pop();\n        if(now.state == 0){\n            ans = now.step; break;\n        }\n        if(mp[(now.state << 5) + now.loc]) continue;\n        mp[(now.state << 5) + now.loc] = true;\n        int cx = now.loc / n, cy = now.loc % n;\n        FOR(i, 8){\n            int ncx = cx + dx[i], ncy = cy + dy[i];\n            if(!isOK(ncx, ncy)) continue;\n            int nloc = 1 << (ncx * n + ncy);\n            if(nloc & now.state) continue;\n            int curstate = now.state | nloc;\n            int cur = now.state;\n            FOR(j, n * n)\n                if(!(curstate & (1 << j)) && notInfected(curstate, j))\n                    cur |= (1 << j);\n            FOR(j, n * n)\n                if((now.state & (1 << j)) && !isInfected(curstate, j))\n                    cur ^= (1 << j);\n            NODE node; node.step = now.step + 1; node.loc = ncx * n + ncy; node.state = cur;\n            Q.push(node);\n        }\n    }\n}\n\nint main() {\n    wh(sf(\"%d\", &n) != EOF){\n        state = 0; ans = -1;\n        mp.clear();\n        FOR(i, n){\n            char tmp[6]; sf(\"%s\", tmp);\n            FOR(j, n){\n                if(tmp[j] == '@')\n                    st = i * n + j;\n                else if(tmp[j] == '#')\n                    state |= 1 << (i * n + j);\n            }\n        }\n        bfs(st, state);\n        pf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<queue>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nchar board[6][6],ma[6][6],tmap[6][6];\nint mov[8][2] = {1,0,1,-1,0,-1,-1,-1,-1,0,-1,1,0,1,1,1};\nint mark[200];\nint n;\nset<int> ss;\nstruct status\n{\n    int x,y;\n    int ord;\n    int te;\n    status(int a,int b,int c){x = a, y= b, ord = c;}\n};\npair < int,int > s;\n\nint encode(char (*a)[6])\n{\n    int bb=0;\n    int va = 1;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            bb += mark[a[i][j]]*(va);\n            va *= 2;\n        }\n    }\n    return bb;\n}\n\nvoid decode(int p,int x,int y)\n{\n    int cnt = 0;\n    while(cnt != n*n)\n    {\n        int t = p%2;\n        ma[cnt/n][cnt%n] = t==1?'#':'.';\n        p /= 2;\n        cnt++;\n    }\n    ma[x][y] ='@';\n}\n\nvoid printt()\n{\n    printf(\"-------\\n\");\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            printf(\"%c \",tmap[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"-------\\n\");\n}\n\nvoid construct(int s,int e,int ss,int ee)\n{\n    memcpy(tmap,ma,sizeof(tmap));\n    char newmap[6][6];\n    swap(tmap[s][e],tmap[ss][ee]);\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            int cnt = 0;\n            for(int k=0;k<8;k++)\n            {\n                int tx = i + mov[k][0] , ty = j + mov[k][1];\n                if(tx >= 0 && ty >= 0 && tx < n && ty < n && (tmap[tx][ty]=='#' || tmap[tx][ty]=='@'))\n                    cnt++;\n            }\n            if(tmap[i][j] == '.')\n            {\n                if(cnt == 3) newmap[i][j] = '#';\n                else newmap[i][j] = tmap[i][j];\n            }\n            else if(tmap[i][j] == '#')\n            {\n                if(cnt == 3 || cnt == 2) newmap[i][j]='#';\n                else newmap[i][j] = '.';\n            }\n            else newmap[i][j] = tmap[i][j];\n        }\n    }\n    memcpy(tmap,newmap,sizeof(tmap));\n}\n\nvoid print(int x,int y)\n{\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            printf(\"%c \",ma[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint bfs()\n{\n     struct status fir(s.first,s.second,0);\n     fir.te = encode(board);\n     queue <struct status> q;\n     q.push(fir);\n     int flag = -1;\n\n     while(!q.empty())\n     {\n         struct status vi = q.front();\n         decode(vi.te,vi.x,vi.y);\n         //print(vi.x,vi.y);\n         q.pop();\n         if(!vi.te) flag = vi.ord;\n         if(vi.ord > 10) break;\n         if(flag == -1)\n         {\n             for(int i=0;i<8;i++)\n             {\n                 int tx = vi.x + mov[i][0],ty = vi.y + mov[i][1];\n                 if(tx >= 0 && ty >= 0 && tx < n && ty < n && ma[tx][ty]!='#')\n                 {\n                     construct(vi.x,vi.y,tx,ty);\n                     struct status newt(tx,ty,vi.ord+1);\n                     newt.te = encode(tmap);\n                     //if(ss.count(newt.te)) flag = -1;\n                     //else ss.insert(newt.te);\n                     q.push(newt);\n                 }\n             }\n         }\n         else break;\n     }\n     return flag;\n}\n\nint main()\n{\n    mark['#'] = 1, mark['.'] = 0, mark['@'] = 0;\n    while(~scanf(\"%d\",&n),n)\n    {\n        ss.clear();\n        getchar();\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                scanf(\"%c\",&board[i][j]);\n                if(board[i][j] == '@') s = make_pair(i,j);\n            }\n            getchar();\n        }\n        printf(\"%d\\n\",bfs());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <map>\nusing namespace std;\nstruct List{\n\tchar s[30];\n};\nstruct List list;\nstruct comp{\n\tbool operator() (const List& a, const List& b) const{\n\t\tif(strcmp(a.s,b.s)<0)\treturn true;\n\t\treturn false;\n\t}\n};\n\nmap <List,int,comp> MAP;\nint op[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}},M[10][10],ini[10][10],N,MAX;\n\nbool dfs(int level);\n\nmain()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\t\n\tint n,i,j,stx,sty,ans,tmpx,tmpy,all,t;\n\tchar ss[10];\n\twhile(scanf(\" %d\",&N)==1 && N){\n\t\tgets(ss);\n\t\tmemset(ini,0,sizeof(ini));\n\t\tfor(n=0;n<N;n++){\n\t\t\tgets(ss);\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tif(ss[i]=='@')\n\t\t\t\t\tini[n][i] = 2;\n\t\t\t\telse if(ss[i]=='#')\n\t\t\t\t\tini[n][i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(MAX=all=0;MAX<=50;MAX++){\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tfor(j=0;j<N;j++)\n\t\t\t\t\tM[i][j] = ini[i][j];\n\t\t\tMAP.clear();\n\t\t\tif(dfs(0)){\n\t\t\t\tall = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(all==2)\n\t\t\tprintf(\"%d\\n\",MAX);\n\t\telse\n\t\t\tprintf(\"-1\\n\");\n\t}\n}\nbool dfs(int level)\n{\n\tint i,j,stx,sty,tmpx,tmpy,all,t,next[10][10],x,y,k;\n\tif(level>MAX)\n\t\treturn false;\n\tfor(i=0;i<30;i++)\n\t\tlist.s[i] = '\\0';\n\tfor(i=all=k=0;i<N;i++){\n\t\tfor(j=0;j<N;j++){\n\t\t\tif(M[i][j]==1){\n\t\t\t\tlist.s[k++] = '#';\n\t\t\t\tall++;\n\t\t\t}\n\t\t\telse if(M[i][j]==2){\n\t\t\t\tstx = i;\n\t\t\t\tsty = j;\n\t\t\t\tlist.s[k++] = '@';\n\t\t\t}\n\t\t\telse\n\t\t\t\tlist.s[k++] = '.';\n\t\t}\n\t}\n\tlist.s[k++] = level;\n\tif(all==0)\n\t\treturn true;\n\tif(MAP.find(list)!=MAP.end())\n\t\treturn false;\n\tMAP[list] = 1;\n\tfor(i=0;i<N;i++)\n\t\tfor(j=0;j<N;j++)\n\t\t\tnext[i][j] = M[i][j];\n\tfor(t=0;t<8;t++){\n\t\ttmpx = stx+op[t][0];\n\t\ttmpy = sty+op[t][1];\n\t\tif(tmpx<0 || tmpx>=N || tmpy<0 || tmpy>=N)\n\t\t\tcontinue;\n\t\tif(next[tmpx][tmpy]==1)\n\t\t\tcontinue;\n\t\tnext[tmpx][tmpy] = 2;\n\t\tnext[stx][sty] = 0;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<N;j++){\n\t\t\t\tif(next[i][j]==2)\n\t\t\t\t\tM[i][j] = 2;\n\t\t\t\telse{\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tfor(k=0;k<8;k++){\n\t\t\t\t\t\tx = i+op[k][0];\n\t\t\t\t\t\ty = j+op[k][1];\n\t\t\t\t\t\tif(x<0 || x>=N || y<0 || y>=N)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(next[x][y]!=0)\n\t\t\t\t\t\t\ttmp++;\n\t\t\t\t\t}\n\t\t\t\t\tif(next[i][j]==1){\n\t\t\t\t\t\tif(tmp==2 || tmp==3)\n\t\t\t\t\t\t\tM[i][j] = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tM[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(tmp==3)\n\t\t\t\t\t\t\tM[i][j] = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tM[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dfs(level+1))\n\t\t\treturn true;\n\t\tnext[tmpx][tmpy] = 0;\n\t\tnext[stx][sty] = 2;\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n\nbool onmp(int x,int y){return x>=0&&y>=0&&x<n&&y<n;}\n\nint count(int x,int y,const vector<string> &A){\n  int res=0;  \n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i,ny = y+j;\n      if((!i&&!j)||!onmp(nx,ny))continue;\n      res += A[ny][nx]=='#'||A[ny][nx]=='@';\n    }\n  return res;\n}\n\nbool check(const vector<string> &A){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(A[i][j]=='#')return 0;\n  return 1;\n}\n\n\nvector<string> mkmp(const vector<string> &A){\n  vector<string> res(n,string(n,'.'));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cnt = count(j,i,A);\n      if(A[i][j]=='#')res[i][j]=(cnt==2||cnt==3)? '#':'.';\n      if(A[i][j]=='.')res[i][j]=(cnt==3)? '#':'.';\n      if(A[i][j]=='@')res[i][j]='@';\n    }\n  return res;\n}\n\n\nmap<vector<string>,int> mem;\nint ans;\nvoid dfs(int x,int y,int cnt,vector<string> A){\n  if(check(A))ans=min(cnt,ans);\n  if(cnt>=ans) return;\n  //if(mem.count(A)&&mem[A]<=cnt)return;\n  //mem[A]=cnt;\n  A[y][x] = '.';\n  for(int dy=-1;dy<=1;dy++){\n    for(int dx=-1;dx<=1;dx++){\n      int nx = x+dx,ny = y+dy;\n      if((!dx&&!dy)||!onmp(nx,ny)||A[ny][nx]=='#')continue;\n      A[ny][nx] = '@';\n      dfs(nx,ny,cnt+1,mkmp(A));\n      A[ny][nx] = '.';\n    }\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    vector<string> mp(n);\n    for(int i=0;i<n;i++)cin>>mp[i];\n    int sx,sy;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)if(mp[i][j]=='@')sy=i,sx=j;\n    mem.clear();\n    ans = 15;\n    dfs(sx,sy,0,mp);\n    cout<<(ans<15? ans:-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint n;\n\nint dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nmap<string, int> mp;\n\nbool in(int x, int y) {\n  return 0 <= x && x < n && 0 <= y && y < n;\n}\n\nbool isinfe(int x, int y, string s) {\n  int cnt = 0;\n  rep(i, 8) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!in(nx, ny)) continue;\n    if(s[nx+ny*n] == '#') cnt++;\n    else if(s[nx+ny*n] == '@') cnt++;\n  }\n  //cout<<x<<\" \"<<y<< \" \"<<cnt<<endl;\n  if(s[x+y*n] == '.') return cnt == 3;\n  else if(s[x+y*n] == '#') return cnt == 2 || cnt == 3;\n  assert(false);\n}\n\nstring infect(string s) {\n  string t = \"\";\n  rep(i, s.size()) {\n    if(s[i] == '@') t += '@';\n    else if(isinfe(i%n, i/n, s)) t += '#';\n    else t += '.';\n  }\n  return t;\n}\n\nbool check(string s) {\n  //cout<<s<<endl;\n  rep(i, s.size()) if(s[i] == '#') return false;\n  return true;\n}\n\nint findvehi(string s) {\n  rep(i, s.size()) if(s[i] == '@') return i;\n  assert(false);\n}\n\nint bfs(string s) {\n  mp.clear();\n  queue<string> que;\n  mp[s] = 0;\n  que.push(s);\n  while(!que.empty()) {\n    string t = que.front(); que.pop();\n    if(check(t)) return mp[t];\n    int idx = findvehi(t);\n    int x = idx%n, y = idx/n;\n    rep(i, 8) {\n      string u = t;\n      int nx = x + dx[i], ny = y + dy[i];\n      int ni = nx+ny*n;\n      if(!in(nx, ny)) continue;\n      if(u[ni] != '.') continue;\n      u[idx] = '.';\n      u[ni] = '@';\n      u = infect(u);\n      if(mp.count(u)) continue;\n      mp[u] = mp[t] + 1;\n      que.push(u);\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n, n) {\n    string s = \"\";\n    rep(i, n) {\n      string t;\n      cin >> t;\n      s += t;\n    }\n    cout << bfs(s) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 };\nint dy[8] = { 1,0,-1,-1,-1,0,1,1 };\n\nint n;\nmap<P, bool> used;\n//map<P, int> memo;\nchar mp[5][5];\n\nvector<P> nexc(int loc, int s) {\n\t//cout << loc << \" \" << s << endl;\n\t//if (s == 0)return 0;\n\tvector<P> ret;\n\t//if (used[{loc, s}])return memo[{loc, s}];\n\t//used[{loc, s}] = true;\n\tvector<vector<bool>> g(n);\n\trep(i, n) {\n\t\tg[i].resize(n);\n\t\trep(j, n) {\n\t\t\tint z = i * n + j;\n\t\t\tif (s&(1 << z))g[i][j] = true;\n\t\t\telse g[i][j] = false;\n\t\t}\n\t}\n\tint x = loc / n, y = loc % n;\n\trep(k, 8) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif (nx < 0 || ny < 0 || nx >= n || ny >= n)continue;\n\t\tif (g[nx][ny])continue;\n\t\tint nloc = nx * n + ny;\n\t\tint nex = 0;\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tint z = i * n + j;\n\t\t\t\tif (z == nloc)continue;\n\t\t\t\t\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(l, 8) {\n\t\t\t\t\tint sx = i + dx[l], sy = j + dy[l];\n\t\t\t\t\tif (sx < 0 || sy < 0 || sx >= n || sy >= n)continue;\n\t\t\t\t\tif (g[sx][sy]||sx*n+sy==nloc)cnt++;\n\t\t\t\t}\n\t\t\t\tif (g[i][j]) {\n\t\t\t\t\tif (cnt == 3 || cnt == 2)nex += (1 << z);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (cnt == 3)nex += (1 << z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!used[{nloc, nex}]) {\n\t\t\tused[{nloc, nex}] = true;\n\t\t\tret.push_back({ nloc,nex });\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tused.clear(); \n\t//memo.clear();\n\tint s = 0;\n\tint x = 0;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tcin >> mp[i][j];\n\t\t\tint z = i * n + j;\n\t\t\tif (mp[i][j] == '#') {\n\t\t\t\ts += (1 << z);\n\t\t\t}\n\t\t\telse if (mp[i][j] == '@') {\n\t\t\t\tx = z;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<P> q; q.push({ x,s }); used[{x, s}] = true;\n\tint tmp = 0;\n\twhile (!q.empty()) {\n\t\tint len = q.size();\n\t\trep(aa, len) {\n\t\t\tP p = q.front(); q.pop();\n\t\t\tx = p.first, s = p.second;\n\t\t\tif (s == 0) {\n\t\t\t\tcout << tmp << endl; return;\n\t\t\t}\n\t\t\tvector<P> c = nexc(x, s);\n\t\t\trep(i, c.size())q.push(c[i]);\n\t\t}\n\t\ttmp++;\n\t}\n\tcout << -1 << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile (cin >> n, n) {\n\t\tsolve();\n\t}\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint n;\n\ntypedef tuple<int,int,int> T;\n\n\nbool getBit(int b, int y, int x){\n\treturn b >> (y * n + x) & 1;\n}\nvoid setBit(int& b, int y, int x){\n\tb |= 1 << (y * n + x);\n}\n\nint bfs(int bit, int sy, int sx){\n\tmap<T, int> memo;\n\n\tqueue<T> q;\n\tq.emplace(bit, sy, sx);\n\n\twhile(not q.empty()){\n\t\tint s, y, x;\n\t\ttie(s, y, x) = q.front(); q.pop();\n\n\t\tif(s == 0) return memo[T(s, y, x)];\n\n\t\trep(vd, 8){\n\t\t\tint vy = y + dy[vd];\n\t\t\tint vx = x + dx[vd];\n\t\t\tif(getBit(s, vy, vx)) continue;\n\t\t\tif(vy < 0 || vy >= n || vx < 0 || vx >= n) continue;\n\n\t\t\tint nxt = 0;\n\t\t\trep(i,n){\n\t\t\t\trep(j,n){\n\t\t\t\t\tif(vy == i and vx == j) continue;\n\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\trep(d,8){\n\t\t\t\t\t\tint ny = i + dy[d];\n\t\t\t\t\t\tint nx = j + dx[d];\n\t\t\t\t\t\tif(ny < 0 || ny >= n || nx < 0 || nx >= n) continue;\n\t\t\t\t\t\tif(getBit(s, ny, nx)) cnt++;\n\t\t\t\t\t\tif(vy == ny and vx == nx) cnt++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif((cnt == 2 or cnt == 3) and getBit(s, i, j) == 1){\n\t\t\t\t\t\tsetBit(nxt, i, j);\n\t\t\t\t\t}else if(cnt == 3 and getBit(s, i, j) == 0){\n\t\t\t\t\t\tsetBit(nxt, i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tauto t = T(nxt, vy, vx);\n\t\t\tif(memo.count(t) and memo[t] > memo[T(s, y, x)] + 1){\n\t\t\t\tmemo[t] = memo[T(s, y, x)] + 1;\n\t\t\t\tq.emplace(t);\n\t\t\t}else if(not memo.count(t)){\n\t\t\t\tmemo[t] = memo[T(s, y, x)] + 1;\n\t\t\t\tq.emplace(t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tint bit = 0, y, x;\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tchar a;\n\t\t\t\tcin >> a;\n\t\t\t\tif(a == '#'){\n\t\t\t\t\tsetBit(bit, i, j);\n\t\t\t\t}\n\t\t\t\tif(a == '@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << bfs(bit, y, x) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <deque>\n#include <algorithm>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n\n#define MP make_pair\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//AOJ 1304\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={-1,0,1,-1,1,-1,0,1};\n\nset<int> vsi;\nint n;\n\ninline void setstate(int &a,int x,int y, int state){\n\tif(state){\n\t\ta|=(1<<(y*n+x));\n\t}else{\n\t\tint p=1<<(y*n+x);\n\t\tp = ~p;\n\t\ta&=p;\n\t}\n}\ninline void setpos(int &a, int x, int y){\n\ta &= ((1<<25)-1);\n\ta |= (x<<25)||(y<<28);\n}\n\ninline int count(int b){\n\tint ret = 0;\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif((b>>(i*n+j))&1){\n\t\t\t\tret++;\n\t\t\t\tif(ret==2)return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\ninline int step(int &b){\n\tint tb = b;\n\tint ret = 0;\n\tint x=(b>>25&7);\n\tint y=(b>>28&7);\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(y==i&&x==j)continue;\n\t\t\tint cnt = 0;\n\t\t\tREP(k,8){\n\t\t\t\tint ny=i+dy[k];\n\t\t\t\tint nx=j+dx[k];\n\t\t\t\tif(nx<0 || ny<0 || nx>=n || ny>=n)continue;\n\t\t\t\tif((tb>>(ny*n+nx))&1)cnt++;\n\t\t\t}\n\t\t\tif((tb>>(i*n+j))&1){\n\t\t\t\tif(cnt!=2&&cnt!=3)setstate(b,j,i,0);\n\t\t\t}else if(!((tb>>(i*n+j))&1)){\n\t\t\t\tif(cnt==3)setstate(b,j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>n, n){\n\t\tvsi.clear();\n\t\tchar b[6];\n\t\tint is=0;\n\t\tREP(i,n){\n\t\t\tscanf(\"%s\", b);\n\t\t\tREP(j,n){\n\t\t\t\tswitch(b[j]){\n\t\t\t\tcase '@':\n\t\t\t\t\tsetpos(is, j, i);\n\t\t\t\tcase '#':\n\t\t\t\t\tis |= (1LL<<i*n+j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int> > q;\n\t\tq.push(MP(0,is));\n\t\tint ans=-1;\n\t\twhile(!q.empty()){\n\t\t\tint x,y;\n\t\t\tpair<int, int> tmp=q.front();\n\t\t\tq.pop();\n\t\t\tif(EXIST(vsi,tmp.second))continue;\n\t\t\tvsi.insert(tmp.second);\n\t\t\tif(count(tmp.second)==0){\n\t\t\t\tans=tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = (tmp.second>>25&7);\n\t\t\ty = (tmp.second>>28&7);\n\t\t\tREP(i,8){\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(nx<0 || ny<0 || nx>=n || ny>=n || ((tmp.second>>(ny*n+nx))&1))continue;\n\t\t\t\tint tb = tmp.second;\n\t\t\t\tsetstate(tb,x,y,0);\n\t\t\t\tsetstate(tb,nx,ny,1);\n\t\t\t\tsetpos(tb,nx,ny);\n\t\t\t\tstep(tb);\n\t\t\t\tif(EXIST(vsi,tb))continue;\n\t\t\t\tq.push(MP(tmp.first+1, tb));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < (n); i++)\nconst int dx[8] = {1,1,1,-1,-1,-1,0,0};\nconst int dy[8] = {1,-1,0,1,-1,0,1,-1};\nstruct data\n{\n\tint mask,x,y;\n};\nint n;\ndata next_state(int mask, int x, int y)\n{\n\tint T = 0;\n\tmask |= (1 << (x*n+y));\n\trep(i,n)\n\t\trep(j,n)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\trep(k,8)\n\t\t\t{\n\t\t\t\tint xx = i + dx[k];\n\t\t\t\tint yy = j + dy[k];\n\t\t\t\tif (xx < 0 || xx >= n || yy < 0 || yy >= n)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (mask & (1 << (xx*n+yy)))\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (mask & (1 << (i * n + j)))\n\t\t\t{\n\t\t\t\tif (cnt == 3 || cnt == 2)\n\t\t\t\t\tT |= 1 << (i * n + j);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cnt == 3)\n\t\t\t\t\tT |= 1 << (i*n+j);\n\t\t\t}\n\t\t}\n\tT &= ~(1 << (x * n + y));\n\treturn (data){T, x, y};\n}\nbool dfs(data s, int dep)\n{\n\tif (s.mask == 0)\n\t\treturn true;\n\tif (dep == 0)\n\t\treturn false;\n\trep(i,8)\n\t{\n\t\tint xx = s.x + dx[i];\n\t\tint yy = s.y + dy[i];\n\t\tif (xx < 0 || xx >= n || yy < 0 || yy >= n) continue;\n\t\tif (s.mask & (1 << (xx*n+yy)))\n\t\t\tcontinue;\n\t\tif (dfs(next_state(s.mask,xx,yy),dep-1))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nchar c[10];\nint main()\n{\n\tfor (; scanf(\"%d\", &n), n;)\n\t{\n\t\tdata s = {};\n\t\trep(i,n)\n\t\t{\n\t\t\tscanf(\"%s\", c);\n\t\t\trep(j,n)\n\t\t\t{\n\t\t\t\tswitch(c[j])\n\t\t\t\t{\n\t\t\t\t\tcase '@': s.x = i, s.y = j; break;\n\t\t\t\t\tcase '#': s.mask |= 1 << (i * n + j);break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\trep(t,11)\n\t\t\tif (dfs(s, t))\n\t\t\t{\n\t\t\t\tans = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\n#define INF 100000000\n\nint n;\nmap<pair<int,int>,int> dp;\nmap<pair<int,int>,bool> vis;\nmap<pair<int,int>,bool> now;\nmap<pair<int,int>,int> next;\nchar buf[25][25];\nint dx[] = {-1,0,1,-1,1,-1,0,1};\nint dy[] = {-1,-1,-1,0,0,1,1,1};\nint ans;\n\nint make(pair<int,int> p) {\n\tif (next.find(p)!=next.end()) return next[p];\n\tint mask = p.first;\n\tint pos = p.second;\n\tmask |= (1<<pos);\n\tint newmask = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tint k = i*n+j;\n\t\t\tint t = 0;\n\t\t\tif (j>0) {\n\t\t\t\tt += (mask&(1<<(k-1)))>0;\n\t\t\t\tif (i>0) t += (mask&(1<<(k-1-n)))>0;\n\t\t\t\tif (i<n-1) t += (mask&(1<<(k-1+n)))>0;\n\t\t\t}\n\t\t\tif (j<n-1) {\n\t\t\t\tt += (mask&(1<<(k+1)))>0;\n\t\t\t\tif (i>0) t += (mask&(1<<(k+1-n)))>0;\n\t\t\t\tif (i<n-1) t += (mask&(1<<(k+1+n)))>0;\n\t\t\t}\n\t\t\tif (i>0) t += (mask&(1<<(k-n)))>0;\n\t\t\tif (i<n-1) t += (mask&(1<<(k+n)))>0;\n\t\t\tif ((mask&(1<<k)) && k!=pos) {\n\t\t\t\tif (t==2 || t==3) {\n\t\t\t\t\tnewmask |= (1<<k);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (t==3 && k!=pos) {\n\t\t\t\t\tnewmask |= (1<<k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnext[p] = newmask;\n\treturn newmask;\n}\n\nvoid print(int m) {\n\tfor (int i=0; i<n;  i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tint k = i*n+j;\n\t\t\tif (m&(1<<k)) cout<<'#';\n\t\t\telse cout<<'.';\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\nvoid solve(int x, int y, int mask,int cur) {\n\t//cout<<x<<\" \"<<y<<\" \"<<mask<<endl;\n\t//print(mask);\n\t//cout<<endl;\n\tif (cur>ans) return;\n\tif (mask==0) ans = cur;\n\tif (now[make_pair(mask,x*n+y)]) return;\n\t\n\tnow[make_pair(mask,x*n+y)] = 1;\n\t\n\tint tmp = INF;\n\tint t = 1000;\n\t\n\tfor (int k=0; k<8; k++) {\n\t\tint u = x + dx[k];\n\t\tint v = y + dy[k];\n\t\tif (u<0 || u>=n) continue;\n\t\tif (v<0 || v>=n) continue;\n\t\tif (mask&(1<<(u*n+v))) continue;\n\t\t\n\t\tint m = make(make_pair(mask,u*n+v));\n\t\t\n\t\tt = min(t,__builtin_popcount(m));\n\t}\n\t\n\tfor (int k=0; k<8; k++) {\n\t\tint u = x + dx[k];\n\t\tint v = y + dy[k];\n\t\tif (u<0 || u>=n) continue;\n\t\tif (v<0 || v>=n) continue;\n\t\tif (mask&(1<<(u*n+v))) continue;\n\t\t\n\t\tint m = make(make_pair(mask,u*n+v));\n\t\t\n\t\tif (__builtin_popcount(m)==t) {\n\t\t\tsolve(u,v,m,cur+1);\n\t\t}\n\t}\n\t\n\tnow[make_pair(mask,x*n+y)] = 0;\n\t//vis[make_pair(mask,x*n+y)] = 1;\n\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d\",&n) && n!=0) {\n\t\tfor (int i=0; i<n; i++) scanf(\"%s\",buf+i);\n\t\tint x,y;\n\t\tint mask = 0;\n\t\tfor (int i=0; i<n; i++) for (int j=0; j<n; j++) {\n\t\t\tif (buf[i][j]=='#') mask |= (1<<(i*n+j));\n\t\t\tif (buf[i][j]=='@') {\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t\tnow.clear();\n\t\tvis.clear();\n\t\tdp.clear();\n\t\tans = INF;\n\t\tsolve(x,y,mask,0);\n\t\tif (ans >= INF) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nmap<P,int> check;\n\nint func(int fie,int x,int y){\n\tint res=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==x && j==y)continue;\n\t\t\tint cnt=0;\n\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\tif(k==0 && l==0)continue;\n\t\t\t\t\tint nx=i+k,ny=j+l;\n\t\t\t\t\tif(nx>=0 && nx<n && ny>=0 && ny<n){\n\t\t\t\t\t\tif(fie>>(ny*n+nx) & 1 || (nx==x && ny==y))cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt==3 || (cnt==2 && (fie>>(j*n+i) & 1)))res|=(1<<(j*n+i));\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int fie,int s){\n\tqueue<P> que;\n\tque.push(P(fie,s));\n\tcheck[P(fie,s)]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tif(q.first==0)return check[P(q.first,q.second)];\n\t\tint x=q.second%n,y=q.second/n;\n\t\tfor(int i=-1;i<=1;i++){\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tif(i==0 && j==0)continue;\n\t\t\t\tint nx=x+i,ny=y+j;\n\t\t\t\tif(nx>=0 && nx<n && ny>=0 && ny<n){\n\t\t\t\t\tif(q.first>>(ny*n+nx) & 1)continue;\n\t\t\t\t\tint nfie=func(q.first,nx,ny);\n\t\t\t\t\tif(check.find(P(nfie,ny*n+nx))==check.end()){\n\t\t\t\t\t\tcheck[P(nfie,ny*n+nx)]=check[P(q.first,y*n+x)]+1;\n\t\t\t\t\t\tque.push(P(nfie,ny*n+nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tint fie=0;\n\t\tint s=0;\n\t\tcheck.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(str[j]=='#')fie|=(1<<(i*n+j));\n\t\t\t\tif(str[j]=='@')s=i*n+j;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",bfs(fie,s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <set>\nusing namespace std;\n\nint dx[]={0,-1,0,1,-1,-1,1,1};\nint dy[]={-1,0,1,0,-1,1,-1,1};\n\nclass State\n{\npublic:\n\tint h,c,x,y;\n\tState(int x, int y, int h, int c)\n\t\t:h(h),c(c),x(x),y(y)\n\t{}\n};\n\nbool tf[5][5];\n\nset<pair<int, int> > hs;\n\nint ch(bool f[5][5],int N)\n{\n\tint ret=0,cnt=0;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t{\n\t\tret|=(f[j][i]<<cnt);\n\t\tcnt++;\n\t}\n\n\treturn ret;\n}\n\nvoid mov(int x, int y, bool f[5][5], int N)\n{\n\tmemset(tf,0,sizeof(tf));\n\tf[x][y]=1;\n\tint cnt[5][5]={0};\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t{\n\t\tif(!f[j][i]) continue;\n\t\tfor(int k=0; k<8; k++)\n\t\t{\n\t\t\tint tx=j+dx[k], ty=i+dy[k];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N) continue;\n\n\t\t\tcnt[tx][ty]++;\n\t\t}\n\t}\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t{\n\t\tif(f[j][i]&&(cnt[j][i]==2||cnt[j][i]==3)) \n\t\t{\n\t\t\ttf[j][i]=1;\n\t\t}\n\t\tif(!f[j][i]&&cnt[j][i]==3)\n\t\t{\n\t\t\ttf[j][i]=1;\n\t\t}\n\t}\n\n\ttf[x][y]=0;\n\tf[x][y]=0;\n}\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\ths.clear();\n\t\tbool f[5][5]={0};\n\t\tint sx,sy;\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin.ignore();\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c=='@')\n\t\t\t\t{\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(c=='#') f[j][i]=1;\n\t\t\t}\n\t\t}\n\n\t\tqueue<State> q;\n\t\tq.push(State(sx,sy,ch(f,N), 0));\n\n\t\tint ans=-1;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tState s=q.front(); q.pop();\n\t\t\tif(s.h==0)\n\t\t\t{\n\t\t\t\tans=s.c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbool sf[5][5];\n\t\t\tint tcnt=0;\n\t\t\tfor(int i=0; i<N; i++)\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tsf[j][i]=(s.h&(1<<tcnt));\n\t\t\t\ttcnt++;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<8; i++)\n\t\t\t{\n\t\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\t\tif(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t\t\t\tif(sf[tx][ty]) continue;\n\n\t\t\t\tmov(tx,ty,sf,N);\n\t\t\t\tint h=ch(tf,N);\n\t\t\t\tif(hs.count(make_pair(tx*5+ty, h))) continue;\n\t\t\t\ths.insert(make_pair(tx*5+ty, h));\n\n\t\t\t\tq.push(State(tx,ty, h, s.c+1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint n;\nmap<int, int> memo[25];\nmap<int, int> nxt[5];\n\nint dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\nint dy[] = {0, -1, 0, 1, 1, -1, 1, -1};\nint h(int i, int j){\n\treturn n * i + j;\n}\n\nvoid print(int state, int pos){\n\tcout << pos / n << \" \" << pos % n << endl;\n\trep(i, n){\n\t\trep(j, n){\n\t\t\tif(state & (1 << h(i, j))) cout << \"#\";\n\t\t\telse cout << '.';\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nbool cango(int state, int i, int j){\n\tint s = state & (1 << h(i, j));\n\treturn (0 <= i && i < n && 0 <= j && j < n && s == 0);\n}\n\nint get_next(int state){\n\tif(nxt[n-1][state]) return nxt[n-1][state] - 1;\n\tint res = 0;\n\tint pow = 1;\n\n\trep(i, n)rep(j, n){\n\t\tint cnt = 0;\n\t\tint s = h(i, j);\n\n\t\tbool f = (state & (1 << s)) ? true : false;\n\t\trep(k, 8){\n\t\t\tint i2 = i + dy[k];\n\t\t\tint j2 = j + dx[k];\n\t\t\tif(0 <= i2 && i2 < n && 0 <= j2 && j2 < n){\t\n\t\t\t\tint s2 = h(i2, j2);\n\t\t\t\tif(state & (1 << s2)) cnt++;\n\t\t\t}\n\t\t}\n\n\t\tif((f && (cnt == 2)) || cnt == 3){\n\t\t\tres += pow;\n\t\t}\n\t\tpow <<= 1;\n\t}\n\tnxt[n-1][state] = res + 1;\n\treturn res;\n\n}\n\nint bfs(int state, int pos){\n\trep(i, n * n) memo[i].clear();\n\n\tmemo[pos][state] = 1;\n\tqueue<P> que;\n\tque.push(P(state, pos));\n\n\twhile(!que.empty()){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tstate = p.first;\n\t\tpos = p.second;\n\t\t\n\t\tif(state == 0){\n\t\t\t//cout << \"!!!!!!!!!!!!!!\" << \" \" << memo[pos][state] << endl;\n\t\t\treturn memo[pos][state] - 1;\n\t\t}\n\n//\t\tprint(state, pos);\n\t\tint i1 = pos / n;\n\t\tint j1 = pos % n;\n\t\t//cout << nstate << endl;\n\n\t\trep(i, 8){\n\t\t\t\t\n\t\t\tint i2 = i1 + dy[i];\n\t\t\tint j2 = j1 + dx[i];\n\t\t\t\n\t\t\tif(cango(state, i2, j2)){\n\t\t\t\tint nstate = get_next((state | (1 << h(i2, j2)))) & ~(1 << h(i2, j2));\n\t\t\t\t//print(nstate, h(i2, j2));\n\t\t\t\tif(memo[h(i2, j2)][nstate] == 0){\n\t\t\t\t\t\n\t\t\t\t\tmemo[h(i2, j2)][nstate] = memo[pos][state] + 1;\n\t\t\t\t\tque.push(P(nstate, h(i2, j2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\t\n\twhile(cin >> n && n){\n\t\tint state = 0;\n\t\tint pos = 0;\n\t\tint pow = 1;\n\t\tchar c;\n\t\trep(i, n)rep(j, n){\n\t\t\tcin >> c;\n\t\t\tif(c == '#') state += pow;\n\t\t\telse if(c == '.') ;\n\t\t\telse {\n\t\t\t\tpos = h(i, j);\n\t\t\t}\n\t\t\tpow <<= 1;\n\t\t}\n\t\tcout << bfs(state, pos) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\ninline int calc_hash(const data &D){\n\tint res=(47*D.S+53)&((1<<24)-1);\n\tres=res*(59*D.x+61)&((1<<24)-1);\n\tres=res*(67*D.x+71)&((1<<24)-1);\n\treturn res;\n}\n\nint main(){\n\tfor(char T=1;scanf(\"%d\",&n),n;T++){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tstatic char vis[1<<24];\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tint hash=calc_hash(D);\n\t\t\tif(vis[hash]==T) continue;\n\t\t\tvis[hash]=T;\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\nint inf=1e8;\nint dx[8]={1,1,1,0,0,-1,-1,-1};\nint dy[8]={1,0,-1,1,-1,1,0,-1};\nint N;\nstring st[5];\nint nxt[6][1<<25];\ninline bool is(int x,int y){\n\treturn 0<=x&&x<N&&0<=y&&y<N;\n}\nint solve(){\n\tset<IP> vis;\n\trep(i,N) cin>>st[i];\n\tint sx,sy,si=0;\n\trep(i,N) rep(j,N){\n\t\tif(st[i][j]=='@') sx=i,sy=j;\n\t\tif(st[i][j]=='#') si|=1<<(i*N+j);\n\t}\n\tqueue<IP> que;\n\tque.push(IP(si,P(sx,sy)));\n\tvis.insert(IP(si,P(sx,sy)));\n\tque.push(IP(-1,P(0,0)));\n\tint dist=0;\n\tint cnt=0;\n\twhile(!que.empty()){\n\t\tcnt++;\n\t\tif(cnt%10000000==0) cout<<cnt<<endl;\n\t\tIP ip=que.front();\n\t\tque.pop();\n\t\tint bit=ip.fs;\n\t\tint x=ip.sc.fs,y=ip.sc.sc;\n\t\tif(bit<0){\n\t\t\tdist++;\n\t\t\tif(que.empty()) break;\n\t\t\tque.push(IP(-1,P(0,0)));\n\t\t}\n\t\tif(bit==0) return dist;\n\t\trep(di,8){\n\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\tif(is(nx,ny)&& !((bit>>(nx*N+ny))&1) ){\n\t\t\t\tint i=bit|(1<<(nx*N+ny));\n\t\t\t\tint ni=0;\n\t\t\t\t{\n\t\t\t\t\tbool a[5][5]={};\n\t\t\t\t\trep(j,N) rep(k,N) a[j][k]=(i>>(j*N+k))&1;\n\t\t\t\t\trep(j,N) rep(k,N){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\trep(d,8){\n\t\t\t\t\t\t\tint nx=j+dx[d],ny=k+dy[d];\n\t\t\t\t\t\t\tif(is(nx,ny)&&a[nx][ny]) cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[j][k]&&(cnt==2||cnt==3)) ni|=1<<(j*N+k);\n\t\t\t\t\t\tif(!a[j][k]&&cnt==3) ni|=1<<(j*N+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( (ni>>(nx*N+ny))&1 ) ni^=1<<(nx*N+ny);\n\t\t\t\tIP nip=IP(ni,P(nx,ny));\n\t\t\t\tif(vis.find(nip)!=vis.end()) continue;\n\t\t\t\tque.push(nip);\n\t\t\t\tvis.insert(nip);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr int dx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconstexpr int dy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\n\n\ninline int encode(const vector<string> &state) {\n\tconst int n = state.size();\n\n\tint index;\n\tint res = 0;\n\n\tfor(int y = 0; y < n; ++y) {\n\t\tfor(int x = 0; x < n; ++x) {\n\t\t\tres = (res << 1) + (state[y][x] == '#' ? 1 : 0);\n\t\t\tif(state[y][x] == '@') {\n\t\t\t\tindex = x + y * n;\n\t\t\t}\n\t\t}\n\t}\n\n\tres |= (index << (n * n));\n\treturn res;\n}\n\ninline vector<string> decode(int code, int n) {\n\tvector<string> res(n, string(n, '.'));\n\tfor(int y = n - 1; y >= 0; --y) {\n\t\tfor(int x = n - 1; x >= 0; --x) {\n\t\t\tif(code & 1) res[y][x] = '#';\n\t\t\tcode >>= 1;\n\t\t}\n\t}\n\n\tres[code / n][code % n] = '@';\n\treturn res;\n}\n\ninline bool out(int x, int y, int n) {\n\treturn x < 0 || y < 0 || x >= n || y >= n;\n}\n\nvector<string> update(const vector<string> &state) {\n\tconst int n = state.size();\n\tvector<string> res(n, string(n, '.'));\n\n\tfor(int y = 0; y < n; ++y) {\n\t\tfor(int x = 0; x < n; ++x) {\n\t\t\tif(state[y][x] == '@') {\n\t\t\t\tres[y][x] = '@';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint cnt = 0;\n\t\t\tfor(int d = 0; d < 8; ++d) {\n\t\t\t\tconst int nx = x + dx[d];\n\t\t\t\tconst int ny = y + dy[d];\n\n\t\t\t\tif(!out(nx, ny, n) && state[ny][nx] != '.') ++cnt;\n\t\t\t}\n\n\t\t\tif(cnt == 3 || (cnt == 2 && state[y][x] == '#')) {\n\t\t\t\tres[y][x] = '#';\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint bfs(const vector<string> &start) {\n\tconst int n = start.size();\n\tconst int s = encode(start);\n\tconst int goal_mask = (1 << (n * n)) - 1;\n\n\tif((s & goal_mask) == 0) return 0;\n\n\tunordered_map<int, int> dist;\n\tqueue<int> que;\n\n\tdist.insert({s, 0});\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int code = que.front();\n\t\tque.pop();\n\n\t\tconst int current_dist = dist[code];\n\t\tconst auto state = decode(code, n);\n\t\tconst int x = (code >> (n * n)) % n;\n\t\tconst int y = (code >> (n * n)) / n;\n\n\t\tfor(int d = 0; d < 8; ++d) {\n\t\t\tconst int nx = x + dx[d];\n\t\t\tconst int ny = y + dy[d];\n\n\t\t\tif(out(nx, ny, n) || state[ny][nx] == '#') continue;\n\n\t\t\tvector<string> next_state(state);\n\t\t\tswap(next_state[ny][nx], next_state[y][x]);\n\t\t\tnext_state = update(move(next_state));\n\t\t\tconst int next_code = encode(next_state);\n\n\t\t\tif(!dist.count(next_code)) {\n\t\t\t\tif((next_code & goal_mask) == 0) return current_dist + 1;\n\t\t\t\tdist.insert({next_code, current_dist + 1});\n\t\t\t\tque.push(next_code);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint cnt = 0;\n\tfor(int n; cin >> n && n;) {\n\t\tvector<string> start(n);\n\t\tfor(auto &e : start) cin >> e;\n\t\tcout << bfs(start) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nmap<pip,int>ma;\nint n;\nvvi in;\nvvi f(int a){\n\tvvi w(n,vi(n));\n\trep(i,n)rep(j,n){\n\t\tw[n-1-i][n-1-j]=a%2;\n\t\ta/=2;\n\t}\n\treturn w;\n}\nint F(vvi w){\n\tint a=0;\n\trep(i,n)rep(j,n){\n\t\ta*=2;\n\t\ta+=w[i][j];\n\t}\n\treturn a;\n}\nvvi nex(vvi w){\n\tvvi ne(n,vi(n));\n\trep(i,n)rep(j,n){\n\t\tint co=0;\n\t\trep(k,8){\n\t\t\tint x=i+dx[k];\n\t\t\tint y=j+dy[k];\n\t\t\tif(x<0||y<0||x>=n||y>=n)continue;\n\t\t\tco+=w[x][y];\n\t\t}\n\t\tif(w[i][j]&&(co==2||co==3))ne[i][j]=1;\n\t\tif(w[i][j]==0&&co==3)ne[i][j]=1;\n\t}\n\t\n\treturn ne;\n}\nsigned main(){\n\twhile(cin>>n,n){\n\t\tvs s(n);\n\t\trep(i,n)cin>>s[i];\n\t\tint x,y;\n\t\tin=vvi(n,vi(n));\n\t\trep(i,n)rep(j,n){\n\t\t\tif(s[i][j]-'.')in[i][j]=1;\n\t\t\tif(s[i][j]=='@')x=i,y=j;\n\t\t}\n\t\tma.clear();\n\t\tma[{F(in),{x,y}}]=1;\n\t\tqueue<pip>que;\n\t\tque.push({F(in),{x,y}});\n\t\twhile(!que.empty()){\n\t\t\tint w;pii p;\n\t\t\tw=que.front().first;\n\t\t\tp=que.front().second;\n\t\t\tque.pop();\n\t\t\tvvi fi=f(w);\n\t\t\t\n\t\t\tint cnt=ma[{w,p}];\n\t\t\tint co=0;\n\t\t\trep(i,n)rep(j,n)if(fi[i][j])co++;\n\t\t\tif(co==1){\n\t\t\t\tcout<<cnt-1<<endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\t\n\t\t\tfi[p.first][p.second]=0;\n\t\t\trep(k,8){\n\t\t\t\tint nx=p.first+dx[k];\n\t\t\t\tint ny=p.second+dy[k];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=n)continue;\n\t\t\t\tif(fi[nx][ny])continue;\n\t\t\t\tfi[nx][ny]=1;\n\t\t\t\t// show2d(fi);\n\t\t\t\tvvi ne=nex(fi);\n\t\t\t\tne[nx][ny]=1;\n\t\t\t\t// show2d(ne);\n\t\t\t\t// cout<<endl;\n\t\t\t\tif(ma[{F(ne),{nx,ny}}]==0){\n\t\t\t\t\tma[{F(ne),{nx,ny}}]=cnt+1;\n\t\t\t\t\tque.push({F(ne),{nx,ny}});\n\t\t\t\t}\n\t\t\t\tfi[nx][ny]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<-1<<endl;\n\t\tend:;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n\nbool onmp(int x,int y){return x>=0&&y>=0&&x<n&&y<n;}\n\nint count(int x,int y,const vector<string> &A){\n  int res=0;  \n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i,ny = y+j;\n      if((!i&&!j)||!onmp(nx,ny))continue;\n      res += A[ny][nx]=='#'||A[ny][nx]=='@';\n    }\n  return res;\n}\n\nbool check(const vector<string> &A){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(A[i][j]=='#')return 0;\n  return 1;\n}\n\n\nvector<string> mkmp(const vector<string> &A){\n  vector<string> res(n,string(n,'.'));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cnt = count(j,i,A);\n      if(A[i][j]=='#')res[i][j]=(cnt==2||cnt==3)? '#':'.';\n      if(A[i][j]=='.')res[i][j]=(cnt==3)? '#':'.';\n      if(A[i][j]=='@')res[i][j]='@';\n    }\n  return res;\n}\n\n\nmap<vector<string>,int> mem;\nint ans;\nvoid dfs(int x,int y,int cnt,vector<string> A){\n  if(check(A))ans=min(cnt,ans);\n  if(cnt>=ans) return;\n  if(mem.count(A)&&mem[A]<=cnt)return;\n  mem[A]=cnt;\n  A[y][x] = '.';\n  for(int dy=-1;dy<=1;dy++){\n    for(int dx=-1;dx<=1;dx++){\n      int nx = x+dx,ny = y+dy;\n      if((!dx&&!dy)||!onmp(nx,ny)||A[ny][nx]=='#')continue;\n      A[ny][nx] = '@';\n      dfs(nx,ny,cnt+1,mkmp(A));\n      A[ny][nx] = '.';\n    }\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    vector<string> mp(n);\n    for(int i=0;i<n;i++)cin>>mp[i];\n    int sx,sy;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)if(mp[i][j]=='@')sy=i,sx=j;\n    ans = 11;\n    mem.clear();\n    dfs(sx,sy,0,mp);\n    cout<<(ans<11? ans:-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#include<map>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct P\n{\n  string field;\n  int cur,phase,cost;\n  P(string field=\"$\",int cur=inf,int phase=inf,int cost=inf):field(field),cur(cur),phase(phase),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return phase > a.phase;\n  }\n};\n\nint n,ans;\nint dx[] = {-1,-1,+0,+1,+1,+1,+0,-1};//LTRB\nint dy[] = {+0,-1,-1,-1,+0,+1,+1,+1};\nmap<string,int> mincost;\n\nint infect(string &s)\n{\n  int cost = 0;\n  string ns = string(n*n,'.');\n  rep(y,n)\n    {\n      rep(x,n)\n\t{\n\t  if(s[x+y*n] == '@')\n\t    {\n\t      ns[x+y*n] = '@';\n\t      continue;\n\t    }\n\t  int cnt = 0;\n\t  rep(k,8)\n\t    {\n\t      int nx = x + dx[k];\n\t      int ny = y + dy[k];\n\t      if(!(0 <= nx && nx < n && 0 <= ny && ny < n))continue;\n\t      if(s[nx+ny*n] != '.')cnt++;\n\t    }\n\t  if(cnt == 3)ns[x+y*n] = '#',cost++;\n\t  if(s[x+y*n] == '#' && cnt == 2)ns[x+y*n] = '#',cost++;\n\t}\n    }\n  s = ns;\n  return cost;\n}\n\nvoid pr(string s)\n{\n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  cout << s[j+i*n];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid bfs(string bfield,int bcur,int bphase,int bcost)\n{\n  priority_queue<P> Q;\n  Q.push(P(bfield,bcur,bphase,bcost));\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(p.cost == 0)\n\t{\n\t  cout << p.phase << endl;\n\t  return;\n\t}\n\n\n      int x = p.cur%n;\n      int y = p.cur/n;\n      int cur = p.cur;\n      rep(i,8)\n\t{\n\t  int nx = x + dx[i];\n\t  int ny = y + dy[i];\n\t  if(!(0 <= nx && nx < n && 0 <= ny && ny < n))continue;\n\t  if(p.field[nx+ny*n] == '#')continue;\n\t  string nfield = p.field;\n\t  cur = nx + ny * n;\n\t  nfield[x+y*n] = '.';\n\t  nfield[nx+ny*n] = '@';\n\t  int ncost = infect(nfield);\n\t  if(mincost.find(nfield) == mincost.end())\n\t    {\n\t      mincost[nfield] = p.phase + 1;\n\t      Q.push(P(nfield,cur,p.phase+1,ncost));\n\t    }\t  \n\t  else if(mincost[nfield] > p.phase + 1)\n\t    {\n\t      mincost[nfield] = p.phase + 1;\n\t      Q.push(P(nfield,cur,p.phase+1,ncost));\n\t    }\n\t}\n\n    }\n  cout << -1 << endl;\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      mincost.clear();\n      int sp;\n      string field = \"\";\n      int cost = 0;\n      rep(i,n)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,n)\n\t    if(line[j] == '@')sp = i*n + j;\n\t    else if(line[j] == '#')cost++;\n\t  field += line;\n\t}\n\n      if(cost == 0)\n\t{\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n\n      ans = inf;\n\n      bfs(field,sp,0,cost);\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n\n#define msn(x) (memset((x),0,sizeof((x))))\n#define msx(x) (memset((x),0x7f,sizeof((x))))\n#define fuck(x) cerr << #x << \" <- \" << x << endl\n#define acer cout<<\"sb\"<<endl\ntypedef long long ll;\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define eps 1e-8\n#define pi acos(-1.0)\nstruct node\n{\n    char mp[7][7];\n    int time;\n    int x,y;\n    ll hs;\n} beg;\nconst ll fu=1e9;\nint n;\nconst int dx[8]= {-1,-1,-1,0,1,1,1,0};\nconst int dy[8]= {-1, 0, 1,1,1,0,-1,-1};\ninline bool in(int x,int y)\n{\n    return (x>=1&&y<=n&&x<=n&&y>=1);\n}\nint solve(ll cmp)\n{\n    set<ll>s;\n    cmp=(beg.x*10+beg.y)*fu+cmp;\n    beg.hs=cmp;\n  //  printf(\"%lld\\n\",cmp);\n    s.insert(cmp);\n    queue<node>q;\n    q.push(beg);\n    while(!q.empty())\n    {\n        node now=q.front();\n        q.pop();\n        node nxt;\n        int tot=0;\n        nxt.time=now.time+1;\n        for(int c=0; c<8; c++)\n        {\n            int x=now.x+dx[c];\n            int y=now.y+dy[c];\n            if(in(x,y)&&now.mp[x][y]=='.')\n            {\n                nxt.x=x;\n                nxt.y=y;\n                swap(now.mp[x][y],now.mp[now.x][now.y]);\n                ll hs=0;\n                for(int i=1; i<=n; i++)\n                {\n                    for(int j=1; j<=n; j++)\n                    {\n                        int sz=0;\n                        for(int k=0; k<8; k++)if(now.mp[i+dx[k]][j+dy[k]]=='#'||now.mp[i+dx[k]][j+dy[k]]=='@')sz++;\n                        if(now.mp[i][j]=='#')\n                        {\n                            if(sz<=3&&sz>=2)\n                            hs|=(1<<((i-1)*n+j-1)),nxt.mp[i][j]='#';\n                            else nxt.mp[i][j]='.';\n                        }else\n                        if(now.mp[i][j]=='.')\n                        {\n                            if(sz==3)nxt.mp[i][j]='#',hs|=(1<<((i-1)*n+j-1));\n                            else nxt.mp[i][j]='.';\n                        }\n                        else nxt.mp[i][j]=now.mp[i][j];\n                    }\n                }\n                if(hs==0)return nxt.time;\n                hs=(x*10+y)*fu+hs;\n                nxt.hs=hs;\n                if(s.find(hs)==s.end())\n                {\n                    s.insert(hs);\n                    q.push(nxt);\n                }\n                swap(now.mp[x][y],now.mp[now.x][now.y]);\n            }\n        }\n    }\n    return -1;\n}\nint main()\n{\n    while(1)\n    {\n        scanf(\"%d\",&n);\n        if(n==0)break;\n        for(int i=1; i<=n; i++)scanf(\"%s\",beg.mp[i]+1);\n        beg.time=0;\n        ll cmp=0;\n        for(int i=1; i<=n; i++)\n        {\n            for(int j=1; j<=n; j++)\n            {\n                if(beg.mp[i][j]=='#')cmp=(cmp|(1<<((i-1)*n+j-1)));\n                if(beg.mp[i][j]=='@')beg.x=i,beg.y=j;\n            }\n        }\n        if(cmp==0)printf(\"0\\n\");else\n        printf(\"%d\\n\",solve(cmp));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1},ans;\nmap<P,int> m;\nbool check(int x, int y) {\n  return x>=0&&x<n&&y>=0&&y<n;\n}\n \nP S(vector<string> s) {\n  P p=P(0,0);\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<n; j++) {\n      if(s[i][j]=='#') p.first|=1<<(i*n+j);\n      if(s[i][j]=='@') p.second=i*n+j;\n    }\n  }\n  return p;\n}\n \nvector<string> change(vector<string> s) {\n  vector<string> t=s;\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<n; j++) {\n      int c=0;\n      for(int k=0; k<8; k++) {\n        int x=i+dx[k],y=j+dy[k];\n        if(!check(x,y)) continue;\n        if(s[x][y]!='.') c++;\n      }\n      if(s[i][j]=='#') {\n        if(c==2||c==3) t[i][j]='#';\n        else t[i][j]='.';\n      }\n      if(s[i][j]=='.') {\n        if(c==3) t[i][j]='#';\n        else t[i][j]='.';\n      }\n      if(s[i][j]=='@') t[i][j]='@';\n    }\n  }\n  return t;\n}\n \nint main() {\n  while(cin >> n && n) {\n    vector<string> s(n);\n    for(int i=0; i<n; i++) cin >> s[i];\n    queue<P> que;\n    P p=S(s);\n    que.push(p);\n    m.clear();\n    m[p]=0;\n    while(!que.empty()) {\n      P p=que.front();que.pop();\n      vector<string> s(n);\n      bool f=1;\n      for(int i=0; i<n; i++) {\n        for(int j=0; j<n; j++) {\n          if(p.first&(1<<(i*n+j))) s[i]+='#',f=0;\n          else s[i]+='.';\n        }\n      }\n      s[p.second/n][p.second%n]='@';\n      if(f) {\n        cout << m[p] << endl;\n        goto end;\n      }\n      int nx=p.second/n,ny=p.second%n,c=m[p];\n      for(int i=0; i<8; i++) {\n        int x=nx+dx[i],y=ny+dy[i];\n        if(!check(x,y)||s[x][y]!='.') continue;\n        vector<string> t=s;\n        t[nx][ny]='.';\n        t[x][y]='@';\n        t=change(t);\n        P q=S(t);\n        if(m.count(q)) continue;\n        m[q]=c+1;\n        que.push(q);\n      }\n    }\n    cout << -1 << endl;\n  end:;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nconst int INF = 1 << 29;\n\nvector<string> get_next_board(const vector<string> &board) {\n    int N = board.size();\n    vector<string> res(N, string(N, '.'));\n\n    // vector<string> sample = {\".....\", \"##.@.\", \"#....\", \"...#.\", \"##.##\"};\n    \n    for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n            int cnt = 0;            \n            for(int k=0; k<8; k++) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if(ni < 0 or ni >= N or nj < 0 or nj >= N) continue;\n                cnt += (board[ni][nj] == '#' or board[ni][nj] == '@');\n            }\n\n            /*\n            if(sample == board) {\n                fprintf(stderr, \"i = %d, j = %d, cnt = %d\\n\", i, j, cnt);\n            }\n            */\n\n            if(board[i][j] == '#') {\n                if(cnt == 2 or cnt == 3) res[i][j] = '#';\n                else res[i][j] = '.';\n            }\n            else if(board[i][j] == '@') {\n                res[i][j] = '@';\n            }\n            else {\n                if(cnt == 3) res[i][j] = '#';\n                else res[i][j] = '.';\n            }\n        }\n    }\n\n    /*\n    if(sample == board) {\n        for(int i=0; i<N; i++) {\n            cerr << \"# \" << res[i] << endl;\n        }\n        for(int i=0; i<N; i++) {\n            cerr << \"? \" << board[i] << endl;\n        }\n    }\n    */\n    return res;\n}\n\nint bfs(const vector<string> &board, int ax, int ay) {\n    map< vector<string>, int > state;\n    int N = board.size();\n    state[board] = 0;\n\n    queue< tuple< vector<string>, int, int> > que;\n    que.emplace(board, ax, ay);\n\n    int res = INF;\n    while(que.size()) {\n        vector<string> B; int x, y;\n        tie(B, x, y) = que.front(); que.pop();\n        int cost = state[B];\n        \n        int cnt = 0;\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                if(B[i][j] == '#') {\n                    cnt = 1;\n                    break;\n                }\n            }\n        }\n        if(cnt == 0) {\n            res = cost;\n            break;\n        }\n        \n        for(int k=0; k<8; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if(nx < 0 or nx >= N or ny < 0 or ny >= N) continue;\n            if(B[nx][ny] == '#') continue;\n            swap(B[x][y], B[nx][ny]);\n            vector<string> NB = get_next_board(B);\n            if(!state.count(NB)) {\n                state[NB] = cost + 1;\n                que.emplace(NB, nx, ny);\n            }\n            swap(B[x][y], B[nx][ny]);\n        }\n    }\n    return res;\n}\n\nint solve_testcase() {\n    int N; cin >> N;\n    if(N == 0) return 1;\n\n    vector<string> board(N);\n    int ax = -1, ay = -1;\n    for(int i=0; i<N; i++) {\n        cin >> board[i];\n        for(int j=0; j<N; j++) {\n            if(board[i][j] == '@') {\n                ax = i, ay = j;\n            }\n        }\n    }\n\n    int ans = bfs(board, ax, ay);\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nvoid dbg(int fld, int p, int n)\n{\n\tstring s(n*n, '.');\n\tREP(i, n*n) if ((fld >> i) & 1) s[i] = '#';\n\ts[p] = '@';\n\tREP(i, n*n)\n\t{\n\t\tif (i % n == 0) cout << endl;\n\t\tcout << s[i];\n\t}\n\tcout << endl;\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvs v(n);\n\t\tREP(i, n) cin >> v[i];\n\t\tint fld = 0;\n\t\tint st;\n\t\tREP(i, n)REP(j, n)\n\t\t{\n\t\t\tif (v[i][j] == '#') fld |= 1 << place(i, j, n);\n\t\t\tif (v[i][j] == '@') st = place(i, j, n);\n\t\t}\n\t\tqueue<pii> que; que.emplace(fld, st);\n\t\tmap<pii, int> mp; mp[pii(fld, st)] = 0;\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpii tmp = que.front(); que.pop();\n\t\t\tint tfld = tmp.first;\n\t\t\tint tx = tmp.second / n, ty = tmp.second % n;\n\t\t\t//dbg(tfld, place(tx,ty,n), n);\n\t\t\tif (tfld == 0)\n\t\t\t{\n\t\t\t\tcout << mp[tmp] << endl;\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, 8)\n\t\t\t{\n\t\t\t\tint nx = tx + dx[i], ny = ty + dy[i];\n\t\t\t\tint np = place(nx, ny, n);\n\t\t\t\tif (!valid(nx, ny, n, n) || (tfld>>np) & 1) continue;\n\t\t\t\tint nfld = tfld;\n\t\t\t\tnfld |= 1 << np;\n\t\t\t\tint res = 0;\n\t\t\t\tREP(j, n)REP(k, n)\n\t\t\t\t{\n\t\t\t\t\tif (j == nx && k == ny) continue;\n\t\t\t\t\tint p = place(j, k, n);\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tREP(l, 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tint x = j + dx[l], y = k + dy[l];\n\t\t\t\t\t\tif (!valid(x, y, n, n)) continue;\n\t\t\t\t\t\tif ((nfld >> place(x, y, n)) & 1) cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif ((nfld >> p) & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (cnt == 2 || cnt == 3) res |= 1 << p;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (cnt == 3) res |= 1 << p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpii nex(res, np);\n\t\t\t\tif (mp.count(nex)) continue;\n\t\t\t\tmp[nex] = mp[tmp] + 1;\n\t\t\t\tque.push(nex);\n\t\t\t}\n\t\t}\n\t\tif (!f) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#include<map>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct P\n{\n  string field;\n  int cur,phase,cost;\n  P(string field=\"$\",int cur=inf,int phase=inf,int cost=inf):field(field),cur(cur),phase(phase),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return phase > a.phase;\n  }\n};\n\nint n,ans;\nint dx[] = {-1,-1,+0,+1,+1,+1,+0,-1};//LTRB\nint dy[] = {+0,-1,-1,-1,+0,+1,+1,+1};\nmap<string,int> mincost;\n\nint infect(string &s)\n{\n  int cost = 0;\n  string ns = string(n*n,'.');\n  rep(y,n)\n    {\n      rep(x,n)\n\t{\n\t  if(s[x+y*n] == '@')\n\t    {\n\t      ns[x+y*n] = '@';\n\t      continue;\n\t    }\n\t  int cnt = 0;\n\t  rep(k,8)\n\t    {\n\t      int nx = x + dx[k];\n\t      int ny = y + dy[k];\n\t      if(!(0 <= nx && nx < n && 0 <= ny && ny < n))continue;\n\t      if(s[nx+ny*n] != '.')cnt++;\n\t    }\n\t  if(cnt == 3)ns[x+y*n] = '#',cost++;\n\t  if(s[x+y*n] == '#' && cnt == 2)ns[x+y*n] = '#',cost++;\n\t}\n    }\n  s = ns;\n  return cost;\n}\n\nvoid pr(string s)\n{\n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  cout << s[j+i*n];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid bfs(string bfield,int bcur,int bphase,int bcost)\n{\n  priority_queue<P> Q;\n  Q.push(P(bfield,bcur,bphase,bcost));\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(p.cost == 0)\n\t{\n\t  cout << p.phase << endl;\n\t  return;\n\t}\n\n\n      int x = p.cur%n;\n      int y = p.cur/n;\n      int cur = p.cur;\n      rep(i,8)\n\t{\n\t  int nx = x + dx[i];\n\t  int ny = y + dy[i];\n\t  if(!(0 <= nx && nx < n && 0 <= ny && ny < n))continue;\n\t  if(p.field[nx+ny*n] == '#')continue;\n\t  string nfield = p.field;\n\t  cur = nx + ny * n;\n\t  nfield[x+y*n] = '.';\n\t  nfield[nx+ny*n] = '@';\n\t  int ncost = infect(nfield);\n\t  if(mincost.find(nfield) == mincost.end())\n\t    {\n\t      mincost[nfield] = p.phase + 1;\n\t      Q.push(P(nfield,cur,p.phase+1,ncost));\n\t    }\t  \n\t  else if(mincost[nfield] > p.phase + 1)\n\t    {\n\t      mincost[nfield] = p.phase + 1;\n\t      Q.push(P(nfield,cur,p.phase+1,ncost));\n\t    }\n\t}\n\n    }\n  cout << -1 << endl;\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      mincost.clear();\n      int sp;\n      string field = \"\";\n      int cost = 0;\n      rep(i,n)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,n)\n\t    if(line[j] == '@')sp = i*n + j;\n\t    else if(line[j] == '#')cost++;\n\t  field += line;\n\t}\n\n      if(cost == 0)\n\t{\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n\n      ans = inf;\n\n      bfs(field,sp,0,cost);\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int IINF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 1, 1, 0, 0, -1, -1, -1}, dy[] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nstruct S {\n\tchar fld[5][5];\n\tint x, y, cnt;\n};\n\nbool can_Move(int y, int x, int n, char fld[5][5]) {\n\tif(x < 0 || y < 0 || n <= x || n <= y)\n\t\treturn false;\n\tif(fld[y][x] == '.')\n\t\treturn true;\n\treturn false;\n}\n\nbool check(int y, int x, int n, char fld[5][5]) {\n\tif(x < 0 || y < 0 || n <= x || n <= y)\n\t\treturn false;\n\tif(fld[y][x] == '#' || fld[y][x] == '@')\n\t\treturn true;\n\treturn false;\n}\n\nvoid infection(S &s, int n) {\n\tchar fld[5][5];\n\tREP(i, n) REP(j, n) {\n\t\tint cnt = 0;\n\t\tREP(k, 8)\n\t\t\tcnt += check(i+dy[k], j+dx[k], n, s.fld);\n\t\tif(s.fld[i][j] == '#' && (cnt == 2 || cnt == 3))\n\t\t\tfld[i][j] = '#';\n\t\telse if(s.fld[i][j] == '.' && cnt == 3)\n\t\t\tfld[i][j] = '#';\n\t\telse if(s.fld[i][j] == '@')\n\t\t\tfld[i][j] = '@';\n\t\telse\n\t\t\tfld[i][j] = '.';\n\t}\n\tmemcpy(s.fld, fld, sizeof(fld));\n\treturn;\n}\n\nbool done(S &s, int n) {\n\tREP(i, n) REP(j, n)\n\t\tif(s.fld[i][j] == '#')\n\t\t\treturn false;\n\treturn true;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tS s;\n\t\tREP(i, n) REP(j, n) {\n\t\t\tcin >> s.fld[i][j];\n\t\t\tif(s.fld[i][j] == '@') {\n\t\t\t\ts.x = j; s.y = i;\n\t\t\t}\n\t\t}\n\t\ts.cnt = 0;\n\t\tqueue<S> q; q.push(s);\n\t\tset<string> ss;\n\n\t\tbool flg = false;\n\t\twhile(!q.empty()) {\n\t\t\ts = q.front(); q.pop();\n\t\t\tif(done(s, n)) {\n\t\t\t\tflg = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, 8) {\n\t\t\t\tint y = s.y + dy[i];\n\t\t\t\tint x = s.x + dx[i];\n\t\t\t\tif(!can_Move(y, x, n, s.fld)) continue;\n\t\t\t\tS s2(s);\n\t\t\t\tswap(s2.fld[y][x], s2.fld[s2.y][s2.x]);\n\t\t\t\ts2.y = y; s2.x = x;\n\n\t\t\t\tinfection(s2, n);\n\t\t\t\ts2.cnt++;\n\n\t\t\t\tstring str;\n\t\t\t\tREP(j, n) REP(k, n)\n\t\t\t\t\tstr += s2.fld[j][k];\n\t\t\t\tif(!ss.count(str)) {\n\t\t\t\t\tq.push(s2);\n\t\t\t\t\tss.insert(str);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flg? s.cnt : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N;\ninline bool infected(int S, int x, int y){\n  return S >> (y * N + x) & 1;\n}\nint next(int S, int bx, int by){\n  int NS = 0;\n  for(int y = 0; y < N; y++){\n    for(int x = 0; x < N; x++){\n      if(bx == x && by == y) continue;\n      int cnt = 0;\n      for(int r = 0; r < 8; r++){\n        if(valid(x + dx[r], y + dy[r], N, N) && infected(S, x + dx[r], y + dy[r]))cnt++;\n        if(bx == x + dx[r] && by == y + dy[r]) cnt++;\n        if(cnt >= 4) break;\n      }\n      if(infected(S, x, y) && (cnt == 2 || cnt == 3)) NS |= 1 << (y * N + x);\n      if(!infected(S, x, y) && cnt == 3) NS |= 1 << (y * N + x);\n    }\n  }\n  return NS;\n}\nvoid output(int bx, int by, int s, int t){\n  printf(\"time = %d:\\n\", t);\n  REP(y, 5){\n    REP(x, 5){\n      if(x == bx && y == by){\n        assert(!infected(s, x, y));\n        putchar('@');\n      }else if(infected(s, x, y)){\n        putchar('#');\n      }else{\n        putchar('.');\n      }\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n}\n\nint main(){\n  while(cin >> N && N){\n    vector<string> grid(N);\n    REP(i, N) cin >> grid[i];\n    int ss = 0, sx = 0, sy = 0;\n    REP(y, N) REP(x, N) {\n      if(grid[y][x] == '@'){\n        sx = x, sy = y;\n      }\n      if(grid[y][x] == '#'){\n        ss |= 1 << (y * N + x);\n      }\n    }\n    queue<int> qs, qx, qy;\n    qx.push(sx); qy.push(sy); qs.push(ss);\n    map<int, int> dist[5][5];\n    int ans = -1;\n    while(!qx.empty()){\n      int x = qx.front(), y = qy.front(), s = qs.front();\n      //output(x, y, s, dist[y][x][s]);\n      qx.pop(); qy.pop(); qs.pop();\n      if(s == 0){\n        ans = dist[y][x][s];\n        break;\n      }\n      REP(r, 8){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, N, N) && !infected(s, nx, ny)){\n          int ns = next(s, nx, ny);\n          if(!dist[ny][nx].count(ns)){\n            dist[ny][nx][ns] = dist[y][x][s] + 1;\n            qx.push(nx); qy.push(ny); qs.push(ns);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int dx[] = {-1, -1, -1, +0, +0, +1, +1, +1};\nconstexpr int dy[] = {-1, +0, +1, -1, +1, -1, +0, +1};\n\nbool is_goal(const vector<string>& f)\n{\n    int N = f.size();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (f[i][j] == '#') {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nbool in_field(int x, int y, int N)\n{\n    return (0 <= x && x < N && 0 <= y && y < N);\n}\n\nvector<string> next(int x, int y, const vector<string>& f)\n{\n    int N = f.size();\n    vector<string> nf = f;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {            \n            int cnt = 0;\n            for (int k = 0; k < 8; k++) {\n                int nx = j + dx[k], ny = i + dy[k];\n                if (!in_field(nx, ny, N)) continue;\n                if (f[ny][nx] == '#' || (nx == x && ny == y)) {\n                    cnt++;\n                }\n            }\n\n            if (f[i][j] == '#') {\n                nf[i][j] = ((cnt == 2 || cnt == 3) ? '#' : '.');\n            } else {\n                nf[i][j] = (j == x && i == y ? '@' : (cnt == 3 ? '#' : '.'));\n            }\n        }\n    } \n    return nf;\n}\n\nint bfs(int sx, int sy, const vector<string>& sf)\n{\n    int N = sf.size();\n    \n    queue<tuple<int, int, vector<string>>> Q;\n    queue<int> Qt;\n    \n    Q.push(make_tuple(sx, sy, sf));\n    Qt.push(0);    \n\n    set<vector<string>> closed;\n    \n    int x, y;\n    vector<string> f;\n    \n    while (!Q.empty()) {\n        tie(x, y, f) = Q.front(); Q.pop();\n        int t = Qt.front(); Qt.pop();\n        \n        if (is_goal(f)) return t;\n\n        for (int i = 0; i < 8; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (!in_field(nx, ny, N)) continue;\n            if (f[ny][nx] == '#') continue;            \n            \n            auto nf = next(nx, ny, f);\n            if (closed.count(nf) == 0) {\n                closed.insert(nf);\n                Q.push(make_tuple(nx, ny, nf));\n                Qt.push(t + 1);\n            }\n        }\n    }        \n    return -1;\n}\n\nint main()\n{\n    int N;\n    while (1) {\n        cin >> N;\n        if (N == 0) break;\n        vector<string> f(N);\n        int sx, sy;\n        for (int i = 0; i < N; i++) {\n            cin >> f[i];\n            for (int j = 0; j < N; j++) {\n                if (f[i][j] == '@') {\n                    sx = j; sy = i;\n                }\n            }\n        }\n        cout << bfs(sx, sy, f) << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\n#define INF 100000000\n\nint n;\nmap<pair<int,int>,int> dp;\nmap<pair<int,int>,bool> vis;\nmap<pair<int,int>,bool> now;\nmap<pair<int,int>,int> next;\nchar buf[25][25];\nint dx[] = {-1,0,1,-1,1,-1,0,1};\nint dy[] = {-1,-1,-1,0,0,1,1,1};\nint ans;\n\nint make(pair<int,int> p) {\n\tif (next.find(p)!=next.end()) return next[p];\n\tint mask = p.first;\n\tint pos = p.second;\n\tmask |= (1<<pos);\n\tint newmask = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tint k = i*n+j;\n\t\t\tint t = 0;\n\t\t\tif (j>0) {\n\t\t\t\tt += (mask&(1<<(k-1)))>0;\n\t\t\t\tif (i>0) t += (mask&(1<<(k-1-n)))>0;\n\t\t\t\tif (i<n-1) t += (mask&(1<<(k-1+n)))>0;\n\t\t\t}\n\t\t\tif (j<n-1) {\n\t\t\t\tt += (mask&(1<<(k+1)))>0;\n\t\t\t\tif (i>0) t += (mask&(1<<(k+1-n)))>0;\n\t\t\t\tif (i<n-1) t += (mask&(1<<(k+1+n)))>0;\n\t\t\t}\n\t\t\tif (i>0) t += (mask&(1<<(k-n)))>0;\n\t\t\tif (i<n-1) t += (mask&(1<<(k+n)))>0;\n\t\t\tif ((mask&(1<<k)) && k!=pos) {\n\t\t\t\tif (t==2 || t==3) {\n\t\t\t\t\tnewmask |= (1<<k);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (t==3 && k!=pos) {\n\t\t\t\t\tnewmask |= (1<<k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnext[p] = newmask;\n\treturn newmask;\n}\n\nvoid print(int m) {\n\tfor (int i=0; i<n;  i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tint k = i*n+j;\n\t\t\tif (m&(1<<k)) cout<<'#';\n\t\t\telse cout<<'.';\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\nint solve(int x, int y, int mask) {\n\t//cout<<x<<\" \"<<y<<\" \"<<mask<<endl;\n\t//print(mask);\n\t//cout<<endl;\n\t\n\tif (mask==0) return 0;\n\t\n\tqueue<pair<int,int> > q;\n\tq.push(make_pair(mask,x*n+y));\n\tq.push(make_pair(-1,-1));\n\tset<pair<int,int> > vis;\n\tvis.insert(make_pair(mask,x*n+y));\n\tint t = 1;\n\t\n\twhile (q.size()>1) {\n\t\tmask = q.front().first;\n\t\tx = q.front().second/n;\n\t\ty = q.front().second%n;\n\t\tq.pop();\n\t\tif (mask==-1) {\n\t\t\tt++;\n\t\t\tq.push(make_pair(-1,-1));\n\t\t}\n\t\t\t\n\t\tfor (int k=0; k<8; k++) {\n\t\t\tint u = x + dx[k];\n\t\t\tint v = y + dy[k];\n\t\t\tif (u<0 || u>=n) continue;\n\t\t\tif (v<0 || v>=n) continue;\n\t\t\tif (mask&(1<<(u*n+v))) continue;\n\t\t\n\t\t\tint m = make(make_pair(mask,u*n+v));\n\t\t\t\n\t\t\tif (m==0) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\t\n\t\t\tif (vis.insert(make_pair(m,u*n+v)).second) q.push(make_pair(m,u*n+v));\n\t\t\t\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d\",&n) && n!=0) {\n\t\tfor (int i=0; i<n; i++) scanf(\"%s\",buf+i);\n\t\t//for (int i=0; i<n; i++) cout<<buf[i]<<endl;\n\t\tint x,y;\n\t\tint mask = 0;\n\t\tfor (int i=0; i<n; i++) for (int j=0; j<n; j++) {\n\t\t\tif (buf[i][j]=='#') mask |= (1<<(i*n+j));\n\t\t\tif (buf[i][j]=='@') {\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t\tnow.clear();\n\t\tvis.clear();\n\t\tdp.clear();\n\t\tans = INF;\n\t\tans = solve(x,y,mask);\n\t\tif (ans >= INF) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N;\ninline bool infected(int S, int x, int y){\n  return S >> (y * N + x) & 1;\n}\nint next(int S, int bx, int by){\n  int NS = 0;\n  for(int y = 0; y < N; y++){\n    for(int x = 0; x < N; x++){\n      if(bx == x && by == y) continue;\n      int cnt = 0;\n      for(int r = 0; r < 8; r++){\n        if(valid(x + dx[r], y + dy[r], N, N) && infected(S, x + dx[r], y + dy[r]))cnt++;\n        if(bx == x + dx[r] && by == y + dy[r]) cnt++;\n        if(cnt >= 4) break;\n      }\n      if(infected(S, x, y) && (cnt == 2 || cnt == 3)) NS |= 1 << (y * N + x);\n      if(!infected(S, x, y) && cnt == 3) NS |= 1 << (y * N + x);\n    }\n  }\n  return NS;\n}\nvoid output(int bx, int by, int s, int t){\n  printf(\"time = %d:\\n\", t);\n  REP(y, 5){\n    REP(x, 5){\n      if(x == bx && y == by){\n        assert(!infected(s, x, y));\n        putchar('@');\n      }else if(infected(s, x, y)){\n        putchar('#');\n      }else{\n        putchar('.');\n      }\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n}\n\nint main(){\n  while(cin >> N && N){\n    vector<string> grid(N);\n    REP(i, N) cin >> grid[i];\n    int ss = 0, sx = 0, sy = 0;\n    REP(y, N) REP(x, N) {\n      if(grid[y][x] == '@'){\n        sx = x, sy = y;\n      }\n      if(grid[y][x] == '#'){\n        ss |= 1 << (y * N + x);\n      }\n    }\n    queue<int> qs, qx, qy;\n    qx.push(sx); qy.push(sy); qs.push(ss);\n    int t = 0;\n    qx.push(-1); qy.push(-1); qs.push(-1);\n    set<int> visit[5][5];\n    int ans = -1;\n    while(qx.size() > 1){\n      int x = qx.front(), y = qy.front(), s = qs.front();\n      qx.pop(); qy.pop(); qs.pop();\n      if(s == 0){\n        ans = t;\n        break;\n      }\n      if(s == -1){\n        t++;\n        qx.push(-1); qy.push(-1); qs.push(-1);\n        continue;\n      }\n      REP(r, 8){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, N, N) && !infected(s, nx, ny)){\n          int ns = next(s, nx, ny);\n          if(visit[ny][nx].insert(ns).second){\n            qx.push(nx); qy.push(ny); qs.push(ns);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\nstruct node{\n\tvs f;\n\tpii pos;\n\tnode(vs &f,pii &pos):f(f),pos(pos){}\n\tstring to_s() const{\n\t\tint n=f.size();\n\t\tstring ret; \n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tret+=pos.first==i&&pos.second==j?'@':f[i][j];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tbool operator<(const node &other)const{\n\t\treturn to_s()<other.to_s();\n\t}\n};\nint dy[]={-1,-1,-1,0,1,1,1,0};\nint dx[]={-1,0,1,1,1,0,-1,-1};\n\nvs change(vs &f,int y,int x){\n\tint n=f.size();\n\tvs nf(f);\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(y==i&&x==j)continue;\n\t\t\tint cnt=0;\n\t\t\tREP(d,8){\n\t\t\t\tint yy=i+dy[d];\n\t\t\t\tint xx=j+dx[d];\n\t\t\t\tif(yy>=0&&xx>=0&&yy<n&&xx<n){\n\t\t\t\t\tcnt+=f[yy][xx]=='#'||(y==yy&&x==xx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch(f[i][j]){\n\t\t\tcase '.':\n\t\t\t\tnf[i][j]=cnt==3?'#':'.';\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tnf[i][j]=(cnt==2||cnt==3?'#':'.');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t}\n\t}\n\treturn nf;\n}\n\nbool done(vs &f){\n\tint n=f.size();\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(f[i][j]=='#'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tvs f(N);\n\t\tpii p;\n\t\tREP(i,N){\n\t\t\tcin>>f[i];\n\t\t\tREP(j,N){\n\t\t\t\tif(f[i][j]=='@'){\n\t\t\t\t\tp=make_pair(i,j);\n\t\t\t\t\tf[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<node> q;\n\t\tmap<node,int> cost;\n\t\tq.push(node(f,p));\n\t\tcost[node(f,p)]=0;\n\t\tint ans=-1;\n\t\twhile(q.size()){\n\t\t\tnode n=q.front();q.pop();\n\t\t\tif(done(n.f)){\n\t\t\t\tans=cost[n];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(d,8){\n\t\t\t\tint y=n.pos.first+dy[d];\n\t\t\t\tint x=n.pos.second+dx[d];\n\t\t\t\tif(y>=0&&x>=0&&y<N&&x<N){\n\t\t\t\t\tif(n.f[y][x]=='.'){\n\t\t\t\t\t\tvs &nf=change(n.f,y,x);\n\t\t\t\t\t\tnode nnode(nf,make_pair(y,x));\n\t\t\t\t\t\tif(!EXIST(cost,nnode)){\n\t\t\t\t\t\t\tcost[nnode]=cost[n]+1;\n\t\t\t\t\t\t\tq.push(nnode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate<typename T1, typename T2>\nvoid chmax(T1 &a, const T2 &b) {\n  if (a < b) a = b;\n}\ntemplate<typename T1, typename T2>\nvoid chmin(T1 &a, const T2 &b) {\n  if (a > b) a = b;\n}\ntemplate<typename T>\nvoid printv(const vector<T> &s) {\n  for (int i = 0; i < (int) (s.size()); ++i) {\n    cout << s[i];\n    if (i != (int) (s.size()) - 1) cout << \" \";\n  }\n  cout << \"\\n\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nstruct RollingHash {\n  const int base = 9973;\n  const int mod[2] = {999999937, 1000000007};\n  vector<int> s;\n  vector<ll> hash[2], pow[2];\n  template<class S>\n  RollingHash(const S &s) {\n    int n = s.size();\n    for (int id = 0; id < 2; ++id) {\n      hash[id].assign(n+1, 0);\n      pow[id].assign(n+1, 1);\n      for (int i = 0; i < n; ++i) {\n        hash[id][i+1] = (hash[id][i] * base + s[i]) % mod[id];\n        pow[id][i+1] = pow[id][i] * base % mod[id];\n      }\n    }\n  }\n  pair<ll,ll> get(int l, int r) {\n    ll ret[2];\n    for (int id = 0; id < 2; ++id) {\n      ret[id] = hash[id][r] - hash[id][l] * pow[id][r - l] % mod[id];\n      if (ret[id] < 0) ret[id] += mod[id];\n    }\n    return { ret[0], ret[1] };\n  }\n};\nstruct Elm {\n  int d, r, c;\n  ll hash;\n  vector<string> v;\n};\nbool operator<(const Elm &e1, const Elm &e2) {\n  return e1.d > e2.d;\n}\nbool solve() {\n  int n;\n  cin >> n;\n  if (n == 0) return false;\n  vector<string> in(n);\n  int r = -1, c = -1;\n  int cnt = 0;\n  for(int i=0;i<n;++i) {\n    cin >> in[i];\n    for(int j=0;j<n;++j) {\n      if (in[i][j] == '@') r = i, c = j;\n      cnt += in[i][j] == '#';\n    }\n  }\n  if(cnt == 0) {\n    cout << 0 << endl;\n    return true;\n  }\n  map<ll, int> mp;\n  queue<Elm> pq;\n  ll hash = 0;\n  ll now = 1;\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<n;++j) {\n      hash += now * in[i][j];\n      hash %= MOD;\n      now *= 998244353;\n      now %= MOD;\n    }\n  }\n  mp[hash] = 0;\n  pq.push({0, r, c, hash, in});\n  vi dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};\n  vi dr2 = {1, 1, 0, -1, -1, -1, 0, 1}, dc2 = {0, -1, -1, -1, 0, 1, 1, 1};\n  ll ans = -1;\n  while (!pq.empty()) {\n    auto now = pq.front();\n    pq.pop();\n    int d = now.d, r = now.r, c = now.c;\n    ll hash = now.hash;\n    auto v = now.v;\n    if (mp.find(hash) != mp.end() && mp[hash] < d) continue;\n    for(int i=0;i<8;++i) {\n      if(ans != -1) break;\n      vector<string> nxt(n);\n      for(int j=0;j<n;++j) {\n        nxt[j].assign(n, '.');\n      }\n      int nr = r + dr2[i], nc = c + dc2[i];\n      if (!(0 <= nr && nr < n && 0 <= nc && nc < n) || v[nr][nc] == '#') continue;\n      nxt[nr][nc] = '@';\n      int cnt_sharp = 0;\n      for(int j=0;j<n;++j) {\n        for(int k=0;k<n;++k) {\n          int cnt = 0;\n          for(int l=0;l<8;++l) {\n            int adjr = j + dr2[l], adjc = k + dc2[l];\n            if (0 <= adjr && adjr < n && 0 <= adjc && adjc < n) {\n              cnt += v[adjr][adjc] == '#' || nxt[adjr][adjc] == '@';\n            }\n          }\n          if ((v[j][k] == '#' && (cnt == 2 || cnt == 3)) ||\n              ((v[j][k] == '.' || v[j][k] == '@') && nxt[j][k] != '@' && cnt == 3)) {\n            nxt[j][k] = '#';\n            cnt_sharp++;\n          }\n        }\n      }\n      ll nxthash = 0;\n      ll nowmul = 1;\n      for(int i=0;i<n;++i) {\n        for(int j=0;j<n;++j) {\n          nxthash += nowmul * nxt[i][j];\n          nxthash %= MOD;\n          nowmul *= 998244353;\n          nowmul %= MOD;\n        }\n      }\n      if (mp.find(nxthash) == mp.end() || mp[nxthash] > d + 1) {\n        if(cnt_sharp == 0) {\n          ans = d+1;\n          break;\n        }\n        mp[nxthash] = d + 1;\n        pq.push({d + 1, nr, nc, nxthash, nxt});\n      }\n    }\n  }\n  cout << (ans == LINF ? -1 : ans) << endl;\n  return true;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while (1) {\n    if (!solve()) break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint dx[]={0,-1,0,1,-1,-1,1,1};\nint dy[]={-1,0,1,0,-1,1,-1,1};\n\nclass State\n{\npublic:\n\tint h,c,x,y;\n\n\tState(int x, int y, int h, int c)\n\t\t:h(h),c(c),x(x),y(y)\n\t{}\n};\n\nbool tf[5][5],hs[25][(1<<25)];\n\nint ch(bool f[5][5],int N)\n{\n\tint ret=0,cnt=0;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t{\n\t\tret|=(f[j][i]<<cnt);\n\t\tcnt++;\n\t}\n\n\treturn ret;\n}\n\nvoid mov(int x, int y, bool f[5][5], int N)\n{\n\tmemset(tf,0,sizeof(tf));\n\tf[x][y]=1;\n\tint cnt[5][5]={0};\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t{\n\t\tif(!f[j][i]) continue;\n\t\tfor(int k=0; k<8; k++)\n\t\t{\n\t\t\tint tx=j+dx[k], ty=i+dy[k];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N) continue;\n\n\t\t\tcnt[tx][ty]++;\n\t\t}\n\t}\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t{\n\t\tif(f[j][i]&&(cnt[j][i]==2||cnt[j][i]==3)) \n\t\t{\n\t\t\ttf[j][i]=1;\n\t\t}\n\t\tif(!f[j][i]&&cnt[j][i]==3)\n\t\t{\n\t\t\ttf[j][i]=1;\n\t\t}\n\t}\n\n\ttf[x][y]=0;\n\tf[x][y]=0;\n}\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tmemset(hs,0,sizeof(hs));\n\t\tbool f[5][5]={0};\n\t\tint sx,sy;\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin.ignore();\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c=='@')\n\t\t\t\t{\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(c=='#') f[j][i]=1;\n\t\t\t}\n\t\t}\n\n\t\tqueue<State> q;\n\t\tq.push(State(sx,sy,ch(f,N), 0));\n\n\t\tint ans=-1;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tState s=q.front(); q.pop();\n\t\t\tif(s.h==0)\n\t\t\t{\n\t\t\t\tans=s.c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbool sf[5][5];\n\t\t\tint tcnt=0;\n\t\t\tfor(int i=0; i<N; i++)\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tsf[j][i]=(s.h&(1<<tcnt));\n\t\t\t\ttcnt++;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<8; i++)\n\t\t\t{\n\t\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\t\tif(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t\t\t\tif(sf[tx][ty]) continue;\n\n\t\t\t\tmov(tx,ty,sf,N);\n\t\t\t\tint h=ch(tf,N);\n\t\t\t\tif(hs[tx*5+ty][h]) continue;\n\t\t\t\ths[tx*5+ty][h]=1;\n\n\t\t\t\tq.push(State(tx,ty, h, s.c+1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b) : value(((a% b) + 2 * b) % b), mod(b) {\n\n    }\n    modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int long long\n\nvoid solve() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0)return;\n        int cnt = 0;\n        REP(i, n) {\n            string s;\n            cin >> s;\n            REP(q, n) {\n                if (s[q] == '#') {\n                    cnt += (1 << (i * n + q + 5));\n                }\n                else if (s[q] == '@') {\n                    cnt += i * n + q;\n                }\n            }\n        }\n        set<int> gogo;\n        gogo.insert(cnt);\n        queue<pair<int, int>> next;\n        next.push(mp(cnt, 0));\n        int ans = -1;\n        while (next.empty() == false) {\n            pair<int, int> now = next.front();\n            next.pop();\n            int grid[5][5] = {};\n            int cnt = 0;\n            REP(i, n) {\n                REP(q, n) {\n                    if ((1LL << (i * n + q + 5)) & now.first) {\n                        grid[i][q] = 1;\n                        cnt++;\n                    }\n                }\n            }\n            if (cnt == 0) {\n                ans = now.second;\n                break;\n            }\n            const int dx[8] = { 1,1,1,0,0,-1,-1,-1 };\n            const int dy[8] = { 1,0,-1,1,-1,1,0,-1 };\n            pair<int, int> place = mp((now.first % (1 << 5)) / n, (now.first % (1 << 5)) % n);\n            REP(q, 8) {\n                int x = place.first + dx[q];\n                int y = place.second + dy[q];\n                if (x >= 0 && x < n && y >= 0 && y < n&&grid[x][y]  == 0) {\n                    grid[x][y] = 1;\n                    int tmp = x * n + y;\n                    REP(j, n) {\n                        REP(t, n) {\n                            if (j == x && t == y) continue;\n                            int cnter = 0;\n                            REP(p, 8) {\n                                int next_x = j + dx[p];\n                                int next_y = t + dy[p];\n                                if (next_x >= 0 && next_x < n && next_y >= 0 && next_y < n) {\n                                    cnter += grid[next_x][next_y];\n                                }\n                            }\n                            int doing = 0;\n                            if (grid[j][t] == 1) {\n                                if (cnter >= 2 && cnter <= 3) {\n                                    doing = 1;\n                                }\n                            }\n                            else {\n                                if (cnter == 3) {\n                                    doing = 1;\n                                }\n                            }\n                            tmp += doing * (1LL << (5 + j * n + t));\n                        }\n                    }\n                    if (gogo.count(tmp) == 0) {\n                        gogo.insert(tmp);\n                        next.push(mp(tmp, now.second + 1));\n                    }\n                    grid[x][y] = 0;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<vector<char> >,int> P;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nint n;\nmap<P, int> m;\nint dx[8] = {1,0,-1,1,-1,1,0,-1};\nint dy[8] = {1,1,1,0,0,-1,-1,-1};\n\nbool check(vector<vector<char> > hoge){\n    int cnt = 0;\n    rep(i,hoge.size()){\n        rep(j,hoge[i].size()){\n            if(hoge[i][j] == '#'){\n                cnt++;\n            }\n        }\n    }\n    if(cnt == 0) return true;\n    else return false;\n}\n\nP simulate(vector<vector<char> > bo, int x, int y){\n    rep(i,bo.size()){\n        rep(j,bo[i].size()){\n            if(bo[i][j] == '@'){\n                bo[i][j] = '.';\n            }\n        }\n    }\n    bo[x][y] = '@';\n    P ret;\n    ret.second = x*n+y;\n    ret.first = bo;\n    rep(i,bo.size()){\n        rep(j,bo[i].size()){\n            if(i == x && j == y) continue;\n            int sur = 0;\n            if(bo[i][j] == '.'){\n                rep(k,8){\n                    if(0>i+dx[k]||i+dx[k]>=n||0>j+dy[k]||j+dy[k]>=n) continue;\n                    if(bo[i+dx[k]][j+dy[k]] != '.'){\n                        sur++;\n                    }\n                }\n                if(sur == 3) ret.first[i][j] = '#';\n            } else{\n                rep(k,8){\n                    if(0>i+dx[k]||i+dx[k]>=n||0>j+dy[k]||j+dy[k]>=n) continue;\n                    if(bo[i+dx[k]][j+dy[k]] != '.'){\n                        sur++;\n                    }\n                }\n                if(sur != 2 && sur != 3) ret.first[i][j] = '.';\n            }\n        }\n    }\n    return ret;\n}\n\nvoid solve(){\n    vector<vector<char> > b;\n    int now = 0;\n    rep(i,n){\n        vector<char> hoge;\n        rep(j,n){\n            char tmp;\n            cin >> tmp;\n            if(tmp == '@') now = i*n+j;\n            hoge.push_back(tmp);\n        }\n        b.push_back(hoge);\n    }\n    m.clear();\n    m[P(b,now)] = 0; \n    queue<P> que;\n    que.push(P(b,now));\n    while(!que.empty()){\n        P p = que.front();\n        vector<vector<char> > bo = p.first;\n        if(check(bo)){\n            cout << m[p] << endl;\n            return;\n        }\n        que.pop();\n        int nx = p.second/n, ny = p.second%n;\n        rep(i,8){\n            if(0>nx+dx[i]||nx+dx[i]>=n||0>ny+dy[i]||ny+dy[i]>=n) continue;\n            if(bo[nx+dx[i]][ny+dy[i]] != '.') continue;\n            P neb = simulate(bo,nx+dx[i],ny+dy[i]);\n            if(m.count(neb)) continue;\n            m[neb] = m[p]+1;\n            que.push(neb);\n        }\n    }\n    cout << -1 << endl;\n}\n\nint main(){\n    while(cin >> n){\n        if(n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<cassert>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint dx[8] = {0, 1, 0, -1, -1, -1, 1, 1};\nint dy[8] = {1, 0, -1, 0, -1, 1, 1, -1};\nint n;\n\nbool iseliminate(string mp) {\n    int i,j;\n    rep(i,mp.length()) if(mp[i] == '#') return false;\n    return true;\n}\n\npair<int,int> getPos(string mp) {\n    int i,j;\n    rep(i,mp.length())\n        if(mp[i] == '@') return make_pair(i/n,i%n);\n}\n\nstring update(string &mp) {\n    int i,j,k;\n    string tmp = mp;\n\n    rep(i,n) rep(j,n) {\n        int adj = 0;\n        if(mp.at(i*n+j) == '@') continue;\n        rep(k,8) {\n            if(i+dy[k] < 0 || i+dy[k] >= n) continue;\n            if(j+dx[k] < 0 || j+dx[k] >= n) continue;\n            if(mp.at((i+dy[k])*n+(j+dx[k])) == '#') adj++;\n        }\n        if(mp.at(i*n+j) == '#') {\n            if(adj == 2 || adj == 3) continue;\n            else tmp.at(i*n+j) = '.';\n            //cout<<\"eliminated !!\"<<endl;\n        }else{\n            if(adj == 3) tmp.at(i*n+j) = '#';\n        }\n    }\n    return tmp;\n}\n\nint bfs(string bmap) {\n    int i,j;\n    queue<pair<int,string > >Q;\n    set<string> memo;\n    memo.insert(bmap);\n    Q.push(make_pair(0,bmap));\n    while(!Q.empty()) {\n        string nmap = Q.front().second;\n        int ii = Q.front().first;\n        Q.pop();\n\n\n        // cout<<ii<<endl;\n        // rep(i,n) cout<<nmap.substr(i*n,n)<<endl;\n        // cout<<endl;\n\n        if(iseliminate(nmap)) return ii;\n\n        pair<int,int> pos = getPos(nmap);\n        for(int i=0; i<8; ++i) {\n            if(pos.first+dy[i] < 0 || pos.first+dy[i] >= n) continue;\n            if(pos.second+dx[i] < 0 || pos.second+dx[i] >= n) continue;\n            if(nmap.at((pos.first+dy[i])*n+(pos.second+dx[i])) == '#') continue;\n            string next = nmap;\n            next.at((pos.first+dy[i])*n+pos.second+dx[i]) = '@';\n            next.at((pos.first)*n+pos.second) = '.';\n            next = update(next);\n            if(memo.find(next) != memo.end()) continue;\n            memo.insert(next);\n            Q.push(make_pair(ii+1, next));\n        }\n    }\n    return -1;\n    assert(false);\n}\n\nint main() {\n    while(cin>>n, n) {\n        string imap = \"\",tmp;\n        for(int i=0; i<n; ++i) {\n            cin>>tmp;\n            imap += tmp;\n        }\n        cout<<bfs(imap)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nstruct data{\n  uint x : 3;\n  uint y : 3;\n  uint b : 26;\n\n  inline data() : x(0), y(0), b(0) {}\n  inline data(uint xx, uint yy, uint bb) : x(xx), y(yy), b(bb) {}\n  inline operator bool () { return b != (1<<26) - 1; }\n  void printa(int n){\n    REP(i,n){\n      REP(j,n){\n        if(x == j && y == i) printf(\"@\");\n        else printf(\"%c\",((1<<(i*n+j))&b) ? '#' : '.');\n      }\n      puts(\"\");\n    }\n  }\n}__attribute__((packed));\n\ndata m = data(0,0,(1<<26)-1);\n\n#define print(x) printf(\"%d\\n\",x)\nconst int _dx[] = {-1,-1,-1,0,0,1,1,1};\nconst int _dy[] = {-1,0,1,-1,1,-1,0,1};\n\nint main(){\n  int n;\n  while(scanf(\"%d \",&n), n){\n    data init; init.b = 0;\n\n    REP(i,n){\n      char buff[10];\n      scanf(\"%s \",buff);\n      REP(j,n){\n        switch(buff[j]){\n        case '.': break;\n        case '#': init.b |= (1<<(i*n+j)); break;\n        case '@': init.x = j; init.y = i; break;\n        }\n      }\n    }\n\n    //    init.printa(n);\n\n    int ans = 0;\n    const int th = 12;\n    queue<data> q;\n    q.push(init); q.push(m);\n\n    while(q.size() != 1){\n      data d = q.front();\n      q.pop();\n\n      if(!d){\n        ans++;\n        q.push(m);\n        //printf(\"ans: %d\\n\",ans);\n        continue;\n      }\n\n      if(ans > th)\n        break;\n\n      if(d.b == 0){\n        print(ans);\n        break;\n      }\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n      REP(i,8){\n        int xx = (int)d.x + _dx[i];\n        int yy = (int)d.y + _dy[i];\n        if(ISIN(xx,yy,n,n) && (d.b & (1<<(yy*n+xx))) == 0){\n          data dd(xx,yy,0);\n          REP(y,n) REP(x,n) if(y != yy || x != xx){\n            int cnt = 0;\n            REP(j,8){\n              int xxx = x + _dx[j];\n              int yyy = y + _dy[j];\n              if(ISIN(xxx,yyy,n,n) && (d.b & (1<<(yyy*n+xxx))))\n                cnt++;\n              else if(xx == xxx && yy == yyy) cnt++;\n            }\n            if(d.b & (1<<(y*n+x))){\n              if(cnt == 2 || cnt == 3) dd.b |= (1<<(y*n+x));\n            }else{\n              if(cnt == 3) dd.b |= (1<<(y*n+x));\n            }\n          }\n          q.push(dd);\n        }\n      }\n\n    }\n\n    if(ans > th) print(-1);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n\n#define msn(x) (memset((x),0,sizeof((x))))\n#define msx(x) (memset((x),0x7f,sizeof((x))))\n#define fuck(x) cerr << #x << \" <- \" << x << endl\n#define acer cout<<\"sb\"<<endl\ntypedef long long ll;\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define eps 1e-8\n#define pi acos(-1.0)\nstruct node\n{\n    char mp[7][7];\n    int time;\n    int x,y;\n    ll hs;\n} beg;\n\nint n;\nconst int dx[8]= {-1,-1,-1,0,1,1,1,0};\nconst int dy[8]= {-1, 0, 1,1,1,0,-1,-1};\ninline bool in(int x,int y)\n{\n    return (x>=1&&y<=n&&x<=n&&y>=1);\n}\nint solve(ll cmp)\n{\n    set<ll>s;\n    cmp=cmp*100+beg.x*10+beg.y;\n    beg.hs=cmp;\n  //  printf(\"%lld\\n\",cmp);\n    s.insert(cmp);\n    queue<node>q;\n    q.push(beg);\n    while(!q.empty())\n    {\n        node now=q.front();\n        q.pop();\n        if(now.hs<100)return now.time;\n        node nxt;\n        int tot=0;\n        nxt.time=now.time+1;\n        for(int i=0; i<8; i++)\n        {\n            int x=now.x+dx[i];\n            int y=now.y+dy[i];\n            if(in(x,y)&&now.mp[x][y]=='.')\n            {\n                nxt.x=x;\n                nxt.y=y;\n                swap(now.mp[x][y],now.mp[now.x][now.y]);\n                ll hs=0;\n                for(int i=1; i<=n; i++)\n                {\n                    for(int j=1; j<=n; j++)\n                    {\n                        int sz=0;\n                        for(int k=0; k<8; k++)if(now.mp[i+dx[k]][j+dy[k]]=='#'||now.mp[i+dx[k]][j+dy[k]]=='@')sz++;\n                        if(now.mp[i][j]=='#')\n                        {\n                            if(sz<=3&&sz>=2)\n                            hs|=(1<<((i-1)*n+j-1)),nxt.mp[i][j]='#';\n                            else nxt.mp[i][j]='.';\n                        }else\n                        if(now.mp[i][j]=='.')\n                        {\n                            if(sz==3)nxt.mp[i][j]='#',hs|=(1<<((i-1)*n+j-1));\n                            else nxt.mp[i][j]='.';\n                        }\n                        else nxt.mp[i][j]=now.mp[i][j];\n                    }\n                }\n                hs=hs*100+x*10+y;\n                nxt.hs=hs;\n                if(s.find(hs)==s.end())\n                {\n                    s.insert(hs);\n                    q.push(nxt);\n                }\n                swap(now.mp[x][y],now.mp[now.x][now.y]);\n            }\n        }\n    }\n    return -1;\n}\nint main()\n{\n    while(1)\n    {\n        scanf(\"%d\",&n);\n        if(n==0)break;\n        for(int i=1; i<=n; i++)scanf(\"%s\",beg.mp[i]+1);\n        beg.time=0;\n        ll cmp=0;\n        for(int i=1; i<=n; i++)\n        {\n            for(int j=1; j<=n; j++)\n            {\n                if(beg.mp[i][j]=='#')cmp=(cmp|(1<<((i-1)*n+j-1)));\n                if(beg.mp[i][j]=='@')beg.x=i,beg.y=j;\n            }\n        }\n        printf(\"%d\\n\",solve(cmp));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <deque>\n#include <algorithm>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n\n#define MP make_pair\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//AOJ 1304\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={-1,0,1,-1,1,-1,0,1};\n\nset<int> vsi;\nint n;\n\ninline int getx(int a){return (a>>25 & 7);}\ninline int gety(int a){return (a>>28 & 7);}\ninline int getidx(int x, int y){return y*n+x;}\ninline int getstate(int a, int x, int y){return ((a>>getidx(x,y))&1);}\ninline int setstate(int a, int x, int y, int state){\n\tif(state){\n\t\treturn a|(1<<getidx(x,y));\n\t}else{\n\t\tint p=1<<getidx(x,y);\n\t\tp = ~p;\n\t\treturn a&p;\n\t}\n}\ninline int setpos(int a, int x, int y){\n\tint ret=a;\n\tret &= ((1<<25)-1);\n\tret |= x<<25;\n\tret |= y<<28;\n\treturn ret;\n}\n\ninline int count(int b){\n\tint ret = 0;\n\tREP(i,n)REP(j,n)if(getstate(b,i,j))ret++;\n\treturn ret-1;\n}\n\ninline int step(int &b){\n\tint tb = b;\n\tint ret = 0;\n\tint x=getx(b);\n\tint y=gety(b);\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(y==i&&x==j)continue;\n\t\t\tint cnt = 0;\n\t\t\tREP(k,8){\n\t\t\t\tint ny=i+dy[k];\n\t\t\t\tint nx=j+dx[k];\n\t\t\t\tif(nx<0 || ny<0 || nx>=n || ny>=n)continue;\n\t\t\t\tif(getstate(tb,nx,ny))cnt++;\n\t\t\t}\n\t\t\tif(getstate(tb,j,i)){\n\t\t\t\tif(cnt!=2&&cnt!=3)b=setstate(b,j,i,0);\n\t\t\t}else if(!getstate(tb,j,i)){\n\t\t\t\tif(cnt==3)b=setstate(b,j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>n, n){\n\t\tvsi.clear();\n\t\tstring b;\n\t\tREP(i,n){\n\t\t\tstring tmp;\n\t\t\tcin>>tmp;\n\t\t\tb+=tmp;\n\t\t}\n\t\tint is=0;\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tswitch(b[i*n+j]){\n\t\t\t\tcase '@':\n\t\t\t\t\tis = setpos(is, j, i);\n\t\t\t\tcase '#':\n\t\t\t\t\tis |= (1LL<<i*n+j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int> > q;\n\t\tq.push(MP(0,is));\n\t\tint ans=-1;\n\t\twhile(!q.empty()){\n\t\t\tint x,y;\n\t\t\tpair<int, int> tmp=q.front();\n\t\t\tq.pop();\n\t\t\tif(EXIST(vsi,tmp.second))continue;\n\t\t\tvsi.insert(tmp.second);\n\t\t\tif(count(tmp.second)==0){\n\t\t\t\tans=tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = getx(tmp.second);\n\t\t\ty = gety(tmp.second);\n\t\t\tREP(i,8){\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(nx<0 || ny<0 || nx>=n || ny>=n || getstate(tmp.second, nx, ny)==1)continue;\n\t\t\t\tint tb = tmp.second;\n\t\t\t\ttb=setstate(tb,x,y,0);\n\t\t\t\ttb=setstate(tb,nx,ny,1);\n\t\t\t\ttb=setpos(tb,nx,ny);\n\t\t\t\tstep(tb);\n\t\t\t\tif(EXIST(vsi,tb))continue;\n\t\t\t\tq.push(MP(tmp.first+1, tb));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<set>\nusing namespace std;\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,-1,0};\nchar str[7][7];\nint tmp[7][7];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tint row,col;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(str[i][j]=='@'){\n\t\t\trow=i;col=j;str[i][j]='.';\n\t\t}\n\t\tset<pair<int,pair<int,int> > >S;\n\t\tint s=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\ts*=2;\n\t\t\tif(str[i][j]=='#')s++;\n\t\t}\n\t\tS.insert(make_pair(s,make_pair(row,col)));\n\t\tqueue<pair<pair<int,int>,pair<int,int> > >Q;\n\t\tQ.push(make_pair(make_pair(0,s),make_pair(row,col)));\n\t\tbool yet=true;\n\t\twhile(Q.size()){\n\t\t\tint cost=Q.front().first.first;\n\t\t\tint at=Q.front().first.second;\n\t\t\tint r=Q.front().second.first;\n\t\t\tint c=Q.front().second.second;\n\t\t\tQ.pop();\n//\t\t\tprintf(\"%d %d %d %d\\n\",cost,at,r,c);\n\t\t\tif(at==0){\n\t\t\t\tyet=false;\n\t\t\t\tprintf(\"%d\\n\",cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint t=at;\n\t\t\tfor(int i=a-1;i>=0;i--)for(int j=a-1;j>=0;j--){\n\t\t\t\ttmp[i][j]=t%2;\n\t\t\t\tt/=2;\n\t\t\t}\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tint tr=r+dx[i];int tc=c+dy[i];\n\t\t\t\tif(tr<0||tr>=a||tc<0||tc>=a)continue;\n\t\t\t\tif(tmp[tr][tc])continue;\n\t\t\t\ttmp[tr][tc]=1;\n\t\t\t\tint num=0;\n\t\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<a;k++){\n\t\t\t\t\tint val=0;\n\t\t\t\t\tfor(int l=0;l<8;l++)if(j+dx[l]>=0&&j+dx[l]<a&&k+dy[l]>=0&&k+dy[l]<a&&tmp[j+dx[l]][k+dy[l]])val++;\n\t\t\t\t\tnum*=2;\n\t\t\t\t\tif(tr==j&&tc==k)continue;\n\t\t\t\t\tif(tmp[j][k]&&(val==2||val==3))num++;\n\t\t\t\t\tif(!tmp[j][k]&&val==3)num++;\n\t\t\t\t}\n\t\t\t\tif(!S.count(make_pair(num,make_pair(tr,tc)))){\n\t\t\t\t\tS.insert(make_pair(num,make_pair(tr,tc)));\n\t\t\t\t\tQ.push(make_pair(make_pair(cost+1,num),make_pair(tr,tc)));\n\t\t\t\t}\n\t\t\t\ttmp[tr][tc]=0;\n\t\t\t}\n\t\t}\n\t\tif(yet)printf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n#include<unordered_map>\nclass HashVI {  // ???????????\\??¢??°???????????§??????\npublic:\n\tsize_t operator()(const vector<vector<int>> &x) const {\n\t\tsize_t t = 0;\n\t\tint num = 1;\n\t\tint two;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tif (x[i][j] == 2) {\n\t\t\t\t\ttwo = i * 5 + j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tt = t + num*x[i][j];\n\t\t\t\t}\n\t\t\t\tnum *= 2;\n\t\t\t}\n\t\t}\n\t\tt += num*two;\n\t\treturn t;\n\t}\n};\n\nunordered_map<vector<vector<int>>, int,HashVI>mp;\n\nstruct aa {\n\tint nx;\n\tint ny;\n\tvector<vector<int>>afield;\n\tint time;\n};\nint N;\nint dx[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\nint dy[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\nbool ok(int x, int y) {\n\treturn x >= 0 && x < N&&y >= 0 && y < N;\n}\nint ans;\nvector<vector<int>>update(int newx, int newy, const vector<vector<int>>& nowf) {\n\tvector<vector<int>>newf(N, vector<int>(N));\n\tbool aok = true;\n\tnewf[newy][newx] = 2;\n\tfor (int ay = 0; ay < N; ++ay) {\n\t\tfor (int ax = 0; ax < N; ++ax) {\n\t\t\tif (ay == newy&&ax == newx) {\n\t\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\tint vnum = 0;\n\t\t\t\tfor (int d = 0; d < 8; ++d) {\n\t\t\t\t\tint newax = ax + dx[d];\n\t\t\t\t\tint neway = ay + dy[d];\n\t\t\t\t\tif (ok(newax, neway) && (nowf[neway][newax]==1||newf[neway][newax]==2)) {\n\t\t\t\t\t\tvnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vnum == 2 && nowf[ay][ax] == 1) {\n\t\t\t\t\tnewf[ay][ax] = 1;\n\t\t\t\t\taok = false;\n\t\t\t\t}\n\t\t\t\telse if (vnum == 3) {\n\t\t\t\t\tnewf[ay][ax] = 1;\n\t\t\t\t\taok = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewf[ay][ax] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (aok) {\n\t\tthrow(0);\n\t}\n\treturn newf;\n}\nint main() {\n\twhile (1) {\n\t\tans = -1;\n\t\tmp.clear();\n\t\tcin >> N;\n\t\tint sx, sy;\n\t\tvector<vector<int>>field(N, vector<int>(N));\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (st[j] == '@') {\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == '#')field[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tmp[field] = 0;\n\t\tbool aaok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (field[i][j] == 1) {\n\t\t\t\t\taaok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (aaok) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<aa>que;\n\t\tque.push({ sx,sy,field,0 });\n\t\twhile (que.size()) {\n\t\t\taa atop(que.front());\n\t\t\tque.pop();\n\t\t\tint nowx = atop.nx;\n\t\t\tint nowy = atop.ny;\n\t\t\tauto nowf = atop.afield;\n\n\t\t\ttry {\n\t\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tint newx = nowx + dx[i];\n\t\t\t\tint newy = nowy + dy[i];\n\t\t\t\tif (ok(newx, newy) && nowf[newy][newx]==0) {\n\t\t\t\t\t\tvector<vector<int>>newf(update(newx, newy, nowf));\n\t\t\t\t\t\tif (mp.find(newf) == mp.end()) {\n\t\t\t\t\t\t\tmp[newf] = atop.time + 1;\n\t\t\t\t\t\t\tque.push(aa{ newx,newy,newf,atop.time + 1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (...) {\n\t\t\t\tans = atop.time + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\ninline int calc_hash(const data &D){\n\tint res=(47*D.S+53)&((1<<24)-1);\n\tres=res*(59*D.x+61)&((1<<24)-1);\n\tres=res*(67*D.y+71)&((1<<24)-1);\n\treturn res;\n}\n\nint main(){\n\tfor(char T=1;scanf(\"%d\",&n),n;T++){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tstatic char vis[1<<25];\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tint hash=calc_hash(D);\n\t\t\tif(vis[hash]==T) continue;\n\t\t\tvis[hash]=T;\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconstexpr int dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconstexpr int INF = 1e9;\n\nstruct state {\n    int y, x, infected;\n    bool operator<(state const& s) const {\n        return make_tuple(y, x, infected) < make_tuple(s.y, s.x, s.infected);\n    }\n};\n\nbool is_in(int y, int x, int n) {\n    return (0 <= y && y < n && 0 <= x && x < n);\n}\n\nint next_infected(int y, int x, int infected, int n) {\n    int res = 0;\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            if(i == y && j == x) {\n                continue;\n            }\n            int cnt = 0;\n            for(int k=0; k<8; ++k) {\n                int adj_y = i + dy[k];\n                int adj_x = j + dx[k];\n                if(!is_in(adj_y, adj_x, n)) {\n                    continue;\n                }\n                cnt += (adj_y == y && adj_x == x) || (infected >> (adj_y * n + adj_x)) & 1;\n            }\n            if((infected >> (i * n + j)) & 1) {\n                if(cnt == 2 || cnt == 3) {\n                    res |= 1 << (i * n + j);\n                }\n            } else {\n                if(cnt == 3) {\n                    res |= 1 << (i * n + j);\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<string> v(n);\n        int sy, sx, sinfected = 0;\n        for(int i=0; i<n; ++i) {\n            cin >> v[i];\n            for(int j=0; j<n; ++j) {\n                if(v[i][j] == '@') {\n                    sy = i;\n                    sx = j;\n                } else if(v[i][j] == '#') {\n                    sinfected |= 1 << (i * n + j);\n                }\n            }\n        }\n        map<state, int> memo;\n        memo[state{sy, sx, sinfected}] = 0;\n        queue<state> que;\n        que.push(state{sy, sx, sinfected});\n        int res = INF;\n        while(!que.empty()) {\n            auto now = que.front();\n            que.pop();\n            if(now.infected == 0) {\n                res = memo[now];\n                break;\n            }\n            for(int i=0; i<8; ++i) {\n                int ny = now.y + dy[i];\n                int nx = now.x + dx[i];\n                if(!is_in(ny, nx, n) || (now.infected >> (ny * n + nx)) & 1) {\n                    continue;\n                }\n                int next_inf = next_infected(ny, nx, now.infected, n);\n                auto next = state{ny, nx, next_inf};\n                if(memo.count(next) == 0) {\n                    memo[next] = memo[now] + 1;\n                    que.push(next);\n                }\n            }\n        }\n        cout << (res == INF ? -1 : res) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tr1/unordered_map>\n#include <map>\nusing namespace std;\n\nstruct NODE{\n\tint x,bit;\n\tNODE(int x,int bit) : x(x) , bit(bit) {}\n};\n\nint n;\nvector<int> dd[25];\n\nint mask[25];\n\nint sim(int bit){\n\tint nextbit = 0;\n\tfor(int i = 0 ; i < n*n ; i++){\n\t\tint c = __builtin_popcount(bit&mask[i]);\n\t\tif( (bit >> i & 1) && (c == 2) ){\n\t\t\tnextbit |= (1<<i);\n\t\t}else if( c == 3 ){\n\t\t\tnextbit |= (1<<i);\n\t\t}\n\t} \n\treturn nextbit;\n}\n\nstring view(int bit){\n\t\tstring s;\n\tfor(int i = 0 ; i < n * n ; i++) s += string(1,(bit>>i&1) + '0') + ((i+1)%n==0?\"\\n\":\"\"); \n\treturn s;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tint bit = 0;\n\t\tint st = 0;\n\t\tint weight = 1;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '#' ) bit += weight;\n\t\t\t\tweight *= 2;\n\t\t\t\tif( c == '@' ) st = n * i + j;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tdd[i*n+j].clear();\n\t\t\t\tmask[i*n+j] = 0;\n\t\t\t\tfor(int k = 0 ; k < 8 ; k++){\n\t\t\t\t\tint dx[] =  {0, 1,0,-1,1,1,-1,-1};\n\t\t\t\t\tint dy[] =  {-1,0,1,0,1,-1,1,-1};\n\t\t\t\t\tint y = i + dy[k];\n\t\t\t\t\tint x = j + dx[k];\n\t\t\t\t\tif( y >= n || x >= n || x < 0 || y < 0 ) continue;\n\t\t\t\t\tdd[i*n+j].push_back(n*y+x);\n\t\t\t\t\tmask[i*n+j] |= (1<<(n*y+x));\n\t\t\t\t\t//cout << i << \",\" << j << \" : \" << dd[i*n+j].back() << endl;\n\t\t\t\t}\n\t\t\t\t//dd[i*n+j].push_back(i*n+j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<NODE> Q;\n\t\tQ.push(NODE(st,bit));\n\t\ttr1::unordered_map<int,int> done[25];\n\t\tdone[st][bit] = 0;\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t//cout << view(q.bit) << q.x << \" \" << (q.bit >> q.x & 1 ) << \"[\" << done[q.x][q.bit] << \"]\" << endl;\n\t\t\t\n\t\t\tif( q.bit == 0 ){\n\t\t\t\tcout << done[q.x][q.bit] << endl;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0 ; i < dd[q.x].size() ; i++){\n\t\t\t\tif( !(q.bit >> (dd[q.x][i]) & 1) ){\n\t\t\t\t\tint tnext = sim(q.bit|(1<<dd[q.x][i])) &~ (1<<dd[q.x][i]);\n\t\t\t\t\tif( !done[dd[q.x][i]].count(tnext) ){\n\t\t\t\t\t\tdone[dd[q.x][i]][tnext] = done[q.x][q.bit] + 1;\n\t\t\t\t\t\tQ.push(NODE(dd[q.x][i],tnext));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\n// (y, x, field)\nusing State = tuple<int, int, int>;\n\nint n;\n\ninline vector<vi> s2f(int fs){\n    vector<vi> field(n, vi(n));\n\n    rep(y, n){\n        rep(x, n){\n            if((fs >> (y * n + x)) & 1){\n                field[y][x] = 1;\n            }\n        }\n    }\n\n    return field;\n}\n\ninline int f2s(vector<vi> field){\n    int fs = 0;\n\n    rep(y, n){\n        rep(x, n){\n            if(field[y][x]){\n                fs |= (1 << (y * n + x));\n            }\n        }\n    }\n\n    return fs;\n}\n\ninline bool in(int y, int x){\n    return 0 <= y and y < n and 0 <= x and x < n;\n}\n\ninline vector<vi> calc(vector<vi>& cur, int vy, int vx){\n    vector<vi> next(n, vi(n));\n\n    rep(y, n){\n        rep(x, n){\n            if(y == vy and x == vx) continue;\n\n            int cnt = 0;\n            rep(i, 8){\n                int ny = y + dy[i], nx = x + dx[i];\n                if(not in(ny, nx)) continue;\n                cnt += ((cur[ny][nx] or (ny == vy and nx == vx)) ? 1 : 0); \n            }\n\n            if(cur[y][x]){\n                if(cnt == 2 or cnt == 3){\n                    next[y][x] = 1;\n                }\n            }\n            else {\n                if(cnt == 3){\n                    next[y][x] = 1;\n                }\n            }\n        }\n    }\n\n    return next;\n}\n\nint main(void){\n    for(; cin >> n, n;){\n//        cerr << \"hoge-------\" << endl;\n        vector<vi> sfield(n, vi(n));\n        int sy, sx;\n        rep(y, n){\n            string in; cin >> in;\n            rep(x, n){\n                if(in[x] == '#'){\n                    sfield[y][x] = 1;\n                }\n                if(in[x] == '@'){\n                    sy = y;\n                    sx = x;\n                }\n            }\n        }\n        int sfs = f2s(sfield);\n\n        queue<State> q;\n        State s = State(sy, sx, sfs);\n        q.push(s);\n        map<State, int> min_cost;\n        min_cost[s] = 0;\n\n        int res = -1;\n        while(q.size()){\n            int cost = min_cost[q.front()];\n            int y, x, fs; tie(y, x, fs) = q.front(); q.pop();\n\n            if(fs == 0){\n                res = cost;\n                break;\n            }\n\n            auto field = s2f(fs);\n\n//            cerr << \"-------\" << endl;\n//            cerr << cost << endl;\n//            rep(yy, n){\n//                rep(xx, n){\n//                    if(yy == y and xx == x){\n//                        cerr << \"@ \";\n//                    }\n//                    else {\n//                        cerr << (field[yy][xx] ? '#' : '.') << \" \";\n//                    }\n//                }\n//                cerr << endl;\n//            }\n\n            rep(i, 8){\n                int ny = y + dy[i], nx = x + dx[i];\n                if(not in(ny, nx) or field[ny][nx]) continue;\n\n                auto nfield = calc(field, ny, nx);\n                int nfs = f2s(nfield);\n\n                State ns = State(ny, nx, nfs);\n                if(min_cost.find(ns) == end(min_cost)){\n                    min_cost[ns] = cost + 1;\n                    q.push(ns);\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define INF\t(1 << 30)\n\n#define N\t(5)\n#define NN\t(N * N)\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef map<int,int> mii;\n\nstruct Pt {\n  int x, y;\n};\n\n/* global variables */\n\nPt dxys[8] = {\n  { 1, 0}, {1, -1}, {0, -1}, {-1, -1},\n  {-1, 0}, {-1, 1}, {0,  1}, { 1,  1}\n};\n\nint n, nn;\nmii dists;\nvi adjs[NN];\n\n/* subroutines */\n\nint infection(int bits) {\n  int ibits = 0;\n\n  for (int pos = 0; pos < nn; pos++) {\n    int c = 0;\n    vi& adj = adjs[pos];\n\n    for (vi::iterator ait = adj.begin(); ait != adj.end(); ait++)\n      c += ((bits >> *ait) & 1);\n\n    int b = 1 << pos;\n    int on = bits & b;\n    if ((! on && c == 3) || (on && (c == 2 || c == 3))) ibits |= b;\n  }\n\n  return ibits;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    nn = n * n;\n\n    int sstat = 0;\n    int mask = (1 << nn) - 1;\n\n    for (int y = 0; y < n; y++) {\n      string line;\n      cin >> line;\n      for (int x = 0; x < n; x++) {\n\tint pos = y * n + x;\n\tswitch (line[x]) {\n\tcase '#': sstat |= (1 << pos); break;\n\tcase '@': sstat |= (pos << nn); break;\n\t}\n      }\n    }\n    //p sbits.to_s(2)\n    //p spos\n\n    for (int y0 = 0; y0 < n; y0++) {\n      for (int x0 = 0; x0 < n; x0++) {\n\tint pos = y0 * n + x0;\n\tadjs[pos].clear();\n\tfor (int di = 0; di < 8; di++) {\n\t  int x = x0 + dxys[di].x;\n\t  int y = y0 + dxys[di].y;\n\t  if (x >= 0 && x < n && y >= 0 && y < n)\n\t    adjs[pos].push_back(y * n + x);\n\t}\n      }\n    }\n    //p adjs\n\n    dists.clear();\n    dists[sstat] = 0;\n\n    queue<int> q;\n    q.push(sstat);\n\n    int min_d = -1;\n  \n    while (! q.empty()) {\n      int u = q.front();\n      q.pop();\n\n      int upos = u >> nn;\n      int ubits = u & mask;\n      \n      int ud = dists[u];\n      //puts tostr(n, ubits, upos); puts\n    \n      if (ubits == 0) {\n\tmin_d = ud;\n\tbreak;\n      }\n\n      int nvd = ud + 1;\n      vi& adj = adjs[upos];\n      \n      for (vi::iterator ait = adj.begin(); ait != adj.end(); ait++) {\n\tint vpos = *ait;\n\tint vb = (1 << vpos);\n\tif ((ubits & vb) == 0) {\n\t  int vbits = (infection(ubits | vb) & ~vb);\n\t  int v = (vpos << nn) | vbits;\n\t  if (dists.find(v) == dists.end()) {\n\t    dists[v] = nvd;\n\t    q.push(v);\n\t  }\n\t}\n      }\n    }\n\n    cout << min_d << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n\nstatic const int dy[8] = {0, -1, -1, -1, 0, 1, 1, 1};\nstatic const int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nclass State{\n    public:\n    char G[5][5]; \n    int py, px, n;\n    State(int n=0):n(n){}\n    bool operator < ( const State &s) const{\n\trep(i, n) rep(j, n){\n\t    if ( G[i][j] == s.G[i][j] ) continue;\n\t    return G[i][j] < s.G[i][j];\n\t}\n\treturn false;\n    }\n    bool goal(){\n\trep(i, n) rep(j, n) if ( G[i][j] == '#' ) return false;\n\treturn true;\n    }\n\n    void activate(){\n\tchar tmp[5][5];\n\tint nx, ny;\n\trep(y, n) rep(x, n) tmp[y][x] = '.';\n\trep(y, n) rep(x, n){\n\t    if ( G[y][x] == '@' ) {\n\t\ttmp[y][x] = '@';\n\t\tcontinue;\n\t    }\n\t    int cnt = 0;\n\t    rep(d, 8){\n\t\tny = y + dy[d];\n\t\tnx = x + dx[d];\n\t\tif ( ny < 0 || nx < 0 || ny >= n || nx >= n ) continue;\n\t\tif ( G[ny][nx] == '#' || G[ny][nx] == '@' ) cnt++;\n\t    }\n\t    if ( G[y][x] == '#'){\n\t\tif ( cnt == 2 || cnt == 3 ) tmp[y][x] = '#';\n\t    } else {\n\t\tif ( cnt == 3 ) tmp[y][x] = '#';\n\t    }\n\t}\n\trep(y, n) rep(x, n) G[y][x] = tmp[y][x];\n    }\n};\n\nint bfs( int n, State source ){\n    queue<State> Q;\n    map<State, int> D;\n    set<State> V;\n    \n    Q.push(source);\n    D[source] = 0;\n    V.insert(source);\n    \n    State u, v;\n    int ny, nx;\n    while(!Q.empty() ){\n\tu = Q.front(); Q.pop();\n\tif ( u.goal() ) return D[u];\n\t\n\trep(d, 8){\n\t    ny = u.py + dy[d];\n\t    nx = u.px + dx[d];\n\t    if ( ny < 0 || nx < 0 || ny >= n || nx >= n ) continue;\n\t    if ( u.G[ny][nx] == '#' ) continue;\n\t    v = u;\n\t    v.G[u.py][u.px] = '.';\n\t    v.G[ny][nx] = '@'; v.py = ny; v.px = nx;\n\t    v.activate();\n\t    if ( V.insert(v).second ){\n\t\tV.insert(v);\n\t\tD[v] = D[u] + 1;\n\t\tQ.push(v);\n\t    }\n\t}\n    }\n    return -1;\n}\n\nmain(){\n    int n;\n    State source;\n    while( cin >> n && n ){\n\tsource = State(n);\n\trep(y, n) rep(x, n){\n\t    cin >> source.G[y][x];\n\t    if ( source.G[y][x] == '@' ){\n\t\tsource.py = y;\n\t\tsource.px = x;\n\t    }\n\t}\n\tcout <<  bfs(n, source) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\nconst int inf = 1e9;\nint update(int h, int p, int n){\n    h |= 1<<p;\n    int res = 0;\n    for(int y=0; y<n; y++){\n        for(int x=0; x<n; x++){\n            int pos = y*n+x;\n            if(pos == p) continue;\n            int count = 0;\n            for(int dy=-1; dy<=1; dy++){\n                for(int dx=-1; dx<=1; dx++){\n                    if(dy==0 && dx==0) continue;\n                    if(y+dy<0 || n<=y+dy || x+dx<0 || n<=x+dx) continue;\n                    int adj = pos +dy*n +dx;\n                    if((h & 1<<adj) != 0) count++;\n                }\n            }\n            if((h & 1<<pos) != 0){\n                if(count==2 || count==3) res |= 1<<pos;\n            }else{\n                if(count == 3) res |= 1<<pos;\n            }\n        }\n    }\n    return res;\n}\n\nstruct info{\n    int h,p,s;\n    info(int h, int p, int s):h(h),p(p),s(s){}\n    info();\n    bool operator<(const info &a) const{\n        return (h!=a.h)? h<a.h: p<a.p;\n    }\n};\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        int p;\n        int hash=0;\n        for(int i=0; i<n*n; i++){\n            char c;\n            cin >> c;\n            if(c=='@') p = i;\n            if(c=='#') hash |= 1<<i;\n        }\n\n        set<info> used;\n        used.insert(info(hash, p, 0));\n        queue<info> wait;\n        wait.push(info(hash, p, 0));\n        int ans = -1;\n        while(!wait.empty()){\n            int h = wait.front().h;\n            int p = wait.front().p;\n            int s = wait.front().s;\n            wait.pop();\n            if(h == 0){\n                ans = s;\n                break;\n            }\n            int y = p/n;\n            int x = p%n;\n            for(int dy=-1; dy<=1; dy++){\n                for(int dx=-1; dx<=1; dx++){\n                    if(dy==0 && dx==0) continue;\n                    if(y+dy<0 || n<=y+dy || x+dx<0 || n<=x+dx) continue;\n                    int np = (y+dy)*n +(x+dx);\n                    if((h & 1<<np) != 0) continue;\n                    int nh = update(h, np, n);\n                    info next(nh, np, s+1);\n                    if(used.find(next) == used.end()){\n                        used.insert(next);\n                        wait.push(next);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvoid showLand(vs land) {\n\tREP(i, land.size()) {\n\t\tcout << land[i] << endl;\n\t}\n}\n\nstruct state {\n\tint t, x, y;\n\tvs land;\n\tstate(int t, int x, int y, vs land) : t(t), x(x), y(y), land(land) {};\n};\n\nbool isProperXY(int x, int y, int n) {\n\treturn 0<=x && x<n && 0<=y && y<n;\n}\n\nbool isDisinfectedLand(vs land, int n) {\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tif(land[i][j] == '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nvs updateLand(vs land, int n) {\n\tvs nland = land;\n\tREP(x, n) {\n\t\tREP(y, n) {\n\t\t\tint count = 0;\n\t\t\tREP(d, 8) {\n\t\t\t\tint nx = x+dx[d], ny = y+dy[d];\n\t\t\t\tif(isProperXY(nx, ny, n) && land[ny][nx] != '.') {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(land[y][x] == '#' && (count == 2 || count == 3)) {\n\t\t\t\tnland[y][x] = '#';\n\t\t\t} else if(land[y][x] == '.' && count == 3) {\n\t\t\t\tnland[y][x] = '#';\n\t\t\t} else if(land[y][x] != '@') {\n\t\t\t\tnland[y][x] = '.';\n\t\t\t}\n\t\t}\n\t}\n\treturn nland;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvs land(n);\n\t\tint sx, sy;\n\t\tREP(i, n) {\n\t\t\tcin >> land[i];\n\t\t\tREP(j, n) {\n\t\t\t\tif(land[i][j] == '@') {\n\t\t\t\t\tsy = i, sx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<state> Q;\n\t\tQ.push(state(0, sx, sy, land));\n\t\tmap<vs, int> memo;\n\t\tmemo[land] = 1;\n\t\tint ans = -1;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(isDisinfectedLand(st.land, n)) {\n\t\t\t\tans = st.t;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(d, 8) {\n\t\t\t\tint nx = st.x+dx[d], ny = st.y+dy[d];\n\t\t\t\tif(isProperXY(nx, ny, n) && st.land[ny][nx] == '.') {\n\t\t\t\t\tvs nland = st.land;\n\t\t\t\t\tnland[st.y][st.x] = '.';\n\t\t\t\t\tnland[ny][nx] = '@';\n\t\t\t\t\tnland = updateLand(nland, n);\n\t\t\t\t\tif(!memo[nland]) {\n\t\t\t\t\t\tmemo[nland] = 1;\n\t\t\t\t\t\tQ.push(state(st.t+1, nx, ny, nland));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <fstream>\n#include <set>\n\nusing namespace std;\n\nconst int dy[]={-1,-1,-1,0,0,1,1,1};\nconst int dx[]={-1,0,1,-1,1,-1,0,1};\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> sit;\n\nint n;\nchar field[6][6];\npii sp;\n\n\nint bfs(){\n\tint res=0;\n\tqueue<sit> q[2];\n\tset<sit> used;\n\tint cur=0;\n\tint nxt=1;\n\tint ss=0;\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(field[i][j]=='#')ss|=(1<<(i*n+j));\n\tq[cur].push(sit(ss,sp));\n\twhile(q[cur].size()){\n\t\twhile(q[cur].size()){\n\t\t\tsit csit=q[cur].front();q[cur].pop();\n\t\t\tif(csit.first==0)return res;\n\t\t\tconst int fsit=csit.first;\n\t\t\tconst pii &pp=csit.second;\n\t\t\tfor(int l=0;l<8;l++){\n\t\t\t\tif(l==5){\n\t\t\t\t\t//cout<<endl;\n\t\t\t\t}\n\t\t\t\tint ny=pp.first+dy[l];\n\t\t\t\tint nx=pp.second+dx[l];\n\t\t\t\t// Ú®æªÚ®Â\\\n\t\t\t\tif(ny>=0&&nx>=0&&ny<n&&nx<n&&!((fsit>>(ny*n+nx))&1)){\n\t\t\t\t\t// infection\n\t\t\t\t\tint nfield=0;\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\t\tif(ny==i&&nx==j)continue;\n\t\t\t\t\t\t\t// ×ÚvfÌóÔðmF\n\t\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\t\t\tint adx=j+dx[k];\n\t\t\t\t\t\t\t\tint ady=i+dy[k];\n\t\t\t\t\t\t\t\tif(ady>=0&&adx>=0&&ady<n&&adx<n)\n\t\t\t\t\t\t\t\t\tif(((fsit>>(ady*n+adx))&1)||(ny==ady&&nx==adx))cnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((fsit>>(i*n+j))&1){\n\t\t\t\t\t\t\t\tif(cnt==2||cnt==3)nfield|=(1<<(i*n+j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tif(cnt==3)nfield|=(1<<(i*n+j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsit nsit=make_pair(nfield,make_pair(ny,nx));\n\t\t\t\t\tif(used.find(nsit)!=used.end())continue;\n\t\t\t\t\tused.insert(nsit);\n\t\t\t\t\tq[nxt].push(nsit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(cur,nxt);\n\t\tres++;\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='@')sp.first=i,sp.second=j,field[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tint res=bfs();\n\t\tcout<<res<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 6\ntypedef pair<int, int> Pos;\ntypedef vector<vector<char>> Field;\n\nconst int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint N;\nint n2;\nField field;\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || N <= y) return false;\n  if (x < 0 || N <= x) return false;\n  return true;\n}\n\nint CalcHash(Field &field) {\n  int ret = 0;\n  int bit = 0;\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      bit <<= 1;\n      if (field[i][j] == '#') bit |= 1;\n      else if (field[i][j] == '@') {\n        ret = i*N + j;\n      } else assert(field[i][j] == '.');\n    }\n  }\n\n  return bit*n2 + ret;\n}\n\nbool IsWall(int hash, int y, int x) {\n  int idx = y*N + x;\n  if (hash%n2 == idx) return true;\n  hash /= n2;\n  return (hash >> (n2-1-idx) & 1);\n}\n\nvoid Print(int g, int d) {\n  printf(\"d[%x]: %d\\n\", g, d);\n  int hash = g/n2;\n  int _ = g%n2;\n  int y = _/N;\n  int x = _%N;\n  printf(\"(%d, %d)\\n\", y, x);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      if (i == y && j == x) {\n        printf(\"@\");\n        assert ((hash >> (n2-1-i*N-j) & 1) == 0);\n      }\n      else printf(\"%01d\", hash >> (n2-1-i*N-j) & 1);\n    }\n    puts(\"\");\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) return 0;\n\n    n2 = N*N;\n    field.resize(N, vector<char>(N));\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<N; j++) {\n        scanf(\" %c\", &field[i][j]);\n      }\n    }\n\n    queue<int> q;\n    map<int, int> d;\n    set<int> calced;\n    int t = CalcHash(field);\n    if (t/n2 == 0) {\n      puts(\"0\");\n      continue;\n    }\n\n    d[t] = 0;\n    q.push(t);\n    while (!q.empty()) { \n      int g = q.front(); q.pop();\n      if (calced.count(g)) continue;\n      calced.insert(g);\n      //Print(g, d[g]);\n      int _ = g%n2;\n      int y = _/N;\n      int x = _%N;\n      for (int k=0; k<8; k++) {\n        int newy = y + dy[k];\n        int newx = x + dx[k];\n        if (!WithinRange(newy, newx)) continue;\n        if (IsWall(g, newy, newx)) continue;\n        int newg = g/n2*n2 + newy*N + newx;\n        int nhash = 0;\n        for (int i=0; i<N; i++) {\n          for (int j=0; j<N; j++) {\n            nhash <<= 1;\n            if (i == newy && j == newx) continue;\n\n            int cnt = 0;\n            for (int l=0; l<8; l++) {\n              int y = i + dy[l];\n              int x = j + dx[l];\n              if (!WithinRange(y, x)) continue;\n              if (IsWall(newg, y, x)) cnt++;\n            }\n\n            if (IsWall(newg, i, j)) {\n              if (2 <= cnt && cnt <= 3) nhash |= 1;\n            } else if (cnt == 3) nhash |= 1;\n          }\n        }\n        newg = nhash*n2 + newy*N + newx;\n        if (d.count(newg)) continue;\n        d[newg] = d[g]+1;\n        if (newg/n2 == 0) {\n          printf(\"%d\\n\", d[newg]);\n          goto L_END;\n        }\n        q.push(newg);\n      }\n    }\n\n    puts(\"-1\");\nL_END:\n    continue;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\nstruct node{\n\tvs f;\n\tpii pos;\n\tstring hash;\n\tnode(vs f,pii pos):f(f),pos(pos){\n\thash=to_s();}\n\tstring to_s() const{\n\t\tif(hash!=\"\"){\n\t\t\treturn hash;\n\t\t}\n\t\tint n=f.size();\n\t\tstring ret; \n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tret+=pos.first==i&&pos.second==j?'@':f[i][j];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tbool operator<(const node &other)const{\n\t\treturn hash<other.hash;\n\t}\n};\nint dy[]={-1,-1,-1,0,1,1,1,0};\nint dx[]={-1,0,1,1,1,0,-1,-1};\n\nvs change(vs &f,int y,int x){\n\tint n=f.size();\n\tvs nf(f);\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(y==i&&x==j)continue;\n\t\t\tint cnt=0;\n\t\t\tREP(d,8){\n\t\t\t\tint yy=i+dy[d];\n\t\t\t\tint xx=j+dx[d];\n\t\t\t\tif(yy>=0&&xx>=0&&yy<n&&xx<n){\n\t\t\t\t\tcnt+=f[yy][xx]=='#'||(y==yy&&x==xx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch(f[i][j]){\n\t\t\tcase '.':\n\t\t\t\tnf[i][j]=cnt==3?'#':'.';\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tnf[i][j]=(cnt==2||cnt==3?'#':'.');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t}\n\t}\n\treturn nf;\n}\n\nbool done(vs &f){\n\tint n=f.size();\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(f[i][j]=='#'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tvs f(N);\n\t\tpii p;\n\t\tREP(i,N){\n\t\t\tcin>>f[i];\n\t\t\tREP(j,N){\n\t\t\t\tif(f[i][j]=='@'){\n\t\t\t\t\tp=make_pair(i,j);\n\t\t\t\t\tf[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<node> q;\n\t\tmap<node,int> cost;\n\t\tq.push(node(f,p));\n\t\tcost[node(f,p)]=0;\n\t\tint ans=-1;\n\t\twhile(q.size()){\n\t\t\tnode n=q.front();q.pop();\n\t\t\tif(done(n.f)){\n\t\t\t\tans=cost[n];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(d,8){\n\t\t\t\tint y=n.pos.first+dy[d];\n\t\t\t\tint x=n.pos.second+dx[d];\n\t\t\t\tif(y>=0&&x>=0&&y<N&&x<N){\n\t\t\t\t\tif(n.f[y][x]=='.'){\n\t\t\t\t\t\tvs nf=change(n.f,y,x);\n\t\t\t\t\t\tnode nnode(nf,make_pair(y,x));\n\t\t\t\t\t\tif(!EXIST(cost,nnode)){\n\t\t\t\t\t\t\tcost[nnode]=cost[n]+1;\n\t\t\t\t\t\t\tq.push(nnode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\nint main(){\n\tfor(char T=1;scanf(\"%d\",&n),n;T++){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tstatic char vis[1<<22];\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tint hash=((D.S+1)*(D.x+1)*(D.y+1))&((1<<22)-1);\n\t\t\tif(vis[hash]==T) continue;\n\t\t\tvis[hash]=T;\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,-1,-1,-1,0,1,1,1};\n\nstruct data{\n\tint S;\n\tint x,y;\n\tbool operator<(const data &D)const{\n\t\tif(S!=D.S) return S<D.S;\n\t\tif(x!=D.x) return x<D.x;\n\t\treturn y<D.y;\n\t}\n};\n\nint n;\n\ndata next_state(int S,int x,int y){\n\tS|=1<<y*n+x;\n\tint T=0;\n\trep(i,n) rep(j,n) {\n\t\tint cnt=0;\n\t\trep(k,8){\n\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && S&(1<<yy*n+xx)) cnt++;\n\t\t}\n\t\tif(S&(1<<i*n+j)){\n\t\t\tif(cnt==2 || cnt==3) T|=1<<i*n+j;\n\t\t}\n\t\telse{\n\t\t\tif(cnt==3) T|=1<<i*n+j;\n\t\t}\n\t}\n\tT&=~(1<<y*n+x);\n\treturn (data){T,x,y};\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdata ini={};\n\t\trep(i,n){\n\t\t\tchar s[6]; scanf(\"%s\",s);\n\t\t\trep(j,n){\n\t\t\t\tif(s[j]=='#') ini.S|=1<<(i*n+j);\n\t\t\t\tif(s[j]=='@') ini.x=j, ini.y=i;\n\t\t\t}\n\t\t}\n\n\t\tint ans=-1;\n\t\tset<data> Vis;\n\t\tqueue< pair<int,data> > Q; Q.push(make_pair(0,ini));\n\t\twhile(!Q.empty()){\n\t\t\tint t=Q.front().first;\n\t\t\tdata D=Q.front().second; Q.pop();\n\n\t\t\tif(t>11) break;\n\n\t\t\tif(Vis.count(D)>0) continue;\n\t\t\tVis.insert(D);\n\n\t\t\tif(D.S==0){ ans=t; break; }\n\n\t\t\trep(k,8){\n\t\t\t\tint yy=D.y+dy[k],xx=D.x+dx[k];\n\t\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && (D.S&(1<<yy*n+xx))==0){\n\t\t\t\t\tQ.push(make_pair(t+1,next_state(D.S,xx,yy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int t;\n  vector<char> v;\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    S is;\n    is.t=0;\n    is.v.resize(n*n);\n    for(int i=0;i<n*n;i++){\n      cin>>is.v[i];\n    }\n    queue<S> que;\n    que.push(is);\n    set<vector<char> > p;\n    while(!que.empty()){\n      S c=que.front();\n      if(find(c.v.begin(),c.v.end(),'#')==c.v.end())break;\n      que.pop();\n      if(!p.insert(c.v).second)continue;\n      int ps=find(c.v.begin(),c.v.end(),'@')-c.v.begin();\n      int x=ps%n;\n      int y=ps/n;\n      for(int i=-1;i<=1;i++){\n\tfor(int j=-1;j<=1;j++){\n\t  int nx=x+j;\n\t  int ny=y+i;\n\t  if(0<=ny&&ny<n&&0<=nx&&nx<n&&c.v[ny*n+nx]=='.'){\n\t    vector<char> nv(n*n);\n\t    for(int k=0;k<n;k++){\n\t      for(int l=0;l<n;l++){\n\t\tif(k==ny&&l==nx){\n\t\t  nv[ny*n+nx]='@';\n\t\t}else{\n\t\t  int ni=0;\n\t\t  for(int m=max(0,k-1);m<=min(k+1,n-1);m++){\n\t\t    for(int o=max(0,l-1);o<=min(l+1,n-1);o++){\n\t\t      ni+=c.v[m*n+o]=='#'||ny==m&&nx==o;\n\t\t    }\n\t\t  }\n\t\t  nv[k*n+l]=((c.v[k*n+l]=='#'&&(ni==3||ni==4))\n\t\t\t     ||(c.v[k*n+l]!='#'&&ni==3))?'#':'.';\n\t\t}\n\t      }\n\t    }\n\t    S ns={c.t+1,nv};\n\t    que.push(ns);\n\t  }\n\t}\n      }\n    }\n    cout<<(que.empty()?-1:que.front().t)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\n\n\nstruct state {\n  int turn;\n  int y,x;\n  int ba;\n  state() {}\n  state(int a,int y, int x, int ba) : turn(a) ,y(y) , x(x) ,ba(ba)  {}\n};\n\ntypedef pair<int,int> pii;\ntypedef pair<int, pair<int,int> > piii;\n\nint dx[] = {-1,-1,-1,0,0,1,1,1};\nint dy[] = {-1,0,1,-1,1,-1,0,1};\nint main() {\n  int n;\n  while(cin >> n , n){\n    state stat;\n    int ba = 0;\n    for(int i = 0; i < n; i++){\n      string str;\n      cin >> str;\n      REP(j, str.size()) {\n        if (str[j] == '#') ba |= 1<<(i*n+j);\n        if (str[j] == '@') {\n          stat.y = i;\n          stat.x = j;\n        }\n      }\n    }\n    stat.ba = ba;\n    stat.turn = 0;\n    queue<state> Q;\n    Q.push(stat);\n\n    int res = -1;\n    map<piii, bool> visited;\n    \n    while(!Q.empty()) {\n      state now = Q.front();\n      Q.pop();\n      \n      if (visited[piii(now.ba,pii(now.y,now.x))]) continue;\n      visited[piii(now.ba,pii(now.y,now.x))] = 1;\n\n      // cout << now.turn << endl;\n      // REP(i, n) {\n      //   REP(j, n) {\n      //     if (now.ba >> (i*n+j) & 1) \n      //       cout << '#';\n      //     else {\n      //       if(i==now.y && j==now.x)\n      //         cout << '@';\n      //       else\n      //         cout << '.';\n      //     }\n      //   }\n      //   cout << endl;\n      // }\n\n      bool f = 0;\n      REP(i, n) {\n        REP(j, n) {\n          if (now.ba >> (i*n+j) & 1) {\n            f = 1;\n            break;\n          }\n        }\n        if(f) break;\n      }\n      if (!f) {\n        res = now.turn;\n        break;\n      }\n      REP(k, 8) {\n        int yy = now.y+dy[k];\n        int xx = now.x+dx[k];\n\n        if(yy<0||yy>=n||xx<0||xx>=n) continue;\n        if(now.ba >> (yy*n+xx) & 1) continue;\n\n        //  cout << yy << \" \" << xx << endl;\n        state next = now;\n        next.turn++;\n        next.y = yy;\n        next.x = xx;\n        \n        REP(i, n) {\n          REP(j, n) {\n            int cnt = 0;\n            REP(k, 8) {\n              int ii = i+dy[k];\n              int jj = j+dx[k];\n              if (ii<0||ii>=n||jj<0||jj>=n) continue;\n              if ((now.ba >> (ii*n+jj) & 1) || ii==next.y&&jj==next.x) cnt++;\n            }\n            if (next.ba >> (i*n+j) & 1) {\n              if (cnt == 2 || cnt == 3);\n              else {\n                next.ba ^= 1<<(i*n+j);\n              }\n            } else if (!(i==next.y&&j==next.x)) {\n              if (cnt == 3) {\n                next.ba |= 1 << (i*n+j);\n              }\n            }\n          }\n        }\n        \n        if(visited[piii(next.ba, pii(next.y, next.x))]) continue;\n        Q.push(next);\n      }\n    }\n    cout << res << endl;\n  }\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\n#define INF 100000000\n\nint n;\nmap<pair<int,int>,int> dp;\nmap<pair<int,int>,bool> vis;\nmap<pair<int,int>,bool> now;\nmap<pair<int,int>,int> next;\nchar buf[25][25];\nint dx[] = {-1,0,1,-1,1,-1,0,1};\nint dy[] = {-1,-1,-1,0,0,1,1,1};\n\nint make(pair<int,int> p) {\n\tif (next.find(p)!=next.end()) return next[p];\n\tint mask = p.first;\n\tint pos = p.second;\n\tmask |= (1<<pos);\n\tint newmask = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tint k = i*n+j;\n\t\t\tint t = 0;\n\t\t\tif (j>0) {\n\t\t\t\tt += (mask&(1<<(k-1)))>0;\n\t\t\t\tif (i>0) t += (mask&(1<<(k-1-n)))>0;\n\t\t\t\tif (i<n-1) t += (mask&(1<<(k-1+n)))>0;\n\t\t\t}\n\t\t\tif (j<n-1) {\n\t\t\t\tt += (mask&(1<<(k+1)))>0;\n\t\t\t\tif (i>0) t += (mask&(1<<(k+1-n)))>0;\n\t\t\t\tif (i<n-1) t += (mask&(1<<(k+1+n)))>0;\n\t\t\t}\n\t\t\tif (i>0) t += (mask&(1<<(k-n)))>0;\n\t\t\tif (i<n-1) t += (mask&(1<<(k+n)))>0;\n\t\t\tif ((mask&(1<<k)) && k!=pos) {\n\t\t\t\tif (t==2 || t==3) {\n\t\t\t\t\tnewmask |= (1<<k);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (t==3 && k!=pos) {\n\t\t\t\t\tnewmask |= (1<<k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnext[p] = newmask;\n\treturn newmask;\n}\n\nvoid print(int m) {\n\tfor (int i=0; i<n;  i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tint k = i*n+j;\n\t\t\tif (m&(1<<k)) cout<<'#';\n\t\t\telse cout<<'.';\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\nint solve(int x, int y, int mask) {\n\t//cout<<x<<\" \"<<y<<\" \"<<mask<<endl;\n\t//print(mask);\n\t//cout<<endl;\n\tif (mask==0) return 0;\n\tif (vis[make_pair(mask,x*n+y)]) return dp[make_pair(mask,x*n+y)];\n\tif (now[make_pair(mask,x*n+y)]) return INF;\n\t\n\tnow[make_pair(mask,x*n+y)] = 1;\n\t\n\tint tmp = INF;\n\tint t = 1000;\n\t\n\tfor (int k=0; k<8; k++) {\n\t\tint u = x + dx[k];\n\t\tint v = y + dy[k];\n\t\tif (u<0 || u>=n) continue;\n\t\tif (v<0 || v>=n) continue;\n\t\tif (mask&(1<<(u*n+v))) continue;\n\t\t\n\t\tint m = make(make_pair(mask,u*n+v));\n\t\t\n\t\tt = min(t,__builtin_popcount(m));\n\t}\n\t\n\tfor (int k=0; k<8; k++) {\n\t\tint u = x + dx[k];\n\t\tint v = y + dy[k];\n\t\tif (u<0 || u>=n) continue;\n\t\tif (v<0 || v>=n) continue;\n\t\tif (mask&(1<<(u*n+v))) continue;\n\t\t\n\t\tint m = make(make_pair(mask,u*n+v));\n\t\t\n\t\tif (__builtin_popcount(m)==t) tmp = min(tmp, 1 + solve(u,v,m));\n\t}\n\t\n\tnow[make_pair(mask,x*n+y)] = 0;\n\tvis[make_pair(mask,x*n+y)] = 1;\n\tdp[make_pair(mask,x*n+y)] = tmp;\n\t\n\treturn tmp;\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d\",&n) && n!=0) {\n\t\tfor (int i=0; i<n; i++) scanf(\"%s\",buf+i);\n\t\tint x,y;\n\t\tint mask = 0;\n\t\tfor (int i=0; i<n; i++) for (int j=0; j<n; j++) {\n\t\t\tif (buf[i][j]=='#') mask |= (1<<(i*n+j));\n\t\t\tif (buf[i][j]=='@') {\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t\tnow.clear();\n\t\tvis.clear();\n\t\tdp.clear();\n\t\tint ans = solve(x,y,mask);\n\t\tif (ans >= INF) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n\nbool onmp(int x,int y){return x>=0&&y>=0&&x<n&&y<n;}\n\nint count(int x,int y,const vector<string> &A){\n  int res=0;  \n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i,ny = y+j;\n      if((!i&&!j)||!onmp(nx,ny))continue;\n      res += A[ny][nx]=='#'||A[ny][nx]=='@';\n    }\n  return res;\n}\n\nbool check(const vector<string> &A){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)if(A[i][j]=='#')return 0;\n  return 1;\n}\n\n\nvector<string> mkmp(const vector<string> &A){\n  vector<string> res(n,string(n,'.'));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cnt = count(j,i,A);\n      if(A[i][j]=='#')res[i][j]=(cnt==2||cnt==3)? '#':'.';\n      if(A[i][j]=='.')res[i][j]=(cnt==3)? '#':'.';\n      if(A[i][j]=='@')res[i][j]='@';\n    }\n  return res;\n}\n\n\nmap<vector<string>,int> mem;\nint ans;\nvoid dfs(int x,int y,int cnt,vector<string> A){\n  if(check(A))ans=min(cnt,ans);\n  if(cnt>=ans) return;\n  if(mem.count(A)&&mem[A]<=cnt)return;\n  mem[A]=cnt;\n  A[y][x] = '.';\n  for(int dy=-1;dy<=1;dy++){\n    for(int dx=-1;dx<=1;dx++){\n      int nx = x+dx,ny = y+dy;\n      if((!dx&&!dy)||!onmp(nx,ny)||A[ny][nx]=='#')continue;\n      A[ny][nx] = '@';\n      dfs(nx,ny,cnt+1,mkmp(A));\n      A[ny][nx] = '.';\n    }\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    vector<string> mp(n);\n    for(int i=0;i<n;i++)cin>>mp[i];\n    int sx,sy;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)if(mp[i][j]=='@')sy=i,sx=j;\n    mem.clear();\n    ans = 15;\n    dfs(sx,sy,0,mp);\n    cout<<(ans<15? ans:-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<cassert>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint dx[8] = {0, 1, 0, -1, -1, -1, 1, 1};\nint dy[8] = {1, 0, -1, 0, -1, 1, 1, -1};\nint n;\n\ninline char atc(string s,int i,int j) { return s.at(i*n+j); }\n\nbool iseliminated(string mp) {\n    int i,j;\n    rep(i,mp.length()) if(mp[i] == '#') return false;\n    return true;\n}\n\npair<int,int> getPos(string mp) {\n    int i,j;\n    rep(i,mp.length()) if(mp[i] == '@') return make_pair(i/n,i%n);\n}\n\n\nstring update(string &mp) {\n    int i,j,k;\n    string tmp = mp;\n\n    rep(i,n) rep(j,n) {\n        int adj = 0;\n        if(mp.at(i*n+j) == '@') continue;\n        rep(k,8) {\n            if(i+dy[k] < 0 || i+dy[k] >= n) continue;\n            if(j+dx[k] < 0 || j+dx[k] >= n) continue;\n            if(mp.at((i+dy[k])*n+(j+dx[k])) == '#'\n               || mp.at((i+dy[k])*n+(j+dx[k])) == '@') adj++;\n        }\n        if(mp.at(i*n+j) == '#') {\n            if(adj == 2 || adj == 3) continue;\n            else tmp.at(i*n+j) = '.';\n        }else{\n            if(adj == 3) tmp.at(i*n+j) = '#';\n        }\n    }\n    return tmp;\n}\n\nint bfs(string bmap) {\n    int i,j;\n    queue<pair<int,string > >Q;\n    set<string> memo;\n    memo.insert(bmap);\n    Q.push(make_pair(0,bmap));\n    while(!Q.empty()) {\n        string nmap = Q.front().second;\n        int ii = Q.front().first;\n        Q.pop();\n\n        if(nmap.find(\"#\") == string::npos) return ii;\n        // if(iseliminated(nmap)) return ii;\n\n        pair<int,int> pos = getPos(nmap);\n        for(int i=0; i<8; ++i) {\n            if(pos.first+dy[i] < 0 || pos.first+dy[i] >= n) continue;\n            if(pos.second+dx[i] < 0 || pos.second+dx[i] >= n) continue;\n            if(nmap.at((pos.first+dy[i])*n+(pos.second+dx[i])) == '#') continue;\n            string next = string(nmap);\n            next.at((pos.first+dy[i])*n+pos.second+dx[i]) = '@';\n            next.at((pos.first)*n+pos.second) = '.';\n            next = update(next);\n            if(memo.find(next) != memo.end()) continue;\n            memo.insert(next);\n            Q.push(make_pair(ii+1, next));\n        }\n    }\n    return -1;\n    assert(false);\n}\n\nint main() {\n    while(cin>>n, n) {\n        string imap = \"\",tmp;\n        for(int i=0; i<n; ++i) {\n            cin>>tmp;\n            imap += tmp;\n        }\n        cout<<bfs(imap)<<endl;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tint[][] a;\n\tint x0, y0;\n\t// 0 .\n\t// 1 #\n\t// 2 @\n\tchar[] obj={'.', '#', '@'};\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tchar c=s.charAt(i);\n\t\t\t\t\tif(c=='.')\n\t\t\t\t\t\ta[j][i]=0;\n\t\t\t\t\telse if(c=='#')\n\t\t\t\t\t\ta[j][i]=1;\n\t\t\t\t\telse if(c=='@'){\n\t\t\t\t\t\ta[j][i]=2;\n\t\t\t\t\t\tx0=i;\n\t\t\t\t\t\ty0=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tQueue<S> que=new LinkedList<S>();\n\t\tLinkedList<S> list=new LinkedList<S>();// ¡ÜÅÉo½âÂ\n\n\t\tS s0=new S(x0, y0, 0);\n\t\tfor(int j=0; j<n; j++)\n\t\t\tSystem.arraycopy(a[j], 0, s0.a[j], 0, n);\n\n\t\tque.offer(s0);\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tS s=que.poll();\n\t\t\tif(s.nInfect()==0){\n\t\t\t\tprintln(s.step+\"\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlist.add(s);\n\t\t\t// sÌ×ÚóÔðñµÄL[ÉÇÁ\n\t\t\tLinkedList<S> nexts=s.nextStates();\n\t\t\tfor(S t : nexts){\n\t\t\t\t//println(\"step\"+t.step);\n\t\t\t\t//t.show();\n\t\t\t}\n\t\t\tboolean f=true;\n/*\t\t\tfor(S t : que){\n\t\t\t\tf&=t.mapEqauls(s);\n\t\t\t}*/\n\t\t\tfor(S t:nexts){\n\t\t\t\tboolean ff=false;\n\t\t\t\tfor(S u:list){\n\t\t\t\t\tif(t.mapEqauls(u)){\n\t\t\t\t\t\tff=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ff){\n\t\t\t\t\t// list.add(t);\n\t\t\t\t\tque.offer(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// que.addAll(nexts);\n\t\t}\n\t\tprintln(\"-1\");\n\t}\n\n\tclass S{\n\t\tint[][] a;\n\t\tint x, y;\n\t\tint step;\n\n\t\tS(int x, int y, int step){\n\t\t\ta=new int[n][n];\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.step=step;\n\t\t}\n\n\t\tint nInfect(){\n\t\t\tint c=0;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tboolean mapEqauls(S s){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]!=s.a[j][i]){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tLinkedList<S> nextStates(){\n\t\t\tLinkedList<S> ret=new LinkedList<S>();\n\t\t\tint[] dx={-1, 0, 1, -1, 1, -1, 0, 1};\n\t\t\tint[] dy={-1, -1, -1, 0, 0, 1, 1, 1};\n\t\t\tfor(int d=0; d<8; d++){\n\t\t\t\tint nx=x+dx[d];\n\t\t\t\tint ny=y+dy[d];\n\t\t\t\tif(nx<0||nx>=n||ny<0||ny>=n)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(a[ny][nx]==1)\n\t\t\t\t\tcontinue;\n\t\t\t\ta[ny][nx]=2;\n\t\t\t\ta[y][x]=0;\n\t\t\t\tS s=new S(nx, ny, step+1);\n\t\t\t\tfor(int y=0; y<n; y++){\n\t\t\t\t\tfor(int x=0; x<n; x++){\n\t\t\t\t\t\tint c=0;\n\t\t\t\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\t\t\t\tint x2=x+dx[i];\n\t\t\t\t\t\t\tint y2=y+dy[i];\n\t\t\t\t\t\t\tif(x2<0||x2>=n||y2<0||y2>=n)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(a[y2][x2]!=0){\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[y][x]==0){\n\t\t\t\t\t\t\tif(c==3){\n\t\t\t\t\t\t\t\ts.a[y][x]=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts.a[y][x]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(a[y][x]==1){\n\t\t\t\t\t\t\tif(c==2||c==3){\n\t\t\t\t\t\t\t\ts.a[y][x]=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts.a[y][x]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ts.a[y][x]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.add(s);\n\t\t\t\ta[ny][nx]=0;\n\t\t\t\ta[y][x]=2;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid show(){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tprint(\"\"+obj[a[j][i]]);\n\t\t\t\t}\n\t\t\t\tprintln(\"\");\n\t\t\t}\n\t\t\tprintln(\"\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tint[][] a;\n\tint x0, y0;\n\t// 0 .\n\t// 1 #\n\t// 2 @\n\tchar[] obj={'.', '#', '@'};\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tchar c=s.charAt(i);\n\t\t\t\t\tif(c=='.')\n\t\t\t\t\t\ta[j][i]=0;\n\t\t\t\t\telse if(c=='#')\n\t\t\t\t\t\ta[j][i]=1;\n\t\t\t\t\telse if(c=='@'){\n\t\t\t\t\t\ta[j][i]=2;\n\t\t\t\t\t\tx0=i;\n\t\t\t\t\t\ty0=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tQueue<S> que=new LinkedList<S>();\n\t\tLinkedList<S> list=new LinkedList<S>();// ¡ÜÅÉo½âÂ\n\n\t\tS s0=new S(x0, y0, 0);\n\t\tfor(int j=0; j<n; j++)\n\t\t\tSystem.arraycopy(a[j], 0, s0.a[j], 0, n);\n\n\t\tque.offer(s0);\n\t\tlist.add(s0);\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tS s=que.poll();\n\t\t\t//println(\"step:\"+s.step);\n\t\t\t//s.show();\n\t\t\tif(s.nInfect()==0){\n\t\t\t\tprintln(s.step+\"\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// list.add(s);\n\n\t\t\t// sÌ×ÚóÔðñµÄL[ÉÇÁ\n\t\t\tLinkedList<S> nexts=s.nextStates();\n\n\t\t\tfor(S t : nexts){\n\t\t\t\t//println(\"step\"+t.step);\n\t\t\t\t//t.show();\n\t\t\t}\n\n\t\t\tfor(S t : nexts){\n\t\t\t\tboolean f=false;\n\t\t\t\tfor(S u : list){\n\t\t\t\t\tif(t.mapEqauls(u)){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tque.offer(t);\n\t\t\t\t\tlist.add(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(\"-1\");\n\t}\n\n\tclass S{\n\t\tint[][] a;\n\t\tint x, y;\n\t\tint step;\n\n\t\tS(int x, int y, int step){\n\t\t\ta=new int[n][n];\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.step=step;\n\t\t}\n\n\t\tint nInfect(){\n\t\t\tint c=0;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tboolean mapEqauls(S s){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]!=s.a[j][i]){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tLinkedList<S> nextStates(){\n\t\t\tLinkedList<S> ret=new LinkedList<S>();\n\t\t\tint[] dx={-1, 0, 1, -1, 1, -1, 0, 1};\n\t\t\tint[] dy={-1, -1, -1, 0, 0, 1, 1, 1};\n\t\t\tfor(int d=0; d<8; d++){\n\t\t\t\tint nx=x+dx[d];\n\t\t\t\tint ny=y+dy[d];\n\t\t\t\tif(nx<0||nx>=n||ny<0||ny>=n)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(a[ny][nx]==1)\n\t\t\t\t\tcontinue;\n\t\t\t\ta[ny][nx]=2;\n\t\t\t\ta[y][x]=0;\n\t\t\t\tS s=new S(nx, ny, step+1);\n\t\t\t\tfor(int y=0; y<n; y++){\n\t\t\t\t\tfor(int x=0; x<n; x++){\n\t\t\t\t\t\tint c=0;\n\t\t\t\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\t\t\t\tint x2=x+dx[i];\n\t\t\t\t\t\t\tint y2=y+dy[i];\n\t\t\t\t\t\t\tif(x2<0||x2>=n||y2<0||y2>=n)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(a[y2][x2]!=0){\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[y][x]==0){\n\t\t\t\t\t\t\tif(c==3){\n\t\t\t\t\t\t\t\ts.a[y][x]=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts.a[y][x]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(a[y][x]==1){\n\t\t\t\t\t\t\tif(c==2||c==3){\n\t\t\t\t\t\t\t\ts.a[y][x]=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts.a[y][x]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ts.a[y][x]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.add(s);\n\t\t\t\ta[ny][nx]=0;\n\t\t\t\ta[y][x]=2;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid show(){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tprint(\"\"+obj[a[j][i]]);\n\t\t\t\t}\n\t\t\t\tprintln(\"\");\n\t\t\t}\n\t\t\tprintln(\"\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t// int map[][];\n\n\tint n;\n\n\tclass S implements Comparable<S> {\n\t\tint value;\n\t\tint cost;\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn cost - tar.cost;\n\t\t}\n\n\t\tS(int value, int cost) {\n\t\t\tthis.value = value;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tboolean goaled(int arg) {\n\t\tint v2 = arg >> 6;\n\t\tint bc = Integer.bitCount(v2);\n\t\treturn bc == n * n - 1;\n\t}\n\n\tint[][] encode(int arg) {\n\t\tint[][] ret = new int[n][n];\n\n\t\tint px = arg & 7;\n\t\targ = arg >> 3;\n\t\tint py = arg & 7;\n\t\targ = arg >> 3;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret[n - i - 1][n - j - 1] = ((arg & 1) == 1 ? '.' : '#');\n\t\t\t\targ = arg >> 1;\n\t\t\t}\n\t\t}\n\t\tret[py][px] = '@';\n\t\treturn ret;\n\t}\n\n\tint decode(int map[][]) {\n\t\tint ret = 0;\n\t\tint py = -1;\n\t\tint px = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret = ret << 1;\n\t\t\t\tret += map[i][j] == '.' ? 1 : 0;\n\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\tpy = i;\n\t\t\t\t\tpx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = (((ret << 3) + py) << 3) + px;\n\t\t// System.out.println(py+\" \"+px+\" \"+ Integer.toBinaryString(ret));\n\t\treturn ret;\n\t}\n\n\tint[][] infect(int m2[][]) {\n\t\tint k[][] = new int[n][n];\n\n\t\tint next[][] = new int[n][n];\n\t\tfor (int ny = 0; ny < n; ny++) {\n\t\t\tfor (int nx = 0; nx < n; nx++) {\n\t\t\t\tif (m2[ny][nx] == '@') {\n\t\t\t\t\tnext[ny][nx] = '@';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m2[i][j] != '.') {\n\t\t\t\t\t\t\tk[ny][nx]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k[ny][nx] == 3 || (m2[ny][nx] == '#' && k[ny][nx] == 2)) {\n\t\t\t\t\tnext[ny][nx] = '#';\n\t\t\t\t} else {\n\t\t\t\t\tnext[ny][nx] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next;\n\t}\n\n\tvoid run() {\n\t\tboolean used[] = new boolean[1 << 25];\n\t\tint mask = (1 << 25) - 1;\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[n][n];\n\n\t\t\tint py = -1;\n\t\t\tint px = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString buffer = sc.next();\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = buffer.charAt(j);\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tpy = i;\n\t\t\t\t\t\tpx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(used, false);\n\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\n\t\t\tq.add(new S(decode(map), 0));\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tS st = q.poll();\n\t\t\t\tif (used[st.value & mask]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(st.cost > 15){\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[st.value & mask] = true;\n\t\t\t\t// System.out.println(Arrays.deepToString(encode(st.value)));\n\t\t\t\t// System.out.println();\n\t\t\t\tif (goaled(st.value)) {\n\t\t\t\t\tSystem.out.println(st.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint nx = st.value & 7;\n\t\t\t\tint ny = (st.value >> 3) & 7;\n\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// System.out.println(\"here\");\n\t\t\t\t\t\tint[][] m2 = encode(st.value);\n\t\t\t\t\t\tif (m2[i][j] == '.') {\n\t\t\t\t\t\t\tm2[i][j] = '@';\n\t\t\t\t\t\t\tm2[ny][nx] = '.';\n\t\t\t\t\t\t\t// System.out.println(Arrays.deepToString(m2));\n\t\t\t\t\t\t\tint[][] n2 = infect(m2);\n\t\t\t\t\t\t\tint next = decode(n2);\n\t\t\t\t\t\t\tif (!used[next & mask])\n\t\t\t\t\t\t\t\tq.add(new S(next, st.cost + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint n;\n\tint[] dx = {-1,-1,-1,0,1,1,1,0};\n\tint[] dy = {1,0,-1,-1,-1,0,1,1};\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tint S = 0;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\tswitch (str.charAt(j)) {\n\t\t\t\t\tcase '.': break;\n\t\t\t\t\tcase '#': S |= 1<<(i*n+j+6); break;\n\t\t\t\t\tcase '@': S |= j<<3; S |= i; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tHashSet<Integer> used = new HashSet<Integer>();\n\t\t\tused.add(S);\n\t\t\tLinkedList<P> que = new LinkedList<P>(); que.add(new P(S, 0));\n\t\t\tboolean ok = false;\n\t\t\tfor(;!que.isEmpty();) {\n\t\t\t\tP cur = que.remove();\n\t\t\t\tif( (cur.s >> 6) == 0 ) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tSystem.out.println(cur.d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tshort x = (short)((cur.s>>3)&7), y = (short)(cur.s&7);\n\t\t\t\tboolean map[][] = new boolean[n][n];\n\t\t\t\tfor(int i=0;i<n*n;i++) map[i/n][i%n] = ((cur.s>>(i+6))&1) == 1;\n\t\t\t\t\n//\t\t\t\tdebug(x, y);\n//\t\t\t\tfor(boolean[] a: map) debug(a);\n\n\t\t\t\tfor(int i=0;i<8;i++) {\n\t\t\t\t\tint px = x + dx[i], py = y + dy[i];\n\t\t\t\t\tif(!out(px, py) && !map[py][px]){\n//\t\t\t\t\tdebug(px, py);\n\t\t\t\t\t\tmap[py][px] = true;\n\t\t\t\t\t\tint NS = (px<<3)|py;\n\t\t\t\t\t\tfor(int j=0;j<n;j++) for(int k=0;k<n;k++) {\n\t\t\t\t\t\t\tif( px == k && py == j ) continue;\n\t\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\t\tfor(int l=0;l<8;l++) {\n\t\t\t\t\t\t\t\tint nx = k+dx[l], ny = j+dy[l];\n\t\t\t\t\t\t\t\tif(!out(nx, ny) && map[ny][nx])cnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[j][k] && ( cnt == 2 || cnt == 3)) NS |= 1<<(j*n+k+6);\n\t\t\t\t\t\t\telse if(!map[j][k] && cnt == 3) NS |= 1<<(j*n+k+6);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!used.contains(NS)){\n\t\t\t\t\t\t\tused.add(NS);\n\t\t\t\t\t\t\tque.add(new P(NS, cur.d+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmap[py][px] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!ok) System.out.println(-1);\n\t\t}\n\t}\n\t\n\tboolean out(int x, int y) {\n\t\treturn x < 0 || y < 0 || x >= n || y >= n;\n\t}\n\t\n\tclass P {\n\t\tint s; int d;\n\t\tP(int s, int d) {\n\t\t\tthis.s = s; this.d = d;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t// int map[][];\n\n\tint n;\n\n\tclass S implements Comparable<S> {\n\t\tint value;\n\t\tint cost;\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn cost - tar.cost;\n\t\t}\n\n\t\tS(int value, int cost) {\n\t\t\tthis.value = value;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tboolean goaled(int arg) {\n\t\tint v2 = arg >> 6;\n\t\tint bc = Integer.bitCount(v2);\n\t\treturn bc == n * n - 1;\n\t}\n\n\tint[][] encode(int arg) {\n\t\tint[][] ret = new int[n][n];\n\n\t\tint px = arg & 7;\n\t\targ = arg >> 3;\n\t\tint py = arg & 7;\n\t\targ = arg >> 3;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret[n - i - 1][n - j - 1] = ((arg & 1) == 1 ? '.' : '#');\n\t\t\t\targ = arg >> 1;\n\t\t\t}\n\t\t}\n\t\tret[py][px] = '@';\n\t\treturn ret;\n\t}\n\n\tint decode(int map[][]) {\n\t\tint ret = 0;\n\t\tint py = -1;\n\t\tint px = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret = ret << 1;\n\t\t\t\tret += map[i][j] == '.' ? 1 : 0;\n\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\tpy = i;\n\t\t\t\t\tpx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = (((ret << 3) + py) << 3) + px;\n\t\t// System.out.println(py+\" \"+px+\" \"+ Integer.toBinaryString(ret));\n\t\treturn ret;\n\t}\n\n\tint[][] infect(int m2[][]) {\n\t\tint k[][] = new int[n][n];\n\n\t\tint next[][] = new int[n][n];\n\t\tfor (int ny = 0; ny < n; ny++) {\n\t\t\tfor (int nx = 0; nx < n; nx++) {\n\t\t\t\tif (m2[ny][nx] == '@') {\n\t\t\t\t\tnext[ny][nx] = '@';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m2[i][j] != '.') {\n\t\t\t\t\t\t\tk[ny][nx]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k[ny][nx] == 3 || (m2[ny][nx] == '#' && k[ny][nx] == 2)) {\n\t\t\t\t\tnext[ny][nx] = '#';\n\t\t\t\t} else {\n\t\t\t\t\tnext[ny][nx] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next;\n\t}\n\n\tvoid run() {\n\t\tboolean used[] = new boolean[1 << 25];\n\t\tint mask = (1 << 25) - 1;\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[n][n];\n\n\t\t\tint py = -1;\n\t\t\tint px = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString buffer = sc.next();\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = buffer.charAt(j);\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tpy = i;\n\t\t\t\t\t\tpx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(used, false);\n\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\n\t\t\tq.add(new S(decode(map), 0));\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tS st = q.poll();\n\t\t\t\tif (used[st.value & mask]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(st.cost > 30){\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[st.value & mask] = true;\n\t\t\t\t// System.out.println(Arrays.deepToString(encode(st.value)));\n\t\t\t\t// System.out.println();\n\t\t\t\tif (goaled(st.value)) {\n\t\t\t\t\tSystem.out.println(st.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint nx = st.value & 7;\n\t\t\t\tint ny = (st.value >> 3) & 7;\n\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// System.out.println(\"here\");\n\t\t\t\t\t\tint[][] m2 = encode(st.value);\n\t\t\t\t\t\tif (m2[i][j] == '.') {\n\t\t\t\t\t\t\tm2[i][j] = '@';\n\t\t\t\t\t\t\tm2[ny][nx] = '.';\n\t\t\t\t\t\t\t// System.out.println(Arrays.deepToString(m2));\n\t\t\t\t\t\t\tint[][] n2 = infect(m2);\n\t\t\t\t\t\t\tint next = decode(n2);\n\t\t\t\t\t\t\tif (!used[next & mask])\n\t\t\t\t\t\t\t\tq.add(new S(next, st.cost + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tbyte[][] a;\n\tint x0, y0;\n\t// 0 .\n\t// 1 #\n\t// 2 @\n\tchar[] obj={'.', '#', '@'};\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new byte[n][n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tchar c=s.charAt(i);\n\t\t\t\t\tif(c=='.')\n\t\t\t\t\t\ta[j][i]=0;\n\t\t\t\t\telse if(c=='#')\n\t\t\t\t\t\ta[j][i]=1;\n\t\t\t\t\telse if(c=='@'){\n\t\t\t\t\t\ta[j][i]=2;\n\t\t\t\t\t\tx0=i;\n\t\t\t\t\t\ty0=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tQueue<S> que=new LinkedList<S>();\n\t\tTreeSet<S> memo=new TreeSet<S>();\n\n\t\tS s0=new S(x0, y0, 0);\n\t\tfor(int j=0; j<n; j++)\n\t\t\tSystem.arraycopy(a[j], 0, s0.a[j], 0, n);\n\n\t\tque.offer(s0);\n\t\tmemo.add(s0);\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tS s=que.poll();\n\t\t\t// println(\"step:\"+s.step);\n\t\t\t// s.show();\n\t\t\tif(s.nInfect()==0){\n\t\t\t\tprintln(s.step+\"\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(s.step>15){\n\t\t\t\tprintln(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// list.add(s);\n\n\t\t\t// sÌ×ÚóÔðñµÄL[ÉÇÁ\n\t\t\tLinkedList<S> nexts=s.nextStates();\n\n\t\t\tfor(S t : nexts){\n\t\t\t\t// println(\"step\"+t.step);\n\t\t\t\t// t.show();\n\t\t\t}\n\n\t\t\tfor(S t : nexts){\n\t\t\t\tboolean f=false;\n\t\t\t\t\n\t\t\t\t/*for(S u : memo){\n\t\t\t\t\tif(t.x==u.x&&t.y==u.y&&t.mapEqauls(u)){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tque.offer(t);\n\t\t\t\t\tmemo.add(t);\n\t\t\t\t}*/\n\t\t\t\tif(!memo.contains(t)){\n\t\t\t\t\tque.offer(t);\n\t\t\t\t\tmemo.add(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(\"-1\");\n\t}\n\n\tclass S implements Comparable<S>{\n\t\tbyte[][] a;\n\t\tint x, y;\n\t\tint step;\n\n\t\tS(int x, int y, int step){\n\t\t\ta=new byte[n][n];\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.step=step;\n\t\t}\n\n\t\tint nInfect(){\n\t\t\tint c=0;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tboolean mapEqauls(S s){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]!=s.a[j][i]){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tLinkedList<S> nextStates(){\n\t\t\tLinkedList<S> ret=new LinkedList<S>();\n\t\t\tint[] dx={-1, 0, 1, -1, 1, -1, 0, 1};\n\t\t\tint[] dy={-1, -1, -1, 0, 0, 1, 1, 1};\n\t\t\tfor(int d=0; d<8; d++){\n\t\t\t\tint nx=x+dx[d];\n\t\t\t\tint ny=y+dy[d];\n\t\t\t\tif(nx<0||nx>=n||ny<0||ny>=n)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(a[ny][nx]==1)\n\t\t\t\t\tcontinue;\n\t\t\t\ta[ny][nx]=2;\n\t\t\t\ta[y][x]=0;\n\t\t\t\tS s=new S(nx, ny, step+1);\n\t\t\t\tfor(int y=0; y<n; y++){\n\t\t\t\t\tfor(int x=0; x<n; x++){\n\t\t\t\t\t\tint c=0;\n\t\t\t\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\t\t\t\tint x2=x+dx[i];\n\t\t\t\t\t\t\tint y2=y+dy[i];\n\t\t\t\t\t\t\tif(x2<0||x2>=n||y2<0||y2>=n)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(a[y2][x2]!=0){\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[y][x]==0){\n\t\t\t\t\t\t\tif(c==3){\n\t\t\t\t\t\t\t\ts.a[y][x]=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts.a[y][x]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(a[y][x]==1){\n\t\t\t\t\t\t\tif(c==2||c==3){\n\t\t\t\t\t\t\t\ts.a[y][x]=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts.a[y][x]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ts.a[y][x]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.add(s);\n\t\t\t\ta[ny][nx]=0;\n\t\t\t\ta[y][x]=2;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid show(){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tprint(\"\"+obj[a[j][i]]);\n\t\t\t\t}\n\t\t\t\tprintln(\"\");\n\t\t\t}\n\t\t\tprintln(\"\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(S s){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]<s.a[j][i])\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\telse if(a[j][i]>s.a[j][i])\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t// int map[][];\n\n\tint n;\n\n\tclass S implements Comparable<S> {\n\t\tint value;\n\t\tint cost;\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn cost - tar.cost;\n\t\t}\n\n\t\tS(int value, int cost) {\n\t\t\tthis.value = value;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tboolean goaled(int arg) {\n\t\tint v2 = arg >> 6;\n\t\tint bc = Integer.bitCount(v2);\n\t\treturn bc == n * n - 1;\n\t}\n\n\tint[][] encode(int arg) {\n\t\tint[][] ret = new int[n][n];\n\n\t\tint px = arg & 7;\n\t\targ = arg >> 3;\n\t\tint py = arg & 7;\n\t\targ = arg >> 3;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret[n - i - 1][n - j - 1] = ((arg & 1) == 1 ? '.' : '#');\n\t\t\t\targ = arg >> 1;\n\t\t\t}\n\t\t}\n\t\tret[py][px] = '@';\n\t\treturn ret;\n\t}\n\n\tint decode(int map[][]) {\n\t\tint ret = 0;\n\t\tint py = -1;\n\t\tint px = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret = ret << 1;\n\t\t\t\tret += map[i][j] == '.' ? 1 : 0;\n\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\tpy = i;\n\t\t\t\t\tpx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = (((ret << 3) + py) << 3) + px;\n\t\t// System.out.println(py+\" \"+px+\" \"+ Integer.toBinaryString(ret));\n\t\treturn ret;\n\t}\n\n\tint[][] infect(int m2[][]) {\n\t\tint k[][] = new int[n][n];\n\n\t\tint next[][] = new int[n][n];\n\t\tfor (int ny = 0; ny < n; ny++) {\n\t\t\tfor (int nx = 0; nx < n; nx++) {\n\t\t\t\tif (m2[ny][nx] == '@') {\n\t\t\t\t\tnext[ny][nx] = '@';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m2[i][j] != '.') {\n\t\t\t\t\t\t\tk[ny][nx]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k[ny][nx] == 3 || (m2[ny][nx] == '#' && k[ny][nx] == 2)) {\n\t\t\t\t\tnext[ny][nx] = '#';\n\t\t\t\t} else {\n\t\t\t\t\tnext[ny][nx] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next;\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[n][n];\n\n\t\t\tint py = -1;\n\t\t\tint px = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString buffer = sc.next();\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = buffer.charAt(j);\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tpy = i;\n\t\t\t\t\t\tpx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tTreeSet<Integer> used = new TreeSet<Integer>();\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\n\t\t\tq.add(new S(decode(map), 0));\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tS st = q.poll();\n\t\t\t\tif (used.contains(st.value)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(st.cost > 15){\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused.add(st.value);\n\t\t\t\t// System.out.println(Arrays.deepToString(encode(st.value)));\n\t\t\t\t// System.out.println();\n\t\t\t\tif (goaled(st.value)) {\n\t\t\t\t\tSystem.out.println(st.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint nx = st.value & 7;\n\t\t\t\tint ny = (st.value >> 3) & 7;\n\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// System.out.println(\"here\");\n\t\t\t\t\t\tint[][] m2 = encode(st.value);\n\t\t\t\t\t\tif (m2[i][j] == '.') {\n\t\t\t\t\t\t\tm2[i][j] = '@';\n\t\t\t\t\t\t\tm2[ny][nx] = '.';\n\t\t\t\t\t\t\t// System.out.println(Arrays.deepToString(m2));\n\t\t\t\t\t\t\tint[][] n2 = infect(m2);\n\t\t\t\t\t\t\tint next = decode(n2);\n\t\t\t\t\t\t\tif (!used.contains(next))\n\t\t\t\t\t\t\t\tq.add(new S(next, st.cost + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t// int map[][];\n\n\tint n;\n\n\tclass S implements Comparable<S> {\n\t\tint value;\n\t\tint cost;\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn cost - tar.cost;\n\t\t}\n\n\t\tS(int value, int cost) {\n\t\t\tthis.value = value;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tboolean goaled(int arg) {\n\t\tint v2 = arg >> 6;\n\t\tint bc = Integer.bitCount(v2);\n\t\treturn bc == n * n - 1;\n\t}\n\n\tint[][] encode(int arg) {\n\t\tint[][] ret = new int[n][n];\n\n\t\tint px = arg & 7;\n\t\targ = arg >> 3;\n\t\tint py = arg & 7;\n\t\targ = arg >> 3;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret[n - i - 1][n - j - 1] = ((arg & 1) == 1 ? '.' : '#');\n\t\t\t\targ = arg >> 1;\n\t\t\t}\n\t\t}\n\t\tret[py][px] = '@';\n\t\treturn ret;\n\t}\n\n\tint decode(int map[][]) {\n\t\tint ret = 0;\n\t\tint py = -1;\n\t\tint px = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret = ret << 1;\n\t\t\t\tret += map[i][j] == '.' ? 1 : 0;\n\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\tpy = i;\n\t\t\t\t\tpx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = (((ret << 3) + py) << 3) + px;\n\t\t// System.out.println(py+\" \"+px+\" \"+ Integer.toBinaryString(ret));\n\t\treturn ret;\n\t}\n\n\tint[][] infect(int m2[][]) {\n\t\tint k[][] = new int[n][n];\n\n\t\tint next[][] = new int[n][n];\n\t\tfor (int ny = 0; ny < n; ny++) {\n\t\t\tfor (int nx = 0; nx < n; nx++) {\n\t\t\t\tif (m2[ny][nx] == '@') {\n\t\t\t\t\tnext[ny][nx] = '@';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m2[i][j] != '.') {\n\t\t\t\t\t\t\tk[ny][nx]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k[ny][nx] == 3 || (m2[ny][nx] == '#' && k[ny][nx] == 2)) {\n\t\t\t\t\tnext[ny][nx] = '#';\n\t\t\t\t} else {\n\t\t\t\t\tnext[ny][nx] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next;\n\t}\n\n\tvoid run() {\n\t\tboolean used[] = new boolean[1 << 25];\n\t\tint mask = (1 << 25) - 1;\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[n][n];\n\n\t\t\tint py = -1;\n\t\t\tint px = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString buffer = sc.next();\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = buffer.charAt(j);\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tpy = i;\n\t\t\t\t\t\tpx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(used, false);\n\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\n\t\t\tq.add(new S(decode(map), 0));\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tS st = q.poll();\n\t\t\t\tif (used[st.value & mask]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[st.value & mask] = true;\n\t\t\t\t// System.out.println(Arrays.deepToString(encode(st.value)));\n\t\t\t\t// System.out.println();\n\t\t\t\tif (goaled(st.value)) {\n\t\t\t\t\tSystem.out.println(st.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint nx = st.value & 7;\n\t\t\t\tint ny = (st.value >> 3) & 7;\n\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// System.out.println(\"here\");\n\t\t\t\t\t\tint[][] m2 = encode(st.value);\n\t\t\t\t\t\tif (m2[i][j] == '.') {\n\t\t\t\t\t\t\tm2[i][j] = '@';\n\t\t\t\t\t\t\tm2[ny][nx] = '.';\n\t\t\t\t\t\t\t// System.out.println(Arrays.deepToString(m2));\n\t\t\t\t\t\t\tint[][] n2 = infect(m2);\n\t\t\t\t\t\t\tint next = decode(n2);\n\t\t\t\t\t\t\tif (!used[next & mask])\n\t\t\t\t\t\t\t\tq.add(new S(next, st.cost + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t// int map[][];\n\n\tint n;\n\n\tclass S implements Comparable<S> {\n\t\tint value;\n\t\tint cost;\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn cost - tar.cost;\n\t\t}\n\n\t\tS(int value, int cost) {\n\t\t\tthis.value = value;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tboolean goaled(int arg) {\n\t\tint v2 = arg >> 6;\n\t\tint bc = Integer.bitCount(v2);\n\t\treturn bc == n * n - 1;\n\t}\n\n\tint[][] encode(int arg) {\n\t\tint[][] ret = new int[n][n];\n\n\t\tint px = arg & 7;\n\t\targ = arg >> 3;\n\t\tint py = arg & 7;\n\t\targ = arg >> 3;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret[n - i - 1][n - j - 1] = ((arg & 1) == 1 ? '.' : '#');\n\t\t\t\targ = arg >> 1;\n\t\t\t}\n\t\t}\n\t\tret[py][px] = '@';\n\t\treturn ret;\n\t}\n\n\tint decode(int map[][]) {\n\t\tint ret = 0;\n\t\tint py = -1;\n\t\tint px = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret = ret << 1;\n\t\t\t\tret += map[i][j] == '.' ? 1 : 0;\n\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\tpy = i;\n\t\t\t\t\tpx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = (((ret << 3) + py) << 3) + px;\n//\t\tSystem.out.println(py+\" \"+px+\" \"+ Integer.toBinaryString(ret));\n\t\treturn ret;\n\t}\n\n\tint[][] infect(int m2[][]) {\n\t\tint k[][] = new int[n][n];\n\n\t\tint next[][] = new int[n][n];\n\t\tfor (int ny = 0; ny < n; ny++) {\n\t\t\tfor (int nx = 0; nx < n; nx++) {\n\t\t\t\tif (m2[ny][nx] == '@') {\n\t\t\t\t\tnext[ny][nx] = '@';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m2[i][j] != '.') {\n\t\t\t\t\t\t\tk[ny][nx]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k[ny][nx] == 3 || (m2[ny][nx] == '#' && k[ny][nx] == 2)) {\n\t\t\t\t\tnext[ny][nx] = '#';\n\t\t\t\t} else {\n\t\t\t\t\tnext[ny][nx] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next;\n\t}\n\n\tvoid run() {\n\t\tboolean used[] = new boolean[1<<31];\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[n][n];\n\n\t\t\tint py = -1;\n\t\t\tint px = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString buffer = sc.next();\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = buffer.charAt(j);\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tpy = i;\n\t\t\t\t\t\tpx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(used, false);\n\t\t\t\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\n\t\t\tq.add(new S(decode(map), 0));\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tS st = q.poll();\n\t\t\t\tif (used[st.value]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[st.value] = true;\n//\t\t\t\tSystem.out.println(Arrays.deepToString(encode(st.value)));\n//\t\t\t\tSystem.out.println();\n\t\t\t\tif (goaled(st.value)) {\n\t\t\t\t\tSystem.out.println(st.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint nx = st.value & 7;\n\t\t\t\tint ny = (st.value >> 3) & 7;\n\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println(\"here\");\n\t\t\t\t\t\tint[][] m2 = encode(st.value);\n\t\t\t\t\t\tif (m2[i][j] == '.') {\n\t\t\t\t\t\t\tm2[i][j] = '@';\n\t\t\t\t\t\t\tm2[ny][nx] = '.';\n//\t\t\t\t\t\t\tSystem.out.println(Arrays.deepToString(m2));\n\t\t\t\t\t\t\tint[][] n2 = infect(m2);\n\t\t\t\t\t\t\tint next = decode(n2);\n\t\t\t\t\t\t\tq.add(new S(next, st.cost + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t// int map[][];\n\n\tint n;\n\n\tclass S implements Comparable<S> {\n\t\tint value;\n\t\tint cost;\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn cost - tar.cost;\n\t\t}\n\n\t\tS(int value, int cost) {\n\t\t\tthis.value = value;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tboolean goaled(int arg) {\n\t\tint v2 = arg >> 6;\n\t\tint bc = Integer.bitCount(v2);\n\t\treturn bc == n * n - 1;\n\t}\n\n\tint[][] encode(int arg) {\n\t\tint[][] ret = new int[n][n];\n\n\t\tint px = arg & 7;\n\t\targ = arg >> 3;\n\t\tint py = arg & 7;\n\t\targ = arg >> 3;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret[n - i - 1][n - j - 1] = ((arg & 1) == 1 ? '.' : '#');\n\t\t\t\targ = arg >> 1;\n\t\t\t}\n\t\t}\n\t\tret[py][px] = '@';\n\t\treturn ret;\n\t}\n\n\tint decode(int map[][]) {\n\t\tint ret = 0;\n\t\tint py = -1;\n\t\tint px = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret = ret << 1;\n\t\t\t\tret += map[i][j] == '.' ? 1 : 0;\n\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\tpy = i;\n\t\t\t\t\tpx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = (((ret << 3) + py) << 3) + px;\n\t\t// System.out.println(py+\" \"+px+\" \"+ Integer.toBinaryString(ret));\n\t\treturn ret;\n\t}\n\n\tint[][] infect(int m2[][]) {\n\t\tint k[][] = new int[n][n];\n\n\t\tint next[][] = new int[n][n];\n\t\tfor (int ny = 0; ny < n; ny++) {\n\t\t\tfor (int nx = 0; nx < n; nx++) {\n\t\t\t\tif (m2[ny][nx] == '@') {\n\t\t\t\t\tnext[ny][nx] = '@';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m2[i][j] != '.') {\n\t\t\t\t\t\t\tk[ny][nx]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k[ny][nx] == 3 || (m2[ny][nx] == '#' && k[ny][nx] == 2)) {\n\t\t\t\t\tnext[ny][nx] = '#';\n\t\t\t\t} else {\n\t\t\t\t\tnext[ny][nx] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next;\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[n][n];\n\n\t\t\tint py = -1;\n\t\t\tint px = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString buffer = sc.next();\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = buffer.charAt(j);\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tpy = i;\n\t\t\t\t\t\tpx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tTreeSet<Integer> used = new TreeSet<Integer>();\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\n\t\t\tq.add(new S(decode(map), 0));\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tS st = q.poll();\n\t\t\t\tif (used.contains(st.value)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused.add(st.value);\n\t\t\t\t// System.out.println(Arrays.deepToString(encode(st.value)));\n\t\t\t\t// System.out.println();\n\t\t\t\tif (goaled(st.value)) {\n\t\t\t\t\tSystem.out.println(st.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint nx = st.value & 7;\n\t\t\t\tint ny = (st.value >> 3) & 7;\n\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// System.out.println(\"here\");\n\t\t\t\t\t\tint[][] m2 = encode(st.value);\n\t\t\t\t\t\tif (m2[i][j] == '.') {\n\t\t\t\t\t\t\tm2[i][j] = '@';\n\t\t\t\t\t\t\tm2[ny][nx] = '.';\n\t\t\t\t\t\t\t// System.out.println(Arrays.deepToString(m2));\n\t\t\t\t\t\t\tint[][] n2 = infect(m2);\n\t\t\t\t\t\t\tint next = decode(n2);\n\t\t\t\t\t\t\tif (!used.contains(next))\n\t\t\t\t\t\t\t\tq.add(new S(next, st.cost + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t// int map[][];\n\n\tint n;\n\n\tclass S implements Comparable<S> {\n\t\tint value;\n\t\tint cost;\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn cost - tar.cost;\n\t\t}\n\n\t\tS(int value, int cost) {\n\t\t\tthis.value = value;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tboolean goaled(int arg) {\n\t\tint v2 = arg >> 6;\n\t\tint bc = Integer.bitCount(v2);\n\t\treturn bc == n * n - 1;\n\t}\n\n\tint[][] encode(int arg) {\n\t\tint[][] ret = new int[n][n];\n\n\t\tint px = arg & 7;\n\t\targ = arg >> 3;\n\t\tint py = arg & 7;\n\t\targ = arg >> 3;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret[n - i - 1][n - j - 1] = ((arg & 1) == 1 ? '.' : '#');\n\t\t\t\targ = arg >> 1;\n\t\t\t}\n\t\t}\n\t\tret[py][px] = '@';\n\t\treturn ret;\n\t}\n\n\tint decode(int map[][]) {\n\t\tint ret = 0;\n\t\tint py = -1;\n\t\tint px = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tret = ret << 1;\n\t\t\t\tret += map[i][j] == '.' ? 1 : 0;\n\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\tpy = i;\n\t\t\t\t\tpx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = (((ret << 3) + py) << 3) + px;\n//\t\tSystem.out.println(py+\" \"+px+\" \"+ Integer.toBinaryString(ret));\n\t\treturn ret;\n\t}\n\n\tint[][] infect(int m2[][]) {\n\t\tint k[][] = new int[n][n];\n\n\t\tint next[][] = new int[n][n];\n\t\tfor (int ny = 0; ny < n; ny++) {\n\t\t\tfor (int nx = 0; nx < n; nx++) {\n\t\t\t\tif (m2[ny][nx] == '@') {\n\t\t\t\t\tnext[ny][nx] = '@';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m2[i][j] != '.') {\n\t\t\t\t\t\t\tk[ny][nx]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k[ny][nx] == 3 || (m2[ny][nx] == '#' && k[ny][nx] == 2)) {\n\t\t\t\t\tnext[ny][nx] = '#';\n\t\t\t\t} else {\n\t\t\t\t\tnext[ny][nx] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next;\n\t}\n\n\tvoid run() {\n\t\tboolean used[] = new boolean[1<<25];\n\t\tint mask = (1<<25)-1;\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[n][n];\n\n\t\t\tint py = -1;\n\t\t\tint px = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString buffer = sc.next();\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = buffer.charAt(j);\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tpy = i;\n\t\t\t\t\t\tpx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(used, false);\n\t\t\t\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\n\t\t\tq.add(new S(decode(map), 0));\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tS st = q.poll();\n\t\t\t\tif (used[st.value&mask]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[st.value&mask] = true;\n//\t\t\t\tSystem.out.println(Arrays.deepToString(encode(st.value)));\n//\t\t\t\tSystem.out.println();\n\t\t\t\tif (goaled(st.value)) {\n\t\t\t\t\tSystem.out.println(st.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint nx = st.value & 7;\n\t\t\t\tint ny = (st.value >> 3) & 7;\n\n\t\t\t\tfor (int i = ny - 1; i < ny + 2; i++) {\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = nx - 1; j < nx + 2; j++) {\n\t\t\t\t\t\tif (i == ny && j == nx) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= n) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println(\"here\");\n\t\t\t\t\t\tint[][] m2 = encode(st.value);\n\t\t\t\t\t\tif (m2[i][j] == '.') {\n\t\t\t\t\t\t\tm2[i][j] = '@';\n\t\t\t\t\t\t\tm2[ny][nx] = '.';\n//\t\t\t\t\t\t\tSystem.out.println(Arrays.deepToString(m2));\n\t\t\t\t\t\t\tint[][] n2 = infect(m2);\n\t\t\t\t\t\t\tint next = decode(n2);\n\t\t\t\t\t\t\tq.add(new S(next, st.cost + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tchar[][] board;\n\tint N;\n\tint dx[] = {0,0,1,1,1,-1,-1,-1};\n\tint dy[] = {1,-1,1,0,-1,1,0,-1};\n\tint maxDepth;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = in.nextInt();\n\t\t\tif(N==0) return ;\n\t\t\tboard = new char[N][];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tboard[i] = in.next().toCharArray();\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tboolean dfs(int depth){\n\t\tif(depth > maxDepth) return false;\n\t\tint x = 0, y = 0;\n\t\tboolean foundVirus = false;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(board[i][j] == '#'){\n\t\t\t\t\tfoundVirus = true;\n\t\t\t\t}\n\t\t\t\telse if(board[i][j] == '@'){\n\t\t\t\t\ty = i; x = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!foundVirus){\n\t\t\treturn true;\n\t\t}\n\t\tchar[][] tmp = new char[N][];\n\t\tfor(int i=0; i<N; i++){\n\t\t\ttmp[i] = board[i].clone();\n\t\t}\n\t\tfor(int k=0; k<8; k++){\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif(0<=nx && nx<N && 0<=ny && ny<N && tmp[ny][nx]!='#'){\n\t\t\t\ttmp[y][x] = '.';\n\t\t\t\ttmp[ny][nx] = '@';\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int kk=0; kk<8; kk++){\n\t\t\t\t\t\t\tint nny = i + dy[kk], nnx = j + dx[kk];\n\t\t\t\t\t\t\tif(0<=nny && nny<N && 0<=nnx && nnx<N && tmp[nny][nnx]!='.')\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(tmp[i][j] == '.'){\n\t\t\t\t\t\t\tboard[i][j] = (cnt==3?'#':'.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp[i][j] == '#'){\n\t\t\t\t\t\t\tboard[i][j] = ((cnt==2 || cnt==3)?'#':'.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tboard[i][j] = '@';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dfs(depth+1)) return true;\n\t\t\t\ttmp[ny][nx] = '.';\n\t\t\t\ttmp[y][x] = '@';\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\tboard[i][j] = tmp[i][j];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint solve(){\n\t\tfor(maxDepth=0; maxDepth<=11; maxDepth++){\n\t\t\tif(dfs(0)) return maxDepth;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tint[][] a;\n\tint x0, y0;\n\t// 0 .\n\t// 1 #\n\t// 2 @\n\tchar[] obj={'.', '#', '@'};\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tchar c=s.charAt(i);\n\t\t\t\t\tif(c=='.')\n\t\t\t\t\t\ta[j][i]=0;\n\t\t\t\t\telse if(c=='#')\n\t\t\t\t\t\ta[j][i]=1;\n\t\t\t\t\telse if(c=='@'){\n\t\t\t\t\t\ta[j][i]=2;\n\t\t\t\t\t\tx0=i;\n\t\t\t\t\t\ty0=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tQueue<S> que=new LinkedList<S>();\n\t\tLinkedList<S> list=new LinkedList<S>();// ¡ÜÅÉo½âÂ\n\n\t\tS s0=new S(x0, y0, 0);\n\t\tfor(int j=0; j<n; j++)\n\t\t\tSystem.arraycopy(a[j], 0, s0.a[j], 0, n);\n\n\t\tque.offer(s0);\n\t\tlist.add(s0);\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tS s=que.poll();\n\t\t\t//println(\"step:\"+s.step);\n\t\t\t//s.show();\n\t\t\tif(s.nInfect()==0){\n\t\t\t\tprintln(s.step+\"\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(s.step>15){\n\t\t\t\tprintln(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// list.add(s);\n\n\t\t\t// sÌ×ÚóÔðñµÄL[ÉÇÁ\n\t\t\tLinkedList<S> nexts=s.nextStates();\n\n\t\t\tfor(S t : nexts){\n\t\t\t\t//println(\"step\"+t.step);\n\t\t\t\t//t.show();\n\t\t\t}\n\n\t\t\tfor(S t : nexts){\n\t\t\t\tboolean f=false;\n\t\t\t\tfor(S u : list){\n\t\t\t\t\tif(t.mapEqauls(u)){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tque.offer(t);\n\t\t\t\t\tlist.add(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(\"-1\");\n\t}\n\n\tclass S{\n\t\tint[][] a;\n\t\tint x, y;\n\t\tint step;\n\n\t\tS(int x, int y, int step){\n\t\t\ta=new int[n][n];\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.step=step;\n\t\t}\n\n\t\tint nInfect(){\n\t\t\tint c=0;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tboolean mapEqauls(S s){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]!=s.a[j][i]){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tLinkedList<S> nextStates(){\n\t\t\tLinkedList<S> ret=new LinkedList<S>();\n\t\t\tint[] dx={-1, 0, 1, -1, 1, -1, 0, 1};\n\t\t\tint[] dy={-1, -1, -1, 0, 0, 1, 1, 1};\n\t\t\tfor(int d=0; d<8; d++){\n\t\t\t\tint nx=x+dx[d];\n\t\t\t\tint ny=y+dy[d];\n\t\t\t\tif(nx<0||nx>=n||ny<0||ny>=n)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(a[ny][nx]==1)\n\t\t\t\t\tcontinue;\n\t\t\t\ta[ny][nx]=2;\n\t\t\t\ta[y][x]=0;\n\t\t\t\tS s=new S(nx, ny, step+1);\n\t\t\t\tfor(int y=0; y<n; y++){\n\t\t\t\t\tfor(int x=0; x<n; x++){\n\t\t\t\t\t\tint c=0;\n\t\t\t\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\t\t\t\tint x2=x+dx[i];\n\t\t\t\t\t\t\tint y2=y+dy[i];\n\t\t\t\t\t\t\tif(x2<0||x2>=n||y2<0||y2>=n)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(a[y2][x2]!=0){\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[y][x]==0){\n\t\t\t\t\t\t\tif(c==3){\n\t\t\t\t\t\t\t\ts.a[y][x]=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts.a[y][x]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(a[y][x]==1){\n\t\t\t\t\t\t\tif(c==2||c==3){\n\t\t\t\t\t\t\t\ts.a[y][x]=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts.a[y][x]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ts.a[y][x]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.add(s);\n\t\t\t\ta[ny][nx]=0;\n\t\t\t\ta[y][x]=2;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid show(){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tprint(\"\"+obj[a[j][i]]);\n\t\t\t\t}\n\t\t\t\tprintln(\"\");\n\t\t\t}\n\t\t\tprintln(\"\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Infected Land\npublic class Main{\n\n\tclass R{\n\t\tString s;\n\t\tint pos, c;\n\t\tpublic R(String s, int pos, int c) {\n\t\t\tthis.s = s;\n\t\t\tthis.pos = pos;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] d = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tchar[] m = new char[n*n];\n\t\t\tint pos = 0, c = 0;;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tchar[] t = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(t[j]=='@')pos=i*n+j;\n\t\t\t\t\tif(t[j]=='#')c++;\n\t\t\t\t\tm[i*n+j]=t[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSet<String> v = new HashSet<String>();\n\t\t\tList<R> l = new ArrayList<R>();\n\t\t\tl.add(new R(new String(m), pos, c));\n\t\t\tv.add(l.get(0).s);\n\t\t\tint res = -1, step = 0;\n\t\t\twhile(!l.isEmpty()){\n\t\t\t\tList<R> next = new ArrayList<R>();\n\t\t\t\tfor(R r:l){\n\t\t\t\t\tif(r.c==0){\n\t\t\t\t\t\tres = step; next.clear(); break;\n\t\t\t\t\t}\n\t\t\t\t\tint pi = r.pos/n, pj = r.pos%n;\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\t\tchar[] map = r.s.toCharArray();\n\t\t\t\t\t\tif(0<=ni&&ni<n&&0<=nj&&nj<n&&map[ni*n+nj]=='.'){\n\t\t\t\t\t\t\tmap[ni*n+nj] = '@'; map[r.pos] = '.';\n\t\t\t\t\t\t\tint nc = 0;\n\t\t\t\t\t\t\tchar[] nm = new char[n*n];\n\t\t\t\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\t\t\t\t\tif(map[i*n+j]=='@'){\n\t\t\t\t\t\t\t\t\tnm[i*n+j] = '@';\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint adj = 0;\n\t\t\t\t\t\t\t\tfor(int x=0;x<8;x++){\n\t\t\t\t\t\t\t\t\tint xi = i+d[x][0], xj = j+d[x][1];\n\t\t\t\t\t\t\t\t\tif(0<=xi&&xi<n&&0<=xj&&xj<n&&map[xi*n+xj]!='.')adj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i*n+j]=='#'&&(adj==2||adj==3)){\n\t\t\t\t\t\t\t\t\tnm[i*n+j] = '#';\n\t\t\t\t\t\t\t\t\tnc++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(map[i*n+j]=='.'&&adj==3){\n\t\t\t\t\t\t\t\t\tnm[i*n+j] = '#';\n\t\t\t\t\t\t\t\t\tnc++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse nm[i*n+j] = '.';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tR nr = new R(new String(nm), ni*n+nj, nc);\n\t\t\t\t\t\t\tif(!v.contains(nr.s)){\n\t\t\t\t\t\t\t\tv.add(nr.s); next.add(nr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tbyte[][] a;\n\tint x0, y0;\n\tchar[] obj={'.', '#', '@'};\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new byte[n][n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tchar c=s.charAt(i);\n\t\t\t\t\tif(c=='.')\n\t\t\t\t\t\ta[j][i]=0;\n\t\t\t\t\telse if(c=='#')\n\t\t\t\t\t\ta[j][i]=1;\n\t\t\t\t\telse if(c=='@'){\n\t\t\t\t\t\ta[j][i]=2;\n\t\t\t\t\t\tx0=i;\n\t\t\t\t\t\ty0=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tQueue<S> que=new LinkedList<S>();\n\t\tTreeSet<S> memo=new TreeSet<S>();\n\n\t\tS s0=new S(x0, y0, 0);\n\t\tfor(int j=0; j<n; j++)\n\t\t\tSystem.arraycopy(a[j], 0, s0.a[j], 0, n);\n\n\t\tque.offer(s0);\n\t\tmemo.add(s0);\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tS s=que.poll();\n\t\t\tif(s.nInfect()==0){\n\t\t\t\tprintln(s.step+\"\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(s.step>15){\n\t\t\t\tprintln(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tLinkedList<S> nexts=s.nextStates();\n\t\t\tfor(S t : nexts){\n\t\t\t\tif(!memo.contains(t)){\n\t\t\t\t\tque.offer(t);\n\t\t\t\t\tmemo.add(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(\"-1\");\n\t}\n\n\tclass S implements Comparable<S>{\n\t\tbyte[][] a;\n\t\tint x, y;\n\t\tint step;\n\n\t\tS(int x, int y, int step){\n\t\t\ta=new byte[n][n];\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.step=step;\n\t\t}\n\n\t\tint nInfect(){\n\t\t\tint c=0;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tboolean mapEqauls(S s){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]!=s.a[j][i]){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tLinkedList<S> nextStates(){\n\t\t\tLinkedList<S> ret=new LinkedList<S>();\n\t\t\tint[] dx={-1, 0, 1, -1, 1, -1, 0, 1};\n\t\t\tint[] dy={-1, -1, -1, 0, 0, 1, 1, 1};\n\t\t\tfor(int d=0; d<8; d++){\n\t\t\t\tint nx=x+dx[d];\n\t\t\t\tint ny=y+dy[d];\n\t\t\t\tif(nx<0||nx>=n||ny<0||ny>=n)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(a[ny][nx]==1)\n\t\t\t\t\tcontinue;\n\t\t\t\ta[ny][nx]=2;\n\t\t\t\ta[y][x]=0;\n\t\t\t\tS s=new S(nx, ny, step+1);\n\t\t\t\tfor(int y=0; y<n; y++){\n\t\t\t\t\tfor(int x=0; x<n; x++){\n\t\t\t\t\t\tint c=0;\n\t\t\t\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\t\t\t\tint x2=x+dx[i];\n\t\t\t\t\t\t\tint y2=y+dy[i];\n\t\t\t\t\t\t\tif(x2<0||x2>=n||y2<0||y2>=n)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(a[y2][x2]!=0){\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[y][x]==0){\n\t\t\t\t\t\t\tif(c==3){\n\t\t\t\t\t\t\t\ts.a[y][x]=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts.a[y][x]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(a[y][x]==1){\n\t\t\t\t\t\t\tif(c==2||c==3){\n\t\t\t\t\t\t\t\ts.a[y][x]=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts.a[y][x]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ts.a[y][x]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.add(s);\n\t\t\t\ta[ny][nx]=0;\n\t\t\t\ta[y][x]=2;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid show(){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tprint(\"\"+obj[a[j][i]]);\n\t\t\t\t}\n\t\t\t\tprintln(\"\");\n\t\t\t}\n\t\t\tprintln(\"\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(S s){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(a[j][i]<s.a[j][i])\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\telse if(a[j][i]>s.a[j][i])\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef change_state(n, state)\n    new_state = 0\n    (0..n-1).each do |i|\n        (0..n-1).each do |j|\n            count = 0\n            t = (i == 0 ? 0 : i-1)\n            b = (i == n-1 ? n-1 : i+1)\n            l = (j == 0 ? 0 : j-1)\n            r = (j == n-1 ? n-1 : j+1)\n            (t..b).each do |y|\n                (l..r).each do |x|\n                    next if y == i && x == j\n                    count += 1 if state[y * n + x] == 1\n                end\n            end\n\n            if state[i * n + j] == 1\n                if count == 2 || count == 3\n                    new_state |= (1 << i * n + j)\n                end\n            elsif count == 3\n                new_state |= (1 << i * n + j)\n            end\n        end\n    end\n    new_state\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n\n    inf_state = 0\n    x = y = nil\n    n.times do |i|\n        gets.chomp.each_char.with_index do |c, j|\n            if c == ?#\n                inf_state |= (1 << i * n + j)\n            elsif c == ?@\n                y = i\n                x = j\n            end\n        end\n    end\n\n    if inf_state == 0\n        puts 0\n        next\n    end\n\n    state = (inf_state << 6) + (x << 3) + y\n    queue = [state]\n    reached = Set[state]\n    d = 1\n\n    catch(:break) do\n        until queue.empty?\n            new_queue = []\n            until queue.empty?\n                state = queue.shift\n                inf_state, x0, y0 = state >> 6, (state >> 3) & 7, state & 7\n                [-1, 0, 1].repeated_permutation(2) do |dx, dy|\n                    next if dx == 0 && dy == 0\n                    x, y = x0 + dx, y0 + dy\n                    next if x < 0 || x >= n || y < 0 || y >= n\n                    next if inf_state[y * n + x] == 1\n\n                    k = y * n + x\n                    changed = change_state(n, inf_state + (1 << k))\n                    changed -= (1 << k) if changed[k] == 1\n\n                    if changed == 0\n                        throw :break\n                    end\n\n                    new_state = (changed << 6) + (x << 3) + y\n                    next if reached.include?(new_state)\n                    reached << new_state\n                    new_queue << new_state\n                end\n            end\n            queue = new_queue\n            d += 1\n        end\n        d = -1\n    end\n\n    p d\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = 1 << 30\n\nDXYS = [\n  [ 1, 0], [1, -1], [0, -1], [-1, -1],\n  [-1, 0], [-1, 1], [0,  1], [ 1,  1]\n]\n\n### subroutines\n\ndef tostr(n, bits, pos)\n  str = ''\n  for k  in (0...(n * n))\n    if k == pos\n      str += '@'\n    else\n      str += (bits & (1 << k)) == 0 ? '.' : '#'\n    end\n    str += \"\\n\" if (k + 1) % n == 0\n  end\n  str\nend\n\ndef infection(nn, bits, adjs)\n  return $icache[bits] if $icache[bits]\n\n  ibits = bits\n\n  for pos in (0...nn)\n    c = 0\n    adjs[pos].each{|apos| c += ((bits >> apos) & 1)}\n\n    b = 1 << pos\n    if (bits & b) == 0\n      ibits |= b if c == 3\n    else\n      ibits &= ~b if c != 2 && c != 3\n    end\n  end\n\n  $icache[bits] = ibits\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  nn = n * n\n\n  sbits = 0\n  spos = 0\n  for y in (0...n)\n    line = gets.strip\n    for x in (0...n)\n      pos = y * n + x\n      case line[x]\n      when '#'\n        sbits |= (1 << pos)\n      when '@'\n        spos = pos\n      end\n    end\n  end\n  #p sbits.to_s(2)\n  #p spos\n\n  adjs = []\n  for y0 in (0...n)\n    for x0 in (0...n)\n      adj = []\n      DXYS.each do |dx, dy|\n        x = x0 + dx\n        y = y0 + dy\n        if x >= 0 && x < n && y >= 0 && y < n\n          adj << (y * n + x)\n        end\n      end\n      adjs << adj\n    end\n  end\n  #p adjs\n\n  $icache = {}\n  \n  dists = nn.times.map{Hash.new{INF}}\n  dists[spos][sbits] = 0\n  q = [[spos, sbits]]\n  min_d = INF\n  \n  while ! q.empty?\n    upos, ubits = q.shift\n    ud = dists[upos][ubits]\n    #puts tostr(n, ubits, upos); puts\n    \n    if ubits == 0\n      min_d = ud\n      break\n    end\n\n    nvd = ud + 1\n\n    for vpos in adjs[upos]\n      #p [upos, vpos]\n      vb = (1 << vpos)\n      if (ubits & vb) == 0\n        vbits = (infection(nn, (ubits | vb), adjs) & ~vb)\n        #p [ubits.to_s(2), vbits.to_s(2)]\n        if dists[vpos][vbits] >= nvd\n          dists[vpos][vbits] = nvd\n          q << [vpos, vbits]\n        end\n      end\n    end\n  end\n\n  #p $icache\n  #p dists\n  puts (min_d >= INF ? -1 : min_d)\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct S {\n    int y, x;\n    int time;\n    string[] F;\n    static const dy = [1,   1,  1, \n                       0,       0,\n                       -1, -1, -1], \n                 dx = [-1,  0,  1,\n                       -1,      1,\n                       -1,  0,  1];\n    S[] nextStates() {\n        S[] Ret;\n        int N = cast(int)F.length;\n        foreach (i; 0 .. 8) {\n            int ny = y + dy[i],\n                nx = x + dx[i];\n            if (ny < 0 || ny >= N) continue;\n            if (nx < 0 || nx >= N) continue;\n            if (F[ny][nx] == '#') continue;\n            Ret ~= S(ny, nx, time + 1, next(F, ny, nx));\n        }\n        return Ret;\n    }\n    static string[] next(string[] F, int y, int x) {\n        int N = cast(int)F.length;\n        auto Ret = new char[][](N, N);\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                int C = 0;\n                if (i == y && j == x) {\n                    Ret[i][j] = '.';\n                    continue;\n                }\n                foreach (k; 0 .. 8) {\n                    int py = i + dy[k],\n                        px = j + dx[k];\n                    if (py < 0 || py >= N) continue;\n                    if (px < 0 || px >= N) continue;\n                    if ((py == y && px == x) || F[py][px] == '#') C++;\n                }\n                if ( (F[i][j] == '#' && (C == 2 || C == 3)) ||\n                     (F[i][j] == '.' && C == 3) ) {\n                    Ret[i][j] = '#';\n                } else {\n                    Ret[i][j] = '.';\n                }\n            }\n        }\n        return cast(string[])Ret;\n    }\n}\n\nvoid main() {\n    int N;\n    string[] F;\n    int y, x;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        F = new string[N];\n        foreach (i; 0 .. N) F[i] = readln.chomp;\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                if (F[i][j] == '@') {\n                    y = i, x = j;\n                }\n            }\n        }\n        F = F.map!((l) => l.replace(\"@\", \".\")).array;\n        return true;\n    }\n    static bool check(string[] F) {\n        //writeln(F.join(\"\\n\"));\n        //writeln(F.all!((l) => l.all!\"a == '.'\"));\n        return F.all!((l) => l.all!\"a == '.'\");\n    }\n    string encode(S s) {\n        return s.F.join(\"\") ~ s.y.to!string ~ \" \" ~ s.x.to!string;\n    }\n    void solve() {\n        DList!S Q;\n        Q.insert(S(y, x, 0, F));\n        int Ans = -1;\n        bool[string] used;\n        while (!Q.empty) {\n            S s = Q.front; Q.removeFront;\n            if (check(s.F)) {\n                Ans = s.time;\n                break;\n            }\n            foreach (t; s.nextStates) {\n                auto k = encode(t);\n                if (k in used) continue;\n                used[k] = true;\n                Q.insert(t);\n            }\n        }\n        writeln(Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct S {\n    int y, x;\n    int time;\n    string[] F;\n    static const dy = [1,   1,  1, \n                       0,       0,\n                       -1, -1, -1], \n                 dx = [-1,  0,  1,\n                       -1,      1,\n                       -1,  0,  1];\n    S[] nextStates() {\n        S[] Ret;\n        int N = cast(int)F.length;\n        foreach (i; 0 .. 8) {\n            int ny = y + dy[i],\n                nx = x + dx[i];\n            if (ny < 0 || ny >= N) continue;\n            if (nx < 0 || nx >= N) continue;\n            if (F[ny][nx] == '#') continue;\n            Ret ~= S(ny, nx, time + 1, next(F, ny, nx));\n        }\n        return Ret;\n    }\n    static string[] next(string[] F, int y, int x) {\n        int N = cast(int)F.length;\n        auto Ret = new char[][](N, N);\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                int C = 0;\n                if (i == y && j == x) {\n                    Ret[i][j] = '.';\n                    continue;\n                }\n                foreach (k; 0 .. 8) {\n                    int py = i + dy[k],\n                        px = j + dx[k];\n                    if (py < 0 || py >= N) continue;\n                    if (px < 0 || px >= N) continue;\n                    if ((py == y && px == x) || F[py][px] == '#') C++;\n                }\n                if ( (F[i][j] == '#' && (C == 2 || C == 3)) ||\n                     (F[i][j] == '.' && C == 3) ) {\n                    Ret[i][j] = '#';\n                } else {\n                    Ret[i][j] = '.';\n                }\n            }\n        }\n        return cast(string[])Ret;\n    }\n}\n\nvoid main() {\n    int N;\n    string[] F;\n    int y, x;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        F = new string[N];\n        foreach (i; 0 .. N) F[i] = readln.chomp;\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                if (F[i][j] == '@') {\n                    y = i, x = j;\n                }\n            }\n        }\n        F = F.map!((l) => l.replace(\"@\", \".\")).array;\n        return true;\n    }\n    static bool check(string[] F) {\n        auto N = F.length;\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                if (F[i][j] != '.') return false;\n            }\n        }\n        return true;\n    }\n    string encode(S s) {\n        return s.F.join(\"\") ~ s.y.to!string ~ \" \" ~ s.x.to!string;\n    }\n    void solve() {\n        DList!S Q;\n        Q.insert(S(y, x, 0, F));\n        int Ans = -1;\n        bool[string] used;\n        while (!Q.empty) {\n            S s = Q.front; Q.removeFront;\n            if (check(s.F)) {\n                Ans = s.time;\n                break;\n            }\n            foreach (t; s.nextStates) {\n                auto k = encode(t);\n                if (k in used) continue;\n                used[k] = true;\n                Q.insert(t);\n            }\n        }\n        writeln(Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndd0 = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\nDD = []\nfor k in range(6):\n    ddk = []\n    for y in range(k):\n        for x in range(k):\n            v = 0\n            for dx, dy in dd0:\n                nx = x + dx; ny = y + dy\n                if not 0 <= nx < k or not 0 <= ny < k:\n                    continue\n                v |= 1 << (ny*k + nx)\n            ddk.append(v)\n    DD.append(ddk)\nL = (1 << 16)\nbc = [0]*L\nfor v in range(1, L):\n    bc[v] = bc[v ^ (v & -v)] + 1\n\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    dd = dd0\n    dk = DD[N]\n    state = 0\n    for i in range(N):\n        s = readline().strip()\n        for j, c in enumerate(s):\n            if c == '#':\n                state |= 1 << (N*i + j)\n            elif c == '@':\n                sx = j; sy = i\n    U = {(state, sx, sy): 0}\n    que = deque([(state, sx, sy)])\n    while que:\n        state, x, y = key = que.popleft()\n        d = U[key]\n        if state == 0:\n            write(\"%d\\n\" % d)\n            break\n        for dx, dy in dd:\n            nx = x + dx; ny = y + dy\n            if not 0 <= nx < N or not 0 <= ny < N:\n                continue\n            b = 1 << (ny*N + nx)\n            if state & b:\n                continue\n            state ^= b\n            n_state = 0\n            for k in range(N*N):\n                v = state & dk[k]\n                if state & (1 << k):\n                    if v and 2 <= bc[v // (v & -v)] <= 3:\n                        n_state |= (1 << k)\n                else:\n                    if v and bc[v // (v & -v)] == 3:\n                        n_state |= (1 << k)\n            if n_state & b:\n                n_state ^= b\n            n_key = (n_state, nx, ny)\n            if n_key not in U:\n                U[n_key] = d+1\n                que.append(n_key)\n            state ^= b\n    else:\n        write(\"-1\\n\")\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n    oks = collections.defaultdict(set)\n\n    def a2k(a, n):\n        r = 0\n        for i in range(n):\n            for j in range(n):\n                r *= 3\n                r += a[i][j]\n        return r\n\n    def k2a(k, n):\n        a = []\n        for i in range(n):\n            t = []\n            for j in range(n):\n                t.append(k%3)\n                k //= 3\n            a.append(t[::-1])\n        return a\n\n    def moves(a,n):\n        si = sj = -1\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] == 2:\n                    si = i\n                    sj = j\n                    break\n            if si >= 0:\n                break\n\n        r = set()\n        a[si][sj] = 0\n        for i in range(max(0,si-1), min(n,si+2)):\n            for j in range(max(0,sj-1), min(n,sj+2)):\n                if a[i][j] != 0 or (si == i and sj == j):\n                    continue\n                a[i][j] = 2\n                na = [[0]*n for _ in range(n)]\n                zf = 1\n                for k in range(n):\n                    for l in range(n):\n                        if a[k][l] == 2:\n                            continue\n                        c = 0\n                        for m in range(max(0, k-1), min(n, k+2)):\n                            for o in range(max(0, l-1), min(n, l+2)):\n                                if m == k and o == l:\n                                    continue\n                                if a[m][o] > 0:\n                                    c += 1\n                        if (a[k][l] == 0 and c == 3) or (a[k][l] == 1 and 2 <= c <= 3):\n                            na[k][l] = 1\n                            zf = 0\n                na[i][j] = 2\n                if zf == 1:\n                    return 'ok'\n                r.add(a2k(na, n))\n                a[i][j] = 0\n        return r\n\n    def f(n):\n        sd = {}\n        sd['.'] = 0\n        sd['#'] = 1\n        sd['@'] = 2\n        a = [[sd[c] for c in S()] for _ in range(n)]\n        zf = 1\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] == 1:\n                    zf = 0\n                    break\n        if zf == 1:\n            return 0\n        r = inf\n        d = collections.defaultdict(lambda: inf)\n        k = a2k(a,n)\n        q = set([k])\n        d[k] = 0\n        t = 0\n        while q:\n            t += 1\n            nq = set()\n            if q & oks[n]:\n                return t\n            for k in q:\n                a = k2a(k,n)\n                r = moves(a,n)\n                if r == 'ok':\n                    oks[n].add(k)\n                    return t\n                for nk in r:\n                    if d[nk] > t:\n                        d[nk] = t\n                        nq.add(nk)\n            q = nq\n        return -1\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  }
]