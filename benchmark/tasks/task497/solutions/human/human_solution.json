[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n\n    if(cnt>1e6){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n\n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n  \n  ans=lcm(ans, euler(n) );\n\n  if( n%ans== 0 || __gcd(n,ans) !=1){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e7){\n      cnt=euler(ans);\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n\n  /*\n  ll C=1;\n  for(ll i=0;i<n;i++){\n    ll k=solve( i , n );\n    C=lcm(k,C);\n  }\n  */\n  //  cout<<C<<' '<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint f(int a){return mod_pow(a,n,n);}\nint F(int a,int k){\n  if(k == 1) return f(a);\n  return F(f(a),k-1);\n}\n\nint mem[100];\nint F2(int a,int k){\n  if(k == 1) return mem[a] = f(a);\n  return mem[a] = mod_pow(mem[a],n,n);\n}\n\ndouble calcTime(){\n  static clock_t start = clock();// ??????????????????\n  clock_t end = clock();     // ????????????\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\nbool check(int k){\n  int res = 1;\n  for(int i=2;i<min(5LL,n);i++){\n    int a = i;\n    if(F(a,k) != a) res = 0;\n  }\n  return res;\n}\n\n\nint solve(){\n  int cnt = 0;\n  for(int k=1; calcTime() < 1;k++,cnt++) if(check(k)) return k;\n  return -1;\n}\n\nvector<bool> visited;\nint find(int num){\n  if(visited[num]) return 0;\n  visited[num] = 1;\n  int res = 1 + find(F(num,1));\n  visited[num] = 0;\n  return res;\n}\n\nint find2(int start){\n  int num  = F(start,1);\n  int cnt = 1;\n  while(num != start) num = F(num,1),cnt++;\n  return cnt;\n}\n\nint lcm(int a,int b){return (a/__gcd(a,b)) * b;}\n\nint solve2(){\n  visited.resize(n,0);\n  int res = 1;\n  for(int i=0;i<3;i++){\n    int num = rand()%(n-2)+1;\n    res = max(res,find2(num));\n  }\n  cout<<\"res=\"<<res<<endl;\n  return check(res)? res:-1;\n}\n\nvoid factor(int n){\n  for(int i=1;i<=n;i++){\n    if(n % i == 0) cout<<i<<\" \";\n  }\n  cout<<endl;\n}\n\nint carmichealLambda(int n){\n  int res = 1;\n  if(n % 8 == 0) n/=2;\n  \n  for(int i=2;i<=n;i++){\n    if( n % i != 0) continue;\n    int sub = i - 1;\n    n/=i;\n    while(n %i == 0) n/=i, sub *=i;\n    res = lcm(res,sub);\n  }\n  return res;\n}\n\nsigned main(){\n  srand((unsigned) time(NULL));\n  cin>>n;\n  //cout<<solve2()<<endl;\n\n  /*  int cnt = 0;\n  for(int i=1;i<n;i++){\n    continue;\n    if(__gcd(i,n) == 1) cnt++;\n    int flag = 0;\n    for(int k=1;k<10;k++)if(F(i,k) == 2) flag = 1;\n    if(!flag) continue;\n    cout<<\"i=\"<<i<<\":\";\n    for(int k=1;k<10;k++)cout<<\"\\t\"<<F(i,k);\n    cout<<endl;\n  }\n  */\n\n  int car = carmichealLambda(n);\n  if(car == 1) {cout<<1<<endl;return 0;}\n  int c = n%car,b = 1;\n  int find = 1;\n  vector<bool> used(car);\n  while(c % car != 1){\n    if(used[c]) {find=0;break;}\n    used[c] = 1;\n    c = c*n%car,b++;\n  }\n  if(find) cout<<b<<endl;\n  else cout<<-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) res=res*x%mod;\n    x=x*x%mod;\n    n>>=1;\n  }\n  return res;\n}\nint f(int a,int n){\n  return mod_pow(a,n,n);\n}\nint F(int a,int k,int n){\n  if(k==1) return f(a,n);\n  else return F(f(a,n),k-1,n);\n}\nsigned main(){\n  int n;\n  cin>>n;\n  int z=0;\n  vector<int> v;\n  {\n    int t=n;\n    bool ff=0;\n    for(int j=2;j*j<=n;j++){\n      if(t%j==0){\n\tz++;\n\tv.push_back(j);\n\tint tmp=0;\n\twhile(t%j==0) t/=j,tmp++;\n\tif(tmp>1){\n\t  ff=1;\n\t  break;\n\t}\n      }\n    }\n    if(t!=1) z++,v.push_back(t);\n    if(ff){\n      cout<<-1<<endl;\n      return 0;;\n    }\n  }\n  if(z==1){\n    cout<<1<<endl;\n    return 0;\n  }\n  int ans=1;\n  if(1){\n    set<int> u;\n    for(int j=1;j*j<=n;j++){\n      if(u.count(j)) continue;\n      int cur=j;\n      set<int> s;\n      while(!s.count(f(cur,n))){\n\tcur=f(cur,n);\n\ts.insert(cur);\n\tu.insert(cur);\n      }\n      if(cur!=j){\n\tans=-1;\n\tbreak;\n      }\n      //cout<<s.size()<<endl;\n      int m=__gcd(ans,(int)s.size());\n      ans*=s.size()/m;\n      if(ans>5000) break;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nbool isp[32000];\nvi p;\nint main() {\n\tint n;\n\tcin >> n;\n\tint n2 = n;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (isp[i])continue;\n\t\tp.push_back(i);\n\t\tfor (ll j = 2 * i; j*j <= n; j += i)isp[j] = 1;\n\t}\n\tvi p2;\n\tfor (auto x : p) {\n\t\tif (n%x == 0) {\n\t\t\tp2.push_back(x);\n\t\t\tn /= x;\n\t\t\tif (n%x == 0) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (p2.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (n > 1)p2.push_back(n);\n\tn = n2;\n\tint ans = 1;\n\tp.push_back(0);\n\tfor (auto x : p2) {\n\t\tx--;\n\t\tfor (auto y : p) {\n\t\t\tif (y != 0 && x%y || x == 1)continue;\n\t\t\tint k = 1;\n\t\t\tif (y == 0) {\n\t\t\t\ty = x;\n\t\t\t}\n\t\t\twhile (x%y == 0)k *= y, x /= y;\n\t\t\tll pr = n%k;\n\t\t\tint t = 0;\n\t\t\trep1(i, k) {\n\t\t\t\tif (pr == 1) {\n\t\t\t\t\tt = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpr = pr*n%k;\n\t\t\t}\n\t\t\tif (!t) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans = lcm(ans, t);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nstd::vector<unsigned long long> calc_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret; ret.push_back(1);\n\tfor (std::pair<unsigned long long, unsigned> w : res) {\n\t\tint s = ret.size();\n\t\tunsigned long long mul = 1;\n\t\tfor (int i = 0; i < w.second; i++) {\n\t\t\tmul *= w.first;\n\t\t\tfor (int j = 0; j < s; j++) ret.push_back(ret[j] * mul);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nlong long n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse if (n == 2) cout << 1 << endl;\n\telse {\n\t\tint e = totient_function(n);\n\t\tvector<unsigned long long> v1 = calc_divisors(totient_function(e));\n\t\tlong long w1 = -1;\n\t\tfor (long long i : v1) {\n\t\t\tif (modpow(n, i, e) == 1) {\n\t\t\t\tw1 = i; break;\n\t\t\t}\n\t\t}\n\t\tcout << w1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<map>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconstexpr long long INF = (long long)1e18;\nconstexpr long long MOD = 1'000'000'007; \n\nstruct fast_io {\n\tfast_io(){\n\t\tstd::cin.tie(nullptr);\n\t\tstd::ios::sync_with_stdio(false);\n\t};\n} fio;\n\nint gcd(int a, int b){\n\treturn a % b ? gcd(b, a % b) : b;\n}\n\nint lcm(int a, int b){\n\treturn a / gcd(a, b) * b;\n}\n\n\nlong long power(long long x, long long n, long long mod){\n\tlong long ans = 1;\n\tfor(;n;n>>=1,x*=x,ans%=mod,x%=mod)\n\t\tif(n&1)ans*=x;\n\treturn ans%mod;\n}\n\nvoid exgcd(long long a, long long b, long long &x, long long &y){\n\tif(b == 0){\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn ;\n\t}\n\texgcd(b, a % b, y, x);\n\ty -= a / b * x;\n}\n\t\nlong long modlog(long long a, long long b, long long mod){\n\t\n\ta %= mod, b %= mod;\n\t\n\tlong long low = -1, high = mod, mid;\n\t\n\t\n\twhile(low + 1 < high){\n\t\tmid = (low + high) >> 1;\n\t\t\n\t\tif(mid * mid >= mod) high = mid;\n\t\telse low = mid;\n\t}\n\t\n\tlong long sqrtM = high;\n\tmap<long long,long long> mp;\n\t\n\tfor(long long i = 0, x = 1; i < sqrtM; i++){\n\t\tif(!mp.count(x)) mp[x] = i;\n\t\tx = x * a % mod;\n\t}\n\t\n\tlong long x, y, temp;\n\tlong long A;\n\t\n\ttemp = power(a, sqrtM ,mod);\n\t\n\tif(gcd(temp, mod) != 1) return -1;\n\t\n\texgcd(temp , mod, x, y);\n\t\n\tA = x;\n\t\n\t// A = power(power(a, sqrtM ,mod), mod-2, mod);\n\t\n\tfor(long long i = 0, bA = b; i < sqrtM; i++){\n\t\tif(mp.count(bA)){\n\t\t\tlong long res = i * sqrtM + mp[bA];\n\t\t\t\n\t\t\tif(res > 0) return res;\n\t\t\t// return res;\n\t\t}\n\t\tbA = bA * A % mod;\n\t}\n\t\n\treturn -1;\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\t\n\tint N, n;\n\tint Lcm = 1;\n\tvector<int> p;\n\t\n\tcin>>N;\n\t\n\tn = N;\n\t\n\tfor(int i = 2; i * i <= N; i++){\n\t\tif(N % (i * i) == 0) {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\twhile(n % i == 0){\n\t\t\tp.push_back(i);\n\t\t\tn /= i;\n\t\t}\n\t}\n\t\n\tif(n != 1) {\n\t\tp.push_back(n);\n\t}\n\t\n\tif(p.size() == 1) {\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 0; i < p.size(); i++){\n\t\tLcm = lcm(Lcm, p[i] - 1);\n\t}\n\t\n\tcout<<modlog(N, 1, Lcm)<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint f(int a){return mod_pow(a,n,n);}\nint F(int a,int k){\n  if(k == 1) return f(a);\n  return F(f(a),k-1);\n}\n\nint mem[100];\nint F2(int a,int k){\n  if(k == 1) return mem[a] = f(a);\n  return mem[a] = mod_pow(mem[a],n,n);\n}\n\ndouble calcTime(){\n  static clock_t start = clock();// ??????????????????\n  clock_t end = clock();     // ????????????\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\nbool check(int k){\n  int res = 1;\n  for(int i=2;i<min(5LL,n);i++){\n    int a = i;\n    if(F(a,k) != a) res = 0;\n  }\n  return res;\n}\n\n\nint solve(){\n  int cnt = 0;\n  for(int k=1; calcTime() < 1;k++,cnt++) if(check(k)) return k;\n  return -1;\n}\n\nvector<bool> visited;\nint find(int num){\n  if(visited[num]) return 0;\n  visited[num] = 1;\n  int res = 1 + find(F(num,1));\n  visited[num] = 0;\n  return res;\n}\n\nint find2(int start){\n  int num  = F(start,1);\n  int cnt = 1;\n  while(num != start) num = F(num,1),cnt++;\n  return cnt;\n}\n\nint lcm(int a,int b){return (a/__gcd(a,b)) * b;}\n\nint solve2(){\n  visited.resize(n,0);\n  int res = 1;\n  for(int i=0;i<3;i++){\n    int num = rand()%(n-2)+1;\n    res = max(res,find2(num));\n  }\n  cout<<\"res=\"<<res<<endl;\n  return check(res)? res:-1;\n}\n\nvoid factor(int n){\n  for(int i=1;i<=n;i++){\n    if(n % i == 0) cout<<i<<\" \";\n  }\n  cout<<endl;\n}\n\nint carmichealLambda(int n){\n  int res = 1;\n  if(n % 8 == 0) n/=2;\n  \n  for(int i=2;i<=n;i++){\n    if( n % i != 0) continue;\n    int sub = i - 1;\n    n/=i;\n    while(n %i == 0) n/=i, sub *=i;\n    res = lcm(res,sub);\n  }\n  return res;\n}\n\nsigned main(){\n  srand((unsigned) time(NULL));\n  cin>>n;\n  //cout<<solve2()<<endl;\n\n  /*  int cnt = 0;\n  for(int i=1;i<n;i++){\n    continue;\n    if(__gcd(i,n) == 1) cnt++;\n    int flag = 0;\n    for(int k=1;k<10;k++)if(F(i,k) == 2) flag = 1;\n    if(!flag) continue;\n    cout<<\"i=\"<<i<<\":\";\n    for(int k=1;k<10;k++)cout<<\"\\t\"<<F(i,k);\n    cout<<endl;\n  }\n  */\n  int car = carmichealLambda(n);\n  int c = n,b = 1;\n  unordered_set<int> used;\n  int find = 1;\n  while(c % car != 1){\n    if(used.count(c)) {find=0;break;}\n    used.insert(c);\n    c = c*n%car,b++;\n  }\n  \n  if(find) cout<<b<<endl;\n  else cout<<-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){return x/__gcd(x,y)*y;}\nint mpow(int n,int x){\n  int res=1;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    //cout<<res<<endl;\n    //cout<<p.first<<\" \"<<p.second<<endl;\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.second-1));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  if(m.count(2)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n  }\n  cout<<(ker(ans)?ker(ans):-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long N, C = 1; vector<long long>R;\n\nint main() {\n\tcin >> N;\n\tfor (int i = 2; i*i <= N; i++) {\n\t\tif (N%i == 0) {\n\t\t\tN /= i; R.push_back(i);\n\t\t\tif (N%i == 0) { cout << \"-1\" << endl; return 0; }\n\t\t}\n\t}\n\tif (N >= 2) { R.push_back(N); }\n\tif (R.size() <= 1) { cout << \"1\" << endl; return 0; }\n\tif (R.size() >= 3 || R[0] == 2) { cout << \"-1\" << endl; return 0; }\n\tlong long a = R[0], b = R[1], c = 1;\n\tfor (int i = 1; i <= b / 2; i++) {\n\t\tc *= a; c %= (b - 1);\n\t\tif (c == 1) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"-1\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint n;\n\nint f_n(int a,int id)//(a^id)%n????????????????¨????\n{\n    int x;\n    if(!id) return 1;\n    x = f_n((a*a)%n,id/2);\n    return((id%2) ? (x*a)%n : x);\n}\n\nint main()\n{\n    int i,j,*f,cnt;\n    //printf(\"n = \");\n    scanf(\"%d\",&n);\n    f = (int *)calloc(n,sizeof(int));\n    //printf(\"       \");\n    for(i=1;i<n;i++){\n        f[i] = i;\n        //printf(\"%2d \",f[i]);\n    }\n    //printf(\"\\n\");\n    for(j=1;j<=n;j++){\n        //printf(\"F_%2d : \",j);\n        cnt = 0;\n        for(i=1;i<n;i++){\n            f[i] = f_n(f[i],n);\n            if(f[i]==i)cnt++;\n            //printf(\"%2d \",f[i]);\n        }\n        //printf(\"\\n\");\n        if(cnt==n-1){\n            printf(\"%d\\n\",j);\n            return 0;\n        }\n    }\n    printf(\"-1\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n\n    if(cnt>1e8){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n\n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n  \n  ans=lcm(ans, euler(n) );\n\n  if( n%ans== 0 || __gcd(n,ans) !=1){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e8){\n      cnt=euler(ans)/3;\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n\n  /*\n  ll C=1;\n  for(ll i=0;i<n;i++){\n    ll k=solve( i , n );\n    C=lcm(k,C);\n  }\n  */\n  //  cout<<C<<' '<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n\n    if(cnt>1e6){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n\n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n  \n  // ans=lcm(ans, euler(n) );\n\n  if( n%ans== 0){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e7){\n      cnt=euler(ans);\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nbool isp[32000];\nvi p;\nint main() {\n\tint n;\n\tcin >> n;\n\tint n2 = n;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (isp[i])continue;\n\t\tp.push_back(i);\n\t\tfor (ll j = 2 * i; j*j <= n; j += i)isp[j] = 1;\n\t}\n\tvi p2;\n\tfor (auto x : p) {\n\t\tif (n%x == 0) {\n\t\t\tp2.push_back(x);\n\t\t\tn /= x;\n\t\t\tif (n%x == 0) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (p2.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (n > 1)p2.push_back(n);\n\tn = n2;\n\tint ans = 1;\n\tfor (auto x : p2) {\n\t\tx--;\n\t\tfor (auto y : p) {\n\t\t\tif (x%y)continue;\n\t\t\tint k = 1;\n\t\t\twhile (x%y == 0)k *= y, x /= y;\n\t\t\tll pr = n%k;\n\t\t\tint t = 0;\n\t\t\trep1(i, k) {\n\t\t\t\tif (pr == 1) {\n\t\t\t\t\tt = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpr = pr*n%k;\n\t\t\t}\n\t\t\tif (!t) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans = lcm(ans, t);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint lcm(int a,int b){return (a/__gcd(a,b)) * b;}\nint carmichealLambda(int n){\n  int res = 1;\n  if(n % 8 == 0) n/=2;\n\n  auto compute = [&](int i){\n    int sub = i - 1;\n    n/=i;\n    while(n%i == 0) n/=i, sub *=i;\n    res = lcm(res,sub);\n  };\n\n  for(int i=2;i*i<=n;i++) if( n % i == 0) compute(i);\n  if(n != 1) compute(n);\n  return res;\n}\n\nsigned main(){\n  cin>>n;\n  int car = carmichealLambda(n);\n  int car2 = carmichealLambda(car);\n  int ans = car2;\n  if(mod_pow(n,1,car)==1) ans = 1;\n  \n  for(int i=1;i*i<=car2;i++){\n    if(mod_pow(n,car2/i,car) == 1) Min(ans,car2/i);\n    if(mod_pow(n,i,car) == 1) Min(ans,i);\n  }\n  \n  if(car != 1 && mod_pow(n,car2,car) !=  1)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nll Pow(ll a, ll b, ll mod) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tll N;\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (N % 2 == 0) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<ll> div;\n\tfor (ll i = 2; i * i <= N; i++) {\n\t\tif (i * i == N) {\n\t\t\tdiv.push_back(i);\n\t\t}\n\t\telse if (N % i == 0) {\n\t\t\tdiv.push_back(i);\n\t\t\tdiv.push_back(N / i);\n\t\t}\n\t}\n\tif (div.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tsort(div.begin(), div.end());\n\tll res = 1;\n\tmap<ll, bool> used;\n\tfor (auto val : div) {\n\t\tll tmp = val, cnt = 0;\n\t\twhile (!used[val]) {\n\t\t\tused[val] = true;\n\t\t\tval = Pow(val, N, N);\n\t\t\tcnt++;\n\t\t}\n\t\tif (val == tmp) {\n\t\t\tres = lcm(res, cnt);\n\t\t}\n\t\telse {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong N;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nlong power(long a,long b,long mod){return b?power(a*a%mod,b/2,mod)*(b%2?a:1)%mod:1;}\nint phi(int N)\n{\n\tint ret=N;\n\tfor(int i=2;i*i<=N;i++)\n\t{\n\t\tif(N%i==0)\n\t\t{\n\t\t\twhile(N%i==0)N/=i;\n\t\t\tret=ret/i*(i-1);\n\t\t}\n\t}\n\tif(N>1)ret=ret/N*(N-1);\n\treturn ret;\n}\nmain()\n{\n\tcin>>N;\n\tif(N==2)\n\t{\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tint tN=N;\n\tint L=1;\n\tfor(int i=2;i*i<=tN;i++)\n\t{\n\t\tif(tN%i==0)\n\t\t{\n\t\t\ttN/=i;\n\t\t\tif(tN%i==0)\n\t\t\t{\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tL=L/gcd(L,i-1)*(i-1);\n\t\t}\n\t}\n\tif(tN>1)\n\t{\n\t\tL=L/gcd(L,tN-1)*(tN-1);\n\t}\n\tint nl=phi(L);\n\tint ans=nl+1;\n\tfor(int i=1;i*i<=nl;i++)\n\t{\n\t\tif(nl%i==0)\n\t\t{\n\t\t\tif(power(N,i,L)==1)ans=min(ans,i);\n\t\t\tif(power(N,nl/i,L)==1)ans=min(ans,nl/i);\n\t\t}\n\t}\n\tcout<<(ans>nl?-1:ans)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint f(int a){return mod_pow(a,n,n);}\nint F(int a,int k){\n  if(k == 1) return f(a);\n  return F(f(a),k-1);\n}\n\nint mem[100];\nint F2(int a,int k){\n  if(k == 1) return mem[a] = f(a);\n  return mem[a] = mod_pow(mem[a],n,n);\n}\n\n\ndouble calcTime(){\n  static clock_t start = clock();// ??????????????????\n  clock_t end = clock();     // ????????????\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\nbool check(int k){\n  int res = 1;\n  for(int i=2;i<min(100LL,n);i++){\n    int a = i;\n    if(F2(a,k) != a) res = 0;\n  }\n  return res;\n}\nint solve(){\n  for(int k=1; calcTime() < 1.5;k++) if(check(k)) return k;\n  return -1;\n}\n\nsigned main(){\n  srand((unsigned) time(NULL));\n  cin>>n;\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <random>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(12231817);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> random_distinct_integers(int l, int r, int k) {\n\tassert((r - l) >= k);\n\tset<int> s;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x = rand_rng(l, r);\n\t\twhile (s.find(x) != s.end()) x = rand_rng(l, r);\n\t\ts.insert(x);\n\t}\n\treturn vector<int>(s.begin(), s.end());\n}\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nconst int max_search_size = 2;\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse {\n\t\tvector<int> v = random_distinct_integers(0, n, min(n, max_search_size));\n\t\tvector<int> a(v.size());\n\t\tfor (int i = 0; i < v.size(); i++) a[i] = modpow(v[i], n, n);\n\t\tfor (int i = 1; ; i++) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\t\tif (a[j] != v[j]) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tcout << i << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int j = 0; j < v.size(); j++) a[j] = modpow(a[j], n, n);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) res=res*x%mod;\n    x=x*x%mod;\n    n>>=1;\n  }\n  return res;\n}\nint f(int a,int n){\n  return mod_pow(a,n,n);\n}\nsigned main(){\n  int n;\n  cin>>n;\n  int z=0;\n  vector<int> v;\n  {\n    int t=n;\n    bool ff=0;\n    for(int j=2;j*j<=n;j++){\n      if(t%j==0){\n\tz++;\n\tv.push_back(j);\n\tint tmp=0;\n\twhile(t%j==0) t/=j,tmp++;\n\tif(tmp>1){\n\t  ff=1;\n\t  break;\n\t}\n      }\n    }\n    if(t!=1) z++,v.push_back(t);\n    if(ff){\n      cout<<-1<<endl;\n      return 0;\n    }\n  }\n  if(z==1){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  if(n%2==0){\n    cout<<-1<<endl;\n    return 0;\n  }\n  \n  int ans=1;\n  if(1){\n    set<int> u,w;\n    for(int j=1;j*j<=n;j++){\n      if(u.count(j)) continue;\n      int cur=j;\n      set<int> s;\n      while(!s.count(f(cur,n))){\n\tcur=f(cur,n);\n\ts.insert(cur);\n\tu.insert(cur);\n      }\n      if(cur!=j){\n\tans=-1;\n\tbreak;\n      }\n      //cout<<s.size()<<endl;\n      int m=__gcd(ans,(int)s.size());\n      ans*=s.size()/m;\n      if(w.count(s.size())) break;\n      w.insert(s.size());\n      //if(ans>5000) break;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nbool isp[32000];\nvi p;\nint main() {\n\tint n;\n\tcin >> n;\n\tint n2 = n;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (isp[i])continue;\n\t\tp.push_back(i);\n\t\tfor (ll j = 2 * i; j*j <= n; j += i)isp[j] = 1;\n\t}\n\tvi p2;\n\tfor (auto x : p) {\n\t\tif (n%x == 0) {\n\t\t\tp2.push_back(x);\n\t\t\tn /= x;\n\t\t\tif (n%x == 0) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (p2.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (n > 1)p2.push_back(n);\n\tn = n2;\n\tint ans = 1;\n\tfor (auto x : p2) {\n\t\tvi used(x);\n\t\tfor (ll i = n % (x - 1), cnt = 1;; i = i*n % (x - 1), cnt++) {\n\t\t\tif (used[i]) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tused[i] = 1;\n\t\t\tif (i == 1) {\n\t\t\t\tans = lcm(ans, cnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint lcm(int x, int y){\n    return x/__gcd(x,y)*y;\n}\n\nint euler_phi(int n){\n    if(n==0) return 0;\n    int ret = n;\n    for(int i=2; i*i<=n; ++i){\n        if(n%i==0){\n            ret -= ret/i;\n            while(n%i==0) n/=i;\n        }\n    }\n    if(n!=1) ret -= ret/n;\n    return ret;\n}\n\nmap<int,int> factorize(int n){\n    map<int,int> ret;\n    for(int i=2; i*i<=n; ++i){\n        while(n%i==0){\n            n/=i;\n            ++ret[i];\n        }\n    }\n    if(n>1) ++ret[n];\n    return ret;\n}\n\nll mod_pow(ll x, ll n, ll mod){\n    ll ret = 1;\n    while(n){\n        if(n&1) (ret*=x)%=mod;\n        (x*=x)%=mod;\n        n>>=1;\n    }\n    return ret;\n}\n\nint main(){\n    int n;\n    cin >>n;\n\n    map<int,int> f = factorize(n);\n    int L = 1;\n    for(const auto &p:f){\n        if(p.se>1){\n            cout << -1 << endl;\n            return 0;\n        }\n        L = lcm(L, p.fi-1);\n    }\n\n    if(__gcd(n,L)!=1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int ans = L;\n    int P = euler_phi(L);\n    for(int i=1; i*i<=P; ++i){\n        if(P%i==0){\n            for(int d:{i,P/i}){\n                if(mod_pow(n,d,L) == 1) ans = min(ans,d);\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nlong long int gcd(long long int a, long long int b) {\n\twhile (b) {\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\n\nlong long int lcm(long long int a, long long int b) {\n\treturn a * b / gcd(a, b);\n}\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tL = N;\n\tvector<int>v(1, 1);\n\tfor (int i = 2; i*i <= N; i++) {\n\t\twhile (N%i == 0) {\n\t\t\tif (v.back() == i) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tv.push_back(i);\n\t\t\tN /= i;\n\t\t}\n\t}\n\tif (N > 1)v.push_back(N);\n\tlong long int box = 1;\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tbox = lcm(box, v[i] - 1);\n\t}\n\tN = L;\n\t//cerr << box << endl;\n\tif (gcd(box, N) != 1) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tlong long int bag = box;\n\tR = box;\n\tfor (int i = 2; i*i <= box; i++) {\n\t\tif (box%i == 0) {\n\t\t\tbag *= i - 1;\n\t\t\tbag /= i;\n\t\t\twhile (box%i == 0) {\n\t\t\t\tbox /= i;\n\t\t\t}\n\t\t}\n\t}\n\tif (box > 1) {\n\t\tbag *= box - 1;\n\t\tbag /= box;\n\t}\n\tbox = R;\n\t//cerr << bag << endl;\n\tint ans = MOD;\n\tfor (int i = 1; i*i <= bag; i++) {\n\t\tif (power(N, i, box) == 1%box) {\n\t\t\tans = min(ans, i);\n\t\t}\n\t\tif (power(N, bag/i, box) == 1%box) {\n\t\t\tans = min(ans, (int)bag/i);\n\t\t}\n\t}\n\tif (ans == MOD)ans = -1;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint f(int a){return mod_pow(a,n,n);}\nint F(int a,int k){\n  if(k == 1) return f(a);\n  return F(f(a),k-1);\n}\n\nint mem[100];\nint F2(int a,int k){\n  if(k == 1) return mem[a] = f(a);\n  return mem[a] = mod_pow(mem[a],n,n);\n}\n\ndouble calcTime(){\n  static clock_t start = clock();// ??????????????????\n  clock_t end = clock();     // ????????????\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\nbool check(int k){\n  int res = 1;\n  for(int i=2;i<min(5LL,n);i++){\n    int a = i;\n    if(F(a,k) != a) res = 0;\n  }\n  return res;\n}\n\n\nint solve(){\n  int cnt = 0;\n  for(int k=1; calcTime() < 1000;k++,cnt++) if(check(k)) return k;\n  return -1;\n}\n\nvector<bool> visited;\nint find(int num){\n  if(visited[num]) return 0;\n  visited[num] = 1;\n  int res = 1 + find(F(num,1));\n  visited[num] = 0;\n  return res;\n}\n\nint find2(int start){\n  int num  = F(start,1);\n  int cnt = 1;\n  while(num != start) num = F(num,1),cnt++;\n  return cnt;\n}\n\nint solve2(){\n  visited.resize(n,0);\n  int res = 1;\n  for(int i=0;i<3;i++){\n    int num = rand()%(n-2)+1;\n    res = max(res,find2(num));\n  }\n  cout<<\"res=\"<<res<<endl;\n  return check(res)? res:-1;\n}\n\nvoid factor(int n){\n  for(int i=1;i<=n;i++){\n    if(n % i == 0) cout<<i<<\" \";\n  }\n  cout<<endl;\n}\n\nint lcm(int a,int b){return (a/__gcd(a,b)) * b;}\nint carmichealLambda(int n){\n  int res = 1;\n  if(n % 8 == 0) n/=2;\n\n  auto compute = [&](int i){\n    int sub = i - 1;\n    n/=i;\n    while(n%i == 0) n/=i, sub *=i;\n    res = lcm(res,sub);\n  };\n\n  for(int i=2;i*i<=n;i++) if( n % i == 0) compute(i);\n  if(n != 1) compute(n);\n  return res;\n}\n\nsigned main(){\n  cin>>n;\n  int car = carmichealLambda(n);\n  int car2 = carmichealLambda(car);\n  if(car == 1) {cout<<1<<endl;return 0;}\n  \n  //cout<<\"car=\"<<car<<endl;\n  //cout<<\"car2=\"<<car2<<endl;\n  //cout<<\"mod\"<<mod_pow(n,car2,car)<<endl;\n\n  int ans = car2;\n  for(int i=2;i*i<=car2;i++){\n    if(mod_pow(n,car2/i,car) == 1){ans=car2/i; break;}\n  }\n  //for(int i=1;i<=n;i++) if(__gcd(i,car) == 1) cout<<mod_pow(i,car2/3,car)<<endl;\n  if(car2 == 1)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long N, C = 1; vector<long long>R;\n\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 2; i*i <= N; i++) {\n\t\tif (N%i == 0) {\n\t\t\tN /= i; R.push_back(i);\n\t\t\tif (N%i == 0) { cout << \"-1\" << endl; return 0; }\n\t\t}\n\t}\n\tif (N >= 2) { R.push_back(N); }\n\tif (R.size() <= 1) { cout << \"1\" << endl; return 0; }\n\tif (R.size() >= 3 || R[0] == 2) { cout << \"-1\" << endl; return 0; }\n\tlong long a = R[0], b = R[1], c = 1, s = -1, t = -1;\n\tfor (int i = 1; i <= b / 2; i++) {\n\t\tc *= a; c %= (b - 1);\n\t\tif (c == 1) { s = i; break; }\n\t}\n\tc = 1;\n\tfor (int i = 1; i <= a / 2; i++) {\n\t\tc *= b; c %= (a - 1);\n\t\tif (c == 1) { t = i; break; }\n\t}\n\tif (s == -1 || t == -1) { cout << \"-1\" << endl; }\n\telse { cout << s*t / gcd(s, t) << endl; }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nint euler(int x){\n    int res=x;\n    for(int i=2;i*i<=x;i++){\n        if(x%i==0){\n            res=res/i*(i-1);\n            while(x%i==0) x/=i;\n        }\n    }\n    if(x>1) res=res/x*(x-1);\n    return res;\n}\n\nll powm(ll x,ll k,ll p){\n    ll res=1%p;\n    while(k){\n        if(k&1) res=res*x%p;\n        x=x*x%p;\n        k>>=1;\n    }\n    return res;\n}\nint circ(int n,int p){\n    int x=euler(p);\n    vector<int> divs;\n    for(int i=1;i*i<=x;i++){\n        if(x%i==0){\n            divs.push_back(i);\n            divs.push_back(x/i);\n        }\n    }\n    int res=x+1;\n    // cerr<<p<<\" \"<<x<<endl;\n    // cerr<<n<<\" \"<<n%p<<endl;\n    // cerr<<powm(n,1,p)<<endl;\n    for(auto d:divs){\n        if(powm(n,d,p)==1%p){\n            res=min(res,d);\n        }\n    }\n    if(res>x) return -1;\n    return res;\n}\n\nint lca(int lhs,int rhs){\n    return lhs/__gcd(lhs,rhs)*rhs;\n}\nint main(){\n    int n; cin>>n;\n    int pren=n;\n    vector<int> ps;\n    for(int i=2;i*i<=n;i++){\n        if(n%i==0){\n            n/=i;\n            ps.push_back(i);\n            if(n%i==0){\n                cout<<-1<<endl;\n                return 0;\n            }\n        }\n    }\n    if(n>1){ps.push_back(n);}\n    n=pren;\n    int res=1;\n    for(auto p:ps){\n        vector<int> divs;\n        int r=circ(n,p-1);\n        if(r<0){\n            cout<<-1<<endl;\n            return 0;\n        }\n        res=lca(res,r);\n    }\n    cout<<res<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef long long int lli;\nconst lli sqrtlimit = 1e5;\n\nvector<bool> prime(sqrtlimit, true);\nvoid initPrimeTable(){\n    prime[0] = prime[1] = false;\n    for(int i=2; i*i<sqrtlimit; i++){\n        if(prime[i]){\n            for(int j=i*2; j<sqrtlimit; j+=i){\n                prime[j] = false;\n            }\n        }\n    }\n}\nvector<pair<lli, lli> > factoring(int n){\n    vector<pair<lli, lli> > ret;\n    for(int i=2; i<=sqrtlimit; i++){\n        if(!prime[i]) continue;\n        if(n%i == 0){\n            ret.emplace_back(i, 1);\n            n /= i;\n            while(n%i == 0){\n                ret.back().second++;\n                n /= i;\n            }\n        }\n    }\n    if(n != 1) ret.emplace_back(n, 1);\n    return ret;\n}\n\nlli modpow(lli a, lli b, lli m){\n    lli ret = 1;\n    for(int i=63; i>=0; i--){\n        ret = ret*ret %m;\n        if((b & 1LL<<i) != 0) ret = ret*a %m;\n    }\n    return ret;\n}\n\nlli gcd(lli a, lli b){\n    if(b==0) return a;\n    return gcd(b, a%b);\n}\n\nlli lcm(lli a, lli b){\n    lli d = gcd(a, b);\n    return a/d*b;\n}\n\nint main(){\n    initPrimeTable();\n\n    lli n;\n    cin >> n;\n    vector<pair<lli, lli> > factor = factoring(n);\n    for(auto f: factor){\n        if(f.second != 1){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    lli l = 1;\n    for(auto f: factor){\n        l = lcm(l, f.first -1);\n    }\n    if(gcd(l, n) != 1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    factor = factoring(l);\n    lli phi = 1;\n    for(auto f: factor){\n        phi *= modpow(f.first, f.second -1, (int)1e18) *(f.first -1);\n    }\n\n    vector<lli> fphi;\n    for(int i=1; i*i<=phi; i++){\n        if(phi%i == 0){\n            fphi.push_back(i);\n            fphi.push_back(phi/i);\n        }\n    }\n\n    sort(fphi.begin(), fphi.end());\n    for(lli f: fphi){\n        if(modpow(n, f, l) == 1%l){\n            cout << f << endl;\n            break;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nint main(){\n  ll n;\n  cin>>n;\n  ll v=euler(n);\n\n  if( __gcd(n,v) != 1 ){\n    cout<<-1<<endl;\n  }else{\n    ll ans=1;\n    ll p=n%v;\n    while(p!=1){\n      p=(p*n)%v;\n      ans++;\n      if(ans>1e8){\n        ans=euler(v);\n        break;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <random>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(12231817);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> random_distinct_integers(int l, int r, int k) {\n\tassert((r - l) >= k);\n\tset<int> s;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x = rand_rng(l, r);\n\t\twhile (s.find(x) != s.end()) x = rand_rng(l, r);\n\t\ts.insert(x);\n\t}\n\treturn vector<int>(s.begin(), s.end());\n}\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nconst int max_search_size = 1;\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse {\n\t\tvector<int> v = random_distinct_integers(0, n, min(n, max_search_size));\n\t\tvector<int> a(v.size());\n\t\tfor (int i = 0; i < v.size(); i++) a[i] = modpow(v[i], n, n);\n\t\tfor (int i = 1; ; i++) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\t\tif (a[j] != v[j]) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tcout << i << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int j = 0; j < v.size(); j++) a[j] = modpow(a[j], n, n);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nll Pow(ll a, ll b, ll mod) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tll N;\n\tcin >> N;\n\tvector<ll> div;\n\tfor (ll i = 2; i * i <= N; i++) {\n\t\tif (i * i == N) {\n\t\t\tdiv.push_back(i);\n\t\t}\n\t\telse if (N % i == 0) {\n\t\t\tdiv.push_back(i);\n\t\t\tdiv.push_back(N / i);\n\t\t}\n\t}\n\tif (div.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tsort(div.begin(), div.end());\n\tll res = 1;\n\tfor (auto val : div) {\n\t\tmap<ll, bool> used;\n\t\tll tmp = val, cnt = 0;\n\t\twhile (!used[val]) {\n\t\t\tused[val] = true;\n\t\t\tval = Pow(val, N, N);\n\t\t\tcnt++;\n\t\t}\n\t\tif (val == tmp) {\n\t\t\tres = lcm(res, cnt);\n\t\t}\n\t\telse {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n\n    if(cnt>1e6){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n\n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n  \n  ans=lcm(ans, euler(n) );\n\n  if( n%ans== 0 || __gcd(n,ans) !=1){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e7){\n      cnt=euler(ans)/2;\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n\n  /*\n  ll C=1;\n  for(ll i=0;i<n;i++){\n    ll k=solve( i , n );\n    C=lcm(k,C);\n  }\n  */\n  //  cout<<C<<' '<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nll Pow(ll a, ll b, ll mod) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tll N;\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (N % 2 == 0) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<ll> div;\n\tfor (ll i = 2; i * i <= N; i++) {\n\t\tif (i * i == N) {\n\t\t\tdiv.push_back(i);\n\t\t}\n\t\telse if (N % i == 0) {\n\t\t\tdiv.push_back(i);\n\t\t\twhile (N % i == 0) {\n\t\t\t\tN /= i;\n\t\t\t}\n\t\t}\n\t}\n\tif (div.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (N != 1) {\n\t\tdiv.push_back(N);\n\t}\n\tsort(div.begin(), div.end());\n\tll res = 1;\n\tmap<ll, bool> used;\n\tfor (auto val : div) {\n\t\tll tmp = val, cnt = 0;\n\t\twhile (!used[val]) {\n\t\t\tused[val] = true;\n\t\t\tval = Pow(val, N, N);\n\t\t\tcnt++;\n\t\t}\n\t\tif (val == tmp) {\n\t\t\tres = lcm(res, cnt);\n\t\t}\n\t\telse {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n\nll powmod(ll x,ll n,ll mod){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x) % mod;\n        x = (x*x)%mod;\n        n >>= 1;\n    }\n    return res;\n}\nll F(ll k,ll a,ll N){\n    if(k <= 1) return powmod(a,N,N);\n    return powmod(F(k-1,a,N),N,N);\n}\n\nvoid greedy_test(){\n    ll maxk = 0;\n    for(ll N = 2; N <= 10000; N++){\n        bool ok2 = false;\n        for(ll k = 1; k < 100; k++){\n            bool ok = true;\n            for(ll a = 1; a < N; a++){\n                if(a == F(k,a,N)) continue;\n                ok = false;\n                break;\n            }\n            if(ok){\n                ok2 = true;\n                //cout << \"ok\" << endl;\n                //cout << N << \" \" << k << endl;\n                maxk = max(maxk,k);\n                break;\n            }\n        }\n        if(!ok2){\n            //cout << \"none\" << endl;\n            //cout << N << endl;\n        }\n        //cout << \" === \" << endl;\n    }\n    cout << maxk << endl;\n}\nvoid test(ll N){\n    for(int k = 1; k < N; k++){\n        cout << k << \" \" << F(2,k,N) << endl;\n        cout << \" === \" << endl;\n    }\n}\n\nunsigned xor128_x = 123456789, xor128_y = 352436069, xor128_z = 521288629, xor128_w = 88675123;\nunsigned xor128(){\n    unsigned t = xor128_x ^ (xor128_x << 11);\n    xor128_x = xor128_y; xor128_y = xor128_z; xor128_z = xor128_w;\n    return xor128_w = xor128_w ^ (xor128_w >> 19) ^ (t ^ (t >> 8));\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n//    ll N; cin >> N;\n//    test(N);\n//    greedy_test();\n    ll N; cin >> N;\n    \n    for(ll k = 1; k <= 5000; k++){\n        ll times = 5000;\n        bool ok = true;\n        while(times--){\n            ll a = xor128()%N;\n            if(a == F(k,a,N)) continue;\n            ok = false;\n            break;\n        }\n        if(ok){\n            cout << k << endl;\n            return 0;\n        }\n    }\n    cout << -1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nint main(){\n  ll n;\n  cin>>n;\n  ll v=euler(n);\n\n  if( __gcd(n,v) != 1 ){\n    cout<<-1<<endl;\n  }else{\n    ll ans=1;\n    ll p=n%v;\n    while(p!=1){\n      p=(p*n)%v;\n      ans++;\n      if(ans>1e7){\n        ans=euler(v);\n        break;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n\nll powmod(ll x,ll n,ll mod){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x) % mod;\n        x = (x*x)%mod;\n        n >>= 1;\n    }\n    return res;\n}\nll F(ll k,ll a,ll N){\n    if(k <= 1) return powmod(a,N,N);\n    return powmod(F(k-1,a,N),N,N);\n}\n\nvoid greedy_test(){\n    ll maxk = 0;\n    for(ll N = 2; N <= 10000; N++){\n        bool ok2 = false;\n        for(ll k = 1; k < 100; k++){\n            bool ok = true;\n            for(ll a = 1; a < N; a++){\n                if(a == F(k,a,N)) continue;\n                ok = false;\n                break;\n            }\n            if(ok){\n                ok2 = true;\n                //cout << \"ok\" << endl;\n                //cout << N << \" \" << k << endl;\n                maxk = max(maxk,k);\n                break;\n            }\n        }\n        if(!ok2){\n            //cout << \"none\" << endl;\n            //cout << N << endl;\n        }\n        //cout << \" === \" << endl;\n    }\n    cout << maxk << endl;\n}\nvoid test(ll N){\n    for(int k = 1; k < N; k++){\n        cout << k << \" \" << F(2,k,N) << endl;\n        cout << \" === \" << endl;\n    }\n}\n\nunsigned xor128_x = 123456789, xor128_y = 352436069, xor128_z = 521288629, xor128_w = 88675123;\nunsigned xor128(){\n    unsigned t = xor128_x ^ (xor128_x << 11);\n    xor128_x = xor128_y; xor128_y = xor128_z; xor128_z = xor128_w;\n    return xor128_w = xor128_w ^ (xor128_w >> 19) ^ (t ^ (t >> 8));\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n//    ll N; cin >> N;\n//    test(N);\n//    greedy_test();\n    ll N; cin >> N;\n    \n    for(ll k = 1; k <= 1000; k++){\n        ll times = 10000;\n        bool ok = true;\n        while(times--){\n            ll a = xor128()%N;\n            if(a == F(k,a,N)) continue;\n            ok = false;\n            break;\n        }\n        if(ok){\n            cout << k << endl;\n            return 0;\n        }\n    }\n    cout << -1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){\n  return x/__gcd(x,y)*y;\n}\nint mpow(int n,int x){\n  int res=1LL;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.first-1));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int x=-1,y;\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n    //cout<<ans<<endl;\n    if(x<0) x=p.first;\n    else y=p.first;\n  }\n  if(__gcd(x+y-1,(x-1)*(y-1))!=1LL){\n    cout<<-1<<endl;\n    return 0;\n  }\n  //cout<<x<<\" \"<<y<<endl;\n  //cout<<x+y-1<<\" \"<<(x-1)*(y-1)<<endl;\n  int k=ker(ans);\n  //cout<<k<<endl;\n  int tmp=k;\n  for(int i=2;i*i<=k;i++){\n    if(k%i) continue;\n    //cout<<i<<\" \"<<mod_pow(x,mod_pow(b,i,ans),b)<<endl;\n    //cout<<k/i<<\" \"<<mod_pow(x,mod_pow(b,k/i,ans),b)<<endl;\n    if(mod_pow(x,mod_pow(b,i,ans),b)==x&&\n       mod_pow(y,mod_pow(b,i,ans),b)==y&&\n       mod_pow(x+1,mod_pow(b,i,ans),b)==x+1&&\n       mod_pow(y-1,mod_pow(b,i,ans),b)==y-1) tmp=min(tmp,i);\n    if(mod_pow(x,mod_pow(b,k/i,ans),b)==x&&\n       mod_pow(y,mod_pow(b,k/i,ans),b)==y&&\n       mod_pow(x+1,mod_pow(b,k/i,ans),b)==x+1&&\n       mod_pow(y-1,mod_pow(b,k/i,ans),b)==y-1) tmp=min(tmp,k/i);\n  }\n  cout<<tmp<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=1;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==1){\n      break;\n    }\n\n    if(cnt>1e6){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n\n  ans=lcm(ans, euler(n) );\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e7){\n      cnt=euler(ans);\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long N, C = 1; vector<long long>R;\n\nint main() {\n\tcin >> N;\n\tfor (int i = 2; i*i <= N; i++) {\n\t\tif (N%i == 0) {\n\t\t\tN /= i; R.push_back(i);\n\t\t\tif (N%i == 0) { cout << \"-1\" << endl; return 0; }\n\t\t}\n\t}\n\tif (N >= 2) { R.push_back(N); }\n\tif (R.size() >= 3 || R[0] == 2) { cout << \"-1\" << endl; return 0; }\n\tif (R.size() == 1) { cout << \"1\" << endl; return 0; }\n\tlong long a = R[0], b = R[1], c = 1;\n\tfor (int i = 1; i <= b / 2; i++) {\n\t\tc *= a; c %= (b - 1);\n\t\tif (c == 1) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"-1\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n\n// min m s.t. a^m = 1 mod n (a, n are coprime)\ntemplate<typename T>\nT carmichael_lambda(T n){\n  auto lcm=[](auto a,auto b){return a/__gcd(a,b)*b;};\n  T res=1;\n  if(n%8==0) n/=2;\n  for(Int i=2;i*i<=n;i++){\n    if(n%i==0){\n      T tmp=i-1;\n      for(n/=i;n%i==0;n/=i) tmp*=i;\n      res=lcm(res,tmp);\n    }\n  }\n  if(n!=1) res=lcm(res,n-1);\n  return res;\n}\n\n\ntemplate<typename T>\nInt isprime(T x){\n  if(x<=1) return 0;\n  for(T i=2;i*i<=x;i++)\n    if(x%i==0) return 0;\n  return 1;\n}\n\n\ntemplate<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}\n\n\ntemplate<typename T>\nT totient(T n){\n  T res=n;\n  for(T i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      for(;n%i==0;n/=i);\n    }\n  }\n  if(n!=1) res=res/n*(n-1);\n  return res;\n}\n\n\ntemplate<typename T>\nT mod_pow(T a,long long n,T mod){\n  using ll = long long;\n  T res(1);\n  while(n){\n    if(n&1) res=(ll)res*a%mod;\n    a=(ll)a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  cin>>n;\n\n  if(isprime(n)) drop(1);\n\n  Int x=carmichael_lambda(n);\n  n%=x;\n  if(__gcd(n,x)!=1) drop(-1);\n\n  Int phi=totient(x);\n  vector<Int> cand;\n  for(Int p=2;p*p<=phi;p++){\n    if(phi%p) continue;\n    cand.emplace_back(p);\n    cand.emplace_back(phi/p);\n  }\n\n  for(auto c:cand)\n    while(phi%c==0 and mod_pow(n,phi/c,x)==1) phi/=c;\n  cout<<phi<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint f(int a){return mod_pow(a,n,n);}\nint F(int a,int k){\n  if(k == 1) return f(a);\n  return F(f(a),k-1);\n}\n\nint F2(int a,int k){return mod_pow(a,pow(n,k),n);}\n\n\ndouble calcTime(){\n  static clock_t start = clock();// ??????????????????\n  clock_t end = clock();     // ????????????\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\nbool check(int k){\n  for(int i=0;i<100;i++){\n    int a = rand()%n + 1;\n    if(a == n) a--;\n    if(F(a,k) != a) return 0;\n  }\n  return 1;\n}\nint solve(){\n  for(int k=1;calcTime() < 4.8;k++) if(check(k)) return k;\n  return -1;\n}\n\nsigned main(){\n  srand((unsigned) time(NULL));\n  cin>>n;\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(ll i = 0;i<((ll)(n));i++)\n#define reg(i,a,b) for(ll i = ((ll)(a));i<=((ll)(b));i++)\n#define irep(i,n) for(ll i = ((ll)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(ll i = ((ll)(b));i>=((ll)(a));i--)\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T = int> void print(vector<T> v){for(auto a:v)cout<<a<<\" \";cout<<endl;}\n\n/*\n*/\n\nll modpow(__int128_t a, ll n,ll mo) {\n\t__int128_t r=1;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nll euler(ll n){\n\tll res=n;\n\tfor(ll i=2;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tres=res/i*(i-1);\n\t\t\twhile(n%i==0)n/=i;\n\t\t}\n\t}\n\tif(n!=1)res=res/n*(n-1);\n\treturn res;\n}\n\nlong long gcd(long long a,long long b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nlong long lcm(long long a,long long b){\n\treturn a*b/gcd(b,a%b);\n}\n\nll n,l=1,ans=1e18;\n\nint main(void){\n\tcin>>n;\n\tif(n==2){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfor(ll i=2;i*i<=n;i++){  // 同じ素因数2個あったらアウト\n\t\tif(n%(i*i)==0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tll n2=n;\n\tfor(ll i=2;i*i<=n;i++){\n\t\tif(n2%i==0){\n\t\t\tl = lcm(l,i-1);\n\t\t\tn2 /= i;\n\t\t}\n\t}\n\tif(n2>1)l = lcm(l,n2-1);\n\tif(gcd(n,l)!=1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tif(gcd(n,l)!=1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tll phi_l = euler(l);\n\tfor(ll i=1;i*i<=phi_l;i++){\n\t\tif(phi_l%i==0){\n\t\t\tif(modpow(n,i,l)==1)ans=min(ans,i);\n\t\t\tif(modpow(n,phi_l/i,l)==1)ans=min(ans,phi_l/i);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n\n    if(cnt>1e8){\n      cnt=euler(b);\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n\n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ll num= euler(n/s[i]);\n    ans=lcm(ans, num );\n  }\n  \n\n\n  if( n%ans== 0 || __gcd(n,ans) !=1){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e8){\n      cnt=euler(ans);\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n\n  /*\n  ll C=1;\n  for(ll i=0;i<n;i++){\n    ll k=solve( i , n );\n    C=lcm(k,C);\n  }\n  */\n  //  cout<<C<<' '<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){return x/__gcd(x,y)*y;}\nint mpow(int n,int x){\n  int res=1;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    //cout<<res<<endl;\n    //cout<<p.first<<\" \"<<p.second<<endl;\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.second-1));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n  }\n  cout<<ker(ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nint main(){\n  ll n;\n  cin>>n;\n  ll v=euler(n);\n\n  if( __gcd(n,v) != 1 ){\n    cout<<-1<<endl;\n  }else{\n    ll ans=1;\n    ll p=n%v;\n    while(p!=1){\n      p=(p*n)%v;\n      ans++;\n      if(ans>1e9)break;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint f(int a){return mod_pow(a,n,n);}\nint F(int a,int k){\n  if(k == 1) return f(a);\n  return F(f(a),k-1);\n}\n\nint F2(int a,int k){return mod_pow(a,pow(n,k),n);}\n\n\ndouble calcTime(clock_t s = NULL){\n  static clock_t start = clock();// ??????????????????\n  if(s != NULL) start = s;\n  clock_t end = clock();     // ????????????\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\nbool check(int k){\n  int res = 1;\n  for(int i=0;i<100;i++){\n    int a = rand()%n + 1;\n    if(a == n) a--;\n    res &= F(a,k) == a;\n  }\n  return res;                  \n}\nint solve(){\n  calcTime(clock());\n  for(int k=1;calcTime() < 4.8;k++){\n    if(check(k)) return 1;\n  }\n  return -1;\n}\n\nsigned main(){\n  cin>>n;\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nbool isp[32000];\nvi p;\nint main() {\n\tint n;\n\tcin >> n;\n\tint n2 = n;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (isp[i])continue;\n\t\tp.push_back(i);\n\t\tfor (int j = 2 * i; j*j <= n; j += i)isp[j] = 1;\n\t}\n\tvi p2;\n\tfor (auto x : p) {\n\t\tif (n%x == 0) {\n\t\t\tp2.push_back(x);\n\t\t\tn /= x;\n\t\t\tif (n%x == 0) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (p2.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (n > 1)p2.push_back(n);\n\tn = n2;\n\tint ans = 1;\n\tfor (auto x : p2) {\n\t\tvi used(x);\n\t\tfor (int i = n % (x - 1), cnt = 1;; i = i*i % (x - 1), cnt++) {\n\t\t\tif (used[i]) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tused[i] = 1;\n\t\t\tif (i == 1) {\n\t\t\t\tans = lcm(ans, cnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint f(int a){return mod_pow(a,n,n);}\nint F(int a,int k){\n  if(k == 1) return f(a);\n  return F(f(a),k-1);\n}\n\nint mem[100];\nint F2(int a,int k){\n  if(k == 1) return mem[a] = f(a);\n  return mem[a] = mod_pow(mem[a],n,n);\n}\n\ndouble calcTime(){\n  static clock_t start = clock();// ??????????????????\n  clock_t end = clock();     // ????????????\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\nbool check(int k){\n  int res = 1;\n  for(int i=2;i<min(5LL,n);i++){\n    int a = i;\n    if(F(a,k) != a) res = 0;\n  }\n  return res;\n}\n\n\nint solve(){\n  int cnt = 0;\n  for(int k=1; calcTime() < 1;k++,cnt++) if(check(k)) return k;\n  return -1;\n}\n\nvector<bool> visited;\nint find(int num){\n  if(visited[num]) return 0;\n  visited[num] = 1;\n  int res = 1 + find(F(num,1));\n  visited[num] = 0;\n  return res;\n}\n\nint find2(int start){\n  int num  = F(start,1);\n  int cnt = 1;\n  while(num != start) num = F(num,1),cnt++;\n  return cnt;\n}\n\nint lcm(int a,int b){return (a/__gcd(a,b)) * b;}\n\nint solve2(){\n  visited.resize(n,0);\n  int res = 1;\n  for(int i=0;i<3;i++){\n    int num = rand()%(n-2)+1;\n    res = max(res,find2(num));\n  }\n  cout<<\"res=\"<<res<<endl;\n  return check(res)? res:-1;\n}\n\nvoid factor(int n){\n  for(int i=1;i<=n;i++){\n    if(n % i == 0) cout<<i<<\" \";\n  }\n  cout<<endl;\n}\n\nint carmichealLambda(int n){\n  int res = 1;\n  if(n % 8 == 0) n/=2;\n  \n  for(int i=2;i<=n;i++){\n    if( n % i != 0) continue;\n    int sub = i - 1;\n    n/=i;\n    while(n %i == 0) n/=i, sub *=i;\n    res = lcm(res,sub);\n  }\n  return res;\n}\n\nsigned main(){\n  srand((unsigned) time(NULL));\n  cin>>n;\n  //cout<<solve2()<<endl;\n\n  /*  int cnt = 0;\n  for(int i=1;i<n;i++){\n    continue;\n    if(__gcd(i,n) == 1) cnt++;\n    int flag = 0;\n    for(int k=1;k<10;k++)if(F(i,k) == 2) flag = 1;\n    if(!flag) continue;\n    cout<<\"i=\"<<i<<\":\";\n    for(int k=1;k<10;k++)cout<<\"\\t\"<<F(i,k);\n    cout<<endl;\n  }\n  */\n\n  int car = carmichealLambda(n);\n  if(car == 1) {cout<<1<<endl;return 0;}\n  int c = n,b = 1;\n  unordered_set<int> used;\n  int find = 1;\n  while(c % car != 1){\n    if(used.count(c)) {find=0;break;}\n    used.insert(c);\n    c = c*n%car,b++;\n  }\n  \n  if(find) cout<<b<<endl;\n  else cout<<-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){\n  return x/__gcd(x,y)*y;\n}\nint mpow(int n,int x){\n  int res=1;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    //cout<<res<<endl;\n    //cout<<p.first<<\" \"<<p.second<<endl;\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.first-1));\n    }\n    //cout<<res<<endl;\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int x=-1,y;\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n    //cout<<ans<<endl;\n    if(x<0) x=p.first;\n    else y=p.first;\n  }\n  if(__gcd(x+y-1,(x-1)*(y-1))!=1LL){\n    cout<<-1<<endl;\n    return 0;\n  }\n  cout<<ker(ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n\nll powmod(ll x,ll n,ll mod){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x) % mod;\n        x = (x*x)%mod;\n        n >>= 1;\n    }\n    return res;\n}\nll F(ll k,ll a,ll N){\n    if(k <= 1) return powmod(a,N,N);\n    return powmod(F(k-1,a,N),N,N);\n}\n\nvoid greedy_test(){\n    ll maxk = 0;\n    for(ll N = 2; N <= 10000; N++){\n        bool ok2 = false;\n        for(ll k = 1; k < 100; k++){\n            bool ok = true;\n            for(ll a = 1; a < N; a++){\n                if(a == F(k,a,N)) continue;\n                ok = false;\n                break;\n            }\n            if(ok){\n                ok2 = true;\n                //cout << \"ok\" << endl;\n                //cout << N << \" \" << k << endl;\n                maxk = max(maxk,k);\n                break;\n            }\n        }\n        if(!ok2){\n            //cout << \"none\" << endl;\n            //cout << N << endl;\n        }\n        //cout << \" === \" << endl;\n    }\n    cout << maxk << endl;\n}\nvoid test(ll N){\n    for(int k = 1; k < N; k++){\n        cout << k << \" \" << F(2,k,N) << endl;\n        cout << \" === \" << endl;\n    }\n}\n\nunsigned xor128_x = 123456789, xor128_y = 352436069, xor128_z = 521288629, xor128_w = 88675123;\nunsigned xor128(){\n    unsigned t = xor128_x ^ (xor128_x << 11);\n    xor128_x = xor128_y; xor128_y = xor128_z; xor128_z = xor128_w;\n    return xor128_w = xor128_w ^ (xor128_w >> 19) ^ (t ^ (t >> 8));\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n//    ll N; cin >> N;\n//    test(N);\n//    greedy_test();\n    ll N; cin >> N;\n    \n    for(ll k = 1; k <= 1000; k++){\n        ll times = 1000;\n        bool ok = true;\n        while(times--){\n            ll a = xor128()%N;\n            if(a == F(k,a,N)) continue;\n            ok = false;\n            break;\n        }\n        if(ok){\n            cout << k << endl;\n            return 0;\n        }\n    }\n    cout << -1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\ntemplate <class T>\nT gcd(T n, T m) {\n    if (n < 0) n = -n;\n    if (m < 0) m = -m;\n    while (m != 0) {\n        n %= m;\n        std::swap(n, m);\n    }\n    return n;\n}\n\nusing lint = long long;\n\nlint pow(lint b, lint n, lint m) {\n    lint x = 1;\n    b %= m;\n\n    while (n > 0) {\n        if (n & 1) (x *= b) %= m;\n        n >>= 1;\n        (b *= b) %= m;\n    }\n    return x;\n}\n\nlint totient(lint n) {\n    lint m = n;\n\n    for (lint p = 2; p * p <= n; ++p) {\n        if (n % p != 0) continue;\n\n        m = m / p * (p - 1);\n        while (n % p == 0) n /= p;\n    }\n\n    if (n > 1) m = m / n * (n - 1);\n\n    return m;\n}\n\nvoid solve() {\n    lint n;\n    std::cin >> n;\n\n    lint l = 1;\n    {\n        auto nn = n;\n        for (lint p = 2; p * p <= nn; ++p) {\n            if (nn % p != 0) continue;\n\n            l *= (p - 1) / gcd(l, p - 1);\n\n            if (nn % (p * p) == 0) {\n                std::cout << -1 << std::endl;\n                return;\n            }\n            nn /= p;\n        }\n\n        if (nn > 1) {\n            auto p = nn;\n            l *= (p - 1) / gcd(l, p - 1);\n        }\n    }\n\n    if (gcd(n, l) != 1) {\n        std::cout << -1 << std::endl;\n        return;\n    }\n\n    auto m = totient(l);\n\n    auto ans = m;\n    for (lint p = 1; p * p <= m; ++p) {\n        if (m % p != 0) continue;\n\n        if (pow(n, p, l) == 1) ans = std::min(ans, p);\n        if (pow(n, m / p, l) == 1) ans = std::min(ans, m / p);\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nnamespace n91 {\n\n\tusing i8 = ::std::int_least8_t;\n\tusing i32 = ::std::int_least32_t;\n\tusing i64 = ::std::int_least64_t;\n\tusing u8 = ::std::uint_least8_t;\n\tusing u32 = ::std::uint_least32_t;\n\tusing u64 = ::std::uint_least64_t;\n\tusing isize = ::std::ptrdiff_t;\n\tusing usize = ::std::size_t;\n\n\tclass rep {\n\t\tconst usize f, l;\n\n\tpublic:\n\t\tclass itr {\n\t\t\tfriend rep;\n\t\t\tusize i;\n\t\t\tconstexpr itr(const usize x) noexcept : i(x) {}\n\n\t\tpublic:\n\t\t\tvoid operator++() noexcept { ++i; }\n\t\t\tconstexpr usize operator*() const noexcept { return i; }\n\t\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t\t};\n\t\tconstexpr rep(const usize first, const usize last) noexcept\n\t\t\t: f(first), l(last) {}\n\t\tconstexpr itr begin() const noexcept { return itr(f); }\n\t\tconstexpr itr end() const noexcept { return itr(l); }\n\t};\n\tclass revrep {\n\t\tconst usize f, l;\n\n\tpublic:\n\t\tclass itr {\n\t\t\tfriend revrep;\n\t\t\tusize i;\n\t\t\tconstexpr itr(usize x) noexcept : i(x) {}\n\n\t\tpublic:\n\t\t\tvoid operator++() noexcept { --i; }\n\t\t\tconstexpr usize operator*() const noexcept { return i; }\n\t\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t\t};\n\t\tconstexpr revrep(const usize first, const usize last) noexcept\n\t\t\t: f(first), l(last) {}\n\t\tconstexpr itr begin() const noexcept { return itr(l - 1); }\n\t\tconstexpr itr end() const noexcept { return itr(f - 1); }\n\t};\n\ttemplate <class T> bool amax(T &a, const T &b) {\n\t\treturn b < a ? false : (a = b, true);\n\t}\n\ttemplate <class T> bool amin(T &a, const T &b) {\n\t\treturn a < b ? false : (a = b, true);\n\t}\n\ttemplate <class T> bool asmax(T &a, const T &b) {\n\t\treturn a < b ? (a = b, true) : false;\n\t}\n\ttemplate <class T> bool asmin(T &a, const T &b) {\n\t\treturn b < a ? (a = b, true) : false;\n\t}\n\ttemplate <class T> using vec_alias = ::std::vector<T>;\n\ttemplate <class T> auto md_vec(const usize n, const T &value) {\n\t\treturn ::std::vector<T>(n, value);\n\t}\n\ttemplate <class... Args> auto md_vec(const usize n, Args... args) {\n\t\treturn ::std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n\t}\n\ttemplate <class T> const T &as_const(const T &v) noexcept { return v; }\n\ttemplate <class T> constexpr T difference(const T &a, const T &b) {\n\t\treturn a < b ? b - a : a - b;\n\t}\n\n} // namespace n91\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <unordered_map>\n\nnamespace n91 {\n\n\ttemplate <class T> T gcd(T m, T n) {\n\t\twhile (m %= n)\n\t\t\t::std::swap(m, n);\n\t\treturn n;\n\t}\n\n\tu64 lcm(const std::vector<u64> &a) {\n\t\tu64 ret = 1;\n\t\tfor (const auto e : a) {\n\t\t\tret = ret / gcd(ret, e)*e;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tu64 modpow(u64 a, u64 k, const u64 mod) {\n\t\tu64 ret = 1;\n\t\twhile (k) {\n\t\t\tif (k % 2 == 1) {\n\t\t\t\tret = ret*a%mod;\n\t\t\t}\n\t\t\tk /= 2;\n\t\t\ta = a*a%mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tu64 dl(u64 a,const u64 mod,const u64 t) {\n\t\tu64 i = 1;\n\t\tfor (;i*i <= mod;++i) {\n\t\t\tif (t % i == 0) {\n\t\t\t\tif (modpow(a, i, mod) == 1) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (;i != 0;--i) {\n\t\t\tif (t % 1 == 0) {\n\t\t\t\tif (modpow(a, t / i, mod) == 1) {\n\t\t\t\t\treturn t / i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvoid main_() {\n\t\tu64 n;\n\t\tstd::cin >> n;\n\t\tif (n == 2) {\n\t\t\tstd::cout << 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t\tu64 l;\n\t\t{\n\t\t\tstd::vector<u64> facts;\n\t\t\tu64 c = n;\n\t\t\tfor (u64 i = 2;i*i <= c;++i) {\n\t\t\t\tif (c%i == 0) {\n\t\t\t\t\tc /= i;\n\t\t\t\t\tif (c%i == 0) {\n\t\t\t\t\t\tstd::cout << \"-1\" << std::endl;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tfacts.emplace_back(i - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c != 1) {\n\t\t\t\tfacts.emplace_back(c - 1);\n\t\t\t}\n\t\t\tl = lcm(facts);\n\t\t}\n\t\tif (gcd(n, l) != 1) {\n\t\t\tstd::cout << \"-1\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\tu64 lc = l, t = l;\n\t\tfor (u64 i = 2;i*i <= lc;++i) {\n\t\t\tif (lc%i == 0) {\n\t\t\t\tt = t / i*(i - 1);\n\t\t\t\twhile (lc%i == 0) {\n\t\t\t\t\tlc /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lc != 1) {\n\t\t\tt = t / lc*(lc - 1);\n\t\t}\n\t\tu64 i = 1;\n\t\tfor (;i*i <= t;++i) {\n\t\t\tif (t%i == 0&& modpow(n, i, l) == 1) {\n\t\t\t\tstd::cout << i << std::endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (;i != 0;--i) {\n\t\t\tif (t%i == 0 && modpow(n, t/i, l) == 1) {\n\t\t\t\tstd::cout << t/i << std::endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n} // namespace n91\n\nint main() {\n\tn91::main_();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <random>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(12231817);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> random_distinct_integers(int l, int r, int k) {\n\tassert((r - l) >= k);\n\tset<int> s;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x = rand_rng(l, r);\n\t\twhile (s.find(x) != s.end()) x = rand_rng(l, r);\n\t\ts.insert(x);\n\t}\n\treturn vector<int>(s.begin(), s.end());\n}\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse {\n\t\tvector<int> v = random_distinct_integers(0, n, min(n, 2000));\n\t\tvector<int> a(v.size());\n\t\tfor (int i = 0; i < v.size(); i++) a[i] = modpow(v[i], n, n);\n\t\tfor (int i = 1; ; i++) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\t\tif (a[j] != v[j]) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tcout << i << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int j = 0; j < v.size(); j++) a[j] = modpow(a[j], n, n);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n\n    if(cnt>1e6){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n\n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n  \n  //  ans=lcm(ans, euler(n) );\n\n  if( n%ans== 0 || __gcd(n,ans) !=1){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e7){\n      cnt=euler(ans);\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n\n  /*\n  ll C=1;\n  for(ll i=0;i<n;i++){\n    ll k=solve( i , n );\n    C=lcm(k,C);\n  }\n  */\n  //  cout<<C<<' '<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <random>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(12231817);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> random_distinct_integers(int l, int r, int k) {\n\tassert((r - l) >= k);\n\tset<int> s;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x = rand_rng(l, r);\n\t\twhile (s.find(x) != s.end()) x = rand_rng(l, r);\n\t\ts.insert(x);\n\t}\n\treturn vector<int>(s.begin(), s.end());\n}\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse {\n\t\tvector<int> v = random_distinct_integers(0, n, min(n, 10000));\n\t\tvector<int> a(v.size());\n\t\tfor (int i = 0; i < v.size(); i++) a[i] = modpow(v[i], n, n);\n\t\tfor (int i = 1; ; i++) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\t\tif (a[j] != v[j]) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tcout << i << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int j = 0; j < v.size(); j++) a[j] = modpow(a[j], n, n);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nll N;\n\nll mod_pow(ll x,ll n, ll mod){\n\n\tif(n == 0)return 1;\n\tll ret = mod_pow(x*x%mod,n/2,mod);\n\tif(n%2 == 1)ret = ret*x%mod;\n\treturn ret;\n}\n\nll euler(ll num){\n\n\t ll ret = num;\n\n\t for(ll i = 2; i*i <= num;  i++){\n\t\t\tif(num%i == 0) {\n\t\t\t\t  ret  = ret/i*(i-1);\n\t\t\t\t  while(num%i == 0)num /= i;\n\t\t\t}\n\t  }\n\t  if(num != 1) ret = ret/num*(num-1);\n\t  return ret;\n}\n\nll gcd(ll x,ll y){\n\tif(x < y){\n\n\t\tswap(x,y);\n\t}\n\n\tif(y == 0){\n\t\treturn x;\n\t}else{\n\t\treturn gcd(y,x%y);\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%lld\",&N);\n\n\tvector<ll> V;\n\n\tll work_N = N;\n\n\tfor(ll i = 2; i*i <= N; i++){\n\n\t\tif(work_N%i == 0){\n\n\t\t\tV.push_back(i);\n\n\t\t\tint count = 0;\n\n\t\t\twhile(work_N%i == 0){\n\t\t\t\twork_N /= i;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tif(count >= 2){\n\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(work_N != 1){\n\t\tV.push_back(work_N);\n\t}\n\n\tll L = 1;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tll common = gcd(L,V[i]-1);\n\t\tL = L*(V[i]-1)/common;\n\t}\n\n\tif(gcd(L,N) != 1){\n\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\tll number = euler(L),ans = L;\n\n\tfor(ll k = 1; k <= number; k++){\n\n\t\tif(number%k != 0)continue;\n\n\t\tif(mod_pow(N,k,L) == 1){\n\n\t\t\tans = k;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nll Pow(ll a, ll b, ll mod) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tll N;\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (N % 2 == 0) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<ll> div;\n\tll n = N;\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (i * i == n) {\n\t\t\tdiv.push_back(i);\n\t\t}\n\t\telse if (n % i == 0) {\n\t\t\tdiv.push_back(i);\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t}\n\t}\n\tif (div.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (n > 1) {\n\t\tdiv.push_back(n);\n\t}\n\tif (div.size() == 1) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tsort(div.begin(), div.end());\n\tll res = 1;\n\tmap<ll, bool> used;\n\tfor (auto val : div) {\n\t\tll tmp = val, cnt = 0;\n\t\twhile (!used[val]) {\n\t\t\tused[val] = true;\n\t\t\tval = Pow(val, N, N);\n\t\t\tcnt++;\n\t\t}\n\t\tif (val == tmp) {\n\t\t\tres = lcm(res, cnt);\n\t\t}\n\t\telse {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse if (n == 2) cout << 1 << endl;\n\telse {\n\t\tint e = totient_function(n);\n\t\tint a = n % e;\n\t\tfor (int i = 1; ; i++) {\n\t\t\tif (a == 1) {\n\t\t\t\tcout << i << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta = 1LL * a * n % e;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nll Pow(ll a, ll b, ll mod) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tll N;\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (N % 2 == 0) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<ll> div;\n\tfor (ll i = 2; i * i <= N; i++) {\n\t\tif (i * i == N) {\n\t\t\tdiv.push_back(i);\n\t\t}\n\t\telse if (N % i == 0) {\n\t\t\tdiv.push_back(i);\n\t\t\tdiv.push_back(N / i);\n\t\t}\n\t}\n\tif (div.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tsort(div.begin(), div.end());\n\tll res = 1;\n\tfor (auto val : div) {\n\t\tmap<ll, bool> used;\n\t\tll tmp = val, cnt = 0;\n\t\twhile (!used[val]) {\n\t\t\tused[val] = true;\n\t\t\tval = Pow(val, N, N);\n\t\t\tcnt++;\n\t\t}\n\t\tif (val == tmp) {\n\t\t\tres = lcm(res, cnt);\n\t\t}\n\t\telse {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tcout << val << ' ' << cnt << endl;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T = long long >\nT pow_mod(T x, T n, T mod)\n{\n  T ret = 1;\n  while(n > 0) {\n    if(n & 1) ret = 1LL * ret * x % mod;\n    x = 1LL * x * x % mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\nint lcm(int x, int y)\n{\n  return (x / __gcd(x, y) * y);\n}\n\nmap< int, int > primefactor(int x)\n{\n  map< int, int > ret;\n  for(int i = 2; i * i <= x; i++) {\n    while(x % i == 0) {\n      ret[i]++;\n      x /= i;\n    }\n  }\n  if(x != 1) ret[x]++;\n  return (ret);\n}\n\nint lambda(int x)\n{\n  auto pp = primefactor(x);\n  vector< int > vs;\n  for(auto &p : pp) {\n    if(p.first == 2) {\n      if(p.second <= 2) vs.push_back(p.second);\n      else vs.push_back(1 << (p.second - 2));\n    } else {\n      int cur = 1;\n      for(int i = 1; i < p.second; i++) cur *= p.first;\n      cur *= p.first - 1;\n      vs.push_back(cur);\n    }\n  }\n  int ret = vs[0];\n  for(int i : vs) ret = lcm(ret, i);\n  return (ret);\n}\n\nvector< int > beet(int x)\n{\n  vector< int > vs;\n  for(int i = 1; i * i <= x; i++) {\n    if(x % i == 0) {\n      if(i * i != x) vs.push_back(x / i);\n      vs.push_back(i);\n    }\n  }\n  sort(begin(vs), end(vs));\n  return (vs);\n}\n\nint solve(int N)\n{\n  if(N == 2) return (1);\n  auto latte = lambda(N);\n  for(auto &s : beet(lambda(latte))) {\n    if(pow_mod(N, s, latte) == 1) return (s);\n  }\n  return (-1);\n}\n\n\nint main()\n{\n  int N;\n  cin >> N;\n  cout << solve(N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvector<int> Zalgorithm(string S) {\n  vector<int> A(S.size());\n  A[0] = S.size();\n  int i = 1, j = 0;\n  while(i < (int)S.size()) {\n    while(i+j < (int)S.size() && S[j] == S[i+j]) j++;\n    A[i] = j;\n    if(j == 0) { i++; continue; }\n    int k = 1;\n    while(i+k < (int)S.size() && k+A[k] < j) A[i+k] = A[k], k++;\n    i += k, j -= k;\n  }\n  return A;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  string S, T;\n  cin >> S >> T;\n  int n = S.size(), m = T.size();\n  string rS = S, rT = T;\n  reverse(all(rS));\n  reverse(all(rT));\n  string Z = T+S, rZ = rT+rS;\n  auto A = Zalgorithm(Z);\n  auto rA = Zalgorithm(rZ);\n\n  int ans = 0;\n  rep(i, n-m+1) {\n    if(n-i-m < 0) continue;\n    if(min(m, A[i+m])+min(m, rA[n-i]) == m-1) ans++;\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <utility>\n#include <functional>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, int> P;\nll gcd(ll a, ll b){\n    if(b==0) return a;\n    return gcd(b, a%b);\n}\nll lcm(ll a, ll b){\n    return a/gcd(a, b)*b;\n}\nll powmod(ll a, ll k, ll m){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=m;\n        }\n        ap=ap*ap;\n        ap%=m;\n        k>>=1;\n    }\n    return ans;\n}\nint main()\n{\n    ll n; cin>>n;\n    vector<ll> fac;\n    ll n0=n;\n    for(ll i=2; i*i<=n0; i++){\n        if(n0%i==0){\n            int e=0;\n            while(n0%i==0){\n                n0/=i; e++;\n            }\n            if(e>1){\n                cout<<-1<<endl;\n                return 0;\n            }\n            fac.push_back(i);\n        }\n    }\n    if(n0>1) fac.push_back(n0);\n    if(fac.size()==1){\n        cout<<1<<endl;\n        return 0;\n    }\n    ll g=1;\n    for(auto p:fac){\n        g=lcm(g, p-1);\n    }\n    if(gcd(n, g)>1){\n        cout<<-1<<endl;\n        return 0;\n    }\n    vector<P> facd;\n    ll g0=g;\n    ll d=g;\n    for(ll i=2; i*i<=g0; i++){\n        if(g0%i==0){\n            while(g0%i==0){\n                g0/=i;\n            }\n            d/=i; d*=(i-1);\n        }\n    }\n    if(g0>1) d=d/g0*(g0-1);\n    ll d0=d;\n    for(ll i=2; i*i<=d0; i++){\n        if(d0%i==0){\n            int e=0;\n            while(d0%i==0){\n                d0/=i; e++;\n            }\n            facd.push_back(P(i, e));\n        }\n    }\n    if(d0>1) facd.push_back(P(d0, 1));\n    ll ans=d;\n    for(auto q:facd){\n        ll p=q.first; int e=q.second;\n        ll d1=d;\n        for(int i=1; i<=e; i++){\n            d1/=p;\n            if(powmod(n, d1, g)!=1) break;\n            ans/=p;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <random>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(12231817);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> random_distinct_integers(int l, int r, int k) {\n\tassert((r - l) >= k);\n\tset<int> s;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x = rand_rng(l, r);\n\t\twhile (s.find(x) != s.end()) x = rand_rng(l, r);\n\t\ts.insert(x);\n\t}\n\treturn vector<int>(s.begin(), s.end());\n}\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nstd::vector<unsigned long long> calc_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret; ret.push_back(1);\n\tfor (std::pair<unsigned long long, unsigned> w : res) {\n\t\tint s = ret.size();\n\t\tunsigned long long mul = 1;\n\t\tfor (int i = 0; i < w.second; i++) {\n\t\t\tmul *= w.first;\n\t\t\tfor (int j = 0; j < s; j++) ret.push_back(ret[j] * mul);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse {\n\t\tint e = totient_function(n);\n\t\tvector<unsigned long long> v1 = calc_divisors(totient_function(e));\n\t\tint w1 = -1;\n\t\tfor (int i : v1) {\n\t\t\tif (modpow(n, i, e) == 1) {\n\t\t\t\tw1 = i; break;\n\t\t\t}\n\t\t}\n\t\tvector<int> sample = random_distinct_integers(0, n, min(n, 100));\n\t\tvector<unsigned long long> v2 = calc_divisors(w1);\n\t\tint ret = -1;\n\t\tfor (int i : v2) {\n\t\t\tbool ok = true;\n\t\t\tint r = modpow(n, i, e);\n\t\t\tfor (int j : sample) {\n\t\t\t\tif (modpow(j, r, n) != j) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tret = i; break;\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\n\nll N;\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> N;\n}\n\nll euler_phi(ll n) {\n  ll ret = n;\n  for(ll i = 2; i * i <= n; i++) {\n    if(n % i == 0) {\n      ret -= ret / i;\n      while(n % i == 0) n /= i;\n    }\n  }\n  if(n > 1) ret -= ret / n;\n  return ret;\n}\n\n\ntemplate< typename T >\nT mod_pow(T x, T n, const T &p) {\n  T ret = 1LL;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= p;\n    (x *= x) %= p;\n    n >>= 1;\n  }\n  return ret;\n}\n\nmap< ll, ll > prime_factor(ll n) {\n  map< ll, ll > ret;\n  for(ll i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n\nll __gcd(ll a,ll b){\n    if(a>b) return __gcd(b,a);\n    if(a==0LL) return b;\n    if(a==1LL) return 1LL;\n    return __gcd(b%a,a);\n}\n\nll __lcm(ll a, ll b){\n    return a*b/__gcd(a,b);\n}\n\nll Carmichael(ll n){\n    auto pf = prime_factor(n);\n    // if(n==2LL) return n;\n    // if(pf.size()==1) {\n    //     for(auto p:pf) return (p.first-1LL);\n    //     }\n    if(pf.size()==1){\n      for(auto p:pf){\n        if(p.first==2LL){\n          if(p.second<=2) return p.second;\n          else return pow(2LL,(p.second-2LL));\n        }\n        else return (p.first-1LL)*pow(p.first,(p.second-1LL));\n      }\n    }\n    ll ret=1LL;\n    for(auto p:pf) {\n        // if(p.first==2LL) ret = __lcm(ret,2LL);\n        // else ret = __lcm(ret,(p.first-1LL));\n        ret = __lcm(ret,Carmichael(pow(p.first,p.second)));\n        }\n    return ret;\n}\n\nvector< ll > divisor(ll n) {\n  vector< ll > ret;\n  for(ll i = 2; i * i <= n; i++) {\n    if(n % i == 0) {\n      ret.push_back(i);\n      if(i * i != n) ret.push_back(n / i);\n    }\n  }\n  sort(begin(ret), end(ret));\n  return (ret);\n}\n\nint solve(){\n    auto pf = prime_factor(N);\n    // Nを素因数分解したとき、2乗以上される因子があるとき。\n    for(auto p:pf) if(p.second>1) {SAY(\"Nを素因数分解したとき、2乗以上される因子があるとき。\"); cout << \"-1\" << endl; return -1;}\n    // Nが素数の場合\n    if(pf.size()==1){SAY(\"Nが素数の場合\") cout << 1 << endl; return 1;}\n    // Nが偶数の場合\n    if(N%2==0) {SAY(\"Nが偶数の場合\") cout << \"-1\" << endl; return -1;}\n    vector<ll> car;\n    auto div = divisor(N);\n    DBG(div)\n    ll L=Carmichael(N);\n    // for(auto p:div) car.push_back(Carmichael(p));\n    // // for(auto p:pf) car.push_back(Carmichael(p.first));\n    // for(auto p:pf) car.push_back(p.first-1);\n    // // car.push_back(Carmichael(N));\n    // // car.push_back(__lcm();\n    // DBG(car)\n\n    // Nは偶数の場合：で除かれてる。。。はず。 \n    // for(auto c:car){\n    //     if(N%c==0){cout << \"-1\" << endl; return 0;}\n    // }\n    // set<ll> car;\n    // for(auto p:pf){\n    //     ll c=p.first-1;\n    //     car.insert(c);\n    //     }\n    vector<pll> modpows;\n    // for(auto p:pf) modpows.push_back({1LL,(p.first-1LL)});\n    map<ll,bool> used;\n    for(auto p:div) {\n      ll lamd = Carmichael(p);\n      if(used[lamd]) continue;\n      modpows.push_back({1LL,lamd});\n      used[lamd] = true;\n      }\n    if(!used[L]) modpows.push_back({1LL,L});\n    DBG(modpows)\n    vector<ll> klcms;\n    for(auto la:modpows){\n      if(__gcd(N,la.second)==1LL){\n        DBG(la.second)\n        klcms.push_back(Carmichael(la.second));\n      }\n    }\n    ll KLCM=1LL;\n    DBG(klcms)\n    for(auto lcm:klcms) KLCM = __lcm(KLCM,lcm);\n    ll k=KLCM;\n    DBG(KLCM)\n    // while(k*k < N)\n    // {\n    //     bool isOk=true;\n    //     for(auto &mps:modpows){\n    //         mps.first *= mod_pow(N,k,mps.second);\n    //         // mps.first %= mps.second;\n    //         if(mps.first!=1LL){\n    //             isOk=false;\n    //         }\n    //     }\n    //     DBG(modpows)\n    //     // for(auto c:car){\n    //     //     if(mod_pow(N%c,k,c)!=1){\n    //     //         isOk=false;\n    //     //         break;\n    //     //     }\n    //     // }\n    //     if(isOk){cout << k << endl; return k;}\n    //     k+=KLCM;\n    // }\n\n    for(ll k=1LL; k <= KLCM;k++)\n    {\n        bool isOk=true;\n        for(auto &mps:modpows){\n            mps.first *= N%mps.second;\n            mps.first %= mps.second;\n            if(mps.first!=1LL){\n                isOk=false;\n            }\n        }\n        DBG(modpows)\n        // for(auto c:car){\n        //     if(mod_pow(N%c,k,c)!=1){\n        //         isOk=false;\n        //         break;\n        //     }\n        // }\n        if(isOk){cout << k << endl; return k;}\n    }\n\n    SAY(\"その他.うまいkが見つからなかった\")\n    cout << \"-1\" << endl;\n    return -1;\n}   \n\n// x^(n^k) mod m\nll mod_pow_induc(ll x, ll n, ll m, ll k){\n  if(k==-1LL) return 1LL;\n  if(k==0LL) return mod_pow(x,1LL,m);\n  if(k==1LL) return mod_pow(x,n,m);\n  else return mod_pow_induc(mod_pow(x,n,m),n,m,k-1);\n}\n\nvoid sample(ll N, ll ans){\n  // ll po=pow(N,ans)\n  // llだと桁が足りない。\n  if(ans==-1) return;\n    for (ll i = 1; i < min(N/ans,(ll)100); i++)\n    {\n      // iとNが互いに素\n      // ll po;\n      // ll m=__gcd(N,i);\n      // po = mod_pow(N,ans,Carmichael(N/m));\n      // DBG(po)\n      // 微妙に違う・・・\n      // else po=mod_pow(N,ans,Carmichael(i));\n      // cout << mod_pow(i,po,N) << endl;\n      cout << mod_pow_induc(i,N,N,ans) << endl;\n    }\n    \n}\n\nint main()\n{\n    input();\n    // N=1234567;\n    ll ans = solve();\n    // sample(N, ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n/**\n * For every prime factor p, perform result[p] += e. (where n = \\prod p^e)\n * Verified by: Codeforces #400 E\n *              (http://codeforces.com/contest/776/submission/24956471)\n */\nvoid factorize(long long v, std::map<long long, int> &result) {\n  long long p = 2;\n  while (v > 1 && p * p <= v) {\n    int cnt = 0;\n    while (v % p == 0) {\n      cnt++;\n      v /= p;\n    }\n    if (cnt > 0) {\n      if (result.count(p) == 0) {\n\tresult[p] = 0;\n      }\n      result[p] += cnt;\n    }\n    p += p == 2 ? 1 : 2;\n  }\n  if (v > 1) {\n    if (result.count(v) == 0) {\n      result[v] = 0;\n    }\n    result[v] += 1;\n  }\n}\n\nll gcd(ll x,ll y){\n  while(y!=0){\n    ll r=x%y;\n    x=y;y=r;\n  }\n  return x;\n}\n\n// Find x s.t. n^x mod mod = 1, or -1 if there's no such x\nll calc(ll n, ll mod) {\n  n %= mod;\n  ll v = 1;\n  REP(i, 0, mod) {\n    v = v * n % mod;\n    if (v == 1) {\n      return i + 1;\n    }\n  }\n  return -1;\n}\n\nint main(void){\n  ll n;\n  cin >> n;\n  map<ll, int> factor;\n  factorize(n, factor);\n  ll res = 1;\n  for (map<ll, int>::iterator it = factor.begin(); it != factor.end(); ++it) {\n    ll p = it->first;\n    int e = it->second;\n    ll v = p - 1;\n    REP(i, 0, e - 1) {\n      v *= p;\n    }\n    ll c = calc(n, v);\n    if (c == -1) {\n      res = -1;\n      break;\n    }\n    res = c / gcd(c, res) * res;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){\n  return x/__gcd(x,y)*y;\n}\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\n\nint euler_phi(int n){\n  int res=n;\n  for(int i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      for(;n%i==0;n/=i);\n    }\n  }\n  if(n!=1) res=res/n*(n-1);\n  return res;\n}\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans=lcm(ans,p.first-1);\n  }\n  if(__gcd(b,ans)!=1LL){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int phi=euler_phi(ans);\n  //cout<<phi<<endl;\n  int tmp=phi;\n  for(int i=2;i*i<=phi;i++){\n    if(phi%i) continue;\n    if(mod_pow(b,i,ans)==1) tmp=min(tmp,i);\n    if(mod_pow(b,phi/i,ans)==1) tmp=min(tmp,phi/i);\n  }\n  cout<<tmp<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n;++i)\nusing namespace std;\nusing ll = long long;\n\nll phi(ll n){\n\tll ret = n;\n\tfor(ll p = 2; p*p <=n;++p){\n\t\tif(n%p==0){\n\t\t\tret /=p,ret *= (p-1);\n\t\t\twhile(n%p==0) n/=p;\n\t\t}\n\t}\n\n\tif(n!=1) ret /=n,ret *= (n-1);\n\treturn ret;\n}\n\nauto factor(ll n){\n\tmap<ll,int> ret;\n\n\tfor(ll p = 2; p*p <=n;++p){\n\t\tif(n%p==0){\n\t\t\tint idx = 0;\n\t\t\twhile(n%p==0) n/=p,idx++;\n\t\t\tret[p]=idx;\n\t\t}\n\t}\t\n\n\tif(n!=1) ret[n]=1;\n\treturn ret;\n}\n\nint main(void){\n\tll n;\n\tcin >> n;\n\n\tll rv = phi(n) + 1LL;\n\n\tauto nf = factor(n);\n\tauto rvf = factor(rv);\n\n\tint ans = 0;\n\tfor(auto elem:rvf){\n\t\tif(ans != -1 and nf.find(elem.first) != end(nf)){\n\t\t\tconst int k = (elem.second + nf[elem.first] - 1) /  nf[elem.first];\n\t\t\tans = max(ans,k);\n\t\t}else{\n\t\t\tans = -1;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n\n    if(cnt>1e6){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n\n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n  \n  ans=lcm(ans, euler(n) );\n\n  if( n%ans== 0){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e7){\n      cnt=euler(ans);\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n\n    if(cnt>1e8){\n      cnt=euler(b);\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n\n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n  \n  ans=lcm(ans, euler(n) );\n\n  if( n%ans== 0 || __gcd(n,ans) !=1){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e9){\n      cnt=euler(ans)/3;\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n\n  /*\n  ll C=1;\n  for(ll i=0;i<n;i++){\n    ll k=solve( i , n );\n    C=lcm(k,C);\n  }\n  */\n  //  cout<<C<<' '<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint lcm(int x, int y){\n    return x/__gcd(x,y)*y;\n}\n\n// カーマイケルのλ関数\n// nと互いに素なaに対して a^{λ(n)} == 1 (mod n) が成り立つ最小の整数を返す\n// (オイラーのφ関数の精密化)\nint carmichael_lambda(int n){\n    int ret = 1;\n    if(n%8==0) n /= 2;\n    for(int i=2; i<=n; ++i){\n        if(n%i!=0) continue;\n        int sub = i-1;\n        n /= i;\n        while(n%i==0){\n            n /= i;\n            sub *= i;\n        }\n        ret = lcm(ret, sub);\n    }\n    return ret;\n}\n\nmap<int,int> factorize(int n){\n    map<int,int> ret;\n    for(int i=2; i*i<=n; ++i){\n        while(n%i==0){\n            n/=i;\n            ++ret[i];\n        }\n    }\n    if(n>1) ++ret[n];\n    return ret;\n}\n\nint main(){\n    int n;\n    cin >>n;\n\n    map<int,int> f = factorize(n);\n\n    int L = 1;\n    for(const auto &p:f){\n        if(p.se>1){\n            cout << -1 << endl;\n            return 0;\n        }\n        L = lcm(L, p.fi-1);\n    }\n\n    int ans;\n    if(__gcd(n,L)!=1) ans = -1;\n    else ans = carmichael_lambda(L);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint carmichaelLambda(int n){\n  int res = 1;\n  if(n % 8 == 0) n/=2;\n  auto lcm = [](int a,int b){return (a/__gcd(a,b)) * b;};\n\n  auto compute = [&](int i){\n    int sub = i - 1;\n    n/=i;\n    while(n%i == 0) n/=i, sub *=i;\n    res = lcm(res,sub);\n  };\n\n  for(int i=2;i*i<=n;i++) if( n % i == 0) compute(i);\n  if(n != 1) compute(n);\n  return res;\n}\n\nsigned main(){\n  cin>>n;\n  int car = carmichaelLambda(n);\n  int car2 = carmichaelLambda(car);\n  int ans = car2;\n  if(mod_pow(n,1,car)==1) ans = 1;\n  \n  for(int i=1;i*i<=car2;i++){\n    if(mod_pow(n,car2/i,car) == 1) Min(ans,car2/i);\n    if(mod_pow(n,i,car) == 1) Min(ans,i);\n  }\n  \n  if(car != 1 && mod_pow(n,car2,car) !=  1)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\nusing ll = long long int;\n\nll gcd(ll N, ll M) {\n    if(M == 0) return N;\n    return gcd(M, N%M);\n}\n\nll lcm(ll N, ll M) {\n    return N / gcd(N, M) * M;\n}\n\nll get_prod(ll N) {\n    ll res = 1;\n    for(int k=2; k*k<=N; k++) {\n        int cnt = 0;\n        while(N % k == 0) {\n            cnt++; N /= k;\n        }\n        if(cnt > 1) return -1;\n        else if(cnt == 1) res = lcm(res, k - 1);\n    }\n    if(N > 1) res = lcm(res, N - 1);\n    return res;\n}\n\n// オイラーの φ 関数 (n 以下の自然数のうち n と互いに素なものの個数)\n// \\phi(n) = n \\times \\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) を使おう\n// (ただし、 p_i は n の素因数)\n// Complexity: O(sqrt n)\n// Vefiried: AOJ NTL_1_D: Euler's Phi Function\n\nll Euler_phi(ll n) {\n    ll ret = n;\n    for(int i=2; i*i <= n; i++) {\n        if(n % i == 0) {\n            ret -= ret / i;\n            while(n % i == 0) n /= i;\n        }\n    }\n    if(n != 1) ret -= ret / n;\n    return ret;\n}\n\nll mod_pow(ll N, ll K, ll mod) {\n    ll res = 1;\n    for(; K>0; K>>=1) {\n        if(K & 1) (res *= N) %= mod;\n        (N *= N) %= mod;\n    }\n    return res;\n}\n\nint main() {\n    ll N; cin >> N;\n    ll prod = get_prod(N);\n    if(prod < 0 or gcd(N, prod) > 1) {\n        cout << -1 << endl;\n    }\n    else {\n        ll euler = Euler_phi(prod);\n\n        ll ans = euler;\n        for(ll k=1; k*k<=euler; k++) {\n            if(mod_pow(N, k, prod) == 1) {\n                ans = min(ans, k);\n            }\n            if(mod_pow(N, euler/k, prod) == 1) {\n                ans = min(ans, euler/k);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n/**\n * For every prime factor p, perform result[p] += e. (where n = \\prod p^e)\n * Verified by: Codeforces #400 E\n *              (http://codeforces.com/contest/776/submission/24956471)\n */\nvoid factorize(long long v, std::map<long long, int> &result) {\n  long long p = 2;\n  while (v > 1 && p * p <= v) {\n    int cnt = 0;\n    while (v % p == 0) {\n      cnt++;\n      v /= p;\n    }\n    if (cnt > 0) {\n      if (result.count(p) == 0) {\n\tresult[p] = 0;\n      }\n      result[p] += cnt;\n    }\n    p += p == 2 ? 1 : 2;\n  }\n  if (v > 1) {\n    if (result.count(v) == 0) {\n      result[v] = 0;\n    }\n    result[v] += 1;\n  }\n}\n\nll gcd(ll x,ll y){\n  while(y!=0){\n    ll r=x%y;\n    x=y;y=r;\n  }\n  return x;\n}\n\n// Find x s.t. n^x mod mod = 1, or -1 if there's no such x\nll calc(ll n, ll mod) {\n  n %= mod;\n  ll v = 1;\n  REP(i, 0, mod) {\n    v = v * n % mod;\n    if (v == 1 % mod) {\n      return i + 1;\n    }\n  }\n  return -1;\n}\n\nint main(void){\n  ll n;\n  cin >> n;\n  map<ll, int> factor;\n  factorize(n, factor);\n  ll res = 1;\n  for (map<ll, int>::iterator it = factor.begin(); it != factor.end(); ++it) {\n    ll p = it->first;\n    int e = it->second;\n    ll v = p - 1;\n    REP(i, 0, e - 1) {\n      v *= p;\n    }\n    ll c = calc(n, v);\n    if (c == -1) {\n      res = -1;\n      break;\n    }\n    res = c / gcd(c, res) * res;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\n\nll gcd(ll a, ll b) {\n    return b == 0 ? a : gcd(b, a%b);\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nll mod_pow(ll a, ll n, ll m) {\n    ll res = 1;\n    while (n > 0) {\n        if (n % 2 == 1) (res *= a) %= m;\n        (a *= a) %= m;\n        n /= 2;\n    }\n    return res;\n}\n\nmap<int, int> factorize(int x) {\n    map<int, int> res;\n    for (int d = 2; d * d <= x; ++d) {\n        int count = 0;\n        while (x % d == 0) {\n            ++count;\n            x /= d;\n        }\n        if (count > 0) res[d] = count;\n    }\n    if (x > 1) res[x] = 1;\n    return res;\n}\n\nint euler_totient(int x) {\n    int res = x;\n    for (int y = 2; y * y <= x; ++y) {\n        if (x % y == 0) {\n            res -= x / y;\n            while (x % y == 0) x /= y;\n        }\n    }\n    if (x > 1) res -= res / x;\n    return res;\n}\n\nint N;\n\nint main(void) {\n    cin >> N;\n\n    auto n_factors = factorize(N);\n    ll L = 1;\n    for (const auto itr : n_factors) {\n        if (itr.second > 1) {\n            cout << -1 << endl;\n            exit(0);\n        }\n        L = lcm(L, itr.first - 1);\n    }\n\n    if (gcd(N, L) > 1) {\n        cout << -1 << endl;\n        exit(0);\n    }\n\n    const int el = euler_totient(L);\n    int ans = el;\n    for (int x = 1; x * x <= el; ++x) {\n        if (el % x == 0) {\n            if (mod_pow(N, x, L) == 1)\n                ans = min(ans, x);\n            if (mod_pow(N, el / x, L) == 1)\n                ans = min(ans, el / x);\n        }\n    }\n\n    cout << ans << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n\n    if(cnt>1e8){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n\n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n  \n  ans=lcm(ans, euler(n) );\n\n  if( n%ans== 0 || __gcd(n,ans) !=1){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e9){\n      cnt=euler(ans)/3;\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n\n  /*\n  ll C=1;\n  for(ll i=0;i<n;i++){\n    ll k=solve( i , n );\n    C=lcm(k,C);\n  }\n  */\n  //  cout<<C<<' '<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){\n  return x/__gcd(x,y)*y;\n}\nint mpow(int n,int x){\n  int res=1LL;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.first-1));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int x=-1,y;\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans=lcm(ans,p.first-1);\n    //cout<<ans<<endl;\n    if(x<0) x=p.first;\n    else y=p.first;\n  }\n  if(__gcd(x+y-1,(x-1)*(y-1))!=1LL){\n    cout<<-1<<endl;\n    return 0;\n  }\n  //cout<<x<<\" \"<<y<<endl;\n  //cout<<x+y-1<<\" \"<<(x-1)*(y-1)<<endl;\n  int k=ker(ans);\n  //cout<<k<<\" \"<<ans<<endl;\n  int tmp=k;\n  for(int i=2;i*i<=k;i++){\n    if(k%i) continue;\n    //cout<<i<<\" \"<<mod_pow(x,mod_pow(b,i,ans),b)<<endl;\n    //cout<<k/i<<\" \"<<mod_pow(x,mod_pow(b,k/i,ans),b)<<endl;\n    if(mod_pow(b,i,ans)==1) tmp=min(tmp,i);\n    if(mod_pow(b,k/i,ans)==1) tmp=min(tmp,k/i);\n  }\n  cout<<tmp<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint lcm(int a,int b){return (a/__gcd(a,b)) * b;}\nint carmichealLambda(int n){\n  int res = 1;\n  if(n % 8 == 0) n/=2;\n\n  auto compute = [&](int i){\n    int sub = i - 1;\n    n/=i;\n    while(n%i == 0) n/=i, sub *=i;\n    res = lcm(res,sub);\n  };\n\n  for(int i=2;i*i<=n;i++) if( n % i == 0) compute(i);\n  if(n != 1) compute(n);\n  return res;\n}\n\nsigned main(){\n  cin>>n;\n  int car = carmichealLambda(n);\n  int car2 = carmichealLambda(car);\n  int ans = car2;\n  if(mod_pow(n,1,car)==1) ans = 1;\n  \n  for(int i=1;i*i<=car2;i++){\n    if(mod_pow(n,car2/i,car) == 1) Min(ans,car2/i);\n    if(mod_pow(n,i,car) == 1) Min(ans,i);\n  }\n  \n  if(mod_pow(n,car2,car) !=  1)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=1;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==1){\n      break;\n    }\n\n    if(cnt>1e6){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n\n  ans=lcm(ans, euler(n) );\n\n  if( n%ans== 0){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e7){\n      cnt=euler(ans);\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n// O(sqrt(N))\nint64_t euler_phi(int64_t n) {\n    int64_t ret = n;\n    for (int64_t i = 2; i * i <= n; ++i) {\n        if (n % i != 0) continue;\n        ret -= ret / i;\n        while (n % i == 0) n /= i;\n    }\n    if (n > 1) ret -= ret / n;\n    return ret;\n}\n\nint64_t powmod(int64_t a, int64_t n, int64_t mod) {\n    int64_t ret = 1, tmp = a;\n    while (n) {\n        if (n & 1) (ret *= tmp) %= mod;\n        (tmp *= tmp) %= mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\n\nint64_t __lcm(int64_t a, int64_t b) {\n    return a / __gcd(a, b) * b;\n}\n\n// O(sqrt(n))\nmap<int64_t, int> prime_factorize(int64_t n) {\n    map<int64_t, int> ret;\n    for (int64_t i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            ret[i]++;\n            n /= i;\n        }\n    }\n    if (n != 1) ret[n] = 1;\n    return ret;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    LL n; cin >> n;\n\n    auto fact = prime_factorize(n);\n\n    if (fact.size() == 1 and fact.begin()->second == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    vector<int> primes;\n    for (const auto& tp : fact) {\n        if (tp.second > 1) {\n            cout << -1 << endl;\n            return 0;\n        }\n        primes.push_back(tp.first);\n    }\n\n    LL lcm = 1;\n    for (LL p : primes) {\n        lcm = __lcm(lcm, p-1);\n    }\n\n    if (__gcd(n, lcm) != 1) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    LL phi = euler_phi(lcm);\n\n    LL ans = numeric_limits<LL>::max();\n    for (LL i = 1; i * i <= phi; ++i) {\n        if (phi % i != 0) continue;\n        if (powmod(n, i, lcm) == 1) chmin(ans, i);\n        if (powmod(n, phi / i, lcm) == 1) chmin(ans, phi / i);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){return x/__gcd(x,y)*y;}\nint mpow(int n,int x){\n  int res=1;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    //cout<<res<<endl;\n    //cout<<p.first<<\" \"<<p.second<<endl;\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.second-1));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  if(m.count(2)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n  }\n  cout<<ker(ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\nll modpow(ll x, ll n, ll M) {\n    ll res = 1;\n    while(n > 0) {\n        if(n & 1) {\n            res *= x;\n            res %= M;\n        }\n        x *= x;\n        x %= M;\n        n >>= 1;\n    }\n    return res;\n}\n\nll euler(ll x) {\n    ll res = x;\n    ll t = x;\n    for(ll i=2; i*i<=x; ++i) {\n        if(t % i == 0) {\n            res = res / i * (i - 1);\n        }\n        while(t % i == 0) {\n            t /= i;\n        }\n    }\n    if(t > 1) {\n        res = res / t * (t - 1);\n    }\n    return res;\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    if(N == 2) {\n        cout << 1 << endl;\n        return 0;\n    }\n    ll L = 1;\n    ll T = N;\n    for(ll i=2; i*i<=N; ++i) {\n        if(N % (i*i) == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n        if(T % i == 0) {\n            L = (L / __gcd(L, i-1) * (i-1));\n            T /= i;\n        }\n    }\n    if(T > 1) {\n        L = L / __gcd(L, T-1) * (T-1);\n    }\n    if(__gcd(N, L) != 1) {\n        cout << -1 << endl;\n        return 0;\n    }\n    ll phi = euler(L);\n    vector<ll> cand;\n    for(int i=1; i*i<=phi; ++i) {\n        if(phi % i == 0) {\n            cand.push_back(i);\n            cand.push_back(phi/i);\n        }\n    }\n    sort(cand.begin(), cand.end());\n    cand.erase(unique(cand.begin(), cand.end()), cand.end());\n    for(int i=0; i<cand.size(); ++i) {\n        if(modpow(N, cand[i], L) == 1) {\n            cout << cand[i] << endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){\n  return x/__gcd(x,y)*y;\n}\nint mpow(int n,int x){\n  int res=1LL;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.first-1));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int x=-1,y;\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n    //cout<<ans<<endl;\n    if(x<0) x=p.first;\n    else y=p.first;\n  }\n  if(__gcd(x+y-1,(x-1)*(y-1))!=1LL){\n    cout<<-1<<endl;\n    return 0;\n  }\n  //cout<<x<<\" \"<<y<<endl;\n  //cout<<x+y-1<<\" \"<<(x-1)*(y-1)<<endl;\n  int k=ker(ans);\n  //cout<<k<<endl;\n  int tmp=k;\n  for(int i=2;i*i<=k;i++){\n    if(k%i) continue;\n    //cout<<i<<\" \"<<mod_pow(x,mod_pow(b,i,ans),b)<<endl;\n    //cout<<k/i<<\" \"<<mod_pow(x,mod_pow(b,k/i,ans),b)<<endl;\n    if(mod_pow(x,mod_pow(b,i,ans),b)==x&&\n       mod_pow(y,mod_pow(b,i,ans),b)==y&&\n       mod_pow(x+1,mod_pow(b,i,ans),b)==x+1&&\n       mod_pow(y-1,mod_pow(b,i,ans),b)==y-1) tmp=min(tmp,i);\n    if(mod_pow(x,mod_pow(b,k/i,ans),b)==x&&\n       mod_pow(y,mod_pow(b,k/i,ans),b)==y&&\n       mod_pow(x+1,mod_pow(b,k/i,ans),b)==x+1&&\n       mod_pow(y-1,mod_pow(b,k/i,ans),b)==y-1) tmp=min(tmp,k/i);\n  }\n  cout<<tmp<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nint main(){\n  ll n;\n  cin>>n;\n  ll v=euler(n);\n\n  if( __gcd(n,v) != 1 ){\n    cout<<-1<<endl;\n  }else{\n    ll ans=1;\n    ll p=n%v;\n    while(p!=1){\n      p=(p*n)%v;\n      ans++;\n      if(ans>1e7){\n        ans=-1;\n        break;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <random>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(12231817);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> random_distinct_integers(int l, int r, int k) {\n\tassert((r - l) >= k);\n\tset<int> s;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x = rand_rng(l, r);\n\t\twhile (s.find(x) != s.end()) x = rand_rng(l, r);\n\t\ts.insert(x);\n\t}\n\treturn vector<int>(s.begin(), s.end());\n}\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse {\n\t\tint max_search_size = 2;\n\t\tif (n <= 1000) max_search_size = 5;\n\t\tvector<int> v = random_distinct_integers(0, n, min(n, max_search_size));\n\t\tvector<int> a(v.size());\n\t\tfor (int i = 0; i < v.size(); i++) a[i] = modpow(v[i], n, n);\n\t\tfor (int i = 1; ; i++) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\t\tif (a[j] != v[j]) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tcout << i << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int j = 0; j < v.size(); j++) a[j] = modpow(a[j], n, n);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\n\nll inv( ll a , ll mod ){\n  ll x, y;\n  if( extgcd( a , mod , x , y ) != 1 ){\n    throw 0;\n  }\n  x %= mod;\n  if( x < 0 ){\n    x += mod;\n  }\n  return x;\n}\n\nll modlog( ll n , ll mod ){\n  ll q = 1;\n  while( q * q < mod ){\n    q++;\n  }\n  n %= mod;\n  map<ll,ll> ma;\n  ll nq = 1;\n  ma[1] = 0;\n  REP( i , q ){\n    nq = ( nq * n ) % mod;\n    if( nq == 1 ){\n      return i + 1;\n    }\n    ll a = ( inv( nq , mod ) ) % mod;\n    if( ma.find( a ) == ma.end() ){\n      ma[a] = i + 1;\n    }\n  }\n  ll cur = 1;\n  REP( i , q ){\n    cur = ( cur * nq ) % mod;\n    if( ma.find( cur ) != ma.end() ){\n      return ( i + 1 ) * q + ma[cur];\n    }\n  }\n  assert( false );\n}\n\nvl fact( ll x ){\n  vl res;\n  for( ll i = 2; i*i <= x; i++ ){\n    while( x % i == 0 ){\n      res.pb( i );\n      x /= i;\n    }\n  }\n  if( x > 1 ) res.pb( x );\n  return res;\n}\n\nll f( ll a , ll b , ll mo ){\n  // a k = b mod mo\n  // a k + mo l = b\n  ll g = __gcd( a , mo );\n  if( b % g != 0 ){\n    return -1;\n  }\n  a /= g;\n  b /= g;\n  mo /= g;\n  // cout << \"* \" << a << \" \" << mo << endl;\n  ll k, l;\n  extgcd( a , mo , k , l );\n  // cout << \"* \" << k << \" \" << l << endl;\n  k *= b;\n  l *= b;\n  k = ( ( k % mo ) + mo ) % mo;\n  return k;\n}\n\nll n;\n\n\nint main(){\n  \n  n = in();\n\n  vl v = fact( n );\n  SORT( v );\n  REP( i , SZ(v) - 1 ){\n    if( v[i] == v[i+1] ){\n      puts( \"-1\" );\n      return 0;\n    }\n  }\n  \n  ll x = 1;\n  ll y = 0;\n  ll ans = 1;\n  REP( i , SZ(v) ){\n    ll mod = v[i] - 1;\n    if( mod == 2 ){\n      cout << \"-1\" << endl;\n      return 0;\n    }\n    try{\n      ll res = modlog( n , mod );\n      if( res == -1 ){\n        puts( \"-1\" );\n        return 0;\n      }\n      ll r = f( x , ( ( res - y ) % mod + mod ) % mod, mod );\n      /*\n      SHOW( x );\n      SHOW( y );\n      SHOW( res );\n      SHOW( mod );\n      cout << res << \" \" << mod << \" \" << r << endl;\n      */\n      ll nx = x * mod;\n      ll ny = x * r + y;\n      x = nx;\n      y = ny;\n      // cout << x << \" \" << y << endl;\n    } catch (...){\n      puts( \"-1\" );\n      return 0;\n    }\n  }\n  \n  cout << y << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\nll gcd(ll a,ll b){\n  while(b!=0){\n    a%=b;\n    swap(a,b);\n  }\n  return a;\n}\n\n//BEGIN CUT HERE\n\ntemplate<typename T>\nT extgcd(T a,T b,T &x,T &y){\n  T d=a;\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }else{\n    x=1;\n    y=0;\n  }\n  return d;\n}\n\ntemplate<typename T>\nT mod_inverse(T a,T mod){\n  T x,y;\n  extgcd(a,mod,x,y);\n  return (mod+x%mod)%mod;\n}\n\ntemplate<typename T>\npair<T, T> linear_congruence(const vector<T> &A,\n                             const vector<T> &B,\n                             const vector<T> &M){\n  T x=0,m=1;\n  for(int i=0;i<(int)A.size();i++){\n    T a=A[i]*m,b=B[i]-A[i]*x,d=__gcd(M[i],a);\n    if(b%d!=0) return make_pair(0,-1);\n    T t=b/d*mod_inverse(a/d,M[i]/d)%(M[i]/d);\n    x=x+m*t;\n    m*=M[i]/d;\n  }\n  return make_pair((x%m+m)%m,m);\n}\n//END CUT HERE\n\n//BEGIN CUT HERE\ntemplate<typename T>\nT totient(T n){\n  T res=n;\n  for(T i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      for(;n%i==0;n/=i);\n    }\n  }\n  if(n!=1) res=res/n*(n-1);\n  return res;\n}\n//END CUT HERE\n\nll mod_pow(ll a,ll x,ll mod){\n  ll ret=1;\n  a%=mod;\n  while(x>0){\n    if(x&1){\n      (ret*=a)%=mod;\n    }\n    (a*=a)%=mod;\n    x>>=1;\n  }\n  return ret;\n}\n\nint main(){\n  ll N,tmp;\n  cin>>N;\n  tmp=N;\n  vector<ll> P;\n  for(ll i=2;i*i<=tmp;i++){\n    while(tmp%i==0){\n      if(!P.empty() && P.back()==i){\n        cout<<-1<<endl;\n        return 0;\n      }\n      P.push_back(i);\n      tmp/=i;\n    }\n  }\n  if(tmp!=1){P.push_back(tmp);}\n  vector<ll> A,B,M;\n  ll ans=1;\n  for(auto &I:P){\n    if(I-1==1){continue;}\n    if(gcd(N,I-1)!=1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ll phi=totient(I-1);\n    ll mi=phi;\n    if(mod_pow(N,phi,I-1)!=1){\n      cerr<<N<<\" \"<<phi<<\" \"<<I-1<<\" \"<<mod_pow(N,phi,I-1)<<endl;\n    }\n    assert(mod_pow(N,phi,I-1)==1);\n    for(ll i=1;i*i<=phi;i++){\n      if(phi%i==0){\n        if(mod_pow(N,i,I-1)==1){mi=min(mi,i);}\n        if(mod_pow(N,phi/i,I-1)==1){mi=min(mi,phi/i);}\n      }\n    }\n    ans=ans/gcd(ans,mi)*mi;\n  }\n  cout<<ans<<endl;\n  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\nusing ld = long double;\nusing ll = long long;\nusing ull = unsigned long long;\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename T>\nconstexpr T MOD = static_cast<T>(1000000007);\ntemplate <typename F>\nconstexpr F PI() { return 3.1415926535897932385; }\n#define SHOW(...) (std::cerr << \"(\" << #__VA_ARGS__ << \") = (\"), HogeHogeSansuu(__VA_ARGS__), std::cerr << \")\" << std::endl;\nstruct has_debugPrint_impl\n{\n    template <class T>\n    static auto check(T&& x) -> decltype(x.debugPrint(), std::true_type{});\n    template <class T>\n    static auto check(...) -> std::false_type;\n};\ntemplate <class T>\nclass has_debugPrint : public decltype(has_debugPrint_impl::check<T>(std::declval<T>()))\n{\n};\ntemplate <bool>\nstruct HogeHogeDump\n{\n    template <typename T>\n    static void dump(const T& x) { x.debugPrint(); }\n};\ntemplate <>\nstruct HogeHogeDump<false>\n{\n    template <typename T>\n    static void dump(const T& x) { std::cerr << x; }\n};\nvoid HogeHogeSansuu() { ; }\ntemplate <typename T>\nvoid HogeHogeSansuu(const T& x) { HogeHogeDump<has_debugPrint<T>::value>::dump(x); }\ntemplate <typename T, typename... Args>\nvoid HogeHogeSansuu(const T& x, Args... args) { HogeHogeDump<has_debugPrint<T>::value>::dump(x), std::cerr << \",\", HogeHogeSansuu(args...); }\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return a = std::min(a, b), a == b; }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return a = std::max(a, b), a == b; }\ntemplate <typename T, typename F>\nvoid For(const T s, const T t, const F f)\n{\n    for (T i = s; i != t; i += T(s < t ? 1 : -1)) { f(i); }\n}\ntemplate <typename T, typename F>\nvoid Rep(const T N, const F f) { For<T, F>(0, N, f); }\ntemplate <typename T, typename F>\nvoid RRep(const T N, const F f) { For<T, F>(N - 1, -1, f); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T PopCount(T v) { return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f); }\ntemplate <typename T>\nconstexpr T log2p1(T v) { return v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), PopCount(v); }\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return (v << 1) == (T(1) << (log2p1(v))); }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return ispow2(v) ? v : T(1) << log2p1(v); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : ispow2(v) ? v : T(1) << (log2p1(v) - 1); }\ntemplate <typename T>\nstruct Accum\n{\n    template <typename InIt>\n    Accum(const InIt first, const InIt last) : accum(std::size_t(std::distance(first, last))) { std::partial_sum(first, last, accum.begin()); }\n    T sum(const std::size_t i) const { return i == 0 ? T(0) : accum[i - 1]; }\n    T sum(const std::size_t l, const std::size_t r) const { return sum(r) - sum(l); }\n    std::vector<T> accum;\n};\ntemplate <typename T>\nstruct Accum2D\n{\n    Accum2D(const std::vector<std::vector<T>>& t) : accum{t}\n    {\n        for (std::size_t i = 0; i < accum.size(); i++) {\n            for (std::size_t j = 1; j < accum[i].size(); j++) { accum[i][j] += accum[i][j - 1]; }\n        }\n        for (std::size_t i = 1; i < accum.size(); i++) {\n            for (std::size_t j = 0; j < accum[i].size(); j++) { accum[i][j] += accum[i - 1][j]; }\n        }\n    }\n    T sum(const std::size_t y, const std::size_t x) const { return y == 0 or x == 0 ? T(0) : accum[y - 1][x - 1]; }\n    T sum(const std::size_t ymin, const std::size_t ysup, const std::size_t xmin, const std::size_t xsup) const { return sum(ysup, xsup) - sum(ymin, xmin); }\n    std::vector<std::vector<T>> accum;\n};\ntemplate <typename T>\nstruct Zip\n{\n    template <typename InIt>\n    Zip(const InIt first, const InIt last) : unzip(std::size_t(std::distance(first, last)))\n    {\n        std::copy(first, last, unzip), std::sort(unzip.begin(), unzip.end()), unzip.erase(std::unique(unzip.begin(), unzip.end()), unzip.end());\n        for (std::size_t i = 0; i < unzip.size(); i++) { zip[unzip[i]] = i; }\n    }\n    std::vector<T> unzip;\n    std::map<T, std::size_t> zip;\n};\ntemplate <typename T, std::size_t N>\nstd::ostream& operator<<(std::ostream& os, const std::array<T, N>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::deque<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::multimap<K, T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::multiset<T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::map<K, T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T1, T2>& v) { return (os << \"<\" << v.first << \",\" << v.second << \">\"); }\ntemplate <typename T1, typename T2, typename T3>\nstd::ostream& operator<<(std::ostream& os, const std::priority_queue<T1, T2, T3>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.top() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::queue<T1>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.front() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::set<T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::stack<T1>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.top() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename K, typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_multimap<K, T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_multiset<T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_map<K, T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_set<T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\n//!====================================================================================================!//\n//!   888888ba           oo                         88888888b                   dP                     !//\n//!   88    '8b                                     88                          88                     !//\n//!  a88aaaa8P' 88d888b. dP 88d8b.d8b. .d8888b.    a88aaaa  d8888b. .d8888b. d8888P .d8888b. 88d888b.  !//\n//!   88        88'  '88 88 88''88''88 88ooood8     88     88'  '88 88'  '\"\"   88   88'  '88 88'  '88  !//\n//!   88        88       88 88  88  88 88.  ...     88     88.  .88 88.  ...   88   88.  .88 88        !//\n//!   dP        dP       dP dP  dP  dP '88888P'     dP     '88888P8 '88888P'   dP   '88888P' dP        !//\n//!====================================================================================================!//\ntemplate <typename T>\nstd::vector<std::pair<T, std::size_t>> PrimeFactors(T n)\n{\n    std::vector<std::pair<T, std::size_t>> ans;\n    for (T i = 2; i * i <= n; i++) {\n        std::size_t cnt = 0;\n        for (; n % i == 0; n /= i, cnt++) {}\n        if (cnt > 0) { ans.push_back({i, cnt}); }\n    }\n    if (n > 1) { ans.push_back({n, 1}); }\n    return ans;\n}\n//!================================================================!//\n//!  888888ba  oo          oo                                      !//\n//!  88    '8b                                                     !//\n//!  88     88 dP dP   .dP dP .d8888b. .d8888b. 88d888b. .d8888b.  !//\n//!  88     88 88 88   d8' 88 Y8ooooo. 88'  '88 88'  '88 Y8ooooo.  !//\n//!  88    .8P 88 88 .88'  88       88 88.  .88 88             88  !//\n//!  8888888P  dP 8888P'   dP '88888P' '88888P' dP       '88888P'  !//\n//!================================================================!//\ntemplate <typename T>\nstd::vector<T> Divisors(const T n)\n{\n    std::vector<T> head, tail;\n    for (T i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            head.push_back(i);\n            if (i * i != n) { tail.push_back(n / i); }\n        }\n    }\n    for (auto it = tail.rbegin(); it != tail.rend(); it++) { head.push_back(*it); }\n    return head;\n}\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!===============================================================!//\n//!  888888ba  8888ba.88ba                 dP dP            dP    !//\n//!  88    '8b 88  '8b  '8b                88 88            88    !//\n//!  88     88 88   88   88 .d8888b. .d888b88 88 88d888b. d8888P  !//\n//!  88     88 88   88   88 88'  '88 88'  '88 88 88'  '88   88    !//\n//!  88    .8P 88   88   88 88.  .88 88.  .88 88 88    88   88    !//\n//!  8888888P  dP   dP   dP '88888P' '88888P8 dP dP    dP   dP    !//\n//!===============================================================!//\ntemplate <typename T>\nclass DModInt\n{\nprivate:\n    T value;\n\npublic:\n    const T mod;  // 正の数を渡すこと！(割り算を使う場合は素数)\n    DModInt(const T val, const T mod) : value{((val % mod) + mod) % mod}, mod{mod} { assert(mod > 0); }\n    DModInt(const DModInt<T>& n) : value{n()}, mod{n.mod} {}\n    DModInt<T>& operator=(const DModInt<T>& n) { return assert(n.mod == mod), value = n(), (*this); }\n    DModInt<T>& operator=(const T v) { return value = (mod + v % mod) % mod, (*this); }\n    DModInt<T> operator+() const { return *this; }\n    DModInt<T> operator-() const { return DModInt{mod - value, mod}; }\n    DModInt<T> operator+(const DModInt<T>& val) const { return assert(mod == val.mod), DModInt{value + val(), mod}; }\n    DModInt<T> operator-(const DModInt<T>& val) const { return assert(mod == val.mod), DModInt{value - val() + mod, mod}; }\n    DModInt<T> operator*(const DModInt<T>& val) const { return assert(mod == val.mod), DModInt{value * val(), mod}; }\n    DModInt<T> operator/(const DModInt<T>& val) const { return assert(mod == val.mod), DModInt{value * inverse(val(), mod), mod}; }\n    DModInt<T>& operator+=(const DModInt<T>& val) { return assert(mod == val.mod), (((value += val()) %= mod) += mod) %= mod, (*this); }\n    DModInt<T>& operator-=(const DModInt<T>& val) { return assert(mod == val.mod), (((value -= val()) %= mod) += mod) %= mod, (*this); }\n    DModInt<T>& operator*=(const DModInt<T>& val) { return assert(mod == val.mod), (((value *= val()) %= mod) += mod) %= mod, (*this); }\n    DModInt<T>& operator/=(const DModInt<T> val) { return assert(mod == val.mod), (((value *= inverse(val(), mod)) %= mod) += mod) %= mod, (*this); }\n    DModInt<T> operator+(const T val) const { return DModInt{value + val, mod}; }\n    DModInt<T> operator-(const T val) const { return DModInt{value - val, mod}; }\n    DModInt<T> operator*(const T val) const { return DModInt{value * val, mod}; }\n    DModInt<T> operator/(const T val) const { return DModInt{value * inverse(val, mod), mod}; }\n    template <typename I>\n    DModInt<T> operator^(const I n) const { return n < 0 ? (T(1) / (*this)) ^ (-n) : n == 0 ? DModInt{1, mod} : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : ((*this * *this) ^ (n / 2)); }\n    DModInt<T>& operator+=(const T val) { return (((value += val) %= mod) += mod) %= mod, (*this); }\n    DModInt<T>& operator-=(const T val) { return (((value -= val) %= mod) += mod) %= mod, (*this); }\n    DModInt<T>& operator*=(const T val) { return (((value *= val) %= mod) += mod) %= mod, (*this); }\n    DModInt<T>& operator/=(const T val) { return (((value *= inverse(val, mod)) %= mod) += mod) %= mod, (*this); }\n    template <typename I>\n    DModInt<T>& operator^=(const I n) { return (*this) = ((*this) ^ n); }\n    bool operator==(const DModInt<T>& val) const { return assert(mod == val.mod), value == val.value; }\n    bool operator!=(const DModInt<T>& val) const { return assert(mod == val.mod), not(*this == val); }\n    bool operator==(const T val) const { return value == (mod + val % mod) % mod; }\n    bool operator!=(const T val) const { return not(*this == val); }\n    T operator()() const { return value; }\n};\ntemplate <typename T>\ninline DModInt<T> operator+(const T val, const DModInt<T>& n) { return DModInt<T>{n() + val, n.mod}; }\ntemplate <typename T>\ninline DModInt<T> operator-(const T val, const DModInt<T>& n) { return DModInt<T>{-n() + val, n.mod}; }\ntemplate <typename T>\ninline DModInt<T> operator*(const T val, const DModInt<T>& n) { return DModInt<T>{n() * val, n.mod}; }\ntemplate <typename T>\ninline DModInt<T> operator/(const T val, const DModInt<T>& n) { return DModInt<T>{val, n.mod} / n; }\ntemplate <typename T>\ninline bool operator==(const T val, const DModInt<T>& n) { return n == val; }\ntemplate <typename T>\ninline bool operator!=(const T val, const DModInt<T>& n) { return not(val == n); }\ntemplate <typename T>\ninline std::istream& operator>>(std::istream& is, DModInt<T>& n)\n{\n    T v;\n    return is >> v, n = v, is;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const DModInt<T>& n) { return (os << n()); }\nusing dmint = DModInt<int>;\nusing dmll = DModInt<ll>;\n//!====================================================================================!//\n//!    .88888.   a88888b. 888888ba        d88b       dP         a88888b. 8888ba.88ba   !//\n//!   d8'   '88 d8'   '88 88    '8b       8''8       88        d8'   '88 88  '8b  '8b  !//\n//!   88        88        88     88       d8b        88        88        88   88   88  !//\n//!   88   YP88 88        88     88     d8P'8b       88        88        88   88   88  !//\n//!   Y8.   .88 Y8.   .88 88    .8P     d8' '8bP     88        Y8.   .88 88   88   88  !//\n//!    '88888'   Y88888P' 8888888P      '888P''YP    88888888P  Y88888P' dP   dP   dP  !//\n//!====================================================================================!//\ntemplate <typename T>\nconstexpr T gcd(const T a, const T b) { return (b != 0) ? gcd(b, a % b) : a; }\ntemplate <typename T>\nconstexpr T lcm(const T a, const T b) { return (a == 0 and b == 0) ? (T)0 : (a / gcd(a, b)) * b; }\nint main()\n{\n    ll N;\n    std::cin >> N;\n    const auto facs = PrimeFactors(N);\n    ll phi = 1;\n    for (const auto& p : facs) {\n        if (p.second > 1) { return std::cout << -1 << std::endl, 0; }\n        phi = lcm(phi, p.first - 1);\n    }\n    if (gcd(phi, N) != 1) { return std::cout << -1 << std::endl, 0; }\n    const auto facs2 = PrimeFactors(phi);\n    ll phi2 = phi;\n    for (const auto& p : facs2) { (phi2 *= (p.first - 1)) /= p.first; }\n    const auto D = Divisors(phi2);\n    const DModInt<ll> DN(N, phi);\n    for (const auto d : D) {\n        if ((DN ^ d) == 1) { return std::cout << d << std::endl, 0; }\n    }\n    std::cout << -1 << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){\n  return x/__gcd(x,y)*y;\n}\nint mpow(int n,int x){\n  int res=1LL;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.first-1));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int x=-1,y;\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n    //cout<<ans<<endl;\n    if(x<0) x=p.first;\n    else y=p.first;\n  }\n  if(__gcd(x+y-1,(x-1)*(y-1))!=1LL){\n    cout<<-1<<endl;\n    return 0;\n  }\n  //cout<<x<<\" \"<<y<<endl;\n  //cout<<x+y-1<<\" \"<<(x-1)*(y-1)<<endl;\n  int k=ker(ans);\n  //cout<<k<<endl;\n  int tmp=k;\n  for(int i=2;i*i<=k;i++){\n    if(k%i) continue;\n    //cout<<i<<\" \"<<mod_pow(x,mod_pow(b,i,ans),b)<<endl;\n    //cout<<k/i<<\" \"<<mod_pow(x,mod_pow(b,k/i,ans),b)<<endl;\n    if(mod_pow(b,i,ans)==1) tmp=min(tmp,i);\n    if(mod_pow(b,k/i,ans)==1) tmp=min(tmp,k/i);\n  }\n  cout<<tmp<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nint power(int a, int n) {\n\tif (n == 0) return 1;\n\tif (n & 1) return a * power(a, n - 1);\n\treturn power(a * a, n / 2);\n}\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n & 1) return (a * powmod(a, n - 1, mod)) % mod;\n\treturn powmod((a * a) % mod, n / 2, mod);\n}\n\nvector<P> factorize(int n) {\n\tint t = n;\n\tvector<P> ret;\n\t\n\tfor (int i = 2; i * i <= t; i++) {\n\t\tint cnt = 0;\n\t\twhile (t % i == 0) {\n\t\t\tt /= i;\n\t\t\tcnt++;\n\t\t}\n\t\tif (cnt > 0) {\n\t\t\tret.push_back(P(i, cnt));\n\t\t}\n\t}\n\tif (t > 1) {\n\t\tret.push_back(P(t, 1));\n\t}\n\treturn ret;\n}\n\nsigned main() {\n\tcin >> n;\n\tif (n == 2) { cout << 1 << endl; return 0; }\n\telse if (n % 2 == 0) { cout << -1 << endl; return 0; }\n\tfor (int m = 2; m * m <= n; m++) { if (n % (m * m) == 0) { cout << -1 << endl; return 0; } }\n\t\n\tvector<P> p = factorize(n);\n\tint L = 1;\n\tfor (int i = 0; i < p.size(); i++) L = lcm(L, p[i].first - 1);\n\tvector<P> q = factorize(L);\n\t\n\tint ans = 1;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tint a = power(q[i].first, q[i].second);\n\t\tif (gcd(n, a) != 1) { cout << -1 << endl; return 0; }\n\t\tint eq = a - power(q[i].first, q[i].second - 1);\n\t\t//eq????´???°???????£?\n\t\tint minK = eq;\n\t\tfor (int k = 1; k * k <= eq; k++) {\n\t\t\tif (eq % k != 0) continue;\n\t\t\tif (powmod((n % a), k, a) == 1) minK = min(minK, k);\n\t\t\tif (powmod((n % a), eq / k, a) == 1) minK = min(minK, eq / k);\n\t\t}\n\t\t//lcm?????????\n\t\tans = lcm(ans, minK);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nbool isp[32000];\nvi p;\nint main() {\n\tint n;\n\tcin >> n;\n\tint n2 = n;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (isp[i])continue;\n\t\tp.push_back(i);\n\t\tfor (int j = 2 * i; j*j <= n; j += i)isp[j] = 1;\n\t}\n\tvi p2;\n\tfor (auto x : p) {\n\t\tif (n%x == 0) {\n\t\t\tp2.push_back(x);\n\t\t\tn /= x;\n\t\t\tif (n%x == 0) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (p2.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (n > 1)p2.push_back(n);\n\tn = n2;\n\tint ans = 1;\n\tfor (auto x : p2) {\n\t\tvi used(x);\n\t\tfor (ll i = n % (x - 1), cnt = 1;; i = i*n % (x - 1), cnt++) {\n\t\t\tif (used[i]) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tused[i] = 1;\n\t\t\tif (i == 1) {\n\t\t\t\tans = lcm(ans, cnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=1;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==1){\n      break;\n    }\n\n    if(cnt>1e6){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n,m;\n  cin>>n;\n  vector<ll> s;\n  m=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n\n  ans=lcm(ans, euler(n) );\n  \n\n\n  cout<< solve( n, ans ) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){\n  return x/__gcd(x,y)*y;\n}\nint mpow(int n,int x){\n  int res=1LL;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.first-1));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int x=-1,y;\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n    //cout<<ans<<endl;\n    if(x<0) x=p.first;\n    else y=p.first;\n  }\n  if(__gcd(x+y-1,(x-1)*(y-1))!=1LL){\n    cout<<-1<<endl;\n    return 0;\n  }\n  //cout<<x<<\" \"<<y<<endl;\n  //cout<<x+y-1<<\" \"<<(x-1)*(y-1)<<endl;\n  int k=ker(ans);\n  //cout<<k<<endl;\n  int tmp=k;\n  for(int i=2;i*i<=k;i++){\n    if(k%i) continue;\n    //cout<<i<<\" \"<<mod_pow(x,mod_pow(b,i,ans),b)<<endl;\n    //cout<<k/i<<\" \"<<mod_pow(x,mod_pow(b,k/i,ans),b)<<endl;\n    if(mod_pow(x,mod_pow(b,i,ans),b)==x&&\n       mod_pow(y,mod_pow(b,i,ans),b)==y) tmp=min(tmp,i);\n    if(mod_pow(x,mod_pow(b,k/i,ans),b)==x&&\n       mod_pow(y,mod_pow(b,k/i,ans),b)==y) tmp=min(tmp,k/i);\n  }\n  cout<<tmp<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <random>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(12231817);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> random_distinct_integers(int l, int r, int k) {\n\tassert((r - l) >= k);\n\tset<int> s;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x = rand_rng(l, r);\n\t\twhile (s.find(x) != s.end()) x = rand_rng(l, r);\n\t\ts.insert(x);\n\t}\n\treturn vector<int>(s.begin(), s.end());\n}\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nstd::vector<unsigned long long> calc_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret; ret.push_back(1);\n\tfor (std::pair<unsigned long long, unsigned> w : res) {\n\t\tint s = ret.size();\n\t\tunsigned long long mul = 1;\n\t\tfor (int i = 0; i < w.second; i++) {\n\t\t\tmul *= w.first;\n\t\t\tfor (int j = 0; j < s; j++) ret.push_back(ret[j] * mul);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse if (n == 2) cout << 1 << endl;\n\telse {\n\t\tint e = totient_function(n);\n\t\tvector<unsigned long long> v1 = calc_divisors(totient_function(e));\n\t\tint w1 = -1;\n\t\tfor (int i : v1) {\n\t\t\tif (modpow(n, i, e) == 1) {\n\t\t\t\tw1 = i; break;\n\t\t\t}\n\t\t}\n\t\tvector<int> sample = random_distinct_integers(0, n, min(n, 100));\n\t\tvector<unsigned long long> v2 = calc_divisors(w1);\n\t\tint ret = -1;\n\t\tfor (int i : v2) {\n\t\t\tbool ok = true;\n\t\t\tint r = modpow(n, i, e);\n\t\t\tfor (int j : sample) {\n\t\t\t\tif (modpow(j, r, n) != j) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tret = i; break;\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){\n  return x/__gcd(x,y)*y;\n}\nint mpow(int n,int x){\n  int res=1;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    //cout<<res<<endl;\n    //cout<<p.first<<\" \"<<p.second<<endl;\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.first-1));\n    }\n    //cout<<res<<endl;\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  if(m.count(2)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n    //cout<<ans<<endl;\n  }\n  cout<<(ker(ans)?ker(ans):-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nint main(){\n  ll n;\n  cin>>n;\n  ll v=euler(n);\n\n  if( __gcd(n,v) != 1 ){\n    cout<<-1<<endl;\n  }else{\n    ll ans=1;\n    ll p=n%v;\n    while(p!=1){\n      p=(p*n)%v;\n      ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint f(int a){return mod_pow(a,n,n);}\nint F(int a,int k){\n  if(k == 1) return f(a);\n  return F(f(a),k-1);\n}\n\nint mem[100];\nint F2(int a,int k){\n  if(k == 1) return mem[a] = f(a);\n  return mem[a] = mod_pow(mem[a],n,n);\n}\n\ndouble calcTime(){\n  static clock_t start = clock();// ??????????????????\n  clock_t end = clock();     // ????????????\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\nbool check(int k){\n  int res = 1;\n  for(int i=2;i<min(5LL,n);i++){\n    int a = i;\n    if(F(a,k) != a) res = 0;\n  }\n  return res;\n}\n\n\nint solve(){\n  int cnt = 0;\n  for(int k=1; calcTime() < 1000;k++,cnt++) if(check(k)) return k;\n  return -1;\n}\nvoid factor(int n){\n  for(int i=1;i<=n;i++){\n    if(n % i == 0) cout<<i<<\" \";\n  }\n  cout<<endl;\n}\n\nint lcm(int a,int b){return (a/__gcd(a,b)) * b;}\nint carmichealLambda(int n){\n  int res = 1;\n  if(n % 8 == 0) n/=2;\n\n  auto compute = [&](int i){\n    int sub = i - 1;\n    n/=i;\n    while(n%i == 0) n/=i, sub *=i;\n    res = lcm(res,sub);\n  };\n\n  for(int i=2;i*i<=n;i++) if( n % i == 0) compute(i);\n  if(n != 1) compute(n);\n  return res;\n}\n\nsigned main(){\n  cin>>n;\n  int car = carmichealLambda(n);\n  int car2 = carmichealLambda(car);\n  if(car == 1) {cout<<1<<endl;return 0;}\n  \n  //cout<<\"car=\"<<car<<endl;\n  //cout<<\"car2=\"<<car2<<endl;\n  //cout<<\"mod\"<<mod_pow(n,car2,car)<<endl;\n\n  int ans = car2;\n  if(mod_pow(n,1,car)==1) ans = 1;\n\n  for(int i=1;i*i<=car2;i++){\n    if(mod_pow(n,car2/i,car) == 1) Min(ans,car2/i);\n    if(mod_pow(n,i,car) == 1) Min(ans,i);\n  }\n  if(mod_pow(n,car2,car) !=  1)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint f(int a){return mod_pow(a,n,n);}\nint F(int a,int k){\n  if(k == 1) return f(a);\n  return F(f(a),k-1);\n}\n\nint mem[100];\nint F2(int a,int k){\n  if(k == 1) return mem[a] = f(a);\n  return mem[a] = mod_pow(mem[a],n,n);\n}\n\ndouble calcTime(){\n  static clock_t start = clock();// ??????????????????\n  clock_t end = clock();     // ????????????\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\nbool check(int k){\n  int res = 1;\n  for(int i=2;i<min(5LL,n);i++){\n    int a = i;\n    if(F(a,k) != a) res = 0;\n  }\n  return res;\n}\n\n\nint solve(){\n  int cnt = 0;\n  for(int k=1; calcTime() < 1;k++,cnt++) if(check(k)) return k;\n  return -1;\n}\n\nvector<bool> visited;\nint find(int num){\n  if(visited[num]) return 0;\n  visited[num] = 1;\n  int res = 1 + find(F(num,1));\n  visited[num] = 0;\n  return res;\n}\n\nint find2(int start){\n  int num  = F(start,1);\n  int cnt = 1;\n  while(num != start) num = F(num,1),cnt++;\n  return cnt;\n}\n\nint lcm(int a,int b){return (a/__gcd(a,b)) * b;}\n\nint solve2(){\n  visited.resize(n,0);\n  int res = 1;\n  for(int i=0;i<3;i++){\n    int num = rand()%(n-2)+1;\n    res = max(res,find2(num));\n  }\n  cout<<\"res=\"<<res<<endl;\n  return check(res)? res:-1;\n}\n\nvoid factor(int n){\n  for(int i=1;i<=n;i++){\n    if(n % i == 0) cout<<i<<\" \";\n  }\n  cout<<endl;\n}\n\nint carmichealLambda(int n){\n  int res = 1;\n  if(n % 8 == 0) n/=2;\n  \n  for(int i=2;i<=n;i++){\n    if( n % i != 0) continue;\n    int sub = i - 1;\n    n/=i;\n    while(n %i == 0) n/=i, sub *=i;\n    res = lcm(res,sub);\n  }\n  return res;\n}\n\nsigned main(){\n  srand((unsigned) time(NULL));\n  cin>>n;\n  //cout<<solve2()<<endl;\n\n  /*  int cnt = 0;\n  for(int i=1;i<n;i++){\n    continue;\n    if(__gcd(i,n) == 1) cnt++;\n    int flag = 0;\n    for(int k=1;k<10;k++)if(F(i,k) == 2) flag = 1;\n    if(!flag) continue;\n    cout<<\"i=\"<<i<<\":\";\n    for(int k=1;k<10;k++)cout<<\"\\t\"<<F(i,k);\n    cout<<endl;\n  }\n  */\n  int car = carmichealLambda(n);\n  int c = n,b = 1;\n  unordered_set<int> used;\n  int find = 1;\n  while(c % car != 1){\n    if(used.count(c)) {find=0;break;}\n    used.insert(c);\n    c = c*n%car,b++;\n  }\n  \n  if(find) cout<<b<<endl;\n  else cout<<-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse if (n == 2) cout << 1 << endl;\n\telse {\n\t\tint a = modpow(2, n, n);\n\t\tfor (int i = 1; ; i++) {\n\t\t\tif (a == 2) {\n\t\t\t\tcout << i << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta = modpow(a, n, n);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint f(int a){return mod_pow(a,n,n);}\nint F(int a,int k){\n  if(k == 1) return f(a);\n  return F(f(a),k-1);\n}\n\nint F2(int a,int k){return mod_pow(a,pow(n,k),n);}\n\n\ndouble calcTime(clock_t s = NULL){\n  static clock_t start = clock();// ??????????????????\n  if(s != NULL) start = s;\n  clock_t end = clock();     // ????????????\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\nbool check(int k){\n  for(int i=0;i<100;i++){\n    int a = rand()%n + 1;\n    if(a == n) a--;\n    if(F(a,k) != a) return 0;\n  }\n  return 1;\n}\nint solve(){\n  calcTime(clock());\n  for(int k=1;calcTime() < 4.8;k++) if(check(k)) return k;\n  return -1;\n}\n\nsigned main(){\n  srand((unsigned) time(NULL));\n  cin>>n;\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nint carmichaelLambda(int n){\n  int res = 1;\n  if(n % 8 == 0) n/=2;\n  auto lcm = [](int a,int b){return (a/__gcd(a,b)) * b;};\n\n  auto compute = [&](int i){\n    int sub = i - 1;\n    n/=i;\n    while(n%i == 0) n/=i, sub *=i;\n    res = lcm(res,sub);\n  };\n\n  for(int i=2;i*i<=n;i++) if( n % i == 0) compute(i);\n  if(n != 1) compute(n);\n  return res;\n}\n\nsigned main(){\n  cin>>n;\n  int car = carmichaelLambda(n);\n  int car2 = carmichaelLambda(car);\n  int ans = car2;\n  if(mod_pow(n,1,car)==1) ans = 1;\n  \n  for(int i=1;i*i<=car2;i++){\n    if(mod_pow(n,car2/i,car) == 1) Min(ans,car2/i);\n    if(mod_pow(n,i,car) == 1) Min(ans,i);\n  }\n  \n  if(car != 1 && mod_pow(n,car2,car) !=  1)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n \nll mod=15;\n \nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n \nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n \nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n \nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n \nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n \nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n \n    if(cnt>1e8){\n      cnt=euler(b);\n      break;\n    }\n  }\n  return cnt;\n}\n \nint main(){\n  ll n;\n  cin>>n;\n \n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n   \n  vector<ll> s;\n \n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n   \n  for(int i=0;i<(int)s.size();i++){\n    ll num= euler(n/s[i]);\n    ans=lcm(ans, num );\n  }\n   \n \n \n  if( n%ans== 0 || __gcd(n,ans) !=1){\n    cout<< -1 <<endl;\n    return 0;\n  }\n   \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e8){\n      cnt=euler(ans);\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n \n \n  /*\n  ll C=1;\n  for(ll i=0;i<n;i++){\n    ll k=solve( i , n );\n    C=lcm(k,C);\n  }\n  */\n  //  cout<<C<<' '<<ans<<endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nint main(){\n  ll n,m;\n  cin>>n;\n  vector<ll> s;\n  m=n;\n  for(ll i=2;i*i<=n;i++){\n    if(m%i==0){\n      m/=i;\n      s.push_back(i);\n    }\n    if(m%i==0){\n      cout<<-1<<endl; return 0;\n    }\n  }\n  \n  ll v=euler(n);\n\n  if( __gcd(n,v) != 1 ){\n    cout<<-1<<endl;\n  }else{\n    \n    ll ans=1;\n    ll p=n%v;\n    while(p!=1){\n      p=(p*n)%v;\n      ans++;\n      if(ans>1e8){\n        ans=euler(v);\n        break;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){return x/__gcd(x,y)*y;}\nint mpow(int n,int x){\n  int res=1;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    //cout<<res<<endl;\n    //cout<<p.first<<\" \"<<p.second<<endl;\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.second-1));\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n  }\n  cout<<ker(ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nlong long gcd(long long a, long long b) {\n    while (b > 0) {\n        long long t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\nlong long lcm(long long a, long long b) {\n    return a / gcd(a, b) * b;\n}\n\nlong long powmod(long long a, long long b, long long mod) {\n    if (b == 0) return 1;\n    long long p = powmod(a, b / 2, mod);\n    p = p * p % mod;\n    if (b & 1) p = p * a % mod;\n    return p;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int m = n;\n    vector<int> v;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            if (n % (i * i) == 0) {\n                cout << \"-1\\n\";\n                return 0;\n            }\n            v.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) v.push_back(n);\n    long long l = 1;\n    for (auto& a : v) l = lcm(l, a - 1);\n    if (gcd(m, l) > 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    long long p = l;\n    long long cnt = l;\n    for (int i = 2; i * i <= l; ++i) {\n        if (l % i == 0) {\n            cnt = cnt / i * (i - 1);\n            while (l % i == 0)\n                l /= i;\n        }\n    }\n    if (l > 1) cnt = cnt / l * (l - 1);\n\n    long long ans = cnt;\n    for (long long i = 1; i * i <= cnt; ++i) {\n        if (cnt % i == 0) {\n            if (powmod(m, i, p) == 1)\n                ans = min(ans, i);\n            if (powmod(m, cnt / i, p) == 1)\n                ans = min(ans, cnt / i);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint pow_mod(int a, int n, int m = MOD) {\n  int res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * a % m;\n    a = a * a % m;\n    n >>= 1;\n  }\n  return res;\n}\n\nint inv_mod(int a, int m = MOD) {\n  int b = m, x = 1, y = 0;\n  while (b) {\n    int t = a/b;\n    a -= t*b; swap(a,b);\n    x -= t*y; swap(x,y);\n  }\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nint log_mod(int a, int b, int m = MOD) {\n  a %= m; b %= m;\n  int ok = m, ng = -1;\n  while (ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n    if (mid * mid >= m) ok = mid;\n    else ng = mid;\n  }\n  unordered_map<int,int> baby;\n  baby.reserve(ok);\n  int factor = 1;\n  for (int i = 0, e = b; i < ok; i++) {\n    baby[e] = i;\n    (factor *= a) %= m;\n    (e *= a) %= m;\n  }\n  for (int i = 1, e = factor; i <= ok; i++) {\n    auto it = baby.find(e);\n    if (it != end(baby)) return i * ok - it->second;\n    (e *= factor) %= m;\n  }\n  return -1;\n}\n\nmap<int,int> prime_factor(int x) {\n  map<int,int> res;\n  for (int i = 2; i*i <= x; i++) {\n    while (x % i == 0) {\n      res[i]++;\n      x /= i;\n    }\n  }\n  if (x != 1) res[x]++;\n  return res;\n}\n\nint gcd(int a, int b) {\n  while (b) {\n    int c = a % b;\n    a = b; b = c;\n  }\n  return a;\n}\n\nint lcm(int a, int b) {\n  return a / gcd(a,b) * b;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int N;\n  cin >> N;\n  auto pf = prime_factor(N);\n  int LCM = 1;\n  for (auto p : pf) {\n    if (p.second != 1) {\n      cout << -1 << endl;\n      return 0;\n    }\n    LCM = lcm(LCM,p.first-1);\n  }\n  cout << (gcd(N,LCM) != 1 ? -1 : log_mod(N,1,LCM)) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) res=res*x%mod;\n    x=x*x%mod;\n    n>>=1;\n  }\n  return res;\n}\nint f(int a,int n){\n  return mod_pow(a,n,n);\n}\nint F(int a,int k,int n){\n  if(k==1) return f(a,n);\n  else return F(f(a,n),k-1,n);\n}\nsigned main(){\n  int n;\n  cin>>n;\n  int z=0;\n  vector<int> v;\n  {\n    int t=n;\n    bool ff=0;\n    for(int j=2;j*j<=n;j++){\n      if(t%j==0){\n\tz++;\n\tv.push_back(j);\n\tint tmp=0;\n\twhile(t%j==0) t/=j,tmp++;\n\tif(tmp>1){\n\t  ff=1;\n\t  break;\n\t}\n      }\n    }\n    if(t!=1) z++,v.push_back(t);\n    if(ff){\n      cout<<-1<<endl;\n      return 0;;\n    }\n  }\n  if(z==1){\n    cout<<1<<endl;\n    return 0;\n  }\n  int ans=1;\n  if(1){\n    set<int> u;\n    for(int j=1;j*j<=n;j++){\n      if(u.count(j)) continue;\n      int cur=j;\n      set<int> s;\n      while(!s.count(f(cur,n))){\n\tcur=f(cur,n);\n\ts.insert(cur);\n\tu.insert(cur);\n      }\n      if(cur!=j){\n\tans=-1;\n\tbreak;\n      }\n      //cout<<s.size()<<endl;\n      int m=__gcd(ans,(int)s.size());\n      ans*=s.size()/m;\n      if(ans>1000) break;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll gcd(ll a,ll b){ return __gcd(a,b); }\nll lcm(ll a,ll b){ return a/gcd(a,b)*b; }\n\nll mod=15;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll mod_pow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mod_pow( mul(a,a) ,b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\n\nll euler(ll n){\n  ll res=n;\n  for(ll i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      while(n%i==0)n/=i;\n    }\n  }\n  if(n!=1)res=res/n*(n-1);\n  return res;\n}\n\nbool isP(ll x){\n  for(ll i=2;i*i<=x;i++){\n    if(x%i==0)return false;\n  }\n  return (x>=2);\n}\n\nll solve(ll a,ll b){\n  ll cnt=0,k=a;\n  while(1){\n    k=(k*a)%b;\n    cnt++;\n    if(k==a){\n      break;\n    }\n\n    if(cnt>1e6){\n      cnt=b-1;\n      break;\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n\n  if(isP(n)){\n    cout<<1<<endl;\n    return 0;\n  }\n  \n  vector<ll> s;\n\n  for(ll i=2;i*i<=n;i++){\n    if(n%(i*i)==0){\n      cout<<-1<<endl;return 0;\n    }\n    if(n%i==0){\n      s.push_back(i);\n      s.push_back(n/i);\n    }\n  }\n  ll ans=1;\n  \n  for(int i=0;i<(int)s.size();i++){\n    ans=lcm(ans, solve(s[i],n) );\n  }\n  \n  ans=lcm(ans, euler(n) );\n\n  if( n%ans== 0 || __gcd(n,ans) !=1){\n    cout<< -1 <<endl;\n    return 0;\n  }\n  \n  ll k=1,cnt=0;\n  while(1){\n    k=(k*n)%ans;\n    cnt++;\n    if(k==1){\n      break;\n    }\n    if(cnt>1e7){\n      cnt=euler(ans);\n      break;\n    }\n  }\n  cout<<cnt<<endl;\n\n\n  \n  ll C=1;\n  for(ll i=0;i<n;i++){\n    ll k=solve( i , n );\n    C=lcm(k,C);\n  }\n  //  cout<<C<<' '<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nbool isp[100000];\nvector<ll> p;\nvoid init() {\n\tfill(isp+2, isp + 100000, true);\n\tRep(i, 2, 100000) {\n\t\tif (!isp[i])continue;\n\t\tp.push_back(i);\n\t\tfor (int j = 2 * i; j < 100000; j += i) {\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n}\nll mod_pow(ll x, int n, ll m) {\n\tx %= m;\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%m;\n\t\tx = x * x%m; n >>= 1;\n\t}\n\treturn ret;\n}\nll Euler_t(int x) {\n\tll ret = 1;\n\trep(i, p.size()) {\n\t\tif (x%p[i] == 0) {\n\t\t\tret *= (p[i] - 1);\n\t\t\tx /= p[i];\n\t\t\twhile (x%p[i] == 0) {\n\t\t\t\tx /= p[i]; ret *= p[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (x > 1)ret *= (x - 1);\n\treturn ret;\n}\nvector<int> divis(int x) {\n\tvector<int> ret;\n\tint k = sqrt(x);\n\trep1(i, k) {\n\t\tif (x%i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tret.push_back(x / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\tret.erase(unique(ret.begin(), ret.end()), ret.end());\n\treturn ret;\n}\nll gcd(ll x, ll y) {\n\tif (x < y)swap(x, y);\n\twhile (y) {\n\t\tll r = x % y; x = y; y = r;\n\t}\n\treturn x;\n}\nll lcm(ll x, ll y) {\n\tll g = gcd(x, y);\n\treturn x / g * y;\n}\nint main() {\n\tinit();\n\tint n; cin >> n; int cop = n;\n\tif (n == 2) {\n\t\tcout << 1 << endl; return 0;\n\t}\n\tif (n % 2 == 0) {\n\t\tcout << -1 << endl; return 0;\n\t}\n\tbool f = true;\n\tvector<ll> u;\n\trep(i, p.size()) {\n\t\tif (n % (p[i] * p[i]) == 0) {\n\t\t\tf = false; break;\n\t\t}\n\t\tif (n%p[i]==0) {\n\t\t\tu.push_back(p[i]); n /= p[i];\n\t\t}\n\t}\n\tif (n > 1)u.push_back(n);\n\tif (!f) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tll ans = 1;\n\t\trep(i, u.size()) {\n\t\t\tint r = cop / u[i];\n\t\t\tint z = Euler_t(u[i] - 1);\n\t\t\tvector<int> d = divis(z);\n\t\t\tint chk = -1;\n\t\t\trep(j, d.size()) {\n\t\t\t\tll s = mod_pow(r, d[j], (u[i] - 1));\n\t\t\t\tif (s == 1) {\n\t\t\t\t\tchk = d[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chk < 0) {\n\t\t\t\tcout << -1 << endl; return 0;\n\t\t\t}\n\t\t\tans = lcm(ans, chk);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nvector<pair<long long, long long> > prime_factorize(long long n) {\n    vector<pair<long long, long long> > res;\n    for (long long p = 2; p * p <= n; ++p) {\n        if (n % p != 0) continue;\n        int num = 0;\n        while (n % p == 0) { ++num; n /= p; }\n        res.push_back(make_pair(p, num));\n    }\n    if (n != 1) res.push_back(make_pair(n, 1));\n    return res;\n}\n\nint calc_order(long long N, long long L) {\n    auto pf = prime_factorize(L);\n    long long euler = L;\n    for (auto pa : pf) {\n        int p = pa.first;\n        euler /= p, euler *= p-1;\n    }\n    \n    long long res = euler;\n    auto pfeuler = prime_factorize(euler);\n    for (auto pa : pfeuler) {\n        int p = pa.first;\n        while (res % p == 0 && modpow(N, res/p, L) == 1) res /= p;\n    }\n    return res;\n}\n\nlong long solve(long long N) {\n    auto pf = prime_factorize(N);\n    \n    bool ok = true;\n    long long L = 1;\n    for (auto p : pf) {\n        if (p.second > 1) ok = false;\n        long long g = GCD(L, p.first - 1);\n        L = L / g * (p.first - 1);\n    }\n    if (!ok) return -1;\n    if (GCD(N, L) > 1) return -1;\n    if (L == 1) return 1; // 例外処理\n\n    // mod L での N の位数を求める\n    return calc_order(N, L);\n}\n\nint main() {\n    long long N; cin >> N;\n    cout << solve(N) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \n  \nstruct edge{\n  int to,cost;\n  bool operator < ( const edge &p)const{\n    return (cost == p.cost? to < p.to :cost < p.cost);\n  }\n};\nstruct state{\n  int pos,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n  \ntypedef long long ll;\n  \n#define MAX 100005\nint pa[MAX],ra[MAX];\nint t[MAX],h[MAX],d[MAX];\n  \nvector<edge> G[MAX];\nvector<edge> g[MAX];\nint n,m;\n  \nvoid init();\nint find(int x);\nvoid unite(int x,int y);\nll solve();\n  \nint main(){\n  while( scanf(\"%d\",&n)!=EOF){\n    init();\n    for(int i=1;i<=n;i++)scanf(\"%d\",&h[i]);\n    scanf(\"%d\",&m);\n    int a,b;\n    for(int i=1;i<=m;i++){\n      scanf(\"%d %d\",&a,&b);\n      g[a].push_back((edge){b,h[b]});\n      g[b].push_back((edge){a,h[a]});\n      if(h[a]<h[b]){        \n        G[a].push_back((edge){b,h[b]});\n      }else if(h[a]>h[b]){\n        G[b].push_back((edge){a,h[a]});\n      }else{        \n        unite(a,b);\n      }\n    }\n  \n  \n    for(int i=1;i<=n;i++){\n      sort(g[i].begin(),g[i].end());\n      for(int j=1;j<(int)g[i].size();j++){\n        if(g[i][j-1].cost==g[i][j].cost){\n          unite(g[i][j-1].to,g[i][j].to);\n        }else if(g[i][j-1].cost<g[i][j].cost){\n          G[ g[i][j-1].to ].push_back( g[i][j] );\n        }\n      }\n    }\n  \n   \n    for(int i=1;i<=n;i++){\n      int id=find(i);\n      t[id]++;\n      if(i==id)continue;\n      for(int j=0;j<(int)G[i].size();j++){\n        edge e=G[i][j];\n        G[id].push_back(e);\n      }\n    }\n   \n    cout<<solve()<<endl;\n  \n    break;\n  }\n  return 0;\n}\n  \nll solve(){\n  priority_queue< state > Q;\n  \n  for(int i=1;i<=n;i++){\n    if(i==find(i))Q.push((state){i,h[i]});\n  }\n   \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    int pos=s.pos;\n    int cost=d[s.pos];\n    for(int i=0;i<(int)G[pos].size();i++){\n      edge e=G[pos][i];\n      e.to=find(e.to);\n      d[e.to]=max(d[e.to],cost+1);      \n    }\n  }\n  ll ans=0;\n  for(int i=1;i<=n;i++)ans+= (ll)d[i] * (ll)t[i];  \n  return ans;\n}\n  \nvoid init(){\n  for(int i=0;i<MAX;i++){\n    pa[i]=i;\n    ra[i]=0;\n    t[i]=0;\n    d[i]=1;\n    G[i].clear();\n    g[i].clear();\n  }  \n}\n  \n  \n  \nint find(int x){\n  if(pa[x]==x)return x;\n  else return pa[x]=find(pa[x]);\n}\n  \nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(ra[x]<ra[y])pa[x]=y;\n  else {\n    pa[y]=x;\n    if(ra[x]==ra[y])ra[x]++;\n  }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\n\nll gcd(ll a, ll b) {\n    return b == 0 ? a : gcd(b, a%b);\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nll mod_pow(ll a, ll n, ll m) {\n    ll res = 1;\n    while (n > 0) {\n        if (n % 2 == 1) (res *= a) %= m;\n        (a *= a) %= m;\n        n /= 2;\n    }\n    return res;\n}\n\nmap<int, int> factorize(int x) {\n    map<int, int> res;\n    for (int d = 2; d * d <= x; ++d) {\n        int count = 0;\n        while (x % d == 0) {\n            ++count;\n            x /= d;\n        }\n        if (count > 0) res[d] = count;\n    }\n    if (x > 1) res[x] = 1;\n    return res;\n}\n\nint euler_totient(int x) {\n    int res = x;\n    for (int y = 2; y * y <= x; ++y) {\n        if (x % y == 0) {\n            res -= res / y;\n            while (x % y == 0) x /= y;\n        }\n    }\n    if (x > 1) res -= res / x;\n    return res;\n}\n\nint N;\n\nint main(void) {\n    cin >> N;\n\n    auto n_factors = factorize(N);\n    ll L = 1;\n    for (auto& itr : n_factors) {\n        if (itr.second > 1) {\n            cout << -1 << endl;\n            exit(0);\n        }\n        L = lcm(L, itr.first - 1);\n    }\n\n    if (gcd(N, L) > 1) {\n        cout << -1 << endl;\n        exit(0);\n    }\n\n    const int el = euler_totient(L);\n    int ans = el;\n    for (int x = 1; x * x <= el; ++x) {\n        if (el % x == 0) {\n            if (mod_pow(N, x, L) == 1)\n                ans = min(ans, x);\n            if (mod_pow(N, el / x, L) == 1)\n                ans = min(ans, el / x);\n        }\n    }\n\n    cout << ans << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\n\nll inv( ll a , ll mod ){\n  ll x, y;\n  if( extgcd( a , mod , x , y ) != 1 ){\n    throw 0;\n  }\n  x %= mod;\n  if( x < 0 ){\n    x += mod;\n  }\n  return x;\n}\n\nll modlog( ll n , ll mod ){\n  ll q = 1;\n  while( q * q < mod ){\n    q++;\n  }\n  n %= mod;\n  map<ll,ll> ma;\n  ll nq = 1;\n  ma[1] = 0;\n  REP( i , q ){\n    nq = ( nq * n ) % mod;\n    if( nq == 1 ){\n      return i + 1;\n    }\n    ll a = ( inv( nq , mod ) ) % mod;\n    if( ma.find( a ) == ma.end() ){\n      ma[a] = i + 1;\n    }\n  }\n  ll cur = 1;\n  REP( i , q ){\n    cur = ( cur * nq ) % mod;\n    if( ma.find( cur ) != ma.end() ){\n      return ( i + 1 ) * q + ma[cur];\n    }\n  }\n  assert( false );\n}\n\nvl fact( ll x ){\n  vl res;\n  for( ll i = 2; i*i <= x; i++ ){\n    while( x % i == 0 ){\n      res.pb( i );\n      x /= i;\n    }\n  }\n  if( x > 1 ) res.pb( x );\n  return res;\n}\n\nll f( ll a , ll b , ll mo ){\n  // a k = b mod mo\n  // a k + mo l = b\n  ll g = __gcd( a , mo );\n  if( b % g != 0 ){\n    return -1;\n  }\n  a /= g;\n  b /= g;\n  mo /= g;\n  // cout << \"* \" << a << \" \" << mo << endl;\n  ll k, l;\n  extgcd( a , mo , k , l );\n  // cout << \"* \" << k << \" \" << l << endl;\n  k *= b;\n  l *= b;\n  k = ( ( k % mo ) + mo ) % mo;\n  return k;\n}\n\nll n;\n\n\nint main(){\n  \n  n = in();\n\n  vl v = fact( n );\n  SORT( v );\n  REP( i , SZ(v) - 1 ){\n    if( v[i] == v[i+1] ){\n      puts( \"-1\" );\n      return 0;\n    }\n  }\n  \n  ll x = 1;\n  ll y = 0;\n  ll ans = 1;\n  REP( i , SZ(v) ){\n    ll mod = v[i] - 1;\n    if( mod == 1 ){\n      continue;\n    }\n    try{\n      ll res = modlog( n , mod );\n      if( res == -1 ){\n        puts( \"-1\" );\n        return 0;\n      }\n      ll r = f( x , ( ( res - y ) % mod + mod ) % mod, mod );\n      // cout << r << \" \" << mod << endl;\n      ans = ans * r / __gcd( ans , r );\n      /*\n      SHOW( x );\n      SHOW( y );\n      SHOW( res );\n      SHOW( mod );\n      cout << res << \" \" << mod << \" \" << r << endl;\n      ll nx = x * mod;\n      ll ny = x * r + y;\n      x = nx;\n      y = ny;\n      y = ( ( y % x ) + x ) % x;\n      cout << x << \" \" << y << endl;\n      */\n    } catch (...){\n      puts( \"-1\" );\n      return 0;\n    }\n  }\n\n  if( ans == 0 ){\n    cout << -1 << endl;\n  } else {\n    cout << ans << endl;\n  }\n  /*\n  if( y == 0 ){\n  cout << -1 << endl;\n  } else {\n    cout << ans << endl;\n  }\n  */\n\n  return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) res=res*x%mod;\n    x=x*x%mod;\n    n>>=1;\n  }\n  return res;\n}\nint f(int a,int n){\n  return mod_pow(a,n,n);\n}\nint F(int a,int k,int n){\n  if(k==1) return f(a,n);\n  else return F(f(a,n),k-1,n);\n}\nsigned main(){\n  int n;\n  cin>>n;\n  int z=0;\n  vector<int> v;\n  {\n    int t=n;\n    bool ff=0;\n    for(int j=2;j*j<=n;j++){\n      if(t%j==0){\n\tz++;\n\tv.push_back(j);\n\tint tmp=0;\n\twhile(t%j==0) t/=j,tmp++;\n\tif(tmp>1){\n\t  ff=1;\n\t  break;\n\t}\n      }\n    }\n    if(t!=1) z++,v.push_back(t);\n    if(ff){\n      cout<<-1<<endl;\n      return 0;;\n    }\n  }\n  if(z==1){\n    cout<<1<<endl;\n    return 0;\n  }\n  int ans=1;\n  if(1){\n    set<int> u;\n    for(int j=1;j*j<=n;j++){\n      if(u.count(j)) continue;\n      int cur=j;\n      set<int> s;\n      while(!s.count(f(cur,n))){\n\tcur=f(cur,n);\n\ts.insert(cur);\n\tu.insert(cur);\n      }\n      if(cur!=j){\n\tans=-1;\n\tbreak;\n      }\n      //cout<<s.size()<<endl;\n      int m=__gcd(ans,(int)s.size());\n      ans*=s.size()/m;\n      if(ans>10000) break;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nll Pow(ll a, ll b, ll mod) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tll N;\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (N % 2 == 0) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<ll> div;\n\tfor (ll i = 2; i * i <= N; i++) {\n\t\tif (i * i == N) {\n\t\t\tdiv.push_back(i);\n\t\t}\n\t\telse if (N % i == 0) {\n\t\t\tdiv.push_back(i);\n\t\t\tdiv.push_back(N / i);\n\t\t}\n\t}\n\tif (div.empty()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tsort(div.begin(), div.end());\n\tll res = 1;\n\tfor (auto val : div) {\n\t\tmap<ll, bool> used;\n\t\tll tmp = val, cnt = 0;\n\t\twhile (!used[val]) {\n\t\t\tused[val] = true;\n\t\t\tval = Pow(val, N, N);\n\t\t\tcnt++;\n\t\t}\n\t\tif (val == tmp) {\n\t\t\tres = lcm(res, cnt);\n\t\t}\n\t\telse {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint lcm(int x,int y){\n  return x/__gcd(x,y)*y;\n}\nint mpow(int n,int x){\n  int res=1;\n  for(int i=0;i<x;i++) res*=n;\n  return res;\n}\nint ker(int n){\n  int res=1;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  for(auto p:m){\n    //cout<<res<<endl;\n    //cout<<p.first<<\" \"<<p.second<<endl;\n    if(p.first==2){\n      if(p.second==1) res=lcm(res,1);\n      else if(p.second==2) res=lcm(res,2);\n      else res=lcm(res,mpow(2,p.second-2));\n    }else{\n      res=lcm(res,mpow(p.first,p.second-1)*(p.first-1));\n    }\n    //cout<<res<<endl;\n  }\n  return res;\n}\n\nsigned main(){\n  int n,b;\n  cin>>n;\n  b=n;\n  map<int,int> m;\n  for(int i=2;i*i<=n;i++){\n    if(n%i) continue;\n    while(n%i==0) n/=i,m[i]++;\n  }\n  if(n!=1) m[n]++;\n  if(b==n){\n    cout<<1<<endl;\n    return 0;\n  }\n  if((int)m.size()>2){\n    cout<<-1<<endl;\n    return 0;\n  }\n  if(m.count(2)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  int ans=1LL;\n  for(auto p:m){\n    if(p.second>1){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans*=(p.first-1);\n    //cout<<ans<<endl;\n  }\n  cout<<(ker(ans)?ker(ans):-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <random>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(12231817);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> random_distinct_integers(int l, int r, int k) {\n\tassert((r - l) >= k);\n\tset<int> s;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x = rand_rng(l, r);\n\t\twhile (s.find(x) != s.end()) x = rand_rng(l, r);\n\t\ts.insert(x);\n\t}\n\treturn vector<int>(s.begin(), s.end());\n}\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nconst int max_search_size = 5;\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse {\n\t\tvector<int> v = random_distinct_integers(0, n, min(n, max_search_size));\n\t\tvector<int> a(v.size());\n\t\tfor (int i = 0; i < v.size(); i++) a[i] = modpow(v[i], n, n);\n\t\tfor (int i = 1; ; i++) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\t\tif (a[j] != v[j]) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tcout << i << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int j = 0; j < v.size(); j++) a[j] = modpow(a[j], n, n);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ninline unsigned long long gcd(unsigned long long x, unsigned long long y) {\n\twhile (y != 0) {\n\t\tunsigned long long r = x;\n\t\tx = y;\n\t\ty = r % y;\n\t}\n\treturn x;\n}\ninline unsigned modpow(unsigned long long a, unsigned long long b, unsigned m) {\n\tunsigned ret = 1; a %= m;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ULL * ret * a % m;\n\t\ta = 1ULL * a * a % m;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nstd::map<unsigned long long, unsigned> prime_factorize(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> ret;\n\tfor (unsigned i = 2; 1ULL * i * i <= x; i++) {\n\t\twhile (x % i == 0) x /= i, ret[i]++;\n\t}\n\tif (x != 1) ret[x]++;\n\treturn ret;\n}\nstd::vector<unsigned long long> prime_divisors(unsigned long long x) {\n\tstd::map<unsigned long long, unsigned> res = prime_factorize(x);\n\tstd::vector<unsigned long long> ret;\n\tfor (std::pair<unsigned long long, unsigned> w : res) ret.push_back(w.first);\n\treturn ret;\n}\nunsigned long long totient_function(unsigned long long x) {\n\tstd::vector<unsigned long long> v = prime_divisors(x);\n\tunsigned long long ret = x;\n\tfor (unsigned long long w : v) ret = ret / w * (w - 1);\n\treturn ret;\n}\nint n;\nint main() {\n\tcin >> n;\n\tif (gcd(n, totient_function(n)) != 1) cout << -1 << endl;\n\telse {\n\t\tint e = totient_function(n);\n\t\tint a = n % e;\n\t\tfor (int i = 1; ; i++) {\n\t\t\tif (a == 1) {\n\t\t\t\tcout << i << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta = 1LL * a * n % e;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nll powmod(ll n,ll k,ll m){\n\tll ret=1;\n\twhile(k){\n\t\tif(k%2)ret=ret*n%m;\n\t\tn=n*n%m;\n\t\tk/=2;\n\t}\n\treturn ret;\n}\nll gcd(ll x,ll y){\n\tif(x<y)swap(x,y);\n\treturn y?gcd(y,x%y) : x;\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nint solve(){\n\tint n;\n\tcin>>n;\n\tll N=n;\n\tif(n==2)return 1;\n\tint m=1;\n\tfor(int i=2;i<100000;++i){\n\t\tif(n%i==0){\n\t\t\tn/=i;\n\t\t\tif(n%i==0)return -1;\n\t\t\tm=lcm(i-1,m);\n\t\t}\n\t}\n\tif(n>1)m=lcm(n-1,m);\n\tll M=m;\n\tll res=m;\n\tfor(int i=2;i<=100000;++i){\n\t\tif(m%i==0){\n\t\t\tres/=i;\n\t\t\tres*=(i-1);\n\t\t\twhile(m%i==0)m/=i;\n\t\t}\n\t}\n\tif(m>1){\n\t\tres/=m;\n\t\tres*=m-1;\n\t}\n\tll ans=1e9;\n\tfor(ll i=1;i<=100000;++i){\n\t\tif(res%i==0){\n\t\t\tif(powmod(N,i,M)==1)ans=min(ans,i);\n\t\t\tif(powmod(N,res/i,M)==1)ans=min(ans,res/i);\n\t\t}\n\t}\n\tif(ans<1e9)return ans;\n\treturn -1;\n}\n\nint main(){\n\tcout<<solve()<<endl;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2720: Identity Function\n// 2017.10.9 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define SIZE  25\nint size;\nint factor[SIZE];\n\nint ptbl[] = {\n         3,   5,   7,  11,  13,  17,  19,  23,  29,\n   31,  37,  41,  43,  47,  53,  59,  61,  67,  71,\n   73,  79,  83,  89,  97, 101, 103, 107, 109, 113,\n  127, 131, 137, 139, 149, 151, 157, 163, 167, 173,\n  179, 181, 191, 193, 197, 199, 211, 223, 227, 229,\n  233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n  283, 293, 307, 311, 313, 317, 331, 337, 347, 349,\n  353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\n  419, 421, 431, 433, 439, 443, 449, 457, 461, 463,\n  467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\n  547, 557, 563, 569, 571, 577, 587, 593, 599, 601,\n  607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\n  661, 673, 677, 683, 691, 701, 709, 719, 727, 733,\n  739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\n  811, 821, 823, 827, 829, 839, 853, 857, 859, 863,\n  877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\n  947, 953, 967, 971, 977, 983, 991, 997, 0 };\n\nvoid prime_factor(long long n)\n{\n  int i, d, sw;\n  int *pp;\n\n  size = 0;\n  if ((n & 1) == 0) {\n    factor[size++] = 2;\n    do n >>= 1LL;\n    while ((n & 1) == 0);\n  }\n  for (pp = ptbl; n > 1 && *pp > 0; pp++) {\n    if (n % *pp) continue;\n    d = *pp;\n    factor[size++] = d;\n    do n /= d;\n    while (n % d == 0);\n  }\n  if (n > 1) {\n    int b = (int)sqrt((double)n);\n    for (i = 1009, sw = 0; n > 1; ) {\n      if (i > b) {\n        factor[size++] = (int)n;\n        break;\n      }\n      if (n % i == 0) {\n        factor[size++] = i;\n        do n /= i;\n        while (n % i == 0);\n      }\n      if (sw) { i += 2, sw = 0; }\n      else    { i += 4, sw = 1; }\n    }\n  }\n}\n\nlong long gcd(long long a, long long b)\n{\n\tlong long r;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nlong long lcm(long long a, long long b)\n{\n\treturn a/gcd(a, b)*b;\n}\n\nint big_mod(int b, int p, int m)\n{\n   int s = 1;\n   int d;\n\n   d = b % m;\n   while (p > 0) {\n      if (p & 1) s = (s * d) % m;\n      p >>= 1;\n      d = (d * d) % m;\n   }\n   return s;\n}\n\nint main()\n{\n\tint n, i, i2, k;\n\tlong long L, a;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 2; ; i++) {\n\t\tif ((i2 = i*i) > n) break;\n\t\tif (n % i2 == 0) goto NG;\n\t}\n\n\tprime_factor(n);\n\tL = factor[0]-1;\n\tfor (i = 1; i < size; i++) L = lcm(L, factor[i]-1);\n\tif (gcd(n, L) != 1) goto NG;\n\n\tprime_factor(L);\n\tfor (a = L, i = 0; i < size; i++) a = a/factor[i]*(factor[i]-1);\n\n\tfor (k = 1; k <= a; k++) {\n\t\tif (a % k == 0 && big_mod(n, k, L) == 1) {\n\t\t\tprintf(\"%d\\n\", k);\n\t\t\treturn 0; \n\t\t}\n\t}\nNG: puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2720: Identity Function\n// 2017.10.9 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define SIZE  25\nint size;\nint factor[SIZE];\n\nint ptbl[] = {\n         3,   5,   7,  11,  13,  17,  19,  23,  29,\n   31,  37,  41,  43,  47,  53,  59,  61,  67,  71,\n   73,  79,  83,  89,  97, 101, 103, 107, 109, 113,\n  127, 131, 137, 139, 149, 151, 157, 163, 167, 173,\n  179, 181, 191, 193, 197, 199, 211, 223, 227, 229,\n  233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n  283, 293, 307, 311, 313, 317, 331, 337, 347, 349,\n  353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\n  419, 421, 431, 433, 439, 443, 449, 457, 461, 463,\n  467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\n  547, 557, 563, 569, 571, 577, 587, 593, 599, 601,\n  607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\n  661, 673, 677, 683, 691, 701, 709, 719, 727, 733,\n  739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\n  811, 821, 823, 827, 829, 839, 853, 857, 859, 863,\n  877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\n  947, 953, 967, 971, 977, 983, 991, 997, 0 };\n\nvoid prime_factor(long long n)\n{\n  int i, d, sw;\n  int *pp;\n\n  size = 0;\n  if ((n & 1) == 0) {\n    factor[size++] = 2;\n    do n >>= 1LL;\n    while ((n & 1) == 0);\n  }\n  for (pp = ptbl; n > 1 && *pp > 0; pp++) {\n    if (n % *pp) continue;\n    d = *pp;\n    factor[size++] = d;\n    do n /= d;\n    while (n % d == 0);\n  }\n  if (n > 1) {\n    int b = (int)sqrt((double)n);\n    for (i = 1009, sw = 0; n > 1; ) {\n      if (i > b) {\n        factor[size++] = (int)n;\n        break;\n      }\n      if (n % i == 0) {\n        factor[size++] = i;\n        do n /= i;\n        while (n % i == 0);\n      }\n      if (sw) { i += 2, sw = 0; }\n      else    { i += 4, sw = 1; }\n    }\n  }\n}\n\nlong long gcd(long long a, long long b)\n{\n\tlong long r;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nlong long lcm(long long a, long long b)\n{\n\treturn a/gcd(a, b)*b;\n}\n\nlong long big_mod(int b, long long p, long long m)\n{\n   long long s = 1;\n   long long d;\n\n   d = b % m;\n   while (p > 0) {\n      if (p & 1) s = (s * d) % m;\n      p >>= 1;\n      d = (d * d) % m;\n   }\n   return s;\n}\n\nint main()\n{\n\tint n, i, i2;\n\tlong long L, a, k;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 2; ; i++) {\n\t\tif ((i2 = i*i) > n) break;\n\t\tif (n % i2 == 0) goto NG;\n\t}\n\n\tprime_factor(n);\n\tL = factor[0]-1;\n\tfor (i = 1; i < size; i++) L = lcm(L, factor[i]-1);\n\tif (L == 1) { puts(\"1\"); return 0; }\n\tif (gcd(n, L) != 1) goto NG;\n\n\tprime_factor(L);\n\tfor (a = L, i = 0; i < size; i++) a = a/factor[i]*(factor[i]-1);\n\n\tfor (k = 1; k <= a; k++) {\n\t\tif (a % k == 0 && big_mod(n, k, L) == 1) {\n\t\t\tprintf(\"%lld\\n\", k);\n\t\t\treturn 0; \n\t\t}\n\t}\nNG: puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2720: Identity Function\n// 2017.10.9 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define SIZE  25\nint size;\nint factor[SIZE];\n\nint ptbl[] = {\n         3,   5,   7,  11,  13,  17,  19,  23,  29,\n   31,  37,  41,  43,  47,  53,  59,  61,  67,  71,\n   73,  79,  83,  89,  97, 101, 103, 107, 109, 113,\n  127, 131, 137, 139, 149, 151, 157, 163, 167, 173,\n  179, 181, 191, 193, 197, 199, 211, 223, 227, 229,\n  233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n  283, 293, 307, 311, 313, 317, 331, 337, 347, 349,\n  353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\n  419, 421, 431, 433, 439, 443, 449, 457, 461, 463,\n  467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\n  547, 557, 563, 569, 571, 577, 587, 593, 599, 601,\n  607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\n  661, 673, 677, 683, 691, 701, 709, 719, 727, 733,\n  739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\n  811, 821, 823, 827, 829, 839, 853, 857, 859, 863,\n  877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\n  947, 953, 967, 971, 977, 983, 991, 997, 0 };\n\nvoid prime_factor(long long n)\n{\n  int i, d, sw;\n  int *pp;\n\n  size = 0;\n  if ((n & 1) == 0) {\n    factor[size++] = 2;\n    do n >>= 1LL;\n    while ((n & 1) == 0);\n  }\n  for (pp = ptbl; n > 1 && *pp > 0; pp++) {\n    if (n % *pp) continue;\n    d = *pp;\n    factor[size++] = d;\n    do n /= d;\n    while (n % d == 0);\n  }\n  if (n > 1) {\n    int b = (int)sqrt((double)n);\n    for (i = 1009, sw = 0; n > 1; ) {\n      if (i > b) {\n        factor[size++] = (int)n;\n        break;\n      }\n      if (n % i == 0) {\n        factor[size++] = i;\n        do n /= i;\n        while (n % i == 0);\n      }\n      if (sw) { i += 2, sw = 0; }\n      else    { i += 4, sw = 1; }\n    }\n  }\n}\n\nlong long gcd(long long a, long long b)\n{\n\tlong long r;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nlong long lcm(long long a, long long b)\n{\n\treturn a/gcd(a, b)*b;\n}\n\nint big_mod(int b, int p, int m)\n{\n   int s = 1;\n   int d;\n\n   d = b % m;\n   while (p > 0) {\n      if (p & 1) s = (s * d) % m;\n      p >>= 1;\n      d = (d * d) % m;\n   }\n   return s;\n}\n\nint main()\n{\n\tint n, i, i2, k;\n\tlong long L, a;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 2; ; i++) {\n\t\tif ((i2 = i*i) > n) break;\n\t\tif (n % i2 == 0) goto NG;\n\t}\n\n\tprime_factor(n);\n\tL = factor[0]-1;\n\tfor (i = 1; i < size; i++) L = lcm(L, factor[i]-1);\n\tif (L == 1) { puts(\"1\"); return 0; }\n\tif (gcd(n, L) != 1) goto NG;\n\n\tprime_factor(L);\n\tfor (a = L, i = 0; i < size; i++) a = a/factor[i]*(factor[i]-1);\n\n\tfor (k = 1; k <= a; k++) {\n\t\tif (a % k == 0 && big_mod(n, k, L) == 1) {\n\t\t\tprintf(\"%d\\n\", k);\n\t\t\treturn 0; \n\t\t}\n\t}\nNG: puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2720: Identity Function\n// 2017.10.9 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define INF 0x7fffffff\n#define SIZE  25\nint size;\nint factor[SIZE];\n\nint ptbl[] = {\n         3,   5,   7,  11,  13,  17,  19,  23,  29,\n   31,  37,  41,  43,  47,  53,  59,  61,  67,  71,\n   73,  79,  83,  89,  97, 101, 103, 107, 109, 113,\n  127, 131, 137, 139, 149, 151, 157, 163, 167, 173,\n  179, 181, 191, 193, 197, 199, 211, 223, 227, 229,\n  233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n  283, 293, 307, 311, 313, 317, 331, 337, 347, 349,\n  353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\n  419, 421, 431, 433, 439, 443, 449, 457, 461, 463,\n  467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\n  547, 557, 563, 569, 571, 577, 587, 593, 599, 601,\n  607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\n  661, 673, 677, 683, 691, 701, 709, 719, 727, 733,\n  739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\n  811, 821, 823, 827, 829, 839, 853, 857, 859, 863,\n  877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\n  947, 953, 967, 971, 977, 983, 991, 997, 0 };\n\nvoid prime_factor(int n)\n{\n  int i, d, sw;\n  int *pp;\n\n  size = 0;\n  if ((n & 1) == 0) {\n    factor[size++] = 2;\n    do n >>= 1LL;\n    while ((n & 1) == 0);\n  }\n  for (pp = ptbl; n > 1 && *pp > 0; pp++) {\n    if (n % *pp) continue;\n    d = *pp;\n    factor[size++] = d;\n    do n /= d;\n    while (n % d == 0);\n  }\n  if (n > 1) {\n    int b = (int)sqrt((double)n);\n    for (i = 1009, sw = 0; n > 1; ) {\n      if (i > b) {\n        factor[size++] = (int)n;\n        break;\n      }\n      if (n % i == 0) {\n        factor[size++] = i;\n        do n /= i;\n        while (n % i == 0);\n      }\n      if (sw) { i += 2, sw = 0; }\n      else    { i += 4, sw = 1; }\n    }\n  }\n}\n\nint gcd(int a, int b)\n{\n\tint r;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nint lcm(int a, int b)\n{\n\treturn a/gcd(a, b)*b;\n}\n\nint big_mod(int b, int p, int m)\n{\n   long long s = 1;\n   long long d;\n\n   d = b % m;\n   while (p > 0) {\n      if (p & 1) s = (s * d) % m;\n      p >>= 1;\n      d = (d * d) % m;\n   }\n   return (int)s;\n}\n\nint main()\n{\n\tint n, i, t, ans;\n\tint L, a, k;\n\n\tscanf(\"%d\", &n);\n\tans = -1;\n\tfor (i = 2; ; i++) {\n\t\tif ((t = i*i) > n) break;\n\t\tif (n % t == 0) goto Done;\n\t}\n\n\tprime_factor(n);\n\tL = factor[0]-1;\n\tfor (i = 1; i < size; i++) L = lcm(L, factor[i]-1);\n\tif (L == 1) { ans = 1; goto Done; }\n\tif (gcd(n, L) != 1) goto Done;\n\n\tprime_factor(L);\n\tfor (a = L, i = 0; i < size; i++) a = a/factor[i]*(factor[i]-1);\n\n\tans = INF; i = (int)sqrt(a);\n\tfor (k = 1; k <= i; k++) {\n\t\tif (a % k == 0) {\n\t\t\tif (big_mod(n, k, L) == 1) { ans = k; goto Done; }\n\t\t\tt = a/k; if (big_mod(n, t, L) == 1 && t < ans) ans = t;\n\t\t}\n\t}\n\tif (ans == INF) ans = -1;\nDone:printf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\ndef gcd(m, n):\n    while n:\n        m, n = n, m % n\n    return m\ndef lcm(m, n):\n    return m // gcd(m, n) * n\ndef carmichael(x):\n    r = 1\n\n    b = 0\n    while x & 1 == 0:\n        b += 1\n        x >>= 1\n    if b > 1:\n        r = 2 if b == 2 else 2**(b-2)\n\n    y = 3\n    while y*y <= x:\n        if x % y == 0:\n            c = 0\n            while x % y == 0:\n                x //= y\n                c += 1\n            r = lcm(r, (y-1) * y**(c-1))\n        y += 1\n    if x > 1:\n        r = lcm(r, x-1)\n    return r\n\ndef solve(x, c):\n    if c == 1:\n        return 1\n    x = x % c\n    sq = int(c ** .5) + 1\n\n    mp = {}\n    y = 1\n    for i in range(sq):\n        mp[y] = i\n        y = (y * x) % c\n        if y == 1:\n            return i+1\n        if y in mp:\n            return -1\n    z = 1\n    for i in range(sq):\n        z = (z * y) % c\n        if z in mp:\n            return sq*(i+1) - mp[z]\n    return -1\nc = carmichael(N)\nk = solve(N, c)\nif k == -1 or pow(N, k, c) != 1 % c:\n    print(-1)\nelse:\n    print(k)\n"
  }
]